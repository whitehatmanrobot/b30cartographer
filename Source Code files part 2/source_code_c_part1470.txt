PCTSTR* MapName2)
{

    return (_tcscmp(*MapName1, *MapName2) == 0);

}

/*====================================================

DestructElements of LPCTSTR

Arguments:

Return Value:

=====================================================*/

void AFXAPI DestructElements(LPCTSTR* ppNextHop, int n)
{

    int i;
    for (i=0;i<n;i++)
        delete [] (WCHAR*) *ppNextHop++;

}

/*====================================================

hash key  of LPCTSTR

Arguments:

Return Value:


=====================================================*/
UINT AFXAPI HashKey(LPCTSTR key)
{
    UINT nHash = 0;
    while (*key)
        nHash = (nHash<<5) + nHash + *key++;
    return nHash;
}

//-------------------------------------------------------
//
//  GetFalconSectionName
//
//-------------------------------------------------------
LPCWSTR
MQUTIL_EXPORT
APIENTRY
GetFalconSectionName(
    VOID
    )
{
    ASSERT(g_tRegKeyName[0] != L'\0');
    return g_tRegKeyName;
}



//
// Registry section of MSMQ is based on the service name.
// This allows multiple QMs to live on same machine, each
// with its own registry section. (ShaiK)
//

static WCHAR s_wzServiceName[256 + 3] = {QM_DEFAULT_SERVICE_NAME};

DWORD
MQUTIL_EXPORT
APIENTRY
GetFalconServiceName(
    LPWSTR pwzServiceNameBuff,
    DWORD dwServiceNameBuffLen
    )
{
    ASSERT(("must point to a valid buffer", NULL != pwzServiceNameBuff));

    DWORD dwLen = wcslen(s_wzServiceName);

    ASSERT(("out buffer too small!", dwLen < dwServiceNameBuffLen));
    if (dwLen < dwServiceNameBuffLen)
    {
        wcscpy(pwzServiceNameBuff, s_wzServiceName);
    }

    return(dwLen);

} //GetFalconServiceName


VOID
MQUTIL_EXPORT
APIENTRY
SetFalconServiceName(
    LPCWSTR pwzServiceName
    )
{
    ASSERT(("must get a valid service name", NULL != pwzServiceName));
    ASSERT(("service name too big", wcslen(pwzServiceName) < TABLE_SIZE(s_wzServiceName)));

    wcscpy(s_wzServiceName, pwzServiceName);

    //
    // Null the global registry handle so that it'd be reopened in the
    // registry section suitable for this service  (multiple QMs).
    // Note: if synchronization needed caller should provide it. (ShaiK)
    //
    if (g_hKeyFalcon)
    {
        RegCloseKey(g_hKeyFalcon) ;
    }
    g_hKeyFalcon = NULL;
    
    {
        CS lock(s_csMapName2Handle);
        s_MapName2Handle.RemoveAll();
    }


} //SetFalconServiceName


//-------------------------------------------------------
//
//  LONG OpenFalconKey(void)
//
//-------------------------------------------------------
LONG OpenFalconKey(void)
{
    LONG rc;
    WCHAR szServiceName[256] = QM_DEFAULT_SERVICE_NAME;

    wcscpy(g_tRegKeyName, FALCON_REG_KEY) ;

    GetFalconServiceName(szServiceName, sizeof(szServiceName) / sizeof(WCHAR));
    if (0 != CompareStringsNoCase(szServiceName, QM_DEFAULT_SERVICE_NAME))
    {
        //
        // Multiple QMs environment. I am a clustered QM !
        //
        wcscpy(g_tRegKeyName, FALCON_CLUSTERED_QMS_REG_KEY);
        wcscat(g_tRegKeyName, szServiceName);
        wcscat(g_tRegKeyName, FALCON_REG_KEY_PARAM);
    }

    {
        CS lock(s_critRegistry);

        rc = RegOpenKeyEx (FALCON_REG_POS,
                           g_tRegKeyName,
                           0L,
                           KEY_READ | KEY_WRITE,
                           &g_hKeyFalcon);

        if (rc != ERROR_SUCCESS)
        {
            rc = RegOpenKeyEx (FALCON_REG_POS,
                               g_tRegKeyName,
                               0L,
                               KEY_READ,
                               &g_hKeyFalcon);
        }
    }

	//
	// temporary remove the assert because if causes trap in 
	// sysocmgr launch
	// Will put it back in when we make mqutil as resource 
	// only dll
	// 
	//
    // ASSERT(rc == ERROR_SUCCESS);

    return rc;
}

/*=============================================================

  FUNCTION:  GetValueKey

  the function returns an handle to open key and the value name.
  If the use value name contains a sub key, it create/open it and returns
  an handle to the subkey; otherwise an handel to Falcon key is returned.

  PARAMETERS:
     pszValueName - Input, user value name. can contain a sub key

     pszValue - pointer to null terminated string contains the value name.

     hKey - pointer to key handle

================================================================*/

LONG GetValueKey(IN LPCTSTR pszValueName,
                 OUT LPCTSTR* lplpszValue,
                 OUT HKEY* phKey)
{
    *lplpszValue = pszValueName;
    LONG rc = ERROR_SUCCESS;

    //
    // Open Falcon key, if it hasn't opened yet.
    //
    if (g_hKeyFalcon == NULL)
    {
        rc = OpenFalconKey();
        if ( rc != ERROR_SUCCESS)
        {
            return rc;
        }
    }

    *phKey = g_hKeyFalcon;

    // look for a sub key
    LPCWSTR lpcsTemp = wcschr(pszValueName,L'\\');
    if (lpcsTemp != NULL)
    {
        // Sub key is exist
        DWORD dwDisposition;

        // update the return val
        *lplpszValue = lpcsTemp +1;

        AP<WCHAR> KeyName = new WCHAR[(lpcsTemp - pszValueName) + 1];
        wcsncpy(KeyName, pszValueName, (lpcsTemp - pszValueName));
        KeyName[(lpcsTemp - pszValueName)] = L'\0';

        // Check if the key already opened
        BOOL rc1;
        {
            CS lock(s_csMapName2Handle);
            rc1 = s_MapName2Handle.Lookup(KeyName, *phKey);
        }
        if (!rc1)
        {
            CS lock(s_critRegistry);
            rc = RegCreateKeyEx (g_hKeyFalcon,
                               KeyName,
                               0L,
                               L"",
                               REG_OPTION_NON_VOLATILE,
                               KEY_READ | KEY_WRITE,
                               NULL,
                               phKey,
                               &dwDisposition);

            if (rc != ERROR_SUCCESS)
            {
                rc = RegCreateKeyEx (g_hKeyFalcon,
                                   KeyName,
                                   0L,
                                   L"",
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_READ,
                                   NULL,
                                   phKey,
                                   &dwDisposition);
            }

            if (rc == ERROR_SUCCESS)
            {
                // save the handle in hash
                {
                    CS lock(s_csMapName2Handle);
                    s_MapName2Handle[KeyName] = *phKey;
                }
                KeyName.detach();
            }
            else
            {
                ASSERT(0);
            }
        }
    }

    return rc;

}

//-------------------------------------------------------
//
//  GetFalconKey
//
//-------------------------------------------------------

LONG
MQUTIL_EXPORT
GetFalconKey(LPCWSTR  pszKeyName,
             HKEY *phKey)
{
    AP<WCHAR> szValueKey = new WCHAR[wcslen(pszKeyName) + 2];
    LPCWSTR szValue;

    wcscat(wcscpy(szValueKey, pszKeyName), TEXT("\\"));
    return GetValueKey(szValueKey, &szValue, phKey);
}

//-------------------------------------------------------
//
//  GetFalconKeyValue
//
//-------------------------------------------------------

LONG
MQUTIL_EXPORT
APIENTRY
GetFalconKeyValue(
    LPCTSTR pszValueName,
    PDWORD  pdwType,
    PVOID   pData,
    PDWORD  pdwSize,
    LPCTSTR pszDefValue
    )
{
    //
    // NOTE: registry routines in mqutil do not provide
    // thread or other synchronization. If you change
    // implementation here, carefully verify that
    // registry routines in mqutil's clients are not
    // broken, especially the wrapper routines in
    // mqclus.dll  (ShaiK, 19-Apr-1999)
    //

    LONG rc;
    HKEY hKey;
    LPCWSTR lpcsValName;

    ASSERT(pdwSize != NULL);

    rc = GetValueKey(pszValueName, &lpcsValName, &hKey);
    if ( rc != ERROR_SUCCESS)
    {
        return rc;
    }

    DWORD dwTempType;
    DWORD *pdwTempType = &dwTempType;

    dwTempType = (pdwType == NULL) ? 0 : *pdwType;


    {
        CS lock(s_critRegistry);
        rc = RegQueryValueEx( hKey,
                          lpcsValName,
                          0L,
                          pdwTempType,
                          static_cast<BYTE*>(pData),
                          pdwSize ) ;
    }

    if ((rc != ERROR_SUCCESS) && pszDefValue)
    {
       if ((rc != ERROR_MORE_DATA) && pdwType && (*pdwType == REG_SZ))
       {
          // Don't use the default if caller buffer was too small for
          // value in registry.
          if ((DWORD) wcslen(pszDefValue) < *pdwSize)
          {
             wcscpy((WCHAR*) pData, pszDefValue) ;
             rc = ERROR_SUCCESS ;
          }
       }
       if (*pdwType == REG_DWORD)
       {
          *((DWORD *)pData) = *((DWORD *) pszDefValue) ;
          rc = ERROR_SUCCESS ;
       }
    }

    return rc;
}



//-------------------------------------------------------
//
//  SetFalconKeyValue
//
//-------------------------------------------------------

LONG
MQUTIL_EXPORT
APIENTRY
SetFalconKeyValue(
    LPCTSTR pszValueName,
    PDWORD  pdwType,
    const VOID * pData,
    PDWORD  pdwSize
    )
{
    ASSERT(pData != NULL);
    ASSERT(pdwSize != NULL);

    DWORD dwType = *pdwType;
    DWORD cbData = *pdwSize;
    HRESULT rc;

    HKEY hKey;
    LPCWSTR lpcsValName;

    rc = GetValueKey(pszValueName, &lpcsValName, &hKey);
    if ( rc != ERROR_SUCCESS)
    {
        return rc;
    }

    CS lock(s_critRegistry);
    rc =  RegSetValueEx( hKey,
                         lpcsValName,
                         0,
                         dwType,
                         reinterpret_cast<const BYTE*>(pData),
                         cbData);
    return(rc);
}

//-------------------------------------------------------
//
//  DeleteFalconKeyValue
//
//-------------------------------------------------------

LONG
MQUTIL_EXPORT
DeleteFalconKeyValue(
    LPCTSTR pszValueName )
{

    HKEY hKey;
    LPCWSTR lpcsValName;
    LONG rc;

    rc = GetValueKey(pszValueName, &lpcsValName, &hKey);
    if ( rc != ERROR_SUCCESS)
    {
        return rc;
    }

    CS lock(s_critRegistry);
    rc = RegDeleteValue( hKey,lpcsValName ) ;
    return rc ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqutil\report.cpp ===
/////////////////////////////////////////////////////////////////////
//
//               File : report.cpp
//
//   NOTE: DllMain is at the end of the module
//////////////////////////////////////////////////////////////////////


#include "stdh.h"
#include "resource.h"
#include <tchar.h>
#include <limits.h>
#include <time.h>
#include <uniansi.h>
#include <process.h>
#include <mqnames.h>
#include <_registr.h>

#include "report.tmh"

static WCHAR s_wszPID[30];

#ifdef _DEBUG

#define  DBG_READREG_THRESHOLD      50

#define  DBG_UPDATETITLE_INITCOUNT  15
#define  DBG_UPDATETITLE_THRESHOLD  115

#endif

//
// Declare an Object of the report-class.
//
// Only one object is declared per process. In no other module should there be another declaration of an
// object of this class.
//
DLL_EXPORT COutputReport Report;


//
// implementation of class COutputReport
//

///////////////////////////////////////////////////////////////
//
// Constructor - COutputReport::COutputReport
//
///////////////////////////////////////////////////////////////

COutputReport::COutputReport(void)
{
    m_bUpdatedRegistry = FALSE;

#ifdef _CHECKED
    // Send asserts to the message box
    _set_error_mode(_OUT_TO_MSGBOX);
#endif


    m_fLogFileInited = FALSE ;
    m_fRefreshLogTypes = TRUE ;
    m_fLoggingDisabled = FALSE ;
    m_fLogEverything = FALSE ;

    m_dwCurErrorHistoryIndex = 0;              // Initial history cell to use
    m_dwCurEventHistoryIndex = 0;             // Initial event history cell to use
    strcpy(m_HistorySignature, "MSMQERR");      // Signature for lookup in dump
        
}

////////////////////////////////////////////////////////////////////////////
//
// COutputReport::ReportMsg
//
// ReportMsg function writes to the Event-log of the Windows-NT system.
// The message is passed only if the the level setisfies the current
// debugging level. The paramaters are :
//
// id - identity of the message that is to be displayed in the event-log
//      (ids are listed in the string-table)
// cMemSize - number of memory bytes to be displayed in the event-log (could be 0)
// pMemDump - address of memory to be displayed
// cParams - number of strings to add to this message (could be 0)
// pParams - a list of cParams strings (could be NULL only if cParams is 0)
//

void COutputReport::ReportMsg( EVENTLOGID id,
                               DWORD      cMemSize,
                               LPVOID     pMemDump,
                               WORD       cParams,
                               LPCTSTR    *pParams,
                               WORD       wCategory )
{
    //
    //  Keep event in the log history
    //
    KeepEventHistory(id);

    WORD sevCode;
    sevCode = GetSeverityCode(id);
    if (sevCode == BAD_SEVERITY_CODE)
    {
        return;
    }

    if (!m_bUpdatedRegistry)
    {
        //
        // The source name is the service name of this QM.
        // Long service names are truncated.
        // Useful in multiple QMs environment. (ShaiK, 28-Apr-1999)
        //

        WCHAR wzServiceName[260] = {QM_DEFAULT_SERVICE_NAME};
        GetFalconServiceName(wzServiceName, TABLE_SIZE(wzServiceName));

        WCHAR buffer[256] = {L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\"};
        DWORD len = wcslen(buffer);
        wcsncat(buffer, wzServiceName, STRLEN(buffer) - len);

        UpdateRegistry(buffer);

        LPCWSTR pwzSourceName = CharNext(wcsrchr(buffer, L'\\'));
        m_hEventLog = RegisterEventSource( (LPTSTR)NULL, pwzSourceName);
        m_bUpdatedRegistry = TRUE;
    }

    if(!ReportEvent( m_hEventLog,
                     sevCode,
                     wCategory,
                     id,
                     (PSID)NULL,
                     cParams,
                     cMemSize,
                     pParams,
                     pMemDump))
    {
        DBGMSG((DBGMOD_API, DBGLVL_ERROR, L"COutputReport::ReportMsg - error while writing to the Event-Log"));
    }

    //
    // output message to the event-log (if in debug mode - output also to the debugging devices)
    //

#ifdef _DEBUG
    TCHAR buf[1024];
    if (FormatMessage( FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                       m_hInst,
                       id,
                       MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
                       buf,
                       sizeof(buf) / sizeof(TCHAR),
                       (va_list *) pParams))
    {
        DBGMSG((DBGMOD_API, DBGLVL_ERROR, _T("Event: %ls"), buf));
    }
#endif

}


//////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// COutputReport::ReportStringMsg
//
// report a message with additional strings
// convert the variable number of strings into a structure of char** which is suitable for calling
// the ReportMsg function
//

void COutputReport::ReportStringMsg(WORD wCategory,
                                    EVENTLOGID id, WORD cCount, ...)
{
    va_list Args;
    UINT i = 0;
    LPTSTR ppStrings[20];
    LPTSTR pStrVal;

    va_start(Args,cCount);
    pStrVal = va_arg(Args,LPTSTR);

    ASSERT(cCount < 20);
    for (i=0; i<cCount; i++)
    {
        ppStrings[i]=pStrVal;
        pStrVal = va_arg(Args,LPTSTR);
    }

    ReportMsg( id,
               0,
               NULL,
               cCount,
               (LPCTSTR*)&ppStrings[0],
               wCategory );
}


//+-------------------------------------------
//
//  void COutputReport::InitLogging()
//
//+-------------------------------------------

void COutputReport::InitLogging( enum enumLogComponents eLogComponent )
{
    m_dwLogTypes = 0 ;

    // 
    // emergency LOG-EVERYTHING setting through file %windir%\debug\msmq.log.all
    //
    WCHAR  wszLogAllFileName[ MAX_PATH+20 ] ;
    {
        GetWindowsDirectory( wszLogAllFileName, MAX_PATH );
        wcscat(wszLogAllFileName, L"\\debug\\msmq.log.all") ;
    }
    CAutoCloseFileHandle hLogAllFile =  CreateFile(
                                           wszLogAllFileName,
                                           GENERIC_READ,
                                           FILE_SHARE_READ,
                                           NULL,
                                           OPEN_EXISTING,
                                           FILE_ATTRIBUTE_NORMAL,
                                           NULL ) ;

    DWORD dwType = REG_DWORD ;
    DWORD dwSize = sizeof(m_dwLogTypes) ;

    LONG res = GetFalconKeyValue( LOG_LOGGING_TYPE_REGNAME,
                                 &dwType,
                                 &m_dwLogTypes,
                                 &dwSize ) ;

    if ((hLogAllFile == INVALID_HANDLE_VALUE) && 
        ((res != ERROR_SUCCESS) || (m_dwLogTypes == 0)))
    {
        //
        // User do not want logging.
        //
        m_fLoggingDisabled = TRUE ;
        return ;
    }

    //
    // Initialize logging.
    //
    if (!m_fLogFileInited)
    {
        //
        // First let see if we're called from the msmq service or from an
        // application. We don't log application, at least not now...
        //
        DWORD  dwFileNameSize = 0 ;
        WCHAR *pwszTmpName = NULL ;
        HMODULE hMq = GetModuleHandle(MQQM_DLL_NAME) ;
        if (hMq)
        {
            pwszTmpName = const_cast<LPWSTR> (x_wszLogFileName) ;
            dwFileNameSize = x_cLogFileNameLen ;
        }
        else
        {
            hMq = GetModuleHandle(MQ1REPL_DLL_NAME) ;
            if (hMq)
            {
                pwszTmpName = const_cast<LPWSTR> (x_wszReplLogFileName) ;
                dwFileNameSize = x_cReplLogFileNameLen ;
            }
            else
            {
                int pid = _getpid();
                wsprintf(s_wszPID, L"\\debug\\msmq%d.log", pid);
                pwszTmpName = s_wszPID;
                dwFileNameSize = wcslen(pwszTmpName);
            }
        }

        if (pwszTmpName)
        {
            ASSERT(dwFileNameSize != 0) ;
            DWORD cbData = sizeof(m_wszLogFileName) /
                           sizeof(m_wszLogFileName[0]) ;
            UINT uLen = GetWindowsDirectory( m_wszLogFileName, cbData )  ;
            if ((uLen+1+dwFileNameSize) < cbData)
            {
                wcscat(m_wszLogFileName, pwszTmpName) ;
                ASSERT(wcslen(m_wszLogFileName) < cbData) ;
                m_fLogFileInited = TRUE ;
            }
        }
    }

    if (!m_fLogFileInited && (hLogAllFile == INVALID_HANDLE_VALUE))
    {
        m_fLoggingDisabled = TRUE ;
        return ;
    }

    DWORD dwSubBits = 0 ;
    if ((m_dwLogTypes & MSMQ_LOG_REFRESH) != MSMQ_LOG_REFRESH)
    {
        //
        // Refresh of registry is not requested, so read all
        // subcomponents bits and mark logging as initialized.
        //
        for ( DWORD j = 0 ; j < e_cLogComponents ; j ++ )
        {
            dwSubBits = 0 ;
            dwType = REG_DWORD ;
            dwSize = sizeof(dwSubBits) ;

            res = GetFalconKeyValue(
                        x_wszLogComponentsRegName[ j ],
                       &dwType,
                       &dwSubBits,
                       &dwSize ) ;
            m_aLogComponentsBits[ j ] = dwSubBits ;
        }
        m_fRefreshLogTypes = FALSE ;
    }
    else
    {
        //
        // read the specific subcomponent bits.
        //
        dwType = REG_DWORD ;
        dwSize = sizeof(dwSubBits) ;

        res = GetFalconKeyValue(
                    x_wszLogComponentsRegName[ eLogComponent ],
                   &dwType,
                   &dwSubBits,
                   &dwSize ) ;
        m_aLogComponentsBits[ eLogComponent ] = dwSubBits ;
    }

    m_fLogEverything = !! (m_dwLogTypes & MSMQ_LOG_EVERYTHING) ;

    if (hLogAllFile != INVALID_HANDLE_VALUE)
    {
        m_fLogEverything = TRUE;
    }

}

//+---------------------------------------------
//
//  void COutputReport::RestartLogging()
//
//+---------------------------------------------

void COutputReport::RestartLogging()
{
    CS lock(m_LogCS) ;
    m_fRefreshLogTypes = TRUE ;
    m_fLoggingDisabled = FALSE ;
}

//+---------------------------------------------------------
//
//  void COutputReport::WriteMsmqLog()
//
// Write to msmq log file (usually \winnt\debug\msmq.log)
//
//+---------------------------------------------------------

void COutputReport::WriteMsmqLog( DWORD dwLevel,
                                  enum enumLogComponents eLogComponent,
                                  DWORD dwSubComponent,
                                  WCHAR * Format, ...)
{
    if (m_fLoggingDisabled)
    {
        return ;
    }

    if (eLogComponent >= e_cLogComponents)
    {
        //
        // Invalid input.
        //
        ASSERT(eLogComponent < e_cLogComponents) ;
        return ;
    }

    CS lock(m_LogCS) ;

    if (m_fRefreshLogTypes)
    {
        InitLogging( eLogComponent ) ;
    }

    if (m_fLoggingDisabled)
    {
        //
        // See if flag updated after refresh.
        //
        return ;
    }

    if (!m_fLogEverything && (dwLevel < MSMQ_LOG_ERROR))
    {
        if ((m_dwLogTypes & dwLevel) != dwLevel)
        {
            //
            // this level is not logged at present.
            //
            return ;
        }

        if ((dwSubComponent & m_aLogComponentsBits[ eLogComponent ]) == 0)
        {
            //
            // this subcomponent is not logged at present.
            //
            return ;
        }
    }

    CAutoCloseFileHandle hLogFile =  CreateFile(
                                           m_wszLogFileName,
                                           GENERIC_WRITE,
                                           FILE_SHARE_READ,
                                           NULL,
                                           OPEN_ALWAYS,
                                           FILE_ATTRIBUTE_NORMAL,
                                           NULL ) ;
    if (hLogFile == INVALID_HANDLE_VALUE)
    {
        return ;
    }

    SetFilePointer(hLogFile, 0, NULL, FILE_END);

    //
    // Next, write time and date.
    //
    time_t  lTime ;
    WCHAR wszTime[ 128 ] ;
    time( &lTime ) ;
    swprintf(wszTime, L"%s", _wctime( &lTime ) );
    wszTime[ wcslen(wszTime)-1 ] = 0 ; // remove line feed.

    //
    // set the Format string into a buffer
    //
    #define LOG_BUF_LEN 512
    WCHAR wszBuf[ LOG_BUF_LEN ] ;

    va_list Args;
    va_start(Args,Format);
    _vsntprintf(wszBuf, LOG_BUF_LEN, Format, Args);

    //
    // Next, write the event text.
    //
    DWORD dwWritten = 0 ;
    char szBuf[ LOG_BUF_LEN ] ;
    sprintf(szBuf, "0x%lx> %S: %S\r\n",
                         GetCurrentThreadId(), wszTime, wszBuf) ;

    WriteFile( hLogFile,
               szBuf,
               strlen(szBuf),
               &dwWritten,
               NULL ) ;
}

//+---------------------------------------------------------
//
//  void COutputReport::KeepErrorHistory()
//
// Keeps error data in the array for future investigations
//
//+---------------------------------------------------------

void COutputReport::KeepErrorHistory(
                           enum enumLogComponents eLogComponent,
                           LPCWSTR wszFileName, 
                           USHORT usPoint, 
                           LONG status)
{
    CS lock(m_LogCS) ;
    DWORD i = m_dwCurErrorHistoryIndex % ERROR_HISTORY_SIZE;

    time( &m_ErrorHistory[i].m_time );        // the way to decipher in tools - swprintf(wszTime, L"%s", _wctime( &lTime ) );
    
    m_ErrorHistory[i].m_status             = status;
    m_ErrorHistory[i].m_eLogComponent     = (USHORT)eLogComponent;
    m_ErrorHistory[i].m_usPoint            = usPoint;
    m_ErrorHistory[i].m_tid                = GetCurrentThreadId(); 

    wcsncpy(  m_ErrorHistory[i].m_wszFileName, 
                wszFileName, 
                sizeof(m_ErrorHistory[i].m_wszFileName)/sizeof(WCHAR));
            
    m_dwCurErrorHistoryIndex++;
}

//+---------------------------------------------------------
//
//  void COutputReport::KeepEventHistory()
//
// Keeps event IDs in the array for future investigations
//
//+---------------------------------------------------------

void COutputReport::KeepEventHistory(EVENTLOGID evid)
{
    CS lock(m_LogCS) ;

    DWORD i = m_dwCurEventHistoryIndex % EVENT_HISTORY_SIZE;
    
    time( &m_EventHistory[i].m_time );       // the way to decipher in tools - swprintf(wszTime, L"%s", _wctime( &lTime ) );

    m_EventHistory[i].m_evid = evid;
    
    m_dwCurEventHistoryIndex++;
}



//+-----------------------------------
//
//  void _cdecl  WriteToMsmqLog()
//
//+-----------------------------------

void APIENTRY  WriteToMsmqLog( DWORD dwLevel,
                               enum enumLogComponents eLogComponent,
                               DWORD dwSubComponent,
                               WCHAR *wszBuf )
{
    Report.WriteMsmqLog( dwLevel,
                         eLogComponent,
                         dwSubComponent,
                         L"%s",
                         wszBuf ) ;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// COutputReport::UpdateRegistry
//
// updates the event-log registry keys
//
//   EventMessageFile key specifies which .dll resource to use as the string-messages resource.
//   TypesSupported   key specifies what types of messages can be displayed (error,warning & informational)
//

void COutputReport::UpdateRegistry(LPCTSTR pszRegKey)
{
    ASSERT(("must get a valid registry key", pszRegKey != NULL));

    HKEY hk;
    DWORD dwData;
    TCHAR szBuf[ MAX_PATH ];

    //
    // In any case of error in writing to registry, the function returns,
    // thus making it possible for continuation of MSMQ without
    // proper-messages in event-log
    //

    if (RegCreateKey( HKEY_LOCAL_MACHINE,
                      pszRegKey,
                      &hk))
    {
        // could not create registry key
        return;
    }

    if (!GetModuleFileName(m_hInst, szBuf, sizeof(szBuf) / sizeof(TCHAR)))
    {
        // could not get current file name and path
        return;
    }

    if (RegSetValueEx( hk,
                       TEXT("EventMessageFile"),
                       0,
                       REG_EXPAND_SZ,
                       (LPBYTE) szBuf,
                       (wcslen(szBuf) + 1) * sizeof(TCHAR)))
    {
        // could not the file name key
        return;
    }

    //
    // Create entries for categories in event log.

    if (RegSetValueEx( hk,
                       TEXT("CategoryMessageFile"),
                       0,
                       REG_EXPAND_SZ,
                       (LPBYTE) szBuf,
                       (wcslen(szBuf) + 1) * sizeof(TCHAR)))
    {
        // could not the file name key
        return;
    }

    dwData =  EVENTLOG_MAX_CATEGORIES ;

    if (RegSetValueEx( hk,
                       TEXT("CategoryCount"),
                       0,
                       REG_DWORD,
                       (LPBYTE) &dwData,
                       sizeof(DWORD)))
    {
        // could not update the types key
        return;
    }

    //
    // set message types for three possible type : errror,warning,informational
    //

    dwData = EVENTLOG_ERROR_TYPE   |
             EVENTLOG_WARNING_TYPE |
             EVENTLOG_INFORMATION_TYPE ;

    if (RegSetValueEx( hk,
                       TEXT("TypesSupported"),
                       0,
                       REG_DWORD,
                       (LPBYTE) &dwData,
                       sizeof(DWORD)))
    {
        // could not update the types key
        return;
    }

    RegCloseKey(hk);
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// COutputReport::GetSevirityCode
//
// returns the event type of event-log entry that is to be written. The type is taken from the severity bits
// of the message Id.
//

WORD COutputReport::GetSeverityCode(EVENTLOGID elid)
{
    WORD  wEventType;

    //
    // looking at the severity bits (bits 31-30) and determining the type of event-log entry to display
    //

    // masking all bits except severity bits (31-30)
    elid = (elid >> 30);

    switch (elid)
    {
        case 3 : wEventType = EVENTLOG_ERROR_TYPE;
                 break;
        case 2 : wEventType = EVENTLOG_WARNING_TYPE;
                 break;
        case 1 : wEventType = EVENTLOG_INFORMATION_TYPE;
                 break;
        default: wEventType = BAD_SEVERITY_CODE;
    }

    return wEventType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqutil\mqutil.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mqutil.cpp

Abstract:

    General utility functions for the general utility dll. This dll contains
    various functions that both the DS and the QM need.

Author:

    Boaz Feldbaum (BoazF) 7-Apr-1996.

--*/

#include "stdh.h"
#include "psecutil.h"
#include <lmaccess.h>
#include <lmserver.h>
#include <LMAPIBUF.H>
#include <lmerr.h>
#include "cancel.h"
#include "mqprops.h"
#include "resource.h"
#include "version.h"
#include <mqversion.h>
#include "locale.h"
#include "uniansi.h"
#include <winbase.h>
#include "mqmacro.h"

#include "mqutil.tmh"


HINSTANCE g_hInstance;
HINSTANCE g_DtcHlib         = NULL; // handle of the loaded DTC proxy library (defined in rtmain.cpp)
IUnknown *g_pDTCIUnknown    = NULL; // pointer to the DTC IUnknown
ULONG     g_cbTmWhereabouts = 0;    // length of DTC whereabouts
BYTE     *g_pbTmWhereabouts = NULL; // DTC whereabouts

MQUTIL_EXPORT CHCryptProv g_hProvVer ;

MQUTIL_EXPORT PSID g_pWorldSid;
static WCHAR wszMachineName[MAX_COMPUTERNAME_LENGTH + 1];
LPCWSTR g_wszMachineName = wszMachineName;

extern CCancelRpc g_CancelRpc;

static BOOL s_fSecInitialized = FALSE ;

void MQUInitGlobalScurityVars()
{
    if (s_fSecInitialized)
    {
       return ;
    }
    s_fSecInitialized = TRUE ;

    BOOL bRet ;
    //
    // Get the verification context of the default cryptographic provider.
    // This is not needed for RT, which call with (fFullInit = FALSE)
    //
    bRet = CryptAcquireContextA(
                &g_hProvVer,
                NULL,
                MS_DEF_PROV_A,
                PROV_RSA_FULL,
                CRYPT_VERIFYCONTEXT);
    if (!bRet)
    {
        DBGMSG((DBGMOD_QM | DBGMOD_DS,
                DBGLVL_ERROR,
                TEXT("InitGlobalScurityVars: Failed to get the CSP ")
                TEXT("verfication context, error = 0x%x"), GetLastError()));
    }

}

STATIC void InitGlobalScurityVars()
{
    BOOL bRet;

    DWORD dwMachineNameSize = sizeof(wszMachineName)/sizeof(WCHAR);

    g_pWorldSid = NULL;

    HRESULT hr = GetComputerNameInternal(
                 const_cast<LPWSTR>(g_wszMachineName),
                 &dwMachineNameSize);
    ASSERT(SUCCEEDED(hr));
	DBG_USED(hr);

    // World SID
    SID_IDENTIFIER_AUTHORITY WorldAuth = SECURITY_WORLD_SID_AUTHORITY;
    bRet = AllocateAndInitializeSid(
                &WorldAuth,
                1,
                SECURITY_WORLD_RID,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                &g_pWorldSid);
    ASSERT(bRet);
}

void FreeGlobalSecurityVars(void)
{
    if (g_pWorldSid)
    {
        FreeSid(g_pWorldSid);
    }
}

//---------------------------------------------------------
//
//  ShutDownDebugWindow()
//
//  Description:
//
//       This routine notifies working threads to shutdown.
//       Each working thread increments the load count of this library,
//       and on exit it calls FreeLibraryAndExistThread().
//
//       This routine cannot be called from this DLL PROCESS_DETACH,
//       Because PROCESS_DETACH is called only after all the threads
//       are terminated ( which doesn't allow them to perform shutdown).
//       Therefore MQRT calls ShutDownDebugWindow(),  and this allows
//       the working threads to perform shutdown.
//
//  Return Value:
//
//      None
//
//---------------------------------------------------------

VOID APIENTRY ShutDownDebugWindow(VOID)
{
    //
    //  Signale all threads to exit
    //
	g_CancelRpc.ShutDownCancelThread();
}


/*====================================================

BOOL WINAPI DllMain (HMODULE hMod, DWORD dwReason, LPVOID lpvReserved)

 Initialization and cleanup when DLL is loaded, attached and detached.

=====================================================*/

BOOL WINAPI DllMain (HMODULE hMod, DWORD dwReason, LPVOID lpvReserved)
{
    g_hInstance = hMod;

    switch(dwReason)
    {

    case DLL_PROCESS_ATTACH :
        WPP_INIT_TRACING(L"Microsoft\\MSMQ");

        Report.SetDbgInst(hMod);
        InitGlobalScurityVars() ;

        break;

    case DLL_PROCESS_DETACH :
        //
        FreeGlobalSecurityVars();

        // Free DTC data - if it was loaded
        //
        XactFreeDTC();

        WPP_CLEANUP();
        break;

    default:
        break;
    }

    return TRUE;
}


HRESULT 
MQUTIL_EXPORT
APIENTRY
GetComputerNameInternal( 
    WCHAR * pwcsMachineName,
    DWORD * pcbSize
    )
{
    if (GetComputerName(pwcsMachineName, pcbSize))
    {
        CharLower(pwcsMachineName);
        return MQ_OK;
    }

    return MQ_ERROR;

} //GetComputerNameInternal

HRESULT 
MQUTIL_EXPORT
APIENTRY
GetComputerDnsNameInternal( 
    WCHAR * pwcsMachineDnsName,
    DWORD * pcbSize
    )
{
    if (GetComputerNameEx(ComputerNameDnsFullyQualified,
						  pwcsMachineDnsName,
						  pcbSize))
    {
        CharLower(pwcsMachineDnsName);
        return MQ_OK;
    }

    return MQ_ERROR;

} 



HRESULT GetThisServerIpPort( WCHAR * pwcsIpEp, DWORD dwSize)
{
    WCHAR wcsServerName[ MAX_COMPUTERNAME_LENGTH +1];
    DWORD dwServerSize = sizeof(wcsServerName)/sizeof(WCHAR);

    HRESULT hr = GetComputerNameInternal(wcsServerName, &dwServerSize);
	ASSERT(SUCCEEDED(hr));
	DBG_USED(hr);

    dwSize = dwSize * sizeof(WCHAR);
    DWORD  dwType = REG_SZ ;
    
    
    LONG res = GetFalconKeyValue( FALCON_DS_RPC_IP_PORT_REGNAME,
        &dwType,
        pwcsIpEp,
        &dwSize,
        FALCON_DEFAULT_DS_RPC_IP_PORT ) ;
    ASSERT(res == ERROR_SUCCESS) ;
	DBG_USED(res);

    ASSERT(dwType == REG_SZ) ;
    return(MQ_OK);
}

#define DEVICE_DRIVER_PERFIX TEXT("\\\\.\\")

HRESULT
MQUTIL_EXPORT
MQUGetAcName(
    LPWSTR szAcName)
{
    READ_REG_STRING(wzReg, MSMQ_DRIVER_REGNAME, MSMQ_DEFAULT_DRIVER);

    if (wcslen(wzReg) + sizeof(DEVICE_DRIVER_PERFIX) / sizeof(WCHAR) > MAX_DEV_NAME_LEN)
    {
        return(MQ_ERROR);
    }

    wcscpy(szAcName, DEVICE_DRIVER_PERFIX);
    wcscat(szAcName, wzReg) ;

    return(MQ_OK);
}

/*====================================================

  MSMQGetOperatingSystem

=====================================================*/
extern "C" DWORD MQUTIL_EXPORT_IN_DEF_FILE APIENTRY MSMQGetOperatingSystem()
{
    HKEY  hKey ;
    DWORD dwOS = MSMQ_OS_NONE;
    WCHAR szNTType[32];

    LONG rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                 L"System\\CurrentControlSet\\Control\\ProductOptions",
                           0L,
                           KEY_READ,
                           &hKey);
    if (rc == ERROR_SUCCESS)
    {
        DWORD dwNumBytes = sizeof(szNTType);
        rc = RegQueryValueEx(hKey, TEXT("ProductType"), NULL,
                                  NULL, (BYTE *)szNTType, &dwNumBytes);

        if (rc == ERROR_SUCCESS)
        {

            //
            // Determine whether Windows NT Server is running
            //
            if (_wcsicmp(szNTType, TEXT("SERVERNT")) != 0 &&
                _wcsicmp(szNTType, TEXT("LANMANNT")) != 0 &&
                _wcsicmp(szNTType, TEXT("LANSECNT")) != 0)
            {
                //
                // Windows NT Workstation
                //
                ASSERT (_wcsicmp(L"WinNT", szNTType) == 0);
                dwOS =  MSMQ_OS_NTW ;
            }
            else
            {
                //
                // Windows NT Server
                //
                dwOS = MSMQ_OS_NTS;
                //
                // Check if Enterprise Edition
                //
                BYTE  ch ;
                DWORD dwSize = sizeof(BYTE) ;
                DWORD dwType = REG_MULTI_SZ ;
                rc = RegQueryValueEx(hKey,
                                     L"ProductSuite",
                                     NULL,
                                     &dwType,
                                     (BYTE*)&ch,
                                     &dwSize) ;
                if (rc == ERROR_MORE_DATA)
                {
                    P<WCHAR> pBuf = new WCHAR[ dwSize + 2 ] ;
                    rc = RegQueryValueEx(hKey,
                                         L"ProductSuite",
                                         NULL,
                                         &dwType,
                                         (BYTE*) &pBuf[0],
                                         &dwSize) ;
                    if (rc == ERROR_SUCCESS)
                    {
                        //
                        // Look for the string "Enterprise".
                        // The REG_MULTI_SZ set of strings terminate with two
                        // nulls. This condition is checked in the "while".
                        //
                        WCHAR *pVal = pBuf ;
                        while(*pVal)
                        {
                            if (_wcsicmp(L"Enterprise", pVal) == 0)
                            {
                                dwOS = MSMQ_OS_NTE ;
                                break;
                            }
                            pVal = pVal + wcslen(pVal) + 1 ;
                        }
                    }
                }
            }
        }
        RegCloseKey(hKey);
    }

    return dwOS;
}

/*====================================================

  MSMQGetOperatingSystem

=====================================================*/
extern "C" LPWSTR MQUTIL_EXPORT_IN_DEF_FILE APIENTRY MSMQGetQMTypeString()
{
#ifndef UNICODE
#error "mqutil is UNICODE only"
#endif
#define M_MTYPE_CLEN        154 //BUGBUG should be same as ..\ds\h\mqiscol.h
    //
    // Determine the operating system type
    //
    OSVERSIONINFOA infoOS;
    infoOS.dwOSVersionInfoSize = sizeof(infoOS);
    GetVersionExA(&infoOS);

    DWORD dwOS = MSMQGetOperatingSystem();

    char strOS[M_MTYPE_CLEN];
    DWORD dwIDSOS;

    switch (dwOS)
    {
        case MSMQ_OS_NTE:
            dwIDSOS = IDS_NTE_LABEL;
            break;
        case MSMQ_OS_NTS:
            dwIDSOS = IDS_NTS_LABEL;
            break;
        case MSMQ_OS_NTW:
            dwIDSOS = IDS_NTW_LABEL;
            break;
        case MSMQ_OS_95:
            dwIDSOS = IDS_WIN95_LABEL;
            break;
        default:
            dwIDSOS = IDS_WINNT_LABEL;
    }

    LoadStringA(g_hInstance, dwIDSOS, strOS, sizeof(strOS));

    //
    // Determine the platform type
    //
    SYSTEM_INFO infoPlatform;
    GetSystemInfo(&infoPlatform);

    UINT uPlatformID;
    switch(infoPlatform.wProcessorArchitecture)
    {
    case PROCESSOR_ARCHITECTURE_ALPHA: uPlatformID = IDS_ALPHA_LABEL;   break;
    case PROCESSOR_ARCHITECTURE_PPC:   uPlatformID = IDS_PPC_LABEL;     break;
    default:                           uPlatformID = IDS_INTEL_LABEL;   break;
    }

    char strPlatform[M_MTYPE_CLEN];
    LoadStringA(g_hInstance, uPlatformID, strPlatform, sizeof(strPlatform));

    //
    // Form the version string
    //
    char strVersionTmp[M_MTYPE_CLEN];
    char strVersion[M_MTYPE_CLEN];
    LoadStringA(g_hInstance, IDS_VERSION_LABEL, strVersionTmp, sizeof(strVersionTmp));
    sprintf(strVersion,strVersionTmp,
                      strOS, infoOS.dwMajorVersion, infoOS.dwMinorVersion,
                      infoOS.dwBuildNumber & 0xFFFF, strPlatform,
                      MSMQ_RMJ, MSMQ_RMM, rup);


    DWORD nSize = strlen(strVersion) + 1;
    WCHAR * wcsVersion = new WCHAR[nSize];

    setlocale(LC_CTYPE, "");
    size_t rc = ConvertToWideCharString(strVersion, wcsVersion, nSize);
	ASSERT(rc != (size_t)(-1));
	DBG_USED(rc);

    ASSERT(nSize > 0);
	ASSERT(wcsVersion[nSize-1] == L'\0');
    
    return wcsVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqutil\bupdate.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    update.cpp

Abstract:

    DS Update Class Implementation

Author:

    Lior Moshaiov (LiorM)


--*/

#include "stdh.h"
#include "mqprops.h"
#include "bupdate.h"
#include "mqcast.h"

#include "bupdate.tmh"

/*====================================================

UnalignedWcslen()

Arguments:

Return Value:

=====================================================*/
size_t  MQUTIL_EXPORT UnalignedWcslen (
        const wchar_t UNALIGNED * wcs
        )
{
        const wchar_t UNALIGNED *eos = wcs;

        while( *eos++ ) ;

        return( (size_t)(eos - (const wchar_t UNALIGNED *)wcs - 1) );
}



/*====================================================

RoutineName
    CDSBaseUpdate::~CDSBaseUpdate()

Arguments:

Return Value:

Threads:RPC, Scheduler(send), Receive

=====================================================*/
CDSBaseUpdate::~CDSBaseUpdate()
{
    if ( m_fNeedRelease)
    {
        delete []m_pwcsPathName;
        if (m_aVar != NULL)
        {
            for (DWORD i=0; i<m_cp; i++)
            {
                DeleteProperty(m_aVar[i]);
            }
        }
    }
    delete m_pGuid;
    delete []m_aProp;
    delete []m_aVar;
}
/*====================================================

RoutineName
    CDSBaseUpdate::Init()

Arguments:

Return Value:

Threads:RPC
    Creates an update due to RPC from a client
    (CreateObject, DeleteObject, SetProps)
    or Scheduler wakes BuildSyncReplMsg() :
         Creates an updates because of Sync request received from network
=====================================================*/
HRESULT  CDSBaseUpdate::Init(
            IN  const GUID *    pguidMasterId,
            IN  const CSeqNum & sn,
            IN  const CSeqNum & snThisMasterIntersitePrevSeqNum,
            IN  const CSeqNum & snPurge,
            IN  BOOL            fOriginatedByThisMaster,
            IN  unsigned char   bCommand,
            IN  DWORD           dwNeedCopy,
            IN  LPWSTR          pwcsPathName,
            IN  DWORD           cp,
            IN  PROPID*         aProp,
            IN  PROPVARIANT*    aVar)
{
    DWORD len;
    HRESULT status;

    //
    // limited by one byte
    //
    if (cp > 256 || aProp == NULL || aVar == NULL)
    {
        return(MQ_ERROR);   //bugbug find a better error code
    }

    m_bCommand  = bCommand;
    m_guidMasterId = *pguidMasterId;
    m_snPrev = snThisMasterIntersitePrevSeqNum;
    m_sn = sn;
	m_snPurge = snPurge;
    m_fOriginatedByThisMaster = fOriginatedByThisMaster;
    m_pwcsPathName = 0;
    m_aProp = 0;
    m_aVar = 0;

    m_cp = (unsigned char) cp;

    m_pGuid = 0;
    m_fUseGuid = FALSE;

    AP<PROPID> aProps = new PROPID[m_cp];
    memcpy(aProps,aProp,m_cp * sizeof(DWORD));

    AP<PROPVARIANT> aVars = new PROPVARIANT[m_cp];

    if (dwNeedCopy == UPDATE_COPY)
    {
        AP<WCHAR> aPathName = 0;
        //
        // Need to keep a copy of the information within the update instance
        // the call is due to API call (RPC from client)
        //
        if (pwcsPathName != NULL)
        {
            len = (wcslen(pwcsPathName) + 1);
            aPathName = new WCHAR[len];
            memcpy(aPathName,pwcsPathName,sizeof(WCHAR) * len);
        }

        for(DWORD i=0; i<m_cp; i++)
        {
            status = CopyProperty(aVar[i],&aVars[i]);
            if (FAILED(status))
            {
                return(status);
            }
        }
        m_fNeedRelease = TRUE;
        m_pwcsPathName = aPathName.detach();
    }
    else
    {
        //
        // There is NO need to keep a copy of values out of the PROPVARIANTs,
        // just to keep pointers to the data.
        //  the call is a result of Sync request received from network (Scheduler)
        // ( the data will be available until the object is destructed)
        //
        m_pwcsPathName = pwcsPathName;
        memcpy(aVars,aVar,m_cp * sizeof(PROPVARIANT));
        if ( dwNeedCopy ==  UPDATE_NO_COPY_NO_DELETE)
        {
            m_fNeedRelease = FALSE;
        }
        else
        {
            m_fNeedRelease = TRUE;
        }
    }

    m_aProp = aProps.detach();
    m_aVar = aVars.detach();
    return(MQ_OK);
}

/*====================================================

RoutineName
    CDSBaseUpdate::Init() - Initalizes object to use a guid as the key DB operations


Arguments:

Return Value:


=====================================================*/
HRESULT  CDSBaseUpdate::Init(
            IN  const GUID *    pguidMasterId,
            IN  const CSeqNum & sn,
            IN  const CSeqNum & snThisMasterIntersitePrevSeqNum,
            IN  const CSeqNum & snPurge,
            IN  BOOL            fOriginatedByThisMaster,
            IN  unsigned char   bCommand,
            IN  DWORD           dwNeedCopy,
            IN  const GUID*     pguidIdentifier,
            IN  DWORD           cp,
            IN  PROPID*         aProp,
            IN  PROPVARIANT*    aVar)

{
    HRESULT hr = Init(pguidMasterId, sn, snThisMasterIntersitePrevSeqNum, snPurge, fOriginatedByThisMaster,
        bCommand,dwNeedCopy,(LPWSTR)NULL,cp,aProp,aVar);
    if (FAILED(hr))
    {
        return(hr);
    }

    m_fUseGuid = TRUE;

    m_pGuid = new GUID;
    //
    // When creating objects without pathname ( such as sitelink or user),
    //  both pathname and pguidId are NULL
    //
    if ( pguidIdentifier)
    {

        memcpy (m_pGuid,pguidIdentifier,sizeof(GUID));
    }
    else
    {
        if (!( (bCommand == DS_UPDATE_CREATE) &&
            ( (GetObjectType() == MQDS_USER) || (GetObjectType() == MQDS_SITELINK))))
        {
            ASSERT(0);
            return(MQ_ERROR);
        }
    }

    return MQ_OK;
}
/*====================================================

RoutineName
    CDSBaseUpdate::Init()

Arguments:
            IN  unsigned char *     pBuffer : stream of received bytes
            OUT DWORD *             pdwSize : # bytes in stream

Return Value:

Threads:Receive

(Create an update instance as a result of a received
stream of bytes)

=====================================================*/
HRESULT  CDSBaseUpdate::Init(
            IN  const unsigned char*    pBuffer,
            OUT DWORD *                 pdwSize,
            IN  BOOL                    fReplicationService )
{

    const unsigned char * ptr = pBuffer;
    DWORD size;
    HRESULT status;


    AP<WCHAR>   aPathName=0;
    P<GUID>     pGuid=0;
    m_fNeedRelease = TRUE;

    m_bCommand = *ptr++;

    m_fUseGuid = ((*ptr) == 1);
    ptr++;

    if (!m_fUseGuid)
    {
        size = sizeof(TCHAR) *
                 numeric_cast<DWORD>(UnalignedWcslen((const unsigned short *) (ptr)) + 1) ;
        aPathName =  new TCHAR[size];

        memcpy(aPathName,ptr,size);
        ptr += size;
    }
    else
    {
        pGuid = new GUID;

        memcpy (pGuid,ptr,sizeof(GUID));

        ptr += sizeof (GUID);
    };


    memcpy(&m_guidMasterId,ptr,sizeof(GUID));
    ptr+= sizeof(GUID);

    ptr+= m_snPrev.SetValue( ptr);

    ptr+= m_sn.SetValue( ptr);

    ptr+= m_snPurge.SetValue( ptr);

    //
    // The update is always built. No matter if its duplicated or out of sync
    //


    m_cp = *ptr++;
    DWORD dwCp = m_cp ;
    if (fReplicationService)
    {
        //
        // The replication service need two more properties, to include
        // the object guid (the one which come from the NT4/MQIS world) and
        // the masterID.
        // (note: We create objects in NT5 DS with our own guids, the ones
        //  which come from NT4 replication).
        // So here we allocate one more entry in the propvariant array and
        // it will be filled with the guid by the replication service code.
        // Note- this is not good C++ code. The replication service touch
        // internal data structure of this object. Better style would be
        // to have a member method like "SetGuid". However, it's more
        // efficient and avoid many changes in other pieces of code.
        //
#ifdef _DEBUG
        m_cpInc = TRUE ;
#endif
        dwCp += 2 ;
    }

    AP<PROPID> aProps = new PROPID[ dwCp ];

    memcpy(aProps,ptr,m_cp * sizeof(DWORD));
    ptr += m_cp * sizeof(DWORD);

    AP<PROPVARIANT> aVars = new PROPVARIANT[ dwCp ];

    for(DWORD i=0; i<m_cp; i++)
    {
        status = InitProperty(ptr,&size,aProps[i],aVars[i]);
        if (IS_ERROR(status))
        {
            return(status);
        }
        ptr += size;
    }

    *pdwSize = DWORD_PTR_TO_DWORD(ptr-pBuffer);

    m_pwcsPathName = aPathName.detach();
    m_aProp = aProps.detach();
    m_aVar = aVars.detach();
    m_pGuid = pGuid.detach();
    return(MQ_OK);
}

/*====================================================

RoutineName
    CDSBaseUpdate::Serialize()

Arguments:
            OUT unsigned char * pBuffer : stream of bytes to be filled
            OUT DWORD * pdwSize : stream size in bytes
            IN OUT DWORD *pdwThisSourcePrevSeqNum : in case we are the source,
                                                    update our PrevSeqNum

Return Value:

Threads:Scheduler

(create a stream of bytes out of an update instance
 in order to send it)

=====================================================*/
HRESULT CDSBaseUpdate::Serialize(
            OUT unsigned char * pBuffer,
            OUT DWORD * pdwSize,
            IN  BOOL    fInterSite)
{
    unsigned char * ptr = pBuffer;
    DWORD size;
    HRESULT status;


    *ptr++ = m_bCommand;

    *ptr++ = (unsigned char)((m_fUseGuid) ? 1 : 0);

    if (!m_fUseGuid)
    {
        size = sizeof(TCHAR) * (lstrlen(m_pwcsPathName) + 1);
        memcpy(ptr,m_pwcsPathName,size);
        ptr += size;
    }
    else
    {
        memcpy(ptr,m_pGuid,sizeof(GUID));
        ptr+=sizeof(GUID);
    };

    memcpy(ptr,&m_guidMasterId,sizeof(GUID));
    ptr+=sizeof(GUID);

    CSeqNum   snPrev;
    if (m_fOriginatedByThisMaster)
    {
        //
        // I am the originator, update created due to DS API
        //
        if ( fInterSite)
        {
            snPrev =  m_snPrev;
        }
        else
        {
            snPrev =  m_sn;
            snPrev.Decrement();
        }
    }
    else
    {
        //
        // I received it from another place, or as result of build sync reply,
        // keep previous seq num
        //
        snPrev = m_snPrev;
    }
    ptr += snPrev.Serialize( ptr);

    ptr += m_sn.Serialize( ptr);

    ptr += m_snPurge.Serialize( ptr);

    *ptr++ = m_cp;
    memcpy(ptr,m_aProp,m_cp * sizeof(DWORD));
    ptr += m_cp * sizeof(DWORD);



    for(DWORD i=0; i<m_cp; i++)
    {
        status = SerializeProperty(m_aVar[i],ptr,&size);
        if (IS_ERROR (status))
        {
            return(status);
        }
        ptr += size;
    }

    *pdwSize = DWORD_PTR_TO_DWORD(ptr-pBuffer);

    return(MQ_OK);
}

/*====================================================

RoutineName
    CDSBaseUpdate::GetSerializeSize()

Arguments:

Return Value:

Threads:Scheduler

  Calculates size in bytes of stream needed to send
  this update

=====================================================*/
HRESULT CDSBaseUpdate::GetSerializeSize(
            OUT DWORD * pdwSize)
{
    DWORD size,TotalSize;
    HRESULT status;

    TotalSize =
            sizeof(m_bCommand)+sizeof(m_guidMasterId)+sizeof(m_cp)+ 1 + // 1 is for m_fUseGuid
            +m_snPrev.GetSerializeSize()+m_sn.GetSerializeSize()+m_snPurge.GetSerializeSize()+
            m_cp * sizeof(DWORD);


    if (!m_fUseGuid)
    {
        TotalSize+=sizeof(TCHAR) * (lstrlen(m_pwcsPathName) + 1);   // m_wcsPathName
    }
    else
    {
        TotalSize+=sizeof(GUID);
    };

    for(DWORD i=0; i<m_cp; i++)
    {
        status = SerializeProperty(m_aVar[i],NULL,&size);
        if (IS_ERROR (status))
        {
            return(status);
        }
        TotalSize += size;
    }

    *pdwSize = TotalSize;

    return(MQ_OK);
}

/*====================================================

RoutineName
    CDSBaseUpdate::SerializeProperty()

Arguments:

Return Value:

Threads:Scheduler

(create a stream of bytes out of a property of
 an update instance)

=====================================================*/
HRESULT CDSBaseUpdate::SerializeProperty(
            IN  PROPVARIANT&    Var,
            OUT unsigned char * pBuffer,
            OUT DWORD *         pdwSize)

{
    DWORD i,size;
    unsigned char * ptr;

    switch (Var.vt)
    {
        case VT_UI1:

            if (pBuffer != NULL)
            {
                *pBuffer = Var.bVal;
            }
            *pdwSize = 1;
            break;

        case VT_I2:
        case VT_UI2:

            if (pBuffer != NULL)
            {
                memcpy(pBuffer,&Var.iVal,sizeof(WORD));
            }
            *pdwSize = sizeof(WORD);
            break;

        case VT_UI4:
		case VT_I4:

            if (pBuffer != NULL)
            {
                memcpy(pBuffer,&Var.lVal,sizeof(DWORD));
            }
            *pdwSize = sizeof(DWORD);
            break;

        case VT_CLSID:

            if (pBuffer != NULL)
            {
                memcpy(pBuffer,Var.puuid,sizeof(GUID));
            }
            *pdwSize = sizeof(GUID);
            break;

        case VT_LPWSTR:

            *pdwSize = (wcslen(Var.pwszVal) + 1) * sizeof(WCHAR);
            if (pBuffer != NULL)
            {
                memcpy(pBuffer,Var.pwszVal,*pdwSize);
            }
            break;

        case VT_BLOB:

            if (pBuffer != NULL)
            {
                memcpy(pBuffer,&Var.blob.cbSize,sizeof(DWORD));
                memcpy(pBuffer+sizeof(DWORD),Var.blob.pBlobData,Var.blob.cbSize);
            }
            *pdwSize = Var.blob.cbSize + sizeof(DWORD);
            break;

        case VT_UI4|VT_VECTOR:
            if (pBuffer != NULL)
            {
                memcpy(pBuffer,&Var.caul.cElems ,sizeof(DWORD));
                if (Var.caul.cElems != 0)
                {
                    memcpy(pBuffer+sizeof(DWORD),Var.caul.pElems,Var.caul.cElems * sizeof(DWORD));
                }
            }
            *pdwSize = Var.caul.cElems * sizeof(DWORD) + sizeof(DWORD);
            break;

        case VT_CLSID|VT_VECTOR:
            if (pBuffer != NULL)
            {
                memcpy(pBuffer,&Var.cauuid.cElems ,sizeof(DWORD));
                if (Var.cauuid.cElems != 0)
                {
                    memcpy(pBuffer+sizeof(DWORD),Var.cauuid.pElems,Var.cauuid.cElems * sizeof(GUID));
                }
            }
            *pdwSize = Var.cauuid.cElems * sizeof(GUID) + sizeof(DWORD);
            break;

        case VT_LPWSTR|VT_VECTOR:
            ptr = pBuffer;
            if (pBuffer != NULL)
            {
                memcpy(ptr,&Var.calpwstr.cElems,sizeof(DWORD));
            }
            ptr+=sizeof(DWORD);
            for (i= 0; i < Var.calpwstr.cElems; i++)
            {
                size = (wcslen(Var.calpwstr.pElems[i]) + 1) * sizeof(WCHAR);
                if (pBuffer != NULL)
                {
                    memcpy(ptr,Var.calpwstr.pElems[i],size);
                }
                ptr += size;
            }
            *pdwSize = DWORD_PTR_TO_DWORD(ptr-pBuffer);
            break;

        default:
            return(MQ_ERROR);   // bugbug find better error code
    }
    return(MQ_OK);
}

/*====================================================

RoutineName
    CDSBaseUpdate::InitProperty()

Arguments:

Return Value:

Threads:Receive

(Create a property of an update instance
 as a result of a received stream of bytes)
=====================================================*/
HRESULT CDSBaseUpdate::InitProperty(
            IN  const unsigned char *   pBuffer,
            OUT DWORD *                 pdwSize,
            IN  PROPID                  PropId,
            OUT PROPVARIANT&            Var)

{
    DWORD len;

    memset(&Var,0,sizeof(PROPVARIANT));

    switch (PropId)
    {
        //VT_UI1
        case PROPID_Q_SCOPE:
        case PROPID_D_SCOPE:
        case PROPID_D_OBJTYPE:
        case PROPID_CN_PROTOCOLID:
        case PROPID_E_NAMESTYLE:
        case PROPID_Q_JOURNAL:
        case PROPID_Q_AUTHENTICATE:
        case PROPID_Q_TRANSACTION:
        case PROPID_QM_FOREIGN:
        case PROPID_QM_SERVICE_ROUTING:
        case PROPID_QM_SERVICE_DSSERVER:
        case PROPID_QM_SERVICE_DEPCLIENTS:

            Var.bVal = *pBuffer;
            Var.vt = VT_UI1;
            *pdwSize = 1;
            break;

        //VT_I2
        case PROPID_Q_BASEPRIORITY:

            Var.vt = VT_I2;
            memcpy(&Var.iVal,pBuffer,sizeof(SHORT));
            *pdwSize = sizeof(SHORT);
            break;

        //VT_UI2
        case PROPID_S_INTERVAL1:
        case PROPID_S_INTERVAL2:
        case PROPID_E_S_INTERVAL1:
        case PROPID_E_S_INTERVAL2:
        case PROPID_E_VERSION:

            Var.vt = VT_UI2;
            memcpy(&Var.iVal,pBuffer,sizeof(WORD));
            *pdwSize = sizeof(WORD);
            break;

        //VT_I4
        case PROPID_Q_CREATE_TIME:
        case PROPID_Q_MODIFY_TIME:
        case PROPID_QM_CREATE_TIME:
        case PROPID_QM_MODIFY_TIME:

            Var.vt = VT_I4;
            memcpy(&Var.lVal,pBuffer,sizeof(long));
            *pdwSize = sizeof(long);
            break;

        //VT_UI4
        case PROPID_Q_QUOTA:
        case PROPID_Q_HASHKEY:
        case PROPID_Q_JOURNAL_QUOTA:
        case PROPID_Q_PRIV_LEVEL:
        case PROPID_Q_LABEL_HASHKEY:
        case PROPID_QM_SERVICE:
        case PROPID_QM_HASHKEY:
        case PROPID_QM_QUOTA:
        case PROPID_QM_JOURNAL_QUOTA:
        case PROPID_QM_OS:
        case PROPID_E_CSP_TYPE:
        case PROPID_E_ENCRYPT_ALG:
        case PROPID_E_SIGN_ALG:
        case PROPID_E_HASH_ALG:
        case PROPID_E_CIPHER_MODE:
        case PROPID_E_LONG_LIVE:
        case PROPID_L_COST:

            Var.vt = VT_UI4;
            memcpy(&Var.ulVal,pBuffer,sizeof(DWORD));
            *pdwSize = sizeof(DWORD);
            break;


        //VT_CLSID
        case PROPID_Q_INSTANCE:
        case PROPID_Q_TYPE:
        case PROPID_Q_QMID:
        case PROPID_Q_MASTERID:
        case PROPID_QM_SITE_ID:
        case PROPID_QM_MACHINE_ID:
        case PROPID_QM_MASTERID:
        case PROPID_S_SITEID:
        case PROPID_S_MASTERID:
        case PROPID_D_MASTERID:
        case PROPID_D_IDENTIFIER:
        case PROPID_CN_GUID:
        case PROPID_CN_MASTERID:
        case PROPID_E_MASTERID:
        case PROPID_E_ID:
        case PROPID_U_ID:
        case PROPID_U_DIGEST:
        case PROPID_U_MASTERID:
        case PROPID_L_MASTERID:
        case PROPID_L_ID:
        case PROPID_L_NEIGHBOR1:
        case PROPID_L_NEIGHBOR2:

            Var.vt = VT_CLSID;
            Var.puuid = new CLSID;

            memcpy(Var.puuid,pBuffer,sizeof(GUID));
            *pdwSize = sizeof(GUID);
            break;

        //VT_LPWSTR
        case PROPID_Q_LABEL:
        case PROPID_QM_PATHNAME:
        case PROPID_QM_MACHINE_TYPE:
        case PROPID_S_PATHNAME:
        case PROPID_S_PSC:
        case PROPID_Q_PATHNAME:
        case PROPID_CN_NAME:
        case PROPID_E_NAME:
        case PROPID_E_CSP_NAME:
        case PROPID_E_PECNAME:

            Var.vt = VT_LPWSTR;
            len = numeric_cast<DWORD>(UnalignedWcslen((const unsigned short *)pBuffer) + 1);
            Var.pwszVal = new WCHAR[ len];
            *pdwSize = len * sizeof(WCHAR);
            memcpy(Var.pwszVal,pBuffer,*pdwSize);
            break;

        //VT_BLOB
        case PROPID_QM_ADDRESS:
        case PROPID_Q_SECURITY:
        case PROPID_E_SECURITY:
        case PROPID_QM_SECURITY:
        case PROPID_S_SECURITY:
		case PROPID_S_PSC_SIGNPK:
        case PROPID_CN_SECURITY:
        case PROPID_QM_SIGN_PK:
        case PROPID_QM_ENCRYPT_PK:
        case PROPID_E_CRL:
        case PROPID_U_SIGN_CERT:
        case PROPID_U_SID:
        case PROPID_Q_SEQNUM:
        case PROPID_QM_SEQNUM:
        case PROPID_S_SEQNUM:
        case PROPID_D_SEQNUM:
        case PROPID_CN_SEQNUM:
        case PROPID_E_SEQNUM:
        case PROPID_U_SEQNUM:
        case PROPID_L_SEQNUM:

            Var.vt = VT_BLOB;
            memcpy(&Var.blob.cbSize,pBuffer,sizeof(DWORD));
            if (Var.blob.cbSize != 0)
            {
                Var.blob.pBlobData = new BYTE __RPC_FAR[Var.blob.cbSize];
                memcpy(Var.blob.pBlobData,pBuffer+sizeof(DWORD),Var.blob.cbSize);
            }
            else
            {
                Var.blob.pBlobData = NULL;
            }
            *pdwSize = Var.blob.cbSize + sizeof(DWORD);
            break;

        //VT_CLSID|VT_VECTOR
        case PROPID_QM_CNS:
        case PROPID_QM_OUTFRS:
        case PROPID_QM_INFRS:
        case PROPID_S_GATES:

            Var.vt = VT_CLSID | VT_VECTOR;
            memcpy(&Var.cauuid.cElems ,pBuffer,sizeof(DWORD));
            if (Var.cauuid.cElems != 0)
            {
                Var.cauuid.pElems = new GUID[Var.cauuid.cElems];
                memcpy(Var.cauuid.pElems,pBuffer+sizeof(DWORD),Var.cauuid.cElems * sizeof(GUID));
            }
            else
            {
                Var.cauuid.pElems = NULL;
            }
            *pdwSize = Var.cauuid.cElems * sizeof(GUID) + sizeof(DWORD);
            break;

        default:
            return(MQ_ERROR);   // bugbug find better error code
    }
    return(MQ_OK);

}

/*====================================================

RoutineName
    CDSBaseUpdate::CopyProperty()

Arguments:

Return Value:

Threads:RPC

=====================================================*/
HRESULT CDSBaseUpdate::CopyProperty(
            IN  PROPVARIANT&    SrcVar,
            IN  PROPVARIANT*    pDstVar)

{
    DWORD len;

    memset(pDstVar,0,sizeof(PROPVARIANT));
    pDstVar->vt = SrcVar.vt;

    switch (SrcVar.vt)
    {
        case VT_UI1:

            pDstVar->bVal = SrcVar.bVal;
            break;

        case VT_I2:
        case VT_UI2:

            pDstVar->iVal = SrcVar.iVal;
            break;

        case VT_UI4:
		case VT_I4:

            pDstVar->ulVal = SrcVar.ulVal;
            break;

        case VT_CLSID:

            pDstVar->puuid = new GUID;
            memcpy(pDstVar->puuid,SrcVar.puuid,sizeof(GUID));
            break;

        case VT_LPWSTR:

            len = (wcslen(SrcVar.pwszVal)+1);
            pDstVar->pwszVal = new WCHAR[len];
            memcpy(pDstVar->pwszVal,SrcVar.pwszVal,len*sizeof(WCHAR));
            break;

        case VT_BLOB:
            pDstVar->blob.cbSize = SrcVar.blob.cbSize;
            if (SrcVar.blob.cbSize != 0)
            {
                pDstVar->blob.pBlobData = new BYTE __RPC_FAR[SrcVar.blob.cbSize];

                memcpy(pDstVar->blob.pBlobData,SrcVar.blob.pBlobData,SrcVar.blob.cbSize);
            }
            else
            {
                pDstVar->blob.pBlobData = NULL;
            }
            break;

        case VT_UI4|VT_VECTOR:

            pDstVar->caul.cElems = SrcVar.caul.cElems;
            if (SrcVar.caul.cElems != 0)
            {
                pDstVar->caul.pElems = new DWORD[SrcVar.caul.cElems];
                memcpy(pDstVar->caul.pElems,SrcVar.caul.pElems,SrcVar.caul.cElems * sizeof(DWORD));
            }
            else
            {
                pDstVar->caul.pElems = NULL;
            }
            break;

        case VT_CLSID|VT_VECTOR:

            pDstVar->cauuid.cElems = SrcVar.cauuid.cElems;
            if (SrcVar.cauuid.cElems != 0)
            {
                pDstVar->cauuid.pElems = new GUID[SrcVar.cauuid.cElems];
                memcpy(pDstVar->cauuid.pElems,SrcVar.cauuid.pElems,SrcVar.cauuid.cElems * sizeof(GUID));
            }
            else
            {
                pDstVar->cauuid.pElems = NULL;
            }
            break;


        default:
            return(MQ_ERROR);   // bugbug find better error code
    }
    return(MQ_OK);
}

/*====================================================

RoutineName
    CDSBaseUpdate::DeleteProperty()

Arguments:

Return Value:

Threads:RPC, Scheduler(send), Receive

=====================================================*/
void    CDSBaseUpdate::DeleteProperty(
            IN  PROPVARIANT&    Var)

{
    switch (Var.vt)
    {
        DWORD i;

        case VT_CLSID:

                delete Var.puuid;
                break;

        case VT_LPWSTR:

                delete []Var.pwszVal;
                break;

        case VT_BLOB:
                delete []Var.blob.pBlobData;
                break;

        case (VT_UI4|VT_VECTOR):

                delete []Var.caul.pElems;
                break;

        case (VT_CLSID|VT_VECTOR):

                delete []Var.cauuid.pElems;
                break;

        case (VT_LPWSTR|VT_VECTOR):

            for (i= 0; i < Var.calpwstr.cElems; i++)
            {
                delete[] Var.calpwstr.pElems[i];
            }
            delete []Var.calpwstr.pElems;

            break;

        default:
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqutil\mqrpc.cpp ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:
        mqrpc.c

Abstract:
        handle RPC common functions.

Autor:
        Doron Juster  (DoronJ)     13-may-1996

--*/

#include "stdh.h"
#include "_mqrpc.h"
#include "mqmacro.h"
#include <autorel2.h>
#include <mqsec.h>

#include "mqrpc.tmh"

//---------------------------------------------------------
//
//  static RPC_STATUS  _mqrpcBind()
//
//  Description:
//
//      Create a RPC binding handle.
//
//  Return Value:
//
//---------------------------------------------------------

STATIC RPC_STATUS  _mqrpcBind( TCHAR * pszUuid,
                               TCHAR * pszNetworkAddress,
                               TCHAR * pszOptions,
                               TCHAR * pProtocol,
                               LPWSTR    lpwzRpcPort,
                               handle_t  *phBind )
{
    TCHAR * pszStringBinding = NULL;

    RPC_STATUS status = RpcStringBindingCompose( pszUuid,
                                                 pProtocol,
                                                 pszNetworkAddress,
                                                 lpwzRpcPort,
                                                 pszOptions,
                                                 &pszStringBinding);

    DBGMSG((DBGMOD_RPC, DBGLVL_INFO,
           TEXT("RpcStringBindingCompose for remote QM: 0x%x, (%ls)"),
                                             status,  pszStringBinding)) ;
    if (status != RPC_S_OK)
    {
       return status ;
    }

    status = RpcBindingFromStringBinding( pszStringBinding,
                                          phBind );
    DBGMSG((DBGMOD_RPC, DBGLVL_INFO,
             TEXT("RpcBindingFromStringBinding returned 0x%x"), status)) ;

    //
    // We don't need the string anymore.
    //
    RPC_STATUS  rc = RpcStringFree(&pszStringBinding) ;
    ASSERT(rc == RPC_S_OK);
	DBG_USED(rc);

    return status ;
}

//+--------------------------------------------
//
//   RPC_STATUS _AddAuthentication()
//
//+--------------------------------------------

STATIC RPC_STATUS  _AddAuthentication( handle_t hBind,
                                       ULONG    ulAuthnSvcIn,
                                       ULONG    ulAuthnLevel )
{
    RPC_SECURITY_QOS   SecQOS;

    SecQOS.Version = RPC_C_SECURITY_QOS_VERSION;
    SecQOS.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
    SecQOS.Capabilities = RPC_C_QOS_CAPABILITIES_DEFAULT;
    SecQOS.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;

    //
    // #3117, for NT5 Beta2
    // Jul/16/1998 RaananH, added kerberos support
    // Jul-1999, DoronJ, add negotiation for remote read.
    //
    BOOL    fNeedDelegation = TRUE ;
    ULONG   ulAuthnSvcEffective = ulAuthnSvcIn ;
    LPWSTR  pwszPrincipalName = NULL;
    RPC_STATUS  status = RPC_S_OK ;

    if (ulAuthnSvcIn != RPC_C_AUTHN_WINNT)
    {
        //
        // We want Kerberos. Let's see if we can obtain the
        // principal name of rpc server.
        //
        status = RpcMgmtInqServerPrincName(
                                      hBind,
                                      RPC_C_AUTHN_GSS_KERBEROS,
                                     &pwszPrincipalName ) ;

        if (status == RPC_S_OK)
        {
            DBGMSG((DBGMOD_RPC, DBGLVL_INFO,
              TEXT("RpcMgmtInqServerPrincName() succeeded, %ls"),
                                            pwszPrincipalName)) ;
            if (ulAuthnSvcIn == MSMQ_AUTHN_NEGOTIATE)
            {
                //
                // remote read.
                // no need for delegation.
                //
                ulAuthnSvcEffective = RPC_C_AUTHN_GSS_KERBEROS ;
                fNeedDelegation = FALSE ;
            }
            else
            {
                ASSERT(ulAuthnSvcIn == RPC_C_AUTHN_GSS_KERBEROS) ;
            }
        }
        else
        {
            DBGMSG((DBGMOD_RPC, DBGLVL_WARNING, TEXT(
              "RpcMgmtInqServerPrincName() failed, status- %lut"),
                                                    status )) ;
            if (ulAuthnSvcIn == MSMQ_AUTHN_NEGOTIATE)
            {
                //
                // server side does not support Kerberos.
                // Let's use ntlm.
                //
                ulAuthnSvcEffective = RPC_C_AUTHN_WINNT ;
                status = RPC_S_OK ;
            }
        }
    }

    if (status != RPC_S_OK)
    {
        //
        // Need Kerberos but failed with principal name.
        //
        ASSERT(ulAuthnSvcIn == RPC_C_AUTHN_GSS_KERBEROS) ;
        return status ;
    }

    if (ulAuthnSvcEffective == RPC_C_AUTHN_GSS_KERBEROS)
    {
        if (fNeedDelegation)
        {
            SecQOS.ImpersonationType = RPC_C_IMP_LEVEL_DELEGATE;
            SecQOS.Capabilities |= RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH ;
        }

        //
        // ASSERT that for Kerberos we're using the highest level.
        //
        ASSERT(ulAuthnLevel == RPC_C_AUTHN_LEVEL_PKT_INTEGRITY) ;

        status = RpcBindingSetAuthInfoEx( hBind,
                                          pwszPrincipalName,
                                          ulAuthnLevel,
                                          RPC_C_AUTHN_GSS_KERBEROS,
                                          NULL,
                                          RPC_C_AUTHZ_NONE,
                                         &SecQOS );

        RpcStringFree(&pwszPrincipalName);

        if ((status != RPC_S_OK) && (ulAuthnSvcIn == MSMQ_AUTHN_NEGOTIATE))
        {
            //
            // I do not support Kerberos. for example- local user account
            // on win2k machine in win2k domain. Or nt4 user on similar
            // machine.  Let's use ntlm.
            //
            ulAuthnSvcEffective = RPC_C_AUTHN_WINNT ;
            status = RPC_S_OK ;
        }
    }

    if (ulAuthnSvcEffective == RPC_C_AUTHN_WINNT)
    {
        status = RpcBindingSetAuthInfoEx( hBind,
                                          0,
                                          ulAuthnLevel,
                                          RPC_C_AUTHN_WINNT,
                                          NULL,
                                          RPC_C_AUTHZ_NONE,
                                          &SecQOS );
    }

    if (status == RPC_S_OK)
    {
        DBGMSG((DBGMOD_RPC, DBGLVL_INFO, TEXT(
        "RpcBindingSetAuthInfoEx(svc- %lut, lvl-%lut) succeeded"),
                        ulAuthnSvcEffective, ulAuthnLevel)) ;
    }
    else
    {
        DBGMSG((DBGMOD_RPC, DBGLVL_WARNING, TEXT(
        "RpcBindingSetAuthInfoEx(svc- %lut, lvl-%lut) failed, status- %lut"),
                  ulAuthnSvcEffective, ulAuthnLevel, status)) ;
    }

    return status ;
}

//---------------------------------------------------------
//
//  mqrpcBindQMService(...)
//
//  Description:
//
//      Create a RPC binding handle for interfacing with a remote
//      server machine.
//
//  Arguments:
//         OUT BOOL*  pProtocolNotSupported - on return, it's TRUE
//             if present protocol is not supported on LOCAL machine.
//
//         OUT BOOL*  pfWin95 - TRUE if remote machine is Win95.
//
//  Return Value:
//
//---------------------------------------------------------

HRESULT
MQUTIL_EXPORT
mqrpcBindQMService(
            IN  LPWSTR       lpwzMachineName,
            IN  DWORD        dwProtocol,
            IN  LPWSTR       lpwzRpcPort,
            IN  OUT MQRPC_AUTHENTICATION_LEVEL *peAuthnLevel,
            OUT BOOL*           pProtocolNotSupported,
            OUT handle_t*       lphBind,
            IN  DWORD           dwPortType,
            IN  GetPort_ROUTINE pfnGetPort,
            OUT BOOL*           pfWin95,
            IN  ULONG           ulAuthnSvcIn)
{
    ASSERT(pfnGetPort) ;

    HRESULT hrInit = MQ_OK ;
    TCHAR * pszUuid = NULL;
    TCHAR * pszNetworkAddress = lpwzMachineName ;
    TCHAR * pszOptions = NULL ;
    TCHAR * pProtocol ;
    BOOL    fWin95 = FALSE ;

    if (pProtocolNotSupported)
    {
       *pProtocolNotSupported = FALSE ;
    }
    *lphBind = NULL ;
    if (pfWin95)
    {
       ASSERT(pfnGetPort) ;
       *pfWin95 = FALSE ;
    }

    if (dwProtocol == IP_ADDRESS_TYPE)
    {
       pProtocol = RPC_TCPIP_NAME ;
    }
    else
    {
       ASSERT(dwProtocol == IPX_ADDRESS_TYPE) ;
       pProtocol = RPC_IPX_NAME ;
    }

    handle_t hBind ;
    RPC_STATUS status =  _mqrpcBind( pszUuid,
                                     pszNetworkAddress,
                                     pszOptions,
                                     pProtocol,
                                     lpwzRpcPort,
                                     &hBind ) ;

    if ((status == RPC_S_OK) && pfnGetPort)
    {
        //
        // Get the fix port from server side and crearte a rpc binding
        // handle for that port. If we're using fix ports only (debug
        // mode), then this call just check if other side exist.
        //

        DWORD dwPort = 0 ;

        //
        // the following is a rpc call cross network, so try/except guard
        // against net problem or unavailable server.
        //
        __try
        {
            dwPort = (*pfnGetPort) (hBind, dwPortType) ;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            //
            // Can't get server port, set authentication leve to NONE, to
            // disable next call with lower authentication level.
            //
            *peAuthnLevel = MQRPC_SEC_LEVEL_NONE;
            status =  RPC_S_SERVER_UNAVAILABLE ;
        }

        if (status == RPC_S_OK)
        {
            //
            // check machine type
            //
            fWin95 = !! (dwPort & PORTTYPE_WIN95) ;
            dwPort = dwPort & (~PORTTYPE_WIN95) ;

            if (pfWin95)
            {
                *pfWin95 = fWin95 ;
            }
        }

        if (lpwzRpcPort == NULL)
        {
            //
            // We're using dynamic endpoints.  Free the dynamic binding handle
            // and create another one for the fix server port.
            //
            mqrpcUnbindQMService( &hBind,
                NULL ) ;
            if (status == RPC_S_OK)
            {
                WCHAR wszPort[32] ;
                _itow(dwPort, wszPort, 10) ;
                status =  _mqrpcBind( pszUuid,
                                      pszNetworkAddress,
                                      pszOptions,
                                      pProtocol,
                                      wszPort,
                                      &hBind ) ;
            }
            else
            {
                ASSERT(dwPort == 0) ;
            }
        }
        else if (status != RPC_S_OK)
        {
            //
            // We're using fix endpoints but other side is not reachable.
            // Release the binding handle.
            //
            mqrpcUnbindQMService(&hBind, NULL) ;
        }
    }

    if (status == RPC_S_OK)
    {
        //
        // Set authentication into the binding handle.
        //

        if (fWin95)
        {
            //
            // Win95 support only min level. change it.
            //
            *peAuthnLevel = MQRPC_SEC_LEVEL_NONE;
        }

        ULONG ulAuthnLevel ;

        switch (*peAuthnLevel)
        {
            case MQRPC_SEC_LEVEL_NONE:
                ulAuthnLevel = RPC_C_AUTHN_LEVEL_NONE;
                break;

            case MQRPC_SEC_LEVEL_MIN:
                //
                // MIN level is for MSMQ 1.0 servers compatability.
                //
                ulAuthnLevel = RPC_C_AUTHN_LEVEL_CONNECT;
                break;

            case MQRPC_SEC_LEVEL_MAX:
                //
                // If we do not use server authentication, at least try to use the
                // integrity security level.
                //
                ulAuthnLevel = RPC_C_AUTHN_LEVEL_PKT_INTEGRITY;
                break;

            default:
                ASSERT(0) ;
                return MQ_ERROR;
        }

        if (*peAuthnLevel != MQRPC_SEC_LEVEL_NONE)
        {
            status = _AddAuthentication( hBind,
                                         ulAuthnSvcIn,
                                         ulAuthnLevel ) ;

            if (status != RPC_S_OK)
            {
                //
                // Release the binding handle.
                //
                mqrpcUnbindQMService(&hBind, NULL) ;

                hrInit = MQ_ERROR ;
            }
        }
    }

    if (status == RPC_S_OK)
    {
        *lphBind = hBind ;
    }
    else if (status == RPC_S_PROTSEQ_NOT_SUPPORTED)
    {
        if (pProtocolNotSupported)
        {
            *pProtocolNotSupported = TRUE ;
        }

        //
        // Protocol is not supported, set authentication leve to NONE, to
        // disable next call with lower authentication level.
        //
        *peAuthnLevel = MQRPC_SEC_LEVEL_NONE;
        hrInit = MQ_ERROR ;
    }
    else if (status ==  RPC_S_SERVER_UNAVAILABLE)
    {
        hrInit = MQ_ERROR_REMOTE_MACHINE_NOT_AVAILABLE ;
    }
    else
    {
        hrInit = MQ_ERROR ;
    }

    return hrInit ;
}

//---------------------------------------------------------
//
//  mqrpcUnbindQMService(...)
//
//  Description:
//
//      Free RPC resources
//
//  Return Value:
//
//---------------------------------------------------------

HRESULT
MQUTIL_EXPORT
mqrpcUnbindQMService(
            IN handle_t*    lphBind,
            IN TBYTE      **lpwBindString)
{
    RPC_STATUS rc = 0;

    if (lpwBindString)
    {
       rc = RpcStringFree(lpwBindString);
       ASSERT(rc == 0);
    }

    if (lphBind && *lphBind)
    {
       rc = RpcBindingFree(lphBind);
       ASSERT(rc == 0);
    }

    return (HRESULT) rc ;
}

//---------------------------------------------------------
//
//  mqrpcIsLocalCall( IN handle_t hBind )
//
//  Description:
//
//      On server side of RPC, check if RPC call is local
//      (i.e., using the lrpc protocol).
//      this is necessary both for licensing and for the
//      replication service. The replication service must
//      bypass several security restriction imposed by mqdssrv.
//      So mqdssrv let this bypass only if called localy.
//      Note- in MSMQ1.0, all replications were handled by the QM itself,
//      so there was no such problem. In MSMQ2.0, when running in mixed
//      mode, there is an independent service which handle MSMQ1.0
//      replication and it need "special" security handing.
//
//  Return Value: TRUE  if local call.
//                FALSE otherwise. FALSE is return even if there is a
//                      problem to determine whether the call is local
//                      or not.
//
//---------------------------------------------------------

BOOL
MQUTIL_EXPORT
mqrpcIsLocalCall( IN handle_t hBind )
{
    BOOL  fLocalCall = FALSE ;
    unsigned char *lpProtocol = NULL ;
    RPC_STATUS stat = RpcBindingToStringBindingA( hBind,
                                                  &lpProtocol ) ;
    if ((stat == RPC_S_OK) && lpProtocol)
    {
       int i = _strnicmp( RPC_LOCAL_PROTOCOLA,
                         (char *)lpProtocol,
                         strlen(RPC_LOCAL_PROTOCOLA)) ;
       if (i == 0)
       {
            fLocalCall = TRUE ;
       }

       stat = RpcStringFreeA(&lpProtocol) ;
       ASSERT(stat == RPC_S_OK) ;
    }
    else
    {
        ASSERT(!lpProtocol) ;
    }

    return fLocalCall ;
}


VOID
MQUTIL_EXPORT
APIENTRY
ComposeLocalEndPoint(
    LPCWSTR pwzEndPoint,
    LPWSTR * ppwzBuffer
    )
{
    //
    // Local RPC endpoints between MQRT and QM are based on the
    // computer name. This allows multiple QMs to live on same
    // physical machine but belong to different cluster virtual
    // servers. (ShaiK, 18-Mar-1999)
    //

    ASSERT(("must get a pointer", NULL != ppwzBuffer));

    DWORD cbSize = sizeof(WCHAR) * (wcslen(g_wszMachineName) + wcslen(pwzEndPoint) + 5);
    *ppwzBuffer = new WCHAR[cbSize];

    wcscpy(*ppwzBuffer, pwzEndPoint);
    wcscat(*ppwzBuffer, L"$");
    wcscat(*ppwzBuffer, g_wszMachineName);

} //ComposeLocalEndPoint

//
// Windows bug 608356, add mutual authentication.
// Keep account name that run the msmq service.
//
AP<WCHAR> g_pwzLocalMsmqAccount = NULL ;
const LPWSTR x_lpwszSystemAccountName = L"NT Authority\\System" ;

//+----------------------------------------
//
//  void  _GetMsmqAccountName()
//
//+----------------------------------------

static void  _GetMsmqAccountNameInternal()
{
    CServiceHandle hServiceCtrlMgr( OpenSCManager(NULL, NULL, GENERIC_READ) ) ;
    if (hServiceCtrlMgr == NULL)
    {
		TrERROR(mqrpc, "failed to open SCM, err- %!winerr!", GetLastError()) ;
        return ;
    }

    CServiceHandle hService( OpenService( hServiceCtrlMgr,
                                          L"MSMQ",
                                          SERVICE_QUERY_CONFIG ) ) ;
    if (hService == NULL)
    {
		TrERROR(mqrpc, "failed to open Service, err- %!winerr!", GetLastError()) ;

        return ;
    }

    DWORD dwConfigLen = 0 ;
    BOOL bRet = QueryServiceConfig( hService, NULL, 0, &dwConfigLen) ;

    DWORD dwErr = GetLastError() ;
    if (!bRet && (dwErr == ERROR_INSUFFICIENT_BUFFER))
    {
        P<QUERY_SERVICE_CONFIG> pQueryData =
                     (QUERY_SERVICE_CONFIG *) new BYTE[ dwConfigLen ] ;

        bRet = QueryServiceConfig( hService,
                                   pQueryData,
                                   dwConfigLen,
                                  &dwConfigLen ) ;
        if (bRet)
        {
            LPWSTR lpName = pQueryData->lpServiceStartName ;
            if ((lpName == NULL) || (_wcsicmp(lpName, L"LocalSystem") == 0))
            {
                //
                // LocalSystem account.
                // This case is handled by the caller.
                //
            }
            else
            {
                g_pwzLocalMsmqAccount = new WCHAR[ wcslen(lpName) + 1 ] ;
                wcscpy(g_pwzLocalMsmqAccount, lpName) ;
            }
        }
        else
        {
		    TrERROR(mqrpc,
             "failed to QueryService (2nd call), err- %!winerr!", GetLastError()) ;
        }
    }
    else
    {
		TrERROR(mqrpc, "failed to QueryService, err- %!winerr!", dwErr) ;
    }
}

static void  _GetMsmqAccountName()
{
    static bool s_bMsmqAccountSet = false ;
    static CCriticalSection s_csAccount ;
    CS Lock(s_csAccount) ;

    if (s_bMsmqAccountSet)
    {
        return ;
    }

    _GetMsmqAccountNameInternal() ;

    if (g_pwzLocalMsmqAccount == NULL)
    {
        //
        // msmq service is running as LocalSystem account (or mqrt failed
        // to get the account name (whatever the reason) and then it
        // default to local system).
        // Convert system sid into account name.
        //
        PSID pSystemSid = MQSec_GetLocalSystemSid() ;

        DWORD cbName = 0 ;
        DWORD cbDomain = 0 ;
        SID_NAME_USE snUse ;
        AP<WCHAR> pwszName = NULL ;
        AP<WCHAR> pwszDomain = NULL ;
        BOOL bLookup = FALSE ;

        if (pSystemSid != NULL)
        {
            bLookup = LookupAccountSid( NULL,
                                        pSystemSid,
                                        NULL,
                                       &cbName,
                                        NULL,
                                       &cbDomain,
                                       &snUse ) ;
            if (!bLookup && (cbName != 0) && (cbDomain != 0))
            {
                pwszName = new WCHAR[ cbName ] ;
                pwszDomain = new WCHAR[ cbDomain ] ;

                DWORD cbNameTmp = cbName ;
                DWORD cbDomainTmp = cbDomain ;

                bLookup = LookupAccountSid( NULL,
                                            pSystemSid,
                                            pwszName,
                                           &cbNameTmp,
                                            pwszDomain,
                                           &cbDomainTmp,
                                           &snUse ) ;
            }
        }
        else
        {
    		TrERROR(mqrpc,
               "failed to init System SID, err- %!winerr!", GetLastError()) ;
        }

        if (bLookup)
        {
            //
            // both cbName and cbDomain include the null temrination.
            //
            g_pwzLocalMsmqAccount = new WCHAR[ cbName + cbDomain ] ;
            wcsncpy(g_pwzLocalMsmqAccount, pwszDomain, (cbDomain-1)) ;
            g_pwzLocalMsmqAccount[ cbDomain - 1 ] = 0 ;
            wcsncat(g_pwzLocalMsmqAccount, L"\\", 1) ;
            wcsncat(g_pwzLocalMsmqAccount, pwszName, cbName) ;
            g_pwzLocalMsmqAccount[ cbName + cbDomain - 1 ] = 0 ;
        }
        else
        {
            //
            // Everything failed...
            // As a last default, Let's use the English name of local
            // system account. If this default is not good, then rpc call
            // itself to local server will fail because mutual authentication
            // will fail, so there is no security risk here.
            //
    		TrERROR(mqrpc,
               "failed to LookupAccountSid, err- %!winerr!", GetLastError()) ;

            g_pwzLocalMsmqAccount = new
                     WCHAR[ wcslen(x_lpwszSystemAccountName) + 1 ] ;
            wcscpy(g_pwzLocalMsmqAccount, x_lpwszSystemAccountName) ;
        }
    }

	TrTRACE(mqrpc, "msmq account name is- %ls", g_pwzLocalMsmqAccount) ;

    s_bMsmqAccountSet = true ;
}

//+----------------------------------------------------
//
// mqrpcSetLocalRpcMutualAuth( handle_t *phBind)
//
//  Windows bug 608356, add mutual authentication.
//  Add mutual authentication to local rpc handle.
//
//+----------------------------------------------------

RPC_STATUS APIENTRY
 mqrpcSetLocalRpcMutualAuth( handle_t *phBind )
{
    //
    // Windows bug 608356, add mutual authentication.
    //
    RPC_SECURITY_QOS   SecQOS;

    SecQOS.Version = RPC_C_SECURITY_QOS_VERSION;
    SecQOS.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
    SecQOS.Capabilities = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
    SecQOS.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;

    _GetMsmqAccountName() ;
    ASSERT(g_pwzLocalMsmqAccount != NULL) ;

    RPC_STATUS rc = RpcBindingSetAuthInfoEx( *phBind,
                                   g_pwzLocalMsmqAccount,
                                   RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                   RPC_C_AUTHN_WINNT,
                                   NULL,
                                   RPC_C_AUTHZ_NONE,
                                  &SecQOS ) ;

    if (rc != RPC_S_OK)
    {
        ASSERT(rc == RPC_S_OK);
		TrERROR(mqrpc, "failed to SetAuth err- %!winerr!", rc) ;
    }

    return rc ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqutil\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mqutil.rc
//
#define IDS_VERSION_LABEL               328
#define IDS_WINNT_LABEL                 329
#define IDS_WIN95_LABEL                 330
#define IDS_INTEL_LABEL                 331
#define IDS_ALPHA_LABEL                 332
#define IDS_PPC_LABEL                   333
#define IDS_NTE_LABEL                   392
#define IDS_NTS_LABEL                   393
#define IDS_NTW_LABEL                   407

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        111
#define _APS_NEXT_COMMAND_VALUE         40027
#define _APS_NEXT_CONTROL_VALUE         1038
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqutil\stdh.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    stdh.h

Abstract:

    MQUtil preprocess header file

Author:

    Erez Haba (erezh) 16-Jan-96

--*/
#ifndef __STDH_H
#define __STDH_H

#include <_stdh.h>
#include <mqutil.h>
#include <_mqdef.h>
#include <cs.h>

extern HINSTANCE g_hInstance;
extern BOOL g_fDomainController;
extern PSID g_pGuestSid;

extern LPCWSTR g_wszMachineName;

extern void XactFreeDTC(void);

#endif // __STDH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqutil\restools.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    restools.cpp

Abstract:

    Various security related functions.

Author:

    Conrad Chang (conradc) March 20, 2001.

--*/

#include "stdh.h"


/* -------------------------------------------------------

Function:     HMODULE MQGetResourceHandle()

Decription:   mqutil.dll is a resource only dll. In order to 
	      get loaded, we need a function such as this to do
              that.  This function allows any component to obtain 
              the handle to the resource only dll, i.e. mqutil.dll

Arguments: None

Return Value: HMODULE -  Handle to the resource only dll.

------------------------------------------------------- */

HMODULE MQGetResourceHandle( )
{
	return (HMODULE)g_hInstance;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqutil\secutils.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    secutils.cpp

Abstract:

    Various security related functions.

Author:

    Boaz Feldbaum (BoazF) 26-Mar-1996.

--*/

#include "stdh.h"
#include <mqsec.h>
#include <mqprops.h>
#include <mqformat.h>
#include <mqcacert.h>

#include "secutils.tmh"

/*====================================================

HashProperties

Arguments:

Return Value:


=====================================================*/
MQUTIL_EXPORT
HRESULT
HashProperties(
    HCRYPTHASH  hHash,
    DWORD       cp,
    PROPID      *aPropId,
    PROPVARIANT *aPropVar)
{
    DWORD        i;
    DWORD        dwErr ;
    PROPID      *pPropId = 0;
    PROPVARIANT *pPropVar = 0;
    BYTE        *pData = 0;
    DWORD        dwDataSize = 0;

    if (!CryptHashData(hHash, (BYTE*)&cp, sizeof(DWORD), 0))
    {
        dwErr = GetLastError() ;
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _TEXT(
          "HashProperties(), fail at CryptHashData(), err- %lut"), dwErr)) ;

        return(MQ_ERROR_CORRUPTED_SECURITY_DATA);
    }

    for (i = 0, pPropId = aPropId, pPropVar = aPropVar;
         i < cp;
         i++, pPropId++, pPropVar++)
    {
        if (aPropId)
        {
            if (!CryptHashData(hHash, (BYTE*)pPropId, sizeof(PROPID), 0))
            {
                dwErr = GetLastError() ;
                DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _TEXT(
                  "HashProperties(), fail at 2nd CryptHashData(), err- %lut"), dwErr)) ;

                return(MQ_ERROR_CORRUPTED_SECURITY_DATA);
            }
        }

        switch(pPropVar->vt)
        {
        case VT_UI1:
            pData = (BYTE*)&pPropVar->bVal;
            dwDataSize = sizeof(pPropVar->bVal);
            break;

        case VT_UI2:
        case VT_I2:
            pData = (BYTE*)&pPropVar->iVal;
            dwDataSize = sizeof(pPropVar->iVal);
            break;

        case VT_UI4:
        case VT_I4:
            pData = (BYTE*)&pPropVar->lVal;
            dwDataSize = sizeof(pPropVar->lVal);
            break;

        case VT_CLSID:
            pData = (BYTE*)pPropVar->puuid;
            dwDataSize = sizeof(GUID);
            break;

        case VT_LPWSTR:
            pData = (BYTE*)pPropVar->pwszVal;
            dwDataSize = wcslen(pPropVar->pwszVal);
            break;

        case VT_BLOB:
            pData = (BYTE*)pPropVar->blob.pBlobData;
            dwDataSize = pPropVar->blob.cbSize;
            break;

        case VT_VECTOR | VT_UI1:
            pData = (BYTE*)pPropVar->caub.pElems;
            dwDataSize = pPropVar->caub.cElems;
            break;

        case (VT_VECTOR | VT_CLSID):
            pData = (BYTE*)pPropVar->cauuid.pElems;
            dwDataSize = sizeof(GUID) * pPropVar->cauuid.cElems;
            break;

        case (VT_VECTOR | VT_VARIANT):
            pData = (BYTE*)pPropVar->capropvar.pElems;
            dwDataSize = sizeof(MQPROPVARIANT) * pPropVar->capropvar.cElems;
            break;

        default:
            ASSERT(0);
            return MQ_ERROR;
        }

        if (!CryptHashData(hHash, pData, dwDataSize, 0))
        {
            dwErr = GetLastError() ;
            DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _TEXT(
              "HashProperties(), fail at last CryptHashData(), err- %lut"), dwErr)) ;

            return(MQ_ERROR_CORRUPTED_SECURITY_DATA);
        }
    }

    return MQ_OK;
}


//
// Function -
//      GetThreadUserSid
//
// Parameters -
//      pUserSid - A pointer to a buffer that receives the address of a buffer
//          that contains the SID of the user of the current thread.
//      pdwUserSidLen - A pointer to a DWORD that receives the length of the
//          SID.
//
// Description -
//      The function allocates the buffer for the SID and fils it with the SID
//      of the user of the current thread. The calling code is responsible for
//      freeing the allocated buffer.
//

MQUTIL_EXPORT
HRESULT
GetThreadUserSid(
    LPBYTE *pUserSid,
    DWORD *pdwUserSidLen)
{
    AP<BYTE> pSD;
    HRESULT hr = MQSec_GetDefaultSecDescriptor(
                                        MQDS_USER,
                                        (PSID*)&pSD,
                                        FALSE,
                                        NULL,
                                        DACL_SECURITY_INFORMATION,
                                        e_UseDefaultDacl
                                        );
    if (FAILED(hr))
    {
        return(MQ_ERROR_INSUFFICIENT_RESOURCES);
    }

    BOOL fDefaulted;
    PSID pSid;
    BOOL bRet = GetSecurityDescriptorOwner(pSD, &pSid, &fDefaulted);
    ASSERT(bRet);

    *pdwUserSidLen = GetLengthSid(pSid);
    *pUserSid = new BYTE[*pdwUserSidLen];
    bRet = CopySid(*pdwUserSidLen, *pUserSid, pSid);
    ASSERT(bRet);

    ASSERT(*pdwUserSidLen && (*pdwUserSidLen < 0x10000));

    return(hr);
}


//
// Function -
//      QueueFormatToFormatName
//
// Parameters -
//      pQueueformat - A pointer to a QUEUE_FORMAT structure.
//      pszShortFormatName - A pointer to a statically allocated buffer. Make
//          this buffer large enough to accomodate most results.
//      ppszLongFormatName - A pointer to a buffer that will hold a pointer to a
//          dynamically allocate buffer, in case pszShortFormatName is not large
//          enough.
//      pulFormatNameLen - Points to a buffer that contains on entry the size
//          of the buffer pointed by pszShortFormatName. On exit he buffer
//          contains the length of the resulted format name.
//      ppszFormatName - A pointer to a buffer that will hold the resulted
//          format name string.
//
// Description -
//      The function converts the queue represented in pQueueformat to it's
//      string representation.
//
STATIC
HRESULT
QueueFormatToFormatName(
    const QUEUE_FORMAT *pQueueformat,
    LPWSTR pszShortFormatName,
    LPWSTR *ppszLongFormatName,
    ULONG *pulFormatNameLen,
    LPWSTR *ppszFormatName)
{
    HRESULT hr;

    //
    // Try to use the short buffer.
    //
    hr = MQpQueueFormatToFormatName(
            pQueueformat,
            pszShortFormatName,
            *pulFormatNameLen,
            pulFormatNameLen,
            false
            );
    if (FAILED(hr))
    {
        if (hr == MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL)
        {
            //
            // The short buffer is not large enough. Allocate a lrger buffer
            // and call once more to MQpQueueFormatToFormatName.
            //
            *ppszLongFormatName = new WCHAR[*pulFormatNameLen];
            hr = MQpQueueFormatToFormatName(
                    pQueueformat,
                    *ppszLongFormatName,
                    *pulFormatNameLen,
                    pulFormatNameLen,
                    false
                    );
            if (FAILED(hr))
            {
                return(hr);
            }
            *ppszFormatName = *ppszLongFormatName;
        }
        else
        {
            return(hr);
        }
    }
    else
    {
        *ppszFormatName = pszShortFormatName;
    }

    return(MQ_OK);
}

//
// A buffer that contains only zeroes. This is the default value for the
// correleation ID. The buffer is used when the passed pointer to the message
// correlation ID is NULL.
//
static const BYTE g_abDefCorrelationId[PROPID_M_CORRELATIONID_SIZE] = {0};

//
// Function -
//      HashMessageProperties
//
// Parameters -
//     hHash - A handle to a hash object.
//     pbCorrelationId - A pointer to a buffer that contains the correlation ID
//          of the mesasge. If this pointer is set to NULL, the default value
//          in g_abDefCorrelationId is used for calculating the has value.
//     dwCorrelationIdSize - The size of the correleation ID.
//     dwAppSpecific - A application specific property.
//     pbBody - A pointer to the message body.
//     dwBodySize - The size of the message body in bytes.
//     pwcLabel - A pointer to the message label (title).
//     dwLabelSize - The size of the message label in bytes.
//     pRespQueueFormat - The responce queue.
//     pAdminQueueFormat - The admin queue.
//
// Description -
//      The function calculates the hash value for the message properties.
//
MQUTIL_EXPORT
HRESULT
HashMessageProperties(
    HCRYPTHASH hHash,
    const BYTE *pbCorrelationId,
    DWORD dwCorrelationIdSize,
    DWORD dwAppSpecific,
    const BYTE *pbBody,
    DWORD dwBodySize,
    const WCHAR *pwcLabel,
    DWORD dwLabelSize,
    const QUEUE_FORMAT *pRespQueueFormat,
    const QUEUE_FORMAT *pAdminQueueFormat)
{
    HRESULT hr;
    WCHAR szShortRespFormatName[128];
    ULONG ulRespFormatNameLen = sizeof(szShortRespFormatName)/sizeof(WCHAR);
    AP<WCHAR> pszLongRespFormatName;
    LPWSTR pszRespFormatName = NULL;

    //
    // Get the string representation for the responce queue.
    //
    if (pRespQueueFormat)
    {
        hr = QueueFormatToFormatName(
                pRespQueueFormat,
                szShortRespFormatName,
                &pszLongRespFormatName,
                &ulRespFormatNameLen,
                &pszRespFormatName);
        if (FAILED(hr))
        {
            return(hr);
        }
    }

    WCHAR szShortAdminFormatName[128];
    ULONG ulAdminFormatNameLen = sizeof(szShortAdminFormatName)/sizeof(WCHAR);
    AP<WCHAR> pszLongAdminFormatName;
    LPWSTR pszAdminFormatName = NULL;

    //
    // Get the string representation for the admin queue.
    //
    if (pAdminQueueFormat)
    {
        hr = QueueFormatToFormatName(
                pAdminQueueFormat,
                szShortAdminFormatName,
                &pszLongAdminFormatName,
                &ulAdminFormatNameLen,
                &pszAdminFormatName);
        if (FAILED(hr))
        {
            return(hr);
        }
    }

    //
    // If no correlation ID was specified, use the default value for the
    // correlation ID.
    //
    if (!pbCorrelationId)
    {
        ASSERT(dwCorrelationIdSize == PROPID_M_CORRELATIONID_SIZE);
        pbCorrelationId = g_abDefCorrelationId;
    }

    //
    // Prepare data - size pairs for calculating the hash value.
    //
    struct { const BYTE *pData; DWORD dwSize; }
        DataAndSize[] =
            {{pbCorrelationId, dwCorrelationIdSize},
             {(const BYTE *)&dwAppSpecific, sizeof(DWORD)},
             {pbBody, dwBodySize},
             {(const BYTE *)pwcLabel, dwLabelSize},
             {(const BYTE *)pszRespFormatName, (DWORD)(pszRespFormatName ? ulRespFormatNameLen * sizeof(WCHAR) : 0)},
             {(const BYTE *)pszAdminFormatName, (DWORD)(pszAdminFormatName ? ulAdminFormatNameLen * sizeof(WCHAR) : 0)}};

    //
    // Accumulate the hash value for each data-size pair.
    //
    for (int i = 0; i < sizeof(DataAndSize)/sizeof(DataAndSize[0]); i++)
    {
        if (DataAndSize[i].pData && DataAndSize[i].dwSize)
        {
            if (!CryptHashData(hHash,
                               DataAndSize[i].pData,
                               DataAndSize[i].dwSize,
                               0))
            {
                return(MQ_ERROR_CORRUPTED_SECURITY_DATA);
            }
        }
    }

    return(MQ_OK);
}


#define CARegKey TEXT("CertificationAuthorities")
#define CACertRegValueName TEXT("CACert")
#define CANameRegValueName TEXT("Name")
#define CAEnabledRegValueName TEXT("Enabled")


//
// Function -
//      GetNewCaConfig
//
// Parameters -
//      hRootStore - A handle to MSMQ ROOT certificate store.
//      pCaConfig - A pointer to an array the receives the configuration.
//
// Return value -
//      If successfull MQ_OK, else error code.
//
// Remarks -
//      The function enumerate the certificates in MSMQ ROOT certificate store
//      and fills pCaConfig with the configuration data. The array suppose to
//      contain enough entries. This is because the calling code looks how many
//      certificats are in the store and allocates an array in just the right
//      size.
//
HRESULT
GetNewCaConfig(
    HCERTSTORE hRootStore,
    MQ_CA_CONFIG *pCaConfig)
{
    DWORD nCert = 0;

    //
    // Enumerate the certificates in the store.
    //
	PCCERT_CONTEXT pCert = CertEnumCertificatesInStore(hRootStore, NULL);
    while(pCert != NULL)
    {
        BYTE abShortBuffer[256];
        AP<BYTE> pbLongBuff;
        PVOID pvBuff = abShortBuffer;
        DWORD dwSize = sizeof(abShortBuffer);

        //
        // Get the friendly name of the certificate.
        //

        if (!CertGetCertificateContextProperty(
                pCert,
                CERT_FRIENDLY_NAME_PROP_ID,
                pvBuff,
                &dwSize))
        {
            if (GetLastError() != ERROR_MORE_DATA)
            {
                ASSERT(0);
                return(MQ_ERROR);
            }

            //
            // 128 bytes are not enough, allocate a large enough buffer and
            // try again.
            //
            pvBuff = pbLongBuff = new BYTE[dwSize];

            if (!CertGetCertificateContextProperty(
                    pCert,
                    CERT_FRIENDLY_NAME_PROP_ID,
                    pvBuff,
                    &dwSize))
            {
                ASSERT(0);
                return(MQ_ERROR);
            }
        }

        //
        // Allocate a buffer in the right size and copy the string to the
        // configuration data.
        //
        pCaConfig[nCert].szCaRegName = (LPWSTR) new BYTE[dwSize];
        memcpy(pCaConfig[nCert].szCaRegName, pvBuff, dwSize);
        delete[] pbLongBuff.detach(); // Free and detach.

        //
        // Get the SHA1 hash for the certificate. We'll search the certificate
        // in the certificate store according to this hash value.
        //

        pvBuff = abShortBuffer;
        dwSize = sizeof(abShortBuffer);

        if (!CertGetCertificateContextProperty(
                pCert,
                CERT_SHA1_HASH_PROP_ID,
                pvBuff,
                &dwSize))
        {
            if (GetLastError() != ERROR_MORE_DATA)
            {
                ASSERT(0);
                return(MQ_ERROR);
            }

            //
            // 128 bytes are not enough, allocate a large enough buffer and
            // try again.
            //
            pvBuff = pbLongBuff = new BYTE[dwSize];

            if (!CertGetCertificateContextProperty(
                    pCert,
                    CERT_SHA1_HASH_PROP_ID,
                    pvBuff,
                    &dwSize))
            {
                ASSERT(0);
                return(MQ_ERROR);
            }
        }

        //
        // Allocate a buffer in the right size and copy the hash value to
        // the configuration data.
        //
        pCaConfig[nCert].pbSha1Hash = new BYTE[dwSize];
        pCaConfig[nCert].dwSha1HashSize = dwSize;
        memcpy(pCaConfig[nCert].pbSha1Hash, pvBuff, dwSize);
        delete[] pbLongBuff.detach(); // Free and detach.

        //
        // Get the subject name of the certificate.
        //

        pvBuff = abShortBuffer;
        dwSize = sizeof(abShortBuffer);

        if (!CertGetCertificateContextProperty(
                pCert,
                MQ_CA_CERT_SUBJECT_PROP_ID,
                pvBuff,
                &dwSize))
        {
            if (GetLastError() != ERROR_MORE_DATA)
            {
                ASSERT(0);
                return(MQ_ERROR);
            }

            //
            // 128 bytes are not enough, allocate a large enough buffer and
            // try again.
            //
            pvBuff = pbLongBuff = new BYTE[dwSize];

            if (!CertGetCertificateContextProperty(
                    pCert,
                    MQ_CA_CERT_SUBJECT_PROP_ID,
                    pvBuff,
                    &dwSize))
            {
                ASSERT(0);
                return(MQ_ERROR);
            }
        }

        //
        // Allocate a buffer in the right size and copy the subject name to
        // the configuration data.
        //
        pCaConfig[nCert].szCaSubjectName = (LPWSTR)new BYTE[dwSize];
        memcpy(pCaConfig[nCert].szCaSubjectName, pvBuff, dwSize);
        delete[] pbLongBuff.detach(); // Free and detach.

        //
        // Get the enabled flag of the certificate.
        //
        dwSize = sizeof(BOOL);

        if (!CertGetCertificateContextProperty(
                pCert,
                MQ_CA_CERT_ENABLED_PROP_ID,
                (PVOID)&pCaConfig[nCert].fEnabled,
                &dwSize))
        {
            ASSERT(0);
            return(MQ_ERROR);
        }

        //
        // Set the deleted flag to FALSE;
        //
        pCaConfig[nCert].fDeleted = FALSE;

        nCert++;
		pCert = CertEnumCertificatesInStore(hRootStore, pCert);
    }

    return(MQ_OK);
}

//
// Function -
//      MQGetCaConfig
//
// Parameters -
//      pnCerts - A pointer to a buffer that will receive the number
//          of certificates.
//      MqCaConfig - A pointer to a buffer that receives the address
//          of the array of configuration structures. Each configuration
//          structure desribes a single CA.
//
// Description -
//      The function allocates an array of *pnCerts of MQ_CA_CONFIG
//      structures. The calling code is responsible to delete[] the
//      array.
//
MQUTIL_EXPORT
HRESULT
MQGetCaConfig(
    DWORD *pnCerts,
    MQ_CA_CONFIG **MqCaConfig)
{
    LONG lError;
    HKEY hCerts;

    //
    // Get a handle to Falcon registry. Don't close this handle
    // because it is cached in MQUTIL.DLL. If you close this handle,
    // the next time you'll need it, you'll get a closed handle.
    //
    lError = GetFalconKey(CARegKey, &hCerts);
    if (lError != ERROR_SUCCESS)
    {
        return MQ_ERROR;
    }

    CHCertStore hRootStore;

    hRootStore = CertOpenStore(CERT_STORE_PROV_REG,
                               X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                               NULL,
                               CERT_STORE_READONLY_FLAG,
                               hCerts);
    if (hRootStore)
    {
        //
        // See if there are certificates in the root cert store and how many.
        //

        PCCERT_CONTEXT pCert;

        for (pCert = CertEnumCertificatesInStore(hRootStore, NULL), *pnCerts = 0;
             pCert != NULL;
             *pnCerts += 1, pCert = CertEnumCertificatesInStore(hRootStore, pCert))
		{
			NULL;
		}

        if (*pnCerts)
        {
            //
            // IE4 is installed, get the configuration out from MSMQ ROOT
            // certificate store.
            //
            HRESULT hr;
            AP<MQ_CA_CONFIG> CaConfig = new MQ_CA_CONFIG[*pnCerts];

            hr = GetNewCaConfig(hRootStore, CaConfig);
            if (SUCCEEDED(hr))
            {
                //
                // Pass on the result to the caller.
                //
                *MqCaConfig = CaConfig.detach();
            }

            return(hr);
        }
    }

    //
    // There are no certificates in the root cert store. Most probably
    // we run on a machnie that run IE3.
    //

    //
    // Get the number of CAs.
    //
    lError = RegQueryInfoKeyA(hCerts,
                              NULL,
                              NULL,
                              NULL,
                              pnCerts,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL);
    if (lError != ERROR_SUCCESS)
    {
        return MQ_ERROR;
    }

    //
    // Fill in data in each MQ_CA_CONFIG structure for each CA.
    //
    WCHAR szCARegName[MAX_PATH + 1];
    WCHAR szCASubjectName[512];
    DWORD dwCASubjectNameLen;
    DWORD dwType;
    DWORD dwEnabled;
    DWORD dwSize = sizeof(DWORD);
    AP<MQ_CA_CONFIG> CaConfig = new MQ_CA_CONFIG[*pnCerts];

    for (DWORD iCert = 0, dwCaREgNameSize = TABLE_SIZE(szCARegName);
         (lError = RegEnumKeyEx(hCerts,
                                iCert,
                                szCARegName,
                                &dwCaREgNameSize,
                                NULL,
                                NULL,
                                NULL,
                                NULL)) == ERROR_SUCCESS;
         iCert++, dwCaREgNameSize = TABLE_SIZE(szCARegName))
    {
        //
        // Allocate a buffer for the CA registry entry name and copy the name.
        //
        CaConfig[iCert].szCaRegName = new WCHAR[wcslen(szCARegName) + 1];
        wcscpy(CaConfig[iCert].szCaRegName, szCARegName);

        //
        // Open the registry of the CA.
        //
        CAutoCloseRegHandle hCa;

        lError = RegOpenKeyEx(hCerts,
                              szCARegName,
                              0,
                              KEY_QUERY_VALUE,
                              &hCa);
        if (lError != ERROR_SUCCESS)
        {
            return MQ_ERROR;
        }

        //
        // Get the CA name into a fixed length buffer.
        //
        dwCASubjectNameLen = sizeof(szCASubjectName);

        lError = RegQueryValueEx(hCa,
                                 CANameRegValueName,
                                 0,
                                 &dwType,
                                 (PBYTE)szCASubjectName,
                                 &dwCASubjectNameLen);
        if (lError != ERROR_SUCCESS)
        {
            return MQ_ERROR;
        }

        //
        // Allocate a buffe rfor the CA name and copy the name into the buffer.
        //
        CaConfig[iCert].szCaSubjectName = new WCHAR[dwCASubjectNameLen];
        wcscpy(CaConfig[iCert].szCaSubjectName, szCASubjectName);

        lError = RegQueryValueEx(hCa,
                                 CAEnabledRegValueName,
                                 0,
                                 &dwType,
                                 (PBYTE)&dwEnabled,
                                 &dwSize);
        if (lError != ERROR_SUCCESS)
        {
            return MQ_ERROR;
        }

        //
        // Set the enabled flag of the CA.
        //
        CaConfig[iCert].fEnabled = (dwEnabled != 0);

        //
        // Set the deleted flag to FALSE;
        //
        CaConfig[iCert].fDeleted = FALSE;
    }

    //
    // Make sure that we scanned all the CAs.
    //
    if ((lError != ERROR_NO_MORE_ITEMS) || (iCert != *pnCerts))
    {
        return MQ_ERROR;
    }

    //
    // Pass the result.
    //
    *MqCaConfig = CaConfig.detach();
    return MQ_OK;
}

//
// Function -
//      SetNewCaConfig
//
// Parameters -
//      nCerts - The number of entries in pMqCaConfig.
//      pMqCaConfig - The configuration data.
//      hRegStore - A handle to ...\MSMQ\Parameters\CertificationAuthorities
//          registry.
//
// Return value -
//      If successfull MQ_OK, else error code.
//
// Remarks -
//      The function updates the MSMQ ROOT certificate store according to the
//      configuration data that is in pMqCaConfig.
//
HRESULT
SetNewCaConfig(
    DWORD nCerts,
    MQ_CA_CONFIG *pMqCaConfig,
    HKEY hRegStore)
{
    //
    // Get a handle to the MSMQ ROOT certificate store.
    //
    CHCertStore hRootStore;

    hRootStore = CertOpenStore(CERT_STORE_PROV_REG,
                               X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                               NULL,
                               0,
                               hRegStore);
    if (!hRootStore)
    {
        return(MQ_ERROR);
    }

    //
    // Go over all the entries in pMqCaConfig and update the store.
    //

    DWORD i;

    for (i = 0; i < nCerts; i++)
    {
        //
        // Find the certificate in MSMQ store.
        //
        CPCCertContext pCert;
        CRYPT_HASH_BLOB HashBlob = {pMqCaConfig[i].dwSha1HashSize, pMqCaConfig[i].pbSha1Hash};

        pCert = CertFindCertificateInStore(
                    hRootStore,
                    X509_ASN_ENCODING,
                    0,
                    CERT_FIND_SHA1_HASH,
                    &HashBlob,
                    NULL);
        ASSERT(pCert);
        if (!pCert)
        {
            return(MQ_ERROR);
        }

        if (pMqCaConfig[i].fDeleted)
        {
            //
            // delete the certificate from the store.
            //
            if (!CertDeleteCertificateFromStore(pCert))
            {
                ASSERT(0);
                return(MQ_ERROR);
            }
            else
            {
                //
                // If CertDeleteCertiticateFromStore succeeded,
                // we don't need to call CertFreeCertificateContext( ) anymore when exit
                // therefore, we need to set it to NULL here.
                //
                pCert = NULL;
            }
        }
        else
        {
            //
            // Set the enabled flag in the temporary in-memory certificate store.
            //
            CRYPT_DATA_BLOB DataBlob = {sizeof(BOOL), (PBYTE)&pMqCaConfig[i].fEnabled};

            if (!CertSetCertificateContextProperty(
                    pCert,
                    MQ_CA_CERT_ENABLED_PROP_ID,
                    0,
                    &DataBlob))
            {
                ASSERT(0);
                return(MQ_ERROR);
            }
        }
    }

    return(MQ_OK);
}

//
// Function -
//      MQSetCaConfig
//
// Parameters -
//      nCerts - The number of MQ_CA_CONFIG entries in MqCaConfig.
//      MqCaConfig - A pointer to a MQ_CA_CONFIG array.
//
// Description -
//      Store the information specified in MqCaConfig into Falcon CA
//      registry.
//
MQUTIL_EXPORT
HRESULT
MQSetCaConfig(
    DWORD nCerts,
    MQ_CA_CONFIG *MqCaConfig)
{
    LONG lError;
    HKEY hCerts;

    //
    // Get a handle to Falcon registry. Don't close this handle
    // because it is cached in MQUTIL.DLL. If you close this handle,
    // the next time you'll need it, you'll get a closed handle.
    //
    lError = GetFalconKey(CARegKey, &hCerts);
    if (lError != ERROR_SUCCESS)
    {
        return MQ_ERROR;
    }

    if (MqCaConfig[0].pbSha1Hash)
    {
        //
        // IE4 is installed, do it in the new way.
        //
        return SetNewCaConfig(nCerts, MqCaConfig, hCerts);
    }

    //
    // Update the registry.
    //
    for (DWORD iCert = 0;
         iCert < nCerts;
         iCert++)
    {
        CAutoCloseRegHandle hCa;

        lError = RegOpenKeyEx(hCerts,
                              MqCaConfig[iCert].szCaRegName,
                              0,
                              KEY_SET_VALUE,
                              &hCa);
        if (lError != ERROR_SUCCESS)
        {
            return MQ_ERROR;
        }

        lError = RegSetValueEx(hCa,
                               CAEnabledRegValueName,
                               0,
                               REG_DWORD,
                               (PBYTE)&MqCaConfig[iCert].fEnabled,
                               sizeof(DWORD));
        if (lError != ERROR_SUCCESS)
        {
            return MQ_ERROR;
        }
    }

    return MQ_OK;
}


MQUTIL_EXPORT
void
MQFreeCaConfig(
    IN  MQ_CA_CONFIG* pvCaConfig
    )
{
	delete[] pvCaConfig;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqutil\res\migtools\mqmigres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by migrat.rc
//
#define IDS_CANT_LOAD_ODBCCP            12001
#define IDS_CANT_GETADRS_ODBCCP         12002
#define IDS_FAIL_CREATE_DSN             12003
#define IDS_CAPTION                     12013
#define IDS_INVALID_MACHINE_NAME        12014

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        12015
#define _APS_NEXT_COMMAND_VALUE         12015
#define _APS_NEXT_CONTROL_VALUE         12015
#define _APS_NEXT_SYMED_VALUE           12015
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqutil\restrict.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
	Restrict.c

Abstract:
	C++ wrappers for restrictions.

--*/

#include "stdh.h"
#include "_rstrct.h"

#include "restrict.tmh"

//--------------------------------------------------------------------------
//
// Methods for CColumns
//
//--------------------------------------------------------------------------
CColumns::CColumns( unsigned size )
        : m_size( size ),
          m_cCol( 0 ),
          m_aCol( 0 )
{
    if ( m_size > 0 )
    {
        m_aCol = new PROPID[m_size];
        //memset( m_aCol, 1, m_size * sizeof( PROPID ) );
    }
}

CColumns::CColumns( CColumns const & src )
        : m_size( src.m_cCol ),
          m_cCol( 0 )
{
    if ( m_size > 0 )
    {
        m_aCol = new PROPID[m_size];

        //memset( m_aCol, 1, m_size * sizeof( PROPID ) );

        while( m_cCol < src.m_cCol )
        {
            Add( src.Get( m_cCol ) );
        }
    }
}


CColumns::~CColumns()
{
    delete[] m_aCol ;
}

void CColumns::Add( PROPID const & Property)
{
    if( m_cCol == m_size )
    {
        unsigned cNew = (m_size > 0) ? (m_size * 2) : 1;
        PROPID* aNew = new PROPID[cNew];

        memcpy( aNew, m_aCol, m_cCol * sizeof( PROPID ) );
        //memset( aNew + m_cCol, 1, (cNew - m_cCol) * sizeof( PROPID ) );

        delete  m_aCol;

        m_aCol = aNew;
        m_size = cNew;
    }

    m_aCol[m_cCol] = Property;
    ++m_cCol;
}

void CColumns::Remove( unsigned pos )
{
    if ( pos < m_cCol )
    {
        m_cCol--;
        RtlMoveMemory( m_aCol + pos,
                 m_aCol + pos + 1,
                 (m_cCol - pos) * sizeof( PROPID ) );
    }
}
//--------------------------------------------------------------------------
//
// Methods for CSort
//
//--------------------------------------------------------------------------
CSort::CSort( unsigned size )
        : m_size( size ),
          m_csk( 0 ),
          m_ask( 0 )
{
    if ( m_size > 0 )
    {
        m_ask = new CSortKey[m_size];
    }
}

CSort::CSort( CSort const & src )
       : m_size( src.m_csk ),
         m_csk( 0 ),
         m_ask( 0 )
{

    if ( m_size > 0 )
    {
        m_ask = new CSortKey [ m_size];
        while( m_csk < src.m_csk )
        {
            Add( src.Get( m_csk ) );
        }
    }
}


CSort::~CSort()
{
    delete []( m_ask );
}


void CSort::Add( CSortKey const & sk )
{
    if( m_csk == m_size )
    {
        unsigned cNew = (m_size > 0) ? (m_size * 2) : 1;
        CSortKey * aNew = new CSortKey[ cNew ];
		for (unsigned i = 0; i < m_csk; i++)
		{
			aNew[i] = m_ask[i];
		}

        delete []( m_ask );

        m_ask = aNew;
        m_size = cNew;

    }

    m_ask[m_csk] = sk;
    ++m_csk;
}


void CSort::Add( PROPID const & property, ULONG dwOrder)
{
    CSortKey sk( property, dwOrder );
    Add(sk);
}

void CSort::Remove( unsigned pos )
{
    if ( pos < m_csk )
    {
        m_csk--;
		for ( unsigned i = pos; i < m_csk - pos; i++)
		{
			m_ask[i] = m_ask[i+1];
		}
    }
}
//--------------------------------------------------------------------------
//
// Methods for CRestriction
//
//--------------------------------------------------------------------------

CRestriction::CRestriction( unsigned cInitAllocated )
		  :m_cNode( 0 ),
          m_paNode( 0 ),
          m_cNodeAllocated( cInitAllocated )
{
    if ( m_cNodeAllocated > 0 )
    {
        m_paNode = new CPropertyRestriction [ m_cNodeAllocated];
    }
}


CRestriction::CRestriction( const CRestriction& Rst )
	 :m_cNode( Rst.Count() ),
      m_cNodeAllocated( Rst.Count() ),
      m_paNode( 0 )
{
    if ( m_cNodeAllocated > 0 )
    {
        m_paNode = new CPropertyRestriction [ m_cNodeAllocated ];

        for (unsigned i=0; i<m_cNode; i++ )
        {
            m_paNode[i] = Rst.GetChild( i );
        }
    }
}

CRestriction & CRestriction::operator=( CRestriction const & Rst )
{
	delete [] m_paNode;
	m_paNode = 0;

	m_cNodeAllocated = m_cNode = Rst.Count();

	if ( m_cNodeAllocated > 0 )
    {
        m_paNode = new CPropertyRestriction [ m_cNodeAllocated ];

        for ( unsigned i=0; i<m_cNode; i++ )
        {
            m_paNode[i] = Rst.GetChild( i );
        }
    }
	
	return (*this);
}




CRestriction::~CRestriction()
{
	delete [] m_paNode;
}


void CRestriction::AddChild(CPropertyRestriction const & presChild)
{
    if ( m_cNode == m_cNodeAllocated )
    {
        Grow();
    }

    m_paNode[m_cNode] = presChild;
    m_cNode++;
}

/*
CPropertyRestriction const & CRestriction::RemoveChild( unsigned pos )
{
    //
    //  BUGBUG: bad bad code; will return ref to a removed child
    //

    if ( pos < m_cNode )
    {
        CPropertyRestriction  const & prstRemoved = m_paNode[pos];

        for ( pos++; pos < m_cNode; pos++ )
        {
            m_paNode[pos-1] = m_paNode[pos];
        }

        m_cNode--;

        return( prstRemoved );
    }
    else
    {
        return( *(CPropertyRestriction *)0 );
    }
}
*/

void CRestriction::Grow()
{
    int count = (m_cNodeAllocated != 0) ? m_cNodeAllocated * 2 : 2;

    CPropertyRestriction* paNew = new CPropertyRestriction [ count ];

	for ( unsigned i = 0 ; i < m_cNode; i++ )
    {
        paNew[i ] = m_paNode[i];
    }

    delete []( m_paNode );

    m_paNode = paNew;
    m_cNodeAllocated = count;
}

void CRestriction::AddRestriction( ULONG ulValue, PROPID property, ULONG relop, unsigned pos)
{
	CPropertyRestriction PropertyRestriction;

	PropertyRestriction.SetRelation( relop);
	PropertyRestriction.SetProperty( property);
	PropertyRestriction.SetValue( ulValue);
    
	AddChild(PropertyRestriction);
}

void CRestriction::AddRestriction( LONG lValue, PROPID property, ULONG relop, unsigned pos)
{
	CPropertyRestriction PropertyRestriction;

	PropertyRestriction.SetRelation( relop);
	PropertyRestriction.SetProperty( property);
	PropertyRestriction.SetValue( lValue);
    
	AddChild(PropertyRestriction);
}

void CRestriction::AddRestriction( SHORT sValue, PROPID property, ULONG relop, unsigned pos)
{
	CPropertyRestriction PropertyRestriction;

	PropertyRestriction.SetRelation( relop);
	PropertyRestriction.SetProperty( property);
	PropertyRestriction.SetValue( sValue);
    
	AddChild(PropertyRestriction);
}

void CRestriction::AddRestriction( UCHAR ucValue, PROPID property, ULONG relop, unsigned pos)
{
	CPropertyRestriction PropertyRestriction;

	PropertyRestriction.SetRelation( relop);
	PropertyRestriction.SetProperty( property);
	PropertyRestriction.SetValue( ucValue);
    
	AddChild(PropertyRestriction);
}

void CRestriction::AddRestriction(const CMQVariant & prval, PROPID property, ULONG relop, unsigned pos)
{
	CPropertyRestriction PropertyRestriction;

	PropertyRestriction.SetRelation( relop);
	PropertyRestriction.SetProperty( property);
	PropertyRestriction.SetValue( prval);
    
	AddChild(PropertyRestriction);
}

void CRestriction::AddRestriction( CACLSID * caclsValus, PROPID property, ULONG relop, unsigned pos)
{
	CPropertyRestriction PropertyRestriction;

	PropertyRestriction.SetRelation( relop);
	PropertyRestriction.SetProperty( property);
	PropertyRestriction.SetValue( caclsValus);
    
	AddChild(PropertyRestriction);
}

void CRestriction::AddRestriction( LPTSTR pwszVal, PROPID property, ULONG relop, unsigned pos)
{
	CPropertyRestriction PropertyRestriction;

	PropertyRestriction.SetRelation( relop);
	PropertyRestriction.SetProperty( property);
	PropertyRestriction.SetValue( pwszVal);
    
	AddChild(PropertyRestriction);
}

void CRestriction::AddRestriction( CALPWSTR * calpwstr, PROPID property, ULONG relop, unsigned pos)
{
	CPropertyRestriction PropertyRestriction;

	PropertyRestriction.SetRelation( relop);
	PropertyRestriction.SetProperty( property);
	PropertyRestriction.SetValue( calpwstr);
    
	AddChild(PropertyRestriction);
}

void CRestriction::AddRestriction( GUID * pguidValue, PROPID property, ULONG relop, unsigned pos)
{
	CPropertyRestriction PropertyRestriction;

	PropertyRestriction.SetRelation( relop);
	PropertyRestriction.SetProperty( property);
	PropertyRestriction.SetValue( pguidValue);
    
	AddChild(PropertyRestriction);
}

void CRestriction::AddRestriction( BLOB & blobValue, PROPID property, ULONG relop, unsigned pos)
{
	CPropertyRestriction PropertyRestriction;

	PropertyRestriction.SetRelation( relop);
	PropertyRestriction.SetProperty( property);
	PropertyRestriction.SetValue( blobValue);
    
	AddChild(PropertyRestriction);
}


//--------------------------------------------------------------------------
//
// Methods for CPropertyRestriction
//
//--------------------------------------------------------------------------
CPropertyRestriction::CPropertyRestriction()
{
}

CPropertyRestriction::CPropertyRestriction( ULONG relop,
                                            PROPID const & Property,
                                            CMQVariant const & prval )
		: m_relop( relop ),
          m_Property( Property ),
          m_prval( prval )
{

}

CPropertyRestriction & CPropertyRestriction::operator=( CPropertyRestriction const & src )
{
	m_relop = src.m_relop;
	m_Property = src.m_Property;
	m_prval = src.m_prval;
	return (*this);
}


CPropertyRestriction::~CPropertyRestriction()
{
}


void CPropertyRestriction::SetValue( TCHAR * pwcsValue )
{
    m_prval = pwcsValue;
}

void CPropertyRestriction::SetValue( BLOB & bValue )
{
    m_prval = bValue;
}

void CPropertyRestriction::SetValue ( CACLSID * caclsValue)
{
	m_prval = caclsValue;
}

void CPropertyRestriction::SetValue ( CALPWSTR  * calpwstrValue)
{
	m_prval = calpwstrValue;
}

void CPropertyRestriction::SetValue( GUID * pguidValue )
{
    m_prval = pguidValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqutil\xactdata.cpp ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactData.cpp

Abstract:
    Static GUID definitions for xact processing

Author:
    Alexander Dadiomov (AlexDad)

--*/

#include "stdh.h"

#define   INITGUID	
#include "initguid.h"

#include "TXDTC.H"

#include "xactdata.tmh"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqutil\res\migtools\migdllres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MqMig.rc
//
#define IDD_MQMIG_FINISH                13001
#define IDS_STR_NOT_DC                  13001
#define IDS_STR_CANT_START              13003
#define IDS_STR_ERROR_TITLE             13004
#define IDS_STR_MUST_FILE               13005
#define IDS_STR_SERVICE_FAIL_TITLE      13006
#define IDS_STR_CANT_OPEN_MGR           13007
#define IDS_STR_CANT_OPEN_MSMQ          13008
#define IDS_STR_CANT_CNFG_MSMQ          13009
#define IDS_STR_CANT_OPEN_MQ1SYNC       13010
#define IDS_STR_CANT_CNFG_MQ1SYNC       13011
#define IDS_STR_SERVICE_WARNING_TITLE   13012
#define IDS_STR_CANT_START_MSMQ         13013
#define IDS_STR_CANT_START_MQ1SYNC      13014
#define IDS_STR_CANT_DEL_WELCOME        13015
#define IDS_STR_DEL_WELCOME_TITLE       13016
#define IDS_STR_WARNING_TITLE           13016
#define IDD_MQMIG_WELCOME               13017
#define IDD_MQMIG_SERVER                13018
#define IDD_MQMIG_LOGIN                 13019
#define IDD_MQMIG_WAIT                  13020
#define IDD_MQMIG_PREMIG                13021
#define IDI_ICON1                       13022
#define IDI_MIGWARNING                  13023
#define IDD_INIT_WAIT                   13024
#define IDD_MQMIG_HELP                  13025
#define IDB_WIZARD_WATERMARK            13026
#define IDD_MQMIG_SERVICE               13027
#define IDB_WIZARD_HEADER               13028

#define IDS_STR_REPLACE_FILE            13030
#define IDS_STR_CANT_CHECK              13031
#define IDS_OLD_VER_SERVERS             13032
#define IDS_STR_TO_CONTINUE             13033
#define IDS_MIGRATION_FAILED            13034
#define IDS_MIGRATION_SUCCEDED          13035
#define IDS_SQL_NOT_STARTED             13036
#define IDS_STR_CANT_OPEN_SQLSERVER     13037
#define IDS_STR_FAILED_OPEN_MGR         13038
#define IDS_STR_CANT_GET_SQLSERVER_STATUS 13039
#define IDS_STR_CANT_START_SQL_SERVER   13040
#define IDS_STR_CREATE_PATH             13041
#define IDS_STR_PRE_CREATE_PATH         13042
#define IDS_STR_PATH_CREATE_ERROR       13043
#define IDS_WAIT_ANALYZE                13044
#define IDS_WAIT_MIGRATE                13045
#define IDS_QUEUES                      13046
#define IDS_MACHINES                    13047
#define IDS_MQMIG_SITES                 13048
#define IDS_USERS                       13049
#define IDS_ENTERPRISE_ALREADY_EXIST    13050
#define IDS_ANALYSIS_SUCCEEDED          13051
#define IDS_ANALYSIS_FAILED             13052
#define IDS_NOTEPAD                     13053
#define IDS_ANALYSIS_FAILED_NO_LOG      13054
#define IDS_MIGRATION_FAILED_NO_LOG     13055
#define IDS_CANT_OPEN_MSMQ_SRVICE       13056
#define IDS_CANT_GET_MSMQ_CONFIG        13057
#define IDS_MSMQ_NOT_DISABLED           13058
#define IDS_MIGTOOL_CAPTION             13059
#define IDS_LOGGING_TITLE               13060
#define IDS_LOGGING_SUBTITLE            13061
#define IDS_ANALYZE_TITLE               13062
#define IDS_ANALYZE_SUBTITLE            13063
#define IDS_WAIT_TITLE                  13064
#define IDS_WAIT_SUBTITLE               13065
#define IDS_PREIMPORT_TITLE             13066
#define IDS_PREIMPORT_SUBTITLE          13067
#define IDS_WAIT2_TITLE                 13068
#define IDS_WAIT2_SUBTITLE              13069
#define IDS_WELCOME_TITLE_TEXT          13070
#define IDS_MQMIG_USAGE                 13071
#define IDS_STR_CANT_STOP_MSMQ          13072
#define IDS_STR_CANT_DISABLE_MSMQ       13073
#define IDS_MQ1SYNCSERVICE_LABEL        13074
#define IDS_STR_FAILED_CREATE_REPLSERV  13075
#define IDS_CANT_CREATE_REPLSERV_QUEUE  13076
#define IDS_CANT_UPDATE_REGISTRY        13077
#define IDS_CANT_CONNECT_DATABASE       13078
#define IDS_CANT_GET_SITEID             13079
#define IDS_CANT_UPDATE_DS              13080
#define IDS_HTML_HELP_PATH              13081
#define IDS_HELP_TITLE                  13082
#define IDS_HELP_SUBTITLE               13083
#define IDS_MQ1SYNC_SERVICE_DESCRIPTION 13084
#define IDS_STR_WRONG_PATH              13085
#define IDS_DRIVE_NOT_VALID             13086
#define IDS_ELAPSED_TIME_TEXT           13087
#define IDS_CANT_GET_IDS                13088
#define IDS_CANT_GET_REGISTRY           13089
#define IDS_CANT_UPDATE_MQIS            13090
#define IDS_UPDATE_SUCCEEDED            13091
#define IDS_UPDATE_PARTIALLY            13092
#define IDS_INITUPDATE                  13093
#define IDS_SRVCACC_SUBTITLE            13094
#define IDS_SRVCACC_TITLE               13095
#define IDS_NO_SERVER_TO_UPDATE         13096
#define IDS_INSUFFICIENT_PERMISSION     13097
#define IDS_CANT_OPEN_MQ1SYNC_SRVICE    13098
#define IDS_CANT_GET_MQ1SYNC_CONFIG     13099
#define IDS_STR_CANT_STOP_MQ1SYNC       13100
#define IDS_STR_CANT_DISABLE_MQ1SYNC    13101
#define IDS_STR_RESTORE_OBJECTS         13102
#define IDS_STR_WRONG_DLL_VERSION       13103
#define IDS_STR_CANT_DETERMINE_FILE_VERSION 13104
#define IDC_TEXT1                       13105
#define IDC_CHECK_READ                  13106
#define IDC_RADIO_ERR                   13107
#define IDC_RADIO_WARN                  13108
#define IDC_RADIO_TRACE                 13109
#define IDC_RADIO_INFO                  13110
#define IDC_RADIO_DISABLE               13111
#define IDC_MQMIG_BROWSE                13112
#define IDC_EDIT_LOGFILE                13113
#define IDC_PROGRESS_SITE               13114
#define IDC_PROGRESS_MACHINE            13115
#define IDC_PROGRESS_QUEUE              13116
#define IDC_STATIC_SITE                 13117
#define IDC_STATIC_MACHINE              13118
#define IDC_STATIC_QUEUE                13119
#define IDC_PROGRESS_USER               13120
#define IDC_STATIC_USER                 13121
#define IDC_FINISH_TEXT                 13122
#define IDC_PLEASE_WAIT                 13123
#define IDC_VIEW_LOG_FILE               13124
#define IDC_WELCOME_TEXT                13125
#define IDC_MQMIG_CHECK1                13126
#define IDC_ELAPSED_TIME                13127
#define IDC_INITTEXT                    13128
#define IDC_DONE                        13129

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        13130
#define _APS_NEXT_COMMAND_VALUE         13130
#define _APS_NEXT_CONTROL_VALUE         13130
#define _APS_NEXT_SYMED_VALUE           13130
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqutil\shrutil.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    shrutil.cpp

Abstract:

    Utilities that are used both by QM and RT DLL

Author:

    Lior Moshaiov (LiorM)


--*/
#include "stdh.h"
#include "TXDTC.H"
#include "txcoord.h"
#include "xolehlp.h"
#include "mqutil.h"
#include <clusapi.h>
#include <mqnames.h>

#include "shrutil.tmh"

extern HINSTANCE g_DtcHlib;         // handle of the loaded DTC proxy library (defined in mqutil.cpp)
extern IUnknown *g_pDTCIUnknown;    // pointer to the DTC IUnknown
extern ULONG     g_cbTmWhereabouts; // length of DTC whereabouts
extern BYTE     *g_pbTmWhereabouts; // DTC whereabouts

static HANDLE g_hMutexDTC = NULL;   // Serializes calls to DTC

#define MSDTC_SERVICE_NAME     TEXT("MSDTC")          // Name of the DTC service
#define MSDTC_PROXY_DLL_NAME   TEXT("xolehlp.dll")    // Name of the DTC helper proxy DLL

#define MAX_DTC_WAIT   150   // waiting for DTC start - seconds
#define STEP_DTC_WAIT  10    // check each .. seconds

//This API should be used to obtain an IUnknown or a ITransactionDispenser
//interface from the Microsoft Distributed Transaction Coordinator's proxy.
//Typically, a NULL is passed for the host name and the TM Name. In which
//case the MS DTC on the same host is contacted and the interface provided
//for it.
typedef HRESULT (STDAPIVCALLTYPE * LPFNDtcGetTransactionManager) (
                                             LPSTR  pszHost,
                                             LPSTR  pszTmName,
                                    /* in */ REFIID rid,
                                    /* in */ DWORD  i_grfOptions,
                                    /* in */ void FAR * i_pvConfigParams,
                                    /*out */ void** ppvObject ) ;

/*====================================================
VerifyCurDTC
    Internal: verifies that the current cached DTC pointers are alive
=====================================================*/
STATIC BOOL VerifyCurDTC()
{
    HRESULT hr;
    BOOL    fOK = FALSE;

    if (g_pDTCIUnknown    != NULL &&
        g_cbTmWhereabouts > 0     &&
        g_pbTmWhereabouts != NULL)
    {
        R<IResourceManagerFactory>       pIRmFactory    = NULL;
        R<ITransactionImport>            pTxImport      = NULL;
        R<ITransactionImportWhereabouts> pITxWhere      = NULL;

        // Check if old DTC pointer is alive yet
        try
        {

            hr = g_pDTCIUnknown->QueryInterface (IID_ITransactionImportWhereabouts,
                                                (void **)(&pITxWhere));
            if (SUCCEEDED(hr))
            {
                hr  = g_pDTCIUnknown->QueryInterface(IID_IResourceManagerFactory,
                                                     (LPVOID *) &pIRmFactory);
                if (SUCCEEDED(hr))
                {
                    hr  =  g_pDTCIUnknown->QueryInterface(IID_ITransactionImport,
                                                          (void **)&pTxImport);
                    if (SUCCEEDED(hr))
                    {
                        fOK = TRUE;
                    }
                }
            }
        }
        catch(...)
        {
            // DTC may have been stopped or killed
            fOK = FALSE;
        }
    }
    return fOK;
}

/*====================================================
XactGetDTC
    Gets the IUnknown pointer amd whereabouts of the MS DTC
Arguments:
    OUT    IUnknown *ppunkDtc
    ULONG  *pcbWhereabouts
    BYTE  **ppbWherabouts
Returns:
    HR
=====================================================*/
HRESULT
XactGetDTC(
    IUnknown **ppunkDtc,
    ULONG     *pcbTmWhereabouts,
    BYTE     **ppbTmWhereabouts
    )
{
    HRESULT hr;
    BOOL    fFreeDone = FALSE;

    // Prepare pessimistic output parameters
    *ppunkDtc         = NULL;
    if (pcbTmWhereabouts)
    {
        *pcbTmWhereabouts = 0;
        *ppbTmWhereabouts = NULL;
    }

    // Is the kept pointer is OK?
    if (!VerifyCurDTC())
    {
        // Release previous pointers and data
        XactFreeDTC();
        fFreeDone = TRUE;

        //
        // Get new DTC pointer
        //

        // On NT, xolehlp is not linked statically to mqutil, so we load it here

        if (g_DtcHlib == NULL)
        {
            g_DtcHlib = LoadLibrary(MSDTC_PROXY_DLL_NAME);
        }

        if (!g_DtcHlib)
        {
            DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("g_DtcHlib=%p "), 0));
            return MQ_ERROR_DTC_CONNECT;
        }

        // Get DTC API pointer
        LPFNDtcGetTransactionManager pfDtcGetTransactionManager =
              (LPFNDtcGetTransactionManager) GetProcAddress(g_DtcHlib, "DtcGetTransactionManagerExA");

        if (!pfDtcGetTransactionManager) 
        {
            pfDtcGetTransactionManager =
              (LPFNDtcGetTransactionManager) GetProcAddress(g_DtcHlib, "DtcGetTransactionManagerEx");
        }

        if (!pfDtcGetTransactionManager)
        {
            DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("pfDtcGetTransactionManager=%p "), 0));
            return MQ_ERROR_DTC_CONNECT;
        }

        // Get DTC IUnknown pointer
        hr = (*pfDtcGetTransactionManager)(
                                 NULL,
                                 NULL,
                                 IID_IUnknown,
                                 OLE_TM_FLAG_QUERY_SERVICE_LOCKSTATUS,
                                 0,
                                 (LPVOID *) ppunkDtc);


        if (FAILED(hr) || *ppunkDtc == NULL)
        {
            DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("pfDtcGetTransactionManager failed: %x "), hr));
            return MQ_ERROR_DTC_CONNECT;
        }

        // Keep DTC IUnknown pointer for the future usage
        g_pDTCIUnknown = *ppunkDtc;

        // Get DTC whereabouts
        if (pcbTmWhereabouts)
        {
            R<ITransactionImportWhereabouts> pITxWhere = NULL;
            ULONG  cbUsed;

            // Get the DTC  ITransactionImportWhereabouts interface
            hr = g_pDTCIUnknown->QueryInterface (IID_ITransactionImportWhereabouts,
                                                 (void **)(&pITxWhere));
            if (FAILED(hr))
            {
                DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("QueryInterface failed: %x "), hr));
                return MQ_ERROR_DTC_CONNECT;
            }

            // Get the size of the whereabouts blob for the TM
            hr = pITxWhere->GetWhereaboutsSize (&g_cbTmWhereabouts);
            if (FAILED(hr))
            {
                DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("GetWhereaboutsSize failed: %x "), hr));
                return MQ_ERROR_DTC_CONNECT;
            }

            // Allocate space for the TM whereabouts blob
            try
            {
                g_pbTmWhereabouts = new BYTE[g_cbTmWhereabouts];
            }
            catch(const bad_alloc&)
            {
                g_cbTmWhereabouts = 0;
                DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("new g_cbTmWhereaboute failed: %x "), hr));
                return MQ_ERROR_INSUFFICIENT_RESOURCES;
            }

            // Get the TM whereabouts blob
            hr = pITxWhere->GetWhereabouts(g_cbTmWhereabouts, g_pbTmWhereabouts, &cbUsed);
            if (FAILED(hr))
            {
                g_cbTmWhereabouts = 0;
                delete []g_pbTmWhereabouts;
                g_pbTmWhereabouts = NULL;

                DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("GetWhereabouts failed: %x "), hr));
                return MQ_ERROR_DTC_CONNECT;
            }

        }
    }

    // Addref the pointer and return everything to the caller.
    g_pDTCIUnknown->AddRef();

    *ppunkDtc           = g_pDTCIUnknown;
    if (pcbTmWhereabouts)
    {
        *pcbTmWhereabouts   = g_cbTmWhereabouts;
        *ppbTmWhereabouts   = g_pbTmWhereabouts;
    }

    return (fFreeDone ? 1 : MQ_OK);
}

/*====================================================
XactFreeDTC
    Called on library download; frees DTC pointers
=====================================================*/
void XactFreeDTC(void)
{
    // Release previous pointers and data
    try
    {
        if (g_pbTmWhereabouts)
        {
            delete []g_pbTmWhereabouts;
        }

        if (g_pDTCIUnknown)
        {
            g_pDTCIUnknown->Release();
        }

        if (g_DtcHlib)
        {
            // Normally we should free DTC proxy library here,
            // but because of some nasty DTC bug xolehlp.dll does not work after reload.
            // So we are simply not freeing it, thus leaving in memory for all process lifetime.

            //FreeLibrary(g_DtcHlib);
        }
    }
    catch(...)
    {
        // Could occur if DTC failed or was released already.
    }

    g_pDTCIUnknown    = NULL;
    g_pbTmWhereabouts = NULL;
    g_cbTmWhereabouts = 0;
    g_DtcHlib         = NULL;
}


bool
MQUTIL_EXPORT
APIENTRY
IsLocalSystemCluster(
    VOID
    )
/*++

Routine Description:

    Check if local machine is a cluster node.

    The only way to know that is try calling cluster APIs.
    That means that on cluster systems, this code should run
    when cluster service is up and running. (ShaiK, 26-Apr-1999)

Arguments:

    None

Return Value:

    true - The local machine is a cluster node.

    false - The local machine is not a cluster node.

--*/
{
    CAutoFreeLibrary hLib = LoadLibrary(L"clusapi.dll");

    if (hLib == NULL)
    {
        DBGMSG((DBGMOD_ALL, DBGLVL_TRACE, _T("Local machine is NOT a Cluster node")));
        return false;
    }

    typedef DWORD (WINAPI *GetState_fn) (LPCWSTR, DWORD*);
    GetState_fn pfGetState = (GetState_fn)GetProcAddress(hLib, "GetNodeClusterState");

    if (pfGetState == NULL)
    {
        DBGMSG((DBGMOD_ALL, DBGLVL_TRACE, _T("Local machine is NOT a Cluster node")));
        return false;
    }

    DWORD dwState = 0;
    if (ERROR_SUCCESS != pfGetState(NULL, &dwState))
    {
        DBGMSG((DBGMOD_ALL, DBGLVL_TRACE, _T("Local machine is NOT a Cluster node")));
        return false;
    }

    if ((dwState == ClusterStateNotInstalled) || (dwState == ClusterStateNotConfigured))
    {
        DBGMSG((DBGMOD_ALL, DBGLVL_TRACE, _T("Local machine is NOT a Cluster node")));
        return false;
    }


    DBGMSG((DBGMOD_ALL, DBGLVL_TRACE, _T("Local machine is a Cluster node !!")));
    return true;

} //IsLocalSystemCluster


bool
APIENTRY
SetupIsLocalSystemCluster(
    VOID
    )
{
    return IsLocalSystemCluster();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\adnotify_s_.c ===
#pragma warning(push, 3)
#include <adnotify_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\admin.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    admin.h

Abstract:

	Admin Class definition
		
Author:

	David Reznick (t-davrez)


--*/


#define ADMIN_QUEUE_NAME	(L"private$\\admin_queue$")
#define REG_REPORTQUEUE     (L"ReportQueueGuid")
#define REG_PROPAGATEFLAG   (L"PropagateFlag")

#define DEFAULT_PROPAGATE_FLAG 0

class CAdmin
{
    public:

        CAdmin();

        HRESULT Init();

        HRESULT GetReportQueue(OUT QUEUE_FORMAT* pReportQueue);
        HRESULT SetReportQueue(IN  GUID* pReportQueueGuid);

        HRESULT GetReportPropagateFlag(OUT BOOL& fReportPropFlag);
        HRESULT SetReportPropagateFlag(IN  BOOL fReportPropFlag);
        
        HRESULT SendReport(IN QUEUE_FORMAT* pReportQueue,
                           IN OBJECTID*     pMessageID,
                           IN QUEUE_FORMAT* pTargetQueue,
                           IN LPCWSTR       pwcsNextHop,
                           IN ULONG         ulHopCount);

        HRESULT SendReportConflict(IN QUEUE_FORMAT* pReportQueue,
                                   IN QUEUE_FORMAT* pOriginalReportQueue,
                                   IN OBJECTID*     pMessageID,
                                   IN QUEUE_FORMAT* pTargetQueue,
                                   IN LPCWSTR       pwcsNextHop);

    private:

        //functions
        HRESULT GetAdminQueueFormat( QUEUE_FORMAT * pQueueFormat);

        //members
        BOOL m_fReportQueueExists;
        QUEUE_FORMAT m_ReportQueueFormat;

        BOOL m_fPropagateFlag;
};



//
//  inline members
//

inline HRESULT CAdmin::GetReportPropagateFlag(OUT BOOL& fReportPropFlag)
{
    fReportPropFlag = m_fPropagateFlag;
    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\admcomnd.cpp ===
#include "stdh.h"
#include "qmres.h"
#include "admcomnd.h"
#include "admutils.h"
#include "admin.h"
#include "cqpriv.h"
#include "mqformat.h"
#include "license.h"

#include "admcomnd.tmh"

extern CAdmin Admin;

extern HMODULE   g_hResourceMod;

static WCHAR *s_FN=L"admcomnd";

/*====================================================

RoutineName
    AdminCommand

Arguments:

Return Value:

=====================================================*/

BOOL AdminCommand(LPCWSTR pBuf, INT iCharsLeft, INT& iArgLength,
                    LPCWSTR lpwCommandName, INT iCommandLen)

{
    if (iCharsLeft < iCommandLen)
    {
        return LogBOOL(FALSE, s_FN, 1010);
    }

    if (!wcsncmp(pBuf, lpwCommandName, iCommandLen))
    {
        pBuf += iCommandLen;

        //
        // find the length of the command's argument
        //
        for (iArgLength = 0; (*pBuf != L'\0') &&
                (*pBuf != ADMIN_COMMAND_DELIMITER); pBuf++,iArgLength++)
		{
			NULL;
		}

        return TRUE;
    }
    else
    {
        //
        // This is some other command...
        //
        return LogBOOL(FALSE, s_FN, 1000);
    }
}

/*====================================================

RoutineName
    HandleGetReportQueueMessage

Arguments:

Return Value:

=======================================================*/
HRESULT HandleGetReportQueueMessage(LPCWSTR         pBuf,
                                    DWORD           TotalSize,
                                    QUEUE_FORMAT*   pResponseQFormat)
{
    QUEUE_FORMAT ReportQueueFormat;
    QMResponse Response;
    HRESULT hr;

    if (TotalSize != 0)
    {
        //
        // Received arguments to the command When there shouldn't be any.
        // Continue executing command anyway
        //
        DBGMSG((DBGMOD_QM,DBGLVL_ERROR,TEXT("HandleGetReportQueueMessage: Command shouldn't have arguments")));
        LogIllegalPoint(s_FN, 1922);
    }

    Response.dwResponseSize = 0;
    hr = Admin.GetReportQueue(&ReportQueueFormat);

    switch(hr)
    {
        case MQ_ERROR_QUEUE_NOT_FOUND :
            Response.uStatus = ADMIN_STAT_NOVALUE;
            break;

        case MQ_OK :
            Response.uStatus = ADMIN_STAT_OK;
            Response.dwResponseSize = sizeof(GUID);
            memcpy(Response.uResponseBody, &ReportQueueFormat.PublicID(),
                   Response.dwResponseSize);
            break;

        default:
            Response.uStatus = ADMIN_STAT_ERROR;
    }

    hr = SendQMAdminResponseMessage(pResponseQFormat,
                                    ADMIN_RESPONSE_TITLE,
                                    STRLEN(ADMIN_RESPONSE_TITLE)+1,
                                    Response,
                                    ADMIN_COMMANDS_TIMEOUT);

    return LogHR(hr, s_FN, 10);
}

/*====================================================

RoutineName
    HandleSetReportQueueMessage

Arguments:

Return Value:

=====================================================*/
HRESULT HandleSetReportQueueMessage(
    LPCWSTR          pBuf,
    DWORD           TotalSize)
{
    HRESULT hr = MQ_ERROR;

    if ((TotalSize == 1                    // for the equal sign "="
                     + STRING_UUID_SIZE)   // for the report queue string guid"
        && (*pBuf == L'='))

    {
        GUID ReportQueueGuid;
        WCHAR wcsGuid[STRING_UUID_SIZE+1];

        wcsncpy(wcsGuid,pBuf+1,STRING_UUID_SIZE);
        wcsGuid[STRING_UUID_SIZE] = L'\0';

        if (IIDFromString((LPWSTR)wcsGuid,&ReportQueueGuid) == S_OK)
        {
            hr = Admin.SetReportQueue(&ReportQueueGuid);
        }
    }
    else
    {
        DBGMSG((DBGMOD_QM,DBGLVL_ERROR,
           TEXT("HandleSetReportQueueMessage: bad argument!!")));
        LogIllegalPoint(s_FN, 1923);
    }
    return LogHR(hr, s_FN, 20);
}


/*====================================================

RoutineName
    HandleGetPropagateFlagMessage

Arguments:

Return Value:

=====================================================*/
HRESULT HandleGetPropagateFlagMessage(LPCWSTR         pBuf,
                                      DWORD           TotalSize,
                                      QUEUE_FORMAT*   pResponseQFormat)

{
    QMResponse Response;
    BOOL    fPropagateFlag;
    HRESULT hr;

    if (TotalSize != 0)
    {
        //
        // Received arguments to the command When there shouldn't be any.
        // Continue executing command anyway
        //
        DBGMSG((DBGMOD_QM,DBGLVL_ERROR,TEXT("HandleGetPropagateFlagMessage: Command shouldn't have arguments")));
    }

    hr = Admin.GetReportPropagateFlag(fPropagateFlag);

    switch(hr)
    {
        case MQ_OK :
            Response.uStatus = ADMIN_STAT_OK;
            Response.dwResponseSize = 1;
            Response.uResponseBody[0] = (fPropagateFlag) ? PROPAGATE_FLAG_TRUE :
                                                           PROPAGATE_FLAG_FALSE;
            break;

        default:
            Response.uStatus = ADMIN_STAT_ERROR;
    }

    hr = SendQMAdminResponseMessage(pResponseQFormat,
                        ADMIN_RESPONSE_TITLE,
                        STRLEN(ADMIN_RESPONSE_TITLE) +1,
                        Response,
                        ADMIN_COMMANDS_TIMEOUT);

    return LogHR(hr, s_FN, 30);
}

/*====================================================

RoutineName
    HandleSetPropagateFlagMessage

Arguments:

Return Value:

=====================================================*/
HRESULT HandleSetPropagateFlagMessage(
    LPCWSTR         pBuf,
    DWORD           TotalSize)
{
    HRESULT hr;
    UINT iFalseLen = wcslen(PROPAGATE_STRING_FALSE);
    UINT iTrueLen  = wcslen(PROPAGATE_STRING_TRUE);

    //
    // Argument format : "=FALSE" or "=TRUE"
    //
    if ( (TotalSize == 1 + iFalseLen) && (*pBuf == L'=') &&
         (!wcsncmp(pBuf+1,PROPAGATE_STRING_FALSE,iFalseLen)) )
    {
        hr = Admin.SetReportPropagateFlag(FALSE);
    }
    else if ( (TotalSize == 1 + iTrueLen) && (*pBuf == L'=') &&
              (!wcsncmp(pBuf+1,PROPAGATE_STRING_TRUE,iTrueLen)) )
    {
        hr = Admin.SetReportPropagateFlag(TRUE);
    }
    else
    {
        DBGMSG((DBGMOD_QM,DBGLVL_ERROR,TEXT("HandleSetPropagateFlagMessage: Bad size of body : %d (should be 1)"),TotalSize));
        hr = MQ_ERROR;
    }

    return LogHR(hr, s_FN, 40);
}


/*====================================================

RoutineName
    HandleSendTestMessage

Arguments:

Return Value:

=====================================================*/
HRESULT HandleSendTestMessage(
    LPCWSTR          pBuf,
    DWORD           TotalSize)
{
    HRESULT hr = MQ_ERROR;

    if ((TotalSize == 1                    // for the equal sign "="
                     + STRING_UUID_SIZE)   // for the report queue string guid"
        && (*pBuf == L'='))

    {
        WCHAR wcsGuid[STRING_UUID_SIZE+1];
        TCHAR szTitle[100];

        LoadString(g_hResourceMod, IDS_TEST_TITLE, szTitle, TABLE_SIZE(szTitle));

        CString strTestMsgTitle = szTitle;

        wcsncpy(wcsGuid,pBuf+1,STRING_UUID_SIZE);
        wcsGuid[STRING_UUID_SIZE] = L'\0';

        GUID guidPublic;
        if (IIDFromString(wcsGuid, &guidPublic) == S_OK)
        {
            QUEUE_FORMAT DestQueueFormat(guidPublic);

            PrepareTestMsgTitle(strTestMsgTitle);

            //
            // Send a test message with a title and no body.
            //
            hr = SendQMAdminMessage(
                        &DestQueueFormat,
                        (LPTSTR)(LPCTSTR)strTestMsgTitle,
                        (strTestMsgTitle.GetLength() + 1),
                        NULL,
                        0,
                        ADMIN_COMMANDS_TIMEOUT,
                        TRUE,
                        TRUE);
        }
    }
    else
    {
        DBGMSG((DBGMOD_QM,DBGLVL_ERROR,
           TEXT("HandleSendTestMessage: bad argument!!")));
        LogIllegalPoint(s_FN, 1924);
    }

    return LogHR(hr, s_FN, 80);
}

//
// GET_FIRST/NEXT_PRIVATE_QUEUE
//
#ifdef _WIN64
//
// WIN64, the LQS operations are done using a DWORD mapping of the HLQS enum handle. The 32 bit mapped
// value is specified in the MSMQ message from MMC, and not the real 64 bit HLQS handle
//
#define GET_FIRST_PRIVATE_QUEUE(pos, strPathName, dwQueueId) \
            g_QPrivate.QMGetFirstPrivateQueuePositionByDword(pos, strPathName, dwQueueId)
#define GET_NEXT_PRIVATE_QUEUE(pos, strPathName, dwQueueId) \
            g_QPrivate.QMGetNextPrivateQueueByDword(pos, strPathName, dwQueueId)
#else //!_WIN64
//
// WIN32, the LQS operations are done using the HLQS enum handle that is specified as 32 bit value
// in the MSMQ messages from MMC
//
#define GET_FIRST_PRIVATE_QUEUE(pos, strPathName, dwQueueId) \
            g_QPrivate.QMGetFirstPrivateQueuePosition(pos, strPathName, dwQueueId)
#define GET_NEXT_PRIVATE_QUEUE(pos, strPathName, dwQueueId) \
            g_QPrivate.QMGetNextPrivateQueue(pos, strPathName, dwQueueId);
#endif //_WIN64

/*====================================================

RoutineName
    HandleGetPrivateQueues

Arguments:

Return Value:

=======================================================*/
//
// This global is used only in this function.
//
HRESULT HandleGetPrivateQueues(LPCWSTR         pBuf,
                               DWORD           TotalSize,
                               QUEUE_FORMAT*   pResponseQFormat)
{
    HRESULT  hr;
    QMGetPrivateQResponse Response;

    Response.hr = ERROR_SUCCESS;
    Response.pos = NULL;
    Response.dwResponseSize = 0;
    Response.dwNoOfQueues = 0;

    if (*pBuf != L'=')
    {
        DBGMSG((DBGMOD_QM,
                DBGLVL_ERROR,
                TEXT("HandleGetPrivateQueues: bad argument!!")));
        return LogHR(MQ_ERROR, s_FN, 90);
    }

    //
    // Inside context for private queues handling.
    //
    {
        DWORD dwReadFrom;
        _stscanf(pBuf+1, L"%ul", &dwReadFrom);

        LPCTSTR  strPathName;
        DWORD    dwQueueId;
        DWORD    dwResponseSize = 0;
        QMGetPrivateQResponse_POS32 pos; //always 32 bit on both win32 and win64

        //
        // lock to ensure private queues are not added or deleted while filling the
        // buffer.
        //
        CS lock(g_QPrivate.m_cs);
        //
        // Skip the previous read queues
        //
        //
        // Write the pathnames into the buffer.
        //
        if (dwReadFrom)
        {
            //
            // Get Next Private queue based on the LQS enum handle that is specified in the MMC message
            // On win64 the value specified is a DWORD mapping of the LQS enum handle - to maintain
            // 32 bit wire compatibility to existing MMC's that run on win32
            //
            pos = (QMGetPrivateQResponse_POS32) dwReadFrom;
            hr = GET_NEXT_PRIVATE_QUEUE(pos, strPathName, dwQueueId);
        }
        else
        {
            //
            // Get First Private queue.
            // Also sets pos to the LQS enum handle (or to a mapped DWORD of it on win64)
            //
            hr = GET_FIRST_PRIVATE_QUEUE(pos, strPathName, dwQueueId);
        }

        while (SUCCEEDED(hr))
        {
			if(dwQueueId <= MAX_SYS_PRIVATE_QUEUE_ID)
			{
				//
				// Filter out system queues out of the list
				//
				hr = GET_NEXT_PRIVATE_QUEUE(pos, strPathName, dwQueueId);
				continue;
			} 
            
            DWORD dwNewQueueLen;

            dwNewQueueLen = (wcslen(strPathName) + 1) * sizeof(WCHAR) + sizeof(DWORD);
            //
            // Check if there is still enough space (take ten characters extra for lengths, etc)
            //
            if (dwNewQueueLen >(MAX_GET_PRIVATE_RESPONSE_SIZE - dwResponseSize))
            {
                Response.hr = ERROR_MORE_DATA;
                break;
            }

            //
            // Write down the Queue Id
            //
            *(DWORD UNALIGNED *)(Response.uResponseBody+dwResponseSize) = dwQueueId;

            //
            // Write down the name - including the terminating NULL.
            //
            wcscpy((TCHAR *)(Response.uResponseBody+dwResponseSize + sizeof(DWORD)), strPathName);
            dwResponseSize += dwNewQueueLen;
            //
            // Update the number of the returned private queue
            //
            Response.dwNoOfQueues++;
            //
            // Get Next Private queue
            //
            hr = GET_NEXT_PRIVATE_QUEUE(pos, strPathName, dwQueueId);
        }

        Response.pos = pos;
        Response.dwResponseSize += dwResponseSize;
    }

    hr = SendQMAdminMessage(pResponseQFormat,
                            ADMIN_RESPONSE_TITLE,
                            STRLEN(ADMIN_RESPONSE_TITLE)+1,
                            (PUCHAR)(&Response),
                            sizeof(QMGetPrivateQResponse),
                            ADMIN_COMMANDS_TIMEOUT);
    return LogHR(hr, s_FN, 96);
}

/*====================================================

RoutineName
    HandlePing

Arguments:

Return Value:

=====================================================*/
HRESULT HandlePing(LPCWSTR         pBuf,
                   DWORD           TotalSize,
                   QUEUE_FORMAT*   pResponseQFormat)

{
    QMResponse Response;
    HRESULT hr;

    //
    // Ping returns the exact arguments it gets
    //
    Response.uStatus = ADMIN_STAT_OK;
    Response.dwResponseSize = (DWORD)min((TotalSize + 1)*sizeof(WCHAR), sizeof(Response.uResponseBody));
    memcpy(Response.uResponseBody, pBuf, Response.dwResponseSize);
    hr = SendQMAdminResponseMessage(pResponseQFormat,
                        ADMIN_PING_RESPONSE_TITLE,
                        STRLEN(ADMIN_PING_RESPONSE_TITLE)+1,
                        Response,
                        ADMIN_COMMANDS_TIMEOUT);

    return LogHR(hr, s_FN, 100);
}


/*====================================================

RoutineName
    HandleGetDependentClients

Arguments:

Return Value:

=======================================================*/
//
// This global is used only in this function.
//
extern CQMLicense  g_QMLicense ;

HRESULT HandleGetDependentClients(LPCWSTR         pBuf,
                               DWORD           TotalSize,
                               QUEUE_FORMAT*   pResponseQFormat)
{
    HRESULT hr;
    AP<ClientNames> pNames;
    
    g_QMLicense.GetClientNames(&pNames);
    PUCHAR  pchResp  = new UCHAR[sizeof(QMResponse) -
                                 MAX_ADMIN_RESPONSE_SIZE +
                                 pNames->cbBufLen] ;
    QMResponse *pResponse = (QMResponse *)pchResp; 

    pResponse->uStatus = ADMIN_STAT_OK;
    pResponse->dwResponseSize = pNames->cbBufLen;

    memcpy(pResponse->uResponseBody, pNames, pNames->cbBufLen);
    hr = SendQMAdminResponseMessage(pResponseQFormat,
                        ADMIN_DEPCLI_RESPONSE_TITLE, 
                        STRLEN(ADMIN_DEPCLI_RESPONSE_TITLE) + 1,
                        *pResponse,
                        ADMIN_COMMANDS_TIMEOUT);
    delete [] pchResp;
    return LogHR(hr, s_FN, 110);
}

/*====================================================

RoutineName
   ParseAdminCommands

Arguments:

Return Value:

=====================================================*/
void ParseAdminCommands(
    LPCWSTR         pBuf,
    DWORD           TotalSize,
    QUEUE_FORMAT*   pResponseQFormat)
{
    //
    // NOTE : The Admin commands are string-based and not indexed. The motivation
    //        is to have meaningful messages (that can be read by explorer). The
    //        efficiency is less important due to the low-frequency of admin
    //        messages.
    //

    ASSERT(pBuf != NULL);

    INT iCmdLen, iArgLength, iCharsLeft   = TotalSize;

    while (*pBuf)
    {
        if (AdminCommand(pBuf, iCharsLeft, iArgLength,
                          ADMIN_SET_REPORTQUEUE, (iCmdLen = wcslen(ADMIN_SET_REPORTQUEUE))))
        {
            pBuf += iCmdLen;
            HandleSetReportQueueMessage(pBuf, iArgLength);
        }
        else if (AdminCommand(pBuf, iCharsLeft, iArgLength,
                  ADMIN_GET_REPORTQUEUE, (iCmdLen = wcslen(ADMIN_GET_REPORTQUEUE))))
        {
            pBuf += iCmdLen;
            HandleGetReportQueueMessage(pBuf, iArgLength, pResponseQFormat);
        }
        else if (AdminCommand(pBuf, iCharsLeft, iArgLength,
                  ADMIN_SET_PROPAGATEFLAG, (iCmdLen = wcslen(ADMIN_SET_PROPAGATEFLAG))))
        {
            pBuf += iCmdLen;
            HandleSetPropagateFlagMessage(pBuf, iArgLength);
        }
        else if (AdminCommand(pBuf, iCharsLeft, iArgLength,
                  ADMIN_GET_PROPAGATEFLAG, (iCmdLen = wcslen(ADMIN_GET_PROPAGATEFLAG))))
        {
            pBuf += iCmdLen;
            HandleGetPropagateFlagMessage(pBuf, iArgLength, pResponseQFormat);
        }
        else if (AdminCommand(pBuf, iCharsLeft, iArgLength,
                  ADMIN_SEND_TESTMSG, (iCmdLen = wcslen(ADMIN_SEND_TESTMSG))))
        {
            pBuf += iCmdLen;
            HandleSendTestMessage(pBuf, iArgLength);
        }
        else if (AdminCommand(pBuf, iCharsLeft, iArgLength,
                  ADMIN_GET_PRIVATE_QUEUES, (iCmdLen = wcslen(ADMIN_GET_PRIVATE_QUEUES))))
        {
            pBuf += iCmdLen;
            HandleGetPrivateQueues(pBuf, iArgLength, pResponseQFormat);
        }
        else if (AdminCommand(pBuf, iCharsLeft, iArgLength,
                  ADMIN_PING, (iCmdLen = wcslen(ADMIN_PING))))
        {
            pBuf += iCmdLen;
            HandlePing(pBuf, iArgLength, pResponseQFormat);
        }
        else if (AdminCommand(pBuf, iCharsLeft, iArgLength,
                  ADMIN_GET_DEPENDENTCLIENTS, (iCmdLen = wcslen(ADMIN_GET_DEPENDENTCLIENTS))))
        {
            pBuf += iCmdLen;
            HandleGetDependentClients(pBuf, iArgLength, pResponseQFormat);
        }
        else
        {
            DBGMSG((DBGMOD_QM,DBGLVL_ERROR,TEXT("HandleAdminCommand: unknown command ")));
            break;
        }

        //
        // parse next command
        //
        if (*(pBuf+iArgLength) == ADMIN_COMMAND_DELIMITER) iArgLength++;

        iCharsLeft -= (iCmdLen + iArgLength);
        pBuf += iArgLength;

    }
}

/*====================================================

RoutineName
    ReceiveAdminCommands()

Arguments:

Return Value:


=====================================================*/
BOOL
WINAPI
ReceiveAdminCommands(
    CMessageProperty* pmp,
    QUEUE_FORMAT* pqf
    )
{
    DWORD dwTitleLen = wcslen(ADMIN_COMMANDS_TITLE);

    if ( (pmp->pTitle == NULL) || (pmp->dwTitleSize != (dwTitleLen+1)) ||
         (wcsncmp((LPCTSTR)pmp->pTitle, ADMIN_COMMANDS_TITLE, dwTitleLen)) )
    {
        DBGMSG((DBGMOD_QM,DBGLVL_ERROR,TEXT("Error -  in ReceiveAdminCommands : No title in message")));
        return(TRUE);
    }

    if ( pmp->wClass == MQMSG_CLASS_NORMAL )
    {
        ParseAdminCommands((LPWSTR)pmp->pBody, pmp->dwBodySize / sizeof(WCHAR), pqf);
    }
    else
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("ReceiveAdminCommands: wrong message class")));
    }
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\admutils.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    admutils.cpp

Abstract:

	QM-Admin utilities (for report-queue handling)

Author:

	David Reznick (t-davrez)  04-13-96


--*/

#include "stdh.h"
#include "qmp.h"
#include "admcomnd.h"
#include "admutils.h"
#include "qmres.h"
#include "mqformat.h"

#include "admutils.tmh"

extern LPTSTR  g_szMachineName;
extern HINSTANCE g_hInstance;	
extern HMODULE   g_hResourceMod;			

static WCHAR *s_FN=L"admutils";

/*====================================================

RoutineName
    GuidToString

Arguments:

Return Value:

=====================================================*/

BOOL GuidToString(const GUID& srcGuid, CString& strGuid)
{
    WCHAR wcsTemp[STRING_UUID_SIZE+1];
    INT iLen = StringFromGUID2(srcGuid, wcsTemp, TABLE_SIZE(wcsTemp));

    if (iLen == (STRING_UUID_SIZE + 1))
    {
        //
        // take the enclosing brackets "{}" off
        //
        wcsTemp[STRING_UUID_SIZE-1] = L'\0';
        strGuid = &wcsTemp[1];
        return TRUE;
    }

    return LogBOOL(FALSE, s_FN, 1010); 
}

/*====================================================

RoutineName
    SendQMAdminMessage

Arguments:

Return Value:

=====================================================*/

HRESULT SendQMAdminMessage(QUEUE_FORMAT* pResponseQueue,
                           TCHAR* pTitle,
                           DWORD  dwTitleSize,
                           UCHAR* puBody,
                           DWORD  dwBodySize,
                           DWORD  dwTimeout,
                           BOOL   fTrace,
                           BOOL   fNormalClass)
{
    CMessageProperty MsgProp;

    if (fNormalClass)
    {
        MsgProp.wClass=MQMSG_CLASS_NORMAL;
    }
    else
    {
        MsgProp.wClass=MQMSG_CLASS_REPORT;
    }
    MsgProp.dwTimeToQueue = dwTimeout;
    MsgProp.dwTimeToLive = INFINITE;
    MsgProp.pMessageID=NULL;
    MsgProp.pCorrelationID=NULL;
    MsgProp.bPriority=MQ_MIN_PRIORITY;
    MsgProp.bDelivery=MQMSG_DELIVERY_EXPRESS;
    MsgProp.bAcknowledge=MQMSG_ACKNOWLEDGMENT_NONE;
    MsgProp.bAuditing=DEFAULT_Q_JOURNAL;
    MsgProp.dwApplicationTag=DEFAULT_M_APPSPECIFIC;
    MsgProp.dwTitleSize=dwTitleSize;
    MsgProp.pTitle=pTitle;
    MsgProp.dwBodySize=dwBodySize;
    MsgProp.dwAllocBodySize=dwBodySize;
    MsgProp.pBody=puBody;

    if (fTrace)
    {
        MsgProp.bTrace = MQMSG_SEND_ROUTE_TO_REPORT_QUEUE;
    }
    else
    {
        MsgProp.bTrace = MQMSG_TRACE_NONE;
    }

    HRESULT hr2 = QmpSendPacket(
                    &MsgProp,
                    pResponseQueue,
                    NULL,
                    NULL
                    );
	return LogHR(hr2, s_FN, 10);
}

/*====================================================

RoutineName
    SendQMAdminResponseMessage

Arguments:

Return Value:

=====================================================*/

HRESULT SendQMAdminResponseMessage(QUEUE_FORMAT* pResponseQueue,
                                   TCHAR* pTitle,
                                   DWORD  dwTitleSize,
                                   QMResponse &Response,
                                   DWORD  dwTimeout,
                                   BOOL   fTrace)
{
    HRESULT hr2 = SendQMAdminMessage(pResponseQueue,
                               pTitle,
                               dwTitleSize,
                               &Response.uStatus,
                               Response.dwResponseSize+1,
                               dwTimeout,
                               fTrace);
	return LogHR(hr2, s_FN, 20);
}



/*====================================================

RoutineName
    GetFormattedName

Arguments:

Return Value:
  returns the formatted name representation of the
  queue format
=====================================================*/

HRESULT GetFormattedName(QUEUE_FORMAT* pTargetQueue,
                         CString&      strTargetQueueFormat)

{
    CString strGuid;
    HRESULT hr = MQ_ERROR;
    WCHAR   wsFormatName[80];
    ULONG   ulFormatNameLength;

    hr = MQpQueueFormatToFormatName(pTargetQueue,wsFormatName,80, &ulFormatNameLength, false);
    strTargetQueueFormat = wsFormatName;


    return LogHR(hr, s_FN, 30);
}

/*====================================================

RoutineName
    GetMsgIdName

Arguments:

Return Value:
  returns the formatted string representation of the
  message id
=====================================================*/

HRESULT GetMsgIdName(OBJECTID* pObjectID,
                     CString&      strTargetQueueFormat)

{
    WCHAR wcsID[STRING_LONG_SIZE];

    if (!GuidToString(pObjectID->Lineage,strTargetQueueFormat))
    {
        return LogHR(MQ_ERROR, s_FN, 40);
    }

    _ltow(pObjectID->Uniquifier,wcsID,10);

    strTargetQueueFormat += '\\';
    strTargetQueueFormat += wcsID;

    return MQ_OK;
}

/*====================================================

RoutineName
    MessageIDToReportTitle

    This function converts the message id and hop count to a string in the following
    format:
    gggg:dddd:hh

  where: g is the first 4 hexadecimal digits of the GUID
         d is the internal message identifier
         h is the hop count

Arguments:

Return Value:

=====================================================*/

void MessageIDToReportTitle(CString& strIdTitle, OBJECTID* pMessageID,
                            ULONG ulHopCount)
{
    //
    // The first four digits of the printed GUID are Data1
    // four MSB.
    //
    USHORT usHashedId = (USHORT)(pMessageID->Lineage.Data1 >> 16);
    strIdTitle.Format(TEXT("%04X:%04d%3d"),
                      usHashedId, (USHORT)pMessageID->Uniquifier, ulHopCount);
}

/*====================================================

RoutineName
    PrepareReportTitle

    This function builds the title of the message send to
    the report queue. The message consists of the sender's
    name and a time stamp

Arguments:

Return Value:

=====================================================*/

void PrepareReportTitle(CString& strMsgTitle, OBJECTID* pMessageID,
                        LPCWSTR pwcsNextHop, ULONG ulHopCount)
{
    CString strTimeDate, strDescript, strIdTitle;
	TCHAR szSend[100], szReceived[100];
	TCHAR szTime[100], szDate[100];

	LoadString(g_hResourceMod, IDS_SENT1, szSend, TABLE_SIZE(szSend));
	LoadString(g_hResourceMod, IDS_RECEIVE, szReceived, TABLE_SIZE(szReceived));


	//
	// Get time and date
	//
	_wstrdate(szDate);
	_wstrtime(szTime);

    strTimeDate.Format(TEXT("%s , %s"),szDate, szTime);

    //
    // NOTE :   The Next-Hop machine is represented by its address. We need a
    //          way to translate the string address to computer
    //          name. Currently the address is put into the message body
    //
    if (pwcsNextHop)
    {
        //
        // Report message is being sent as the message exists the QM
        //
        strDescript.Format(szSend,g_szMachineName,pwcsNextHop);
    }
    else
    {
        //
        // Report message is being sent on receival of message
        //
        strDescript.Format(szReceived, g_szMachineName);
    }

    //
    // Prepate the message ID title
    //
    MessageIDToReportTitle(strIdTitle, pMessageID, ulHopCount);

    strMsgTitle.Format(TEXT("%s %s%s"), strIdTitle,strDescript,strTimeDate);
}

void PrepareTestMsgTitle(CString& strTitle)
{
    CString strDescript;
	TCHAR szSend[100];
	TCHAR szDate[100], szTime[100];

	LoadString(g_hResourceMod, IDS_SENT2, szSend, TABLE_SIZE(szSend));

	//
	// Get time and date
	//
	_wstrdate(szDate);
	_wstrtime(szTime);

    strDescript.Format(szSend, g_szMachineName,	szDate, szTime);

    strTitle += strDescript;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\cache.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:
    cache.h

    Template for managing cached values.  Each value in the cache should be
    inherited from the CCacheValue class. The calling code should call the
    method of the cached value, so that the entry may be deleted.

    Each value in the cache can have maximum life time in the cache - set
    using m_ExpirationTime member variable. If the number of values in
    the cache becomes twice as much as the hash size, half of the older
    values are removed from the cache.

Author:

    Boaz Feldbaum (BoazF) 26-Mar-1996.

--*/

#ifndef _CACHE_H_
#define _CACHE_H_

#define CACHE_EXPIRATION_GANULARITY (CTimeDuration::OneSecond().Ticks() * 60)

//
// Each value on the cache must be inherited from the CCacheValue class.
//
class CCacheValue
{
public:
    LONG AddRef();
    LONG Release();

public:
    CTimeInstant m_CreationTime;
    LONG  m_lRefCount;

protected:
    CCacheValue();
    virtual ~CCacheValue() = 0;
};

inline CCacheValue::CCacheValue() :
    m_CreationTime(ExGetCurrentTime()),
    m_lRefCount(1)
{
}

inline LONG CCacheValue::AddRef()
{
    LONG lRefCount = InterlockedIncrement(&m_lRefCount);

    return lRefCount;
}

inline LONG CCacheValue::Release()
{
    LONG lRefCount = InterlockedDecrement(&m_lRefCount);

    if (lRefCount == 0)
    {
        delete this;
    }

    return lRefCount;
}

inline CCacheValue::~CCacheValue()
{
    ASSERT(m_lRefCount == 0);
}

//
// Cache template.
//
template <class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CCache : public CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>
{
public:
    CCache();
    BOOL Lookup(ARG_KEY key, VALUE& rValue) const;
    void SetAt(ARG_KEY key, ARG_VALUE newValue);

private:
    void ExpireHalfCacheEntries();
    void ExpirePeriodicCacheEnteries(CTimer* pTimer);

    VALUE& operator[](ARG_KEY key) 
        { 
            return CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::operator[](key);
        }

private:
    static void WINAPI TimeToExpireCacheEntries(CTimer* pTimer);

public:
    CTimeDuration m_CacheLifetime;
    CCriticalSection m_cs;

private:
    BOOL m_fExpireCacheScheduled;
    CTimer m_ExpireCacheTimer;


};

template <class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CCache<KEY, ARG_KEY, VALUE, ARG_VALUE>::CCache() :
    m_CacheLifetime(CTimeDuration::MaxValue()),
    m_fExpireCacheScheduled(FALSE),
    m_ExpireCacheTimer(TimeToExpireCacheEntries)
{
}

//
// This function is defined in symmkey.cpp. It finds the median
// value for the time values on the array t.
//
extern ULONGLONG FindMedianTime(ULONGLONG* t, int p, int r, int i);


template <class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CCache<KEY, ARG_KEY, VALUE, ARG_VALUE>::ExpirePeriodicCacheEnteries(CTimer* pTimer)
/*++

  Routine Description:
    The routine removes all the keys that are in the cache for more than a certain
    amount of time.
    The routine calls from the timer.

  Arguments:
    pointer to timer object, that can be used for rescheduling

  Returned Value:
    None
 --*/
{
    ASSERT(pTimer == &m_ExpireCacheTimer);
    ASSERT(m_fExpireCacheScheduled == TRUE);

    CS lock(m_cs);

    //
    // Expire all the keys that are in the cache for more than
    // a certain amount of time.
    //

    m_fExpireCacheScheduled = FALSE;

    CTimeInstant CurrentTime = ExGetCurrentTime();
    CTimeInstant ExpirationTime = CurrentTime - m_CacheLifetime + CACHE_EXPIRATION_GANULARITY;

    //
    // Scan the cache and expire entries.
    //
    POSITION pos = GetStartPosition();
    CTimeInstant MinCreationTime = CTimeInstant::MaxValue();

    while (pos)
    {
        KEY key;
        VALUE value;

        GetNextAssoc(pos, key, value);

        if (value)
        {
            if (value->m_CreationTime < ExpirationTime)
            {
                RemoveKey(key);
            }
            else
            {
                MinCreationTime = min(MinCreationTime, value->m_CreationTime);
            }
        }
    }

    if (MinCreationTime != CTimeInstant::MaxValue())
    {
        //
        // Reschedule the expiration routine for next time.
        //
        CTimeDuration NextTimeout = m_CacheLifetime - (CurrentTime - MinCreationTime) + CACHE_EXPIRATION_GANULARITY;
            
        ExSetTimer(pTimer, NextTimeout); 
        m_fExpireCacheScheduled = TRUE;
    }
}


template <class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CCache<KEY, ARG_KEY, VALUE, ARG_VALUE>::ExpireHalfCacheEntries(void)
/*++

  Routine Description:
    The routine removes older half of the keys in the cache.

  Arguments:
    pointer to timer object, that can be used for rescheduling

  Returned Value:
    None
 --*/
{
    CS lock(m_cs);

    //
    // Expire older half of the keys in the cache.
    //

    //
    // Get the time values into an array.
    //
    int iHashCount = GetCount();
    AP<ULONGLONG> t = new ULONGLONG[iHashCount];

    POSITION pos = GetStartPosition();
    int i = 0;

    while (pos)
    {
        KEY key;
        VALUE value;

        GetNextAssoc(pos, key, value);
        if (value)
        {
            t[i++] = value->m_CreationTime.Ticks();
        }
    }

    //
    // Find the time median.
    //
    CTimeInstant MedExpiration = FindMedianTime(t, 0, i - 1, iHashCount / 2);

    //
    // Limit the expiration to half of the entries. This is required if
    // many entries have the same time.
    //
    int nLimit = i / 2;


    //
    // Scan the cache and expire entries.
    //
    pos = GetStartPosition();
    int n = 0;

    while (pos)
    {
        KEY key;
        VALUE value;

        GetNextAssoc(pos, key, value);

        if (value)
        {
            if (value->m_CreationTime < MedExpiration)
            {
                RemoveKey(key);
                if (++n > nLimit)
                {
                    break;
                }
            }
        }
    }
}


template <class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CCache<KEY, ARG_KEY, VALUE, ARG_VALUE>::Lookup(ARG_KEY key, VALUE& rValue) const
{
    //
    // Lookup the value in the cache.
    //
    BOOL fRet = CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Lookup(key, rValue);

    if (fRet)
    {
        //
        // Added one to the reference count og the value.
        //
        rValue->AddRef();
    }

    return fRet;
}


template <class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CCache<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
/*++

Note:
    The Critical Section should be held by the caller

--*/
{
    newValue->AddRef();

    //
    // See if the hash table is to be exploded and release old entries
    // as needed.
    //
    if (GetCount() >= (int)GetHashTableSize() << 1)
    {
        ExpireHalfCacheEntries();
    }

    //
    // Add the value to the cache.
    //
    CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(key, newValue);

    if(m_fExpireCacheScheduled)
        return;

    if(m_CacheLifetime == CTimeDuration::MaxValue())
        return;

    ASSERT(GetCount() == 1);

    ExSetTimer(&m_ExpireCacheTimer,  m_CacheLifetime + CACHE_EXPIRATION_GANULARITY);
    m_fExpireCacheScheduled = TRUE;
}


template <class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CCache<KEY, ARG_KEY, VALUE, ARG_VALUE>::TimeToExpireCacheEntries(CTimer* pTimer)
{
    CCache<KEY, ARG_KEY, VALUE, ARG_VALUE>* pCache = 
        CONTAINING_RECORD(pTimer, CCache, m_ExpireCacheTimer);
    pCache->ExpirePeriodicCacheEnteries(pTimer);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\appnotify.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    appNotify.cpp

Abstract:
    Application notification

Author:
    Uri Habusha (urih)

--*/


#include "stdh.h"
#include "Tm.h"
#include "Mtm.h"
#include <qmres.h>

#include "cqmgr.h"
#include "httpaccept.h"

#include "appnotify.tmh"

extern HANDLE g_hAc;
extern HMODULE g_hResourceMod;

static WCHAR *s_FN=L"appnotify";

VOID
AppNotifyTransportClosed(
    LPCWSTR queueUrl
    )
{
    TmTransportClosed(queueUrl);
}


VOID
AppNotifyMulticastTransportClosed(
    MULTICAST_ID id
    )
{
    MtmTransportClosed(id);
}


//
// BUGBUG: temporary code should be move to MC library
//                              Urti Habusha, 21-May-2000
//
const GUID&
McGetMachineID(
    void
    )
{
    return *CQueueMgr::GetQMGuid();
}


void
AppAllocatePacket(
    const QUEUE_FORMAT& destQueue,
    UCHAR delivery,
    DWORD pktSize,
    CACPacketPtrs& pktPtrs
    )
{
    ACPoolType acPoolType = (delivery == MQMSG_DELIVERY_RECOVERABLE) ? ptPersistent : ptReliable;

    HRESULT hr = ACAllocatePacket(
            g_hAc,
            acPoolType,
            pktSize,
            pktPtrs,
            TRUE
            );

    if (SUCCEEDED(hr))
        return;

    DBGMSG((DBGMOD_QM,
            DBGLVL_ERROR,
            _TEXT("No more resources in AC driver. Error %xh"), hr));

    LogHR(hr, s_FN, 10);
	
    throw exception();
}


void
AppFreePacket(
    CACPacketPtrs& pktPtrs
    )
{
    ACFreePacket(g_hAc, pktPtrs.pDriverPacket);
}


void
AppAcceptMulticastPacket(
    const char* httpHeader,
    DWORD bodySize,
    const BYTE* body,
    const QUEUE_FORMAT& destQueue
    )
{
    HttpAccept(httpHeader, bodySize, body, &destQueue);
}



static
void
GetInstanceName(
	LPWSTR instanceName,
	DWORD size,
	...
	)
{
	WCHAR formatIntanceName[256];
	int rc;
	
	rc = LoadString(
			g_hResourceMod,
			IDS_INCOMING_PGM_INSTANCE_NAME,
			formatIntanceName,
			TABLE_SIZE(formatIntanceName)
			);
	
	if (rc == 0)
	{
		return;
	}

    va_list va;
    va_start(va, size);

	rc = FormatMessage(
				FORMAT_MESSAGE_FROM_STRING,
				formatIntanceName,
				IDS_INCOMING_PGM_INSTANCE_NAME,
				0,
				instanceName,
				size,
				&va
				);

	va_end(va);
}


R<ISessionPerfmon>
AppGetIncomingPgmSessionPerfmonCounters(
	LPCWSTR strMulticastId,
	LPCWSTR remoteAddr
	)
{
	WCHAR instanceName[MAX_PATH] = L"" ;
	_snwprintf(instanceName, TABLE_SIZE(instanceName), L"%s", strMulticastId);
	instanceName[MAX_PATH-1] = L'\0' ;

	GetInstanceName(instanceName, TABLE_SIZE(instanceName), strMulticastId,	remoteAddr);

	R<CInPgmSessionPerfmon> p = new CInPgmSessionPerfmon;
	p->CreateInstance(instanceName);
	
	return p;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\admin.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    admin.cpp

Abstract:

	Admin Class implementation.

Author:

	David Reznick (t-davrez)


--*/

#include "stdh.h"
#include "qmres.h"
#include "cqmgr.h"
#include "admcomnd.h"
#include "admutils.h"
#include "admin.h"
#include "cqpriv.h"

#include "admin.tmh"

extern HMODULE   g_hResourceMod;

static WCHAR *s_FN=L"admin";

CCriticalSection g_csReadWriteRequests;

//
// Constructor
//
CAdmin::CAdmin() : m_fReportQueueExists(FALSE),
                   m_fPropagateFlag(DEFAULT_PROPAGATE_FLAG)
{
}


/*====================================================
															
RoutineName
	CAdmin::Init()

Arguments:

Return Value:

=====================================================*/
HRESULT CAdmin::Init()
{
    DWORD dwSize, dwType;
    GUID ReportQueueGuid;
    QUEUE_FORMAT QueueFormat;

    BOOL WINAPI ReceiveAdminCommands(CMessageProperty*, QUEUE_FORMAT*);

    DBGMSG((DBGMOD_QM,DBGLVL_INFO,TEXT("Entering CAdmin::Init")));
		
    HRESULT hR = GetAdminQueueFormat( &QueueFormat);
    if (FAILED(hR))
    {
        DBGMSG((DBGMOD_QM,DBGLVL_ERROR,TEXT("ERROR : CAdmin::Init -> couldn't get Admin-Queue from registry!!!")));
        return LogHR(hR, s_FN, 10);
    }

    //
    // Get the report-queue guid from registry (if one exists)
    //
    dwSize = sizeof(GUID);
    dwType = REG_BINARY;

    LONG iReg = GetFalconKeyValue( REG_REPORTQUEUE,
                                   &dwType,
                                   &ReportQueueGuid,
                                   &dwSize);

    if (iReg == ERROR_SUCCESS)
    {
        m_ReportQueueFormat.PublicID(ReportQueueGuid);
        m_fReportQueueExists = TRUE;
        //
        // Get the propagate flag from the registry (if one exists)
        //
        dwType = REG_DWORD;
        dwSize = sizeof(DWORD);

        iReg = GetFalconKeyValue( REG_PROPAGATEFLAG,
                                  &dwType,
                                  &m_fPropagateFlag,
                                  &dwSize) ;
    }

    //
    // Set the QM's state (Report Or Normal)
    //
    CQueueMgr::SetReportQM(m_fPropagateFlag != 0);

    HRESULT hr2 = QmpOpenAppsReceiveQueue( &QueueFormat, ReceiveAdminCommands );
    return LogHR(hr2, s_FN, 20);
}

/*====================================================
															
RoutineName
	CAdmin::GetReportQueue

Arguments:

Return Value:

=====================================================*/

HRESULT CAdmin::GetReportQueue(QUEUE_FORMAT* pReportQueue)
{
    static BOOL fAfterInit = TRUE;
    DBGMSG((DBGMOD_QM,DBGLVL_INFO,TEXT("Entering CAdmin::GetReportQueue")));

    CS lock(g_csReadWriteRequests);

    if (m_fReportQueueExists)
    {
        if (fAfterInit)
        {
            fAfterInit = FALSE;
            //
            // Check if the queue exist any more
            //
            QueueProps QueueProp;
            HRESULT hr = QmpGetQueueProperties( &m_ReportQueueFormat, &QueueProp, false);

            if (FAILED(hr))
            {
                if (hr != MQ_ERROR_NO_DS)
                {
                    DBGMSG((DBGMOD_QM, 
                            DBGLVL_INFO,
                            TEXT("CAdmin::GetReportQueue : The report queue is not exist")));

                    LogHR(hr, s_FN, 30);

                    m_ReportQueueFormat.UnknownID(0);
                    m_fReportQueueExists = FALSE;
                    hr = DeleteFalconKeyValue(REG_REPORTQUEUE);

                    //
                    // Reset the propagation flag and delete it from registry.
                    //
                    m_fPropagateFlag = DEFAULT_PROPAGATE_FLAG ;
                    CQueueMgr::SetReportQM(m_fPropagateFlag != 0);
                    DeleteFalconKeyValue( REG_PROPAGATEFLAG ) ;
                    return LogHR(MQ_ERROR_QUEUE_NOT_FOUND, s_FN, 35);
                }
                else
                {
                    fAfterInit = TRUE;
                }
            }
            else
            {
                delete QueueProp.pQMGuid;
                delete [] QueueProp.lpwsQueuePathName;
            }
        }

        *pReportQueue = m_ReportQueueFormat;
        return MQ_OK;
    }
    else
    {
        DBGMSG((DBGMOD_QM, DBGLVL_INFO,
        TEXT("CAdmin::GetReportQueue : The report queue is not defined")));
        return LogHR(MQ_ERROR_QUEUE_NOT_FOUND, s_FN, 40);
    }
}

/*====================================================
															
RoutineName
	CAdmin::SetReportQueue

Arguments:

Return Value:

=====================================================*/

HRESULT CAdmin::SetReportQueue(GUID* pReportQueueGuid)
{
    LONG    hr;
    DWORD dwSize = sizeof(GUID);
    DWORD dwType = REG_BINARY;
    HRESULT rc = MQ_OK;

    DBGMSG((DBGMOD_QM,DBGLVL_INFO,TEXT("Entering CAdmin::SetReportQueue")));

    CS lock(g_csReadWriteRequests);

    if (*pReportQueueGuid == GUID_NULL)
    {
        m_ReportQueueFormat.UnknownID(0);
        m_fReportQueueExists = FALSE;
        hr = DeleteFalconKeyValue(REG_REPORTQUEUE);

        //
        // Reset the propagation flag and delete it from registry.
        //
        m_fPropagateFlag = DEFAULT_PROPAGATE_FLAG ;
        CQueueMgr::SetReportQM(m_fPropagateFlag != 0);
        DeleteFalconKeyValue( REG_PROPAGATEFLAG ) ;
    }
    else
    {
        //
        // write report queue's name if registry
        //

        hr = SetFalconKeyValue(REG_REPORTQUEUE,
                               &dwType,
                               pReportQueueGuid,
                               &dwSize);

        if (hr == ERROR_SUCCESS)
        {
            m_ReportQueueFormat.PublicID(*pReportQueueGuid);
            m_fReportQueueExists = TRUE;
        }
        else
        {
            rc = MQ_ERROR;
        }
    }

    return LogHR(rc, s_FN, 50);
}


/*====================================================
															
RoutineName
	CAdmin::SetReportPropagateFlag

Arguments:

Return Value:

=====================================================*/

HRESULT CAdmin::SetReportPropagateFlag(BOOL fReportPropFlag)
{
    LONG rc;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = REG_DWORD;

    DBGMSG((DBGMOD_QM,DBGLVL_INFO,TEXT("Entering CAdmin::SetReportPropagateFlag")));

    rc = SetFalconKeyValue(REG_PROPAGATEFLAG,
                           &dwType,
                           &fReportPropFlag,
                           &dwSize);

    if (rc == ERROR_SUCCESS)
    {
        m_fPropagateFlag = fReportPropFlag;

        //
        // Set the QM's state (Report Or Normal)
        //
        CQueueMgr::SetReportQM(m_fPropagateFlag !=0);
        return(MQ_OK);
    }
    else
    {
        LogNTStatus(rc, s_FN, 60);
        return MQ_ERROR;
    }
}

/*====================================================
															
RoutineName
	CAdmin::SendReport

Arguments:

Return Value:

=====================================================*/

HRESULT CAdmin::SendReport(IN QUEUE_FORMAT* pReportQueue,
                           IN OBJECTID*     pMessageID,
                           IN QUEUE_FORMAT* pTargetQueue,
                           IN LPCWSTR       pwcsNextHop,
                           IN ULONG         ulHopCount)
{
    CString strMsgTitle, strMsgBody, strMsgID, strTargetQueueFormat;

    //
    // translate Message-ID and Target-Queue to string format
    //
    if ( FAILED(GetMsgIdName(pMessageID, strMsgID)) ||
         FAILED(GetFormattedName(pTargetQueue,strTargetQueueFormat)))
    {
        DBGMSG((DBGMOD_QM,DBGLVL_ERROR,TEXT("SendReport : couldn't prepare message")));
        return LogHR(MQ_ERROR, s_FN, 70);
    }

    //
    // Build the Title with a time stamp
    //
    PrepareReportTitle(strMsgTitle, pMessageID, pwcsNextHop, ulHopCount);

    //
    // Build report message body
    //
    strMsgBody += L"<MESSAGE ID>";
    strMsgBody += strMsgID + L"</MESSAGE ID>\n";
    strMsgBody += L"<TARGET QUEUE>";
    strMsgBody += strTargetQueueFormat + L"</TARGET QUEUE>\n";

    if (pwcsNextHop)
    {
        strMsgBody += L"<NEXT HOP>";
        strMsgBody += pwcsNextHop;
        strMsgBody += L"</NEXT HOP>\n";
    }

    //
    // Send report message with report title
    //
    HRESULT hr2 = SendQMAdminMessage(
                           pReportQueue,
                           (LPTSTR)(LPCTSTR)strMsgTitle,
                           (strMsgTitle.GetLength() + 1),
                           (UCHAR*)(LPTSTR)(LPCTSTR)strMsgBody,
                           (strMsgBody.GetLength() + 1) * sizeof(WCHAR),
                           REPORT_MSGS_TIMEOUT); 
    return LogHR(hr2, s_FN, 80);

}

/*====================================================
															
RoutineName
	CAdmin::SendReportConflict

Arguments:

Return Value:

=====================================================*/

HRESULT CAdmin::SendReportConflict(IN QUEUE_FORMAT* pReportQueue,
                                   IN QUEUE_FORMAT* pOriginalReportQueue,
                                   IN OBJECTID*     pMessageID,
                                   IN QUEUE_FORMAT* pTargetQueue,
                                   IN LPCWSTR       pwcsNextHop)
{
	WCHAR szReportTitle[100];

	LoadString(g_hResourceMod, IDS_REPORT_TITLE, szReportTitle, TABLE_SIZE(szReportTitle));
	

    CString strMsgTitle, strMsgBody, strMsgID, strTargetQueueFormat,
            strOriginalQueueFormat;

    //
    // translate Message-ID and Target-Queue to string format
    //
    if ( FAILED(GetMsgIdName(pMessageID, strMsgID)) ||
         FAILED(GetFormattedName(pTargetQueue,strTargetQueueFormat)) ||
         FAILED(GetFormattedName(pOriginalReportQueue,strOriginalQueueFormat)))
    {
        DBGMSG((DBGMOD_QM,DBGLVL_ERROR,TEXT("SendReportConflict : couldn't prepare message")));
        return LogHR(MQ_ERROR, s_FN, 90);
    }

    //
    // Build the Title with a time stamp
    //
    strMsgTitle = szReportTitle;

    //
    // Build report message body
    //
    strMsgBody += L"<ORIGINAL QUEUE>";
    strMsgBody += strOriginalQueueFormat + L"</ORIGINAL QUEUE>\n";
    strMsgBody += L"<MESSAGE ID>";
    strMsgBody += strMsgID + L"</MESSAGE ID>\n";
    strMsgBody += L"<TARGET QUEUE>";
    strMsgBody += strTargetQueueFormat + L"</TARGET QUEUE>\n";

    if (pwcsNextHop)
    {
        strMsgBody += L"<NEXT HOP>";
        strMsgBody += pwcsNextHop;
        strMsgBody += L"</NEXT HOP>\n";
    }

    //
    // Send report message with report title
    //
    HRESULT hr2 = SendQMAdminMessage(
                           pReportQueue,
                           (LPTSTR)(LPCTSTR)strMsgTitle,
                           (strMsgTitle.GetLength() + 1),
                           (UCHAR*)(LPTSTR)(LPCTSTR)strMsgBody,
                           (strMsgBody.GetLength() + 1) * sizeof(WCHAR),
                           REPORT_MSGS_TIMEOUT); 
    return LogHR(hr2, s_FN, 100);

}


/********************************************************************
/      Private Routines of CAdmin Class
/********************************************************************/




/*====================================================
															
RoutineName
	CAdmin::GetAdminQueueFormat()

Arguments:

Return Value:

=====================================================*/

HRESULT CAdmin::GetAdminQueueFormat( QUEUE_FORMAT * pQueueFormat)
{
    extern LPTSTR  g_szMachineName;

    HRESULT rc;

   	DWORD LenMachine = wcslen(g_szMachineName);
	DWORD Length =
			LenMachine +                    // "machineName"
            1 +                             // '\'
			wcslen(ADMIN_QUEUE_NAME) +1;	// "private$\ADMIN_QUEUE$"

	P<WCHAR> lpwFormatName = new WCHAR[Length];

	wcscpy(lpwFormatName,g_szMachineName);
	lpwFormatName[LenMachine] = L'\\';
	wcscpy(lpwFormatName+LenMachine+1,ADMIN_QUEUE_NAME);

    rc = g_QPrivate.QMPrivateQueuePathToQueueFormat(lpwFormatName, pQueueFormat);

    if (FAILED(rc))
    {
        //
        // The ADMIN_QUEUE doesn't exist
        //
        LogHR(rc, s_FN, 110);
        return MQ_ERROR;
    }

    ASSERT((pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_PRIVATE) ||
           (pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_DIRECT));
    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\admutils.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    admutils.h

Abstract:

	headers for QM-Admin utilities (for report-queue handling)

Author:

	David Reznick (t-davrez)  04-13-96


--*/

#define STRING_LONG_SIZE 20
#define STRING_UUID_SIZE 38  // Wide-Characters (includiing - "{}")


HRESULT SendQMAdminResponseMessage(QUEUE_FORMAT* pResponseQueue,
                                   TCHAR* pTitle,
                                   DWORD  dwTitleSize,
                                   QMResponse &Response,
                                   DWORD  dwTimeout,
                                   BOOL   fTrace = FALSE);

HRESULT SendQMAdminMessage(QUEUE_FORMAT* pResponseQueue,
                           TCHAR* pTitle,
                           DWORD  dwTitleSize,
                           UCHAR* puBody,
                           DWORD  dwBodySize,
                           DWORD  dwTimeout,
                           BOOL   fTrace = FALSE,
                           BOOL   fNormalClass = FALSE);

HRESULT GetFormattedName(QUEUE_FORMAT* pTargetQueue,
                         CString&      strTargetQueueFormat);

HRESULT GetMsgIdName(OBJECTID* pObjectID,
                     CString&  strTargetQueueFormat);

void PrepareReportTitle(CString& strMsgTitle, OBJECTID* pMessageID, 
                        LPCWSTR pwcsNextHop, ULONG ulHopCount);
void PrepareTestMsgTitle(CString& strTitle);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\cqpriv.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cqprivate.h

Abstract:

    CQPrivate class definition

Author:

    Uri Habusha (urih)

--*/

#ifndef __QM_CQPRIVATE__
#define __QM_CQPRIVATE__

#include "privque.h"
#include "qformat.h"
#include "qmrt.h"

class CQPrivate{
public:
    CQPrivate();                     // Constructore

    ~CQPrivate();                    // deconstructor

    HRESULT PrivateQueueInit(void);

    HRESULT
	QMSetupCreateSystemQueue(
		IN LPCWSTR lpwcsPathName,
		IN DWORD   dwQueueId
		);


    HRESULT QMCreatePrivateQueue(IN LPCWSTR lpwcsPathName,
                                 IN DWORD  SDSize,
                                 IN PSECURITY_DESCRIPTOR  pSecurityDescriptor,
                                 IN DWORD       cp,
                                 IN PROPID      aProp[],
                                 IN PROPVARIANT apVar[],
                                 IN BOOL        fCheckAccess
                                );

    HRESULT QMGetPrivateQueueProperties(IN  QUEUE_FORMAT* pObjectFormat,
                                        IN  DWORD cp,
                                        IN  PROPID aProp[],
                                        IN  PROPVARIANT apVar[]
                                       );

    HRESULT QMGetPrivateQueuePropertiesInternal(IN  LPCWSTR lpwcsPathName,
                                                IN  DWORD cp,
                                                IN  PROPID aProp[],
                                                IN  PROPVARIANT apVar[]
                                               );

    HRESULT QMGetPrivateQueuePropertiesInternal(IN  DWORD Uniquifier,
                                                IN  DWORD cp,
                                                IN  PROPID aProp[],
                                                IN  PROPVARIANT apVar[]
                                               );

    HRESULT QMDeletePrivateQueue(IN  QUEUE_FORMAT* pObjectFormat);

    HRESULT QMPrivateQueuePathToQueueFormat(IN LPCWSTR lpwcsPathName,
                                            OUT QUEUE_FORMAT *pQueueFormat
                                           );

    HRESULT QMPrivateQueuePathToQueueId(IN LPCWSTR lpwcsPathName,
                                        OUT DWORD* dwQueueId
                                        );

    HRESULT QMSetPrivateQueueProperties(IN  QUEUE_FORMAT* pObjectFormat,
                                        IN  DWORD cp,
                                        IN  PROPID aProp[],
                                        IN  PROPVARIANT apVar[]
                                       );

    HRESULT QMSetPrivateQueuePropertiesInternal(
                        		IN  DWORD  Uniquifier,
                                IN  DWORD  cp,
                                IN  PROPID aProp[],
                                IN  PROPVARIANT apVar[]
                               );

    HRESULT QMGetPrivateQueueSecrity(IN  QUEUE_FORMAT* pObjectFormat,
                                     IN SECURITY_INFORMATION RequestedInformation,
                                     OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
                                     IN DWORD nLength,
                                     OUT LPDWORD lpnLengthNeeded
                                    );

    HRESULT QMSetPrivateQueueSecrity(IN  QUEUE_FORMAT* pObjectFormat,
                                     IN SECURITY_INFORMATION RequestedInformation,
                                     IN PSECURITY_DESCRIPTOR pSecurityDescriptor
                                    );

    HRESULT QMGetFirstPrivateQueuePosition(OUT LPVOID   &pos,
                                           OUT LPCWSTR  &lpszPathName,
                                           OUT DWORD    &dwQueueId
                                          );

    HRESULT QMGetNextPrivateQueue(IN OUT LPVOID   &pos,
                                  OUT    LPCWSTR  &lpszPathName,
                                  OUT    DWORD    &dwQueueId
                                 );

#ifdef _WIN64
    HRESULT QMGetFirstPrivateQueuePositionByDword(OUT DWORD    &dwpos,
                                                  OUT LPCWSTR  &lpszPathName,
                                                  OUT DWORD    &dwQueueId
                                                 );

    HRESULT QMGetNextPrivateQueueByDword(IN OUT DWORD    &dwpos,
                                         OUT    LPCWSTR  &lpszPathName,
                                         OUT    DWORD    &dwQueueId
                                        );
#endif //_WIN64

    BOOL    IsPrivateSysQueue(IN  LPCWSTR lpwcsPathName ) ;

    BOOL    IsPrivateSysQueue(IN  DWORD Uniquifier ) ;

    HRESULT GetPrivateSysQueueProperties(IN  DWORD       cp,
                                         IN  PROPID      aProp[],
                                         IN  PROPVARIANT apVar[] );

    CCriticalSection m_cs;

private:

    void InitDefaultQueueProperties(void);

    HRESULT SetQueueProperties(
                IN LPCWSTR lpwcsPathName,
                IN  PSECURITY_DESCRIPTOR   pSecurityDescriptor,
                IN  DWORD                  cp,
                IN  PROPID                 aProp[],
                IN  PROPVARIANT            apVar[],
                OUT DWORD*                 pcpOut,
                OUT PROPID **              ppOutProp,
                OUT PROPVARIANT **         ppOutPropvariant);

    HRESULT GetNextPrivateQueueId(OUT DWORD* dwQueueId);

    HRESULT RegisterPrivateQueueProperties(IN LPCWSTR lpszPathName,
                                           IN DWORD dwQueueId,
                                           IN BOOLEAN fNewQueue,
                                           IN DWORD cpObject,
                                           IN PROPID pPropObject[],
                                           IN PROPVARIANT pVarObject[]
                                          );

    HRESULT
    GetQueueIdForDirectFormatName(
        LPCWSTR QueueFormatname,
        DWORD* pQueueId
        );

    HRESULT
    GetQueueIdForQueueFormatName(
        const QUEUE_FORMAT* pObjectFormat,
        DWORD* pQueueId
        );

    static HRESULT ValidateProperties(IN DWORD cp,
                                      IN PROPID aProp[]);


    DWORD  m_dwMaxSysQueue ;
    DWORD  m_dwSysQueuePriority ;
    LPWSTR m_lpSysQueueNames[ MAX_SYS_PRIVATE_QUEUE_ID ] ;
};

/*====================================================

CQPrivate::ValidateProperties

   Validate that all the specified properties are allowed to be queried
   by applications via the DS API.

Arguments:

Return Value:


=====================================================*/
inline HRESULT
CQPrivate::ValidateProperties(IN DWORD cp,
                              IN PROPID aProp[])
{
	DWORD i;
	PROPID *pPropID;

	for (i = 0, pPropID = aProp;
		 (i < cp) && !IS_PRIVATE_PROPID(*pPropID);
		 i++, pPropID++)
	{
		NULL;
	}

    if (i < cp) {
        return MQ_ERROR_ILLEGAL_PROPERTY_VT;
    }

    return(MQ_OK);
}

//
// The singleton private queues manager.
//
extern CQPrivate g_QPrivate;

#endif // __QM_CQPRIVATE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\cgroup.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    cgroup.h

Abstract:
    Handle AC group

Author:
    Uri Habusha (urih)

--*/

#ifndef __CQGroup__
#define __CQGroup__

#include <msi.h>
#include <rwlock.h>


class CTransportBase;
class CQueue;
extern CCriticalSection    g_csGroupMgr;

class CQGroup : public IMessagePool
{
   public:
      CQGroup();
      ~CQGroup();

      VOID InitGroup(CTransportBase* pSession, BOOL fPeekByPriority) throw(std::bad_alloc);

      HRESULT CloseGroup(void);
	
      void AddToGroup(CQueue* pQueue) throw();

      R<CQueue> RemoveHeadFromGroup();

      HANDLE  GetGroupHandle() const;

      void EstablishConnectionCompleted(void);

      BOOL IsEmpty(void) const;

   public:
      static void MoveQueueToGroup(CQueue* pQueue, CQGroup* pcgNewGroup);

   public:
        // 
        // Interface function
        //
        void Requeue(CQmPacket* pPacket);
        void EndProcessing(CQmPacket* pPacket);
        void LockMemoryAndDeleteStorage(CQmPacket * pPacket);


        void GetFirstEntry(EXOVERLAPPED* pov, CACPacketPtrs& acPacketPtrs);
        void CancelRequest(void);
		virtual void OnRetryableDeliveryError();
		virtual void OnAbortiveDeliveryError(USHORT DeliveryErrorClass );
		
   private:
   		R<CQueue> RemoveFromGroup(CQueue* pQueue);
		bool DidRetryableDeliveryErrorHappened() const;
	
		void CloseGroupAndMoveQueueToWaitingGroup(R<CQueue>* pWaitingQueues);
		void CloseGroupAndMoveQueueToWaitingGroup(void);
		void CloseGroupAndMoveQueuesToNonActiveGroup(void);

   private:
	   static void AddWaitingQueue(R<CQueue>* pWaitingQueues, DWORD size);


   private:
	  mutable CReadWriteLock m_CloseGroup;  
      HANDLE              m_hGroup;
      CTransportBase*        m_pSession;
      CList<CQueue *, CQueue *&> m_listQueue;
	  bool m_fIsDeliveryOk;
	  USHORT m_DeliveryErrorClass;
};

/*====================================================

Function:      CQGroup::GetGroupHandle

Description:   The routine returns the Group Handle

Arguments:     None

Return Value:  Group Handle

Thread Context:

=====================================================*/

inline HANDLE
CQGroup::GetGroupHandle() const
{
        return(m_hGroup);
}

inline
BOOL 
CQGroup::IsEmpty(
    void
    ) const
{
    return m_listQueue.IsEmpty();
}

#endif __CQGroup__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\cgroup.cpp ===
//++
//
// Copyright (c) 1996 Microsoft Coroporation
//
// Module Name : cgroup.cpp
//
// Abstract    : Handle  AC group
//
// Module Autor: Uri Habusha
//
//--

#include "stdh.h"
#include "cgroup.h"
#include "cqmgr.h"
#include "qmthrd.h"
#include "qmutil.h"
#include "sessmgr.h"
#include <ac.h>

#include "cgroup.tmh"

extern HANDLE g_hAc;
extern CQGroup * g_pgroupNonactive;
extern CQGroup * g_pgroupWaiting;
extern CSessionMgr SessionMgr;
CCriticalSection    g_csGroupMgr;


static WCHAR *s_FN=L"cgroup";

/*======================================================

Function:        CGroup::CGroup

Description:     Constructor.

Arguments:       None

Return Value:    None

Thread Context:

History Change:

========================================================*/
CQGroup::CQGroup():
    m_hGroup(NULL),
    m_pSession(NULL),
	m_fIsDeliveryOk(true),
	m_DeliveryErrorClass(MQMSG_CLASS_NORMAL)
{
}


/*======================================================
Function:        CQGroup::OnRetryableDeliveryError

Description:     Called by mt.lib on retryable delivery error. This call will cause
                 the group to be moved to the wating list on destruction.

Arguments:       None

Return Value:    None
========================================================*/
void CQGroup::OnRetryableDeliveryError()
{
	m_fIsDeliveryOk = false;
}



/*======================================================
Function:        CQGroup::OnAbortiveDeliveryError

Description:     Called by mt.lib on abortive delivery error. This call will cause
                 the group messages in the group to be purged on group close

Arguments:       None

Return Value:    None
========================================================*/
void CQGroup::OnAbortiveDeliveryError(USHORT DeliveryErrorClass)
{
	ASSERT(MQCLASS_NACK_HTTP(DeliveryErrorClass));
	m_fIsDeliveryOk = false;
	m_DeliveryErrorClass =  DeliveryErrorClass;
}




/*======================================================

Function:        CQGroup::~CQGroup()

Description:     Deconstructor.
                 Using when closing a group due a closing of a session. As a result all the queue
                 in the group moving to non-active group and waiting for re-establishing of a
                 session.

Arguments:       None

Return Value:    None

Thread Context:

History Change:

========================================================*/

CQGroup::~CQGroup()
{
	//
	// BUGBUG:
	//		If an exception is raised due to low resource while
	//      moving the queue from one group to another it cause the
	//      the QM to crache. Must use intrusive list instead of MFC list.
	//									Uri Habusha, 16-May-200
	//
    CloseGroup();
}


/*======================================================

Function:        CGroup::InitGroup

Description:     Constructor. Create a group in AC

Arguments:       pSession - Pointer to transport

Return Value:    None. Throws an exception.

Thread Context:

History Change:

========================================================*/
VOID
CQGroup::InitGroup(
    CTransportBase * pSession,
    BOOL             fPeekByPriority
    )
    throw(bad_alloc)
{
   HRESULT rc = ACCreateGroup(&m_hGroup, fPeekByPriority);
   if (FAILED(rc))
   {
       m_hGroup = NULL;
       DBGMSG((DBGMOD_ALL, DBGLVL_ERROR, _T("Failed to create a group, ntstatus 0x%x"), rc));
       LogHR(rc, s_FN, 30);
       throw bad_alloc();
   }

   //
   // Associate the group to completion port
   //
   ExAttachHandle(m_hGroup);

   if (pSession != NULL)
   {
       m_pSession = pSession;
   }

   DBGMSG((DBGMOD_QM, DBGLVL_TRACE, _T("Succeeded to create a group (handle %p) for new session"), m_hGroup));
}


bool CQGroup::DidRetryableDeliveryErrorHappened()  const
{	
	
	return m_DeliveryErrorClass == MQMSG_CLASS_NORMAL;
}


/*======================================================

Function:        CQGroup::CloseGroup()

Description:     This function is used when closing a group due a closing of a session. As a result all the queue
                 in the group moving to non-active group and waiting for re-establishing of a
                 session.

Arguments:       None

Return Value:    None

Thread Context:

History Change:

========================================================*/
HRESULT
CQGroup::CloseGroup(void)
{
	//
	// BUGBUG:
	//		An exception can raise due to low resource while
	//      moving the queue from one group to another. As a result
	//      the qroup will not close properly and no message is sent
	//      on the associated queue. Must use intrusive list instead
	//      of MFC list. (See BUBUG in ~CGroup)
	//									Uri Habusha, 16-May-200
	//

	if (m_fIsDeliveryOk)
	{
		CloseGroupAndMoveQueuesToNonActiveGroup();
	}
	else
	{
		CloseGroupAndMoveQueueToWaitingGroup();
	}

    return LogHR(MQ_OK, s_FN, 20);
}


void CQGroup::CloseGroupAndMoveQueuesToNonActiveGroup(void)
{
    CS lock(g_csGroupMgr);

    POSITION  posInList = m_listQueue.GetHeadPosition();

	while(posInList != NULL)
    {
        //
        // Move the queue from the group to nonactive group
        //
        CQueue* pQueue = m_listQueue.GetNext(posInList);

		pQueue->SetSessionPtr(NULL);
		pQueue->ClearRoutingRetry();
		MoveQueueToGroup(pQueue, g_pgroupNonactive);
	}

    ASSERT(m_listQueue.IsEmpty());

    CancelRequest();
    m_pSession = NULL;
}


void CQGroup::CloseGroupAndMoveQueueToWaitingGroup(R<CQueue>* pWaitingQueues)
{
	CS lock(g_csGroupMgr);

	POSITION  posInList = m_listQueue.GetHeadPosition();
	DWORD index = 0;

	while(posInList != NULL)
	{
		CQueue* pQueue = m_listQueue.GetNext(posInList);
		pWaitingQueues[index++] = SafeAddRef(pQueue);

		pQueue->IncRoutingRetry();
		MoveQueueToGroup(pQueue, g_pgroupWaiting);				
		if(!DidRetryableDeliveryErrorHappened())
		{
			ACPurgeQueue(pQueue->GetQueueHandle(), FALSE, m_DeliveryErrorClass);
 		}
	}

	ASSERT(m_listQueue.IsEmpty());

	CancelRequest();
	m_pSession = NULL;
}


void
CQGroup::AddWaitingQueue(
	R<CQueue>* pWaitingQueues,
	DWORD size
	)
{
	//
	// Move the queue to sessionMgr waiting queue list
	//
	for(;;)
	{
		try
		{
			for(DWORD i = 0; i < size ; ++i)
			{
				if (pWaitingQueues[i].get() == NULL)
					continue;

				SessionMgr.AddWaitingQueue(pWaitingQueues[i].get());
				pWaitingQueues[i].free();
			}
			break;
		}
		catch(const bad_alloc&)
		{
		    DBGMSG((DBGMOD_QM, DBGLVL_ERROR, L"Failed to add queue to sessionMgr waiting queue list due to low resource state. Wait a second and try again"));
			
			Sleep(1000);
		}
	}
}


void CQGroup::CloseGroupAndMoveQueueToWaitingGroup(void)
{
	DWORD size = m_listQueue.GetCount();
	AP< R<CQueue> > pWaitingQueues = new R<CQueue>[size];

	CloseGroupAndMoveQueueToWaitingGroup(pWaitingQueues);
	AddWaitingQueue(pWaitingQueues, size);
}


/*======================================================

Function:        CGroup::AddToGroup

Description:     Add Queue to a group

Arguments:       This function is called when a new queue is opened, a session is created
                 or session is closed. It is used to move queue from one group to another.

Return Value:    qHandle - Handle of the added queue

Thread Context:  None

History Change:

========================================================*/

void CQGroup::AddToGroup(CQueue *pQueue) throw()
{
    CS lock(g_csGroupMgr);


	for(;;)
	{	
		ASSERT(("queue handle can't be invalid", (pQueue->GetQueueHandle() != INVALID_HANDLE_VALUE)));
		ASSERT(("group handle can't be invalid", (m_hGroup != NULL)));

		//
		// Add the queue to AC group
		//
		HRESULT rc = ACMoveQueueToGroup(pQueue->GetQueueHandle(), m_hGroup);
		if (SUCCEEDED(rc))
			break;

		LogHR(rc, s_FN, 991);
		ASSERT(("move queue to group can fail only due to low resource", (rc == STATUS_INSUFFICIENT_RESOURCES)));

        //
        // ISSUE-2001/05/21-urih: catch the critical section for long period. All working thread can be stuck.
        //
		DBGMSG((DBGMOD_QM, DBGLVL_ERROR, L"MQAC Failed to move queue %ls to group. Error 0x%x. Wait a second and try again", pQueue->GetQueueName(), rc));
		Sleep(1000);
	}

    //
    // Add the Handle to group list
    //
	m_listQueue.AddHead(pQueue);
	pQueue->AddRef();

    //
    // Set The group
    //
    pQueue->SetGroup(this);

    //
    // Set The Group Session
    //
    pQueue->SetSessionPtr(m_pSession);

    DBGMSG((DBGMOD_QM, DBGLVL_TRACE, _TEXT("Add Queue: %p to group %p"), pQueue->GetQueueHandle(), m_hGroup));
}


/*======================================================

Function:       CGroup::RemoveFromGroup

Description:    Remove queue from a group
                This function is called when a queue is closed and it
                is used to remove the queue from the current group.

Arguments:      qHandle - an Handle of the removed queue

Return Value:   The removed queue or null if not found

Thread Context:

History Change:

========================================================*/

R<CQueue> CQGroup::RemoveFromGroup(CQueue* pQueue)
{
   POSITION posInList;

   CS lock(g_csGroupMgr);

   posInList = m_listQueue.Find(pQueue, NULL);
   if (posInList == NULL)
        return 0;

   m_listQueue.RemoveAt(posInList);
   pQueue->SetGroup(NULL);
   pQueue->SetSessionPtr(NULL);



   return pQueue;
}

/*====================================================

Function:      CQGroup::MoveQueueToGroup

Description:   Move the queue from current group to another group

Arguments:     None

Return Value:  pointer to cqueue object

Thread Context:

=====================================================*/
void CQGroup::MoveQueueToGroup(CQueue* pQueue, CQGroup* pcgNewGroup)
{
    CS lock(g_csGroupMgr);

    CQGroup* pcgOwner = pQueue->GetGroup();
    if ((pcgOwner == NULL) || (pcgOwner == pcgNewGroup))
    {
        return;
    }

	R<CQueue> Queue = pcgOwner->RemoveFromGroup(pQueue);
    ASSERT(Queue.get() != NULL);

    if (pcgNewGroup)
    {
        pcgNewGroup->AddToGroup(pQueue);
    }
}

/*====================================================

Function:      CQGroup::RemoveHeadFromGroup

Description:

Arguments:     None

Return Value:  pointer to cqueue object

Thread Context:

=====================================================*/

R<CQueue>  CQGroup::RemoveHeadFromGroup()
{
   CS  lock(g_csGroupMgr);
   CQueue* pQueue = NULL ;

   if (! m_listQueue.IsEmpty())
   {
       pQueue = m_listQueue.GetHead() ;
       R<CQueue> Queue = RemoveFromGroup(pQueue);
       ASSERT(Queue.get() != NULL);
	   return Queue;
   }
   return NULL;
}

/*======================================================

Function:        CQGroup::EstablishConnectionCompleted()

Description:     This function is used when the session is establish. It marks the queues
                 in the group as active.

Arguments:       None

Return Value:    None

Thread Context:

History Change:

========================================================*/
void
CQGroup::EstablishConnectionCompleted(void)
{
    CS          lock(g_csGroupMgr);

    POSITION    posInList;
    CQueue*     pQueue;

    //
    // Check if there are any queue in the group
    //
    if (! m_listQueue.IsEmpty())
    {
        posInList = m_listQueue.GetHeadPosition();
        while (posInList != NULL)
        {
            //
            // the session becomes active. Clear the retry field in queue object
            //
            pQueue = m_listQueue.GetNext(posInList);

#ifdef _DEBUG
            if (pQueue->GetRoutingRetry() > 1)
            {
                //
                // print report message if we recover from a reported problem
                //
		        DBGMSG((DBGMOD_ALL,
				        DBGLVL_ERROR,
						_TEXT("The message was successfully routed to queue %ls"),
						pQueue->GetQueueName()));
            }
#endif
            pQueue->ClearRoutingRetry();
        }
    }

    DBGMSG((DBGMOD_QM,
            DBGLVL_TRACE,
            _TEXT("Mark all the queues in  group %p as active"), m_hGroup));
 }


void
CQGroup::Requeue(
    CQmPacket* pPacket
    )
{
    //
    // Get destination queue. Using for finding the CQueue object
    //
    QUEUE_FORMAT DestinationQueue;
    CQueue* pQueue;

    pPacket->GetDestinationQueue(&DestinationQueue);
	QUEUE_FORMAT_TRANSLATOR RealDestinationQueue(&DestinationQueue);
    BOOL f = QueueMgr.LookUpQueue(RealDestinationQueue.get(), &pQueue, false, false);
	DBG_USED(f);

    R<CQueue> Ref = pQueue;

    //
    // the queue must be record in hash table since it must be opened
    // before sending. If the queue doesn't exist it is internal error.
    //
    ASSERT(f);
    ASSERT(pQueue != NULL);
    ASSERT(pQueue->GetGroup() == this);

    pQueue->Requeue(pPacket);
}


void
CQGroup::EndProcessing(
    CQmPacket* pPacket
    )
{
    ACFreePacket(g_hAc, pPacket->GetPointerToDriverPacket());
}


void
CQGroup::LockMemoryAndDeleteStorage(
    CQmPacket* pPacket
    )
{
    //
    // Construct CACPacketPtrs
    //
    CACPacketPtrs pp;
    pp.pPacket = NULL;
    pp.pDriverPacket = pPacket->GetPointerToDriverPacket();
    ASSERT(pp.pDriverPacket != NULL);

    //
    // Lock the packet mapping to QM address space (by add ref it)
    //
    ACGetPacketByCookie(g_hAc, &pp);

    //
    // Delete the packet from disk. It is still mapped to QM process address space.
    //
    ACFreePacket2(g_hAc, pPacket->GetPointerToDriverPacket());
}


void
CQGroup::GetFirstEntry(
    EXOVERLAPPED* pov,
    CACPacketPtrs& acPacketPtrs
    )
{
	CSR readlock(m_CloseGroup);

    acPacketPtrs.pPacket = NULL;
    acPacketPtrs.pDriverPacket = NULL;

	//
	// If group was closed just before
	//
	if(m_hGroup == NULL)
	{
		throw exception();
	}

    //
    // Create new GetPacket request from the queue
    //
    HRESULT rc = ACGetPacket(
                    GetGroupHandle(),
                    acPacketPtrs,
                    pov
                    );

    if (FAILED(rc) )
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, L"Failed to  generate get request from group. Error %x", rc));
        LogHR(rc, s_FN, 40);
        throw exception();
    }
		
}

void CQGroup::CancelRequest(void)
{
	CSW writelock(m_CloseGroup);

    HANDLE hGroup = InterlockedExchangePointer(&m_hGroup, NULL);

    if (hGroup == NULL)
        return;


    HRESULT rc = ACCloseHandle(hGroup);
    ASSERT(SUCCEEDED(rc));
	DBG_USED(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\cqpriv.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cqpriv.cpp

Abstract:

    This module implements QM Private queue

Author:

    Uri Habusha (urih)

--*/

#include "stdh.h"
#include <Msm.h>
#include <mqexception.h>
#include "cqpriv.h"
#include "cqmgr.h"
#include "_mqdef.h"
#include <mqsec.h>
#include "regqueue.h"
#include "mqutil.h"
#include "lqs.h"

#include "cqpriv.tmh"

extern LPWSTR  g_szMachineName;
extern BOOL g_fWorkGroupInstallation;

static WCHAR g_nullLable[2] = L"";

static PROPID g_propidQueue [] = {
                PROPID_Q_LABEL,
                PROPID_Q_TYPE,
                PROPID_Q_PATHNAME,
                PROPID_Q_JOURNAL,
                PROPID_Q_QUOTA,
                PROPID_Q_SECURITY,
                PROPID_Q_JOURNAL_QUOTA,
                PROPID_Q_CREATE_TIME,
                PROPID_Q_BASEPRIORITY,
                PROPID_Q_MODIFY_TIME,
                PROPID_Q_AUTHENTICATE,
                PROPID_Q_PRIV_LEVEL,
                PROPID_Q_TRANSACTION,
                PPROPID_Q_SYSTEMQUEUE,
                PROPID_Q_MULTICAST_ADDRESS
                };

#define NPROPS (sizeof(g_propidQueue)/sizeof(PROPID))

static PROPVARIANT g_propvariantQueue[NPROPS];

static DWORD g_QueueSecurityDescriptorIndex;
static DWORD g_QueueCreateTimeIndex;
static DWORD g_QueueModifyTimeIndex;

CQPrivate g_QPrivate;

static WCHAR *s_FN=L"cqpriv";

//
// PROPERTY_MAP is a class that mapps from the property id to it's index in
// propvariants array.
//
class PROPERTY_MAP
{
public:
    PROPERTY_MAP(PROPID *, DWORD);
    ~PROPERTY_MAP();
    int operator [](PROPID);

private:
    PROPID m_propidMax;
    PROPID m_propidMin;
    int *m_pMap;
};

PROPERTY_MAP::PROPERTY_MAP(PROPID *aProps, DWORD cProps)
{
    DWORD i;

    m_pMap = NULL;

    if (!cProps)
    {
        return;
    }

    //
    // Find the maximum and minimum values of the propery IDs
    //
    for (i = 1, m_propidMax = aProps[0], m_propidMin = aProps[0];
         i < cProps;
         i++)
    {
        if (m_propidMax < aProps[i])
        {
            m_propidMax = aProps[i];
        }

        if (m_propidMin > aProps[i])
        {
            m_propidMin = aProps[i];
        }
    }

    //
    // Allocate memory for the map.
    //
    m_pMap = new int[m_propidMax - m_propidMin + 1];

    //
    // Fill the entier map with -1s. Property IDs that does not exist will
    // result in a -1.
    //
    for (i = 0; i < m_propidMax - m_propidMin + 1; i++)
    {
        m_pMap[i] = -1;
    }

    //
    // Fill the map with the indesis of the property IDs.
    //
    for (i = 0; i < cProps; i++)
    {
        m_pMap[aProps[i] - m_propidMin] = i;
    }
}

PROPERTY_MAP::~PROPERTY_MAP()
{
    delete[] m_pMap;
}

int PROPERTY_MAP::operator[] (PROPID PropId)
{
    if ((PropId > m_propidMax) || (PropId < m_propidMin))
    {
        //
        // Out of range.
        //
        return -1;
    }

    return m_pMap[PropId - m_propidMin];
}


static PROPERTY_MAP g_mapQueuePropertyToIndex(g_propidQueue, NPROPS);

/*====================================================

CQPrivate::IsLocalPrivateQueue

Arguments:

Return Value:


=====================================================*/
inline BOOL IsLocalPrivateQueue(IN const QUEUE_FORMAT* pQueueFormat)
{
    switch (pQueueFormat->GetType())
    {
        case QUEUE_FORMAT_TYPE_DIRECT:
            //
            // We never call it in the receive pass (YoelA, 6-Aug-2000)
            //
            return IsLocalDirectQueue(pQueueFormat, false);

        case QUEUE_FORMAT_TYPE_PRIVATE:
            return QmpIsLocalMachine(&pQueueFormat->PrivateID().Lineage);

    }

    return FALSE;
}


inline
void
ReplaceDNSNameWithNetBiosName(
    LPCWSTR PathName,
    LPWSTR ReplaceName
    )
{
    //
    // We want to keep the queue with a single name representation. Replace the
    // DNS name with a NetBios Name
    //
    LPWSTR FirstSlash = wcschr(PathName,L'\\');
    ASSERT(FirstSlash != NULL);
	
    wcscpy(ReplaceName, g_szMachineName);
    wcscat(ReplaceName, FirstSlash);
}


/*====================================================

CQPrivate::CQPrivate

Arguments:

Return Value:

=====================================================*/

CQPrivate::CQPrivate()
{
   m_dwMaxSysQueue = 0 ;
}

/*====================================================

CQPrivate::~CQPrivate

Arguments:

Return Value:


=====================================================*/
CQPrivate::~CQPrivate()
{
}

/*====================================================

CQPrivate::QMSetupCreateSystemQueue

Arguments:

Return Value:


=====================================================*/
HRESULT
CQPrivate::QMSetupCreateSystemQueue(
	IN LPCWSTR lpwcsPathName,
	IN DWORD   dwQueueId
	)
{

    //
    // Object not initialized yet
    //
    ASSERT(m_dwMaxSysQueue != 0);

	if(g_szMachineName == NULL)
	{

		//
		// This routine is called by setup only
		// and g_szMachineName is not initialized yet.
		// So, take the machine name from the queue pathname
		//
		g_szMachineName = new WCHAR[lstrlen(lpwcsPathName) + 1];
		wcscpy(g_szMachineName, lpwcsPathName);
		LPWSTR pSlash = wcschr(g_szMachineName,L'\\');
		ASSERT(pSlash);
		*pSlash = 0;
	}

    HRESULT rc;

    DBGMSG((DBGMOD_QM, DBGLVL_TRACE, TEXT(" MQSetupCreatePrivateQueue - Queue Path name: %ls"), lpwcsPathName));

    //
    // Set default values for all the queue properties
    // that were not provided by the caller
    //
    DWORD cpObject;
    PROPID* pPropObject;
    AP<PROPVARIANT> pVarObject;
    P<VOID> pSecurityDescriptor;
    P<VOID> pSysSecurityDescriptor;
    P<ACL> pDacl;

    //
    // Set the queue's DACL so that the local administrators group
    // will have full control over the queue, except for delete access right.
	// Everyone will have the Generic write (send, get).
	// Anonymous will have only write message (send) access.
    //
    pSysSecurityDescriptor = new SECURITY_DESCRIPTOR;
    InitializeSecurityDescriptor(
			pSysSecurityDescriptor,
			SECURITY_DESCRIPTOR_REVISION
			);

    PSID pAdminSid;
    DWORD dwDaclSize;
    SID_IDENTIFIER_AUTHORITY NtSecAuth = SECURITY_NT_AUTHORITY;

    //
    // Create the SID for the local administrators group.
    //
    AllocateAndInitializeSid(
        &NtSecAuth,
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS,
        0,
        0,
        0,
        0,
        0,
        0,
        &pAdminSid
		);

	PSID pAnonymousSid = MQSec_GetAnonymousSid();
	ASSERT((pAnonymousSid != NULL) && IsValidSid(pAnonymousSid));

    //
    // Calculate the required DACL size and allocate it.
    //
    dwDaclSize = sizeof(ACL) +
                 3 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                 GetLengthSid(pAdminSid) +
				 GetLengthSid(g_pWorldSid) +
				 GetLengthSid(pAnonymousSid);

    pDacl = (PACL)(char*) new BYTE[dwDaclSize];

    //
    // Initialize the DACL and fill it with the two ACEs
    //
    InitializeAcl(pDacl, dwDaclSize, ACL_REVISION);
    BOOL fSuccess = AddAccessAllowedAce(
						pDacl,
						ACL_REVISION,
						MQSEC_QUEUE_GENERIC_WRITE,
						g_pWorldSid
						);

	ASSERT(fSuccess);

    fSuccess = AddAccessAllowedAce(
					pDacl,
					ACL_REVISION,
					MQSEC_QUEUE_GENERIC_ALL & ~MQSEC_DELETE_QUEUE,
					pAdminSid
					);

	ASSERT(fSuccess);

    fSuccess = AddAccessAllowedAce(
					pDacl,
					ACL_REVISION,
					MQSEC_WRITE_MESSAGE,
					pAnonymousSid
					);

	ASSERT(fSuccess);

    SetSecurityDescriptorDacl(pSysSecurityDescriptor, TRUE, pDacl, FALSE);

    FreeSid(pAdminSid);

    //
    // Create a default security descriptor.
    //
    HRESULT hr = MQSec_GetDefaultSecDescriptor(
						MQDS_QUEUE,
						&pSecurityDescriptor,
						FALSE, // fImpersonate
						pSysSecurityDescriptor,
						0,     // seInfoToRemove
						e_UseDefaultDacl
						);
    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 20);
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }

    rc = SetQueueProperties(
				lpwcsPathName,
				pSecurityDescriptor,
				0,
				NULL,
				NULL,
				&cpObject,
				&pPropObject,
				&pVarObject
				);

    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 30);
    }
    //
    // Set Path Name + queue name
    //
    LPTSTR lpszQueueName;

    lpszQueueName = _tcschr(lpwcsPathName,TEXT('\\'));
    if (lpszQueueName++ == NULL)
	{
        return LogHR(MQ_ERROR, s_FN, 40);
    }

    pVarObject[g_mapQueuePropertyToIndex[PROPID_Q_PATHNAME]].pwszVal =  (LPTSTR)lpwcsPathName;
    pVarObject[g_mapQueuePropertyToIndex[PROPID_Q_LABEL]].pwszVal = lpszQueueName;
    pVarObject[g_mapQueuePropertyToIndex[PPROPID_Q_SYSTEMQUEUE]].bVal = true;

	//
	// Set system queues to max priority.
	//
	pVarObject[g_mapQueuePropertyToIndex[PROPID_Q_BASEPRIORITY]].lVal =  DEFAULT_SYS_Q_BASEPRIORITY ;

    rc = RegisterPrivateQueueProperties(
			lpwcsPathName,
			dwQueueId,
			TRUE,
			cpObject,
			pPropObject,
			pVarObject
			);

    if (SUCCEEDED(rc))
    {
       //
       // try to open the queue. If file is not valid (e.g., because
       // disk is full) then LQSOpen fail and delete the file.
       //
       CHLQS hLQS;
       rc = LQSOpen(lpwcsPathName, &hLQS, NULL);
    }

    return LogHR(rc, s_FN, 45);
}

/*====================================================

CQPrivate::QMCreatePrivateQueue

Arguments:

Return Value:


=====================================================*/
HRESULT
CQPrivate::QMCreatePrivateQueue(LPCWSTR lpwcsPathName,
                                DWORD  SDSize,
                                PSECURITY_DESCRIPTOR  pSecurityDescriptor,
                                DWORD       cp,
                                PROPID      aProp[],
                                PROPVARIANT apVar[],
                                BOOL        fCheckAccess
                               )
{
    HRESULT rc;

    DBGMSG((DBGMOD_QM,
            DBGLVL_TRACE,
            TEXT(" MQDSCreatePrivateQueue - Queue Path name: %ls"), lpwcsPathName));

    //
    // Check that it is local machine
    //
    BOOL fDNSName;
    BOOL fLocalMachine = IsPathnameForLocalMachine(lpwcsPathName, &fDNSName);
    if (!fLocalMachine)
	    return LogHR(MQ_ERROR_ILLEGAL_QUEUE_PATHNAME, s_FN, 50);

    WCHAR QueuePathName[MAX_COMPUTERNAME_LENGTH + MQ_MAX_Q_NAME_LEN + 2];
    if (fDNSName)
    {
        ReplaceDNSNameWithNetBiosName(lpwcsPathName, QueuePathName);
        lpwcsPathName = QueuePathName;
    }

    if (fCheckAccess)
    {
        //
        // Verify the the user has access rights to create a private queue.
        //
        rc = CheckPrivateQueueCreateAccess();
        if (FAILED(rc))
        {
            return LogHR(rc, s_FN, 60);
        }
    }

    //
    // Try to open the queue, if we succeed, it means that the queue
    // already exist.
    //
    CHLQS hLQS;
    rc = LQSOpen(lpwcsPathName, &hLQS, NULL);
    if (SUCCEEDED(rc))
    {
        return LogHR(MQ_ERROR_QUEUE_EXISTS, s_FN, 70);
    }

    //
    // Set default values for all the queue properties
    // that were not provided by the caller
    //
    DWORD cpObject;
    PROPID* pPropObject;
    AP<PROPVARIANT> pVarObject;
    P<VOID> pDefaultSecurityDescriptor ;

    //
    // Fill with default vaules any missing part of the security descriptor.
    //
    HRESULT hr = MQSec_GetDefaultSecDescriptor(
                                              MQDS_QUEUE,
                                             &pDefaultSecurityDescriptor,
                                              TRUE, // fImpersonate
                                              pSecurityDescriptor,
                                              0,    // seInfoToRemove
                                              e_UseDefaultDacl ) ;
    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 80);
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }

    pSecurityDescriptor = pDefaultSecurityDescriptor;


    rc = SetQueueProperties(lpwcsPathName,
                            pSecurityDescriptor,
                            cp,
                            aProp,
                            apVar,
                            &cpObject,
                            &pPropObject,
                            &pVarObject
                           );

    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 90);
    }

    DWORD dwQueueId;

    rc = GetNextPrivateQueueId(&dwQueueId);
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 100);
    }

    rc = RegisterPrivateQueueProperties(lpwcsPathName,
                                        dwQueueId,
                                        TRUE,
                                        cpObject,
                                        pPropObject,
                                        pVarObject);

    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 110);
    }

    //
    // try to open the queue. If file is not valid (e.g., because
    // disk is full) then LQSOpen fail and delete the file.
    //
    rc = LQSOpen(lpwcsPathName, &hLQS, NULL);
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 111);
    }

    //
    // Notify the queue manager about properties changes.
    // Build the queue format as private queue type, since bind/unbind
    // to multicast group is done only for private or public queues (not direct).
    //
    QUEUE_FORMAT qf(*QueueMgr.GetQMGuid(), dwQueueId);
    QueueMgr.UpdateQueueProperties(&qf, cp, aProp, apVar);

    return rc;
}

/*====================================================

CQPrivate::QMGetPrivateQueueProperties

Arguments:

Return Value:


=====================================================*/
HRESULT
CQPrivate::QMGetPrivateQueuePropertiesInternal(IN  LPCWSTR lpwcsPathName,
                                               IN  DWORD cp,
                                               IN  PROPID aProp[],
                                               IN  PROPVARIANT apVar[]
                                            )
{
    HRESULT rc;
    CHLQS hLQS;

    DBGMSG((DBGMOD_QM,
            DBGLVL_TRACE,
            TEXT(" QMGetPrivateQueueProperties - Queue Path name: %ls"), lpwcsPathName));

    rc = LQSOpen(lpwcsPathName, &hLQS, NULL);
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 120);
    }

    rc = LQSGetProperties(hLQS, cp, aProp, apVar);
    return LogHR(rc, s_FN, 130);

}

/*====================================================

CQPrivate::QMGetPrivateQueueProperties

Arguments:

Return Value:


=====================================================*/
HRESULT
CQPrivate::QMGetPrivateQueueProperties(IN  QUEUE_FORMAT* pQueueFormat,
                                       IN  DWORD cp,
                                       IN  PROPID aProp[],
                                       IN  PROPVARIANT apVar[]
                                      )
{
    HRESULT rc;

    ASSERT(pQueueFormat != NULL);

    rc = ValidateProperties(cp, aProp);
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 150);
    }

    DWORD QueueId;
    rc = GetQueueIdForQueueFormatName(pQueueFormat, &QueueId);
    if (FAILED(rc))
        return LogHR(rc, s_FN, 160);

    //
    // Verify that the user has access rights to get the queue properties.
    //
    CQMSecureablePrivateObject QSec(eQUEUE, QueueId);
    rc = QSec.AccessCheck(MQSEC_GET_QUEUE_PROPERTIES);
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 170);
    }

    HRESULT hr2 = QMGetPrivateQueuePropertiesInternal(QueueId,
                                               cp,
                                               aProp,
                                               apVar
                                              );
    return LogHR(hr2, s_FN, 175);
}

/*====================================================

CQPrivate::QMGetPrivateQueuePropertiesInternal

Arguments:

Return Value:

=====================================================*/
HRESULT
CQPrivate::QMGetPrivateQueuePropertiesInternal(IN  DWORD       Uniquifier,
                                               IN  DWORD       cp,
                                               IN  PROPID      aProp[],
                                               IN  PROPVARIANT apVar[]
                                              )
{
    HRESULT rc;

    //
    //  Clear all the pointers of VT_NULL variants
    //
    for ( DWORD i = 0; i < cp ; i++)
    {
        if (apVar[i].vt == VT_NULL)
        {
            memset( &apVar[i].caub, 0, sizeof(CAUB));
        }
    }

    CHLQS hLQS;

    rc = LQSOpen(Uniquifier, &hLQS, NULL);
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 180);
    }

    HRESULT hr2 = LQSGetProperties(hLQS, cp, aProp, apVar);
    return LogHR(hr2, s_FN, 190);
}

/*====================================================

CQPrivate::QMDeletePrivateQueue

Arguments:

Return Value:


=====================================================*/
HRESULT
CQPrivate::QMDeletePrivateQueue(IN  QUEUE_FORMAT* pQueueFormat)
{
    HRESULT rc;

    ASSERT(pQueueFormat != NULL);

    DWORD QueueId;
    rc = GetQueueIdForQueueFormatName(pQueueFormat, &QueueId);
    if (FAILED(rc))
        return LogHR(rc, s_FN, 200);

    //
    // Verify that the user has access rights to delete the queue.
    //
    CQMSecureablePrivateObject QSec(eQUEUE, QueueId);
    rc = QSec.AccessCheck(MQSEC_DELETE_QUEUE);
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 210);
    }

    //
    // Generate context to allow deleting key in a critical section
    //
    {
        //
        // lock before changing the map - to allow safe reading of the map.
        //
        CS lock(m_cs);
        CQueue* pQueue;

        if (QueueMgr.LookUpQueue(pQueueFormat, &pQueue, false, false))
        {
            //
            // Mark the queue as invalid
            //
            pQueue->SetQueueNotValid();
            pQueue->Release();
       }

    }

    HRESULT hr2 = LQSDelete(QueueId);
    if (FAILED(hr2))
    {
        return LogHR(hr2, s_FN, 220);
    }

    QUEUE_FORMAT qf(*QueueMgr.GetQMGuid(), QueueId);
    MsmUnbind(qf);

    return hr2;
}

/*====================================================

CQPrivate::QMPrivateQueuePathToQueueFormat

Arguments:

Return Value:


=====================================================*/
HRESULT
CQPrivate::QMPrivateQueuePathToQueueFormat(
    LPCWSTR lpwcsPathName,
    QUEUE_FORMAT* pQueueFormat
    )
{
    DWORD dwQueueId;
    HRESULT rc;

    if (g_fWorkGroupInstallation)
    {
        //
        // if the machine is MSMQ workgroup machine, the routine returns
        // direct format name. This is use to enables the application to pass
        // the queue as a response queue, or admin queue
        //
        DWORD size = FN_DIRECT_OS_TOKEN_LEN + 1 + wcslen(lpwcsPathName)+1;
        AP<WCHAR> pQueueFormatName = new WCHAR[size];
        swprintf(pQueueFormatName, L"%s%s", FN_DIRECT_OS_TOKEN, lpwcsPathName);
        //
        //  verify validity of local queue
        //
        DWORD dwTmp;
        rc = QMPrivateQueuePathToQueueId(lpwcsPathName, &dwTmp);
        if (FAILED(rc))
        {
            return LogHR(rc, s_FN, 230);
        }
        pQueueFormat->DirectID(pQueueFormatName.detach());
        return MQ_OK;
    }

    AP<WCHAR> lpwcsQueueName = new WCHAR[wcslen(lpwcsPathName)+1];

    wcscpy(lpwcsQueueName, lpwcsPathName);
    CharLower(lpwcsQueueName);

    rc = QMPrivateQueuePathToQueueId(lpwcsPathName, &dwQueueId);
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 240);
    }

    pQueueFormat->PrivateID(*CQueueMgr::GetQMGuid(), dwQueueId);

    return(MQ_OK);
}

/*====================================================

QmpPrepareSetPrivateQueueProperties

Arguments:

Return Value:

=====================================================*/
static
HRESULT
QmpPrepareSetPrivateQueueProperties(
    HLQS          hLqs,
    DWORD         cProps,
    PROPID        aProp[],
    PROPVARIANT   aVar[],
    DWORD *       pcProps1,
    PROPID *      paProp1[],
    PROPVARIANT * paVar1[]
    )
{
    //
    // Query LQS if queue is transactional
    //
    PROPID aPropXact[1];
    PROPVARIANT aVarXact[1];
    aPropXact[0] = PROPID_Q_TRANSACTION;
    aVarXact[0].vt = VT_UI1;

    HRESULT rc = LQSGetProperties(hLqs, 1, aPropXact, aVarXact);
    if (FAILED(rc))
    {
        return rc;
    }

    //
    // Allocate new structures
    //
    DWORD cProps1 = cProps + 1;
    AP<PROPID> aProp1;
    AP<PROPVARIANT> aVar1;

    try
    {
        aProp1 = new PROPID[cProps1];
        aVar1  = new PROPVARIANT[cProps1];
    }
    catch (const std::exception&)
    {
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }

    //
    // Copy the transactional property to the allocated structures
    //
    aProp1[0] = aPropXact[0];
    aVar1[0]  = aVarXact[0];

    //
    // Copy the original properties to the allocated structures
    //
    for (DWORD ix = 0; ix < cProps; ++ix)
    {
        aProp1[ix + 1] = aProp[ix];
        aVar1[ix + 1]  = aVar[ix];
    }

    //
    // Assign allocated structures to the out parameters and detach
    //
    (*pcProps1) = cProps1;
    (*paProp1) = aProp1.detach();
    (*paVar1)  = aVar1.detach();

    return MQ_OK;
}

/*====================================================

QMSetPrivateQueueProperties

Arguments:

Return Value:


=====================================================*/
HRESULT
CQPrivate::QMSetPrivateQueueProperties(
    IN  QUEUE_FORMAT* pQueueFormat,
    IN  DWORD cp,
    IN  PROPID aProp[],
    IN  PROPVARIANT apVar[]
    )
{
    HRESULT rc;

    ASSERT(pQueueFormat != NULL);

    rc = ValidateProperties(cp, aProp);
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 250);
    }

    DWORD QueueId;
    rc = GetQueueIdForQueueFormatName(pQueueFormat, &QueueId);
    if (FAILED(rc))
        return LogHR(rc, s_FN, 260);

    //
    // Verify that the user has access rights to set the queue props.
    //
    CQMSecureablePrivateObject QSec(eQUEUE, QueueId);
    rc = QSec.AccessCheck(MQSEC_SET_QUEUE_PROPERTIES);
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 270);
    }

    //
    // Windows bug 580512.
    // Moved most code to the "internal" method and call it.
    //
    rc = QMSetPrivateQueuePropertiesInternal( QueueId,
                    	                      cp,
                    	                      aProp,
                    	                      apVar
                                        	) ;
    return LogHR(rc, s_FN, 290);
}

/*====================================================

QMSetPrivateQueuePropertiesInternal

Arguments:

Return Value:

=====================================================*/

HRESULT
CQPrivate::QMSetPrivateQueuePropertiesInternal(
                    	IN  DWORD       Uniquifier,
                    	IN  DWORD       cp,
                    	IN  PROPID      aProp[],
                    	IN  PROPVARIANT apVar[]
                    	)
{
    HRESULT rc;
    CHLQS hLQS;

    rc = LQSOpen(Uniquifier, &hLQS, NULL);
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 780);
    }

    //
    // UpdateQueueProperties() needs to know if queue is transactional,
    // so handle allocations and preparation that can fail before calling it.
    //
    AP<PROPID> aProp1;
    AP<PROPVARIANT> aVar1;
    ULONG cProps1;

    rc = QmpPrepareSetPrivateQueueProperties( hLQS,
                                              cp,
                                              aProp,
                                              apVar,
                                             &cProps1,
                                             &aProp1,
                                             &aVar1 ) ;
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 790);
    }

    rc = LQSSetProperties(hLQS, cp, aProp, apVar);
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 800);
    }

    //
    // Build the queue format as private queue type, since bind/unbind
    // to multicast group is done only for private or public queues (not direct).
    //
    QUEUE_FORMAT qf(*QueueMgr.GetQMGuid(), Uniquifier);
    QueueMgr.UpdateQueueProperties(&qf, cProps1, aProp1 ,aVar1);

    return LogHR(rc, s_FN, 300);
}

/*====================================================

CQPrivate::QMGetPrivateQueueSecrity

Arguments:

Return Value:


=====================================================*/
HRESULT
CQPrivate::QMGetPrivateQueueSecrity(IN  QUEUE_FORMAT* pQueueFormat,
                                    IN SECURITY_INFORMATION RequestedInformation,
                                    OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
                                    IN DWORD nLength,
                                    OUT LPDWORD lpnLengthNeeded
                                   )
{
    ASSERT(pQueueFormat != NULL);

    HRESULT hr;
    DWORD QueueId;
    hr = GetQueueIdForQueueFormatName(pQueueFormat, &QueueId);
    if (FAILED(hr))
        return LogHR(hr, s_FN, 310);

    //
    // Verify that the user has access rights to get the queue security.
    //
    CQMSecureablePrivateObject QSec(eQUEUE,
                                    QueueId);

    hr = QSec.GetSD(RequestedInformation,
                    pSecurityDescriptor,
                    nLength,
                    lpnLengthNeeded);
    return LogHR(hr, s_FN, 320);
}

/*====================================================

CQPrivate::QMSetPrivateQueueSecrity

Arguments:

Return Value:


=====================================================*/
HRESULT
CQPrivate::QMSetPrivateQueueSecrity(IN  QUEUE_FORMAT* pQueueFormat,
                                    IN SECURITY_INFORMATION RequestedInformation,
                                    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
                                   )
{
    HRESULT hr;

    ASSERT(pQueueFormat != NULL);

    DWORD QueueId;
    hr = GetQueueIdForQueueFormatName(pQueueFormat, &QueueId);
    if (FAILED(hr))
        return LogHR(hr, s_FN, 330);

    //
    // Verify that the user has access rights to set the queue security.
    //
    CQMSecureablePrivateObject QSec(eQUEUE, QueueId);

    hr = QSec.SetSD(RequestedInformation, pSecurityDescriptor);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 340);
    }

    hr = QSec.Store() ;
    return LogHR(hr, s_FN, 350);
}

/*====================================================

CQPrivate::RegisterPrivateQueueProperties

Arguments:

Return Value:


=====================================================*/
HRESULT
CQPrivate::RegisterPrivateQueueProperties(IN LPCWSTR lpszQueuePathName,
                                          IN DWORD dwQueueId,
                                          IN BOOLEAN fNewQueue,
                                          IN DWORD cpObject,
                                          IN PROPID pPropObject[],
                                          IN PROPVARIANT pVarObject[]
                                         )
{
    HRESULT rc;
    CHLQS hLQS;

    //
    // Create the queue in the local queue store
    //
    rc = LQSCreate( lpszQueuePathName,
                    dwQueueId,
                    cpObject,
                    pPropObject,
                    pVarObject,
                    &hLQS);

    if (rc == MQ_ERROR_QUEUE_EXISTS)
    {
        //
        // If the queue already exists, only set the queue props.
        //
        rc = LQSSetProperties( hLQS,
                               cpObject,
                               pPropObject,
                               pVarObject);
        if (FAILED(rc) && fNewQueue)
        {
            LQSClose(hLQS);
            hLQS = NULL;
            LQSDelete(dwQueueId);
        }
    }

    return LogHR(rc, s_FN, 360);
}

/*====================================================

CQPrivate::GetNextPrivateQueueId

Arguments:

Return Value:


=====================================================*/
HRESULT
CQPrivate::GetNextPrivateQueueId(OUT DWORD *pdwQueueId)
{
    CS lock(m_cs);
    HRESULT rc;
    static CAutoCloseRegHandle hKey = NULL;

    if (!hKey)
    {
        CS lock(*GetRegCS());

        rc = RegOpenKeyEx(FALCON_REG_POS,
                          GetFalconSectionName(),
                          0L,
                          KEY_WRITE | KEY_READ,
                          &hKey);
        if (rc != ERROR_SUCCESS)
        {
            DBGMSG((DBGMOD_QM,
                    DBGLVL_ERROR,
                    TEXT("Fail to Open 'LastPrivateQueueId' ")
                    TEXT("Key in Falcon Registry. Error %d"), rc));
            LogNTStatus(rc, s_FN, 370);
            return MQ_ERROR;
        }
    }
    DWORD dwType;
    DWORD cbData = sizeof(DWORD);

    {
        CS lock(*GetRegCS());
        rc = RegQueryValueEx(hKey,
                     TEXT("LastPrivateQueueId"),
                     0L,
                     &dwType,
                     (LPBYTE)pdwQueueId,
                     &cbData);
    }

    if (rc != ERROR_SUCCESS)
    {

        CS lock(*GetRegCS());
        //
        // QFE - bug 2736: K2 setup problem with private queues
        //
        // After runing K2 setup on a cluster, the LastPrivateQueueId isn't
        // stored on the registery. When trying to create a private queue
        // the QM failes to retreive the data and returns MQ_ERROR.
        //
        // Fix
        //==========
        // when the QM failed to retrive the LAstPrivateQueueId from
        // registery, it generates this reg value and set it to 0xf.
        //
        *pdwQueueId = 0xf;
        dwType = REG_DWORD;
        rc =  RegSetValueEx(hKey,
                        L"LastPrivateQueueId",
                        0L,
                        REG_DWORD,
                        (const BYTE*)pdwQueueId,
                        sizeof(DWORD));

        ASSERT(rc == ERROR_SUCCESS);
        if (FAILED(rc))
        {
            LogHR(rc, s_FN, 380);
            return MQ_ERROR;
        }
    }


    if (dwType != REG_DWORD)
    {
        LogIllegalPoint(s_FN, 162);
        DBGMSG((DBGMOD_QM,
                DBGLVL_ERROR,
                TEXT("Registry Inconsistant for 'LastPrivateQueueId' value.")));
        throw "Register Inconsistence";
    }

    BOOL fCheckAll = FALSE;
    rc = MQ_OK;
    while (SUCCEEDED(rc))
    {
        //
        // increment the queue Id to next queue
        //
        (*pdwQueueId)++;
        if (*pdwQueueId == 0)
        {
            if (fCheckAll)
            {
                //
                // We can't find any free ID.
                //
                return LogHR(MQ_ERROR, s_FN, 390);
            }
            ASSERT(m_dwMaxSysQueue) ;
            *pdwQueueId =  m_dwMaxSysQueue + 1 ;
            fCheckAll = TRUE;
        }

        CHLQS hLQS;

        rc = LQSOpen(*pdwQueueId, &hLQS, NULL);
    }

    //
    // Store the new value in registery
    //
    {
        CS lock(*GetRegCS());
        rc =  RegSetValueEx(hKey,
                        L"LastPrivateQueueId",
                        0L,
                        REG_DWORD,
                        (const BYTE*)pdwQueueId,
                        sizeof(DWORD));

        ASSERT(rc == ERROR_SUCCESS);
    }

    return LogHR(rc, s_FN, 400);

}


/*====================================================

CQPrivate::SetQueueProperties

Arguments:

=====================================================*/

HRESULT
CQPrivate::SetQueueProperties(
                IN  LPCWSTR                lpwcsPathName,
                IN  PSECURITY_DESCRIPTOR   pSecurityDescriptorIn,
                IN  DWORD                  cp,
                IN  PROPID                 aProp[],
                IN  PROPVARIANT            apVar[],
                OUT DWORD*                 pcpOut,
                OUT PROPID **              ppOutProp,
                OUT PROPVARIANT **         ppOutPropvariant )
{
    DWORD i;
    DWORD   dwNumOfObjectProps;
    PROPVARIANT * pDefaultPropvariants;
    int index;

    dwNumOfObjectProps = NPROPS;
    pDefaultPropvariants = g_propvariantQueue;
    //
    //  allocate a copy of the default provariants
    //
    AP<PROPVARIANT> pAllPropvariants = new PROPVARIANT[dwNumOfObjectProps];
    memcpy (pAllPropvariants, pDefaultPropvariants, sizeof(PROPVARIANT) * dwNumOfObjectProps);
    //
    //  Overwrite the defaults with the values supplied by the user
    //
    for ( i =0 ; i < cp; i++)
    {
        //
        //  Get this propert index in the default arrays
        //
        if((index = g_mapQueuePropertyToIndex[aProp[i]]) != -1)
        {
            //
            //  just copy the propety over the default value
            //
            if (aProp[i] == PROPID_Q_PATHNAME)
            {
                pAllPropvariants[index].vt = VT_LPWSTR;
                pAllPropvariants[index].pwszVal = const_cast<LPWSTR>(lpwcsPathName);
            }
            else
            {
                pAllPropvariants[index] = apVar[i];
            }
        }
    }

    //
    //  Set the security property
    //
    SECURITY_DESCRIPTOR *pPrivateSD = NULL ;


#ifdef _DEBUG
    // First verify that we're sane
    SECURITY_DESCRIPTOR_CONTROL sdc;
    DWORD dwSDRev;

    ASSERT(pSecurityDescriptorIn);
    ASSERT(GetSecurityDescriptorControl(pSecurityDescriptorIn, &sdc, &dwSDRev));
    ASSERT(dwSDRev == SECURITY_DESCRIPTOR_REVISION);
    ASSERT(sdc & SE_SELF_RELATIVE);
#endif

    //
    // Convert security descriptor to NT4 format. We keep it in LQS file
    // in NT4 format, mostly for support of cluster rolling-upgrade.
    //
    DWORD dwSD4Len = 0 ;
    P<SECURITY_DESCRIPTOR> pSD4 ;
    HRESULT hr = MQSec_ConvertSDToNT4Format(
                                MQDS_QUEUE,
                               (SECURITY_DESCRIPTOR*) pSecurityDescriptorIn,
                               &dwSD4Len,
                               &pSD4 ) ;
    ASSERT(SUCCEEDED(hr)) ;
    LogHR(hr, s_FN, 199);

    if (SUCCEEDED(hr) && (hr != MQSec_I_SD_CONV_NOT_NEEDED))
    {
        pPrivateSD = pSD4 ;
    }
    else
    {
        ASSERT(pSD4 == NULL) ;
        pPrivateSD = (SECURITY_DESCRIPTOR*) pSecurityDescriptorIn ;
    }
    ASSERT(pPrivateSD && IsValidSecurityDescriptor(pPrivateSD)) ;

    pAllPropvariants[g_QueueSecurityDescriptorIndex].blob.pBlobData =
                                            (unsigned char *) pPrivateSD ;
    pAllPropvariants[g_QueueSecurityDescriptorIndex].blob.cbSize =
           ((pPrivateSD) ? GetSecurityDescriptorLength(pPrivateSD) : 0) ;

    //
    //  Set the create and modify time
    //
    pAllPropvariants[g_QueueCreateTimeIndex].lVal = INT_PTR_TO_INT(time( NULL)); //BUGBUG bug year 2038
    pAllPropvariants[g_QueueModifyTimeIndex].lVal =
                             pAllPropvariants[g_QueueCreateTimeIndex].lVal ;

    *pcpOut =  dwNumOfObjectProps;
    *ppOutProp = g_propidQueue;
    *ppOutPropvariant = pAllPropvariants.detach();
    return(MQ_OK);
}

/*====================================================

CQPrivate::InitDefaultQueueProperties

Arguments:

Return Value:


=====================================================*/
void
CQPrivate::InitDefaultQueueProperties(void)
{
    DWORD i;
    BLOB  defaultQueueSecurity = {0, NULL};

    for (i=0; i < NPROPS; i++)
    {
        //
        //  Set default values
        //
        switch( g_propidQueue[i] )
        {
            case PROPID_Q_TYPE:
                g_propvariantQueue[i].vt = VT_CLSID;
                g_propvariantQueue[i].puuid = const_cast<GUID*>(&GUID_NULL);
                break;
            case PROPID_Q_JOURNAL:
                g_propvariantQueue[i].vt = VT_UI1;
                g_propvariantQueue[i].bVal = DEFAULT_Q_JOURNAL;
                break;
            case PROPID_Q_QUOTA:
                g_propvariantQueue[i].vt = VT_UI4;
                g_propvariantQueue[i].ulVal = DEFAULT_Q_QUOTA;
                break;
            case PROPID_Q_LABEL:
                g_propvariantQueue[i].vt = VT_LPWSTR;
                g_propvariantQueue[i].pwszVal = g_nullLable;
                break;
            case PROPID_Q_SECURITY:
                g_propvariantQueue[i].vt = VT_BLOB;
                g_propvariantQueue[i].blob = defaultQueueSecurity;
                g_QueueSecurityDescriptorIndex = i;
                break;
            case PROPID_Q_JOURNAL_QUOTA:
                g_propvariantQueue[i].vt = VT_UI4;
                g_propvariantQueue[i].ulVal = DEFAULT_Q_JOURNAL_QUOTA;
                break;
            case PROPID_Q_BASEPRIORITY:
                g_propvariantQueue[i].vt = VT_I2;
                g_propvariantQueue[i].lVal = DEFAULT_Q_BASEPRIORITY;
                break;
            case PROPID_Q_CREATE_TIME:
                g_propvariantQueue[i].vt = VT_I4;
                g_QueueCreateTimeIndex = i;
                break;
            case PROPID_Q_MODIFY_TIME:
                g_propvariantQueue[i].vt = VT_I4;
                g_QueueModifyTimeIndex =i;
                break;
            case PROPID_Q_AUTHENTICATE:
                g_propvariantQueue[i].vt = VT_UI1;
                g_propvariantQueue[i].bVal = DEFAULT_Q_AUTHENTICATE;
                break;
            case PROPID_Q_PRIV_LEVEL:
                g_propvariantQueue[i].vt = VT_UI4;
                g_propvariantQueue[i].ulVal = DEFAULT_Q_PRIV_LEVEL;
                break;
            case PROPID_Q_TRANSACTION:
                g_propvariantQueue[i].vt = VT_UI1;
                g_propvariantQueue[i].bVal = DEFAULT_Q_TRANSACTION;
                break;
            case PPROPID_Q_SYSTEMQUEUE:
                g_propvariantQueue[i].vt = VT_UI1;
                g_propvariantQueue[i].bVal = 0 ;
                break;
            case PROPID_Q_PATHNAME:
                g_propvariantQueue[i].vt = VT_LPWSTR;
                break;
            case PROPID_Q_MULTICAST_ADDRESS:
                g_propvariantQueue[i].vt = VT_EMPTY;
                break;
            default:
                g_propvariantQueue[i].vt = VT_EMPTY;
                break;
        }
    }
}



/*====================================================

CQPrivate::PrivateQueueInit

Arguments:

Return Value:


=====================================================*/

HRESULT
CQPrivate::PrivateQueueInit(void)
{
    if (m_dwMaxSysQueue)
    {
       //
       // Already initialized
       //
       return MQ_OK ;
    }

    InitDefaultQueueProperties();

    //
    // If either of these constant change, then change the size and
    // initialization of arrat m_lpSysQueueNames, below.
    //
    ASSERT(MIN_SYS_PRIVATE_QUEUE_ID == 1) ;
    ASSERT(MAX_SYS_PRIVATE_QUEUE_ID == 5) ;

    DWORD dwDefault = MAX_SYS_PRIVATE_QUEUE_ID ;
    READ_REG_DWORD( m_dwMaxSysQueue,
                    MSMQ_MAX_PRIV_SYSQUEUE_REGNAME,
                    &dwDefault ) ;

    dwDefault =  DEFAULT_SYS_Q_BASEPRIORITY ;
    READ_REG_DWORD( m_dwSysQueuePriority,
                    MSMQ_PRIV_SYSQUEUE_PRIO_REGNAME,
                    &dwDefault ) ;

    m_lpSysQueueNames[0] = REPLICATION_QUEUE_NAME ;
    m_lpSysQueueNames[1] = ADMINISTRATION_QUEUE_NAME ;
    m_lpSysQueueNames[2] = NOTIFICATION_QUEUE_NAME ;
    m_lpSysQueueNames[3] = ORDERING_QUEUE_NAME ;
    m_lpSysQueueNames[4] = NT5PEC_REPLICATION_QUEUE_NAME ;

    return(MQ_OK);
}

STATIC
HRESULT
GetPathName(DWORD dwQueueId, LPCWSTR &lpszPathName)
{
    HRESULT hr;
    CHLQS hLQS;

    hr = LQSOpen(dwQueueId, &hLQS, NULL);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 410);
    }

    PROPID PropId[1];
    PROPVARIANT PropVar[1];

    PropId[0] = PROPID_Q_PATHNAME;
    PropVar[0].vt = VT_NULL;
    hr = LQSGetProperties(hLQS, 1, PropId, PropVar);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 420);
    }

    lpszPathName = PropVar[0].pwszVal;

    return LogHR(hr, s_FN, 430);
}

/*====================================================

CQPrivate::QMGetFirstPrivateQueue

Arguments:

Return Value:


=====================================================*/
HRESULT CQPrivate::QMGetFirstPrivateQueuePosition(
                               IN OUT    PVOID    &pos,
                               OUT       LPCWSTR  &lpszPathName,
                               OUT       DWORD    &dwQueueId)
{
    HRESULT hr;
    CHLQS hLQS;

    pos = NULL;

    hr = LQSGetFirst(&hLQS, &dwQueueId);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 440);
    }

    hr = GetPathName(dwQueueId, lpszPathName);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 450);
    }

    pos = hLQS;
    hLQS = NULL;

    return MQ_OK;
}

/*====================================================

CQPrivate::QMGetNextPrivateQueue

Arguments:

Return Value:


=====================================================*/
HRESULT CQPrivate::QMGetNextPrivateQueue(
                               IN OUT    PVOID    &hLQSEnum,
                               OUT       LPCWSTR  &lpszPathName,
                               OUT       DWORD    &dwQueueId)
{
    HRESULT hr;

    hr = LQSGetNext(hLQSEnum, &dwQueueId);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 460);
    }

    hr = GetPathName(dwQueueId, lpszPathName);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 470);
    }

    return LogHR(hr, s_FN, 480);
}

#ifdef _WIN64
/*====================================================

CQPrivate::QMGetFirstPrivateQueueByDword

Arguments:

Return Value:


=====================================================*/
HRESULT CQPrivate::QMGetFirstPrivateQueuePositionByDword(OUT DWORD    &dwpos,
                                                         OUT LPCWSTR  &lpszPathName,
                                                         OUT DWORD    &dwQueueId)
{
    HRESULT hr;
    CMappedHLQS dwMappedHLQS;

    dwpos = 0;

    hr = LQSGetFirstWithMappedHLQS(&dwMappedHLQS, &dwQueueId);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 560);
    }

    hr = GetPathName(dwQueueId, lpszPathName);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 570);
    }

    dwpos = dwMappedHLQS;
    dwMappedHLQS = NULL;

    return MQ_OK;
}

/*====================================================

CQPrivate::QMGetNextPrivateQueueByDword

Arguments:

Return Value:


=====================================================*/
HRESULT CQPrivate::QMGetNextPrivateQueueByDword(IN OUT DWORD    &dwpos,
                                                OUT    LPCWSTR  &lpszPathName,
                                                OUT    DWORD    &dwQueueId)
{
    HRESULT hr;

    hr = LQSGetNextWithMappedHLQS(dwpos, &dwQueueId);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 580);
    }

    hr = GetPathName(dwQueueId, lpszPathName);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 590);
    }

    return LogHR(hr, s_FN, 600);
}
#endif //_WIN64
/*====================================================

CQPrivate::QMPrivateQueuePathToQueueId

Arguments:

Return Value:

=====================================================*/

HRESULT
CQPrivate::QMPrivateQueuePathToQueueId(IN LPCWSTR lpwcsPathName,
                                       OUT DWORD *pdwQueueId
                                      )
{
    HRESULT rc;
    CHLQS hLQS;

    BOOL fDNSName;
    BOOL fLocalMachine = IsPathnameForLocalMachine(lpwcsPathName, &fDNSName);
    if(!fLocalMachine)
	    return LogHR(MQ_ERROR_ILLEGAL_QUEUE_PATHNAME, s_FN, 490);

    WCHAR QueuePathName[MAX_COMPUTERNAME_LENGTH + MQ_MAX_Q_NAME_LEN + 2];
    if (fDNSName)
    {
        ReplaceDNSNameWithNetBiosName(lpwcsPathName, QueuePathName);
        lpwcsPathName = QueuePathName;
    }

    rc = LQSOpen(lpwcsPathName, &hLQS, NULL);
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 500);
    }

    rc = LQSGetIdentifier(hLQS, pdwQueueId);

    return LogHR(rc, s_FN, 510);
}

/*====================================================

BOOL CQPrivate::IsPrivateSysQueue()

Arguments:

Return Value:

=====================================================*/

BOOL
CQPrivate::IsPrivateSysQueue(IN  LPCWSTR lpwcsPathName )
{
   WCHAR *pName = wcsrchr(lpwcsPathName, L'\\') ;
   if (!pName)
   {
      return FALSE ;
   }
   pName++ ;  // skip the backslash.

   for ( int j = 0 ; j < MAX_SYS_PRIVATE_QUEUE_ID ; j++ )
   {
      if (0 == _wcsicmp(pName, m_lpSysQueueNames[j]))
      {
         return TRUE ;
      }
   }

   return FALSE ;
}

/*====================================================

CQPrivate::IsPrivateSysQueue()

Arguments:

Return Value:

=====================================================*/

BOOL
CQPrivate::IsPrivateSysQueue(IN  DWORD Uniquifier )
{
   ASSERT(m_dwMaxSysQueue) ;
   BOOL fSystemQueue = (Uniquifier <=  m_dwMaxSysQueue) &&
                       (Uniquifier >=  MIN_SYS_PRIVATE_QUEUE_ID) ;
   return fSystemQueue ;
}

/*====================================================

CQPrivate::GetPrivateSysQueueProperties()

Arguments:

Return Value:

=====================================================*/

HRESULT
CQPrivate::GetPrivateSysQueueProperties(IN  DWORD       cp,
                                        IN  PROPID      aProp[],
                                        IN  PROPVARIANT apVar[] )
{
   for ( DWORD j = 0 ; j < cp ; j++ )
   {
      switch (aProp[j])
      {
         case  PPROPID_Q_SYSTEMQUEUE:
            apVar[j].bVal = TRUE ;
            break ;

         case  PROPID_Q_BASEPRIORITY:
            apVar[j].iVal =  (SHORT) m_dwSysQueuePriority ;
            break ;

         default:
            break ;
      }
   }

   return MQ_OK ;
}

HRESULT
CQPrivate::GetQueueIdForDirectFormatName(
    LPCWSTR QueueFormatname,
    DWORD* pQueueId
    )
//
// Routine Description:
//      The routine gets direct format name and returns the Queue ID of the
//      corresponding queue
//
// Arguments:
//      QueueFormatname - direct queue format name
//      pQueueId - pointer to return Queue Id
//
// Returned Value:
//      MQ_OK if the Queue  exist, MQ_ERROR_QUEUE_NOT_FOUND otherwise
//
{
    //
    // build queue name
    //
    LPCWSTR lpszQueueName = wcschr(QueueFormatname, L'\\');
    ASSERT(lpszQueueName != NULL);

    const DWORD x_MaxLength = MAX_COMPUTERNAME_LENGTH +                 // computer name
                              1 +                                       // '\'
                              PRIVATE_QUEUE_PATH_INDICATIOR_LENGTH +    // "private$\"
                              MQ_MAX_Q_NAME_LEN +                       // Queue name
                              1;                                        // '\0'
    WCHAR QueuePathName[x_MaxLength];
    swprintf(QueuePathName, L"%s%s",g_szMachineName,lpszQueueName);

    HRESULT hr2 = QMPrivateQueuePathToQueueId(QueuePathName, pQueueId);
    return LogHR(hr2, s_FN, 520);
}




HRESULT
CQPrivate::GetQueueIdForQueueFormatName(
    const QUEUE_FORMAT* pQueueFormat,
    DWORD* pQueueId
    )
//
// Routine Description:
//      The routine gets format name and returns the Queue ID of the
//      corresponding queue
//
// Arguments:
//      QueueFormatname - queue format name
//      pQueueId - pointer to return Queue Id
//
// Returned Value:
//      MQ_OK if the Queue  exist, MQ_ERROR_QUEUE_NOT_FOUND otherwise
//
{
    if (!IsLocalPrivateQueue(pQueueFormat))
    {
        return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 530);
    }

    switch(pQueueFormat->GetType())
    {
        case QUEUE_FORMAT_TYPE_PRIVATE:
            *pQueueId = pQueueFormat->PrivateID().Uniquifier;
            return MQ_OK;

        case QUEUE_FORMAT_TYPE_DIRECT:
            return LogHR(GetQueueIdForDirectFormatName(pQueueFormat->DirectID(), pQueueId), s_FN, 540);

        default:
            ASSERT(0);
    }

    return LogHR(MQ_ERROR, s_FN, 550);
}

/*====================================================

CompareElements  of LPCTSTR

Arguments:

Return Value:


=====================================================*/

BOOL AFXAPI  CompareElements(const LPCTSTR* MapName1, const LPCTSTR* MapName2)
{
    return (_tcscmp(*MapName1, *MapName2) == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\cqueue.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    cqueue.cpp

Abstract:
    Definition of a CQueue class

Author:
    Uri Habusha (urih)

--*/

#include "stdh.h"
#include "cqmgr.h"
#include "qmthrd.h"
#include "cgroup.h"
#include "cqpriv.h"
#include "qmperf.h"
#include "onhold.h"
#include <mqstl.h>
#include <qal.h>
#include <fn.h>
#include <ac.h>
#include <mqformat.h>

#include "sessmgr.h"
#include "QmRd.h"

#include "Tm.h"
#include "Mtm.h"
#include "Mt.h"

#include "cqueue.tmh"

//
// extern CQMCmd   QMCmd;
//
extern CSessionMgr SessionMgr;
extern CQueueMgr QueueMgr;
extern CQGroup * g_pgroupNonactive;
extern CQGroup * g_pgroupWaiting;
extern CQGroup * g_pgroupNotValidated;
extern CQGroup* g_pgroupDisconnected;

extern HANDLE g_hAc;

static WCHAR *s_FN=L"cqueue";

/*======================================================

Function:         CopySecurityDescriptor

Description:      Allocate memory for a copy of a security descriptor and copy
                  the security descriptor of a CSecureableObject to the
                  allocated memory.

Arguments:        ppSD - A pointer to a buffer that receives the address of the
                         allocated memory for the destination security
                         descriptor.
                  pSec - A pointer to a CSecureableObject. The security
                         descriptor of this secureable object is the source
                         security descriptor for the copy

Return Value:     None

Thread Context:

History Change:

Comments:         It is the resposibility of the calling code to free the
                  allocated memory for the destination security descriptor.

========================================================*/

void
CopySecurityDescriptor(
       PSECURITY_DESCRIPTOR *ppSD,
       CSecureableObject    *pSec )
{
    const VOID* pSD ;
    DWORD dwSdLen;

    if ((pSD = pSec->GetSDPtr()) != NULL)
    {
        dwSdLen = GetSecurityDescriptorLength(const_cast<PSECURITY_DESCRIPTOR>(pSD));
        *ppSD = (PSECURITY_DESCRIPTOR)new char[dwSdLen]; // Allocate the memory.
        memcpy(*ppSD, pSD, dwSdLen); // Copy the security descriptor.
    }
    else
    {
        *ppSD = NULL;
    }
}

/*======================================================

Function:         CBaseQueue::CBaseQueue

Description:      Constructor

========================================================*/

CBaseQueue::CBaseQueue() :
    m_usQueueType(0)
{
}

/*======================================================


Function:         void  CBaseQueue::InitNameAndGuid()

Description:

========================================================*/

void  CBaseQueue::InitNameAndGuid( IN const QUEUE_FORMAT* pQueueFormat,
                                   IN PQueueProps         pQueueProp )
{

    m_qid.pguidQueue = NULL;
    if (pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_DIRECT)
    {
        //
        // Direct Queue
        //
        m_qid.dwPrivateQueueId = 0;
        if (pQueueProp->fIsLocalQueue)
        {
            m_qName = pQueueProp->lpwsQueuePathName;
            LPCWSTR lpcsTemp = wcschr(m_qName,L'\\');
            ASSERT(lpcsTemp != NULL);

            if (_wcsnicmp(lpcsTemp+1,
                PRIVATE_QUEUE_PATH_INDICATIOR,
                wcslen(PRIVATE_QUEUE_PATH_INDICATIOR)) == 0)
            {
                m_dwQueueType = QUEUE_TYPE_PRIVATE;
                m_qid.pguidQueue = new GUID;
                *(m_qid.pguidQueue) = *(CQueueMgr::GetQMGuid());
                g_QPrivate.QMPrivateQueuePathToQueueId(m_qName, &(m_qid.dwPrivateQueueId));

            }
            else
            {
                m_qid.pguidQueue = new GUID;
                *(m_qid.pguidQueue) = pQueueProp->guidDirectQueueInstance;
                m_dwQueueType = QUEUE_TYPE_PUBLIC;
            }
        }
        else
        {
            m_qName = (TCHAR*)pQueueProp->lpwsQueuePathName;
            m_dwQueueType = QUEUE_TYPE_UNKNOWN;
        }
    }
    else
    {
        m_qid.dwPrivateQueueId = 0;
        m_qName = (TCHAR*)pQueueProp->lpwsQueuePathName;
        switch (pQueueFormat->GetType())
        {
            case QUEUE_FORMAT_TYPE_PUBLIC:
                m_dwQueueType = QUEUE_TYPE_PUBLIC;
                m_qid.pguidQueue = new GUID;
                *(m_qid.pguidQueue) = pQueueFormat->PublicID();
                break;

            case QUEUE_FORMAT_TYPE_MACHINE:
                m_dwQueueType = QUEUE_TYPE_MACHINE;
                m_qid.pguidQueue = new GUID;
                *(m_qid.pguidQueue) = pQueueFormat->MachineID();
                break;

            case QUEUE_FORMAT_TYPE_CONNECTOR:
                m_dwQueueType = QUEUE_TYPE_CONNECTOR;
                m_qid.pguidQueue = new GUID;
                *(m_qid.pguidQueue) = pQueueFormat->ConnectorID();
                m_qid.dwPrivateQueueId = (pQueueFormat->Suffix() == QUEUE_SUFFIX_TYPE_XACTONLY) ? 1 : 0;
                break;

            case QUEUE_FORMAT_TYPE_PRIVATE:
                m_qid.pguidQueue = new GUID;
                *m_qid.pguidQueue = pQueueFormat->PrivateID().Lineage;
                m_qid.dwPrivateQueueId = pQueueFormat->PrivateID().Uniquifier;

                if (QmpIsLocalMachine(pQueueProp->pQMGuid))
                {
                    m_dwQueueType = QUEUE_TYPE_PRIVATE;
                }
                else
                {
                    m_dwQueueType = QUEUE_TYPE_MACHINE;
                }
                break;

            case QUEUE_FORMAT_TYPE_MULTICAST:
                m_dwQueueType = QUEUE_TYPE_MULTICAST;
                break;

            case QUEUE_FORMAT_TYPE_UNKNOWN:
                //
                // Distribution queues are of type unknown.
                //
                NULL;
                break;

            default:
                ASSERT(0);
        }
    }
}

/*======================================================

Function:  void CQueue::SetSecurityDescriptor()

Description:

========================================================*/
void CQueue::SetSecurityDescriptor(void)
{
    switch (GetQueueType())
    {
        case QUEUE_TYPE_PUBLIC:
        {
            CQMDSSecureableObject DsSec(
                                    eQUEUE,
                                    GetQueueGuid(),
                                    TRUE,
                                    TRUE,
                                    NULL);

            CopySecurityDescriptor(&m_pSecurityDescriptor, &DsSec);
            break;
        }
        case QUEUE_TYPE_PRIVATE:
        {
            CQMSecureablePrivateObject QmSec(eQUEUE, GetPrivateQueueId());
            CopySecurityDescriptor(&m_pSecurityDescriptor, &QmSec);
            break;
        }
        case QUEUE_TYPE_MACHINE:
        case QUEUE_TYPE_CONNECTOR:
        case QUEUE_TYPE_MULTICAST:
        {
            //
            // No caching of security descriptor of the machine.
            // Whenever the security descriptor of the machnie is needed
            // it is taken from the registry. The registry is updated
            // using the notification messages.
            // Whenever the security descriptor of the CN is needed, it is
            // taken from the DS.
            //
            m_pSecurityDescriptor = NULL;
            break;
        }
        case QUEUE_TYPE_UNKNOWN:
        {
            m_pSecurityDescriptor = NULL;
            break;
        }

        default:
            ASSERT(0);
    }
}

/*======================================================

Function:  void CQueue::InitQueueProperties()

Description:

========================================================*/

void CQueue::InitQueueProperties(IN PQueueProps   pQueueProp)
{
    m_fLocalQueue     = pQueueProp->fIsLocalQueue;
    m_pguidDstMachine = pQueueProp->pQMGuid;
    m_dwQuota         = pQueueProp->dwQuota;
    m_dwJournalQuota  = pQueueProp->dwJournalQuota;
    m_lBasePriority   = pQueueProp->siBasePriority;
    m_fTransactedQueue= pQueueProp->fTransactedQueue;
    m_fJournalQueue   = pQueueProp->fJournalQueue;
    m_fSystemQueue    = pQueueProp->fSystemQueue;
    m_fConnectorQueue = pQueueProp->fConnectorQueue;
    m_fForeign        = pQueueProp->fForeign;
    m_fAuthenticate   = pQueueProp->fAuthenticate;
    m_fUnknownQueueType = pQueueProp->fUnknownQueueType;
    m_dwPrivLevel     = pQueueProp->dwPrivLevel;

    m_pSecurityDescriptor = NULL;

    if (pQueueProp->fIsLocalQueue)
    {
        SetSecurityDescriptor();
    }
}

/*======================================================

Function:         CQueue::CQueue

Description:      Constructor

Arguments:        pQGuid - Queue Guid
                  qHandle - Queue Handle. Local queue recorder in DS is constructed with
                            qHandle = INVALID_FILE_HANDLE. The qHandle will update when a
                            message     is arrived to the queue.


Return Value:     None

Thread Context:

History Change:

========================================================*/

CQueue::CQueue(IN const QUEUE_FORMAT* pQueueFormat,
               IN HANDLE              hQueue,
               IN PQueueProps         pQueueProp,
               IN BOOL                fNotDSValidated)
{
    ASSERT(pQueueFormat != NULL);

    if (pQueueProp->lpwsQueuePathName)
    {
        DBGMSG((DBGMOD_QM, DBGLVL_INFO,
              _TEXT("CQueue Constructor for queue: %ls, NoDS- %lxh"),
                          pQueueProp->lpwsQueuePathName, fNotDSValidated)) ;
    }
    else
    {
        DBGMSG((DBGMOD_QM, DBGLVL_INFO,
              _TEXT("CQueue Constructor for unknown queue, NoDS- %lxh"),
                                            fNotDSValidated)) ;
    }

    //
    // Data member initilization
    //
    m_fNotValid = FALSE ;
    m_fOnHold = FALSE;

    m_pSecurityDescriptor = NULL;
    m_pSession = NULL;
    m_pGroup = NULL;
    m_dwRoutingRetry = 0;
    m_fHopCountFailure = FALSE;
    m_pgConnectorQM = NULL;
    m_hQueue = hQueue;

    InitNameAndGuid(pQueueFormat, pQueueProp ) ;

    InitQueueProperties(pQueueProp) ;

    m_srvr_pRemoteMapping = NULL ;
#ifdef _DEBUG
    m_cPendings = 0 ;
#endif

    PerfRegisterQueue();

    m_dwSignature =  QUEUE_SIGNATURE ;
}

/*======================================================

Function:      CQueue::~CQueue

Description:   destructor

Arguments:     None

Return Value:  None

Thread Context:

History Change:

========================================================*/

CQueue::~CQueue()
{
	
	ASSERT(!QueueMgr.IsQueueInList(this));

    m_dwSignature = 0 ;
    delete [] m_qName;
    delete m_qid.pguidQueue;
    delete m_pguidDstMachine;
    delete m_pgConnectorQM;
    delete[] (char*)m_pSecurityDescriptor;
    delete m_srvr_pRemoteMapping;

    PerfRemoveQueue();
}

/*======================================================

Function:        CQueue::CreateConnection

Description:     Create Connection

Arguments:       None

Return Value:    None

Thread Context:

History Change:

========================================================*/
void CQueue::CreateConnection(void) throw(bad_alloc)
{
    //
    // Create connection for direct HTTP/HTTPS queue, use different function
    //
    ASSERT(! IsDirectHttpQueue());

    //
    // Increment the reference count, to insure that the queue doesn't remove
    // during the clean-up while the routine try to find a session for it.
    //
    AddRef();
    //
    // No Session - try to establish one
    //
    IncRoutingRetry();
    //
    // Bugbug - Check for giving up retrying
    // Bugbug - we would like to have adjustable retry time
    //

    HRESULT rc;

    try
    {
        if (m_qid.pguidQueue == NULL)
        {
            rc = SessionMgr.GetSessionForDirectQueue(this, &m_pSession);
        }
        else
        {
            //
            // No Session - try to establish one
            //
            rc = QmRdGetSessionForQueue(this, &m_pSession);
        }
    }
    catch(const bad_alloc&)
    {
        //
        //  No resources to establish connection; try it latter
        //
        rc = MQ_ERROR_INSUFFICIENT_RESOURCES;
        LogIllegalPoint(s_FN, 60);
    }


    SetHopCountFailure(FALSE);

    if(FAILED(rc))
    {
#ifdef _DEBUG
        if (GetRoutingRetry() == 1)
        {
            DBGMSG((DBGMOD_ALL,
                    DBGLVL_ERROR,
                    _TEXT("Cannot route messages to queue %ls. Status is %x"), GetQueueName(),rc));
        }
#endif

        if (rc == MQ_ERROR_NO_DS)
        {
			CQGroup::MoveQueueToGroup(this, g_pgroupNotValidated);
        }
        else
        {
            //
            // Don't decrement the reference count. we do it inorder to avoid remove queue
            // while it in waiting stage. If we want to remove the queue in this stage requires
            // synchronization between the QueueMgr and SessionMgr in order to remove the queue
            // from SessionMgr data structure.
            //
            SessionMgr.AddWaitingQueue(this);

            //
            // Don't move the queue to the waiting group before calling SessionMgr.AddWaitingQueue.
            // If exception is raised on sessionMgr, no one move the queue back to nonactive group
            // In such a case the queue stay on waiting state until re-boot
            //
			CQGroup::MoveQueueToGroup(this, g_pgroupWaiting);
        }

        Release();
        return;
    }
    else
    {
        if (m_pSession == NULL) {
            //
            // Establish session failed
            //
            DBGMSG((DBGMOD_ROUTING,
                    DBGLVL_WARNING,
                    _TEXT("Could not find a session for %ls"),GetQueueName()));
        } else {
            //
            // Success to get a session
            //
            ASSERT(m_pSession != NULL);

            //
            // move the queue to active list
            //
            m_pSession->AddQueueToSessionGroup(this);
        }
        Release();
    }
}

/*====================================================
Function:       CQueue::Connect

Description:    Connect a queue to a session. Using when queue is waiting for a
                session and it was found. A session was allocated to the queue.
                It can begin sending packets.

Arguments:      pSess - pointer to allocated session

Return Value:   None. Throws an exception.

Thread Context:

History Change:

========================================================*/

void CQueue::Connect(IN CTransportBase * pSess) throw(bad_alloc)
{
    CS lock(m_cs);

    if (pSess == NULL)
    {
        //
        // assyncronic request for session failed. The Queue will move from waiting to
        // nonactive state later.
        //
#ifdef _DEBUG
        if (GetRoutingRetry() == 1)
        {
            //
            // print report message only for the First try
            //
            DBGMSG((DBGMOD_ALL,
                    DBGLVL_ERROR,
                    _TEXT("assyncronic request for session with target queue %ls failed"),GetQueueName()));
        }
#endif
        return;
    }

    m_pSession = pSess;
    //
    // Move the queue from waiting group to Active group
    //
    m_pSession->AddQueueToSessionGroup(this);

#ifdef _DEBUG
    if (GetRoutingRetry() > 1)
    {
        DBGMSG((DBGMOD_ALL,
                DBGLVL_ERROR,
                _TEXT("The message was successfully routed to queue %ls"),GetQueueName()));
    }
#endif
    ClearRoutingRetry();
}

/*======================================================

Function:       CQueue::RcvPk

Description:    The function gets a packet and pass it to the AC for the appropriete quque

Arguments:      PktPtrs - pointer to receive packet

Return Value:   MQI_STATUS

Thread Context:

History Change:

========================================================*/

HRESULT CQueue::PutPkt(IN CQmPacket* PktPtrs,
                       IN BOOL      fRequeuePkt,
                       IN CTransportBase*  pSession)
{
    QMOV_ACPut* pAcPutOV;
    HRESULT rc;

    //
    // Queue the packet to the appropriate queue
    //

    //
    // Create an overlapped for AcPutPacket
    //
    rc = CreateAcPutPacketRequest(pSession,
                                  ((fRequeuePkt) ? 0 : PktPtrs->GetStoreAcknowledgeNo()),
                                  &pAcPutOV);

    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 10);
    }
    //
    // Increment reference count. We don't delete the Session
    // object before the put operation is completed
    //
    pSession->AddRef();

    //
    // put packet in AC
    //
    rc = ACPutPacket(
            m_hQueue,
            PktPtrs->GetPointerToDriverPacket(),
            &pAcPutOV->qmov
            );

    if(FAILED(rc))
    {
        DBGMSG((DBGMOD_QM,
                DBGLVL_ERROR,
                _TEXT("ACPutPacket Failed. Error: %x"), rc));
        // BUGBUG return NAK if needed
        LogHR(rc, s_FN, 20);
        return MQ_ERROR;
    }

    LPCTSTR lpszQueueName = GetQueueName() ;
    if (lpszQueueName)
    {
        DBGMSG((DBGMOD_MSGTRACK, DBGLVL_TRACE, _TEXT(
                      "Pass Packet to QUEUE %ls"), GetQueueName()));
    }
    else
    {
        DBGMSG((DBGMOD_MSGTRACK, DBGLVL_TRACE, _TEXT(
                                   "Pass Packet to unknown QUEUE"))) ;
    }

    return MQ_OK;
}

/*======================================================

Function:       CQueue::PutOrderedPkt

Description:    The function puts the ordered packet to the AC queue
                It also sets Received flag

Arguments:      PktPtrs - pointer to receive packet

Return Value:   MQI_STATUS

Thread Context:

History Change:

========================================================*/

HRESULT CQueue::PutOrderedPkt(IN CQmPacket* PktPtrs,
                              IN BOOL      fRequeuePkt,
                              IN CTransportBase*  pSession)
{
    QMOV_ACPutOrdered* pAcPutOV;
    HRESULT rc;

    //
    // Queue the packet to the appropriate queue, mark it Received and wait
    //

    //
    // Create an overlapped for AcPutPacket
    //
    rc = CreateAcPutOrderedPacketRequest(PktPtrs,
                                         m_hQueue,
                                         pSession,
                                         ((fRequeuePkt) ? 0 : PktPtrs->GetStoreAcknowledgeNo()),
                                         &pAcPutOV);

    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 30);
    }
    //
    // Increment reference count. We don't delete the Session
    // object before the put operation is completed
    //
    pSession->AddRef();

    //
    // Set received bit of the packet - to make it invisible for readers
    //     and put packet in AC
    //
    rc = ACPutPacket1(m_hQueue, PktPtrs->GetPointerToDriverPacket(), &pAcPutOV->qmov);

    if(FAILED(rc))
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, _TEXT("ACPutPacket Failed. Error: %x"), rc));
        // BUGBUG return NAK if needed
        LogHR(rc, s_FN, 40);
        return MQ_ERROR;
    }

    DBGMSG((DBGMOD_MSGTRACK,DBGLVL_TRACE,_TEXT("Pass Ordered Packet to QUEUE %ls"), GetQueueName()));

    return MQ_OK;
}

//
//Performance counters update
//


void CQueue::PerfUpdateName() const
{
    if(m_pQueueCounters == 0)
        return;

    AP<WCHAR> pName = GetName();
    PerfApp.SetInstanceName(m_pQueueCounters, pName);
}


/*======================================================

Function:       CQueue::PerfRegisterQueue()

Description:    Registers an instance of a queue object corrosponding to this queue
                for performace monitoring.

Arguments:

Return Value:   None

Comments:       The CPerf::AddInstance function always returns a valid pointer (even if more than
                the maximum allowed instances have been added) so the member should never fail.

========================================================*/

void CQueue::PerfRegisterQueue()
{
    AP<WCHAR> pName = GetName();
    m_pQueueCounters = (QueueCounters *)PerfApp.AddInstance(PERF_QUEUE_OBJECT, pName);
    PerfApp.ValidateObject(PERF_QUEUE_OBJECT);

    if (PerfApp.IsDummyInstance(m_pQueueCounters))
    {
        //
        //  Do not pass dummy instances to the device driver, just pass null,
        //  it'll handle it.
        //
        m_pQueueCounters = NULL;
    }
}

/*======================================================

Function:         CQueue::PerfRemoveQueue()

Description:      Removes the instance correspanding to this queue from
                  performance monitoring

Arguments:

Return Value:     None

Comments:

========================================================*/

void CQueue::PerfRemoveQueue()
{
    PerfApp.RemoveInstance(PERF_QUEUE_OBJECT, m_pQueueCounters);

    m_pQueueCounters = NULL;
}

/*======================================================

Function:         CQueue::SetQueueNotValid()

Description:

Arguments:

Return Value:     None

Comments:

========================================================*/

void CQueue::SetQueueNotValid()
{
    ASSERT(!m_fNotValid) ;
    ASSERT(GetQueueType() != QUEUE_TYPE_MULTICAST);

    m_fNotValid = TRUE ;


    //
    //  Purge the queue, removing all messages from it. The queue will be close
    //  when no handles and no messages are in the queue.
    //
    HANDLE hQueue = GetQueueHandle();
    if (hQueue != INVALID_HANDLE_VALUE)
    {
        HRESULT hr;
        hr = ACPurgeQueue(hQueue, TRUE, MQMSG_CLASS_NORMAL);

        if (hr == STATUS_INSUFFICIENT_RESOURCES)
        {
            Sleep(2 * 1000);

            //
            // ISSUE-2000/10/22-shaik: Second chance fail due to low resources causes leaks.
            //
            hr = ACPurgeQueue(hQueue, TRUE, MQMSG_CLASS_NORMAL);
        }

        LogHR(hr, s_FN, 101);
    }

    if (IsOnHold())
    {
        ASSERT(!IsLocalQueue());
        const QUEUE_FORMAT qf = GetQueueFormat();

        ASSERT((qf.GetType() == QUEUE_FORMAT_TYPE_PUBLIC) ||
               (qf.GetType() == QUEUE_FORMAT_TYPE_PRIVATE) ||
               (qf.GetType() == QUEUE_FORMAT_TYPE_DIRECT));
        //
        // remove the queu from "onHold" registery
        //
        ResumeQueue(&qf);
    }

    //
    //  Remove the queue from hash so it will no be found
    //
    QueueMgr.RemoveQueueFromHash(this);
}

/*======================================================

Function:         SetConnectorQM()

Description:      The Function set the Connector QM that should be used
                  to reach the foreign queue. If the queue is not transacted
                  foreign queue the Connector QM is ignored.

                  The function calls twice. first after recovery, the GUID of
                  the Connector QM is fetched from the packet. the second time
                  when creating a queue object for transacted foreign queue.
                  In this case the function determine the Connector QM and set
                  its guid.

Arguments:        pgConnectorQM - pointer to Connector QM GUID. When calling
                  for creating a new queue object the value is null

Return Value:     None

Comments:

========================================================*/
HRESULT
CQueue::SetConnectorQM(const GUID* pgConnectorQM)
{
    HRESULT hr = MQ_OK;

    delete m_pgConnectorQM;
    m_pgConnectorQM = NULL;

    if (IsDSQueue())
    {
        //
        //  Get Connector QM ID
        //
        if (pgConnectorQM)
        {
            ASSERT(m_pgConnectorQM == NULL);
            ASSERT(IsTransactionalQueue() && IsForeign());

            m_pgConnectorQM = new GUID;
            *m_pgConnectorQM = *pgConnectorQM;
        }
        else
        {
            if (IsForeign() && IsTransactionalQueue())
            {
				m_pgConnectorQM = new GUID;
				hr = QmRdGetConnectorQM(m_pguidDstMachine, m_pgConnectorQM);
            }
            else
            {
                if (IsUnkownQueueType())
                {
                    m_pgConnectorQM = new GUID;
                    *m_pgConnectorQM = GUID_NULL;
                }
            }
        }
    }
    else
    {
        ASSERT(pgConnectorQM == NULL);
    }

    #ifdef _DEBUG

        if (m_pgConnectorQM)
        {
            AP<WCHAR> lpcsTemp;
            GetQueue(&lpcsTemp);

            DBGMSG((DBGMOD_XACT,
                    DBGLVL_INFO,
                    _T("The Connector QM for Queue: %ls is: %!guid!"), lpcsTemp, m_pgConnectorQM));
        }

    #endif

    return LogHR(hr, s_FN, 50);
}

/*======================================================

Function:         CQueue::GetRoutingMachine()

Description:      The function return the machine guid that should be used when
                  routing to the QUEUE.

                  If the queue is transacted foreign queue and we are FRS we route
                  according to the Connector QM. otherwise the routing is done
                  according to the destination machine.

Arguments:

Return Value:     None

Comments:

========================================================*/
const GUID*
CQueue::GetRoutingMachine(void) const
{
    ASSERT((GetQueueType() == QUEUE_TYPE_PUBLIC) ||
           (GetQueueType() == QUEUE_TYPE_MACHINE));

    if (GetConnectorQM() && !QmpIsLocalMachine(GetConnectorQM()))
    {
        ASSERT(IsForeign() && IsTransactionalQueue());
        return GetConnectorQM();
    }
    else
    {
        ASSERT(GetMachineQMGuid() != NULL);
        return GetMachineQMGuid();
    }
}

LPWSTR CBaseQueue::GetName() const
{
    AP<WCHAR> pName = new WCHAR[MAX_PATH];

    if (m_qName != NULL)
    {
        wcsncpy(pName, m_qName, MAX_PATH);
        pName[MAX_PATH-1] = L'\0';
        return pName.detach();
    }

    if (m_qid.pguidQueue != NULL)
    {
        const QUEUE_FORMAT qf = GetQueueFormat();

        //
        // Use the format name as the name.
        // NOTE: we don't care if the buffer is too small (it will not).
        // In any case it will be filled up to it's end.
        //
        //
        ULONG Size;
        MQpQueueFormatToFormatName(&qf, pName, MAX_PATH, &Size, false);
        return pName.detach();
    }

    return 0;
}


#ifdef _DEBUG
void
CBaseQueue::GetQueue(OUT LPWSTR* lplpcsQueue)
{
    *lplpcsQueue = GetName();

    if(*lplpcsQueue == NULL)
    {
        *lplpcsQueue = new WCHAR[MAX_PATH];
        swprintf(*lplpcsQueue, L"Unknown or deleted queue at %p", this);
    }
}
#endif // _DEBUG

//
// Admin Functions
//
LPCWSTR
CQueue::GetConnectionStatus(
    void
    ) const
{
    CS lock(m_cs);

    if (IsLocalQueue() || IsConnectorQueue())
        return MGMT_QUEUE_STATE_LOCAL;

    if (IsOnHold())
        return MGMT_QUEUE_STATE_ONHOLD;

	//
	// Capture the group before checking the session. Otherwise we can get unstable state.
	// The queue doesn't belong to session group, therefore the session pointer is null. Now 
	// before capturing the group, the queue was moved to session group. As a result the queue
	// doesn't belong to build-in group any more and we got an assert.
	//
    const CQGroup* pGroup = GetGroup();
    
	if (m_pSession != NULL)
    {
        if (m_pSession->IsDisconnected())
        {
            return MGMT_QUEUE_STATE_DISCONNECTING;
        }
        else
        {
            return MGMT_QUEUE_STATE_CONNECTED;
        }
    }

	if (pGroup == NULL)
    {
		//
        // ISSUE-2001/07/11-urih: The queue is in transition mode. 
		//                        Need better synchronization between CQGroup and CQueue
        //
		return MGMT_QUEUE_STATE_NONACTIVE;
	}

    if (pGroup == g_pgroupNonactive)
        return MGMT_QUEUE_STATE_NONACTIVE;

    if (pGroup == g_pgroupWaiting)
        return MGMT_QUEUE_STATE_WAITING;

    if (pGroup == g_pgroupNotValidated)
        return MGMT_QUEUE_STATE_NEED_VALIDATE;

    if (pGroup == g_pgroupDisconnected)
        return MGMT_QUEUE_STATE_DISCONNECTED;

    if (IsDirectHttpQueue())
        return GetHTTPConnectionStatus();

    if (GetQueueType() == QUEUE_TYPE_MULTICAST)
        return MGMT_QUEUE_STATE_CONNECTED;

    ASSERT(0);
    return L"";

}


LPCWSTR
CQueue::GetHTTPConnectionStatus(
    void
    ) const
{
    ASSERT(IsDirectHttpQueue());

    R<CTransport> p = TmGetTransport(GetQueueName());
    if (p.get() == NULL)
        return MGMT_QUEUE_STATE_NONACTIVE;

    CTransport::ConnectionState state = p->State();
    switch (state)
    {
    case CTransport::csNotConnected:
        return MGMT_QUEUE_STATE_NONACTIVE;

    case CTransport::csConnected:
        return MGMT_QUEUE_STATE_CONNECTED;

    case CTransport::csShuttingDown:
        return MGMT_QUEUE_STATE_DISCONNECTING;

    case CTransport::csShutdownCompleted:
        return MGMT_QUEUE_STATE_DISCONNECTED;

    default:
        //
        // Illegal Connection state",
        //
        ASSERT(0);
    };

    return L"";
}


LPWSTR
CQueue::GetNextHop(
    void
    ) const
{
    CS lock(m_cs);

    if (!m_pSession)
    {
        if (GetQueueType() == QUEUE_TYPE_MULTICAST)
        {
            ASSERT(GetQueueName != NULL);
            return newwcs(GetQueueName());
        }
        return NULL;
    }

    return GetReadableNextHop(m_pSession->GetSessionAddress());
}


LPCWSTR
CQueue::GetType(
    void
    ) const
{
    switch (GetQueueType())
    {
        case QUEUE_TYPE_PUBLIC:
            ASSERT(IsDSQueue());
            return MGMT_QUEUE_TYPE_PUBLIC;

        case QUEUE_TYPE_PRIVATE:
            ASSERT(IsPrivateQueue());
            return MGMT_QUEUE_TYPE_PRIVATE;

        case QUEUE_TYPE_MACHINE:
            if (IsPrivateQueue())
            {
                ASSERT(!IsLocalQueue());
                return MGMT_QUEUE_TYPE_PRIVATE;
            }

            return MGMT_QUEUE_TYPE_MACHINE;

        case QUEUE_TYPE_CONNECTOR:
            ASSERT(IsConnectorQueue());
            return MGMT_QUEUE_TYPE_CONNECTOR;

        case QUEUE_TYPE_MULTICAST:
            return MGMT_QUEUE_TYPE_MULTICAST;

        case QUEUE_TYPE_UNKNOWN:
        {
			LPCWSTR lpcsTemp;

			if (IsDirectHttpQueue())
			{
				DirectQueueType dqt;
				lpcsTemp = FnParseDirectQueueType(m_qName, &dqt);
				ASSERT(lpcsTemp != NULL);

				//
				// skip machine name
				//
				lpcsTemp = wcspbrk(lpcsTemp, FN_HTTP_SEPERATORS);
				if ((lpcsTemp == NULL) ||
					(_wcsnicmp(lpcsTemp +1, FN_MSMQ_HTTP_NAMESPACE_TOKEN, FN_MSMQ_HTTP_NAMESPACE_TOKEN_LEN)) != 0)
					return MGMT_QUEUE_TYPE_PUBLIC;

				lpcsTemp = wcspbrk(lpcsTemp + 1, FN_HTTP_SEPERATORS);
				if (lpcsTemp == NULL)
					return MGMT_QUEUE_TYPE_PUBLIC;
			}
			else
			{
				//
				// The queue is remote direct queue. Check the queue Type
				// according to format name
				//
				lpcsTemp = wcschr(m_qName, L'\\');
			}

			ASSERT(lpcsTemp	!= NULL);
            if (_wcsnicmp(lpcsTemp+1,FN_PRIVATE_TOKEN, FN_PRIVATE_TOKEN_LEN) == 0)
            {
                return MGMT_QUEUE_TYPE_PRIVATE;
            }

			return MGMT_QUEUE_TYPE_PUBLIC;
        }

        default:
            ASSERT(0);
    }
    return L"";
}

void
CQueue::Resume(
    void
    )
{
	BOOL fOnHold = InterlockedExchange(&m_fOnHold, FALSE);
    if (!fOnHold)
    {
        //
        // The queue isn't in OnHold state. Can't execute resume
        //
        return;
    }

    DBGMSG((DBGMOD_QM,
            DBGLVL_TRACE,
            _T("Resume Queue: %ls. Move the Queue to NonActive Group"),GetQueueName()));

    //
    // return the Queue back to Non-Active group
    //
	CQGroup::MoveQueueToGroup(this, g_pgroupNonactive);

    //
    // Decrement the refernce count such the queue object cab be cleaned
    //
    Release();
}

void
CQueue::Pause(
    void
    )
{

	BOOL fOnHold = InterlockedExchange(&m_fOnHold, TRUE);
    if (fOnHold)
    {
        //
        // The queue is already onhold.
        //
        return;
    }

    DBGMSG((DBGMOD_QM,
            DBGLVL_TRACE,
            _T("Pause Queue: %ls."),GetQueueName()));

    //
    // Increment the reference count. So the Queue object will not cleaned up
    //
    AddRef();

    CTransportBase* pSession = NULL;
	{
		CS Lock(m_cs);
		//
		// When the queue move to onhold state, MSMQ disconnect the
		// session it belong to. As a result all the queues moved to
		// Nonactive group. When the QM gets the next message for sending
		// from this queue, it moves the Queue to OnHold greop
		//
		if ((IsOnHold()) && (m_pSession != NULL))
		{
			pSession = m_pSession;
			pSession->AddRef();
		}
	}

	if (pSession != NULL)
	{
		pSession->Disconnect();
		pSession->Release();
	}
}

const QUEUE_FORMAT
CBaseQueue::GetQueueFormat(
    void
    ) const
{
    QUEUE_FORMAT qf;

    switch (m_dwQueueType)
    {
        case QUEUE_TYPE_PUBLIC:
            ASSERT(IsDSQueue());
            qf.PublicID(*m_qid.pguidQueue);
            break;

        case QUEUE_TYPE_PRIVATE:
            ASSERT(IsPrivateQueue());
            qf.PrivateID(*m_qid.pguidQueue, m_qid.dwPrivateQueueId);
            break;

        case QUEUE_TYPE_MACHINE:
            if (IsPrivateQueue())
            {
                qf.PrivateID(*m_qid.pguidQueue, m_qid.dwPrivateQueueId);
            }
            else
            {
                qf.MachineID(*m_qid.pguidQueue);
            }
            break;

        case QUEUE_TYPE_CONNECTOR:
            ASSERT(m_fConnectorQueue);
            qf.ConnectorID(*m_qid.pguidQueue);
            break;

        case QUEUE_TYPE_MULTICAST:
            ASSERT(("CBaseQueue::GetQueueFormat for multicast queue is unexpected!", 0));
            break;

        case QUEUE_TYPE_UNKNOWN:
            qf.DirectID(const_cast<LPWSTR>(GetQueueName()));
            break;

        default:
            ASSERT(0);
    }

    return qf;
}


void
CQueue::Requeue(
    CQmPacket* pPacket
    )
{
    //
    // put packet in AC
    //
    HRESULT rc = ACPutPacket(GetQueueHandle(), pPacket->GetPointerToDriverPacket());

    if(FAILED(rc))
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, L"Failed to requeue message to queue: %ls", GetName()));
        LogHR(rc, s_FN, 90);
        throw exception();
    }
}


void
CQueue::EndProcessing(
    CQmPacket* pPacket
    )
{
    ACFreePacket(g_hAc, pPacket->GetPointerToDriverPacket());
}


void
CQueue::LockMemoryAndDeleteStorage(
    CQmPacket* pPacket
    )
{
    ASSERT(("CQueue::LockMemoryAndDeleteStorage should not be called!", 0));
}


void
CQueue::GetFirstEntry(
    EXOVERLAPPED* pov,
    CACPacketPtrs& acPacketPtrs
    )
{
    acPacketPtrs.pPacket = NULL;
    acPacketPtrs.pDriverPacket = NULL;

    //
    // Create new GetPacket request from the queue
    //
    HRESULT rc = ACGetPacket(
                    GetQueueHandle(),
                    acPacketPtrs,
                    pov
                    );

    if (FAILED(rc))
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, L"Failed to  generate get request from queue: %ls. Error %x", GetName(), rc));
        LogHR(rc, s_FN, 100);
        throw exception();
    }
}


void CQueue::CancelRequest(void)
{
    ASSERT(0);
}


bool CQueue::IsDirectHttpQueue(void) const
{
	if(GetQueueName())
		return FnIsHttpDirectID(GetQueueName());

	return false;
}


R<CQGroup> CQueue::CreateMessagePool(void)
{
    try
    {
        R<CQGroup> pGroup = new CQGroup();
        pGroup->InitGroup(NULL, TRUE);

		CQGroup::MoveQueueToGroup(this, pGroup.get());
		
		return pGroup;
    }
    catch(const exception&)
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, L"Failed to create connection for multicast address: %ls.", GetName()));
        LogIllegalPoint(s_FN, 70);
		
		IncRoutingRetry();
    
		SessionMgr.AddWaitingQueue(this);

        //
        // Don't move the queue to the waiting group before calling SessionMgr.AddWaitingQueue.
        // If exception is raised on sessionMgr, no one move the queue back to nonactive group
        // In such a case the queue stay on waiting state until re-boot
        //
        CQGroup::MoveQueueToGroup(this, g_pgroupWaiting);
		throw;
    }
}


void CQueue::CreateMulticastConnection(const MULTICAST_ID& id)
{
	R<CQGroup> pGroup = CreateMessagePool();
	
	try
	{
		R<COutPgmSessionPerfmon> pPerfmon = new COutPgmSessionPerfmon;

        MtmCreateTransport(pGroup.get(), pPerfmon.get(), id);
	}
	catch(const exception&)
	{
		pGroup->OnRetryableDeliveryError();
		throw;
	}
} 


void CQueue::CreateHttpConnection(void)
{
	R<CQGroup> pGroup = CreateMessagePool();

    try
    {
		R<COutHttpSessionPerfmon> pPerfmon = new COutHttpSessionPerfmon;

		TmCreateTransport(pGroup.get(), pPerfmon.get(), GetQueueName());
    }
    catch(const exception&)
    {
		pGroup->OnRetryableDeliveryError();
		throw;
    }
}



QUEUE_FORMAT_TRANSLATOR::QUEUE_FORMAT_TRANSLATOR(const QUEUE_FORMAT* pQueueFormat)
/*++
Routine Description:
	Translate given queue format according to local mapping	 (qal.lib)

Arguments:
	IN - pQueueFormat - queue format to translate.


Returned Value:


--*/
{
	m_FormatName = *pQueueFormat;

	//
	// If not direct - not translation
	//
    if(pQueueFormat->GetType() != QUEUE_FORMAT_TYPE_DIRECT)
	{
		return ;		
	}
 	
	AP<WCHAR> pRealQueueName;
	bool fSuccess =  QalGetMapping().GetQueue(pQueueFormat->DirectID(), &pRealQueueName);
	if(fSuccess)
	{
		m_FormatName.DirectID(pRealQueueName.get());
		m_MemoryToDelete = 	pRealQueueName.detach();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\cqmgr.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cqmgr.h

Abstract:

    Declaration of the QM outbound queue manager

Author:

    Uri Habusha (urih)

--*/

#ifndef __CQMGR_H__
#define __CQMGR_H__

#include "session.h"
#include "cgroup.h"
#include "cqueue.h"
#include "qmsecutl.h"
#include "qmutil.h"
#include "ac.h"


class CQueueMgr
{
public:

    CQueueMgr();
    ~CQueueMgr();

    BOOL
    InitQueueMgr(
        void
        );

    HRESULT
    OpenQueue(
        const QUEUE_FORMAT * pQueueFormat,
        DWORD              dwCallingProcessID,
        DWORD              dwAccess,
        DWORD              dwShareMode,
        CQueue * *         ppQueue,
        LPWSTR *           lplpwsRemoteQueueName,
        PHANDLE            phQueue,
        BOOL               fRemote = FALSE
        );

    HRESULT
    OpenMqf(
        ULONG              nTopLevelMqf,
        const QUEUE_FORMAT TopLevelMqf[],
        DWORD              dwCallingProcessID,
        HANDLE *           phDistribution
        );

    HRESULT
    OpenRRQueue(
        const QUEUE_FORMAT*          pQueueFormat,
        DWORD                        dwCallingProcessID,
        DWORD                        dwAccess,
        DWORD                        dwShareMode,
        ULONG                        srv_hACQueue,
        ULONG                        srv_pQMQueue,
        DWORD                        dwpContext,
        PHANDLE                      phQueue,
        CRRQueue * *                 ppQueue,
        PCTX_RRSESSION_HANDLE_TYPE * ppRRContext);

    HRESULT
    ValidateOpenedQueues(
        void
        );

    HRESULT
    ValidateMachineProperties(
        void
        );

    HRESULT
    OpenAppsReceiveQueue(
        const QUEUE_FORMAT *         pQueueFormat,
        LPRECEIVE_COMPLETION_ROUTINE lpReceiveRoutine
        );

    HRESULT
    SendPacket(
        CMessageProperty *   pmp,
        const QUEUE_FORMAT   DestinationMqf[],
        ULONG                nDestinationMqf,
        const QUEUE_FORMAT * pAdminQueueFormat,
        const QUEUE_FORMAT * pResponseQueueFormat
        );

    void
    AddQueueToHashAndList(
        CQueue* pQueue
        );

    void
    RemoveQueueFromHash(
        CQueue* pQueue
        );

    void
    AddRRQueueToHashAndList(
        CRRQueue* pQueue
        );

    void
    RemoveQueue(
        CQueue * pQueue,
        LONGLONG * pliSeqId
        );

    void
    RemoveRRQueue(
        CRRQueue* pQueue
        );

    void
    ReleaseQueue(
        void
        );

    HRESULT
    GetQueueObject(
        const QUEUE_FORMAT * pqf,
        CQueue * *           ppQueue,
        const GUID *         pgConnectorQM,
        bool                 fInReceive
        );

    BOOL
    LookUpQueue(
        const QUEUE_FORMAT * pqf,
        CQueue * *           ptQueue,
        bool                 fInReceive,
        bool                 fInSend
        );

    BOOL
    LookUpRRQueue(
        const QUEUE_FORMAT * pqf,
        CRRQueue * *         ptQueue
        );

    void
    NotifyQueueDeleted(
        const GUID *
        );

    VOID
    UpdateQueueProperties(
        const QUEUE_FORMAT * pQueueFormat,
        DWORD                cpObject,
        PROPID               pPropObject[],
        PROPVARIANT          pVarObject[]
        );

    void
    UpdateMachineProperties(
        DWORD       cpObject,
        PROPID      pPropObject[],
        PROPVARIANT pVarObject[]
        );

    BOOL
    IsOnHoldQueue(
        const CQueue* pQueue
        )
    {
        return (!IsConnected() || pQueue->IsOnHold());
    }

    void
    MoveQueueToOnHoldGroup(
        CQueue * pQueue
        );

#ifdef _DEBUG

	bool
    IsQueueInList(
        const CBaseQueue * pQueue
        );

#endif

    static
    bool
    IsConnected(
        void
        )
    {
        return (m_Connected != 0);
    }

    static
    void
    InitConnected(
        void
        );

    void
    SetConnected(
        bool
        );

    static
    bool
    CanAccessDS(
        void
        )
    {
        return  (IsConnected() && IsDSOnline());
    }

    static
    HRESULT
        SetQMGuid(
        void
        );

    static
    HRESULT
    SetQMGuid(
        const GUID * pGuid
        );

    static
    const GUID*
    GetQMGuid(
        void
        )
    {
	    ASSERT( m_guidQmQueue != GUID_NULL);
        return(&m_guidQmQueue);
    }

    static
    bool
    IsDSOnline(
        void
        )
    {
        return m_fDSOnline;
    }

    static
    void
    SetDSOnline(
        bool f
        )
    {
        m_fDSOnline = f;
    }

    static
    void
    SetReportQM(
        bool f
        )
    {
        m_fReportQM = f;
    }

    static
    bool
    IsReportQM(
        void
        )
    {
        return m_fReportQM;
    }

    static
    HRESULT
    SetMQSRouting(
        void
        );

    static
    bool
    GetMQSRouting(
        void
        )
    {
        return m_bMQSRouting;
    }

    static
    HRESULT
    SetMQSDepClients(
        void
        );

    static
    bool
    GetMQSDepClients(
        void
        )
    {
        return m_bMQSDepClients;
    }

    static
    void
    WINAPI
    QueuesCleanup(
        CTimer * pTimer
        );

    //
    // Administration functions
    //

    void
    GetOpenQueuesFormatName(
        LPWSTR** pppFormatName,
        LPDWORD  pdwFormatSize
        );

    static
    HRESULT
    SetMessageSizeLimit(
        void
        );

    static
    ULONG
    GetMessageSizeLimit(
        void
        )
    {
        return m_MessageSizeLimit;
    }

private:

    HRESULT
    CreateACQueue(
        CQueue *             pQueue,
        const QUEUE_FORMAT * pQueueFormat
        );

    //
    //  Create standard queue object. For send and local read.
    //
    HRESULT
    CreateQueueObject(
        const QUEUE_FORMAT * pQueueFormat,
        CQueue * *           ppQueue,
        DWORD                dwAccess,
        LPWSTR *             lplpwsRemoteQueueName,
        BOOL *               pfRemoteReturn,
        BOOL                 fRemoteServer,
        const GUID *         pgConnectorQM,
        bool                 fInReceive
        );


    //
    //  Create "proxy" queue object on client side of remote reader.
    //
    HRESULT
    CreateRRQueueObject(
        const QUEUE_FORMAT * pQueueFormat,
        CRRQueue * *         ppQueue
        );

    void
    AddToActiveQueueList(
        const CBaseQueue * pQueue
        );

    HRESULT
    GetDistributionQueueObject(
        ULONG              nTopLevelMqf,
        const QUEUE_FORMAT TopLevelMqf[],
        CQueue * *         ppQueue
        );

    VOID
    ExpandMqf(
        ULONG              nTopLevelMqf,
        const QUEUE_FORMAT TopLevelMqf[],
        ULONG *            pnLeafMqf,
        QUEUE_FORMAT * *   ppLeafMqf
        ) const;

    HRESULT
    CreateACDistribution(
        ULONG              nTopLevelMqf,
        const QUEUE_FORMAT TopLevelMqf[],
        ULONG              nLeafMqf,
        const R<CQueue>    LeafQueues[],
        const bool         ProtocolSrmp[],
        HANDLE *           phDistribution
        );

private:

    CCriticalSection m_cs;

    //
    // Guid of the QM queue
    //
    static GUID m_guidQmQueue;

    //
    // DS initilization status
    //
    static bool m_fDSOnline;

    static LONG m_Connected;
    static bool m_fReportQM;
    static bool m_bMQSRouting;
    static bool m_bMQSDepClients;

    static ULONG m_MessageSizeLimit;

    CTimeDuration m_CleanupTimeout;

    CMap<const QUEUE_ID*, const QUEUE_ID*, CQueue*, CQueue*&> m_MapQueueId2Q ;
    CMap<LPCTSTR, LPCTSTR, CQueue*, CQueue*&> m_MapName2Q;

    //
    //  Mapping object for remote-read proxy queues.
    //
    CMap<const QUEUE_ID*, const QUEUE_ID*, CRRQueue*, CRRQueue*&> m_MapQueueId2RRQ ;

    //
    // Hash table mapped queue Name to CQueue objects.
    //
    CMap<LPCTSTR, LPCTSTR, CRRQueue*, CRRQueue*&> m_MapName2RRQ;

    //
    // Clean Up variables
    //
    BOOL m_fQueueCleanupScheduled;
    CTimer m_QueueCleanupTimer;
    CList <const CBaseQueue *, const CBaseQueue *> m_listQueue;
};


extern CQueueMgr QueueMgr;

//
//  Compare two const strings
//
extern BOOL AFXAPI  CompareElements(const LPCTSTR* MapName1, const LPCTSTR* MapName2);



HRESULT
QmpGetQueueProperties(
    const QUEUE_FORMAT * pQueueFormat,
    PQueueProps          pQueueProp,
    bool                 fInReceive
    );


inline
BOOL
QmpIsLocalMachine(
    const GUID * pGuid
    )
{
    return(pGuid ? (*pGuid == *CQueueMgr::GetQMGuid()) : FALSE);
}


#endif // __CQMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\cqmgr.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cqmgr.cpp

Abstract:

    Definition of the QM outbound queue manager

Author:

    Uri Habusha (urih)

--*/

#include "stdh.h"
#include <mqwin64a.h>
#include <mqformat.h>
#include <Msm.h>
#include "cqmgr.h"
#include "qmthrd.h"
#include "cgroup.h"
#include "cqpriv.h"
#include "session.h"
#include "sessmgr.h"
#include <ac.h>
#include <mqsec.h>
#include "regqueue.h"
#include "qmutil.h"
#include "qmsecutl.h"
#include "fntoken.h"
#include "xactout.h"
#include <fn.h>
#include <adsiutil.h>
#include <autohandle.h>
#include "qmds.h"
#include "ad.h"

#include "cqmgr.tmh"

extern HANDLE g_hAc;
extern HANDLE g_hMachine;
extern CQGroup * g_pgroupNonactive;
extern CQGroup * g_pgroupNotValidated;
extern CQGroup* g_pgroupDisconnected;
extern LPTSTR g_szMachineName;
extern AP<WCHAR> g_szComputerDnsName;
extern DWORD  g_dwOperatingSystem;
extern CSessionMgr SessionMgr;
extern BOOL g_fWorkGroupInstallation;

static WCHAR *s_FN=L"cqmgr";
const TraceIdEntry QmMqf = L"QM MQF";


LONGLONG g_NextSeqID;
inline void InitNextSeqID()
{
    //
    // Read previous SeqID from the registry
    // N.B. if GetFalconKeyValue fails, it does not change RegSeqID value
    //
    //
    DWORD Type = REG_DWORD;
    DWORD Size = sizeof(DWORD);

    DWORD RegSeqID = 0;
    GetFalconKeyValue(
        MSMQ_SEQ_ID_REGNAME,
        &Type,
        &RegSeqID,
        &Size
        );

    //
    // Increment by 1, so we will not use the same SeqID more than once in
    // successive boots.
    //
    ++RegSeqID;

    //
    // Select the max SeqID, Time or Registry. This overcomes date/time changes
    // on this computer.
    //
    DWORD TimeSeqID = MqSysTime();
    DWORD SeqID = max(RegSeqID, TimeSeqID);

    //
    // Write-back selected SeqID
    //
    SetFalconKeyValue(
        MSMQ_SEQ_ID_REGNAME,
        &Type,
        &SeqID,
        &Size
        );

    ((LARGE_INTEGER*)&g_NextSeqID)->HighPart = SeqID;

    DBGMSG((DBGMOD_QM, DBGLVL_WARNING, _TEXT("QM sets starting SeqID: %x"), RegSeqID)) ;
}


inline LONGLONG GetNextSeqID()
{
    return ++g_NextSeqID;
}


inline BOOL IsPublicQueue(const QUEUE_FORMAT* pQueue)
{
    return (pQueue->GetType() == QUEUE_FORMAT_TYPE_PUBLIC);
}

inline BOOL IsPrivateQueue(const QUEUE_FORMAT* pQueue)
{
    return (pQueue->GetType() == QUEUE_FORMAT_TYPE_PRIVATE);
}

inline BOOL IsDirectQueue(const QUEUE_FORMAT* pQueue)
{
    return (pQueue->GetType() == QUEUE_FORMAT_TYPE_DIRECT);
}

inline BOOL IsMachineQueue(const QUEUE_FORMAT* pQueue)
{
    return (pQueue->GetType() == QUEUE_FORMAT_TYPE_MACHINE);
}

inline BOOL IsConnectorQueue(const QUEUE_FORMAT* pQueue)
{
    return (pQueue->GetType() == QUEUE_FORMAT_TYPE_CONNECTOR);
}

inline BOOL IsNormalQueueType(const QUEUE_FORMAT* pQueue)
{
    return (pQueue->Suffix() == QUEUE_SUFFIX_TYPE_NONE);
}

inline BOOL IsJournalQueueType(const QUEUE_FORMAT* pQueue)
{
    return (pQueue->Suffix() == QUEUE_SUFFIX_TYPE_JOURNAL);
}

inline BOOL IsDeadXactQueueType(const QUEUE_FORMAT* pQueue)
{
    return (pQueue->Suffix() == QUEUE_SUFFIX_TYPE_DEADXACT);
}

inline BOOL IsDeadLetterQueueType(const QUEUE_FORMAT* pQueue)
{
    return (pQueue->Suffix() == QUEUE_SUFFIX_TYPE_DEADLETTER);
}

inline BOOL IsMulticastQueue(const QUEUE_FORMAT* pQueue)
{
    return (pQueue->GetType() == QUEUE_FORMAT_TYPE_MULTICAST);
}

inline DWORD MQAccessToFileAccess(DWORD dwAccess)
{
    DWORD dwFileAccess = 0;

    if (dwAccess & (MQ_RECEIVE_ACCESS | MQ_PEEK_ACCESS))
    {
        dwFileAccess |= FILE_READ_ACCESS;
    }

    if (dwAccess & MQ_SEND_ACCESS)
    {
        dwFileAccess |= FILE_WRITE_ACCESS;
    }

    return dwFileAccess;
}


static CMap<GUID,  const GUID&, BOOL, BOOL> ForeignMachineMap;

BOOL IsForeignMachine(const GUID* pGuid)
{
    BOOL val = FALSE;

    if (!ForeignMachineMap.Lookup(*pGuid, val) &&
        (CQueueMgr::CanAccessDS()))
    {
        PROPID      aProp[1];
        PROPVARIANT aVar[1];
        ULONG       cProps = sizeof(aProp) / sizeof(PROPID);
        HRESULT     rc;

        aProp[0] = PROPID_QM_FOREIGN;
        aVar[0].vt = VT_NULL;

        rc = ADGetObjectPropertiesGuid(
                        eMACHINE,
                        NULL,   // pwcsDomainController
						false,	// fServerName
                        pGuid,
                        cProps,
                        aProp,
                        aVar
						);
        if (SUCCEEDED(rc))
        {
            val = ForeignMachineMap[*pGuid] = (aVar[0].bVal != MSMQ_MACHINE);
        }
    }

    return val;
}


static
VOID
QMpUpdateMulticastBinding(
    const QUEUE_FORMAT * pQueueFormat,
    DWORD       cp,
    PROPID      aProp[],
    PROPVARIANT aVar[]
    )
{
    //
    // Transactional queues ignore the multicast property.
    //
    // We either have the transactional queue property in the aProp argument,
    // or the queue is not transactional (in the case of create private queue), or
    // both the transactional and multicast properties are not in the aProp arguments
    // (in the case of handling DS notification from downlevel platforms).
    //
    for (DWORD ix = 0; ix < cp; ++ix)
    {
        if (aProp[ix] == PROPID_Q_TRANSACTION && aVar[ix].bVal)
        {
            DBGMSG((DBGMOD_QM, DBGLVL_INFO, L"Do not update multicast binding for transactional queue"));
            return;
        }
    }

    for (DWORD ix = 0; ix < cp; ++ix)
    {
        if (aProp[ix] == PROPID_Q_MULTICAST_ADDRESS)
        {
            if (aVar[ix].vt == VT_EMPTY)
            {
                MsmUnbind(*pQueueFormat);
                return;
            }

            ASSERT(("VT must be VT_LPWSTR", aVar[ix].vt == VT_LPWSTR));
            ASSERT(("NULL not allowed", aVar[ix].pwszVal != NULL));
            ASSERT(("Empty string not allowed", L'\0' != *aVar[ix].pwszVal));

            MULTICAST_ID MulticastId;
            FnParseMulticastString(aVar[ix].pwszVal, &MulticastId);

            try
            {
                MsmBind(*pQueueFormat, MulticastId);
            }
            catch (const bad_win32_error& e)
            {
                WCHAR wzError[20];
                _ultot(e.error(), wzError, 16);
                LogIllegalPoint(s_FN, 2000);
                REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL, MULTICAST_BIND_ERROR, 2, aVar[ix].pwszVal, wzError));
            }

            return;
        }
    }
} // QMpUpdateMulticastBinding


/*======================================================

Function:      GetMachineProperty

Description:   query the database, and gets the MACHINE path name

Arguments:     pQueueFormat - pointer to format name

Return Value:  pQueueProp - pointer to QueueProp Structure that contains the
               Machine property

History Change:

========================================================*/
HRESULT GetMachineProperty(IN  const QUEUE_FORMAT* pQueueFormat,
                           OUT PQueueProps    pQueueProp)
{
    ASSERT(IsMachineQueue(pQueueFormat));

    PROPID      aProp[3];
    PROPVARIANT aVar[3];
    ULONG       cProps = sizeof(aProp) / sizeof(PROPID);
    HRESULT     rc = MQ_ERROR_NO_DS;

    aProp[0] = PROPID_QM_PATHNAME;
    aProp[1] = PROPID_QM_QUOTA;
    aProp[2] = PROPID_QM_JOURNAL_QUOTA;

    aVar[0].vt = VT_NULL;
    aVar[1].vt = VT_UI4;
    aVar[2].vt = VT_UI4;

    //
    // SP4, bug# 2962. postpone the MQIS initialization until it realy required
    //
    MQDSClientInitializationCheck();

    if (CQueueMgr::CanAccessDS())
    {
        rc = ADGetObjectPropertiesGuid(
                        eMACHINE,
                        NULL,   // pwcsDomainController
						false,	// fServerName
                        &pQueueFormat->MachineID(),
                        cProps,
                        aProp,
                        aVar
						);
    }

    pQueueProp->fJournalQueue = FALSE;
    pQueueProp->pQMGuid = new GUID;
    *pQueueProp->pQMGuid = pQueueFormat->MachineID();
    pQueueProp->fTransactedQueue = FALSE;
    pQueueProp->fIsLocalQueue = QmpIsLocalMachine(pQueueProp->pQMGuid);
    pQueueProp->fForeign = IsForeignMachine(pQueueProp->pQMGuid);


    if (SUCCEEDED(rc))
    {
        pQueueProp->lpwsQueuePathName = aVar[0].pwszVal;
        pQueueProp->dwQuota = aVar[1].ulVal;
        pQueueProp->dwJournalQuota = aVar[2].ulVal;
        pQueueProp->fUnknownQueueType = FALSE;
    }
    else
    {
        //
        // If we cannot connect to the DS, or we are working in a Workgroup environment,
        // and we deal with the local computer - try the registry.
        //
        if ((rc == MQ_ERROR_NO_DS || rc == MQ_ERROR_UNSUPPORTED_OPERATION) && (pQueueProp->fIsLocalQueue))
        {
            //
            // Retreive the machine properties from registery
            //
            pQueueProp->lpwsQueuePathName = new WCHAR[wcslen(g_szMachineName) +1];
            wcscpy(pQueueProp->lpwsQueuePathName, g_szMachineName);
            GetMachineQuotaCache(&(pQueueProp->dwQuota), &(pQueueProp->dwJournalQuota));
            rc = MQ_OK;
        }
        else
        {
            pQueueProp->lpwsQueuePathName = NULL;
            pQueueProp->dwQuota = 0;
            pQueueProp->dwJournalQuota = 0;
        }
    }

    return LogHR(rc, s_FN, 10);
}

/*======================================================

Function:      GetDSQueueProperty

Description:   query the database, and gets the DS Queue path name,
               Quata, QMID and Jornal

Arguments:     pQueueFormat - pointer to format name

Return Value:  pQueueProp - pointer to QueueProp Structure that contains the
               Machine property

History Change:

========================================================*/

HRESULT GetDSQueueProperty(IN  const QUEUE_FORMAT* pQueueFormat,
                           OUT PQueueProps         pQueueProp)
{
    ASSERT(IsPublicQueue(pQueueFormat));
    HRESULT rc = MQ_ERROR_NO_DS ;
    BOOL fGotDSInfo = FALSE;

    PROPID aProp[12];
    PROPVARIANT aVar[12];
    ULONG  cProps = sizeof(aProp) / sizeof(PROPID);

    aProp[0] = PROPID_Q_PATHNAME;
    aProp[1] = PROPID_Q_JOURNAL;
    aProp[2] = PROPID_Q_QUOTA;
    aProp[3] = PROPID_Q_QMID;
    aProp[4] = PROPID_Q_JOURNAL_QUOTA;
    aProp[5] = PROPID_Q_BASEPRIORITY;
    aProp[6] = PROPID_Q_TRANSACTION;
    aProp[7] = PROPID_Q_AUTHENTICATE;
    aProp[8] = PROPID_Q_PRIV_LEVEL;
    aProp[9] = PROPID_Q_INSTANCE;
    //
    // Note the following property is supported by MSMQ 3.0 and higher in AD schema of
    // Whistler version and higher. In other cases our AD provider will return VT_EMPTY and MQ_OK.
    //
    aProp[10] = PROPID_Q_MULTICAST_ADDRESS;
    //
    // Note the following property is supported by MSMQ 2.0 and higher in AD schema of
    // Win2K version and higher. In other cases our AD provider will return MQ_ERROR.
    //
    aProp[11] = PROPID_Q_PATHNAME_DNS;

    aVar[0].vt = VT_NULL;
    aVar[1].vt = VT_UI1;
    aVar[2].vt = VT_UI4;
    aVar[3].vt = VT_NULL;
    aVar[4].vt = VT_UI4;
    aVar[5].vt = VT_I2;
    aVar[6].vt = VT_UI1;
    aVar[7].vt = VT_UI1;
    aVar[8].vt = VT_UI4;
    aVar[9].vt = VT_CLSID;
    aVar[10].vt = VT_NULL;
    aVar[11].vt = VT_NULL;

    GUID gQueueID;
    aVar[9].puuid = &gQueueID;

    //
    // SP4, bug# 2962. postpone the MQIS initialization until it realy required
    //
    MQDSClientInitializationCheck();

    if (CQueueMgr::CanAccessDS())
    {
        rc = ADGetObjectPropertiesGuid(
					eQUEUE,
					NULL,     // pwcsDomainController
					false,	  // fServerName
					&pQueueFormat->PublicID(),
					cProps,
					aProp,
					aVar
					);
        //
        //  MSMQ 1.0 DS server do not support PROPID_Q_PATHNAME_DNS
        //  and return MQ_ERROR in case of unsupported property.
        //  If such error is returned, assume MSMQ 1.0 DS and try again
        //  this time without PROPID_Q_PATHNAME_DNS.
        //
        if ( rc == MQ_ERROR)
        {
            aVar[11].vt = VT_EMPTY;
            ASSERT(aProp[cProps - 1] == PROPID_Q_PATHNAME_DNS);

            rc = ADGetObjectPropertiesGuid(
							eQUEUE,
							NULL,     // pwcsDomainController
							false,	  // fServerName
							&pQueueFormat->PublicID(),
							cProps - 1,
							aProp,
							aVar
							);
        }

        if (SUCCEEDED(rc))
        {
            //
            // We look for the enhanced key first, and ignore error.
            // If we are not able to get the base key, however, this is a real
            // problem. If it is because of NO_DS, the oper should fail (DS failed
            // between get props and GetSendQMKeyxPbKey). Otherwise, we will open
            // the queue and non-encrypted messages will work. We will try again on send
            // encrypted messages. (YoelA - 13-Jan-2000).
            // propagated to Whistler by DoronJ, apr-2000.
            //
            HRESULT rcEnhanced = GetSendQMKeyxPbKey( aVar[3].puuid,
                                                     eEnhancedProvider ) ;
            LogHR(rcEnhanced, s_FN, 2221);

            HRESULT rcBase = GetSendQMKeyxPbKey( aVar[3].puuid,
                                                 eBaseProvider );
            LogHR(rcBase, s_FN, 2220);

            if (SUCCEEDED(rcBase))
            {
                fGotDSInfo = TRUE;
            }
            else if (rcBase == MQ_ERROR_NO_DS)
            {
                rc = rcBase ;
            }
        }
    }

    if (rc == MQ_ERROR_NO_DS)
    {
        //
        // Cleanup aVar members that were dynamically allocated and get their cached values
        //

        if (aVar[0].vt == VT_LPWSTR)
        {
            delete [] aVar[0].pwszVal;
        }
        aVar[0].vt = VT_NULL;

        if (aVar[3].vt == VT_CLSID)
        {
            delete aVar[3].puuid;
        }
        aVar[3].vt = VT_NULL;

        if (aVar[10].vt == VT_LPWSTR)
        {
            delete [] aVar[10].pwszVal;
        }
        aVar[10].vt = VT_NULL;

        if (aVar[11].vt == VT_LPWSTR)
        {
            delete [] aVar[11].pwszVal;
        }
        aVar[11].vt = VT_NULL;

        rc = GetCachedQueueProperties(
                cProps,
                aProp,
                aVar,
                &pQueueFormat->PublicID()
                );
    }

    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 20);
    }

    pQueueProp->lpwsQueuePathName = aVar[0].pwszVal;
    if ( aVar[11].vt != VT_EMPTY)
    {
        pQueueProp->lpwsQueueDnsName = aVar[11].pwszVal;
    }
    pQueueProp->fJournalQueue     = aVar[1].bVal;
    pQueueProp->dwQuota           = aVar[2].ulVal;
    pQueueProp->pQMGuid           = aVar[3].puuid;
    pQueueProp->dwJournalQuota    = aVar[4].ulVal;
    pQueueProp->siBasePriority    = aVar[5].iVal;
    pQueueProp->fIsLocalQueue     = QmpIsLocalMachine(pQueueProp->pQMGuid);
    pQueueProp->fTransactedQueue  = aVar[6].bVal;
    pQueueProp->fAuthenticate     = aVar[7].bVal;
    pQueueProp->dwPrivLevel       = aVar[8].ulVal;
    pQueueProp->fForeign          = IsForeignMachine(pQueueProp->pQMGuid);
    pQueueProp->fUnknownQueueType = FALSE;


    if (pQueueProp->fIsLocalQueue && fGotDSInfo)
    {
        //
        // In case we got the proerties from the DS and this is a local queue, update the
        // public queue cache.
        //
        SetCachedQueueProp(&pQueueFormat->PublicID(),
                           cProps,
                           aProp,
                           aVar,
                           TRUE,
                           TRUE,
                           time(NULL));

        QMpUpdateMulticastBinding(pQueueFormat, cProps, aProp, aVar);
    }

    return MQ_OK;
}

/*======================================================

Function:      GetPrivateQueueProperty

Description:   query the database, and gets the private Queue path name,
               Quata, QMID and Jornal

Arguments:     pQueueFormat - pointer to format name

Return Value:  pQueueProp - pointer to QueueProp Structure that contains the
               Machine property

History Change:

========================================================*/
HRESULT GetPrivateQueueProperty(IN  const QUEUE_FORMAT* pQueueFormat,
                                OUT PQueueProps         pQueueProp)
{
    ASSERT(IsPrivateQueue(pQueueFormat));

    PROPID      aProp[9];
    PROPVARIANT aVar[9];
    ULONG       cProps = sizeof(aProp) / sizeof(PROPID);
    HRESULT     rc = MQ_OK;

    aProp[0] = PROPID_Q_PATHNAME;
    aProp[1] = PROPID_Q_JOURNAL;
    aProp[2] = PROPID_Q_QUOTA;
    aProp[3] = PROPID_Q_JOURNAL_QUOTA;
    aProp[4] = PROPID_Q_BASEPRIORITY;
    aProp[5] = PROPID_Q_TRANSACTION;
    aProp[6] = PPROPID_Q_SYSTEMQUEUE ;
    aProp[7] = PROPID_Q_AUTHENTICATE;
    aProp[8] = PROPID_Q_PRIV_LEVEL;

    aVar[0].vt = VT_NULL;
    aVar[1].vt = VT_UI1;
    aVar[2].vt = VT_UI4;
    aVar[3].vt = VT_UI4;
    aVar[4].vt = VT_I2;
    aVar[5].vt = VT_UI1;
    aVar[6].vt = VT_UI1;
    aVar[7].vt = VT_UI1;
    aVar[8].vt = VT_UI4;

    if (QmpIsLocalMachine(&pQueueFormat->PrivateID().Lineage))
    {
        //
        // Local Private Queue
        //
        rc = g_QPrivate.QMGetPrivateQueuePropertiesInternal(
                            pQueueFormat->PrivateID().Uniquifier,
                            cProps,
                            aProp,
                            aVar
                            );

        if (SUCCEEDED(rc))
        {
            pQueueProp->lpwsQueuePathName   = aVar[0].pwszVal;
            pQueueProp->fJournalQueue       = aVar[1].bVal;
            pQueueProp->dwQuota             = aVar[2].ulVal;
            pQueueProp->dwJournalQuota      = aVar[3].ulVal;
            pQueueProp->siBasePriority      = aVar[4].iVal;
            pQueueProp->fIsLocalQueue       = TRUE;
            pQueueProp->fTransactedQueue    = aVar[5].bVal;
            pQueueProp->fSystemQueue        = aVar[6].bVal;
            pQueueProp->fAuthenticate       = aVar[7].bVal;
            pQueueProp->dwPrivLevel         = aVar[8].ulVal;
            pQueueProp->fUnknownQueueType   = FALSE;
        }
    }
    else
    {
        {
            //
            // Create queue name "machine guid\queue id"
            //

            GUID_STRING strUuid;
            MQpGuidToString(&pQueueFormat->PrivateID().Lineage, strUuid);

            pQueueProp->lpwsQueuePathName = new WCHAR[wcslen(strUuid) +10];
            swprintf(pQueueProp->lpwsQueuePathName, L"%s" FN_PRIVATE_SEPERATOR FN_PRIVATE_ID_FORMAT,
                              strUuid, pQueueFormat->PrivateID().Uniquifier);

        }
        pQueueProp->fIsLocalQueue = FALSE;
        pQueueProp->fJournalQueue = FALSE;
        pQueueProp->dwQuota = 0;
        pQueueProp->dwJournalQuota = 0;
        pQueueProp->siBasePriority = 0;
        pQueueProp->fTransactedQueue = FALSE;
        pQueueProp->fSystemQueue = FALSE ;
        pQueueProp->fAuthenticate = FALSE;
        pQueueProp->dwPrivLevel = MQ_PRIV_LEVEL_OPTIONAL;
        pQueueProp->fUnknownQueueType = TRUE;

        //
        // If we send to a system queue then we want max priority.
        // All system queues on all machines have the same ID number
        // so check local machine to see if the ID is one of a system
        // queue and retrieve its base priority.
        //
        if (g_QPrivate.IsPrivateSysQueue(
                                 pQueueFormat->PrivateID().Uniquifier))
        {
            aProp[0] = PROPID_Q_BASEPRIORITY;
            aVar[0].vt = VT_I2;
            rc = g_QPrivate.GetPrivateSysQueueProperties(1,
                                                         aProp,
                                                         aVar ) ;
            ASSERT(rc == MQ_OK) ;
            if (rc == MQ_OK)
            {
               pQueueProp->siBasePriority = aVar[0].iVal;
               pQueueProp->fSystemQueue = TRUE ;
            }
        }
        rc = MQ_OK ;
    }
    pQueueProp->pQMGuid = new GUID;
    *pQueueProp->pQMGuid = pQueueFormat->PrivateID().Lineage;
    pQueueProp->fForeign = IsForeignMachine(const_cast<GUID*>(&(pQueueFormat->PrivateID().Lineage)));

    if (SUCCEEDED(rc) && !pQueueProp->fIsLocalQueue)
    {
       //
       // Private queue on remote machine.
       //

       //
       // SP4, bug# 2962. postpone the MQIS initialization until it realy required
       //
       MQDSClientInitializationCheck();

       if (CQueueMgr::CanAccessDS())
       {
            //
            // We look for the enhanced key first, and ignore error.
            // If we are not able to get the base key, however, this is a real
            // problem. If it is because of NO_DS, the oper should fail (DS failed
            // between get props and GetSendQMKeyxPbKey). Otherwise, we will open
            // the queue and non-encrypted messages will work. We will try again on send
            // encrypted messages. (YoelA - 13-Jan-2000).
            // propagated to Whistler by DoronJ, apr-2000
            //
            HRESULT rcEnhanced = GetSendQMKeyxPbKey( pQueueProp->pQMGuid,
                                                     eEnhancedProvider ) ;
            LogHR(rcEnhanced, s_FN, 2231);

            HRESULT rcBase = GetSendQMKeyxPbKey( pQueueProp->pQMGuid,
                                                 eBaseProvider );
            LogHR(rcBase, s_FN, 2230);

            if (rcBase == MQ_ERROR_NO_DS)
            {
                rc = rcBase ;
            }
            else
            {
                rc = MQ_OK;
            }
       }
       else
       {
            //
            // Return this error to prevent premature routing.
            //
            rc = MQ_ERROR_NO_DS ;
       }
    }

    return LogHR(rc, s_FN, 30);
}

/*======================================================

Function:      GetConnectorQueueProperty

Description:

Arguments:

Return Value:

History Change:

========================================================*/
HRESULT
GetConnectorQueueProperty(
    const QUEUE_FORMAT* pQueueFormat,
    PQueueProps         pQueueProp
    )
{
    ASSERT(IsConnectorQueue(pQueueFormat));

    //
    // This code added as part of QFE 2738 that fixed connector
	// rcovery problem (urih, 3-Feb-98)
	//
    BOOL fXactOnly = (pQueueFormat->Suffix() == QUEUE_SUFFIX_TYPE_XACTONLY) ? TRUE : FALSE;
    {
        //
        // Create queue name "CONNECTOR=CN id"
        //
        GUID_STRING strUuid;
        MQpGuidToString(&pQueueFormat->ConnectorID(), strUuid);

        DWORD dwFormatNameSize = FN_CONNECTOR_TOKEN_LEN + 1 +  // L"CONNECTOR="
                                 wcslen(strUuid) +             // Connector Guid
                                 FN_DEADXACT_SUFFIX_LEN +      // L";XACTONLY"
                                 1;                            // L"\0'

        pQueueProp->lpwsQueuePathName = new WCHAR[dwFormatNameSize];
        swprintf(pQueueProp->lpwsQueuePathName,L"%s=%s", FN_CONNECTOR_TOKEN, strUuid);
        if (fXactOnly)
        {
            wcscat(pQueueProp->lpwsQueuePathName, FN_DEADXACT_SUFFIX);
        }
    }
    pQueueProp->fJournalQueue     = FALSE;
    pQueueProp->dwQuota           = DEFAULT_Q_QUOTA;
    pQueueProp->pQMGuid           = NULL;
    pQueueProp->dwJournalQuota    = 0;
    pQueueProp->siBasePriority    = DEFAULT_Q_BASEPRIORITY;
    pQueueProp->fIsLocalQueue     = FALSE;
    pQueueProp->fTransactedQueue  = fXactOnly;
    pQueueProp->fConnectorQueue   = TRUE;
    pQueueProp->fForeign          = FALSE;
    pQueueProp->fUnknownQueueType = FALSE;


    if (!CQueueMgr::CanAccessDS())
    {
        return LogHR(MQ_ERROR_NO_DS, s_FN, 40);
    }
    //
    // Check if the machine belongs to such site
    //
    HRESULT hr;
    PROPID      aProp[1];
    PROPVARIANT aVar[1];
    ULONG       cProps = sizeof(aProp) / sizeof(PROPID);

    aProp[0] = PROPID_QM_SITE_IDS;
    aVar[0].vt = VT_NULL;
	
    hr = ADGetObjectPropertiesGuid(
                    eMACHINE,
                    NULL,       // pwcsDomainController
					false,	    // fServerName
                    QueueMgr.GetQMGuid(),
                    cProps,
                    aProp,
                    aVar
					);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 50);
    }


    BOOL fFound = FALSE;

    for(DWORD i = 0; i < aVar[0].cauuid.cElems; i++)
    {
        if (aVar[0].cauuid.pElems[i] == pQueueFormat->ConnectorID())
        {
            //
            //  verify that the site is indeed foreign
            //
            //  BUGBUG - to improve and call local routing cache
            //  instead of accessing the DS
            //      ronith june-00
            //
            PROPID propSite[]= {PROPID_S_FOREIGN};
            MQPROPVARIANT varSite[TABLE_SIZE(propSite)] = {{VT_NULL,0,0,0,0}};
            HRESULT hr1 = ADGetObjectPropertiesGuid(
                            eSITE,
                            NULL,       // pwcsDomainController
							false,	    // fServerName
                            &aVar[0].cauuid.pElems[i],
                            TABLE_SIZE(propSite),
                            propSite,
                            varSite
							);
            if (FAILED(hr1))
            {
                break;
            }
            if (varSite[0].bVal == 1)
            {
                fFound = TRUE;
                break;
            }
        }
    }

    delete [] aVar[0].cauuid.pElems;

    if (fFound)
    {
        return MQ_OK;
    }
    else
    {
        return LogHR(MQ_ERROR_QUEUE_NOT_FOUND, s_FN, 60);
    }
}



/*======================================================

Function:      GetDirectQueueProperty

Description:   query the database, and gets the Direct Queue path name,
               Quata, QMID and Jornal

Arguments:     pQueueFormat - pointer to format name

Return Value:  pQueueProp - pointer to QueueProp Structure that contains the
               Machine property

History Change:

========================================================*/

HRESULT GetDirectQueueProperty(IN  const QUEUE_FORMAT* pQueueFormat,
                               OUT PQueueProps         pQueueProp,
                               bool                    fInReceive
                               )
{
    ASSERT(IsDirectQueue(pQueueFormat));
    HRESULT     rc = MQ_OK;

    PROPID      aProp[10];
    PROPVARIANT aVar[10];
    ULONG       cProps = sizeof(aProp) / sizeof(PROPID);

    aProp[0] = PROPID_Q_PATHNAME;
    aProp[1] = PROPID_Q_JOURNAL;
    aProp[2] = PROPID_Q_QUOTA;
    aProp[3] = PROPID_Q_JOURNAL_QUOTA;
    aProp[4] = PROPID_Q_BASEPRIORITY;
    aProp[5] = PROPID_Q_TRANSACTION;
    aProp[6] = PROPID_Q_AUTHENTICATE;
    aProp[7] = PROPID_Q_PRIV_LEVEL;
    aProp[8] = PPROPID_Q_SYSTEMQUEUE;
    //
    // Note the following property is supported by MSMQ 3.0 and higher in AD schema of
    // Whistler version and higher. In other cases our AD provider will return VT_EMPTY and MQ_OK.
    //
    aProp[9] = PROPID_Q_MULTICAST_ADDRESS;

    aVar[0].vt = VT_NULL;
    aVar[1].vt = VT_UI1;
    aVar[2].vt = VT_UI4;
    aVar[3].vt = VT_UI4;
    aVar[4].vt = VT_I2;
    aVar[5].vt = VT_UI1;
    aVar[6].vt = VT_UI1;
    aVar[7].vt = VT_UI4;
    aVar[8].vt = VT_UI1;
    aVar[9].vt = VT_NULL;

    pQueueProp->fSystemQueue = FALSE ;
    pQueueProp->fForeign = FALSE;

    BOOL fLocal = IsLocalDirectQueue(pQueueFormat, fInReceive) ;

    if (fLocal)
    {
		AP<WCHAR> lpwsQueuePathName;
		
		try
		{
			FnDirectIDToLocalPathName(
				pQueueFormat->DirectID(),
				g_szMachineName,
				lpwsQueuePathName
				);
		}
		catch(const exception&)
		{
			return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 65);
		}

        //
        // Local Queue. Access the DB to reterive the queue properties
        //
        if (FnIsPrivatePathName(lpwsQueuePathName.get()))
        {
            //
            // Local private queue
            //
            ASSERT(aProp[ cProps - 2 ] == PPROPID_Q_SYSTEMQUEUE);
            ASSERT(aVar[ cProps - 2 ].vt == VT_UI1);

            rc = g_QPrivate.QMGetPrivateQueuePropertiesInternal(
                                                      lpwsQueuePathName.get(),
                                                      cProps,
                                                      aProp,
                                                      aVar );
            if (SUCCEEDED(rc))
            {
               pQueueProp->fSystemQueue = aVar[ cProps - 2 ].bVal;
            }
        }
        else
        {
            //
            // local DS queue
            //
            aProp[ cProps - 2 ] = PROPID_Q_INSTANCE;
            aVar[ cProps - 2 ].vt = VT_NULL;

            rc = MQ_ERROR_NO_DS;

            //
            // SP4, bug# 2962. postpone the MQIS initialization until it realy required
            //
            MQDSClientInitializationCheck();

            if (CQueueMgr::CanAccessDS())
            {
                rc = ADGetObjectProperties(
						eQUEUE,
						NULL,     // pwcsDomainController
						false,	  // fServerName
						lpwsQueuePathName.get(),
						cProps,
						aProp,
						aVar
						);

                if (SUCCEEDED(rc))
                {
                    //
                    // Update the public queue cache.
                    //
                    SetCachedQueueProp(aVar[cProps-2].puuid,
                                       cProps,
                                       aProp,
                                       aVar,
                                       TRUE,
                                       TRUE,
                                       time(NULL));

                    //
                    // Try to update queue properties in the queue manager.
                    // Build the queue format as public or private queue type, since bind/unbind
                    // to multicast group is done only for private or public queues (not direct).
                    //
                    QUEUE_FORMAT PublicQueueFormat(*aVar[cProps-2].puuid);
                    QMpUpdateMulticastBinding(&PublicQueueFormat, cProps, aProp, aVar);
                }
            }
            if (rc == MQ_ERROR_NO_DS)
            {
                rc = GetCachedQueueProperties( cProps,
                                               aProp,
                                               aVar,
                                               NULL,
                                               lpwsQueuePathName.get() ) ;
            }
            if (SUCCEEDED(rc))
            {
                pQueueProp->guidDirectQueueInstance = *(aVar[cProps-2].puuid);
                delete aVar[cProps-2].puuid;
            }
        }

        if (SUCCEEDED(rc))
        {
            pQueueProp->lpwsQueuePathName = aVar[0].pwszVal;
            pQueueProp->fJournalQueue = aVar[1].bVal;
            pQueueProp->dwQuota = aVar[2].ulVal;
            pQueueProp->dwJournalQuota = aVar[3].ulVal;
            pQueueProp->siBasePriority = aVar[4].iVal;
            pQueueProp->pQMGuid = new GUID;
            *pQueueProp->pQMGuid = *(CQueueMgr::GetQMGuid());
            pQueueProp->fIsLocalQueue = TRUE;
            pQueueProp->fTransactedQueue = aVar[5].bVal;
            pQueueProp->fAuthenticate = aVar[6].bVal;
            pQueueProp->dwPrivLevel = aVar[7].ulVal;
            pQueueProp->fUnknownQueueType = FALSE;

        }
    }

    if (!fLocal || (rc == MQ_ERROR_NO_DS))
    {
        //
        // Retreive the queue name from Queue Format direct name.
        // Store the name with the protocol type.
        //
        DWORD dwLength = wcslen(pQueueFormat->DirectID())+1;
        pQueueProp->lpwsQueuePathName = new WCHAR[dwLength];
        wcscpy(pQueueProp->lpwsQueuePathName,pQueueFormat->DirectID());
        CharLower(pQueueProp->lpwsQueuePathName);

        pQueueProp->fIsLocalQueue = FALSE;
        pQueueProp->pQMGuid = new GUID;
        memset(pQueueProp->pQMGuid,0,sizeof(GUID));
        pQueueProp->fJournalQueue = FALSE;
        pQueueProp->dwQuota = 0;
        pQueueProp->dwJournalQuota = 0;
        pQueueProp->siBasePriority = 0;
        pQueueProp->fTransactedQueue = FALSE;
        pQueueProp->fUnknownQueueType = TRUE;
	}

	//
	// If we send to a system queue then we want max priority.
	// All system queues on all machines have the same name
	// so check local machine to see if the name is one of a system
	// queue and retrieve its base priority.
	//
    if (!fLocal)
	{
		AP<WCHAR> lpwsQueuePathName;
		
		try
		{
			FnDirectIDToLocalPathName(
				pQueueFormat->DirectID(),
				g_szMachineName,
				lpwsQueuePathName
				);
		}
		catch(const exception&)
		{
			//
			// Give up boosting. Could not parse remote direct formatname
			//
			return MQ_OK;
		}

		if(!FnIsPrivatePathName(lpwsQueuePathName.get()) ||
			!g_QPrivate.IsPrivateSysQueue(lpwsQueuePathName.get()))
		{
			return MQ_OK;
		}

		//
		// Boost priority. Queue is a remote system queue.
		//

		aProp[0] = PROPID_Q_BASEPRIORITY;
		aVar[0].vt = VT_I2;
		HRESULT rc1 = g_QPrivate.GetPrivateSysQueueProperties(1,
													aProp,
													aVar ) ;
		ASSERT(rc1 == MQ_OK) ;
		if (rc1 == MQ_OK)
		{
			pQueueProp->siBasePriority = aVar[0].iVal;
			pQueueProp->fSystemQueue = TRUE ;
		}
	}

    return LogHR(rc, s_FN, 70);

} // GetDirectQueueProperty


HRESULT
GetMulticastQueueProperty(
    const QUEUE_FORMAT* pQueueFormat,
    PQueueProps         pQueueProp
    )
{
    //
    // Must be multicast queue here
    //
    ASSERT(IsMulticastQueue(pQueueFormat));

    //
    // Set system and foreign properties
    //
    pQueueProp->fSystemQueue = FALSE ;
    pQueueProp->fForeign = FALSE;

    //
    // Set queue name
    //
    WCHAR QueueName[MAX_PATH];
    MQpMulticastIdToString(pQueueFormat->MulticastID(), QueueName);
    CharLower(QueueName);
    pQueueProp->lpwsQueuePathName = newwcs(QueueName);

    //
    // Multicast queue is not local
    //
    pQueueProp->fIsLocalQueue = FALSE;

    //
    // Multicast queue has no meaningful guid
    //
    pQueueProp->pQMGuid = new GUID;
    memset(pQueueProp->pQMGuid,0,sizeof(GUID));

    //
    // Set journal and quota
    //
    pQueueProp->fJournalQueue = FALSE;
    pQueueProp->dwQuota = 0;
    pQueueProp->dwJournalQuota = 0;

    //
    // Multicast queue is not transactional
    //
    pQueueProp->siBasePriority = 0;
    pQueueProp->fTransactedQueue = FALSE;
    pQueueProp->fUnknownQueueType = FALSE;

    return MQ_OK;

} // GetMulticastQueueProperty


/*======================================================

Function:      QmpGetQueueProperties

Description:   query the database, and gets the QUEUE path name and
               destination machine

Arguments:

Return Value:

Thread Context:

History Change:

========================================================*/
HRESULT
QmpGetQueueProperties(
    const QUEUE_FORMAT * pQueueFormat,
    PQueueProps          pQueueProp,
    bool                 fInReceive
    )
{
    HRESULT rc = MQ_OK;

    FillMemory(pQueueProp, sizeof(QueueProps), 0);

    switch(pQueueFormat->GetType())
    {
        case QUEUE_FORMAT_TYPE_MACHINE:
            rc = GetMachineProperty(pQueueFormat, pQueueProp);
            break;

        case QUEUE_FORMAT_TYPE_PUBLIC:
            rc = GetDSQueueProperty(pQueueFormat, pQueueProp);
            break;

        case QUEUE_FORMAT_TYPE_PRIVATE:
            rc = GetPrivateQueueProperty(pQueueFormat, pQueueProp);
            break;

        case QUEUE_FORMAT_TYPE_DIRECT:
            rc = GetDirectQueueProperty(pQueueFormat, pQueueProp, fInReceive);
            break;

        case QUEUE_FORMAT_TYPE_CONNECTOR:
            rc = GetConnectorQueueProperty(pQueueFormat, pQueueProp);
            break;

        case QUEUE_FORMAT_TYPE_MULTICAST:
            rc = GetMulticastQueueProperty(pQueueFormat, pQueueProp);
            break;

        default:
            ASSERT(0);
            rc = MQ_ERROR;
    }

    if (rc == MQ_ERROR_NO_DS)
    {
        pQueueProp->fUnknownQueueType = TRUE;
    }
    return LogHR(rc, s_FN, 80);

} // QmpGetQueueProperties


/*======================================================

Function:      CQueueMgr::CQueueMgr

Description:   Constructor

Arguments:     None

Return Value:  None

Thread Context:

History Change:

========================================================*/

CQueueMgr::CQueueMgr() :
    m_fQueueCleanupScheduled(FALSE),
    m_QueueCleanupTimer(QueuesCleanup)
{
}

/*======================================================

Function:      CQueueMgr::~CQueueMgr

Description:   Deconstructor

Arguments:     None

Return Value:  None

Thread Context:

History Change:

========================================================*/


CQueueMgr::~CQueueMgr()
{
    m_MapQueueId2Q.RemoveAll();
}

/*======================================================

Function:       CQueueMgr::InitQueueMgr

Description:    Create the QM threads and AC services request

                The routine is called after the QM initialization passes successfully.
                The routine creates ACGetServiceRequest and create QM threads

Arguments:      None

Return Value:   TRUE if the AC services and QM threads create successfully. FALSE otherwise

Thread Context:

History Change:

========================================================*/

BOOL CQueueMgr::InitQueueMgr()
{
    HRESULT hr;

    //
    // Initialize private queue data structures
    //
    hr = g_QPrivate.PrivateQueueInit();

    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 1020);
        return FALSE;
    }

    ASSERT(g_hAc != NULL);           //be sure the intilization pass o.k

    //
    // Create ACGetServiceRequest
    //
    HRESULT rc;
    QMOV_ACGetRequest* pAcRequestOv;
    pAcRequestOv = new QMOV_ACGetRequest;
    rc = CreateAcServiceRequest(g_hAc, pAcRequestOv);
    REPORT_ILLEGAL_STATUS(rc, L"InitQueueMgr");

    //
    // Set Queue clean-up timeout
    //
    DWORD dwDefaultVal;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = REG_DWORD;

    if (!IsRoutingServer())  //[adsrv]
    {
        //
        // In Client the default Release session timeout is 5 minitues
        //
        dwDefaultVal = MSMQ_DEFAULT_CLIENT_CLEANUP;
    }
    else
    {
        //
        // In FRS the default Release session timeout is 2 minitues
        //
        dwDefaultVal = MSMQ_DEFAULT_SERVER_CLEANUP;
    }

    DWORD dwCleanupTimeout;
    rc = GetFalconKeyValue(
            MSMQ_CLEANUP_INTERVAL_REGNAME,
            &dwType,
            &dwCleanupTimeout,
            &dwSize,
            (LPCTSTR)&dwDefaultVal
            );

    m_CleanupTimeout = CTimeDuration::FromMilliSeconds(dwCleanupTimeout);

    InitNextSeqID();

    return(TRUE);
}



/*======================================================

Function:       IsRemoteReadAccess

Description:    Check that access is for get operation (receive/peek)
                the queue itself (no admin operation)

========================================================*/
#define MQ_GET_ACCESS  (MQ_RECEIVE_ACCESS | MQ_PEEK_ACCESS)

inline
BOOL
IsRemoteReadAccess(
    DWORD dwAccess
    )
{
    return ((dwAccess & MQ_GET_ACCESS) && !(dwAccess & MQ_ADMIN_ACCESS));
}


/*======================================================

Function:       IsValidOpenOperation

Description:    Check that open operation is valid

Arguments:      pQueueFormat - pointer to QUEUE_FORMAT of open queue
                dqAccess - Access type

Return Value:   HRESULT

Thread Context:

History Change:

========================================================*/
HRESULT
IsValidOpenOperation(
    const QUEUE_FORMAT* pQueueFormat,
    DWORD dwAccess
    )
{
    //
    // This code is not called when opening distribution queues
    //
    ASSERT(pQueueFormat->GetType() != QUEUE_FORMAT_TYPE_DL);

    //
    // Check that machine queues are opened only for read
    //
    if (IsMachineQueue(pQueueFormat) &&
        (!(dwAccess & MQ_GET_ACCESS) || IsForeignMachine(&pQueueFormat->MachineID())))
    {
        return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 90);
    }


    //
    // Check that journal queues and system queues are opened for read only
    //
    if ((!IsNormalQueueType(pQueueFormat)) && !(dwAccess & MQ_GET_ACCESS))
    {
        return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 100);
    }

    //
    // Check that Connector queues are opened for read only
    //
    if (IsConnectorQueue(pQueueFormat) && !(dwAccess & MQ_GET_ACCESS))
    {
        return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 110);
    }

    //
    // Check that Multicast queues are not opened for read, unless this is Admin access.
    //
    if (IsMulticastQueue(pQueueFormat) && (dwAccess & MQ_GET_ACCESS) != 0 && (dwAccess & MQ_ADMIN_ACCESS) == 0)
    {
        return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 114);
    }

    return MQ_OK;
}


/*======================================================

Function:  HRESULT CQueueMgr::CreateQueueObject()

Description:

Arguments:
     DWORD  dwAccess - Queue Access mode. This value is 0 for "internal"
                       opens, i.e., queue openings because of recivery
                       or reception of packets.

Return Value:

Thread Context:

History Change:

========================================================*/

HRESULT
CQueueMgr::CreateQueueObject(
    IN  const QUEUE_FORMAT* pQueueFormat,
    OUT CQueue**            ppQueue,
    IN  DWORD               dwAccess,
    OUT LPWSTR*             lplpwsRemoteQueueName,
    OUT BOOL*               pfRemoteReturn,
    IN  BOOL                fRemoteServer,
    IN  const GUID*         pgConnectorQM,
    IN  bool                fInReceive
    )
{
    HRESULT    rc;
    BOOL       fNoDS = FALSE ;

    QueueProps qp;

    *ppQueue = NULL;

    if (pfRemoteReturn)
    {
        ASSERT(dwAccess != 0) ;
        *pfRemoteReturn = FALSE;
    }

    //
    // Get Queue Properties. Name and QMId
    //
    rc = QmpGetQueueProperties( pQueueFormat, &qp, fInReceive);
    if (FAILED(rc))
    {
        if (rc == MQ_ERROR_NO_DS)
        {
            fNoDS = TRUE;
            if (pgConnectorQM)
            {
                ASSERT(qp.fUnknownQueueType);
                qp.fUnknownQueueType = FALSE;
                qp.fTransactedQueue = TRUE;
                qp.fForeign = TRUE;
            }
            else
            {
                if ((dwAccess == 0) || (dwAccess & MQ_SEND_ACCESS))
                {
                    ASSERT(qp.fUnknownQueueType);
                }
                else
                {
                    DBGMSG((DBGMOD_QM,
                        DBGLVL_ERROR,
                        _TEXT("::CreateQueueObject failed, mqstatus %x"), rc)) ;
                   return LogHR(rc, s_FN, 120);
                }
            }
        }
        else
        {
            DBGMSG((DBGMOD_QM, DBGLVL_ERROR,
                    _TEXT("::CreateQueueObject failed, mqstatus %x"), rc)) ;
            return LogHR(rc, s_FN, 130);
        }
    }

    if (pfRemoteReturn   && lplpwsRemoteQueueName &&
       !qp.fIsLocalQueue && !qp.fConnectorQueue)
    {
        //
        // Open for Remote read (first call on client side).
        // Return path name so RT can find remote server name and call
        // it for remote open.
        //
        if(IsRemoteReadAccess(dwAccess))
        {
            ASSERT(!fRemoteServer) ;
            ASSERT(!(dwAccess & MQ_SEND_ACCESS)) ;

            HRESULT rc = MQ_OK;

            if  (lplpwsRemoteQueueName)
            {
                if ((pQueueFormat->GetType()) == QUEUE_FORMAT_TYPE_PRIVATE)
                {
                    if (qp.lpwsQueuePathName)
                    {
                        delete qp.lpwsQueuePathName ;
                        qp.lpwsQueuePathName = NULL ;
                        ASSERT( qp.lpwsQueueDnsName == NULL);
                    }
                    //
                    // Remote read from privat queue.
                    // Get remote machine name from DS.
                    //
                    PROPID      aProp[2];
                    PROPVARIANT aVar[2];
                    rc = MQ_ERROR_NO_DS;

                    aProp[0] = PROPID_QM_PATHNAME;
                    aVar[0].vt = VT_NULL;
                    aProp[1] = PROPID_QM_PATHNAME_DNS;  // should be last
                    aVar[1].vt = VT_NULL;

                    if (CQueueMgr::CanAccessDS())
                    {
                        rc = ADGetObjectPropertiesGuid(
									eMACHINE,
									NULL,    // pwcsDomainController
									false,	 // fServerName
									qp.pQMGuid,
									2,
									aProp,
									aVar
									);
                        //
                        //  MSMQ 1.0 DS server do not support PROPID_QM_PATHNAME_DNS
                        //  and return MQ_ERROR in case of unsupported property.
                        //  If such error is returned, assume MSMQ 1.0 DS and try again
                        //  this time without PROPID_QM_PATHNAME_DNS.
                        //
                        if ( rc == MQ_ERROR)
                        {
                            aVar[1].vt = VT_EMPTY;
                            ASSERT( aProp[1] ==  PROPID_QM_PATHNAME_DNS);

                            rc = ADGetObjectPropertiesGuid(
										eMACHINE,
										NULL,    // pwcsDomainController
										false,	 // fServerName
										qp.pQMGuid,
										1,   // assuming DNS property is last
										aProp,
										aVar
										);
                        }
                        if (SUCCEEDED(rc))
                        {
                            qp.lpwsQueuePathName = aVar[0].pwszVal ;
                            if ( aVar[1].vt != VT_EMPTY)
                            {
                                qp.lpwsQueueDnsName = aVar[1].pwszVal ;
                            }
                        }
                    }
                }
                if (SUCCEEDED(rc))
                {
                    ASSERT(qp.lpwsQueuePathName) ;
                    if ( qp.lpwsQueueDnsName != NULL)
                    {
                        *lplpwsRemoteQueueName = qp.lpwsQueueDnsName.detach();
						delete[]  qp.lpwsQueuePathName;
						qp.lpwsQueuePathName = NULL;
                    }
                    else
                    {
                        *lplpwsRemoteQueueName = qp.lpwsQueuePathName;
                    }
                    *pfRemoteReturn = TRUE;
                }
            }
            else
            {
                rc = MQ_ERROR ;
            }

            //
            // Clean up queue properties. (usually this is done in
            // CQueue destructor, but here we don't create a CQueue
            // object).
            //
            if (qp.pQMGuid)
            {
                delete qp.pQMGuid ;
            }
            if (FAILED(rc))
            {
                if (qp.lpwsQueuePathName)
                {
                    delete qp.lpwsQueuePathName ;
                }
                *lplpwsRemoteQueueName = NULL ;
                *pfRemoteReturn = FALSE ;
            }

            return LogHR(rc, s_FN, 140);
        }
        else if ((dwAccess & MQ_ADMIN_ACCESS) == MQ_ADMIN_ACCESS)
        {
            //
            // Bug 8765.
            // Trying to open a remote journal queue with ADMIN access.
            // this is not supported. If you want to purge a remote
            // journal queue, then open it just with MQ_RECEIVE_ACCESS and
            // then call MQPurgeQueue.
            // Same fix for remote deadletter/xactdead queues.
            //
            BOOL fBadQueue = IsJournalQueueType(pQueueFormat)  ||
                             IsDeadXactQueueType(pQueueFormat) ||
                             IsDeadLetterQueueType(pQueueFormat);
            if (fBadQueue)
            {
                return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 390);
            }
        }
    }
    else if (fRemoteServer && !qp.fIsLocalQueue && !qp.fConnectorQueue)
    {
        ASSERT(!lplpwsRemoteQueueName) ;
        if (dwAccess & MQ_GET_ACCESS)
        {
            //
            // We're on server side of remote read but queue is not local.
            // This weird situation can happen (at least) in the following
            // cases:
            // 1. The machine is dual boot. Each configuration has its own
            //    QM but both configurations have same address.
            //    So request to remote read machine A reach
            //    machine B, which physically are the same.
            // 2. Remote machine is in another site. when it process this
            //    request it's offline and the queue is not registered in
            //    its local registry.
            //
            if (qp.pQMGuid)
            {
                delete qp.pQMGuid ;
            }
            if (qp.lpwsQueuePathName)
            {
                delete qp.lpwsQueuePathName ;
            }
            return LogHR(MQ_ERROR_QUEUE_NOT_FOUND, s_FN, 150);
        }
        else
        {
            //
            // Why did we reach here ??? BUGBUGBUGBUG
            //
            ASSERT(0) ;
        }
    }

    R<CQueue> pQueue = new CQueue(
								pQueueFormat,
								INVALID_HANDLE_VALUE,
								&qp,
								fNoDS
								);

    //
    // Set the Connector QM ID
    //
    rc = pQueue->SetConnectorQM(pgConnectorQM);
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 160);
    }

    //
    // As a machine queue handle, sets the AC handle
    //
    if ((dwAccess != 0) && IsMachineQueue(pQueueFormat))
    {
        BOOL fSuccess;
        HANDLE hDup;
        fSuccess = MQpDuplicateHandle(
                    GetCurrentProcess(),
                    g_hMachine,
                    GetCurrentProcess(),
                    &hDup,
                    0,      // desired access
                    FALSE,  // inheritance
                    DUPLICATE_SAME_ACCESS
                    );

        if(!fSuccess)
        {
            //
            // Duplicate must succeed since we use the same process. The only reason
            // for failure is insufficient resources
            //
            return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 170);
        }

        pQueue->SetQueueHandle(hDup);
    }
    else
    {
        //
        // Create AC queue and set the Queue Handle
        //
        rc = CreateACQueue(pQueue.get(), pQueueFormat);

        if(FAILED(rc))
        {
            DBGMSG((DBGMOD_ALL, DBGLVL_ERROR,
                _TEXT("ACCreateQueue failed, mqstatus %x;"), rc)) ;
            return LogHR(rc, s_FN, 180);
        }

        //
        // If the Queue isn't Local, Add queue to non active group
        //
        if (!qp.fIsLocalQueue && !IsRemoteReadAccess(dwAccess))
        {
            if (fNoDS)
            {
                g_pgroupNotValidated->AddToGroup(pQueue.get());
            }
            else  if (!qp.fConnectorQueue)
            {
                g_pgroupNonactive->AddToGroup(pQueue.get());
            }
        }
    }

        //
        // Add queue to QM internal DB
        //
#ifdef _DEBUG
    {
        //
        // Verify the queue is not already in hash.
        //
        CQueue *pQueueTmp ;
        BOOL fLookup = LookUpQueue(pQueueFormat, &pQueueTmp, fInReceive, false) ;
        ASSERT(!fLookup) ;
        if (fLookup)
        {
           //
           // It's a bug, but release the reference on the queue.
           //
           pQueueTmp->Release();
        }
    }
#endif

    AddQueueToHashAndList(pQueue.get());
    *ppQueue = pQueue.detach();
    return MQ_OK;
}


/*======================================================

Function:  HRESULT CQueueMgr::OpenQueue()

Description:

Arguments:
        BOOL fRemoteServer- TRUE on server side of remote-read.

Return Value:

Thread Context:

History Change:

========================================================*/

HRESULT
CQueueMgr::OpenQueue(
    const QUEUE_FORMAT * pQueueFormat,
    DWORD              dwCallingProcessID,
    DWORD              dwAccess,
    DWORD              dwShareMode,
    CQueue * *         ppQueue,
    LPWSTR *           lplpwsRemoteQueueName,
    PHANDLE            phQueue,
    BOOL               fRemoteServer
    )
{
    CQueue*   pQueue = NULL;
	QUEUE_FORMAT_TRANSLATOR  RealDestinationQueue(pQueueFormat);
    BOOL      fJournalQueue = IsJournalQueueType(RealDestinationQueue.get());

    CS lock(m_cs);

    HRESULT rc = IsValidOpenOperation(RealDestinationQueue.get(), dwAccess);
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 190);
    }

    if(IsDirectQueue(RealDestinationQueue.get()))
    {
        BOOL fLocal = IsLocalDirectQueue(RealDestinationQueue.get(), false) ;

        if (fLocal && RealDestinationQueue.get()->IsSystemQueue())
        {
            //
            // This is a local machine queue
            //
            QUEUE_SUFFIX_TYPE qst = RealDestinationQueue.get()->Suffix();
            RealDestinationQueue.get()->MachineID(*GetQMGuid());
            RealDestinationQueue.get()->Suffix(qst);
        }
    }

    //
    // Check if the queue already exist
    //
    BOOL fQueueExist = LookUpQueue(RealDestinationQueue.get(), &pQueue, false, false);
    R<CQueue> Ref = pQueue;

    if (fQueueExist)
    {
        if (pQueue->QueueNotValid())
        {
            //
            // This case happens when a queue was originally opened when
            // MQIS server was offline. Later, when MQIS becomes available,
            // it was determined that the open operation was not valid.
            //
            return LogHR(MQ_ERROR_QUEUE_NOT_FOUND, s_FN, 210);
        }

        if (!pQueue->IsLocalQueue() && !pQueue->IsConnectorQueue())
        {
            if(IsRemoteReadAccess(dwAccess))
            {
                //
                // Remote reader. (first call on client side). Turn the Exist
                // flag to FALSE so CreateQueueObject is create to retrieve
                // full path of remote queue.
                //
                Ref.free();
                fQueueExist = FALSE ;
            }
        }
    }

    //
    // If first time the queue is opened than create queue object
    //
    if (!fQueueExist)
    {
        ASSERT(Ref.get() == 0);

        BOOL fRemoteReturn ;
        rc = CreateQueueObject(RealDestinationQueue.get(),
                               &pQueue,
                               dwAccess,
                               lplpwsRemoteQueueName,
                               &fRemoteReturn,
                               fRemoteServer,
                               0,
                               false);
        if (fRemoteReturn || FAILED(rc))
        {
            ASSERT(pQueue == 0);
            return LogHR(rc, s_FN, 220);
        }

        Ref = pQueue;
    }

    //
    // we should not reach here under these conditions.
    // We should be in ::OpenRRQueue() instead.
    //
    ASSERT(!IsRemoteReadAccess(dwAccess) || pQueue->IsLocalQueue() || pQueue->IsConnectorQueue());
    HANDLE hQueue = pQueue->GetQueueHandle() ;
    ASSERT(hQueue) ;

    //
    // If dwCallingProcessID is NULL no handle duplication is required
    //
    if (dwCallingProcessID == NULL)
    {
		if (ppQueue)
		{
     		*ppQueue = Ref.detach();
		}

        if (phQueue != NULL)
        {
            *phQueue = hQueue;
        }
        return MQ_OK;
    }

    //
    // Verify that the user has permissions to open
    // the queue in the desired access.
    //
    rc = VerifyOpenPermission(
            pQueue,
            RealDestinationQueue.get(),
            dwAccess,
            fJournalQueue,
            pQueue->IsLocalQueue()
            );

    //
    // If the queue is marked as Unknown queue type it means it opens without
    // DS. In such a case we don't have security descriptor and we can't check
    // access permision
    //
    if(FAILED(rc))
    {
        return LogHR(rc, s_FN, 230);
    }

    HANDLE hAcQueue;
    rc = ACCreateHandle(&hAcQueue);
    if(FAILED(rc))
    {
        return LogHR(rc, s_FN, 240);
    }

    if(fJournalQueue)
    {
        rc = ACAssociateJournal(
                hQueue,
                hAcQueue,
                dwAccess,
                dwShareMode
                );
    }
    else if(IsDeadXactQueueType(RealDestinationQueue.get()))
    {
        rc = ACAssociateDeadxact(
                hQueue,
                hAcQueue,
                dwAccess,
                dwShareMode
                );
    }
    else
    {
        bool fProtocolSrmp = (FnIsDirectHttpFormatName(RealDestinationQueue.get()) ||
                              IsMulticastQueue(RealDestinationQueue.get()));
        rc = ACAssociateQueue(
                hQueue,
                hAcQueue,
                dwAccess,
                dwShareMode,
                fProtocolSrmp
                );
    }

    if(FAILED(rc))
    {
        ACCloseHandle(hAcQueue);
        return LogHR(rc, s_FN, 250);
    }

    CHandle hCallingProcess = OpenProcess(
                                PROCESS_DUP_HANDLE,
                                FALSE,
                                dwCallingProcessID
                                );

    if(hCallingProcess == 0)
    {
        DBGMSG((DBGMOD_QM,DBGLVL_ERROR,_TEXT("Cannot open calling process in OpenQueue, error %d"), GetLastError()));
        return LogHR(MQ_ERROR_PRIVILEGE_NOT_HELD, s_FN, 260);
    }

    HANDLE hDupQueue;
    BOOL fSuccess;
    fSuccess = MQpDuplicateHandle(
                GetCurrentProcess(),
                hAcQueue,
                hCallingProcess,
                &hDupQueue,
                MQAccessToFileAccess(dwAccess),
                TRUE,
                DUPLICATE_CLOSE_SOURCE
                );

    if(!fSuccess)
    {
        ACCloseHandle(hAcQueue);
        return LogHR(MQ_ERROR_PRIVILEGE_NOT_HELD, s_FN, 270);
    }

    ASSERT(phQueue != NULL);
    *phQueue = hDupQueue;
	if (ppQueue)
	{
		*ppQueue = Ref.detach();
	}
	
    return MQ_OK;

} // CQueueMgr::OpenQueue


/*======================================================

Function:    ValidateOpenedQueues()

Description: Validate a queue which was opened while working offline,
             without a MQIS server.
             We only check that the queue exist in the database and
             retrieve its properties.
             We can't validate permissions because we may now run in
             a security context which is different than the one when
             sending the message. (assume userA was logged on while
             offline, sent a message, then logged on as userB and
             connect the network).
             Security will be checked on the receiving side, as it is
             done with recovered packets after boot.

========================================================*/

HRESULT
CQueueMgr::ValidateOpenedQueues()
{
   CS lock(m_cs);

   R<CQueue>  pQueue = g_pgroupNotValidated->RemoveHeadFromGroup() ;
   while (pQueue.get())
   {
      HRESULT    rc;
      QueueProps qp;
      P<QUEUE_FORMAT> pQueueFormat = NULL ;

      ASSERT(("Multicast queue should not be in NotValidate group", (pQueue->GetQueueType() != QUEUE_TYPE_MULTICAST)));

      if (pQueue->GetRoutingRetry() != 0)
      {
          //
          // If routing retry isn't 0, we reach here due NO_DS error during the
          // create connection. It means that the Queue properties is already
          // verified and we used the not validated group as a temporary group until
          // the DS becomes online and routing information can be retreived from
          // the DS.
          //
          pQueue->ClearRoutingRetry();
          g_pgroupNonactive->AddToGroup(pQueue.get());
      }
      else
      {
          //
          // Get Queue Properties. Name and QMId
          //
          if (pQueue->GetQueueType() == QUEUE_TYPE_PUBLIC)
          {
             pQueueFormat = new QUEUE_FORMAT(*pQueue->GetQueueGuid());
          }
          else
          {
              if (pQueue->GetQueueType() == QUEUE_TYPE_MACHINE)
              {
                  if (pQueue->GetPrivateQueueId() != 0)
                  {
                    //
                    // Remote private queue.
                    //
                    pQueueFormat = new QUEUE_FORMAT( *pQueue->GetQueueGuid(),
                                                   pQueue->GetPrivateQueueId()) ;
                  }
                  else
                  {
                      //
                      // Temorary queue for foreign transacted queue on FRS
                      //
                      pQueueFormat = new QUEUE_FORMAT(NULL, *pQueue->GetQueueGuid());
                  }
              }
              else if (pQueue->GetQueueType() == QUEUE_TYPE_CONNECTOR)
              {
                //
                // This code added as part of QFE 2738 that fixed connector
			    // rcovery problem (urih, 3-Feb-98)
			    //
                  pQueueFormat = new QUEUE_FORMAT;
                  pQueueFormat->ConnectorID(*pQueue->GetQueueGuid());
                  if (pQueue->GetPrivateQueueId() == 1)
                  {
                    pQueueFormat->Suffix(QUEUE_SUFFIX_TYPE_XACTONLY);
                  }

              }
              else if (pQueue->GetQueueName())
              {
                 //
                 // Probably local direct queue which was not written in registry
                 // (or which was already deleted).
                 //
                 pQueueFormat = new QUEUE_FORMAT(
                                  const_cast<WCHAR*> (pQueue->GetQueueName())) ;
              }
              else
              {
                 ASSERT(0) ;
              }
          }

          rc = QmpGetQueueProperties( pQueueFormat, &qp, false);

          if (FAILED(rc))
          {
              //
              // DS offline again. Return the queue to the list and
              // untill DS be online again
              //
              if (rc == MQ_ERROR_NO_DS)
              {
                  g_pgroupNotValidated->AddToGroup(pQueue.get());
                  return MQ_OK;
              }
             pQueue->SetQueueNotValid() ;
          }
          else
          {
              if (qp.fIsLocalQueue)
              {
                 //
                 // When offline, local queues are supposed to be open by using
                 // cache in registry. We'll reach this point if registry is not
                 // up-to-date (notification get lost). We previously (when offline)
                 // opened the queue as non-local and now that we have DS we found
                 // it's local. At present we don't handle such change in state
                 // and we just mark the queue as not valid.
                 //
                 pQueue->SetQueueNotValid() ;
                 delete qp.pQMGuid;

              }
              else if (!pQueue->IsConnectorQueue())
              {
                 ASSERT(qp.lpwsQueuePathName ||
                       (pQueue->GetQueueType() != QUEUE_TYPE_PUBLIC)) ;

                 if (pQueue->GetQueueName() == NULL)
                 {
                     pQueue->SetQueueName((TCHAR*)qp.lpwsQueuePathName) ;
                     pQueue->PerfUpdateName();
                     if (pQueue->GetQueueName() != NULL)
                     {
                        m_MapName2Q[pQueue->GetQueueName()] = pQueue.get();
                     }
                 }
                 else
                 {
                     ASSERT(wcscmp(qp.lpwsQueuePathName, pQueue->GetQueueName()) == 0);
                 }

                 pQueue->InitQueueProperties(&qp) ;
                 //
                 // Update the connector QM.
                 //
                 rc = pQueue->SetConnectorQM();
                 if (FAILED(rc))
                 {
                     ASSERT( rc == MQ_ERROR_NO_DS);
                     g_pgroupNotValidated->AddToGroup(pQueue.get());
                     return MQ_OK;
                 }

                 rc = ACSetQueueProperties(
                            pQueue->GetQueueHandle(),
                            pQueue->IsJournalQueue(),
                            pQueue->ShouldMessagesBeSigned(),
                            pQueue->GetPrivLevel(),
                            pQueue->GetQueueQuota(),         // Quota
                            pQueue->GetJournalQueueQuota(),
                            pQueue->GetBaseQueuePriority(),
                            pQueue->IsTransactionalQueue(),
                            pQueue->GetConnectorQM(),
                            pQueue->IsUnkownQueueType()
                            );

                 LogHR(rc, s_FN, 112);
                 ASSERT(SUCCEEDED(rc));

                 g_pgroupNonactive->AddToGroup(pQueue.get());

              }
          }
      }

      pQueue = g_pgroupNotValidated->RemoveHeadFromGroup() ;
   }
   return MQ_OK ;
}

/*======================================================
Function:    OpenAppsReceiveQueue

Description: The function opens a receive queue for QM internal application
             (i.e DS, Admin). The queue should be a local queue and it
             should be created before opening or beeing recorder in
             Registery As a private queue.

Arguments:   pguidInstance - Pointer to a guid. It the queue is private
                             queue it should be a dummy guid, in which
                             the guid is zero except the low 2 bytes that
                             contains the private queue ID.

             lpReceiveRoutine - Pointer to call back routine. This routine
                             will be called when a message arrive to the
                             queue. The routine is a synchronize routine.

Return Value: phQueue - Queue Handle. The function returns to the caller
                        the open queue handle. This will be used by the
                        caller to close the queue.

History Change:

========================================================*/
HRESULT
CQueueMgr::OpenAppsReceiveQueue(
    const QUEUE_FORMAT* pQueueFormat,
    LPRECEIVE_COMPLETION_ROUTINE  lpReceiveRoutine
    )
{
    HRESULT rc = MQ_OK;
    CQueue* pQueue;
    HANDLE  hQueue;
    CQueue* pBQueue;

    if (LookUpQueue(pQueueFormat, &pQueue, false, false))
    {
        ASSERT(!pQueue->QueueNotValid());
        ASSERT(pQueue->GetQueueHandle() != INVALID_HANDLE_VALUE);
        hQueue = pQueue->GetQueueHandle();
    }
    else
    {
        rc = OpenQueue(
                   pQueueFormat,
                   NULL,
                   MQ_RECEIVE_ACCESS,
                   TRUE,
                   NULL,
                   NULL,
                   &hQueue);
    }

    if (SUCCEEDED(rc)) {

        //
        // Increment the reference count, such the queue never remove
        //
        rc = LookUpQueue(pQueueFormat, &pBQueue, false, false);
        REPORT_ILLEGAL_STATUS(rc, L"OpenAppsReceiveQueue");

        //
        // Wait to incoming packet
        //
        QMOV_ACGetInternalMsg* lpQmOv = NULL;
        try
        {
            lpQmOv = new QMOV_ACGetInternalMsg;
        }
        catch(const bad_alloc&)
        {
            return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 280);
        }

        lpQmOv->hQueue = hQueue;
        lpQmOv->lpCallbackReceiveRoutine = lpReceiveRoutine;

        rc = ACGetPacket(hQueue,
                         lpQmOv->packetPtrs,
                         &lpQmOv->qmov
                        );

        if (FAILED(rc))
        {
            delete lpQmOv;
            DBGMSG((DBGMOD_QM,
                    DBGLVL_ERROR,
                    _TEXT("Get Packet from a Internal Queue failed, ntstatus %x"), rc));
        }
        else
        {
            DBGMSG((DBGMOD_QM,
                    DBGLVL_TRACE,
                    _TEXT("Succeeded to Create get packet request from internal queue")));
        }
    }

    return LogHR(rc, s_FN, 290);
}

/*======================================================

Function:       CQueueMgr::GetQueueObject

Description:    The routine returnes the Queue object that match the specifued guid.

                generally the Queue object is featched from QueueMgr internal data
                structure. However if the queue is not local queue and the machine is
                FRS, the routine locate a temporary queue on the machine and returnes
                a pointer to its object.

Arguments:      pguidQueue - pointer to guid of the queue

Return Value:   pointer to queue object.

Thread Context:

History Change:

========================================================*/

HRESULT
CQueueMgr::GetQueueObject(
    const QUEUE_FORMAT* pQueueFormat,
    CQueue **           ppQueue,
    const GUID*         pgConnectorQM,
    bool                fInReceive
    )
{
    HRESULT  rc = MQ_OK;

    *ppQueue = NULL;
    CS lock(m_cs);

    try
    {
        //
        // look for the destination queue in the QueuMgr.m_MapGuid2Q
        // For the time being, we will assume that both DstQueue and RspQueue
        // format is short
        // BUGBUG: handling private queue
        //
        if (!LookUpQueue(pQueueFormat, ppQueue, fInReceive, false))
        {
            rc = CreateQueueObject(
                     pQueueFormat,
                     ppQueue,
                     0,
                     NULL,
                     NULL,
                     FALSE,
                     pgConnectorQM,
                     fInReceive
                     );

            if (FAILED(rc))
            {
                if (*ppQueue)
                {
                    (*ppQueue)->Release();
                }
                return LogHR(rc, s_FN, 300);
            }
        }
        else
        {
            if ((*ppQueue)->GetQueueHandle() == INVALID_HANDLE_VALUE)
            {
                rc = CreateACQueue(*ppQueue, pQueueFormat);

                //
                //  BUGBUG: should handle ACMakeQueue failure
                //
                REPORT_ILLEGAL_STATUS(rc, L"GetQueueObject");
            }
        }
    }
    catch(const bad_alloc&)
    {
        LogIllegalPoint(s_FN, 2002);
        rc = MQ_ERROR_INSUFFICIENT_RESOURCES;
    }

    return LogHR(rc, s_FN, 310);
}

/*====================================================

  RoutineName: CreateACQueue

  Arguments:   pQueeu - pointer to queue object

  Return Value:

=====================================================*/
HRESULT
CQueueMgr::CreateACQueue(IN CQueue*                 pQueue,
                         IN const QUEUE_FORMAT*     pQueueFormat)
{
    HRESULT rc;
    HANDLE  hQueue;
    P<QUEUE_FORMAT> pLocalDirectQueueFormat;
    AP<WCHAR> pDirectId;

    //
    //  We reset the format name journal flag, so MQHandleToFormatName
    //  will be correct if the journal queue is opened first.
    //
    QUEUE_SUFFIX_TYPE qst = pQueueFormat->Suffix();
    QUEUE_FORMAT* pqf = const_cast<QUEUE_FORMAT*>(pQueueFormat);

    //
    // Local direct queue gets a canonical format name: PUBLIC= or PRIVATE= in Domain environment,
    // DIRECT=OS:<MachineName> in Workgroup (DS-Less) environment (where <MachineName> in DNS
    // format if available).
    //
    if (pQueue->IsLocalQueue() && pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_DIRECT)
    {
        if (g_fWorkGroupInstallation)
        {
            AP<WCHAR> pLocalPathName;
            if (g_szComputerDnsName == NULL)
            {
                FnDirectIDToLocalPathName(pQueueFormat->DirectID(), g_szMachineName, pLocalPathName);
            }
            else
            {
                FnDirectIDToLocalPathName(pQueueFormat->DirectID(), g_szComputerDnsName, pLocalPathName);
            }
            pDirectId = new WCHAR[FN_DIRECT_OS_TOKEN_LEN + wcslen(pLocalPathName) + 1];
            wcscpy(pDirectId, FN_DIRECT_OS_TOKEN);
            wcscat(pDirectId, pLocalPathName);
            pLocalDirectQueueFormat = new QUEUE_FORMAT(pDirectId);
        }
        else
        {
            switch (pQueue->GetQueueType())
            {
                case QUEUE_FORMAT_TYPE_PUBLIC:
                    pLocalDirectQueueFormat = new QUEUE_FORMAT(*pQueue->GetQueueGuid());
                    break;

                case QUEUE_FORMAT_TYPE_PRIVATE:
                    pLocalDirectQueueFormat = new QUEUE_FORMAT(*pQueue->GetQueueGuid(),
                                                               pQueue->GetPrivateQueueId());
                    break;

                default:
                    ASSERT(0);
                    return LogHR(MQ_ERROR, s_FN, 320);
            }
        }
        pqf = pLocalDirectQueueFormat;
    }


    if(IsJournalQueueType(pqf))
    {
        pqf->Suffix(QUEUE_SUFFIX_TYPE_NONE);
    }

    const GUID* pDestGUID = pQueue->GetMachineQMGuid();
    rc = ACCreateQueue(
            pQueue->IsLocalQueue(),
            (pDestGUID) ? pDestGUID : &GUID_NULL,
            pqf,
            pQueue->GetQueueCounters(),
            GetNextSeqID(),
            0,
            &hQueue
            );

    //
    //  reset the journal flag state to the original state
    //
    pqf->Suffix(qst);

    if(FAILED(rc))
    {
        return LogHR(rc, s_FN, 330);
    }

    rc = ACSetQueueProperties(
                hQueue,
                pQueue->IsJournalQueue(),
                pQueue->ShouldMessagesBeSigned(),
                pQueue->GetPrivLevel(),
                pQueue->GetQueueQuota(),          // Quota
                pQueue->GetJournalQueueQuota(),
                pQueue->GetBaseQueuePriority(),
                pQueue->IsTransactionalQueue(),
                pQueue->GetConnectorQM(),
                pQueue->IsUnkownQueueType()
                );

    ASSERT(SUCCEEDED(rc));

    if(FAILED(rc))
    {
        return LogHR(rc, s_FN, 340);
    }

    pQueue->SetQueueHandle(hQueue);

    if (SUCCEEDED(rc)) {
        //
        // Asocciate the queue handle for IoPort. Needed for completion
        // indication of ACPutPacket
        //

        ExAttachHandle(hQueue);
    }

    return LogHR(rc, s_FN, 350);
}


/*====================================================

  RoutineName:

  Arguments:

  Return Value:

=====================================================*/

extern DWORD g_dwDefaultTimeToQueue ;

HRESULT
CQueueMgr::SendPacket(
    CMessageProperty *   pmp,
    const QUEUE_FORMAT   DestinationMqf[],
    ULONG                nDestinationMqf,
    const QUEUE_FORMAT * pAdminQueueFormat,
    const QUEUE_FORMAT * pResponseQueueFormat
    )
{
    CQueue *          pQueue = NULL;
    HRESULT           rc;

    //
    // Build AC Send Parameters Buffer
    //

    CACSendParameters SendParams;

    if (pAdminQueueFormat != NULL)
    {
        SendParams.nAdminMqf = 1;
        SendParams.AdminMqf =  const_cast<QUEUE_FORMAT*>(pAdminQueueFormat);
    }

    if (pResponseQueueFormat != NULL)
    {
        SendParams.nResponseMqf = 1;
        SendParams.ResponseMqf =  const_cast<QUEUE_FORMAT*>(pResponseQueueFormat);
    }

    //
    //  Set properties values
    //
    SendParams.MsgProps.pClass           = &pmp->wClass;
    if (pmp->pMessageID != NULL)
    {
        SendParams.MsgProps.ppMessageID  = const_cast<OBJECTID**>(&pmp->pMessageID);
    }
    if (pmp->pCorrelationID != NULL)
    {
        SendParams.MsgProps.ppCorrelationID  = const_cast<PUCHAR*>(&pmp->pCorrelationID);
    }
    SendParams.MsgProps.pPriority        = &pmp->bPriority;
    SendParams.MsgProps.pDelivery        = &pmp->bDelivery;
    SendParams.MsgProps.pAcknowledge     = &pmp->bAcknowledge;
    SendParams.MsgProps.pAuditing        = &pmp->bAuditing;
    SendParams.MsgProps.pTrace           = &pmp->bTrace;
    SendParams.MsgProps.pApplicationTag  = &pmp->dwApplicationTag;
    SendParams.MsgProps.ppBody           = const_cast<PUCHAR*>(&pmp->pBody);
    SendParams.MsgProps.ulBodyBufferSizeInBytes = pmp->dwBodySize;
    SendParams.MsgProps.pulBodyType      = &pmp->dwBodyType;
    SendParams.MsgProps.ulAllocBodyBufferInBytes = pmp->dwAllocBodySize;
    SendParams.MsgProps.pBodySize        = 0;
    SendParams.MsgProps.ppTitle          = const_cast<PWCHAR*>(&pmp->pTitle);
    SendParams.MsgProps.ulTitleBufferSizeInWCHARs = pmp->dwTitleSize;

    SendParams.MsgProps.ulAbsoluteTimeToQueue = pmp->dwTimeToQueue ;
    SendParams.MsgProps.ulRelativeTimeToLive = pmp->dwTimeToLive ;

    if ((SendParams.MsgProps.ulAbsoluteTimeToQueue == INFINITE) ||
        (SendParams.MsgProps.ulAbsoluteTimeToQueue == LONG_LIVED))
    {
        SendParams.MsgProps.ulAbsoluteTimeToQueue = g_dwDefaultTimeToQueue ;
    }

    if (SendParams.MsgProps.ulRelativeTimeToLive != INFINITE)
    {
       if (SendParams.MsgProps.ulAbsoluteTimeToQueue > SendParams.MsgProps.ulRelativeTimeToLive)
       {
          //
          // TimeToQueue should be less than TimeToLive
          //
          ASSERT(0) ;
          SendParams.MsgProps.ulAbsoluteTimeToQueue = SendParams.MsgProps.ulRelativeTimeToLive ;
          SendParams.MsgProps.ulRelativeTimeToLive = 0 ;
       }
       else
       {
          SendParams.MsgProps.ulRelativeTimeToLive -= SendParams.MsgProps.ulAbsoluteTimeToQueue ;
       }
    }

    //
    // Convert TimeToQueue, which was relative until now,
    // to absolute
    //
    ULONG utime = MqSysTime() ;
    if (utime > (SendParams.MsgProps.ulAbsoluteTimeToQueue + utime))
    {
       //
       // overflow. timeout too long.
       //
       ASSERT(INFINITE == 0xffffffff) ;
       ASSERT(LONG_LIVED == 0xfffffffe) ;

       SendParams.MsgProps.ulAbsoluteTimeToQueue = LONG_LIVED - 1 ;
    }
    else
    {
       SendParams.MsgProps.ulAbsoluteTimeToQueue += utime ;
    }

    SendParams.MsgProps.pulSenderIDType  = &pmp->ulSenderIDType;
    SendParams.MsgProps.ppSenderID       = const_cast<PUCHAR*>(&pmp->pSenderID);
    SendParams.MsgProps.uSenderIDLen     = pmp->uSenderIDLen;
    SendParams.MsgProps.ppSenderCert     = const_cast<PUCHAR*>(&pmp->pSenderCert);
    SendParams.MsgProps.ulSenderCertLen  = pmp->ulSenderCertLen;
    SendParams.MsgProps.pulPrivLevel     = &pmp->ulPrivLevel;
    SendParams.MsgProps.pulHashAlg       = &pmp->ulHashAlg;
    SendParams.MsgProps.pulEncryptAlg    = &pmp->ulEncryptAlg;
    SendParams.MsgProps.ppSymmKeys       = const_cast<PUCHAR*>(&pmp->pSymmKeys);
    SendParams.MsgProps.ulSymmKeysSize   = pmp->ulSymmKeysSize;
    SendParams.MsgProps.bEncrypted       = pmp->bEncrypted;
    SendParams.MsgProps.bAuthenticated   = pmp->bAuthenticated;
    SendParams.MsgProps.ppMsgExtension   = const_cast<PUCHAR*>(&pmp->pMsgExtension);
    SendParams.MsgProps.ulMsgExtensionBufferInBytes = pmp->dwMsgExtensionSize;
    SendParams.MsgProps.ppSignature      = const_cast<PUCHAR*>(&pmp->pSignature);
    SendParams.MsgProps.ulSignatureSize  = pmp->ulSignatureSize;
    if (SendParams.MsgProps.ulSignatureSize)
    {
        SendParams.MsgProps.fDefaultProvider = pmp->bDefProv;
        if (!pmp->bDefProv)
        {
            ASSERT(pmp->wszProvName);
            SendParams.MsgProps.ppwcsProvName    = const_cast<WCHAR **>(&pmp->wszProvName);
            SendParams.MsgProps.ulProvNameLen    = wcslen(pmp->wszProvName)+1;
            SendParams.MsgProps.pulProvType      = &pmp->ulProvType;
        }
        else
        {
            SendParams.MsgProps.ppwcsProvName    = NULL;
            SendParams.MsgProps.ulProvNameLen    = 0;
            SendParams.MsgProps.pulProvType      = NULL;
        }
    }

	//
	// Order ack information
	//
	if(pmp->pEodAckStreamId != NULL)
	{
		SendParams.MsgProps.ppEodAckStreamId  = (UCHAR**)&pmp->pEodAckStreamId;
		ASSERT(pmp->EodAckStreamIdSizeInBytes != 0);
		SendParams.MsgProps.EodAckStreamIdSizeInBytes = pmp->EodAckStreamIdSizeInBytes;
		
		SendParams.MsgProps.pEodAckSeqId  =  &pmp->EodAckSeqId;

		ASSERT(pmp->EodAckSeqNum != 0);
		SendParams.MsgProps.pEodAckSeqNum  = &pmp->EodAckSeqNum;
	}


    ASSERT(("Must have at least one destination queue", nDestinationMqf >= 1));
    if (nDestinationMqf == 1   &&
        DestinationMqf[0].GetType() != QUEUE_FORMAT_TYPE_DL)
    {

		//
	    // Translate the queue format name according to local mapping (qal.lib)
	    //
		QUEUE_FORMAT_TRANSLATOR  RealDestinationMqf(&DestinationMqf[0]);
	   	
        //
        // Single destination queue.
        //
        rc = GetQueueObject(RealDestinationMqf.get(), &pQueue, 0, false);
        if (FAILED(rc))
        {
            return LogHR(rc, s_FN, 360);
        }
    }
    else
    {
        //
        // Distribution queue.
        //
        try
        {
            rc = GetDistributionQueueObject(nDestinationMqf, DestinationMqf, &pQueue);
            if (FAILED(rc))
            {
                return LogHR(rc, s_FN, 362);
            }
        }
        catch (const bad_alloc&)
        {
            return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 364);
        }
        catch (const bad_hresult& failure)
        {
            return LogHR(failure.error(), s_FN, 366);
        }
        catch (const exception&)
        {
            ASSERT(("Need to know the real reason for failure here!", 0));
            return LogHR(MQ_ERROR_NO_DS, s_FN, 368);
        }
    }

    R<CQueue> Ref = pQueue;

    //
    // N.B. Using this version of ACSendMessage. there is no notification
    //      when the send is completed (persistent case)
    //      Also check quota for non system queues only.
    //
    rc = ACSendMessage( pQueue->GetQueueHandle(),
                       !pQueue->IsSystemQueue(),
                        SendParams );
    return LogHR(rc, s_FN, 370);
}

/*======================================================

Function:       CQueueMgr::LookUpQueue

Description:    the rutine returnes the CQueue object that match the Queue Guid

Arguments:      pguidQueue - Queue Guid

Return Value:   pQueue - pointer to CQueue object
                TRUE if a queue was found for the guid, FALSE otherwse.

Thread Context:

History Change:

========================================================*/

BOOL
CQueueMgr::LookUpQueue(
    IN  const QUEUE_FORMAT* pQueueFormat,
    OUT CQueue **           pQueue,
    IN  bool                fInReceive,
    IN  bool                fInSend
    )
{
    CS lock(m_cs);

    QUEUE_ID QueueObject = {0};
    BOOL     fSucc = FALSE;

    *pQueue = NULL;                         // set default return value
    switch (pQueueFormat->GetType())
    {
        case QUEUE_FORMAT_TYPE_PRIVATE:
            QueueObject.pguidQueue = const_cast<GUID*>(&pQueueFormat->PrivateID().Lineage);
            QueueObject.dwPrivateQueueId = pQueueFormat->PrivateID().Uniquifier;
            fSucc = m_MapQueueId2Q.Lookup((const PQUEUE_ID)&QueueObject, *pQueue);
            break;

        case QUEUE_FORMAT_TYPE_PUBLIC:
            //
            // Public Queue
            //
            QueueObject.pguidQueue = const_cast<GUID*>(&pQueueFormat->PublicID());
            fSucc = m_MapQueueId2Q.Lookup(&QueueObject, *pQueue);
            break;

        case QUEUE_FORMAT_TYPE_CONNECTOR:
            //
            // Connector Queue
            //
            QueueObject.pguidQueue = const_cast<GUID*>(&pQueueFormat->ConnectorID());
            QueueObject.dwPrivateQueueId = (pQueueFormat->Suffix() == QUEUE_SUFFIX_TYPE_XACTONLY) ? 1 : 0;
            fSucc = m_MapQueueId2Q.Lookup(&QueueObject, *pQueue);
            break;

        case QUEUE_FORMAT_TYPE_MACHINE:
            //
            // Machine Queue
            //
            QueueObject.pguidQueue = const_cast<GUID*>(&pQueueFormat->MachineID());
            fSucc = m_MapQueueId2Q.Lookup(&QueueObject, *pQueue);
            break;

        case QUEUE_FORMAT_TYPE_DIRECT:
            //
            // Direct Queue
            //
            if (fInSend)
            {
                //
                // Windows bug 666075.
                // We send message to ourselves using direct=tcp while computer
                // didn't have a ip address. So messaged ended in outgoing
                // queue. The queue itself did hold several recoverable messages
                // already. Then we boot with same ip (as in the  direct=tcp
                // format name). Upon recovery, packet are still considered
                // as outgoing, so format name is not converted to local
                // path name. The recovery code create two CQueue objects-
                // one for the messages already marked as "local" and another
                // one for the outgoing messages.
                // Then HandleNonActive is called and we reach here.
                // IsLocalDirectQueue will return TRUE (because it compares
                // ip addresses) and would pick the other CQueue object (the
                // "real" one, with local messages) instead of the outgoing
                // CQueue object that was created at recovery.
                // This "if" enforce us to choose the correct CQueue object
                // when called from HandleNonActive.
                //
                AP<WCHAR> lpwcsQueuePathName = new WCHAR[wcslen(pQueueFormat->DirectID())+1];

                wcscpy(lpwcsQueuePathName,pQueueFormat->DirectID());
                CharLower(lpwcsQueuePathName);
                fSucc = m_MapName2Q.Lookup(lpwcsQueuePathName, *pQueue);
            }
            else if (IsLocalDirectQueue(pQueueFormat, fInReceive))
            {
                //
                // System direct queues should have been replaced with machine queues
                // at this stage
                //
                ASSERT(!pQueueFormat->IsSystemQueue());

				try
				{
					AP<WCHAR> PathName;
				
					FnDirectIDToLocalPathName(
						pQueueFormat->DirectID(),
						g_szMachineName,
						PathName
						);
					
					fSucc = m_MapName2Q.Lookup(PathName.get(), *pQueue);
				}
				catch(const exception&)
				{
					LogIllegalPoint(s_FN, 372);
					return FALSE;
				}
            }
            else
            {
                AP<WCHAR> lpwcsQueuePathName = new WCHAR[wcslen(pQueueFormat->DirectID())+1];

                wcscpy(lpwcsQueuePathName,pQueueFormat->DirectID());
                CharLower(lpwcsQueuePathName);
                fSucc = m_MapName2Q.Lookup(lpwcsQueuePathName, *pQueue);
            }
            break;

        case QUEUE_FORMAT_TYPE_MULTICAST:
        {
            //
            // Lookup lowercase string in map
            //
            WCHAR QueueName[MAX_PATH];
            MQpMulticastIdToString(pQueueFormat->MulticastID(), QueueName);
            CharLower(QueueName);

            fSucc = m_MapName2Q.Lookup(QueueName, *pQueue);
            break;
        }

        default:
            ASSERT(0);
			LogIllegalPoint(s_FN, 374);
            return NULL;
    }

    if (fSucc)
    {
        //
        // Increment the refernce count. It is the caller responsibility to decrement it.
        //
        (*pQueue)->AddRef();
    }
    return(fSucc);
}

/*======================================================

Function:      CQueueMgr::AddQueueToHash

Description:   Add Queue To Hash Table and to active queue list

Arguments:     pguidQueue - Guid of the Queue
               pQueue     - pointer to CQueue Object

Return Value:  None

Thread Context:

History Change:

========================================================*/

void CQueueMgr::AddQueueToHashAndList(IN CQueue* pQueue)
{
    CS lock(m_cs);

	//
	// auto release reference couting in case of exception
	//
	R<CQueue> Ref(SafeAddRef(pQueue));

    //
    // Add queue to Active queue list
    //
    AddToActiveQueueList(pQueue);

    //
    // Add the queue to the map.
    //
    if (pQueue->GetQueueGuid() != NULL)
    {
        m_MapQueueId2Q[pQueue->GetQueueId()] = pQueue;
    }

    if (pQueue->GetQueueName() != NULL)
    {
        m_MapName2Q[pQueue->GetQueueName()] = pQueue;
    }

	//
	// Transfer ownership to the list
	//
	Ref.detach();
}

/*======================================================

Function:      CQueueMgr::RemoveQueueFromHash

Description:   remove a queue from the hash but don't remove
               remove it form the list

Arguments:     pQueue     - pointer to CQueue Object

Return Value:  None

Thread Context:

History Change:

========================================================*/

void CQueueMgr::RemoveQueueFromHash(CQueue* pQueue)
{
    CS lock(m_cs);

    //
    // Remove the queue from Id to Queue object map
    //
    if (pQueue->GetQueueGuid() != NULL)
    {
        m_MapQueueId2Q.RemoveKey(pQueue->GetQueueId());
        pQueue->SetQueueGuid(NULL) ;
    }

    //
    // Remove the queue from name to Queue object map
    //
    LPCTSTR  qName = pQueue->GetQueueName();
    if (qName != NULL)
    {
        m_MapName2Q.RemoveKey(qName);
        pQueue->SetQueueName(NULL);
    }
}


/*======================================================

Function:      CQueueMgr::RemoveQueue

Description:   Close handle and Remove Queue from Hash Tables

Arguments:     pQueue   - pointer to CQueue Object
               fDelete  - of TRUE then delete the object. Otherwise,
                          only invalidate the handle and remove from
                          hash tables.

Return Value:  None

Thread Context:

History Change:

========================================================*/

void CQueueMgr::RemoveQueue(CQueue* pQueue, LONGLONG *pliSeqId)
{
    ASSERT(pQueue != NULL);
    *pliSeqId = 0;

#ifdef _DEBUG
    {
        AP<WCHAR> lpcsQueueName;
        pQueue->GetQueue(&lpcsQueueName);
        DBGMSG((DBGMOD_QM,
            DBGLVL_TRACE,
            _TEXT("Remove Queue %ls"), lpcsQueueName.get()));
    }
#endif

    HANDLE hQueue = pQueue->GetQueueHandle();
    if (hQueue != INVALID_HANDLE_VALUE)
    {
		CQGroup::MoveQueueToGroup(pQueue, NULL);

        //
        // Find whether Exactly-Once-Delivery sequence exists
        //
        CACGetQueueProperties qp;
        HRESULT hr = ACGetQueueProperties(hQueue, qp);
        ASSERT(SUCCEEDED(hr));
        LogHR(hr, s_FN, 118);

        *pliSeqId = qp.liSeqID;

        //
        // Close the queue Handle
        //
        ACCloseHandle(hQueue);
        pQueue->SetQueueHandle(INVALID_HANDLE_VALUE);
    }

    RemoveQueueFromHash(pQueue);
}


/*======================================================
Function:      CanReleaseQueue

Description: Check if given queue object has no users so it can be released

========================================================*/
static bool CanReleaseQueue(const CBaseQueue& BaseQueue)
{
	//
	// If remote read queue - then we can remove it it has no users except the queue manager
	//
	if (BaseQueue.IsRemoteProxy())
    {
		if(BaseQueue.GetRef() == 1 )
			return true;

		return false;
    }

	//
	// On non remote queue - The queue can be removed if it has no external users
	// except the queue manager  and the group (if any)
	//
	const CQueue& Queue = static_cast<const CQueue&>(BaseQueue);
	if(Queue.GetRef() == 1 || 	(Queue.GetRef() == 2 && Queue.GetGroup()  != NULL) )
		return true;
	
	return false;
}



/*======================================================

Function:      CQueueMgr::ReleaseQueue

Description:   Scan the queue list and remove from internal DB all the queues
               that are not used. The creterias are:

                 - All the Application Handles are closed
                 - No waiting messgae in the queue.
                 - No waiting message in the associate journal queue

========================================================*/

void CQueueMgr::ReleaseQueue(void)
{
    CList<LONGLONG, LONGLONG&> listSeqId;

    //
    // Cleaning the unused queues
    //
    {
        CS lock(m_cs);

        ASSERT(m_fQueueCleanupScheduled);

        POSITION pos, prevpos;
        CBaseQueue*  pBQueue;

        pos = m_listQueue.GetHeadPosition();
        while(pos != NULL)
        {
            prevpos = pos;
            pBQueue = const_cast<CBaseQueue*>(m_listQueue.GetNext(pos));
		    if(CanReleaseQueue(*pBQueue))
            {
                if (pBQueue->IsRemoteProxy())
                {
                   m_listQueue.RemoveAt(prevpos);
				   RemoveRRQueue((CRRQueue*)pBQueue) ;
				   pBQueue->Release();
                }
                else
                {
                    CQueue* pQueue = (CQueue*) pBQueue ;

                    //
                    // Remove the queue only if there is no active session
                    //
                    if(! pQueue->IsConnected())
                    {
                        HANDLE hQueue = pQueue->GetQueueHandle();

                        ASSERT(hQueue != g_hAc);
                        ASSERT(hQueue != g_hMachine);
                        HRESULT hr  = ACCanCloseQueue(hQueue);
                        if (SUCCEEDED(hr))
                        {
                            DBGMSG((DBGMOD_QM,DBGLVL_INFO,
                                _T("ReleaseQueue %p; name=%ls"),pBQueue, pBQueue->GetQueueName()));

                            m_listQueue.RemoveAt(prevpos);

                            LONGLONG liSeqId;
                            RemoveQueue(pQueue, &liSeqId);
							pQueue->Release();
                            if (liSeqId != 0)
                            {
                                listSeqId.AddTail(liSeqId);
                            }
                        }
                        else
                        {
                            //
                            // Here MQ_ERROR indicates that the queue object
                            // can not be deleted. That's OK. So do not
                            // log here anything.
                            //
                        }
                    }
                }
            }
        }

        //
        // Set a new timer for Queues cleaning
        //
        if (m_listQueue.IsEmpty())
        {
            m_fQueueCleanupScheduled = FALSE;
        }
        else
        {
            ExSetTimer(&m_QueueCleanupTimer, m_CleanupTimeout);
        }
    }

    //
    // Release any Exactly-Once-Delivery sequences if any exist
    //
    if(!listSeqId.IsEmpty())
    {
        CS lockoutHash(g_critOutSeqHash);

        LONGLONG liSeqId;
        POSITION pos;

        pos = listSeqId.GetHeadPosition();
        while(pos != NULL)
        {
            liSeqId = listSeqId.GetNext(pos);

            // Deleting last and all previous sequences for the direction
            g_OutSeqHash.DeleteSeq(liSeqId);
        }
    }
}

/*======================================================

Function:      CQueueMgr::QueueDeleted

Description:   Queue was deleted. The function removed the queue from
               QM internal data structure and from the public queue cache

Arguments:     pguidQueue - Guid of the Queue

Return Value:  None

========================================================*/
void
CQueueMgr::NotifyQueueDeleted(IN const GUID* pguidQueue)
{
    CQueue* pQueue;
    QUEUE_FORMAT QueueFormat(*pguidQueue);
    R<CQueue> Ref = NULL;

    ASSERT(pguidQueue != NULL);

    DBGMSG((DBGMOD_QM,
            DBGLVL_TRACE,
            _TEXT("DS NOTIFICATION: Queue: %!guid! was deleted"), pguidQueue));

    //
    // Find the Queue ObjectIn QM internal Data Structure
    //
    if (LookUpQueue(&QueueFormat, &pQueue, false, false))
    {
        ASSERT (pQueue->GetQueueHandle() != INVALID_HANDLE_VALUE);
        ASSERT(pQueue->IsLocalQueue());
        ASSERT(pQueue->GetQueueType() == QUEUE_TYPE_PUBLIC);

        Ref = pQueue;      // automatic release
        //
        // Mark the queue as invalid
        //
        pQueue->SetQueueNotValid();
    }
}


VOID
CQueueMgr::UpdateQueueProperties(
    IN const QUEUE_FORMAT* pQueueFormat,
    IN DWORD       cpObject,
    IN PROPID      pPropObject[],
    IN PROPVARIANT pVarObject[]
    )
{
    CQueue* pQueue;
    R<CQueue> Ref = NULL;

    ASSERT(pQueueFormat != NULL);
    ASSERT((pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_PUBLIC) ||
           (pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_DIRECT) ||
           (pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_PRIVATE));

    QMpUpdateMulticastBinding(pQueueFormat, cpObject, pPropObject, pVarObject);

    //
    // Find the Queue ObjectIn QM internal Data Structure
    //
    if (LookUpQueue(pQueueFormat, &pQueue, false, false))
    {
        Ref = pQueue;

#ifdef _DEBUG
        {
            AP<WCHAR> lpcsQueueName;
            pQueue->GetQueue(&lpcsQueueName);
            DBGMSG((DBGMOD_QM,
                DBGLVL_TRACE,
                _TEXT("DS NOTIFICATION: Set Queue properties for queue: %ls"), lpcsQueueName));
        }
#endif
        ASSERT(pQueue->IsLocalQueue());

        BOOL fPropChange = FALSE;
        //
        // Change the queue properties
        //
        for (DWORD i = 0 ; i < cpObject ; i++ )
        {
            switch( pPropObject[i] )
            {
                case PROPID_Q_JOURNAL:
                    pQueue->SetJournalQueue(pVarObject[i].bVal == MQ_JOURNAL);
                    fPropChange = TRUE;
                    break;

                case PROPID_Q_QUOTA:
                    pQueue->SetQueueQuota(pVarObject[i].ulVal);
                    fPropChange = TRUE;
                    break;

                case PROPID_Q_BASEPRIORITY:
                    pQueue->SetBaseQueuePriority(pVarObject[i].iVal);
                    fPropChange = TRUE;
                    break;

                case PROPID_Q_JOURNAL_QUOTA:
                    pQueue->SetJournalQueueQuota(pVarObject[i].ulVal);
                    fPropChange = TRUE;
                    break;

                case PROPID_Q_SECURITY:
                    pQueue->SetSecurityDescriptor((SECURITY_DESCRIPTOR*)pVarObject[i].blob.pBlobData,
                                                  pVarObject[i].blob.cbSize);
                    break;

                case PROPID_Q_AUTHENTICATE:
                    pQueue->SetAuthenticationFlag(pVarObject[i].bVal);
                    break;

                case PROPID_Q_PRIV_LEVEL:
                    pQueue->SetPrivLevel(pVarObject[i].ulVal);
                    break;
            }
        }

        if (fPropChange)
        {
            HRESULT rc;
            rc = ACSetQueueProperties(
                        pQueue->GetQueueHandle(),
                        pQueue->IsJournalQueue(),
                        pQueue->ShouldMessagesBeSigned(),
                        pQueue->GetPrivLevel(),
                        pQueue->GetQueueQuota(),         // Quota
                        pQueue->GetJournalQueueQuota(),
                        pQueue->GetBaseQueuePriority(),
                        pQueue->IsTransactionalQueue(),
                        pQueue->GetConnectorQM(),
                        pQueue->IsUnkownQueueType()
                        );

            ASSERT(SUCCEEDED(rc));
            LogHR(rc, s_FN, 113);
        }
    }
} // CQueueMgr::UpdateQueueProperties


/*======================================================

Function:    ValidateMachineProperties()

========================================================*/

HRESULT
CQueueMgr::ValidateMachineProperties()
{
    PROPID aProp[6];
    PROPVARIANT aVar[6];
    HRESULT rc = MQ_ERROR_NO_DS;

    aProp[0] = PROPID_QM_PATHNAME;
    aProp[1] = PROPID_QM_QUOTA;
    aProp[2] = PROPID_QM_JOURNAL_QUOTA;

    aVar[0].vt = VT_NULL;
    aVar[1].vt = VT_UI4;
    aVar[2].vt = VT_UI4;


    rc = ADGetObjectPropertiesGuid(
                    eMACHINE,
                    NULL,   // pwcsDomainController
					false,	// fServerName
                    GetQMGuid(),
                    3,
                    aProp,
                    aVar
					);
    if (SUCCEEDED(rc))
    {
       UpdateMachineProperties(3, aProp, aVar);
    }

    return LogHR(rc, s_FN, 380);
}

/*======================================================

Function:      CQueueMgr::UpdateMachineProperties

Description:   Machine properties was changed. The function changed the mqchine
               properties and change the machine properties on the cache

Arguments:     pguidQueue - Guid of the Queue

Return Value:  None

========================================================*/
void
CQueueMgr::UpdateMachineProperties(IN DWORD       cpObject,
                                   IN PROPID      pPropObject[],
                                   IN PROPVARIANT pVarObject[])
{
    CS lock(m_cs);
    HRESULT rc;

    //
    // Change the queue properties
    //
    for(DWORD i = 0 ; i < cpObject ; i++ )
    {
        switch( pPropObject[i] )
        {
            case PROPID_QM_QUOTA:
                //
                // change Quota value of machine object
                //
                rc = ACSetMachineProperties(g_hAc, pVarObject[i].ulVal);
                LogHR(rc, s_FN, 115);

                //
                // Change the machine quota on registery
                //
                SetMachineQuotaChace(pVarObject[i].ulVal);
                break;

            case PROPID_QM_JOURNAL_QUOTA:
                //
                //  change the quota of the machine journal
                //
                rc = ACSetQueueProperties(
                        g_hMachine,
                        FALSE,
                        FALSE,
                        MQ_PRIV_LEVEL_OPTIONAL,
                        DEFAULT_Q_QUOTA,        // The deadletter quota, currently no property
                        pVarObject[i].ulVal,
                        0,
                        FALSE,
                        NULL,
                        FALSE
                        );
                LogHR(rc, s_FN, 116);

                //
                // Change the machine Journal quota on registery
                //
                SetMachineJournalQuotaChace(pVarObject[i].ulVal);
                break;

            case PROPID_QM_SECURITY:
                SetMachineSecurityCache((PVOID) pVarObject[i].blob.pBlobData,
                                        pVarObject[i].blob.cbSize );
                break;

            default:
                break;
        }
    }
}


void
CQueueMgr::GetOpenQueuesFormatName(
    LPWSTR** pppFormatName,
    LPDWORD  pdwFormatSize
    )
{
    *pppFormatName = NULL;
    *pdwFormatSize = 0;

    //
    //  Get the critical section to insure that no other
    //  thread add/remove queue
    //

    CS lock(m_cs);

    //
    // Retrieve number of queues
    //
    int iElem;
    iElem = m_listQueue.GetCount();  // The driver opens 3 queues (Machine Queues) always.
                                      // These queues are not appear in the QM hash tabel.
    //
    // Allocate result memory
    //
    DWORD Index = 0;
    AP<LPWSTR> pFormatName = new LPWSTR[iElem];


    try
    {
        //
        // Loop over all open queues
        //
        POSITION pos = m_listQueue.GetHeadPosition();
        while (pos)
        {
            const CQueue* pQueue;
            pQueue = static_cast<const CQueue*>(m_listQueue.GetNext(pos));

            if ((pQueue->GetQueueType() == QUEUE_TYPE_MACHINE) &&
                (pQueue->IsLocalQueue()))
            {
                continue;
            }


            if(pQueue->IsRemoteProxy())
            {
                //
                // Skip Remote Read queue.
                // NOTE: remote read queue does not have the NotValid Flag.
                //
                continue;
            }

            if (pQueue->QueueNotValid())
            {
                //
                // Ignore deleted queue
                //
                continue;
            }

            //
            // Copy the format name
            //
            WCHAR tmpBuf[1000];
            DWORD dwBufSize = 1000;
            HRESULT hr;
            hr = ACHandleToFormatName(pQueue->GetQueueHandle(), tmpBuf, &dwBufSize);
			LogHR(hr, s_FN, 102);
			if(FAILED(hr))
			{
				DBGMSG((DBGMOD_ALL,
                    DBGLVL_TRACE,
                    _T("ACHandleToFormatName returned error %x \n"),hr));

				ASSERT(SUCCEEDED(hr));
				throw bad_alloc();
			}	

            //
            // Allocate memory
            //
            pFormatName[Index] = new WCHAR[wcslen(tmpBuf) + 1];
            wcscpy(pFormatName[Index], tmpBuf);
            ++Index;
        }
    }
    catch(const bad_alloc&)
    {
        while(Index)
        {
            delete [] pFormatName[--Index];
        }

        LogIllegalPoint(s_FN, 1040);
        throw;
    }

    *pppFormatName = pFormatName.detach();
    *pdwFormatSize = Index;

}


/*======================================================

Function:      CQueueMgr::SetConnected

Description:   Assign if the DS access is allowed

========================================================*/
void CQueueMgr::SetConnected(bool fConnected)
{
    LONG Connected = fConnected;
    LONG PrevConnectValue = InterlockedExchange(&m_Connected, Connected);

    if (Connected == PrevConnectValue)
        return;

    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = REG_DWORD;

    SetFalconKeyValue(
        FALCON_CONNECTED_NETWORK,
        &dwType,
        &m_Connected,
        &dwSize
        );

    //
    // Don't catch the QueueMgr semaphore before calling the "SessionMgr.NetworkConnection"
    // It can cause deadlock
    //
    SessionMgr.NetworkConnection(m_Connected != 0);

    if (m_Connected == 0)
        return;

    CS lock(m_cs);

    //
    // Move the queues from On Hold group to NonActive Group. Queues that
    // are marked as onhold will be move back to the "onhold" group latter.
    //
	for(;;)
    {
        R<CQueue> pQueue =  g_pgroupDisconnected->RemoveHeadFromGroup();
		if (pQueue.get() == NULL)
		{
		     ASSERT(g_pgroupDisconnected->IsEmpty());
			 break;
		}

        g_pgroupNonactive->AddToGroup(pQueue.get());
    }

    //
    // handle the Queues that were opened when the machine was disconected
    //
    ValidateOpenedQueues();
    ValidateMachineProperties();
}


void
CQueueMgr::MoveQueueToOnHoldGroup(
    CQueue* pQueue
    )
{
    CS lock(m_cs);

    //
    // This check is protected with the CS. This insures that
    // if the queue is marked as OnHold queue no one changes
    // its status during the move
    //
    if (IsOnHoldQueue(pQueue))
    {
		CQGroup::MoveQueueToGroup(pQueue, g_pgroupDisconnected);
    }
}

/*======================================================

Function:      CQueueMgr::InitConnected

Description:   Initialize the network and DS connection state

========================================================*/
void
CQueueMgr::InitConnected(
    void
    )
{
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = REG_DWORD;
    DWORD DefaultValue = TRUE;

    GetFalconKeyValue(
        FALCON_CONNECTED_NETWORK,
        &dwType,
        &m_Connected,
        &dwSize,
        (LPCTSTR)&DefaultValue
        );
}

// [adsrv]
/*======================================================

Globally-available functions make it easy to find out the
nature of the available services on this very machine

========================================================*/
bool IsRoutingServer(void)
{
    return CQueueMgr::GetMQSRouting();
}


bool IsDepClientsServer(void)
{
    return CQueueMgr::GetMQSDepClients();
}

bool IsNonServer(void)
{
    return (!CQueueMgr::GetMQSRouting());
}

#ifdef _DEBUG
bool CQueueMgr::IsQueueInList(const CBaseQueue* pQueue)
/*++

  Routine Description:
   check if given queue is in the queues list

  Parameters:
    pQueue - pointer to basic Queue class

  Returned value:
    true - the queue is in the list otherwise false

  Note:
    This function is called from Cqueue destrcutor to verify that the queue
	is not in the list after destruction.
 --*/
{
	 POSITION pos = m_listQueue.GetHeadPosition();
     while(pos != NULL)
     {
		if(pQueue == m_listQueue.GetNext(pos))
			return true;
	 }
     return false;
}
#endif



void
CQueueMgr::AddToActiveQueueList(
    const CBaseQueue* pQueue
    )
/*++

  Routine Description:
    The routine add the queue to list of active queues. This list is used
    for cleanup and for admin purpose.
    The routine ignores the system queues, since they are only used internally
    by MSMQ and are never cleaned up.

  Parameters:
    pQueue - pointer to basic Queue class

  Returned value:
    None.

  Note:
    The list contains the regular queues and the remote read queues.
    The QueueManager critcal section must be held.

 --*/
{
    //
    // Ignore system queues on local machine. They are always alive.
    //
    if (pQueue->IsSystemQueue() && pQueue->IsLocalQueue())
        return;


    m_listQueue.AddTail(pQueue);
    if (!m_fQueueCleanupScheduled)
    {
        //
        // Set a new timer for Queues cleaning
        //
        ExSetTimer(&m_QueueCleanupTimer, m_CleanupTimeout);
        m_fQueueCleanupScheduled = TRUE;
    }

}


static
HRESULT
QMpDuplicateDistributionHandle(
    HANDLE   hDistribution,
    DWORD    CallingProcessID,
    HANDLE * phDuplicate
    )
{
    ASSERT(phDuplicate != NULL);

    CAutoCloseHandle hCallingProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, CallingProcessID);
    if(hCallingProcess == 0)
    {
        return MQ_ERROR_PRIVILEGE_NOT_HELD;
    }

    BOOL fSuccess = MQpDuplicateHandle(
                        GetCurrentProcess(),
                        hDistribution,
                        hCallingProcess,
                        phDuplicate,
                        MQAccessToFileAccess(MQ_SEND_ACCESS),
                        TRUE,
                        DUPLICATE_CLOSE_SOURCE
                        );
    if(!fSuccess)
    {
        return LogHR(MQ_ERROR_PRIVILEGE_NOT_HELD, s_FN, 1042);
    }

    return MQ_OK;

} // QMpDuplicateDistributionHandle


void
WINAPI
CQueueMgr::QueuesCleanup(
    CTimer* pTimer
    )
/*++
  Routine Description:
    The function is called from scheduler when Queueu Cleanup interval
    timeout is expired. The routine retrive the Queue Manager
    object and calls the ReleaseQueue member function .

  Arguments:
    pTimer - Pointer to Timer structure. pTimer is part of the Queue Manager
             object and it use to retrive the transport object.

  Return Value:
    None

--*/
{
    CQueueMgr* pQueueMgr = CONTAINING_RECORD(pTimer, CQueueMgr, m_QueueCleanupTimer);

    DBGMSG((DBGMOD_QM, DBGLVL_TRACE, _T("Call Queue Cleanup")));
    pQueueMgr->ReleaseQueue();
}



static HRESULT QMpTranslateError(HRESULT hr)
{
	if(SUCCEEDED(hr))
		return MQ_OK;

	switch(hr)
	{
    case HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN):
	case HRESULT_FROM_WIN32(ERROR_DS_SERVER_DOWN):
		return MQ_ERROR_NO_DS;
        break;

	case HRESULT_FROM_WIN32(ERROR_DS_DECODING_ERROR):
    case HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT):
		return MQDS_OBJECT_NOT_FOUND;
        break;

    case HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED):
        return MQ_ERROR_ACCESS_DENIED;
        break;

	default:
		return MQ_ERROR;
	}
}



VOID
CQueueMgr::ExpandMqf(
    ULONG              nTopLevelMqf,
    const QUEUE_FORMAT TopLevelMqf[],
    ULONG *            pnLeafMqf,
    QUEUE_FORMAT * *   ppLeafMqf
    ) const
/*++

Routine Description:

    Expand top level elemtns of a multi queue format to leaf elements.
    The elements that need expansion in the MQF are queue format of type DL=.
    Expansion means querying Active Directory for the leaf elements of a DL.

    This routine allocates memory for the leaf MQF. Deallocation is the
    responsibility of the caller.

Arguments:

    nTopLevelMqf - Number of top level elemenets in the array.

    TopLevelMqf  - Array of top level elements of multi queue format.

    pnLeafMqf    - Points to the number of leaf elements in the array, on output.

    ppLeafMqf    - Points to an array of leaf queue formats, on output.

Note:

    This routine may query Active Directory, which is quite lengthy,
    so make sure caller does not hold the member CS lock.

Return Value:

    None. Throws exception.

--*/
{
    ASSERT(nTopLevelMqf != 0);
    ASSERT(ppLeafMqf);
    ASSERT(pnLeafMqf);

    //
    // In DS-less configuration the formatname DL= is not supported.
    //
    if (g_fWorkGroupInstallation)
    {
        for (ULONG ix = 0; ix < nTopLevelMqf; ++ix)
        {
            if (TopLevelMqf[ix].GetType() == QUEUE_FORMAT_TYPE_DL)
            {
                TrERROR(QmMqf, "DL= not supported in DS-less mode");
                throw bad_hresult(MQ_ERROR_UNSUPPORTED_OPERATION);
            }
        }
    }

    //
    // Do expansion in AD
    //
    CCoInit cCoInit;
    HRESULT hr = cCoInit.CoInitialize();
    if (FAILED(hr))
    {
        TrERROR(QmMqf, "CoInitialize failed, status 0x%x", hr);
        LogHR(hr, s_FN, 1053);
        throw bad_alloc();
    }

	try
	{
		FnExpandMqf(nTopLevelMqf, TopLevelMqf, pnLeafMqf, ppLeafMqf);
	}
	catch(const bad_ds_result& e)
	{
		throw bad_hresult(QMpTranslateError(e.error()));
	}
} // CQueueMgr::ExpandMqf


HRESULT
CQueueMgr::GetDistributionQueueObject(
    ULONG              nTopLevelMqf,
    const QUEUE_FORMAT TopLevelMqf[],
    CQueue * *         ppQueue
    )
/*++

Routine Description:

    Get a queue object that represent a distribution queue.

    Note that this routine does not lock the member CS.

Parameters:

    nTopLevelMqf - Number of top level queue format names. Minimum is 1.

    TopLevelMqf  - The top level queue format names of the distribution.

    ppQueue      - Pointer to pointer to a queue object, on output.

Returned value:

    MQ_OK - The operation completed successfully.
    other status - The operation failed.

    This routine throws exception.

 --*/
{
    ASSERT(nTopLevelMqf != 0);
    ASSERT(ppQueue != NULL);

    AP<QUEUE_FORMAT> LeafMqf;
    ULONG            nLeafMqf;
    ExpandMqf(nTopLevelMqf, TopLevelMqf, &nLeafMqf, &LeafMqf);
    {
        //
        // Enforce cleaner is cleaned up before LeafMqf by scoping
        //
        CMqfDisposer cleaner(nLeafMqf, LeafMqf);

        HRESULT hr;
        AP< R<CQueue> > LeafQueues = new R<CQueue>[nLeafMqf];
        AP<bool> ProtocolSrmp = new bool[nLeafMqf];
        for (ULONG ix = 0; ix < nLeafMqf; ++ix)
        {
		    //
	        // Translate the queue format name according to local mapping (qal.lib)
	        //
			QUEUE_FORMAT_TRANSLATOR RealLeafMqf(&LeafMqf[ix]);

            //
            // GetDistributionQueueObject is called only in the send pass
            //
            hr = GetQueueObject(RealLeafMqf.get(), &LeafQueues[ix].ref(), 0, false);
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 1044);
            }

            LeafQueues[ix]->AddRef();

            ProtocolSrmp[ix] = (FnIsDirectHttpFormatName(RealLeafMqf.get()) ||
                                IsMulticastQueue(RealLeafMqf.get()));
        }

        QueueProps qp;
        FillMemory(&qp, sizeof(QueueProps), 0);
		QUEUE_FORMAT qf;
        R<CQueue> pDistribution = new CQueue(&qf ,INVALID_HANDLE_VALUE, &qp, TRUE);

        HANDLE hDistribution;
        hr = CreateACDistribution(nTopLevelMqf, TopLevelMqf, nLeafMqf, LeafQueues, ProtocolSrmp, &hDistribution);
        if(FAILED(hr))
        {
            return LogHR(hr, s_FN, 1046);
        }

        pDistribution->SetQueueHandle(hDistribution);

        *ppQueue = pDistribution.detach();
        return MQ_OK;
    }
} // CQueueMgr::GetDistributionQueueObject


HRESULT
CQueueMgr::OpenMqf(
    ULONG              nTopLevelMqf,
    const QUEUE_FORMAT TopLevelMqf[],
    DWORD              dwCallingProcessID,
    HANDLE *           phDistribution
    )
/*++

Routine Description:

    Open a distribution queue for send.

    Note that this routine does not lock the member CS.

Parameters:

    nTopLevelMqf - Number of top level queue formats. Minimum is 1.

    TopLevelMqf  - The top level queue formats of the distribution.

    dwCallingProcessID - Process ID of the user process.

    phDistribution     - Points to the handle of the distribution, on output.

Returned value:

    MQ_OK - The operation completed successfully.
    other status - The operation failed.

    This routine throws exception.

 --*/
{
    ASSERT(nTopLevelMqf != 0);
    ASSERT(phDistribution != NULL);

    AP<QUEUE_FORMAT> LeafMqf;
    ULONG            nLeafMqf;
    ExpandMqf(nTopLevelMqf, TopLevelMqf, &nLeafMqf, &LeafMqf);
    {
        //
        // Enforce cleaner is cleaned up before LeafMqf by scoping
        //
        CMqfDisposer cleaner(nLeafMqf, LeafMqf);

        HRESULT hr;
        AP< R<CQueue> > LeafQueues = new R<CQueue>[nLeafMqf];
        AP<bool> ProtocolSrmp = new bool[nLeafMqf];
        for (ULONG ix = 0; ix < nLeafMqf; ++ix)
        {
            hr = OpenQueue(&LeafMqf[ix], 0, MQ_SEND_ACCESS, 0, &LeafQueues[ix].ref(), NULL, NULL);
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 1048);
            }

            hr = VerifyOpenPermission(LeafQueues[ix].get(), &LeafMqf[ix], MQ_SEND_ACCESS, FALSE, LeafQueues[ix]->IsLocalQueue());
            if(FAILED(hr))
            {
                return LogHR(hr, s_FN, 1049);
            }

            ProtocolSrmp[ix] = (FnIsDirectHttpFormatName(&LeafMqf[ix]) ||
                                IsMulticastQueue(&LeafMqf[ix]));
        }

        hr = CreateACDistribution(nTopLevelMqf, TopLevelMqf, nLeafMqf, LeafQueues, ProtocolSrmp, phDistribution);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 1051);
        }

        hr = QMpDuplicateDistributionHandle(*phDistribution, dwCallingProcessID, phDistribution);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 1052);
        }

        return MQ_OK;
    }
} // CQueueMgr::OpenMqf


HRESULT
CQueueMgr::CreateACDistribution(
    ULONG              nTopLevelMqf,
    const QUEUE_FORMAT TopLevelMqf[],
    ULONG              nLeafQueues,
    const R<CQueue>    LeafQueues[],
    const bool         ProtocolSrmp[],
    HANDLE *           phDistribution
    )
/*++

Routine Description:

    Create a distribution object in the AC layer.

Parameters:

    nTopLevelMqf - Number of top level queues in the distribution. Minimum is 1.

    TopLevelMqf  - The top level queue formats of the distribution.

    nLeafQueues  - Number of leaf queues in the distribution. May be 0.

    LeafQueues   - The leaf queue objects of the distribution.

    ProtocolSrmp - Indicates for each queue of the distribution whether it is an http queue.

    phDistribution - Points to the handle of the distribution object, on output.

Returned value:

    MQ_OK - The operation completed successfully.
    other status - The operation failed.

    This routine throws bad_alloc exception.

 --*/
{
    //
    // Get the handles of all leaf queues.
    //
    AP<HANDLE> phLeafQueues = new HANDLE[nLeafQueues];
    for (ULONG ix = 0; ix < nLeafQueues; ++ix)
    {
        phLeafQueues[ix] = LeafQueues[ix]->GetQueueHandle();

        ASSERT(phLeafQueues[ix] != NULL);
        ASSERT(phLeafQueues[ix] != INVALID_HANDLE_VALUE);
    }

    //
    // Call AC to create the distribution object
    //
    return ACCreateDistribution(
               nLeafQueues,
               phLeafQueues,
               ProtocolSrmp,
               nTopLevelMqf,
               TopLevelMqf,
               phDistribution
               );
} // CQueueMgr::CreateACDistribution


HRESULT
CQueueMgr::SetQMGuid(
    void
    )
{
    DWORD dwValueType = REG_BINARY ;
    DWORD dwValueSize = sizeof(GUID);

    LONG rc = GetFalconKeyValue(MSMQ_QMID_REGNAME,
                               &dwValueType,
                               &m_guidQmQueue,
                               &dwValueSize);

    if (rc != ERROR_SUCCESS)
    {
        DWORD dwSysprep = 0;
        dwValueSize = sizeof(DWORD);
        dwValueType = REG_DWORD;

        GetFalconKeyValue(MSMQ_SYSPREP_REGNAME, &dwValueType, &dwSysprep, &dwValueSize);
        if (dwSysprep != 0)
        {
            DBGMSG((DBGMOD_ALL, DBGLVL_WARNING, _T("First run after Sysprep - generating a new QM ID !")));

            RPC_STATUS status = UuidCreate(&m_guidQmQueue);
			DBG_USED(status);
            ASSERT(("must succeed in generating guid for this QM", status == RPC_S_OK));

            dwValueType = REG_BINARY;
            dwValueSize = sizeof(GUID);
            rc = SetFalconKeyValue(MSMQ_QMID_REGNAME, &dwValueType, &m_guidQmQueue, &dwValueSize);

            if (rc != ERROR_SUCCESS)
            {
                DBGMSG((DBGMOD_ALL, DBGLVL_ERROR, _T("Failed to set QM Guid in registry, error 0x%x"), rc));
                REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL, MQ_ERROR_CANNOT_WRITE_REGISTRY, 1, MSMQ_QMID_REGNAME));
                return MQ_ERROR;
            }

            DeleteFalconKeyValue(MSMQ_SYSPREP_REGNAME);
            return MQ_OK;
        }

        DBGMSG((DBGMOD_ALL, DBGLVL_ERROR, _T("Can't initilize QM Guid. Error %d"), GetLastError()));
        REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL, REGISTRY_FAILURE, 1, MSMQ_QMID_REGNAME));
        return(MQ_ERROR);
    }

    ASSERT((dwValueType == REG_BINARY) &&
           (dwValueSize == sizeof(GUID)));

    return(MQ_OK);
}


HRESULT
CQueueMgr::SetQMGuid(
    const GUID * pGuid
    )
{
    m_guidQmQueue = *pGuid;

    return(MQ_OK);
}


HRESULT
CQueueMgr::SetMQSRouting(
    void
    )
{
   DWORD dwDef = 0xfffe ;
   DWORD dwMQSRouting;
   READ_REG_DWORD(dwMQSRouting, MSMQ_MQS_ROUTING_REGNAME, &dwDef ) ;
   if (dwMQSRouting == dwDef)
   {
      DBGMSG((DBGMOD_ALL, DBGLVL_ERROR, _T("QMInit :: Could not retrieve data for value MQSRouting in registry")));
      REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL, REGISTRY_FAILURE, 1, MSMQ_MQS_ROUTING_REGNAME));
      return MQ_ERROR;
   }

   m_bMQSRouting = (dwMQSRouting != 0);

   DBGMSG((DBGMOD_QM, DBGLVL_TRACE, L"Setting QM Routing status: %d",m_bMQSRouting)) ;

   return MQ_OK;
}


HRESULT
CQueueMgr::SetMQSDepClients(
    void
    )
{
   DWORD dwDef = 0xfffe ;
   DWORD dwMQSDepClients;
   READ_REG_DWORD(dwMQSDepClients, MSMQ_MQS_DEPCLINTS_REGNAME, &dwDef ) ;
   if (dwMQSDepClients == dwDef)
   {
      DBGMSG((DBGMOD_ALL, DBGLVL_ERROR, _T("QMInit::Could not retrieve data for value MQSDepClients in registry")));
      REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL, REGISTRY_FAILURE, 1, MSMQ_MQS_DEPCLINTS_REGNAME));
      return MQ_ERROR;
   }

   m_bMQSDepClients = (dwMQSDepClients != 0);

   DBGMSG((DBGMOD_QM, DBGLVL_TRACE, L"Setting QM Dependent Clients Servicing state: %d",m_bMQSDepClients)) ;

   return MQ_OK;
}


HRESULT
CQueueMgr::SetMessageSizeLimit(
    void
    )
{
    ULONG ulDefault = MSMQ_DEFAULT_MESSAGE_SIZE_LIMIT;
    READ_REG_DWORD(
        m_MessageSizeLimit,
        MSMQ_MESSAGE_SIZE_LIMIT_REGNAME,
        &ulDefault
        );

   DBGMSG((DBGMOD_QM, DBGLVL_TRACE, L"Setting QM Max Message size: %u",m_MessageSizeLimit)) ;

   return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\cqueue.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    cqueue.h

Abstract:
    Definition of a Receive/Send queue class

Author:
    Uri habusha (urih)

--*/


#ifndef __CQUEUE_H__
#define __CQUEUE_H__

#include "qmpkt.h"
#include "session.h"
#include "acdef.h"
#include "qmutil.h"

#include "qm2qm.h"
#include "msi.h"

#define  QUEUE_SIGNATURE  0x426f617a

typedef struct _QueueProps
{
    LPWSTR  lpwsQueuePathName;
    GUID*   pQMGuid;
    BOOL    fIsLocalQueue;
    BOOL    fJournalQueue;
    BOOL    fTransactedQueue;
    DWORD   dwQuota;
    DWORD   dwJournalQuota;
    GUID    guidDirectQueueInstance;
    SHORT   siBasePriority;
    BOOL    fSystemQueue;
    BOOL    fConnectorQueue;
    BOOL    fAuthenticate;
    DWORD   dwPrivLevel;
    BOOL    fForeign;
    BOOL    fUnknownQueueType;
    AP<WCHAR> lpwsQueueDnsName;
} QueueProps, * PQueueProps;

class CQGroup;

#define  QUEUE_TYPE_UNKNOWN 0
#define  QUEUE_TYPE_PUBLIC  1
#define  QUEUE_TYPE_PRIVATE 2
#define  QUEUE_TYPE_MACHINE 3
#define  QUEUE_TYPE_CONNECTOR 4
#define  QUEUE_TYPE_MULTICAST 5

struct RR_CLIENT_INFO {
   ULONG hcliQueue;
   ULONG ulTag;
};

inline UINT AFXAPI HashKey(const RR_CLIENT_INFO& key)
{
    return key.ulTag;
}

inline operator ==(const RR_CLIENT_INFO& a, const RR_CLIENT_INFO& b)
{
    return ((a.hcliQueue == b.hcliQueue) && (a.ulTag == b.ulTag));
}

typedef CMap<RR_CLIENT_INFO, const RR_CLIENT_INFO&, DWORD, DWORD> CRemoteMapping;

//
// CBaseQueue Class
//==================
// Data Memeber:
//
//   m_qName - This field is used in debuging mode. It is used for producing
//             meaningfull debug messages. It is also used for auditing in
//             order to write the queue name in the audited events.
//

class CBaseQueue : public IMessagePool
{
public:
    CBaseQueue() ;

protected:
    virtual ~CBaseQueue() {}

public:
    BOOL IsLocalQueue(void) const ;
    BOOL IsRemoteProxy(void) const ;
    BOOL IsDSQueue(void) const;
    BOOL IsPrivateQueue(void) const;
    BOOL IsSystemQueue() const;

    const GUID *GetQueueGuid(void) const;
    void  SetQueueGuid(GUID *pGuid) ;
    const PQUEUE_ID GetQueueId(void);

    void  InitNameAndGuid( IN const QUEUE_FORMAT* pQueueFormat,
                         IN PQueueProps         pQueueProp) ;

    LPCTSTR GetQueueName(void) const ;
    void    SetQueueName(LPTSTR pName);

    inline DWORD GetSignature() { return m_dwSignature ; }

    const QUEUE_FORMAT GetQueueFormat() const;

#ifdef _DEBUG
    void GetQueue(OUT LPWSTR* lpcsQueue);
#endif

protected:
    LPWSTR GetName() const;


protected:

    union {
        USHORT   m_usQueueType;
        struct {
            USHORT m_fLocalQueue      : 1;
            USHORT m_fRemoteProxy     : 1;
            USHORT m_fSystemQueue     : 1;      // True if private system Queue.
            USHORT m_fConnectorQueue  : 1;
            USHORT m_fForeign         : 1;
            USHORT m_fJournalQueue    : 1;
            USHORT m_fTransactedQueue : 1;
            USHORT m_fAuthenticate    : 1;
            USHORT m_fUnknownQueueType: 1;      // TRUE if opened without DS
        };
    };


    LPTSTR      m_qName ;
    QUEUE_ID    m_qid ;
    DWORD       m_dwQueueType;
    DWORD       m_dwSignature ;
};

//
// CQueue Class
//===============
// Data Memeber:
//
//   m_qHandle - Specifies the queue handle in AC driver. All the reference to the queue
//             in AC is with this handle.
//
//   m_qGroupHandle - specifies the handle of the group to which the queue is belong. This
//             field is only relevant for send queues.
//
//   m_qGuid - Queue guid using to identify the queue.
//
//   m_fSendMore - indicates if more packets can be passed to the session. This field
//             is only relevant for the send queue.
//
//   m_qSock - SOCKET Handle uses for sending packet to a queue. Relevant for send
//             packet only.
//
//   m_listPkt - Unsend packet, when the packet can be resend all the packets are returned to
//             AC driver. The driver is responsible to hold them according to there priority.
//

class CQueue : public CBaseQueue
{
  public:
      CQueue( IN const QUEUE_FORMAT* pQueueFormat,
              IN HANDLE              hQueue,
              IN PQueueProps         pQueueProp,
              IN BOOL                fNotDSValidated = FALSE ) ;

  protected:
      virtual ~CQueue();

  public:
      void  InitQueueProperties(IN PQueueProps   pQueueProp) ;

      void   SetQueueHandle(IN HANDLE hQueue);
      HANDLE GetQueueHandle(void) const;

      HRESULT  PutPkt(IN CQmPacket*      PktPtrs,
                      IN BOOL            fRequeuePkt,
                      IN CTransportBase* pSession);

      HRESULT  PutOrderedPkt(IN CQmPacket*       PktPtrs,
                             IN BOOL             fRequeuePkt,
                             IN CTransportBase*  pSession);

      void CreateConnection(void) throw(std::bad_alloc);

      void Connect(IN CTransportBase * pSess) throw(std::bad_alloc);

      HANDLE GetGroupHandle(void) const;

      void SetSessionPtr(CTransportBase*);
      BOOL IsConnected(void) const;

      void     SetGroup(CQGroup*);
      CQGroup* GetGroup(void) const;

      void SetJournalQueue(BOOL);
      BOOL IsJournalQueue(void) const;

      void  SetQueueQuota(DWORD);
      DWORD GetQueueQuota(void) const;

      void  SetJournalQueueQuota(DWORD);
      DWORD GetJournalQueueQuota(void) const;

      void SetBaseQueuePriority(LONG);
      LONG GetBaseQueuePriority(void) const;

      void SetTransactionalQueue(BOOL);
      BOOL IsTransactionalQueue(void) const;

      BOOL IsConnectorQueue(void) const;
      BOOL IsForeign(void) const;

      void SetAuthenticationFlag(BOOL);
      BOOL ShouldMessagesBeSigned() const;

      void  UnknownQueueType(BOOL);
      BOOL  IsUnkownQueueType() const;

      void SetPrivLevel(DWORD);
      DWORD GetPrivLevel(void) const;

      BOOL IsValidOtherwiseRelease(void);

      DWORD GetQueueType(void) const;

      DWORD GetPrivateQueueId(void) const;

      const GUID* GetMachineQMGuid(void) const;

      void  ClearRoutingRetry(void);
      void  IncRoutingRetry(void);
      DWORD GetRoutingRetry(void) const;

      void  SetHopCountFailure(BOOL flag);
      BOOL  IsHopCountFailure(void) const;


      // Method on server side to register a pending read request for a
      // remote reader. Needed for cleanup.
      //
      void RegisterReadRequest(ULONG hRemote, ULONG cli_tag, ULONG srv_tag);
      void UnregisterReadRequest(ULONG hRemote, DWORD cli_tag);

      HRESULT CancelPendingRemoteRead(ULONG hRemote, HRESULT hr, DWORD ulTag);


      void SetSecurityDescriptor(void);
      void SetSecurityDescriptor(const SECURITY_DESCRIPTOR*, DWORD);

      const VOID* GetSecurityDescriptor();
      BOOL  QueueNotValid() const;
      void  SetQueueNotValid() ;

      QueueCounters* GetQueueCounters();

      HRESULT SetConnectorQM(const GUID* pgConnectorQM = NULL);
      const GUID* GetConnectorQM(void) const;

      const GUID* GetRoutingMachine(void) const;

      void PerfUpdateName(void) const;

      bool IsDirectHttpQueue(void) const;
      void CreateHttpConnection(void);
      void CreateMulticastConnection(const MULTICAST_ID& id);

      //
      // Admin Functions
      //
      LPCWSTR GetConnectionStatus(void) const;
      LPCWSTR GetHTTPConnectionStatus(void) const;

      LPCWSTR GetType(void) const;
      LPWSTR GetNextHop(void) const;
      BOOL IsOnHold(void) const;
      void Pause(void);
      void Resume(void);

  public:
    //
    // Queue interfaces
    //
    void Requeue(CQmPacket* pPacket);
    void EndProcessing(CQmPacket* pPacket);
    void LockMemoryAndDeleteStorage(CQmPacket * pPacket);

    void GetFirstEntry(EXOVERLAPPED* pov, CACPacketPtrs& acPacketPtrs);
    void CancelRequest(void);

  private:
		R<CQGroup> CreateMessagePool(void);

  private:
        mutable CCriticalSection    m_cs;

        LONG                m_lBasePriority;
        DWORD               m_dwPrivLevel;       // Required privacy level of messages.
        DWORD               m_dwQuota;
        DWORD               m_dwJournalQuota;
        GUID*               m_pguidDstMachine;   //
        GUID*               m_pgConnectorQM;
        CTransportBase*     m_pSession;          // pointer to session
        CQGroup*            m_pGroup;            // pointer togroup the queue belong

        PSECURITY_DESCRIPTOR m_pSecurityDescriptor; // The security descriptor
                                                    // of the queue.
        DWORD               m_dwRoutingRetry;
        BOOL                m_fHopCountFailure;

        HANDLE m_hQueue;   // Queue handle in AC driver
        BOOL m_fNotValid;
        LONG m_fOnHold;

        //
        //Queue performance counters defenitions
        //
        QueueCounters *m_pQueueCounters;

        void PerfRemoveQueue();
        void PerfRegisterQueue();

        //
        //  Data for server side of remote read.
        //  On server side, we use the standard CQueue object.
        //
#ifdef _DEBUG
        LONG  m_cPendings ;
#endif
        CCriticalSection m_srvr_RemoteMappingCS ;
        CRemoteMapping *m_srvr_pRemoteMapping ;
        //
        // This mapping object is kept in the server side of remote reader.
        // It maps between irp in client side (irp of read request in client
        // side) and a structure containing client queue handle, client
        // cursor handle and irp on server side.
        // Whenever a remote read is pending (on server side), the mapping
        // are updated.
        // If client side closes the queue (or the client thread terminate),
        // a Cancel or Close is performed. The server side uses the mapping
        // to know which irp to cancel in the driver. The server get the
        // irp from the client on each call.
        // This mapping enable one server queue to service several clients
        // queues, when each client queue has several pending read requests.
        // The critical section makes the mapping objects threads safe.
        //

};

//
// CRRQueue Class
//================
// Data Memeber:
//

class CRRQueue : public CBaseQueue
{
  public:
      CRRQueue( IN const QUEUE_FORMAT* pQueueFormat,
                IN PQueueProps         pQueueProp ) ;

  protected:
      virtual ~CRRQueue();

  public:
      void  RemoteRead( CACRequest * pRequest ) ;

      void  RemoteCloseQueue(PCTX_RRSESSION_HANDLE_TYPE pRRContext);
      void  RemoteCloseQueue(CACRequest* pRequest);
      void  RemoteCloseCursor(CACRequest* pRequest);
      void  RemoteCancelRead(CACRequest* pRequest);
      void  RemotePurgeQueue(CACRequest* pRequest);

      HANDLE GetRemoteQueueHandle(void) const;

      HRESULT OpenRRSession(
                ULONG hRemoteQueue,
                ULONG pRemoteQueue,
                PCTX_RRSESSION_HANDLE_TYPE *ppRRContext,
                DWORD  dwpContext );

    //
    // Queue interfaces
    //
    void Requeue(CQmPacket* )
    {
        ASSERT(0);
    }


    void EndProcessing(CQmPacket* )
    {
        ASSERT(0);
    }


    void LockMemoryAndDeleteStorage(CQmPacket* )
    {
        ASSERT(0);
    }


    void GetFirstEntry(EXOVERLAPPED* , CACPacketPtrs& )
    {
        ASSERT(0);
    }


    void CancelRequest(void)
    {
        ASSERT(0);
    }


  private:
      void   CreateThread(PVOID pThreadFunction, CACRequest *pRequest) ;

      handle_t m_hRemoteBind;
      handle_t m_hRemoteBind2;

      //
      // Version of the remote QM. For remote QM of version that does not 
      // support latest remote read interface these fields are zero.
      //
      UCHAR  m_RemoteQmMajorVersion;
      UCHAR  m_RemoteQmMinorVersion;
      USHORT m_RemoteQmBuildNumber;

      //
      //   Methods for remote reader
      //
      HRESULT      BindRemoteQMService() ;
      RPC_STATUS   UnBindRemoteQMService() ;

  public:
      CCriticalSection m_cli_csRemoteClose ;
       //
       // This critical section serialized the calls to remote side to
       // close the queue or cancel a read request.
       // This member is public because it is accessed from the remote
       // read threads.
      DWORD m_dwcli_pQMQueueMapped; //Contains a mapping of this CRRQueue
                                    //instance inside g_map_QM_cli_pQMQueue
};

//
// Inline functions of CBaseQueue
//

/*======================================================

Function:        CBaseQueue::GetQueueName

Description:     Returns the name of the queue

Arguments:       None

Return Value:    Returns the name of the queue

Thread Context:

History Change:

========================================================*/

inline LPCTSTR
CBaseQueue::GetQueueName(void) const
{
    return(m_qName);
}

/*======================================================

Function:        CBaseQueue::IsLocalQueue

Description:     Returns if the queue is local queue (open for receive
                 and not FRS queue) or not.

Arguments:       None

Return Value:    TRUE, if the queue is local queue. FALSE otherwise

Thread Context:

History Change:

========================================================*/

inline BOOL
CBaseQueue::IsLocalQueue(void) const
{
   return(m_fLocalQueue);
}

/*======================================================

Function:        CBaseQueue::IsRemoteProxy

Description:     Returns if the queue is local queue (open for receive
                 and not FRS queue) or not.

Arguments:       None

Return Value:    TRUE, if the queue is local queue. FALSE otherwise

Thread Context:

History Change:

========================================================*/

inline BOOL
CBaseQueue::IsRemoteProxy(void) const
{
   return(m_fRemoteProxy) ;
}

/*======================================================

Function:        CBaseQueue::IsDSQueue

========================================================*/

inline BOOL
CBaseQueue::IsDSQueue(void) const
{
   return (m_qid.pguidQueue && (m_qid.dwPrivateQueueId == 0));
}

/*======================================================

Function:        CBaseQueue::IsPrivateQueue

========================================================*/

inline BOOL
CBaseQueue::IsPrivateQueue(void) const
{
   return (m_qid.pguidQueue && (m_qid.dwPrivateQueueId != 0));
}


inline BOOL CBaseQueue::IsSystemQueue(void) const
{
    return m_fSystemQueue;
}

/*======================================================

Function:        CBaseQueue::GetQueueGuid

Description:     Returns the guid of the queue

Arguments:       None

Return Value:    Returns the guid of the queue

Thread Context:

History Change:

========================================================*/

inline const GUID *
CBaseQueue::GetQueueGuid(void) const
{
        return(m_qid.pguidQueue);
}

/*======================================================

Function:        CBaseQueue::SetQueueGuid

Description:     Set the guid of the queue

Arguments:       None

Thread Context:

History Change:

========================================================*/

inline void
CBaseQueue::SetQueueGuid(GUID *pGuid)
{
   if (m_qid.pguidQueue)
   {
      delete m_qid.pguidQueue ;
   }
   m_qid.pguidQueue = pGuid ;
}

/*======================================================

Function:        CBaseQueue::GetQueueId

Description:     Returns the id of the queue

========================================================*/
inline const PQUEUE_ID
CBaseQueue::GetQueueId(void)
{
        return(&m_qid);
}

/*======================================================

Function:        CBaseQueue::NullQueueName

Description:     Returns the name of the queue

Arguments:       None

Return Value:    Returns the name of the queue

Thread Context:

History Change:

========================================================*/

inline void
CBaseQueue::SetQueueName(LPTSTR pName)
{
   delete [] m_qName;

   m_qName = pName ;
}

//*******************************************************************
//
// Inline functions of CQueue
//
//*******************************************************************

 //++
 // Function: CQueue::GetQueueHandle
 //
 // Synopsis: The function returns the queue handle
 //
 //--

inline HANDLE
CQueue::GetQueueHandle(void) const
{
    ASSERT(this);
   return(m_hQueue);
}

 //++
 // Function: CQueue::SetQueueHandle
 //
 // Synopsis: The function set the queue handle
 //
 // Arguments:       hQueue - Handle to a queue
 //
 //--

inline void
CQueue::SetQueueHandle(IN HANDLE hQueue)
{
   m_hQueue = hQueue;
}

/*======================================================

Function:        CQueue::GetGroupHandle

Description:     The function returns the handle of the group that the queue belongs

Arguments:       None

Return Value:    Handle of the group

Thread Context:

History Change:

========================================================*/
inline HANDLE
CQueue::GetGroupHandle(void) const
{
    return(m_pSession->GetGroupHandle());
}

/*======================================================

Function:        CQueue::SetSessionPtr

Description:     The function set the  Session that the queue belongs

========================================================*/
inline void
CQueue::SetSessionPtr(CTransportBase* pSession)
{
    CS lock(m_cs);

    m_pSession = pSession;

    //
    // If the Queue is connected to new session but the queue is mark
    // as onhold queue, disconnect the session. This can happen when the
    // connection process began before the queue move to onhold and
    // completed after
    //
    if ((m_pSession != NULL) && IsOnHold())
    {
        m_pSession->Disconnect();
    }
}

//+-------------------------------------------------------------------------
//
//  inline BOOL CQueue::IsConnected(void) const
//
//  bug 4342.
//  stop reciving transactional messages because of failure to access the
//  DS.  The receiver, sender and DS are on line and sending/receiving
//  messages. At some time the DS goes down, as a result the receiver stop
//  sending order acks and the sender stop sending a newer messages.
//  This bug caused since the "sender order ack" queue is cleaned-up. when
//  the receiver try to send a new order ack, the QM tries to open the queue
//  but failed due "ERROR_NO_DS". The QM moves the queue to "need validate"
//  group and wait until the DS will be  on line.
//  First fix- Release queue object only if there is no an active session.
//
//  This caused regression, because if session never close (there is a lot
//  of traffic between the machines) then queues will never be cleaned up.
//  This is exactly what happen at upgraded PEC. Because of replication and
//  hello traffic, there are many permanent sessions with BSCs and PSCs.
//  Second fix- Apply first fix only to system queues, not to users queues.
//
//+-------------------------------------------------------------------------

inline BOOL CQueue::IsConnected(void) const
{
    BOOL fIsConnected = (m_pSession != NULL) && IsSystemQueue() ;
    return fIsConnected ;
}


/*======================================================

Function:        CQueue::SetGroup

Description:     The function set the  Group that the queue belongs

========================================================*/
inline void
CQueue::SetGroup(CQGroup* pGroup)
{
    m_pGroup = pGroup;
}


/*======================================================

Function:        CQueue::SetGroup

Description:     The function set the  Group that the queue belongs

========================================================*/
inline CQGroup*
CQueue::GetGroup(void) const
{
    return m_pGroup;
}

/*======================================================

Function:        CQueue::IsValidOtherwiseRelease

Description:     Returns TRUE if queue is still valid (has messages),
                 otherwise release the queue and returns FALSE

Arguments:       None

Return Value:    TRUE/FALSE

Thread Context:

History Change:

========================================================*/
inline BOOL
CQueue::IsValidOtherwiseRelease(void)
{
    // if scheduler propted the routing module to rebuild
    // but meanwhile all the messages on the queue have been timeouted
    // there is no need to rebuild DS info
    // and create a session for the queue
    // and the queue can be release
    //
    //
    // bugbug, not implemented yet
    //
        return(TRUE);
}

/*======================================================

Function:        CQueue::GetQueueType

Description:

Arguments:

Return Value:

========================================================*/
inline DWORD
CQueue::GetQueueType(void) const
{
    return m_dwQueueType;
}

/*======================================================

Function:        CQueue::GetPrivateQueueId

Description:

Arguments:

Return Value:

========================================================*/
inline DWORD
CQueue::GetPrivateQueueId(void) const
{
    return m_qid.dwPrivateQueueId;
};

/*======================================================

Function:        CQueue::GetMachineQMGuid

Description:

Arguments:

Return Value:

========================================================*/
inline const GUID*
CQueue::GetMachineQMGuid(void) const
{
    return m_pguidDstMachine;
}

/*======================================================

Function:        CQueue::SetSecurityDescriptor

Description:

========================================================*/
inline void
CQueue::SetSecurityDescriptor(const SECURITY_DESCRIPTOR* pSD, DWORD dwSDLength)
{
    delete [] m_pSecurityDescriptor;                                 // delete the previous SD
    m_pSecurityDescriptor = NULL;

    m_pSecurityDescriptor = (PSECURITY_DESCRIPTOR)new char[dwSDLength]; // Allocate the memory.
    memcpy(m_pSecurityDescriptor, pSD, dwSDLength);                  // Copy the security descriptor.

}

/*======================================================

Function:        CQueue::GetSecurityDescriptor

Description:

Arguments:

Return Value:

========================================================*/
inline const VOID *
CQueue::GetSecurityDescriptor(void)
{
    return m_pSecurityDescriptor;
}

inline void
CQueue::SetJournalQueue(BOOL f)
{
    m_fJournalQueue = f ? 1 : 0;
}

inline BOOL
CQueue::IsJournalQueue(void) const
{
    return m_fJournalQueue;
}

inline void
CQueue::SetQueueQuota(DWORD dwQuota)
{
    m_dwQuota = dwQuota;
}

inline BOOL
CQueue::IsTransactionalQueue(void) const
{
    return m_fTransactedQueue;
}

inline void
CQueue::SetTransactionalQueue(BOOL f)
{
    m_fTransactedQueue = f ? 1 : 0;
}

inline void
CQueue::SetAuthenticationFlag(BOOL fAuthntication)
{
    m_fAuthenticate = fAuthntication;
}

inline BOOL
CQueue::ShouldMessagesBeSigned(void) const
{
    return m_fAuthenticate;
}

inline void
CQueue::SetPrivLevel(DWORD dwPrivLevel)
{
    m_dwPrivLevel = dwPrivLevel;
}

inline DWORD
CQueue::GetPrivLevel(void) const
{
    return m_dwPrivLevel;
}

inline BOOL
CQueue::IsConnectorQueue(void) const
{
    return m_fConnectorQueue;
}

inline BOOL
CQueue::IsForeign(void) const
{
    return m_fForeign;
}

inline DWORD
CQueue::GetQueueQuota(void) const
{
    return m_dwQuota;
}

inline void
CQueue::SetJournalQueueQuota(DWORD dwJournalQuota)
{
    m_dwJournalQuota = dwJournalQuota;
}

inline DWORD
CQueue::GetJournalQueueQuota(void) const
{
    return m_dwJournalQuota;
}

inline void
CQueue::SetBaseQueuePriority(LONG lBasePriority)
{
    m_lBasePriority = lBasePriority;
}

inline LONG
CQueue::GetBaseQueuePriority(void) const
{
    return m_lBasePriority;
}

inline void
CQueue::ClearRoutingRetry(void)
{
    m_dwRoutingRetry=0;
}

inline void
CQueue::IncRoutingRetry(void)
{
    m_dwRoutingRetry++;
}

inline DWORD
CQueue::GetRoutingRetry(void) const
{
    return m_dwRoutingRetry;
}

inline void
CQueue::SetHopCountFailure(BOOL flag)
{
    m_fHopCountFailure=flag;
}

inline BOOL
CQueue::IsHopCountFailure(void) const
{
    return(m_fHopCountFailure);
}

inline
QueueCounters*
CQueue::GetQueueCounters()
{
    return(m_pQueueCounters);
}

inline void
CQueue::UnknownQueueType(BOOL f)
{
    m_fUnknownQueueType = f;
}

inline BOOL
CQueue::IsUnkownQueueType() const
{
   return m_fUnknownQueueType; ;
}

inline BOOL
CQueue::QueueNotValid() const
{
   return m_fNotValid ;
}

inline const GUID*
CQueue::GetConnectorQM(void) const
{
    return m_pgConnectorQM;
}

inline
BOOL
CQueue::IsOnHold(
    void
    ) const
{
    return m_fOnHold;
}


class QUEUE_FORMAT_TRANSLATOR
{
public:
	QUEUE_FORMAT_TRANSLATOR(const QUEUE_FORMAT* pQueueFormat);

public:
	QUEUE_FORMAT* get()  
	{
		return &m_FormatName;
	}

	bool IsTranslated() const
	{
		return 	m_MemoryToDelete.get() != NULL;
	}


private:
	QUEUE_FORMAT  m_FormatName;	
	AP<WCHAR> m_MemoryToDelete;

private:
	QUEUE_FORMAT_TRANSLATOR& operator=(const QUEUE_FORMAT_TRANSLATOR&);
	QUEUE_FORMAT_TRANSLATOR(const QUEUE_FORMAT_TRANSLATOR&);
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\csecobj.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:  csecobj.h

Abstract: "SecureableObject" code, once in mqutil.dll.
    in MSMQ2.0 it's used only here, so I removed it from mqutil.
    This object holds the security descriptor of an object. This object is
    used for validating access rights for various operations on the various
    objects.

Author:

    Doron Juster  (DoronJ)

--*/
#include "mqaddef.h"

class CSecureableObject
{

public:
    CSecureableObject(AD_OBJECT eObject);
    HRESULT Store();
    HRESULT SetSD(SECURITY_INFORMATION, PSECURITY_DESCRIPTOR);
    HRESULT GetSD(SECURITY_INFORMATION, PSECURITY_DESCRIPTOR, DWORD, LPDWORD);
    HRESULT AccessCheck(DWORD dwDesiredAccess);
    const VOID *GetSDPtr() { return m_SD; };

private:
    DWORD AdObjectToMsmq1Object(void) const;

protected:
    PSECURITY_DESCRIPTOR m_SD;
    AD_OBJECT  m_eObject;
    BOOL  m_fImpersonate;

    virtual HRESULT GetObjectSecurity() = 0;
    virtual HRESULT SetObjectSecurity() = 0;
    HRESULT m_hr;
    LPWSTR  m_pwcsObjectName;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\crrthrd.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    crrthrd.cpp

Abstract:
    Handle threads pool for remote read

Author:
    Doron Juster  (DoronJ)

--*/

#include "stdh.h"
#include "crrthrd.h"
#include "cqmgr.h"

#include "crrthrd.tmh"

extern DWORD WINAPI RemoteReadThread(LPVOID pV) ;
extern DWORD g_dwOperatingSystem;

static WCHAR *s_FN=L"crrthrd";

CRRThreadsPool::CRRThreadsPool() : m_ThreadsCleanupTimer(ThreadsCleanup)
{
   m_iMaxNumofThreads = 0 ;
   m_iMinNumofThreads = 0 ;
   m_dwTimeToLive = 0 ;
   m_ppThreadDispathData = NULL ;
}


CRRThreadsPool::~CRRThreadsPool()
{
   if (m_ppThreadDispathData)
   {
      ASSERT(m_iMaxNumofThreads) ;

      for (int i = 0 ; i < m_iMaxNumofThreads ; i++ )
      {
         if (m_ppThreadDispathData[i])
         {
             if (m_ppThreadDispathData[i]->hEvent)
             {
                CloseHandle(m_ppThreadDispathData[i]->hEvent) ;
             }
             delete m_ppThreadDispathData[i] ;
         }
      }
      delete m_ppThreadDispathData ;
      m_ppThreadDispathData = NULL ;
   }
}

//+----------------------------------
//
//  void CRRThreadsPool::Init()
//
//+----------------------------------

void CRRThreadsPool::Init()
{
   DWORD dwMaxThrdDef = FALCON_DEFUALT_MAX_RRTHREADS_WKS ;
   DWORD dwMinThrdDef = FALCON_DEFUALT_MIN_RRTHREADS_WKS ;
   DWORD dwIdleTTLDef = FALCON_DEFAULT_RRTHREAD_TTL_WKS ;

   if (OS_SERVER(g_dwOperatingSystem))
   {
      dwMaxThrdDef = FALCON_DEFUALT_MAX_RRTHREADS_SRV ;
      dwMinThrdDef = FALCON_DEFUALT_MIN_RRTHREADS_SRV ;
      dwIdleTTLDef = FALCON_DEFAULT_RRTHREAD_TTL_SRV ;
   }

   READ_REG_DWORD(m_iMaxNumofThreads,
                  FALCON_MAX_RRTHREADS_REGNAME,
                  &dwMaxThrdDef ) ;

   READ_REG_DWORD(m_iMinNumofThreads,
                  FALCON_MIN_RRTHREADS_REGNAME,
                  &dwMinThrdDef ) ;

   READ_REG_DWORD(m_dwTimeToLive,
                  FALCON_RRTHREAD_TTL_REGNAME,
                  &dwIdleTTLDef ) ;


   m_ppThreadDispathData = new LPRRTHREADDISPATCHDATA[ m_iMaxNumofThreads ] ;
   memset( m_ppThreadDispathData,
           0,
           (m_iMaxNumofThreads * sizeof(LPRRTHREADDISPATCHDATA))) ;

   ExSetTimer(&m_ThreadsCleanupTimer, CTimeDuration::FromMilliSeconds(m_dwTimeToLive));
}

//+---------------------------------------------------------------------
//
//  void CRRThreadsPool::CleanupIdleThreads()
//
//  Periodically, cleanup idle threads that are not used anymore.
//
//+---------------------------------------------------------------------

void CRRThreadsPool::CleanupIdleThreads(void)
{
   CS lock(m_cs);

   DWORD dwPresentTime = GetTickCount() ;

   for ( int j = m_iMinNumofThreads ; j < m_iMaxNumofThreads ; j++ )
   {
       BOOL fFreeThread = FALSE ;

       if (m_ppThreadDispathData[j]         &&
           m_ppThreadDispathData[j]->hEvent &&
          !(m_ppThreadDispathData[j]->pRRThreadData))
       {
           DWORD dwThreadTime = m_ppThreadDispathData[j]->dwLastActiveTime ;

           if (dwThreadTime)
           {
               //
               // NULL dwThreadTime means that thread clean itself right
               // now, so don't disturb it.
               //
               if (dwPresentTime > (dwThreadTime + m_dwTimeToLive))
               {
                   fFreeThread = TRUE ;
               }
               else if (dwThreadTime > (dwPresentTime + m_dwTimeToLive))
               {
                   //
                   // Wrap around of the clock.
                   //
                   fFreeThread = TRUE ;
               }
           }

           if (fFreeThread)
           {
               m_ppThreadDispathData[j]->dwLastActiveTime = 0 ;
               BOOL f = SetEvent(m_ppThreadDispathData[j]->hEvent) ;
               ASSERT(f) ;
			   DBG_USED(f);
               m_ppThreadDispathData[j] = NULL ;
           }
       }
   }

   ExSetTimer(&m_ThreadsCleanupTimer, CTimeDuration::FromMilliSeconds(m_dwTimeToLive)) ;
}

//+-----------------------------------------------------------
//
//  void CRRThreadsPool::ThreadsCleanup(CTimer* pTimer)
//
//+-----------------------------------------------------------

void WINAPI
CRRThreadsPool::ThreadsCleanup(CTimer* pTimer)
{
    CRRThreadsPool* pThreadsTool =
       CONTAINING_RECORD(pTimer, CRRThreadsPool, m_ThreadsCleanupTimer);

    pThreadsTool->CleanupIdleThreads() ;
}

//+--------------------------------------------------------------------------
//
//  BOOL CRRThreadsPool::Dispatch(PVOID pRRThread)
//
//  Dispatch a request for remote read to an available thread. If threads
//  are not available, and threads pool is not full yet, create a new thread.
//
//+--------------------------------------------------------------------------

BOOL CRRThreadsPool::Dispatch(PVOID pRRThread)
{
   BOOL fThreadFound = FALSE ;
   BOOL fResult = TRUE ;

   CS lock(m_cs);

   if (!m_ppThreadDispathData)
   {
      Init() ;
   }

    //
    // First try to find an existing (and idle) thread that can server
    // present remote read request.
    //
    for (int j = 0 ; j < m_iMaxNumofThreads ; j++ )
    {
        if ( m_ppThreadDispathData[j]                   &&
             m_ppThreadDispathData[j]->hEvent           &&
           !(m_ppThreadDispathData[j]->pRRThreadData)   &&
            (m_ppThreadDispathData[j]->dwLastActiveTime != 0))
        {
            fThreadFound = TRUE ;
            m_ppThreadDispathData[j]->pRRThreadData = pRRThread ;
            fResult = SetEvent(m_ppThreadDispathData[j]->hEvent) ;
            break ;
        }
    }

    //
    // Try to create a thread (if threads pool not at its peak).
    //
   if (!fThreadFound)
   {
      fResult = FALSE ;
      for ( j = 0 ; j < m_iMaxNumofThreads ; j++ )
      {
         if (!m_ppThreadDispathData[j])
         {
            CAutoCloseHandle hEvent = CreateEvent( NULL,
                                                   FALSE,
                                                   FALSE,
                                                   NULL )  ;

            if (hEvent)
            {
               m_ppThreadDispathData[j] = new RRTHREADDISPATCHDATA ;
               m_ppThreadDispathData[j]->hEvent = hEvent ;
               m_ppThreadDispathData[j]->pRRThreadData = pRRThread ;
               m_ppThreadDispathData[j]->dwLastActiveTime = 0 ;
               hEvent = NULL ;

               DWORD dwID ;
               HANDLE hThread = ::CreateThread(
                                        NULL,
                                        0,
                                        RemoteReadThread,
                                        (LPVOID) m_ppThreadDispathData[j],
                                        0,
                                        &dwID ) ;
               ASSERT(hThread) ;
               if (hThread)
               {
                  CloseHandle(hThread) ;
                  fResult = TRUE ;
               }
               else
               {
                  CloseHandle(m_ppThreadDispathData[j]->hEvent) ;
                  delete m_ppThreadDispathData[j] ;
                  m_ppThreadDispathData[j] = NULL ;
               }
            }
            break ;
         }
      }
   }

    return LogBOOL(fResult, s_FN, 10);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\crrqmgr.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    crrqmgr.cpp

Abstract:
    Contain CQueueMgr methods which handle client side of remote-read.

Author:
    Doron Juster  (DoronJ)

--*/


#include "stdh.h"
#include "cqpriv.h"
#include "cqmgr.h"
#include "qmutil.h"
#include "ad.h"
#include <Fn.h>

#include "crrqmgr.tmh"

extern LPTSTR g_szMachineName;

static WCHAR *s_FN=L"crrqmgr";

const TraceIdEntry QmRrMgr = L"QM Remote Read Queue Manager";

extern CContextMap g_map_QM_cli_pQMQueue;

/*======================================================

Function:  CQueueMgr::CreateRRQueueObject()

Description: Create a CRRQueue object in client side of
             remote reader.

Arguments:

Return Value:

Thread Context:

History Change:

========================================================*/

HRESULT
CQueueMgr::CreateRRQueueObject(IN  const QUEUE_FORMAT* pQueueFormat,
                               OUT CRRQueue**          ppQueue
                             )
{
    QueueProps qp;
    HRESULT    rc;

    *ppQueue = NULL;

    //
    // Get Queue Properties. Name and QMId
    //
    rc = QmpGetQueueProperties(pQueueFormat,&qp, false);

    if (FAILED(rc))
    {
       DBGMSG((DBGMOD_QM, DBGLVL_ERROR,
                  _TEXT("CreateRRQueueObject failed, ntstatus %x"), rc));
       return LogHR(rc, s_FN, 10);
    }
    //
    //  Override the Netbios name if there is a DNS name
    //
    if (qp.lpwsQueueDnsName != NULL)
    {
        delete qp.lpwsQueuePathName;
        qp.lpwsQueuePathName = qp.lpwsQueueDnsName.detach();
    }

    //
    //  Cleanup
    //
    P<GUID> pClean = qp.pQMGuid;

    if (pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_PRIVATE)
    {
        if (qp.lpwsQueuePathName)
        {
            delete qp.lpwsQueuePathName ;
            qp.lpwsQueuePathName = NULL ;
            ASSERT(qp.lpwsQueueDnsName == NULL);
        }
        //
        // Create a dummy path name. It must start with machine name.
        // Get machine name from DS.
        //
        PROPID      aProp[2];
        PROPVARIANT aVar[2];
        rc = MQ_ERROR_NO_DS;

        aProp[0] = PROPID_QM_PATHNAME;
        aVar[0].vt = VT_NULL;
        aProp[1] = PROPID_QM_PATHNAME_DNS; // should be last
        aVar[1].vt = VT_NULL;

        if (CQueueMgr::CanAccessDS())
        {
            rc = ADGetObjectPropertiesGuid(
                        eMACHINE,
                        NULL,   // pwcsDomainController
						false,	// fServerName
                        qp.pQMGuid,
                        2,
                        aProp,
                        aVar
						);

            //
            //  MSMQ 1.0 DS server do not support PROPID_QM_PATHNAME_DNS
            //  and return MQ_ERROR in case of unsupported property.
            //  If such error is returned, assume MSMQ 1.0 DS and try again
            //  this time without PROPID_QM_PATHNAME_DNS.
            //
            if ( rc == MQ_ERROR)
            {
                aVar[1].vt = VT_EMPTY;
                ASSERT( aProp[1] == PROPID_QM_PATHNAME_DNS);

                rc = ADGetObjectPropertiesGuid(
							eMACHINE,
							NULL,    // pwcsDomainController
							false,	 // fServerName
							qp.pQMGuid,
							1,   // assuming DNS property is last
							aProp,
							aVar
							);
            }
            if (SUCCEEDED(rc))
            {
                GUID_STRING strUuid;
                MQpGuidToString(qp.pQMGuid, strUuid);

                WCHAR wszTmp[512];

                //
                //    use dns name of remote computer if we have it
                //
                if ( aVar[1].vt != VT_EMPTY)
                {
                    swprintf(wszTmp, L"%s\\%s\\%lu",
                                      aVar[1].pwszVal,
                                      strUuid,
                                      pQueueFormat->PrivateID().Uniquifier) ;
                    delete [] aVar[1].pwszVal;
                }
                else
                {
                    swprintf(wszTmp, L"%s\\%s\\%lu",
                                      aVar[0].pwszVal,
                                      strUuid,
                                      pQueueFormat->PrivateID().Uniquifier) ;
                }
                qp.lpwsQueuePathName = new WCHAR[ wcslen(wszTmp) + 1 ] ;
                wcscpy(qp.lpwsQueuePathName, wszTmp) ;
                delete  aVar[0].pwszVal ;
            }
        }
    }

    ASSERT(!qp.fIsLocalQueue) ;
    ASSERT(qp.lpwsQueuePathName) ;

    R<CRRQueue> pQueue = new CRRQueue( pQueueFormat,
                                       &qp ) ;
    //
    // Add a mapping of this instance to DWORD (cli_pQMQueue), and store it on the object for reference/cleanup
    //
    pQueue->m_dwcli_pQMQueueMapped =
       ADD_TO_CONTEXT_MAP(g_map_QM_cli_pQMQueue, pQueue.get(), s_FN, 100); //may throw a bad_alloc exception on win64

    *ppQueue = pQueue.detach();
    //
    // And add it to the map.
    //
    AddRRQueueToHashAndList(*ppQueue);
    return MQ_OK;
}

/*======================================================

Function:  HRESULT CQueueMgr::OpenRRQueue()

Description:

Arguments:

Return Value:

Thread Context:

History Change:

========================================================*/

HRESULT
CQueueMgr::OpenRRQueue(IN  const QUEUE_FORMAT* pQueueFormat,
                       IN  DWORD dwCallingProcessID,
                       IN  DWORD dwAccess,
                       IN  DWORD dwShareMode,
                       IN  ULONG srv_hACQueue,
                       IN  ULONG srv_pQMQueue,
                       IN  DWORD dwpContext,
                       OUT PHANDLE    phQueue,
                       OUT CRRQueue **ppQueue,
                       OUT PCTX_RRSESSION_HANDLE_TYPE *ppRRContext)
{
    //
    // It's essential that handle is null on entry, for cleanup in RT.
    //
    *ppQueue = NULL ;
    *ppRRContext = 0 ;
    ASSERT(*phQueue == NULL) ;

    CRRQueue*     pQueue = NULL;
    HRESULT       rc = MQ_OK;
    R<CRRQueue> Ref = NULL;

    {
        //
        // bug 507667.
        // Use the CQueueMgr lock only when touching the global list
        // of CRRQueue objects. Then call remote side outside of the lock.
        // Otherwise, queue manager can get to deadlock if remote side
        // fail to respond.
        //
        CS lock(m_cs);

        //
        // Check if the queue already exist. If exist, its ref count
        // is incremented by one.
        //
        BOOL fQueueExist = LookUpRRQueue(pQueueFormat, &pQueue);

        //
        // If first time the queue is opened than create queue object
        //
        if (!fQueueExist)
        {
            rc = CreateRRQueueObject(pQueueFormat,
                                     &pQueue) ;
            if (FAILED(rc))
            {
               return LogHR(rc, s_FN, 20);
            }
            ASSERT(pQueue->GetRef() == 2) ;
        }
        else
        {
            ASSERT(pQueue->GetRef() >= 2) ;
        }
    }

    Ref = pQueue ;

    //
    //  open Session with remote QM and create RPC context for this
    //  queue handle.
    //
    PCTX_RRSESSION_HANDLE_TYPE pRRContext = 0;
    rc = pQueue->OpenRRSession( srv_hACQueue,
                                srv_pQMQueue,
                                &pRRContext,
                                dwpContext) ;
    if(FAILED(rc))
    {
       DBGMSG((DBGMOD_QM, DBGLVL_ERROR,
                            TEXT("Canot Open RR Session %x"), rc));
       return LogHR(rc, s_FN, 30);
    }
    ASSERT(pRRContext != 0) ;

    //
    // In case on error, pQueue is released by the calling process.
    // BUGBUG BUT it is not removed from the hash table - leak - RAANAN,
    // Caller should call RemoveRRQueue, instead of Release.
    //
    Ref.detach();
    *ppQueue = pQueue ;
    *ppRRContext = pRRContext ;

    CRITICAL_SECTION* pCS = new CRITICAL_SECTION;
    BOOL rc1 = InitializeCriticalSectionAndSpinCount(pCS, CCriticalSection::xAllocateSpinCount);
    if (!rc1)
    {
        TrTRACE(QmRrMgr, "InitializeCriticalSectionAndSpinCount failed, error 0x%x", GetLastError());
        LogHR(rc1, s_FN, 95);
        throw std::bad_alloc();
    }

    //
    //  N.B. The queue handle created by ACCreateRemoteProxy is not held by
    //      the QM. **THIS IS NOT A LEAK**. The handle is held by the driver
    //      which call back with this handle to close the RR proxy queue when
    //      the application closes its handle.
    //
    HANDLE hQueue;
    rc = ACCreateRemoteProxy(
            pQueueFormat,
            pQueue->m_dwcli_pQMQueueMapped, //mapped pQueue instance, cli_pQMQueue
            srv_pQMQueue,
            srv_hACQueue,
            pRRContext,
            pCS,
            pQueue, //real pQueue instance, cli_pQMQueue2
            &hQueue
            );

    if (FAILED(rc))
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, TEXT("Make queue failed, ntstatus %x"), rc));
        return LogHR(rc, s_FN, 40);
    }
    ASSERT(hQueue);

    ASSERT(dwCallingProcessID) ;
    HANDLE hCallingProcess = OpenProcess(
                                PROCESS_DUP_HANDLE,
                                FALSE,
                                dwCallingProcessID
                                );
    if(hCallingProcess == 0)
    {
        ASSERT(("The calling proccess has shut down.", FALSE));
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR,
          _TEXT("Cannot open process in OpenRRQueue, error %d"), GetLastError()));
        return LogHR(MQ_ERROR_PRIVILEGE_NOT_HELD, s_FN, 50);
    }

    HANDLE hAcQueue;
    rc = ACCreateHandle(&hAcQueue);
    if(FAILED(rc))
    {
        CloseHandle(hCallingProcess);
        return LogHR(rc, s_FN, 60);
    }

    rc = ACAssociateQueue(
            hQueue,
            hAcQueue,
            dwAccess,
            dwShareMode,
            false
            );

    if(FAILED(rc))
    {
        CloseHandle(hCallingProcess);
        ACCloseHandle(hAcQueue);
        return LogHR(rc, s_FN, 70);
    }

    HANDLE hDupQueue;

    BOOL fSuccess;
    fSuccess = MQpDuplicateHandle(
                GetCurrentProcess(),
                hAcQueue,
                hCallingProcess,
                &hDupQueue,
                FILE_READ_ACCESS,
                TRUE,
                DUPLICATE_CLOSE_SOURCE
                );

    CloseHandle(hCallingProcess);
    if(!fSuccess)
    {
        ACCloseHandle(hAcQueue);
        return LogHR(MQ_ERROR_PRIVILEGE_NOT_HELD, s_FN, 80);
    }

    *ppQueue = NULL ;
    *phQueue = hDupQueue;

    return LogHR(rc, s_FN, 90);

}

/*======================================================

Function:       CQueueMgr::LookUpRRQueue

Description:    the rutine returnes the CQueue object that match the Queue Guid

Arguments:      pguidQueue - Queue Guid

Return Value:   pQueue - pointer to CQueue object
                TRUE if a queue was found for the guid, FALSE otherwse.

Thread Context:

History Change:

========================================================*/

BOOL
CQueueMgr::LookUpRRQueue(IN  const QUEUE_FORMAT* pQueueFormat,
                         OUT CRRQueue **         pQueue)
{
    CS lock(m_cs);

    QUEUE_ID QueueObject = {0};
    BOOL     fSucc = FALSE;

    *pQueue = NULL;                         // set default return value
    switch (pQueueFormat->GetType())
    {
        case QUEUE_FORMAT_TYPE_PRIVATE:
            QueueObject.pguidQueue = const_cast<GUID*>(&pQueueFormat->PrivateID().Lineage);
            QueueObject.dwPrivateQueueId = pQueueFormat->PrivateID().Uniquifier;
            fSucc = m_MapQueueId2RRQ.Lookup((const PQUEUE_ID)&QueueObject, *pQueue);
            break;

        case QUEUE_FORMAT_TYPE_PUBLIC:
            //
            // Public Queue
            //
            QueueObject.pguidQueue = const_cast<GUID*>(&pQueueFormat->PublicID());
            fSucc = m_MapQueueId2RRQ.Lookup(&QueueObject, *pQueue);
            break;

        case QUEUE_FORMAT_TYPE_MACHINE:
            //
            // Machine Queue
            //
            QueueObject.pguidQueue = const_cast<GUID*>(&pQueueFormat->MachineID());
            fSucc = m_MapQueueId2RRQ.Lookup(&QueueObject, *pQueue);
            break;

        case QUEUE_FORMAT_TYPE_DIRECT:
            //
            // Direct Queue
            //
            if (IsLocalDirectQueue(pQueueFormat, false))
            {
				try
				{
					AP<WCHAR> PathName;
					
					FnDirectIDToLocalPathName(
						pQueueFormat->DirectID(),
						g_szMachineName,
						PathName
						);

					fSucc = m_MapName2RRQ.Lookup(PathName.get(), *pQueue);
				}
				catch(const exception&)
				{
					LogIllegalPoint(s_FN, 92);
					return FALSE;
				}
            }
            else
            {
                AP<WCHAR> lpwcsQueuePathName = new WCHAR[wcslen(pQueueFormat->DirectID())+1];

                wcscpy(lpwcsQueuePathName,pQueueFormat->DirectID());
                CharLower(lpwcsQueuePathName);
                fSucc = m_MapName2RRQ.Lookup(lpwcsQueuePathName, *pQueue);
            }
            break;

        default:
            ASSERT(0);
            LogIllegalPoint(s_FN, 94);
            return NULL;
    }

    if (fSucc)
    {
        //
        // Increment the refernce count. It is the caller responsibility to decrement it.
        //
        (*pQueue)->AddRef();
    }
    return(fSucc);
}

/*======================================================

Function:      CQueueMgr::AddRRQueueToHash

Description:   Add Queue To Hash Table

Arguments:     pguidQueue - Guid of the Queue
               pQueue     - pointer to CQueue Object

Return Value:  None

Thread Context:

History Change:

========================================================*/

void
CQueueMgr::AddRRQueueToHashAndList(IN CRRQueue* pQueue)
{
    CS lock(m_cs);

	SafeAddRef(pQueue);

    //
    // Add queue to Active queue list
    //
    AddToActiveQueueList(pQueue);

    //
    // Add the queue to the map.
    //
    if (pQueue->GetQueueGuid() != NULL)
    {
        m_MapQueueId2RRQ[pQueue->GetQueueId()] = pQueue;
    }

    if (pQueue->GetQueueName() != NULL)
    {
        m_MapName2RRQ[pQueue->GetQueueName()] = pQueue;
    }
}

/*======================================================

Function:      CQueueMgr::RemoveRRQueue

Description:   Remove Queue form Hash Table and deconstruct

Arguments:     pguidQueue - Guid of the Queue
               pQueue     - pointer to CQueue Object

Return Value:  None

Thread Context:

History Change:

========================================================*/

void
CQueueMgr::RemoveRRQueue(IN CRRQueue* pQueue)
{
    ASSERT(pQueue != NULL);
    ASSERT(pQueue->GetRef() == 1);

    DBGMSG((DBGMOD_QM,
            DBGLVL_TRACE,
            _TEXT("Remove RR Queue %ls"), pQueue->GetQueueName()));

    //
    // Remove the queue from Id to Queue object map
    //
    if (pQueue->GetQueueGuid() != NULL)
    {
        m_MapQueueId2RRQ.RemoveKey(pQueue->GetQueueId());
    }

    //
    // Remove the queue from name to Queue object map
    //
    LPCTSTR  qName = pQueue->GetQueueName();
    if (qName != NULL)
    {
        m_MapName2RRQ.RemoveKey(qName);
    }
    pQueue->SetQueueName(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\crrthrd.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    crrthrd.h

Abstract:
    Handle threads pool for remote read

Author:
    Doron Juster  (DoronJ)

--*/

#ifndef  __CRRTHRD_H_
#define  __CRRTHRD_H_

#include <Ex.h>
#include "cancel.h"
#include "qmutil.h"

typedef struct  _RRTHREADDISPATCHDATA
{
   //
   // The event is used to wake up a thread. Each thread has its own event.
   //
   HANDLE hEvent ;

   //
   // This point to a data block which is used by a thread to perform the
   // remote read.
   //
   PVOID  pRRThreadData ;

   //
   // Record time of last activity. If thread is idle too long, we'll
   // delete it. Use GetTickCount() for this time.
   //
   DWORD  dwLastActiveTime ;
}
RRTHREADDISPATCHDATA,  *LPRRTHREADDISPATCHDATA ;

class CRRThreadsPool
{
   public:
     CRRThreadsPool() ;
     ~CRRThreadsPool() ;

     BOOL  Dispatch(PVOID pRRThread) ;
     void  CleanupIdleThreads(void) ;

     static void WINAPI ThreadsCleanup(CTimer* pTimer);

   private:
     void     Init() ;

     CCriticalSection    m_cs;

     //
     // timer for idle threads cleanup
     //
     CTimer m_ThreadsCleanupTimer;

     //
     // Maximum number of threads. read from registry.
     //
     int m_iMaxNumofThreads ;

     //
     // Minimum number of threads. read from registry. This number of threads
     // will always be kept alive, even if idle.
     //
     int m_iMinNumofThreads ;

     //
     // Time that a thread can live while idle. After that time,
     // it's terminated.
     //
     DWORD m_dwTimeToLive ;

     RRTHREADDISPATCHDATA **m_ppThreadDispathData ;
};


extern MQUTIL_EXPORT CCancelRpc g_CancelRpc;

/*====================================================

RegisterRRCallForCancel

Arguments:

Return Value:

  Register a remote read rpc call for cancel,
  if its duration is too long

=====================================================*/

inline  void RegisterRRCallForCancel( IN HANDLE *phThread,
                                      IN DWORD   dwRecvTimeout )
{
    *phThread =  GetHandleForRpcCancel() ;
    //
    //  Register the thread
    //
    TIME32 tPresentTime = DWORD_PTR_TO_DWORD(time(NULL)) ;
    TIME32  tTimeToWake = tPresentTime + (dwRecvTimeout / 1000) ;
    if ((dwRecvTimeout == INFINITE) || (tTimeToWake < tPresentTime))
    {
        //
        // Overflow
        // Note that time_t is a long, not unsigned. On the other hand
        // INFINITE is defined as 0xffffffff (i.e., -1). If we'll use
        // INFINITE here, then cancel routine,  CCancelRpc::CancelRequests(),
        // will cancel this call immediately.
        //
        tTimeToWake = MAXLONG ;
    }
    g_CancelRpc.Add( *phThread, tTimeToWake) ;
}


/*====================================================

UnregisterRRCallForCancel

Arguments:

Return Value:

=====================================================*/

inline  void UnregisterRRCallForCancel(IN HANDLE hThread)
{
    ASSERT( hThread != NULL);

    //
    //  unregister the thread
    //
    g_CancelRpc.Remove( hThread );
}

#endif //  __CRRTHRD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\csecobj.cpp ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:  csecobj.h

Abstract: "SecureableObject" code, once in mqutil.dll.
    in MSMQ2.0 it's used only here, so I removed it from mqutil.
    This object holds the security descriptor of an object. This object is
    used for validating access rights for various operations on the various
    objects.

Author:

    Doron Juster  (DoronJ)

--*/

#include "stdh.h"
#include "csecobj.h"
#include <mqsec.h>
#include "ad.h"

#include "csecobj.tmh"

static WCHAR *s_FN=L"csecobj";

// The default constructor of CSecureableObject just sets object type name for
// audits.
CSecureableObject::CSecureableObject(AD_OBJECT eObject)
{
    m_eObject = eObject;
    m_pwcsObjectName = NULL;
}

// Copy the security descriptor to a buffer.
HRESULT
CSecureableObject::GetSD(
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD nLength,
    LPDWORD lpnNeededLength)
{
    HRESULT hr;
    SECURITY_DESCRIPTOR sd;
    BOOL bRet;
    DWORD dwDesiredAccess;

    VERIFY_INIT_OK();

    dwDesiredAccess = READ_CONTROL;
    if (RequestedInformation & SACL_SECURITY_INFORMATION)
    {
        dwDesiredAccess |= ACCESS_SYSTEM_SECURITY;
    }

    hr = AccessCheck(dwDesiredAccess);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 10);
    }

    bRet = InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
    ASSERT(bRet);

    // use the  e_DoNotCopyControlBits for compatibility with old code.
    // That was the default behavior of old code.
    //
    MQSec_CopySecurityDescriptor( &sd,
                                   m_SD,
                                   RequestedInformation,
                                   e_DoNotCopyControlBits ) ;

    *lpnNeededLength = nLength;

    if (!MakeSelfRelativeSD(&sd, pSecurityDescriptor, lpnNeededLength))
    {
        DWORD gle = GetLastError();
        LogNTStatus(gle, s_FN, 20);
        ASSERT(gle == ERROR_INSUFFICIENT_BUFFER);
        return MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL;
    }

    ASSERT(IsValidSecurityDescriptor(pSecurityDescriptor));

    return (MQ_OK);
}

//+-------------------------------------------
//
//  CSecureableObject::SetSD()
//
//  Set (modify) the security descriptor.
//
//+-------------------------------------------

HRESULT
CSecureableObject::SetSD(
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptorIn)
{
    ASSERT(m_eObject == eQUEUE) ;

    BOOL bRet;

#ifdef _DEBUG
    SECURITY_DESCRIPTOR_CONTROL sdc;
    DWORD dwRevision;

    // Verify that the destination security descriptor answers to all
    // requirements.
    bRet = GetSecurityDescriptorControl(m_SD, &sdc, &dwRevision);
    ASSERT(bRet);
    ASSERT(dwRevision == SECURITY_DESCRIPTOR_REVISION);
    ASSERT(sdc & SE_SELF_RELATIVE);
#endif

    VERIFY_INIT_OK();

    DWORD dwDesiredAccess = 0;
    if (RequestedInformation & OWNER_SECURITY_INFORMATION)
    {
        dwDesiredAccess |= WRITE_OWNER;
    }

    if (RequestedInformation & DACL_SECURITY_INFORMATION)
    {
        dwDesiredAccess |= WRITE_DAC;
    }

    if (RequestedInformation & SACL_SECURITY_INFORMATION)
    {
        dwDesiredAccess |= ACCESS_SYSTEM_SECURITY;
    }

    HRESULT hr = AccessCheck(dwDesiredAccess);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 30);
    }

    //
    // Convert to NT4 format.
    //
    SECURITY_DESCRIPTOR *pSecurityDescriptor = NULL;
    P<SECURITY_DESCRIPTOR> pSD4;

    if (pSecurityDescriptorIn)
    {
        DWORD dwSD4Len = 0 ;
        hr = MQSec_ConvertSDToNT4Format(
					MQDS_QUEUE,
					(SECURITY_DESCRIPTOR*) pSecurityDescriptorIn,
					&dwSD4Len,
					&pSD4,
					RequestedInformation
					);
        ASSERT(SUCCEEDED(hr));
        LogHR(hr, s_FN, 198);

        if (SUCCEEDED(hr) && (hr != MQSec_I_SD_CONV_NOT_NEEDED))
        {
            pSecurityDescriptor = pSD4;
        }
        else
        {
            ASSERT(pSD4 == NULL);
            pSecurityDescriptor =
                             (SECURITY_DESCRIPTOR*) pSecurityDescriptorIn ;
        }
        ASSERT(pSecurityDescriptor &&
               IsValidSecurityDescriptor(pSecurityDescriptor));
    }

    AP<char> pDefaultSecurityDescriptor;
    hr = MQSec_GetDefaultSecDescriptor( 
				AdObjectToMsmq1Object(),
				(PSECURITY_DESCRIPTOR*) &pDefaultSecurityDescriptor,
				m_fImpersonate,
				pSecurityDescriptor,
				0,    // seInfoToRemove
				e_UseDefaultDacl 
				);
    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 40);
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }

	//
    // Temporarily convert the security descriptor to an absolute security
    // descriptor.
	//
	CAbsSecurityDsecripror AbsSecDsecripror;
	bool fSuccess = MQSec_MakeAbsoluteSD(
						m_SD,
						&AbsSecDsecripror
						);

	DBG_USED(fSuccess);
	ASSERT(fSuccess);

    //
    // Overwrite the information from the passed security descriptor.
    // use the  e_DoNotCopyControlBits for compatibility with old code.
    // That was the default behavior of old code.
    //
    MQSec_CopySecurityDescriptor(
                reinterpret_cast<PSECURITY_DESCRIPTOR>(AbsSecDsecripror.m_pObjAbsSecDescriptor.get()),
                (PSECURITY_DESCRIPTOR) pDefaultSecurityDescriptor,
                RequestedInformation,
                e_DoNotCopyControlBits 
				);

	//
    // Re-convert the security descriptor to a self relative security
    // descriptor.
	//
    DWORD dwSelfRelativeSecurityDescriptorLength = 0;
    MakeSelfRelativeSD(
        reinterpret_cast<PSECURITY_DESCRIPTOR>(AbsSecDsecripror.m_pObjAbsSecDescriptor.get()),
        NULL,
        &dwSelfRelativeSecurityDescriptorLength
		);

    ASSERT(GetLastError() == ERROR_INSUFFICIENT_BUFFER);

	//
    // Allocate the buffer for the new security descriptor.
	//
    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor =
        (PSECURITY_DESCRIPTOR) new char[dwSelfRelativeSecurityDescriptorLength];
    bRet = MakeSelfRelativeSD(
	                reinterpret_cast<PSECURITY_DESCRIPTOR>(AbsSecDsecripror.m_pObjAbsSecDescriptor.get()),
					pSelfRelativeSecurityDescriptor,
					&dwSelfRelativeSecurityDescriptorLength
					);
    ASSERT(bRet);

    // Free the previous security descriptor.
    delete[] (char*)m_SD;
    // Set the new security descriptor.
    m_SD =  pSelfRelativeSecurityDescriptor;

    return (MQ_OK);
}

// Store the security descriptor in the database.
HRESULT
CSecureableObject::Store()
{
    HRESULT hr;
#ifdef _DEBUG
    BOOL bRet;
    SECURITY_DESCRIPTOR_CONTROL sdc;
    DWORD dwRevision;

    // Verify that the destination security descriptor answers to all
    // requirements.
    bRet = GetSecurityDescriptorControl(m_SD, &sdc, &dwRevision);
    ASSERT(bRet);
    ASSERT(sdc & SE_SELF_RELATIVE);
#endif

    VERIFY_INIT_OK();

    hr = SetObjectSecurity();

    return LogHR(hr, s_FN, 50);
}

HRESULT
CSecureableObject::AccessCheck(DWORD dwDesiredAccess)
{
    //
    //  Access check should be performed only on queue,machine.
    //
    if ((m_eObject != eQUEUE) && (m_eObject != eMACHINE) &&
        (m_eObject != eSITE))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 60);
    }

    VERIFY_INIT_OK();

    HRESULT hr = MQSec_AccessCheck( (SECURITY_DESCRIPTOR*) m_SD,
                                    AdObjectToMsmq1Object(),
                                    m_pwcsObjectName,
                                    dwDesiredAccess,
                                    (LPVOID) this,
                                    m_fImpersonate,
                                    TRUE ) ;
    return LogHR(hr, s_FN, 70) ;
}

DWORD
CSecureableObject::AdObjectToMsmq1Object(void) const
{
    switch (m_eObject)
    {
    case eQUEUE:
        return MQDS_QUEUE;
        break;
    case eMACHINE:
        return MQDS_MACHINE;
        break;
    case eCOMPUTER:
        return MQDS_COMPUTER;
        break;
    case eUSER:
        return MQDS_USER;
        break;
    case eSITE:
        return MQDS_SITE;
        break;
    case eENTERPRISE:
        return MQDS_ENTERPRISE;
        break;
    default:
        ASSERT(0);
        return 0;
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\depclient.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    DepClient.cpp

Abstract:

    Server side support for MSMQ 1.0 and 2.0 dependent clients.

Author:

    Shai Kariv  (shaik)  15-May-2000

--*/

#include "stdh.h"

#include "ds.h"
#include "cqueue.h"
#include "cqmgr.h"
#include "_rstrct.h"
#include "qmds.h"
#include "cqpriv.h"
#include "qm2qm.h"
#include "qmrt.h"
#include "_mqini.h"
#include "_mqrpc.h"
#include "qmthrd.h"
#include "license.h"
#include "version.h"
#include <mqsec.h>

#include "DepClient.tmh"

extern CContextMap g_map_QM_dwQMContext;


static WCHAR *s_FN=L"DepClient";


//
// Declarations (definition is in qmcommnd.cpp)
//
HRESULT
OpenQueueInternal(
    QUEUE_FORMAT*   pQueueFormat,
    DWORD           dwCallingProcessID,
    DWORD           dwDesiredAccess,
    DWORD           dwShareMode,
    DWORD           hRemoteQueue,
    LPWSTR*         lplpRemoteQueueName,
    IN DWORD        *dwpRemoteQueue,
    HANDLE		    *phQueue,
    DWORD           dwpRemoteContext,
    OUT CQueue**    ppLocalQueue
    );


static
VOID
TransferBufferV1ToMsgProps(
    const CACTransferBufferV1 * ptb1,
    CACMessageProperties      * pMsgProps
    )
/*++

Routine Description:

    Maps MSMQ 1.0 transfer buffer to CACMessageProperties structure.

Arguments:

    ptb1      - Pointer to MSMQ 1.0 transfer buffer.

    pMsgProps - Pointer to message properties structure.

Returned Value:

    None.

--*/
{
    //
    // BUGBUG: Only TB2 needs mapping. (ShaiK, 26-May-2000)
    //

    pMsgProps->bAuthenticated   = ptb1->bAuthenticated;
    pMsgProps->bEncrypted       = ptb1->bEncrypted;
    pMsgProps->fDefaultProvider = ptb1->fDefaultProvider;
    pMsgProps->pAcknowledge     = ptb1->pAcknowledge;
    pMsgProps->pApplicationTag  = ptb1->pApplicationTag;
    pMsgProps->pArrivedTime     = ptb1->pArrivedTime;
    pMsgProps->pAuditing        = ptb1->pAuditing;
    pMsgProps->pAuthenticated   = ptb1->pAuthenticated;
    pMsgProps->pBodySize        = ptb1->pBodySize;
    pMsgProps->pClass           = ptb1->pClass;
    pMsgProps->pDelivery        = ptb1->pDelivery;
    pMsgProps->pMsgExtensionSize= ptb1->pMsgExtensionSize;
    pMsgProps->ppBody           = ptb1->ppBody;
    pMsgProps->ppConnectorType  = ptb1->ppConnectorType;
    pMsgProps->ppCorrelationID  = ptb1->ppCorrelationID;
    pMsgProps->ppMessageID      = ptb1->ppMessageID;
    pMsgProps->ppMsgExtension   = ptb1->ppMsgExtension;
    pMsgProps->pPriority        = ptb1->pPriority;
    pMsgProps->ppSenderCert     = ptb1->ppSenderCert;
    pMsgProps->ppSenderID       = ptb1->ppSenderID;
    pMsgProps->ppSignature      = ptb1->ppSignature;
    pMsgProps->pulSignatureSizeProp = ptb1->pulSignatureSizeProp;
    pMsgProps->ulSignatureSize  = ptb1->ulSignatureSize;
    pMsgProps->ppSrcQMID        = ptb1->ppSrcQMID;
    pMsgProps->ppSymmKeys       = ptb1->ppSymmKeys;
    pMsgProps->ppTitle          = ptb1->ppTitle;
    pMsgProps->ppwcsProvName    = ptb1->ppwcsProvName;
    pMsgProps->pSentTime        = ptb1->pSentTime;
    pMsgProps->pTrace           = ptb1->pTrace;
    pMsgProps->pulAuthProvNameLenProp = ptb1->pulAuthProvNameLenProp;
    pMsgProps->pulBodyType      = ptb1->pulBodyType;
    pMsgProps->pulEncryptAlg    = ptb1->pulEncryptAlg;
    pMsgProps->pulHashAlg       = ptb1->pulHashAlg;
    pMsgProps->pulPrivLevel     = ptb1->pulPrivLevel;
    pMsgProps->pulProvType      = ptb1->pulProvType;
    pMsgProps->pulRelativeTimeToLive = ptb1->pulRelativeTimeToLive;
    pMsgProps->pulRelativeTimeToQueue= ptb1->pulRelativeTimeToQueue;
    pMsgProps->pulSenderCertLenProp  = ptb1->pulSenderCertLenProp;
    pMsgProps->pulSenderIDLenProp= ptb1->pulSenderIDLenProp;
    pMsgProps->pulSenderIDType   = ptb1->pulSenderIDType;
    pMsgProps->pulSymmKeysSizeProp  = ptb1->pulSymmKeysSizeProp;
    pMsgProps->pulTitleBufferSizeInWCHARs = ptb1->pulTitleBufferSizeInWCHARs;
    pMsgProps->pulVersion        = ptb1->pulVersion;
    pMsgProps->pUow              = ptb1->pUow;
    pMsgProps->ulAbsoluteTimeToQueue = ptb1->ulAbsoluteTimeToQueue;
    pMsgProps->ulAllocBodyBufferInBytes = ptb1->ulAllocBodyBufferInBytes;
    pMsgProps->ulAuthLevel       = ptb1->ulAuthLevel;
    pMsgProps->ulBodyBufferSizeInBytes = ptb1->ulBodyBufferSizeInBytes;
    pMsgProps->ulMsgExtensionBufferInBytes = ptb1->ulMsgExtensionBufferInBytes;
    pMsgProps->ulProvNameLen     = ptb1->ulProvNameLen;
    pMsgProps->ulRelativeTimeToLive = ptb1->ulRelativeTimeToLive;
    pMsgProps->ulSenderCertLen   = ptb1->ulSenderCertLen;
    pMsgProps->ulSymmKeysSize    = ptb1->ulSymmKeysSize;
    pMsgProps->ulTitleBufferSizeInWCHARs = ptb1->ulTitleBufferSizeInWCHARs;
    pMsgProps->uSenderIDLen      = ptb1->uSenderIDLen;

    //
    // Properties in CACMessageProperties that are not included in
    // transfer buffer V1.0 should be initialized here (e.g. zeroed):
    //
    pMsgProps->pbFirstInXact = 0;
    pMsgProps->pbLastInXact  = 0;
    pMsgProps->ppXactID      = 0;

    pMsgProps->pLookupId     = 0;
    pMsgProps->ppSrmpEnvelope = NULL;
    pMsgProps->pSrmpEnvelopeBufferSizeInWCHARs = NULL;
    pMsgProps->ppCompoundMessage = NULL;
    pMsgProps->pCompoundMessageSizeInBytes = NULL;
    pMsgProps->CompoundMessageSizeInBytes = 0;

    pMsgProps->EodStreamIdSizeInBytes = 0;
    pMsgProps->pEodStreamIdSizeInBytes = NULL;
    pMsgProps->ppEodStreamId = NULL;
    pMsgProps->EodOrderQueueSizeInBytes = 0;
    pMsgProps->pEodOrderQueueSizeInBytes = NULL;
    pMsgProps->ppEodOrderQueue = NULL;

    pMsgProps->pEodAckSeqId = NULL;
    pMsgProps->pEodAckSeqNum = NULL;
    pMsgProps->EodAckStreamIdSizeInBytes = 0;
    pMsgProps->pEodAckStreamIdSizeInBytes = NULL;
    pMsgProps->ppEodAckStreamId = NULL;

} // TransferBufferV1ToMsgProps


static
VOID
TransferBufferV2ToMsgProps(
    const CACTransferBufferV2 * ptb2,
    CACMessageProperties      * pMsgProps
    )
/*++

Routine Description:

    Maps MSMQ 2.0 transfer buffer to CACMessageProperties structure.

Arguments:

    ptb2      - Pointer to MSMQ 2.0 transfer buffer.

    pMsgProps - Pointer to message properties structure.

Returned Value:

    None.

--*/
{
    //
    // First translate message properties that in transfer buffer 1.0
    //
    TransferBufferV1ToMsgProps(&ptb2->old, pMsgProps);

    //
    // Now translate additional properties that in transfer buffer 2.0
    //
    pMsgProps->pbFirstInXact    = ptb2->pbFirstInXact;
    pMsgProps->pbLastInXact     = ptb2->pbLastInXact;
    pMsgProps->ppXactID         = ptb2->ppXactID;

} // TransferBufferV2ToMsgProps


static
VOID
MsgPropsToTransferBufferV1(
    const CACMessageProperties & MsgProps,
    CACTransferBufferV1 *        ptb1
    )
/*++

Routine Description:

    Maps CACMessageProperties structure to MSMQ 1.0 transfer buffer

Arguments:

    MsgProps  - Message properties structure.

    ptb1      - Pointer to MSMQ 1.0 transfer buffer.

Returned Value:

    None.

--*/
{
    //
    // BUGBUG: Only TB2 needs mapping. (ShaiK, 26-May-2000)
    //

    ptb1->bAuthenticated    = MsgProps.bAuthenticated;
    ptb1->bEncrypted        = MsgProps.bEncrypted;
    ptb1->fDefaultProvider  = MsgProps.fDefaultProvider;
    ptb1->pAcknowledge      = MsgProps.pAcknowledge;
    ptb1->pApplicationTag   = MsgProps.pApplicationTag;
    ptb1->pArrivedTime      = MsgProps.pArrivedTime;
    ptb1->pAuditing         = MsgProps.pAuditing;
    ptb1->pAuthenticated    = MsgProps.pAuthenticated;
    ptb1->pBodySize         = MsgProps.pBodySize;
    ptb1->pClass            = MsgProps.pClass;
    ptb1->pDelivery         = MsgProps.pDelivery;
    ptb1->pMsgExtensionSize = MsgProps.pMsgExtensionSize;
    ptb1->ppBody            = MsgProps.ppBody;
    ptb1->ppConnectorType   = MsgProps.ppConnectorType;
    ptb1->ppCorrelationID   = MsgProps.ppCorrelationID;
    ptb1->ppMessageID       = MsgProps.ppMessageID;
    ptb1->ppMsgExtension    = MsgProps.ppMsgExtension;
    ptb1->pPriority         = MsgProps.pPriority;
    ptb1->ppSenderCert      = MsgProps.ppSenderCert;
    ptb1->ppSenderID        = MsgProps.ppSenderID;
    ptb1->ppSignature       = MsgProps.ppSignature;
    ptb1->pulSignatureSizeProp  = MsgProps.pulSignatureSizeProp;
    ptb1->ulSignatureSize       = MsgProps.ulSignatureSize;
    ptb1->ppSrcQMID         = MsgProps.ppSrcQMID;
    ptb1->ppSymmKeys        = MsgProps.ppSymmKeys;
    ptb1->ppTitle           = MsgProps.ppTitle;
    ptb1->ppwcsProvName     = MsgProps.ppwcsProvName;
    ptb1->pSentTime         = MsgProps.pSentTime;
    ptb1->pTrace            = MsgProps.pTrace;
    ptb1->pulAuthProvNameLenProp = MsgProps.pulAuthProvNameLenProp;
    ptb1->pulBodyType       = MsgProps.pulBodyType;
    ptb1->pulEncryptAlg     = MsgProps.pulEncryptAlg;
    ptb1->pulHashAlg        = MsgProps.pulHashAlg;
    ptb1->pulPrivLevel      = MsgProps.pulPrivLevel;
    ptb1->pulProvType       = MsgProps.pulProvType;
    ptb1->pulRelativeTimeToLive = MsgProps.pulRelativeTimeToLive;
    ptb1->pulRelativeTimeToQueue= MsgProps.pulRelativeTimeToQueue;
    ptb1->pulSenderCertLenProp  = MsgProps.pulSenderCertLenProp;
    ptb1->pulSenderIDLenProp    = MsgProps.pulSenderIDLenProp;
    ptb1->pulSenderIDType       = MsgProps.pulSenderIDType;
    ptb1->pulSymmKeysSizeProp   = MsgProps.pulSymmKeysSizeProp;
    ptb1->pulTitleBufferSizeInWCHARs = MsgProps.pulTitleBufferSizeInWCHARs;
    ptb1->pulVersion            = MsgProps.pulVersion;
    ptb1->pUow                  = MsgProps.pUow;
    ptb1->ulAbsoluteTimeToQueue = MsgProps.ulAbsoluteTimeToQueue;
    ptb1->ulAllocBodyBufferInBytes = MsgProps.ulAllocBodyBufferInBytes;
    ptb1->ulAuthLevel           = MsgProps.ulAuthLevel;
    ptb1->ulBodyBufferSizeInBytes  = MsgProps.ulBodyBufferSizeInBytes;
    ptb1->ulMsgExtensionBufferInBytes = MsgProps.ulMsgExtensionBufferInBytes;
    ptb1->ulProvNameLen         = MsgProps.ulProvNameLen;
    ptb1->ulRelativeTimeToLive  = MsgProps.ulRelativeTimeToLive;
    ptb1->ulSenderCertLen       = MsgProps.ulSenderCertLen;
    ptb1->ulSymmKeysSize        = MsgProps.ulSymmKeysSize;
    ptb1->ulTitleBufferSizeInWCHARs = MsgProps.ulTitleBufferSizeInWCHARs;
    ptb1->uSenderIDLen          = MsgProps.uSenderIDLen;

    //
    // Properties that are not included in transfer buffer 1.0 / 2.0
    //
    ASSERT(MsgProps.pLookupId == 0);
    ASSERT(MsgProps.ppSrmpEnvelope == NULL);
    ASSERT(MsgProps.pSrmpEnvelopeBufferSizeInWCHARs == NULL);
    ASSERT(MsgProps.ppCompoundMessage == NULL);
    ASSERT(MsgProps.pCompoundMessageSizeInBytes == NULL);
    ASSERT(MsgProps.CompoundMessageSizeInBytes == 0);
    ASSERT(MsgProps.EodStreamIdSizeInBytes == 0);
    ASSERT(MsgProps.pEodStreamIdSizeInBytes == NULL);
    ASSERT(MsgProps.ppEodStreamId == NULL);
    ASSERT(MsgProps.EodOrderQueueSizeInBytes == 0);
    ASSERT(MsgProps.pEodOrderQueueSizeInBytes == NULL);
    ASSERT(MsgProps.ppEodOrderQueue == NULL);
    ASSERT(MsgProps.pEodAckSeqId == NULL);
    ASSERT(MsgProps.pEodAckSeqNum == NULL);
    ASSERT(MsgProps.EodAckStreamIdSizeInBytes == 0);
    ASSERT(MsgProps.pEodAckStreamIdSizeInBytes == NULL);
    ASSERT(MsgProps.ppEodAckStreamId == NULL);

} // MsgPropsToTransferBufferV1


static
VOID
MsgPropsToTransferBufferV2(
    const CACMessageProperties & MsgProps,
    CACTransferBufferV2 *        ptb2
    )
/*++

Routine Description:

    Maps CACMessageProperties structure to MSMQ 2.0 transfer buffer

Arguments:

    MsgProps  - Message properties structure.

    ptb2      - Pointer to MSMQ 2.0 transfer buffer.

Returned Value:

    None.

--*/
{
    //
    // First translate message properties that in transfer buffer 1.0
    //
    MsgPropsToTransferBufferV1(MsgProps, &ptb2->old);

    //
    // Now translate additional properties that in transfer buffer 2.0
    //
    ptb2->pbFirstInXact         = MsgProps.pbFirstInXact;
    ptb2->pbLastInXact          = MsgProps.pbLastInXact;
    ptb2->ppXactID              = MsgProps.ppXactID;

} // MsgPropsToTransferBufferV2


static
VOID
TransferBufferV1ToSendParams(
    const CACTransferBufferV1 * ptb1,
    CACSendParameters         * pSendParams
    )
/*++

Routine Description:

    Maps MSMQ 1.0 transfer buffer to CACSendParameters structure.

Arguments:

    ptb1        - Pointer to MSMQ 1.0 transfer buffer.

    pSendParams - Pointer to send parameters structure.

Returned Value:

    None.

--*/
{
    //
    // BUGBUG: Only TB2 needs mapping. (ShaiK, 26-May-2000)
    //

    TransferBufferV1ToMsgProps(ptb1, &pSendParams->MsgProps);

    pSendParams->nAdminMqf = 0;
    pSendParams->nResponseMqf = 0;

    if (ptb1->Send.pAdminQueueFormat != NULL)
    {
        pSendParams->AdminMqf = ptb1->Send.pAdminQueueFormat;
        pSendParams->nAdminMqf = 1;
    }

    if (ptb1->Send.pResponseQueueFormat != NULL)
    {
        pSendParams->ResponseMqf = ptb1->Send.pResponseQueueFormat;
        pSendParams->nResponseMqf = 1;
    }

    //
    // Additional send parameters that are not in transfer buffer 1.0
    // should be initialized here (e.g. zeroed):
    //
    pSendParams->SignatureMqfSize = 0;
	pSendParams->ppSignatureMqf = NULL;

	pSendParams->ulXmldsigSize = 0;
	pSendParams->ppXmldsig = NULL;

    pSendParams->ppSoapHeader = NULL;
    pSendParams->ppSoapBody = NULL;

} // TransferBufferV1ToSendParams


static
VOID
TransferBufferV2ToSendParams(
    const CACTransferBufferV2 * ptb2,
    CACSendParameters         * pSendParams
    )
/*++

Routine Description:

    Maps MSMQ 2.0 transfer buffer to CACSendParameters structure.

Arguments:

    ptb2        - Pointer to MSMQ 2.0 transfer buffer.

    pSendParams - Pointer to send parameters structure.

Returned Value:

    None.

--*/
{
    //
    // First translate parameters that in transfer buffer 1.0
    //
    TransferBufferV1ToSendParams(&ptb2->old, pSendParams);

    //
    // Now translate additional send parameters that in transfer buffer 2.0.
    // Actually there are no additional send parameters in transfer buffer 2.0,
    // but rather message properties
    //
    TransferBufferV2ToMsgProps(ptb2, &pSendParams->MsgProps);

    //
    // Additional send parameters that are not in transfer buffer 2.0
    // should be initialized here (e.g. zeroed):
    //
    NULL;

} // TransferBufferV2ToSendParams


static
VOID
TransferBufferV1ToReceiveParams(
    const CACTransferBufferV1 * ptb1,
    CACReceiveParameters      * pReceiveParams
    )
/*++

Routine Description:

    Maps MSMQ 1.0 transfer buffer to CACReceiveParameters structure.

Arguments:

    ptb1           - Pointer to MSMQ 1.0 transfer buffer.

    pReceiveParams - Pointer to receive parameters structure.

Returned Value:

    None.

--*/
{
    //
    // BUGBUG: Only TB2 needs mapping. (ShaiK, 26-May-2000)
    //

    TransferBufferV1ToMsgProps(ptb1, &pReceiveParams->MsgProps);

#ifdef _WIN64
    pReceiveParams->Cursor         = ptb1->Receive.Cursor;
#else
    pReceiveParams->Cursor         = reinterpret_cast<HANDLE>(ptb1->Receive.Cursor);
#endif

    pReceiveParams->RequestTimeout = ptb1->Receive.RequestTimeout;
    pReceiveParams->Action         = ptb1->Receive.Action;
    pReceiveParams->Asynchronous   = ptb1->Receive.Asynchronous;

    pReceiveParams->ppDestFormatName             = ptb1->Receive.ppDestFormatName;
    pReceiveParams->pulDestFormatNameLenProp     = ptb1->Receive.pulDestFormatNameLenProp;

    pReceiveParams->ppAdminFormatName            = ptb1->Receive.ppAdminFormatName;
    pReceiveParams->pulAdminFormatNameLenProp    = ptb1->Receive.pulAdminFormatNameLenProp;

    pReceiveParams->ppResponseFormatName         = ptb1->Receive.ppResponseFormatName;
    pReceiveParams->pulResponseFormatNameLenProp = ptb1->Receive.pulResponseFormatNameLenProp;

    pReceiveParams->ppOrderingFormatName         = ptb1->Receive.ppOrderingFormatName;
    pReceiveParams->pulOrderingFormatNameLenProp = ptb1->Receive.pulOrderingFormatNameLenProp;

    //
    // Additional receive parameters that are not in transfer buffer 1.0
    // should be initialized here (e.g. zeroed):
    //

    pReceiveParams->ppDestMqf    = NULL;
    pReceiveParams->pulDestMqfLenProp = NULL;

    pReceiveParams->ppAdminMqf    = NULL;
    pReceiveParams->pulAdminMqfLenProp = NULL;

    pReceiveParams->ppResponseMqf    = NULL;
    pReceiveParams->pulResponseMqfLenProp = NULL;

	pReceiveParams->SignatureMqfSize = 0;
	pReceiveParams->ppSignatureMqf = NULL;
	pReceiveParams->pSignatureMqfSize = NULL;

    pReceiveParams->LookupId = 0;

} // TransferBufferV1ToReceiveParams


static
VOID
TransferBufferV2ToReceiveParams(
    const CACTransferBufferV2 * ptb2,
    CACReceiveParameters      * pReceiveParams
    )
/*++

Routine Description:

    Maps MSMQ 2.0 transfer buffer to CACReceiveParameters structure.

Arguments:

    ptb2           - Pointer to MSMQ 2.0 transfer buffer.

    pReceiveParams - Pointer to receive parameters structure.

Returned Value:

    None.

--*/
{
    //
    // First translate parameters that in transfer buffer 1.0
    //
    TransferBufferV1ToReceiveParams(&ptb2->old, pReceiveParams);

    //
    // Now translate additional recieve parameters that in transfer buffer 2.0.
    // Actually there are no additional receive parameters in transfer buffer 2.0,
    // but rather message properties
    //
    TransferBufferV2ToMsgProps(ptb2, &pReceiveParams->MsgProps);

} // TransferBufferV2ToReceiveParams


static
VOID
ReceiveParamsToTransferBufferV1(
    const CACReceiveParameters & ReceiveParams,
    CACTransferBufferV1 *        ptb1
    )
/*++

Routine Description:

    Maps CACReceiveParameters structure to MSMQ 1.0 transfer buffer.

Arguments:

    ReceiveParams  - Receive parameters structure.

    ptb1           - Pointer to MSMQ 1.0 transfer buffer.

Returned Value:

    None.

--*/
{
    //
    // BUGBUG: Only TB2 needs mapping. (ShaiK, 26-May-2000)
    //

    MsgPropsToTransferBufferV1(ReceiveParams.MsgProps, ptb1);

#ifdef _WIN64
    ptb1->Receive.Cursor         = ReceiveParams.Cursor;
#else
    ptb1->Receive.Cursor         = (ULONG)ReceiveParams.Cursor;
#endif

    ptb1->Receive.RequestTimeout = ReceiveParams.RequestTimeout;
    ptb1->Receive.Action         = ReceiveParams.Action;
    ptb1->Receive.Asynchronous   = ReceiveParams.Asynchronous;

    ptb1->Receive.ppDestFormatName    = ReceiveParams.ppDestFormatName;
    ptb1->Receive.pulDestFormatNameLenProp = ReceiveParams.pulDestFormatNameLenProp;

    ptb1->Receive.ppAdminFormatName    = ReceiveParams.ppAdminFormatName;
    ptb1->Receive.pulAdminFormatNameLenProp = ReceiveParams.pulAdminFormatNameLenProp;

    ptb1->Receive.ppResponseFormatName    = ReceiveParams.ppResponseFormatName;
    ptb1->Receive.pulResponseFormatNameLenProp = ReceiveParams.pulResponseFormatNameLenProp;

    ptb1->Receive.ppOrderingFormatName    = ReceiveParams.ppOrderingFormatName;
    ptb1->Receive.pulOrderingFormatNameLenProp = ReceiveParams.pulOrderingFormatNameLenProp;

    //
    // Properties that are not included in transfer buffer 1.0 / 2.0
    //
    ASSERT(ReceiveParams.LookupId == 0);
	ASSERT(ReceiveParams.SignatureMqfSize == 0);
	ASSERT(ReceiveParams.pSignatureMqfSize == NULL);
	ASSERT(ReceiveParams.ppSignatureMqf == NULL);

} // ReceiveParamsToTransferBufferV1


static
VOID
ReceiveParamsToTransferBufferV2(
    const CACReceiveParameters & ReceiveParams,
    CACTransferBufferV2 *        ptb2
    )
/*++

Routine Description:

    Maps CACReceiveParameters structure to MSMQ 2.0 transfer buffer.

Arguments:

    ReceiveParams  - Receive parameters structure.

    ptb2           - Pointer to MSMQ 2.0 transfer buffer.

Returned Value:

    None.

--*/
{
    //
    // First translate receive parameters that in transfer buffer 1.0
    //
    ReceiveParamsToTransferBufferV1(ReceiveParams, &ptb2->old);

    //
    // Now translate additional receive parameters that in transfer buffer 2.0.
    // Actually there are no additional receive parameters in transfer buffer 2.0,
    // but rather message properties.
    //
    MsgPropsToTransferBufferV2(ReceiveParams.MsgProps, ptb2);

} // ReceiveParamsToTransferBufferV2


//---------------------------------------------------------
//
//  RT interface to AC, done indirectly by RPC to QM (rather than
//  directly calling the driver).
//  For Win95 (all configurations) and NT dependent clients.
//
//---------------------------------------------------------

//
// This is the context for the RPC. Upon rundown (or normal call to
// CloseQueue), the queue handle is closed and the reference count of the
// license is decremented.
//
typedef struct _RPC_QUEUE_CONTEXT
{
   HANDLE   hQueue ;
   GUID     LicGuid ;
   DWORD    dwQMContextMapped;
}
RPC_QUEUE_CONTEXT ;

#define  _CONTEXT_TO_HANDLE(pContext) \
                    (((RPC_QUEUE_CONTEXT*)pContext)->hQueue)

#define  _CONTEXT_TO_LICENSE(pContext) \
                    (((RPC_QUEUE_CONTEXT*)pContext)->LicGuid)

#define  _CONTEXT_TO_QM_CONTEXT_MAPPED(pContext) \
                    (((RPC_QUEUE_CONTEXT*)pContext)->dwQMContextMapped)

HRESULT rpc_QMOpenQueueInternal(
    /* [in] */ handle_t                     hBind,
    /* [in] */ QUEUE_FORMAT*                pQueueFormat,
    /* [in] */ DWORD                        dwDesiredAccess,
    /* [in] */ DWORD                        dwShareMode,
    /* [in] */ DWORD                        hRemoteQueue,
    /* [out][in] */ LPWSTR __RPC_FAR       *lplpRemoteQueueName,
    /* [in] */  DWORD __RPC_FAR             *dwpQueue,
    /* [in] */  GUID*                       pLicGuid,
    /* [in] */  LPWSTR                      lpClientName,
    /* [out] */ DWORD __RPC_FAR             *pdwQMContext,
    /* [out] */ RPC_QUEUE_HANDLE __RPC_FAR  *phQueue,
    /* [in]  */ DWORD                       /*dwRemoteProtocol*/,
    /* [in]  */ DWORD                       dwpRemoteContext)
{

    if(pQueueFormat == NULL || !pQueueFormat->IsValid())
    {
         return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 177);
    }

    ASSERT(pQueueFormat->GetType() != QUEUE_FORMAT_TYPE_CONNECTOR);


    if (!IsDepClientsServer())
    {
        return LogHR(MQ_ERROR_WKS_CANT_SERVE_CLIENT, s_FN, 170);
    }

    if (!g_QMLicense.IsClientRPCAccessAllowed(pLicGuid, lpClientName, hBind))
    {
        return LogHR(MQ_ERROR_DEPEND_WKS_LICENSE_OVERFLOW, s_FN, 180);
    }

    HANDLE hQueueHandle = 0 ;
    HRESULT hr = OpenQueueInternal(
                        pQueueFormat,
                        GetCurrentProcessId(),
                        dwDesiredAccess,
                        dwShareMode,
                        hRemoteQueue,
                        lplpRemoteQueueName,
                        dwpQueue,
                        &hQueueHandle,
                        dwpRemoteContext,
                        NULL /* ppLocalQueue */
                        ) ;

    *phQueue = NULL ;
    DWORD dwQMContext = NULL;
    if (SUCCEEDED(hr))
    {
       if (hQueueHandle == 0)
       {
          // First call for remote-read open.
          ASSERT(lplpRemoteQueueName && (*lplpRemoteQueueName != NULL)) ;
       }
       else
       {
          P<RPC_QUEUE_CONTEXT> pContext =
                               (RPC_QUEUE_CONTEXT *) new RPC_QUEUE_CONTEXT ;
          memset(pContext, 0, sizeof(RPC_QUEUE_CONTEXT)) ;
          pContext->hQueue = hQueueHandle ;
          if (pLicGuid)
          {
             memcpy(&(pContext->LicGuid), pLicGuid, sizeof(GUID)) ;
          }
          dwQMContext = ADD_TO_CONTEXT_MAP(g_map_QM_dwQMContext, (RPC_QUEUE_CONTEXT *)pContext, s_FN, 390); //can throw a bad_alloc exception on win64

          pContext->dwQMContextMapped = dwQMContext;
          *phQueue = (RPC_QUEUE_HANDLE) pContext.detach() ;
       }
    }

    if (*phQueue == NULL)
    {
        //
        // Either Open operatoin failed or it is first call for
        // remote-read. Queue actually not opened.
        //
        g_QMLicense.DecrementActiveConnections(pLicGuid) ;
    }

    *pdwQMContext = dwQMContext ;
    return LogHR(hr, s_FN, 190);
}

HRESULT rpc_ACCloseHandle(/* [out][in] */ RPC_QUEUE_HANDLE __RPC_FAR *phQueue)
/*++

Routine Description:

    RPC server side of a dependent client call to ACCloseHandle.
    This routine handles dependent client 1.0 and 2.0 .

Arguments:

    phQueue - Pointer to queue handle.

Returned Value:

    Status.

--*/
{
    if(*phQueue == 0)
        return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 1941);

    HANDLE hQueue = _CONTEXT_TO_HANDLE(*phQueue) ;
    HRESULT rc = ACCloseHandle(hQueue);

    //
    // Decrement the license ref count.
    //
    g_QMLicense.DecrementActiveConnections(&(_CONTEXT_TO_LICENSE(*phQueue))) ;

    DELETE_FROM_CONTEXT_MAP(g_map_QM_dwQMContext, _CONTEXT_TO_QM_CONTEXT_MAPPED(*phQueue), s_FN, 380);
    //
    //  revoke rpc context handle
    //
    delete *phQueue ;
    *phQueue = 0;

    return LogHR(rc, s_FN, 195);

} // rpc_ACCloseHandle


HRESULT
rpc_ACCreateCursorEx(
    /* [in] */ RPC_QUEUE_HANDLE                       hQueue,
    /* [in][out] */ CACCreateRemoteCursor __RPC_FAR * pcc)
{
    if(pcc == 0)
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 1951);

    //
    // Construct parameters for creating local cursor
    //
    CACCreateLocalCursor cc;
    cc.cli_pQMQueue = pcc->cli_pQMQueue;
    cc.srv_hACQueue = pcc->srv_hACQueue;
#ifdef _WIN64
    cc.hCursor      = pcc->hCursor;
#else
    cc.hCursor      = reinterpret_cast<HANDLE>(pcc->hCursor);
#endif


    //
    // Call local AC driver
    //
    HRESULT hr2 = ACCreateCursor(_CONTEXT_TO_HANDLE(hQueue), cc);

    //
    // Convert parameters to remotable structure
    //
    pcc->cli_pQMQueue = cc.cli_pQMQueue;
    pcc->srv_hACQueue = cc.srv_hACQueue;
#ifdef _WIN64
    pcc->hCursor      = cc.hCursor;
#else
    pcc->hCursor      = reinterpret_cast<ULONG>(cc.hCursor);
#endif

    return LogHR(hr2, s_FN, 200);

} // rpc_ACCreateCursorEx


HRESULT
rpc_ACCreateCursor(
    /* [in] */ RPC_QUEUE_HANDLE                     hQueue,
    /* [in][out] */ CACTransferBufferV1 __RPC_FAR * ptb1)
{
    HRESULT hr2 = rpc_ACCreateCursorEx(hQueue, &ptb1->CreateCursor);
    return LogHR(hr2, s_FN, 210);

} // rpc_ACCreateCursor


HRESULT
rpc_ACCloseCursor(
    /* [in] */ RPC_QUEUE_HANDLE hQueue,
    /* [in] */ ULONG    hCursor
    )
{
    HRESULT hr2 = ACCloseCursor(_CONTEXT_TO_HANDLE(hQueue), (HACCursor32)hCursor);
    return LogHR(hr2, s_FN, 220);
}


HRESULT rpc_ACSetCursorProperties(
    /* [in] */ RPC_QUEUE_HANDLE hProxy,
    /* [in] */ ULONG hCursor,
    /* [in] */ ULONG hRemoteCursor
    )
{
    HRESULT hr2 = ACSetCursorProperties( _CONTEXT_TO_HANDLE(hProxy),
                                  (HACCursor32)hCursor,
                                  hRemoteCursor);
    return LogHR(hr2, s_FN, 230);
}


HRESULT
rpc_ACSendMessageEx(
    /* [in] */ RPC_QUEUE_HANDLE                  hQueue,
    /* [in] */ CACTransferBufferV2 __RPC_FAR *   ptb2,
    /* [in, out, unique] */ OBJECTID __RPC_FAR * pMessageID
    )
/*++

Routine Description:

    RPC server side of a dependent client call to ACSendMessageEx.
    This routine handles dependent client 2.0 .

Arguments:

    hQueue     - Queue handle.

    ptb2       - Pointer to transfer buffer of MSMQ 2.0.

    pMessageID - Pointer to message ID.

Returned Value:

    Status.

--*/
{
    if(ptb2 == 0)
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 2301);

    //
    // Convert MSMQ V2.0 transfer buffer to CACSendParameters structure
    //
    CACSendParameters SendParams;
    TransferBufferV2ToSendParams(ptb2, &SendParams);

	//
	//	Even though, on the client side pMessageID and
	//  *ptb2->old.ppMessageID point to the same buffer,
	//	RPC on the server side allocates different buffers.
	//
    if(pMessageID)
    {
        SendParams.MsgProps.ppMessageID = &pMessageID;
    }

    OVERLAPPED ov = {0};
    ov.hEvent = GetThreadEvent();

    HRESULT rc;
    rc = ACSendMessage(_CONTEXT_TO_HANDLE(hQueue), SendParams, &ov);

    if(rc == STATUS_PENDING)
    {
        //
        //  Wait for send completion
        //
        DWORD dwResult;
        dwResult = WaitForSingleObject(ov.hEvent, INFINITE);
        ASSERT(dwResult == WAIT_OBJECT_0);
        if (dwResult != WAIT_OBJECT_0)
        {
            LogNTStatus(GetLastError(), s_FN, 192);
        }

        rc = DWORD_PTR_TO_DWORD(ov.Internal);
    }
    return LogHR(rc, s_FN, 240);

} // rpc_ACSendMessageEx


HRESULT
rpc_ACSendMessage(
    /* [in] */ RPC_QUEUE_HANDLE                       hQueue,
    /* [in] */ struct CACTransferBufferV1 __RPC_FAR * ptb1,
    /* [in, out, unique] */ OBJECTID __RPC_FAR *      pMessageID
    )
/*++

Routine Description:

    RPC server side of a dependent client call to ACSendMessage.
    This routine handles dependent client 1.0 .

Arguments:

    hQueue - Queue handle.

    ptb1   - Pointer to transfer buffer of MSMQ 1.0.

    pMessageID - Pointer to message ID.

Returned Value:

    Status.

--*/
{
    if(ptb1 == 0)
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 2401);

    //
    // Convert MSMQ V1.0 transfer buffer to CACSendParameters structure
    //
    CACSendParameters SendParams;
    TransferBufferV1ToSendParams(ptb1, &SendParams);

	//
	//	Even though, on the client side pMessageID and
	//  *ptb1->ppMessageID point to the same buffer,
	//	RPC on the server side allocates different buffers.
	//
    if(pMessageID)
    {
        SendParams.MsgProps.ppMessageID = &pMessageID;
    }

    OVERLAPPED ov = {0};
    ov.hEvent = GetThreadEvent();

    HRESULT rc;
    rc = ACSendMessage(_CONTEXT_TO_HANDLE(hQueue), SendParams, &ov);

    if(rc == STATUS_PENDING)
    {
        //
        //  Wait for send completion
        //
        DWORD dwResult;
        dwResult = WaitForSingleObject(ov.hEvent, INFINITE);
        ASSERT(dwResult == WAIT_OBJECT_0);
        if (dwResult != WAIT_OBJECT_0)
        {
            LogNTStatus(GetLastError(), s_FN, 400);
        }

        rc = DWORD_PTR_TO_DWORD(ov.Internal);
    }
    return LogHR(rc, s_FN, 250);

} // rpc_ACSendMessage


HRESULT
rpc_ACReceiveMessageEx(
    /* [in] */ handle_t hBind,
    /* [in] */ DWORD hQMContext,
    /* [out][in] */ struct CACTransferBufferV2 __RPC_FAR * ptb2
    )
/*++

Routine Description:

    RPC server side of a dependent client call to ACReceiveMessageEx.
    This routine handles dependent client 2.0 .

Arguments:

    hBind      - Binding handle.

    hQMContext - Context handle.

    ptb2       - Pointer to transfer buffer of MSMQ 2.0.

Returned Value:

    Status.

--*/
{
    if(hQMContext == 0)
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 4001);

    if(ptb2 == 0)
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 4002);

    //
    // Convert MSMQ V2.0 transfer buffer to CACReceiveParameters structure
    //
    CACReceiveParameters ReceiveParams;
    TransferBufferV2ToReceiveParams(ptb2, &ReceiveParams);

    OVERLAPPED ov = {0};
    ov.hEvent = GetThreadEvent();

    HANDLE hQueue;
    HRESULT rc;

    __try
    {
        hQueue = (HANDLE) _CONTEXT_TO_HANDLE(GET_FROM_CONTEXT_MAP(g_map_QM_dwQMContext, hQMContext, s_FN, 370)); //may throw an exception on win64
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
      DWORD dwStatus = GetExceptionCode();
      LogNTStatus(dwStatus, s_FN, 260);

      return MQ_ERROR_INVALID_PARAMETER;
    }

    rc = ACReceiveMessage(hQueue, ReceiveParams, &ov);

    //
    // Convert CACReceiveParameters to MSMQ V2.0 transfer buffer
    //
    ReceiveParamsToTransferBufferV2(ReceiveParams, ptb2);

    if(rc == STATUS_PENDING)
    {
        //
        //  Wait for receive completion
        //
        DWORD dwResult;
        dwResult = WaitForSingleObject(ov.hEvent, INFINITE);
        ASSERT(dwResult == WAIT_OBJECT_0);
        if (dwResult != WAIT_OBJECT_0)
        {
            LogNTStatus(GetLastError(), s_FN, 193);
        }

        rc = DWORD_PTR_TO_DWORD(ov.Internal);
    }

    //
    //  Set correct string length to unmarshal correct
    //
    if(ptb2->old.Receive.ppResponseFormatName)
    {
        ptb2->old.Receive.ulResponseFormatNameLen = min(
            *ptb2->old.Receive.pulResponseFormatNameLenProp,
            ptb2->old.Receive.ulResponseFormatNameLen
            );
    }

    if(ptb2->old.Receive.ppAdminFormatName)
    {
        ptb2->old.Receive.ulAdminFormatNameLen = min(
            *ptb2->old.Receive.pulAdminFormatNameLenProp,
            ptb2->old.Receive.ulAdminFormatNameLen
            );
    }

    if(ptb2->old.Receive.ppDestFormatName)
    {
        ptb2->old.Receive.ulDestFormatNameLen = min(
            *ptb2->old.Receive.pulDestFormatNameLenProp,
            ptb2->old.Receive.ulDestFormatNameLen
            );
    }

    if(ptb2->old.Receive.ppOrderingFormatName)
    {
        ptb2->old.Receive.ulOrderingFormatNameLen = min(
            *ptb2->old.Receive.pulOrderingFormatNameLenProp,
            ptb2->old.Receive.ulOrderingFormatNameLen
            );
    }

    if(ptb2->old.ppTitle)
    {
        ptb2->old.ulTitleBufferSizeInWCHARs = min(
            *ptb2->old.pulTitleBufferSizeInWCHARs,
            ptb2->old.ulTitleBufferSizeInWCHARs
            );
    }

    return LogHR(rc, s_FN, 270);

} // rpc_ACReceiveMessageEx


HRESULT
rpc_ACReceiveMessage(
    /* [in] */ handle_t hBind,
    /* [in] */ DWORD hQMContext,
    /* [out][in] */ struct CACTransferBufferV1 __RPC_FAR * ptb1
    )
/*++

Routine Description:

    RPC server side of a dependent client call to ACReceiveMessage.
    This routine handles dependent client 1.0 .

Arguments:

    hBind      - Binding handle.

    hQMContext - Context handle.

    ptb1       - Pointer to transfer buffer of MSMQ 1.0.

Returned Value:

    Status.

--*/
{
    if(hQMContext == 0)
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 2701);

    if(ptb1 == 0)
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 2702);

    //
    // Convert MSMQ V1.0 transfer buffer to CACReceiveParameters structure
    //
    CACReceiveParameters ReceiveParams;
    TransferBufferV1ToReceiveParams(ptb1, &ReceiveParams);

    OVERLAPPED ov = {0};
    ov.hEvent = GetThreadEvent();

    HANDLE hQueue;
    HRESULT rc;

    __try
    {
        hQueue = (HANDLE) _CONTEXT_TO_HANDLE(GET_FROM_CONTEXT_MAP(g_map_QM_dwQMContext, hQMContext, s_FN, 372)); //may throw an exception on win64
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
      DWORD dwStatus = GetExceptionCode();
      LogNTStatus(dwStatus, s_FN, 410);

      return MQ_ERROR_INVALID_PARAMETER;
    }

    rc = ACReceiveMessage(hQueue, ReceiveParams, &ov);

    //
    // Convert CACReceiveParameters to MSMQ V1.0 transfer buffer
    //
    ReceiveParamsToTransferBufferV1(ReceiveParams, ptb1);

    if(rc == STATUS_PENDING)
    {
        //
        //  Wait for receive completion
        //
        DWORD dwResult;
        dwResult = WaitForSingleObject(ov.hEvent, INFINITE);
        ASSERT(dwResult == WAIT_OBJECT_0);
        if (dwResult != WAIT_OBJECT_0)
        {
            LogNTStatus(GetLastError(), s_FN, 420);
        }

        rc = DWORD_PTR_TO_DWORD(ov.Internal);
    }

    //
    //  Set correct string length to unmarshal correct
    //
    if(ptb1->Receive.ppResponseFormatName)
    {
        ptb1->Receive.ulResponseFormatNameLen = min(
            *ptb1->Receive.pulResponseFormatNameLenProp,
            ptb1->Receive.ulResponseFormatNameLen
            );
    }

    if(ptb1->Receive.ppAdminFormatName)
    {
        ptb1->Receive.ulAdminFormatNameLen = min(
            *ptb1->Receive.pulAdminFormatNameLenProp,
            ptb1->Receive.ulAdminFormatNameLen
            );
    }

    if(ptb1->Receive.ppDestFormatName)
    {
        ptb1->Receive.ulDestFormatNameLen = min(
            *ptb1->Receive.pulDestFormatNameLenProp,
            ptb1->Receive.ulDestFormatNameLen
            );
    }

    if(ptb1->Receive.ppOrderingFormatName)
    {
        ptb1->Receive.ulOrderingFormatNameLen = min(
            *ptb1->Receive.pulOrderingFormatNameLenProp,
            ptb1->Receive.ulOrderingFormatNameLen
            );
    }

    if(ptb1->ppTitle)
    {
        ptb1->ulTitleBufferSizeInWCHARs = min(
            *ptb1->pulTitleBufferSizeInWCHARs,
            ptb1->ulTitleBufferSizeInWCHARs
            );
    }

    return LogHR(rc, s_FN, 280);

} // rpc_ACReceiveMessage


HRESULT
rpc_ACHandleToFormatName(
    /* [in] */ RPC_QUEUE_HANDLE hQueue,
    /* [in] */ DWORD dwFormatNameRPCBufferLen,
    /* [size_is][out] */ LPWSTR lpwcsFormatName,
    /* [out][in] */ LPDWORD pdwLength
    )
{
    if ((dwFormatNameRPCBufferLen != 0) && (lpwcsFormatName == NULL))
    {
		TrERROR(GENERAL, "Received NULL buffer");
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 293);
    }

	memset(lpwcsFormatName, 0, dwFormatNameRPCBufferLen * sizeof(WCHAR));

    HRESULT hr2 = ACHandleToFormatName( _CONTEXT_TO_HANDLE(hQueue),
                                 lpwcsFormatName,
                                 pdwLength);
    return LogHR(hr2, s_FN, 290);
}

HRESULT rpc_ACPurgeQueue(
    /* [in] */ RPC_QUEUE_HANDLE hQueue)
{
    HRESULT hr2 = ACPurgeQueue(_CONTEXT_TO_HANDLE(hQueue));
    return LogHR(hr2, s_FN, 300);
}

void __RPC_USER RPC_QUEUE_HANDLE_rundown( RPC_QUEUE_HANDLE hQueue)
{
    DBGMSG((DBGMOD_QM, DBGLVL_WARNING,
            _TEXT("QUEUE_HANDLE_rundown: handle = 0x%p"),
                                     _CONTEXT_TO_HANDLE(hQueue))) ;
    rpc_ACCloseHandle(&hQueue);
}

//+-------------------------------------------------------------------------
//
//  HRESULT QMQueryQMRegistryInternal()
//
// This function is called by dependent clients to update the registry
// on the dependent machine. The dependent need the list of MSMQ DS servers
// because it query them directly, not through the supporting server.
//
//+-------------------------------------------------------------------------

HRESULT QMQueryQMRegistryInternal(
    /* [in] */ handle_t hBind,
    /* [in] */ DWORD    dwQueryType,
    /* [string][out] */ LPWSTR __RPC_FAR *lplpRegValue )
{
    ASSERT(lplpRegValue) ;
    *lplpRegValue = NULL ;

    switch (dwQueryType)
    {
       case  QueryRemoteQM_MQISServers:
       {
         //
         //  Read the list of servers from registry
         //
         WCHAR wszServers[ MAX_REG_DSSERVER_LEN ] ;
         DWORD dwSize = sizeof(wszServers) ;
         DWORD dwType = REG_SZ ;

         LONG res = GetFalconKeyValue( MSMQ_DS_SERVER_REGNAME,
                                       &dwType,
                                       wszServers,
                                       &dwSize ) ;

         ASSERT(res == ERROR_SUCCESS) ;

         if (res == ERROR_SUCCESS)
         {
            ASSERT(dwType == REG_SZ) ;
            ASSERT(dwSize < MAX_REG_DSSERVER_LEN) ;

            dwSize = wcslen(wszServers) ;
            *lplpRegValue = new WCHAR[ dwSize + 1 ] ;
            wcscpy(*lplpRegValue, wszServers) ;
            return MQ_OK ;
         }
         else
         {
            return LogHR(MQ_ERROR, s_FN, 310);
         }
       }

       case  QueryRemoteQM_LongLiveDefault:
       {
            DWORD dwVal ;
            DWORD dwDef = MSMQ_DEFAULT_LONG_LIVE ;
            READ_REG_DWORD(dwVal,
                           MSMQ_LONG_LIVE_REGNAME,
                           &dwDef ) ;
            *lplpRegValue = new WCHAR[ 24 ] ;
            swprintf(*lplpRegValue, L"%ld", (long) dwVal) ;
            return MQ_OK ;
       }

        case  QueryRemoteQM_EnterpriseGUID:
        {
            GUID guidEnterprise = McGetEnterpriseId();

            GUID_STRING strUuid;
            MQpGuidToString(&guidEnterprise, strUuid);

            *lplpRegValue = new WCHAR[ wcslen(strUuid) + 1 ] ;
            wcscpy(*lplpRegValue, strUuid) ;

            return MQ_OK ;
        }

       case QueryRemoteQM_QMVersion:
       {
          //
          // This is used by MSMQ2.0 dependent client to find the version of
          // its supporting server. if the dependent client get MQ_ERROR,
          // then it know the server is MSMQ1.0
          //
          WCHAR wszVersion[ 64 ] ;
          swprintf(wszVersion, L"%ld,%ld,%ld", rmj, rmm, rup) ;
          *lplpRegValue = new WCHAR[ wcslen(wszVersion) + 1 ] ;
          wcscpy(*lplpRegValue, wszVersion) ;

          return MQ_OK ;
       }

       case  QueryRemoteQM_ServerQmGUID:
       {
            GUID_STRING strUuid;
            MQpGuidToString(QueueMgr.GetQMGuid(), strUuid);

            *lplpRegValue = new WCHAR[wcslen(strUuid) + 1 ] ;
            wcscpy(*lplpRegValue, strUuid) ;

            return MQ_OK ;
       }

       default:
         ASSERT_BENIGN(("Bad dwQueryType value passed to QMQueryQMRegistryInternal RPC interface; safe to ignore.", 0));
         return LogHR(MQ_ERROR, s_FN, 320);
    }
} // QMQueryQMRegistryInternal


HRESULT
QMSendMessageInternalEx(
    /* [in] */ handle_t                     hBind,
    /* [in] */ QUEUE_FORMAT *               pQueueFormat,
    /* [in] */ struct CACTransferBufferV2 * ptb2,
	/* [in, out, unique] */ OBJECTID *	    pMessageID
    )
/*++

Routine Description:

    RPC server side of a dependent client call to QMSendMessageInternalEx.
    This routine handles dependent client 2.0 .

Arguments:

    hBind        - Binding handle.

    pQueueFormat - Pointer to queue format.

    ptb2         - Pointer to transfer buffer of MSMQ 2.0.

    pMessageID   - Pointer to the message ID.

Returned Value:

    Status.

--*/
{
    //
    // Dependent client 2.0 calls this routine when AC on supporting server
    // returns STATUS_RETRY in the send path. In MSMQ 3.0 AC does not return
    // STATUS_RETRY anymore and thus we do not expect this routine to be called.
    // (ShaiK, 30-May-2000)
    //
    ASSERT_BENIGN(("QMSendMessageInternalEx is an obsolete RPC interface; safe to ignore", 0));
    LogIllegalPoint(s_FN, 500);
    return MQ_ERROR_ILLEGAL_OPERATION;

} // QMSendMessageInternalEx


HRESULT
QMSendMessageInternal(
    /* [in] */ handle_t                     hBind,
    /* [in] */ QUEUE_FORMAT *               pQueueFormat,
    /* [in] */ struct CACTransferBufferV1 * ptb1
    )
/*++

Routine Description:

    RPC server side of a dependent client call to QMSendMessageInternal.
    This routine handles dependent client 1.0 .

Arguments:

    hBind        - Binding handle.

    pQueueFormat - Pointer to queue format.

    ptb1         - Pointer to transfer buffer of MSMQ 1.0.

Returned Value:

    Status.

--*/
{
    //
    // Dependent client 2.0 calls this routine when AC on supporting server
    // returns STATUS_RETRY in the send path. In MSMQ 3.0 AC does not return
    // STATUS_RETRY anymore and thus we do not expect this routine to be called.
    // (ShaiK, 30-May-2000)
    //
    ASSERT_BENIGN(("QMSendMessageInternal is an obsolete RPC interface; safe to ignore", 0));
    LogIllegalPoint(s_FN, 510);
    return MQ_ERROR_ILLEGAL_OPERATION;

} // QMSendMessageInternal
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\dumpauthzutl.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    DumpAuthzUtl.cpp

Abstract:

    Dump authz related information utilities.

Author:

    Ilan Herbst (ilanh) 14-Apr-2001

--*/

#include "stdh.h"
#include "Authz.h"
#include "sddl.h"
#include "cm.h"
#include "tr.h"
#include "mqexception.h"
#include "autoreln.h"
#include "mqsec.h"
#include "DumpAuthzUtl.h"

#include "DumpAuthzUtl.tmh"

static WCHAR *s_FN=L"DumpAuthzUtl";

const TraceIdEntry DumpAuthz = L"DUMP AUTHZ";


static
bool 
DumpAccessCheckFailure()
/*++

Routine Description:
    Read DumpAccessCheckFailure flag from registry

Arguments:
	None

Return Value:
	true if DumpAccessCheckFailure is set.
--*/
{
	//
	// Reading this registry only at first time.
	//
	static bool s_fInitialized = false;
	static bool s_fDumpAccessCheck = false;

	if(s_fInitialized)
	{
		return s_fDumpAccessCheck;
	}

	const RegEntry xRegEntry(TEXT("security"), TEXT("DumpAccessCheckFailure"), 0);
	DWORD DumpAccessCheckValue;
	CmQueryValue(xRegEntry, &DumpAccessCheckValue);

	s_fDumpAccessCheck = (DumpAccessCheckValue != 0);
	s_fInitialized = true;

	TrTRACE(DumpAuthz, "DumpAccessCheckFailure value = %d", DumpAccessCheckValue);

	return s_fDumpAccessCheck;
}


#define GET_PSID_FROM_PACE(pAce) (&((PACCESS_ALLOWED_ACE)pAce)->SidStart)
#define GET_ACE_MASK(pAce) (((PACCESS_DENIED_ACE)pAce)->Mask)
#define GET_ACE_TYPE(pAce) (((PACCESS_DENIED_ACE)pAce)->Header.AceType)


void 
IsPermissionGranted(
	PSECURITY_DESCRIPTOR pSD,
	DWORD Permission,
	bool* pfAllGranted, 
	bool* pfEveryoneGranted, 
	bool* pfAnonymousGranted 
	)
/*++

Routine Description:
	Check if we allow all (everyone + anonymous) a permission in
	a security descriptor.
	if there is no deny ace, also return if Everyone or Anonymous are
	explicitly grant the permissions.

Arguments:
	pSD - pointer to the security descriptor 
	Permission - requested permission.
	pfAllGranted - [out] flag that indicate if all grant the permissions.
	pfEveryoneGranted - [out] flag that indicate if Everyone explicitly grant the permissions.
	pfAnonymousGranted - [out] flag that indicate if Anonymous explicitly grant the permissions.

Returned Value:
	true if we allow all the permission, false otherwise
	
--*/
{
	ASSERT((pSD != NULL) && IsValidSecurityDescriptor(pSD));

	*pfAllGranted = false;
	*pfEveryoneGranted = false;
	*pfAnonymousGranted = false;

	//
    // get the DACL of the queue security descriptor.
	//
    BOOL bDaclPresent;
    PACL pDacl;
    BOOL bDaclDefaulted;
    if(!GetSecurityDescriptorDacl(
						pSD, 
						&bDaclPresent, 
						&pDacl, 
						&bDaclDefaulted
						))
	{
        DWORD gle = GetLastError();
		TrERROR(DumpAuthz, "GetSecurityDescriptorDacl() failed, gle = 0x%x", gle);
		LogBOOL(FALSE, s_FN, 20);
		return;
	}

	//
    // If there is no DACL, or it is NULL, access is granted for all.
	//
    if (!bDaclPresent || !pDacl)
    {
		TrTRACE(DumpAuthz, "no DACL, or NULL DACL, access is granted for all");
		*pfAllGranted = true;
		*pfEveryoneGranted = true;
		*pfAnonymousGranted = true;
		return;
    }

    ACL_SIZE_INFORMATION AclSizeInfo;
    if(!GetAclInformation(
					pDacl, 
					&AclSizeInfo, 
					sizeof(AclSizeInfo), 
					AclSizeInformation
					))
	{
        DWORD gle = GetLastError();
		TrERROR(DumpAuthz, "GetAclInformation() failed, gle = 0x%x", gle);
		LogBOOL(FALSE, s_FN, 40);
		return;
	}

	//
    // If the DACL is empty, deny access from all.
	//
    if (AclSizeInfo.AceCount == 0)
    {
		TrTRACE(DumpAuthz, "empty DACL, deny access from all");
		LogBOOL(FALSE, s_FN, 50);
		return;
    }

	bool fEveryoneGranted = false;
	bool fAnonymousGranted = false;
    for (DWORD i = 0; i < AclSizeInfo.AceCount; i++)
    {
		LPVOID pAce;

        GetAce(pDacl, i, &pAce);

        //
		// Ignore unknown ACEs
		//
        if (!(GET_ACE_TYPE(pAce) == ACCESS_ALLOWED_ACE_TYPE) &&
            !(GET_ACE_TYPE(pAce) == ACCESS_DENIED_ACE_TYPE))
        {
            continue;
        }

		//
        // See if we have the permission bit set in the ACE.
		//
        if (GET_ACE_MASK(pAce) & Permission)
        {
			if(GET_ACE_TYPE(pAce) == ACCESS_DENIED_ACE_TYPE)
			{
				//
				// Found a deny on the requested permission
				//
				TrTRACE(DumpAuthz, "found deny ACE");
				LogBOOL(FALSE, s_FN, 60);
				return;
			}

			ASSERT(GET_ACE_TYPE(pAce) == ACCESS_ALLOWED_ACE_TYPE);

            if(EqualSid(MQSec_GetWorldSid(), GET_PSID_FROM_PACE(pAce)))
			{
				fEveryoneGranted = true;
				TrTRACE(DumpAuthz, "Everyone allowed access");
				continue;
			}

            if(EqualSid(MQSec_GetAnonymousSid(), GET_PSID_FROM_PACE(pAce)))
			{
				TrTRACE(DumpAuthz, "Anonymous allowed access");
				fAnonymousGranted = true;
			}

		}

	}

	*pfEveryoneGranted = fEveryoneGranted;
	*pfAnonymousGranted = fAnonymousGranted;

	*pfAllGranted = (fEveryoneGranted && fAnonymousGranted);
}


static 
void 
PrintSid(
	PSID pSid
	)
/*++
Routine Description:
	Print text sid and user information.

Arguments:
	pSid - pointer to the sid

Returned Value:
	None

--*/
{

	//
	// string sid
	//
	LPWSTR pStringSid = NULL;
	if(!ConvertSidToStringSid(pSid, &pStringSid))
	{
        DWORD gle = GetLastError();
		TrERROR(DumpAuthz, "ConvertSidToStringSid failed, gle = 0x%x", gle);
		return;
	}

    CAutoLocalFreePtr pFreeSid = reinterpret_cast<BYTE*>(pStringSid);

	//
	// map sid to domain\user account
	//
    WCHAR NameBuffer[128];
    WCHAR DomainBuffer[128];
    ULONG NameLength = TABLE_SIZE(NameBuffer);
    ULONG DomainLength = TABLE_SIZE(DomainBuffer);
    SID_NAME_USE SidUse;
    if (!LookupAccountSid( 
			NULL,
			pSid,
			NameBuffer,
			&NameLength,
			DomainBuffer,
			&DomainLength,
			&SidUse
			))
    {
        DWORD gle = GetLastError();
		TrTRACE(DumpAuthz, "%ls", pStringSid);
		TrERROR(DumpAuthz, "LookupAccountSid failed, gle = 0x%x", gle);
		return;
    }

	if(DomainBuffer[0] == '\0')
	{
		TrTRACE(DumpAuthz, "%ls, %ls", pStringSid, NameBuffer);
		return;
	}

	TrTRACE(DumpAuthz, "%ls, %ls\\%ls", pStringSid, DomainBuffer, NameBuffer);

}


typedef struct _ACCESS_ALLOWED_OBJECT_ACE_1 {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    DWORD SidStart;
} ACCESS_ALLOWED_OBJECT_ACE_1 ;


static
void
PrintACEs(
	PACL pAcl
	)
/*++
Routine Description:
	Print list of ACEs

Arguments:
	pAcl - pointer to the ACL to be printed

Returned Value:
	None

--*/
{
	TrTRACE(DumpAuthz, "Revision: %d,  Numof ACEs: %d", pAcl->AclRevision, pAcl->AceCount);

    for (DWORD i = 0; i < pAcl->AceCount; i++)
    {
		ACCESS_ALLOWED_ACE* pAce;
        if(!GetAce(
				pAcl, 
				i, 
				(LPVOID*)&(pAce)
				))
        {
			DWORD gle = GetLastError();
			TrERROR(DumpAuthz, "GetAce() failed, gle = 0x%x", gle);
			throw bad_win32_error(gle);
        }

        DWORD AceType = pAce->Header.AceType;
		if((AceType > ACCESS_MAX_MS_OBJECT_ACE_TYPE) || 
		   (AceType == ACCESS_ALLOWED_COMPOUND_ACE_TYPE))
		{
			//
			// Handle only obj ACE and normal ACE.
			//
			TrTRACE(DumpAuthz, "ACE(%d), Unknown AceType %d", i, AceType);
			throw bad_win32_error(ERROR_INVALID_ACL);
		}

	    bool fObjAce = false;
		if((AceType >= ACCESS_MIN_MS_OBJECT_ACE_TYPE) && 
		   (AceType <= ACCESS_MAX_MS_OBJECT_ACE_TYPE))
		{
			fObjAce = true;
		}

		TrTRACE(DumpAuthz, "ACE(%d), AceType - %d, Mask- 0x%x", i, AceType, pAce->Mask);

		ACCESS_ALLOWED_OBJECT_ACE* pObjAce = reinterpret_cast<ACCESS_ALLOWED_OBJECT_ACE*>(pAce);

		PSID pSid = reinterpret_cast<PSID>(&(pAce->SidStart));
        if(fObjAce)
        {
			TrTRACE(DumpAuthz, "ObjFlags - 0x%x", pObjAce->Flags);

            if (pObjAce->Flags == ACE_OBJECT_TYPE_PRESENT)
            {
	            ACCESS_ALLOWED_OBJECT_ACE_1* pObjAce1 = reinterpret_cast<ACCESS_ALLOWED_OBJECT_ACE_1*>(pObjAce);
				pSid = reinterpret_cast<PSID>(&(pObjAce1->SidStart));
            }
        }

        if (pObjAce->Flags == ACE_OBJECT_TYPE_PRESENT)
        {
			TrTRACE(DumpAuthz, "ObjectType - %!guid!", &pObjAce->ObjectType);
        }

//		TrTRACE(DumpAuthz, "%!sid!", pSid);
		PrintSid(pSid);
    }
}


static
void
ShowOGandSID(
	PSID pSid, 
	BOOL fDefaulted
	)
/*++
Routine Description:
	Print owner\group and sid

Arguments:
	pSid - pointer to sid
	Defaulted - flag that indicate if defaulted

Returned Value:
	None

--*/
{
	if(fDefaulted)
	{
		TrTRACE(DumpAuthz, "Defaulted");
	}
	else
	{
		TrTRACE(DumpAuthz, "NotDefaulted");
	}

    if (!pSid)
    {
		TrTRACE(DumpAuthz, "Not available");
		return;
    }

//	TrTRACE(DumpAuthz, "%!sid!", pSid);
    PrintSid(pSid);
}


void
PrintAcl(
    BOOL fAclExist,
    BOOL fDefaulted,
    PACL pAcl
	)
/*++
Routine Description:
	Print Acl

Arguments:
	pSid - pointer to sid
	Defaulted - flag that indicate if defaulted

Returned Value:
	None

--*/
{
	if (!fAclExist)
    {
		TrTRACE(DumpAuthz, "NotPresent");
		return;
    }

	if(fDefaulted)
	{
		TrTRACE(DumpAuthz, "Defaulted");
	}
	else
	{
		TrTRACE(DumpAuthz, "NotDefaulted");
	}

	if (pAcl == NULL)
    {
		TrTRACE(DumpAuthz, "NULL");
		return;
	}

    PrintACEs(pAcl);
}


static
void  
ShowNT5SecurityDescriptor( 
	PSECURITY_DESCRIPTOR pSD
	)
/*++
Routine Description:
	Print Security descriptor

Arguments:
	pSD - pointer to security descriptor

Returned Value:
	None

--*/
{
	ASSERT((pSD != NULL) && IsValidSecurityDescriptor(pSD));
	if((pSD == NULL) || !IsValidSecurityDescriptor(pSD))
	{
		TrERROR(DumpAuthz, "invalid security descriptor or NULL security descriptor");
		throw bad_win32_error(ERROR_INVALID_SECURITY_DESCR);
	}

    DWORD dwRevision = 0;
    SECURITY_DESCRIPTOR_CONTROL sdC;
    if(!GetSecurityDescriptorControl(pSD, &sdC, &dwRevision))
	{
		DWORD gle = GetLastError();
		TrERROR(DumpAuthz, "GetSecurityDescriptorControl() failed, gle = 0x%x", gle);
		throw bad_win32_error(gle);
	}
	
	TrTRACE(DumpAuthz, "SecurityDescriptor");
	TrTRACE(DumpAuthz, "Control - 0x%x, Revision - %d", (DWORD) sdC, dwRevision);

	//
	// Owner
	//
    PSID  pSid;
    BOOL  Defaulted = FALSE;
    if (!GetSecurityDescriptorOwner(pSD, &pSid, &Defaulted))
    {
		DWORD gle = GetLastError();
		TrERROR(DumpAuthz, "GetSecurityDescriptorOwner() failed, gle = 0x%x", gle);
		throw bad_win32_error(gle);
    }

	TrTRACE(DumpAuthz, "Owner information:");
    ShowOGandSID(pSid, Defaulted);

	//
	// Group
	//
    if (!GetSecurityDescriptorGroup(pSD, &pSid, &Defaulted))
    {
		DWORD gle = GetLastError();
		TrERROR(DumpAuthz, "GetSecurityDescriptorGroup() failed, gle = 0x%x", gle);
		throw bad_win32_error(gle);
    }

	TrTRACE(DumpAuthz, "Group information:");
    ShowOGandSID(pSid, Defaulted);


	//
	// DACL
	//
    BOOL fAclExist;
    PACL pAcl;
    if (!GetSecurityDescriptorDacl(pSD, &fAclExist, &pAcl, &Defaulted))
    {
		DWORD gle = GetLastError();
		TrERROR(DumpAuthz, "GetSecurityDescriptorDacl() failed, gle = 0x%x", gle);
		throw bad_win32_error(gle);
    }

	TrTRACE(DumpAuthz, "DACL information:");
	PrintAcl(fAclExist, Defaulted, pAcl); 

	//
	// SACL
	//
    if (!GetSecurityDescriptorSacl(pSD, &fAclExist, &pAcl, &Defaulted))
    {
		DWORD gle = GetLastError();
		TrERROR(DumpAuthz, "GetSecurityDescriptorSacl() failed, gle = 0x%x", gle);
		throw bad_win32_error(gle);
    }

	TrTRACE(DumpAuthz, "SACL information:");
	PrintAcl(fAclExist, Defaulted, pAcl); 
}


static
void
GetClientContextInfo(
	AUTHZ_CLIENT_CONTEXT_HANDLE ClientContext
	)
/*++

Routine Description:
	Get Client context info.

Arguments:
	AuthzClientContext - client context

Returned Value:
	None
	
--*/
{
	//
	// UserSid
	//
	DWORD BufferSize = 0;

	AuthzGetInformationFromContext(
		  ClientContext,
		  AuthzContextInfoUserSid,
		  0,
		  &BufferSize,
		  NULL
		  );

	AP<BYTE> pToken = new BYTE[BufferSize];
	if(!AuthzGetInformationFromContext(
			  ClientContext,
			  AuthzContextInfoUserSid,
			  BufferSize,
			  &BufferSize,
			  pToken
			  ))
	{
		DWORD gle = GetLastError();
		TrERROR(DumpAuthz, "AuthzGetContextInformation(AuthzContextInfoUserSid)  failed, gle = 0x%x", gle);
		throw bad_win32_error(gle);
	}

	TrTRACE(DumpAuthz, "AuthzContextInfoUserSid");
    PSID pSid = (PSID) (((TOKEN_USER*) pToken.get())->User.Sid);
//	TrTRACE(DumpAuthz, "%!sid!", pSid);
	PrintSid(pSid);

	//
	// GroupsSids
	//
	AuthzGetInformationFromContext(
		  ClientContext,
		  AuthzContextInfoGroupsSids,
		  0,
		  &BufferSize,
		  NULL
		  );

	AP<BYTE> pTokenGroup = new BYTE[BufferSize];
	if(!AuthzGetInformationFromContext(
			  ClientContext,
			  AuthzContextInfoGroupsSids,
			  BufferSize,
			  &BufferSize,
			  pTokenGroup
			  ))
	{
		DWORD gle = GetLastError();
		TrERROR(DumpAuthz, "AuthzGetContextInformation(AuthzContextInfoGroupsSids)  failed, gle = 0x%x", gle);
		throw bad_win32_error(gle);
	}

	DWORD GroupCount = (((TOKEN_GROUPS*) pTokenGroup.get())->GroupCount);
	TrTRACE(DumpAuthz, "AuthzContextInfoGroupsSids, GroupCount = %d", GroupCount);

	for(DWORD i=0; i < GroupCount; i++)
	{
		PSID pSid = (PSID) (((TOKEN_GROUPS*) pTokenGroup.get())->Groups[i].Sid);
		TrTRACE(DumpAuthz, "Group %d: ", i);
//		TrTRACE(DumpAuthz, "%!sid!", pSid);
		PrintSid(pSid);
	}
	
	//
	// RestrictedSids
	//
	AuthzGetInformationFromContext(
		  ClientContext,
		  AuthzContextInfoRestrictedSids,
		  0,
		  &BufferSize,
		  NULL
		  );

	AP<BYTE> pRestrictedSids = new BYTE[BufferSize];
	if(!AuthzGetInformationFromContext(
			  ClientContext,
			  AuthzContextInfoRestrictedSids,
			  BufferSize,
			  &BufferSize,
			  pRestrictedSids
			  ))
	{
		DWORD gle = GetLastError();
		TrERROR(DumpAuthz, "AuthzGetContextInformation(AuthzContextInfoRestrictedSids)  failed, gle = 0x%x", gle);
		throw bad_win32_error(gle);
	}

	GroupCount = (((TOKEN_GROUPS*) pRestrictedSids.get())->GroupCount);
	TrTRACE(DumpAuthz, "AuthzContextInfoRestrictedSids, GroupCount = %d", GroupCount);

	for(DWORD i=0; i < GroupCount; i++)
	{
		PSID pSid = (PSID) (((TOKEN_GROUPS*) pRestrictedSids.get())->Groups[i].Sid);
		TrTRACE(DumpAuthz, "Group %d: ", i);
//		TrTRACE(DumpAuthz, "%!sid!", pSid);
		PrintSid(pSid);
	}
}


bool
IsAllGranted(
	DWORD permissions,
	PSECURITY_DESCRIPTOR pSD
	)
/*++

Routine Description:
	Checks if all granted permission.

Arguments:
	permissions - requested permissions.
	pSD - security descriptor.

Returned Value:
	true if all grant the permission.
	
--*/
{
	bool fAllGranted = false;
	bool fEveryoneGranted = false;
	bool fAnonymousGranted = false;

	IsPermissionGranted(
		pSD, 
		MQSEC_WRITE_MESSAGE,
		&fAllGranted, 
		&fEveryoneGranted, 
		&fAnonymousGranted 
		);

	TrTRACE(DumpAuthz, "IsAllGranted = %d", fAllGranted);
	return fAllGranted;
}


bool
IsEveryoneGranted(
	DWORD permissions,
	PSECURITY_DESCRIPTOR pSD
	)
/*++

Routine Description:
	Checks if everyone granted permission.

Arguments:
	permissions - requested permissions.
	pSD - security descriptor.

Returned Value:
	true if everyone grant the permission.
	
--*/
{
	bool fAllGranted = false;
	bool fEveryoneGranted = false;
	bool fAnonymousGranted = false;

	IsPermissionGranted(
		pSD, 
		MQSEC_WRITE_MESSAGE,
		&fAllGranted, 
		&fEveryoneGranted, 
		&fAnonymousGranted 
		);

	TrTRACE(DumpAuthz, "IsEveryoneGranted = %d", fEveryoneGranted);
	return fEveryoneGranted;
}


void
DumpAccessCheckFailureInfo(
	DWORD permissions,
	PSECURITY_DESCRIPTOR pSD,
	AUTHZ_CLIENT_CONTEXT_HANDLE ClientContext
	)
/*++

Routine Description:
	DumpAccessCheckFailureInfo if registry DumpAccessCheckFailure
	is set.

Arguments:
	permissions - requested permissions.
	pSD - security descriptor.
	ClientContext - authz client context handle

Returned Value:
	None
	
--*/
{
	if(DumpAccessCheckFailure())
	{
		TrTRACE(DumpAuthz, "requested permission = 0x%x", permissions);

		try
		{
			GetClientContextInfo(ClientContext);
			ShowNT5SecurityDescriptor(pSD);
		}
		catch(bad_win32_error& exp)
		{
			TrERROR(DumpAuthz, "catch bad_win32_error exception, error = 0x%x", exp.error());
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\dumpauthzutl.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    DumpAuthzUtl.h

Abstract:

    Dump authz related information utilities.

Author:

    Ilan Herbst (ilanh) 14-Apr-2001

--*/

#ifndef _DUMPAUTHZUTL_H_
#define _DUMPAUTHZUTL_H_


void
PrintAcl(
    BOOL fAclExist,
    BOOL fDefaulted,
    PACL pAcl
	);


void 
IsPermissionGranted(
	PSECURITY_DESCRIPTOR pSD,
	DWORD Permission,
	bool* pfAllGranted, 
	bool* pfEveryoneGranted, 
	bool* pfAnonymousGranted 
	);


bool
IsAllGranted(
	DWORD permissions,
	PSECURITY_DESCRIPTOR pSD
	);


bool
IsEveryoneGranted(
	DWORD permissions,
	PSECURITY_DESCRIPTOR pSD
	);


void
DumpAccessCheckFailureInfo(
	DWORD permissions,
	PSECURITY_DESCRIPTOR pSD,
	AUTHZ_CLIENT_CONTEXT_HANDLE ClientContext
	);


#endif // _DUMPAUTHZUTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\heap.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company and Microsoft
 * Corporation make no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without express or
 * implied warranty.
 *
 */

#ifndef HEAP_H
#define HEAP_H

template <class RandomAccessIterator, class Distance, class T>
void __push_heap(RandomAccessIterator first, Distance holeIndex,
		 Distance topIndex, T value) {
    Distance parent = (holeIndex - 1) / 2;
    while (holeIndex > topIndex && *(first + parent) < value) {
	*(first + holeIndex) = *(first + parent);
	holeIndex = parent;
	parent = (holeIndex - 1) / 2;
    }
    *(first + holeIndex) = value;
}

#if 0
template <class RandomAccessIterator, class T, class Distance>
inline void __push_heap_aux(RandomAccessIterator first,
			    RandomAccessIterator last, T*, Distance) {
    __push_heap(first, (Distance)((last - first) - 1), (Distance)(0), T(*(last - 1)));
}
#else //!0
template <class RandomAccessIterator, class T>
inline void __push_heap_aux(RandomAccessIterator first,
			    RandomAccessIterator last, T*) {
    __push_heap(first, (last - first) - 1, first - first /* 0 cast to Distance */, T(*(last - 1)));
}
#endif //0

template <class RandomAccessIterator>
inline void push_heap(RandomAccessIterator first, RandomAccessIterator last) {
#if 0
    __push_heap_aux(first, last, value_type(first), /*dummy, just for ptrdiff*/ last - first);
#else //!0
    __push_heap_aux(first, last, value_type(first));
#endif //0
}

template <class RandomAccessIterator, class Distance, class T, class Compare>
void __push_heap(RandomAccessIterator first, Distance holeIndex,
		 Distance topIndex, T value, Compare comp) {
    Distance parent = (holeIndex - 1) / 2;
    while (holeIndex > topIndex && comp(*(first + parent), value)) {
	*(first + holeIndex) = *(first + parent);
	holeIndex = parent;
	parent = (holeIndex - 1) / 2;
    }
    *(first + holeIndex) = value;
}

#if 0
template <class RandomAccessIterator, class Compare,  class T,  class Distance>
inline void __push_heap_aux(RandomAccessIterator first,
			    RandomAccessIterator last, Compare comp, T*, Distance) {
    __push_heap(first, (Distance)((last - first) - 1), (Distance)(0), T(*(last - 1)), comp);
}
#else //!0
template <class RandomAccessIterator, class Compare,  class T>
inline void __push_heap_aux(RandomAccessIterator first,
			    RandomAccessIterator last, Compare comp, T*) {
    __push_heap(first, (last - first) - 1, first - first /* 0 cast to Distance */, T(*(last - 1)), comp);
}
#endif //0

template <class RandomAccessIterator, class Compare>
inline void push_heap(RandomAccessIterator first, RandomAccessIterator last,
		      Compare comp) {
#if 0
    __push_heap_aux(first, last, comp, value_type(first), /*dummy, just for ptrdiff*/ last - first);
#else //!0
    __push_heap_aux(first, last, comp, value_type(first));
#endif //0
}

template <class RandomAccessIterator, class Distance, class T>
void __adjust_heap(RandomAccessIterator first, Distance holeIndex,
		   Distance len, T value) {
    Distance topIndex = holeIndex;
    Distance secondChild = 2 * holeIndex + 2;
    while (secondChild < len) {
	if (*(first + secondChild) < *(first + (secondChild - 1)))
	    secondChild--;
	*(first + holeIndex) = *(first + secondChild);
	holeIndex = secondChild;
	secondChild = 2 * (secondChild + 1);
    }
    if (secondChild == len) {
	*(first + holeIndex) = *(first + (secondChild - 1));
	holeIndex = secondChild - 1;
    }
    __push_heap(first, holeIndex, topIndex, value);
}

template <class RandomAccessIterator, class T, class Distance>
inline void __pop_heap(RandomAccessIterator first, RandomAccessIterator last,
		       RandomAccessIterator result, T value, Distance*) {
    *result = *first;
    __adjust_heap(first, Distance(0), Distance(last - first), value);
}

template <class RandomAccessIterator, class T>
inline void __pop_heap_aux(RandomAccessIterator first,
			   RandomAccessIterator last, T*) {
    __pop_heap(first, last - 1, last - 1, T(*(last - 1)), distance_type(first));
}

template <class RandomAccessIterator>
inline void pop_heap(RandomAccessIterator first, RandomAccessIterator last) {
    __pop_heap_aux(first, last, value_type(first));
}

template <class RandomAccessIterator, class Distance, class T, class Compare>
void __adjust_heap(RandomAccessIterator first, Distance holeIndex,
		   Distance len, T value, Compare comp) {
    Distance topIndex = holeIndex;
    Distance secondChild = 2 * holeIndex + 2;
    while (secondChild < len) {
	if (comp(*(first + secondChild), *(first + (secondChild - 1))))
	    secondChild--;
	*(first + holeIndex) = *(first + secondChild);
	holeIndex = secondChild;
	secondChild = 2 * (secondChild + 1);
    }
    if (secondChild == len) {
	*(first + holeIndex) = *(first + (secondChild - 1));
	holeIndex = secondChild - 1;
    }
    __push_heap(first, holeIndex, topIndex, value, comp);
}

template <class RandomAccessIterator, class T, class Compare, class Distance>
inline void __pop_heap(RandomAccessIterator first, RandomAccessIterator last,
		       RandomAccessIterator result, T value, Compare comp,
		       Distance*) {
    *result = *first;
    __adjust_heap(first, Distance(0), Distance(last - first), value, comp);
}

template <class RandomAccessIterator, class T, class Compare>
inline void __pop_heap_aux(RandomAccessIterator first,
			   RandomAccessIterator last, T*, Compare comp) {
    __pop_heap(first, last - 1, last - 1, T(*(last - 1)), comp,
	       distance_type(first));
}

template <class RandomAccessIterator, class Compare>
inline void pop_heap(RandomAccessIterator first, RandomAccessIterator last,
		     Compare comp) {
    __pop_heap_aux(first, last, value_type(first), comp);
}

template <class RandomAccessIterator, class T, class Distance>
void __make_heap(RandomAccessIterator first, RandomAccessIterator last, T*,
		 Distance*) {
    if (last - first < 2) return;
    Distance len = last - first;
    Distance parent = (len - 2)/2;

    for (;;) {
	__adjust_heap(first, parent, len, T(*(first + parent)));
	if (parent == 0) return;
	parent--;
    }
}

template <class RandomAccessIterator>
inline void make_heap(RandomAccessIterator first, RandomAccessIterator last) {
    __make_heap(first, last, value_type(first), distance_type(first));
}

template <class RandomAccessIterator, class Compare, class T, class Distance>
void __make_heap(RandomAccessIterator first, RandomAccessIterator last,
		 Compare comp, T*, Distance*) {
    if (last - first < 2) return;
    Distance len = last - first;
    Distance parent = (len - 2)/2;

    for (;;) {
	__adjust_heap(first, parent, len, T(*(first + parent)), comp);
	if (parent == 0) return;
	parent--;
    }
}

template <class RandomAccessIterator, class Compare>
inline void make_heap(RandomAccessIterator first, RandomAccessIterator last,
		      Compare comp) {
    __make_heap(first, last, comp, value_type(first), distance_type(first));
}

template <class RandomAccessIterator>
void sort_heap(RandomAccessIterator first, RandomAccessIterator last) {
    while (last - first > 1) pop_heap(first, last--);
}

template <class RandomAccessIterator, class Compare>
void sort_heap(RandomAccessIterator first, RandomAccessIterator last,
	       Compare comp) {
    while (last - first > 1) pop_heap(first, last--, comp);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\httpaccept.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    httpAccept.h

Abstract:
    Accept HTTP request interface

Author:
    Uri Habusha (urih) 14-May-2000

--*/

#pragma once

#ifndef __HTTP_ACCEPT_H__
#define __HTTP_ACCEPT_H__



void 
IntializeHttpRpc(
    void
    );



LPCSTR
HttpAccept(
    const char* httpHeader,
    DWORD bodySize,
    const BYTE* body,
    const QUEUE_FORMAT* pDestQueue
    );

#endif // __HTTP_ACCEPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\httpauthr.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    SignMessageXml.h

Abstract:
    functions to verify authentication and authorization  in the qm

Author:
    Ilan Herbst (ilanh) 21-May-2000

Environment:
    Platform-independent,

--*/

#ifndef _HTTPAUTHR_H_
#define _HTTPAUTHR_H_


USHORT 
VerifyAuthenticationHttpMsg(
	CQmPacket* pPkt,
	PCERTINFO* ppCertInfo
	);


USHORT 
VerifyAuthenticationHttpMsg(
	CQmPacket* pPkt, 
	const CQueue* pQueue,
	PCERTINFO* ppCertInfo
	);

	
USHORT 
VerifyAuthorizationHttpMsg(
	const CQueue* pQueue,
	PSID pSenderSid
	);

#endif // _HTTPAUTHR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\httpaccept.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    HttpAccept.cpp

Abstract:
    Http Accept implementation

Author:
    Uri Habusha (urih) 14-May-2000

Environment:
    Platform-independent,

--*/

#include <stdh.h>
#include <mqstl.h>
#include <xml.h>
#include <tr.h>
#include <ref.h>
#include <Mp.h>
#include <Fn.h>
#include "qmpkt.h"
#include "cqueue.h"
#include "cqmgr.h"
#include "inrcv.h"
#include "ise2qm.h"
#include "rmdupl.h"
#include "HttpAccept.h"
#include "HttpAuthr.h"
#include "perf.h"
#include "httpAccept.tmh"

#include <singelton.h>

static WCHAR *s_FN=L"HttpAccept";

using namespace std;



const char xHttpOkStatus[] = "200 OK";
const char xHttpBadRequestStatus[] =  "400 Bad Request";
const char xHttpInternalErrorStatus[] = "500 Internal Server Error";
const char xHttpEntityTooLarge[]= "413 Request Entity Too Large";




//-------------------------------------------------------------------
//
// CPutHttpRequestOv class 
//
//-------------------------------------------------------------------
class CPutHttpRequestOv : public OVERLAPPED
{
public:
    CPutHttpRequestOv()
    {
        memset(static_cast<OVERLAPPED*>(this), 0, sizeof(OVERLAPPED));

        hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

        if (hEvent == NULL)
        {
            DBGMSG((DBGMOD_QM, DBGLVL_ERROR, L"Failed to create event for HTTP AC put request. Error %d", GetLastError()));
            LogIllegalPoint(s_FN, 10);
            throw exception();
        }

        //
        //  Set the Event first bit to disable completion port posting
        //
        hEvent = (HANDLE)((DWORD_PTR) hEvent | (DWORD_PTR)0x1);

    }

    
    ~CPutHttpRequestOv()
    {
        CloseHandle(hEvent);
    }

    
    HANDLE GetEventHandle(void) const
    {
        return hEvent;
    }


    HRESULT GetStatus(void) const
    {
        return static_cast<HRESULT>(Internal);
    }
};


static 
USHORT 
VerifyTransactRights(
    const CQmPacket& pkt, 
    const CQueue* pQueue
    )
{
    if(pkt.IsOrdered() == pQueue->IsTransactionalQueue())
        return MQMSG_CLASS_NORMAL;

    if (pkt.IsOrdered())
        return MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_Q;

    return MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_MSG;
}



static
R<CQueue>
GetDestinationQueue(
    const CQmPacket& pkt,
	bool* fTranslated
    )
{
    //
    // Get Destination queue
    //
    QUEUE_FORMAT destQueue;
    const_cast<CQmPacket&>(pkt).GetDestinationQueue(&destQueue);

	//
	// Translate the queue format name according to local mapping )qal.lib)
	//
	QUEUE_FORMAT_TRANSLATOR  RealDestinationQueue(&destQueue);

	
  	*fTranslated = RealDestinationQueue.IsTranslated();

    CQueue* pQueue = NULL;
    QueueMgr.GetQueueObject(RealDestinationQueue.get(), &pQueue, 0, false);

    return pQueue;
}


static
bool
VerifyDuplicate(
	const CQmPacket& pkt,
	bool* pfDupInserted 
	)
{
	
	if(pkt.IsOrdered())
	{
		*pfDupInserted = false;
		return true;
	}

	bool fRet =  DpInsertMessage(pkt) == TRUE;
	*pfDupInserted = fRet;
	return fRet;
}



static 
void 
ProcessReceivedPacket(
    CQmPacket& pkt
    )
{

    ASSERT(! pkt.IsSessionIncluded());

    try
    {
        //
        // Increment Hop Count
        //
        pkt.IncHopCount();
		bool	fDupInserted;
		if(!VerifyDuplicate(pkt , &fDupInserted) )
		{
			DBGMSG((DBGMOD_QM, DBGLVL_ERROR, _TEXT("Http Duplicate Packet rejectet")));
			AppPacketNotAccepted(pkt, 0);
            return;
		}
		
		//
		// If the packet was inserted to the remove duplicate map - we should clean it on rejection
		//
		CAutoDeletePacketFromDuplicateMap AutoDeletePacketFromDuplicateMap(fDupInserted ? &pkt : NULL);

		bool fIsTranslatedQueueFormat;
        R<CQueue> pQueue = GetDestinationQueue(pkt, &fIsTranslatedQueueFormat);
        if(pQueue.get() == NULL)
        {
			DBGMSG((DBGMOD_QM, DBGLVL_ERROR, _TEXT("Packet rejectet because queue was not found")));
            AppPacketNotAccepted(pkt, MQMSG_CLASS_NACK_BAD_DST_Q);
            return;
        }


		//
		// If not local queue  - queue it for delivery if it is frs.
		// 
		if(!pQueue->IsLocalQueue())
		{

			//
			// if we are not frs and no translation exists  - reject the packet
			//
			if(!CQueueMgr::GetMQSRouting() && !fIsTranslatedQueueFormat)
			{	
				DBGMSG((DBGMOD_QM, DBGLVL_ERROR, _TEXT("Packet rejectet because http routing is not supported")));
				AppPacketNotAccepted(pkt, MQMSG_CLASS_NACK_BAD_DST_Q); 
				return;
			}

			AppPutPacketInQueue(pkt, pQueue.get());
			AutoDeletePacketFromDuplicateMap.detach();
			return;
		}
		   

	        
	    //
        //  Match ordered packets with transactional queue
        //
        USHORT usClass = VerifyTransactRights(pkt, pQueue.get());
        if(MQCLASS_NACK(usClass))
        {
			DBGMSG((DBGMOD_QM, DBGLVL_ERROR, _TEXT("Http Packet rejectet because wrong transaction usage")));
            AppPacketNotAccepted(pkt, 0);
            return;
        }

						
		//
		// Verify that the packet is in the right order
		//
		if(!AppVerifyPacketOrder(&pkt))
		{
			DBGMSG((DBGMOD_QM, 
					DBGLVL_ERROR, 
					_TEXT("Http Packet rejectet because of wrong order : SeqID=%x / %x , SeqN=%d ,Prev=%d"),
					HIGH_DWORD(pkt.GetSeqID()),
					LOW_DWORD(pkt.GetSeqID()),
					pkt.GetSeqN(),
					pkt.GetPrevSeqN()));

			AppPacketNotAccepted(pkt, 0);
            return;
		}


	    //
	    // After Authentication the message we know the SenderSid
	    // and perform the Authorization based on the SenderSid
	    //
		R<CERTINFO> pCertInfo;
	    usClass = VerifyAuthenticationHttpMsg(&pkt, pQueue.get(), &pCertInfo.ref());
        if(MQCLASS_NACK(usClass))
        {
			DBGMSG((DBGMOD_QM, DBGLVL_ERROR, _TEXT("Http Packet rejectet because of bad signature")));
            AppPacketNotAccepted(pkt, usClass);
            return;
        }

    	usClass = VerifyAuthorizationHttpMsg(
						pQueue.get(), 
						(pCertInfo.get() == NULL) ? NULL : pCertInfo->pSid
						);

        if(MQCLASS_NACK(usClass))
        {
			DBGMSG((DBGMOD_QM, DBGLVL_ERROR, _TEXT("Http Packet rejectet because access was denied")));
            AppPacketNotAccepted(pkt, usClass);
            return;
        }

			
        AppPutPacketInQueue(pkt, pQueue.get());
		AutoDeletePacketFromDuplicateMap.detach();
    }
    catch (const exception&)
    {
		DBGMSG((DBGMOD_QM, DBGLVL_ERROR, _TEXT("Http Packet rejectet because of unknown exception")));
        AppPacketNotAccepted(pkt, 0);
        LogIllegalPoint(s_FN, 20);
        throw;
    }

}


CQmPacket*
MpSafeDeserialize(
    const char* httpHeader,
    DWORD bodySize,
    const BYTE* body,
    const QUEUE_FORMAT* pqf,
	bool fLocalSend
    )
/*++

Routine Description:
	This function will catch stack overflow exceptions and fix stack if they happen.
	it will not catch other C exceptions & C++ exceptions
	
Arguments:
    Like MpDeserialize.

Return Value:
	CQmPacket - Success
	NULL - stack overflow exception happened.
	
--*/
{
    __try
    {
		return MpDeserialize(httpHeader, bodySize, body,  pqf, fLocalSend);
    }
	__except(GetExceptionCode() == STATUS_STACK_OVERFLOW)
	{
     	_resetstkoflw();
        TrERROR(SRMP, "Http Packet rejected because of stack overflow");
        ASSERT_BENIGN(0);
	}
   	return NULL;
}


LPCSTR
HttpAccept(
    const char* httpHeader,
    DWORD bodySize,
    const BYTE* body,
    const QUEUE_FORMAT* pqf
    )
{
    //
    // Covert Mulitipart HTTP request to MSMQ packet
    //
    P<CQmPacket> pkt = MpSafeDeserialize(httpHeader, bodySize, body,  pqf, false);
    if (pkt.get() == NULL)
    {
    	return xHttpEntityTooLarge;
    }
    
    //
    // Validate the receive packet. If wrong return an acknowledge and free 
    // the packet. Otherwise store in AC
    //
    ProcessReceivedPacket(*pkt);

    return xHttpOkStatus;
}


void UpdatePerfmonCounters(DWORD bytesReceived)
{
	CSingelton<CInHttpPerfmon>::get().UpdateBytesReceived(bytesReceived);
	CSingelton<CInHttpPerfmon>::get().UpdateMessagesReceived();
}


extern "C" LPSTR 
R_ProcessHTTPRequest( 
    LPCSTR Headers,
    DWORD BufferSize,
    BYTE __RPC_FAR Buffer[]
    )
{

	DBGMSG((DBGMOD_ALL,
            DBGLVL_TRACE,
            _T("Got http messages from msmq extension dll ")));

	//
	// Update performace counters
	//
	UpdatePerfmonCounters(strlen(Headers) + BufferSize);

	//
	// here we must verify that we have four zeros at the end
	// of the buffer. It was appended by the mqise.dll to make sure
	// that c run time functions like swcanf we will use on the buffer will not crach.
	// At the moment 4 zeros are needed to make sure we will not crach even
	// that the xml data is not alligned on WCHAR boundery
	//
	DWORD ReduceLen =  sizeof(WCHAR)*2; 
    for(DWORD i=1; i<= ReduceLen ; ++i)
	{
		ASSERT(Buffer[BufferSize - i] == 0);
	}

	//
	//  We must tell the buffer parsers that the real size does not includes
	//	The four zedros at the end
	BufferSize -= ReduceLen;
	
    try
    {
       LPCSTR status = HttpAccept(Headers, BufferSize, Buffer, NULL);
       return newstr(status);
    }
    catch(const bad_document&)
    {
        return newstr(xHttpBadRequestStatus);
    }
    catch(const bad_srmp&)
    {
        return newstr(xHttpBadRequestStatus);
    }
    catch(const bad_request&)
    {
        return newstr(xHttpBadRequestStatus);
    }

	catch(const bad_format_name& )
	{
	    return newstr(xHttpBadRequestStatus);
	}
    catch(const std::bad_alloc&)
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, L"Failed to handle HTTP request due to low resources"));
        LogIllegalPoint(s_FN, 30);
        return newstr(xHttpInternalErrorStatus);
    }
	catch(const std::exception&)
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, L"Failed to handle HTTP request due to unknown exception"));
        LogIllegalPoint(s_FN, 40);
        return newstr(xHttpInternalErrorStatus);
    }

}


void IntializeHttpRpc(void)
{
    RPC_STATUS status = RpcServerRegisterIf2(
				            ISE2QM_v1_0_s_ifspec,
                            NULL,   
                            NULL,
				            0,
				            RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
				            (unsigned int)-1,	
				            NULL
				            );
 
    if(status != RPC_S_OK) 
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, L"Failed to initialize HTTP RPC. Error %x", status));
        LogRPCStatus(status, s_FN, 50);
        throw exception();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\httpauthr.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    HttpAuthr.cpp

Abstract:
    functions to verify the xml signature authnticate the sender 
	and check the sender access rights (sender authorization)

Author:
    Ilan Herbst (ilanh) 15-May-2000

Environment:
    Platform-independent,

--*/

#include "stdh.h"
#include "session.h"
#include "qmsecutl.h"
#include <mqsec.h>
#include <mqformat.h>
#include "Xds.h"
#include "tr.h"
#include "mpnames.h"
#include <utf8.h>

#include "HttpAuthr.tmh"

const TraceIdEntry QmHttp = L"QM HTTP";

static WCHAR *s_FN=L"HttpAuthr";


static
LPCWSTR
SkipUriPrefix(
	LPCWSTR Uri
	)
/*++
Routine Description:
	Skip the Uri prefix

Arguments:
	Uri - reference Uri

Returned Value:
	Pointer to reference Uri after the prefix.

--*/
{
	LPCWSTR pUriNoPrefix = Uri;
	if(pUriNoPrefix[0] == PREFIX_INTERNAL_REFERENCE_C)
	{
		//
		// This is internal #.....
		//
		pUriNoPrefix++;
		return pUriNoPrefix;
	}

	if(wcsncmp(pUriNoPrefix, xPrefixMimeAttachmentW, xPrefixMimeAttachmentLen) == 0)
	{
		pUriNoPrefix += xPrefixMimeAttachmentLen;
		return pUriNoPrefix;
	}

	ASSERT_BENIGN(("Unknown Uri prefix", 0));
	return pUriNoPrefix;
}


#ifdef _DEBUG
static
void
StringToGuid(
    LPCWSTR p, 
    GUID* pGuid
    )
{
    //
    //  N.B. scanf stores the results in an int, no matter what the field size
    //      is. Thus we store the result in tmp variabes.
    //
    UINT w2, w3, d[8];
    if(swscanf(
            p,
            GUID_FORMAT,
            &pGuid->Data1,
            &w2, &w3,                       //  Data2, Data3
            &d[0], &d[1], &d[2], &d[3],     //  Data4[0..3]
            &d[4], &d[5], &d[6], &d[7]      //  Data4[4..7]
            ) != 11)
    {
        ASSERT_BENIGN(("Illegal uuid format", 0));
    }

    pGuid->Data2 = static_cast<WORD>(w2);
    pGuid->Data3 = static_cast<WORD>(w3);
    for(int i = 0; i < 8; i++)
    {
        pGuid->Data4[i] = static_cast<BYTE>(d[i]);
    }
}
#endif // _DEBUG


static
void
VerifySignatureXds(
	CQmPacket *PktPtrs, 
	HCRYPTPROV hProv, 
	HCRYPTKEY hPbKey,
	bool fMarkAuth
	)
/*++
Routine Description:
	Verify signature on xml dsig element.
	this function verify that the signature in the packet fits the message body
	and other references that were signed with the public key of the certificate

Arguments:
	PktPtrs - pointer to the packet
	hProv - handle of the provider
	hPbKey - handle of the sender public key
	fMarkAuth - indicate if the packet will be marked as authenticated after verifying the signature.

Returned Value:
	MQ_OK, if successful, else error code.

--*/
{

    ASSERT(!PktPtrs->IsEncrypted());
	
	ASSERT(!PktPtrs->IsAuthenticated());
	ASSERT(PktPtrs->GetLevelOfAuthentication() == 0);

    //
    // Get the signature from the packet.
    //
    USHORT ulSignatureSize;
    const BYTE* pSignature = PktPtrs->GetSignature(&ulSignatureSize);

	ASSERT(ulSignatureSize > 0);

	ASSERT(hProv != NULL);
	ASSERT(hPbKey != NULL);

	//
	// Convert the signature element to unicode.
	// our xml parser works on unicode
	//
	size_t SignatureWSize;
	AP<WCHAR> pSignatureW = UtlUtf8ToWcs(pSignature, ulSignatureSize,  &SignatureWSize);

	//
	// Parsing signature element
	//
	CAutoXmlNode SignatureTree;
	XmlParseDocument(xwcs_t(pSignatureW, SignatureWSize), &SignatureTree);

	//
	// Get reference vector from the SignatureTree
	//
	CReferenceValidateVectorTypeHelper ReferenceValidateVector = XdsGetReferenceValidateInfoVector(
															         SignatureTree
															         );

	XdsValidateSignature(
		SignatureTree, 
		hPbKey, 
		hProv
		);
	
	TrTRACE(QmHttp, "Validate Signature on signature element completed ok (still need to validate references)");

	//
	// Normal termination --> Validation ok
	//
  
	bool fBodyRefValidated = false;
	bool fExtensionRefValidated = false;
	//
	// Fill ReferenceData in the ReferenceValidateVector found in the signature
	//
	for(ReferenceValidateVectorType::iterator ir = ReferenceValidateVector->begin(); 
		ir != ReferenceValidateVector->end(); ++ir)
	{
		TrTRACE(QmHttp, "Uri '%.*ls'", LOG_XWCS((*ir)->Uri()));
		LPCWSTR pUriId = SkipUriPrefix((*ir)->Uri().Buffer());

		//
		// Get ReferenceData according to Uri or some other mechanism
		// this need to be decided
		//
		xdsvoid_t ReferenceData;

		if(wcsncmp(pUriId, xMimeBodyIdW, xMimeBodyIdLen) == 0)
		{
#ifdef _DEBUG
		    GUID UriSrcQmGuid = GUID_NULL;
			StringToGuid(pUriId + xMimeBodyIdLen, &UriSrcQmGuid);
			ASSERT_BENIGN(UriSrcQmGuid == *PktPtrs->GetSrcQMGuid());
#endif // _DEBUG

			//
			// Message Body validation
			//
			ULONG dwBodySize;
			const UCHAR* pBody = PktPtrs->GetPacketBody(&dwBodySize);
			TrTRACE(QmHttp, "VerifySignatureXds: message body reference, BodySize = %d", dwBodySize);

			ReferenceData = xdsvoid_t(pBody, dwBodySize);
			(*ir)->SetReferenceData(ReferenceData);
			XdsValidateReference(**ir, hProv);

			//
			// Mark that we validated body reference
			//
			fBodyRefValidated = true;

			TrTRACE(QmHttp, "Validate message body reference completed ok");
		}
		else if(wcsncmp(pUriId, xMimeExtensionIdW, xMimeExtensionIdLen) == 0)
		{
#ifdef _DEBUG
		    GUID UriSrcQmGuid = GUID_NULL;
			StringToGuid(pUriId + xMimeExtensionIdLen, &UriSrcQmGuid);
			ASSERT_BENIGN(UriSrcQmGuid == *PktPtrs->GetSrcQMGuid());
#endif // _DEBUG

			//
			// Message Extension validation
			//
			ULONG dwExtensionSize = PktPtrs->GetMsgExtensionSize();
			const UCHAR* pExtension = PktPtrs->GetMsgExtensionPtr();
			TrTRACE(QmHttp, "VerifySignatureXds: message Extension reference, ExtensionSize = %d", dwExtensionSize);

			ReferenceData = xdsvoid_t(pExtension, dwExtensionSize);
			(*ir)->SetReferenceData(ReferenceData);
			XdsValidateReference(**ir, hProv);

			//
			// Mark that we validate extension reference
			//
			fExtensionRefValidated = true;

			TrTRACE(QmHttp, "Validate message Extension reference completed ok");
		}
		else
		{
			//
			// Unknown Reference in SignatureElement
			// We will not reject the signature because unknown references
			// this means that we will only validate body and extension references
			// and ignore other references.
			//
			TrERROR(QmHttp, "unexpected reference in SignatureElement, Uri = %.*ls", LOG_XWCS((*ir)->Uri()));
		}
	}

	TrTRACE(QmHttp, "Verify SignatureXds completed ok");

	//
	// Check if all mandatory references exist
	//
	bool fMandatoryReferencesExist = true;
	if(!fBodyRefValidated && (PktPtrs->GetBodySize() != 0))
	{
		fMandatoryReferencesExist = false;
		TrERROR(QmHttp, "Body exist but we did not validate body reference");
	}

	if(!fExtensionRefValidated && (PktPtrs->GetMsgExtensionSize() != 0))
	{
		fMandatoryReferencesExist = false;
		TrERROR(QmHttp, "Extension exist but we did not validate extension reference");
	}

	//
	// mark the message as authenticated only if needed. 
	// Certificate was found in the DS or certificate is not self signed
	// and all Mandatory references exists.
	//
	if(!fMarkAuth || !fMandatoryReferencesExist)
	{
		TrTRACE(QmHttp, "The message will not mark as autheticated");
		return;
	}

	//
	// All is well, mark the message that it is an authenticated message.
	// mark the authentication flag and the level of authentication as XMLDSIG
	//
	PktPtrs->SetAuthenticated(TRUE);
	PktPtrs->SetLevelOfAuthentication(MQMSG_AUTHENTICATED_SIGXML);
}		


USHORT
AuthenticateHttpMsg(
	CQmPacket* pPkt, 
	PCERTINFO* ppCertInfo
	)
/*++
Routine Description:
	Authenticate Http message
	The function get the certificate related information including the crypto provider
	and the user sid, verify the xml digital signature.

Arguments:
	pPkt - pointer to the packet
	ppCertInfo - pointer to cert info

Returned Value:
    The acknowledgment class.
    if Authenticate packet is OK, MQMSG_CLASS_NORMAL is returned
	if error MQMSG_CLASS_NACK_BAD_SIGNATURE is returned

--*/
{
	//
	// 1) Get the CSP information for the message certificate.
	// 2) Get the SenderSid from the DS according to the certificate - will be used latter
	//    after verifying the signature to determinate the user access rights.
	//
	// Note: for http messages we are always trying to get the sid, fNeedSidInfo = true 
	// this is a change comparing to msmq protocol. 
	// In msmq protocol we tried to get the sid in case of MQMSG_SENDERID_TYPE_SID
	//

	R<CERTINFO> pCertInfo;
	HRESULT hr = GetCertInfo(
					 pPkt, 
					 &pCertInfo.ref(),
					 true // fNeedSidInfo
					 );

	if (FAILED(hr))
	{
		TrERROR(QmHttp, "GetCertInfo() Failed in VerifyHttpRecvMsg()");
		return(MQMSG_CLASS_NACK_BAD_SIGNATURE);
	}

	HCRYPTPROV hProv = pCertInfo->hProv;
	HCRYPTKEY hPbKey = pCertInfo->hPbKey;

	try
	{
		//
		// fMarkAuth flag indicate if the packet should be mark as authenticated
		// after validating the signature.
		// The packed should be marked as authenticate if the certificate was found in the DS (pSid != NULL)
		// or the certificate is not self signed
		//
		bool fMarkAuth = ((pCertInfo->pSid != NULL) || (!pCertInfo->fSelfSign));

		VerifySignatureXds(
			pPkt, 
			hProv, 
			hPbKey,
			fMarkAuth 
			);

		*ppCertInfo = pCertInfo.detach();

		return(MQMSG_CLASS_NORMAL);
	}
	catch (const bad_signature&)
	{
		//
		// XdsValidateSignature throw excption --> Validation fail
		//
		TrERROR(QmHttp, "Signature Validation Failed - bad_signature excption");

		//
		// Bad signature, send NACK.
		//
		return(MQMSG_CLASS_NACK_BAD_SIGNATURE);
	}
	catch (const bad_reference&)
	{
		//
		// XdsCoreValidation throw Reference excption --> CoreValidation fail
		//
		TrERROR(QmHttp, "Core Validation Failed, Reference Validation Failed");

		//
		// Bad signature, send NACK.
		//
		return(MQMSG_CLASS_NACK_BAD_SIGNATURE);
	}
	catch (const bad_CryptoApi& badCryEx)
	{
		TrERROR(QmHttp, "bad Crypto Class Api Excption ErrorCode = %x", badCryEx.error());

		//
		// Bad signature, send NACK.
		//
		return(MQMSG_CLASS_NACK_BAD_SIGNATURE);
	}
    catch (const bad_base64&)
    {
		TrERROR(QmHttp, "Signature Validation Failed - bad_base64 excption");
		return(MQMSG_CLASS_NACK_BAD_SIGNATURE);
	}
    catch (const bad_alloc&)
    {
		TrERROR(QmHttp, "Signature Validation Failed - bad_alloc excption");
		LogIllegalPoint(s_FN, 20);
		return(MQMSG_CLASS_NACK_BAD_SIGNATURE);
	}
}


USHORT 
VerifyAuthenticationHttpMsg(
	CQmPacket* pPkt,
	PCERTINFO* ppCertInfo
	)
/*++
Routine Description:
	Authenticate http message for local queues

Arguments:
	pPkt - pointer to the packet
	ppCertInfo - pointer to cert info

Returned Value:
    The acknowledgment class.
    if packet authentication is OK, MQMSG_CLASS_NORMAL is returned

--*/
{
	ASSERT(pPkt->IsEncrypted() == 0);

	//
	// Authentication
	//

	//
	// Mark the message as unAuthenticated
	//
	pPkt->SetAuthenticated(FALSE);
	pPkt->SetLevelOfAuthentication(MQMSG_AUTHENTICATION_NOT_REQUESTED);

	*ppCertInfo = NULL;

	if(pPkt->GetSignatureSize() != 0)
	{
		//
		// We have signature but no sender certificate
		//
		if(!pPkt->SenderCertExist())
		{
			TrERROR(QmHttp, "VerifyAuthenticationHttpMsg(): We have Signature but no sender certificate");
			return(MQMSG_CLASS_NACK_BAD_SIGNATURE);
		}
		USHORT usClass = AuthenticateHttpMsg(
							pPkt, 
							ppCertInfo
							);

		if(MQCLASS_NACK(usClass))
		{
			TrERROR(QmHttp, "AuthenticateHttpMsg() failed");
			return(usClass);
		}

	}

    return(MQMSG_CLASS_NORMAL);
}


USHORT 
VerifyAuthenticationHttpMsg(
	CQmPacket* pPkt, 
	const CQueue* pQueue,
	PCERTINFO* ppCertInfo
	)
/*++
Routine Description:
	Authenticate http message and get sender sid

Arguments:
	pPkt - pointer to the packet
	pQueue - pointer to the queue
	ppCertInfo - pointer to cert info

Returned Value:
    The acknowledgment class.
    if packet authentication is OK, MQMSG_CLASS_NORMAL is returned

--*/
{
	ASSERT(pQueue->IsLocalQueue());

	//
	// dont support encryption in HTTP messages
	// encryption is done using https - iis level
	// 
	ASSERT(pQueue->GetPrivLevel() != MQ_PRIV_LEVEL_BODY);
	ASSERT(pPkt->IsEncrypted() == 0);

	USHORT usClass = VerifyAuthenticationHttpMsg(
						pPkt, 
						ppCertInfo
						);

	if(MQCLASS_NACK(usClass))
	{
		TrERROR(QmHttp, "Authentication failed");
		return(usClass);
	}

    if (pQueue->ShouldMessagesBeSigned() && !pPkt->IsAuthenticated())
    {
		//
        // The queue enforces that any message sent to it should be signed.
        // But the message does not contain a signature, send NACK.
		//

		TrERROR(QmHttp, "The queue accept only Authenticated packets, the packet is not authenticated");
        return(MQMSG_CLASS_NACK_BAD_SIGNATURE);
    }

    return(MQMSG_CLASS_NORMAL);
}



USHORT 
VerifyAuthorizationHttpMsg(
	const CQueue* pQueue,
	PSID pSenderSid
	)
/*++
Routine Description:
	Check if the sender sid is Authorize to write message to the queue

Arguments:
	pQueue - pointer to the queue
	pSenderSid - pointer to sender sid

Returned Value:
    The acknowledgment class.
    if access granted, MQMSG_CLASS_NORMAL is returned

--*/
{
	ASSERT(pQueue->IsLocalQueue());

	//
    // Verify the the sender has write access permission on the queue.
	//
	HRESULT hr = VerifySendAccessRights(
					 const_cast<CQueue*>(pQueue), 
					 pSenderSid, 
					 (USHORT)(pSenderSid ? MQMSG_SENDERID_TYPE_SID : MQMSG_SENDERID_TYPE_NONE)
					 );

    if (FAILED(hr))
    {
		//
        // Access was denied, send NACK.
		//
		TrERROR(QmHttp, "VerifyAuthorizationHttpMsg(): VerifySendAccessRights failed");
        return(MQMSG_CLASS_NACK_ACCESS_DENIED);
    }

	TrTRACE(QmHttp, "VerifyAuthorizationHttpMsg(): VerifySendAccessRights ok");
    return(MQMSG_CLASS_NORMAL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\initmclistener.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    InitMcListener.cpp

Abstract:
    Initialize Multicast listener

Author:
    Uri Habusha (urih) 26-Sep-2000

Environment:
    Platform-independent

--*/

#include "stdh.h"
#include "Mc.h"
#include "Msm.h"
#include "Fn.h"
#include "mqexception.h"
#include "lqs.h"

#include "InitMcListener.tmh"

static WCHAR *s_FN=L"Initmclistener";

static LPWSTR GetMulticastAddress(HLQS hLqs)
{
    PROPID aProp[2];
    PROPVARIANT aVar[2];
    ULONG cProps = 0;

    aProp[0] = PROPID_Q_MULTICAST_ADDRESS;
    aVar[0].vt = VT_NULL;
    ++cProps;

    //
    // Transactional queues ignore the multicast property. We allow setting the multicast
    // property for transactional queues since it's difficult to block it but do not bind.
    //
    aProp[1] = PROPID_Q_TRANSACTION;
    aVar[1].vt = VT_UI1;
    ++cProps;

    HRESULT hr = LQSGetProperties(hLqs, cProps, aProp, aVar);
    LogHR(hr, s_FN, 70);
    if (FAILED(hr))
        throw bad_hresult(hr);

    if (aVar[0].vt == VT_EMPTY)
        return NULL;

    if (aVar[1].bVal)
    {
        DBGMSG((DBGMOD_QM, DBGLVL_INFO, L"Do not bind transactional queue to multicast address"));
        return NULL;
    }

    ASSERT((aVar[0].pwszVal != NULL) && (aVar[0].vt == VT_LPWSTR));
    return aVar[0].pwszVal;
}


static void BindMulticast(const QUEUE_FORMAT& qf, LPCWSTR address)
{    
    MULTICAST_ID multicastId;

    try
    {
        FnParseMulticastString(address, &multicastId);
    }
    catch(const bad_format_name&)
    {
        //
        // If the multicast address isn't valid ignore the current address and
        // continue to procees the rest of the queues
        //
        WCHAR wzError[20];
        _ultot(MQ_ERROR_ILLEGAL_FORMATNAME, wzError, 16);
        REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL, MULTICAST_BIND_ERROR, 2, address, wzError));
        LogIllegalPoint(s_FN, 50);
        return;
    }

    try
    {
        MsmBind(qf, multicastId);
    }
    catch (const bad_win32_error& e)
    {
        WCHAR wzError[20];
        _ultot(e.error(), wzError, 16);
        REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL, MULTICAST_BIND_ERROR, 2, address, wzError));
        LogIllegalPoint(s_FN, 55);
    }
}


static bool InitMulticastPublicQueues(void)
    //
    // Enumerate local public queues in LQS.
    //
{
    GUID guid;
    HLQS hLQS;

    HRESULT hr = LQSGetFirst(&hLQS, &guid);

    for(;;)
    {
        //
        // No more queues
        //
        if (hr == MQ_ERROR_QUEUE_NOT_FOUND)
            return true;

        //
        // Open a public queue store according to the queue GUID.
        //
        WCHAR szFilePath[MAX_PATH_PLUS_MARGIN];
        CHLQS hLqsQueue;
        hr = LQSOpen(&guid, &hLqsQueue, szFilePath);
        if (FAILED(hr))
        {
            WCHAR strHresult[20];
            _ultot(hr, strHresult, 16);
            REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL, SERVICE_START_ERROR_INIT_MULTICAST, 2, strHresult, szFilePath));
            LogHR(hr, s_FN, 60);
            return false;
        }

        AP<WCHAR> multicastAddress = GetMulticastAddress(hLqsQueue);

        if (multicastAddress != NULL)
        {
            BindMulticast(QUEUE_FORMAT(guid), multicastAddress);
        }

        hr = LQSGetNext(hLQS, &guid);
    }

    //
    // No need to close the enumeration handle in case LQSGetNext fails
    //
}


static bool InitMulticastPrivateQueues(void)
{
    //
    // Enumerate local public queues in LQS.
    //
    DWORD queueId;
    HLQS hLQS;

    HRESULT hr = LQSGetFirst(&hLQS, &queueId);

    for(;;)
    {
        //
        // No more queues
        //
        if (hr == MQ_ERROR_QUEUE_NOT_FOUND)
            return true;

        //
        // Open a private queue store according to the queue id.
        //
        WCHAR szFilePath[MAX_PATH_PLUS_MARGIN];
        CHLQS hLqsQueue;
        hr = LQSOpen(queueId, &hLqsQueue, szFilePath);
        if (FAILED(hr))
        {
            WCHAR strHresult[20];
            _ultot(hr, strHresult, 16);
            REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL, SERVICE_START_ERROR_INIT_MULTICAST, 2, strHresult, szFilePath));
            return false;
        }

        AP<WCHAR> multicastAddress = GetMulticastAddress(hLqsQueue);

        if (multicastAddress != NULL)
        {
            BindMulticast(QUEUE_FORMAT(McGetMachineID(), queueId), multicastAddress);
        }

        hr = LQSGetNext(hLQS, &queueId);
    }

    //
    // No need to close the enumeration handle in case LQSGetNext fails
    //
}


bool QmpInitMulticastListen(void)
{
    if (!InitMulticastPublicQueues())
    {
    	LogIllegalPoint(s_FN, 30);
        return false;
    }

    if (!InitMulticastPrivateQueues())
    {
    	LogIllegalPoint(s_FN, 40);
        return false;
    }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\ise2qm_s_.c ===
#pragma warning(push, 3)
#include <ise2qm_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\httpdeserialize.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    HttpDeserialize.cpp

Abstract:
    Http deserialize implementation

Author:
    Uri Habusha (urih) 13-Jun-2000

Environment:
    Platform-independent,

--*/

#include <stdh.h>

#include "mqstl.h"
#include "algorithm"
#include <tr.h>
#include <ref.h>
#include <utf8.h>
#include "Mp.h"
#include "HttpAccept.h"
#include "acdef.h"
#include "qmpkt.h"
#include "ac.h"

#include "httpdeserialize.tmh"

static WCHAR *s_FN=L"HttpDeserialize";

using namespace std;


extern HANDLE g_hAc;

const char xFieldSeperator[] = "\r\n";


inline LPCSTR removeLeadingSpace(LPCSTR p, LPCSTR pEnd)
{
    for(; ((pEnd > p) && iswspace(*p)); ++p)
    {
        NULL;
    }

    return p;
}


inline LPCSTR removeTralingSpace(LPCSTR p, LPCSTR pEnd)
{
    for(; ((pEnd >= p) && iswspace(*pEnd)); --pEnd)
    {
        NULL;
    }

    return pEnd;
}


static xstr_t FindHeaderField(LPCSTR p, DWORD length, LPCSTR fieldName)
{
    //
    // HTTP header must terminate with '\r\n\r\n'. We already parse
    // the header and find it as a legal HTTP header.
    //
    ASSERT(length >= 4);

    LPCSTR pEnd = p + length;
    
    p = search (p, pEnd, fieldName, fieldName + strlen(fieldName));	
    if((p == pEnd) || ((p + strlen(fieldName)) == pEnd))
    {
        throw bad_request(L"HTTP header field is missing");	
    }
    
    p += strlen(fieldName);
    p = removeLeadingSpace(p, pEnd);

    LPCSTR pEndOfField = search (p, pEnd, xFieldSeperator, xFieldSeperator + strlen(xFieldSeperator));	
    if((pEndOfField == pEnd) || ((pEndOfField + strlen(fieldName)) == pEnd))
    {
        throw bad_request(L"HTTP header field is missing");	
    }
    
    pEndOfField = removeTralingSpace(p, pEndOfField);

    return xstr_t(p, (pEndOfField - p + 1));
}


const char xBoundary[] = "boundary=";

static xstr_t FindBoundarySeperator(xstr_t contentType)
{
    LPCSTR p = contentType.Buffer();
    LPCSTR pEnd = p + contentType.Length();

    //
    // looking for boundary attribute
    //
    p = search (p, pEnd, xBoundary, xBoundary + STRLEN(xBoundary));	
    if((p == pEnd) || ((p + STRLEN(xBoundary)) == pEnd))
    {
        throw bad_request(L"failed to retreive boundary attribute");	
    }
    
    p += STRLEN(xBoundary);
    p = removeLeadingSpace(p, pEnd);

    //
    // mime attribute value can be enclosed by '"' or not
    //
    if (*p =='"')
        ++p;

    //
    // looking for end of boundary attribute. It can be '\r\n' or ';'
    //
    LPCSTR ptemp = strchr(p, ';');
    if ((ptemp != NULL) && (pEnd > ptemp))
    {
        pEnd = --ptemp;
    }
    
    pEnd = removeTralingSpace(p, pEnd);

    if (*pEnd =='"')
        --pEnd;

    return xstr_t(p, (pEnd - p + 1));
}


const char xContentType[] = "Content-Type:";
const char xContentLength[] = "Content-Length:";
const char xContentId[] = "Content-Id:";
const char xEndOfHttpHeaderRequest[] = "\r\n\r\n";

const char xMimeContentTypeValue[] = "multipart/related";
const char xEnvelopeContentTypeValue[] = "text/xml";


static DWORD FindEndOfHeader(LPCSTR p, DWORD length)
{
    LPCSTR pEnd = p + length;
    LPCSTR pEndOfHeader = search(
                            p, 
                            pEnd, 
                            xEndOfHttpHeaderRequest, 
                            xEndOfHttpHeaderRequest + STRLEN(xEndOfHttpHeaderRequest)
                            );
    
    if((pEndOfHeader == pEnd) || ((pEndOfHeader + STRLEN(xEndOfHttpHeaderRequest)) == pEnd))
    {
        throw bad_request(L"Can't find EOF HTTP header");	
    }

    pEndOfHeader += STRLEN(xEndOfHttpHeaderRequest);
    return numeric_cast<DWORD>((pEndOfHeader - p)); 
}



static
const BYTE*
GetSection(
    const BYTE* pSection,
    size_t sectionLength,
    CAttachmentsArray* pAttachments	,
	const BYTE* pHttpBody,
	const BYTE* pEndHttpBody 
    )
{
	
	ASSERT(pHttpBody <= pSection); 


    const char* pHeader = reinterpret_cast<const char*>(pSection);

    //
    // Find the end of Envelope header
    //
    DWORD headerSize = FindEndOfHeader(pHeader, numeric_cast<DWORD>(sectionLength));

    //
    // Find Content-Id value;
    //
	CAttachment attachment;
    attachment.m_id = FindHeaderField(pHeader, headerSize, xContentId);


    //
    // Get section size
    //
    xstr_t contentLengthField = FindHeaderField(pHeader, headerSize, xContentLength);
    ASSERT(contentLengthField.Length() != 0);
    DWORD size = atoi(contentLengthField.Buffer());


	const BYTE* pNextSection = 	pSection + headerSize + size;
	//
	// check overflow
	//
	if(pNextSection >= pEndHttpBody)
	{
		throw bad_request(L"");	
	}

	const BYTE* pAttachmentData = pSection  + headerSize;
    attachment.m_data = xbuf_t<const VOID>((pAttachmentData), size);
	attachment.m_offset	= pAttachmentData - pHttpBody;

	pAttachments->push_back(attachment);

    return pNextSection;
}
    

const char xBoundaryLeadingHyphen[] = "--";
const char xCRLF[] = "\r\n";

static
const BYTE*
ParseBoundaryLineDelimeter(
    const BYTE* pBoundary,
    xstr_t boundary
    )
{
    //
    // The boundary delimiter line is then defined as a line
    // consisting entirely of two hyphen characters ("-", decimal value 45)
    // followed by the boundary parameter value from the Content-Type header
    // field, optional linear whitespace, and a terminating CRLF.
    //

    LPCSTR p = reinterpret_cast<LPCSTR>(pBoundary);
    //
    // Check exisiting of two hyphen characters
    //
    if(strncmp(p, xBoundaryLeadingHyphen, STRLEN(xBoundaryLeadingHyphen)) != 0)
        throw bad_request(L"Failed to find boundary line delimeter");

    p += STRLEN(xBoundaryLeadingHyphen);

    //
    // Check exisiting of boundary parameter value
    //
    if(strncmp(p, boundary.Buffer(), boundary.Length()) != 0)
        throw bad_request(L"Failed to find boundary line delimeter");

    p += boundary.Length();
    p = removeLeadingSpace(p, p + strlen(p));

    return reinterpret_cast<const BYTE*>(p);
}


static
wstring
GetAttachments(
    const BYTE* pHttpBody,
    DWORD HttpBodySize,
    CAttachmentsArray* pAttachments,
    xstr_t boundary
    )
{
	const BYTE* p = pHttpBody;
    const BYTE* pEndHttpBody = p + HttpBodySize;
    const char* pAttachmentHeader = reinterpret_cast<const char*>(p);

    //
    // Find the end of Envelope header
    //
    DWORD headerSize = FindEndOfHeader(pAttachmentHeader, HttpBodySize);
    xstr_t contentLength = FindHeaderField(pAttachmentHeader, headerSize, xContentLength);

    DWORD envelopeSize = atoi(contentLength.Buffer());

    //
	// check overflow
	//
	const BYTE* pStartEnv =  p + headerSize;
	const BYTE* pEndEnv =  pStartEnv + envelopeSize;
	if(pEndEnv >= pEndHttpBody)
	{
		throw bad_request(L"");	
	}
   
    wstring envelope = UtlUtf8ToWcs(pStartEnv, envelopeSize);
 
    //
    // After the envelope should apper Multipart boundary seperator
    //
    p = ParseBoundaryLineDelimeter(pEndEnv , boundary);

    while(pEndHttpBody > p)
    {
        p = GetSection(
			p, 
			(pEndHttpBody - p), 
			pAttachments, 
			pHttpBody,
			pEndHttpBody
			);

        //
        // After each section should apper Multipart boundary seperator
        //
        p = ParseBoundaryLineDelimeter(p, boundary);
    }

    return envelope; 
}

static
wstring
BreakRequestToMultipartSections(
    const char* pHttpHeader,
    DWORD HttpBodySize,
    const BYTE* pHttpBody,
    CAttachmentsArray* pAttachments
    )
{
    //
    // Get Content-Type
    //
    xstr_t contentType = FindHeaderField(pHttpHeader, strlen(pHttpHeader), xContentType);

    if (contentType == xEnvelopeContentTypeValue)
    {
        //
        // Simple message. The message doesn't contain external reference
        //
       return  UtlUtf8ToWcs(pHttpBody, HttpBodySize);
    }

    if ((contentType.Length() >= STRLEN(xMimeContentTypeValue)) &&
        (_strnicmp(contentType.Buffer(), xMimeContentTypeValue,STRLEN(xMimeContentTypeValue)) == 0))
    {
        return GetAttachments(
			pHttpBody, 
			HttpBodySize, 
			pAttachments, 
			FindBoundarySeperator(contentType));
    }

    DBGMSG((DBGMOD_QM, DBGLVL_ERROR, L"Bad HTTP request. Unsupported Content-Type field"));
    throw bad_request(L"Illegal Content-Type value");
}




CQmPacket*
HttpDeserialize(
    const char* httpHeader,
    DWORD bodySize,
    const BYTE* body,
    const QUEUE_FORMAT* pqf,
    bool  fLocalSend
    )
{
	basic_xstr_t<BYTE> TheBody(body, bodySize); 
    CHttpReceivedBuffer HttpReceivedBuffer(TheBody, httpHeader);
	
    wstring envelope = BreakRequestToMultipartSections(
                                                httpHeader,
                                                bodySize,
                                                body,
                                                &HttpReceivedBuffer.GetAttachments()
                                                );

    //
    // build the QmPacket
    //
	CACPacketPtrs  ACPacketPtrs;
    if (fLocalSend)
    {
        ACPacketPtrs = MpDeserializeLocalSend(
                           xwcs_t(envelope.c_str(), envelope.size()),    
                           HttpReceivedBuffer,
                           pqf
                           );
    }
    else
    {
        ACPacketPtrs = MpDeserialize(
                           xwcs_t(envelope.c_str(), envelope.size()),    
                           HttpReceivedBuffer,
                           pqf
                           );
    }

    try
    {
        return new CQmPacket(ACPacketPtrs.pPacket, ACPacketPtrs.pDriverPacket);
    }
    catch (const std::bad_alloc&)
    {
        ACFreePacket(g_hAc, ACPacketPtrs.pDriverPacket);
        LogIllegalPoint(s_FN, 10);
        throw;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\inrcv.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    inrcv.cpp

Abstract:
	implementation for functions that handlers incomming message.					

Author:
    Gil Shafriri 4-Oct-2000

Environment:
    Platform-independent

--*/
#include "stdh.h"
#include "mqstl.h"
#include "qmpkt.h"
#include "xact.h"
#include "xactin.h"
#include "cqueue.h"
#include "rmdupl.h"
#include "inrcv.h"
#include "rmdupl.h"
#include <mp.h>
#include <mqexception.h>

#include "inrcv.tmh"

extern  CInSeqHash* g_pInSeqHash;
extern HANDLE g_hAc;
extern CCriticalSection g_critVerifyOrdered;

static WCHAR *s_FN=L"Inrcv";

struct ACPutOrderedOvl : public EXOVERLAPPED 
{
    ACPutOrderedOvl(
        EXOVERLAPPED::COMPLETION_ROUTINE lpComplitionRoutine
        ) :
        EXOVERLAPPED(lpComplitionRoutine, lpComplitionRoutine)
    {
    }
	HANDLE          m_hQueue;
    CACPacketPtrs   m_packetPtrs;   // packet pointers
};


//-------------------------------------------------------------------
//
// CSyncPutPacketOv class 
//
//-------------------------------------------------------------------
class CSyncPutPacketOv : public OVERLAPPED
{
public:
    CSyncPutPacketOv()
    {
        memset(static_cast<OVERLAPPED*>(this), 0, sizeof(OVERLAPPED));

        hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

        if (hEvent == NULL)
        {
            DBGMSG((DBGMOD_QM, DBGLVL_ERROR, L"Failed to create event for HTTP AC put request. Error %d", GetLastError()));
            LogIllegalPoint(s_FN, 10);
            throw exception();
        }

        //
        //  Set the Event first bit to disable completion port posting
        //
        hEvent = (HANDLE)((DWORD_PTR) hEvent | (DWORD_PTR)0x1);

    }

    
    ~CSyncPutPacketOv()
    {
        CloseHandle(hEvent);
    }

    
    HANDLE GetEventHandle(void) const
    {
        return hEvent;
    }


    HRESULT GetStatus(void) const
    {
        return static_cast<HRESULT>(Internal);
    }
};



static void WaitForIoEnd(CSyncPutPacketOv* pov)
/*++
Routine Description:
   Wait until IO operation ends.
  
Arguments:
   	pov - overlapp to wait on.
 
Returned Value:
    None.

Note:
--*/
{
    HRESULT rc = WaitForSingleObject(pov->GetEventHandle(), INFINITE);
    ASSERT(rc != WAIT_FAILED);

    if (FAILED(pov->GetStatus()))
    {
		DBGMSG((DBGMOD_QM, DBGLVL_ERROR, L"Storing packet Failed Asyncronusly. Error: %x", rc));
        LogHR(rc, s_FN, 20);
        throw exception();
    }
}



static 
void 
SyncPutPacket(
	const CQmPacket& pkt, 
    const CQueue* pQueue
    )
/*++
Routine Description:
   Save packet in the driver queue and wait for completion.
   
  
Arguments:
	pkt - packet to save.
	pQueue - queue to save the packet into.
  
Returned Value:
    None.

--*/
{
	CSyncPutPacketOv ov;


    HRESULT rc = ACPutPacket(
                        pQueue->GetQueueHandle(),
                        pkt.GetPointerToDriverPacket(),
                        &ov
                        );

    if(FAILED(rc))
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, L"ACPutPacket Failed. Error: %x", rc));
        LogHR(rc, s_FN, 30);
        throw bad_hresult(rc);
    }
	WaitForIoEnd(&ov);
}




void static WINAPI HandlePutOrderedPacket(EXOVERLAPPED* pov)
/*++
Routine Description:
   Save the packet in the logger. This function is called after the order packet
   saved to disk/
  
Arguments:
   	pov - overlapp that pointing to the stored packet and additional information
	needed to be written to the logger (stream information).
 
Returned Value:
    None.

Note:
--*/
{
	ACPutOrderedOvl* pACPutOrderedOvl = static_cast<ACPutOrderedOvl*> (pov);
	ASSERT(SUCCEEDED(pACPutOrderedOvl->GetStatus()));
        
	    
    ASSERT(g_pInSeqHash);
    CQmPacket Pkt(
		pACPutOrderedOvl->m_packetPtrs.pPacket,
		pACPutOrderedOvl->m_packetPtrs.pDriverPacket
		);

    HRESULT hr = g_pInSeqHash->Register(
									&Pkt, 
									pACPutOrderedOvl->m_hQueue
									);

	UNREFERENCED_PARAMETER(hr);
    delete pov;	
}

static
void 
AsyncPutOrderPacket(
					const CQmPacket& Pkt,
					const CQueue& Queue
					)
/*++
Routine Description:
   Store order packet in a queue asyncrounsly. 
  
Arguments:
   		Pkt - packet to store
		Queue - queue to stote in the packet.
		
 
Returned Value:
    None.

Note:
After this   asyncrounsly operation ends the packet is still invisible to application.
Only after it is written to the logger - the logger callback make it visible according to the correct
order.

--*/
{
	ASSERT(Pkt.IsEodIncluded());
	P<ACPutOrderedOvl> pACPutOrderedOvl = 	new ACPutOrderedOvl(HandlePutOrderedPacket);
										
	pACPutOrderedOvl->m_packetPtrs.pPacket = Pkt.GetPointerToPacket();
    pACPutOrderedOvl->m_packetPtrs.pDriverPacket = Pkt.GetPointerToDriverPacket();
    pACPutOrderedOvl->m_hQueue    = Queue.GetQueueHandle();
	

	HRESULT rc = ACPutPacket1(
						Queue.GetQueueHandle(),
                        Pkt.GetPointerToDriverPacket(),
                        pACPutOrderedOvl
						);


    if(FAILED(rc))
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, _TEXT("ACPutPacket1 Failed. Error: %x"), rc));
        throw bad_hresult(rc);
    }
	pACPutOrderedOvl.detach();
}



bool AppVerifyPacketOrder(CQmPacket* pPkt)
{
	if(!pPkt->IsOrdered())
		return true;

	ASSERT(pPkt->IsEodIncluded());

	CS cs(g_critVerifyOrdered );

	return g_pInSeqHash->Verify(pPkt) == TRUE;
}


void
AppPacketNotAccepted(
    CQmPacket& pkt, 
    USHORT usClass
    )
{
	ACFreePacket(g_hAc, pkt.GetPointerToDriverPacket(), usClass);
}




void 
AppPutPacketInQueue(
    CQmPacket& pkt, 
    const CQueue* pQueue 
	)
/*++
Routine Description:
   Save packet in the driver queue.
  
Arguments:
    pkt - packet to save.
	pQueue - queue to save the packet into.
	
   
Returned Value:
    None.

--*/
{
	//
	// If ordered and the queue is the destination queue
	//
    if(pkt.IsOrdered() && pQueue->IsLocalQueue())
	{
		AsyncPutOrderPacket(pkt, *pQueue);
		return;
	}

	//
	// We don't need ordering - save it syncrounosly and make it visible to application.
	//
	SyncPutPacket(pkt, pQueue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\inrcv.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    inrcv.h

Abstract:
	header for functions that handlers incomming message.					

Author:
    Gil Shafriri 4-Oct-2000

Environment:
    Platform-independent

--*/
class  CQmPacket;
class  CQueue;

bool AppVerifyPacketOrder(CQmPacket* pPkt);
void AppPutPacketInQueue( CQmPacket& pkt, const CQueue* pQueue);
void AppPacketNotAccepted(CQmPacket& pkt,USHORT usClass);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\joinstat.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    joinstat.h

Abstract:

    Handle the case where workgroup machine join a domain, or domain
    machine leave the domain.

Author:

    Doron Juster  (DoronJ)
    Ilan Herbst   (ilanh)  20-Aug-2000

--*/

void HandleChangeOfJoinStatus();

void SetMachineForDomain();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\joinstat.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    joinstat.cpp

Abstract:

    Handle the case where workgroup machine join a domain, or domain
    machine leave the domain.

Author:		 

    Doron Juster  (DoronJ)
    Ilan  Herbst  (ilanh)  20-Aug-2000

--*/

#include "stdh.h"
#include <new.h>
#include <autoreln.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmerr.h>
#include <lmjoin.h>
#include "setup.h"
#include "cqmgr.h"
#include <adsiutil.h>
#include "..\ds\h\mqdsname.h"
#include "mqexception.h"
#include "uniansi.h"
#include <adshlp.h>

#define SECURITY_WIN32
#include <security.h>

#include "joinstat.tmh"

BOOL  g_fQMIDChanged = FALSE;

extern HINSTANCE g_hInstance;
extern BOOL      g_fWorkGroupInstallation;

enum JoinStatus
{
    jsNoChange,
    jsChangeDomains,
    jsMoveToWorkgroup,
    jsJoinDomain
};

static WCHAR *s_FN=L"joinstat";

const TraceIdEntry QmJoinStat = L"QM JOIN STAT";

static 
void
GetQMIDRegistry(
	OUT GUID* pQmGuid
	)
/*++
Routine Description:
	Get current QMID from registry.

Arguments:
	pQmGuid - [out] pointer to the QM GUID

Returned Value:
	None

--*/
{
	DWORD dwValueType = REG_BINARY ;
	DWORD dwValueSize = sizeof(GUID);

	LONG rc = GetFalconKeyValue(
					MSMQ_QMID_REGNAME,
					&dwValueType,
					pQmGuid,
					&dwValueSize
					);

	DBG_USED(rc);

	ASSERT(rc == ERROR_SUCCESS);
}


static 
LONG
GetMachineDomainRegistry(
	OUT LPWSTR pwszDomainName,
	IN OUT DWORD* pdwSize
	)
/*++
Routine Description:
	Get MachineDomain from MACHINE_DOMAIN registry.

Arguments:
	pwszDomainName - pointer to domain string buffer
	pdwSize - pointer to buffer length

Returned Value:
	None

--*/
{
    DWORD dwType = REG_SZ;
    LONG res = GetFalconKeyValue( 
					MSMQ_MACHINE_DOMAIN_REGNAME,
					&dwType,
					(PVOID) pwszDomainName,
					pdwSize 
					);
	return res;
}


static 
void
SetMachineDomainRegistry(
	IN LPCWSTR pwszDomainName
	)
/*++
Routine Description:
	Set new domain in MACHINE_DOMAIN registry

Arguments:
	pwszDomainName - pointer to new domain string

Returned Value:
	None

--*/
{
    DWORD dwType = REG_SZ;
    DWORD dwSize = (wcslen(pwszDomainName) + 1) * sizeof(WCHAR);

    LONG res = SetFalconKeyValue( 
					MSMQ_MACHINE_DOMAIN_REGNAME,
					&dwType,
					pwszDomainName,
					&dwSize 
					);

    ASSERT(res == ERROR_SUCCESS);
	DBG_USED(res);

	TrTRACE(QmJoinStat, "Set registry setup\\MachineDomain = %ls", pwszDomainName);
}


static 
LONG
GetMachineDNRegistry(
	OUT LPWSTR pwszComputerDN,
	IN OUT DWORD* pdwSize
	)
/*++
Routine Description:
	Get ComputerDN from MACHINE_DN registry.

	Note: we are using this function also to get MachineDN length
	by passing pwszComputerDN == NULL.
	in that case the return value of GetFalconKeyValue will not be ERROR_SUCCESS.

Arguments:
	pwszComputerDN - pointer to ComputerDN string
	pdwSize - pointer to buffer length

Returned Value:
	GetFalconKeyValue result

--*/
{
    DWORD  dwType = REG_SZ;

    LONG res = GetFalconKeyValue( 
					MSMQ_MACHINE_DN_REGNAME,
					&dwType,
					pwszComputerDN,
					pdwSize 
					);
	return res;
}


static 
void
SetMachineDNRegistry(
	IN LPCWSTR pwszComputerDN,
	IN ULONG  uLen
	)
/*++
Routine Description:
	Set new ComputerDN in MACHINE_DN registry

Arguments:
	pwszComputerDN - pointer to new ComputerDN string
	uLen - string length

Returned Value:
	None

--*/
{
    DWORD  dwSize = uLen * sizeof(WCHAR);
    DWORD  dwType = REG_SZ;

    LONG res = SetFalconKeyValue( 
					MSMQ_MACHINE_DN_REGNAME,
					&dwType,
					pwszComputerDN,
					&dwSize 
					);

    ASSERT(res == ERROR_SUCCESS);
	DBG_USED(res);

	TrTRACE(QmJoinStat, "Set registry setup\\MachineDN = %ls", pwszComputerDN);
}


static 
void
SetWorkgroupRegistry(
	IN DWORD dwWorkgroupStatus
	)
/*++
Routine Description:
	Set Workgroup Status in registry

Arguments:
	dwWorkgroupStatus - [in] Workgroup Status Status value

Returned Value:
	None

--*/
{
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = REG_DWORD;

    LONG res = SetFalconKeyValue(
					MSMQ_WORKGROUP_REGNAME,
					&dwType,
					&dwWorkgroupStatus,
					&dwSize 
					);
    ASSERT(res == ERROR_SUCCESS);
	DBG_USED(res);

	TrTRACE(QmJoinStat, "Set registry Workgroup = %d", dwWorkgroupStatus);
}


static 
LONG
GetAlwaysWorkgroupRegistry(
	OUT DWORD* pdwAlwaysWorkgroup
	)
/*++
Routine Description:
	Get Always Workgroup from registry.

Arguments:
	pdwAlwaysWorkgroup - [out] pointer to Always Workgroup value

Returned Value:
	None

--*/
{
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = REG_DWORD;

    LONG res = GetFalconKeyValue( 
					MSMQ_ALWAYS_WORKGROUP_REGNAME,
					&dwType,
					pdwAlwaysWorkgroup,
					&dwSize 
					);

	return res;
}


static 
HRESULT 
GetMsmqGuidFromAD( 
	IN WCHAR          *pwszComputerDN,
	OUT GUID          *pGuid 
	)
/*++
Routine Description:
	Get guid of msmqConfiguration object from active directory
	that match the Computer distinguish name supplied in pwszComputerDN.

Arguments:
	pwszComputerDN - computer distinguish name
	pGuid - pointer to guid

Returned Value:
	MQ_OK, if successful, else error code.

--*/
{
    DWORD dwSize = wcslen(pwszComputerDN);
    dwSize += x_LdapMsmqConfigurationLen + 1;

    AP<WCHAR> pwszName = new WCHAR[dwSize];
    wcscpy(pwszName, x_LdapMsmqConfiguration);
    wcscat(pwszName, pwszComputerDN);

	TrTRACE(QmJoinStat, "configuration DN = %ls", pwszName);

	//
    // Bind to RootDSE to get configuration DN
    //
    R<IDirectoryObject> pDirObj = NULL;
    HRESULT hr = ADsOpenObject( 
					pwszName,
					NULL,
					NULL,
					ADS_SECURE_AUTHENTICATION,
					IID_IDirectoryObject,
					(void **)&pDirObj 
					);

    if (FAILED(hr))
    {
		TrWARNING(QmJoinStat, "Fail to Bind to RootDSE to get configuration DN, hr = 0x%x", hr);
        return LogHR(hr, s_FN, 40);
    }

	TrTRACE(QmJoinStat, "bind to msmq configuration DN = %ls", pwszName);

    QmpReportServiceProgress();

    LPWSTR  ppAttrNames[1] = {const_cast<LPWSTR> (x_AttrObjectGUID)};
    DWORD   dwAttrCount = 0;
    ADS_ATTR_INFO *padsAttr = NULL;

    hr = pDirObj->GetObjectAttributes( 
						ppAttrNames,
						(sizeof(ppAttrNames) / sizeof(ppAttrNames[0])),
						&padsAttr,
						&dwAttrCount 
						);

    ASSERT(SUCCEEDED(hr) && (dwAttrCount == 1));

    if (FAILED(hr))
    {
		TrERROR(QmJoinStat, "Fail to get QM Guid from AD, hr = 0x%x", hr);
        return LogHR(hr, s_FN, 50);
    }
    else if (dwAttrCount == 0)
    {
        ASSERT(!padsAttr) ;
        hr =  MQDS_OBJECT_NOT_FOUND;
    }
    else
    {
        ADS_ATTR_INFO adsInfo = padsAttr[0];
        hr = MQ_ERROR_ILLEGAL_PROPERTY_VT;

        ASSERT(adsInfo.dwADsType == ADSTYPE_OCTET_STRING);

        if (adsInfo.dwADsType == ADSTYPE_OCTET_STRING)
        {
            DWORD dwLength = adsInfo.pADsValues->OctetString.dwLength;
            ASSERT(dwLength == sizeof(GUID));

            if (dwLength == sizeof(GUID))
            {
                memcpy( 
					pGuid,
					adsInfo.pADsValues->OctetString.lpValue,
					dwLength 
					);

				TrTRACE(QmJoinStat, "GetMsmqGuidFromAD, QMGuid = %!guid!", pGuid);
				
				hr = MQ_OK;
            }
        }
    }

    if (padsAttr)
    {
        FreeADsMem(padsAttr);
    }

    QmpReportServiceProgress();
    return LogHR(hr, s_FN, 60);
}


static 
void 
GetComputerDN( 
	OUT WCHAR **ppwszComputerDN,
	OUT ULONG  *puLen 
	)
/*++
Routine Description:
	Get Computer Distinguish name.
	The function return the ComputerDN string and string length.
	the function throw bad_hresult() in case of errors

Arguments:
	ppwszComputerDN - pointer to computer distinguish name string
	puLen - pointer to computer distinguish name string length.

Returned Value:
	Normal terminatin if ok, else throw exception

--*/
{
	CCoInit cCoInit;
    HRESULT hr = cCoInit.CoInitialize();
    if (FAILED(hr))
    {
		TrERROR(QmJoinStat, "GetComputerDN: CoInitialize failed, hr = 0x%x", hr);
		LogHR(hr, s_FN, 300);
		throw bad_hresult(hr);
    }

    //
    // Get the DistinguishedName of the local computer.
    //
    *puLen = 0;
	BOOL fSuccess = false;
    for(DWORD Cnt = 0; Cnt < 60; Cnt++)
	{
		fSuccess = GetComputerObjectName( 
						NameFullyQualifiedDN,
						NULL,
						puLen 
						);

		if(GetLastError() != ERROR_NO_SUCH_DOMAIN)
			break;

		//
		// Retry in case of ERROR_NO_SUCH_DOMAIN
		// netlogon need more time. sleep 1 sec.
		//
		TrWARNING(QmJoinStat, "GetComputerObjectName failed with error ERROR_NO_SUCH_DOMAIN, Cnt = %d, sleeping 1 seconds and retry", Cnt);
		LogNTStatus(Cnt, s_FN, 305);
		QmpReportServiceProgress();
		Sleep(1000);
	}
	
	if (*puLen == 0)
	{
        DWORD gle = GetLastError();
		TrERROR(QmJoinStat, "GetComputerObjectName failed, error = 0x%x", gle);
		LogIllegalPoint(s_FN, 310);
		throw bad_hresult(HRESULT_FROM_WIN32(gle));
	}

    *ppwszComputerDN = new WCHAR[*puLen];

    fSuccess = GetComputerObjectName( 
					NameFullyQualifiedDN,
					*ppwszComputerDN,
					puLen
					);

	if(!fSuccess)
	{
        DWORD gle = GetLastError();
		TrERROR(QmJoinStat, "GetComputerObjectName failed, error = 0x%x", gle);
		LogIllegalPoint(s_FN, 320);
		throw bad_hresult(HRESULT_FROM_WIN32(gle));
	}
	
    QmpReportServiceProgress();
	TrTRACE(QmJoinStat, "ComputerDNName = %ls", *ppwszComputerDN);
}


void SetMachineForDomain()
/*++
Routine Description:
	Write ComputerDN (Computer Distinguish name) in MSMQ_MACHINE_DN_REGNAME registry.
	if the called GetComputerDN() failed, no update is done.

Arguments:
	None.

Returned Value:
	Normal terminatin if ok

--*/
{

    AP<WCHAR> pwszComputerDN;
    ULONG uLen = 0;

	try
	{
		//
		// throw bad_hresult() in case of errors
		//
		GetComputerDN(&pwszComputerDN, &uLen);
	}
	catch(bad_hresult&)
	{
		TrERROR(QmJoinStat, "SetMachineForDomain: GetComputerDN failed, got bad_hresult exception");
		LogIllegalPoint(s_FN, 330);
		return;
	}

	SetMachineDNRegistry(pwszComputerDN, uLen);
}


static 
void  
FailMoveDomain( 
	IN  LPCWSTR pwszCurrentDomainName,
	IN  LPCWSTR pwszPrevDomainName,
	IN  ULONG  uEventId 
	)
/*++
Routine Description:
	Report failed to move from one domain to another.

Arguments:
	pwszCurrentDomainName - pointer to current (new) domain string
	pwszPrevDomainName - pointer to previous domain string
	uEventId - event number

Returned Value:
	None

--*/
{
	TrERROR(QmJoinStat, "Failed To move from domain %ls to domain %ls", pwszPrevDomainName, pwszCurrentDomainName);

    TCHAR tBuf[256];

    _stprintf(tBuf, TEXT("%s, %s"), pwszPrevDomainName, pwszCurrentDomainName);
    REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL, uEventId, 1, tBuf));
    LogIllegalPoint(s_FN, 540);
}


static 
void  
SucceedMoveDomain( 
	IN  LPCWSTR pwszCurrentDomainName,
	IN  LPCWSTR pwszPrevDomainName,
	IN  ULONG  uEventId 
	)
/*++
Routine Description:
	write new domain to MACHINE_DOMAIN registry and
	Report success to move from one domain to another.

Arguments:
	pwszCurrentDomainName - pointer to current (new) domain string
	pwszPrevDomainName - pointer to previous domain string
	uEventId - event number

Returned Value:
	None

--*/
{
	TrTRACE(QmJoinStat, "Succeed To move from domain %ls to domain %ls", pwszPrevDomainName, pwszCurrentDomainName);

    if (uEventId != 0)
    {
        REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL, uEventId, 2, pwszCurrentDomainName, pwszPrevDomainName));
        LogIllegalPoint(s_FN, 550);
    }
}


static bool FindMsmqConfInOldDomain()    
/*++
Routine Description:
	Check if msmq configuration object is found in the old domain with the same GUID.
	If we find the object in the old domain we will use it and not create a new 
	msmq configuration object.

	Note: this function rely on the value in MSMQ_MACHINE_DN_REGNAME registry.
	SetMachineForDomain() change this value to the new MACHINE_DN after joining 
	the new domain. you must call this function before SetMachineForDomain() is called.

Arguments:
	None

Returned Value:
	true if msmq configuration object was found in the old domain with the same OM GUID.
	else false.

--*/
{
	//
    // Get old MACHINE_DN
	// Note this value must not be updated to the new MACHINE_DN
	// before calling this function
    //

    //
	// Get required buffer length
	//
	DWORD  dwSize = 0;
	GetMachineDNRegistry(NULL, &dwSize);

	if(dwSize == 0)
	{
		TrERROR(QmJoinStat, "CheckForMsmqConfInOldDomain: MACHINE_DN DwSize = 0");
		LogIllegalPoint(s_FN, 350);
		return false;
	}

    AP<WCHAR> pwszComputerDN = new WCHAR[dwSize];
	LONG res = GetMachineDNRegistry(pwszComputerDN, &dwSize);

    if (res != ERROR_SUCCESS)
	{
		TrERROR(QmJoinStat, "CheckForMsmqConfInOldDomain: Get MACHINE_DN from registry failed");
		LogNTStatus(res, s_FN, 360);
		return false;
	}

	TrTRACE(QmJoinStat, "CheckForMsmqConfInOldDomain: OLD MACHINE_DN = %ls", pwszComputerDN);

    CCoInit cCoInit;
    HRESULT hr = cCoInit.CoInitialize();
    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 370);
		TrERROR(QmJoinStat, "CheckForMsmqConfInOldDomain: CoInitialize failed, hr = 0x%x", hr);
		return false;
    }

    GUID msmqGuid;

    hr = GetMsmqGuidFromAD( 
				pwszComputerDN,
				&msmqGuid 
				);

    if (FAILED(hr))
	{
		TrTRACE(QmJoinStat, "CheckForMsmqConfInOldDomain: did not found msmq configuration object in old domain, hr = 0x%x", hr);
        LogHR(hr, s_FN, 380);
		return false;
	}

	ASSERT(("found msmq configuration object in old domain with different QMID", msmqGuid == *QueueMgr.GetQMGuid()));

    if (msmqGuid == *QueueMgr.GetQMGuid())
    {
		//
        // msmqConfiguration object in old domain.
        // We consider this a success and write name of new
        // domain in registry. we also suggest the user to
        // move the msmq tree to the new domain.
        //
		TrTRACE(QmJoinStat, "CheckForMsmqConfInOldDomain: found msmq configuration object in old domain with same QMID, MACHINE_DN = %ls", pwszComputerDN);
		return true;
	}

	//
	// ISSUE-2000/08/16-ilanh - If we get here 
	// we found msmqConfiguration object from the old domain with different Guid then QueueMgr
	// this will be caught in the ASSERT above.
	// We are in trouble since we will try to create a new one, if we don't want to use this one.
	//
	TrERROR(QmJoinStat, "CheckForMsmqConfInOldDomain: found msmq configuration object in old domain with different QMID, MACHINE_DN = %ls", pwszComputerDN);
	LogBOOL(FALSE, s_FN, 390);
	return false;
}
	

static void CreateNewMsmqConf()
/*++
Routine Description:
	Create New Msmq Configuration object in ActiveDirectory with new guid

	if failed the function throw bad_hresult.

Arguments:
	None

Returned Value:
	None

--*/
{

	HRESULT hr;
    try
    {
        //
        // Must be inside try/except, so we catch any failure and set
        // again the workgroup flag to TRUE.
        //
        hr = CreateTheConfigObj();

    }
    catch(...)
    {
		TrERROR(QmJoinStat, "CreateNewMsmqConf: got exception");
        hr = MQ_ERROR_CANNOT_JOIN_DOMAIN;
        LogIllegalPoint(s_FN, 80);
    }

	if(FAILED(hr))
	{
		TrERROR(QmJoinStat, "CreateNewMsmqConf: failed, hr = 0x%x", hr);
        LogHR(hr, s_FN, 400);
		throw bad_hresult(hr);
	}

	//
	// New Msmq Configuration object was created successfully
	//
	TrTRACE(QmJoinStat, "CreateNewMsmqConf: Msmq Configuration object was created successfully with new guid");

    QmpReportServiceProgress();

	//
	// New msmq configuration object was created and we have new guid.
	// CreateTheConfigObj() wrote the new value to QMID registry
	// so The new value is already in QMID registry.
	//

	GUID QMNewGuid;
	GetQMIDRegistry(&QMNewGuid);

	ASSERT(QMNewGuid != *QueueMgr.GetQMGuid());
	
	TrTRACE(QmJoinStat, "CreateNewMsmqConf: NewGuid = %!guid!", &QMNewGuid);

	hr = QueueMgr.SetQMGuid(&QMNewGuid);
	if(FAILED(hr))
	{
		TrERROR(QmJoinStat, "setting QM guid failed. The call to CQueueMgr::SetQMGuid failed with error, hr = 0x%x", hr);
        LogHR(hr, s_FN, 410);
		throw bad_hresult(hr);
	}


	TrTRACE(QmJoinStat, "Set QueueMgr QMGuid");

	//
	// This flag indicate we created a new msmq configuration object and have a New QMID
	// It will be used by the driver to covert the QMID in the restored packets
	//
	g_fQMIDChanged = TRUE;
}


static 
bool 
FindMsmqConfInNewDomain(
	LPCWSTR   pwszNetDomainName
	)
/*++
Routine Description:
	Check if we have the msmq configuration object in the new domain with the same Guid.
    If yes, then we can "join" the new domain.

	throw bad_hresult

Arguments:
	pwszNetDomainName - new domain name

Returned Value:
	true if msmq configuration object was found with the same GUID, false otherwise 

--*/
{
    //
    // Check if user run MoveTree and moved the msmqConfiguration object to
    // new domain.
	//
	// This function can throw exceptions bad_hresult.
	//
    AP<WCHAR> pwszComputerDN;
    ULONG uLen = 0;
    GetComputerDN(&pwszComputerDN, &uLen);

	TrTRACE(QmJoinStat, "FindMsmqConfInNewDomain: ComputerDN = %ls", pwszComputerDN);

    CCoInit cCoInit;
    HRESULT hr = cCoInit.CoInitialize();
    if (FAILED(hr))
    {
		TrERROR(QmJoinStat, "FindMsmqConfInNewDomain: CoInitialize failed, hr = 0x%x", hr);
        LogHR(hr, s_FN, 420);
		throw bad_hresult(hr);
    }

    GUID msmqGuid;

    hr = GetMsmqGuidFromAD( 
			pwszComputerDN,
			&msmqGuid 
			);

    if (FAILED(hr))
    {
		//
		// We didn't find the msmqConfiguration object in the new domain. 
		// We will try to look in the old domain.
		// or try to create it if not found in the old domain.
		//
		TrTRACE(QmJoinStat, "FindMsmqConfInNewDomain: did not found msmqConfiguration object in the new Domain");
        LogHR(hr, s_FN, 430);
		return false;
	}

	//
	// We have an msmqConfiguration object in the new domain - use it
	//
	TrTRACE(QmJoinStat, "FindMsmqConfInNewDomain: found msmqConfiguration, ComputerDN = %ls", pwszComputerDN);

	if (msmqGuid == *QueueMgr.GetQMGuid())
	{
		//
		// msmqConfiguration object moved to its new domain.
		// the user probably run MoveTree
		//
		TrTRACE(QmJoinStat, "FindMsmqConfInNewDomain: found msmqConfiguration object with same guid");
		return true;
	}

	ASSERT(msmqGuid != *QueueMgr.GetQMGuid());

	//
	// msmqConfiguration object was found in new domain with different guid. 
	// This may cause lot of problems for msmq, 
	// as routing (and maybe other functinoality) may be confused.
	// We will issue an event and throw which means we will be in workgroup.
	// until this msmqConfiguration object will be deleted.
	//
	TrERROR(QmJoinStat, "FindMsmqConfInNewDomain: found msmqConfiguration object with different guid");
	TrERROR(QmJoinStat, "QM GUID = " LOG_GUID_FMT, LOG_GUID(QueueMgr.GetQMGuid()));
	TrERROR(QmJoinStat, "msmq configuration guid = " LOG_GUID_FMT, LOG_GUID(&msmqGuid));
	LogHR(EVENT_JOIN_DOMAIN_OBJECT_EXIST, s_FN, 440);
    REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL, EVENT_JOIN_DOMAIN_OBJECT_EXIST, 1, pwszNetDomainName));
	throw bad_hresult(EVENT_JOIN_DOMAIN_OBJECT_EXIST);

}


static void SetMachineForWorkgroup()
/*++
Routine Description:
	set Workgroup flag and registry.

Arguments:
	None

Returned Value:
	None 

--*/
{
    //
    // Turn on workgroup flag.
    //
    g_fWorkGroupInstallation = TRUE;
	SetWorkgroupRegistry(g_fWorkGroupInstallation);
}


static
JoinStatus  
CheckIfJoinStatusChanged( 
	IN  NETSETUP_JOIN_STATUS status,
	IN  LPCWSTR   pwszNetDomainName,
	IN  LPCWSTR   pwszPrevDomainName
	)
/*++
Routine Description:
	Check if there where changes in Join Status.

Arguments:
	status - [in] Network join status
	pwszNetDomainName - [in] Net domain name (current machine domain)
	pwszPrevDomainName - [in] prev domain name

Returned Value:
	JoinStatus that hold the Join Status 
	(no change. move to workgroup, join domain, change domains)

--*/
{
    if (status != NetSetupDomainName)
    {
        //
        // Currently, machine in workgroup mode,  not in domain.
        //
        if (g_fWorkGroupInstallation)
        {
            //
            // No change. Was and still is in workgroup mode.
            //
			TrTRACE(QmJoinStat, "No change in JoinStatus, remain Workgroup");
            return jsNoChange;
        }
        else
        {
            //
            // Status changed. Domain machine leaved its domain.
            //
			TrTRACE(QmJoinStat, "detect change in JoinStatus: Move from Domain to Workgroup");
            return jsMoveToWorkgroup;
        }
    }

	//
    //  Currently, machine is in domain.
    //

    if (g_fWorkGroupInstallation)
	{
        //
        // workgroup machine joined a domain.
        //
		TrTRACE(QmJoinStat, "detect change in JoinStatus: Move from Workgroup to Domain %ls", pwszNetDomainName);
        return jsJoinDomain;
	}

    if ((CompareStringsNoCase(pwszPrevDomainName, pwszNetDomainName) == 0))
    {
        //
        // No change. Was and still is member of domain.
        //
		TrTRACE(QmJoinStat, "No change in JoinStatus, remain in domain %ls", pwszPrevDomainName);
        return jsNoChange;
    }

	//
	// if Prev Domain not available we are treating this as moving to a new domain.
	//
    // Status changed. Machine moved from one domain to another.
    //
	TrTRACE(QmJoinStat, "detect change in JoinStatus: Move from Domain %ls to Domain %ls", pwszPrevDomainName, pwszNetDomainName);
    return jsChangeDomains;
}


static
void
EndChangeDomains(
	IN  LPCWSTR   pwszNewDomainName,
	IN  LPCWSTR   pwszPrevDomainName
	)
/*++
Routine Description:
	End of change domain.
	Set MachineDN, MachineDomain registry to the new values.
	MsmqMoveDomain_OK event.

Arguments:
	pwszNewDomainName - [in] new domain name (current machine domain)
	pwszPrevDomainName - [in] prev domain name (current machine domain)

Returned Value:
	None

--*/
{
	SetMachineForDomain();
	SetMachineDomainRegistry(pwszNewDomainName);

	SucceedMoveDomain( 
		pwszNewDomainName,
		pwszPrevDomainName,
		MsmqMoveDomain_OK 
		);
}


static
void
EndJoinDomain(
	IN  LPCWSTR   pwszDomainName
	)
/*++
Routine Description:
	End of join domain operations.

Arguments:
	pwszDomainName - [in] Net domain name (current machine domain)

Returned Value:
	None

--*/
{
	//
	// Reset Workgroup registry and restore old list of MQIS servers.
	//
    g_fWorkGroupInstallation = FALSE;
	SetWorkgroupRegistry(g_fWorkGroupInstallation);
	
	//
	// Set MachineDN registry
	//
	SetMachineForDomain();

	//
	// Set MachineDomain registry
	//
	SetMachineDomainRegistry(pwszDomainName);

	REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL, JoinMsmqDomain_SUCCESS, 1, pwszDomainName));

	TrTRACE(QmJoinStat, "successfully join Domain %ls from workgroup", pwszDomainName);

}


static
void
ChangeDomains(
	IN  LPCWSTR   pwszNetDomainName,
	IN  LPCWSTR   pwszPrevDomainName
	)
/*++
Routine Description:
	Change between 2 domains.
	If failed throw bad_hresult or bad_win32_erorr

Arguments:
	pwszNetDomainName - [in] Net domain name (current machine domain)
	pwszPrevDomainName - [in] prev domain name

Returned Value:
	None

--*/
{
	bool fFound = FindMsmqConfInNewDomain(pwszNetDomainName);
	if(fFound)
	{
		//
		// Found msmqconfiguration object in the new domain
		// update registry, event
		//
		TrTRACE(QmJoinStat, "ChangeDomains: successfully change Domains, PrevDomain = %ls, NewDomain = %ls, existing msmq configuration", pwszPrevDomainName, pwszNetDomainName);

		EndChangeDomains(pwszNetDomainName, pwszPrevDomainName);

		return;
	}
	
    ASSERT(CompareStringsNoCase(pwszPrevDomainName, pwszNetDomainName) != 0);

	fFound = FindMsmqConfInOldDomain();
	if(fFound)
	{
		//
		// Found msmqconfiguration object in the old domain
		// We dont change MachineDNRegistry, MachineDomainRegistry
		// So next boot we will also try to ChangeDomain 
		// and we will also get this event, or if the user move msmqconfiguration object
		// we will update the registry.
		//
		TrTRACE(QmJoinStat, "ChangeDomains: successfully change Domains, PrevDomain = %ls, NewDomain = %ls, existing msmq configuration in old domain", pwszPrevDomainName, pwszNetDomainName);

		SucceedMoveDomain( 
			pwszNetDomainName,
			pwszPrevDomainName,
			MsmqNeedMoveTree_OK 
			);

		return;
	}

	//
	// Try to create new msmqconfiguration object.
	// we get here if we did not found the msmqconfiguration object in both domain:
	// new and old domain.
	//
	CreateNewMsmqConf();

	//
	// Create msmqconfiguration object in the new domain
	// update registry, event
	//
	TrTRACE(QmJoinStat, "ChangeDomains: successfully change Domains, PrevDomain = %ls, NewDomain = %ls, create new msmq configuration object", pwszPrevDomainName, pwszNetDomainName);

	EndChangeDomains(pwszNetDomainName, pwszPrevDomainName);
}


static
void
JoinDomain(
	IN  LPCWSTR   pwszNetDomainName,
	IN  LPCWSTR   pwszPrevDomainName
	)
/*++
Routine Description:
	Join domain from workgroup
	If failed throw bad_hresult or bad_win32_erorr

Arguments:
	pwszNetDomainName - [in] Net domain name (current machine domain)
	pwszPrevDomainName - [in] prev domain name

Returned Value:
	None

--*/
{

	bool fFound = FindMsmqConfInNewDomain(pwszNetDomainName);
	if(fFound)
	{
		//
		// Found msmqconfiguration object in the new domain
		// update registry, event
		//
		TrTRACE(QmJoinStat, "JoinDomain: successfully join Domain %ls from workgroup, existing msmq configuration", pwszNetDomainName);

		EndJoinDomain(pwszNetDomainName);

		return;
	}
	
    if((pwszPrevDomainName[0] != 0) 
		&& (CompareStringsNoCase(pwszPrevDomainName, pwszNetDomainName) != 0))
	{
		//
		// We have PrevDomain different than the new domain name try to find msmq configuration object there
		//
		TrTRACE(QmJoinStat, "JoinDomain: Old domain name exist and different PrevDomain = %ls", pwszPrevDomainName);
		fFound = FindMsmqConfInOldDomain();
	}

	if(fFound)
	{
		//
		// Found msmqconfiguration object in the old domain
		// We dont change MachineDNRegistry, MachineDomainRegistry
		// So next boot we will also try to ChangeDomain 
		// and we will also get this event, or if the user move msmqconfiguration object
		// we will update the registry.
		//
		// ISSUE - qmds, in UpdateDs - update MachineDNRegistry, we might need another registry
		// like MsmqConfObj
		//
		TrTRACE(QmJoinStat, "JoinDomain: successfully join Domain %ls from workgroup, existing msmq configuration in old domain %ls", pwszNetDomainName, pwszPrevDomainName);

		g_fWorkGroupInstallation = FALSE;
		SetWorkgroupRegistry(g_fWorkGroupInstallation);

		//
		// Event for the user to change msmqconfiguration object.
		//
		SucceedMoveDomain( 
			pwszNetDomainName,
			pwszPrevDomainName,
			MsmqNeedMoveTree_OK 
			);

		return;
	}

	//
	// Try to create new msmqconfiguration object.
	// we get here if we did not found the msmqconfiguration object in both domain:
	// new and old domain.
	//
	CreateNewMsmqConf();  

	TrTRACE(QmJoinStat, "JoinDomain: successfully join Domain %ls from workgroup, create new msmq configuration object", pwszNetDomainName);

	//
	// update registry, event
	//
	EndJoinDomain(pwszNetDomainName);
}


static
void
FailChangeDomains(
	IN  HRESULT  hr,
	IN  LPCWSTR   pwszNetDomainName,
	IN  LPCWSTR   pwszPrevDomainName
	)
/*++
Routine Description:
	Fail to change domains

Arguments:
	hr - [in] hresult
	pwszNetDomainName - [in] Net domain name (current machine domain)
	pwszPrevDomainName - [in] prev domain name

Returned Value:
	None

--*/
{
	TrERROR(QmJoinStat, "Failed to change domains from domain %ls to domain %ls, bad_hresult exception", pwszPrevDomainName, pwszNetDomainName);
	LogHR(hr, s_FN, 460);

	SetMachineForWorkgroup();


	if(hr == EVENT_JOIN_DOMAIN_OBJECT_EXIST)
	{
		TrERROR(QmJoinStat, "Failed To join domain %ls, msmq configuration object already exist in the new domain with different QM guid", pwszNetDomainName);
		return;
	}

	FailMoveDomain( 
		pwszNetDomainName,
		pwszPrevDomainName,
		MoveMsmqDomain_ERR 
		);
}

	
static 
void 
FailJoinDomain(
	HRESULT  hr,
	LPCWSTR   pwszNetDomainName
	)
/*++
Routine Description:
	Fail to join domain from workgroup

Arguments:
	hr - [in] hresult
	pwszNetDomainName - [in] Net domain name (the domain we tried to join)

Returned Value:
	None

--*/
{
	//
	// Let's remain in workgroup mode.
	//
	SetMachineForWorkgroup();

	LogHR(hr, s_FN, 480);

	if(hr == EVENT_JOIN_DOMAIN_OBJECT_EXIST)
	{
		TrERROR(QmJoinStat, "Failed To join domain %ls, msmq configuration object already exist in the new domain with different QM guid", pwszNetDomainName);
		return;
	}

	TCHAR tBuf[24];
	_stprintf(tBuf, TEXT("0x%x"), hr);
	REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL, JoinMsmqDomain_ERR, 2, pwszNetDomainName, tBuf));
	TrERROR(QmJoinStat, "Failed to join Domain, bad_hresult, hr = 0x%x", hr);
}


void HandleChangeOfJoinStatus()
/*++
Routine Description:
	Handle join status.
	This function check if there was change in join status.
	if detect a change perform the needed operations to comlete the change.

Arguments:
	None

Returned Value:
	None

--*/
{
#ifdef _DEBUG
    TCHAR tszFileName[MAX_PATH * 2];
    DWORD dwGet = GetModuleFileName( 
						g_hInstance,
						tszFileName,
						(MAX_PATH * 2) 
						);
    if (dwGet)
    {
        DWORD dwLen = lstrlen(tszFileName);
        lstrcpy(&tszFileName[ dwLen - 3 ], TEXT("ini"));

        UINT uiDbg = GetPrivateProfileInt( 
						TEXT("Debug"),
						TEXT("StopBeforeJoin"),
						0,
						tszFileName 
						);
        if (uiDbg)
        {
            ASSERT(0);
        }
    }
#endif

	TrRegisterComponent(&QmJoinStat, 1);

    if (g_fWorkGroupInstallation)
    {
        DWORD dwAlwaysWorkgroup = 0;
		LONG res = GetAlwaysWorkgroupRegistry(&dwAlwaysWorkgroup);

        if ((res == ERROR_SUCCESS) && (dwAlwaysWorkgroup == 1))
        {
            //
            // User wants to remain in ds-less mode, unconditioanlly.
            // We always respect user wishs !
            //
			TrTRACE(QmJoinStat, "Always WorkGroup!");
            return;
        }
    }

    //
    // Read join status.
    //
    PNETBUF<WCHAR> pwszNetDomainName = NULL;
    NETSETUP_JOIN_STATUS status = NetSetupUnknownStatus;

    NET_API_STATUS rc = NetGetJoinInformation( 
							NULL,
							&pwszNetDomainName,
							&status 
							);

    if (NERR_Success != rc)
    {
		TrERROR(QmJoinStat, "NetGetJoinInformation failed error = 0x%x", rc);
		LogNTStatus(rc, s_FN, 500);
        return;
    }

	TrTRACE(QmJoinStat, "NetGetJoinInformation: status = %d", status);
	TrTRACE(QmJoinStat, "NetDomainName = %ls", pwszNetDomainName);

    QmpReportServiceProgress();

	WCHAR wszPrevDomainName[256] = {0}; // name of domain from msmq registry.

	//
    //  Read previous domain name, to check if machine moved from one
    //  domain to another.
    //
    DWORD dwSize = 256;
	LONG res = GetMachineDomainRegistry(wszPrevDomainName, &dwSize);

    if (res != ERROR_SUCCESS)
    {
        //
        // Previous name not available.
        //
		TrWARNING(QmJoinStat, "Prev Domain name is not available");
        wszPrevDomainName[0] = 0;
    }

	TrTRACE(QmJoinStat, "PrevDomainName = %ls", wszPrevDomainName);
    
	
	JoinStatus JStatus = CheckIfJoinStatusChanged(
								status,
								pwszNetDomainName,
								wszPrevDomainName
								);

    switch(JStatus)
    {
        case jsNoChange:
            return;

        case jsMoveToWorkgroup:

			ASSERT(g_fWorkGroupInstallation == FALSE);
			ASSERT(status != NetSetupDomainName);

			//
			// Move from Domain To Workgroup
			//
			TrTRACE(QmJoinStat, "Moving from domain to workgroup");

			SetMachineForWorkgroup();

			REPORT_CATEGORY(LeaveMsmqDomain_SUCCESS, CATEGORY_KERNEL);
            return;

        case jsChangeDomains:

			ASSERT(g_fWorkGroupInstallation == FALSE);
			ASSERT(status == NetSetupDomainName);

			//
			// Change Domains
			//
			try
			{
				ChangeDomains(pwszNetDomainName, wszPrevDomainName);
				return;
			}
			catch(bad_hresult& exp)
			{
				FailChangeDomains(exp.error(), pwszNetDomainName, wszPrevDomainName);
				LogHR(exp.error(), s_FN, 510);
				return;
			}

        case jsJoinDomain:

			ASSERT(g_fWorkGroupInstallation);
			ASSERT(status == NetSetupDomainName);

			//
			// Join Domain from workgroup
			//
			try
			{
				JoinDomain(pwszNetDomainName, wszPrevDomainName);
				return;
			}
			catch(bad_hresult& exp)
			{
				FailJoinDomain(exp.error(), pwszNetDomainName);
				LogHR(exp.error(), s_FN, 520);
				return;
			}

		default:
			ASSERT(("should not get here", 0));
			return;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\license.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    license.cpp

Abstract:
    Handle licensing issues

Author:
    Doron Juster  (DoronJ)  04-May-1997   Created

--*/

#include "stdh.h"
#include "license.h"
#include "qmutil.h"

#include "license.tmh"

extern DWORD g_dwOperatingSystem;

static WCHAR *s_FN=L"license";

void AFXAPI DestructElements(ClientInfo ** ppClientInfo, int n)
{
    int i;
    for (i=0;i<n;i++)
	{
		delete [] (*ppClientInfo)->lpClientName;
        delete *ppClientInfo++;
	}
}


//
// global object which keep the licensing data.
//
CQMLicense  g_QMLicense ;

//
// CQMLicense::CQMLicense()
// constructor.
//
CQMLicense::CQMLicense()
{
 
	m_dwLastEventTime = 0;
}

//
// CQMLicense::~CQMLicense()
// destructor.
//
CQMLicense::~CQMLicense()
{
}

//
// CQMLicense::Init()
//
// Initialize the object.
// At present, read licensing data from registry.
// Future: read from license mechanism of NT.
//
HRESULT
CQMLicense::Init()
{
	if(OS_SERVER(g_dwOperatingSystem))
	{

		//
		// Read number of CALs for servers
		//
        //
        // NT4 has bug in licensing server when mode is per-server. So we
        // read the mode and number of cals. If mode is per-server then we
        // count the cals ourselves and do not use NT license apis.
        //
        m_fPerServer = FALSE ;

        HKEY  hKey ;
        LONG rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
             L"System\\CurrentControlSet\\Services\\LicenseInfo\\FilePrint",
                               0L,
                               KEY_READ,
                               &hKey);
        if (rc == ERROR_SUCCESS)
        {
            DWORD dwMode ;
            DWORD dwSize = sizeof(DWORD) ;
            DWORD dwType = REG_DWORD ;
            rc = RegQueryValueEx(hKey,
                                 L"Mode",
                                 NULL,
                                 &dwType,
                                 (BYTE*)&dwMode,
                                 &dwSize) ;
            if ((rc == ERROR_SUCCESS) && (dwMode == 1))
            {
                ASSERT(dwSize == sizeof(DWORD)) ;
                ASSERT(dwType == REG_DWORD) ;

                //
                // Per-server. read number of cals.
                //
                DWORD dwCals ;
                rc = RegQueryValueEx(hKey,
                                     L"ConcurrentLimit",
                                     NULL,
                                     &dwType,
                                     (BYTE*)&dwCals,
                                     &dwSize) ;
                if (rc == ERROR_SUCCESS)
                {
                    m_fPerServer = TRUE ;
                    m_dwPerServerCals = dwCals ;
                }
            }
        }
	}

    return MQ_OK ;
}

//
// CQMLicense::IncrementActiveConnections
//
//  Update the number of active session after creating a new session
//
//  This routine always increment a connection. Checking if it is legal to
//  increment the connections is done in NewConnectionAllowed
//
//
void
CQMLicense::IncrementActiveConnections(
    CONST GUID* pGuid,
    LPWSTR lpwUser,
    LPWSTR lpwClientName
    )
{
    CS lock(m_cs);

    ClientInfo * pClientInfo;

	//
	// If connection already counted, 
	// increment reference count and return
	//
    if (m_MapQMid2ClientInfo.Lookup(*pGuid, pClientInfo))
    {
        pClientInfo->dwRefCount++ ;

        DBGMSG((
            DBGMOD_NETSESSION,
            DBGLVL_TRACE,
            _T("License::Increment ref count of ") _T(LOG_GUID_FMT) _T(" to %d"),
            LOG_GUID(pGuid),
            pClientInfo->dwRefCount
            )) ;

	    return;
    }
    
    LS_HANDLE  lsHandle = (LS_HANDLE) -1 ;


    //
    // Consume a CAL on servers
    //
    if (OS_SERVER(g_dwOperatingSystem))
    {
        lsHandle = GetNTLicense(lpwUser) ;
    }

    //
    // Keep info of the new connection
    //
    pClientInfo = new ClientInfo;
    pClientInfo->hLicense = lsHandle ;
    pClientInfo->dwRefCount = 1;
    if (lpwClientName)
    {
        pClientInfo->dwNameLength = wcslen( lpwClientName) + 1;
        pClientInfo->lpClientName = new WCHAR[ pClientInfo->dwNameLength];
        wcscpy( pClientInfo->lpClientName, lpwClientName);
    }
    else
    {
        pClientInfo->dwNameLength = 0 ;
        pClientInfo->lpClientName = NULL ;
    }
    
    m_MapQMid2ClientInfo[ *pGuid ] = pClientInfo ;
    
    DBGMSG((DBGMOD_NETSESSION, DBGLVL_TRACE,
        _T("License::Add computer ") _T(LOG_GUID_FMT), LOG_GUID(pGuid)));
    
    DBGMSG((DBGMOD_NETSESSION, DBGLVL_TRACE,
        _T("License::Current number of license connections incremented to %d"),
        m_MapQMid2ClientInfo.GetCount())) ;
}

//
// CQMLicense::DecrementActiveConnections
//
//  Update the number of active connections after closing a session or
//  closing a connection with dependent client / remote-read clients.
//
void
CQMLicense::DecrementActiveConnections(CONST GUID *pGuid)
{
    CS lock(m_cs);
    ClientInfo * pClientInfo ;
    
    if (m_MapQMid2ClientInfo.Lookup(*pGuid, pClientInfo))
    {
        pClientInfo->dwRefCount--;
        DBGMSG((DBGMOD_NETSESSION, DBGLVL_TRACE,
            _T("License::Decrement ref count of ") _T(LOG_GUID_FMT) _T(" to %d"),
                LOG_GUID(pGuid), pClientInfo->dwRefCount)) ;

        if (pClientInfo->dwRefCount <= 0)
        {
            //
            // release the license
            //
            if (((LONG_PTR) pClientInfo->hLicense) >= 0)
            {
                ReleaseNTLicense(pClientInfo->hLicense) ;
            }

            //
            // remove client from license list.
            //
            BOOL f = m_MapQMid2ClientInfo.RemoveKey(*pGuid) ;
            ASSERT(f) ;
			DBG_USED(f);
        }
    }


    DBGMSG((DBGMOD_NETSESSION, DBGLVL_TRACE,
        _T("License::Current number of license connections is %d"),
                m_MapQMid2ClientInfo.GetCount())) ;
};

//****************************************************************
//
//  void CQMLicense::ReleaseNTLicense(LS_HANDLE hLicense)
//
//****************************************************************

void CQMLicense::ReleaseNTLicense(LS_HANDLE hLicense)
{
    if (m_fPerServer)
    {
        m_dwPerServerCals++ ;
    }
    else
    {
        ASSERT((long) hLicense >= 0) ;

        //
        // On NT4 Per-Seat licencing does not function as expected
        //
        // LS_STATUS_CODE status = NtLSFreeHandle(hLicense) ;
    }
}

//****************************************************************
//
//  LS_HANDLE  CQMLicense::GetNTLicense(LPWSTR lpwUser)
//
//  Request a CAL from the NT license manager
//
//****************************************************************

LS_HANDLE CQMLicense::GetNTLicense(LPWSTR lpwUser)
{
    if (m_fPerServer)
    {
        if (m_dwPerServerCals <= 0)
            return ((LS_HANDLE)((LONG_PTR)-1));

        m_dwPerServerCals--;
        return 0;
    }

#if 0
    //
    // On NT4 Per-Seat licencing does not function as expected.
    // So we disable the check alltogether.
    //

    NT_LS_DATA lsData;
    lsData.DataType =  NT_LS_USER_NAME ;
    lsData.Data = lpwUser ;
    lsData.IsAdmin = FALSE ; //TRUE ;
    
    LS_HANDLE lsHandle;
    LS_STATUS_CODE rc;
    rc = NtLicenseRequest( L"MSMQ",
                           L"1",
                           &lsHandle,
                           &lsData );

    if(rc != LS_SUCCESS)
    {
        //
        // We do not enforce Licensing on Per-Seat configuration
        // The administrator will be notified for Licenses shortage.
        //
        return 0;
    }
#endif // 0

    return 0;
}

//
// CQMLicense::IsClientRPCAccessAllowed(GUID *pGuid)
//
// Check if remote machine can access (as far as license is concerned) the
// server.
//
BOOL
CQMLicense::IsClientRPCAccessAllowed(GUID     *pGuid,
                                     LPWSTR   lpwClientName,
                                     handle_t hBind)
{
    if (!NewConnectionAllowed(TRUE, pGuid))
    {
        return LogBOOL(FALSE, s_FN, 10);
    }

    LPWSTR  lpwUser = L"" ;

    //
    // First obtain user name from rpc binding handle. This is necessary
    // only on WinNT, for the license api.
    //
    RPC_STATUS status;
    RPC_AUTHZ_HANDLE Privs = 0;
    SEC_WINNT_AUTH_IDENTITY *pAuth = NULL;


    status = RpcBindingInqAuthClient(hBind,
                                     &Privs,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL) ;
    if (status == RPC_S_OK)
    {
       if (Privs)
       {
           pAuth = (SEC_WINNT_AUTH_IDENTITY *) &Privs;
           lpwUser = pAuth->User ;
       }
    }

    IncrementActiveConnections(pGuid,
                               lpwUser,
                               lpwClientName) ;
    return TRUE ;
}

//
// CQMLicense::NewConnectionAllowed()
//
// Check if this machine can create a new connection with another
// machine.
// Params: fWorkstation - we want a connection with NTW or Win95
//         pGuid is the QM Guid of the other machine.
//
BOOL
CQMLicense::NewConnectionAllowed(BOOL   fWorkstation,
                                 GUID * pGuid )
{
    CS lock(m_cs);
      
    
	//
	// Always allow a connection to a server
	//
	if(fWorkstation == FALSE)
		return(TRUE);


    if (!pGuid)
    {
       ASSERT(0) ;
       return LogBOOL(FALSE, s_FN, 20);
	}

#ifdef _DEBUG
    if (memcmp(pGuid, &GUID_NULL, sizeof(GUID)) == 0)
    {
       ASSERT(0) ;
    }
#endif

    CS Lock(m_cs) ;

    ClientInfo * pClientInfo;

	//
	// We already have a connection - so we allow a new one
	//
    if (m_MapQMid2ClientInfo.Lookup(*pGuid, pClientInfo))
		return(TRUE);

        
	//
	// If we are NTW or Win95, count max number of allowed connections
	//
    if(!OS_SERVER(g_dwOperatingSystem))
		 return(m_MapQMid2ClientInfo.GetCount() < DEFAULT_FALCON_MAX_SESSIONS_WKS);


	//
	// We are a server, so check if enough CALs
	//	
	// 1. Consume a CAL
	//
	LS_HANDLE  lsHandle = GetNTLicense(L"") ;

	if ((LONG_PTR) lsHandle < 0)
	{
		DisplayEvent(SERVER_NO_MORE_CALS);
		return(FALSE);
	}
    //
    // 2. And free it, if you have it. It will be re-aqcuired when the number
    // of connections is incremented.
    //
    ReleaseNTLicense(lsHandle) ;


	//
	// On NTE and NTS, no limits on number of connections.
	//
	return(TRUE);

}

//
// CQMLicense::GetClientNames()
//
// Allocates and returns the buffer with all client names
//  (to be released by caller)
void CQMLicense::GetClientNames(ClientNames **ppNames)
{
    CS Lock(m_cs) ;

    ClientInfo *pClientInfo;
    GUID        guid;

    // Calculate buffer length
    ULONG    len = sizeof(ClientNames);

    POSITION posInList = m_MapQMid2ClientInfo.GetStartPosition();
    while (posInList != NULL)
    {
        m_MapQMid2ClientInfo.GetNextAssoc(posInList, guid, pClientInfo);
        len += (pClientInfo->dwNameLength * sizeof(WCHAR));
    }

    // Allocate memory
    *ppNames = (ClientNames *) new UCHAR[len];

    // Fill the buffer
    (*ppNames)->cbBufLen  = len;
    WCHAR *pw = &(*ppNames)->rwName[0];

    ULONG ulCount = 0 ;
    posInList = m_MapQMid2ClientInfo.GetStartPosition();
    while (posInList != NULL)
    {
        m_MapQMid2ClientInfo.GetNextAssoc(posInList, guid, pClientInfo);
        if (pClientInfo->dwNameLength > 0)
        {
            CopyMemory(pw,
                       pClientInfo->lpClientName,
                       pClientInfo->dwNameLength * sizeof(WCHAR));
            pw += pClientInfo->dwNameLength;
            ulCount++ ;
        }
    }
    (*ppNames)->cbClients = ulCount ;
    ASSERT((int)ulCount <= m_MapQMid2ClientInfo.GetCount());
}


//
// Display an event in the event log file, in case 
// of a licensing error.
//
void CQMLicense::DisplayEvent(DWORD dwFailedError)
{
	DWORD t1;

	//
	// Get current time, and check that
	// last event was added more than 1hour ago.
	// (works correctly when GetTickCount wrap around)
	//
	t1 = GetTickCount();
	if(t1 - m_dwLastEventTime > 60 * 60 * 1000)
	{
		m_dwLastEventTime = t1;
		REPORT_CATEGORY(dwFailedError, CATEGORY_KERNEL);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\license.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    license.h

Abstract:
    Handle licensing issues
    1. Number of clients allowed.
    2. ...

Author:
    Doron Juster  (DoronJ)  04-May-1997   Created

--*/

#ifndef  __LICENSE_H_
#define  __LICENSE_H_

#include "cqmgr.h"
#include "admcomnd.h"
EXTERN_C
{
#include "ntlsapi.h"
}

typedef struct _ClientInfo {
	DWORD		dwRefCount;
    LS_HANDLE   hLicense;
	DWORD		dwNameLength;
	LPWSTR		lpClientName;
} ClientInfo;

class  CQMLicense
{
   public:
      CQMLicense() ;
      ~CQMLicense() ;

      HRESULT  Init() ;

      BOOL     NewConnectionAllowed(BOOL, GUID *);
      void     IncrementActiveConnections(CONST GUID *, LPWSTR, LPWSTR);
      void     DecrementActiveConnections(CONST GUID *);
      void     GetClientNames(ClientNames **ppNames);

      BOOL      IsClientRPCAccessAllowed(GUID *   pGuid,
                                         LPWSTR   lpClientName,
                                         handle_t hBind) ;

   private:
	  void		DisplayEvent(DWORD dwFailedError);

      BOOL      m_fPerServer ; // TRUE if licensing mode is per-server.
      DWORD     m_dwPerServerCals ;

      LS_HANDLE GetNTLicense(LPWSTR lpwUser) ;
      void      ReleaseNTLicense(LS_HANDLE hLicense) ;

      CMap<GUID, const GUID&, ClientInfo *, ClientInfo*&>
                                                 m_MapQMid2ClientInfo ;


      CCriticalSection m_cs ;
	  DWORD			   m_dwLastEventTime;
} ;


extern CQMLicense  g_QMLicense ;

#endif //  __LICENSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\list.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    list.h

Abstract:
    List and List::Iterator.
    An intrusive double linked list and iterator template

Author:
    Erez Haba (erezh) 13-Aug-95

Revision History:

--*/

/*++

  DESCRIPTION:
    List is defined as a circular doubble linked list. With actions
    to insert and remove entries.

       List
      +-----+   +-----+ +-----+ +-----+ +-----+ +-----+
      |     |<--|     | |     | |     | |     | |     |
      | head|   | data| | data| | data| | data| | data|
      |     |-->|     | |     | |     | |     | |     |
      +-----+   +-----+ +-----+ +-----+ +-----+ +-----+

                      Linked list diagram

    An iteration is defined for the list using the member type named
    Iterator. To declater an interator variable, use full qualified
    name. e.g., List<T>::Iterator. An iterator variable is analogous
    to type T pointer. Dereference '*' and arrow '->' operators are
    overloaded for this type so you can (allmost) freely use it as a
    T pointer.

      Example:

        for(List<T>::Iterator p = list.begin(); p != list.end(); ++p)
        {
            p->doSomeThing();
        }
--*/

#ifndef _LIST_H
#define _LIST_H

//---------------------------------------------------------
//
//  class List
//
//---------------------------------------------------------
template<class T, int Offset = FIELD_OFFSET(T, m_link)>
class List {
private:
    LIST_ENTRY m_head;
    int m_count;

public:
    class Iterator;

public:
    List(void);
   ~List(void);

    void insertBefore(Iterator it, T* pItem);
    void insert(T* pItem);
    void remove(T* pItem);

    bool isempty(void) const;
    int getcount() const;

    T* peekhead(void) const;
    T* peektail(void) const;

    T* gethead(void);
    T* gettail(void);

    Iterator begin() const;
    const Iterator end() const;

public:
    static void RemoveEntry(LIST_ENTRY*);
    static LIST_ENTRY* Item2Entry(T*);
    static T* Entry2Item(LIST_ENTRY*);

public:

    //
    // class List<T, Offset>::Iterator
    //
    class Iterator {
    private:
        LIST_ENTRY* m_current;

    public:
        explicit Iterator(LIST_ENTRY* pEntry) :
            m_current(pEntry)
        {
        }

        Iterator& operator++()
        {
            m_current = m_current->Flink;
            return *this;
        }

        Iterator& operator--()
        {
            m_current = m_current->Blink;
            return *this;
        }

        T& operator*() const
        {
            return (*List<T, Offset>::Entry2Item(m_current));
        }

        T* operator->() const
        {
            return (&**this);
        }

        bool operator==(const Iterator& i) const
        {
            return (m_current == i.m_current);
        }

        bool operator!=(const Iterator& i) const
        {
            return (!(*this == i));
        }
    };
    //
    // end class Iterator decleration
    //
};


//---------------------------------------------------------
//
//  IMPLEMENTATION
//
//---------------------------------------------------------
template<class T, int Offset>
inline List<T, Offset>::List(void)
{
    m_count = 0;
    m_head.Flink = m_head.Blink = &m_head;
}


template<class T, int Offset>
inline List<T, Offset>::~List(void)
{
    ASSERT(isempty());
}


template<class T, int Offset>
inline void List<T, Offset>::RemoveEntry(LIST_ENTRY* pEntry)
{
    LIST_ENTRY* Blink = pEntry->Blink;
    LIST_ENTRY* Flink = pEntry->Flink;

    Blink->Flink = Flink;
    Flink->Blink = Blink;

    #ifdef _DEBUG
        pEntry->Flink = pEntry->Blink = 0;
    #endif
}


template<class T, int Offset>
inline LIST_ENTRY* List<T, Offset>::Item2Entry(T* t)
{
    return ((LIST_ENTRY*)(PVOID)((PCHAR)t + Offset));
}


template<class T, int Offset>
inline T* List<T, Offset>::Entry2Item(LIST_ENTRY* l)
{
    return ((T*)(PVOID)((PCHAR)l - Offset));
}


template<class T, int Offset>
inline void List<T, Offset>::insertBefore(Iterator it, T* item)
{
    LIST_ENTRY* pEntry = Item2Entry(item);
    LIST_ENTRY* pInsertBeforEntry = Item2Entry(&(*it));
                       
	pEntry->Flink = pInsertBeforEntry;
	pEntry->Blink = pInsertBeforEntry->Blink;
	pInsertBeforEntry->Blink->Flink = pEntry;
	pInsertBeforEntry->Blink = pEntry;

    ++m_count;
}

template<class T, int Offset>
inline void List<T, Offset>::insert(T* item)
{
    LIST_ENTRY* pEntry = Item2Entry(item);

    pEntry->Flink = &m_head;
    pEntry->Blink = m_head.Blink;

    m_head.Blink->Flink = pEntry;
    m_head.Blink = pEntry;

    ++m_count;
}                                


template<class T, int Offset>
inline void List<T, Offset>::remove(T* item)
{
    LIST_ENTRY* pEntry = Item2Entry(item);
    RemoveEntry(pEntry);

    --m_count;
}


template<class T, int Offset>
inline bool List<T, Offset>::isempty(void) const
{
    return (m_head.Flink == &m_head);
}

template<class T, int Offset>
inline int List<T, Offset>::getcount(void) const
{
    return m_count;
}

template<class T, int Offset>
inline T* List<T, Offset>::peekhead() const
{
    return (isempty() ? 0 : Entry2Item(m_head.Flink));
}


template<class T, int Offset>
inline T* List<T, Offset>::peektail() const
{
    return (isempty() ? 0 : Entry2Item(m_head.Blink));
}


template<class T, int Offset>
inline T* List<T, Offset>::gethead()
{
    if(isempty())
        return 0;

    LIST_ENTRY* pEntry = m_head.Flink;
    RemoveEntry(pEntry);

    --m_count;
    
    return Entry2Item(pEntry);
}


template<class T, int Offset>
inline T* List<T, Offset>::gettail()
{
    if(isempty())
        return 0;

    LIST_ENTRY* pEntry = m_head.Blink;
    RemoveEntry(pEntry);

    --m_count;

    return Entry2Item(pEntry);
}


template<class T, int Offset>
inline List<T, Offset>::Iterator List<T, Offset>::begin() const
{
    return Iterator(m_head.Flink);
}


template<class T, int Offset>
inline const List<T, Offset>::Iterator List<T, Offset>::end() const
{
    return Iterator(const_cast<LIST_ENTRY*>(&m_head));
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\lms.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    lms.h

Abstract:
    Local Message Storage

Author:
    Erez Haba (erezh) 7-May-97

--*/

#ifndef _LMS_H_
#define _LMS_H_

void QMStorePacket(CBaseHeader* pBase, PVOID pCookie, PVOID pPool, ULONG ulSize);

#endif // _LMS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\lms.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    lms.cpp

Abstract:
    Local Message Storage

Author:
    Erez Haba (erezh) 7-May-97

--*/

#include "stdh.h"
#include "heap.h"
#include "ph.h"
#include "ac.h"
#include <Ex.h>

#include "lms.tmh"

static WCHAR *s_FN=L"lms";

#define PAGE_SIZE 0x1000
#define PAGE_ALLIGN_DN(p) ((PCHAR)(((ULONG_PTR)(p)) & ~((ULONG_PTR)(PAGE_SIZE-1))))
#define PAGE_ALLIGN_UP(p) ((PCHAR)((((ULONG_PTR)(p)) + (PAGE_SIZE-1)) & ~((ULONG_PTR)(PAGE_SIZE-1))))

template <class T>
inline T* value_type(const T*) { return (T*)(0); }

template <class T>
inline ptrdiff_t* distance_type(const T*) { return (ptrdiff_t*)(0); }

//
//  External linkage
//
extern HANDLE g_hAc;

//
//  Forwards
//
void WINAPI FlushPackets(EXOVERLAPPED*);


#if 0
static int DbgPrint(const char* format, ...)
{
    char buffer[1024];

    va_list va;
    va_start(va, format);
    int x = vsprintf(buffer, format, va);
    va_end(va);
    OutputDebugStringA(buffer);
    return x;
}
#endif


//---------------------------------------------------------
//
//  class CPacketFlusher
//
//---------------------------------------------------------
class CPacketFlusher {

    struct CNode;

    enum { max_entries = 1024 };

public:
    void add(CBaseHeader* pBase, PVOID pCookie, PVOID pPool, ULONG ulSize);
    BOOL isempty() const;
    BOOL isfull() const;
    void reset();
    void flush();

    CPacketFlusher& operator=(const CPacketFlusher& other);

private:
    PCHAR get_batch_end(PCHAR pEnd, PVOID pPool);
    const CNode& first() const;
    void pop();
    BOOL flush_batch(PCHAR pStart, PCHAR pEnd);
    HRESULT flush_all();
    void notify(int nEntries, HRESULT rc);

private:

    struct CNode {
    public:
        CNode() {}
        CNode(CBaseHeader* base, PVOID pool, ULONG ulSize, int index) :
            m_base(base), m_pool(pool), m_size(ulSize), m_index(index) {}

        CBaseHeader* base() const
        {
            return m_base;
        }

        PVOID pool() const
        {
            return m_pool;
        }

		ULONG size() const
		{
			return m_size;
		}

    public:
        inline static BOOL greater(const CNode& x, const CNode& y)
        {
			if(x.m_base == y.m_base)
				return(x.m_index > y.m_index);
	
	        return (x.m_base > y.m_base);
        }

    private:
        CBaseHeader* m_base;
        PVOID m_pool;
		ULONG m_size;
		int	  m_index;
    };

private:
    PVOID m_cookies[max_entries];
    CNode m_entries[max_entries];
    int m_nEntries;

};


inline void CPacketFlusher::add(CBaseHeader* pBase, PVOID pCookie, PVOID pPool, ULONG ulSize)
{
    m_cookies[m_nEntries] = pCookie;
    m_entries[m_nEntries] = CNode(pBase, pPool, ulSize, m_nEntries);
    ++m_nEntries;
    push_heap(m_entries, m_entries + m_nEntries, CNode::greater);
}

inline BOOL CPacketFlusher::isempty() const
{
    return (m_nEntries == 0);
}

inline BOOL CPacketFlusher::isfull() const
{
    return (m_nEntries == max_entries);
}

CPacketFlusher& CPacketFlusher::operator=(const CPacketFlusher& o)
{
    m_nEntries = o.m_nEntries;
    memcpy(m_cookies, o.m_cookies, m_nEntries * sizeof(m_cookies[0]));
    memcpy(m_entries, o.m_entries, m_nEntries * sizeof(m_entries[0]));
    return *this;
}

const CPacketFlusher::CNode& CPacketFlusher::first() const
{
    ASSERT(!isempty());
    return m_entries[0];
}

inline void CPacketFlusher::reset()
{
    m_nEntries = 0;
}

void CPacketFlusher::pop()
{
    ASSERT(!isempty());
    pop_heap(m_entries, m_entries + m_nEntries, CNode::greater);
    --m_nEntries;
}

inline PCHAR CPacketFlusher::get_batch_end(PCHAR pEnd, PVOID pPool)
{
    pEnd = PAGE_ALLIGN_UP(pEnd);

    while(!isempty())
    {
        CBaseHeader* pBase = first().base();
        PCHAR pStart = PAGE_ALLIGN_DN(pBase);

        if((pStart > pEnd) || (pPool != first().pool()))
        {
            break;
        }

        ULONG ulSize = first().size();
        pEnd = PAGE_ALLIGN_UP(reinterpret_cast<PCHAR>(pBase) + ulSize);
        pop();
    }

    return pEnd;
}

inline BOOL CPacketFlusher::flush_batch(PCHAR pStart, PCHAR pEnd)
{
    //////DbgPrint("...0x%p bytes at 0x%p - 0x%p\n", pEnd - pStart, pStart, pEnd);
    //DbgPrint("...0x%p bytes at 0x%p. touch=%d...", pEnd - pStart, pStart, GetTickCount());
    //DbgPrint("flush=%d...", GetTickCount());

    BOOL fSuccess = FlushViewOfFile(
                        pStart,
                        pEnd - pStart
                        );

    //DbgPrint("done=%d\n", GetTickCount());
    return LogBOOL(fSuccess, s_FN, 5);
}

inline HRESULT CPacketFlusher::flush_all()
{
    while(!isempty())
    {
        CBaseHeader* pBase = first().base();
        PVOID pPool = first().pool();
		ULONG ulSize = first().size();
		pop();
        PCHAR pStart = PAGE_ALLIGN_DN(pBase);
        PCHAR pEnd = get_batch_end(reinterpret_cast<PCHAR>(pBase) + ulSize, pPool);

        if(!flush_batch(pStart, pEnd))
        {
            return LogHR(MQ_ERROR_MESSAGE_STORAGE_FAILED, s_FN, 10);
        }
    }

     return MQ_OK;
}


inline void CPacketFlusher::notify(int nEntries, HRESULT rc)
{
    HRESULT hr = ACStorageCompleted(
        g_hAc,
        nEntries,
        m_cookies,
        rc
        );

    LogHR(hr, s_FN, 119);
}

inline void CPacketFlusher::flush()
{
    int nEntries = m_nEntries;
    /////DbgPrint("flushing %4d entries tick=%d\n", nEntries, GetTickCount());
    notify(nEntries, flush_all());
    //DbgPrint("end flush tick=%d\n", GetTickCount());
}


static CCriticalSection s_pending_lock(CCriticalSection::xAllocateSpinCount);
static CPacketFlusher   s_pending;
static CPacketFlusher   s_flushing;

static bool s_flush_scheduled = false;
static EXOVERLAPPED  s_flush_ov(FlushPackets, FlushPackets) ;

void QMStorePacket(CBaseHeader* pBase, PVOID pCookie, PVOID pPool, ULONG ulSize)
{
	for(;;)
	{
		{
			CS lock(s_pending_lock);
			if(!s_pending.isfull())
			{
				s_pending.add(pBase, pCookie, pPool, ulSize);

				if(s_flush_scheduled)
				{
					//
					// Flushing already scheduled.
					//
					return;
				}

				s_flush_scheduled = true;
				ExPostRequest(&s_flush_ov);
				return;
			}
		}

		//
		// Pending list is full. Wait until flush thread read the messages
		//
		Sleep(1);
	}
}


void WINAPI FlushPackets(EXOVERLAPPED*)
{
	ASSERT(("Flush should be scheduled", s_flush_scheduled));
	for(;;)
	{
		{
			CS lock(s_pending_lock);
			if(s_pending.isempty())
			{
				s_flush_scheduled = false;
				return;
			}
			
		    s_flushing = s_pending;
		    s_pending.reset();
		}
			
		s_flushing.flush();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\localsend.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    LocalSend.h

Abstract:

    QM Local Send Packet Creation processing.

Author:

    Shai Kariv (shaik) 31-Oct-2000

Revision History:

--*/


#pragma once

#ifndef _QM_LOCAL_SEND_H_
#define _QM_LOCAL_SEND_H_

#include <ph.h>


void 
QMpCreatePacket(
    CBaseHeader * pBase, 
    CPacket *     pDriverPacket,
    bool          fProtocolSrmp
    );


#endif // _QM_LOCAL_SEND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\localsecurity.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    LocalSecurity.h

Abstract:
    functions for local security 

Author:
    Ilan Herbst (ilanh) 19-Nov-2000

Environment:
    Platform-independent,

--*/

#ifndef _LOCALSECURITY_H_
#define _LOCALSECURITY_H_


HRESULT
QMpHandlePacketSecurity(
    CQmPacket *   pQmPkt,
    USHORT *      pAck,
    bool          fProtocolSrmp
    );


#endif // _LOCALSECURITY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\localsend.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    LocalSend.cpp

Abstract:

    QM Local Send Pakcet Creation processing.

Author:

    Shai Kariv (shaik) 31-Oct-2000

Revision History: 

--*/

#include "stdh.h"
#include <ac.h>
#include <Tr.h>
#include <ref.h>
#include <Ex.h>
#include <qmpkt.h>
#include "LocalSend.h"
#include "LocalSecurity.h"
#include "LocalSrmp.h"

#include "LocalSend.tmh"

extern HANDLE g_hAc;

static WCHAR *s_FN=L"localsend";

class CCreatePacketOv : public EXOVERLAPPED
{
public:

    CCreatePacketOv(
        EXOVERLAPPED::COMPLETION_ROUTINE pfnCompletionRoutine,
        CBaseHeader *                    pBase,
        CPacket *                        pDriverPacket,
        bool                             fProtocolSrmp
        ) :
        EXOVERLAPPED(pfnCompletionRoutine, pfnCompletionRoutine),
        m_pBase(pBase),
        m_pDriverPacket(pDriverPacket),
        m_fProtocolSrmp(fProtocolSrmp)
    {
    }

public:

    CBaseHeader * m_pBase;
    CPacket *     m_pDriverPacket;
    bool          m_fProtocolSrmp;

}; // class CCreatePacketOv


static
void
QMpCompleteHandleCreatePacket(
    CPacket *    pOriginalDriverPacket,
    CPacket *    pNewDriverPacket,
    HRESULT      status,
    USHORT       ack
    )
{
	//
	// If ack is set, status must be MQ_OK.
	//
	ASSERT(ack == 0 || SUCCEEDED(status));

    HRESULT hr = ACCreatePacketCompleted(
                     g_hAc,
                     pOriginalDriverPacket,
                     pNewDriverPacket,
                     status,
                     ack
                     );

	UNREFERENCED_PARAMETER(hr);

} // QMpCompleteHandleCreatePacket


static
void
WINAPI
QMpHandleCreatePacket(
    EXOVERLAPPED * pov
    )
{
	CCreatePacketOv * pCreatePacketOv = static_cast<CCreatePacketOv*> (pov);
    ASSERT(SUCCEEDED(pCreatePacketOv->GetStatus()));

    //
    // Get the context from the overlapped and deallocate the overlapped
    //
    CQmPacket QmPkt(pCreatePacketOv->m_pBase, pCreatePacketOv->m_pDriverPacket);
    bool fProtocolSrmp = pCreatePacketOv->m_fProtocolSrmp;
    delete pCreatePacketOv;

	if(!fProtocolSrmp)
	{
		//
		// Do authentication/decryption. If ack is set, status must be MQ_OK.
		//
	    USHORT ack = 0;
		HRESULT hr = QMpHandlePacketSecurity(&QmPkt, &ack, false);
		ASSERT(ack == 0 || SUCCEEDED(hr));

		//
		// Give the results to AC
		//
		QMpCompleteHandleCreatePacket(QmPkt.GetPointerToDriverPacket(), NULL, hr, ack);
		return;
	}

	//
    // Do SRMP serialization. Create a new packet if needed (AC will free old one).
    //
	ASSERT(fProtocolSrmp);
    CQmPacket * pQmPkt = &QmPkt;

    HRESULT hr = QMpHandlePacketSrmp(&pQmPkt);
	if(FAILED(hr))
	{
		//
		// Give the results to AC
		//
		ASSERT(pQmPkt == &QmPkt);
		QMpCompleteHandleCreatePacket(QmPkt.GetPointerToDriverPacket(), NULL, hr, 0);
		return;
	}
    
    CBaseHeader * pBase = pQmPkt->GetPointerToPacket();
    CPacketInfo * ppi = reinterpret_cast<CPacketInfo*>(pBase) - 1;
    ppi->InSourceMachine(TRUE);
    
	//
	// Srmp success path always create new packet
	//
	ASSERT(pQmPkt != &QmPkt);
    CPacket * pNewDriverPacket = pQmPkt->GetPointerToDriverPacket();

	//
	// Do authentication/decryption. If ack is set, status must be MQ_OK.
	//
	USHORT ack = 0;
	hr = QMpHandlePacketSecurity(pQmPkt, &ack, true);
	ASSERT(ack == 0 || SUCCEEDED(hr));
	if(FAILED(hr))
	{
		//
		// Fail in packet security, need to free the new packet that was created by Srmp.
		// The driver don't expect new packet in case of failure. only in case of ack.
		//
		ACFreePacket(g_hAc, pNewDriverPacket);
	    QMpCompleteHandleCreatePacket(QmPkt.GetPointerToDriverPacket(), NULL, hr, 0);
		return;
	}

    //
    // Give the results to AC
    //
    QMpCompleteHandleCreatePacket(QmPkt.GetPointerToDriverPacket(), pNewDriverPacket, hr, ack);

} // QMpHandleCreatePacket


void 
QMpCreatePacket(
    CBaseHeader * pBase, 
    CPacket *     pDriverPacket,
    bool          fProtocolSrmp
    )
{
    try
    {
        //
        // Handle the create packet request in a different thread, since it is lengthy.
        //
        P<CCreatePacketOv> pov = new CCreatePacketOv(QMpHandleCreatePacket, pBase, pDriverPacket, fProtocolSrmp);
        pov->SetStatus(STATUS_SUCCESS);
        ExPostRequest(pov);
        pov.detach();
    }
    catch (const std::exception&)
    {
        //
        // Failed to handle the create packet request, no resources.
        //
        QMpCompleteHandleCreatePacket(pDriverPacket, NULL, MQ_ERROR_INSUFFICIENT_RESOURCES, false);
        LogIllegalPoint(s_FN, 10);
    }
} // QMpCreatePacket
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\localsrmp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    LocalSrmp.h

Abstract:

    QM Local Send SRMP properties serialization.

Author:

    Shai Kariv (shaik) 21-Nov-2000

Revision History:

--*/


#pragma once

#ifndef _QM_LOCAL_SRMP_H_
#define _QM_LOCAL_SRMP_H_

#include <qmpkt.h>


HRESULT
QMpHandlePacketSrmp(
    CQmPacket * * ppQmPkt
    )
    throw();


#endif // _QM_LOCAL_SRMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\localsecurity.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    LocalSecurity.cpp

Abstract:
    functions for local security 

Author:
    Ilan Herbst (ilanh) 19-Nov-2000

Environment:
    Platform-independent,

--*/

#include "stdh.h"

#include "qmsecutl.h"
#include "HttpAuthr.h"

#include "LocalSecurity.tmh"

static WCHAR *s_FN=L"localsecurity";

static
HRESULT
QMpHandlePacketAuthentication(
    CQmPacket *   pQmPkt
    )
/*++

Routine Description:

	Handle Local queue receiving side authentication.

Arguments:

    pQmPkt     - Pointer to the packet to authenticate.

Return Value:

	HRESULT

--*/
{
    if ((pQmPkt->GetSenderIDType() == MQMSG_SENDERID_TYPE_QM) || 
		((pQmPkt->GetSignatureSize() == 0) && (pQmPkt->GetSignatureMqfSize() == 0)))
    {
		//
		// The sender is the QM or no signatures
		//
        return MQ_OK;
    }

    return VerifySignature(pQmPkt);
} // QMpHandlePacketAuthentication


static
USHORT
QMpHandleHttpPacketAuthentication(
    CQmPacket *   pQmPkt
    )
/*++

Routine Description:

	Handle Local queue receiving side http authentication.

Arguments:

    pQmPkt     - Pointer to the packet to authenticate.

Return Value:

	HRESULT

--*/
{
    if ((pQmPkt->GetSenderIDType() == MQMSG_SENDERID_TYPE_QM) || (pQmPkt->GetSignatureSize() == 0))
    {
		//
		// The sender is the QM or no signatures
		//
        return MQMSG_CLASS_NORMAL;
    }

    R<CERTINFO> pCertInfo;
    return VerifyAuthenticationHttpMsg(pQmPkt, &pCertInfo.ref());
} // QMpHandleHttpPacketAuthentication


static
HRESULT
QMpHandlePacketDecryption(
    CQmPacket *   pQmPkt
    )
/*++

Routine Description:

	Handle Local queue receiving side decryption.

Arguments:

    pQmPkt     - Pointer to the original packet to decrypt.

Return Value:

	MQ_OK - The operation completed successfully in the sender's view.

    other - The operation failed, ppNewQmPkt does not point to new packet.

--*/
{
	if(!pQmPkt->IsEncrypted())
	{
		return MQ_OK;
	}

	return pQmPkt->Decrypt();

} // QMpHandlePacketDecryption


HRESULT
QMpHandlePacketSecurity(
    CQmPacket *   pQmPkt,
    USHORT *      pAck,
    bool          fProtocolSrmp
    )
/*++

Routine Description:

	Handle Local queue receiving side security.

Arguments:

    pQmPkt     - Pointer to the packet to authenticate/decrypt.

    pAck       - Pointer to ack class, on output. This field is non zero when
                 authentication/decryption fails and NACK should be issued. The
                 sender views it as success but the packet is revoked in AC.
                 If you set this field, return MQ_OK so that sender will view it
                 as success.

    fProtocolSrmp - Indicates whether the send is over SRMP protocol.

Return Value:

    MQ_OK - The operation completed successfully in the sender's view.
            If pAck is zero: security was handled OK, 
			If pAck is non zero, security checks failed and NACK should be issued, 

    other - The operation failed.

--*/
{
    (*pAck) = 0;

    try
    {
		if(fProtocolSrmp)
		{
			//
			// No encryption is allowed in http/multicast.
			//
			ASSERT(!pQmPkt->IsEncrypted());

			USHORT usClass = QMpHandleHttpPacketAuthentication(pQmPkt);
			if(MQCLASS_NACK(usClass))
			{
				*pAck = usClass;
				return MQ_OK;
			}
			return MQ_OK;
		}

		//
		// non-http message
		// First Decryption if needed
		// if decryption is done m_ulBodySize is updated (reduced)
		// but not m_ulAllocBodySize so no need to create a new packet
		//
        HRESULT hr = QMpHandlePacketDecryption(pQmPkt);
        if (FAILED(hr))
        {
            if (hr == MQ_ERROR_ENCRYPTION_PROVIDER_NOT_SUPPORTED)
            {
                *pAck = MQMSG_CLASS_NACK_UNSUPPORTED_CRYPTO_PROVIDER;
                return MQ_OK;
            }

            *pAck = MQMSG_CLASS_NACK_BAD_ENCRYPTION;
            return MQ_OK;
        }

        hr = QMpHandlePacketAuthentication(pQmPkt);
        if (FAILED(hr))
        {
            *pAck = MQMSG_CLASS_NACK_BAD_SIGNATURE;
            return MQ_OK;
        }

        return MQ_OK;

    }
    catch (const exception&)
    {
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 10);
    }

} // QMpHandlePacketSecurity
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\lqs.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    lqs.h

Abstract:
    Local Queue Store.

Author:
    Boaz Feldbaum (BoazF) 12-Feb-1997.

--*/

#ifndef _HLQS_H_
#define _HLQS_H_

//
// We need to allocate buffers for the file names that are larger than
// MAX_PATH this in order to be on the safe side. We need:
// 5 chars for the \LQS\
// 32 chars for the GUID
// 1 character for the dot
// 8 characters for the queue path name hash
//
#define MAX_PATH_PLUS_MARGIN            (MAX_PATH + 5+32+1+8)

typedef LPVOID HLQS;

HRESULT
LQSCreate(
    LPCWSTR pszQueuePath,
    const GUID *pguidQueue,
    DWORD cProps,
    PROPID aPropId[],
    PROPVARIANT aPropVar[],
    HLQS *phLQS
    );

HRESULT
LQSCreate(
    LPCWSTR pszQueuePath,
    DWORD dwQueueId,
    DWORD cProps,
    PROPID aPropId[],
    PROPVARIANT aPropVar[],
    HLQS *phLQS
    );

HRESULT
LQSSetProperties(
    HLQS hLQS,
    DWORD cProps,
    PROPID aPropId[],
    PROPVARIANT aPropVar[],
    BOOL fNewFile = FALSE
    );

HRESULT
LQSGetProperties(
    HLQS        hLQS,
    DWORD       cProps,
    PROPID      aPropId[],
    PROPVARIANT aPropVar[],
    BOOL        fCheckFile = FALSE
    );

HRESULT
LQSOpen(
    LPCWSTR pszQueuePath,
    HLQS *phLQS,
    LPWSTR pFilePath
    );

HRESULT
LQSOpen(
    DWORD dwQueueId,
    HLQS *phLQS,
    LPWSTR pFilePath
    );

HRESULT
LQSOpen(
    const GUID *pguidQueue,
    HLQS *phLQS,
    LPWSTR pFilePath
    );

HRESULT
LQSClose(
    HLQS hLQS
    );

#ifdef _WIN64
HRESULT
LQSCloseWithMappedHLQS(
    DWORD dwMappedHLQS
    );
#endif //_WIN64

HRESULT
LQSDelete(
    DWORD dwQueueId
    );

HRESULT
LQSDelete(
    const GUID *pguidQueue
    );

HRESULT
LQSGetIdentifier(
    HLQS hLQS,
    DWORD *pdwId
    );

HRESULT
LQSGetFirst(
    HLQS *hLQS,
    GUID *pguidQueue
    );

HRESULT
LQSGetFirst(
    HLQS *hLQS,
    DWORD *pdwQueueId
    );

HRESULT
LQSGetNext(
    HLQS hLQS,
    GUID *pguidQueue
    );

HRESULT
LQSGetNext(
    HLQS hLQS,
    DWORD *pdwQueueId
    );

#ifdef _WIN64
HRESULT
LQSGetFirstWithMappedHLQS(
    DWORD *pdwMappedHLQS,
    DWORD *pdwQueueId
    );

HRESULT
LQSGetNextWithMappedHLQS(
    DWORD dwMappedHLQS,
    DWORD *pdwQueueId
    );
#endif //_WIN64

HRESULT
LQSDelete(
    HLQS hLQS
	);

//
// Auto-free HLQS
//
class CHLQS
{
public:
    CHLQS(HLQS h =NULL) { m_h = h; };
    ~CHLQS() { if (m_h) LQSClose(m_h); };

public:
    CHLQS & operator =(HLQS h) { m_h = h; return(*this); };
    HLQS * operator &() { return &m_h; };
    operator HLQS() { return m_h; };

private:
    HLQS m_h;
};

#ifdef _WIN64
//
// Auto-free Mapped HLQS
//
class CMappedHLQS
{
public:
    CMappedHLQS(DWORD dw =NULL) { m_dw = dw; };
    ~CMappedHLQS() { if (m_dw) LQSCloseWithMappedHLQS(m_dw); };

public:
    CMappedHLQS & operator =(DWORD dw) { m_dw = dw; return(*this); };
    DWORD * operator &() { return &m_dw; };
    operator DWORD() { return m_dw; };

private:
    DWORD m_dw;
};
#endif //_WIN64


//
// LQS Migration routine
//
BOOL MigrateLQS();

void SetLqsUpdatedSD();


//
// Delete temporary files at startup
//
void
LQSCleanupTemporaryFiles();


#endif // _HLQS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\localsrmp.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    LocalSrmp.cpp

Abstract:

    QM Local Send SRMP properties serialization.

Author:

    Shai Kariv (shaik) 21-Nov-2000

Revision History:

--*/

#include "stdh.h"
#include <Tr.h>
#include <ref.h>
#include <Mp.h>
#include "LocalSrmp.h"
#include "HttpAccept.h"

#include "LocalSrmp.tmh"

extern HANDLE g_hAc;
extern LPTSTR g_szMachineName;

static WCHAR *s_FN=L"localsrmp";


HRESULT 
QMpHandlePacketSrmp(
    CQmPacket * * ppQmPkt
    )
    throw()
/*++

Routine Description:

	Handle serialization of SRMP properties for a packet sent to local queue.

    Algorithm:

    * Serialize the original packet to network representation.
    * Deserialize the network representation to a newly created packet.
    * Point ppQmPkt to the newly created packet.
    * Do not free the original packet, it is the caller responsibility.
    * On failure: cleanup after myself if needed and return failure code. Do not
      throw exceptions.

Arguments:

    ppQmPkt    - On input, pointer to pointer to original packet.
                 On output, pointer to pointer to original packet (if no-op),
                 or pointer to newly created packet.

Return Value:

    MQ_OK - The operation completed successfully, possibly no-op (no need for SRMP
            serialization: in this case no new packet is created).

    other - The operation failed.

--*/
{
    try
    {
        //
        // Serialize original packet to SRMP format
        //
        R<CSrmpRequestBuffers> srb = MpSerialize(**ppQmPkt, g_szMachineName, L"//LocalHost");

        //
        // Construct a network representation of the http header and body
        //
        const char * HttpHeader = srb->GetHttpHeader();
        ASSERT(HttpHeader != NULL);

        DWORD HttpBodySize = numeric_cast<DWORD>(srb->GetHttpBodyLength());
        AP<BYTE> HttpBody = srb->SerializeHttpBody();

        //
        // Build packet from the network representation buffers
        //
        QUEUE_FORMAT qf;
        (**ppQmPkt).GetDestinationQueue(&qf);
        *ppQmPkt = MpDeserialize(HttpHeader, HttpBodySize, HttpBody, &qf, true);
    }
    catch (const std::exception&)
    {
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 10);
    }

    return MQ_OK;

} // QMpHandlePacketSrmp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\main.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    main.cpp

Abstract:


Author:

    Raphi Renous (RaphiR)
    Uri Habusha (urih)

--*/
#include "stdh.h"
#include <new.h>
#include <eh.h>
#include <ev.h>
#include <lmcons.h>
#include <lmserver.h>
#include <mqexcept.h>
#include "_rstrct.h"
#include "qmres.h"
#include "sessmgr.h"
#include "perf.h"
#include <ac.h>
#include <qm.h>
#include "qmthrd.h"
#include "cqmgr.h"
#include "cqpriv.h"
#include "qmsecutl.h"
#include "admin.h"
#include "qmnotify.h"
#include <mqcrypt.h>
#include "xact.h"
#include "xactrm.h"
#include "xactin.h"
#include "xactout.h"
#include "xactlog.h"
#include "license.h"
#include "lms.h"
#include "mqcacert.h"
#include "cancel.h"
#include <mqsec.h>
#include "onhold.h"
#include "xactrm.h"
#include "xactmode.h"
#include "lqs.h"
#include "setup.h"
#include "mqsocket.h"
#include "uniansi.h"
#include "process.h"
#include "verstamp.h"
#include <mqnames.h>
#include "qmds.h"
#include "qmras.h"
#include "joinstat.h"
#include "_mqres.h"
//
// mqwin64.cpp may be included only once in a module
//
#include <mqwin64.cpp>

#include <mqstl.h>
#include <Tr.h>
#include <Cm.h>
#include <No.h>
#include <Mt.h>
#include <Mmt.h>
#include <St.h>
#include <Tm.h>
#include <Mtm.h>
#include <Rd.h>
#include <Ad.h>
#include <Xds.h>
#include <Mp.h>
#include <qal.h>
#include <Fn.h>
#include <Msm.h>
#include <Svc.h>

#include "main.tmh"

extern CSessionMgr SessionMgr;
extern CAdmin      Admin;
extern CNotify     g_NotificationHandler;
extern UINT        g_dwIPPort ;
extern BOOL        g_fNewLoggerData;

LPTSTR  g_szMachineName = NULL;
AP<WCHAR> g_szComputerDnsName;
BOOL    g_fQMRunMode = FALSE;
BOOL	g_bCluster_IP_BindAll=FALSE;

//
// Number of working threads.
//
DWORD  g_dwThreadsNo = 0 ;

//
// Holds the interval in milliseconds of progress report to SCM
//
DWORD g_ServiceProgressTime = MSMQ_PROGRESS_REPORT_TIME_DEFAULT;

//
// Holds the OS we are running on
//
DWORD   g_dwOperatingSystem;

//
// Holds MSMQ version for debugging purposes
//
CHAR *g_szMsmqBuildNo = VER_PRODUCTVERSION_STR;

static WCHAR *s_FN=L"main";


HANDLE    g_hAc = INVALID_HANDLE_VALUE;
HANDLE    g_hMachine = INVALID_HANDLE_VALUE;
CQGroup * g_pgroupNonactive;
CQGroup * g_pgroupWaiting;
//
// The g_pgroupNotValidated group hold all queues that where opened
// for send without MQIS validation. When MQIS becomes available the
// queue will be validated and moved to the Nonactive group.
//
CQGroup * g_pgroupNotValidated;

//
// The g_pgroupDisconnected group contains all the queues that are on hold
//
CQGroup* g_pgroupDisconnected;

//
//  WorkGroup Installed machine
//
BOOL g_fWorkGroupInstallation = FALSE;


WCHAR  g_wzDeviceName[ MAX_DEV_NAME_LEN ] = {0} ;

GUID CQueueMgr::m_guidQmQueue = {0};
bool CQueueMgr::m_fDSOnline = false;
bool CQueueMgr::m_fReportQM = false;
bool CQueueMgr::m_bMQSRouting = false;
bool CQueueMgr::m_bMQSDepClients = false;
LONG CQueueMgr::m_Connected = 0;
ULONG CQueueMgr::m_MessageSizeLimit = MSMQ_DEFAULT_MESSAGE_SIZE_LIMIT;

HINSTANCE g_hInstance;

//
// Get the mqutil resource only DLL handle first
//
HMODULE g_hResourceMod = MQGetResourceHandle();

HRESULT RecoverPackets();
static  void InitLogging();

// Flags for RM init coordination
extern unsigned int g_cMaxCalls;

extern MQUTIL_EXPORT CCancelRpc  g_CancelRpc;


bool StartRpcServer(void)
{
    //
    // Issuing RPC Listen ourselves.
    //
    // Note for WinNT: all our interfaces are registed as "AUTOLISTEN".
    // The only reason we need this call here is to enable Win95 (and w2k)
    // clients to call us. Otherwise, when Win95 call RpcBindingSetAuthInfo()
    // it will get a Busy (0x6bb) error.
    //
    // This initialization is needed also for w2k.
    // Otherwise RpcMgmtInqServerPrincName() will get a Busy (0x6bb) error.
    // ilanh 9-July-2000
    //

    RPC_STATUS status = RpcServerListen(
                            1, /* Min Call Threads */
                            g_cMaxCalls,
                            TRUE /* fDontWait */
                            );

    if (status == RPC_S_OK)
        return true;

    //
    // On WinNT, a listen may be issued by DTC, until they fix their
    // code to use RegisterIfEx() instead of RegisterIf().
    //
    if (status == RPC_S_ALREADY_LISTENING)
        return true;

    DBGMSG((DBGMOD_RPC, DBGLVL_ERROR, _TEXT("RpcServerListen failed. RPC status=%d"), status));

    ASSERT(("RPC failed on RpcServerListen", 0));
    LogRPCStatus(status, s_FN, 1213);
    return false;
}


/*======================================================

Function:        GetStoragePath

Description:     Get storage path for mmf

Arguments:       None

Return Value:    None

========================================================*/
BOOL GetStoragePath(PWSTR PathPointers[AC_PATH_COUNT])
{
    return (
        //
        //  This first one is a hack to verify that the registry key exists
        //
        GetRegistryStoragePath(FALCON_XACTFILE_PATH_REGNAME,        PathPointers[0], L"") &&

        GetRegistryStoragePath(MSMQ_STORE_RELIABLE_PATH_REGNAME,    PathPointers[0], L"\\r%07x.mq") &&
        GetRegistryStoragePath(MSMQ_STORE_PERSISTENT_PATH_REGNAME,  PathPointers[1], L"\\p%07x.mq") &&
        GetRegistryStoragePath(MSMQ_STORE_JOURNAL_PATH_REGNAME,     PathPointers[2], L"\\j%07x.mq") &&
        GetRegistryStoragePath(MSMQ_STORE_LOG_PATH_REGNAME,         PathPointers[3], L"\\l%07x.mq")
        );
}

/*======================================================

Function:        GetQueueAliasDir

Description:

Arguments:       None

Return Value:    Pointer to queue alias directory path.

Note : Currently - the queue alias directory is on %WINDIR%\SYSTEM32\MSMQ.
       In the future it will set by the setup in the registry
       and will be retrieved by  calling CQueueAliasCfg::GetQueueAliasDirectory()
========================================================*/
static WCHAR* GetQueueAliasPath(void)
{
    //
    // Get mapping directory according to mapping special registry key
    //
    RegEntry registry(0, MSMQ_MAPPING_PATH_REGNAME);
    AP<WCHAR> pRetStr;
    CmQueryValue(registry, &pRetStr);
    if(pRetStr.get() == NULL)
    {
        //
        // Get msmq root path and append to it "mapping" string
        //
        RegEntry registry(0, MSMQ_ROOT_PATH);
        CmQueryValue(registry, &pRetStr);
        if(pRetStr.get() == NULL)
        {
            ASSERT(("Could not find storage directory in registry",0));
            LogIllegalPoint(s_FN, 200);
            return NULL;
        }
        return newwcscat(pRetStr.get() , DIR_MSMQ_MAPPING);
    }
    return pRetStr.detach();
}



/*======================================================

Function:        ConnectToDriver

Description:     Gets all relevant registry data and connects to the AC driver

Arguments:       None

Return Value:    None

========================================================*/
static BOOL ConnectToDriver()
{
    WCHAR StoragePath[AC_PATH_COUNT][MAX_PATH];
    PWSTR StoragePathPointers[AC_PATH_COUNT];
    for(int i = 0; i < AC_PATH_COUNT; i++)
    {
        StoragePathPointers[i] = StoragePath[i];
    }

    if(GetStoragePath(StoragePathPointers) == FALSE)
    {
        DBGMSG((DBGMOD_ALL,DBGLVL_ERROR,
           TEXT("Storage path is invalid, look at registry StoreXXXPath")));
        return LogBOOL(FALSE, s_FN, 1010);
    }

    ULONG ulDefault = 0;
    ULONG MessageIdLow32 = 0;
    READ_REG_DWORD(
        MessageIdLow32,
        MSMQ_MESSAGE_ID_LOW_32_REGNAME,
        &ulDefault
        );

    ulDefault = 0;
    ULONG MessageIdHigh32 = 0;
    READ_REG_DWORD(
        MessageIdHigh32,
        MSMQ_MESSAGE_ID_HIGH_32_REGNAME,
        &ulDefault
        );

    ULONGLONG MessageId = MessageIdHigh32;
    MessageId = (MessageId << 32);
    MessageId += MessageIdLow32;

    ulDefault = 0;
    ULONG ulSeqID = 0;
    READ_REG_DWORD(
        ulSeqID,
        MSMQ_LAST_SEQID_REGNAME,
        &ulDefault
        );
    LONGLONG liSeqIdAtRestore = 0;
    ((LARGE_INTEGER*)&liSeqIdAtRestore)->HighPart = ulSeqID;


    ulDefault = FALCON_DEFAULT_XACT_V1_COMPATIBLE;
    ULONG ulCompMode = 0;
    READ_REG_DWORD(
        ulCompMode,
        FALCON_XACT_V1_COMPATIBLE_REGNAME,
        &ulDefault
        );

    HRESULT rc = ACConnect(
                    g_hMachine,
                    QueueMgr.GetQMGuid(),
                    StoragePathPointers,
                    MessageId,
                    QueueMgr.GetMessageSizeLimit(),
                    liSeqIdAtRestore,
                    (ulCompMode != 0)
                    );

    if (FAILED(rc))
    {
        LogHR(rc, s_FN, 1030);

        DBGMSG((DBGMOD_QM, DBGLVL_ERROR,
              L"QM failed to connect to the driver, rc=0x%x", rc));

        return(FALSE);
    }
    return TRUE;
}

//+----------------------------------
//
//  HRESULT  _InitFromRegistry()
//
//+----------------------------------

HRESULT  _InitFromRegistry()
{
    HRESULT hr = QueueMgr.SetQMGuid();
    if(FAILED(hr))
    {
        return LogHR(hr, s_FN, 10);
    }

    //
    // Set Machine service type ( read from registry )
    //
    hr = QueueMgr.SetMQSRouting();
    if(FAILED(hr))
    {
        return LogHR(hr, s_FN, 20);
    }

    hr = QueueMgr.SetMQSDepClients();
    if(FAILED(hr))
    {
        return LogHR(hr, s_FN, 40);
    }

    hr = QueueMgr.SetMessageSizeLimit();
    if(FAILED(hr))
    {
        return LogHR(hr, s_FN, 50);
    }

    return LogHR(hr, s_FN, 60);
}


BOOL
QmpInitializeInternal(
    DWORD dwSetupStatus
    )
/*++

Routine Description:

    Various initializations.

Arguments:

    dwSetupStatus - Indicates whether this is first time QM is running after setup.

Returned Value:

    TRUE  - Initialization completed successfully.
    FALSE - Initialization failed.

--*/
{
    HRESULT hr =  _InitFromRegistry() ;
    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 1050);
        return FALSE;
    }

    if ((dwSetupStatus == MSMQ_SETUP_UPGRADE_FROM_NT) ||
        (dwSetupStatus == MSMQ_SETUP_UPGRADE_FROM_WIN9X))
    {
        if (MQsspi_IsSecuredServerConn(FALSE /*fRefresh*/))
        {
            //
            // Convert certificates from IE 3.02 format.
            // Need to to it only once, after upgrade from
            // NT 4.
            //
            DBGMSG((DBGMOD_QM, DBGLVL_TRACE,
                            L"QM Converts certificates (after upgrade from Nt4/Qin98)"));
            MQsspi_UpdateCaConfig(TRUE);
            QmpReportServiceProgress();
        }

        CompleteServerUpgrade();
    }

    //
    // Delete temporary queue (LQS) files
    //
    LQSCleanupTemporaryFiles();

    //
    // Initialize driver related names.
    //
    HRESULT rc;
    rc = MQUGetAcName(g_wzDeviceName);
    if (FAILED(rc))
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, _T("The AC device driver name is too long.")));
        REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL, REGISTRY_FAILURE, 1, MSMQ_DRIVER_REGNAME));
        LogHR(rc, s_FN, 1070);
        return(FALSE);
    }

    //
    // Get AC handle
    //
    rc = ACCreateHandle(&g_hAc);
    if(FAILED(rc))
    {
        DBGMSG((DBGMOD_ALL, DBGLVL_ERROR, _T("Failed to get first MQAC handle %!status!"), rc));
        REPORT_CATEGORY(SERVICE_START_ERROR_CONNECT_AC, CATEGORY_KERNEL);
        LogHR(rc, s_FN, 1080);
        return(FALSE);
    }

    rc = ACCreateHandle(&g_hMachine);
    if(FAILED(rc))
    {
        DBGMSG((DBGMOD_ALL, DBGLVL_ERROR, _T("Failed to get MQAC connect handle %!status!"), rc));
        REPORT_CATEGORY(SERVICE_START_ERROR_CONNECT_AC, CATEGORY_KERNEL);
        LogHR(rc, s_FN, 1081);
        return(FALSE);
    }

    //
    // Connect to AC
    //
    if(!ConnectToDriver())
    {
        DBGMSG((DBGMOD_ALL, DBGLVL_ERROR, _T("INTERNAL ERROR: Unable to connect to the driver"))) ;
        REPORT_CATEGORY(SERVICE_START_ERROR_CONNECT_AC, CATEGORY_KERNEL);
        return LogBOOL(FALSE, s_FN, 1090);
    }

    //
    //  Update machine & journal queue quotas
    //
    DWORD dwQuota;
    DWORD dwJournalQuota;
    GetMachineQuotaCache(&dwQuota, &dwJournalQuota);

    rc = ACSetMachineProperties(g_hMachine, dwQuota);

    ASSERT(SUCCEEDED(rc));
    LogHR(rc, s_FN, 121);


    rc = ACSetQueueProperties(
            g_hMachine,
            FALSE,
            FALSE,
            MQ_PRIV_LEVEL_OPTIONAL,
            DEFAULT_Q_QUOTA,
            dwJournalQuota,
            0,
            FALSE,
            NULL,
            FALSE
            );

    ASSERT(SUCCEEDED(rc));
    LogHR(rc, s_FN, 117);

    //
    // Enable completion port notifications for this handle
    //
    ExAttachHandle(g_hAc);
    ExAttachHandle(g_hMachine);

    //
    // Create wait, Validate and Non-active groups.
    //
    g_pgroupNonactive = new CQGroup;
    g_pgroupNonactive->InitGroup(NULL, FALSE);

    g_pgroupWaiting = new CQGroup;
    g_pgroupWaiting->InitGroup(NULL, TRUE);

    g_pgroupNotValidated = new CQGroup;
    g_pgroupNotValidated->InitGroup(NULL, TRUE);

    g_pgroupDisconnected = new CQGroup;
    g_pgroupDisconnected->InitGroup(NULL, TRUE);

    return TRUE;

} // QmpInitializeInternal


//
// Following routines deal with recovery of logger and logged subsystems:
//   Resource Manager and Incoming Sequences
//

/*======================================================

 BOOL LoadOldStyleCheckpoint()

 Gets data from the old-style (pre-RC1 B3) checkpoint
 Then logger did not keep the checkpoint versions
 This code will work only once after the upgrade

======================================================*/
BOOL LoadOldStyleCheckpoint()
{
    DBGMSG((DBGMOD_QM, DBGLVL_TRACE,
                    L"QM Loads Old Style (pre-RC1B3) Checkpoint"));

    // Pre-init InSeqHash (create object, find and load last checkpoint)
    HRESULT hr = QMPreInitInSeqHash(0, piOldData);
    if (FAILED(hr))
    {
        REPORT_CATEGORY(QM_INSEQ_INIT_FAIL, CATEGORY_KERNEL) ;
        LogHR(hr, s_FN, 230);
        return FALSE;
    }

    // Pre-init Resource Manager (create RM, find and load last checkpoint)
    hr = QMPreInitResourceManager(0, piOldData);
    if (FAILED(hr))
    {
        REPORT_CATEGORY(QM_COULD_NOT_INIT_TRANS_FILE, CATEGORY_KERNEL) ;
        LogHR(hr, s_FN, 240);
        return FALSE;
    }

    // Initizlize logger in the old fashion
    hr = g_Logger.Init_Legacy();
    if (FAILED(hr))
    {
        REPORT_CATEGORY(MQ_ERROR_CANT_INIT_LOGGER, CATEGORY_KERNEL);
        LogHR(hr, s_FN, 250);
        return FALSE;
    }

    return TRUE;
}

/*======================================================

 BOOL LoadCheckpoint(ulNumChkpt)

 ulNumChkpt = # of the checkpoint from the end (1=last, 2=one before, etc.)

 Recovers all logged susbsystems from the specified checkpoint
 Logger keeps appropriate checkpoint versions in consolidation record

======================================================*/
BOOL LoadCheckpoint(ULONG ulNumChkpt)
{
    HRESULT  hr;
    ULONG    ulVerInSeq, ulVerXact;

    //
    // Initialize Logger, get proper versions
    //
    hr = g_Logger.Init(&ulVerInSeq, &ulVerXact, ulNumChkpt);
    if (FAILED(hr))
    {
        REPORT_CATEGORY(MQ_ERROR_CANT_INIT_LOGGER, CATEGORY_KERNEL);
        LogHR(hr, s_FN, 260);
        return FALSE;
    }

    //
    // PreInit In-Sequences hash table (crwate object, load checkpoint data)
    //
    hr = QMPreInitInSeqHash(ulVerInSeq, piNewData);
    if (FAILED(hr))
    {
        REPORT_CATEGORY(QM_INSEQ_INIT_FAIL, CATEGORY_KERNEL) ;
        LogHR(hr, s_FN, 270);
        return FALSE;
    }

    //
    // Pre-init Resource Manager (create RM, load xact data file)
    //
    hr = QMPreInitResourceManager(ulVerXact, piNewData);
    if (FAILED(hr))
    {
        REPORT_CATEGORY(QM_COULD_NOT_INIT_TRANS_FILE, CATEGORY_KERNEL) ;
        LogHR(hr, s_FN, 280);
        return FALSE;
    }

    return TRUE;
}

/*======================================================

 BOOL RecoverLoggedSubsystems()

 Initialization and recovery of all log-based subsystems

 Initializes log
 Reads consolidation record and gets versions of checkpoint files
 Reads these correct checkpoint files for all subsystems.
 Reads all post-checkpoint log records

 We may be in 3 valid situations:
   a. New logger data exists (usually)
   b. Old Logger data exists (after upgrade)- then use existing and continue in a new mode
   c. No logger data exists (after setup) - then create log file

======================================================*/
BOOL RecoverLoggedSubsystems()
{
    // Preinit logger and find out whether the log file exists
    BOOL fLogFileExists;
    HRESULT hr = g_Logger.PreInit(&fLogFileExists);
    if (FAILED(hr))
    {
       REPORT_CATEGORY(MQ_ERROR_CANT_INIT_LOGGER, CATEGORY_KERNEL);
       LogHR(hr, s_FN, 290);
       return(FALSE);
    }

    // Case a: New logger data exists - recover in a new fashion
    if (g_fNewLoggerData)
    {
        // ConfigureXactMode saw flag of new data in registry
        // Recover checkpoint data from the last checkpoint
        if (!LoadCheckpoint(1))
        {
            DBGMSG((DBGMOD_QM, DBGLVL_ERROR,
                            L"First Checkpoint failed to load"));

            LogIllegalPoint(s_FN, 300);
            // Try to use 2nd checkpoint from the end

            // Return to the initial state
            QMFinishResourceManager();
            QMFinishInSeqHash();
            g_Logger.Finish();

            // Recover checkpoint data from the 2nd last checkpoint
            if (!LoadCheckpoint(2))
            {
                DBGMSG((DBGMOD_QM, DBGLVL_ERROR,
                                L"Second Checkpoint failed to load"));
                REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL, CHECKPOINT_RECOVER_ERROR, 1, L"checkpoint")) ;
                LogIllegalPoint(s_FN, 310);
                return FALSE;
            }
        }
    }

    // Case b: Old logger data exists (after upgrade) - recover in an old fashion
    else if (fLogFileExists)
    {
        // Gets checkpoint data from the old-style checkpoint
        if (!LoadOldStyleCheckpoint())
        {
            REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL, CHECKPOINT_RECOVER_ERROR, 1, L"old checkpoint")) ;
            LogIllegalPoint(s_FN, 320);
            return FALSE;
        }
    }

    // Case c: No logger data existed - we've created log file already, creating objects
    else
    {
        // Pre-init InSeqHash (create CInSeqHash)
        HRESULT hr = QMPreInitInSeqHash(0, piNoData);
        if (FAILED(hr))
        {
            REPORT_CATEGORY(QM_INSEQ_INIT_FAIL, CATEGORY_KERNEL) ;
            LogHR(hr, s_FN, 330);
            return FALSE;
        }

        // Pre-init Resource Manager (create RM)
        hr = QMPreInitResourceManager(0, piNoData);
        if (FAILED(hr))
        {
            REPORT_CATEGORY(QM_COULD_NOT_INIT_TRANS_FILE, CATEGORY_KERNEL) ;
            LogHR(hr, s_FN, 340);
            return FALSE;
        }

    }

    // Now, do recover
    hr = g_Logger.Recover();
    if (FAILED(hr))
    {
       REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL, CHECKPOINT_RECOVER_ERROR, 1, L"log")) ;
       LogHR(hr, s_FN, 350);
       return(FALSE);
    }

    return TRUE;
}


static DWORD GetThreadPoolCount()
/*++

Routine Description:
  Calculate the number of threads required for the thread pool.

Arguments:
  None.

Returned Value:
  Number of threads desired from the thread pool.

--*/
{
    //
    // Read if there is a preset thread count in configuration store
    //
    DWORD dwThreadNo;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = REG_DWORD;
    LONG rc = GetFalconKeyValue(
                FALCON_QM_THREAD_NO_REGNAME,
                &dwType,
                &dwThreadNo,
                &dwSize
                );

    if (rc == ERROR_SUCCESS)
        return dwThreadNo;

    //
    // No thread count was configured, use default values base on operating
    // system functionality and processor count.
    //

    SYSTEM_INFO     SystemInfo;
    GetSystemInfo(&SystemInfo);
    DWORD nProcessors = SystemInfo.dwNumberOfProcessors;

    if (OS_SERVER(g_dwOperatingSystem))
    {
        return (nProcessors * 5 + 3);
    }

    return (nProcessors * 3);
}


static void QmpSetServiceProgressReportTime(void)
{
    const RegEntry reg(0, MSMQ_PROGRESS_REPORT_TIME_REGNAME, MSMQ_PROGRESS_REPORT_TIME_DEFAULT);
    CmQueryValue(reg, &g_ServiceProgressTime);
}


void QmpReportServiceProgress(void)
{
    SvcReportProgress(g_ServiceProgressTime);
}


void SetAssertBenign(void)
{
#ifdef _DEBUG
    DWORD AssertBenignValue = 0;
    const RegEntry reg(L"Debug", L"AssertBenign");
    CmQueryValue(reg, &AssertBenignValue);
    g_fAssertBenign = (AssertBenignValue != 0);
#endif
}


BOOL
QmpInitialize(
    LPCWSTR pwzServiceName
    )
{
    //
    // ISSUE-2000/10/01-erezh hack for cluster/winsock
    // Set the environment variable to filter out cluster
    // addresses.
    //
    if(IsLocalSystemCluster())
    {
        //
        // Cluster is installed and configured on this machine
        // Environment variable is set in the context of the node QM and
        // the virtual machine QM.
        //
        DBGMSG((DBGMOD_ALL, DBGLVL_ERROR,
            TEXT("Setting environement variable DnsFilterClusterIp=1 for cluster address filtering")));
        SetEnvironmentVariable(L"DnsFilterClusterIp", L"1");
    }

    QmpReportServiceProgress();

    //
    // Retrieve name of the machine (Always UNICODE)
    //
    DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;
    g_szMachineName = new WCHAR[dwSize];

    HRESULT res = GetComputerNameInternal(g_szMachineName, &dwSize);
    if(FAILED(res))
    {
        DBGMSG((DBGMOD_ALL, DBGLVL_ERROR, _T("Cannot retrieve computer name")));
        return LogBOOL(FALSE, s_FN, 1201);
    }

    ASSERT(("must have a service name", NULL != pwzServiceName));
    if (0 == CompareStringsNoCase(pwzServiceName, QM_DEFAULT_SERVICE_NAME))
    {
        //
        // Retrieve the DNS name of this computer ( in unicode).
        // Clustered QM does not have DNS name.
        //

        //
        // Get ComputerDns Size, ignore the returned error
        //
        dwSize = 0;
        GetComputerDnsNameInternal(NULL, &dwSize);

        g_szComputerDnsName = new WCHAR[dwSize];

        res = GetComputerDnsNameInternal(g_szComputerDnsName, &dwSize);
        if(FAILED(res))
        {
            DBGMSG((DBGMOD_ALL, DBGLVL_ERROR,
                TEXT("Cannot retrieve computer DNS name")));

            g_szComputerDnsName.free();
            //
            //  this can be a valid situation, where a computer doesn't
            //  have DNS name.
            //
        }
    }

    //
    //  Log down the time, place and version data
    //
    QmpReportServiceProgress();
    InitLogging();

    //
    // Registry section of the QM is based on the service name.
    // This allows multiple QMs on same machine. (ShaiK)
    //
    SetFalconServiceName(pwzServiceName);

    //
    // The very first time QM is running, it should finish
    // setup/upgrade work.
    //
    DWORD dwSetupStatus = MSMQ_SETUP_DONE;
    READ_REG_DWORD(dwSetupStatus, MSMQ_SETUP_STATUS_REGNAME, &dwSetupStatus);

    //
    // Read workgroup flag from registry.
    //
    READ_REG_DWORD( g_fWorkGroupInstallation,
                    MSMQ_WORKGROUP_REGNAME,
                   &g_fWorkGroupInstallation) ;


    //
    // Initialize registry, and debug tracing
    //
    CmInitialize(HKEY_LOCAL_MACHINE, GetFalconSectionName());
    SetAssertBenign();
    TrInitialize();
    EvInitialize(pwzServiceName);
    //
    //  Must be called before any COM & ADSI calls
    //
    g_CancelRpc.Init();

    QmpSetServiceProgressReportTime();

    if (dwSetupStatus != MSMQ_SETUP_FRESH_INSTALL)
    {
        QmpReportServiceProgress();

        //
        // Set QM GUID (read from registry). This guid is needed for algorithm
        // of join/move domain, so initialize it here, not in QmpInitializeInternal().
        //
        HRESULT hr =  _InitFromRegistry() ;
        if(FAILED(hr))
        {
            return LogBOOL(FALSE, s_FN, 1200);
        }

        if  (!IsLocalSystemCluster())
        {
            //
            // check if we were workgroup that join domain or domain machine
            // that leave its domain and return to workgroup. This function does
            // not return any value. We won't stop the msmq service just because
            // it failed. Do not call it immediately after setup.
            //
            //  For DS server do not check those transitions. The reason is DC
            //  in safe mode is actually in workgroup, and in this state we don't
            //  want to move to workgroup
            //
            //  On a Cluster system do not check those transitions.
            //  Multiple QMs can live, and some can fail to join, leaving the system
            //  unmanageable. Also Clustered QMs should be managed only by mqclus.dll .
            //
            HandleChangeOfJoinStatus() ;
        }
    } //if (dwSetupStatus != MSMQ_SETUP_FRESH_INSTALL)


    WSADATA     WSAData;
    BOOL        Success;

    //
    // Log what we did so far
    //
    DBGMSG((DBGMOD_QM, DBGLVL_TRACE, L"QM Service name: %ls", pwzServiceName));

    DBGMSG((DBGMOD_QM, DBGLVL_TRACE, L"QM Setup status: %x", dwSetupStatus));

    DBGMSG((DBGMOD_QM, DBGLVL_TRACE, L"QM Workgroup Installation: %x", g_fWorkGroupInstallation));

    DBGMSG((DBGMOD_QM, DBGLVL_TRACE, L"QM found computer name: %ls", g_szMachineName));

    DBGMSG((DBGMOD_QM, DBGLVL_TRACE, L"QM found computer DNS name: %ls", g_szComputerDnsName));
	

    if ((MSMQ_SETUP_UPGRADE_FROM_NT == dwSetupStatus) ||
        (MSMQ_SETUP_UPGRADE_FROM_WIN9X == dwSetupStatus))
    {
        QmpReportServiceProgress();

        DBGMSG((DBGMOD_QM, DBGLVL_TRACE, L"QM will now execute migration from NT4/Win98/Win2000: 0x%x", dwSetupStatus));

        MigrateLQS();

        MQsspi_MigrateSecureCommFlag() ;
    }

	if ((MSMQ_SETUP_UPGRADE_FROM_WIN9X == dwSetupStatus)  ||
         ((MSMQ_SETUP_FRESH_INSTALL == dwSetupStatus) &&
            g_fWorkGroupInstallation) )
    {
        //
        // Add machine security cache, if fresh install of workgroup or
        // upgrade of win9x.
        //
        QmpReportServiceProgress();
        DBGMSG((DBGMOD_QM, DBGLVL_TRACE, L"QM will now add machine security cache: 0x%x", dwSetupStatus));
        AddMachineSecurity() ;
    }

    //
    // Initialize the private-queues manager object.
    //
    res = g_QPrivate.PrivateQueueInit();

    DBGMSG((DBGMOD_QM, DBGLVL_TRACE,
                    L"QM Initialized the private-queues manager: 0x%x", res));


    //
    // Get the OS we are running on
    //
    g_dwOperatingSystem = MSMQGetOperatingSystem();

    DBGMSG((DBGMOD_QM, DBGLVL_TRACE,
                    L"QM detected the OS type: 0x%x", g_dwOperatingSystem));

    //
    // First time QM is running after fresh install,
    // it should create storage directories and
    // machine (system) queues.
    //
    if (MSMQ_SETUP_FRESH_INSTALL == dwSetupStatus)
    {
        try
        {
            QmpReportServiceProgress();

            DBGMSG((DBGMOD_QM, DBGLVL_TRACE, L"QM creates storage, machine queues, setups ADS (after fresh install)"));

            DeleteFalconKeyValue(FALCON_LOGDATA_CREATED_REGNAME);
            CreateStorageDirectories();
            CreateMachineQueues();
			SetLqsUpdatedSD();
            CompleteMsmqSetupInAds();
        }
        catch (const CSelfSetupException& err)
        {
            REPORT_CATEGORY(err.m_id, CATEGORY_KERNEL);
            LogIllegalPoint(s_FN, 181);
            return FALSE;
        }
    }

    //
    // Recreate all machine queues when upgrading from NT
    //
    if ((MSMQ_SETUP_UPGRADE_FROM_NT == dwSetupStatus) ||
        (MSMQ_SETUP_UPGRADE_FROM_WIN9X == dwSetupStatus))
    {
        DBGMSG((DBGMOD_QM, DBGLVL_TRACE, L"QM creates machine queues (after upgrade from NT)"));

        CreateMachineQueues();
    }

    QmpReportServiceProgress();
    QMSecurityInit();


    //
    // Initialize the Thread pool and Scheduler
    //
    QmpReportServiceProgress();
    g_dwThreadsNo = GetThreadPoolCount();
    ExInitialize(g_dwThreadsNo);

    DBGMSG((DBGMOD_QM, DBGLVL_INFO,_TEXT("Succeeded to Create %d QM thread."), g_dwThreadsNo));

    if(!g_fWorkGroupInstallation)
    {
        McInitialize();
    }
    MpInitialize();
    NoInitialize();
    MtInitialize();
    MmtInitialize();
    StInitialize();
    TmInitialize();
    MtmInitialize();
    XdsInitialize();
    XmlInitialize();
    CryInitialize();
    FnInitialize();
    MsmInitialize();

    QmpReportServiceProgress();
    QalInitialize(AP<WCHAR>(GetQueueAliasPath()));

    QmpReportServiceProgress();
    if(!QmpInitializeInternal(dwSetupStatus))
    {
       return LogBOOL(FALSE, s_FN, 1202);
    }

    //
    // Initialize the licensing manager object.
    //
    QmpReportServiceProgress();
    res = g_QMLicense.Init() ;
    if(FAILED(res))
    {
        DBGMSG((DBGMOD_ALL, DBGLVL_ERROR, _T("Cannot initialize licensing")));
        return LogBOOL(FALSE, s_FN, 1203);
    }

    //
    // Init QM Perf
    //
    if(!QMPrfInit())
    {
        REPORT_CATEGORY(QM_PERF_INIT_FAILED, CATEGORY_KERNEL);
        ASSERT_BENIGN(("Failed QMPrfInit(). Performace data will not be available.", FALSE));
    }

    //
    // Init the winsocket
    //
    int rc = WSAStartup(MAKEWORD(1,1), &WSAData);
    if(rc != 0)
    {
       REPORT_CATEGORY(SOCKET_INIT_FAIL, CATEGORY_KERNEL);
       return LogBOOL(FALSE, s_FN, 1204);
    }

    SessionMgr.Init();
    DBGMSG((DBGMOD_QM, DBGLVL_ERROR, _T("Successful WinSocket and SessionMgr initialization")));

    //
    // Activate the QM threads
    //
    Success = QueueMgr.InitQueueMgr();
    if (!Success)
    {
        return LogBOOL(FALSE, s_FN, 1205);
    }

    //
    // Init Admin command queue
    //
    HRESULT hr = Admin.Init();
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, _T("Failed to Init Admin command queue, hr=0x%x"), hr));
        REPORT_CATEGORY(QM_ADMIN_INIT_FAIL, CATEGORY_KERNEL) ;
    }

    //
    // Init Ordering command queue
    //
    QmpReportServiceProgress();
    hr = QMInitOrderQueue();
    if (FAILED(hr))
    {
        REPORT_CATEGORY(QM_ORDER_INIT_FAIL, CATEGORY_KERNEL) ;
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, _T("Failed to Init order queue, hr=0x%x"), hr));
        return LogBOOL(FALSE, s_FN, 1206);
    }

    //
    // Get fine-tuning parameters for xact mechanism
    //
    QMPreInitXact();

    //
    // Configure transactional mode
    //
    hr = ConfigureXactMode();
    if(FAILED(hr))
    {
        REPORT_CATEGORY(QM_CONFIGURE_XACT_MODE_FAIL, CATEGORY_KERNEL);
        return LogBOOL(FALSE, s_FN, 1207);
    }

    // Initilize log and recover all logged subsystems
    //   (including data recovery for InSeq and Xacts)
    //
    QmpReportServiceProgress();
    if(!RecoverLoggedSubsystems())
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, _T("Failed to recover logged subsystems")));
        return LogBOOL(FALSE, s_FN, 1208);
    }

    //
    // Recover all packets and transactions
    //
    QmpReportServiceProgress();
    hr = RecoverPackets();
    if (FAILED(hr))
    {
        REPORT_CATEGORY(QM_RECOVERY_FAIL, CATEGORY_KERNEL);
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, _T("Failed to recover packets, hr=0x%x"), hr));
        return LogBOOL(FALSE, s_FN, 1209);
    }

    //
    // Make checkpoint after the end of recovery
    //
    g_Logger.Activate();
    HANDLE h = CreateEvent(0, TRUE,FALSE, 0);
    if (h == NULL)
    {
        LogNTStatus(GetLastError(), s_FN, 171);
        ASSERT(0);
    }

    QmpReportServiceProgress();
    BOOL b =  g_Logger.MakeCheckpoint(h);
    if (!b)
    {
        CloseHandle(h);
        return LogBOOL(FALSE, s_FN, 191);
    }

    DWORD dwResult = WaitForSingleObject(h, INFINITE);
    if (dwResult != WAIT_OBJECT_0)
    {
        LogNTStatus(GetLastError(), s_FN, 192);
    }
    CloseHandle(h);

    //
    // Recovery completed successfully, reconfigure
    // transactional mode
    //
    ReconfigureXactMode();

    //
    // Initialize resource manager
    // We allready made a checkpoint therefore it is safe to report
    // to DTC that recovery is complete.
    //
    QmpReportServiceProgress();
    hr = QMInitResourceManager();
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, _T("Failed to initialize resource manager, hr=0x%x"), hr));

        return LogBOOL(FALSE, s_FN, 1210);
    }
    DBGMSG((DBGMOD_QM, DBGLVL_INFO, _T("Successful Resource Manager initialization"))) ;

    //
    // read IP port from registry.
    //
    DWORD dwDef = FALCON_DEFAULT_IP_PORT ;
    READ_REG_DWORD(g_dwIPPort,
                   FALCON_IP_PORT_REGNAME,
                   &dwDef ) ;

    DBGMSG((DBGMOD_QM, DBGLVL_TRACE, L"QM will use IP port : %d", g_dwIPPort));


    //
    // read the registry to see if the cluster node
    // need to bind to all IP for outgoing connections
    //
    dwDef = MSMQ_DEFAULT_CLUSTER_NOT_BIND_ALL_IP;
    READ_REG_DWORD(g_bCluster_IP_BindAll,
                   MSMQ_CLUSTER_BIND_ALL_IP,
                   &dwDef ) ;

    DBGMSG((DBGMOD_QM, DBGLVL_INFO,
		  L"QM cluster will %ls use wild binding for outgoing connections...",
		  g_bCluster_IP_BindAll ? L"" : L"NOT" ));


    //
    // Restore the onhold queues. It must be after recovery.
    // During the recovery we open the foreign queue with the connector
    // information. If it is done in oposite order the connector machine
    // guid isn't set and we can get messages out of order.
    //
    QmpReportServiceProgress();
    InitOnHold();


    //
    // Retreive the machine connection status from the registery
    //
    QueueMgr.InitConnected();

    //
    // Init routing should be called before OnlineInitialization, since it can called
    // RdGetConnector during the Validation of open queue.
    //
    QmpReportServiceProgress();
    RdInitialize(IsRoutingServer(), CTimeDuration::FromMilliSeconds(180 * 1000));

    hr = ADInit(
            QMLookForOnlineDS,
            NULL,   // pGetServers
            false,  // fDSServerFunctionality
            false,  // fSetupMode
            true,   // fQMDll
            false,  // fIgnoreWorkGroup
            NULL,   // pNoServerAuth
            NULL,   // szServerName
            true    // fDisableDownlevelNotifications
            );

    if (FAILED(hr))
    {
        REPORT_CATEGORY(DS_INIT_ERROR, CATEGORY_KERNEL) ;
        return LogBOOL(FALSE, s_FN, 1215);
    }

    //
    // Init RAS monitoring.
    // For Falcon client machine, see if we are also ras client. If so,
    // determine which are our ras self addresses. for ip, determine
    // also the ip address of the ras server.
    //
    QmpReportServiceProgress();
    if (IsNonServer())
    {
        hr = InitRAS() ;
        if (FAILED(hr))
        {
            REPORT_CATEGORY(QM_RAS_INIT_FAIL, CATEGORY_KERNEL) ;
            return LogBOOL(FALSE, s_FN, 1212);
        }
    }

    //
    //  Init notification queue
    //
    hr = g_NotificationHandler.Init();
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR,
               TEXT("Failed to initialize notification handler, hr=0x%x"), hr));
        REPORT_CATEGORY(QM_NOTIFY_INIT_FAIL, CATEGORY_KERNEL);
    }

    //
    // Try to get online with the Active Directory
    //
    QmpReportServiceProgress();
    ScheduleOnlineInitialization();

    QmpReportServiceProgress();
    if (!QMOneTimeInit())
    {
        WRITE_MSMQ_LOG((MSMQ_LOG_ERROR, e_LogQM, LOG_QM_INIT, L"QMOneTimeInit failed, exiting"));
        return LogBOOL(FALSE, s_FN, 1214);
    }

    //
    // No need to do post setup work next time we start!
    // We reset the value rather than deleting the key b/c mqclus depends on that (otherwise
    // every Open of cluster resource will be treated as Create). (shaik, 10-Jul-2000)
    //
    DWORD dwType = REG_DWORD;
    DWORD dwDone = MSMQ_SETUP_DONE;
    dwSize = sizeof(DWORD);
    SetFalconKeyValue(MSMQ_SETUP_STATUS_REGNAME, &dwType, &dwDone, &dwSize);

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwDone = TRUE;
    SetFalconKeyValue(MSMQ_SEQUENTIAL_ID_MSMQ3_FORMAT_REGNAME, &dwType, &dwDone, &dwSize);

    REPORT_CATEGORY(QM_INITILIZATION_SUCCEEDED, CATEGORY_KERNEL) ;

    DBGMSG((DBGMOD_QM, DBGLVL_TRACE, L"QMinit succeeded"));

    return TRUE;

} // QmpInitialize


VOID
AppRun(
    LPCWSTR pServiceName
    )
/*++

Routine Description:
    Service startup code. It should immidiatly report it state and enable the
    controls it accepts.

Arguments:
    Service name

Returned Value:
    None.

--*/
{
    try
    {
        if(!QmpInitialize(pServiceName))
        {
            throw exception();
        }

        if(!StartRpcServer())
        {
            throw exception();
        }

        SvcReportState(SERVICE_RUNNING);

        SvcEnableControls(
            SERVICE_ACCEPT_STOP |
            SERVICE_ACCEPT_SHUTDOWN
            );

        g_fQMRunMode = TRUE;
        Sleep(INFINITE);
    }
    catch (const bad_alloc&)
    {
        REPORT_CATEGORY(SERVICE_START_ERROR_LOW_RESOURCES, CATEGORY_KERNEL);
        LogIllegalPoint(s_FN, 1425);
    }
    catch(const exception&)
    {
        LogIllegalPoint(s_FN, 1420);
    }

    SvcReportState(SERVICE_STOPPED);
}


static void StopServiceActivity()
{
    SvcReportState(SERVICE_STOP_PENDING);
    QmpReportServiceProgress();

    XactLogWriteCheckpointAndExitThread();
    g_Logger.Finish();

    ShutDownDebugWindow();

    ACCloseHandle(g_hMachine);
    g_hMachine = INVALID_HANDLE_VALUE;

    SvcReportState(SERVICE_STOPPED);
}

VOID
AppStop(
    VOID
    )
{
    DBGMSG((DBGMOD_QM, DBGLVL_INFO, _T("MSMQ Service is stopping...")));
    StopServiceActivity();
    REPORT_CATEGORY(QM_SERVICE_STOPPED, CATEGORY_KERNEL);
}


VOID
AppShutdown(
    VOID
    )
{
    DBGMSG((DBGMOD_QM, DBGLVL_INFO, _T("MSMQ Service is shutting down...")));
    StopServiceActivity();
}


VOID
AppPause(
    VOID
    )
{
    ASSERT(("MQMQ Service unexpectedly got Pause control from SCM", 0));
}


VOID
AppContinue(
    VOID
    )
{
    ASSERT(("MSMQ Service unexpectedly got Continue control from SCM", 0));
}


QM_EXPORT
int
APIENTRY
QMMain(
    int argc,
    LPCTSTR argv[]
    )
{
    try
    {
        //
        // If a command line parameter is passed, use it as the dummy service
        // name. This is very usful for debugging cluster startup code.
        //
        LPCWSTR DummyServiceName = (argc == 2) ? argv[1] : L"MSMQ";
        SvcInitialize(DummyServiceName);
    }
    catch(const exception&)
    {
        return -1;
    }

    return 0;
}



HRESULT
QmpOpenAppsReceiveQueue(
    const QUEUE_FORMAT* pQueueFormat,
    LPRECEIVE_COMPLETION_ROUTINE lpReceiveRoutine
    )
{
    HRESULT hr2 = QueueMgr.OpenAppsReceiveQueue(
                        pQueueFormat,
                        lpReceiveRoutine
                        );
    return LogHR(hr2, s_FN, 70);
}

static
HRESULT
QMSignPacket(
    IN CMessageProperty*   pmp,
    IN const QUEUE_FORMAT* pDestinationQueueFormat, // is this unreferenced or what?
    IN const QUEUE_FORMAT* pAdminQueueFormat,
    IN const QUEUE_FORMAT* pResponseQueueFormat
    )
{
    DWORD   dwErr ;
    HRESULT hr;

    pmp->ulSenderIDType = MQMSG_SENDERID_TYPE_QM;
    pmp->pSenderID = (PUCHAR)QueueMgr.GetQMGuid();
    pmp->uSenderIDLen = sizeof(GUID);
    pmp->ulHashAlg = PROPID_M_DEFUALT_HASH_ALG;
    pmp->bDefProv = TRUE;

    //
    // Compute the hash value for the message body and sign the message.
    //

    CHCryptHash hHash;

    HCRYPTPROV hProvQM = NULL ;
    hr = MQSec_AcquireCryptoProvider( eBaseProvider,
                                     &hProvQM ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 80);
    }

    ASSERT(hProvQM) ;
    if (!CryptCreateHash(       // Create a hash object
            hProvQM,
            pmp->ulHashAlg,
            0,
            0,
            &hHash))
    {
        dwErr = GetLastError() ;
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _TEXT(
          "QMSignPacket(), fail at CryptCreateHash(), err- %lut"), dwErr)) ;

        LogNTStatus(dwErr, s_FN, 90);
        return MQ_ERROR_CORRUPTED_SECURITY_DATA;
    }

    hr = HashMessageProperties( // Compute the hash value for the mesage body.
            hHash,
            pmp,
            pResponseQueueFormat,
            pAdminQueueFormat
            );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 100);
    }

    if (!CryptSignHashA(        // Sign the message.
            hHash,
            AT_SIGNATURE,
            NULL,
            0,
            const_cast<PUCHAR>(pmp->pSignature),
            &pmp->ulSignatureSize))
    {
        dwErr = GetLastError() ;
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _TEXT(
          "QMSignPacket(), fail at CryptSignHashA(), err- %lut"), dwErr)) ;

        LogNTStatus(dwErr, s_FN, 110);
        return MQ_ERROR_CORRUPTED_SECURITY_DATA;
    }

    return(MQ_OK);
}


HRESULT
QmpSendPacket(
    CMessageProperty  * pmp,
    CONST QUEUE_FORMAT* pqdDstQueue,
    CONST QUEUE_FORMAT* pqdAdminQueue,
    CONST QUEUE_FORMAT* pqdResponseQueue,
    BOOL fSign /* = FALSE */
    )
{
    HRESULT hr;
    BYTE abMessageSignature[MAX_MESSAGE_SIGNATURE_SIZE];

    if (fSign)
    {
        pmp->pSignature = abMessageSignature;
        pmp->ulSignatureSize = sizeof(abMessageSignature);
        hr = QMSignPacket(
                 pmp,
                 pqdDstQueue,
                 pqdAdminQueue,
                 pqdResponseQueue
                 );

        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 120);
        }
    }

    HRESULT hr2 = QueueMgr.SendPacket(
                        pmp,
                        pqdDstQueue,
                        1,
                        pqdAdminQueue,
                        pqdResponseQueue
                        );
    return LogHR(hr2, s_FN, 130);
} // QmpSendPacket


static void __cdecl QmpExceptionTranslator(unsigned int u, PEXCEPTION_POINTERS)
{
    switch(u)
    {
        case STATUS_NO_MEMORY:
        case STATUS_STACK_OVERFLOW:
        case STATUS_INSUFFICIENT_RESOURCES:
            LogHR(u, s_FN, 164);
            throw bad_alloc();

    }
}


static void __cdecl QmpAbnormalTerminationHandler()
{
    LogBOOL(FALSE, s_FN, 1300);
    ASSERT_RELEASE(("Abnormal Termination", 0));
}


/*====================================================

DllMain

Initialize/cleanup dll

=====================================================*/

//
// ISSUE-2000/12/07-erezh Compiler bug, warning 4535
// This seems like a compiler bug, warning 4535 is generated even though
// that /EHc is specified to the compiler.
//
// Specify /EHa with the use of _set_se_translator() library function
//
#pragma warning(disable: 4535)

BOOL WINAPI DllMain (HMODULE hMod, DWORD dwReason, LPVOID lpvReserved)
{
    g_hInstance = hMod;

    switch(dwReason)
    {
       case DLL_PROCESS_ATTACH:
            WPP_INIT_TRACING(L"Microsoft\\MSMQ");
            AllocateThreadTLSs();
            MQUInitGlobalScurityVars() ;
            // FALL Through

        case DLL_THREAD_ATTACH:
            //
            // Install structured exceptions translator, and abnormal termination handlers
            //
            _set_se_translator(QmpExceptionTranslator);
            set_terminate(QmpAbnormalTerminationHandler);
            break;

       case DLL_PROCESS_DETACH:
            WPP_CLEANUP();
            // FALL Through

        case DLL_THREAD_DETACH:
            FreeThreadEvent();
            FreeHandleForRpcCancel() ;
            _set_se_translator(0);
            set_terminate(0);
            break;
    }

    return TRUE;
}


void LogMsgHR(HRESULT hr, LPWSTR wszFileName, USHORT usPoint)
{
    KEEP_ERROR_HISTORY((e_LogQM, wszFileName, usPoint, hr));

    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogQM,
                     LOG_QM_ERRORS,
                     L"QM Error: %s/%d, HR: 0x%x",
                     wszFileName,
                     usPoint,
                     hr)) ;
}

void LogMsgNTStatus(NTSTATUS status, LPWSTR wszFileName, USHORT usPoint)
{
    KEEP_ERROR_HISTORY((e_LogQM, wszFileName, usPoint, status));

    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogQM,
                     LOG_QM_ERRORS,
                     L"QM Error: %s/%d, NTStatus: 0x%x",
                     wszFileName,
                     usPoint,
                     status)) ;
}

void LogMsgRPCStatus(RPC_STATUS status, LPWSTR wszFileName, USHORT usPoint)
{
    KEEP_ERROR_HISTORY((e_LogQM, wszFileName, usPoint, status));

    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogQM,
                     LOG_QM_ERRORS,
                     L"QM Error: %s/%d, RPCStatus: 0x%x",
                     wszFileName,
                     usPoint,
                     status)) ;
}

void LogMsgBOOL(BOOL b, LPWSTR wszFileName, USHORT usPoint)
{
    KEEP_ERROR_HISTORY((e_LogQM, wszFileName, usPoint, b));

    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogQM,
                     LOG_QM_ERRORS,
                     L"QM Error: %s/%d, BOOL: %x",
                     wszFileName,
                     usPoint,
                     b)) ;
}

void LogIllegalPoint(LPWSTR wszFileName, USHORT dwLine)
{
        KEEP_ERROR_HISTORY((e_LogQM, wszFileName, dwLine, 0));

        WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                         e_LogQM,
                         LOG_QM_ERRORS,
                         L"QM Error: %s/%d, Point",
                         wszFileName,
                         dwLine)) ;
}

#ifdef _WIN64
	void LogIllegalPointValue(DWORD64 dw64, LPCWSTR wszFileName, USHORT usPoint)
	{
		KEEP_ERROR_HISTORY((e_LogQM, wszFileName, usPoint, 0));

		WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
						 e_LogQM,
						 LOG_QM_ERRORS,
						 L"QM Error: %s/%d, Value: 0x%I64x",
						 wszFileName,
						 usPoint,
						 dw64)) ;
	}
#else
	void LogIllegalPointValue(DWORD dw, LPCWSTR wszFileName, USHORT usPoint)
	{
		KEEP_ERROR_HISTORY((e_LogQM, wszFileName, usPoint, 0));

		WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
						 e_LogQM,
						 LOG_QM_ERRORS,
						 L"QM Error: %s/%d, Value: 0x%x",
						 wszFileName,
						 usPoint,
						 dw)) ;
	}
#endif //_WIN64

void InitLogging()
{
    // Process & Machine
    int pid = _getpid();

    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogQM,
                     LOG_QM_ERRORS,
                     L"---------------------------------------------------------------")) ;

    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogQM,
                     LOG_QM_ERRORS,
                     L"*** QM: ** Start logging. Machine: %s, DNSName: %s, PID: %x ",
                     g_szMachineName, g_szComputerDnsName, pid )) ;


    // OS info
    OSVERSIONINFO verOsInfo;
    verOsInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (GetVersionEx(&verOsInfo))
    {
        WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                         e_LogQM,
                         LOG_QM_ERRORS,
                         L"*** OS: %d.%d  Build: %d Platform: %d %s",
                         verOsInfo.dwMajorVersion, verOsInfo.dwMinorVersion,
                         verOsInfo.dwBuildNumber,  verOsInfo.dwPlatformId,
                         verOsInfo.szCSDVersion )) ;

    }

    // Machine and MSMQ info
    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogQM,
                     LOG_QM_ERRORS,
                     L"*** MSMQ Version: %d.%d.%d (built as %S). Workgroup: %d",
                     rmj, rmm, rup, szVerName, g_fWorkGroupInstallation)) ;

}


//
// Nedded for linking with fn.lib
//
LPCWSTR
McComputerName(
    void
    )
{
    ASSERT(g_szMachineName != NULL);
    return g_szMachineName;
}

//
// Nedded for linking with fn.lib
//
DWORD
McComputerNameLen(
    void
    )
{
    ASSERT(g_szMachineName != NULL);
    return wcslen(g_szMachineName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\lqs.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    lqs.cpp

Abstract:
    Loacl Queue Store.

Author:
    Boaz Feldbaum (BoazF) 12-Feb-1997.

--*/
#include "stdh.h"
#include "cqmgr.h"
#include "lqs.h"
#include "regqueue.h"
#include "uniansi.h"
#include "qmutil.h"
#include <mqsec.h>
#include "DumpAuthzUtl.h"
#include <aclapi.h>
#include <autoreln.h>
#include <fn.h>

#include "lqs.tmh"

const TraceIdEntry Lqs = L"LQS";

extern LPTSTR      g_szMachineName;
extern CQueueMgr       QueueMgr;
#ifdef _WIN64
//
//HLQS handle for enumeration of private queues from admin, passed inside an MSMQ message as 32 bit value
//
extern CContextMap g_map_QM_HLQS;
#endif //_WIN64

static WCHAR *s_FN=L"lqs";

#define LQS_SUBDIRECTORY                TEXT("\\LQS\\")

#define LQS_TYPE_PROPERTY_NAME          TEXT("Type")
#define LQS_INSTANCE_PROPERTY_NAME      TEXT("Instance")
#define LQS_BASEPRIO_PROPERTY_NAME      TEXT("BasePriority")
#define LQS_JOURNAL_PROPERTY_NAME       TEXT("Journal")
#define LQS_QUOTA_PROPERTY_NAME         TEXT("Quota")
#define LQS_JQUOTA_PROPERTY_NAME        TEXT("JournalQuota")
#define LQS_TCREATE_PROPERTY_NAME       TEXT("CreateTime")
#define LQS_TMODIFY_PROPERTY_NAME       TEXT("ModifyTime")
#define LQS_SECURITY_PROPERTY_NAME      TEXT("Security")
#define LQS_TSTAMP_PROPERTY_NAME        TEXT("TimeStamp")
#define LQS_PATHNAME_PROPERTY_NAME      TEXT("PathName")
#define LQS_QUEUENAME_PROPERTY_NAME     TEXT("QueueName")
#define LQS_LABEL_PROPERTY_NAME         TEXT("Label")
#define LQS_MULTICAST_ADDRESS_PROPERTY_NAME TEXT("MulticastAddress")
#define LQS_AUTH_PROPERTY_NAME          TEXT("Authenticate")
#define LQS_PRIVLEVEL_PROPERTY_NAME     TEXT("PrivLevel")
#define LQS_TRANSACTION_PROPERTY_NAME   TEXT("Transaction")
#define LQS_SYSQ_PROPERTY_NAME          TEXT("SystemQueue")
#define LQS_PROP_SECTION_NAME           TEXT("Properties")

#define LQS_SIGNATURE_NAME              TEXT("Signature")
#define LQS_SIGNATURE_VALUE             TEXT("DoronJ")
#define LQS_SIGNATURE_NULL_VALUE        TEXT("EpspoK")

static const WCHAR x_szTemporarySuffix[] = TEXT(".tmp");

//
// Purely local definitions.
//
#define LQS_PUBLIC_QUEUE                1
#define LQS_PRIVATE_QUEUE               2

HRESULT IsBadLQSFile( LPCWSTR lpszFileName,
                      BOOL    fDeleteIfBad = TRUE) ;

//
// LQS_MAX_VALUE_SIZE is the maximum length a property value can have in the
// INI file.
//
#define LQS_MAX_VALUE_SIZE              (64 * 1024)

#ifdef _DEBUG
#define LQS_HANDLE_TYPE_QUEUE           1
#define LQS_HANDLE_TYPE_FIND            2
#endif

#ifdef _DEBUG
#define LQS_MAGIC_NUMBER                0x53514c00  // 'LQS'
#endif

class CAutoCloseFindFile
{
public:
    CAutoCloseFindFile(HANDLE h =INVALID_HANDLE_VALUE) { m_h = h; };
    ~CAutoCloseFindFile() { if (m_h != INVALID_HANDLE_VALUE) FindClose(m_h); };

public:
    CAutoCloseFindFile & operator =(HANDLE h) { m_h = h; return(*this); };
    HANDLE * operator &() { return &m_h; };
    operator HANDLE() { return m_h; };

private:
    HANDLE m_h;
};

//
// The local queue store handle class
//
class _HLQS
{
public:
    _HLQS(LPCWSTR lpszQueuePath, LPCWSTR lpszFilePathName); // For queue operations
    _HLQS(HANDLE hFindFile); // For queue enumerations
    ~_HLQS();
    BOOL IsEqualQueuePathName(LPCWSTR lpszPathName);
    LPCWSTR GetFileName();
    LPCWSTR GetTemporaryFileName();
    LPCWSTR GetQueuePathName();
    HANDLE GetFindHandle();
    DWORD AddRef();
    DWORD Release();
#ifdef _DEBUG
    BOOL Validate() const;
#endif
#ifdef _WIN64
    void SetMappedHLQS(DWORD dwMappedHLQS);
#endif //_WIN64

private:
    void SetFilePathName(LPCWSTR lpszFilePathName);
    void SetQueuePathName(LPCWSTR lpszQueuePathName);

private:
    AP<WCHAR> m_lpszFilePathName;
    AP<WCHAR> m_lpszTemporaryFilePathName;
    AP<WCHAR> m_lpszQueuePathName;
    int m_iRefCount;
    CAutoCloseFindFile m_hFindFile;
#ifdef _DEBUG
    BYTE m_bType;
    DWORD m_dwMagic;
#endif
#ifdef _WIN64
    DWORD m_dwMappedHLQS;
#endif //_WIN64
};

//
// Constractor for queue operations
//
_HLQS::_HLQS(
    LPCWSTR lpszQueuePath,
    LPCWSTR lpszFilePathName)
{
    SetQueuePathName(lpszQueuePath);
    SetFilePathName(lpszFilePathName);
    m_iRefCount = 0;
#ifdef _DEBUG
    m_bType = LQS_HANDLE_TYPE_QUEUE;
    m_dwMagic = LQS_MAGIC_NUMBER;
#endif
#ifdef _WIN64
    m_dwMappedHLQS = 0;
#endif //_WIN64
}

//
// Constractor for queue enumerations.
//
_HLQS::_HLQS(HANDLE hFindFile)
{
    m_iRefCount = 0;
    m_hFindFile = hFindFile;
#ifdef _DEBUG
    m_bType = LQS_HANDLE_TYPE_FIND;
    m_dwMagic = LQS_MAGIC_NUMBER;
#endif
#ifdef _WIN64
    m_dwMappedHLQS = 0;
#endif //_WIN64
}

_HLQS::~_HLQS()
{
    ASSERT(m_iRefCount == 0);
#ifdef _WIN64
    //
    // remove mapping of this instance from the map
    //
    if (m_dwMappedHLQS != 0)
    {
        DELETE_FROM_CONTEXT_MAP(g_map_QM_HLQS, m_dwMappedHLQS, s_FN, 620);
    }
#endif //_WIN64
}

#ifdef _DEBUG
//
// Validate that the handle is a valid local queue store handle.
//
BOOL _HLQS::Validate() const
{
    return !IsBadReadPtr(&m_dwMagic, sizeof(m_dwMagic)) &&
           (m_dwMagic == LQS_MAGIC_NUMBER);
}
#endif

//
// Store the path to the file that contains the queue properties.
//
void _HLQS::SetFilePathName(LPCWSTR lpszFilePathName)
{
    delete[] m_lpszFilePathName.detach();
    delete[] m_lpszTemporaryFilePathName.detach();
    if (lpszFilePathName)
    {
        m_lpszFilePathName = new WCHAR[wcslen(lpszFilePathName) + 1];
        wcscpy(m_lpszFilePathName, lpszFilePathName);
    }
}

//
// Store the queue path name.
//
void _HLQS::SetQueuePathName(LPCWSTR lpszQueuePathName)
{
    delete[] m_lpszQueuePathName.detach();
    if (lpszQueuePathName)
    {
        m_lpszQueuePathName = new WCHAR[wcslen(lpszQueuePathName) + 1];
        wcscpy(m_lpszQueuePathName, lpszQueuePathName);
    }
}

//
// Return TRUE if the queue path name equals to the passed path name.
//
BOOL _HLQS::IsEqualQueuePathName(LPCWSTR lpszQueuePathName)
{
    return CompareStringsNoCaseUnicode(m_lpszQueuePathName, lpszQueuePathName) == 0;
}

//
// Add one to the reference count of the handle.
//
DWORD _HLQS::AddRef(void)
{
    //
    // No need to lock because the entire Local Queue Store is locked.
    //
    return ++m_iRefCount;
}

//
// Substract one from the reference count and delete the handle if the
// reference count drops to zero.
//
DWORD _HLQS::Release()
{
    //
    // No need to lock because the entire Local Queue Store is locked.
    //
    int iRefCount = --m_iRefCount;

    if (iRefCount == 0)
    {
        delete this;
    }

    return iRefCount;
}

//
// Get the name of the files that holds the queue properties.
//
LPCWSTR _HLQS::GetFileName(void)
{
    ASSERT(m_bType == LQS_HANDLE_TYPE_QUEUE);
    return m_lpszFilePathName;
}

//
// Get the name of the backup file that holds the "last known good" queue properties.
//
LPCWSTR _HLQS::GetTemporaryFileName(void)
{
    //
    // Note that we use both prefix and suffix. this is because the 
    // wildcard for finding private queue files ends with "*", and the one for public begins with "*",
    // and we don't want them to find the temporary files (YoelA, 1-Aug-99)
    //
    static const WCHAR x_szTemporaryPrefix[] = TEXT("~T~");
    static const DWORD x_dwAdditionsLen = TABLE_SIZE(x_szTemporaryPrefix) + TABLE_SIZE(x_szTemporarySuffix);
    ASSERT(m_bType == LQS_HANDLE_TYPE_QUEUE);
    if (m_lpszTemporaryFilePathName == 0)
    {
        //
        // Find the beginning of the file name - after the last backslash
        //
        LPCTSTR lpszStartName = wcsrchr(m_lpszFilePathName, L'\\');
        if (lpszStartName == NULL)
        {
            lpszStartName = m_lpszFilePathName;
        }
        else
        {
            lpszStartName++;
        }

        //
        // Allocate abuffer for the new name
        //
        m_lpszTemporaryFilePathName = new WCHAR[wcslen(m_lpszFilePathName) + x_dwAdditionsLen + 1];

        //
        // Copy the path (drive, dirs, etc) except for the file name
        //
        DWORD_PTR dwPrefixLen = lpszStartName - m_lpszFilePathName;
        wcsncpy(m_lpszTemporaryFilePathName, m_lpszFilePathName, dwPrefixLen);

        //
        // Add the file name with prefix and suffix
        //
        swprintf(m_lpszTemporaryFilePathName + dwPrefixLen, 
                 TEXT("%s%s%s"),
                 x_szTemporaryPrefix,
                 lpszStartName,
                 x_szTemporarySuffix);
    }

    return m_lpszTemporaryFilePathName;
}

//
// Get the original queue path name
//
LPCWSTR _HLQS::GetQueuePathName(void)
{
    ASSERT(m_bType == LQS_HANDLE_TYPE_QUEUE);
    return m_lpszQueuePathName;
}

//
// Get the find handle for enumerating the queues in the LQS.
//
HANDLE _HLQS::GetFindHandle(void)
{
    ASSERT(m_bType == LQS_HANDLE_TYPE_FIND);
    return m_hFindFile;
}

#ifdef _WIN64
//
// Saves a DWORD mapping of this HQLS object to be removed from the map upon destruction
//
void _HLQS::SetMappedHLQS(DWORD dwMappedHLQS)
{
    ASSERT(m_dwMappedHLQS == 0);
    m_dwMappedHLQS = dwMappedHLQS;
}
#endif //_WIN64

//
// Synchronously flush content of existing file
// 
static
BOOL
LqspFlushFile(
    LPCWSTR pFile
    )
{
    CAutoCloseHandle hFile;
    hFile = CreateFile(
                pFile,
                GENERIC_WRITE,
                0,
                0,
                OPEN_EXISTING,
                FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING,
                0
                );

    if (hFile == INVALID_HANDLE_VALUE)
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, 
            _T("Failed to open file '%ls' for flush, error 0x%x"), pFile, GetLastError()));        
        return LogBOOL(false, s_FN, 560);
    }

    if (!FlushFileBuffers(hFile))
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, 
            _T("Failed to flush file '%ls', error 0x%x"), pFile, GetLastError()));        
        return LogBOOL(false, s_FN, 570);
    }

    return true;

} // LqspFlushFile


//
// Determines wheather or not a file exists
//
BOOL DoesFileExist(LPCTSTR lpszFilePath)
{
    WIN32_FIND_DATA FindData;
    CAutoCloseFindFile hFindFile = FindFirstFile(lpszFilePath, &FindData);

    if (hFindFile == INVALID_HANDLE_VALUE)
    {
        //
        // Nothing was found.
        //
        return FALSE;
    }
    return TRUE;
}
//
// Hash the queue path to a DWORD. This serves us for creating the file name
// of the file that holds the queue properties.
//
STATIC
DWORD
HashQueuePath(
    LPCWSTR lpszPathName)
{
    DWORD dwHash = 0;

    AP<WCHAR> pTemp = new WCHAR[wcslen(lpszPathName) + 1];
    wcscpy(pTemp, lpszPathName);

    //
    // Call CharLower on all string and not every character, to enalbe Win95.
    // This is how MQ implementation supports it. erezh 19-Mar-98
    //
    WCHAR* pName = pTemp;
    CharLower(pName);

    while (*pName)
    {
        dwHash = (dwHash<<5) + dwHash + *pName++;
    }

    return dwHash;
}

//
// Convert a GUID to it's string representation.
//
STATIC
DWORD
GuidToStr(
    LPWSTR lpszGuid,
    const GUID *lpGuid)
{
    swprintf(lpszGuid,
            TEXT("%08x%04x%04x%02x%02x%02x%02x%02x%02x%02x%02x"),
            lpGuid->Data1,
            lpGuid->Data2,
            lpGuid->Data3,
            lpGuid->Data4[0],
            lpGuid->Data4[1],
            lpGuid->Data4[2],
            lpGuid->Data4[3],
            lpGuid->Data4[4],
            lpGuid->Data4[5],
            lpGuid->Data4[6],
            lpGuid->Data4[7]);

    return (8+4+4+8*2);
}

//
// Fill a buffer with the directory of the LQS and return a pointer to the
// location in the buffer after the directory name.
//
STATIC
LPWSTR
LQSGetDirectory(
    LPWSTR lpszFilePath)
{
    static WCHAR szDirectory[MAX_PATH] = {TEXT("")};
    static DWORD dwDirectoryLength;

    //
    // We do not have the directory name yet cached in the static variable
    // so get the value from the registry.
    //
    if (!szDirectory[0])
    {
        DWORD dwValueType = REG_SZ ;

        dwDirectoryLength = sizeof(szDirectory); // In bytes!!!

        LONG rc = GetFalconKeyValue(
                        MSMQ_STORE_PERSISTENT_PATH_REGNAME,
                        &dwValueType,
                        szDirectory,
                        &dwDirectoryLength);
        ASSERT(rc == ERROR_SUCCESS);
        //
        // BUGBUG - Should throw exception and handle it, if the
        //          above assertion is triggered.
        //
        if (rc != ERROR_SUCCESS)
        {
            DBGMSG((DBGMOD_QM,
                    DBGLVL_ERROR,
                    TEXT("LQSGetDirectory - failed to retrieve the LQS ")
                    TEXT("directory from the registry, error = %d"), rc));
        }
        dwDirectoryLength = dwDirectoryLength / sizeof(WCHAR) - 1;
    }

    wcscpy(lpszFilePath, szDirectory);
    wcscpy(lpszFilePath += dwDirectoryLength, LQS_SUBDIRECTORY);

    return lpszFilePath +
           sizeof(LQS_SUBDIRECTORY) / sizeof(WCHAR) - 1;
}

//
// Fill a buffer with the path to the file that should contain the
// queue properties. The file name for private queues is the hex value of the
// queue's ID with leading zeroes. The file name for public queues is the
// queue's GUID. The file names extension is always the DWORD hash value of
// the queue path name.
//
// It is possible to pass a NULL for each of the parameters: queue path, queue
// giud, or queue ID. In this case the file name will contain an asterisk - '*'.
// This results in a wild carded path that can be used for finding the file
// for the queue using FindFirst/NextFile.
//
STATIC
void
LQSFilePath(
    DWORD dwQueueType,
    LPWSTR lpszFilePath,
    LPCWSTR pszQueuePath,
    const GUID *pguidQueue,
    DWORD *pdwQueueId)
{
    WCHAR *p = LQSGetDirectory(lpszFilePath);

    switch (dwQueueType)
    {
    case LQS_PUBLIC_QUEUE:
        if (pguidQueue)
        {
            p += GuidToStr(p, pguidQueue);
        }
        else
        {
            *p++ = L'*';
        }
        break;

    case LQS_PRIVATE_QUEUE:
        if (pdwQueueId)
        {
            p += swprintf(p, TEXT("%08x"), *pdwQueueId);
        }
        else
        {
            *p++ = L'*';
        }
        break;

    default:
        ASSERT(0);
        break;
    }

    *p++ = L'.';

    if (pszQueuePath)
    {

		LPWSTR pSlashStart = wcschr(pszQueuePath,L'\\');

		ASSERT(pSlashStart);
        swprintf(p, TEXT("%08x"), HashQueuePath(pSlashStart));
    }
    else
    {
        *p++ = L'*';
        *p = L'\0';
    }
}

//
// Add to the reference count of the handle and cast it to PVOID, so it can be
// returned to the caller.
//
STATIC
HRESULT
LQSDuplicateHandle(
    HLQS *phLQS,
    _HLQS *hLQS)
{
    hLQS->AddRef();
    *phLQS = (PVOID)hLQS;

    return MQ_OK;
}

//
// Create an LQS handle for queue operations.
//
STATIC
VOID
LQSCreateHandle(
    LPCWSTR lpszQueuePath,
    LPCWSTR lpszFilePath,
    _HLQS **pphLQS)
{
    *pphLQS = new _HLQS(lpszQueuePath, lpszFilePath);
}

//
// Create an LQS handle for queue enumerations.
//
STATIC
HRESULT
LQSCreateHandle(
    HANDLE hFindFile,
    _HLQS **pphLQS)
{
    *pphLQS = new _HLQS(hFindFile);

    return MQ_OK;
}

#ifdef _DEBUG
STATIC
BOOL
LQSValidateHandle(HLQS hLQS)
{
    return (reinterpret_cast<const _HLQS *>(hLQS))->Validate();
}
#endif

STATIC
_HLQS * LQSReferenceHandle(HLQS hLQS)
{
    ASSERT(LQSValidateHandle(hLQS));
    return reinterpret_cast<_HLQS *>(hLQS);
}

//
// All the operations on the LQS are serialized using this critical section
// object.
//
static CCriticalSection g_LQSCS;

//
// Create a queue in the LQS. If the queue already exists, the queue
// properties are not modified, but a valid handle is returned.
//
STATIC
HRESULT
LQSCreateInternal(
    DWORD dwQueueType,          // Public or private queue.
    LPCWSTR pszQueuePath,       // The queue path name.
    const GUID *pguidQueue,     // The queue's GUID - valid only for public queues
    DWORD dwQueueId,            // The queus's ID - valid only for private queues
    DWORD cProps,               // The number of properties.
    PROPID aPropId[],           // The property IDs.
    PROPVARIANT aPropVar[],     // The property values.
    HLQS *phLQS)                // A buffer for the created handle.
{
    CS lock(g_LQSCS);
    P<_HLQS> hLQS;
    HRESULT hr = MQ_OK;
    HRESULT hr1;
    WCHAR szFilePath[MAX_PATH_PLUS_MARGIN];


    //
    // Get the path to the file.
    //
    LQSFilePath(dwQueueType,
                szFilePath,
                pszQueuePath,
                pguidQueue,
                &dwQueueId);
    //
    // If the file already exists, it means that the queue already exists.
    //
    if (_waccess(szFilePath, 0) == 0)
    {
        hr = MQ_ERROR_QUEUE_EXISTS;
    }

    //
    // Create a handle to the queue.
    //
    LQSCreateHandle(pszQueuePath, szFilePath, &hLQS);
    //
    // If the queue does not exist, set the queue properties. Writing the
    // queue properties also creates the file.
    //
    if (hr != MQ_ERROR_QUEUE_EXISTS)
    {
        hr1 = LQSSetProperties((HLQS)hLQS, cProps, aPropId, aPropVar, TRUE);
        if (FAILED(hr1))
        {
            return LogHR(hr1, s_FN, 20);
        }
    }

    //
    // Pass the created handle to the user.
    //
    LQSDuplicateHandle(phLQS, hLQS);
    hLQS.detach();

    return LogHR(hr, s_FN, 30);
}


//
// Create a public queue in the LQS. If the queue already exists, the queue
// properties are not modified, but a valid handle is returned.
//
HRESULT
LQSCreate(
    LPCWSTR pszQueuePath,       // The queue path name.
    const GUID *pguidQueue,     // The queue's GUID.
    DWORD cProps,               // The number of properties.
    PROPID aPropId[],           // The property IDs.
    PROPVARIANT aPropVar[],     // The property values.
    HLQS *phLQS)                // A buffer for the created handle.
{
    ASSERT(pguidQueue);

    if (!pszQueuePath)
    {
        for (DWORD i = 0;
             (i < cProps) && (aPropId[i] != PROPID_Q_PATHNAME);
             i++)
		{
			NULL;
		}

        if (i == cProps)
        {
            return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 40);
        }

        pszQueuePath = aPropVar[i].pwszVal;
    }

    HRESULT hr2 = LQSCreateInternal(LQS_PUBLIC_QUEUE,
                             pszQueuePath,
                             pguidQueue,
                             0,
                             cProps,
                             aPropId,
                             aPropVar,
                             phLQS);
    return LogHR(hr2, s_FN, 50);
}

//
// Create a private queue in the LQS. If the queue already exists, the queue
// properties are not modified, but a valid handle is returned.
//
HRESULT
LQSCreate(
    LPCWSTR pszQueuePath,     // The queue path name.
    DWORD dwQueueId,          // The queue's ID.
    DWORD cProps,             // The number of properties.
    PROPID aPropId[],         // The property IDs.
    PROPVARIANT aPropVar[],   // The property values.
    HLQS *phLQS)              // A buffer for the created handle.
{
    ASSERT(pszQueuePath);

    HRESULT hr2 = LQSCreateInternal(LQS_PRIVATE_QUEUE,
                             pszQueuePath,
                             NULL,
                             dwQueueId,
                             cProps,
                             aPropId,
                             aPropVar,
                             phLQS);
    return LogHR(hr2, s_FN, 60);
}

//
// Write a property as a string in the INI file.
//
STATIC
HRESULT
WriteProperyString(
    LPCWSTR lpszFileName,       // The path of the INI file.
    LPCWSTR lpszLQSPropName,    // The property name (e.g., "BasePriority").
    VARTYPE vt,                 // The var type of the property (e.g., VT_UI4).
    const BYTE * pBuff)         // The property value.
{
    WCHAR awcShortBuff[64];
    AP<WCHAR> pLongBuff;
    WCHAR *pValBuff = awcShortBuff;

    //
    // Convert the property value into it's string representation.
    //
    switch (vt)
    {
    case VT_UI1:
        swprintf(pValBuff, TEXT("%02x"), *pBuff);
        break;

    case VT_I2:
        swprintf(pValBuff, TEXT("%d"), *(short *)pBuff);
        break;

    case VT_I4:
        swprintf(pValBuff, TEXT("%d"), *(long *)pBuff);
        break;

    case VT_UI4:
        swprintf(pValBuff, TEXT("%u"), *(DWORD *)pBuff);
        break;

    case VT_LPWSTR:
        pValBuff = const_cast<LPWSTR>(reinterpret_cast<LPCWSTR>(pBuff));
        break;

    case VT_EMPTY:
        pValBuff = NULL;
        break;

    case VT_CLSID:
        {
            const GUID *pGuid = reinterpret_cast<const GUID *>(pBuff);
            swprintf(pValBuff,
                     TEXT("%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x"),
                     pGuid->Data1,
                     pGuid->Data2,
                     pGuid->Data3,
                     pGuid->Data4[0],
                     pGuid->Data4[1],
                     pGuid->Data4[2],
                     pGuid->Data4[3],
                     pGuid->Data4[4],
                     pGuid->Data4[5],
                     pGuid->Data4[6],
                     pGuid->Data4[7]);
        }
        break;

    case VT_BLOB:
        {
            const BLOB *pBlob = reinterpret_cast<const BLOB *>(pBuff);
            if (2*pBlob->cbSize > sizeof(awcShortBuff)/sizeof(WCHAR))
            {
                if (2*pBlob->cbSize + 1 > LQS_MAX_VALUE_SIZE)
                {
                    return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 70);
                }
                pLongBuff = new WCHAR[2*pBlob->cbSize + 1];
                pValBuff = pLongBuff;
            }
            WCHAR *p = pValBuff;
            for (DWORD i = 0;
                 i < pBlob->cbSize;
                 i++)
            {
                p += swprintf(p, TEXT("%02x"), pBlob->pBlobData[i]);
            }
            *p = '\0';
        }
        break;

    default:
        ASSERT(0);
        break;
    }

    //
    // Write the property in the INI file.
    //
    if (!WritePrivateProfileString(LQS_PROP_SECTION_NAME,
                                   lpszLQSPropName,
                                   pValBuff,
                                   lpszFileName))
    {
        LogNTStatus(GetLastError(), s_FN, 80);
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }

    return MQ_OK;
}


//
// Create the file and add 0xFF + 0xFE at the beggining to mark
// it as unicode. If we do not do it, global characters will not 
// be supported unless they belong to the default locale of the
// current computer.
// This is a fix to bug 5005, and it is actually a workaroung 
// for a bug in WritePrivateProfileStringW, that does not support unicode
// YoelA - 20-Oct-99
//
HRESULT CreateLqsUnicodeFile (LPCTSTR lpszFileName )
{
	CAutoCloseFileHandle hLogFileHandle = CreateFile(lpszFileName,GENERIC_WRITE,0,0,
			CREATE_NEW,FILE_ATTRIBUTE_TEMPORARY,0);
	if (hLogFileHandle == INVALID_HANDLE_VALUE )
	{
           //
           // CreateFile failed. We will generate an event and fail
           //
           DWORD err = GetLastError();

           WRITE_MSMQ_LOG(( 
                 MSMQ_LOG_ERROR,
                 e_LogQM,
                 LOG_QM_ERRORS,
                 L"CreateLqsUnicodeFile failed to create LQS file %s, LastError - %x",
                 lpszFileName,
                 err));
           return LogHR(HRESULT_FROM_WIN32(err), s_FN, 600);
	}

	UCHAR strUnicodeMark[]={(UCHAR)0xff,(UCHAR)0xfe};
	DWORD dwWrittenSize;
	if (0 == WriteFile( hLogFileHandle , strUnicodeMark , sizeof(strUnicodeMark), &dwWrittenSize , NULL))
    {
       //
       // WriteFile failed. We will generate an event and fail
       //
       DWORD err = GetLastError();

       WRITE_MSMQ_LOG(( 
             MSMQ_LOG_ERROR,
             e_LogQM,
             LOG_QM_ERRORS,
             L"CreateLqsUnicodeFile failed to write to LQS file %s, LastError - %x",
             lpszFileName,
             err));
       return LogHR(HRESULT_FROM_WIN32(err), s_FN, 610);
    }

    if (dwWrittenSize != sizeof(strUnicodeMark))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 615);
    }

    return S_OK;
}

//
// Write the properties of a queue in the queue peroperties file.
//
HRESULT
LQSSetProperties(
    HLQS hLQS,
    DWORD cProps,
    PROPID aPropId[],
    PROPVARIANT aPropVar[],
    BOOL fNewFile)
{
    CS lock(g_LQSCS);

    HRESULT hr = MQ_OK ;
    BOOL fModifyTimeIncluded = FALSE;
    LPCWSTR lpszIniFile = LQSReferenceHandle(hLQS)->GetFileName();
    LPCWSTR lpszTemporaryFile = LQSReferenceHandle(hLQS)->GetTemporaryFileName();
    LPCWSTR lpszQueueName = LQSReferenceHandle(hLQS)->GetQueuePathName(); // Requeired for reporting purposes

    if (!fNewFile)
    {
       //
       // Copy the LQS file to a temporary work file - in case we will fail during the update
       //
       BOOL bCancelDummy = FALSE; // Cancle flag. CopyFileEx require it, but we don't use it.
       BOOL fCopySucceeded = CopyFileEx(lpszIniFile, lpszTemporaryFile, 0, 0, &bCancelDummy, 0);
       if (!fCopySucceeded)
       {
           //
           // Copy failed. We will generate an event and fail
           //
           DWORD err = GetLastError();

           WRITE_MSMQ_LOG(( 
                 MSMQ_LOG_ERROR,
                 e_LogQM,
                 LOG_QM_ERRORS,
                 L"LQSSetProperties failed to copy LQS file to temporary work file, LastError - %x, queue - %s, LQS file - %s, temporary file - %s",
                 err,
                 lpszQueueName,
                 lpszIniFile,
                 lpszTemporaryFile));
           LogNTStatus(err, s_FN, 400);

           //
           // Generate an event log file to notify the user that the copy failed
           //
           TCHAR szErr[20];
           _ultot(err,szErr,10);

           REPORT_WITH_STRINGS_AND_CATEGORY(( CATEGORY_KERNEL,
                                     SET_QUEUE_PROPS_FAIL_COUND_NOT_COPY,
                                     4,
                                     lpszQueueName,
                                     lpszIniFile,
                                     lpszTemporaryFile,
                                     szErr)) ;

           //
           // Well... We don't know why CopyFile failed. A reasonable reason may be 
           // insufficient resources, but other reasons may cause it as well (like permission issues).
           // We return the best error code we can. A detailed log was generated anyway.
           // (YoelA - 28-Jul-99)
           //
           return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 460);
       }
       //
       // Make the file a temporary file. We do not check return code here except for
       // debug / report purposes.
       //
       BOOL fSetAttrSucceeded = SetFileAttributes(lpszTemporaryFile, FILE_ATTRIBUTE_TEMPORARY);
       if (!fSetAttrSucceeded)
       {
           DWORD err = GetLastError();
           ASSERT(0);

           WRITE_MSMQ_LOG(( 
                 MSMQ_LOG_ERROR,
                 e_LogQM,
                 LOG_QM_ERRORS,
                 L"LQSSetProperties failed to set temporary work file attributes, LastError - %x, queue - %s, temporary file - %s",
                 err,
                 lpszQueueName,
                 lpszTemporaryFile));
           LogNTStatus(err, s_FN, 410);
       }
    }
    else
    {
        //
        // Create the file first so it will be globalizable.See explanation above in CreateLqsUnicodeFile
        // YoelA - 20-Oct-99
        //
        HRESULT rc = CreateLqsUnicodeFile(lpszTemporaryFile);
		DBG_USED(rc);

        ASSERT(SUCCEEDED(rc));

        //
        // Note: We don't care if we failed to create the file and mark it as UNICODE. In the worst case,
        // WritePrivateProfileString (called from WriteProperyString) will create it, and it will not support
        // characters that do not come from the default language (see bug 5005). This is why we just assert 
        // and continue (There will be a message in the log file, however).
        // YoelA - 20-Oct-99
        //
    }

    try
    {
        for (DWORD i = 0 ; SUCCEEDED(hr) && (i < cProps) ; i++ )
        {
            switch( aPropId[i] )
            {
                case PROPID_Q_TYPE:
                    hr = WriteProperyString(
                             lpszTemporaryFile,
                             LQS_TYPE_PROPERTY_NAME,
                             aPropVar[i].vt,
                             (const BYTE*) aPropVar[i].puuid);
                    break;

                case PROPID_Q_INSTANCE:
                    hr = WriteProperyString(
                             lpszTemporaryFile,
                             LQS_INSTANCE_PROPERTY_NAME,
                             aPropVar[i].vt,
                             (const BYTE*) aPropVar[i].puuid);
                    break;

                case PROPID_Q_BASEPRIORITY:
                    hr = WriteProperyString(
                             lpszTemporaryFile,
                             LQS_BASEPRIO_PROPERTY_NAME,
                             aPropVar[i].vt,
                             (const BYTE*) &aPropVar[i].iVal);
                    break;

                case PROPID_Q_JOURNAL:
                    hr = WriteProperyString(
                             lpszTemporaryFile,
                             LQS_JOURNAL_PROPERTY_NAME,
                             aPropVar[i].vt,
                             (const BYTE*) &aPropVar[i].bVal);
                    break;

                case PROPID_Q_QUOTA:
                    hr = WriteProperyString(
                             lpszTemporaryFile,
                             LQS_QUOTA_PROPERTY_NAME,
                             aPropVar[i].vt,
                             (const BYTE*) &aPropVar[i].ulVal);
                    break;

                case PROPID_Q_JOURNAL_QUOTA:
                    hr = WriteProperyString(
                             lpszTemporaryFile,
                             LQS_JQUOTA_PROPERTY_NAME,
                             aPropVar[i].vt,
                             (const BYTE*) &aPropVar[i].ulVal);
                    break;

                case PROPID_Q_CREATE_TIME:
                    hr = WriteProperyString(
                             lpszTemporaryFile,
                             LQS_TCREATE_PROPERTY_NAME,
                             aPropVar[i].vt,
                             (const BYTE*) &aPropVar[i].lVal);
                    break;

                case PROPID_Q_MODIFY_TIME:
                    hr = WriteProperyString(
                             lpszTemporaryFile,
                             LQS_TMODIFY_PROPERTY_NAME,
                             aPropVar[i].vt,
                             (const BYTE*) &aPropVar[i].lVal);
                     //
                     //  Modify time will be part of the properties only when
                     //  queue is created.
                     //
                     fModifyTimeIncluded = TRUE;
                     break;

                case PROPID_Q_SECURITY:
				    ASSERT( aPropVar[i].blob.pBlobData != NULL);
                    hr = WriteProperyString(
                             lpszTemporaryFile,
                             LQS_SECURITY_PROPERTY_NAME,
                             aPropVar[i].vt,
                             (const BYTE*) &aPropVar[i].blob);
                    break;

                case PPROPID_Q_TIMESTAMP:
                    hr = WriteProperyString(
                             lpszTemporaryFile,
                             LQS_TSTAMP_PROPERTY_NAME,
                             aPropVar[i].vt,
                             (const BYTE*) &aPropVar[i].blob);
                    break;

                case PROPID_Q_PATHNAME:
                    {
                        DWORD dwstrlen = wcslen(aPropVar[i].pwszVal);
                        AP<WCHAR> lpQueuePathName = new WCHAR [dwstrlen+1];
                        wcscpy(lpQueuePathName, aPropVar[i].pwszVal);
                        CharLower(lpQueuePathName);
    #ifdef _DEBUG
					    BOOL bIsDns;

					    if (! (IsPathnameForLocalMachine( lpQueuePathName,
                                                         &bIsDns)))
                        {
                            //
                            // This will happen when migrated BSC, after
                            // dcpromo create local queue. Such an operation
                            // issue a write-request to the PSC and we'll
                            // be here when notification arrive.
                            //
                            ASSERT((lpQueuePathName[0] == L'.') &&
                                   (lpQueuePathName[1] == L'\\')) ;
                        }

    #endif
					    //
					    // Extract the queue name from the path name
					    //
					    LPWSTR pSlashStart = wcschr(lpQueuePathName,L'\\');
					    ASSERT(pSlashStart);

                        hr = WriteProperyString(
                                 lpszTemporaryFile,
                                 LQS_QUEUENAME_PROPERTY_NAME,
                                 aPropVar[i].vt,
                                 (const BYTE *)(WCHAR *)pSlashStart);

                    }
                    break;

                case PROPID_Q_LABEL:
                    hr = WriteProperyString(
                             lpszTemporaryFile,
                             LQS_LABEL_PROPERTY_NAME,
                             aPropVar[i].vt,
                             (const BYTE*) aPropVar[i].pwszVal);
                    break;

                case PROPID_Q_AUTHENTICATE:
                    hr = WriteProperyString(
                             lpszTemporaryFile,
                             LQS_AUTH_PROPERTY_NAME,
                             aPropVar[i].vt,
                             (const BYTE*) &aPropVar[i].bVal);
                    break;

                case PROPID_Q_PRIV_LEVEL:
                    hr = WriteProperyString(
                             lpszTemporaryFile,
                             LQS_PRIVLEVEL_PROPERTY_NAME,
                             aPropVar[i].vt,
                             (const BYTE*) &aPropVar[i].ulVal);
                    break;

                case PROPID_Q_TRANSACTION:
                    hr = WriteProperyString(
                             lpszTemporaryFile,
                             LQS_TRANSACTION_PROPERTY_NAME,
                             aPropVar[i].vt,
                             (const BYTE*) &aPropVar[i].bVal);
                    break;

                case PPROPID_Q_SYSTEMQUEUE:
                    hr = WriteProperyString(
                             lpszTemporaryFile,
                             LQS_SYSQ_PROPERTY_NAME,
                             aPropVar[i].vt,
                             (const BYTE*) &aPropVar[i].bVal);
                    break;

                case PROPID_Q_MULTICAST_ADDRESS:
                    ASSERT(("Must be VT_EMPTY or VT_LPWSTR", aPropVar[i].vt == VT_EMPTY || aPropVar[i].vt == VT_LPWSTR));
                    ASSERT(("NULL not allowed", aPropVar[i].vt == VT_EMPTY || aPropVar[i].pwszVal != NULL));
                    ASSERT(("Empty string not allowed", aPropVar[i].vt == VT_EMPTY || L'\0' != *aPropVar[i].pwszVal));

                    hr = WriteProperyString(
                            lpszTemporaryFile,
                            LQS_MULTICAST_ADDRESS_PROPERTY_NAME,
                            aPropVar[i].vt,
                            (const BYTE*) aPropVar[i].pwszVal
                            );
                    break;

                case PROPID_Q_ADS_PATH:
                    ASSERT(("Setting PROPID_Q_ADS_PATH is not allowed", 0));
                    break;

                default:
                    // ASSERT(0);
                    break;
            }
        }

        //
        //  Update modify time field, if not included in the input properties
        //
        if (SUCCEEDED(hr) && !fModifyTimeIncluded)
        {
            TIME32 lTime = INT_PTR_TO_INT(time(NULL)); //BUGBUG bug year 2038
            hr = WriteProperyString(
                     lpszTemporaryFile,
                     LQS_TMODIFY_PROPERTY_NAME,
                     VT_I4,
                     (const BYTE*) &lTime);
        }
    }
    catch(...)
    {
        ASSERT(0);
        LogIllegalPoint(s_FN, 700);
        REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL,
                                          MSMQ_INTERNAL_ERROR,
                                          1,
                                          L"RegSetQueueProperties()")) ;
        hr = MQ_ERROR_INVALID_PARAMETER;
    }

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 545);
    }

    //
    // Write signature.
    //
    hr = WriteProperyString(lpszTemporaryFile,
                            LQS_SIGNATURE_NAME,
                            VT_LPWSTR,
                            (const BYTE*) LQS_SIGNATURE_VALUE ) ;

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 547);
    }

    if (!LqspFlushFile(lpszTemporaryFile))
    {
        return LogHR(GetLastError(), s_FN, 550);
    }

    //
    // Now that update is completed, we move the temporary file to the real file. 
    // This is an atomic operation
    //
    BOOL fMoveSucceeded = FALSE;
    
    if (fNewFile)
    {
        fMoveSucceeded = MoveFileEx(lpszTemporaryFile, lpszIniFile, MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH);
        //
        // Remove the temporary flag
        //
        BOOL fSetAttrSucceeded = SetFileAttributes(lpszIniFile, FILE_ATTRIBUTE_ARCHIVE);
        if (!fSetAttrSucceeded)
        {
           DWORD err = GetLastError();
           ASSERT(0);

           WRITE_MSMQ_LOG(( 
                 MSMQ_LOG_ERROR,
                 e_LogQM,
                 LOG_QM_ERRORS,
                 L"LQSSetProperties failed to set file attributes back to normal, LastError - %x, queue - %s, file - %s",
                 err,
                 lpszQueueName,
                 lpszIniFile));
           LogNTStatus(err, s_FN, 420);
        }

    }
    else
    {
        fMoveSucceeded = ReplaceFile(lpszIniFile, lpszTemporaryFile, 0, REPLACEFILE_WRITE_THROUGH, 0, 0);
    }

    if (fMoveSucceeded)
    {
        return MQ_OK;
    }

    DWORD err = GetLastError();

    WRITE_MSMQ_LOG(( 
         MSMQ_LOG_ERROR,
         e_LogQM,
         LOG_QM_ERRORS,
         L"LQSSetProperties failed to replace the LQS file with the temporary file. LastError - %x, queue - %s, LQS file - %s, Temporary file - %s",
         err,
         lpszQueueName,
         lpszIniFile,
         lpszTemporaryFile
         ));
    LogNTStatus(err, s_FN, 510);

    //
    // Generate an event log file to notify the user that the move failed
    //
    TCHAR szErr[20];
    _ultot(err,szErr,10);
    REPORT_WITH_STRINGS_AND_CATEGORY(( CATEGORY_KERNEL,
                             SET_QUEUE_PROPS_FAIL_COUND_NOT_REPLACE,
                             4,
                             lpszQueueName,
                             lpszTemporaryFile,
                             lpszIniFile,
                             szErr)) ;

    //
    // Well... We don't know why MoveFileEx failed. A reasonable reason may be 
    // insufficient resources, but other reasons may cause it as well (like permission issues).
    // We return the best error code we can. A detailed log was generated anyway.
    // (YoelA - 28-Jul-99)
    //
    return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 520);
}

//
// Read a property from an INI file.
//
STATIC
HRESULT
GetPropertyValue(
    LPCWSTR lpszFileName,   // The INI file name.
    LPCWSTR lpszPropName,   // The property name.
    VARTYPE vt,             // The var type of the property.
    PROPVARIANT *pPropVal)  // The propvar of the prperty.
{
    BOOL bShouldAllocate = FALSE;

    if (pPropVal->vt == VT_NULL)
    {
        //
        // Set the var type on the propvar and mark that we should allocate
        // the buffer for the property valkue, as neccessary.
        //
        pPropVal->vt = vt;
        bShouldAllocate = TRUE;
    }
    else
    {
        //
        // Validate the var type.
        //
        if (pPropVal->vt != vt)
        {
            return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VT, s_FN, 95);
        }
    }

    //
    // Try to retrieve the property value into a short buffer.
    //
    WCHAR awcShortBuff[64];
    AP<WCHAR> pLongBuff;
    WCHAR *pValBuff = awcShortBuff;
    DWORD dwBuffLen = sizeof(awcShortBuff)/sizeof(WCHAR);
    DWORD dwReqBuffLen;
    awcShortBuff[0] = '\0'; //for win95, when the entry is empty

    dwReqBuffLen = GetPrivateProfileString(LQS_PROP_SECTION_NAME,
                                           lpszPropName,
                                           TEXT(""),
                                           pValBuff,
                                           dwBuffLen,
                                           lpszFileName);

    //
    //   Either default string length, or
    //   a NULL string
    //
    if ( (!dwReqBuffLen) && (vt != VT_LPWSTR) )
    {
        //
        // Nothing was read, this is an error.
        //
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 100);
    }

    if (dwReqBuffLen == dwBuffLen - 1)
    {
        //
        // The buffer seem to be too short, try a larger buffer.
        //
        dwBuffLen = 512;
        do
        {
            delete[] pLongBuff.detach();
            //
            // Start with a 1K buffer. Each time that we fail we try with a
            // buffer that is twice as large, up to 64K.
            //
            dwBuffLen *= 2;
            pLongBuff = new WCHAR[dwBuffLen];
            pValBuff = pLongBuff;
            dwReqBuffLen = GetPrivateProfileString(LQS_PROP_SECTION_NAME,
                                                   lpszPropName,
                                                   TEXT(""),
                                                   pValBuff,
                                                   dwBuffLen,
                                                   lpszFileName);

        } while (dwReqBuffLen &&
                 (dwReqBuffLen == dwBuffLen - 1) &&
                 (dwBuffLen < LQS_MAX_VALUE_SIZE));

        if (!dwReqBuffLen)
        {
            //
            // Nothing was read, this is an error.
            //
            return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 110);
        }
    }


    //
    // Convert the string representation into the actual representation depending
    // on the property data type.
    //
    switch (vt)
    {
    case VT_UI1:
        swscanf(pValBuff, TEXT("%x"), &pPropVal->bVal);
        break;

    case VT_I2:
        {
            LONG lShort;

            swscanf(pValBuff, TEXT("%d"), &lShort);
            pPropVal->iVal = (SHORT)lShort;
        }
        break;

    case VT_I4:
        swscanf(pValBuff, TEXT("%d"), &pPropVal->lVal);
        break;

    case VT_UI4:
        swscanf(pValBuff, TEXT("%u"), &pPropVal->ulVal);
        break;

    case VT_LPWSTR:
        ASSERT(("Must be VT_NULL for strings!", bShouldAllocate));
        pPropVal->pwszVal = new WCHAR[dwReqBuffLen + 1];
        memcpy(pPropVal->pwszVal, pValBuff, sizeof(WCHAR) * (dwReqBuffLen + 1));
        break;

    case VT_CLSID:
        {
            ASSERT(dwReqBuffLen == 36);
            if (bShouldAllocate)
            {
                pPropVal->puuid = new GUID;
            }
            DWORD dwData4[8];
            int f = swscanf(pValBuff,
                        TEXT("%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x"),
                        &pPropVal->puuid->Data1,
                        &pPropVal->puuid->Data2,
                        &pPropVal->puuid->Data3,
                        &dwData4[0],
                        &dwData4[1],
                        &dwData4[2],
                        &dwData4[3],
                        &dwData4[4],
                        &dwData4[5],
                        &dwData4[6],
                        &dwData4[7]);
            ASSERT(f == 11);
			DBG_USED(f);

            pPropVal->puuid->Data4[0] = static_cast<BYTE>(dwData4[0]);
            pPropVal->puuid->Data4[1] = static_cast<BYTE>(dwData4[1]);
            pPropVal->puuid->Data4[2] = static_cast<BYTE>(dwData4[2]);
            pPropVal->puuid->Data4[3] = static_cast<BYTE>(dwData4[3]);
            pPropVal->puuid->Data4[4] = static_cast<BYTE>(dwData4[4]);
            pPropVal->puuid->Data4[5] = static_cast<BYTE>(dwData4[5]);
            pPropVal->puuid->Data4[6] = static_cast<BYTE>(dwData4[6]);
            pPropVal->puuid->Data4[7] = static_cast<BYTE>(dwData4[7]);
        }
        break;

    case VT_BLOB:
        {
            if (bShouldAllocate)
            {
                pPropVal->blob.cbSize = dwReqBuffLen / 2;
                pPropVal->blob.pBlobData = new BYTE[dwReqBuffLen / 2];
            }
            WCHAR *p = pValBuff;
            for (DWORD i = 0;
                 i < pPropVal->blob.cbSize;
                 i++, p += 2)
            {
                DWORD dwByte;
                int f = swscanf(p, TEXT("%02x"), &dwByte);
				DBG_USED(f);
                pPropVal->blob.pBlobData[i] = (BYTE)dwByte;
                ASSERT(f == 1);
            }
        }
        break;

    default:
        ASSERT(0);
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 120);
        break;
    }

    return MQ_OK;
}



//
// Get the queue name for the LQS file and concatenate the machine name
// to get the pathname
//
HRESULT GetPathNameFromQueueName(LPCWSTR lpszIniFile, LPCWSTR pMachineName, PROPVARIANT * pvar)
{
	ASSERT(pvar->vt == VT_NULL);

	HRESULT hr =  GetPropertyValue(lpszIniFile,
						LQS_QUEUENAME_PROPERTY_NAME,
						VT_LPWSTR,
						pvar);

	if(FAILED(hr))
		return LogHR(hr, s_FN, 130);

	ASSERT(pvar->pwszVal != NULL);
	DWORD dwLen=wcslen(pvar->pwszVal) + 1;
	AP<WCHAR> pwcsQueueName = pvar->pwszVal; //Keep original queuename.
											 //Will be automatically freed
	
    pvar->pwszVal=0; 
	pvar->pwszVal = new WCHAR [wcslen(pMachineName) +
							   dwLen];

	wcscpy(pvar->pwszVal, pMachineName);
	wcscat(pvar->pwszVal, pwcsQueueName);

	return LogHR(hr, s_FN, 140);
}



//
// Retrieve a queue properties out of the properties file.
//
HRESULT
LQSGetProperties(
    HLQS hLQS,              // A handle to the queue storage file.
    DWORD cProps,           // The number of properties.
    PROPID aPropId[],       // The property IDs.
    PROPVARIANT aPropVar[], // The property values.
    BOOL  fCheckFile)       // Check if file is corrupt.
{

    CS lock(g_LQSCS);
    HRESULT hr = MQ_OK ;
    LPCWSTR lpszIniFile = LQSReferenceHandle(hLQS)->GetFileName();

    try
    {
       for (DWORD i = 0 ;
            SUCCEEDED(hr) && (i < cProps);
            i++)
       {
          switch (aPropId[i])
          {
             case PROPID_Q_TYPE:
                 hr =  GetPropertyValue(lpszIniFile,
                                        LQS_TYPE_PROPERTY_NAME,
                                        VT_CLSID,
                                        aPropVar + i);
                 break;

             case PROPID_Q_INSTANCE:
                 hr =  GetPropertyValue(lpszIniFile,
                                        LQS_INSTANCE_PROPERTY_NAME,
                                        VT_CLSID,
                                        aPropVar + i);
                 break;

             case PROPID_Q_JOURNAL:
                 hr = GetPropertyValue(lpszIniFile,
                                       LQS_JOURNAL_PROPERTY_NAME,
                                       VT_UI1,
                                       aPropVar + i);
                 break;

             case PROPID_Q_BASEPRIORITY:
                 hr =  GetPropertyValue(lpszIniFile,
                                        LQS_BASEPRIO_PROPERTY_NAME,
                                        VT_I2,
                                        aPropVar + i);
                 break;

             case PROPID_Q_QUOTA:
                 hr =  GetPropertyValue(lpszIniFile,
                                        LQS_QUOTA_PROPERTY_NAME,
                                        VT_UI4,
                                        aPropVar + i);
                 break;

             case PROPID_Q_JOURNAL_QUOTA:
                 hr =  GetPropertyValue(lpszIniFile,
                                        LQS_JQUOTA_PROPERTY_NAME,
                                        VT_UI4,
                                        aPropVar + i);
                 break;
             case PROPID_Q_CREATE_TIME:
                 hr =  GetPropertyValue(lpszIniFile,
                                        LQS_TCREATE_PROPERTY_NAME,
                                        VT_I4,
                                        aPropVar + i);
                 break;
             case PROPID_Q_MODIFY_TIME:
                 hr =  GetPropertyValue(lpszIniFile,
                                        LQS_TMODIFY_PROPERTY_NAME,
                                        VT_I4,
                                        aPropVar + i);
                 break;
             case PROPID_Q_SECURITY:
                 hr =  GetPropertyValue(lpszIniFile,
                                        LQS_SECURITY_PROPERTY_NAME,
                                        VT_BLOB,
                                        aPropVar + i);
                 break;
             case PPROPID_Q_TIMESTAMP:
                 hr =  GetPropertyValue(lpszIniFile,
                                        LQS_TSTAMP_PROPERTY_NAME,
                                        VT_BLOB,
                                        aPropVar + i);
                 break;

			 case PROPID_Q_PATHNAME_DNS:
				 {
						AP<WCHAR> pwcsLocalMachineDnsName;

						GetDnsNameOfLocalMachine(&pwcsLocalMachineDnsName);

						if ( pwcsLocalMachineDnsName == NULL)
						{
							PROPVARIANT *pvar = aPropVar + i;
							//
							//  The DNS name of the local machine is unknown
							//
							pvar->vt = VT_EMPTY;
							pvar->pwszVal = NULL;
							hr = MQ_OK;
							break;
						}

						hr = GetPathNameFromQueueName(lpszIniFile, pwcsLocalMachineDnsName, aPropVar + i);

						break;

				 }

					
             case PROPID_Q_PATHNAME:
					hr = GetPathNameFromQueueName(lpszIniFile, g_szMachineName, aPropVar + i);
			
                 break;

             case PROPID_Q_LABEL:
                 hr =  GetPropertyValue(lpszIniFile,
                                        LQS_LABEL_PROPERTY_NAME,
                                        VT_LPWSTR,
                                        aPropVar + i);
                 break;

             case PROPID_Q_QMID:
                 //
                 // The QM GUID is not in queue registry (it's in each
                 // queue record in the MQIS database but not in registry
                 // which cache only local queues).
                 //
                 if (aPropVar[i].vt == VT_NULL)
                 {
                     aPropVar[i].puuid = new GUID;
                     aPropVar[i].vt = VT_CLSID;
                 }
                 *(aPropVar[i].puuid) = *(QueueMgr.GetQMGuid()) ;
                 break;

              case PROPID_Q_AUTHENTICATE:
                  hr =  GetPropertyValue(lpszIniFile,
                                         LQS_AUTH_PROPERTY_NAME,
                                         VT_UI1,
                                         aPropVar + i);
                  break;

              case PROPID_Q_PRIV_LEVEL:
                  hr =  GetPropertyValue(lpszIniFile,
                                         LQS_PRIVLEVEL_PROPERTY_NAME,
                                         VT_UI4,
                                         aPropVar + i);
                  break;

              case PROPID_Q_TRANSACTION:
                  hr =  GetPropertyValue(lpszIniFile,
                                         LQS_TRANSACTION_PROPERTY_NAME,
                                         VT_UI1,
                                         aPropVar + i);
                  break;

              case PPROPID_Q_SYSTEMQUEUE:
                  hr =  GetPropertyValue(lpszIniFile,
                                         LQS_SYSQ_PROPERTY_NAME,
                                         VT_UI1,
                                         aPropVar + i);
                  break;

             case PROPID_Q_MULTICAST_ADDRESS:
                 hr =  GetPropertyValue(lpszIniFile,
                                        LQS_MULTICAST_ADDRESS_PROPERTY_NAME,
                                        VT_LPWSTR,
                                        aPropVar + i);
                 if (SUCCEEDED(hr) && wcslen((aPropVar + i)->pwszVal) == 0)
                 {
                     delete (aPropVar + i)->pwszVal;
                     (aPropVar + i)->vt = VT_EMPTY;
                 }
                 break;

             case PROPID_Q_ADS_PATH:
                 (aPropVar + i)->vt = VT_EMPTY;
                 break;

           default:

                break;
          }
       }
    }

    catch(...)
    {
      
        REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL,
                                          MSMQ_INTERNAL_ERROR,
                                          1,
                                          L"LQSGetProperties()")) ;
        LogIllegalPoint(s_FN, 710);
        hr = MQ_ERROR_INVALID_PARAMETER;
    }

    if (fCheckFile)
    {
       //
       // Check if file is corrupted.
       //
       HRESULT hr1 = IsBadLQSFile(lpszIniFile) ;
	   if (FAILED(hr1))
       {
          hr=hr1;
       }
    }

    return LogHR(hr, s_FN, 150);
}

//
// Open a queue store file according to the queue's path name.
//
STATIC
HRESULT
LQSOpenInternal(
    LPCWSTR lpszFilePath,   // The file path in a wild card form.
    LPCWSTR lpszQueuePath,  // The queue path name
    HLQS *phLQS,            // A buffer to receive the new handle.
    LPWSTR pFilePath        // An optional buffer to receive the full filename
    )
{
    //
    // The file path is in the following format: drive:\path\*.xxxxxxxx The
    // xxxxxxxx is the hex value of the hash value for the queue name. Since
    // there might be colosions in the hash value, we should enumerate all
    // the files with the same hash value and see if the queue path name that
    // is stored inside the file matches the passed queue path name.
    // It is also possible that the file path will be as follows:
    // drive:\path\xxxxxxxx.* In this case, the searched queue is a private
    // queue. Also in this case, the queue path euals NULL. There should
    // be only one file that matches this wild card, because the queue ID is
    // unique.
    // A similar case also exist for a public queue when the passed file path
    // is of the following form:
    // drive\path\xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.*
    //
    HRESULT hr;
    WIN32_FIND_DATA FindData;
    CAutoCloseFindFile hFindFile = FindFirstFile(lpszFilePath, &FindData);
    WCHAR szFilePath[MAX_PATH_PLUS_MARGIN];

    if (hFindFile == INVALID_HANDLE_VALUE)
    {
        //
        // Nothing was found.
        //
        return LogHR(MQ_ERROR_QUEUE_NOT_FOUND, s_FN, 160);
    }

    while (TRUE)
    {
        P<_HLQS> hLQS;

        wcscpy(LQSGetDirectory(szFilePath), FindData.cFileName);
        LQSCreateHandle(NULL, szFilePath, &hLQS);
        if (pFilePath)
        {
            wcscpy(pFilePath, szFilePath);
        }

        //
        // Retrieve the queue path name.
        //
        PROPID PropId[1] = {PROPID_Q_PATHNAME};
        PROPVARIANT PropVal[1];
        PropVal[0].pwszVal = NULL ;
        PropVal[0].vt = VT_NULL;

        //
        // Check if file is corrupt and delete it if it is.
        //
        hr = LQSGetProperties(hLQS,
                              1,
                              PropId,
                              PropVal,
                              TRUE) ;

        //
        // Make sure that the buffer will get freed.
        //
        AP<WCHAR> pszQueuePath1 = PropVal[0].pwszVal;

        if (SUCCEEDED(hr))
        {
            if (!lpszQueuePath ||
                CompareStringsNoCaseUnicode(pszQueuePath1, lpszQueuePath) == 0)
            {
                //
                // If this is a private queue, or we have a match in the queue
                // path, we found it!
                //
                _HLQS *hRet;

                wcscpy(LQSGetDirectory(szFilePath), FindData.cFileName);
                LQSCreateHandle(pszQueuePath1, szFilePath, &hRet);
                LQSDuplicateHandle(phLQS, hRet);
                return MQ_OK;
            }
        }
        else if (hr == MQ_CORRUPTED_QUEUE_WAS_DELETED)
        {
            LPWSTR lpName = szFilePath ;
            if (PropVal[0].pwszVal && (wcslen(PropVal[0].pwszVal) > 1))
            {
               lpName = PropVal[0].pwszVal ;
            }

            REPORT_WITH_STRINGS_AND_CATEGORY(( CATEGORY_KERNEL,
                                         MQ_CORRUPTED_QUEUE_WAS_DELETED,
                                         2,
                                         FindData.cFileName,
                                         lpName )) ;
        }

        //
        // Try the next file.
        //
        if (!FindNextFile(hFindFile, &FindData))
        {
            LogHR(GetLastError(), s_FN, 190);
            return MQ_ERROR_QUEUE_NOT_FOUND;
        }
    }

    return MQ_OK;
}

//
// Open either a private or public queue store according to the queue path.
//
HRESULT
LQSOpen(
    LPCWSTR pszQueuePath,
    HLQS *phLQS,
    LPWSTR pFilePath
    )
{
    CS lock(g_LQSCS);
    WCHAR szFilePath[MAX_PATH_PLUS_MARGIN];

    LQSFilePath(LQS_PUBLIC_QUEUE,
                szFilePath,
                pszQueuePath,
                NULL,
                NULL);

    HRESULT hr2 = LQSOpenInternal(szFilePath, pszQueuePath, phLQS, pFilePath);
    return LogHR(hr2, s_FN, 200);
}

//
// Open a private queue store according to the queue ID.
//
HRESULT
LQSOpen(
    DWORD dwQueueId,
    HLQS *phLQS,
    LPWSTR pFilePath
    )
{
    CS lock(g_LQSCS);
    WCHAR szFilePath[MAX_PATH_PLUS_MARGIN];

    LQSFilePath(LQS_PRIVATE_QUEUE,
                szFilePath,
                NULL,
                NULL,
                &dwQueueId);

    HRESULT hr2 = LQSOpenInternal(szFilePath, NULL, phLQS, pFilePath);
    return LogHR(hr2, s_FN, 210);
}

//
// Open a public queue store according to the queue GUID.
//
HRESULT
LQSOpen(
    const GUID *pguidQueue,
    HLQS *phLQS,
    LPWSTR pFilePath
    )
{
    CS lock(g_LQSCS);
    WCHAR szFilePath[MAX_PATH_PLUS_MARGIN];

    LQSFilePath(LQS_PUBLIC_QUEUE,
                szFilePath,
                NULL,
                pguidQueue,
                NULL);

    HRESULT hr2 = LQSOpenInternal(szFilePath, NULL, phLQS, pFilePath);
    return LogHR(hr2, s_FN, 220);
}

//
// Close a queue store handle, or an enumeration handle.
//
HRESULT
LQSClose(
    HLQS hLQS)
{
    CS lock(g_LQSCS);

    LQSReferenceHandle(hLQS)->Release();

    return MQ_OK;
}

#ifdef _WIN64
HRESULT
LQSCloseWithMappedHLQS(
    DWORD dwMappedHLQS)
{
    HLQS hLQS =
       GET_FROM_CONTEXT_MAP(g_map_QM_HLQS, dwMappedHLQS, s_FN, 680); //this can throw on win64
    HRESULT hr = LQSClose(hLQS);
    return LogHR(hr, s_FN, 690);
}
#endif //_WIN64

//
// Delete a queue store.
//
HRESULT
LQSDeleteInternal(
    LPCWSTR lpszFilePath)   // The qeueu store path - wild card.
{
    //
    // Find the queue store file.
    //
    WIN32_FIND_DATA FindData;
    CAutoCloseFindFile hFindFile = FindFirstFile(lpszFilePath, &FindData);
    WCHAR szFilePath[MAX_PATH_PLUS_MARGIN];

    if (hFindFile == INVALID_HANDLE_VALUE)
    {
        return LogHR(MQ_ERROR_QUEUE_NOT_FOUND, s_FN, 230);
    }

    //
    // Delete the file.
    //
    wcscpy(LQSGetDirectory(szFilePath), FindData.cFileName);
    if (!DeleteFile(szFilePath))
    {
        DWORD err = GetLastError();
        ASSERT(0);
        WRITE_MSMQ_LOG(( 
             MSMQ_LOG_ERROR,
             e_LogQM,
             LOG_QM_ERRORS,
             L"LQSDeleteInternal failed to delete LQS file. LastError - %x, LQS file - %s",
             err,
             lpszFilePath
           ));

        LogNTStatus(err, s_FN, 240);
        return MQ_ERROR_QUEUE_NOT_FOUND;
    }

    return MQ_OK;
}

//
// Delete a private queue store.
//
HRESULT
LQSDelete(
    DWORD dwQueueId)
{
    CS lock(g_LQSCS);
    WCHAR szFilePath[MAX_PATH_PLUS_MARGIN];

    LQSFilePath(LQS_PRIVATE_QUEUE,
                szFilePath,
                NULL,
                NULL,
                &dwQueueId);

    HRESULT hr2 = LQSDeleteInternal(szFilePath);
    return LogHR(hr2, s_FN, 250);
}

//
// Delete a public queue store.
//
HRESULT
LQSDelete(
    const GUID *pguidQueue)
{
    CS lock(g_LQSCS);
    WCHAR szFilePath[MAX_PATH_PLUS_MARGIN];

    LQSFilePath(LQS_PUBLIC_QUEUE,
                szFilePath,
                NULL,
                pguidQueue,
                NULL);

    HRESULT hr2 = LQSDeleteInternal(szFilePath);
    return LogHR(hr2, s_FN, 260);
}

//
// Get the unique identifier of the private queue the is associated with the
// queue store handle. This will NOT fail if the handle is of a public queue.
//
HRESULT
LQSGetIdentifier(
    HLQS hLQS,      // The queue store handle
    DWORD *pdwId)   // A buffer that receives the resulted ID.
{
    CS lock(g_LQSCS);

    LPCWSTR lpszIniFile = LQSReferenceHandle(hLQS)->GetFileName();
    LPCWSTR lpszPoint = wcsrchr(lpszIniFile, L'.');
    int f = swscanf(lpszPoint - 8, TEXT("%08x"), pdwId);
	DBG_USED(f);
    ASSERT(f);

    return MQ_OK;
}

//
// Convert a file name string of a public queue store to it's GUID
// representation.
//
STATIC
void
LQSFileNameToGuid(
    LPCWSTR lpszFileName,
    GUID *pQueueGuid)
{
    WCHAR szData[9];
    int i;

    memcpy(szData, lpszFileName, 8 * sizeof(WCHAR));
    szData[8] = L'\0';
    swscanf(szData, TEXT("%08x"), &pQueueGuid->Data1);
    memcpy(szData, lpszFileName += 8, 4 * sizeof(WCHAR));
    szData[5] = L'\0';
    swscanf(szData, TEXT("%04x"), &pQueueGuid->Data2);
    memcpy(szData, lpszFileName += 4, 4 * sizeof(WCHAR));
    szData[5] = L'\0';
    swscanf(szData, TEXT("%04x"), &pQueueGuid->Data3);
    for (i = 0, lpszFileName += 4;
         i < 8;
         i++, lpszFileName += 2)
    {
        DWORD dwData4;
        memcpy(szData, lpszFileName, 2 * sizeof(WCHAR));
        szData[3] = L'\0';
        swscanf(szData, TEXT("%02x"), &dwData4);
        pQueueGuid->Data4[i] = static_cast<BYTE>(dwData4);
    }
}

//
// Convert a file name string of a private queue store to it's ID
// representation.
//
STATIC
void
LQSFileNameToId(
    LPCWSTR lpszFileName,
    DWORD *pQueueId)
{
    int f = swscanf(lpszFileName, TEXT("%08x"), pQueueId);
    ASSERT(f);
	DBG_USED(f);
}

//
// Get either the queue GUID or the queue unique ID from the queue store file
// name string.
//
STATIC
BOOL
LQSGetQueueInfo(
    LPCWSTR pszFileName,    // The queue store file name - not a full path.
    GUID *pguidQueue,       // A pointer to a buffer that receives the GUID.
                            // Should be NULL in case of a private queue.
    DWORD *pdwQueueId)      // A pointer to a buffer that receives the unique
                            // ID. Should be NULL in case of a public queue.
{
    BOOL bFound = FALSE;

    //
    // Find the point in the file name.
    //
    LPCWSTR lpszPoint = wcschr(pszFileName, L'.');
    ASSERT(((lpszPoint - pszFileName) == 8) ||  // In case of a private queue.
           ((lpszPoint - pszFileName) == 32));  // In case of a public queue.

    if (pguidQueue)
    {
        ASSERT(!pdwQueueId);
        //
        // We're interested in public queues only.
        //
        if (lpszPoint - pszFileName == 32)
        {
            //
            // This is indeed a public queue.
            //
            bFound = TRUE;
            LQSFileNameToGuid(pszFileName, pguidQueue);
        }
    }
    else
    {
        ASSERT(!pguidQueue);
        //
        // We're interested in private queues only.
        //
        if (lpszPoint - pszFileName == 8)
        {
            //
            // This is indeed a private queue.
            //
            bFound = TRUE;
            LQSFileNameToId(pszFileName, pdwQueueId);
        }
    }

    return bFound;
}

//
// Start the enumeration of either public or private queues
//
STATIC
HRESULT
LQSGetFirstInternal(
    HLQS *phLQS,        // The enumeration handle.
    GUID *pguidQueue,   // A buffer to receive the resulted GUID.
    DWORD *pdwQueueId)  // A buffer to receive the resulted ID.
{
    CS lock(g_LQSCS);
    WCHAR lpszFilePath[MAX_PATH_PLUS_MARGIN];
    //
    // Start the enumeration.
    //
    wcscpy(LQSGetDirectory(lpszFilePath), TEXT("*.*"));
    WIN32_FIND_DATA FindData;
    HANDLE hFindFile = FindFirstFile(lpszFilePath, &FindData);
    if (hFindFile == INVALID_HANDLE_VALUE)
    {
        return LogHR(MQ_ERROR_QUEUE_NOT_FOUND, s_FN, 270);
    }

    BOOL bFound = FALSE;

    //
    // Loop while we did not found the appropriate queue, i.e., public
    // or private
    //
    while (!bFound)
    {
        //
        // Skip over directories and queue of wrong type (private/public).
        //
        bFound = !(FindData.dwFileAttributes &
                        (FILE_ATTRIBUTE_DIRECTORY |
                         FILE_ATTRIBUTE_READONLY |      // Setup for some reasone creates a read-only
                         FILE_ATTRIBUTE_HIDDEN |        // hidden file named CREATE.DIR.
                         FILE_ATTRIBUTE_TEMPORARY)) &&  // Left-over temporary files   
                 LQSGetQueueInfo(FindData.cFileName, pguidQueue, pdwQueueId);

        if (bFound)
        {
            //
            // Found one! return a queue store handle.
            //
            _HLQS *hLQS = NULL;

            LQSCreateHandle(hFindFile, &hLQS);
            LQSDuplicateHandle(phLQS, hLQS);
        }
        else
        {
            //
            // Continue searching.
            //
            if (!FindNextFile(hFindFile, &FindData))
            {
                //
                // Found none!
                //
                LogNTStatus(GetLastError(), s_FN, 280);
                FindClose(hFindFile);
                return MQ_ERROR_QUEUE_NOT_FOUND;
            }
        }
    }

    return MQ_OK;
}

//
// Start the enumeration of public queues
//
HRESULT
LQSGetFirst(
    HLQS *phLQS,        // A buffer to receive the resulted enumeration handle.
    GUID *pguidQueue)   // A buffer to receive the GUID of the first found queue.
{
    HRESULT hr2 = LQSGetFirstInternal(phLQS, pguidQueue, NULL);
    return LogHR(hr2, s_FN, 290);
}

//
// Start the enumeration of private queues
//
HRESULT
LQSGetFirst(
    HLQS *phLQS,        // A buffer to receive the resulted enumeration handle.
    DWORD *pdwQueueId)  // A buffer to receive the ID of the first found queue.
{
    HRESULT hr2 = LQSGetFirstInternal(phLQS, NULL, pdwQueueId);
    return LogHR(hr2, s_FN, 300);
}

//
// Continue searching for more queues. Once the search fails, the handle should
// not be closed.
//
STATIC
HRESULT
LQSGetNextInternal(
    HLQS hLQS,          // The enumeration handle.
    GUID *pguidQueue,   // A buffer to receive the resulted queue GUID.
    DWORD *pdwQueueId)  // A buffer to receive the resulted queue ID.
{
    CS lock(g_LQSCS);
    BOOL bFound;
    WIN32_FIND_DATA FindData;
    HANDLE hFindFile = LQSReferenceHandle(hLQS)->GetFindHandle();

    do
    {
        //
        // Get the next file.
        //
        if (!FindNextFile(hFindFile, &FindData))
        {
            LogNTStatus(GetLastError(), s_FN, 310);
            LQSClose(hLQS);
            return MQ_ERROR_QUEUE_NOT_FOUND;
        }

        //
        // Skip directories and queue of wrong type (private/public).
        //
        bFound = !(FindData.dwFileAttributes &
                        (FILE_ATTRIBUTE_DIRECTORY |
                         FILE_ATTRIBUTE_READONLY |      // Setup for some reasone creates a read-only
                         FILE_ATTRIBUTE_HIDDEN   |      // hidden file named CREATE.DIR.
                         FILE_ATTRIBUTE_TEMPORARY)) &&  // Left-over temporary files   
                 LQSGetQueueInfo(FindData.cFileName, pguidQueue, pdwQueueId);
    } while (!bFound);

    return MQ_OK;
}

//
// Continue searching for more public queues. Once the search fails, the handle
// should not be closed.
//
HRESULT
LQSGetNext(
    HLQS hLQS,
    GUID *pguidQueue)
{
    return LogHR(LQSGetNextInternal(hLQS, pguidQueue, NULL), s_FN, 320);
}

//
// Continue searching for more private queues. Once the search fails, the handle
// should not be closed.
//
HRESULT
LQSGetNext(
    HLQS hLQS,
    DWORD *pdwQueueId)
{
    return LogHR(LQSGetNextInternal(hLQS, NULL, pdwQueueId), s_FN, 330);
}

#ifdef _WIN64
//
// Start the enumeration of public queues, return a mapped HLQS (e.g. DWORD)
//
HRESULT
LQSGetFirstWithMappedHLQS(
    DWORD *pdwMappedHLQS,
    DWORD *pdwQueueId)
{
    CS lock(g_LQSCS);
    CHLQS hLQS;

    HRESULT hr = LQSGetFirst(&hLQS, pdwQueueId);
    if (SUCCEEDED(hr))
    {
        //
        // create a DWORD mapping of this instance
        //
        DWORD dwMappedHLQS = ADD_TO_CONTEXT_MAP(g_map_QM_HLQS, (HLQS)hLQS, s_FN, 630); //this can throw bad_alloc on win64
        ASSERT(dwMappedHLQS != 0);
        //
        // save mapped HLQS in the _HLQS object for self destruction
        //
        LQSReferenceHandle(hLQS)->SetMappedHLQS(dwMappedHLQS);
        //
        // set returned mapped handle
        //
        *pdwMappedHLQS = dwMappedHLQS;
        hLQS = NULL;
    }
    return LogHR(hr, s_FN, 650);
}

//
// Continue searching for more private queues. Once the search fails, the handle
// should not be closed. Based on a mapped HLQS
//
HRESULT
LQSGetNextWithMappedHLQS(
    DWORD dwMappedHLQS,
    DWORD *pdwQueueId)
{
    HLQS hLQS = GET_FROM_CONTEXT_MAP(g_map_QM_HLQS, dwMappedHLQS, s_FN, 660); //this can throw on win64
    HRESULT hr = LQSGetNext(hLQS, pdwQueueId);
    return LogHR(hr, s_FN, 670);
}
#endif //_WIN64

HRESULT IsBadLQSFile( LPCWSTR lpszFileName,
                      BOOL    fDeleteIfBad /*= TRUE*/)
{
    WCHAR awcShortBuff[64];
    WCHAR *pValBuff = awcShortBuff;
    DWORD dwBuffLen = sizeof(awcShortBuff)/sizeof(WCHAR);
    DWORD dwReqBuffLen;
    awcShortBuff[0] = '\0';

    dwReqBuffLen = GetPrivateProfileString(LQS_PROP_SECTION_NAME,
                                           LQS_SIGNATURE_NAME,
                                           TEXT(""),
                                           pValBuff,
                                           dwBuffLen,
                                           lpszFileName);
    if ((dwReqBuffLen == wcslen(LQS_SIGNATURE_VALUE)) &&
        (CompareStringsNoCaseUnicode(pValBuff, LQS_SIGNATURE_VALUE) == 0))
    {
       //
       // Signature OK!
       //
       return MQ_OK ;
    }
    if ( dwReqBuffLen == 0)
    {
        //
        //  This can happen in low resources situation,
        //  GetPrivateProfileString will return zero bytes,
        //  assume the file is ok
        //
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 340);
    }

    if (fDeleteIfBad)
    {
        BOOL f = DeleteFile(lpszFileName) ;
        if (f)
        {
            return LogHR(MQ_CORRUPTED_QUEUE_WAS_DELETED, s_FN, 350);
        }

        DWORD err = GetLastError();
        WRITE_MSMQ_LOG(( 
            MSMQ_LOG_ERROR,
            e_LogQM,
            LOG_QM_ERRORS,
            L"IsBadLQSFile failed to delete bad LQS file. LastError - %x, LQS file - %s",
            err,
            lpszFileName
            ));

        ASSERT(("should succeed to delete lqs file!", f));
    }

    return LogHR(MQ_ERROR, s_FN, 360);
}

//
// Delete a queue store.
//
HRESULT
LQSDelete(
    HLQS hLQS
	)
{
    CS lock(g_LQSCS);

    LPCWSTR lpszIniFile = LQSReferenceHandle(hLQS)->GetFileName();

    BOOL f = DeleteFile(lpszIniFile) ;
    if (f)
	{
		LogNTStatus(GetLastError(), s_FN, 370);
        return MQ_CORRUPTED_QUEUE_WAS_DELETED;
	}
	return LogHR(MQ_ERROR, s_FN, 380);
}

//
// Cleanup temporary files. This is called from QMInit to delete 
// temporary (.tmp) files - result of previously failed SetProperties attempt
//
void
LQSCleanupTemporaryFiles()
{
    //
    // We don't really need the critical section here, since we are called from
    // QMInit. Just wanted to be on the safe side.
    //
    CS lock(g_LQSCS);

    WCHAR szTempFileWildcard[MAX_PATH_PLUS_MARGIN];
    WCHAR szFilePath[MAX_PATH_PLUS_MARGIN];
    //
    // Start the enumeration.
    //
    swprintf(LQSGetDirectory(szTempFileWildcard), TEXT("*%s"), x_szTemporarySuffix);
    WIN32_FIND_DATA FindData;
    HANDLE hFindFile = FindFirstFile(szTempFileWildcard, &FindData);
    if (hFindFile == INVALID_HANDLE_VALUE)
    {
        //
        // No temporary files left (normal case) return.
        //
        return;
    }

    //
    // Loop over the temporary files and delete them
    //
    while (TRUE)
    {
        QmpReportServiceProgress();

        wcscpy(LQSGetDirectory(szFilePath), FindData.cFileName);
        BOOL fDeleteSucceeded = DeleteFile(szFilePath);
        if (!fDeleteSucceeded)
        {
            //
            // Assert and report error - for debug purpose only.
            // Operation can continue normally
            //
            DWORD err = GetLastError();
            WRITE_MSMQ_LOG(( 
                 MSMQ_LOG_ERROR,
                 e_LogQM,
                 LOG_QM_ERRORS,
                 L"LQSCleanupTemporaryFiles failed to delete a temporary file. LastError - %x, file name - %s",
                 err,
                 szFilePath
                ));

            ASSERT(fDeleteSucceeded);
        }

        //
        // Loop step
        //
        if (!FindNextFile(hFindFile, &FindData))
        {
            FindClose(hFindFile);
            break;
        }
    }

}


static
bool
ShouldAddAnonymous(
	PSECURITY_DESCRIPTOR pSD
	)
/*++
Routine Description:
	Check if we should add Anonymous write message permissions
	to the security descriptor.
	The function return true in the following case only:
	the security descriptor has no deny on MQSEC_WRITE_MESSAGE permission
	everyone has that permission and anonymous don't have that permissions.

Arguments:
	pSD - pointer to the security descriptor.

Returned Value:
	true - should add write message permission to Anonymous, false - should not add.

--*/
{
	bool fAllGranted = false;
	bool fEveryoneGranted = false;
	bool fAnonymousGranted = false;

	IsPermissionGranted(
		pSD, 
		MQSEC_WRITE_MESSAGE,
		&fAllGranted, 
		&fEveryoneGranted, 
		&fAnonymousGranted 
		);

	TrTRACE(Lqs, "fEveryoneGranted = %d, fAnonymousGranted = %d", fEveryoneGranted, fAnonymousGranted);
	
	if(fEveryoneGranted && !fAnonymousGranted)
	{
		//
		// Only when everyone allowed and anonymous don't we should return true.
		//
		TrWARNING(Lqs, "The security descriptor need to add Anonymous");
		return true;
	}

	return false;
}


static
bool
AddAnonymousWriteMessagePermission( 
	PACL pDacl,
	CAutoLocalFreePtr& pDaclNew
    )
/*++
Routine Description:
	Create new DACL by adding anonymous ALLOW_ACE with MQSEC_WRITE_MESSAGE permission
	to existing DACL.

Arguments:
	pDacl - original DACL.
	pDaclNew - pointer to the new DACL that is created by this function

Returned Value:
	true - success, false - failure.

--*/
{
    ASSERT((pDacl != NULL) && IsValidAcl(pDacl));

    //
    // Create ace for the Anonymous, granting MQSEC_WRITE_MESSAGE permission.
    //
    EXPLICIT_ACCESS expAcss;
    memset(&expAcss, 0, sizeof(expAcss));

    expAcss.grfAccessPermissions = MQSEC_WRITE_MESSAGE;
    expAcss.grfAccessMode = GRANT_ACCESS;

    expAcss.Trustee.pMultipleTrustee = NULL;
    expAcss.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    expAcss.Trustee.TrusteeForm = TRUSTEE_IS_SID;
    expAcss.Trustee.TrusteeType = TRUSTEE_IS_USER;
    expAcss.Trustee.ptstrName = (WCHAR*) MQSec_GetAnonymousSid();

    //
    // Obtain new DACL, that merge present one with new ace.
    //
    DWORD rc = SetEntriesInAcl( 
						1,
						&expAcss,
						pDacl,
						reinterpret_cast<PACL*>(&pDaclNew) 
						);

    if (rc != ERROR_SUCCESS)
    {
		TrERROR(Lqs, "SetEntriesInAcl failed, error = 0x%x", rc);
		return false;
    }

    return true;
}


static
void
AddAnonymousToPrivateQueue(
	LPWSTR pFilePath, 
	LPWSTR pQueueName
	)
/*++
Routine Description:
	If needed add Anonymous MQSEC_WRITE_MESSAGE permission ACE to the
	queue security descriptor DACL.
	This will be done only to private queues. 

Arguments:
    pFilePath - the queue file path.
	pQueueName - Queue name

Returned Value:
	None

--*/
{
	TrTRACE(Lqs, "pQueueName = %ls", pQueueName);

	//
	// Check if this is Private queue
	//
	if(!FnIsPrivatePathName(pQueueName))
	{
		TrTRACE(Lqs, "The queue %ls is not private queue", pQueueName);
		return;
	}

	TrTRACE(Lqs, "The queue %ls is private queue", pQueueName);

	//
	// Get Queue Security descriptor
	//
	PROPVARIANT PropVal;
	PropVal.vt = VT_NULL;
    PropVal.blob.pBlobData = NULL;
    PropVal.blob.cbSize = 0;

    HRESULT hr =  GetPropertyValue( 
						pFilePath,
						LQS_SECURITY_PROPERTY_NAME,
						VT_BLOB,
						&PropVal 
						);

	if(FAILED(hr))
	{
		TrERROR(Lqs, "Failed to get LQS_SECURITY_PROPERTY_NAME for queue %ls, hr = 0x%x", pQueueName, hr);
		return;
	}

    AP<BYTE> pAutoReleaseSD = PropVal.blob.pBlobData;

	if(!ShouldAddAnonymous(PropVal.blob.pBlobData))
	{
		TrTRACE(Lqs, "No need to add anonymous permissions for queue %ls", pQueueName);
		return;
	}

	//
	// Get DACL Information
	//
	BOOL Defaulted;
	BOOL fAclExist;
	PACL pDacl;
	if (!GetSecurityDescriptorDacl(PropVal.blob.pBlobData, &fAclExist, &pDacl, &Defaulted))
	{
		DWORD gle = GetLastError();
		TrERROR(Lqs, "GetSecurityDescriptorDacl() failed, gle = 0x%x", gle);
		return;
	}

#ifdef _DEBUG
	TrTRACE(Lqs, "DACL information:");
	PrintAcl(fAclExist, Defaulted, pDacl);
#endif

	//
	// Create new DACL with Anonymous ALLOW_ACE for MQSEC_WRITE_MESSAGE permission 
	//
	CAutoLocalFreePtr pNewDacl;
	if(!AddAnonymousWriteMessagePermission(pDacl, pNewDacl))
	{
		TrERROR(Lqs, "Failed to create new DACL with Anonymous permissions");
		return;
	}

	ASSERT((pNewDacl.get() != NULL) && 
			IsValidAcl(reinterpret_cast<PACL>(pNewDacl.get())));

#ifdef _DEBUG
	TrTRACE(Lqs, "new DACL information:");
	PrintAcl(
		true, 
		false, 
		reinterpret_cast<PACL>(pNewDacl.get())
		);
#endif

	//
	// Merge the new DACL in the security descriptor
	//

    AP<BYTE> pNewSd;
	if(!MQSec_SetSecurityDescriptorDacl(
			reinterpret_cast<PACL>(pNewDacl.get()),
			PropVal.blob.pBlobData,
			pNewSd
			))
	{
		TrERROR(Lqs, "MQSec_UpdateSecurityDescriptorDacl() failed");
		return;
	}

    ASSERT((pNewSd.get() != NULL) && IsValidSecurityDescriptor(pNewSd));
	ASSERT(GetSecurityDescriptorLength(pNewSd) != 0);

    PropVal.vt = VT_BLOB;
    PropVal.blob.pBlobData = pNewSd.get();
    PropVal.blob.cbSize = GetSecurityDescriptorLength(pNewSd);

    hr = WriteProperyString( 
				pFilePath,
				LQS_SECURITY_PROPERTY_NAME,
				VT_BLOB,
				reinterpret_cast<const BYTE*>(&PropVal.blob) 
				);

	if(FAILED(hr))
	{
		TrERROR(Lqs, "Failed to set LQS_SECURITY_PROPERTY_NAME for queue %ls, hr = 0x%x", pQueueName, hr);
		return;
	}

	TrTRACE(Lqs, "Anonymous permissions were set for queue %ls", pQueueName);

}


void SetLqsUpdatedSD()
/*++
Routine Description:
	Set MSMQ_LQS_UPDATED_SD_REGNAME registry value to 1

Arguments:
	None

Returned Value:
	None

--*/
{
    DWORD dwType = REG_DWORD;
    DWORD dwSize = sizeof(DWORD);
	DWORD Value = 1;

    LONG rc = SetFalconKeyValue(
					MSMQ_LQS_UPDATED_SD_REGNAME,
					&dwType,
					&Value,
					&dwSize
					);

	DBG_USED(rc);
    ASSERT(rc == ERROR_SUCCESS);
}


static bool IsLqsUpdatedSD()
/*++
Routine Description:
	Read MSMQ_LQS_UPDATED_SD_REGNAME registry value

Arguments:
	None

Returned Value:
	true - lqs was already updated, false otherwise

--*/
{
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = REG_DWORD;
    DWORD dwLqsUpdated = REG_DWORD;

    LONG rc = GetFalconKeyValue( 
					MSMQ_LQS_UPDATED_SD_REGNAME,
					&dwType,
					&dwLqsUpdated,
					&dwSize 
					);

	if((rc == ERROR_SUCCESS) && (dwLqsUpdated != 0))
		return true;

	return false;
}


//-----------------------------
// MigrateLQSFromNT4
//
// Migrate all the LQS files from NT4 format.
//
// In NT4 format - the suffix (Hash) of the file name is based on machinename\queuename
//
// We will migrate so suffix (hash) is based on \queuename only.
//
// In addition this routine check if we need to update private queues DACL 
//
// and add Anonymous ALLOW_ACE with MQSEC_WRITE_MESSAGE permissinn
//
// This routine is idempotent (can be called several times without destroying anything)
//
// Return TRUE always
//
// -----------------------------
BOOL MigrateLQS()
{
	if(IsLqsUpdatedSD())
	{
		//
		// In this case that we already updated the lqs security descriptor
		// lqs files are already converted so no need to perform
		// the migration again
		//
		TrTRACE(Lqs, "LQS already updated its security descriptor");
		return TRUE;
	}
    
	WCHAR szFilePath[MAX_PATH_PLUS_MARGIN];

    wcscpy(LQSGetDirectory(szFilePath), L"*.*");

	TrTRACE(Lqs, "LQS search path = %ls", szFilePath);

    WIN32_FIND_DATA FindData;
    CAutoCloseFindFile hFindFile = FindFirstFile(szFilePath, &FindData);

    if (hFindFile == INVALID_HANDLE_VALUE)
    {
        //
        // Nothing was found. This is weird...
        //
		ASSERT(0);
        return TRUE;
    }

    AP<BYTE> pSecurityDescriptor;
	do  // while(FindNextFile(hFindFile, &FindData) != FALSE)
    {
        QmpReportServiceProgress();

        //
        // Skip over directories and queue of wrong type (private/public).
        //
        BOOL fFound = !(FindData.dwFileAttributes &
                        (FILE_ATTRIBUTE_DIRECTORY |
                         FILE_ATTRIBUTE_READONLY  |     // Setup for some reasone creates a read-only
                         FILE_ATTRIBUTE_HIDDEN    |     // hidden file named CREATE.DIR.
                         FILE_ATTRIBUTE_TEMPORARY));   // Left-over temporary files    

		if(!fFound)
			continue;


        wcscpy(LQSGetDirectory(szFilePath), FindData.cFileName);

		TrTRACE(Lqs, "LQS file = %ls", szFilePath);

        //
        // Try to retrieve the queue name.
        //
		PROPVARIANT PropVal;
        PropVal.pwszVal = NULL;
        PropVal.vt = VT_NULL;
		HRESULT hr =  GetPropertyValue(
							szFilePath,
							LQS_QUEUENAME_PROPERTY_NAME,
							VT_LPWSTR, 
							&PropVal
							);


		if(FAILED(hr))
		{
			TrERROR(Lqs, "Failed to get LQS_QUEUENAME_PROPERTY_NAME from file %ls, hr = 0x%x", szFilePath, hr);
		}

        //
        // Make sure that the buffer will get freed.
        //
        AP<WCHAR> pqp = PropVal.pwszVal;

		if(PropVal.pwszVal[0] != 0)
		{
			//
			// File has a pathname property
			// This means that it is a converted one
			// check if we need to update private queues DACL 
			// and add Anonymous ALLOW_ACE with MQSEC_WRITE_MESSAGE permissinn
			//
			TrTRACE(Lqs, "the file %ls is already in w2k format", szFilePath);
			AddAnonymousToPrivateQueue(szFilePath, pqp.get());

			//
			// skip to the next file
			//
			continue;
		}


        //
        // Retrieve the path name.
        //
        PropVal.pwszVal = NULL;
        PropVal.vt = VT_NULL;
		hr =  GetPropertyValue(
					szFilePath,
					LQS_PATHNAME_PROPERTY_NAME,
					VT_LPWSTR, 
					&PropVal
					);

        //
        // Make sure that the buffer will get freed.
        //
        AP<WCHAR> pqp1 = PropVal.pwszVal;

		if(PropVal.pwszVal[0] == 0)
		{
			//
			// File does not have a PATHNAME
			// Bad file
			//
			TrERROR(Lqs, "File %ls doesn't have LQS_PATHNAME_PROPERTY_NAME, hr = 0x%x", szFilePath, hr);
			continue;
		}
	
		//
		// Extract the queue name from the path name
		//
		LPWSTR pSlashStart = wcschr(PropVal.pwszVal,L'\\');

		if(pSlashStart == NULL)
		{
			//
			// Invalid queue name - No slash in queue name - Ignore
			//
			TrERROR(Lqs, "Invalid queue name, path = %ls", PropVal.pwszVal);
			ASSERT(pSlashStart);
			continue;
		}


		//
		// Compute Hash value
		//
		DWORD Win2000HashVal = HashQueuePath(pSlashStart);

		WCHAR Win2000LQSName[MAX_PATH_PLUS_MARGIN];
        wcscpy(Win2000LQSName, szFilePath);

		LPWSTR pDot = wcsrchr(Win2000LQSName, L'.');

		if(lstrlen(pDot) != 9)
		{
			//
			// File suffix is not in the form *.1234578 - ignore
			// For example - 000000001.12345678.old
			//
			TrERROR(Lqs, "File %ls, prefix is not in the required form", szFilePath);
			continue;
		}

#ifdef _DEBUG

		DWORD fp;
		swscanf(pDot+1, TEXT("%x"), &fp);

		ASSERT(fp != Win2000HashVal);

#endif

		//
		// If we got up to here - this means we need to update
		// the file
		//

		//
		// Write the queue name in the LQS file
		//
        hr = WriteProperyString(
                 szFilePath,
                 LQS_QUEUENAME_PROPERTY_NAME,
                 VT_LPWSTR, 
				 (const BYTE *)(WCHAR *)pSlashStart
				 );

		
		if(FAILED(hr))
		{
			TrERROR(Lqs, "Failed to set LQS_QUEUENAME_PROPERTY_NAME for file %ls, hr = 0x%x", szFilePath, hr);
			ASSERT(0);
			continue;
		}

        PropVal.vt = VT_NULL ;
        PropVal.blob.pBlobData = NULL ;
        PropVal.blob.cbSize = 0 ;

        hr =  GetPropertyValue( 
					szFilePath,
					LQS_SECURITY_PROPERTY_NAME,
					VT_BLOB,
					&PropVal 
					);

        if (hr == MQ_ERROR_INVALID_PARAMETER)
        {
            //
            // Security property does not exist. This may happen when
            // upgrading from Win9x to Windows 2000. Create a security
            // descriptor that grant everyone full control.
            //
            static  BOOL  fInit = FALSE;
            static  DWORD dwSDLen = 0;

            if (!fInit)
            {
                SECURITY_DESCRIPTOR sd;

                BOOL f = InitializeSecurityDescriptor(
								&sd,
								SECURITY_DESCRIPTOR_REVISION 
								);
                ASSERT(f);
                //
                // a NULL dacl grant everyone full control.
                //
                f = SetSecurityDescriptorDacl( 
							&sd,
							TRUE,
							NULL,
							FALSE 
							);
                ASSERT(f);

                //
                // the defautl descriptor will include the null dacl and
                // will retrieve owner and group from thread access token.
                //
                hr =  MQSec_GetDefaultSecDescriptor(
                             MQDS_QUEUE,
                            (PSECURITY_DESCRIPTOR *) &pSecurityDescriptor,
                             FALSE,
                            &sd,
                             0,		// seInfoToRemove
                             e_UseDefaultDacl
							 );

                ASSERT(SUCCEEDED(hr));
                LogHR(hr, s_FN, 193);

                if (SUCCEEDED(hr))
                {
                    dwSDLen = GetSecurityDescriptorLength(pSecurityDescriptor);
                }

                fInit = TRUE;
            }

            if (dwSDLen > 0)
            {
                PropVal.vt = VT_BLOB;
                PropVal.blob.pBlobData = (BYTE*) pSecurityDescriptor;
                PropVal.blob.cbSize = dwSDLen;

                ASSERT(IsValidSecurityDescriptor(pSecurityDescriptor));

                hr = WriteProperyString( 
						szFilePath,
						LQS_SECURITY_PROPERTY_NAME,
						VT_BLOB,
						(const BYTE*) &PropVal.blob 
						);

                PropVal.blob.pBlobData = NULL; // prevent auto-release.
            }
        }

        ASSERT(SUCCEEDED(hr));
        LogHR(hr, s_FN, 192);
        AP<BYTE> pAutoReleaseSD = PropVal.blob.pBlobData;

		//
		// check if we need to update private queues DACL 
		// and add Anonymous ALLOW_ACE with MQSEC_WRITE_MESSAGE permission
		//
		AddAnonymousToPrivateQueue(szFilePath, pSlashStart);

		//
		// Replace the old hash by the new one in the file name
		//
		swprintf(pDot, TEXT(".%08x"), Win2000HashVal);

		//
		// And rename the file
		//
		int rc = _wrename(szFilePath, Win2000LQSName);
		DBG_USED(rc);
		
		ASSERT(rc == 0);

	} while(FindNextFile(hFindFile, &FindData) != FALSE);

	SetLqsUpdatedSD();

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\midluser.cpp ===
#include <stdh.h>

#include "..\\common\\midluser.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\mgmt.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    mgmt.cpp

Abstract:

   MSMQ Local machine adminstration

Author:

    Uri Habusha (urih) June, 1998

--*/

#include "stdh.h"

#include <qmmgmt.h>
#include <mqutil.h>

#include "cqmgr.h"
#include "cqpriv.h"
#include "sessmgr.h"
#include "acapi.h"
#include "xact.h"
#include "xactout.h"
#include "xactin.h"
#include "onhold.h"

#include "mgmt.tmh"

extern CSessionMgr SessionMgr;
extern LPTSTR g_szMachineName;
extern HANDLE g_hAc;

static WCHAR *s_FN=L"mgmt";

STATIC
void
FreeVariant(
    PROPVARIANT& var
    );


STATIC
void
GetOpenQueues(
    PROPVARIANT& var
    )
{
    //
    // Initialize the LPWSTR array
    //
    var.calpwstr.cElems = 0;
    var.calpwstr.pElems = NULL;

    QueueMgr.GetOpenQueuesFormatName(
                    &var.calpwstr.pElems,
                    &var.calpwstr.cElems
                    );

    var.vt = VT_LPWSTR | VT_VECTOR;
}


STATIC
void
GetPrivateQueueList(
    PROPVARIANT& var
    )
{
    HRESULT  hr;
    LPWSTR  strPathName;
    DWORD  dwQueueId;
    LPVOID pos;
    DWORD NumberOfQueues = 0;

    //
    // lock to ensure private queues are not added or deleted while filling the
    // buffer.
    //
    CS lock(g_QPrivate.m_cs);

    //
    // Write the pathnames into the buffer.
    //
    hr = g_QPrivate.QMGetFirstPrivateQueuePosition(pos, strPathName, dwQueueId);

    if (FAILED(hr))
    {
        return;
    }

    const DWORD x_IncrementBufferSize = 100;
    LPWSTR* listPrivateQueue = NULL;
    DWORD MaxBufferSize = 0;

    try
    {
        while (SUCCEEDED(hr))
        {
			if(dwQueueId <= MAX_SYS_PRIVATE_QUEUE_ID)
			{
				//
				// Filter out system queues out of the list
				//
				hr = g_QPrivate.QMGetNextPrivateQueue(pos, strPathName, dwQueueId);
				continue;
			}

            //
            // Check if there is still enough space
            //
            if (NumberOfQueues == MaxBufferSize)
            {
                //
                // Allocate a new buffer
                //
                LPWSTR* tempBuffer = new LPWSTR [MaxBufferSize + x_IncrementBufferSize];
                MaxBufferSize = MaxBufferSize + x_IncrementBufferSize;

                //
                // Copy the information from the old buffer to the new one
                //
                memcpy(tempBuffer, listPrivateQueue, NumberOfQueues*sizeof(LPWSTR));

                delete [] listPrivateQueue;
                listPrivateQueue= tempBuffer;
            }

            //
            // Add the Queue to the list
            //
            listPrivateQueue[NumberOfQueues] = strPathName;
            ++NumberOfQueues;

            //
            // Get Next Private queue
            //
            hr = g_QPrivate.QMGetNextPrivateQueue(pos, strPathName, dwQueueId);
        }
    }
    catch(const bad_alloc&)
    {
        while(NumberOfQueues)
        {
            delete []  listPrivateQueue[--NumberOfQueues];
        }

        delete [] listPrivateQueue;
        LogIllegalPoint(s_FN, 61);

        throw;
    }


    var.calpwstr.cElems = NumberOfQueues;
    var.calpwstr.pElems = listPrivateQueue;
    var.vt = VT_LPWSTR | VT_VECTOR;

    return;
}


STATIC
void
GetMsmqType(
    PROPVARIANT& var
    )
{
    var.pwszVal = MSMQGetQMTypeString();
    var.vt = VT_LPWSTR;
}


STATIC
void
GetDsServer(
    PROPVARIANT& var
    )
{
    if (!QueueMgr.CanAccessDS())
    {
        return;
    }


    WCHAR DSServerName[MAX_PATH];
    DWORD dwSize = sizeof(DSServerName);
    DWORD dwType = REG_SZ;
    LONG rc = GetFalconKeyValue(
                    MSMQ_DS_CURRENT_SERVER_REGNAME,
                    &dwType,
                    DSServerName,
                    &dwSize
                    );

    if (rc != ERROR_SUCCESS)
    {
        //
        // No DS server.
        //
        return;
    }

    if(DSServerName[0] == L'\0')
    {
        return;
    }

    var.pwszVal = new WCHAR[wcslen(DSServerName)];
    var.vt = VT_LPWSTR;

    //
    // skip the 2 first character that indicates supported protocols
    //
    wcscpy(var.pwszVal, DSServerName+2);
}


STATIC
void
GetDSConnectionMode(
    PROPVARIANT& var
    )
{
    C_ASSERT(15 > STRLEN(MSMQ_CONNECTED));
    C_ASSERT(15 > STRLEN(MSMQ_DISCONNECTED));

    var.pwszVal = new WCHAR[15];
    var.vt = VT_LPWSTR;

    if (QueueMgr.IsConnected())
    {
        wcscpy(var.pwszVal, MSMQ_CONNECTED);
    }
    else
    {
        wcscpy(var.pwszVal, MSMQ_DISCONNECTED);
    }
}


STATIC
HRESULT
GetMachineInfo(
    DWORD cprop,
    PROPID* propId,
    PROPVARIANT* propVar
    )
{
    for(DWORD i =0; i < cprop; ++i)
    {
        ASSERT(propVar[i].vt == VT_NULL);

        switch(propId[i])
        {
            case PROPID_MGMT_MSMQ_ACTIVEQUEUES:
                GetOpenQueues(propVar[i]);
                break;

            case PROPID_MGMT_MSMQ_DSSERVER:
                GetDsServer(propVar[i]);
                break;

            case PROPID_MGMT_MSMQ_CONNECTED:
                GetDSConnectionMode(propVar[i]);
                break;

            case PROPID_MGMT_MSMQ_PRIVATEQ:
                GetPrivateQueueList(propVar[i]);
                break;

            case PROPID_MGMT_MSMQ_TYPE:
                GetMsmqType(propVar[i]);
                break;

            default:
                ASSERT(0);

        }
    }

    return MQ_OK;
}


STATIC
void
GetQueuePathName(
    CQueue* pQueue,
    PROPVARIANT& var
    )
{
    ASSERT(pQueue != NULL);

    if ((pQueue->GetQueueType() == QUEUE_TYPE_UNKNOWN) ||
        (pQueue->IsPrivateQueue() && !pQueue->IsLocalQueue()))
        return;

    //
    // retrieve the Queue Name from the Queue Object
    //
    LPCWSTR pQueueName = pQueue->GetQueueName();

    if (pQueueName == NULL)
        return;

    //
    // Copy the name to new buffer and update the prop variant
    //
    LPWSTR tempBuffer = new WCHAR[wcslen(pQueueName)+1];
    wcscpy(tempBuffer, pQueueName);

    var.pwszVal = tempBuffer;
    var.vt = VT_LPWSTR;
}


STATIC
void
GetQueueFormatName(
    CQueue* pQueue,
    PROPVARIANT& var
    )
{
    ASSERT(pQueue != NULL);

    WCHAR FormatName[1000];
    DWORD dwFormatSize = 1000;

    HRESULT hr = ACHandleToFormatName(
            pQueue->GetQueueHandle(),
            FormatName,
            &dwFormatSize
            );
    LogHR(hr, s_FN, 101);


    //
    // Copy the name to new buffer and update the prop variant
    //
    LPWSTR tempBuffer = new WCHAR[wcslen(FormatName)+1];
    wcscpy(tempBuffer, FormatName);

    var.pwszVal = tempBuffer;
    var.vt = VT_LPWSTR;
}


STATIC
void
GetQueueState(
    CQueue* pQueue,
    PROPVARIANT& var
    )
{
    LPCWSTR ConnectionState = pQueue->GetConnectionStatus();

    LPWSTR pBuf = new WCHAR[wcslen(ConnectionState) + 1];
    wcscpy(pBuf,ConnectionState);

    var.pwszVal = pBuf;
    var.vt = VT_LPWSTR;
}


STATIC
void
GetQueueType(
    CQueue* pQueue,
    PROPVARIANT& var
    )
{
    LPCWSTR pQueueType = pQueue->GetType();

    LPWSTR pBuf = new WCHAR[wcslen(pQueueType) + 1];
    wcscpy(pBuf, pQueueType);

    var.pwszVal = pBuf;
    var.vt = VT_LPWSTR;
}



STATIC
void
GetQueueLocation(
    CQueue* pQueue,
    PROPVARIANT& var
    )
{
    C_ASSERT(10 > STRLEN(MGMT_QUEUE_LOCAL_LOCATION));
    C_ASSERT(10 > STRLEN(MGMT_QUEUE_REMOTE_LOCATION));

    var.pwszVal = new WCHAR[10];
    var.vt = VT_LPWSTR;

    if (pQueue->IsLocalQueue())
    {
        wcscpy(var.pwszVal, MGMT_QUEUE_LOCAL_LOCATION);
    }
    else
    {
        wcscpy(var.pwszVal, MGMT_QUEUE_REMOTE_LOCATION);
    }
}


STATIC
void
GetQueueXact(
    CQueue* pQueue,
    PROPVARIANT& var
    )
{
    C_ASSERT(20 > STRLEN(MGMT_QUEUE_UNKNOWN_TYPE));
    C_ASSERT(20 > STRLEN(MGMT_QUEUE_CORRECT_TYPE));
    C_ASSERT(20 > STRLEN(MGMT_QUEUE_INCORRECT_TYPE));

    var.pwszVal = new WCHAR[20];
    var.vt = VT_LPWSTR;

    if (pQueue->IsUnkownQueueType())
    {
        wcscpy(var.pwszVal, MGMT_QUEUE_UNKNOWN_TYPE);
    }
    else
    {
        if (pQueue->IsTransactionalQueue())
        {
            wcscpy(var.pwszVal, MGMT_QUEUE_CORRECT_TYPE);
        }
        else
        {
            wcscpy(var.pwszVal, MGMT_QUEUE_INCORRECT_TYPE);
        }
    }
}


STATIC
void
GetQueueForeign(
    CQueue* pQueue,
    PROPVARIANT& var
    )
{
    C_ASSERT(20 > STRLEN(MGMT_QUEUE_UNKNOWN_TYPE));
    C_ASSERT(20 > STRLEN(MGMT_QUEUE_CORRECT_TYPE));
    C_ASSERT(20 > STRLEN(MGMT_QUEUE_INCORRECT_TYPE));

    var.pwszVal = new WCHAR[20];
    var.vt = VT_LPWSTR;

    if (pQueue->IsUnkownQueueType())
    {
        if (pQueue->IsPrivateQueue())
        {
            wcscpy(var.pwszVal, MGMT_QUEUE_INCORRECT_TYPE);
        }
        else
        {
            wcscpy(var.pwszVal, MGMT_QUEUE_UNKNOWN_TYPE);
        }
    }
    else
    {
        if (pQueue->IsForeign())
        {
            wcscpy(var.pwszVal, MGMT_QUEUE_CORRECT_TYPE);
        }
        else
        {
            wcscpy(var.pwszVal, MGMT_QUEUE_INCORRECT_TYPE);
        }
    }
}


STATIC
void
GetQueueNextHops(
    CQueue* pQueue,
    PROPVARIANT& var
    )
{
    LPWSTR* NextHopsArray;
    DWORD NoOfNextHops;

    ASSERT(pQueue != NULL);

    if(pQueue->IsLocalQueue())
        return;

    for (;;)
    {
        HRESULT hr;
        LPCWSTR ConnectionStatus = pQueue->GetConnectionStatus();

        if (pQueue->IsDirectHttpQueue())
        {
            //
            // BUGBUG: must add GetAddress methode to CTransport
            //                              Uri Habusha, 16-May-2000
            //
            return;
        }

        if (wcscmp(ConnectionStatus, MGMT_QUEUE_STATE_CONNECTED) == 0)
        {

            LPWSTR pNextHop = pQueue->GetNextHop();
            if (pNextHop == NULL)
            {
                //
                // The Queue isn't in connected status anymore. Get the new status
                //
                continue;
            }

            NoOfNextHops = 1;
            NextHopsArray = new LPWSTR[1];
            NextHopsArray[0] = pNextHop;
            break;
        }

        if (wcscmp(ConnectionStatus, MGMT_QUEUE_STATE_WAITING) == 0)
        {
            hr = SessionMgr.ListPossibleNextHops(pQueue, &NextHopsArray, &NoOfNextHops);
            if (FAILED(hr))
            {
                //
                // The Queue isn't in waiting status anymore. Get the new status
                //
                continue;
            }

            break;

        }

        //
        // The Queue is in NONACTIVE or NEADVALIDATE status.
        //
        return;
    }

    var.calpwstr.cElems = NoOfNextHops;
    var.calpwstr.pElems = NextHopsArray;
    var.vt = VT_LPWSTR | VT_VECTOR;
}


STATIC
void
GetQueueMessageCount(
    CQueue* pQueue,
    PROPVARIANT& var,
    CACGetQueueProperties& qp
    )
{
    var.ulVal = qp.ulCount;
    var.vt = VT_UI4;
}


STATIC
void
GetJournalQueueMessageCount(
    CQueue* pQueue,
    PROPVARIANT& var,
    CACGetQueueProperties& qp
    )
{
    var.ulVal = qp.ulJournalCount;
    var.vt = VT_UI4;
}


STATIC
void
GetQueueUsedQuata(
    CQueue* pQueue,
    PROPVARIANT& var,
    CACGetQueueProperties& qp
    )
{
    var.ulVal = qp.ulQuotaUsed;
    var.vt = VT_UI4;
}


STATIC
void
GetJournalQueueUsedQuata(
    CQueue* pQueue,
    PROPVARIANT& var,
    CACGetQueueProperties& qp
    )
{
    var.ulVal = qp.ulJournalQuotaUsed;
    var.vt = VT_UI4;
}


STATIC
void
GetQueueEODNextSequence(
    CQueue* pQueue,
    PROPVARIANT& var,
    CACGetQueueProperties& qp
    )
{
    if (pQueue->IsLocalQueue())
        return;

    SEQUENCE_INFO* pSeqInfo = new SEQUENCE_INFO;
    pSeqInfo->SeqID = qp.liSeqID;
    pSeqInfo->SeqNo = qp.ulSeqNo;
    pSeqInfo->PrevNo = qp.ulPrevNo;

    var.blob.cbSize = sizeof(SEQUENCE_INFO);
    var.blob.pBlobData = reinterpret_cast<BYTE*>(pSeqInfo);
    var.vt = VT_BLOB;
}


STATIC
void
GetQueueEODLastAcked(
    CQueue* pQueue,
    PROPVARIANT& var,
    CACGetQueueProperties& qp
    )
{
    if (pQueue->IsLocalQueue())
        return;

    HRESULT hr;
    ULONG AckedSeqNumber;
    hr = g_OutSeqHash.GetLastAck(qp.liSeqID, AckedSeqNumber);
    if (FAILED(hr))
    {
        //
        // The sequence was not found in the internal data
        // structure. This can be only when all the messages
        // have been acknowledged
        //
        return;
    }

    SEQUENCE_INFO* pSeqInfo = new SEQUENCE_INFO;
    pSeqInfo->SeqID = qp.liSeqID;
    pSeqInfo->SeqNo = AckedSeqNumber;
    pSeqInfo->PrevNo = 0;

    var.blob.cbSize = sizeof(SEQUENCE_INFO);
    var.blob.pBlobData = reinterpret_cast<BYTE*>(pSeqInfo);
    var.vt = VT_BLOB;
}


STATIC
void
GetQueueEODUnAcked(
    CQueue* pQueue,
    PROPVARIANT& var,
    CACGetQueueProperties& qp,
    BOOL fFirst
    )
{
    if (pQueue->IsLocalQueue())
        return;

    HRESULT hr;
    P<SEQUENCE_INFO> pSeqInfo = new SEQUENCE_INFO;
    pSeqInfo->SeqID = qp.liSeqID;

    hr = g_OutSeqHash.GetUnackedSequence(
                        qp.liSeqID,
                        &pSeqInfo->SeqNo,
                        &pSeqInfo->PrevNo,
                        fFirst
                        );

    if (FAILED(hr))
        return;

    var.blob.cbSize = sizeof(SEQUENCE_INFO);
    var.blob.pBlobData = reinterpret_cast<BYTE*>(pSeqInfo.detach());
    var.vt = VT_BLOB;
}

STATIC
void
GetUnackedCount(
    CQueue* pQueue,
    PROPVARIANT& var,
    CACGetQueueProperties& qp
    )
{
    if (pQueue->IsLocalQueue())
        return;

    var.ulVal = g_OutSeqHash.GetUnackedCount(qp.liSeqID);
    var.vt = VT_UI4;
}


STATIC
void
GetAckedNoReadCount(
    CQueue* pQueue,
    PROPVARIANT& var,
    CACGetQueueProperties& qp
    )
{
    if (pQueue->IsLocalQueue())
        return;

    var.ulVal = g_OutSeqHash.GetAckedNoReadCount(qp.liSeqID);
    var.vt = VT_UI4;
}


STATIC
void
GetLastAckedTime(
    CQueue* pQueue,
    PROPVARIANT& var,
    CACGetQueueProperties& qp
    )
{
    if (pQueue->IsLocalQueue())
        return;

    time_t LastAckTime;
    LastAckTime = g_OutSeqHash.GetLastAckedTime(qp.liSeqID);

    if (LastAckTime == 0)
    {
        return;
    }

    var.lVal = INT_PTR_TO_INT(LastAckTime); //BUGBUG bug year 2038
    var.vt = VT_I4;
}

STATIC
void
GetNextResendTime(
    CQueue* pQueue,
    PROPVARIANT& var,
    CACGetQueueProperties& qp
    )
{
    if (pQueue->IsLocalQueue())
        return;

    var.lVal = INT_PTR_TO_INT(g_OutSeqHash.GetNextResendTime(qp.liSeqID)); //BUGBUG bug year 2038
    var.vt = VT_I4;
}

STATIC
void
GetResendIndex(
    CQueue* pQueue,
    PROPVARIANT& var,
    CACGetQueueProperties& qp
    )
{
    if (pQueue->IsLocalQueue())
        return;

    var.lVal = g_OutSeqHash.GetResendIndex(qp.liSeqID);
    var.vt = VT_UI4;

}

STATIC
void
GetEDOSourceInfo(
    CQueue* pQueue,
    PROPVARIANT& var
    )
{
    if (!pQueue->IsLocalQueue() ||
        (!pQueue->IsDSQueue() && !pQueue->IsPrivateQueue()))
    {
        return;
    }

    const QUEUE_FORMAT qf = pQueue->GetQueueFormat();

    ASSERT((qf.GetType() == QUEUE_FORMAT_TYPE_PUBLIC) ||
           (qf.GetType() == QUEUE_FORMAT_TYPE_PRIVATE));

    //
    // Remove the machine name
    //
    LPCWSTR QueueName;
    QueueName = wcschr(pQueue->GetQueueName(), L'\\') + 1;

    GUID* pSenderId;
    ULARGE_INTEGER* pSeqId;
    DWORD* pSeqN;
    LPWSTR* pSendQueueFormatName;
    TIME32* pLastActiveTime;
    DWORD* pRejectCount;
    DWORD size;
    AP<PROPVARIANT> RetVar = new PROPVARIANT[6];

    g_pInSeqHash->GetInSequenceInformation(
                        &qf,
                        QueueName,
                        &pSenderId,
                        &pSeqId,
                        &pSeqN,
                        &pSendQueueFormatName,
                        &pLastActiveTime,
                        &pRejectCount,
                        &size
                        );

    if (size == 0)
        return;


    var.vt = VT_VECTOR | VT_VARIANT;
    var.capropvar.cElems = 6;
    var.capropvar.pElems = RetVar.detach();

    PROPVARIANT* pVar = var.capropvar.pElems;
    //
    // Return the format name
    //
    pVar->vt = VT_LPWSTR | VT_VECTOR;
    pVar->calpwstr.cElems = size;
    pVar->calpwstr.pElems = pSendQueueFormatName;
    ++pVar;

    //
    // Return Sender QM ID
    //
    pVar->vt = VT_CLSID | VT_VECTOR;
    pVar->cauuid.cElems = size;
    pVar->cauuid.pElems = pSenderId;
    ++pVar;

    //
    // Return Sequence ID
    //
    pVar->vt = VT_UI8 | VT_VECTOR;
    pVar->cauh.cElems = size;
    pVar->cauh.pElems = pSeqId;
    ++pVar;

    //
    // Return Sequence Number
    //
    pVar->vt = VT_UI4 | VT_VECTOR;
    pVar->caul.cElems = size;
    pVar->caul.pElems = pSeqN;
    ++pVar;

    //
    // Return Last Access Time
    //
    pVar->vt = VT_I4 | VT_VECTOR;
    pVar->cal.cElems = size;
    pVar->cal.pElems = pLastActiveTime; //BUGBUG bug year 2038
    ++pVar;

    //
    // Return Reject Count
    //
    pVar->vt = VT_UI4 | VT_VECTOR;
    pVar->cal.cElems = size;
    pVar->caul.pElems = pRejectCount;
}


STATIC
void
GetResendInterval(
    CQueue* pQueue,
    PROPVARIANT& var,
    CACGetQueueProperties& qp
    )
{
    var.lVal = g_OutSeqHash.GetResendInterval(qp.liSeqID);
    var.vt = VT_UI4;
}


STATIC
void
GetLastAckCount(
    CQueue* pQueue,
    PROPVARIANT& var,
    CACGetQueueProperties& qp
    )
{
    var.lVal = g_OutSeqHash.GetLastAckCount(qp.liSeqID);
    var.vt = VT_UI4;
}


static
bool
IsMgmtValidQueueFormatName(
	const QUEUE_FORMAT* pQueueFormat
	)
{
	switch (pQueueFormat->GetType())
	{
        case QUEUE_FORMAT_TYPE_PRIVATE:
        case QUEUE_FORMAT_TYPE_PUBLIC:
        case QUEUE_FORMAT_TYPE_DIRECT:
			return (pQueueFormat->Suffix() == QUEUE_SUFFIX_TYPE_NONE);

        case QUEUE_FORMAT_TYPE_MULTICAST:
        case QUEUE_FORMAT_TYPE_CONNECTOR:
			return true;

		case QUEUE_FORMAT_TYPE_DL:
		case QUEUE_FORMAT_TYPE_MACHINE:
			return false;
	}

	return false;
}


STATIC
HRESULT
GetQueueInfo(
    QUEUE_FORMAT* pQueueFormat,
    DWORD cprop,
    PROPID* propId,
    PROPVARIANT* propVar
    )
{

	if ( !IsMgmtValidQueueFormatName(pQueueFormat) )
	{
		return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 220);
	}

    R<CQueue> pQueue = NULL;

    if (!QueueMgr.LookUpQueue(pQueueFormat, &pQueue.ref(), false, false))
    {
        return LogHR(MQ_ERROR, s_FN, 10);
    }

    //
    // Get Queue information from AC
    //
    HRESULT hr;
    CACGetQueueProperties qp;
    hr = ACGetQueueProperties(pQueue->GetQueueHandle(), qp);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 20);
    }

    for(DWORD i =0; i < cprop; ++i)
    {
        ASSERT(propVar[i].vt == VT_NULL);

        switch(propId[i])
        {
        case PROPID_MGMT_QUEUE_PATHNAME:
            GetQueuePathName(pQueue.get(), propVar[i]);
            break;

        case PROPID_MGMT_QUEUE_FORMATNAME:
            GetQueueFormatName(pQueue.get(), propVar[i]);
            break;

        case PROPID_MGMT_QUEUE_TYPE:
            GetQueueType(pQueue.get(), propVar[i]);
            break;

        case PROPID_MGMT_QUEUE_LOCATION:
            GetQueueLocation(pQueue.get(), propVar[i]);
            break;

        case PROPID_MGMT_QUEUE_XACT:
            GetQueueXact(pQueue.get(), propVar[i]);
            break;

        case PROPID_MGMT_QUEUE_FOREIGN:
            GetQueueForeign(pQueue.get(), propVar[i]);
            break;

        case PROPID_MGMT_QUEUE_MESSAGE_COUNT:
            GetQueueMessageCount(pQueue.get(), propVar[i], qp);
            break;

        case PROPID_MGMT_QUEUE_USED_QUOTA:
            GetQueueUsedQuata(pQueue.get(), propVar[i], qp);
            break;

        case PROPID_MGMT_QUEUE_JOURNAL_MESSAGE_COUNT:
            GetJournalQueueMessageCount(pQueue.get(), propVar[i], qp);
            break;

        case PROPID_MGMT_QUEUE_JOURNAL_USED_QUOTA:
            GetJournalQueueUsedQuata(pQueue.get(), propVar[i], qp);
            break;

        case PROPID_MGMT_QUEUE_STATE:
            GetQueueState(pQueue.get(), propVar[i]);
            break;

        case PROPID_MGMT_QUEUE_NEXTHOPS:
            GetQueueNextHops(pQueue.get(), propVar[i]);
            break;

        case PROPID_MGMT_QUEUE_EOD_NEXT_SEQ:
            GetQueueEODNextSequence(pQueue.get(), propVar[i], qp);
            break;

        case PROPID_MGMT_QUEUE_EOD_LAST_ACK:
            GetQueueEODLastAcked(pQueue.get(), propVar[i], qp);
            break;

        case PROPID_MGMT_QUEUE_EOD_FIRST_NON_ACK:
            GetQueueEODUnAcked(pQueue.get(), propVar[i], qp, TRUE);
            break;

        case PROPID_MGMT_QUEUE_EOD_LAST_NON_ACK:
            GetQueueEODUnAcked(pQueue.get(), propVar[i], qp, FALSE);
            break;

        case PROPID_MGMT_QUEUE_EOD_NO_ACK_COUNT:
            GetUnackedCount(pQueue.get(), propVar[i], qp);
            break;

        case PROPID_MGMT_QUEUE_EOD_NO_READ_COUNT:
            GetAckedNoReadCount(pQueue.get(), propVar[i], qp);
            break;

        case PROPID_MGMT_QUEUE_EOD_LAST_ACK_TIME:
            GetLastAckedTime(pQueue.get(), propVar[i], qp);
            break;

        case PROPID_MGMT_QUEUE_EOD_RESEND_TIME:
            GetNextResendTime(pQueue.get(), propVar[i], qp);
            break;

        case PROPID_MGMT_QUEUE_EOD_RESEND_COUNT:
            GetResendIndex(pQueue.get(), propVar[i], qp);
            break;

        case PROPID_MGMT_QUEUE_EOD_RESEND_INTERVAL:
            GetResendInterval(pQueue.get(), propVar[i], qp);
            break;

        case PROPID_MGMT_QUEUE_EOD_LAST_ACK_COUNT:
            GetLastAckCount(pQueue.get(), propVar[i], qp);
            break;

        case PROPID_MGMT_QUEUE_EOD_SOURCE_INFO:
            GetEDOSourceInfo(pQueue.get(), propVar[i]);
            break;

        default:
			for (DWORD j = 0; j < cprop; ++j)
			{
				FreeVariant(propVar[j]);
			}
			
			return LogHR(MQ_ERROR_ILLEGAL_PROPID, s_FN, 230);
        }
    }

    return MQ_OK;
}

STATIC
HRESULT
VerifyMgmtGetInfoAccess()
{
    HRESULT hr2 = MQ_OK ;
    static bool   s_bRestrictRead = false ;
    static DWORD  s_dwRestrictToAdmin = 0 ;

    if (!s_bRestrictRead)
    {
        //
        // read restrict value from registry.
        //
        DWORD ulDefault = MSMQ_DEFAULT_RESTRICT_ADMIN_API ;
        READ_REG_DWORD( s_dwRestrictToAdmin,
                        MSMQ_RESTRICT_ADMIN_API_REGNAME,
                       &ulDefault );
        s_bRestrictRead = true ;
    }

    if (s_dwRestrictToAdmin == MSMQ_RESTRICT_ADMIN_API_TO_LA)
    {
        //
        // Perform access check to see if caller is local administrator.
        // this access check ignore the DACL in the security descriptor
        // of the msmqConfiguration object.
        //
        hr2 = VerifyMgmtPermission( QueueMgr.GetQMGuid(),
                                    g_szMachineName );
        if (FAILED(hr2))
        {
            return LogHR(hr2, s_FN, 360);
        }
    }
    else if (s_dwRestrictToAdmin == MSMQ_DEFAULT_RESTRICT_ADMIN_API)
    {
        //
        // Perform "classic" access check. Allow this query only if caller
        // has the "get properties" permission on the msmqConfiguration
        // object.
        //
        hr2 = VerifyMgmtGetPermission( QueueMgr.GetQMGuid(),
                                       g_szMachineName );
        if (FAILED(hr2))
        {
            return LogHR(hr2, s_FN, 365);
        }
    }
    else
    {

        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 370);
    }

    return MQ_OK ;
}

STATIC
HRESULT
MgmtGetInfo(
    const MGMT_OBJECT* pObjectFormat,
    DWORD cp,
    PROPID* pProp,
    PROPVARIANT* ppVar
    )
{
    HRESULT hr2 = VerifyMgmtGetInfoAccess() ;
    if (FAILED(hr2))
    {
        return hr2 ;
    }

	switch (pObjectFormat->type)
    {
        case MGMT_MACHINE:
            hr2 = GetMachineInfo(cp, pProp, ppVar);
            return LogHR(hr2, s_FN, 30);

        case MGMT_QUEUE:
            hr2 = GetQueueInfo(
                        pObjectFormat->pQueueFormat,
                        cp,
                        pProp,
                        ppVar);
            return LogHR(hr2, s_FN, 40);

        case MGMT_SESSION:
            return LogHR(MQ_ERROR, s_FN, 50);

        default:
            return LogHR(MQ_ERROR, s_FN, 60);
    }
}

STATIC
void
FreeVariant(
    PROPVARIANT& var
    )
{
    ULONG i;

    switch (var.vt)
    {
        case VT_CLSID:
            delete var.puuid;
            break;

        case VT_LPWSTR:
            delete[] var.pwszVal;
            break;

        case VT_BLOB:
            delete[] var.blob.pBlobData;
            break;

        case (VT_I4 | VT_VECTOR):
            delete [] var.cal.pElems;
            break;

        case (VT_UI4 | VT_VECTOR):
            delete [] var.caul.pElems;
            break;

        case (VT_UI8 | VT_VECTOR):
            delete [] var.cauh.pElems;
            break;

        case (VT_VECTOR | VT_CLSID):
            delete[] var.cauuid.pElems;
            break;

        case (VT_VECTOR | VT_LPWSTR):
            for(i = 0; i < var.calpwstr.cElems; i++)
            {
                delete[] var.calpwstr.pElems[i];
            }
            delete [] var.calpwstr.pElems;
            break;

        case (VT_VECTOR | VT_VARIANT):
            for(i = 0; i < var.capropvar.cElems; i++)
            {
                FreeVariant(var.capropvar.pElems[i]);
            }

            delete[] var.capropvar.pElems;
            break;

        default:
            break;
    }

    var.vt = VT_NULL;
}

static bool IsValidMgmtObject(const MGMT_OBJECT* p)
{
    if(p == NULL)
        return false;

    if(p->type == MGMT_MACHINE)
        return true;

    if(p->type != MGMT_QUEUE)
        return false;

    if(p->pQueueFormat == NULL)
        return false;

    return p->pQueueFormat->IsValid();
}


/*====================================================

QMMgmtGetInfo

Arguments:

Return Value:

=====================================================*/
HRESULT R_QMMgmtGetInfo(
    /* [in] */ handle_t hBind,
    /* [in] */ const MGMT_OBJECT* pObjectFormat,
    /* [in] */ DWORD cp,
    /* [size_is][in] */ PROPID __RPC_FAR aProp[  ],
    /* [size_is][out][in] */ PROPVARIANT __RPC_FAR apVar[  ]
    )
{
    if(!IsValidMgmtObject(pObjectFormat))
    {
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 69);
    }

    try
    {
        return LogHR(MgmtGetInfo(pObjectFormat, cp, aProp, apVar), s_FN, 70);
    }
    catch(const bad_alloc&)
    {
        for (DWORD i = 0; i < cp; ++i)
        {
            FreeVariant(apVar[i]);
        }

        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 80);
    }

}

//
//  Skip white space characters, return next non ws char
//
inline LPCWSTR skip_ws(LPCWSTR p)
{
    while(isspace(*p))
    {
        ++p;
    }

    return p;
}


STATIC
BOOL
IsTheAction(
    LPCWSTR pInputBuffer,
    LPCWSTR pAction
    )
{
    LPCWSTR p = skip_ws(pInputBuffer);
    if (_wcsnicmp(p, pAction, wcslen(pAction)) == 0)
    {
        p = skip_ws(p + wcslen(pAction));
        if (*p == '\0')
            return TRUE;
    }

    return FALSE;

}

STATIC
HRESULT
MachineAction(
    LPCWSTR pAction
    )
{
    if (IsTheAction(pAction, MACHINE_ACTION_CONNECT))
    {
        QueueMgr.SetConnected(TRUE);
        return MQ_OK;
    }

    if (IsTheAction(pAction, MACHINE_ACTION_DISCONNECT))
    {
        QueueMgr.SetConnected(FALSE);
        return MQ_OK;
    }

    if (IsTheAction(pAction, MACHINE_ACTION_TIDY))
    {
        return LogHR(ACReleaseResources(g_hAc), s_FN, 90);
    }

    return LogHR(MQ_ERROR, s_FN, 100);
}

STATIC
HRESULT
EdoResendAction(
    QUEUE_FORMAT* pQueueFormat
    )
{
    R<CQueue> pQueue = NULL;

    if (!QueueMgr.LookUpQueue(pQueueFormat, &pQueue.ref(), false, false))
    {
        return LogHR(MQ_ERROR, s_FN, 110);
    }

    //
    // Local queue can't hold. It is meaningless
    //
    if (pQueue->IsLocalQueue())
    {
        return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 250);
    }

    //
    // Get Queue information from AC
    //
    HRESULT hr;
    CACGetQueueProperties qp;
    hr = ACGetQueueProperties(pQueue->GetQueueHandle(), qp);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 120);
    }

    g_OutSeqHash.AdminResend(qp.liSeqID);

    return MQ_OK;
}


static
bool
IsMgmtActionValidQueueFormatName(
	const QUEUE_FORMAT* pQueueFormat
	)
{
	switch (pQueueFormat->GetType())
	{
        case QUEUE_FORMAT_TYPE_PRIVATE:
        case QUEUE_FORMAT_TYPE_PUBLIC:
        case QUEUE_FORMAT_TYPE_DIRECT:
			return (pQueueFormat->Suffix() == QUEUE_SUFFIX_TYPE_NONE);

        case QUEUE_FORMAT_TYPE_MULTICAST:
			return true;

		case QUEUE_FORMAT_TYPE_DL:
		case QUEUE_FORMAT_TYPE_MACHINE:
        case QUEUE_FORMAT_TYPE_CONNECTOR:
			return false;
	}

	return false;
}


STATIC
HRESULT
QueueAction(
    QUEUE_FORMAT* pQueueFormat,
    LPCWSTR pAction
    )
{
	if ( !IsMgmtActionValidQueueFormatName(pQueueFormat) )
	{
		return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 240);
	}

    if (IsTheAction(pAction, QUEUE_ACTION_PAUSE))
    {
        return LogHR(PauseQueue(pQueueFormat), s_FN, 125);
    }

    if (IsTheAction(pAction, QUEUE_ACTION_RESUME))
    {
        return LogHR(ResumeQueue(pQueueFormat), s_FN, 130);
    }

    if (IsTheAction(pAction, QUEUE_ACTION_EOD_RESEND))
    {
        return LogHR(EdoResendAction(pQueueFormat), s_FN, 140);
    }

    return LogHR(MQ_ERROR, s_FN, 150);
}


HRESULT
MgmtAction(
    const MGMT_OBJECT* pObjectFormat,
    LPCWSTR lpwszAction
    )
{
    HRESULT hr;
    hr = VerifyMgmtPermission(
                QueueMgr.GetQMGuid(),
                g_szMachineName
                );

    if (FAILED(hr))
        return LogHR(hr, s_FN, 160);

	switch (pObjectFormat->type)
    {
        case MGMT_MACHINE:
            return LogHR(MachineAction(lpwszAction), s_FN, 170);

        case MGMT_QUEUE:
            hr = QueueAction(
                             pObjectFormat->pQueueFormat,
                             lpwszAction
                            );
            return LogHR(hr, s_FN, 180);

        case MGMT_SESSION:
            return LogHR(MQ_ERROR, s_FN, 185);

        default:
            return LogHR(MQ_ERROR, s_FN, 190);
    }
}

/*====================================================

QMMgmtAction

Arguments:

Return Value:

=====================================================*/
HRESULT R_QMMgmtAction(
    /* [in] */ handle_t hBind,
    /* [in] */ const MGMT_OBJECT* pObjectFormat,
    /* [in] */ LPCWSTR lpwszAction
    )
{
    if(!IsValidMgmtObject(pObjectFormat))
    {
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 199);
    }

    try
    {
        return LogHR(MgmtAction(pObjectFormat, lpwszAction), s_FN, 200);
    }
    catch(const bad_alloc&)
    {
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 210);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\onhold.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    onhold.cpp

Abstract:

   Handle queue onhold/resume decleration

Author:

    Uri Habusha (urih) July, 1998

--*/

#ifndef __ONHOLD__
#define __ONHOLD__

HRESULT
InitOnHold(
    void
    );

HRESULT
PauseQueue(
    const QUEUE_FORMAT* pqf
    );

HRESULT
ResumeQueue(
    const QUEUE_FORMAT* pqf
    );

#endif //__ONHOLD__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\msgprops.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    msgprops.h

Abstract:
    Message properties class

Author:
    Erez Haba (erezh) 23-Feb-2001

--*/

#pragma once

#ifndef _MSGPROPS_H_
#define _MSGPROPS_H_

#include "qmpkt.h"

//---------------------------------------------------------
//
// class CMessageProperty
//
//---------------------------------------------------------

class CMessageProperty {
public:
    //
    //  Message properties
    //
    USHORT wClass;
    DWORD dwTimeToQueue;
    DWORD dwTimeToLive;
    OBJECTID* pMessageID;
    PUCHAR pCorrelationID;
    UCHAR bPriority;
    UCHAR bDelivery;
    UCHAR bAcknowledge;
    UCHAR bAuditing;
    UCHAR bTrace;
    DWORD dwApplicationTag;
    DWORD dwTitleSize;
    const TCHAR* pTitle;
    DWORD dwMsgExtensionSize;
    const UCHAR* pMsgExtension;
    DWORD dwBodySize;
    DWORD dwAllocBodySize;
    const UCHAR* pBody;
    DWORD dwBodyType;
    const UCHAR* pSenderID;
    const UCHAR* pSymmKeys;
    LPCWSTR wszProvName;
    ULONG ulSymmKeysSize;
    ULONG ulPrivLevel;
    ULONG ulHashAlg;
    ULONG ulEncryptAlg;
    ULONG ulSenderIDType;
    ULONG ulProvType;
    UCHAR bDefProv;
    USHORT uSenderIDLen;
    UCHAR bAuthenticated;
    UCHAR bEncrypted;
    const UCHAR *pSenderCert;
    ULONG ulSenderCertLen;
    const UCHAR *pSignature;
    ULONG ulSignatureSize;
    UCHAR bConnector;
	const UCHAR*  pEodAckStreamId;
	ULONG EodAckStreamIdSizeInBytes;
	LONGLONG EodAckSeqId;
	LONGLONG EodAckSeqNum;


public:
    CMessageProperty(void);
    CMessageProperty(CQmPacket* pPkt);
    CMessageProperty(
        USHORT usClass,
        PUCHAR pCorrelationId,
        USHORT usPriority,
        UCHAR  ucDelivery
        );

    ~CMessageProperty();

private:
    BOOLEAN fCreatedFromPacket;
};


//
// CMessageProperty constructor
//
inline CMessageProperty::CMessageProperty(void)
{
    memset(this, 0, sizeof(CMessageProperty));
}


inline CMessageProperty::~CMessageProperty()
{
    if (fCreatedFromPacket == TRUE)
    {
        if (pMessageID)
        {
            delete pMessageID;
        }
        if (pCorrelationID)
        {
            delete pCorrelationID;
        }
    }
}

#endif // _MSGPROPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\outdlv.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    outdlv.cpp

Abstract:
	Implementation 	of function declared in outdlv.h					

Author:
    Gil Shafriri 4-Oct-2000


Environment:
    Platform-independent

--*/
#include "stdh.h"
#include "outdlv.h"
#include "qmpkt.h"
#include "xactout.h"
#include "xact.h"
#include "xactin.h"

#include "outdlv.tmh"

extern BOOL QmpIsLocalMachine(const GUID * pGuid);
extern COutSeqHash g_OutSeqHash;


static bool IsOrderNeeded(CQmPacket* pPkt)
{
	return pPkt->IsOrdered() && QmpIsLocalMachine(pPkt->GetSrcQMGuid() );
}



bool AppCanDeliverPacket(CQmPacket* pPkt)
/*++

Routine Description:
    Test if given packet should be delivered now.	

	
Arguments:
	CQmPacket* pPkt - packet.

 Returned Value: true if the packet should be delivered - otherwise false.
--*/
{
	if(!IsOrderNeeded(pPkt))
		return true;

	return g_OutSeqHash.PreSendProcess(pPkt, true) == TRUE;
}

void AppPutPacketOnHold(CQmPacket* pPkt)
/*++

Routine Description:
    Put packet onhold for later delivery.	

	
Arguments:
	CQmPacket* pPkt - packet.


Returned Value: None

--*/
{
	ASSERT(IsOrderNeeded(pPkt));
	g_OutSeqHash.PostSendProcess(pPkt);	
}


bool AppPostSend(CQmPacket* pPkt)
/*++

Routine Description:
    called for handling packet after send.	

	
Arguments:
	CQmPacket* pPkt - packet.


Returned Value: true if ownership is taken on the packet - otherwise false.

--*/
{
	if(!IsOrderNeeded(pPkt))
		return false;

	g_OutSeqHash.PostSendProcess(pPkt);	
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\outdlv.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    outdlv.h

Abstract:
	header for functions that handlers actions needed befor and after sending messages.					

Author:
    Gil Shafriri 4-Oct-2000

Environment:
    Platform-independent

--*/


class  CQmPacket;

bool AppCanDeliverPacket(CQmPacket* pPkt);
void AppPutPacketOnHold(CQmPacket* pPkt);
bool AppPostSend(CQmPacket* pPkt);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\ntsecapi.h ===
/*++ BUILD Version: 0006     Increment this if a change has global effects

Copyright (c) 1990-1996  Microsoft Corporation

Module Name:

    ntsecapi.h

Abstract:

    This module defines the Local Security Authority APIs.

Revision History:

--*/

#ifndef _NTSECAPI_
#define _NTSECAPI_

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _NTDEF_
typedef LONG NTSTATUS, *PNTSTATUS;
#endif

#ifndef _NTLSA_IFS_
// begin_ntifs


//
// Security operation mode of the system is held in a control
// longword.
//

typedef ULONG  LSA_OPERATIONAL_MODE, *PLSA_OPERATIONAL_MODE;

// end_ntifs
#endif // _NTLSA_IFS_

//
// The flags in the security operational mode are defined
// as:
//
//    PasswordProtected - Some level of authentication (such as
//        a password) must be provided by users before they are
//        allowed to use the system.  Once set, this value will
//        not be cleared without re-booting the system.
//
//    IndividualAccounts - Each user must identify an account to
//        logon to.  This flag is only meaningful if the
//        PasswordProtected flag is also set.  If this flag is
//        not set and the PasswordProtected flag is set, then all
//        users may logon to the same account.  Once set, this value
//        will not be cleared without re-booting the system.
//
//    MandatoryAccess - Indicates the system is running in a mandatory
//        access control mode (e.g., B-level as defined by the U.S.A's
//        Department of Defense's "Orange Book").  This is not utilized
//        in the current release of NT.  This flag is only meaningful
//        if both the PasswordProtected and IndividualAccounts flags are
//        set.  Once set, this value will not be cleared without
//        re-booting the system.
//
//    LogFull - Indicates the system has been brought up in a mode in
//        which if must perform security auditing, but its audit log
//        is full.  This may (should) restrict the operations that
//        can occur until the audit log is made not-full again.  THIS
//        VALUE MAY BE CLEARED WHILE THE SYSTEM IS RUNNING (I.E., WITHOUT
//        REBOOTING).
//
// If the PasswordProtected flag is not set, then the system is running
// without security, and user interface should be adjusted appropriately.
//

#define LSA_MODE_PASSWORD_PROTECTED     (0x00000001L)
#define LSA_MODE_INDIVIDUAL_ACCOUNTS    (0x00000002L)
#define LSA_MODE_MANDATORY_ACCESS       (0x00000004L)
#define LSA_MODE_LOG_FULL               (0x00000008L)

#ifndef _NTLSA_IFS_
// begin_ntifs
//
// Used by a logon process to indicate what type of logon is being
// requested.
// NOTE: Proxy logon type is not currently supported in NT 3.x
//

typedef enum _SECURITY_LOGON_TYPE {
    Interactive = 2,    // Interactively logged on (locally or remotely)
    Network,            // Accessing system via network
    Batch,              // Started via a batch queue
    Service,            // Service started by service controller
    Proxy,              // Proxy logon
    Unlock              // Unlock workstation
} SECURITY_LOGON_TYPE, *PSECURITY_LOGON_TYPE;

// end_ntifs
#endif // _NTLSA_IFS_


//
// Audit Event Categories
//
// The following are the built-in types or Categories of audit event.
// WARNING!  This structure is subject to expansion.  The user should not
// compute the number of elements of this type directly, but instead
// should obtain the count of elements by calling LsaQueryInformationPolicy()
// for the PolicyAuditEventsInformation class and extracting the count from
// the MaximumAuditEventCount field of the returned structure.
//

typedef enum _POLICY_AUDIT_EVENT_TYPE {

    AuditCategorySystem,
    AuditCategoryLogon,
    AuditCategoryObjectAccess,
    AuditCategoryPrivilegeUse,
    AuditCategoryDetailedTracking,
    AuditCategoryPolicyChange,
    AuditCategoryAccountManagement

} POLICY_AUDIT_EVENT_TYPE, *PPOLICY_AUDIT_EVENT_TYPE;


//
// The following defines describe the auditing options for each
// event type
//

// Leave options specified for this event unchanged

#define POLICY_AUDIT_EVENT_UNCHANGED       (0x00000000L)

// Audit successful occurrences of events of this type

#define POLICY_AUDIT_EVENT_SUCCESS         (0x00000001L)

// Audit failed attempts to cause an event of this type to occur

#define POLICY_AUDIT_EVENT_FAILURE         (0x00000002L)

#define POLICY_AUDIT_EVENT_NONE            (0x00000004L)

// Mask of valid event auditing options

#define POLICY_AUDIT_EVENT_MASK \
    (POLICY_AUDIT_EVENT_SUCCESS | \
     POLICY_AUDIT_EVENT_FAILURE | \
     POLICY_AUDIT_EVENT_UNCHANGED | \
     POLICY_AUDIT_EVENT_NONE)


#ifdef _NTDEF_
// begin_ntifs
typedef UNICODE_STRING LSA_UNICODE_STRING, *PLSA_UNICODE_STRING;
typedef STRING LSA_STRING, *PLSA_STRING;
typedef OBJECT_ATTRIBUTES LSA_OBJECT_ATTRIBUTES, *PLSA_OBJECT_ATTRIBUTES;
// end_ntifs
#else // _NTDEF_

#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif


typedef struct _LSA_UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} LSA_UNICODE_STRING, *PLSA_UNICODE_STRING;

typedef struct _LSA_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PCHAR Buffer;
} LSA_STRING, *PLSA_STRING;

typedef struct _LSA_OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PLSA_UNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
    PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
} LSA_OBJECT_ATTRIBUTES, *PLSA_OBJECT_ATTRIBUTES;



#endif // _NTDEF_

//
// Macro for determining whether an API succeeded.
//

#define LSA_SUCCESS(Error) ((LONG)(Error) >= 0)

#ifndef _NTLSA_IFS_
// begin_ntifs

NTSTATUS
NTAPI
LsaRegisterLogonProcess (
    IN PLSA_STRING LogonProcessName,
    OUT PHANDLE LsaHandle,
    OUT PLSA_OPERATIONAL_MODE SecurityMode
    );

// end_ntifs
// begin_ntsrv

NTSTATUS
NTAPI
LsaLogonUser (
    IN HANDLE LsaHandle,
    IN PLSA_STRING OriginName,
    IN SECURITY_LOGON_TYPE LogonType,
    IN ULONG AuthenticationPackage,
    IN PVOID AuthenticationInformation,
    IN ULONG AuthenticationInformationLength,
    IN PTOKEN_GROUPS LocalGroups OPTIONAL,
    IN PTOKEN_SOURCE SourceContext,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferLength,
    OUT PLUID LogonId,
    OUT PHANDLE Token,
    OUT PQUOTA_LIMITS Quotas,
    OUT PNTSTATUS SubStatus
    );


// end_ntsrv
// begin_ntifs

NTSTATUS
NTAPI
LsaLookupAuthenticationPackage (
    IN HANDLE LsaHandle,
    IN PLSA_STRING PackageName,
    OUT PULONG AuthenticationPackage
    );

NTSTATUS
NTAPI
LsaFreeReturnBuffer (
    IN PVOID Buffer
    );

NTSTATUS
NTAPI
LsaCallAuthenticationPackage (
    IN HANDLE LsaHandle,
    IN ULONG AuthenticationPackage,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );


NTSTATUS
NTAPI
LsaDeregisterLogonProcess (
    IN HANDLE LsaHandle
    );

NTSTATUS
NTAPI
LsaConnectUntrusted (
    OUT PHANDLE LsaHandle
    );


// end_ntifs
#endif // _NTLSA_IFS_

////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Local Security Policy Administration API datatypes and defines         //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

//
// Access types for the Policy object
//

#define POLICY_VIEW_LOCAL_INFORMATION              0x00000001L
#define POLICY_VIEW_AUDIT_INFORMATION              0x00000002L
#define POLICY_GET_PRIVATE_INFORMATION             0x00000004L
#define POLICY_TRUST_ADMIN                         0x00000008L
#define POLICY_CREATE_ACCOUNT                      0x00000010L
#define POLICY_CREATE_SECRET                       0x00000020L
#define POLICY_CREATE_PRIVILEGE                    0x00000040L
#define POLICY_SET_DEFAULT_QUOTA_LIMITS            0x00000080L
#define POLICY_SET_AUDIT_REQUIREMENTS              0x00000100L
#define POLICY_AUDIT_LOG_ADMIN                     0x00000200L
#define POLICY_SERVER_ADMIN                        0x00000400L
#define POLICY_LOOKUP_NAMES                        0x00000800L

#define POLICY_ALL_ACCESS     (STANDARD_RIGHTS_REQUIRED         |\
                               POLICY_VIEW_LOCAL_INFORMATION    |\
                               POLICY_VIEW_AUDIT_INFORMATION    |\
                               POLICY_GET_PRIVATE_INFORMATION   |\
                               POLICY_TRUST_ADMIN               |\
                               POLICY_CREATE_ACCOUNT            |\
                               POLICY_CREATE_SECRET             |\
                               POLICY_CREATE_PRIVILEGE          |\
                               POLICY_SET_DEFAULT_QUOTA_LIMITS  |\
                               POLICY_SET_AUDIT_REQUIREMENTS    |\
                               POLICY_AUDIT_LOG_ADMIN           |\
                               POLICY_SERVER_ADMIN              |\
                               POLICY_LOOKUP_NAMES )


#define POLICY_READ           (STANDARD_RIGHTS_READ             |\
                               POLICY_VIEW_AUDIT_INFORMATION    |\
                               POLICY_GET_PRIVATE_INFORMATION)

#define POLICY_WRITE          (STANDARD_RIGHTS_WRITE            |\
                               POLICY_TRUST_ADMIN               |\
                               POLICY_CREATE_ACCOUNT            |\
                               POLICY_CREATE_SECRET             |\
                               POLICY_CREATE_PRIVILEGE          |\
                               POLICY_SET_DEFAULT_QUOTA_LIMITS  |\
                               POLICY_SET_AUDIT_REQUIREMENTS    |\
                               POLICY_AUDIT_LOG_ADMIN           |\
                               POLICY_SERVER_ADMIN)

#define POLICY_EXECUTE        (STANDARD_RIGHTS_EXECUTE          |\
                               POLICY_VIEW_LOCAL_INFORMATION    |\
                               POLICY_LOOKUP_NAMES )


//
// Policy object specific data types.
//

//
// The following data type is used to identify a domain
//

typedef struct _LSA_TRUST_INFORMATION {

    LSA_UNICODE_STRING Name;
    PSID Sid;

} LSA_TRUST_INFORMATION, *PLSA_TRUST_INFORMATION;

// where members have the following usage:
//
//     Name - The name of the domain.
//
//     Sid - A pointer to the Sid of the Domain
//

//
// The following data type is used in name and SID lookup services to
// describe the domains referenced in the lookup operation.
//

typedef struct _LSA_REFERENCED_DOMAIN_LIST {

    ULONG Entries;
    PLSA_TRUST_INFORMATION Domains;

} LSA_REFERENCED_DOMAIN_LIST, *PLSA_REFERENCED_DOMAIN_LIST;

// where members have the following usage:
//
//     Entries - Is a count of the number of domains described in the
//         Domains array.
//
//     Domains - Is a pointer to an array of Entries LSA_TRUST_INFORMATION data
//         structures.
//


//
// The following data type is used in name to SID lookup services to describe
// the domains referenced in the lookup operation.
//

typedef struct _LSA_TRANSLATED_SID {

    SID_NAME_USE Use;
    ULONG RelativeId;
    LONG DomainIndex;

} LSA_TRANSLATED_SID, *PLSA_TRANSLATED_SID;

// where members have the following usage:
//
//     Use - identifies the use of the SID.  If this value is SidUnknown or
//         SidInvalid, then the remainder of the record is not set and
//         should be ignored.
//
//     RelativeId - Contains the relative ID of the translated SID.  The
//         remainder of the SID (the prefix) is obtained using the
//         DomainIndex field.
//
//     DomainIndex - Is the index of an entry in a related
//         LSA_REFERENCED_DOMAIN_LIST data structure describing the
//         domain in which the account was found.
//
//         If there is no corresponding reference domain for an entry, then
//         this field will contain a negative value.
//


//
// The following data type is used in SID to name lookup services to
// describe the domains referenced in the lookup operation.
//

typedef struct _LSA_TRANSLATED_NAME {

    SID_NAME_USE Use;
    LSA_UNICODE_STRING Name;
    LONG DomainIndex;

} LSA_TRANSLATED_NAME, *PLSA_TRANSLATED_NAME;

// where the members have the following usage:
//
//     Use - Identifies the use of the name.  If this value is SidUnknown
//         or SidInvalid, then the remainder of the record is not set and
//         should be ignored.  If this value is SidWellKnownGroup then the
//         Name field is invalid, but the DomainIndex field is not.
//
//     Name - Contains the isolated name of the translated SID.
//
//     DomainIndex - Is the index of an entry in a related
//         LSA_REFERENCED_DOMAIN_LIST data structure describing the domain
//         in which the account was found.
//
//         If there is no corresponding reference domain for an entry, then
//         this field will contain a negative value.
//


//
// The following data type is used to represent the role of the LSA
// server (primary or backup).
//

typedef enum _POLICY_LSA_SERVER_ROLE {

    PolicyServerRoleBackup = 2,
    PolicyServerRolePrimary

} POLICY_LSA_SERVER_ROLE, *PPOLICY_LSA_SERVER_ROLE;


//
// The following data type is used to represent the state of the LSA
// server (enabled or disabled).  Some operations may only be performed on
// an enabled LSA server.
//

typedef enum _POLICY_SERVER_ENABLE_STATE {

    PolicyServerEnabled = 2,
    PolicyServerDisabled

} POLICY_SERVER_ENABLE_STATE, *PPOLICY_SERVER_ENABLE_STATE;


//
// The following data type is used to specify the auditing options for
// an Audit Event Type.
//

typedef ULONG POLICY_AUDIT_EVENT_OPTIONS, *PPOLICY_AUDIT_EVENT_OPTIONS;

// where the following flags can be set:
//
//     POLICY_AUDIT_EVENT_UNCHANGED - Leave existing auditing options
//         unchanged for events of this type.  This flag is only used for
//         set operations.  If this flag is set, then all other flags
//         are ignored.
//
//     POLICY_AUDIT_EVENT_NONE - Cancel all auditing options for events
//         of this type.  If this flag is set, the success/failure flags
//         are ignored.
//
//     POLICY_AUDIT_EVENT_SUCCESS - When auditing is enabled, audit all
//         successful occurrences of events of the given type.
//
//     POLICY_AUDIT_EVENT_FAILURE - When auditing is enabled, audit all
//         unsuccessful occurrences of events of the given type.
//



//
// The following data type is used to return information about privileges
// defined on a system.
//

typedef struct _POLICY_PRIVILEGE_DEFINITION {

    LSA_UNICODE_STRING Name;
    LUID LocalValue;

} POLICY_PRIVILEGE_DEFINITION, *PPOLICY_PRIVILEGE_DEFINITION;

// where the members have the following usage:
//
//     Name - Is the architected name of the privilege.  This is the
//         primary key of the privilege and the only value that is
//         transportable between systems.
//
//     Luid - is a LUID value assigned locally for efficient representation
//         of the privilege.  Ths value is meaningful only on the system it
//         was assigned on and is not transportable in any way.
//


//
// The following data type defines the classes of Policy Information
// that may be queried/set.
//

typedef enum _POLICY_INFORMATION_CLASS {

    PolicyAuditLogInformation = 1,
    PolicyAuditEventsInformation,
    PolicyPrimaryDomainInformation,
    PolicyPdAccountInformation,
    PolicyAccountDomainInformation,
    PolicyLsaServerRoleInformation,
    PolicyReplicaSourceInformation,
    PolicyDefaultQuotaInformation,
    PolicyModificationInformation,
    PolicyAuditFullSetInformation,
    PolicyAuditFullQueryInformation

} POLICY_INFORMATION_CLASS, *PPOLICY_INFORMATION_CLASS;


//
// The following data type corresponds to the PolicyAuditLogInformation
// information class.  It is used to represent information relating to
// the Audit Log.
//
// This structure may be used in both query and set operations.  However,
// when used in set operations, some fields are ignored.
//

typedef struct _POLICY_AUDIT_LOG_INFO {

    ULONG AuditLogPercentFull;
    ULONG MaximumLogSize;
    LARGE_INTEGER AuditRetentionPeriod;
    BOOLEAN AuditLogFullShutdownInProgress;
    LARGE_INTEGER TimeToShutdown;
    ULONG NextAuditRecordId;

} POLICY_AUDIT_LOG_INFO, *PPOLICY_AUDIT_LOG_INFO;

// where the members have the following usage:
//
//     AuditLogPercentFull - Indicates the percentage of the Audit Log
//         currently being used.
//
//     MaximumLogSize - Specifies the maximum size of the Audit Log in
//         kilobytes.
//
//     AuditRetentionPeriod - Indicates the length of time that Audit
//         Records are to be retained.  Audit Records are discardable
//         if their timestamp predates the current time minus the
//         retention period.
//
//     AuditLogFullShutdownInProgress - Indicates whether or not a system
//         shutdown is being initiated due to the security Audit Log becoming
//         full.  This condition will only occur if the system is configured
//         to shutdown when the log becomes full.
//
//         TRUE indicates that a shutdown is in progress
//         FALSE indicates that a shutdown is not in progress.
//
//         Once a shutdown has been initiated, this flag will be set to
//         TRUE.  If an administrator is able to currect the situation
//         before the shutdown becomes irreversible, then this flag will
//         be reset to false.
//
//         This field is ignored for set operations.
//
//     TimeToShutdown - If the AuditLogFullShutdownInProgress flag is set,
//         then this field contains the time left before the shutdown
//         becomes irreversible.
//
//         This field is ignored for set operations.
//


//
// The following data type corresponds to the PolicyAuditEventsInformation
// information class.  It is used to represent information relating to
// the audit requirements.
//

typedef struct _POLICY_AUDIT_EVENTS_INFO {

    BOOLEAN AuditingMode;
    PPOLICY_AUDIT_EVENT_OPTIONS EventAuditingOptions;
    ULONG MaximumAuditEventCount;

} POLICY_AUDIT_EVENTS_INFO, *PPOLICY_AUDIT_EVENTS_INFO;

// where the members have the following usage:
//
//     AuditingMode - A Boolean variable specifying the Auditing Mode value.
//         This value is interpreted as follows:
//
//         TRUE - Auditing is to be enabled (set operations) or is enabled
//             (query operations).  Audit Records will be generated according
//             to the Event Auditing Options in effect (see the
//             EventAuditingOptions field.
//
//         FALSE - Auditing is to be disabled (set operations) or is
//             disabled (query operations).  No Audit Records will be
//             generated.  Note that for set operations the Event Auditing
//             Options in effect will still be updated as specified by the
//             EventAuditingOptions field whether Auditing is enabled or
//             disabled.
//
//    EventAuditingOptions - Pointer to an array of Auditing Options
//        indexed by Audit Event Type.
//
//    MaximumAuditEventCount - Specifiesa count of the number of Audit
//        Event Types specified by the EventAuditingOptions parameter.  If
//        this count is less than the number of Audit Event Types supported
//        by the system, the Auditing Options for Event Types with IDs
//        higher than (MaximumAuditEventCount + 1) are left unchanged.
//


//
// The following structure corresponds to the PolicyAccountDomainInformation
// information class.
//

typedef struct _POLICY_ACCOUNT_DOMAIN_INFO {

    LSA_UNICODE_STRING DomainName;
    PSID DomainSid;

} POLICY_ACCOUNT_DOMAIN_INFO, *PPOLICY_ACCOUNT_DOMAIN_INFO;

// where the members have the following usage:
//
//     DomainName - Is the name of the domain
//
//     DomainSid - Is the Sid of the domain
//


//
// The following structure corresponds to the PolicyPrimaryDomainInformation
// information class.
//

typedef struct _POLICY_PRIMARY_DOMAIN_INFO {

    LSA_UNICODE_STRING Name;
    PSID Sid;

} POLICY_PRIMARY_DOMAIN_INFO, *PPOLICY_PRIMARY_DOMAIN_INFO;

// where the members have the following usage:
//
//     Name - Is the name of the domain
//
//     Sid - Is the Sid of the domain
//


//
// The following structure corresponds to the PolicyPdAccountInformation
// information class.  This structure may be used in Query operations
// only.
//

typedef struct _POLICY_PD_ACCOUNT_INFO {

    LSA_UNICODE_STRING Name;

} POLICY_PD_ACCOUNT_INFO, *PPOLICY_PD_ACCOUNT_INFO;

// where the members have the following usage:
//
//     Name - Is the name of an account in the domain that should be used
//         for authentication and name/ID lookup requests.
//


//
// The following structure corresponds to the PolicyLsaServerRoleInformation
// information class.
//

typedef struct _POLICY_LSA_SERVER_ROLE_INFO {

    POLICY_LSA_SERVER_ROLE LsaServerRole;

} POLICY_LSA_SERVER_ROLE_INFO, *PPOLICY_LSA_SERVER_ROLE_INFO;

// where the fields have the following usage:
//
// TBS
//


//
// The following structure corresponds to the PolicyReplicaSourceInformation
// information class.
//

typedef struct _POLICY_REPLICA_SOURCE_INFO {

    LSA_UNICODE_STRING ReplicaSource;
    LSA_UNICODE_STRING ReplicaAccountName;

} POLICY_REPLICA_SOURCE_INFO, *PPOLICY_REPLICA_SOURCE_INFO;


//
// The following structure corresponds to the PolicyDefaultQuotaInformation
// information class.
//

typedef struct _POLICY_DEFAULT_QUOTA_INFO {

    QUOTA_LIMITS QuotaLimits;

} POLICY_DEFAULT_QUOTA_INFO, *PPOLICY_DEFAULT_QUOTA_INFO;


//
// The following structure corresponds to the PolicyModificationInformation
// information class.
//

typedef struct _POLICY_MODIFICATION_INFO {

    LARGE_INTEGER ModifiedId;
    LARGE_INTEGER DatabaseCreationTime;

} POLICY_MODIFICATION_INFO, *PPOLICY_MODIFICATION_INFO;

// where the members have the following usage:
//
//     ModifiedId - Is a 64-bit unsigned integer that is incremented each
//         time anything in the LSA database is modified.  This value is
//         only modified on Primary Domain Controllers.
//
//     DatabaseCreationTime - Is the date/time that the LSA Database was
//         created.  On Backup Domain Controllers, this value is replicated
//         from the Primary Domain Controller.
//

//
// The following structure type corresponds to the PolicyAuditFullSetInformation
// Information Class.
//

typedef struct _POLICY_AUDIT_FULL_SET_INFO {

    BOOLEAN ShutDownOnFull;

} POLICY_AUDIT_FULL_SET_INFO, *PPOLICY_AUDIT_FULL_SET_INFO;

//
// The following structure type corresponds to the PolicyAuditFullQueryInformation
// Information Class.
//

typedef struct _POLICY_AUDIT_FULL_QUERY_INFO {

    BOOLEAN ShutDownOnFull;
    BOOLEAN LogIsFull;

} POLICY_AUDIT_FULL_QUERY_INFO, *PPOLICY_AUDIT_FULL_QUERY_INFO;


//
// LSA RPC Context Handle (Opaque form).  Note that a Context Handle is
// always a pointer type unlike regular handles.
//

typedef PVOID LSA_HANDLE, *PLSA_HANDLE;


//
// Trusted Domain Object specific data types
//

//
// This data type defines the following information classes that may be
// queried or set.
//

typedef enum _TRUSTED_INFORMATION_CLASS {

    TrustedDomainNameInformation = 1,
    TrustedControllersInformation,
    TrustedPosixOffsetInformation,
    TrustedPasswordInformation

} TRUSTED_INFORMATION_CLASS, *PTRUSTED_INFORMATION_CLASS;

//
// The following data type corresponds to the TrustedDomainNameInformation
// information class.
//

typedef struct _TRUSTED_DOMAIN_NAME_INFO {

    LSA_UNICODE_STRING Name;

} TRUSTED_DOMAIN_NAME_INFO, *PTRUSTED_DOMAIN_NAME_INFO;

// where members have the following meaning:
//
// Name - The name of the Trusted Domain.
//

//
// The following data type corresponds to the TrustedControllersInformation
// information class.
//

typedef struct _TRUSTED_CONTROLLERS_INFO {

    ULONG Entries;
    PLSA_UNICODE_STRING Names;

} TRUSTED_CONTROLLERS_INFO, *PTRUSTED_CONTROLLERS_INFO;

// where members have the following meaning:
//
// Entries - Indicate how mamy entries there are in the Names array.
//
// Names - Pointer to an array of LSA_UNICODE_STRING structures containing the
//     names of domain controllers of the domain.  This information may not
//     be accurate and should be used only as a hint.  The order of this
//     list is considered significant and will be maintained.
//
//     By convention, the first name in this list is assumed to be the
//     Primary Domain Controller of the domain.  If the Primary Domain
//     Controller is not known, the first name should be set to the NULL
//     string.
//


//
// The following data type corresponds to the TrustedPosixOffsetInformation
// information class.
//

typedef struct _TRUSTED_POSIX_OFFSET_INFO {

    ULONG Offset;

} TRUSTED_POSIX_OFFSET_INFO, *PTRUSTED_POSIX_OFFSET_INFO;

// where members have the following meaning:
//
// Offset - Is an offset to use for the generation of Posix user and group
//     IDs from SIDs.  The Posix ID corresponding to any particular SID is
//     generated by adding the RID of that SID to the Offset of the SID's
//     corresponding TrustedDomain object.
//

//
// The following data type corresponds to the TrustedPasswordInformation
// information class.
//

typedef struct _TRUSTED_PASSWORD_INFO {
    LSA_UNICODE_STRING Password;
    LSA_UNICODE_STRING OldPassword;
} TRUSTED_PASSWORD_INFO, *PTRUSTED_PASSWORD_INFO;




//
// LSA Enumeration Context
//

typedef ULONG LSA_ENUMERATION_HANDLE, *PLSA_ENUMERATION_HANDLE;

//
// LSA Enumeration Information
//

typedef struct _LSA_ENUMERATION_INFORMATION {

    PSID Sid;

} LSA_ENUMERATION_INFORMATION, *PLSA_ENUMERATION_INFORMATION;


////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Local Security Policy - Miscellaneous API function prototypes          //
//                                                                        //
////////////////////////////////////////////////////////////////////////////


NTSTATUS
NTAPI
LsaFreeMemory(
    IN PVOID Buffer
    );

NTSTATUS
NTAPI
LsaClose(
    IN LSA_HANDLE ObjectHandle
    );

NTSTATUS
NTAPI
LsaOpenPolicy(
    IN PLSA_UNICODE_STRING SystemName OPTIONAL,
    IN PLSA_OBJECT_ATTRIBUTES ObjectAttributes,
    IN ACCESS_MASK DesiredAccess,
    IN OUT PLSA_HANDLE PolicyHandle
    );

NTSTATUS
NTAPI
LsaQueryInformationPolicy(
    IN LSA_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    );

NTSTATUS
NTAPI
LsaSetInformationPolicy(
    IN LSA_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    IN PVOID Buffer
    );


NTSTATUS
NTAPI
LsaEnumerateTrustedDomains(
    IN LSA_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PVOID *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    );


NTSTATUS
NTAPI
LsaLookupNames(
    IN LSA_HANDLE PolicyHandle,
    IN ULONG Count,
    IN PLSA_UNICODE_STRING Names,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_SID *Sids
    );

NTSTATUS
NTAPI
LsaLookupSids(
    IN LSA_HANDLE PolicyHandle,
    IN ULONG Count,
    IN PSID *Sids,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_NAME *Names
    );



#define SE_INTERACTIVE_LOGON_NAME       TEXT("SeInteractiveLogonRight")
#define SE_NETWORK_LOGON_NAME           TEXT("SeNetworkLogonRight")
#define SE_BATCH_LOGON_NAME             TEXT("SeBatchLogonRight")
#define SE_SERVICE_LOGON_NAME           TEXT("SeServiceLogonRight")

//
// This new API returns all the accounts with a certain privilege
//

NTSTATUS
NTAPI
LsaEnumerateAccountsWithUserRight(
    IN LSA_HANDLE PolicyHandle,
    IN OPTIONAL PLSA_UNICODE_STRING UserRights,
    OUT PVOID *EnumerationBuffer,
    OUT PULONG CountReturned
    );

//
// These new APIs differ by taking a SID instead of requiring the caller
// to open the account first and passing in an account handle
//

NTSTATUS
NTAPI
LsaEnumerateAccountRights(
    IN LSA_HANDLE PolicyHandle,
    IN PSID AccountSid,
    OUT PLSA_UNICODE_STRING *UserRights,
    OUT PULONG CountOfRights
    );

NTSTATUS
NTAPI
LsaAddAccountRights(
    IN LSA_HANDLE PolicyHandle,
    IN PSID AccountSid,
    IN PLSA_UNICODE_STRING UserRights,
    IN ULONG CountOfRights
    );

NTSTATUS
NTAPI
LsaRemoveAccountRights(
    IN LSA_HANDLE PolicyHandle,
    IN PSID AccountSid,
    IN BOOLEAN AllRights,
    IN PLSA_UNICODE_STRING UserRights,
    IN ULONG CountOfRights
    );


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Local Security Policy - Trusted Domain Object API function prototypes     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
LsaQueryTrustedDomainInfo(
    IN LSA_HANDLE PolicyHandle,
    IN PSID TrustedDomainSid,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    );

NTSTATUS
NTAPI
LsaSetTrustedDomainInformation(
    IN LSA_HANDLE PolicyHandle,
    IN PSID TrustedDomainSid,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    IN PVOID Buffer
    );

NTSTATUS
NTAPI
LsaDeleteTrustedDomain(
    IN LSA_HANDLE PolicyHandle,
    IN PSID TrustedDomainSid
    );

//
// This API sets the workstation password (equivalent of setting/getting
// the SSI_SECRET_NAME secret)
//

NTSTATUS
NTAPI
LsaStorePrivateData(
    IN LSA_HANDLE PolicyHandle,
    IN PLSA_UNICODE_STRING KeyName,
    IN PLSA_UNICODE_STRING PrivateData
    );

NTSTATUS
NTAPI
LsaRetrievePrivateData(
    IN LSA_HANDLE PolicyHandle,
    IN PLSA_UNICODE_STRING KeyName,
    OUT PLSA_UNICODE_STRING * PrivateData
    );


ULONG
NTAPI
LsaNtStatusToWinError(
    NTSTATUS Status
    );

//
// Define a symbol so we can tell if ntifs.h has been included.
//

// begin_ntifs
#ifndef _NTLSA_IFS_
#define _NTLSA_IFS_
#endif
// end_ntifs

#ifndef _NTDEF_
typedef LSA_UNICODE_STRING UNICODE_STRING, *PUNICODE_STRING;
#endif

typedef NTSTATUS (*PSAM_PASSWORD_NOTIFICATION_ROUTINE) (
    PUNICODE_STRING UserName,
    ULONG RelativeId,
    PUNICODE_STRING NewPassword
);

#define SAM_PASSWORD_CHANGE_NOTIFY_ROUTINE  "PasswordChangeNotify"

typedef BOOLEAN (*PSAM_INIT_NOTIFICATION_ROUTINE) (
);

#define SAM_INIT_NOTIFICATION_ROUTINE  "InitializeChangeNotify"


#define SAM_PASSWORD_FILTER_ROUTINE  "PasswordFilter"

typedef BOOLEAN (*PSAM_PASSWORD_FILTER_ROUTINE) (
    IN PUNICODE_STRING  AccountName,
    IN PUNICODE_STRING  FullName,
    IN PUNICODE_STRING Password,
    IN BOOLEAN SetOperation
    );


#ifdef __cplusplus
}
#endif

#endif /* _NTSECAPI_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\onhold.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    onhold.cpp

Abstract:

   Handle queue onhold/resume

Author:

    Uri Habusha (urih) July, 1998

--*/

#include "stdh.h"

#include <fntoken.h>
#include <qformat.h>
#include <mqformat.h>
#include "cqmgr.h"
#include "cqueue.h"
#include "sessmgr.h"

#include "onhold.tmh"

extern CSessionMgr SessionMgr;
const WCHAR ONHOLDRegKey[] = L"OnHold Queues";

static WCHAR *s_FN=L"onhold";

STATIC
HRESULT
GetRegValueName(
    const QUEUE_FORMAT* pqf,
    LPWSTR pRegValueName,
    DWORD size
    )
{
    const DWORD x_KeyNameLen = STRLEN(ONHOLDRegKey) + 1; // for '\'
    //
    // build the registery value name. It consist from the key name
    // and the Queue format name
    //
    if (x_KeyNameLen >= size)
    {
        return LogHR(MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL, s_FN, 10);
    }

    wsprintf(pRegValueName, L"%s\\", ONHOLDRegKey);

    DWORD QueueFormatNameLen;
    HRESULT hr = MQpQueueFormatToFormatName(
                        pqf,
                        pRegValueName + x_KeyNameLen,
                        size - x_KeyNameLen,
                        &QueueFormatNameLen,
                        false
                        );
    return LogHR(hr, s_FN, 20);
}

HRESULT
InitOnHold(
    void
    )
{
    //
    // Get a handle to Falcon registry. Don't close this handle
    // because it is cached in MQUTIL.DLL. If you close this handle,
    // the next time you'll need it, you'll get a closed handle.
    //
    HKEY hOnHoldKey;
    LONG lError;
    lError = GetFalconKey(ONHOLDRegKey, &hOnHoldKey);
    if (lError != ERROR_SUCCESS)
    {
        return LogHR(MQ_ERROR, s_FN, 30);
    }


    DWORD Index = 0;
    for(;;)
    {
        WCHAR QueueFormatName[256];
        DWORD BuffSize = 256;

        QUEUE_FORMAT qf;
        DWORD qfSize = sizeof(QUEUE_FORMAT);

        lError= RegEnumValue(
                    hOnHoldKey,
                    Index,
                    QueueFormatName,
                    &BuffSize,
                    0,
                    NULL,
                    reinterpret_cast<BYTE*>(&qf),
                    &qfSize
                    );

        if (lError != ERROR_SUCCESS)
        {
            break;
        }

        ASSERT((qf.GetType() == QUEUE_FORMAT_TYPE_PUBLIC) ||
               (qf.GetType() == QUEUE_FORMAT_TYPE_PRIVATE) ||
               (qf.GetType() == QUEUE_FORMAT_TYPE_DIRECT));

        if (qf.GetType() == QUEUE_FORMAT_TYPE_DIRECT)
        {
            ASSERT(wcsncmp(QueueFormatName, FN_DIRECT_TOKEN, FN_DIRECT_TOKEN_LEN) == 0);
            ASSERT(QueueFormatName[FN_DIRECT_TOKEN_LEN] == L'=');
            //
            // the format name for direct is stored without the
            // direct sting. reconstruct it from the queue format name
            //
            qf.DirectID(&QueueFormatName[FN_DIRECT_TOKEN_LEN+1]);
        }

        //
        // Get the Queue object
        //
        CQueue* pQueue;
        HRESULT hr = QueueMgr.GetQueueObject(&qf, &pQueue, NULL, false);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 40);
        }

        //
        // On Hold for local queue isn't allowed
        //
        ASSERT(!pQueue->IsLocalQueue());
        pQueue->Pause();

        //
        // Decrement the refernce count. It already increment in
        // GetQueueObject  function
        //
        pQueue->Release();

        ++Index;
    }

    return MQ_OK;
}


STATIC
HRESULT
RegAddOnHoldQueue(
    const QUEUE_FORMAT* pqf
    )
{
    //
    // build the registery value name. It consist from the key name
    // and the Queue format name
    //
    WCHAR RegValueName[500];
    HRESULT hr;
    hr = GetRegValueName(
            pqf,
            RegValueName,
            500
            );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 50);
    }

    //
    // Set the value in registery.
    //
    DWORD dwSize = sizeof(QUEUE_FORMAT);
    DWORD dwType = REG_BINARY;
    hr = SetFalconKeyValue(
                RegValueName,
                &dwType,
                const_cast<QUEUE_FORMAT*>(pqf),
                &dwSize
                );

    return LogHR(hr, s_FN, 60);
}


STATIC
HRESULT
RegRemoveOnHoldQueue(
    const QUEUE_FORMAT* pqf
    )
{
    //
    // build the registery value name. It consist from the key name
    // and the Queue format name
    //
    WCHAR RegValueName[500];
    HRESULT hr;
    hr = GetRegValueName(
            pqf,
            RegValueName,
            500
            );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 70);
    }

    //
    // Delet the value from registery.
    //
    hr = DeleteFalconKeyValue(RegValueName);
    return LogHR(hr, s_FN, 80);
}


HRESULT
PauseQueue(
    const QUEUE_FORMAT* pqf
    )
{
    //
    // Get the Queue object
    //
    R<CQueue> pQueue;
    HRESULT hr = QueueMgr.GetQueueObject(pqf, &pQueue.ref(), NULL, false);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 90);
    }

    //
    // Local queue can't hold. It is meaningless
    //
    if (pQueue->IsLocalQueue())
    {
        return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 100);
    }

    //
    // Save the queue format in registery. So after next
    // MSMQ start-up it'll be open in onhold state
    //
    hr = RegAddOnHoldQueue(pqf);
    ASSERT(SUCCEEDED(hr));
    LogHR(hr, s_FN, 189);

    //
    // Mark the queue as onhold queue
    //
    pQueue->Pause();

    //
    // move the queue from waiting group to nonactive.
    //
    SessionMgr.MoveQueueFromWaitingToNonActiveGroup(pQueue.get());
    return MQ_OK;
}


HRESULT
ResumeQueue(
    const QUEUE_FORMAT* pqf
    )
{
    //
    // Get the Queue object
    //
    R<CQueue> pQueue;
    BOOL fSucc = QueueMgr.LookUpQueue(pqf, &pQueue.ref(), false, false);

    //
    // onhold queue should be in the internal data structure.
    //
    if (!fSucc)
    {
        return LogHR(MQ_ERROR, s_FN, 110);
    }

    //
    // Local queue can't hold. It is meaningless
    //
    if (pQueue->IsLocalQueue())
    {
        return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 120);
    }

    //
    // Remove the format name from registery
    //
    HRESULT hr = RegRemoveOnHoldQueue(pqf);
    ASSERT(SUCCEEDED(hr));
    LogHR(hr, s_FN, 193);

    //
    // Mark the queue as regular queue
    //
    pQueue->Resume();

    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\perfcomn.cpp ===
#include <stdh.h>

#include "..\\mqperf\\perfcomn.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\perfdata.cpp ===
#include <stdh.h>

#include "..\\mqperf\\perfdata.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\ping.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ping.h

Abstract:

  Falcon private ping

Author:

    Lior Moshaiov (LiorM) 19-Apr-1997

--*/

#ifndef _PING_H_
#define _PING_H_


BOOL ping(const SOCKADDR* pAddr, DWORD dwTimeout);
HRESULT StartPingClient();
HRESULT StartPingServer();

#endif // _PING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\perf.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name : perfapp.cpp



Abstract    : Defines the methods of the CPerf class.



Prototype   : perfctr.h

Author:

    Gadi Ittah (t-gadii)

--*/

#include "stdh.h"

#include <string.h>
#include <TCHAR.H>
#include <stdio.h>
#include <winperf.h>
#include "qmperf.h"
#include "perfdata.h"
#include <ac.h>
#include "qmres.h"

#include "perf.tmh"

CPerf * g_pPerfObj = NULL;

static WCHAR *s_FN=L"perf";
extern HMODULE   g_hResourceMod;


CPerfUnLockMem::CPerfUnLockMem(void * pAddr,DWORD dwSize)
{
#ifdef PROTECT_PERF_COUNTERS
   m_pAddr=pAddr;
   m_dwSize = dwSize;

   g_pPerfObj->m_cs.Enter();
   g_pPerfObj->EnableUpdate(m_pAddr,m_dwSize,TRUE);
#endif // PROTECT_PERF_COUNTERS
}

CPerfUnLockMem::~CPerfUnLockMem()
{
#ifdef PROTECT_PERF_COUNTERS
   g_pPerfObj->EnableUpdate(m_pAddr,m_dwSize,FALSE);
   g_pPerfObj->m_cs.Leave();
#endif // PROTECT_PERF_COUNTERS
}


//
// pqmCounters will point to the shared memory area, where the counters are stored.
// This area is updated by the QM and read by the Performance Monitor.
//
QmCounters dummyCounters;
QmCounters *g_pqmCounters = &dummyCounters;


extern HANDLE g_hAc;




inline PERF_INSTANCE_DEFINITION* Counters2Instance(const void* pCounters)
{
    BYTE* p = reinterpret_cast<BYTE*>(const_cast<void*>(pCounters));
    return reinterpret_cast<PPERF_INSTANCE_DEFINITION>(
            p -
            sizeof(PERF_INSTANCE_DEFINITION) -
            INSTANCE_NAME_LEN_IN_BYTES -
            sizeof (PERF_COUNTER_BLOCK)
            );
}


#if 0
//
// BUGBUG: this code is here for completness. it is not tested and not used
// in this file
//
inline void* Instance2Counters(PERF_INSTANCE_DEFINITION* pInstance)
{
    BYTE* p = reinterpret_cast<BYTE*>(pInstance);
    return reinterpret_cast<void*>(
            p +
            sizeof(PERF_INSTANCE_DEFINITION) +
            INSTANCE_NAME_LEN_IN_BYTES +
            sizeof (PERF_COUNTER_BLOCK)
            );
}
#endif // 0
/*====================================================



Description : Constructor for CPerf class


Arguments   :
                IN PerfObjectDef * pObjectArray - Pointer to an array of objects.
                IN DWORD dwObjectCount          - The number of objects.
                IN LPTSTR pszPerfApp            - The name of the application as it written in the registery.


=====================================================*/
CPerf::CPerf(IN PerfObjectDef * pObjectArray,IN DWORD dwObjectCount):
m_fShrMemCreated(FALSE),m_pObjectDefs (NULL),m_hSharedMem(NULL)

{
    //
    // There should be only one instance of the cperf object
    //
    ASSERT(g_pPerfObj == NULL);

    g_pPerfObj = this;

    m_pObjects      = pObjectArray;
    m_dwObjectCount = dwObjectCount;
    m_dwMemSize     = 0;

    DWORD dwServiceNameLen;

    dwServiceNameLen = GetFalconServiceName(m_szPerfApp,
                                            sizeof(m_szPerfApp)/sizeof(WCHAR));
    ASSERT(dwServiceNameLen < sizeof(m_szPerfApp)/sizeof(WCHAR));

    //
    // find the maximum number of counters per object and initalize a dummy array
    // with maximum number of counters
    //

    DWORD dwMaxCounters = 1;

    for (DWORD i = 0;i<dwObjectCount;i++)
    {
        if (pObjectArray[i].dwNumOfCounters > dwMaxCounters)
        {
           dwMaxCounters = pObjectArray[i].dwNumOfCounters;
        }
    }

    m_pDummyInstance = new DWORD[dwMaxCounters];
}


/*====================================================



Description :Destructor for CPerf class. Closes shared memory and frees allocated memory


Arguments   :

Return Value:

=====================================================*/


CPerf::~CPerf()
{

    if (m_fShrMemCreated)
    {

        EnableUpdate(m_pSharedMemBase,m_dwMemSize,TRUE);

        //
        // Clear the shared memory so objects won't be displayed in permon
        // after the QM goes down.
        //
        memset (m_pSharedMemBase,0,m_dwMemSize);

        UnmapViewOfFile (m_pSharedMemBase);
        CloseHandle(m_hSharedMem);
        delete m_pObjectDefs;
        m_pObjectDefs = 0;

    }

    delete m_pDummyInstance;
}


/*====================================================


CPerf::InValidateObject

Description :   Invalidates an object.The object will not be displayed in the performance monitor.
                The pointers to the objects counters thst were returned by the method GetCounters
                will still be valid.

Arguments   : IN LPTSTR pszObjectName - Name of object to invalidate

Return Value: TRUE if sucsesfull FALSE otherwise.

=====================================================*/


BOOL CPerf::InValidateObject (IN LPTSTR pszObjectName)

{
    CS lock(m_cs);

    if (!m_fShrMemCreated)
        return LogBOOL(FALSE, s_FN, 50);


    int  iObjectIndex = FindObject(pszObjectName);

    if (iObjectIndex==-1)
    {
        DBGMSG( (DBGMOD_PERF,DBGLVL_ERROR,_T("CPerf::InValidateObject : No object named %ls"),pszObjectName));
        ASSERT (0);
        return LogBOOL(FALSE, s_FN, 40);
    }


    PPERF_OBJECT_TYPE pPerfObject = (PPERF_OBJECT_TYPE) (m_pObjectDefs[iObjectIndex].pSharedMem);


    CPerfUnLockMem lockMem(&pPerfObject->TotalByteLength,sizeof(DWORD));

    //
    // Invalidate the object
    //
    pPerfObject-> TotalByteLength = PERF_INVALID;

    return TRUE;
}


/*====================================================


CPerf::ValidateObject

Description :   Validates an object.If the object is instensiable it must have at least one instance for it to be
                validated. After the object is validated it will appear in the performance monitor

Arguments   : IN LPTSTR pszObjectName - Name of object to invalidate

Return Value: TRUE if sucsesfull FALSE otherwise.

=====================================================*/

BOOL CPerf::ValidateObject (IN LPTSTR pszObjectName)

{
    CS lock(m_cs);


    if (!m_fShrMemCreated)
        return LogBOOL(FALSE, s_FN, 10);

    int  iObjectIndex = FindObject(pszObjectName);

    if (iObjectIndex==-1)
    {
        DBGMSG( (DBGMOD_PERF,DBGLVL_ERROR,_T("CPerf::ValidateObject : No object named %ls"),pszObjectName));
        ASSERT (0);
        return LogBOOL(FALSE, s_FN, 20);
    }


    PPERF_OBJECT_TYPE pPerfObject = (PPERF_OBJECT_TYPE) (m_pObjectDefs[iObjectIndex].pSharedMem);

    //
    // if object has instances at least one of its instances must be valid for it to be valid
    //
    if (m_pObjects[iObjectIndex].dwMaxInstances >0)
    {
        if (m_pObjectDefs[iObjectIndex].dwNumOfInstances  ==  0)
        {
            DBGMSG( (DBGMOD_PERF,DBGLVL_ERROR,_T("CPerf::ValidateObject : Non of object's %ls instances is valide"),pszObjectName));
	        return LogBOOL(FALSE, s_FN, 30);
        }
    }


    CPerfUnLockMem lockMem(&pPerfObject->TotalByteLength,sizeof(DWORD));

    //
    // Validate the object
    //

    pPerfObject-> TotalByteLength = PERF_VALID;

    return TRUE;
}




/*====================================================

GetCounters

Description : Returns a pointer to an array of counters for an object with no instances.
              The application should cache this pointer and use it to update the counters directly.
              Note that the object will be valid this method is returns.


Arguments   :

Return Value: If succefull returns a pointer to an array of counters , otherwise returns NULL.

=====================================================*/


void * CPerf::GetCounters(IN LPTSTR pszObjectName)
{
    CS lock(m_cs);

    if (!m_fShrMemCreated)
        return m_pDummyInstance;

    int  iObjectIndex = FindObject(pszObjectName);

    if (iObjectIndex==-1)
    {
        DBGMSG( (DBGMOD_PERF,DBGLVL_ERROR,_T("CPerf::GetCounters : No object named %ls"),pszObjectName));
        ASSERT (0);
        return NULL;
    }

    if (m_pObjects[iObjectIndex].dwMaxInstances != 0)
    {
        DBGMSG( (DBGMOD_PERF,DBGLVL_ERROR,_T("CPerf::GetCounters  : Object %ls has instances use CPerf::AddInstance()"),pszObjectName));
        ASSERT (0);
        return NULL;
    }

    ValidateObject (pszObjectName);

    PPERF_OBJECT_TYPE pPerfObject = (PPERF_OBJECT_TYPE) (m_pObjectDefs[iObjectIndex].pSharedMem);

    return ((PBYTE)pPerfObject)+sizeof (PERF_COUNTER_BLOCK)+OBJECT_DEFINITION_SIZE(m_pObjects[iObjectIndex].dwNumOfCounters);
}


/*====================================================

SetInstanceNameInternal

Description :  Set instance name internal, does not lcok instance

Arguments   :  pInstance  - Instance to update its name
               pszInstanceName - the new instance name

Return Value:  None

=====================================================*/
STATIC void SetInstanceNameInternal(PERF_INSTANCE_DEFINITION* pInstance, LPCTSTR pszInstanceName)
{
    ASSERT(pszInstanceName != 0);

    DWORD length = min(wcslen(pszInstanceName) + 1, INSTANCE_NAME_LEN);
    LPTSTR pName = reinterpret_cast<LPTSTR>(pInstance + 1);

	pInstance->NameLength = length * sizeof(WCHAR);
    wcsncpy(pName, pszInstanceName, length - 1);
    pName[length] = 0;

	//
	// replace '/' with '\' due bug in perfmon
	//
	LPWSTR pStart = pName;
	LPWSTR pEnd = pName + length;

	std::replace(pStart, pEnd, L'/', L'\\');
}



/*====================================================

CPerf::SetInstanceName

Description :  Replace instance name

Arguments   :  pInstance  - Instance to update its name
               pszInstanceName - the new instance name

Return Value:  TRUE if successfull, FALSE otherwise.

=====================================================*/
BOOL CPerf::SetInstanceName(const void* pCounters, LPCTSTR pszInstanceName)
{
    CS lock(m_cs);

    if (pCounters == m_pDummyInstance)
        return TRUE;

    if (!m_fShrMemCreated)
        return FALSE;

    if (pCounters == NULL)
        return FALSE;

    PPERF_INSTANCE_DEFINITION pInstance;
    pInstance = Counters2Instance(pCounters);

    SetInstanceNameInternal(pInstance, pszInstanceName);

    return TRUE;
}


/*====================================================

CPerf::AddInstance

Description :  Adds an instance to an object.

Arguments   :  IN LPTSTR pszObjectName  - name of object to add the instance to.
               IN LPTSTR pszInstanceName    - name of the instance;

Return Value:  if succeeds returns a pointer to a an array of counters
               for the instance.
               if fails returns a pointer to a dummy array of pointers.
               The application can update the dummy array but the results will not be shown in the performance
               monitor.
=====================================================*/
void * CPerf::AddInstance(IN LPCTSTR pszObjectName,IN LPCTSTR pszInstanceName)
{
    CS lock(m_cs);

    if (!m_fShrMemCreated)
        return m_pDummyInstance;


    //
    // BugBug. Should put an assert
    //
    if ((pszObjectName==NULL) || (pszInstanceName==NULL))
    {
       DBGMSG((DBGMOD_PERF, DBGLVL_TRACE, _T("CPerf::AddInstance:Either object or instance == NULL. (No damage done)")));
       return(m_pDummyInstance);
    }

    int  iObjectIndex = FindObject (pszObjectName);
    if (iObjectIndex==-1)
    {
        DBGMSG( (DBGMOD_PERF,DBGLVL_ERROR,_T("CPerf::AddInstence : No object named %ls"),pszObjectName));
        ASSERT(0) ;
        return m_pDummyInstance;
    }

    DBGMSG( (DBGMOD_PERF,DBGLVL_TRACE,_T("CPerf::AddInstence : Object Name - %ls"), pszObjectName));

    if (m_pObjects[iObjectIndex].dwMaxInstances == 0)
    {
        DBGMSG( (DBGMOD_PERF,DBGLVL_ERROR,_T("CPerf::AddInstance: Object %ls can not have instances use CPerf::GetCounters()"),pszObjectName));
        ASSERT (m_pObjects[iObjectIndex].dwMaxInstances == 0);
        return m_pDummyInstance;
    }


    PPERF_OBJECT_TYPE pPerfObject = (PPERF_OBJECT_TYPE) (m_pObjectDefs[iObjectIndex].pSharedMem);

    if (m_pObjectDefs[iObjectIndex].dwNumOfInstances  ==  m_pObjects[iObjectIndex].dwMaxInstances)

    {
        // if there is no memory than an instamce can't be added
        DBGMSG( (DBGMOD_PERF, DBGLVL_WARNING ,
           _T("Perf: No memory for instance %ls of Object %ls."),
                                      pszInstanceName, pszObjectName));
        return m_pDummyInstance;
    };


    PPERF_INSTANCE_DEFINITION pInstance = (PPERF_INSTANCE_DEFINITION)((PBYTE)pPerfObject+OBJECT_DEFINITION_SIZE(m_pObjects[iObjectIndex].dwNumOfCounters));

    //
    // find the first free place for the instance
    //
    DWORD i;
    for (i = 0; i < m_pObjects[iObjectIndex].dwMaxInstances; i++)
    {
        if (pInstance->ByteLength == PERF_INVALID)
            break;
        pInstance =( PPERF_INSTANCE_DEFINITION) ((PBYTE)pInstance+INSTANCE_SIZE(m_pObjects[iObjectIndex].dwNumOfCounters));
    }

    //ASSERT (i < m_pObjects[iObjectIndex].dwMaxInstances); (this assert breaks me on multi-qm. ShaiK)
    //
    // if there are less than dwMaxInstances Instances there must always be a free place
    //
    if(i >= m_pObjects[iObjectIndex].dwMaxInstances)
    {
       //
       // If we reach here, there is a Bug in our code.
       // Until we found where, at least return a dummy instance.
       //
       return(m_pDummyInstance);
    }


    DBGMSG( (DBGMOD_PERF,DBGLVL_TRACE,_T("CPerf:: First free place for instance - %d. Instance Address %p"), i, pInstance));



    CPerfUnLockMem lockMem(pInstance,INSTANCE_SIZE(m_pObjects[iObjectIndex].dwNumOfCounters));


    //
    // Initialize the instance
    //
    pInstance->ByteLength = PERF_VALID ;
    pInstance->ParentObjectTitleIndex = 0;
    pInstance->ParentObjectInstance = 0;
    pInstance->UniqueID     = PERF_NO_UNIQUE_ID;
    pInstance->NameOffset   = sizeof(PERF_INSTANCE_DEFINITION);
    pInstance->NameLength   = 0;

    SetInstanceNameInternal(pInstance, pszInstanceName);

    //
    // setup counter block
    //
    DWORD* pdwCounters = (DWORD*)(((PBYTE)(pInstance + 1)) + INSTANCE_NAME_LEN_IN_BYTES);
    *pdwCounters = COUNTER_BLOCK_SIZE(pPerfObject->NumCounters);
    pdwCounters = (DWORD *) (((PBYTE)pdwCounters)+sizeof (PERF_COUNTER_BLOCK));

    void * pvRetVal = pdwCounters;

    //
    // initalize counters to zero
    //
    //ASSERT(pPerfObject->NumCounters == m_pObjects[iObjectIndex].dwNumOfCounters); (ShaiK)

    for (i=0;i<pPerfObject->NumCounters;i++,pdwCounters++)
        *pdwCounters =0;


    m_pObjectDefs[iObjectIndex].dwNumOfInstances++;

    return pvRetVal;
}





/*====================================================

CPerf::RemoveInstance

Description : Removes an objects instance.


Arguments: Pointer to instance


Return Value: If the function fails returns FALSE, otherwise TRUE is returned.

=====================================================*/



BOOL CPerf::RemoveInstance (LPTSTR IN pszObjectName, IN void* pCounters)
{
    CS lock(m_cs);

    if (pCounters == m_pDummyInstance)
        return TRUE;

    if (!m_fShrMemCreated)
        return FALSE;

    if (pCounters == NULL)
        return FALSE;

    PPERF_INSTANCE_DEFINITION pInstance;
    pInstance = Counters2Instance(pCounters);;

    int iObjectIndex = FindObject (pszObjectName);

    ASSERT(iObjectIndex != -1);

    DBGMSG( (DBGMOD_PERF,DBGLVL_TRACE,_T("CPerf::RemoveInstance : Object Name - %ls. Instance Address %p"),pszObjectName, pInstance));


    //
    // Check if instance already removed
    //
    if (pInstance->ByteLength == PERF_INVALID)
    {
        //ASSERT(0);  (this assert breaks me on multi-qm. ShaiK)
        DBGMSG( (DBGMOD_PERF,DBGLVL_TRACE,_T("CPerf::RemoveInstance : Object Name - %ls. Instance already removed!"),pszObjectName));
        return FALSE;
    }

    CPerfUnLockMem lockMem(pInstance,INSTANCE_SIZE(m_pObjects[iObjectIndex].dwNumOfCounters));

    //
    // Check if instance has already been removed
    //
    if (pInstance->ByteLength == PERF_INVALID)
    {
        ASSERT(0);
        DBGMSG( (DBGMOD_PERF,DBGLVL_TRACE,_T("CPerf::RemoveInstance : Object Name - %ls. Instance already removed!"),pszObjectName));
        return FALSE;
    }


    //
    // invalidate the instance so it won't be displayed in perfmon
    //
    pInstance->ByteLength = PERF_INVALID;


    if (m_pObjectDefs[iObjectIndex].dwNumOfInstances == 0)
        return TRUE;

    m_pObjectDefs[iObjectIndex].dwNumOfInstances--;

    //
    // if this was the last instance of the object then the object should be invalidated
    //

    if (m_pObjectDefs[iObjectIndex].dwNumOfInstances == 0)
    {
        PPERF_OBJECT_TYPE pPerfObject   = (PPERF_OBJECT_TYPE) (m_pObjectDefs[iObjectIndex].pSharedMem);
        pPerfObject->TotalByteLength    = PERF_INVALID;
    }

    return TRUE;

}





/*====================================================

CPerf::InitPerf()

Description :   Allocates shared memory and initalizes performance data structures.
                This function must be called before any other method of the object.


Arguments   :

Return Value: Returns TRUE if succeful ,FALSE otherwise.

=====================================================*/


BOOL   CPerf::InitPerf ()
{
    DWORD i,j; // loop control variables
    BOOL bRet;
    SECURITY_ATTRIBUTES sa;
    SECURITY_DESCRIPTOR sd;
    CAutoCloseHandle hToken;
    DWORD dwLen;
    AP<char> to_buff;
    TOKEN_OWNER *to;
    AP<char> Dacl_buff;
    PACL pDacl;
    SID_IDENTIFIER_AUTHORITY WoldSidAuth = SECURITY_WORLD_SID_AUTHORITY;
    PSID pWorldSid;
    DWORD dwAclSize;

    CS lock(m_cs);

    static BOOL fEnterdInitAlready = FALSE;

    if (fEnterdInitAlready)
        return FALSE;

    fEnterdInitAlready = TRUE;

    if (m_fShrMemCreated)
        return TRUE;

    LONG dwStatus;
    HKEY hKeyDriverPerf;
    DWORD dwSize;
    DWORD dwType;
    DWORD dwFirstCounter;
    DWORD dwFirstHelp;

    m_dwMemSize=0;

    if  (!m_fShrMemCreated)
    {
        // get counter and help index base values from registry
        //      Open key to registry entry
        //      read First Counter and First Help values
        //      update static data structures by adding base to
        //          offset value in structure.

        _TCHAR szPerfKey [255];

        _stprintf (szPerfKey,_T("SYSTEM\\CurrentControlSet\\Services\\%s\\Performance"), MQQM_SERVICE_NAME);

        {
            CS lock(*GetRegCS());
            dwStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,szPerfKey,0L,KEY_QUERY_VALUE,&hKeyDriverPerf);
        }

        if (dwStatus != ERROR_SUCCESS)
        {

            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.

            DBGMSG( (DBGMOD_PERF,DBGLVL_ERROR,_T("CPerf :: PerfInit Could not open registery key for application")));
	        return LogBOOL(FALSE, s_FN, 70);
        }

        dwSize = sizeof (DWORD);
        {
            CS lock(*GetRegCS());
            dwStatus = RegQueryValueEx(hKeyDriverPerf,_T("First Counter"),0L,&dwType,(LPBYTE)&dwFirstCounter,&dwSize);
        }

        if (dwStatus != ERROR_SUCCESS)
        {

            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
            DBGMSG( (DBGMOD_PERF,DBGLVL_ERROR,_T("CPerf :: PerfInit Could not get base values of counters")));
	        return LogBOOL(FALSE, s_FN, 80);
        }

        dwSize = sizeof (DWORD);
        {
            CS lock(*GetRegCS());
            dwStatus = RegQueryValueEx(hKeyDriverPerf,_T("First Help"),0L,&dwType,(LPBYTE)&dwFirstHelp,&dwSize);
        }

        if (dwStatus != ERROR_SUCCESS)
        {

            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
            DBGMSG( (DBGMOD_PERF,DBGLVL_ERROR,_T("CPerf :: PerfInit Could not get vbase values of counters")));
	        return LogBOOL(FALSE, s_FN, 90);
        }

        {
            CS lock(*GetRegCS());
            RegCloseKey (hKeyDriverPerf); // close key to registry
        }

        m_pObjectDefs = new PerfObjectInfo [m_dwObjectCount];
        for (i=0;i<m_dwObjectCount;i++)
        {

            m_dwMemSize += m_pObjects[i].dwMaxInstances*INSTANCE_SIZE(m_pObjects[i].dwNumOfCounters)
                        +OBJECT_DEFINITION_SIZE (m_pObjects[i].dwNumOfCounters);

            //
            // if this object dosn't have instances then it has a counter block
            //
            if (m_pObjects[i].dwMaxInstances == 0)
                m_dwMemSize += COUNTER_BLOCK_SIZE(m_pObjects[i].dwNumOfCounters);
        }

        //
        // Create a security descriptor for the shared memory. The security
        // descriptor gives full access to the shared memory for the creator
        // and read acccess for everyone else. By default, only the creator
        // can access the shared memory. But we want that anyone will be able
        // to read the performance data. So we must give read access to
        // everyone.
        //

        // Initialize the security descriptor
        bRet = InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
        ASSERT(bRet);

        // Open the process token for query.
        bRet = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);
        ASSERT(bRet);

        // Get the owner information from the token.
        bRet = GetTokenInformation(hToken, TokenOwner, NULL, 0, &dwLen);
        ASSERT(!bRet && (GetLastError() == ERROR_INSUFFICIENT_BUFFER));
        to_buff = new char[dwLen];
        to = (TOKEN_OWNER*)(char*)to_buff;
        bRet = GetTokenInformation(hToken, TokenOwner, to, dwLen, &dwLen);
        ASSERT(bRet);

        // Create the world well known SID
        bRet = AllocateAndInitializeSid(
            &WoldSidAuth, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &pWorldSid);
        ASSERT(bRet);

        // Allcoate buffer for the DACL.
        dwAclSize = sizeof(ACL) +
                    2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                    GetLengthSid(pWorldSid) + GetLengthSid(to->Owner);
        Dacl_buff = new char[dwAclSize];
        pDacl = (PACL)(char*)Dacl_buff;

        // Initialize the DACL.
        bRet = InitializeAcl(pDacl, dwAclSize, ACL_REVISION);
        ASSERT(bRet);

        // Add read access to everyone.
        bRet = AddAccessAllowedAce(pDacl,
                                   ACL_REVISION,
                                   FILE_MAP_READ,
                                   pWorldSid);
        ASSERT(bRet);

        // Free the world well known SID.
        FreeSid(pWorldSid);

        // Add full access to the creator.
        bRet = AddAccessAllowedAce(pDacl,
                                   ACL_REVISION,
                                   FILE_MAP_ALL_ACCESS,
                                   to->Owner);
        ASSERT(bRet);

        // Set the security descriptor's DACL.
        bRet = SetSecurityDescriptorDacl(&sd, TRUE, pDacl, TRUE);
        ASSERT(bRet);

        // Prepare the SECURITY_ATTRIBUTES structure.
        sa.nLength = sizeof(sa);
        sa.lpSecurityDescriptor = &sd;
        sa.bInheritHandle = FALSE;

#ifdef _DEBUG
        if ((m_dwMemSize/4096+1)*4096 - m_dwMemSize > 200)
        {
            DBGMSG((DBGMOD_PERF,DBGLVL_ERROR,_T("CPerfInit :: Shared memory can be enlarged without actually consume more memory. See file perfdata.h")));
        }
#endif

		std::wstring ObjectName = L"Global\\";
		ObjectName += m_szPerfApp;

        //
        // Create the shared memory.
        //
        m_hSharedMem = CreateFileMapping (INVALID_HANDLE_VALUE,
                  &sa,
                  PAGE_READWRITE,
                  0,
                  m_dwMemSize,
                  ObjectName.c_str());


        if ( m_hSharedMem== NULL)
        {
            DBGMSG((DBGMOD_PERF,DBGLVL_ERROR,_T("CPerfInit :: Could not Create shared memory")));
	        return LogBOOL(FALSE, s_FN, 110);
        }



        m_pSharedMemBase = (PBYTE)MapViewOfFile(m_hSharedMem,FILE_MAP_WRITE,0,0,0);

        if (!m_pSharedMemBase)
        {
            DBGMSG((DBGMOD_PERF,DBGLVL_ERROR,_T("CPerf::PerfInit : Could not map shared memory")));
	        return LogBOOL(FALSE, s_FN, 120);
        }


        CPerfUnLockMem lockMem(m_pSharedMemBase,m_dwMemSize);

        //
        // Initalize shared memory
        //
        memset(m_pSharedMemBase,0,m_dwMemSize);


        MapObjects (m_pSharedMemBase,m_dwObjectCount,m_pObjects,m_pObjectDefs);

        //
        // invalidate all the instances of all objects
        //
        for (i=0;i<m_dwObjectCount;i++)
        {
            PBYTE pTemp =(PBYTE)m_pObjectDefs[i].pSharedMem;
            pTemp+=OBJECT_DEFINITION_SIZE(m_pObjects[i].dwNumOfCounters);

            for (j=0;j<m_pObjects[i].dwMaxInstances;j++)
            {
                ((PPERF_INSTANCE_DEFINITION)pTemp)->ByteLength = PERF_INVALID;
                pTemp+=INSTANCE_SIZE(m_pObjects[i].dwNumOfCounters);
            }
        }

	    m_fShrMemCreated = TRUE;

        for (i=0;i<m_dwObjectCount;i++)
        {

            //
            // for each object we update the offset of title and help index's
            //
            m_pObjects[i].dwObjectNameTitleIndex += dwFirstCounter;
            m_pObjects[i].dwObjectHelpTitleIndex += dwFirstHelp;

            for (j=0;j<m_pObjects[i].dwNumOfCounters;j++)
            {
                m_pObjects[i].pCounters [j].dwCounterNameTitleIndex += dwFirstCounter;
                m_pObjects[i].pCounters [j].dwCounterHelpTitleIndex += dwFirstHelp;
            }


            //
            // for each object we initalizes the shared memory with the object                                                ;
            //
            PPERF_OBJECT_TYPE pPerfObject = (PPERF_OBJECT_TYPE) m_pObjectDefs[i].pSharedMem;

            //
            // invalidate all objects untill get counters are called
            //
            pPerfObject->TotalByteLength = PERF_INVALID;

            pPerfObject->DefinitionLength       = OBJECT_DEFINITION_SIZE(m_pObjects[i].dwNumOfCounters);
            pPerfObject->HeaderLength           = sizeof(PERF_OBJECT_TYPE);
            pPerfObject->ObjectNameTitleIndex   = m_pObjects[i].dwObjectNameTitleIndex;
            pPerfObject->ObjectNameTitle        = NULL;
            pPerfObject->ObjectHelpTitleIndex   = m_pObjects[i].dwObjectHelpTitleIndex;
            pPerfObject->ObjectHelpTitle        = NULL;
            pPerfObject->DetailLevel            = PERF_DETAIL_NOVICE;
            pPerfObject->NumCounters            = m_pObjects[i].dwNumOfCounters;
            pPerfObject->DefaultCounter         = 0;
            pPerfObject->NumInstances           = -1;
            pPerfObject->CodePage               = 0;

            PPERF_COUNTER_DEFINITION pCounter;
            pCounter = (PPERF_COUNTER_DEFINITION) ((BYTE *)pPerfObject+sizeof(PERF_OBJECT_TYPE));

            //
            // here we initalizes the counter defenitions
            //
            for (j=0;j<m_pObjects[i].dwNumOfCounters;j++)
            {

                pCounter->ByteLength = sizeof (PERF_COUNTER_DEFINITION);
                pCounter->CounterNameTitleIndex = m_pObjects[i].pCounters[j].dwCounterNameTitleIndex;
                pCounter->CounterNameTitle = NULL;
                pCounter->CounterHelpTitleIndex  = m_pObjects[i].pCounters[j].dwCounterHelpTitleIndex;
                pCounter->CounterHelpTitle = NULL;
                pCounter->DefaultScale = m_pObjects[i].pCounters[j].dwDefaultScale;
                pCounter->DetailLevel = PERF_DETAIL_NOVICE;
                pCounter->CounterType = m_pObjects[i].pCounters[j].dwCounterType;
                pCounter->CounterSize = sizeof (DWORD);
                pCounter->CounterOffset = j*sizeof (DWORD)+sizeof (PERF_COUNTER_BLOCK);

                pCounter=(PPERF_COUNTER_DEFINITION ) ((BYTE *)pCounter + sizeof (PERF_COUNTER_DEFINITION));

            }

            //
            //if the object has no instances then we must setup a counter block for it
            //
            if (m_pObjects[i].dwMaxInstances == 0)
                // setup the counter block
                * (DWORD *) pCounter = COUNTER_BLOCK_SIZE(m_pObjects[i].dwNumOfCounters);
        }
    }

	WCHAR PerfMachineQueueInstance[128];
	int Result = LoadString(
					g_hResourceMod, 
					IDS_MACHINE_QUEUES_INSTANCE,
					PerfMachineQueueInstance, 
					TABLE_SIZE(PerfMachineQueueInstance)
					);

	if(Result == 0)
	{
        DBGMSG( (DBGMOD_PERF,DBGLVL_ERROR,_T("CPerf::PerfInit Could not load string from resource file.")));
        return LogBOOL(FALSE, s_FN, 130);
	}

    //
    // Inform the device driver about the performance counters buffer, so it'll
    // update the queues and QM counters.
    //
    QueueCounters *pMachineQueueCounters = static_cast<QueueCounters*>(
        AddInstance(PERF_QUEUE_OBJECT, PerfMachineQueueInstance));
    g_pqmCounters = (QmCounters *)GetCounters(PERF_QM_OBJECT);


    HRESULT rc = ACSetPerformanceBuffer(g_hAc,
                           m_hSharedMem,
                           m_pSharedMemBase,
                           pMachineQueueCounters,
                           g_pqmCounters);
    LogHR(rc, s_FN, 140);


    DBGMSG( (DBGMOD_PERF,DBGLVL_INFO,_T("CPerf :: Initalization Ok.")));

    return TRUE;
}



/*====================================================

CPerf::FindObject

Description : Helper function for locating the objects index in the object array.


Arguments   : IN LPTSTR pszObjectName - objects name

Return Value: if succefull returns the objects index. Otherwise -1 is returned

=====================================================*/


int CPerf::FindObject (IN LPCTSTR pszObjectName)
{

    PerfObjectDef * pPerfObject = m_pObjects;

    for (DWORD i=0;i<m_dwObjectCount;i++)
    {
        if (!_tcscmp (pPerfObject->pszName,pszObjectName))
          return i;

        pPerfObject++;
    }

    return -1;
}





void CPerf::EnableUpdate(void * pAddr,DWORD dwSize,BOOL fEnable)
{
#ifdef PROTECT_PERF_COUNTERS

    //
    // if the counter isn't in the shared memory than don't do any thing
    //

    if ((g_pPerfObj->m_pSharedMemBase < pAddr) || (pAddr > g_pPerfObj->m_pSharedMemBase+g_pPerfObj->m_dwMemSize))
    {
        return;
    }

    DWORD dwOldProtect;

    DWORD dwProtect = PAGE_READONLY;

    if (fEnable)
    {
        dwProtect = PAGE_READWRITE;
    }

    ASSERT(VirtualProtect(pAddr,dwSize,PAGE_READWRITE,&dwOldProtect));

#endif // PROTECT_PERF_COUNTERS

}


void
CSessionPerfmon::CreateInstance(
	LPCWSTR instanceName
	)
{
    m_pSessCounters = static_cast<SessionCounters*>(PerfApp.AddInstance(PERF_SESSION_OBJECT,instanceName));
	ASSERT(m_pSessCounters != NULL);

    PerfApp.ValidateObject(PERF_SESSION_OBJECT);

    UPDATE_COUNTER(&g_pqmCounters->nSessions, g_pqmCounters->nSessions += 1);
    UPDATE_COUNTER(&g_pqmCounters->nIPSessions, g_pqmCounters->nIPSessions += 1);
}


CSessionPerfmon::~CSessionPerfmon()
{
	if (m_pSessCounters == NULL)
		return;

    UPDATE_COUNTER(&g_pqmCounters->nSessions, g_pqmCounters->nSessions -= 1)
    UPDATE_COUNTER(&g_pqmCounters->nIPSessions, g_pqmCounters->nIPSessions -= 1)

    BOOL f = PerfApp.RemoveInstance(PERF_SESSION_OBJECT, m_pSessCounters);
	ASSERT(("RemoveInstance failed", f));
	DBG_USED(f);
}


void 
CSessionPerfmon::UpdateBytesSent(
	DWORD bytesSent
	)
{
	ASSERT(("Used uncreated object", m_pSessCounters != NULL));

    UPDATE_COUNTER(&m_pSessCounters->nOutBytes, m_pSessCounters->nOutBytes += bytesSent)
    UPDATE_COUNTER(&m_pSessCounters->tOutBytes, m_pSessCounters->tOutBytes += bytesSent)
}


void 
CSessionPerfmon::UpdateMessagesSent(
	void
	)
{
	ASSERT(("Used uncreated object", m_pSessCounters != NULL));

	UPDATE_COUNTER(&m_pSessCounters->nOutPackets, m_pSessCounters->nOutPackets += 1)
	UPDATE_COUNTER(&m_pSessCounters->tOutPackets, m_pSessCounters->tOutPackets += 1)

	UPDATE_COUNTER(&g_pqmCounters->nOutPackets, g_pqmCounters->nOutPackets += 1)
	UPDATE_COUNTER(&g_pqmCounters->tOutPackets, g_pqmCounters->tOutPackets += 1)
}


void 
CSessionPerfmon::UpdateBytesReceived(
	DWORD bytesReceived
	)
{
	ASSERT(("Used uncreated object", m_pSessCounters != NULL));

    UPDATE_COUNTER(&m_pSessCounters->nInBytes, m_pSessCounters->nInBytes += bytesReceived)
    UPDATE_COUNTER(&m_pSessCounters->tInBytes, m_pSessCounters->tInBytes += bytesReceived)

}


void 
CSessionPerfmon::UpdateMessagesReceived(
	void
	)
{
	ASSERT(("Used uncreated object", m_pSessCounters != NULL));

	UPDATE_COUNTER(&m_pSessCounters->nInPackets, m_pSessCounters->nInPackets += 1)
	UPDATE_COUNTER(&m_pSessCounters->tInPackets, m_pSessCounters->tInPackets += 1)

	UPDATE_COUNTER(&g_pqmCounters->nInPackets, g_pqmCounters->nInPackets += 1)
	UPDATE_COUNTER(&g_pqmCounters->tInPackets, g_pqmCounters->tInPackets += 1)
}


void
COutHttpSessionPerfmon::CreateInstance(
	LPCWSTR instanceName
	)
{
    m_pSessCounters = static_cast<COutSessionCounters*>(PerfApp.AddInstance(PERF_OUT_HTTP_SESSION_OBJECT,instanceName));
	ASSERT(m_pSessCounters != NULL);

    PerfApp.ValidateObject(PERF_OUT_HTTP_SESSION_OBJECT);


    UPDATE_COUNTER(&g_pqmCounters->nSessions, g_pqmCounters->nSessions += 1);
    UPDATE_COUNTER(&g_pqmCounters->nIPSessions, g_pqmCounters->nOutHttpSessions += 1);
}


COutHttpSessionPerfmon::~COutHttpSessionPerfmon()
{
	if (m_pSessCounters == NULL)
		return;

    UPDATE_COUNTER(&g_pqmCounters->nSessions, g_pqmCounters->nSessions -= 1)
    UPDATE_COUNTER(&g_pqmCounters->nIPSessions, g_pqmCounters->nOutHttpSessions -= 1)

    BOOL f = PerfApp.RemoveInstance(PERF_OUT_HTTP_SESSION_OBJECT, m_pSessCounters);
	ASSERT(("RemoveInstance failed", f));
	DBG_USED(f);
}


void 
COutHttpSessionPerfmon::UpdateMessagesSent(
	void
	)
{
	ASSERT(("Used uncreated object", m_pSessCounters != NULL));

	UPDATE_COUNTER(&m_pSessCounters->nOutPackets, m_pSessCounters->nOutPackets += 1)
	UPDATE_COUNTER(&m_pSessCounters->tOutPackets, m_pSessCounters->tOutPackets += 1)

	UPDATE_COUNTER(&g_pqmCounters->nOutPackets, g_pqmCounters->nOutPackets += 1)
	UPDATE_COUNTER(&g_pqmCounters->tOutPackets, g_pqmCounters->tOutPackets += 1)
}


void 
COutHttpSessionPerfmon::UpdateBytesSent(
	DWORD bytesSent
	)
{
	ASSERT(("Used uncreated object", m_pSessCounters != NULL));

    UPDATE_COUNTER(&m_pSessCounters->nOutBytes, m_pSessCounters->nOutBytes += bytesSent)
    UPDATE_COUNTER(&m_pSessCounters->tOutBytes, m_pSessCounters->tOutBytes += bytesSent)
}


void
COutPgmSessionPerfmon::CreateInstance(
	LPCWSTR instanceName
	)
{
    m_pSessCounters = static_cast<COutSessionCounters*>(PerfApp.AddInstance(PERF_OUT_PGM_SESSION_OBJECT,instanceName));
	ASSERT(m_pSessCounters != NULL);

    PerfApp.ValidateObject(PERF_OUT_PGM_SESSION_OBJECT);

    UPDATE_COUNTER(&g_pqmCounters->nSessions, g_pqmCounters->nSessions += 1);
    UPDATE_COUNTER(&g_pqmCounters->nIPSessions, g_pqmCounters->nOutPgmSessions += 1);
}


COutPgmSessionPerfmon::~COutPgmSessionPerfmon()
{
	if (m_pSessCounters == NULL)
		return;

    UPDATE_COUNTER(&g_pqmCounters->nSessions, g_pqmCounters->nSessions -= 1)
    UPDATE_COUNTER(&g_pqmCounters->nIPSessions, g_pqmCounters->nOutPgmSessions -= 1)

    BOOL f = PerfApp.RemoveInstance(PERF_OUT_PGM_SESSION_OBJECT, m_pSessCounters);
	ASSERT(("RemoveInstance failed", f));
	DBG_USED(f);
}


void 
COutPgmSessionPerfmon::UpdateMessagesSent(
	void
	)
{
	ASSERT(("Used uncreated object", m_pSessCounters != NULL));

	UPDATE_COUNTER(&m_pSessCounters->nOutPackets, m_pSessCounters->nOutPackets += 1)
	UPDATE_COUNTER(&m_pSessCounters->tOutPackets, m_pSessCounters->tOutPackets += 1)

	UPDATE_COUNTER(&g_pqmCounters->nOutPackets, g_pqmCounters->nOutPackets += 1)
	UPDATE_COUNTER(&g_pqmCounters->tOutPackets, g_pqmCounters->tOutPackets += 1)
}
   

void 
COutPgmSessionPerfmon::UpdateBytesSent(
	DWORD bytesSent
	)
{
	ASSERT(("Used uncreated object", m_pSessCounters != NULL));

    UPDATE_COUNTER(&m_pSessCounters->nOutBytes, m_pSessCounters->nOutBytes += bytesSent)
    UPDATE_COUNTER(&m_pSessCounters->tOutBytes, m_pSessCounters->tOutBytes += bytesSent)
}


void
CInPgmSessionPerfmon::CreateInstance(
	LPCWSTR instanceName
	)
{
    m_pSessCounters = static_cast<CInSessionCounters*>(PerfApp.AddInstance(PERF_IN_PGM_SESSION_OBJECT,instanceName));
	ASSERT(m_pSessCounters != NULL);

    PerfApp.ValidateObject(PERF_IN_PGM_SESSION_OBJECT);

	UPDATE_COUNTER(&g_pqmCounters->nSessions, g_pqmCounters->nSessions += 1);
    UPDATE_COUNTER(&g_pqmCounters->nIPSessions, g_pqmCounters->nInPgmSessions += 1);
}


CInPgmSessionPerfmon::~CInPgmSessionPerfmon()
{
	if (m_pSessCounters == NULL)
		return;

    UPDATE_COUNTER(&g_pqmCounters->nSessions, g_pqmCounters->nSessions -= 1)
    UPDATE_COUNTER(&g_pqmCounters->nIPSessions, g_pqmCounters->nInPgmSessions -= 1)

    BOOL f = PerfApp.RemoveInstance(PERF_IN_PGM_SESSION_OBJECT, m_pSessCounters);
	ASSERT(("RemoveInstance failed", f));
	DBG_USED(f);
}


void 
CInPgmSessionPerfmon::UpdateBytesReceived(
	DWORD bytesReceived
	)
{
	ASSERT(("Used uncreated object", m_pSessCounters != NULL));

    UPDATE_COUNTER(&m_pSessCounters->nInBytes, m_pSessCounters->nInBytes += bytesReceived)
    UPDATE_COUNTER(&m_pSessCounters->tInBytes, m_pSessCounters->tInBytes += bytesReceived)

}


void 
CInPgmSessionPerfmon::UpdateMessagesReceived(
	void
	)
{
	ASSERT(("Used uncreated object", m_pSessCounters != NULL));

	UPDATE_COUNTER(&m_pSessCounters->nInPackets, m_pSessCounters->nInPackets += 1)
	UPDATE_COUNTER(&m_pSessCounters->tInPackets, m_pSessCounters->tInPackets += 1)

	UPDATE_COUNTER(&g_pqmCounters->nInPackets, g_pqmCounters->nInPackets += 1)
	UPDATE_COUNTER(&g_pqmCounters->tInPackets, g_pqmCounters->tInPackets += 1)
}


void
CInHttpPerfmon::CreateInstance(
	LPCWSTR 
	)
{
	ASSERT(m_pSessCounters == NULL);
    m_pSessCounters = static_cast<CInSessionCounters*>(PerfApp.GetCounters(PERF_IN_HTTP_OBJECT));
	ASSERT(m_pSessCounters != NULL);

    PerfApp.ValidateObject(PERF_IN_PGM_SESSION_OBJECT);
}


void 
CInHttpPerfmon::UpdateBytesReceived(
	DWORD bytesReceived
	)
{
	ASSERT(("Used uncreated object", m_pSessCounters != NULL));

    UPDATE_COUNTER(&m_pSessCounters->nInBytes, m_pSessCounters->nInBytes += bytesReceived)
    UPDATE_COUNTER(&m_pSessCounters->tInBytes, m_pSessCounters->tInBytes += bytesReceived)

}


void 
CInHttpPerfmon::UpdateMessagesReceived(
	void
	)
{
	ASSERT(("Used uncreated object", m_pSessCounters != NULL));

	UPDATE_COUNTER(&m_pSessCounters->nInPackets, m_pSessCounters->nInPackets += 1)
	UPDATE_COUNTER(&m_pSessCounters->tInPackets, m_pSessCounters->tInPackets += 1)

	UPDATE_COUNTER(&g_pqmCounters->nInPackets, g_pqmCounters->nInPackets += 1)
	UPDATE_COUNTER(&g_pqmCounters->tInPackets, g_pqmCounters->tInPackets += 1)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\perf.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name : perfctr.h

Abstract    :

    This file defines the CPerf class which manages the counter objects and their intances.



Prototype   :

Author:

    Gadi Ittah (t-gadii)

--*/

#ifndef _PERF_H_
#define _PERF_H_

#include "perfctr.h"
#include "cs.h"
#include "spi.h"

class
#ifdef _QM_
__declspec(dllexport)
#else
__declspec(dllimport)
#endif


CPerf
{

    public:

    // the constructor does not initalize the shared memory automatically
    // InitPerf() should be called.
    CPerf (PerfObjectDef * pObjectArray,DWORD dwObjectC);
    ~CPerf();

    void * GetCounters (IN LPTSTR pszObjectName);

    BOOL ValidateObject (IN LPTSTR pszObjectName);
    BOOL InValidateObject (IN LPTSTR pszObjectName);
    void * AddInstance (IN LPCTSTR pszObjectName,IN LPCTSTR pszInstanceName);
    BOOL RemoveInstance (LPTSTR IN pszObjectName, void* pCounters);
    BOOL InitPerf ();
    BOOL IsDummyInstance(void*);
    BOOL SetInstanceName(const void* pCounters, LPCTSTR pszInstanceName);

    void EnableUpdate(void * pAddr,DWORD dwSize,BOOL fEnable);

    private:
    //
    // private member functions
    //
    int FindObject (LPCTSTR pszObjectName);

    //
    // private data members
    //
    PBYTE  m_pSharedMemBase;                // pointer to base of shared memory
    DWORD  m_dwMemSize;                     // size of shared memory

    HANDLE m_hSharedMem;                    // handle to shared memory

    PerfObjectInfo * m_pObjectDefs;         // ponter to an array of information on the objects

    BOOL m_fShrMemCreated;                  // flag - set to true after shared memory has been allocated

    WCHAR               m_szPerfApp[32];   // name of application in registery

    PerfObjectDef *     m_pObjects  ;       // pointer to array of objects
    DWORD               m_dwObjectCount;    // number of objects.

    void *   m_pDummyInstance;              // pointer to a buffer to dummy counters. This buffer is returned
                                            // when the AddInstance member failes. This enables the application
                                            // to assume the member always returns a valid pointer

    CCriticalSection m_cs;                  // critical section object used to synchronize threads

    friend class CPerfUnLockMem;
};

inline
BOOL
CPerf::IsDummyInstance(
    void *pInstance
    )
{
    return(pInstance == m_pDummyInstance);
}


class
#ifdef _QM_
__declspec(dllexport)
#else
__declspec(dllimport)
#endif
CPerfUnLockMem
{
public:
    CPerfUnLockMem(void * pAddr,DWORD dwSize);
    ~CPerfUnLockMem();
private:
    void * m_pAddr;
    DWORD  m_dwSize;
};

#ifdef PROTECT_PERF_COUNTERS
    #define UPDATE_COUNTER(addr,op)   \
    {\
        CPerfUnLockMem perfUnLock(addr,sizeof(DWORD));\
        op;\
    }
#else // PROTECT_PERF_COUNTERS
    #define UPDATE_COUNTER(addr,op)  op;
#endif // PROTECT_PERF_COUNTERS


class CSessionPerfmon : public ISessionPerfmon
{
	public:
		CSessionPerfmon() :
			m_pSessCounters(NULL)
		{
		}

		
		virtual ~CSessionPerfmon();


	public:
		// 
		// Interface function
		//
		virtual void CreateInstance(LPCWSTR instanceName);

		virtual void UpdateBytesSent(DWORD bytesSent);
		virtual void UpdateMessagesSent(void);
		
		virtual void UpdateBytesReceived(DWORD bytesReceived);
		virtual void UpdateMessagesReceived(void);

	private:
		SessionCounters* m_pSessCounters;
};


class COutHttpSessionPerfmon : public ISessionPerfmon
{
	public:
		COutHttpSessionPerfmon()  :
			m_pSessCounters(NULL)
		{
		}

		
		virtual ~COutHttpSessionPerfmon();


	public:
		// 
		// Interface function
		//
		virtual void CreateInstance(LPCWSTR instanceName);
		virtual void UpdateMessagesSent(void);
		virtual void UpdateBytesSent(DWORD bytesSent);

		virtual void UpdateBytesReceived(DWORD)
		{
			ASSERT(("unexpected call", 0));
		}

		virtual void UpdateMessagesReceived(void)
		{
			ASSERT(("unexpected call", 0));
		}

	private:
		COutSessionCounters* m_pSessCounters;
};

 
class CInHttpPerfmon : public ISessionPerfmon
{
	public:
		CInHttpPerfmon()  :
			m_pSessCounters(NULL)
		{
			CreateInstance(NULL);
		}

		virtual ~CInHttpPerfmon()
		{
		}

	public:
		// 
		// Interface function
		//
		virtual void CreateInstance(LPCWSTR instanceName);
		virtual void UpdateMessagesReceived(void);
		virtual void UpdateBytesReceived(DWORD bytesRecv);

		virtual void UpdateBytesSent(DWORD )
		{
			ASSERT(("unexpected call", 0));
		}

		virtual void UpdateMessagesSent(void)
		{
			ASSERT(("unexpected call", 0));
		}


	private:
		CInSessionCounters* m_pSessCounters;
};


class COutPgmSessionPerfmon : public ISessionPerfmon
{
	public:
		COutPgmSessionPerfmon()  :
			m_pSessCounters(NULL)
		{
		}

		
		virtual ~COutPgmSessionPerfmon();


	public:
		// 
		// Interface function
		//
		virtual void CreateInstance(LPCWSTR instanceName);
		virtual void UpdateMessagesSent(void);
		virtual void UpdateBytesSent(DWORD bytesSent);

		virtual void UpdateBytesReceived(DWORD)
		{
			ASSERT(("unexpected call", 0));
		}

		virtual void UpdateMessagesReceived(void)
		{
			ASSERT(("unexpected call", 0));
		}


	private:
		COutSessionCounters* m_pSessCounters;
};

 
class CInPgmSessionPerfmon : public ISessionPerfmon
{
	public:
		CInPgmSessionPerfmon()  :
			m_pSessCounters(NULL)
		{
		}

		
		virtual ~CInPgmSessionPerfmon();


	public:
		// 
		// Interface function
		//
		virtual void CreateInstance(LPCWSTR instanceName);
		virtual void UpdateMessagesReceived(void);
		virtual void UpdateBytesReceived(DWORD bytesRecv);

		virtual void UpdateBytesSent(DWORD )
		{
			ASSERT(("unexpected call", 0));
		}

		virtual void UpdateMessagesSent(void)
		{
			ASSERT(("unexpected call", 0));
		}


	private:
		CInSessionCounters* m_pSessCounters;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\ping.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ping.cpp

Abstract:

  Falcon private ping client and server

Author:

    Lior Moshaiov (LiorM) 19-Apr-1997

--*/

#include "stdh.h"
#include <winsock.h>
#include <nspapi.h>
#include "ping.h"
#include "cqmgr.h"
#include "license.h"
#include <mqutil.h>

#include "ping.tmh"

extern LPTSTR  g_szMachineName;
extern DWORD g_dwOperatingSystem;

#define PING_SIGNATURE       'UH'

static WCHAR *s_FN=L"ping";

//---------------------------------------------------------
//
//  class CPingPacket.
//
//---------------------------------------------------------
struct CPingPacket{
public:
    CPingPacket();
    CPingPacket(DWORD, USHORT, USHORT, GUID);

    DWORD Cookie() const;
    BOOL IsOtherSideClient() const;
    BOOL IsRefuse() const;
    BOOL IsValidSignature(void) const;
    GUID *pOtherGuid() ;

private:
    union {
        USHORT m_wFlags;
        struct {
            USHORT m_bfIC : 1;
            USHORT m_bfRefuse : 1;
        };
    };
    USHORT  m_ulSignature;
    DWORD   m_dwCookie;
    GUID    m_myQMGuid ;
};

//
// CPingPacket Implementation
//
inline
CPingPacket::CPingPacket()
{
}

inline
CPingPacket::CPingPacket(DWORD dwCookie, USHORT fIC, USHORT fRefuse, GUID QMGuid):
        m_bfIC(fIC),
        m_bfRefuse(fRefuse),
        m_ulSignature(PING_SIGNATURE),
        m_dwCookie(dwCookie),
        m_myQMGuid(QMGuid)
{

}

inline DWORD
CPingPacket::Cookie() const
{
    return m_dwCookie;
}

inline BOOL
CPingPacket::IsOtherSideClient() const
{
    return m_bfIC;
}

inline BOOL
CPingPacket::IsValidSignature(void) const
{
    return(m_ulSignature == PING_SIGNATURE);
}


inline BOOL
CPingPacket::IsRefuse(void) const
{
    return m_bfRefuse;
}

inline GUID *
CPingPacket::pOtherGuid()
{
   return &m_myQMGuid ;
}

//---------------------------------------------------------
//
//  class CPing
//
//---------------------------------------------------------

class CPing
{
    public:
        HRESULT Init(DWORD dwPort) ;

        SOCKET Select();
        virtual void Run() = 0;

    public:
        static HRESULT Receive(SOCKET sock,
                               SOCKADDR* pReceivedFrom,
                               CPingPacket* pPkt);
        static HRESULT Send(SOCKET sock,
                            const SOCKADDR* pSendTo,
                            DWORD dwCookie,
                            BOOL  fRefuse);

    private:
        static SOCKET CreateIPPingSocket(UINT dwPortID);

        static DWORD WINAPI WorkingThread(PVOID pThis);

    protected:
        SOCKET m_socket;
};

SOCKET CPing::CreateIPPingSocket(UINT dwPortID)
{
    SOCKET sock = socket(AF_INET, SOCK_DGRAM, 0);
    if(sock == INVALID_SOCKET)
    {
        DBGMSG((DBGMOD_ALL, DBGLVL_ERROR, TEXT("failed to create IP ping socket")));
        LogIllegalPoint(s_FN, 100);
        return INVALID_SOCKET;
    }

    int rc;
    BOOL exclusive = TRUE;
    rc = setsockopt(sock, SOL_SOCKET, SO_EXCLUSIVEADDRUSE, (char*)&exclusive, sizeof(exclusive));
    if(rc != 0)
    {
        DWORD gle = WSAGetLastError();

        DBGMSG((DBGMOD_ALL, DBGLVL_ERROR, 
		    TEXT("failed to set SO_EXCLUSIVEADDRUSE option for ping IP socket, rc=%d"), gle));
        LogHR(gle, s_FN, 110);
        return INVALID_SOCKET;
    }

    SOCKADDR_IN local_sin;
    local_sin.sin_family = AF_INET;
    local_sin.sin_port = htons(DWORD_TO_WORD(dwPortID));
    
    if (IsLocalSystemCluster())
    {
        //
        // BUGBUG:
        //
        // On cluster we can not use INADDR_ANY because we will bind to 
        // all addresses on the machine, including addresses in cluster
        // groups that are currently hosted on this machine.
        // We need to iterate the IP addresses and explicitly bind to each.
        // This way we are cluster-safe and do not need to know if we're on
        // cluster or not (thus our service would not depend on cluster service).
        // That means listenning on a different socket for each IP address. 
        // This is too risky / complex at this point, so on cluster we bind 
        // only to one IP address.  (ShaiK, 26-Apr-1999)
        //
        char szBuff[1000];
        DWORD dwSize = sizeof(szBuff);

        size_t res = wcstombs(szBuff, g_szMachineName, dwSize);
		DBG_USED(res);
        ASSERT(res != (size_t)(-1));

        PHOSTENT phe;
        phe = gethostbyname(szBuff);
        ASSERT(("must have an IP address", NULL != phe));
        
        memcpy(&local_sin.sin_addr.s_addr, phe->h_addr_list[0], IP_ADDRESS_LEN);
    }
    else
    {
        local_sin.sin_addr.s_addr = INADDR_ANY;
    }

    //
    //  Bind to IP address
    //
    rc = bind(sock, (sockaddr*)&local_sin, sizeof(local_sin));
    if (rc != 0)
    {
        DWORD gle = WSAGetLastError();
        DBGMSG((DBGMOD_ALL, DBGLVL_ERROR, TEXT("failed bind rc = %d for IP ping socket"), gle));
        LogHR(gle, s_FN, 130);
        return INVALID_SOCKET;
    }

    return sock;
}



HRESULT CPing::Init(DWORD dwPort)
{
    m_socket  = CreateIPPingSocket(dwPort);
    if(m_socket == INVALID_SOCKET)
    {
        LogHR(WSAGetLastError(), s_FN, 10);
        return MQ_ERROR;
    }

    DWORD dwThreadID;
    HANDLE hThread = CreateThread(
                        0,
                        0,
                        WorkingThread,
                        this,
                        0,
                        &dwThreadID
                        );
    if(hThread == NULL)
    {
        LogNTStatus(GetLastError(), s_FN, 20);
        return MQ_ERROR;
    }

    CloseHandle(hThread);
    return MQ_OK;
}


SOCKET CPing::Select()
{
    fd_set sockset;
    FD_ZERO(&sockset);
    FD_SET(m_socket, &sockset);

    int rc;
    rc = select(0, &sockset, NULL, NULL, NULL);
    if(rc == SOCKET_ERROR)
    {
        ASSERT(m_socket != INVALID_SOCKET) ;
        DBGMSG((DBGMOD_ALL, DBGLVL_ERROR, TEXT("Ping Server listen: select failed rc = %d"), WSAGetLastError())) ;
        return INVALID_SOCKET;
    }

    ASSERT(FD_ISSET(m_socket, &sockset)) ;
    return m_socket;
}


HRESULT CPing::Receive(SOCKET sock,
                       SOCKADDR* pReceivedFrom,
                       CPingPacket* pPkt)
{
    int fromlen = sizeof(SOCKADDR);

    int len = recvfrom(sock, (char*)pPkt, sizeof(CPingPacket), 0, pReceivedFrom, &fromlen);

    if((len != sizeof(CPingPacket)) || !pPkt->IsValidSignature())
    {
        DBGMSG((DBGMOD_ALL, DBGLVL_ERROR, TEXT("CPing::Receive failed, rc=%d, len=%d"), WSAGetLastError(), len));
        return LogHR(MQ_ERROR, s_FN, 30);
    }
    DBGMSG((DBGMOD_ROUTING, DBGLVL_INFO, TEXT("CPing::Receive succeeded")));


    return MQ_OK;
}


HRESULT CPing::Send(SOCKET sock,
                    const SOCKADDR* pSendTo,
                    DWORD dwCookie,
                    BOOL  fRefuse)
{
    CPingPacket Pkt( dwCookie,
                     !OS_SERVER(g_dwOperatingSystem),
                     DWORD_TO_WORD(fRefuse),
                     *(CQueueMgr::GetQMGuid())) ;


    int len = sendto(sock, (char*)&Pkt, sizeof(Pkt), 0, pSendTo, sizeof(SOCKADDR));
    if(len != sizeof(Pkt))
    {
        DWORD gle = WSAGetLastError();
        DBGMSG((DBGMOD_ALL,DBGLVL_ERROR,TEXT("CPing::Send failed, rc=%d"), gle));
        LogNTStatus(gle, s_FN, 41);
        return MQ_ERROR;
    }

    return MQ_OK;
}


//
// ISSUE-2000/7/24-erezh bad compiler pragma
// This is a bug in the compiler, waiting for a fix
//
#pragma warning(disable: 4716)

DWORD WINAPI CPing::WorkingThread(PVOID pThis)
{
    for(;;)
    {
        static_cast<CPing*>(pThis)->Run();
    }
}

//
// ISSUE-2000/7/24-erezh bad compiler pragma
// This is a bug in the compiler, waiting for a fix
//
#pragma warning(default: 4716)


//---------------------------------------------------------
//
//  class CPingClient
//
//---------------------------------------------------------

class CPingClient : public CPing
{
    public:
        HRESULT Init(DWORD dwServerPort);
        BOOL Ping(const SOCKADDR* pAddr, DWORD dwTimeout);

    private:
        virtual void Run();
        void Notify(DWORD dwCookie,
                    BOOL fRefuse,
                    BOOL fOtherSideClient,
                    GUID *pOtherGuid);
        void SetPingAddress(IN const SOCKADDR* pAddr,
                            OUT SOCKADDR * pPingAddr);

    private:
        CCriticalSection m_cs;
        HANDLE m_hNotification;
        BOOL m_fPingSucc;
        DWORD m_dwCurrentCookie;
        UINT m_server_port;
};

//
//

//---------------------------------------------------------
//
//  CPingClient IMPLEMENTATION
//
//---------------------------------------------------------
HRESULT CPingClient::Init(DWORD dwServerPort)
{
    m_server_port = dwServerPort;
    m_fPingSucc = FALSE;
    m_dwCurrentCookie = 0;
    m_hNotification = ::CreateEvent(0, FALSE, FALSE, 0);
    ASSERT(m_hNotification != 0);
    HRESULT hr = CPing::Init(0);
    return LogHR(hr, s_FN, 40);
}

void CPingClient::SetPingAddress(IN const SOCKADDR* pAddr,
                                 OUT SOCKADDR * pPingAddr)
{
    memcpy(pPingAddr, pAddr, sizeof(SOCKADDR));
    ASSERT(pAddr->sa_family == AF_INET);
    ((SOCKADDR_IN*)pPingAddr)->sin_port = htons(DWORD_TO_WORD(m_server_port));
}


BOOL CPingClient::Ping(const SOCKADDR* pAddr, DWORD dwTimeout)
{
    {
        CS lock(m_cs);
        m_fPingSucc = FALSE;
        ResetEvent(m_hNotification);
        SOCKADDR ping_addr;
        SetPingAddress(pAddr,&ping_addr);
        m_dwCurrentCookie++;
        Send(m_socket, &ping_addr, m_dwCurrentCookie, FALSE);
    }

    if(WaitForSingleObject(m_hNotification, dwTimeout) != WAIT_OBJECT_0)
    {
        return FALSE;
    }

    return m_fPingSucc;
}


void CPingClient::Notify(DWORD dwCookie,
                         BOOL  fRefuse,
                         BOOL  fOtherSideClient,
                         GUID  *pOtherGuid)
{
    CS lock(m_cs);

    if(dwCookie == m_dwCurrentCookie)
    {
        if (fRefuse)
        {
            m_fPingSucc = !fRefuse;
        }
        else
        {
            m_fPingSucc = g_QMLicense.NewConnectionAllowed(fOtherSideClient,
                                                           pOtherGuid);
        }

#ifdef _DEBUG
        if (!m_fPingSucc)
        {
            DBGMSG((DBGMOD_NETSESSION,
                    DBGLVL_WARNING,
                    _T("::PING, Client Get refuse to create a new session ")));
        }
#endif

        SetEvent(m_hNotification);
    }
}

void CPingClient::Run()
{
    SOCKET sock = Select();
    if(sock == INVALID_SOCKET)
    {
        return;
    }

    SOCKADDR addr;
    HRESULT rc;
    CPingPacket PingPkt;
    rc = Receive(sock, &addr, &PingPkt);
    if(FAILED(rc))
    {
        return;
    }

    Notify( PingPkt.Cookie(),
            PingPkt.IsRefuse(),
            PingPkt.IsOtherSideClient(),
            PingPkt.pOtherGuid());
}


//---------------------------------------------------------
//
//  class CPingServer
//
//---------------------------------------------------------

class CPingServer : public CPing
{
    private:
        virtual void Run();
};

//---------------------------------------------------------
//
//  CPingServer IMPLEMENTATION
//
//---------------------------------------------------------
void CPingServer::Run()
{
    SOCKET sock = Select();
    if(sock == INVALID_SOCKET)
    {
        return;
    }

    SOCKADDR addr;
    HRESULT rc;
    CPingPacket PingPkt;

    rc = Receive(sock, &addr, &PingPkt);
    if(FAILED(rc))
    {
        return;
    }

    BOOL fRefuse = ! g_QMLicense.NewConnectionAllowed(
                                          PingPkt.IsOtherSideClient(),
                                          PingPkt.pOtherGuid());
    if (fRefuse)
    {
        DBGMSG((DBGMOD_NETSESSION,
                DBGLVL_WARNING,
                _T("::PING, Server side refuse to create a new session")));
    }
    Send(sock, &addr, PingPkt.Cookie(), fRefuse);
}


//---------------------------------------------------------
//
//  Interface Functions
//
//---------------------------------------------------------

CPingServer s_PingServer_IP ;
CPingClient s_PingClient_IP ;

//---------------------------------------------------------
//
//  ping(...)
//
//---------------------------------------------------------

BOOL ping(const SOCKADDR* pAddr, DWORD dwTimeout)
{
    ASSERT(pAddr->sa_family == AF_INET);
    return s_PingClient_IP.Ping(pAddr, dwTimeout);
}

//---------------------------------------------------------
//
//  StartPingClient(...)
//
//---------------------------------------------------------

HRESULT StartPingClient()
{
    //
    // read IP port from registry.
    //
    DWORD dwIPPort ;

    DWORD dwDef = FALCON_DEFAULT_PING_IP_PORT ;
    READ_REG_DWORD(dwIPPort,
                   FALCON_PING_IP_PORT_REGNAME,
                   &dwDef ) ;

    s_PingClient_IP.Init(dwIPPort);

    return MQ_OK ;
}

//---------------------------------------------------------
//
//  StartPingServer(...)
//
//---------------------------------------------------------

HRESULT StartPingServer()
{
    //
    // read IP port from registry.
    //
    DWORD dwIPPort ;

    DWORD dwDef = FALCON_DEFAULT_PING_IP_PORT ;
    READ_REG_DWORD(dwIPPort,
                   FALCON_PING_IP_PORT_REGNAME,
                   &dwDef ) ;

    s_PingServer_IP.Init(dwIPPort) ;

    return MQ_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\pktlist.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    recovery.cpp

Abstract:

    Packet & Transaction Recovery

Author:

    Erez Haba (erezh) 3-Jul-96

Revision History:

--*/


#ifndef __PKTLIST_H
#define __PKTLIST_H

template <class T>
inline T* value_type(const T*) { return (T*)(0); }

template <class T>
inline ptrdiff_t* distance_type(const T*) { return (ptrdiff_t*)(0); }

#include "heap.h"

//---------------------------------------------------------
//
//  class CPacketList
//
//---------------------------------------------------------

class CPacketList {

    class CNode;

    enum { xInitialSize = 1024 };

public:
    CPacketList();
   ~CPacketList();

    BOOL isempty() const;
    void pop();
    CPacket* first() const;
    void insert(ULONGLONG key, CPacket* pDriverPacket);

private:
    void realloc_buffer();

private:
    CNode* m_pElements;
    int m_limit;
    int m_used;

};

class CPacketList::CNode {
public:
    CNode() {}
    CNode(ULONGLONG key, CPacket* pDriverPacket) :
        m_key(key), m_pDriverPacket(pDriverPacket) {}


    int operator < (const CNode& a)
    {
        return (m_key > a.m_key);
    }
    
public:
    ULONGLONG m_key;
    CPacket* m_pDriverPacket;

};


CPacketList::CPacketList() :
    m_pElements(new CNode[xInitialSize]),
    m_limit(xInitialSize),
    m_used(0)
{
}

CPacketList::~CPacketList()
{
    delete[] m_pElements;
}

BOOL CPacketList::isempty() const
{
    return (m_used == 0);
}

void CPacketList::pop()
{
    ASSERT(isempty() == FALSE);
    pop_heap(m_pElements, m_pElements + m_used);
    --m_used;
}

CPacket* CPacketList::first() const
{
    ASSERT(isempty() == FALSE);
    return m_pElements->m_pDriverPacket;
}

void CPacketList::insert(ULONGLONG key, CPacket* pDriverPacket)
{
    if(m_used == m_limit)
    {
        realloc_buffer();
    }

    m_pElements[m_used] = CNode(key, pDriverPacket);
    ++m_used;
    push_heap(m_pElements, m_pElements + m_used);
}


void CPacketList::realloc_buffer()
{
    ASSERT(m_limit != 0);
    CNode* pElements = new CNode[m_limit * 2];

    //
    //  NOTE: we do a bitwise copy this might not be good for all purpos
    //        and might be replace with a copy loop
    //
    memcpy(pElements, m_pElements, m_used * sizeof(CNode));

    m_limit *= 2;
    delete[] m_pElements;
    m_pElements = pElements;
}

#endif // __PKTLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\proxy.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    proxy.h

Abstract:
    Proxy transport definition

Author:
    urih

--*/
#ifndef __PROXY_H__
#define __PROXY_H__

#include "session.h"

void
GetConnectorQueue(
	CQmPacket& pPkt,
    QUEUE_FORMAT& ConnectorFormatName
	);

class CProxyTransport : public CTransportBase
{
    public:

        CProxyTransport();
        ~CProxyTransport();

        HRESULT CreateConnection(IN const TA_ADDRESS *pAddr,
                                 IN const GUID* pguidQMId,
                                 IN BOOL fQuick = TRUE
                                 );
        void CloseConnection(LPCWSTR, bool fClosedOnError);
        void HandleAckPacket(CSessionSection * pcSessionSection);

        void Receive(CBaseHeader* pBaseHeader,
                     CPacket* pDriverPacket);
        HRESULT Send(IN CQmPacket* pPkt, 
                     OUT BOOL* pfGetNext);

        void SetStoredAck(IN DWORD_PTR wStoredAckNo);
    
        void Disconnect(void);

    private:
		HRESULT CopyPacket(
			       IN  CQmPacket* pPkt,
                   OUT CBaseHeader**  ppPacket,
                   OUT CPacket**    pDriverPacket
				   );


        CQueue* m_pQueue;
        CQueue* m_pQueueXact;

		GUID m_guidConnector;

};


#endif //__PROXY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\proxy.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    proxy.cpp

Abstract:

    Implementation of local transport class, used for passing
    messages to the connector queue

Author:

    Uri Habusha (urih)
--*/


#include "stdh.h"
#include "cqmgr.h"
#include "qmthrd.h"
#include "proxy.h"
#include "xact.h"
#include "xactrm.h"
#include "xactout.h"
#include "xactin.h"

#include "proxy.tmh"

extern CQueueMgr QueueMgr;
extern HANDLE g_hAc;

static WCHAR *s_FN=L"proxy";

void
GetConnectorQueue(
	CQmPacket& pPkt,
    QUEUE_FORMAT& fn
	)
{
    PVOID p = pPkt.GetPointerToPacket();

	CPacketInfo* ppi = reinterpret_cast<CPacketInfo*>(p) - 1;
	ASSERT(ppi->InConnectorQueue());
	DBG_USED(ppi);

	
	//
	//Retreive the connector Guid. We save it at the end of the message
	//
	const GUID* pgConnectorQueue = (GUID*)(pPkt.GetPointerToPacket() + ALIGNUP4_ULONG(pPkt.GetSize()));
    try
    {
    	fn.ConnectorID(*pgConnectorQueue);
    }
    catch(...)
    {
        //
        // MSMQ1 connector packet not compatibale with the QFE. 
        // This is the last packet in memory mapped file that doesn't include the 
        // connector queue guid.
        //
        fn.ConnectorID(GUID_NULL);
        LogIllegalPoint(s_FN, 61);
    }
	if (pPkt.IsOrdered())
	{
		//
		// Get transacted connector queue
        //
        fn.Suffix(QUEUE_SUFFIX_TYPE_XACTONLY);
    }
}


HRESULT 
CProxyTransport::CopyPacket(
	IN  CQmPacket* pPkt,
    OUT CBaseHeader**    ppPacket,
    OUT CPacket**    ppDriverPacket
	)
{
    enum ACPoolType acPoolType;
    HRESULT hr=MQ_OK;

    if (pPkt->IsRecoverable())
    {
        acPoolType = ptPersistent;
    }
    else
    {
        acPoolType = ptReliable;
    }

	DWORD dwSize = 	ALIGNUP4_ULONG(ALIGNUP4_ULONG(pPkt->GetSize()) + sizeof(GUID));
    CACPacketPtrs packetPtrs = {NULL, NULL};
    hr = ACAllocatePacket(g_hAc,
                          acPoolType,
                          dwSize,
                          packetPtrs
                         );

    if (SUCCEEDED(hr))
    {
        memcpy(packetPtrs.pPacket, pPkt->GetPointerToPacket(), pPkt->GetSize());

		//
		// Copy the connector GUID for recovery porpose
		//
		GUID* pCNId = reinterpret_cast<GUID*>((PUCHAR)packetPtrs.pPacket + ALIGNUP4_ULONG(pPkt->GetSize()));
		*pCNId = m_guidConnector;
    }

	*ppPacket = packetPtrs.pPacket;
    *ppDriverPacket = packetPtrs.pDriverPacket;
    return LogHR(hr, s_FN, 10);
}
//
// constructor
//
CProxyTransport::CProxyTransport()
{
    m_pQueue = NULL;
    m_pQueueXact = NULL;
}

//
// destructor
//
CProxyTransport::~CProxyTransport()
{
    //
    // Decrement reference count on connector queue objects.
    //
    if (m_pQueue)
    {
        m_pQueue->Release();
        m_pQueue = NULL;
    }

    if (m_pQueueXact)
    {
        m_pQueueXact->Release();
        m_pQueueXact = NULL;
    }
}

//
// CProxyTransport::CreateConnection
//
HRESULT 
CProxyTransport::CreateConnection(
    IN const TA_ADDRESS *pAddr,
    IN const GUID* pguidQMId,
    IN BOOL  /* fQuick = TRUE */
    )
{
    ASSERT(pAddr->AddressType == FOREIGN_ADDRESS_TYPE);

    //
    // Get Forien CN Name
    //
    QUEUE_FORMAT qFormat;
    HRESULT rc;

    //
    // Get Not transacted connector queue
    //
	m_guidConnector = *(GUID*)pAddr->Address;	
    qFormat.ConnectorID(m_guidConnector);
    rc = QueueMgr.GetQueueObject(&qFormat, &m_pQueue, 0, false);
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 20);
    }

    //
    // Get transacted connector queue
    //
    qFormat.Suffix(QUEUE_SUFFIX_TYPE_XACTONLY);
    rc = QueueMgr.GetQueueObject(&qFormat, &m_pQueueXact, 0, false);
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 30);
    }



    // set session status to connect
    SetSessionStatus(ssActive);

    //Keep the TA_ADDRESS format
    SetSessionAddress(pAddr);

    // store that this is the client side
    SetClientConnect(TRUE);

    // keep the destination QM ID
    SetQMId(&GUID_NULL);

    DBGMSG((DBGMOD_NETSESSION,
            DBGLVL_TRACE,
            TEXT("Proxy Session created with %ls"), GetStrAddr()));

    return MQ_OK;
}


/*====================================================

CProxyTransport::CloseConnection

Arguments:

Return Value:

Thread Context:

=====================================================*/
void CProxyTransport::CloseConnection(
                                   LPCWSTR lpcwsDbgMsg,
								   bool	
                                   )
{
    CS lock(m_cs);

    //
    // Delete the group. move all the queues that associated
    // to this session to non-active group.
    //
    CQGroup* pGroup = GetGroup();
    if (pGroup != NULL)
    {
        HRESULT rc = pGroup->CloseGroup();

        REPORT_ILLEGAL_STATUS(rc, L"CloseConnection");

        pGroup->Release();
        SetGroup(NULL);
    }

    //
    // set session status to not connect
    //
    SetSessionStatus(ssNotConnect);
   
    DBGMSG((DBGMOD_NETSESSION,
            DBGLVL_WARNING,
            _TEXT("Close Connection with %ls. %ls"), GetStrAddr(), lpcwsDbgMsg));

}



/*====================================================

CProxyTransport::Send

Arguments: this function should not be called for proxy session

Return Value:

Thread Context:

=====================================================*/
HRESULT  
CProxyTransport::Send(IN  CQmPacket* pPkt, 
                      OUT BOOL* pfGetNext)
{
    if (IsDisconnected())
    {
        DBGMSG((DBGMOD_NETSESSION,
                DBGLVL_TRACE,
                _T("Session %ls is disconnected. Reque the packet and don't send any more message on this session"),
                                   GetStrAddr()));

        //
        // The session is disconnected. return the packet to the driver 
        // and don't get a new packet for sending on this session. All 
        // the queues move latter to nonactive group and rerouted using
        // a new session.
        //
        RequeuePacket(pPkt);
        delete pPkt;
        *pfGetNext = FALSE;

        return MQ_OK;
    }

    #ifdef _DEBUG
    {
        OBJECTID MessageId;
        pPkt->GetMessageId(&MessageId);

        DBGMSG((
            DBGMOD_NETSESSION,
            DBGLVL_TRACE,
            _T("Send packet to Connector queue. Packet ID = ") _T(LOG_GUID_FMT) _T("\\%u"),
            LOG_GUID(&MessageId.Lineage),
            MessageId.Uniquifier
            ));

    }
    #endif

    HRESULT hr = MQ_OK;

    *pfGetNext = TRUE;
    P<CQmPacket> PktPtrs = NULL;
    CBaseHeader* pbuf;
    CPacket* pDriverPacket;

    //
    // Mark the proxy session as used, such it will not clean up in release session.
    //
    SetUsedFlag(TRUE);

    if (pPkt->IsOrdered())
    {
        CPacketInfo* pInfo = reinterpret_cast<CPacketInfo*>(pPkt->GetPointerToPacket()) - 1;

		ASSERT(!pInfo->InConnectorQueue());
		DBG_USED(pInfo);
        //
        // Exactly-Once:  freshly received ordered message processing
        //

		ASSERT(g_pInSeqHash != NULL);

        //
        // Check if the packet should be accepted or ignored
        //
        if (g_pInSeqHash->Verify(pPkt))
        {
            //
            // Copy the packet
            //
            hr = CopyPacket(pPkt,&pbuf, &pDriverPacket);
            if (SUCCEEDED(hr))
            {
                PktPtrs = new CQmPacket(pbuf, pDriverPacket);
                CACPacketPtrs * pOldPktPtrs = new CACPacketPtrs(); 
                P<CACPacketPtrs> CleanOldPktPtrs = pOldPktPtrs;
                pOldPktPtrs->pPacket = pPkt->GetPointerToPacket();
                pOldPktPtrs->pDriverPacket = pPkt->GetPointerToDriverPacket();
     
                DBGMSG((DBGMOD_XACT_SEND,
                        DBGLVL_TRACE,
                        _TEXT("Exactly1 send: Send Transacted packet to Connector queue.: SeqID=%I64d, SeqN=%d, Prev=%d"),
                        pPkt->GetSeqID(),
                        pPkt->GetSeqN(),
                        pPkt->GetPrevSeqN()));

                //
                // Save the pointer to old packet, so when the storage of the new packet
                // completes, MSMQ release the old one. 
                // Increment the reference count to insure that no one delete the session
                // object before the storage of the packet is completed
                //
                AddRef();

                PktPtrs->SetStoreAcknowldgeNo((DWORD_PTR) pOldPktPtrs);

                //
                // Accepted. Mark as received (to be invisible to readers 
                // yet) and store in the queue.
                //
                hr = m_pQueueXact->PutOrderedPkt(PktPtrs, FALSE, this);
                if (FAILED(hr))
                {
                    Release();
                    ACFreePacket(g_hAc, PktPtrs->GetPointerToDriverPacket());
                    Close_Connection(this, L"Allocation Failure in receive packet procedure");
                }
                else
                {
                    CleanOldPktPtrs.detach();
                }
                
            }
        }
        else
        {
            //
            // Packet has a wrong seq number. Seq Ack will be sent back with last good number.
            //
            hr = MQ_OK;
            //
            // Clean
            //
            ACFreePacket(g_hAc, pPkt->GetPointerToDriverPacket());
        }

        if (FAILED(hr))
        {
            //
            // We could not copy the packet and the Connector QM is the send machine.
            // Return the message to the queue. We will retry later
            //
            RequeuePacket(pPkt);
        }
    }
    else
    {
        //
        // Non Transaction message
        hr = CopyPacket(pPkt,&pbuf, &pDriverPacket);
        if (SUCCEEDED(hr))
        {
            PktPtrs = new CQmPacket(pbuf, pDriverPacket);
            CACPacketPtrs * pOldPktPtrs = new CACPacketPtrs(); 
            P<CACPacketPtrs> CleanldPktPtrs = pOldPktPtrs;
            pOldPktPtrs->pPacket = pPkt->GetPointerToPacket();
            pOldPktPtrs->pDriverPacket = pPkt->GetPointerToDriverPacket();

            //
            // Save the pointer to old packet, so when the storage of the new packet
            // completes, MSMQ release the old one. 
            // Increment the reference count to insure that no one delete the session
            // object before the storage of the packet is completed
            //
            AddRef();
            PktPtrs->SetStoreAcknowldgeNo((DWORD_PTR) pOldPktPtrs);
            hr = m_pQueue->PutPkt(PktPtrs, FALSE, this);

            if (SUCCEEDED(hr))
            {
                CleanldPktPtrs.detach();
            }
        }
        if (FAILED(hr))
        {
            Release();
            ACFreePacket(g_hAc, PktPtrs->GetPointerToDriverPacket());
            Close_Connection(this, L"Allocation Failure in receive packet procedure");
            RequeuePacket(pPkt);
        } 
    }

    //
    // The orignal packet will be removed when the ACPutPacket is completed. We do it
    // to avoid the case that persistence message is deleted before writing on the
    // disk completed.
    //
    delete pPkt;

    return LogHR(hr, s_FN, 40);
}

/*====================================================

CProxyTransport::HandleAckPacket

Arguments: this function should not be called for proxy session

Return Value:

Thread Context:

=====================================================*/
void 
CProxyTransport::HandleAckPacket(CSessionSection * pcSessionSection)
{
    ASSERT(0);
}


/*====================================================

CProxyTransport::Receive

Arguments: this function should not be called for proxy session

Return Value:

Thread Context:

=====================================================*/
void CProxyTransport::Receive(CBaseHeader* pBaseHeader,
                              CPacket* pDriverPacket)
{
    ASSERT(0);
    return;
}

/*====================================================

CProxyTransport::SetStoredAck

Arguments: this function should not be called for proxy session

Return Value:

Thread Context:

=====================================================*/
void 
CProxyTransport::SetStoredAck(IN DWORD_PTR dwStoredAckNo)
{
    P<CACPacketPtrs> pPacketPtrs = (CACPacketPtrs*)dwStoredAckNo;
    P<CQmPacket> pPkt = new CQmPacket(pPacketPtrs->pPacket, pPacketPtrs->pDriverPacket);

    CPacketInfo* pInfo = reinterpret_cast<CPacketInfo*>(pPkt->GetPointerToPacket()) - 1;

    //
    // free the original packet. If the packet is transacted packet and we are 
    // in the source machine we can't free the packet until readReceipt Ack is arrived.
    //
	ASSERT(!pInfo->InConnectorQueue());
	DBG_USED(pInfo);
    if (pPkt->IsOrdered() && QmpIsLocalMachine(pPkt->GetSrcQMGuid()))
    {
        //
        // Ordered packet on the sender node: resides in a separate list in COutSeq
        //
        g_OutSeqHash.PostSendProcess(pPkt.detach());
    }
    else
    {
        ACFreePacket(g_hAc, pPkt->GetPointerToDriverPacket());
    }

    Release();
}

/*====================================================

CProxyTransport::Disconnect

Arguments:

Return Value:

Thread Context:

=====================================================*/
void 
CProxyTransport::Disconnect(
    void
    )
{
    CS lock(m_cs);

    SetDisconnected();
    if (GetSessionStatus() == ssActive)
    {
        DBGMSG((DBGMOD_NETSESSION, DBGLVL_TRACE, L"Disconnect ssesion with %ls", GetStrAddr()));

        Close_Connection(this, L"Disconnect network");        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qm2qm_c_.c ===
#pragma warning(push, 3)
#include <qm2qm_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qm2qm_s_.c ===
#pragma warning(push, 3)
#include <qm2qm_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\pubcache.cpp ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:
    pubcache.cpp

Abstract:
    Update cache of local public key.
    Done on client machines only, to enable off-line (no DS) operation.

Author:
    Doron Juster  (DoronJ)

History:
   25-sep-1996   DoronJ       Created

--*/

#include "stdh.h"
#include "cqmgr.h"
#include "_rstrct.h"
#include "regqueue.h"
#include "lqs.h"
#include "ad.h"

#include "pubcache.tmh"

extern CQueueMgr   QueueMgr;

#define MAX_NO_OF_PROPS 40
#define RETRY_INTERVAL_WHEN_OFFLINE  (60 * 1000)

static WCHAR *s_FN=L"pubcache";

//***************************************************************
//
//
//***************************************************************

void  
WINAPI
TimeToPublicCacheUpdate(
    CTimer* pTimer
    )
{
	HRESULT hr = UpdateAllPublicQueuesInCache();

	if(hr == MQ_ERROR_NO_DS)
	{
        ExSetTimer(pTimer, CTimeDuration::FromMilliSeconds(RETRY_INTERVAL_WHEN_OFFLINE));
	}
}

HRESULT UpdateAllPublicQueuesInCache()
/*++
Routine Description:
	Attempts to update public queues in LQS and Queue manager against DS.
	if DS is not available reschedules itself and returns MQ_ERROR_NO_DS.

Arguments:

Return Value:
	returns MQ_ERROR_NO_DS if and only if it reschedulled itself because 
	DS was unavailable.

--*/
{
    if(!QueueMgr.CanAccessDS())
        return LogHR(MQ_ERROR_NO_DS, s_FN, 20);

   //
   // Enumerate local public queues in DS.
   //
   HRESULT        hr = MQ_OK;
   HANDLE         hQuery = NULL ;
   DWORD          dwProps = MAX_NO_OF_PROPS;
   PROPID         propids[ MAX_NO_OF_PROPS ];
   PROPVARIANT    result[ MAX_NO_OF_PROPS ];
   PROPVARIANT*   pvar;
   CColumns       Colset;
   DWORD nCol;

   const GUID* pMyQMGuid =  QueueMgr.GetQMGuid() ;

   //
   //  set Column Set values
   //
   nCol = 0 ;
   propids[ nCol ] = PROPID_Q_INSTANCE ;
   Colset.Add( PROPID_Q_INSTANCE ) ;

   nCol++ ;
   propids[ nCol ] = PROPID_Q_JOURNAL ;
   Colset.Add( PROPID_Q_JOURNAL ) ;

   nCol++ ;
   propids[ nCol ] = PROPID_Q_LABEL ;
   Colset.Add( PROPID_Q_LABEL ) ;

   nCol++ ;
   propids[ nCol ] = PROPID_Q_TYPE ;
   Colset.Add( PROPID_Q_TYPE ) ;

   nCol++ ;
   propids[ nCol ] = PROPID_Q_QUOTA ;
   Colset.Add( PROPID_Q_QUOTA ) ;

   nCol++ ;
   propids[ nCol ] = PROPID_Q_JOURNAL_QUOTA ;
   Colset.Add( PROPID_Q_JOURNAL_QUOTA ) ;

   nCol++ ;
   propids[ nCol ] = PROPID_Q_PATHNAME ;
   Colset.Add( PROPID_Q_PATHNAME ) ;
   DWORD nColPathName = nCol ;

   nCol++ ;
   propids[ nCol ] = PROPID_Q_BASEPRIORITY ;
   Colset.Add( PROPID_Q_BASEPRIORITY ) ;

   nCol++ ;
   propids[ nCol ] = PROPID_Q_TRANSACTION ;
   Colset.Add( PROPID_Q_TRANSACTION ) ;

   nCol++ ;
   propids[ nCol ] = PROPID_Q_AUTHENTICATE ;
   Colset.Add( PROPID_Q_AUTHENTICATE ) ;

   nCol++ ;
   propids[ nCol ] = PROPID_Q_PRIV_LEVEL ;
   Colset.Add( PROPID_Q_PRIV_LEVEL ) ;

   nCol++ ;
   propids[ nCol ] = PROPID_Q_MULTICAST_ADDRESS ;
   Colset.Add( PROPID_Q_MULTICAST_ADDRESS ) ;

   nCol++ ;
   ASSERT(nCol <=  MAX_NO_OF_PROPS) ;

   time_t regtime ;
   time(&regtime) ;

   hr = ADQueryMachineQueues(
                NULL,       // pwcsDomainController
				false,		// fServerName
                pMyQMGuid,
                Colset.CastToStruct(),
                &hQuery
                );

   if (SUCCEEDED(hr))
   {
      ASSERT(hQuery) ;

      while ( SUCCEEDED( hr = ADQueryResults( hQuery, &dwProps, result)))
      {
          if (!dwProps)
          {
             //
             //  No more results to retrieve
             //
             break;
          }

          //
          //  For each queue get its properties.
          //
          pvar = result;
          for ( int i = (dwProps / nCol) ; i > 0 ; i-- )
          {
			 UpdateCachedQueueProp(  
				pvar->puuid,
				nCol,
				propids,
				pvar,
				regtime
				);             
			 
			 delete pvar->puuid ;
             PROPVARIANT*  ptmpvar = pvar + nColPathName ;
             delete ptmpvar->pwszVal ;
             pvar = pvar + nCol ;
          }
      }
      //
      // close the query handle
      //
      ADEndQuery( hQuery);
   }

   if (FAILED(hr))
	  return LogHR(hr, s_FN, 10);

   //
   // Now cleanup old registry entries, to prevent garbage accumulation.
   //
   GUID guid;
   HLQS hLQSEnum;

   HRESULT hrEnum = LQSGetFirst(&hLQSEnum, &guid);

   while (SUCCEEDED(hrEnum))
   {
        DeleteCachedQueueOnTimeStamp(&guid, regtime) ;
        hrEnum = LQSGetNext(hLQSEnum, &guid);
        //
        // No need to close the enumeration handle in case LQSGetNext fails
        //
   }

   DBGMSG((DBGMOD_QM, DBGLVL_TRACE,
                   _TEXT("TimeToPublicCacheUpdate successfully terminated"))) ;

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qalappnotify.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    QalappNotify.cpp

Abstract:
    Notification functions from Qal.lib

Author:
    Gil Shafriri(gilsh)

--*/

#include "stdh.h"
#include <ev.h>
#include <fn.h>
#include <mqexception.h>
#include <mqsymbls.h>

#include "QalAppNotify.tmh"

void AppNotifyQalDirectoryMonitoringWin32Error(LPCWSTR pMappingDir, DWORD err)throw()
/*++

Routine Description:
	Called when win32 error accured while monitoring queue alias directory change.
	Report the problem to the event log.

Arguments:
	 err - Win32 error that happened.   
	 pMappingDir - Mapping directory path.

Returned value:
	None

--*/
{
	WCHAR errstr[64];
	swprintf(errstr, L"%x", err);

	EvReport(QUEUE_ALIAS_DIR_MONITORING_WIN32_ERROR, 2, pMappingDir, errstr);
}


void AppNotifyQalDuplicateMappingError(LPCWSTR pAliasFormatName, LPCWSTR pFormatName) throw()
/*++

Routine Description:
	Called when alias mapped to a queue has another mapping to different queue.
	Report the problem to the event log.
	

Arguments:
	pAliasFormatName - Queue Alias.
	pFormatName - Queue Name.
  
Returned value:
	None

--*/
{

	EvReport(QUEUE_ALIAS_DUPLICATE_MAPPING_WARNING,	2,	pAliasFormatName, pFormatName);
}


void AppNotifyQalInvalidMappingFileError(LPCWSTR pMappingFileName) throw()
/*++

Routine Description:
	Called when mapping file was parsed by the xml parser but the mapping format is invalid.
	Report the problem to the event log.
		

Arguments:
	pMappingFileName - Mapping file name.
	
	  
Returned value:
	None

--*/
{
	EvReport(QUEUE_ALIAS_INVALID_MAPPING_FILE, 1, pMappingFileName );
}


void AppNotifyQalWin32FileError(LPCWSTR pFileName, DWORD err)throw()
/*++

Routine Description:
	Called when got win32 error when reading queue alias mapping file.
	Report the problem to the event log.

	

Arguments:
	pFileName - Name of the file that had the error.
	err - The error code.
  
Returned value:
	None

--*/
{
	WCHAR errstr[64];
	swprintf(errstr, L"%x", err);

	EvReport(QUEUE_ALIAS_WIN32_FILE_ERROR, 2, pFileName, errstr	);
	
}



bool AppNotifyQalMappingFound(LPWSTR pAliasFormatName, LPWSTR pFormatName)throw()
/*++

Routine Description:
	Called when new mapping from alias to queue found  by qal library. 


Arguments:
	pAliasFormatName - Alias name .
	pFormatName - The error code.
  
Returned value:
	true is return if the mapping is valid and should be inserted into the qal mapping in memory.
	false otherwise. 
	
Note:	  
	The function implementation converts the queue name to cononical
	url form. For example , Http://host\msmq\private$\q  converted to Http://host/msmq/private$/q 
--*/
{
	DBG_USED(pAliasFormatName);
	bool fSuccess = FnAbsoluteMsmqUrlCanonization(pFormatName);
	if(!fSuccess)
	{
		EvReport(QUEUE_ALIAS_INVALID_QUEUE_NAME, 2, pAliasFormatName,	pFormatName );
	}
	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qmds.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

  qmds.h

Abstract:

    Definition of DS function table.

Author:

    Lior Moshaiov (LiorM)


--*/

#ifndef __QMDS_H__
#define __QMDS_H__

//********************************************************************
//                           A P I
//********************************************************************


void MQDSClientInitializationCheck(void);

BOOL IsThisServerDomainController() ;

void APIENTRY QMLookForOnlineDS(void*, DWORD);

BOOL QMOneTimeInit(VOID);
void ScheduleOnlineInitialization();

#endif // __QMDS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qmglbobj.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    QMGlbObj.cpp

Abstract:

    Declaration of Global Instances of the QM.
    They are put in one place to ensure the order their constructors take place.

Author:

    Lior Moshaiov (LiorM)

--*/

#include "stdh.h"
#include "cqmgr.h"
#include "sessmgr.h"
#include "perf.h"
#include "perfdata.h"
#include "admin.h"
#include "qmnotify.h"

#include "qmglbobj.tmh"

static WCHAR *s_FN=L"qmglbobj";

CSessionMgr     SessionMgr;
CQueueMgr       QueueMgr;
CAdmin          Admin;
CNotify         g_NotificationHandler;


CContextMap g_map_QM_dwQMContext;  //dwQMContext of rpc_xxx routines
CContextMap g_map_QM_cli_pQMQueue; //cli_pQMQueue - returned by AC to RT (ACCreateCursor for remote), then passed to QM (QMGetRemoteQueueName)
CContextMap g_map_QM_srv_pQMQueue; //srv_pQMQueue of a remote queue
CContextMap g_map_QM_srv_hQueue;   //hQueue of a remote queue
CContextMap g_map_QM_dwpContext;   //dwpContext RPC context of RT (QMOpenRemoteQueue), passed to QM (QMOpenQueueInternal) for remote queue

#ifdef _WIN64
CContextMap g_map_QM_HLQS;         //HLQS handle for enumeration of private queues from admin, passed inside an MSMQ message as 32 bit value
#endif //_WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qmcommnd.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    qm.cpp

Abstract:

    This module implements QM commands that are issued by the RT using local RPC

Author:

    Lior Moshaiov (LiorM)

--*/

#include "stdh.h"

#include "ds.h"
#include "cqueue.h"
#include "cqmgr.h"
#include "_rstrct.h"
#include "cqpriv.h"
#include "qm2qm.h"
#include "qmrt.h"
#include "_mqini.h"
#include "_mqrpc.h"
#include "qmthrd.h"
#include "license.h"
#include "..\inc\version.h"
#include <mqsec.h>
#include "ad.h"
#include <fn.h>

#include "qmcommnd.tmh"

extern CQueueMgr    QueueMgr;


CCriticalSection qmcmd_cs;

static WCHAR *s_FN=L"qmcommnd";

extern CContextMap g_map_QM_dwQMContext;


/*==================================================================
    The routines below are called by RT using local RPC
    They use a critical section to synchronize
    that no more than one call to the QM will be served at a time.
====================================================================*/

/*====================================================

OpenQueueInternal

Arguments:

Return Value:

=====================================================*/
HRESULT
OpenQueueInternal(
    QUEUE_FORMAT*   pQueueFormat,
    DWORD           dwCallingProcessID,
    DWORD           dwDesiredAccess,
    DWORD           dwShareMode,
    DWORD           hRemoteQueue,
    LPWSTR*         lplpRemoteQueueName,
    IN DWORD        *dwpRemoteQueue, //IN value only - even though it is passed as a ptr to its value
    HANDLE			*phQueue,
    DWORD           dwpRemoteContext,
    OUT CQueue**    ppLocalQueue
    )
{
    ASSERT(pQueueFormat->GetType() != QUEUE_FORMAT_TYPE_DL);

    try
    {
        *phQueue = NULL;

        if (hRemoteQueue)
        {
            //
            // This is client side of remote read.
            // RT calls here after it get handle to queue from remote computer.
            //
            ASSERT(dwpRemoteQueue);
            ASSERT(pQueueFormat->GetType() != QUEUE_FORMAT_TYPE_CONNECTOR);
            CRRQueue *pQueue = NULL ;
            PCTX_RRSESSION_HANDLE_TYPE pRRContext = 0;
            HANDLE hQueue = NULL;
            HRESULT hr = QueueMgr.OpenRRQueue( pQueueFormat,
                                               dwCallingProcessID,
                                               dwDesiredAccess,
                                               dwShareMode,
                                               hRemoteQueue,
                                               *dwpRemoteQueue,
                                               dwpRemoteContext,
                                               &hQueue, /* phQueue, */
                                               &pQueue,
                                               &pRRContext) ;
            *phQueue = hQueue;
            if (pQueue)
            {
                ASSERT(FAILED(hr)) ;
                pQueue->RemoteCloseQueue(pRRContext) ;
                pQueue->Release() ; // BUGBUG may be a leak in the hash table
            }
            return LogHR(hr, s_FN, 10);
        }
        else
        {
            BOOL fRemoteReadServer = !(hRemoteQueue || lplpRemoteQueueName) ;
            HANDLE hQueue = NULL;
            HRESULT hr2 = QueueMgr.OpenQueue(
                                pQueueFormat,
                                dwCallingProcessID,
                                dwDesiredAccess,
                                dwShareMode,
                                ppLocalQueue,
                                lplpRemoteQueueName,
                                &hQueue,
                                fRemoteReadServer);
            *phQueue = hQueue;
            return LogHR(hr2, s_FN, 20);
        }
    }
    catch(const bad_alloc&)
    {
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 30);
    }
} // OpenQueueInternal


HRESULT
R_QMOpenQueue(
    handle_t        hBind,
	ULONG           nMqf,
    QUEUE_FORMAT    mqf[],
    DWORD           dwCallingProcessID,
    DWORD           dwDesiredAccess,
    DWORD           dwShareMode,
    DWORD           hRemoteQueue,
    LPWSTR*         lplpRemoteQueueName,
    DWORD           *dwpQueue,
    DWORD __RPC_FAR *phQueue,
    DWORD           dwpRemoteContext
    )
/*++

Routine Description:

    RPC server side of a local MQRT call.

Arguments:


Returned Value:

    Status.

--*/
{
    if(nMqf == 0)
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, _T("Bad MQF count. n=0")));
        return MQ_ERROR_INVALID_PARAMETER;
    }

    for(ULONG i = 0; i < nMqf; ++i)
    {
        if(!mqf[i].IsValid())
        {
            DBGMSG((DBGMOD_QM, DBGLVL_ERROR, _T("Bad MQF parameter. n=%d index=%d"), nMqf, i));
            return MQ_ERROR_INVALID_PARAMETER;
        }
    }

    if (nMqf > 1 || mqf[0].GetType() == QUEUE_FORMAT_TYPE_DL)
    {
        ASSERT(dwDesiredAccess == MQ_SEND_ACCESS);
        ASSERT(dwShareMode == 0);
        ASSERT(hRemoteQueue == 0);
        ASSERT(dwpRemoteContext == 0);

        HANDLE hQueue;
        HRESULT hr;
        try
        {
            hr = QueueMgr.OpenMqf(
                     nMqf,
                     mqf,
                     dwCallingProcessID,
                     &hQueue
                     );
        }
        catch(const bad_alloc&)
        {
            return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 300);
        }
        catch (const bad_hresult& failure)
        {
            return LogHR(failure.error(), s_FN, 302);
        }
        catch (const exception&)
        {
            ASSERT(("Need to know the real reason for failure here!", 0));
            return LogHR(MQ_ERROR_NO_DS, s_FN, 303);
        }

        ASSERT(phQueue != NULL);
        *phQueue = (DWORD) HANDLE_TO_DWORD(hQueue); // NT handles can be safely cast to 32 bits
        return LogHR(hr, s_FN, 304);
    }

	HANDLE hQueue = 0;
    HRESULT hr = OpenQueueInternal(
				  mqf,
				  dwCallingProcessID,
				  dwDesiredAccess,
				  dwShareMode,
				  hRemoteQueue,
				  lplpRemoteQueueName,
				  dwpQueue,
				  &hQueue,
				  dwpRemoteContext,
				  NULL /* ppLocalQueue */
				  );

	*phQueue = (DWORD) HANDLE_TO_DWORD(hQueue);
	
	return hr;
} // R_QMOpenQueue


/*====================================================

QMCreateObjectInternal

Arguments:

Return Value:

=====================================================*/
HRESULT QMCreateObjectInternal(
    handle_t                hBind,
    DWORD                   dwObjectType,
    LPCWSTR                 lpwcsPathName,
    DWORD                   SDSize,
    unsigned char __RPC_FAR *pSecurityDescriptor,
    DWORD                   cp,
    PROPID __RPC_FAR        aProp[  ],
    PROPVARIANT __RPC_FAR   apVar[  ]
    )
{
    if((SDSize != 0) && (pSecurityDescriptor == NULL))
    {
        TrERROR(GENERAL, "RPC (QMCreateObjectInternal) NULL SD");
        return MQ_ERROR_INVALID_PARAMETER;
    }

    HRESULT rc;
    CS lock(qmcmd_cs);

    DBGMSG((DBGMOD_QM,
            DBGLVL_TRACE,
            TEXT(" QMCreateObjectInternal. object path name : %ls"), lpwcsPathName));

    switch (dwObjectType)
    {
        case MQQM_QUEUE:
            rc = g_QPrivate.QMCreatePrivateQueue(lpwcsPathName,
                                                 SDSize,
                                                 pSecurityDescriptor,
                                                 cp,
                                                 aProp,
                                                 apVar,
                                                 TRUE
                                                );
            break ;

        case MQQM_QUEUE_LOCAL_PRIVATE:
        {
            unsigned int iTransport = 0 ;
            RPC_STATUS status = I_RpcBindingInqTransportType(
                                                  hBind,
                                                 &iTransport ) ;
            if ((status == RPC_S_OK) &&
                (iTransport == TRANSPORT_TYPE_LPC))
            {
                //
                // See CreateDSObject() below for explanations.
                // Same behavior for private queues.
                //
            }
            else
            {
                //
                // reject calls from remote machines.
                //
                LogRPCStatus(status, s_FN, 40);
                return MQ_ERROR_ACCESS_DENIED;
            }

            rc = g_QPrivate.QMCreatePrivateQueue(lpwcsPathName,
                                                 SDSize,
                                                 pSecurityDescriptor,
                                                 cp,
                                                 aProp,
                                                 apVar,
                                                 FALSE
                                                );
            break;
        }

        default:
            rc = MQ_ERROR;
            break;
    }

    return LogHR(rc, s_FN, 50);
}

/*====================================================

QMCreateDSObjectInternal

Description:
    Create a public queue in Active directory.

Arguments:

Return Value:

=====================================================*/

HRESULT QMCreateDSObjectInternal(
    handle_t                hBind,
    DWORD                   dwObjectType,
    LPCWSTR                 lpwcsPathName,
    DWORD                   SDSize,
    unsigned char __RPC_FAR *pSecurityDescriptor,
    DWORD                   cp,
    PROPID __RPC_FAR        aProp[  ],
    PROPVARIANT __RPC_FAR   apVar[  ],
    GUID                   *pObjGuid
    )
{
    if((SDSize != 0) && (pSecurityDescriptor == NULL))
    {
        TrERROR(GENERAL, "RPC (QMCreateDSObjectInternal) NULL SD");
        return MQ_ERROR_INVALID_PARAMETER;
    }

    unsigned int iTransport = 0 ;
    RPC_STATUS status = I_RpcBindingInqTransportType( hBind,
                                                     &iTransport ) ;
    if ((status == RPC_S_OK) && (iTransport == TRANSPORT_TYPE_LPC))
    {
        //
        // Local RPC. That's OK.
        // On Windows 2000, by default, the local msmq service is the one
        // that has the permission to create public queues on local machine.
        // And it does it only for local application, i.e., msmq application
        // running on local machine.
        //
    }
    else
    {
        //
        // reject calls from remote machines.
        //
        LogRPCStatus(status, s_FN, 60);
        return MQ_ERROR_ACCESS_DENIED;
    }

    HRESULT rc;

    DBGMSG((DBGMOD_QM, DBGLVL_TRACE,
            TEXT(" QMCreateDSObjectInternal. object path name : %ls"), lpwcsPathName));
    switch (dwObjectType)
    {
        case MQDS_LOCAL_PUBLIC_QUEUE:
        {
            //
            // This call goes to the MSMQ DS server without impersonation.
            // So create the default security descriptor here, in order
            // for the caller to have full control on the queue.
            // Note: the "owner" component in the DS object will be the
            // local computer account. so remove owner and group from the
            // security descriptor.
            //
            SECURITY_INFORMATION siToRemove = OWNER_SECURITY_INFORMATION |
                                              GROUP_SECURITY_INFORMATION ;
            P<BYTE> pDefQueueSD = NULL ;

            rc = MQSec_GetDefaultSecDescriptor( MQDS_QUEUE,
                                       (PSECURITY_DESCRIPTOR*) &pDefQueueSD,
                                                TRUE, //  fImpersonate
                                                pSecurityDescriptor,
                                                siToRemove,
                                                e_UseDefaultDacl ) ;
            if (FAILED(rc))
            {
                return LogHR(rc, s_FN, 70);
            }

            rc = ADCreateObject(
                        eQUEUE,
						NULL,       // pwcsDomainController
						false,	    // fServerName
                        lpwcsPathName,
                        pDefQueueSD,
                        cp,
                        aProp,
                        apVar,
                        pObjGuid
                        );
        }
            break;

        default:
            rc = MQ_ERROR;
            break;
    }

    return LogHR(rc, s_FN, 80);
}


static bool IsValidObjectFormat(const OBJECT_FORMAT* p)
{
    if(p == NULL)
        return false;

    if(p->ObjType != MQQM_QUEUE)
        return false;

    if(p->pQueueFormat == NULL)
        return false;

    return p->pQueueFormat->IsValid();
}


/*====================================================

QMSetObjectSecurityInternal

Arguments:

Return Value:

=====================================================*/
HRESULT QMSetObjectSecurityInternal(
    handle_t                hBind,
    OBJECT_FORMAT*          pObjectFormat,
    SECURITY_INFORMATION    SecurityInformation,
    DWORD                   SDSize,
    unsigned char __RPC_FAR *pSecurityDescriptor
    )
{
    if(!IsValidObjectFormat(pObjectFormat))
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, _T("RPC Invalid object format")));
        return MQ_ERROR_INVALID_PARAMETER;
    }
    if((SDSize != 0) && (pSecurityDescriptor == NULL))
    {
        TrERROR(GENERAL, "RPC (QMSetObjectSecurityInternal) NULL SD");
        return MQ_ERROR_INVALID_PARAMETER;
    }

    HRESULT rc;
    CS lock(qmcmd_cs);

    DBGMSG((DBGMOD_QM, DBGLVL_TRACE, TEXT("QMSetObjectSecurityInternal")));

    switch (pObjectFormat->ObjType)
    {
        case MQQM_QUEUE:
            ASSERT((pObjectFormat->pQueueFormat)->GetType() != QUEUE_FORMAT_TYPE_CONNECTOR);

            rc = g_QPrivate.QMSetPrivateQueueSecrity(
                                pObjectFormat->pQueueFormat,
                                SecurityInformation,
                                pSecurityDescriptor
                                );
            break;

        default:
            rc = MQ_ERROR;
            break;
    }

    return LogHR(rc, s_FN, 85);
}


/*====================================================

QMGetObjectSecurityInternal

Arguments:

Return Value:

=====================================================*/
HRESULT QMGetObjectSecurityInternal(
    handle_t                hBind,
    OBJECT_FORMAT*          pObjectFormat,
    SECURITY_INFORMATION    RequestedInformation,
    unsigned char __RPC_FAR *pSecurityDescriptor,
    DWORD                   nLength,
    LPDWORD                 lpnLengthNeeded
    )
{
    if(!IsValidObjectFormat(pObjectFormat))
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, _T("RPC Invalid object format")));
        return MQ_ERROR_INVALID_PARAMETER;
    }

    HRESULT rc;
    CS lock(qmcmd_cs);

    DBGMSG((DBGMOD_QM, DBGLVL_TRACE, TEXT("QMGetObjectSecurityInternal")));

    switch (pObjectFormat->ObjType)
    {
        case MQQM_QUEUE:
            ASSERT((pObjectFormat->pQueueFormat)->GetType() != QUEUE_FORMAT_TYPE_CONNECTOR);

            rc = g_QPrivate.QMGetPrivateQueueSecrity(
                                pObjectFormat->pQueueFormat,
                                RequestedInformation,
                                pSecurityDescriptor,
                                nLength,
                                lpnLengthNeeded
                                );
            break;

        default:
            rc = MQ_ERROR;
            break;
    }

    return LogHR(rc, s_FN, 90);
}

/*====================================================

QMDeleteObject

Arguments:

Return Value:

=====================================================*/
HRESULT
QMDeleteObject(
    handle_t       hBind,
    OBJECT_FORMAT* pObjectFormat
    )
{
    if(!IsValidObjectFormat(pObjectFormat))
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, _T("RPC Invalid object format")));
        return MQ_ERROR_INVALID_PARAMETER;
    }

    HRESULT rc;
    CS lock(qmcmd_cs);

    DBGMSG((DBGMOD_QM, DBGLVL_TRACE, TEXT("QMDeleteObject")));

    switch (pObjectFormat->ObjType)
    {
        case MQQM_QUEUE:
            ASSERT((pObjectFormat->pQueueFormat)->GetType() != QUEUE_FORMAT_TYPE_CONNECTOR);

            rc = g_QPrivate.QMDeletePrivateQueue(pObjectFormat->pQueueFormat);
            break;

        default:
            rc = MQ_ERROR;
            break;
    }

    return LogHR(rc, s_FN, 100);
}

/*====================================================

QMGetObjectProperties

Arguments:

Return Value:

=====================================================*/
HRESULT
QMGetObjectProperties(
    handle_t              hBind,
    OBJECT_FORMAT*        pObjectFormat,
    DWORD                 cp,
    PROPID __RPC_FAR      aProp[  ],
    PROPVARIANT __RPC_FAR apVar[  ]
    )
{
    if(!IsValidObjectFormat(pObjectFormat))
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, _T("RPC Invalid object format")));
        return MQ_ERROR_INVALID_PARAMETER;
    }

    HRESULT rc;
    CS lock(qmcmd_cs);

    DBGMSG((DBGMOD_QM, DBGLVL_TRACE, TEXT("QMGetObjectProperties")));

    switch (pObjectFormat->ObjType)
    {
        case MQQM_QUEUE:
            ASSERT((pObjectFormat->pQueueFormat)->GetType() != QUEUE_FORMAT_TYPE_CONNECTOR);

            rc = g_QPrivate.QMGetPrivateQueueProperties(
                    pObjectFormat->pQueueFormat,
                    cp,
                    aProp,
                    apVar
                    );
            break;

        default:
            rc = MQ_ERROR;
            break;
    }

    return LogHR(rc, s_FN, 110);
}

/*====================================================

QMSetObjectProperties

Arguments:

Return Value:

=====================================================*/
HRESULT
QMSetObjectProperties(
    handle_t              hBind,
    OBJECT_FORMAT*        pObjectFormat,
    DWORD                 cp,
    PROPID __RPC_FAR      aProp[],
    PROPVARIANT __RPC_FAR apVar[]
    )
{
    if(!IsValidObjectFormat(pObjectFormat))
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, _T("RPC Invalid object format")));
        return MQ_ERROR_INVALID_PARAMETER;
    }
    if((cp != 0) &&
          ((aProp == NULL) || (apVar == NULL))  )
    {
        TrERROR(GENERAL, "RPC (QMSetObjectProperties) NULL arrays");
        return MQ_ERROR_INVALID_PARAMETER;
    }

    HRESULT rc;
    CS lock(qmcmd_cs);

    DBGMSG((DBGMOD_QM, DBGLVL_TRACE, TEXT(" QMSetObjectProperties.")));

    ASSERT((pObjectFormat->pQueueFormat)->GetType() != QUEUE_FORMAT_TYPE_CONNECTOR);

    rc = g_QPrivate.QMSetPrivateQueueProperties(
            pObjectFormat->pQueueFormat,
            cp,
            aProp,
            apVar
            );

    return LogHR(rc, s_FN, 120);
}


static bool IsValidOutObjectFormat(const OBJECT_FORMAT* p)
{
    if(p == NULL)
        return false;

    if(p->ObjType != MQQM_QUEUE)
        return false;

    if(p->pQueueFormat == NULL)
        return false;

    //
    // If type is other than UNKNOWN this will lead to a leak on the server
    //
    if(p->pQueueFormat->GetType() != QUEUE_FORMAT_TYPE_UNKNOWN)
        return false;

    return true;
}

/*====================================================

QMObjectPathToObjectFormat

Arguments:

Return Value:

=====================================================*/
HRESULT
QMObjectPathToObjectFormat(
    handle_t                hBind,
    LPCWSTR                 lpwcsPathName,
    OBJECT_FORMAT __RPC_FAR *pObjectFormat
    )
{
    if((lpwcsPathName == NULL) || !IsValidOutObjectFormat(pObjectFormat))
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, _T("RPC Invalid object format out parameter")));
        return MQ_ERROR_INVALID_PARAMETER;
    }


    HRESULT rc;
    CS lock(qmcmd_cs);

    DBGMSG((DBGMOD_QM, DBGLVL_TRACE, TEXT("QMObjectPathToObjectFormat. object path name : %ls"), lpwcsPathName));

    rc = g_QPrivate.QMPrivateQueuePathToQueueFormat(
                        lpwcsPathName,
                        pObjectFormat->pQueueFormat
                        );

    return LogHR(rc, s_FN, 130);
}

HRESULT QMAttachProcess(
    handle_t       hBind,
    DWORD          dwProcessId,
    DWORD          cInSid,
    unsigned char  *pSid_buff,
    LPDWORD        pcReqSid)
{
    //
    // Restart the logging mechanism (i.e., read again logging flags from
    // registry) each time a msmq application start running.
    //
    Report.RestartLogging() ;

    if (dwProcessId)
    {
        HANDLE hCallingProcess = OpenProcess(
                                    PROCESS_DUP_HANDLE,
                                    FALSE,
                                    dwProcessId);
        if (hCallingProcess)
        {
            //
            // So we can duplicate handles to the process, no need to
            // mess around with the security descriptor on the calling
            // process side.
            //
            CloseHandle(hCallingProcess);
            return(MQ_OK);
        }
    }

    CAutoCloseHandle hProcToken;
    BOOL bRet;
    DWORD cLen;
    AP<char> tu_buff;
    DWORD cSid;

#define tu ((TOKEN_USER*)(char*)tu_buff)
#define pSid ((PSECURITY_DESCRIPTOR)pSid_buff)

    bRet = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hProcToken);
    ASSERT(bRet);
    GetTokenInformation(hProcToken, TokenUser, NULL, 0, &cLen);
    tu_buff = new char[cLen];
    bRet = GetTokenInformation(hProcToken, TokenUser, tu, cLen, &cLen);
    ASSERT(bRet);
    cSid = GetLengthSid(tu->User.Sid);
    if (cInSid >= cSid)
    {
        CopySid(cInSid, pSid, tu->User.Sid);
    }
    else
    {
        *pcReqSid = cSid;

        return LogHR(MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL, s_FN, 140);
    }

#undef tu
#undef pSid

    return MQ_OK;
}

//---------------------------------------------------------
//
//  Transaction enlistment RT interface to QM
//  For internal transactions uses RPC context handle
//
//---------------------------------------------------------
extern HRESULT QMDoGetTmWhereabouts(
    DWORD   cbBufSize,
    unsigned char *pbWhereabouts,
    DWORD *pcbWhereabouts);

extern HRESULT QMDoEnlistTransaction(
    XACTUOW* pUow,
    DWORD cbCookie,
    unsigned char *pbCookie);

extern HRESULT QMDoEnlistInternalTransaction(
    XACTUOW *pUow,
    RPC_INT_XACT_HANDLE *phXact);

extern HRESULT QMDoCommitTransaction(
    RPC_INT_XACT_HANDLE *phXact);

extern HRESULT QMDoAbortTransaction(
    RPC_INT_XACT_HANDLE *phXact);

HRESULT QMGetTmWhereabouts(
    /* [in]  */             handle_t  hBind,
    /* [in]  */             DWORD     cbBufSize,
    /* [out] [size_is] */   UCHAR __RPC_FAR *pbWhereabouts,
    /* [out] */             DWORD    *pcbWhereabouts)
{
    //CS  lock(qmcmd_cs);
    HRESULT hr2 = QMDoGetTmWhereabouts(cbBufSize, pbWhereabouts, pcbWhereabouts);
    return LogHR(hr2, s_FN, 150);
}


HRESULT QMEnlistTransaction(
    /* [in] */ handle_t hBind,
    /* [in] */ XACTUOW __RPC_FAR *pUow,
    /* [in] */ DWORD cbCookie,
    /* [size_is][in] */ UCHAR __RPC_FAR *pbCookie)
{
    //CS  lock(qmcmd_cs);
    HRESULT hr2 = QMDoEnlistTransaction(pUow, cbCookie, pbCookie);
    return LogHR(hr2, s_FN, 160);
}

HRESULT QMEnlistInternalTransaction(
    /* [in] */ handle_t hBind,
    /* [in] */ XACTUOW __RPC_FAR *pUow,
    /* [out]*/ RPC_INT_XACT_HANDLE *phXact)
{
    //CS  lock(qmcmd_cs);
    HRESULT hr2 = QMDoEnlistInternalTransaction(pUow, phXact);
    return LogHR(hr2, s_FN, 161);
}

HRESULT QMCommitTransaction(
    /* [in, out] */ RPC_INT_XACT_HANDLE *phXact)
{
    //CS  lock(qmcmd_cs);
    HRESULT hr2 = QMDoCommitTransaction(phXact);
    return LogHR(hr2, s_FN, 162);
}


HRESULT QMAbortTransaction(
    /* [in, out] */ RPC_INT_XACT_HANDLE *phXact)
{
    // CS  lock(qmcmd_cs);
    HRESULT hr2 = QMDoAbortTransaction(phXact);
    return LogHR(hr2, s_FN, 163);
}


HRESULT QMListInternalQueues(
    /* [in] */ handle_t hBind,
    /* [length_is][length_is][size_is][size_is][unique][out][in] */ WCHAR __RPC_FAR *__RPC_FAR *ppFormatName,
    /* [out][in] */ LPDWORD pdwFormatLen,
    /* [length_is][length_is][size_is][size_is][unique][out][in] */ WCHAR __RPC_FAR *__RPC_FAR *ppDisplayName,
    /* [out][in] */ LPDWORD pdwDisplayLen)
{
	*pdwFormatLen = 0;
	*pdwDisplayLen = 0;

    ASSERT_BENIGN(("QMListInternalQueues is an obsolete RPC interface; safe to ignore", 0));
    return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 164);
}


// Obsolete but kept to preserve RPC
HRESULT QMCorrectOutSequence(
        /* [in] */ handle_t hBind,
        /* [in] */ DWORD dwSeqID1,
        /* [in] */ DWORD dwSeqID2,
        /* [in] */ ULONG ulSeqN)
{
    ASSERT_BENIGN(("QMCorrectOutSequence is an obsolete RPC interface; safe to ignore", 0));
    return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 165);
}


HRESULT
QMGetMsmqServiceName(
    /* [in] */ handle_t                hBind,
    /* [in, out, ptr, string] */ LPWSTR *lplpService
    )
{
    if(lplpService == NULL)
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 165);
    try
	{
		*lplpService = new WCHAR[MAX_PATH];
	}
    catch(const bad_alloc&)
    {
        return (MQ_ERROR_INSUFFICIENT_RESOURCES);
    }
	GetFalconServiceName(*lplpService, MAX_PATH);

    return MQ_OK ;

} //QMGetFalconServiceName
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qmmgmt_s_.c ===
#pragma warning(push, 3)
#include <qmmgmt_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qmguest.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    qmguest.cpp

Abstract:

    This file contains the code to initialize and use the access token
    of the guest user account.

Author:

    Doron Juster (DoronJ)

--*/

#include "stdh.h"

//+-----------------------------------------
//
//   HANDLE  InitializeGuestToken()
//
//+-----------------------------------------

HANDLE  InitializeGuestToken()
{
    //
    // Try to read password of guest account from registry. If not found,
    // use blank password.
    // Note: by default, if administrator want to enable anonymous access,
    // he should enable the guest account with blank password. However, if
    // this is a security hole, and he wants to set a non-blank password,
    // then he has to add this registry for MSMQ usage. At present we don't
    // plan to implement real password management (ui + LSA).
    // DoronJ, 12-Jan-1999.
    //
    WCHAR wszPassword[ 64 ] ;
    DWORD dwType = REG_SZ ;
    DWORD dwSize = sizeof(wszPassword) ;
    LONG rc = GetFalconKeyValue( GUEST_PASSWORD_REGNAME,
                                 &dwType,
                                 (PVOID) wszPassword,
                                 &dwSize ) ;
    if ((rc != ERROR_SUCCESS) || (dwSize <= 1))
    {
        ASSERT(rc != ERROR_MORE_DATA) ;
        wcscpy(wszPassword, L"") ;
    }

    HANDLE  hGuestToken = NULL ;

    BOOL fLogon = LogonUser( L"Guest",
                             L"",
                             wszPassword,
                             LOGON32_LOGON_NETWORK,
                             LOGON32_PROVIDER_DEFAULT,
                             &hGuestToken ) ;
    if (!fLogon)
    {
        DWORD dwErr = GetLastError() ;
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, TEXT(
          "InitializeGuestToken: LogonUser() failed, Err- %lut"), dwErr)) ;
    }

    return hGuestToken ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qmds.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    InitFRS.cpp

Abstract:

    Implementation of Routing Decision class.

Author:

    Lior Moshaiov (LiorM)

--*/


#include "stdh.h"
#include "qmds.h"
#include "session.h"
#include "cqmgr.h"
#include "cqueue.h"
#include "_rstrct.h"
#include "qmres.h"
#include "mqdsdef.h"
#include "qmsecutl.h"
#include "qmthrd.h"
#include "qmutil.h"
#include "xact.h"
#include "xactrm.h"
#include "regqueue.h"
#include "_mqrpc.h"
#include "qm2qm.h"
#include "qmrpcsrv.h"
#include <dsgetdc.h>
#include <dsrole.h>
#include <uniansi.h>
#include "safeboot.h"
#include "setup.h"
#include <mqnames.h>
#include "ad.h"

#include "httpAccept.h"
#include "sessmgr.h"
#include "joinstat.h"

#include "Qmp.h"

#include "qmds.tmh"


extern CQGroup* g_pgroupNotValidated;
extern CSessionMgr       SessionMgr;
extern LPTSTR            g_szMachineName;
extern AP<WCHAR>		 g_szComputerDnsName;
extern CQGroup*          g_pgroupNonactive;
extern DWORD             g_dwOperatingSystem;
extern BOOL              g_fWorkGroupInstallation;
extern BOOL              g_fQMIDChanged ;

extern void WINAPI TimeToUpdateDsServerList(CTimer* pTimer);

static void WINAPI TimeToLookForOnlineDS(CTimer* pTimer);
static void WINAPI TimeToUpdateDS(CTimer* pTimer);
static void WINAPI TimeToOnlineInitialization(CTimer* pTimer);
static void WINAPI TimeToClientInitializationCheckDeferred(CTimer* pTimer);

static CTimer s_LookForOnlineDSTimer(TimeToLookForOnlineDS);
static CTimer s_UpdateDSTimer(TimeToUpdateDS);
static CTimer s_OnlineInitializationTimer(TimeToOnlineInitialization);
static CTimer s_UpdateCacheTimer(TimeToPublicCacheUpdate);
static CTimer s_UpdateDSSeverListTimer(TimeToUpdateDsServerList);
static CTimer s_DeferredInitTimer(TimeToClientInitializationCheckDeferred);

static LONG s_fLookForOnlineDSTimerScheduled = FALSE;

static WCHAR *s_FN=L"qmds";


static void ExitMSMQProcess()
{
    LogBOOL(FALSE, s_FN, 11);
    ASSERT(("Exiting MSMQ process!!!", 0));
    
    ExitProcess(1);
}


/*====================================================

UpdateMachineSecurityCache

Arguments:

Return Value:

=====================================================*/

HRESULT
UpdateMachineSecurityCache(void)
{
    const VOID *pSD;
    DWORD dwSDSize;

    if (! QueueMgr.CanAccessDS())
    {
       return LogHR(MQ_ERROR_NO_DS, s_FN, 10);
    }

    CQMDSSecureableObject DSMacSec(eMACHINE,  QueueMgr.GetQMGuid(), TRUE, TRUE, NULL);

    pSD = DSMacSec.GetSDPtr();
    if (!pSD)
    {
        return LogHR(MQ_ERROR, s_FN, 20);
    }

    dwSDSize = GetSecurityDescriptorLength(const_cast<PSECURITY_DESCRIPTOR>(pSD));

    HRESULT hr = SetMachineSecurityCache(pSD, dwSDSize);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 30);
    }

    //
    // cache machine account sid in registry.
    //
    PROPID propidSid = PROPID_COM_SID ;
    MQPROPVARIANT   PropVarSid ;
    PropVarSid.vt = VT_NULL ;
    PropVarSid.blob.pBlobData = NULL ;
    P<BYTE> pSid = NULL ;

    if (g_szComputerDnsName != NULL)
    {
        hr = ADGetObjectProperties(
                        eCOMPUTER,
                        NULL,   // pwcsDomainController
						false,	// fServerName
                        g_szComputerDnsName,
                        1,
                        &propidSid,
                        &PropVarSid
                        );
    }
    else
    {
        hr = MQ_ERROR;
    }
    if (FAILED(hr))
    {
        hr = ADGetObjectProperties(
					eCOMPUTER,
					NULL,   // pwcsDomainController
					false,	// fServerName
					g_szMachineName,
					1,
					&propidSid,
					&PropVarSid
					);
    }
    if (SUCCEEDED(hr))
    {
        pSid = PropVarSid.blob.pBlobData ;
        ASSERT(IsValidSid(pSid)) ;

        DWORD  dwSize = GetLengthSid(pSid) ;
        DWORD  dwType = REG_BINARY ;

        LONG rc = SetFalconKeyValue( MACHINE_ACCOUNT_REGNAME,
                                    &dwType,
                                     pSid,
                                    &dwSize) ;
        ASSERT(rc == ERROR_SUCCESS) ;
        if (rc != ERROR_SUCCESS)
        {
            hr = MQ_ERROR ;
        }
    }
    else if (hr == MQ_ERROR_ILLEGAL_PROPID)
    {
        //
        // We queries a MSMQ1.0 server. It can't answer us with this.
        //
        hr = MQ_OK ;
    }

    return LogHR(hr, s_FN, 40);
}

//+-------------------------------------------
//
//  BOOL IsThisServerDomainController()
//
//+-------------------------------------------

BOOL IsThisServerDomainController()
{
    static BOOL  s_fIsDc = FALSE ;
    static BOOL  s_fAlreadyAsked = FALSE ;

    if (s_fAlreadyAsked)
    {
        return s_fIsDc ;
    }

    BYTE *pBuf = NULL ;

    DWORD dwRole = DsRoleGetPrimaryDomainInformation(
                                     NULL,
                                     DsRolePrimaryDomainInfoBasic,
                                    &pBuf ) ;
    if (dwRole == ERROR_SUCCESS)
    {
        s_fAlreadyAsked = TRUE ;

        DSROLE_PRIMARY_DOMAIN_INFO_BASIC *pRole =
                           (DSROLE_PRIMARY_DOMAIN_INFO_BASIC *) pBuf ;
        s_fIsDc = !!(pRole->Flags & DSROLE_PRIMARY_DS_RUNNING) ;

        DsRoleFreeMemory(pRole) ;
    }

    return s_fIsDc ;
}


/*====================================================

HRESULT _CheckQMGuidInADS()

Arguments:

Return Value:

=====================================================*/

static HRESULT _CheckQMGuidInADS(EVENTLOGID *pEventId)
{
    //
    // Check QM Guid consistency
    //
    PROPID propId[1];
    PROPVARIANT var[1];

    propId[0] = PROPID_QM_PATHNAME;
    var[0].vt = VT_NULL;
	
    HRESULT rc = ADGetObjectPropertiesGuid(
						eMACHINE,
						NULL,   // pwcsDomainController
						false,	// fServerName
						QueueMgr.GetQMGuid(),
						1,
						propId,
						var
						);

    if (FAILED(rc))
    {
        if (rc == MQDS_OBJECT_NOT_FOUND)
        {
            if (g_fQMIDChanged)
            {
                //
                // This may happen if we joined a domain after boot, and
                // the msmqConfiguration object was created in a remote
                // GC and not yet replicated to nearby domain controllers.
                //
                return LogHR(MQ_ERROR_NO_DS, s_FN, 275);
            }

            *pEventId = DS_MACHINE_NAME_INCONSISTENT ;
            return LogHR(MQ_ERROR_QM_OBJECT_NOT_FOUND, s_FN, 280);
        }

        return LogHR(rc, s_FN, 290);
    }

    AP<WCHAR> pCleanup = var[0].pwszVal;

    if (wcscmp( var[0].pwszVal, g_szMachineName) != 0)
    {
        *pEventId = INCONSISTENT_QM_ID_ERROR ;
        return LogHR(MQ_ERROR_INCONSISTENT_QM_ID, s_FN, 300);
    }

    return MQ_OK;
}

/*====================================================

HRESULT CheckQMGuid()

Arguments:

Return Value:

=====================================================*/

HRESULT CheckQMGuid()
{
    EVENTLOGID EventId = 0 ;

    HRESULT hr = _CheckQMGuidInADS(&EventId) ;

    if ((hr != MQ_ERROR_INCONSISTENT_QM_ID) &&
		(hr != MQ_ERROR_QM_OBJECT_NOT_FOUND))
    {
        ASSERT(EventId == 0) ;
        return LogHR(hr, s_FN, 301);
    }

    static BOOL s_fAlreadyFailedHere = FALSE ;
    if (s_fAlreadyFailedHere)
    {
        //
        // No need to handle this failure again.
        //
        return LogHR(hr, s_FN, 302);
    }
    s_fAlreadyFailedHere = TRUE ;

    REPORT_WITH_STRINGS_AND_CATEGORY(( CATEGORY_KERNEL,
                                       EventId, 0));


    //
    // Return NO_DS and not the INCONSISTENT error.
    // Otherwise, the msmq service will quit and won't try again to
    // query from new list of servers.
    //
    return LogHR(MQ_ERROR_NO_DS, s_FN, 303);
}

//+-------------------------------------------
//
//   void  TimeToLookForOnlineDS()
//
//+-------------------------------------------

static
void
WINAPI
TimeToLookForOnlineDS(
    CTimer* pTimer
    )
{
    ASSERT(pTimer == &s_LookForOnlineDSTimer);

    if (QueueMgr.IsDSOnline())
    {
        LONG fAlreadySchedule = InterlockedExchange(&s_fLookForOnlineDSTimerScheduled, FALSE);
        ASSERT(fAlreadySchedule);
		DBG_USED(fAlreadySchedule);

        //
        // We're already online. Do nothing.
        //
        return ;
    }

    //
    // Here we're called from the timer scheduling thread.
    //
    // SP4 - bug# 2962 : check if access to DS is allowed. This feature is used
    //                   support Administrative offline DS.
    //                       Uri Habusha (urih), 17-Jun-98
    //
    if (!QueueMgr.IsConnected() || FAILED(CheckQMGuid()))
    {
        LONG fAlreadySchedule = InterlockedExchange(&s_fLookForOnlineDSTimerScheduled, TRUE);
        ASSERT(fAlreadySchedule);
		DBG_USED(fAlreadySchedule);

        CQueueMgr::SetDSOnline(FALSE);
        ExSetTimer(&s_LookForOnlineDSTimer, CTimeDuration::FromMilliSeconds(60000));
        return;
    }

    HRESULT hr;

    LONG fAlreadySchedule = InterlockedExchange(&s_fLookForOnlineDSTimerScheduled, FALSE);
    ASSERT(fAlreadySchedule);
	DBG_USED(fAlreadySchedule);
    CQueueMgr::SetDSOnline(TRUE);
    hr = QueueMgr.ValidateOpenedQueues() ;
    hr = QueueMgr.ValidateMachineProperties();
}

/*====================================================

HRESULT  QMLookForOnlineDS()

Description:

Return Value:

=====================================================*/

void APIENTRY QMLookForOnlineDS(void* pvoid, DWORD dwtemp)
{
    ASSERT(dwtemp == 1);

    //
    // Called from DS to start looking for an online MQIS server.
    //
    if (!QueueMgr.IsDSOnline())
    {
        //
        // I'm already offline so do nothing. There is already
        // a timer for this. (at least it should be).
        //
        return ;
    }

    LONG fAlreadySchedule = InterlockedExchange(&s_fLookForOnlineDSTimerScheduled, TRUE);
    if (fAlreadySchedule)
        return;

    CQueueMgr::SetDSOnline(FALSE);
    ExSetTimer(&s_LookForOnlineDSTimer, CTimeDuration::FromMilliSeconds(60000));
}



void QMpRegisterIPNotification();
VOID WINAPI HandleIPAddressListChange(EXOVERLAPPED* pov);

static SOCKET s_Socket = NULL;
EXOVERLAPPED s_pOverlapped(HandleIPAddressListChange, HandleIPAddressListChange);



VOID 
WINAPI 
HandleIPAddressListChange(
	EXOVERLAPPED* //pov
	)
{
	DBGMSG((DBGMOD_QM, DBGLVL_TRACE, TEXT("HandleIPAddressListChange() invoked.")));

#ifdef _DEBUG

	struct hostent* HostEnt = gethostbyname(NULL);

    for(int i = 0; HostEnt->h_addr_list[i] != NULL; i++)
    {
        DBGMSG((DBGMOD_QM, DBGLVL_TRACE, _T("gethostbyname() IP address %-2d ... [%hs]"), i, 
            inet_ntoa(*((in_addr*)HostEnt->h_addr_list[i]))));
    }

	char BufOut[1024];
	DWORD BytesRead = 0;

	int Result = WSAIoctl(
					s_Socket,                                 
					SIO_ADDRESS_LIST_QUERY,                         
					NULL,                       
					0,                         
					BufOut,                       
					sizeof(BufOut),                       
					&BytesRead,                     
					NULL,                         
					NULL 
					);

	UNREFERENCED_PARAMETER(Result);

	SOCKET_ADDRESS_LIST* slist = (SOCKET_ADDRESS_LIST *)BufOut;

    for(i = 0; i < slist->iAddressCount; i++)
    {
        DBGMSG((DBGMOD_QM, DBGLVL_TRACE, TEXT("WSAioctl() IP address %-2d ... [%hs]\n"), i, 
            inet_ntoa(((SOCKADDR_IN *)slist->Address[i].lpSockaddr)->sin_addr)));
    }

#endif

	QMpRegisterIPNotification();
}



void QMpCreateIPNotificationSocket()
{
	ASSERT(s_Socket == NULL);

	s_Socket = WSASocket(
					AF_INET,
					SOCK_RAW,
					IPPROTO_IP,
					NULL, 
					0,
					WSA_FLAG_OVERLAPPED
					);

	if(s_Socket == INVALID_SOCKET) 
	{
		DBGMSG((DBGMOD_QM, DBGLVL_ERROR, TEXT("WSASocket() failed: %d\n"), WSAGetLastError()));
		LogIllegalPoint(s_FN, 100);
		throw exception();
	}

	ExAttachHandle((HANDLE)s_Socket);
}



void QMpRegisterIPNotification()
/*++

Routine Description:
    Registers a notification on a change in the IP address list.
	This change usually occurs when a network cable is plugged or unplugged.
	Thus this mechanism is used to notify network connectivity changes.

--*/
{
	ASSERT(s_Socket != NULL);

	DWORD BytesRead = 0;

	int Result = WSAIoctl(
					s_Socket,                                     
					SIO_ADDRESS_LIST_CHANGE,                     
					NULL,                     
					0,                           
					NULL,                    
					0,                         
					&BytesRead,               
					&s_pOverlapped,                         
					NULL 
					);

	if((Result == SOCKET_ERROR) && (WSAGetLastError() != WSA_IO_PENDING))
	{
		DBGMSG((DBGMOD_QM, DBGLVL_ERROR, TEXT("WSAIoctl() failed: %d\n"), WSAGetLastError()));
		LogIllegalPoint(s_FN, 305);
		throw exception();
	}
}



BOOL
QMOneTimeInit(
    VOID
    )
/*++

Routine Description:
    Start session listener, RPC listener and not active group listener

Arguments:
    None

Returned Value:
    TRUE if initialization succeeded

--*/
{
    //
    // Begin to accept incoming sesions
    //
    SessionMgr.BeginAccept();
	DBGMSG((DBGMOD_QM, DBGLVL_TRACE,  L"QM began to accept incoming session"));

    //
    // bind multicast address
    //
    bool f = QmpInitMulticastListen();
    if (!f)
    {
        return LogBOOL(FALSE, s_FN, 304);
    }

    //
    // Get packet for nonactive groups
    //
    HRESULT hr;
    try
    {
        QMOV_ACGetMsg* pov = new QMOV_ACGetMsg(
									GetNonactiveMessageSucceeded, 
									GetNonactiveMessageFailed
									);
        hr = CreateAcGetPacketRequest( g_pgroupNonactive->GetGroupHandle(),
                                       pov,
                                       NULL,
                                       FALSE /*fAfterFailure*/ ) ;
    }
    catch (const bad_alloc&)
    {
        hr = MQ_ERROR;
        LogIllegalPoint(s_FN, 61);
    }

    if (FAILED(hr))
    {
        REPORT_ILLEGAL_STATUS(hr, L"QMOneTimeInit");
        LogHR(hr, s_FN, 62);
        return FALSE;
    }

    RPC_STATUS status = InitializeRpcServer() ;
    if (status != RPC_S_OK)
    {
        REPORT_ILLEGAL_STATUS(status, L"QMOneTimeInit");
        LogRPCStatus(status, s_FN, 63);
        return FALSE ;
    }

    try
    {
        IntializeHttpRpc();
    }
    catch(const exception&)
    {
    	LogIllegalPoint(s_FN, 306);
        return FALSE;
    }

    try
    {
		QMpCreateIPNotificationSocket();
        QMpRegisterIPNotification();
    }
    catch(const exception&)
    {
    	LogIllegalPoint(s_FN, 307);
        return FALSE;
    }

    return TRUE;
}


static bool GuidContained(const CACLSID& a, const GUID& g)
{
	for (DWORD i=0; i < a.cElems; ++i)
	{
		if (a.pElems[i] == g)
			return true;
	}

	return false;
}

static bool GuidListEqual(const CACLSID& a, const CACLSID& b)
{
    if(a.cElems != b.cElems)
        return false;

    for(DWORD i = 0; i < a.cElems; i++) 
    {
        if(!GuidContained(b, a.pElems[i]))
            return false;
    }

    return true;
}

static bool s_fInformedSiteResolutionFailure = false;

static HRESULT UpdateMachineSites()
/*++

Routine Description:
    Update the QM list of sites in the Active Directory

Arguments:
    None

Returned Value:
    MQ_OK on successful update

--*/
{
    //
    // If not running in AD environemnt, bail out. We do not track
    // machine sites in other environemnts.
    //
    if(ADGetEnterprise() != eAD)
        return MQ_OK;

    //
    // Get the computer sites as seen by Active Directory
    //
    DWORD nSites;
    AP<GUID> pSites;
    HRESULT hr = ADGetComputerSites(0, &nSites, &pSites);

    if ( hr == MQDS_INFORMATION_SITE_NOT_RESOLVED)
    {
        if (!s_fInformedSiteResolutionFailure)
        {
            // 
            // failed to resolved the computer sites, inform the user and continue
            //
            REPORT_CATEGORY(EVENT_NO_SITE_RESOLUTION, CATEGORY_KERNEL);
            s_fInformedSiteResolutionFailure = true;
        }
        return hr;
    }

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 653);
    }

    s_fInformedSiteResolutionFailure = false;

    //
    // Set the first site to registry
    //
    DWORD dwType = REG_BINARY;
    DWORD dwSize = sizeof(GUID);
    LONG rc = SetFalconKeyValue(
                MSMQ_SITEID_REGNAME,
                &dwType,
                pSites.get(),
                &dwSize
                );

    ASSERT(rc == ERROR_SUCCESS);
	DBG_USED(rc);

    //
    // Get current computer sites as registered in msmqConfiguration object
    //
    PROPID aProp[] = {PROPID_QM_SITE_IDS};
    PROPVARIANT aVar[TABLE_SIZE(aProp)] = {{VT_NULL,0,0,0,0}};
   

    hr = ADGetObjectPropertiesGuid(
                    eMACHINE,
                    NULL,   // pwcsDomainController
					false,	// fServerName
                    QueueMgr.GetQMGuid(),
                    TABLE_SIZE(aProp),
                    aProp,
                    aVar
                    );

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 675);
    }

    //
    // Set auto pointer to free the list of sites
    //
    AP<GUID> pOldSites = aVar[0].cauuid.pElems;


    //
    // Allocate enough memory for the composed site list
    // and copy the machine sites
    //
    AP<GUID> pNewSites = new GUID[nSites + aVar[0].cauuid.cElems];
    memcpy(pNewSites, pSites, nSites * sizeof(GUID));
    

    //
    // Extract all foreign sites for sites in DS
    // and compose machine + foreign site IDs
    //
    for(DWORD i = 0; i < aVar[0].cauuid.cElems; i++)
    {
        //
        // Find out if this site is foreign 
        //
        // BUGBUG - to improve and call local routing cache
        // instead of accessing the DS
        //      ronith june-00
        //
        PROPID propSite[]= {PROPID_S_FOREIGN};
        MQPROPVARIANT varSite[TABLE_SIZE(propSite)] = {{VT_NULL,0,0,0,0}};
        HRESULT hr1 = ADGetObjectPropertiesGuid(
                            eSITE,
                            NULL,   // pwcsDomainController
							false,	// fServerName
                            &aVar[0].cauuid.pElems[i],
                            TABLE_SIZE(propSite),
                            propSite,
                            varSite
                            );
        if (FAILED(hr1))
        {
            break;
        }

        if (varSite[0].bVal == 1)
        {
            pNewSites[nSites++] = aVar[0].cauuid.pElems[i];
        }
    }

    //
    // Set the properites to update in Active Directory
    //
    PROPID propSite[]= {PROPID_QM_SITE_IDS};
    MQPROPVARIANT varSite[TABLE_SIZE(propSite)] = {{VT_CLSID|VT_VECTOR,0,0,0,0}};
	varSite[0].cauuid.pElems = pNewSites;
	varSite[0].cauuid.cElems = nSites;

    //
    // Compare to the sites in the DS, bail out if equal
    // The order of the GUIDs should not matter as the Active Directory
    // stores them in a different order than we set them below.
    //
    if(GuidListEqual(aVar[0].cauuid, varSite[0].cauuid))
        return MQ_OK;

    //
    // Update this machine sites in DS
    //
    hr = ADSetObjectPropertiesGuid(
                eMACHINE,
                NULL,       // pwcsDomainController
				false,		// fServerName
                QueueMgr.GetQMGuid(),
                TABLE_SIZE(propSite), 
                propSite, 
                varSite
                );

    if(FAILED(hr))
    {
        return LogHR(hr, s_FN, 754);
    }

    return MQ_OK;
}


static HRESULT DoUpdateDS()
{
    if(!QueueMgr.IsConnected())
    {
        return LogHR(MQ_ERROR, s_FN, 430);
    }

    HRESULT hr = UpdateMachineSites();
    DBGMSG((DBGMOD_QM, DBGLVL_TRACE,  L"QM Updates QM Topology"));
    if(FAILED(hr))
    {
        return LogHR(hr, s_FN, 440);
    }

    return LogHR(hr, s_FN, 460);
}


static DWORD GetDSUpdateInterval(bool fSuccess)
{
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = REG_DWORD;
    DWORD dwUpdateInterval = 0;

    LONG rc = GetFalconKeyValue(
                fSuccess ? MSMQ_SITES_UPDATE_INTERVAL_REGNAME : MSMQ_DSUPDATE_INTERVAL_REGNAME,
                &dwType,
                &dwUpdateInterval,
                &dwSize
                );

    if(rc != ERROR_SUCCESS)
    {
        dwUpdateInterval = fSuccess ? MSMQ_DEFAULT_SITES_UPDATE_INTERVAL : MSMQ_DEFAULT_DSUPDATE_INTERVAL;
    }

    return dwUpdateInterval;
}


static void WINAPI TimeToUpdateDS(CTimer* pTimer)
{
    ASSERT(pTimer == &s_UpdateDSTimer);

    HRESULT hr;
    hr = DoUpdateDS();

    DBGMSG((DBGMOD_QM, DBGLVL_TRACE,  L"QM Updates machine sites in DS"));

    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, TEXT("Can't update machine information in DS. hr=0x%x"), hr));
    }

    //
    // Update the DS information periodically even on successful update.
    // e.g., the machine subnets might get changed, affecting message routing.
    // subnet change does not require machine reboot, thus we need to update
    // machine sites periodically.
    // Zero value disables this periodic update.
    //
    DWORD dwUpdateInterval = GetDSUpdateInterval(SUCCEEDED(hr));

    if(dwUpdateInterval == 0)
        return;

    ExSetTimer(pTimer, CTimeDuration::FromMilliSeconds(dwUpdateInterval));
}


static BOOL MachineAddressChanged(void)
{
    //
    // TODO: erezh, check if this function is needed anymore.
    //      check if an address has changed.
    //
    return FALSE;
}


static BOOL OnlineInitialization()
/*++

Routine Description:
    Validate the QM ID with the one registered with the active directory.
    Validate all queues and update Active Directory with QM information.

Arguments:
    None

Returned Value:
    None

--*/
{
    if (g_fWorkGroupInstallation)
    {
        CQueueMgr::SetDSOnline(TRUE);
        return TRUE;
    }

    //
    //  Check machine parameters
    //
    HRESULT hr = CheckQMGuid();
    if (FAILED(hr))
    {
        if (hr == MQ_ERROR_INCONSISTENT_QM_ID)
        {
            REPORT_CATEGORY(QM_MACHINE_INIT_FAIL, CATEGORY_KERNEL);
	        LogHR(hr, s_FN, 66);
            return FALSE;
        }

        //
        // Failed to access Active Directory, schedule a latter retry
        //
        ExSetTimer(&s_OnlineInitializationTimer, CTimeDuration::FromMilliSeconds(120000));
        return TRUE;
    }

    DBGMSG((DBGMOD_QM, DBGLVL_TRACE, TEXT("Successful Online initialization")));

    CQueueMgr::SetDSOnline(TRUE);


    //
    //  Now that we found a MQIS server we can validate all the
    //  opened and not validated queues.
    //  We always, (on servers too), recover before initializing MQIS
    //  so we always must validate.
    //
    hr = QueueMgr.ValidateOpenedQueues() ;
    if (SUCCEEDED(hr))
    {
        hr = QueueMgr.ValidateMachineProperties();
    }

    if (SUCCEEDED(hr))
    {
        hr = UpdateMachineSecurityCache();
    }

    if (FAILED(hr))
    {
        if (hr != MQ_ERROR_NO_DS)
        {
            REPORT_ILLEGAL_STATUS(hr, L"OnlineInitialization");
	        LogHR(hr, s_FN, 68);
            return FALSE;
        }

        //
        // MQIS server failed while we initialized. Try later.
        //
        ExSetTimer(&s_OnlineInitializationTimer, CTimeDuration::FromMilliSeconds(10000));

		WRITE_MSMQ_LOG((MSMQ_LOG_ERROR, e_LogQM, LOG_QM_INIT,
					    L"QM: MQIS server failed while we initialized. Try later"));

        return TRUE;

    }

    REPORT_CATEGORY(EVENT_INFO_QM_ONLINE_WITH_DS, CATEGORY_KERNEL);

    //
    //  Update the cache of local public queues.
    //  Needed for off-line operation in the future.
    //
    ExSetTimer(&s_UpdateCacheTimer, CTimeDuration::FromMilliSeconds(10 * 1000));

    //
    //  Schedule   TimeToUpdateDsServerList
    // We do this on servers too, because falcon apps need this info
    // and because SQL may fail and then Falcon work as client QM.
    //
    ExSetTimer(&s_UpdateDSSeverListTimer, CTimeDuration::FromMilliSeconds(60 * 1000));


    TimeToUpdateDS(&s_UpdateDSTimer);

    return TRUE;
}


static
void
WINAPI
TimeToOnlineInitialization(
    CTimer* pTimer
    )
/*++

Routine Description:
    The routine calls from the scheduler to Initialize the DS

Arguments:
    Pointer to Timer object

Returned Value:
    None

--*/
{
    if(!OnlineInitialization())
    {
        ExitMSMQProcess();
    }
}


static LONG s_Initialized = 0;
/*====================================================

  Function: MQDSClientInitializationCheck
    SP4. Postpone access to DS until it really required.
    When client is started MSMQ doesn't initialize the connection to the server. The DS
    connection is delayed until the application access the DS, open a queue or MSMQ
    receive a message.
    This fix comes to solve the McDonald's problem that causes dial-out each time MSMQ
    is started, even it doesn't execute any MSMQ operation.

  Arguments:
    None.

  Returned Value:
    None

=====================================================*/
void MQDSClientInitializationCheck(void)
{

    if (
        (QueueMgr.IsConnected()) &&
        (InterlockedExchange(&s_Initialized, 1) == 0)
        )
    {
        if(!OnlineInitialization())
        {
            ExitMSMQProcess();
        }
    }
}


static
void
WINAPI
TimeToClientInitializationCheckDeferred(
    CTimer* pTimer
    )
{
    MQDSClientInitializationCheck();
}


void ScheduleOnlineInitialization()
/*++

Routine Description:
    Control online access, either spawn another thread to get online with the
    active directory. Or mark state online and QM ID checkup and queue
    validation will be done on first access to the Active Directory.

Arguments:
    None

Returned Value:
    None

--*/
{
    ASSERT(!QueueMgr.IsDSOnline());

    //
    // SP4 - Bug# 2962 (QM accesses MQIS at start-up)
    // Postpone access to DS until it really required.
    // When MSMQ client is started it doesn't initialize the connection to the server.
    // The DS connection is delayed until the application access the DS, open a queue
    // or MSMQ receive a message.
    //

    //
    // Read Deferred Initalization Mode form Registry. Eiter the QM access
    // immediately the DS, or defer it to first needed access.
    //
    BOOL fDeferredInit = FALSE;
    READ_REG_DWORD(
        fDeferredInit,
        MSMQ_DEFERRED_INIT_REGNAME,
        &fDeferredInit
        );

    if (
        //
        // Deffered initialization is not required, so go ahead and connect to DS
        //
        !fDeferredInit ||
        
        //
        // One of the machine addresses (this might be obsolete)
        //
        MachineAddressChanged() ||
        
        //
        // There are queues that require validation, go and check them up.
        //
        !g_pgroupNotValidated->IsEmpty())
    {
        ExSetTimer(&s_DeferredInitTimer, CTimeDuration::FromMilliSeconds(0));
        return;
    }

    //
    // Set the DS status as online although the DS initialization was postponed
    // until first access. This is done to ensure that the QM tries to access
    // the DS even at the first time before the MSMQ client initialization
    // is completed and not return NO_DS immediately
    //                          Uri Habusha (urih), 17-Jun-98
    //
    CQueueMgr::SetDSOnline(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qmnotify.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    qmnotify.h

Abstract:

	Admin Class definition
		
Author:



--*/


#define NOTIFY_QUEUE_NAME	(L"private$\\notify_queue$")


class CNotify
{
    public:

        CNotify();

        HRESULT Init();


    private:

        //functions
        HRESULT GetNotifyQueueFormat( QUEUE_FORMAT * pQueueFormat);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qmp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    Qmp.h

Abstract:
    QM general function decleration

Author:
    Uri Habusha (urih) 26-Sep-2000

Environment:
    Platform-independent

--*/

#pragma once

#ifndef __QMP_H__
#define __QMP_H__

#include "msgprops.h"

bool 
QmpInitMulticastListen(
    void
    );

SOCKET
QmpCreateSocket(
    bool fQoS
    );

void 
QmpFillQoSBuffer(
    QOS* pQos
    );

HRESULT
QmpSendPacket(
    CMessageProperty* pmp,
    const QUEUE_FORMAT* pqdDstQueue,
    const QUEUE_FORMAT* pqdAdminQueue,
    const QUEUE_FORMAT* pqdResponseQueue,
    BOOL fSign = FALSE
    );

typedef
BOOL
(WINAPI *LPRECEIVE_COMPLETION_ROUTINE)(
    CMessageProperty* pmp,
    QUEUE_FORMAT*     pQueueFormat
    );


HRESULT
QmpOpenAppsReceiveQueue(
    const QUEUE_FORMAT* pQueueFormat,
    LPRECEIVE_COMPLETION_ROUTINE lpReceiveRoutine
    );

void
QmpReportServiceProgress(
    void
    );

#endif // __QMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qmperf.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    admin.h

Abstract:

    Admin utilities include file (common)

Author:

    Yoel Arnon (yoela)

    Gadi Ittah (t-gadii)

--*/

#ifndef __QMPERF_H__
#define __QMPERF_H__

#include "mqperf.h"
#include "perf.h"

#ifdef _QM_
__declspec(dllexport) extern CPerf PerfApp;
#else
__declspec(dllimport) extern CPerf PerfApp;
#endif

extern QmCounters *g_pqmCounters;


BOOL QMPrfInit();

#endif // __ADMIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qmperf.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    qmperf.cpp

Abstract:

    qm performance monitor counters handling

Authors:

    Yoel Arnon (yoela)
    Gadi Ittach (t-gadii)

--*/

#include "stdh.h"
#include "qmperf.h"
#include "perfdata.h"

#include "qmperf.tmh"

static WCHAR *s_FN=L"qmperf";


//
// The PerfApp object is the interface between the QM and the performance dll.
// It is used here to get a pointer to the performance counters block, and store it
// in g_pqmCounter
//


__declspec(dllexport) CPerf PerfApp(ObjectArray, dwPerfObjectsCount);


/*====================================================
RoutineName: QMPerfInit

Arguments: None

Return Value: True if successfull. False otherwise.

Initialize the shared memory and put a pointer to it in
pqmCounters.
=====================================================*/
BOOL QMPrfInit()
{
    if (!PerfApp.InitPerf())
        return LogBOOL(FALSE, s_FN, 10);

    PerfApp.ValidateObject(PERF_QM_OBJECT);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qmras.h ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:
    qmras.h

Abstract:
    Handle RAS connections

Author:
    Doron Juster  (DoronJ)

--*/

#ifndef  __QMRAS_H_
#define  __QMRAS_H_

#include "ras.h"
#include "qmutil.h"

#include <winsock.h>
#include <nspapi.h>

HRESULT InitRAS() ;
HRESULT InitRAS2() ;

typedef enum _CFGSTAT
{
   NOT_RECOGNIZED_YET,
   RECOGNIZED,
   IP_NEW_SERVER,
   IP_NEW_CLIENT,
   NOT_FALCON_IP,
} CFGSTAT ;

typedef struct _RAS_CLI_IP_ADDRESS
{
    ULONG   ulMyIPAddress ;
    ULONG   ulMyOldIPAddress ;
    ULONG   ulServerIPAddress ;
    CFGSTAT eConfigured ;
    //
    // "eConfigured" is set RECOGNIZED after the automatic recognition
    // algorithm find a CN for it.
    //
    BOOL  fOnline ;
    BOOL  fHandled ;
    //
    // "fHandled" is used to determine if any line changed state (from
    // online to offline and vice-versa).
    // It is used only while enumerating the RAS lines.
    //
} RAS_CLI_IP_ADDRESS ;

typedef CList<RAS_CLI_IP_ADDRESS*,  RAS_CLI_IP_ADDRESS*&>  CRasCliIPList;

class  CRasCliConfig
{
   public:
      CRasCliConfig() ;
      ~CRasCliConfig() ;

      BOOL  Add(RASPPPIPA  *pRasIpAddr) ;
      BOOL  CheckChangedLines() ;
      void  UpdateMQIS() ;

      BOOL  IsRasIP(ULONG ulIpAddr, ULONG *pServerIp) ;

   private:
      CRasCliIPList*   m_pCliIPList ;
} ;

#endif //  __QMRAS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qmpkt.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    qmpkt.cpp

Abstract:

    Handle packet in QM side

Author:

    Uri Habusha  (urih)


--*/
#include "stdh.h"

#include "qmpkt.h"
#include "phintr.h"
#include "ac.h"
#include "cqmgr.h"
#include "qmsecutl.h"
#include <mqsec.h>

#include "qmpkt.tmh"

extern BOOL g_fRejectEnhRC2WithLen40 ;

static WCHAR *s_FN=L"qmpkt";

extern HRESULT GetDstQueueObject(
    CQmPacket* pPkt,
    CQueue** ppQueue,
    bool     fInReceive);


/*===========================================================

  Routine Name: CQmPacket::CQmPacket

  Description:  CQmPacket constructor

  Arguments:

  Return Value:

=============================================================*/
CQmPacket::CQmPacket(CBaseHeader *pPkt,
					 CPacket *pDriverPkt,
					 bool ValidityCheck /* = FALSE */):
                m_pDriverPacket(pDriverPkt),
			    m_pBasicHeader(pPkt),
                m_pcUserMsg(NULL),
				m_pXactSection(NULL),
                m_pSecuritySection(NULL),
				m_pcMsgProperty(NULL),
				m_pDbgPkt(NULL),
				m_pDestinationMqfHeader(NULL),
				m_pAdminMqfHeader(NULL),
				m_pResponseMqfHeader(NULL),
				m_pMqfSignatureHeader(NULL),
				m_pSrmpEnvelopeHeader(NULL),
				m_pCompoundMessageHeader(NULL),
				m_pEodHeader(NULL),
				m_pEodAckHeader(NULL),
				m_pSoapHeaderSection(NULL),
				m_pSoapBodySection(NULL),
 				m_pSessPkt(NULL)

{
    PCHAR pSection;

	PCHAR PacketEnd = m_pBasicHeader->GetPacketEnd();
	if (ValidityCheck)
	{
		m_pBasicHeader->SectionIsValid(QueueMgr.GetMessageSizeLimit());
	}

    pSection = m_pBasicHeader->GetNextSection();
	

    if (m_pBasicHeader->GetType() == FALCON_USER_PACKET)
    {
        //
        // User Packet
        //
    	m_pcUserMsg = section_cast<CUserHeader*>(pSection);
   		if (ValidityCheck)
		{
			m_pcUserMsg->SectionIsValid(PacketEnd);
		}
	    pSection = m_pcUserMsg->GetNextSection();

        //
        // Xact Section
        //
        if (m_pcUserMsg->IsOrdered())
        {
            m_pXactSection = section_cast<CXactHeader*>(pSection);
			if (ValidityCheck)
			{
				m_pXactSection->SectionIsValid(PacketEnd);
			}
            pSection = m_pXactSection->GetNextSection();
        }

        //
        // Security Section
        //
        if (m_pcUserMsg->SecurityIsIncluded())
        {
            m_pSecuritySection = section_cast<CSecurityHeader*>(pSection);
			if (ValidityCheck)
			{
				m_pSecuritySection->SectionIsValid(PacketEnd);
			}
            pSection = m_pSecuritySection->GetNextSection();
        }


        //
        // Message propery section
        //
        m_pcMsgProperty = section_cast<CPropertyHeader*>(pSection);
		if (ValidityCheck)
		{
			m_pcMsgProperty->SectionIsValid(PacketEnd);
		}
        pSection = m_pcMsgProperty->GetNextSection();

        //
        // Debug Section
        //
        if (m_pBasicHeader->DebugIsIncluded())
        {
            m_pDbgPkt = section_cast<CDebugSection*>(pSection);
			if(ValidityCheck)
			{
				m_pDbgPkt->SectionIsValid(PacketEnd);
			}
            pSection = m_pDbgPkt->GetNextSection();
        }

        //
        // MQF sections: Destination, Admin, Response, Signature.
        // When MQF is included, the Debug section must be included too,
        // to prevent reporting QMs 1.0/2.0 to append their Debug section.
        //
        if (m_pcUserMsg->MqfIsIncluded())
        {
			if(ValidityCheck && !m_pBasicHeader->DebugIsIncluded())
			{
		        ReportAndThrow("Debug section is not included while MQF included");
			}

            m_pDestinationMqfHeader = section_cast<CBaseMqfHeader*>(pSection);
			if (ValidityCheck)
			{
				m_pDestinationMqfHeader->SectionIsValid(PacketEnd);
			}
            pSection = m_pDestinationMqfHeader->GetNextSection();

            m_pAdminMqfHeader = section_cast<CBaseMqfHeader*>(pSection);
			if (ValidityCheck)
			{
				m_pAdminMqfHeader->SectionIsValid(PacketEnd);
			}
            pSection = m_pAdminMqfHeader->GetNextSection();

            m_pResponseMqfHeader = section_cast<CBaseMqfHeader*>(pSection);
			if (ValidityCheck)
			{
				m_pResponseMqfHeader->SectionIsValid(PacketEnd);
			}
            pSection = m_pResponseMqfHeader->GetNextSection();

			m_pMqfSignatureHeader = section_cast<CMqfSignatureHeader*>(pSection);
			if (ValidityCheck)
			{
				m_pMqfSignatureHeader->SectionIsValid(PacketEnd);
			}
			pSection = m_pMqfSignatureHeader->GetNextSection();
        }
        //
        // SRMP sections: Envelope, CompoundMessage
        //
        if (m_pcUserMsg->SrmpIsIncluded())
        {
            m_pSrmpEnvelopeHeader = section_cast<CSrmpEnvelopeHeader*>(pSection);
            pSection = m_pSrmpEnvelopeHeader->GetNextSection();

            m_pCompoundMessageHeader = section_cast<CCompoundMessageHeader*>(pSection);
            pSection = m_pCompoundMessageHeader->GetNextSection();
        }
        //
        // EOD section
        //
        if (m_pcUserMsg->EodIsIncluded())
        {
            m_pEodHeader = section_cast<CEodHeader*>(pSection);
            pSection = m_pEodHeader->GetNextSection();
        }
        //
        // EOD-ACK section
        //
        if (m_pcUserMsg->EodAckIsIncluded())
        {
            m_pEodAckHeader = section_cast<CEodAckHeader*>(pSection);
            pSection = m_pEodAckHeader->GetNextSection();
        }

		//
		// SOAP sections
		//
		if (m_pcUserMsg->SoapIsIncluded())
		{
			m_pSoapHeaderSection = section_cast<CSoapSection*>(pSection);
            pSection = m_pSoapHeaderSection->GetNextSection();

			m_pSoapBodySection = section_cast<CSoapSection*>(pSection);
            pSection = m_pSoapBodySection->GetNextSection();
		}

        //
        // Session Section
        //
        if (m_pBasicHeader->SessionIsIncluded())
        {
            m_pSessPkt = section_cast<CSessionSection*>(pSection);
        }
    }

	if (ValidityCheck)
	{
		PacketIsValid();
	}
}

/*===========================================================

  Routine Name: CQmPacket::CreateAck

  Description:  Create Ack packet and PUT it in admin queue

  Arguments:

  Return Value:

=============================================================*/
void CQmPacket::CreateAck(USHORT wAckValue)
{
    //
    //  The class must match the user required acknowledgement
    //
    ASSERT(MQCLASS_MATCH_ACKNOWLEDGMENT(wAckValue, GetAckType()));

    //
    // Admin queue may exist on the packet
    //
    QUEUE_FORMAT  AdminQueueFormat;
    BOOL fOldStyleAdminQueue = GetAdminQueue(&AdminQueueFormat);

    if (!fOldStyleAdminQueue)
    {
        return;
    }

    //
    // Old-style destination queue always exists on the packet.
    //
    QUEUE_FORMAT DestinationQueueFormat;
    BOOL fOldStyleDestinationQueue = GetDestinationQueue(&DestinationQueueFormat);
    ASSERT(fOldStyleDestinationQueue);
	DBG_USED(fOldStyleDestinationQueue);

    //
    // Create Message property on stack
    //
    CMessageProperty MsgProperty(this);
    MsgProperty.wClass = wAckValue;
    MsgProperty.bAcknowledge = MQMSG_ACKNOWLEDGMENT_NONE;
    MsgProperty.dwTimeToQueue = INFINITE;
    MsgProperty.dwTimeToLive = INFINITE;
    MsgProperty.pSignature = NULL;  // ACKs are non-authenticated.
    MsgProperty.ulSignatureSize = 0;
    MsgProperty.ulSymmKeysSize = 0;
    MsgProperty.bAuditing = DEFAULT_M_JOURNAL;

    //
    // Update the correlation field to hold the original packet ID
    //
    delete MsgProperty.pCorrelationID;
    MsgProperty.pCorrelationID = (PUCHAR) MsgProperty.pMessageID;
    MsgProperty.pMessageID = NULL;

    if (!MQCLASS_NACK(wAckValue) ||
        (MsgProperty.ulPrivLevel != MQMSG_PRIV_LEVEL_NONE))
    {

        //
        // For ACK message don't include the message body
        // Also, for NACK of encrypted messages, we do not
        // include the body.
        //
        MsgProperty.dwBodySize = 0;
        MsgProperty.dwAllocBodySize = 0;
        MsgProperty.dwBodyType = 0;

		//
		// Set the message as encrypted, otherwise when sending to direct
		// format name, the AC will fail the operation (encryption isn't supported
		// with direct format name.
		//		Uri Habusha, 4-Dec-200 (bug# 6070)
		//
        MsgProperty.bEncrypted = (MsgProperty.ulPrivLevel != MQMSG_PRIV_LEVEL_NONE);
   }

    HRESULT hr = QueueMgr.SendPacket(
                     &MsgProperty,
                     &AdminQueueFormat,
                     1,
                     NULL,
                     &DestinationQueueFormat
                     );
    ASSERT(hr != STATUS_RETRY) ;
	DBG_USED(hr);

} // CQmPacket::CreateAck


/*===========================================================

  Routine Name: CQmPacket::GetSymmKey

  Description:  Returns the Symmetric key of the destination

  Arguments:

  Return Value:

=============================================================*/
HRESULT
CQmPacket::GetDestSymmKey(HCRYPTKEY *phSymmKey,
                          BYTE     **ppEncSymmKey,
                          DWORD     *pdwEncSymmKeyLen,
                          PVOID     *ppQMCryptInfo)
{
    ASSERT(IsBodyInc() && !IsEncrypted()) ;
    ASSERT(GetPrivBaseLevel() == MQMSG_PRIV_LEVEL_BODY_BASE);

    enum enumProvider eProvider = eBaseProvider ;
    if (GetPrivLevel() == MQMSG_PRIV_LEVEL_BODY_ENHANCED)
    {
        eProvider = eEnhancedProvider ;
    }
    HCRYPTPROV hProvQM = NULL ;
    HRESULT hr = MQSec_AcquireCryptoProvider( eProvider,
                                             &hProvQM ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 10);
    }

    if (!hProvQM)
    {
        // Sorry, the local QM doesn't support encryption.
        return LogHR(MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION, s_FN, 20);
    }

    const GUID *pguidQM = GetDstQMGuid();

    if (*pguidQM == GUID_NULL)
    {
        //
        // The queue was opened when the DS was offline. Therefore the Destination
        // QM is NULL. In such a case we retrive the information from queue object
        //
        CQueue* pQueue;

        //
        // GetDestSymmKey is called only during send
        //
        GetDstQueueObject(this, &pQueue, false);
        pguidQM = pQueue->GetMachineQMGuid();
        pQueue->Release();
        ASSERT(*pguidQM != GUID_NULL);
    }

    // Get the encrypted symmetric key for the destination QM.
    switch(GetEncryptAlg())
    {
    case CALG_RC4:
        hr = GetSendQMSymmKeyRC4(pguidQM,
                                 eProvider,
                                 phSymmKey,
                                 ppEncSymmKey,
                                 pdwEncSymmKeyLen,
                                 (CCacheValue **)ppQMCryptInfo);
        break;
    case CALG_RC2:
        hr = GetSendQMSymmKeyRC2(pguidQM,
                                 eProvider,
                                 phSymmKey,
                                 ppEncSymmKey,
                                 pdwEncSymmKeyLen,
                                 (CCacheValue **)ppQMCryptInfo);
        break;
    default:
        ASSERT(0);
        break;
    }

    return LogHR(hr, s_FN, 30);

}

/*===========================================================

  Routine Name: CQmPacket::Encrypt

  Description:  Encrypt the message body.

  Arguments:

  Return Value:

=============================================================*/
HRESULT
CQmPacket::EncryptExpressPkt(IN HCRYPTKEY hKey,
                             IN BYTE *pbSymmKey,
                             IN DWORD dwSymmKeyLen
                            )
{

    // write the symmetric key in the message packet.
    SetEncryptedSymmetricKey(pbSymmKey, (USHORT)dwSymmKeyLen);

    DWORD dwPacketSize;
    const UCHAR *pPacket = GetPacketBody(&dwPacketSize);
    DWORD dwAllocBodySize = GetAllocBodySize();

    // Encrypt the message body.
    if (!CryptEncrypt(
            hKey,
            NULL,
            TRUE,
            0,
            const_cast<BYTE *>(pPacket),
            &dwPacketSize,
            dwAllocBodySize))
    {
        DWORD gle = GetLastError();
        DBGMSG((DBGMOD_QM,
                DBGLVL_ERROR,
                TEXT("Message encryption failed. Error %d"), gle));
        LogNTStatus(gle, s_FN, 40);
        return MQ_ERROR_CORRUPTED_SECURITY_DATA;
    }

    // Update the message body size. The message body size may be changed
    // when using a block cypher.
    SetBodySize(dwPacketSize);
    SetEncrypted(TRUE);

    return(MQ_OK);
}


/*===========================================================

  Routine Name: CQmPacket::Dencrypt

  Description:  Dencrypt the message body.

  Arguments:

  Return Value:

=============================================================*/
HRESULT
CQmPacket::Decrypt(void)
{
    if ((GetPrivLevel() == MQMSG_PRIV_LEVEL_NONE) ||
        !IsBodyInc())
    {
        // The message is not encrypted. Get out of here.
        if (IsSecurInc())
        {
            SetEncrypted(FALSE); // NACKs for encrypted messages arrived with
                                 // no message body, but the "encrypted" flag
                                 // is set. So clear here the "encrypted" bit.
        }
        return(MQ_OK);
    }
	if (!IsEncrypted())
	{
        TrERROR(GENERAL, "IsEncrypted != GetPrivLevel");
		throw exception();
	}

    enum enumProvider eProvider = eBaseProvider ;
    HRESULT hrDefault = MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION ;

    if (GetPrivLevel() == MQMSG_PRIV_LEVEL_BODY_ENHANCED)
    {
        eProvider = eEnhancedProvider ;
        hrDefault = MQ_ERROR_ENCRYPTION_PROVIDER_NOT_SUPPORTED ;
    }

    HCRYPTPROV hProvQM = NULL ;
    HRESULT hr = MQSec_AcquireCryptoProvider( eProvider,
                                             &hProvQM ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 50);
    }

    if (!hProvQM)
    {
        // Sorry, the QM doesn't support encryption.
        return LogHR(hrDefault, s_FN, 60);
    }

    const GUID *pguidQM = GetSrcQMGuid();
    DWORD dwBodySize;
    const UCHAR *pBody = GetPacketBody(&dwBodySize);
    DWORD dwSymmKeyLen = 0;
    const BYTE *pbSymmKey = GetEncryptedSymmetricKey((PUSHORT)&dwSymmKeyLen);
    HCRYPTKEY hKey = 0;
    R<CCacheValue> pCacheValue;

    BOOL fNewKey = FALSE ;

    // Get the symmetric key either from the key blob from the message packet,
    // or from the cached keys.
    switch(GetEncryptAlg())
    {
    case CALG_RC4:
        hr = GetRecQMSymmKeyRC4( pguidQM,
                                 eProvider,
                                 &hKey,
                                 pbSymmKey,
                                 dwSymmKeyLen,
                                 &pCacheValue.ref() );
        break;
    case CALG_RC2:
        hr = GetRecQMSymmKeyRC2( pguidQM,
                                 eProvider,
                                 &hKey,
                                 pbSymmKey,
                                 dwSymmKeyLen,
                                 &pCacheValue.ref(),
                                 &fNewKey );
        break;
    default:
        return LogHR(MQ_ERROR_ENCRYPTION_PROVIDER_NOT_SUPPORTED, s_FN, 65);
    }

    if (FAILED(hr))
    {
        // We received a corrupted symmetric key, drop the message.
        return LogHR(hr, s_FN, 70);
    }

    BOOL fTry40 = FALSE ;
    AP<BYTE> pTmpBuf = NULL ;

    if (fNewKey                          &&
        (eProvider == eEnhancedProvider) &&
        (GetEncryptAlg() == CALG_RC2)    &&
          !g_fRejectEnhRC2WithLen40)
    {
        //
        // Windows bug 562586.
        // If decryption fail (for RC2 enhanced) then set effective
        // length of key to 40 bits and try again.
        // Save body buffer, to be reused for second decryption.
        // that's need because the body buffer is overwritten in-place by
        // CryptDecrypt, even when it fail.
        //
        fTry40 = TRUE ;
        pTmpBuf = new BYTE[ dwBodySize ] ;
        memcpy(pTmpBuf, pBody, dwBodySize) ;
    }

    // Decrypt the message body.
    if (!CryptDecrypt(
            hKey,
            NULL,
            TRUE,
            0,
            const_cast<BYTE *>(pBody),
            &dwBodySize))
    {
        BOOL fDecrypt = FALSE ;

        if (fTry40)
        {
            //
            // New symmetric key. Set length to 40 bits and try again
            // to decrypt the body. Use the backup of body buffer.
            //
            const DWORD x_dwEffectiveLength = 40 ;

            if (!CryptSetKeyParam( hKey,
                                   KP_EFFECTIVE_KEYLEN,
                                   (BYTE*) &x_dwEffectiveLength,
                                   0 ))
            {
        	    DWORD gle = GetLastError();
			    TrERROR(SECURITY, "Failed to set enhanced RC2 key len to 40 bits, gle = %!winerr!", gle);
                return MQ_ERROR_CORRUPTED_SECURITY_DATA;
            }

            pBody = GetPacketBody(&dwBodySize);
            memcpy(const_cast<BYTE *>(pBody), pTmpBuf, dwBodySize) ;

            fDecrypt = CryptDecrypt( hKey,
                                     NULL,
                                     TRUE,
                                     0,
                                     const_cast<BYTE *>(pBody),
                                    &dwBodySize) ;
        }

        if (!fDecrypt)
        {
            // We receive a corrupted message.
	    	DWORD gle = GetLastError();
		    TrERROR(SECURITY, "CryptDecrypt() failed, gle = 0x%x", gle);
            return MQ_ERROR_CORRUPTED_SECURITY_DATA;
        }
    }

    // Update the message body size. The message body size may get modified
    // when using a block cypher.
    SetBodySize(dwBodySize);
    SetEncrypted(FALSE);

    return(MQ_OK);
}

//
// CMessageProperty constructor
//
CMessageProperty::CMessageProperty(CQmPacket* pPkt)
{
    P<OBJECTID> pMessageId = new OBJECTID;
    AP<UCHAR> pCorrelationId = new UCHAR[PROPID_M_CORRELATIONID_SIZE];

    pPkt->GetMessageId(pMessageId);
    pPkt->GetCorrelation(pCorrelationId);

    wClass          = pPkt->GetClass();
    dwTimeToQueue   = INFINITE;
    dwTimeToLive    = INFINITE;
    pMessageID      = pMessageId;
    pCorrelationID  = pCorrelationId;
    bPriority       = (UCHAR)pPkt->GetPriority();
    bDelivery       = (UCHAR)pPkt->GetDeliveryMode();
    bAcknowledge    = pPkt->GetAckType();
    bAuditing       = (UCHAR)pPkt->GetAuditingMode();
    bTrace          = (UCHAR)pPkt->GetTrace();
    dwApplicationTag= pPkt->GetApplicationTag();
    pBody           = pPkt->GetPacketBody(&dwBodySize);
    dwAllocBodySize = pPkt->IsSrmpIncluded() ? dwBodySize : pPkt->GetAllocBodySize();
    dwBodyType      = pPkt->GetBodyType();
    pTitle          = pPkt->GetTitlePtr();
    dwTitleSize     = pPkt->GetTitleLength();
    pMsgExtension   = pPkt->GetMsgExtensionPtr();
    dwMsgExtensionSize = pPkt->GetMsgExtensionSize();
    pSenderID       = pPkt->GetSenderID(&uSenderIDLen);
    ulSenderIDType  = pPkt->GetSenderIDType();
    pSenderCert     = pPkt->GetSenderCert(&ulSenderCertLen);

    USHORT usTemp;
    pSignature      = pPkt->GetSignature(&usTemp);
    ulSignatureSize = usTemp;
    pSymmKeys       = pPkt->GetEncryptedSymmetricKey(&usTemp);
    ulSymmKeysSize  = usTemp;
    bEncrypted      = (UCHAR)pPkt->IsEncrypted();
    ulPrivLevel     = pPkt->GetPrivLevel();
    ulHashAlg       = pPkt->GetHashAlg();
    ulEncryptAlg    = pPkt->GetEncryptAlg();
    bAuthenticated  = (UCHAR)pPkt->IsAuthenticated();
    bConnector      = (UCHAR)pPkt->ConnectorTypeIsIncluded();

	if(pPkt->IsEodAckIncluded())
	{
		pEodAckStreamId = pPkt->GetPointerToEodAckStreamId();
		EodAckStreamIdSizeInBytes = pPkt->GetEodAckStreamIdSizeInBytes();
		EodAckSeqId = pPkt->GetEodAckSeqId();
		EodAckSeqNum = pPkt->GetEodAckSeqNum();
	}
	else
    {
		pEodAckStreamId = NULL;
		EodAckStreamIdSizeInBytes = 0;
		EodAckSeqId = 0;
		EodAckSeqNum = 0;
	}

    if (ulSignatureSize)
    {
        BOOL bPktDefProv;

        pPkt->GetProvInfo(&bPktDefProv, &wszProvName, &ulProvType);
        bDefProv = (UCHAR)bPktDefProv;
    }
    else
    {
        bDefProv = TRUE;
        wszProvName = NULL;
    }

    //
    // store indication that the class was generated from packet
    //
    fCreatedFromPacket = TRUE;

	pMessageId.detach();
	pCorrelationId.detach();
}

//
// CMessageProperty constructor for acking generation
//
CMessageProperty::CMessageProperty(USHORT usClass,
                                   PUCHAR pCorrelationId,
                                   USHORT usPriority,
                                   UCHAR  ucDelivery)
{
    memset(this, 0, sizeof(CMessageProperty));

    if (pCorrelationId)
    {
        pCorrelationID = new UCHAR[PROPID_M_CORRELATIONID_SIZE];
        ASSERT(pCorrelationID);
        memcpy(pCorrelationID, pCorrelationId, PROPID_M_CORRELATIONID_SIZE);
    }

    wClass          = usClass;
    dwTimeToQueue   = INFINITE;
    dwTimeToLive    = INFINITE;
    bPriority       = (UCHAR)usPriority;
    bDelivery       = ucDelivery;

    //
    // store indication that the the memory was allocated
    //
    fCreatedFromPacket = TRUE;
}

// Saves the changed header persistently
HRESULT CQmPacket::Save()
{
    // NYI
    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qmras.cpp ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:
    qmras.cpp

Abstract:
    Handle RAS connections

Author:
    Doron Juster  (DoronJ)

--*/

#include "stdh.h"
#include "cqmgr.h"
#include "qmras.h"
#include "raserror.h"

#include "qmras.tmh"

#define  RASENUMINTERVAL95  60
//
// From ras.h for Winnt4.0.
// Not available in VC++ 4.1
//
#define RASCN_Connection        0x00000001
#define RASCN_Disconnection     0x00000002

#define  RAS_SERVICE_NAME1  TEXT("RasAuto")
#define  RAS_SERVICE_NAME2  TEXT("RasMan")

#define RAS_INIT         0
#define RAS_RESOLUTION   1
#define RAS_NOTIFICATION 2
#define RAS_POLLING      3

extern BOOL g_fQMRunMode;

static WCHAR *s_FN=L"qmras";

//
// Define prototypes of RAS apis, for calling getProcAddress
//
typedef DWORD (APIENTRY *RasConnectionNotification_ROUTINE)
(  HANDLE, HANDLE, DWORD dwFlags );
RasConnectionNotification_ROUTINE  g_pfnRasConnectionNotification = NULL ;

typedef DWORD (APIENTRY *RasEnumConnections_ROUTINE)
( LPRASCONNA, LPDWORD, LPDWORD ) ;
RasEnumConnections_ROUTINE g_pfnRasEnumConnections = NULL ;

typedef DWORD (APIENTRY *RasGetProjectionInfo_ROUTINE)
( HRASCONN, RASPROJECTION, LPVOID, LPDWORD );
RasGetProjectionInfo_ROUTINE g_pfnRasGetProjectionInfo = NULL ;

//
// Global Variables
//
HINSTANCE  g_hRasDll   = NULL ;
HANDLE     g_hRASEvent = NULL ;
CRasCliConfig *g_pRasCliConfig = NULL ;
CCriticalSection  CfgRasCS ;

//***************************************************************
//
//
//***************************************************************

DWORD  DetermineRASConfiguration(void *pvoid, DWORD dwOption)
{
   CS Lock(CfgRasCS) ;
   ASSERT(g_pRasCliConfig) ;

   RASCONNA sRasConn ;
   AP<RASCONNA> pRasConn = NULL ;
   DWORD    dwRasSize = 0 ;
   DWORD    dwcConns  = 0 ;

   //
   // Get the available connections.
   // First determine how many connections are active.
   //
   sRasConn.dwSize = sizeof(RASCONNA) ;
   DWORD dwEnum = (*g_pfnRasEnumConnections) ( &sRasConn,
                                               &dwRasSize,
                                               &dwcConns ) ;
   if ((dwEnum == ERROR_BUFFER_TOO_SMALL) && (dwcConns > 0))
   {
      //
      // We allocate one more element than necessary and initialize the
      // size of all elements and call the A version to workaround a bug
      // in NT implementation of RasEnumConnections. (anyway, for Win95
      // we need the A version).
      //
      pRasConn = new RASCONNA[ dwcConns + 1 ] ;
      for ( DWORD j = 0 ; j <= dwcConns ; j++ )
      {
         pRasConn[j].dwSize = sizeof(RASCONNA) ;
      }
      dwRasSize = sizeof(RASCONNA) * dwcConns ;
      DWORD dwOldConns = dwcConns ;
      dwcConns = 0 ;
      dwEnum = (*g_pfnRasEnumConnections) ( pRasConn,
                                            &dwRasSize,
                                            &dwcConns ) ;
      ASSERT((dwEnum == 0) && (dwcConns == dwOldConns)) ;
	  DBG_USED(dwOldConns);
   }
   else
   {
      return dwEnum ;
   }

   //
   // update the RAS configuration.
   //
   BOOL       fConfigChanged = FALSE ;
   RASPPPIPA  sRasIp ;
   DWORD      dwIpSize = sizeof(RASPPPIPA) ;
   BOOL       fAdd ;

   while (dwcConns > 0)
   {
      //
      // Check for IP address
      //
      sRasIp.dwSize = dwIpSize ;
      DWORD dwProj = (*g_pfnRasGetProjectionInfo)
                                  ( pRasConn[ dwcConns-1 ].hrasconn,
                                    RASP_PppIp,
                                    &sRasIp,
                                    &dwIpSize ) ;
      if (dwProj == 0)
      {
         fAdd = g_pRasCliConfig->Add(&sRasIp) ;
         if (!fConfigChanged)
         {
            fConfigChanged = fAdd ;
         }
      }


      dwcConns-- ;
   }

   BOOL fLineChanged = g_pRasCliConfig->CheckChangedLines() ;

   if (dwOption == RAS_NOTIFICATION || dwOption == RAS_POLLING)
   {
	   if (fConfigChanged || fLineChanged)
	   {
		  g_pRasCliConfig->UpdateMQIS() ;
	   }
   }


   return 0 ;
}

//***************************************************************
//
//  DWORD WINAPI RASNotificationThread(LPVOID pV)
//
//  RAS monitoring thread.
//
//***************************************************************
DWORD WINAPI RASNotificationThread(LPVOID pV)
{
    BOOL fSecondPartOfRasInitWasPerformed = (BOOL)(INT_PTR_TO_INT(pV));
    
    if ( !fSecondPartOfRasInitWasPerformed)
    {
        while ( !g_fQMRunMode)
        {
            Sleep( 5000);
        }
        //
        //   The service init stage has completed.
        //   It is o.k. to try and load rasapi32
        //   ( and start the rasman service)
        //
        HRESULT hr = InitRAS2();
        if (FAILED(hr) || (hr == MQ_INFORMATION_RAS_NOT_AVAILABLE))
        {
            return 0;
        }
    }
    ASSERT(g_hRASEvent) ;
    
    while (TRUE)
    {
        DWORD dwObjectIndex = WaitForSingleObject(g_hRASEvent, INFINITE);
        
        ASSERT(dwObjectIndex == WAIT_OBJECT_0);
		DBG_USED(dwObjectIndex);

        //
        // TODO: erezh, we where waiting here previously for topology to complete.
        //
        
        DetermineRASConfiguration(0, RAS_NOTIFICATION) ;
    }
    
    return 0 ;
}


//***************************************************************
//
//  HRESULT InitRAS()
//
//***************************************************************
static LONG s_fRasInitialized = FALSE;

HRESULT InitRAS()
{
    #ifdef _DEBUG
        LONG fRasAlreadyInitialized = InterlockedExchange(&s_fRasInitialized, TRUE);
        ASSERT(!fRasAlreadyInitialized);
    #endif


   HANDLE hThread = NULL ;
   HRESULT  hr = MQ_OK ;
   BOOL  fRasServerIsRunning = FALSE;

   //
   // Check if the RAS service is running.
   //
   SC_HANDLE hServiceCtrlMgr = OpenSCManager( NULL,
                                              NULL,
                                              SC_MANAGER_ALL_ACCESS ) ;
   if (hServiceCtrlMgr)
   {
      SC_HANDLE hService = OpenService( hServiceCtrlMgr,
                                        RAS_SERVICE_NAME2,
            									 SERVICE_QUERY_STATUS) ;
      if (!hService)
      {
         //
         // Try the other RAS service
         //
         hService = OpenService( hServiceCtrlMgr,
                                 RAS_SERVICE_NAME1,
            							SERVICE_QUERY_STATUS) ;
      }
      CloseServiceHandle(hServiceCtrlMgr) ;
      if (hService)
      {
         SERVICE_STATUS srvStatus;
         //
         // Find out if the service is running
         //
         if ( QueryServiceStatus( hService,
                                  &srvStatus))
         {
             if ( srvStatus.dwCurrentState == SERVICE_RUNNING)
             {
                fRasServerIsRunning = TRUE;
             }
         }
         CloseServiceHandle(hService) ;
      }
      else
      {
#ifdef _DEBUG
         DWORD dwErr = GetLastError() ;
         DBGMSG((DBGMOD_QM, DBGLVL_TRACE,
            TEXT("InitRAS(): RAS not available on this machine (%lut)"), dwErr)) ;
#endif
         //
         // RAS service not active on this machine
         //
         return MQ_OK ;
      }
   }
   else
   {
      //
      // It's an error if we can't open the service manager
      //
      hr = MQ_ERROR ;
      return LogHR(hr, s_FN, 10) ;
   }

   //
   //   If RAS server is running, continue initialization.
   //
   //   Else postponed the rest of the initialization for a while ( NT only).
   //   The reason for postponding is : on boot load of rasapi32.dll tries to
   //   start the RAS service and fails to do so because the QM service is
   //   starting.
   //   In this case RASNotificationThread will call InitRAS2 after a delay
   //
   if  ( fRasServerIsRunning)
   {
        hr = InitRAS2();
        if (hr == MQ_INFORMATION_RAS_NOT_AVAILABLE)
        {
            return MQ_OK ;
        }
   }

   //
   // Now create the thread which will wait on this event
   //
   DWORD dwID ;
   hThread = CreateThread( NULL,
                           0,
                           RASNotificationThread,
                           (void *)(ULONG_PTR)fRasServerIsRunning,
                           0,
                           &dwID ) ;
   ASSERT(hThread) ;
   if (hThread)
   {
      CloseHandle(hThread) ;
   }
   else
   {
      hr = MQ_ERROR_INSUFFICIENT_RESOURCES ;
   }


   return LogHR(hr, s_FN, 20);
}

HRESULT InitRAS2()
{
   HRESULT hr = MQ_OK ;
   DWORD dwRas ;
   //
   // Try to load the ras dll.
   // Note: we can't staticly link with the ras dll because the QM will
   //       fail to start if RAS service is not active.
   //
   g_hRasDll = LoadLibrary(TEXT("rasapi32.dll")) ;
   if (!g_hRasDll)
   {
      //
      // Bad configuration of the machine. The service is available
      // but we can't load the ras dll.
      // This is an error.
      //
      hr =  MQ_ERROR ;
      goto failRAS ;
   }

   //
   // Get addresses of relevant RAS apis.
   //
   g_pfnRasConnectionNotification = (RasConnectionNotification_ROUTINE)
                          GetProcAddress( g_hRasDll,
                                          "RasConnectionNotificationW" ) ;

   g_pfnRasEnumConnections = (RasEnumConnections_ROUTINE)
                          GetProcAddress( g_hRasDll,
                                          "RasEnumConnectionsA" ) ;

   g_pfnRasGetProjectionInfo = (RasGetProjectionInfo_ROUTINE)
                          GetProcAddress( g_hRasDll,
                                        "RasGetProjectionInfoA" ) ;
   //
   // note: we use the Ansi projection api, to get ansi strings for
   //       passing them to the winsock apis.
   //

   if ((g_pfnRasEnumConnections == NULL)         ||
       (g_pfnRasConnectionNotification == NULL)  ||
       (g_pfnRasGetProjectionInfo == NULL))
   {
      //
      // Can't find the api we need.
      //
      hr = MQ_ERROR ;
      goto failRAS ;
   }

   g_pRasCliConfig = new CRasCliConfig ;

   dwRas = DetermineRASConfiguration(0, RAS_INIT) ;
   if (dwRas == ERROR_RASMAN_CANNOT_INITIALIZE)
   {
      //
      // RAS Services are active but RAS "adapters" are disabled.
      // Return OK, but cleanup everything, since we don't have RAS.
      // This is legal case where user diabled the "ras" adapters but
      // didn't remove the ras service.
      //
      hr = MQ_INFORMATION_RAS_NOT_AVAILABLE ;
      goto failRAS ;
   }

   //
   // Create the event for RAS notification.
   // At present (Q4-1996), RAS notifications are not available on Win95.
   //
   g_hRASEvent = CreateEvent( NULL,
                              FALSE,   // Auto Reset
                              FALSE,   // initially signalled
                              NULL ) ;
   if (!g_hRASEvent)
   {
      //
      // Can't create event. Error
      //
      hr = MQ_ERROR_INSUFFICIENT_RESOURCES ;
      goto failRAS ;
   }

   dwRas = (*g_pfnRasConnectionNotification) (
                           INVALID_HANDLE_VALUE,
                           g_hRASEvent,
                           (RASCN_Connection | RASCN_Disconnection)) ;
   if (dwRas)
   {
      //
      // Error in RAS notification
      //
      hr = MQ_ERROR ;
      goto failRAS ;
   }


   DBGMSG((DBGMOD_QM, DBGLVL_TRACE,
                           TEXT("Successfully RAS initialization"))) ;
   return MQ_OK ;

   //
   //  FAILURE !
   //
failRAS:
   if (g_hRASEvent)
   {
      CloseHandle(g_hRASEvent) ;
      g_hRASEvent = NULL ;
   }
   if (g_hRasDll)
   {
      FreeLibrary(g_hRasDll) ;
      g_hRasDll = NULL ;
   }
   if (g_pRasCliConfig)
   {
      delete g_pRasCliConfig ;
      g_pRasCliConfig = NULL ;
   }

   DBGMSG((DBGMOD_QM, DBGLVL_ERROR,
                    TEXT("Failed to initialize RAS, hr- %lxh"), hr)) ;
   return LogHR(hr, s_FN, 30);

}

//*********************************************************
//
//  implementation of the  CRasCliConfig  class
//
//*********************************************************

CRasCliConfig::CRasCliConfig() :
    m_pCliIPList(new CRasCliIPList)
{
}

CRasCliConfig::~CRasCliConfig()
{
   //
   // Cleanup IP list
   //
   if (m_pCliIPList)
   {
      POSITION                pos ;
      RAS_CLI_IP_ADDRESS*     pAddr;

      pos = m_pCliIPList->GetHeadPosition();
      while(pos != NULL)
      {
         pAddr = m_pCliIPList->GetNext(pos);
         delete pAddr ;
      }

      delete m_pCliIPList ;
   }
}

//***********************************************************************
//
//  BOOL CRasCliConfig::Add(RASPPPIPA *pRasIpAddr)
//
//  Return TRUE if new ip address or if there was a change in configurtion.
//
//***********************************************************************

BOOL CRasCliConfig::Add(RASPPPIPA *pRasIpAddr)
{
   ASSERT(pRasIpAddr) ;

   ULONG ulMyIp = inet_addr((char *)pRasIpAddr->szIpAddress) ;
   ULONG ulServerIp = inet_addr((char *)pRasIpAddr->szServerIpAddress) ;

   POSITION                pos ;
   RAS_CLI_IP_ADDRESS*     pAddr;

   //
   // First loop check if this address is already in list.
   //
   pos = m_pCliIPList->GetHeadPosition();
   while(pos != NULL)
   {
      pAddr = m_pCliIPList->GetNext(pos);
      if (pAddr->ulMyIPAddress == ulMyIp)
      {
         pAddr->fHandled = TRUE ;
         if (pAddr->ulServerIPAddress == ulServerIp)
         {
            //
            // Already in address list. Do nothing more.
            //
            return FALSE ;
         }
         else
         {
            //
            // changed configuration (new server).
            // This may happen only if client is configured to
            // have a fix ip and it doesn't got it from the RAS server.
            //
            pAddr->ulServerIPAddress = ulServerIp ;
            pAddr->eConfigured = IP_NEW_SERVER ;
            return TRUE ;
         }
      }
   }

   //
   // Second loop check if this address is a new one which should replace
   // an existing address after redialling the RAS server.
   //
   pos = m_pCliIPList->GetHeadPosition();
   while(pos != NULL)
   {
      pAddr = m_pCliIPList->GetNext(pos);
      if ((pAddr->ulServerIPAddress == ulServerIp) &&
          (!pAddr->fHandled))
      {
         //
         // RAS Client connected to same RAS server but after a new dial up
         // connection it got a new IP. Update MQIS database.
         //
         pAddr->fHandled = TRUE ;
         pAddr->ulMyOldIPAddress = pAddr->ulMyIPAddress ;
         pAddr->ulMyIPAddress = ulMyIp ;
         pAddr->eConfigured = IP_NEW_CLIENT ;
         return TRUE ;
      }
   }

   //
   // New entry.
   //
   pAddr = new RAS_CLI_IP_ADDRESS ;
   pAddr->eConfigured = NOT_RECOGNIZED_YET ;
   pAddr->ulMyIPAddress = ulMyIp ;
   pAddr->ulServerIPAddress = ulServerIp ;
   pAddr->ulMyOldIPAddress = 0 ;
   pAddr->fHandled = TRUE ;
   pAddr->fOnline = TRUE ;

   m_pCliIPList->AddTail(pAddr) ;

   return TRUE ;
}


//***********************************************************************
//
//  BOOL CRasCliConfig::CheckChangedLines()
//
//  Return TRUE if an address changed its online/offline state
//
//***********************************************************************

BOOL CRasCliConfig::CheckChangedLines()
{
   POSITION                pos ;
   RAS_CLI_IP_ADDRESS*     pAddr;
   BOOL                    fIPChanged = FALSE ;

   //
   // Check the IP list
   //
   pos = m_pCliIPList->GetHeadPosition();
   while(pos != NULL)
   {
      pAddr = m_pCliIPList->GetNext(pos);
      if (pAddr->fHandled)
      {
         pAddr->fHandled = FALSE ;
         if (!pAddr->fOnline)
         {
            fIPChanged = TRUE ;
         }
         pAddr->fOnline = TRUE ;
      }
      else
      {
         if (pAddr->fOnline)
         {
            fIPChanged = TRUE ;
         }
         pAddr->fOnline = FALSE ;
      }
   }

   return fIPChanged;
}


//***********************************************************************
//
//  void CRasCliConfig::UpdateMQIS()
//
//  Update MQIS database if a line changed status.
//  At present the only update is when a RAS client got a new address
//  after a new dial-up to the SAME RAS server.
//
//***********************************************************************

void CRasCliConfig::UpdateMQIS()
{
    
    //
    // TODO: erezh call update the ds sites if address changed. need to accumulate addresses
    // and then update DS once???
    // check with ronith the algorithm
    //
}

//***********************************************************************
//
//  BOOL CRasCliConfig::IsRasIP(ULONG ulIpAddr)
//
//  Return TRUE if "ulIpAddr" is an IP address on RAS
//
//***********************************************************************

BOOL CRasCliConfig::IsRasIP(ULONG ulIpAddr, ULONG *pServerIp)
{
   ASSERT(ulIpAddr) ;

   CS Lock(CfgRasCS) ;

   POSITION                pos ;
   RAS_CLI_IP_ADDRESS*     pAddr;

   pos = m_pCliIPList->GetHeadPosition();
   while(pos != NULL)
   {
      pAddr = m_pCliIPList->GetNext(pos);
      if (pAddr->ulMyIPAddress == ulIpAddr)
      {
         if (pServerIp)
         {
            *pServerIp = pAddr->ulServerIPAddress ;
         }
         return TRUE ;
      }
   }

   return FALSE ;
}


/*====================================================

void DetermineRASAddresses()

Arguments:

Return Value:

=====================================================*/

BOOL DetermineRASAddresses( IN const CAddressList * pIPAddressList )
{
    if (!g_pRasCliConfig)
    {
       //
       // RAS not available on this machine.
       //
       return FALSE;
    }

	DetermineRASConfiguration(0,RAS_RESOLUTION);

    POSITION     pos ;
    TA_ADDRESS*  pAddr;

    //
    //  IP addresses
    //
    pos = pIPAddressList->GetHeadPosition();
    while(pos != NULL)
    {
        pAddr = pIPAddressList->GetNext(pos);
        DWORD ipaddr ;
        memcpy(&ipaddr, &(pAddr->Address), IP_ADDRESS_LEN) ;
        if (g_pRasCliConfig->IsRasIP( ipaddr, NULL ))
        {
            pAddr->AddressType = IP_RAS_ADDRESS_TYPE ;
        }
    }

	return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qmnotify.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    qmnotify.cpp

Abstract:

    QM notify mechanism.
	
	in MSMQ 1.0 and 2.0, when an msmq client changes the state of an msmq 
	object on the DS, the DS sends a notification to the object's owner QM.

	Now in MSMQ the DS server has been elimintated in favor of using the AD. 
	therefore, when an msmq client changes the state of an msmq object on 
	the DS, it notifies the local QM about it. the local QM will decide
	whether to sych with the DS or send an msmq notification message to the
	object's owner QM.
	Also, since QMs don't trust each other, the recieving QM accesses the DS 
	at a maximum rate of once per 15 minutes, to avoid being voulnerable to 
	denial of service atacks.

Author:
	Extended by Nir Aides (niraides) 13-Jun-2000

--*/

#include "stdh.h"
#include "cqmgr.h"
#include "qmnotify.h"
#include "pnotify.h"
#include "bupdate.h"
#include "regqueue.h"
#include <mqsec.h>
#include "ad.h"
#include <adnotify.h>
#include <privque.h>
#include <mqprops.h>
#include <mqstl.h>
#include "lqs.h"
#include "cqpriv.h"

#include "qmnotify.tmh"

static WCHAR *s_FN=L"qmnotify";

using namespace std;



#define NOTIFICATION_MSG_TIMEOUT (5 * 60) //5 minutes
#define NOTIFICATION_MSG_PRIORITY DEFAULT_M_PRIORITY

//
// Update from DS will be done in intervals of 15 minutes
// to defend against denial of service attacks.
//
static const CTimeDuration xNotificationUpdateDelay = CTimeDuration::OneSecond().Ticks() * 60 * 15; 

//
// If we recieve more then 'xLQSTresholdMagicNumber' notifications in the time interval, 
// we invoke the general LQS cache update.
//
static const DWORD xLQSTresholdMagicNumber = 100;



//
//  Parse a guid string, into guid.
//  Return next char to parse on success, 0 on failure.
//
static VOID ParseGuidString(LPCWSTR p, GUID* pg)
{
    //
    //  N.B. scanf stores the results in an int, no matter what the field size
    //      is. Thus we store the result in tmp variabes.
    //
    int n;
    UINT w2, w3, d[8];
	unsigned long Data1;

	swscanf(
        p,
        GUID_FORMAT L"%n",
        &Data1,
        &w2, &w3,                       //  Data2, Data3
        &d[0], &d[1], &d[2], &d[3],     //  Data4[0..3]
        &d[4], &d[5], &d[6], &d[7],     //  Data4[4..7]
        &n                              //  number of characters scaned
        );
		
	if(n != 36)
    {
		DBGMSG((DBGMOD_QM,DBGLVL_ERROR,TEXT("Failed in ParseGuidString().")));
		LogIllegalPoint(s_FN, 110);
        throw exception();
    }

	pg->Data1 = Data1;
    pg->Data2 = (WORD)w2;
    pg->Data3 = (WORD)w3;
    for(int i = 0; i < 8; i++)
    {
        pg->Data4[i] = (BYTE)d[i];
    }
}



//
// The following two strings are used to for marshaling the notification body,
// in a readable xml-like form.
//
// Guid Format expected to be "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
//

#define QM_NOTIFICATION_INPUT_MARSHALLING_FORMAT \
		L"<Notification>" \
			L"<Event>%d</Event>" \
			L"<ObjectGuid>%40[^<]</ObjectGuid>" \
			L"<DomainController>%260[^<]</DomainController>" \
		L"</Notification>"

#define QM_NOTIFICATION_OUTPUT_MARSHALLING_FORMAT \
		L"<Notification>" \
			L"<Event>%d</Event>" \
			L"<ObjectGuid>" GUID_FORMAT L"</ObjectGuid>" \
			L"<DomainController>%s</DomainController>" \
		L"</Notification>"



//
// This class is used to marshal the notification information inside 
// an msmq message
//
class CNotificationBody
{
public:
	CNotificationBody() : 
		m_Event(neNoEvent)
	{
	}

	CNotificationBody(
		ENotificationEvent Event, 
		const GUID& ObjectGuid,
		LPCWSTR DomainController 
		);

	const WCHAR* MarhshalIn(const WCHAR* pBuffer, long Size);

	//
	// returns the estimated buffer size required for MarshalOut()
	//
	long RequiredWideBufferSize();

	WCHAR* MarshalOut(WCHAR* pBuffer, long Size);

	ENotificationEvent Event() const
	{
		return m_Event;
	}

	const GUID& Guid() const
	{
		return m_ObjectGuid;
	}

	const wstring& DomainController() const
	{
		return m_DomainController;
	}

	VOID DomainController(const wstring& str)
	{
		m_DomainController = str;
	}

private:
	ENotificationEvent m_Event;
	GUID m_ObjectGuid;
	wstring m_DomainController;
};



CNotificationBody::CNotificationBody(
	ENotificationEvent Event, 
	const GUID& ObjectGuid,
	LPCWSTR DomainController 
	)
{
	m_Event = Event;
	m_ObjectGuid = ObjectGuid;
	if(DomainController != NULL)
	{
		m_DomainController = wstring(DomainController);
	}
}



const WCHAR* CNotificationBody::MarhshalIn(const WCHAR* pBuffer, long Size)
{
	ASSERT(pBuffer != NULL && Size != 0);
	
	//
	// Asserts the notification body is alligned for a unicode buffer.
	//
	ASSERT(((INT_PTR)pBuffer & 1) == 0);

	int dwEvent;
	WCHAR szGuid[MAX_PATH];
	WCHAR szDomainController[MAX_PATH];
	int CharactersRead;

	int Count = swscanf(
					pBuffer, 
					QM_NOTIFICATION_INPUT_MARSHALLING_FORMAT L"%n", 
					&dwEvent,
					szGuid,
					szDomainController,
					&CharactersRead
					);
	
	//
	// Number of fields read, may be 2 if no domain controller was specified in 
	// the message body.
	// 
	if(Count < 2)
	{
		DBGMSG((DBGMOD_QM,DBGLVL_ERROR,TEXT("Failed in CNotificationBody::MarhshalIn().")));
		LogIllegalPoint(s_FN, 120);
		throw exception();
	}

	wstring DomainController = szDomainController;

	ParseGuidString(szGuid, &m_ObjectGuid);
	m_DomainController.erase();
	if(Count == 3)
	{
		m_DomainController = DomainController;
	}
	m_Event = (ENotificationEvent) dwEvent;

	return pBuffer + CharactersRead;
}



WCHAR* CNotificationBody::MarshalOut(WCHAR* pBuffer, long Size)
{
	ASSERT(Size >= RequiredWideBufferSize());

	int Count = _snwprintf(
					pBuffer,
					Size,
					QM_NOTIFICATION_OUTPUT_MARSHALLING_FORMAT,
					(int)m_Event,
					GUID_ELEMENTS((&m_ObjectGuid)),
					m_DomainController.c_str()
					);
	if(Count < 0)
	{
		DBGMSG((DBGMOD_QM,DBGLVL_ERROR,TEXT("Buffer too small, in CNotificationBody::MarshalOut().")));
		LogIllegalPoint(s_FN, 130);
		throw exception();
	}

	return pBuffer + Count;
}



long CNotificationBody::RequiredWideBufferSize()
{
	return 
		STRLEN(QM_NOTIFICATION_OUTPUT_MARSHALLING_FORMAT) - 
		STRLEN(GUID_FORMAT) + 
		numeric_cast<long>(16 + 36 + m_DomainController.length());
}



STATIC VOID ClearMQPropVariantArray(MQPROPVARIANT* pVars, DWORD cProps)
{
	for(DWORD i = 0; i < cProps; i++)
	{
		MQFreeVariant(pVars[i]);
	}
}



HRESULT 
GetRelevantProperties(
	AD_OBJECT Object,
    const GUID& ObjectGuid,
	LPCWSTR DomainController,
	DWORD cProps,
	PROPID* pProps,
	PROPVARIANT* pVars	
	)
{
	ASSERT(pProps[cProps - 1] == PROPID_Q_SECURITY || pProps[cProps - 1] == PROPID_QM_SECURITY);
	
	for(DWORD i = 0; i < cProps; i++)
	{
		PropVariantInit(&pVars[i]);
	}

	//
	// ISSUE-2001/05/27-ilanh - notification message don't include fServerName flag
	// so we are passing false for fServerName.
	//
	HRESULT hr = ADGetObjectPropertiesGuid(
					Object,
					DomainController,
					false,	// fServerName
					&ObjectGuid,
					cProps - 1,
					pProps,
					pVars
					);

	if(FAILED(hr))
	{
		TrERROR(qm, "ADGetObjectPropertiesGuid() failed, hr = 0x%x", hr);
		return LogHR(hr, s_FN, 200);
	}

	SECURITY_INFORMATION RequestedInformation = 
							OWNER_SECURITY_INFORMATION |
							GROUP_SECURITY_INFORMATION |
							DACL_SECURITY_INFORMATION  | 
							SACL_SECURITY_INFORMATION;

	//
	// Try to get security information including SACL information.
	// If we fail try again without SACL information.
	//

    MQSec_SetPrivilegeInThread(SE_SECURITY_NAME, TRUE);

	hr = ADGetObjectSecurityGuid(
			Object,
			DomainController, 
			false,	// fServerName
			&ObjectGuid,
			RequestedInformation,
			PROPID_Q_SECURITY,
			pVars + cProps - 1
			);

	MQSec_SetPrivilegeInThread(SE_SECURITY_NAME, FALSE);

	if(SUCCEEDED(hr))
		return hr;

	RequestedInformation &= ~SACL_SECURITY_INFORMATION;

	hr = ADGetObjectSecurityGuid(
			Object,
			DomainController, 
			false,	// fServerName
			&ObjectGuid,
			RequestedInformation,
			PROPID_Q_SECURITY,
			pVars + cProps - 1
			);
	if(FAILED(hr))
	{
		TrERROR(qm, "ADGetObjectPropertiesGuid() failed to get security property, hr = 0x%x", hr);
		ClearMQPropVariantArray(pVars, cProps - 1);
		return LogHR(hr, s_FN, 230);
	}

	return LogHR(hr, s_FN, 240);
}



void 
SyncQueueState(
    const GUID& ObjectGuid,
	LPCWSTR DomainController
	)
{
	//
	// BUGBUG: need to create mechanism to keep list syncronized with 
	// LQSSetProperties(). niraides 06-Jun-00
	//
	PROPID pProps[] = {
	        PROPID_Q_TYPE, 
			PROPID_Q_INSTANCE,			 
			PROPID_Q_BASEPRIORITY,		
			PROPID_Q_JOURNAL,			 
			PROPID_Q_QUOTA,				
			PROPID_Q_JOURNAL_QUOTA,		
			PROPID_Q_CREATE_TIME,		
			PROPID_Q_MODIFY_TIME,		
//			PPROPID_Q_TIMESTAMP,		//does not exist. triggers assertion (ads.cpp 2208)
			PROPID_Q_PATHNAME,				
			PROPID_Q_LABEL, 
			PROPID_Q_AUTHENTICATE,		
			PROPID_Q_PRIV_LEVEL,		
			PROPID_Q_TRANSACTION,		
			PROPID_Q_MULTICAST_ADDRESS,

			//
			// Must be last property
			//
			PROPID_Q_SECURITY			
	};

    const DWORD cProps = TABLE_SIZE(pProps);
	PROPVARIANT pVars[cProps] = {0};

    HRESULT hr = GetRelevantProperties(
					eQUEUE,
					ObjectGuid,
					DomainController,
					cProps,
					pProps,
					pVars	
					);

	if((hr == MQ_ERROR_NO_DS) && (DomainController != NULL))
	{
		//
		// The specified DC was unreachable. try to sync with local DC.
		//
		TrWARNING(qm, "failed to sync with DC = %ls, trying local DC", DomainController);
		hr = GetRelevantProperties(
				eQUEUE,
				ObjectGuid,
				NULL,
				cProps,
				pProps,
				pVars	
				);
	}
	
	if(hr == MQ_ERROR_NO_DS)
	{
		TrERROR(qm, "GetRelevantProperties() Failed, MQ_ERROR_NO_DS");
		throw exception();
	}

	if(hr == MQ_ERROR_QUEUE_NOT_FOUND)
	{
		TrTRACE(qm, "GetRelevantProperties() Failed, MQ_ERROR_QUEUE_NOT_FOUND");
		DeleteCachedQueue(&ObjectGuid);
		return;
	}

	if(FAILED(hr))
	{
		//
		// Don't throw exception to allow processing of more notifications
		//
		TrERROR(qm, "GetRelevantProperties() Failed, hr = 0x%x", hr);
		return;
	}
	
	UpdateCachedQueueProp(&ObjectGuid, cProps, pProps, pVars, time(NULL));

	ClearMQPropVariantArray(pVars, cProps);
}



void 
SyncMachineState(
    const GUID& ObjectGuid,
	LPCWSTR DomainController
	)
{
	if(ObjectGuid != *CQueueMgr::GetQMGuid())
	{
		DBGMSG((DBGMOD_QM,DBGLVL_ERROR,TEXT("Object guid is not this QM.")));
		LogIllegalPoint(s_FN, 260);
		throw exception();
	}

	//
	// BUGBUG: need to create mechanism to keep list syncronized with 
	// CQueueMgr::UpdateMachineProperties(). niraides 06-Jun-00
	//
	PROPID pProps[] = {
            PROPID_QM_QUOTA,
            PROPID_QM_JOURNAL_QUOTA,

			//
			// Must be last property
			//
            PROPID_QM_SECURITY         
 	};

	const DWORD cProps = TABLE_SIZE(pProps);
	PROPVARIANT pVars[cProps] = {0};

    HRESULT hr = GetRelevantProperties(
					eMACHINE,
					ObjectGuid,
					DomainController,
					cProps,
					pProps,
					pVars	
					);

	if((hr == MQ_ERROR_NO_DS) && (DomainController != NULL))
	{
		//
		// The specified DC was unreachable. try to sync with local DC.
		//
		TrWARNING(qm, "failed to sync with DC = %ls, trying local DC", DomainController);
		hr = GetRelevantProperties(
					eMACHINE,
					ObjectGuid,
					NULL,
					cProps,
					pProps,
					pVars	
					);
	}

	if(hr == MQ_ERROR_NO_DS)
	{
		TrERROR(qm, "GetRelevantProperties() failed, MQ_ERROR_NO_DS");
		LogHR(hr, s_FN, 275);
		throw exception();
	}

	if(FAILED(hr))
	{
		//
		// Don't throw exception to allow processing of more notifications
		//
		TrERROR(qm, "GetRelevantProperties() failed, hr = 0x%x", hr);
		LogHR(hr, s_FN, 290);
		return;
	}
	
	QueueMgr.UpdateMachineProperties(cProps, pProps, pVars);

	ClearMQPropVariantArray(pVars, cProps);
}



void 
SyncObjectState(
	ENotificationEvent Event,
    const GUID& ObjectGuid,
	LPCWSTR DomainController
	)
{
	if(DomainController != NULL && DomainController[0] == L'\0')
	{
		DomainController = NULL;
	}

	TrTRACE(qm, "sync object, event = %d, guid = %!guid!, DomainController = %ls", Event, &ObjectGuid, DomainController);

	switch(Event)
	{
	case neChangeQueue:
	case neCreateQueue:
	case neDeleteQueue:
        SyncQueueState(ObjectGuid, DomainController);
        break;

	case neChangeMachine:
		SyncMachineState(ObjectGuid, DomainController);
		break;

	default:
		DBGMSG((DBGMOD_QM,DBGLVL_ERROR,TEXT("Unsupported notification event in SyncObjectState().")));
		LogIllegalPoint(s_FN, 300);
		throw exception();
	}
}



void 
BuildNotificationMsg(
	ENotificationEvent Event,
	LPCWSTR DomainController,
    const GUID& ObjectGuid,
	AP<BYTE>& Buffer,
	long* pSize
	)
/*++
Routine Description:
	Builds the body of an msmq QM-notification message.

Arguments:
	[out] Buffer - Newly allocated buffer containing the msmq message body
	[out] pSize - Buffer's size

Return Value:

--*/
{
	CNotificationBody Body(Event, ObjectGuid, DomainController);

	long BufferSize = sizeof(CNotificationHeader) + Body.RequiredWideBufferSize() * 2;
    AP<BYTE> TempBuffer = new BYTE[BufferSize];
 
	CNotificationHeader* pHeader = (CNotificationHeader*)TempBuffer.get();

    pHeader->SetVersion(QM_NOTIFICATION_MSG_VERSION);
    pHeader->SetNoOfNotifications(1);

	//
	// Asserts the notification body is alligned for a unicode buffer.
	//
	ASSERT(((INT_PTR)pHeader->GetPtrToData() & 1) == 0);

	WCHAR* pBodyData = (WCHAR*)pHeader->GetPtrToData();
	
	BYTE* pEnd = (BYTE*) Body.MarshalOut(
							pBodyData, 
							Body.RequiredWideBufferSize()
							);

	*pSize = numeric_cast<long>(pEnd - TempBuffer.get());
	Buffer = TempBuffer.detach();
}



void 
SendNotificationMsg(
    const GUID* pDestQMGuid,
	BYTE* pBuffer,
	long Size
	)
{
    CMessageProperty MsgProp;

    MsgProp.wClass=0;
    MsgProp.dwTimeToQueue = NOTIFICATION_MSG_TIMEOUT;
    MsgProp.dwTimeToLive = INFINITE ;
    MsgProp.pMessageID = NULL;
    MsgProp.pCorrelationID = NULL;
    MsgProp.bPriority= NOTIFICATION_MSG_PRIORITY;
    MsgProp.bDelivery= MQMSG_DELIVERY_EXPRESS;
    MsgProp.bAcknowledge= MQMSG_ACKNOWLEDGMENT_NONE;
    MsgProp.bAuditing=MQ_JOURNAL_NONE;
    MsgProp.dwApplicationTag= DEFAULT_M_APPSPECIFIC;
    MsgProp.dwTitleSize=0;
    MsgProp.pTitle=NULL;
    MsgProp.dwBodySize=Size;
    MsgProp.dwAllocBodySize = Size;
    MsgProp.pBody= pBuffer;

	QUEUE_FORMAT QueueFormat;
    QueueFormat.PrivateID(*pDestQMGuid, NOTIFICATION_QUEUE_ID);
    
    HRESULT hr = QmpSendPacket(
					&MsgProp, 
					&QueueFormat, 
					NULL,			  //pqdAdminQueue 
					NULL,			 //pqdResponseQueue 
					FALSE			//fSign
					);
    if (FAILED(hr))
    {
		DBGMSG((DBGMOD_QM,DBGLVL_ERROR,TEXT("Failed call to QmpSendPacket() in SendNotificationMsg().")));
		LogHR(hr, s_FN, 310);
		throw exception();
    }
}



void 
R_NotifyQM( 
    /* [in] */ handle_t hBind,
    /* [in] */ enum ENotificationEvent Event,
    /* [unique][in] */ LPCWSTR DomainController,
    /* [in] */ const GUID __RPC_FAR *pDestQMGuid,
    /* [in] */ const GUID __RPC_FAR *pObjectGuid
	)
/*++
Routine Description:
	this RPC routine is invoked by the msmq client who changed an object's 
	state in the DS, to trigger synchronisation of the object's new state 
	by the owner QM.

Arguments:
	Event - The nature of the state change (created, deleted, changed...)
	DomainController - The domain controller on which the state was changed
	pDestQMGuid - id of the QM which is the owner of the object
	pObjectGuid - id of the object whose state should be sync-ed

Return Value:

--*/
{
	if(pObjectGuid == NULL || pDestQMGuid == NULL)
	{
		DBGMSG((DBGMOD_QM,DBGLVL_ERROR,TEXT("Bad Arguments for R_NotifyQM().")));
		LogIllegalPoint(s_FN, 320);
		throw exception();
	}

	try
	{
		//
		// If the subject of the notification is local, sync immediately
		//
		if(*pDestQMGuid == *CQueueMgr::GetQMGuid())
		{
			SyncObjectState(Event, *pObjectGuid, DomainController);
			return;
		}

		//
		// Otherwise send Notification message to owner QM
		//
		
		AP<BYTE> Buffer;
		long size;

		BuildNotificationMsg(
			Event,
			DomainController, 
			*pObjectGuid, 
			Buffer,
			&size
			);

		SendNotificationMsg(pDestQMGuid, Buffer.get(), size);
	}
	catch(const exception&)
	{
		DBGMSG((DBGMOD_QM,DBGLVL_ERROR,TEXT("Failed NotifyQM().")));
		LogIllegalPoint(s_FN, 330);
		throw exception();
	}
}



void IntializeQMNotifyRpc(void)
{
    RPC_STATUS status = RpcServerRegisterIf2(
				            qmnotify_v1_0_s_ifspec,
                            NULL,   
                            NULL,
				            0,
				            RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
				            (unsigned int)-1,	
				            NULL
				            );
 
    if(status != RPC_S_OK) 
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, L"Failed to initialize HTTP RPC. Error %x", status));
		LogRPCStatus(status, s_FN, 340);
        throw exception();
    }
}



//
// A "function object" which is used to compare GUID objects
//
struct CFunc_CompareGuids: binary_function<GUID, GUID, bool> 
{
	bool operator()(const GUID& obj1, const GUID& obj2) const
	{
		C_ASSERT(sizeof(obj1) == 16);
		return (memcmp(&obj1, &obj2, sizeof(obj1)) < 0);
	}
};



//
// This class is used to store notifications until a set time interval has 
// passed, and then sync all of them together from the DS.
//
class CNotificationScheduler 
{
public:
	CNotificationScheduler() :
		m_fDoGeneralUpdate(false),
		m_fTimerArmed(false),
		m_LastTimeFired(CTimeInstant::MinValue()),
		m_Timer(TimeToHandleNotifications)
	{
	}

	VOID ScheduleNotification(const CNotificationBody& Body);
	VOID HandleNotifications();

private:
	VOID GeneralUpdate();

public:
	static void WINAPI TimeToHandleNotifications(CTimer* pTimer);

private:
	typedef map<GUID, CNotificationBody, CFunc_CompareGuids> NotificationMap;

private:
	CCriticalSection m_cs;

	bool m_fDoGeneralUpdate;
	bool m_fTimerArmed;
	CTimeInstant m_LastTimeFired;

	CTimer m_Timer;
	NotificationMap m_NotificationMap;
};



void WINAPI CNotificationScheduler::TimeToHandleNotifications(CTimer* pTimer)
{
	CNotificationScheduler* pNotificationScheduler = CONTAINING_RECORD(pTimer, CNotificationScheduler, m_Timer);

	CS Lock(pNotificationScheduler->m_cs);

	pNotificationScheduler->m_fTimerArmed = false;
	pNotificationScheduler->m_LastTimeFired = ExGetCurrentTime();
	pNotificationScheduler->HandleNotifications();
}

	
	
VOID CNotificationScheduler::HandleNotifications()
{
	CS Lock(m_cs);

	try
	{
		if(m_fDoGeneralUpdate)
		{
			GeneralUpdate();
			m_fDoGeneralUpdate = false;
			return;
		}

		NotificationMap::iterator Itr = m_NotificationMap.begin();

		for(;Itr != m_NotificationMap.end();)
		{
			CNotificationBody& Body = Itr->second;

			SyncObjectState(Body.Event(), Body.Guid(), Body.DomainController().c_str());

			Itr = m_NotificationMap.erase(Itr);
		}
	}
	catch(const exception&)
	{
	    ExSetTimer(&m_Timer, xNotificationUpdateDelay);
        LogIllegalPoint(s_FN, 360);
	    return;
	}
}



VOID CNotificationScheduler::GeneralUpdate()
{
	SyncMachineState(*CQueueMgr::GetQMGuid(), NULL);

	HRESULT hr = UpdateAllPublicQueuesInCache();

	if(FAILED(hr))
	{
        DBGMSG((DBGMOD_QM,
                DBGLVL_TRACE,
                TEXT("Failed UpdateAllPublicQueuesInCache() with error %d. Will schedule a retry."),
                hr));
		LogHR(hr, s_FN, 315);
		throw exception();
	}
}



VOID CNotificationScheduler::ScheduleNotification(const CNotificationBody& Body)
{
	CS Lock(m_cs);

	if(m_fDoGeneralUpdate)
	{
		//
		// An Update of all public queues is scheduled. No need to schedule
		// specific updates
		//
		return;
	}

	if(m_NotificationMap.size() > xLQSTresholdMagicNumber)
	{
		//
		// Too many updates schedulled. Issue a general update.
		//
		m_fDoGeneralUpdate = true;
		m_NotificationMap.clear();
		return;
	}

	CNotificationBody& MappedBody = m_NotificationMap[Body.Guid()];

	if((MappedBody.Event() != neNoEvent) && !(MappedBody.DomainController() == Body.DomainController()))
	{
		//
		// Domain controllers conflict, so synch with local domain controller.
		//
		MappedBody = Body;
		MappedBody.DomainController(L"");
	}
	else
	{
		MappedBody = Body;
	}
		
	if(!m_fTimerArmed)
	{
		m_fTimerArmed = true;

		//
		// The following timing calculations ensure timer will go off at a 
		// maximum rate of 15 minutes, and no sooner then 1 minute from 
		// its setting (assuming more notifications are likely to arrive in
		// that minute).
		//
		CTimeInstant GoOffTime = m_LastTimeFired + xNotificationUpdateDelay;
		CTimeInstant NextMinute = ExGetCurrentTime() + CTimeDuration::OneSecond().Ticks() * 60;

		if(GoOffTime < NextMinute)
		{
			GoOffTime = NextMinute; 
		}

		ExSetTimer(&m_Timer, GoOffTime);
	}
}



static CNotificationScheduler g_NotificationScheduler;



void VerifyBody(const CNotificationBody& Body)
{
	CHLQS hLQS;

	switch(Body.Event())
	{
	case neChangeQueue:
	case neCreateQueue:
		break;

	case neDeleteQueue:	
		//
		// Verify that queue is known to QM. No need to delete otherwise.
		//
		if(SUCCEEDED(LQSOpen(&Body.Guid(), &hLQS, NULL)))
			return;

		DBGMSG((DBGMOD_QM, DBGLVL_ERROR, L"Failed VerifyBody(). Queue is unknown to QM."));
		throw exception();

	case neChangeMachine:
		if(Body.Guid() == *CQueueMgr::GetQMGuid())
			return;

		DBGMSG((DBGMOD_QM, DBGLVL_ERROR, L"Failed VerifyBody(). designated QM is not us."));
		throw exception();

	default:
		DBGMSG((DBGMOD_QM, DBGLVL_ERROR, L"Failed VerifyBody(). Bad body."));
		throw exception();
	}
}



//
// -----------------------------------------------------------------------
//

void
HandleQueueNotification(
    LPWSTR pwcsPathName,
    GUID* pguidIdentifier,
    unsigned char  ucOperation,
    DWORD dwNoOfProps,
    PROPID * pProps,
    PROPVARIANT * pVars
    )
{
    GUID gQueue;


    if ((pwcsPathName != NULL) && (ucOperation != DS_UPDATE_CREATE))
    {
         PROPID aProp[1];
         PROPVARIANT aVar[1];
         HRESULT rc;

         aProp[0] = PROPID_Q_INSTANCE;
         aVar[0].vt = VT_CLSID;
         aVar[0].puuid = &gQueue;

         rc = GetCachedQueueProperties(1, aProp, aVar, NULL, pwcsPathName) ;
         pguidIdentifier = aVar[0].puuid;

         if (FAILED(rc))
             return;
    }

    switch (ucOperation)
    {
        case DS_UPDATE_CREATE:
        {
            ASSERT((pguidIdentifier == NULL) && (pwcsPathName != NULL));
            for (DWORD i=0; i< dwNoOfProps; i++)
            {
                if (pProps[i] == PROPID_Q_INSTANCE)
                {
                    pguidIdentifier = pVars[i].puuid;
                    break;
                }
            }
            ASSERT(pguidIdentifier != NULL);
            UpdateCachedQueueProp(pguidIdentifier, dwNoOfProps, pProps, pVars, time(NULL));
            break;
        }

        case DS_UPDATE_SET:
        {
            ASSERT(pguidIdentifier != NULL);
            UpdateCachedQueueProp(pguidIdentifier, dwNoOfProps, pProps, pVars, time(NULL));
            break;
        }

        case DS_UPDATE_DELETE:
            ASSERT(pguidIdentifier != NULL);
			DeleteCachedQueue(pguidIdentifier);
            break;

        default:
            ASSERT(0);
    }
}

void HandleMachineNotification(unsigned char ucOperation,
                               DWORD dwNoOfProps,
                               PROPID * pProps,
                               PROPVARIANT * pVars)
{
    QUEUE_FORMAT QueueFormat;
   

    if (ucOperation == DS_UPDATE_SET)
    {
        QueueMgr.UpdateMachineProperties(dwNoOfProps, pProps, pVars);
    }
}



//
// Constructor
//
CNotify::CNotify()
{
}


/*====================================================

RoutineName
    CNotify::Init()

Arguments:

Return Value:

=====================================================*/
HRESULT CNotify::Init()
{
    QUEUE_FORMAT QueueFormat;

    BOOL WINAPI ReceiveNotifications(CMessageProperty*, QUEUE_FORMAT*);

    DBGMSG((DBGMOD_QM,DBGLVL_INFO,TEXT("Entering CNotify::Init")));

	try
	{
		IntializeQMNotifyRpc();
	}
	catch(const exception&)
	{
        DBGMSG((DBGMOD_QM,DBGLVL_ERROR,TEXT("ERROR : CNotify::Init -> Failed call to IntializeQMNotifyRpc()")));
    	LogIllegalPoint(s_FN, 370);
        return LogHR(MQ_ERROR, s_FN, 5);
	}

    HRESULT hR = GetNotifyQueueFormat( &QueueFormat);
    if (FAILED(hR))
    {
        DBGMSG((DBGMOD_QM,DBGLVL_ERROR,TEXT("ERROR : CNotify::Init -> couldn't get Admin-Queue from registry!!!")));
        return LogHR(hR, s_FN, 10);
    }

    hR = QmpOpenAppsReceiveQueue(&QueueFormat, ReceiveNotifications);
    return LogHR(hR, s_FN, 20);
}


/*====================================================

RoutineName
    CNotify::GetNotifyQueueFormat()

Arguments:

Return Value:

=====================================================*/

HRESULT CNotify::GetNotifyQueueFormat( QUEUE_FORMAT * pQueueFormat)
{
    extern LPTSTR  g_szMachineName;

    HRESULT rc;

    DWORD LenMachine = wcslen(g_szMachineName);
    DWORD Length =
            LenMachine +                    // "machineName"
            1 +                             // '\'
            wcslen(NOTIFY_QUEUE_NAME) +1;   // "private$\NOTIFY_QUEUE$"

    P<WCHAR> lpwFormatName = new WCHAR[Length];

    wcscpy(lpwFormatName,g_szMachineName);
    lpwFormatName[LenMachine] = L'\\';
    wcscpy(lpwFormatName+LenMachine+1,NOTIFY_QUEUE_NAME);

    rc = g_QPrivate.QMPrivateQueuePathToQueueFormat(lpwFormatName, pQueueFormat);

    if (FAILED(rc))
    {
        //
        // The NOTIFY_QUEUE doesn't exist
        //
        LogHR(rc, s_FN, 30);
        return MQ_ERROR;
    }

    ASSERT((pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_PRIVATE) ||
           (pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_DIRECT));

    return MQ_OK;
}

/*====================================================

ValidateServerPacket

Arguments:

Return Value:

=====================================================*/

STATIC BOOL
ValidateServerPacket(
    const CMessageProperty* pmp,
    const GUID         *pGuidQM
    )
{
    //
    // The sender ID must be marked as QM.
    //
    if ((pmp->pSenderID == NULL) ||
        pmp->ulSenderIDType != MQMSG_SENDERID_TYPE_QM)
    {
        DBGMSG((DBGMOD_QM | DBGMOD_DS,
                DBGLVL_ERROR,
                TEXT("ValidateServerPacket: Sender ID type is not QM (%d)"),
                pmp->ulSenderIDType));
        return LogBOOL(FALSE, s_FN, 50);
    }

    //
    // Server packets must be authenticated.
    //
    if (!pmp->bAuthenticated)
    {
        //
        // BUGBUG -
        // Non-authenticated server packets can be received only if we're
        // running on the server it self. This is because we do not go
        // through the QM in this case.
        // So see if the QM guid that is in the packet is identical to the
        // QM guid of our - the local QM.
        //

        if ((pmp->pSignature == NULL) ||
            memcmp(pmp->pSenderID, pGuidQM, sizeof(GUID)) != 0)
        {
            //
            // This still might happen when receiving first replication
            // messages from a new site. This special case is treated by
            // the MQIS. A special debug message is generated to indicate
            // that the message was accepted after all.
            //
            DBGMSG((DBGMOD_QM | DBGMOD_DS,
                    DBGLVL_ERROR,
                    TEXT("ValidateServerPacket: Received a non-authenticated ")
                    TEXT("server message.")));
            return LogBOOL(FALSE, s_FN, 60);
        }

        //
        // Yup, so compute the hash value and then validate the signature.
        //
        CHCryptHash hHash;
        CHCryptKey hPbKey;

        //
        // Packet are signed with the base provider. Always.
        //
        HCRYPTPROV hProvQM = NULL ;
        HRESULT hr = MQSec_AcquireCryptoProvider( eBaseProvider,
                                                 &hProvQM ) ;
        if (FAILED(hr))
        {
            return LogBOOL(FALSE, s_FN, 70);
        }

        ASSERT(hProvQM) ;
        if (!CryptCreateHash(hProvQM, pmp->ulHashAlg, 0, 0, &hHash))
        {
            DBGMSG((DBGMOD_QM | DBGMOD_DS,
                    DBGLVL_ERROR,
                    TEXT("ValidateServerPacket: Received a signed server message ")
                    TEXT("but with bad signature (couldn't create a hash object).")));
            return LogBOOL(FALSE, s_FN, 80);
        }

        hr = HashMessageProperties(
                hHash,
                pmp,
                NULL,
                NULL);
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_QM | DBGMOD_DS,
                    DBGLVL_ERROR,
                    TEXT("ValidateServerPacket: Received a signed server message ")
                    TEXT("but with bad signature (couldn't compute hash value).")));
            LogHR(hr, s_FN, 90);
            return(FALSE);
        }

        if (!CryptGetUserKey(hProvQM, AT_SIGNATURE, &hPbKey) ||
            !CryptVerifySignatureA(
                    hHash,
                    pmp->pSignature,
                    pmp->ulSignatureSize,
                    hPbKey,
                    NULL,
                    0))
        {
            DBGMSG((DBGMOD_QM | DBGMOD_DS,
                    DBGLVL_ERROR,
                    TEXT("ValidateServerPacket: Received a signed server message ")
                    TEXT("but with bad signature.")));
            return LogBOOL(FALSE, s_FN, 100);
        }
    }

    //
    // See that we indeed got the message from a server.
    //
    HRESULT hr;
    PROPID PropId = PROPID_QM_SERVICE;   //[adsrv] Keeping old - query will process.
    PROPVARIANT PropVar;

    PropVar.vt = VT_UI4;
    // This search request will be recognized and specially simulated by DS
    hr = ADGetObjectPropertiesGuid(
            eMACHINE,
            NULL,   // pwcsDomainController
			false,	// fServerName
            (GUID *)pmp->pSenderID,
            1,
            &PropId,
            &PropVar
            );
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_QM | DBGMOD_DS,
                DBGLVL_ERROR,
                TEXT("ValidateServerPacket: Failed to get the service ")
                TEXT("type (%x)"),
                hr));
        LogHR(hr, s_FN, 115);
        return(FALSE);
    }

    // [adsrv] Not changing it, because query will do its work.
    // It is a special case for the query.

    if ((PropVar.ulVal != SERVICE_PEC) &&
        (PropVar.ulVal != SERVICE_PSC) &&
        (PropVar.ulVal != SERVICE_BSC))
    {
        DBGMSG((DBGMOD_QM | DBGMOD_DS,
                DBGLVL_ERROR,
                TEXT("ValidateServerPacket: Received notification ")
                TEXT("not from a server (%d)"),
                PropVar.ulVal));
        return LogBOOL(FALSE, s_FN, 135);
    }

    return(TRUE);
}



BOOL
WINAPI
ReceiveNotifications(
    CMessageProperty* pmp,
    QUEUE_FORMAT* pqf
    )
{
	try
    {
		if ( pmp->wClass != MQMSG_CLASS_NORMAL )
		{
			DBGMSG((DBGMOD_QM,
					DBGLVL_ERROR,
					TEXT("ReceiveNotifications: wrong message class")));
			return TRUE;
		}
	
		DWORD dwTotalSize = pmp->dwBodySize;

		if (dwTotalSize < sizeof(CNotificationHeader))
		{
			DBGMSG((DBGMOD_QM,DBGLVL_ERROR,TEXT("Bad notification message size.")));
			return TRUE;
		}
		
		CNotificationHeader * pNotificationHeader = (CNotificationHeader *)pmp->pBody;

		if (pNotificationHeader->GetVersion() == QM_NOTIFICATION_MSG_VERSION)
		{
			//
			// New format notification, sent from another QM.
			//

			CNotificationBody Body;
			long BodySize = (dwTotalSize - pNotificationHeader->GetBasicSize()) / 2;
			const WCHAR* pBodyData = (const WCHAR*) pNotificationHeader->GetPtrToData();

			Body.MarhshalIn(pBodyData, BodySize);
			
			VerifyBody(Body);
			g_NotificationScheduler.ScheduleNotification(Body);

			return TRUE;
		}

		//
		// Should be an old format signed notification, sent from a DS server.
		//

		if ( pNotificationHeader->GetVersion() != DS_NOTIFICATION_MSG_VERSION)
		{
			DBGMSG((DBGMOD_QM,DBGLVL_ERROR,TEXT("Wrong version number of notification message")));
			LogIllegalPoint(s_FN, 140);
			return TRUE;
		}

		BOOL fSigned = ValidateServerPacket(pmp, QueueMgr.GetQMGuid());

		if(!fSigned)
		{
			DBGMSG((DBGMOD_QM,DBGLVL_ERROR,TEXT("Failed DS notification validation.")));
			LogIllegalPoint(s_FN, 145);
			return TRUE;
		}

		DWORD sum = pNotificationHeader->GetBasicSize();
		const unsigned char* ptr = pNotificationHeader->GetPtrToData();
  
		for (unsigned char i = 0; i < pNotificationHeader->GetNoOfNotifications(); i++)
		{
			ASSERT (sum < dwTotalSize);
			P<CDSBaseUpdate> pUpdate = new CDSBaseUpdate;

			DWORD size;

			HRESULT hr = pUpdate->Init(ptr,&size);
			if (FAILED(hr))
			{
				//
				// We don't want to read junked values
				// The notification will be ignored
				//
				DBGMSG((DBGMOD_QM,DBGLVL_ERROR,TEXT("Error -  in parsing a received notification")));
				LogHR(hr, s_FN, 150);
				break;
			}
			sum+=size;
			ptr+=size;

			switch ( pUpdate->GetObjectType())
			{
				case MQDS_QUEUE:
					HandleQueueNotification( pUpdate->GetPathName(),
											 pUpdate->GetGuidIdentifier(),
											 pUpdate->GetCommand(),
											 pUpdate->getNumOfProps(),
											 pUpdate->GetProps(),
											 pUpdate->GetVars());
					break;
				case MQDS_MACHINE:
					HandleMachineNotification( pUpdate->GetCommand(),
											   pUpdate->getNumOfProps(),
											   pUpdate->GetProps(),
											   pUpdate->GetVars());

					break;
				default:
					DBGMSG((DBGMOD_QM,DBGLVL_ERROR,TEXT("Notification about unexpected object type")));
					break;
			}

		}
    }
	catch(const exception&)
	{
        DBGMSG((DBGMOD_QM,
                DBGLVL_ERROR,
                TEXT("Exception thrown inside ReceiveNotifications().")));
		LogIllegalPoint(s_FN, 350);
	}

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qmrd.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    QmRd.h

Abstract:
    QM, routing decision interface

Author:
    Uri Habusha (urih), 20-May-2000
--*/

#pragma once

#ifndef __QMRD_H__
#define __QMRD_H__

HRESULT
QmRdGetSessionForQueue(
	const CQueue* pQueue,
	CTransportBase** ppSession
	);

HRESULT
QmRdGetConnectorQM(
	const GUID* foreignId,
	GUID* ponnectorId
	);

#endif // __QMRD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qmrd.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    rd.cpp

Abstract:
    QM interface to Routing Decision (Rd) library

Author:
    Uri Habusha (urih)

--*/

#include "stdh.h"
#include <mqexception.h>
#include "mqstl.h"
#include "Tr.h"
#include "ref.h"
#include "Rd.h"
#include "No.h"
#include "qmta.h"
#include "cqueue.h"
#include "sessmgr.h"

#include "QmRd.tmh"

static WCHAR *s_FN=L"qmrd";

using namespace std;

class CTransportBase;

extern CSessionMgr SessionMgr;

#ifdef _DEBUG

static
void
PrintRoutingTable(
    const GUID* pDestId, 
    CRouteTable& RouteTable
    )
{
    WCHAR buff[512];
    LPWSTR p = buff;
    DWORD size = STRLEN(buff) - sizeof(WCHAR);

    int n = _snwprintf(p, size , L"Routing Table for " GUID_FORMAT L"\n", GUID_ELEMENTS(pDestId));
    p += n;
    size -= n;
    
    n =  _snwprintf(p, size, L"\tFirst priority:");
    p += n;
    size -= n;
    

    CRouteTable::RoutingInfo::iterator it;
    CRouteTable::RoutingInfo* pRoute = RouteTable.GetNextHopFirstPriority();

    for (it = pRoute->begin(); it != pRoute->end(); ++it)
    {
        n = _snwprintf(p, size, L"%s ", (*it)->GetName());
        if (n < 0) 
            goto trace;

        p += n;
        size -= n;
    }

    pRoute = RouteTable.GetNextHopSecondPriority();

    if (pRoute->size() == 0)
        goto trace;

    n =  _snwprintf(p, size, L"\n\tSecond priority:");
    if (n < 0)
	{
        goto trace;
	}

    p += n;
    size -= n;
    

    for (it = pRoute->begin(); it != pRoute->end(); ++it)
    {
        n = _snwprintf(p, size, L"%s ", (*it)->GetName());
        if (n < 0)
            goto trace;

        p += n;
        size -= n;
    }

trace:
    *p = L'\0';
    DBGMSG((DBGMOD_ROUTING, DBGLVL_TRACE, L"%ls", buff));

}

#endif


static
DWORD
GetForeignMachineAddress(
	const CACLSID& foreignSitesId,
	CAddress address[],
	DWORD addressTableSize
	)
{
    //
    // BUGBUG: need to avoid the possibility that foreign machine belong to more than one site
    //
    ASSERT(foreignSitesId.cElems == 1);

    if (addressTableSize == 0)
        return 0;

    address[0].AddressType = FOREIGN_ADDRESS_TYPE;
    address[0].AddressLength = FOREIGN_ADDRESS_LEN;
    memcpy(address[0].Address, &foreignSitesId.pElems[0], sizeof(GUID));
   
    return 1;
}


static
DWORD
GetMachineAddress(
	LPCWSTR machineName,
	CAddress address[],
	DWORD addressTableSize
	)
{
	vector<SOCKADDR_IN> sockAddress;

	bool fSucc = NoGetHostByName(machineName, &sockAddress);

	if (!fSucc)
	{
		DBGMSG((DBGMOD_ROUTING,DBGLVL_TRACE, L"Failed to retrieve computer: %ls address", machineName));
		return 0;
	}

	DWORD maxNoOfAddress = numeric_cast<DWORD>(sockAddress.size());
	
	if (maxNoOfAddress > addressTableSize)
	{
		maxNoOfAddress = addressTableSize;
	}

	for (DWORD i = 0; i < maxNoOfAddress; ++i)
	{
		address[i].AddressType = IP_ADDRESS_TYPE;
		address[i].AddressLength = IP_ADDRESS_LEN;

		*(reinterpret_cast<ULONG*>(&(address[i].Address))) = sockAddress[i].sin_addr.s_addr;
	}

	return maxNoOfAddress;
}


static
CTransportBase*
GetSessionToNextHop(
	const CRouteTable::RoutingInfo* pNextHopTable,
	const CQueue* pQueue,
	CAddress* pAddress,
	const GUID** pGuid,
	DWORD addressTableSize,
	DWORD* pNoOfAddress
	)
{
	*pNoOfAddress = 0;

	const GUID** pTempGuid = pGuid;
	CAddress* pTempAddr = pAddress;

	for(CRouteTable::RoutingInfo::const_iterator it = pNextHopTable->begin(); it != pNextHopTable->end(); ++it)
	{
        DWORD noOfNewAddress;
        const CRouteMachine* pMachine = (*it).get();
        
        if (pMachine->IsForeign())
        {
            noOfNewAddress = GetForeignMachineAddress(
                                        pMachine->GetSiteIds(),
                                        pTempAddr, 
							            addressTableSize
							            );
        }
        else
        {
		    noOfNewAddress = GetMachineAddress(
							            pMachine->GetName(), 
							            pTempAddr, 
							            addressTableSize
							            );
        }

		if (noOfNewAddress == 0)
			continue;

		for (DWORD i = 0; i < noOfNewAddress; ++i)
		{
			*pTempGuid = &(*it)->GetId();
			++pTempGuid;
		}

		pTempAddr += noOfNewAddress;
		addressTableSize -= noOfNewAddress;
		*pNoOfAddress += noOfNewAddress;
	}

	CTransportBase* pSession;

    //
    // We never get here for Direct queues, so we ask for session without QoS
    //
	SessionMgr.GetSession(
					SESSION_ONE_TRY, 
					pQueue,
					*pNoOfAddress, 
					pAddress,
					pGuid,
                    false,
					&pSession
					);

	return pSession;
}


static
HRESULT
GetSessionToNextHop(
    CRouteTable& RouteTable,
	const CQueue* pQueue,
	CTransportBase** ppSession
	)
{
	DWORD MachineNo = numeric_cast<DWORD>(RouteTable.GetNextHopFirstPriority()->size() +
					  RouteTable.GetNextHopSecondPriority()->size());

    //
    // BUGBUG: is it a legal assumption that machine don't have more than 10 address
    //                  Uri Habusha, 23-May-2000
    //
	DWORD addressTableSize = MachineNo * 10;
	CAddress* pAddress = static_cast<CAddress*>(_alloca(sizeof(CAddress) * addressTableSize));
	const GUID** pGuid = static_cast<const GUID**>(_alloca(sizeof(GUID*) * addressTableSize));

	//
	// try first priority
	//
	DWORD noOfFirstPriorityAddress = 0;
	*ppSession = GetSessionToNextHop(
						RouteTable.GetNextHopFirstPriority(),
						pQueue,
						pAddress,
						pGuid,
						addressTableSize,
						&noOfFirstPriorityAddress
						);

	if (*ppSession != NULL)
		return MQ_OK;

	//
	// try Second priority
	// 
	DWORD noOfSecondPriorityAddress = 0;
	*ppSession = GetSessionToNextHop(
						RouteTable.GetNextHopSecondPriority(),
						pQueue,
						pAddress + noOfFirstPriorityAddress,
						pGuid + noOfFirstPriorityAddress,
						addressTableSize - noOfFirstPriorityAddress,
						&noOfSecondPriorityAddress
						);

	if (*ppSession != NULL)
		return MQ_OK;


    //
    // We never get here for Direct queues, so we ask for session without QoS
    //
    HRESULT hr = SessionMgr.GetSession(
						SESSION_RETRY,
						pQueue,
						noOfFirstPriorityAddress + noOfSecondPriorityAddress,
						pAddress,
						pGuid,
                        false,
						ppSession);
    
	return LogHR(hr, s_FN, 14);
}


HRESULT
QmRdGetSessionForQueue(
	const CQueue* pQueue,
	CTransportBase** ppSession
	)
{
	*ppSession = NULL;
	const GUID* pDestId = pQueue->GetRoutingMachine();

    DBGMSG((DBGMOD_ROUTING,DBGLVL_TRACE, L"Computing route to machine " TEXT(LOG_GUID_FMT), LOG_GUID(pDestId)));

    try
    {
        if (pQueue->IsHopCountFailure())
        {
            RdRefresh();
        }

        CRouteTable RouteTable;
        RdGetRoutingTable(*pDestId, RouteTable);

        #ifdef _DEBUG
            PrintRoutingTable(pDestId, RouteTable);
        #endif

        return LogHR(GetSessionToNextHop(RouteTable, pQueue, ppSession), s_FN, 20);

    }
    catch(const bad_ds_result& e)
    {
        DBGMSG((DBGMOD_ROUTING, DBGLVL_ERROR, L"Routing Decision failed due to DS error. Error=0x%x", e.error()));
		DBG_USED(e);
		LogIllegalPoint(s_FN, 30);
        return e.error();
    }
	catch(const	bad_route& e)
	{
        DBGMSG((DBGMOD_ROUTING, DBGLVL_ERROR, L"Routing Decision failed due to: %ls", e.ErrorType()));
		DBG_USED(e);
		LogIllegalPoint(s_FN, 40);
		return QM_ROUTING_FAIL;
	}
	catch(const exception&)
	{
        DBGMSG((DBGMOD_ROUTING, 
                DBGLVL_TRACE, 
                L"Failed to find route to " TEXT(LOG_GUID_FMT) L"exception raised", LOG_GUID(pDestId)));
		LogIllegalPoint(s_FN, 50);
		return MQ_ERROR_INSUFFICIENT_RESOURCES;
	}
}


HRESULT
QmRdGetConnectorQM(
	const GUID* foreignId,
	GUID* ponnectorId
	)
{
	try
	{
		RdGetConnector(*foreignId, *ponnectorId);
		return MQ_OK;  
	}
    catch(const bad_ds_result& e)
    {
        DBGMSG((DBGMOD_ROUTING, DBGLVL_ERROR, L"Getting connector failed due to DS error. Error 0x%x", e.error()));
		DBG_USED(e);
		LogIllegalPoint(s_FN, 60);
        return e.error();
    }
	catch(const	bad_route& e)
	{
        DBGMSG((DBGMOD_ROUTING, DBGLVL_ERROR, L"Getting connector failed due to: %ls", e.ErrorType()));
		DBG_USED(e);
		LogIllegalPoint(s_FN, 70);
		return QM_ROUTING_FAIL;
	}
	catch(const exception&)
	{
        DBGMSG((DBGMOD_ROUTING, 
                DBGLVL_TRACE, 
                L"Using " TEXT(LOG_GUID_FMT) L" as a connector to " TEXT(LOG_GUID_FMT), LOG_GUID(ponnectorId), LOG_GUID(foreignId)));
		LogIllegalPoint(s_FN, 80);
		return MQ_ERROR_INSUFFICIENT_RESOURCES;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qmrepl_s_.c ===
#pragma warning(push, 3)
#include <qmrepl_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qmrepls.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    qmrepls.cpp

Abstract:
    Send replication messages on behalf of the replication service on
    NT5.

Author:

    Doron Juster  (DoronJ)    01-Mar-1998    Created

--*/

#include "stdh.h"
#include "_mqrpc.h"
#include "qmrepl.h"
#include "qmp.h"

#include "qmrepls.tmh"

static WCHAR *s_FN=L"qmrepls";

HRESULT QMSendReplMsg(
    /* [in] */ handle_t hBind,
    /* [in] */ LPWSTR lpwszDestination,
    /* [in] */ DWORD dwSize,
    /* [size_is][in] */ const unsigned char __RPC_FAR *pBuffer,
    /* [in] */ DWORD dwTimeout,
    /* [in] */ unsigned char bAckMode,
    /* [in] */ unsigned char bPriority,
    /* [in] */ LPWSTR lpwszAdminResp)
{
    BOOL  fLocalCall = mqrpcIsLocalCall( hBind ) ;

    if (!fLocalCall)
    {
        DBGMSG((DBGMOD_DS, DBGLVL_ERROR, TEXT(
            "SECURITY Hole: QMSendReplMsg called from remote. Reject"))) ;
        return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 10);
    }

    DBGMSG((DBGMOD_DS, DBGLVL_INFO, _T("Sending Replication to %ls"), lpwszDestination )) ;

    CMessageProperty MsgProp;

    MsgProp.wClass=0;
    MsgProp.dwTimeToQueue= dwTimeout;
    MsgProp.dwTimeToLive = dwTimeout;
    MsgProp.pMessageID=NULL;
    MsgProp.pCorrelationID=NULL;
    MsgProp.bPriority= bPriority;
    MsgProp.bDelivery=MQMSG_DELIVERY_EXPRESS;
    MsgProp.bAcknowledge=bAckMode;
    MsgProp.bAuditing=DEFAULT_Q_JOURNAL;
    MsgProp.dwApplicationTag=DEFAULT_M_APPSPECIFIC;
    MsgProp.dwTitleSize=0;
    MsgProp.pTitle=NULL;
    MsgProp.dwBodySize=dwSize;
    MsgProp.dwAllocBodySize = dwSize;
    MsgProp.pBody=pBuffer;

    QUEUE_FORMAT qfDst(lpwszDestination) ;
    QUEUE_FORMAT qfAdmin;
    QUEUE_FORMAT qfResp;
    if (lpwszAdminResp != NULL) 
    {
        qfAdmin.DirectID(lpwszAdminResp);
        qfResp.DirectID(lpwszAdminResp);
    }

    HRESULT hr = QmpSendPacket(
                    &MsgProp,
                    &qfDst,
                    ((lpwszAdminResp != NULL) ? &qfAdmin : NULL),
                    ((lpwszAdminResp != NULL) ? &qfResp : NULL),
                    TRUE
                    );

    return LogHR(hr, s_FN, 20);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qmrpcsrv.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    qmrpcsrv.h

Abstract:

Author:

    Doron Juster  (DoronJ)    25-May-1997    Created
    Ilan Herbst   (IlanH)     9-July-2000    Removed mqdssrv-qm dependencies 

--*/

#ifndef  __QMRPCSRV_H_
#define  __QMRPCSRV_H_

#define  RPCSRV_START_QM_IP_EP     2103
#define  RPCSRV_START_QM_IP_EP2    2105
#define  MGMT_RPCSRV_START_IP_EP   2107

RPC_STATUS InitializeRpcServer();

extern TCHAR   g_wszRpcIpPort[ ];
extern TCHAR   g_wszRpcIpPort2[ ];

extern BOOL    g_fUsePredefinedEP;


#endif  //  __QMRPCSRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qmrt_s_.c ===
#pragma warning(push, 3)
#include <qmrt_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qmrpcsrv.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    qmrpcsrv.cpp

Abstract:

    1. Register the QM as rpc server.
    2. Utility functions for rpc processing.

Author:

    Doron Juster  (DoronJ)    25-May-1997    Created

--*/

#include "stdh.h"
#include "winsock.h"
#include "_mqini.h"
#include "_mqrpc.h"
#include "qm2qm.h"
#include "qmrt.h"
#include "qmrepl.h"
#include "qmmgmt.h"
#include "qmrpcsrv.h"
#include "mgmtrpc.h"
#include "..\replserv\mq1repl\replrpc.h"
#include <uniansi.h>
#include <mqsocket.h>
#include <mqsec.h>

#include "qmrpcsrv.tmh"

static WCHAR *s_FN=L"qmrpcsrv";

static RPC_BINDING_VECTOR *g_pBindings ;  // used for rpc dynamic endpoints.
BOOL  g_fUsePredefinedEP =  RPC_DEFAULT_PREDEFINE_QM_EP ;

unsigned int g_cMaxCalls = RPC_C_LISTEN_MAX_CALLS_DEFAULT;

#define  MAX_RPC_PORT_LEN  18

TCHAR   g_wszRpcIpPort[ MAX_RPC_PORT_LEN ] ;
TCHAR   g_wszRpcIpPort2[ MAX_RPC_PORT_LEN ] ;

static DWORD   s_dwRpcIpPort  = 0 ;
static DWORD   s_dwRpcIpPort2 = 0 ;


STATIC
RPC_STATUS
QMRpcServerUseProtseqEp(
    unsigned short __RPC_FAR * Protseq,
    unsigned int MaxCalls,
    unsigned short __RPC_FAR * Endpoint,
    void __RPC_FAR * SecurityDescriptor
    )
{
    if (!IsLocalSystemCluster())
    {
        //
        // fix 7123.
        // If we're not cluster, then bind to all addresses.
        // if we bind only to addresses we find at boot, then on ras
        // client (when not dialed) we'll bind to 127.0.0.1.
        // Then after dialling, no one will be able to call us, as we're
        // not bound to real addresses, only to the loopback.
        //
        RPC_STATUS status ;

        if (Endpoint)
        {
            status = RpcServerUseProtseqEp( Protseq,
                                            MaxCalls,
                                            Endpoint,
                                            SecurityDescriptor ) ;

            DBGMSG((DBGMOD_RPC, DBGLVL_INFO, _TEXT(
            "non cluster- RpcServerUseProtseqEp(%ls, %ls) returned 0x%x"),
                                         Protseq, Endpoint, status)) ;
        }
        else
        {
            status = RpcServerUseProtseq( Protseq,
                                          MaxCalls,
                                          SecurityDescriptor ) ;

            DBGMSG((DBGMOD_RPC, DBGLVL_INFO, _TEXT(
            "non cluster- RpcServerUseProtseq(%ls) returned 0x%x"),
                                                     Protseq, status)) ;
        }

        return status ;
    }

    //
    // Listen only on IP addresses we get from winsock.
    // This enables multiple QMs to listen each to its
    // own addresses, in a cluster environment. (ShaiK)
    //

    char szHostName[ MQSOCK_MAX_COMPUTERNAME_LENGTH ] = {0};
    if (SOCKET_ERROR == gethostname(szHostName, sizeof(szHostName)))
    {
        ASSERT(("IP not configured", 0));
        return LogRPCStatus(RPC_S_ACCESS_DENIED, s_FN, 10);
    }

    PHOSTENT pHostEntry = gethostbyname(szHostName);
    if ((pHostEntry == NULL) || (pHostEntry->h_addr_list == NULL))
    {
        ASSERT(("IP not configured", 0));
        return LogRPCStatus(RPC_S_ACCESS_DENIED, s_FN, 20);
    }

    for ( DWORD ix = 0; pHostEntry->h_addr_list[ix] != NULL; ++ix)
    {
        WCHAR wzAddress[50];
        ConvertToWideCharString(
            inet_ntoa(*(struct in_addr *)(pHostEntry->h_addr_list[ix])),
            wzAddress,
            TABLE_SIZE(wzAddress)
            );

        RPC_POLICY policy;
        policy.Length = sizeof(policy);
        policy.EndpointFlags = 0;
        policy.NICFlags = 0;

        RPC_STATUS status = RPC_S_OK;
        if (NULL != Endpoint)
        {
            status = I_RpcServerUseProtseqEp2(
                         wzAddress,
                         Protseq,
                         MaxCalls,
                         Endpoint,
                         SecurityDescriptor,
                         &policy
                         );
            DBGMSG((DBGMOD_RPC, DBGLVL_INFO,
                    _TEXT("I_RpcServerUseProtseqEp2 (%ls, %ls, %ls) returned 0x%x"),
                    wzAddress, Protseq, Endpoint, status)) ;
        }
        else
        {
            status = I_RpcServerUseProtseq2(
                         wzAddress,
                         Protseq,
                         MaxCalls,
                         SecurityDescriptor,
                         &policy
                         );
            DBGMSG((DBGMOD_RPC, DBGLVL_INFO,
                    _TEXT("I_RpcServerUseProtseq2 (%ls, %ls) returned 0x%x"),
                    wzAddress, Protseq, status)) ;
        }

        if (RPC_S_OK != status)
        {
            return LogRPCStatus(status, s_FN, 30);
        }
    }

    return RPC_S_OK;

} //QMRpcServerUseProtseqEp


STATIC
RPC_STATUS
QMRpcServerUseProtseq(
    unsigned short __RPC_FAR * Protseq,
    unsigned int MaxCalls,
    void __RPC_FAR * SecurityDescriptor
    )
{
    return LogRPCStatus(QMRpcServerUseProtseqEp(Protseq, MaxCalls, NULL, SecurityDescriptor), s_FN, 40) ;

} //QMRpcServerUseProtseq


static
void
ReadRegString(
	WCHAR KeyValue[MAX_REG_DEFAULT_LEN],
	LPCWSTR KeyName,
	LPCWSTR DefaultValue
	)
{
	ASSERT(wcslen(DefaultValue) < MAX_REG_DEFAULT_LEN);

	DWORD  dwSize = MAX_REG_DEFAULT_LEN * sizeof(WCHAR);
	DWORD  dwType = REG_SZ;
							
	LONG res = GetFalconKeyValue(
					KeyName,
					&dwType,
					KeyValue,
					&dwSize,
					DefaultValue
					);
						
	if(res == ERROR_MORE_DATA)									
	{															
		wcscpy(KeyValue, DefaultValue);								
	}															
	ASSERT(res == ERROR_SUCCESS || res == ERROR_MORE_DATA);
	ASSERT(dwType == REG_SZ);
}

/*====================================================

Function:  QMInitializeLocalRpcServer()

Arguments:

Return Value:

=====================================================*/

RPC_STATUS QMInitializeLocalRpcServer( IN LPWSTR lpwszEpRegName,
                                       IN LPWSTR lpwszDefaultEp,
                                       IN SECURITY_DESCRIPTOR *pSD,
                                       IN unsigned int cMaxCalls )
{
	WCHAR wzLocalEp[MAX_REG_DEFAULT_LEN];
	ReadRegString(wzLocalEp, lpwszEpRegName, lpwszDefaultEp);

    AP<WCHAR> pwzEndPoint = 0;
    ComposeLocalEndPoint(wzLocalEp, &pwzEndPoint);

    RPC_STATUS statusLocal = RpcServerUseProtseqEp(
                                      (TBYTE *) RPC_LOCAL_PROTOCOL,
                                       cMaxCalls,
                                       pwzEndPoint,
                                       pSD);
    DBGMSG((DBGMOD_RPC, DBGLVL_INFO,
        _TEXT("RpcServerUseProtseqEp (local, %ls) returned 0x%x"),
                                              pwzEndPoint, statusLocal)) ;

    return LogRPCStatus(statusLocal, s_FN, 50);
}

/*====================================================

Function:  QMRegisterDynamicEnpoint()

Arguments:

Return Value:

=====================================================*/

DWORD  QMRegisterDynamicEnpoint(
    IN unsigned int  cMaxCalls,
    IN unsigned char *pszSecurity,
    IN DWORD         dwFirstEP,
    IN BOOL          fRegisterDyn
    )
{
    LPWSTR lpProtocol = RPC_TCPIP_NAME ;

    //
    // Register this protocol for dynamic endpoint
    //
    RPC_STATUS  status = RPC_S_OK ;
    if (fRegisterDyn)
    {
        status = QMRpcServerUseProtseq(
                   lpProtocol,
                   cMaxCalls,
                   pszSecurity
                   );
    }

  if (status == RPC_S_OK)
  {
     //
     // Now register a fix endpoint which will be used for the real
     // interface communnication.
     //
     WCHAR wszEndpoint[24] ;
     for ( DWORD j = dwFirstEP ; j < dwFirstEP + 1000 ; j = j + 11 )
     {
        swprintf(wszEndpoint, L"%lu", j) ;

            status = QMRpcServerUseProtseqEp(
                         lpProtocol,
                         cMaxCalls,
                         wszEndpoint,
                         pszSecurity
                         );
        if (status == RPC_S_OK)
        {
           return j ;
        }

        LogRPCStatus(status, s_FN, 60);
     }
  }

   DBGMSG((DBGMOD_RPC, DBGLVL_WARNING,
          _TEXT("DSSRV_RegisterDynamicEnpoint: failed to register %ls"),
                                                             lpProtocol)) ;
   return 0 ;
}

/*====================================================

Function:  QMInitializeNetworkRpcServer()

Arguments:

Return Value:

=====================================================*/

RPC_STATUS
QMInitializeNetworkRpcServer(
    IN LPWSTR lpwszEpRegName,
    IN LPWSTR lpwszDefaultEp,
    IN LPWSTR lpwszEp,
    IN DWORD  dwFirstEP,
    IN BOOL   fRegisterDyn,
    IN SECURITY_DESCRIPTOR *pSD,
    IN unsigned int cMaxCalls
    )
{
    LPWSTR pProtocol =  RPC_TCPIP_NAME ;

    //
    // Register the tcp/ip protocol.
    //

    RPC_STATUS  status ;
    if (g_fUsePredefinedEP)
    {
		WCHAR KeyValue[MAX_REG_DEFAULT_LEN] = L"" ;
		ReadRegString(KeyValue, lpwszEpRegName, lpwszDefaultEp);
		KeyValue[MAX_REG_DEFAULT_LEN-1] = L'\0';

       ASSERT(wcslen(KeyValue) < MAX_RPC_PORT_LEN) ;
       wcscpy(lpwszEp, KeyValue) ;

       status = QMRpcServerUseProtseqEp(
                    pProtocol,
                    cMaxCalls,
                    lpwszEp,
                    NULL
                    );
    }
    else
    {
       DWORD dwPort =  QMRegisterDynamicEnpoint(
                             cMaxCalls,
                             (unsigned char *) pSD,
                             dwFirstEP,
                             fRegisterDyn
                             ) ;
       if (dwPort != 0)
       {
          _itow(dwPort, lpwszEp, 10) ;
          status = RPC_S_OK ;
       }
       else
       {
          status = RPC_S_PROTSEQ_NOT_SUPPORTED ;
       }
    }

    return LogRPCStatus(status, s_FN, 70);
}

/*====================================================

InitializeRpcServer

Arguments:

Return Value:

=====================================================*/

RPC_STATUS InitializeRpcServer()
{
    SECURITY_DESCRIPTOR SD;

    DBGMSG((DBGMOD_RPC,DBGLVL_INFO,_TEXT("InitializeRpcServer")));

    InitializeSecurityDescriptor(&SD, SECURITY_DESCRIPTOR_REVISION);
    SetSecurityDescriptorDacl(&SD, TRUE, NULL, FALSE);

    RPC_STATUS statusLocal = QMInitializeLocalRpcServer(
                                             RPC_LOCAL_EP_REGNAME,
											 RPC_LOCAL_EP,
                                             &SD,
                                             g_cMaxCalls ) ;

    RPC_STATUS statusRepl = RpcServerUseProtseqEp(
                                           QMREPL_PROTOCOL,
                                           g_cMaxCalls,
                                           QMREPL_ENDPOINT,
                                           &SD);
	DBG_USED(statusRepl);

    DBGMSG((DBGMOD_DS, DBGLVL_INFO,
         _TEXT("RpcServerUseProtseqEp (local, %ls) returned 0x%x"),
                                             QMREPL_ENDPOINT, statusRepl)) ;


    AP<WCHAR> pwzEndPoint = 0;
    ComposeLocalEndPoint(QMMGMT_ENDPOINT, &pwzEndPoint);

    RPC_STATUS statusMgmt = RpcServerUseProtseqEp(
                                           QMMGMT_PROTOCOL,
                                           g_cMaxCalls,
                                           pwzEndPoint,
                                           &SD);
    DBGMSG((DBGMOD_DS, DBGLVL_INFO,
         _TEXT("RpcServerUseProtseqEp (local, %ls) returned 0x%x"),
                                             pwzEndPoint, statusMgmt)) ;

    //
    // Initialize Remote Managment.
    //
    WCHAR RpcMgmtPort[MAX_RPC_PORT_LEN] ;
    statusMgmt = QMInitializeNetworkRpcServer(
                         L"",
                         L"",
                         RpcMgmtPort,
                         MGMT_RPCSRV_START_IP_EP,
                         TRUE,
                         &SD,
                         g_cMaxCalls
                         );

    //
    // See if we use dynamic or predefined endpoints. By default we use
    // dynamic endpoints.
    //
    DWORD ulDefault =  RPC_DEFAULT_PREDEFINE_QM_EP ;
    READ_REG_DWORD( g_fUsePredefinedEP,
                    RPC_PREDEFINE_QM_EP_REGNAME,
                    &ulDefault );

    //
    // Initialize the tcp/ip protocol.
    //
    RPC_STATUS statusIP = QMInitializeNetworkRpcServer(
                                         FALCON_QM_RPC_IP_PORT_REGNAME,
                                         FALCON_DEFAULT_QM_RPC_IP_PORT,
                                         g_wszRpcIpPort,
                                         RPCSRV_START_QM_IP_EP,
                                         TRUE,
                                         &SD,
                                         g_cMaxCalls ) ;
    if(statusIP == RPC_S_OK)
    {
        s_dwRpcIpPort = (DWORD) _wtol (g_wszRpcIpPort) ;
        //
        // Server machine need two tcp endpoints to support rundown.
        // The main endpoint is used for all calls except MQReceive which
        // use the alternate endpoint (EP2).
        //
        statusIP = QMInitializeNetworkRpcServer(
                                         FALCON_QM_RPC_IP_PORT_REGNAME2,
                                         FALCON_DEFAULT_QM_RPC_IP_PORT2,
                                         g_wszRpcIpPort2,
                                         RPCSRV_START_QM_IP_EP2,
                                         FALSE,
                                         &SD,
                                         g_cMaxCalls ) ;
       if(statusIP == RPC_S_OK)
       {
           s_dwRpcIpPort2 = (DWORD) _wtol (g_wszRpcIpPort2) ;

           ASSERT(s_dwRpcIpPort) ;
           ASSERT(s_dwRpcIpPort2) ;
       }
    }


    if (statusIP || statusLocal)
    {
       //
       // can't use a protocol. It's Ok if IP can't be used
       // (which probably mean it is not installed). But at least one of the
       // protocol must be OK, otherwise we terminate.
       //
       if (statusLocal)
       {
          REPORT_CATEGORY(QM_COULD_NOT_USE_LOCAL_RPC, CATEGORY_KERNEL);
       }
       if (statusIP)
       {
          REPORT_CATEGORY(QM_COULD_NOT_USE_TCPIP, CATEGORY_KERNEL);
       }
       if (statusIP && statusLocal)
       {
          return LogRPCStatus(statusLocal, s_FN, 90);
       }
    }

    RPC_STATUS  status;
    if (!g_fUsePredefinedEP)
    {
       status = RpcServerInqBindings( &g_pBindings ) ;
       if (status == RPC_S_OK)
       {
           status = RpcEpRegisterA( qmcomm_v1_0_s_ifspec,
                                   g_pBindings,
                                   NULL,
                                   NULL ) ;

           if (status == RPC_S_OK)
           {
               status = RpcEpRegisterA( qmcomm2_v1_0_s_ifspec,
                                        g_pBindings,
                                        NULL,
                                        NULL ) ;

               if (status == RPC_S_OK)
               {
                   status = RpcEpRegisterA( qm2qm_v1_0_s_ifspec,
                                            g_pBindings,
                                            NULL,
                                            NULL ) ;
               }
           }
       }

       DBGMSG((DBGMOD_DS, DBGLVL_ERROR,
             TEXT("QMRPCSRV: Registering Endpoints, status- %lxh"), status)) ;

       if (status != RPC_S_OK)
       {
          //
          // can't register endpoints, can't be rpc server
          //
          return LogRPCStatus(RPC_S_PROTSEQ_NOT_SUPPORTED, s_FN, 100);
       }

    }


    status = RpcServerRegisterIf2( qmcomm_v1_0_s_ifspec,
                                   NULL,
                                   NULL,
                                   RPC_IF_AUTOLISTEN,
                                   g_cMaxCalls,
                                   MSMQ_DEFAULT_MESSAGE_SIZE_LIMIT,
                                   NULL );
    DBGMSG((DBGMOD_RPC, DBGLVL_INFO,
               _TEXT("RpcServerRegisterIf2(rtqm) returned 0x%x"), status)) ;

    if (status)
    {
        return LogRPCStatus(status, s_FN, 110);
    }

    status = RpcServerRegisterIf2( qmcomm2_v1_0_s_ifspec,
                                   NULL,
                                   NULL,
                                   RPC_IF_AUTOLISTEN,
                                   g_cMaxCalls,
                                   MSMQ_DEFAULT_MESSAGE_SIZE_LIMIT,
                                   NULL );
    DBGMSG((DBGMOD_RPC, DBGLVL_INFO,
               _TEXT("RpcServerRegisterIf2(rtqm2) returned 0x%x"), status)) ;

    if (status)
    {
        return LogRPCStatus(status, s_FN, 130);
    }

    status = RpcServerRegisterIfEx( qmrepl_v1_0_s_ifspec,
                                    NULL,
                                    NULL,
                                    RPC_IF_AUTOLISTEN,
                                    g_cMaxCalls,
                                    NULL);
    DBGMSG((DBGMOD_RPC, DBGLVL_INFO,
               _TEXT("RpcServerRegisterIfEx(qmrpel) returned 0x%x"), status)) ;

    if(status)
    {
       return LogRPCStatus(status, s_FN, 140);
    }

    status = RpcServerRegisterIfEx( qmmgmt_v1_0_s_ifspec,
                                    NULL,
                                    NULL,
                                    RPC_IF_AUTOLISTEN,
                                    g_cMaxCalls,
                                    NULL);
    DBGMSG((DBGMOD_RPC, DBGLVL_INFO,
               _TEXT("RpcServerRegisterIfEx(qmmgmt) returned 0x%x"), status)) ;

    if(status)
    {
       return LogRPCStatus(status, s_FN, 150);
    }

    status = RpcServerRegisterIfEx( qm2qm_v1_0_s_ifspec,
                                    NULL,
                                    NULL,
                                    RPC_IF_AUTOLISTEN,
                                    g_cMaxCalls,
                                    NULL);
   DBGMSG((DBGMOD_RPC, DBGLVL_INFO,
             _TEXT ("RpcServerRegisterIfEx(qm2qm) returned 0x%x"),status)) ;

    if (status)
    {
        return LogRPCStatus(status, s_FN, 160);
    }

    status = RpcServerRegisterAuthInfo(NULL, RPC_C_AUTHN_WINNT, NULL, NULL);

    DBGMSG((DBGMOD_DS, DBGLVL_TRACE,
           _TEXT("RpcServerRegisterAuthInfo(ntlm) returned 0x%x"), status));

    if (status != RPC_S_OK)
    {
       return LogRPCStatus(status, s_FN, 165);
    }

    //
    // Register kerberos authenticaton. This is needed for LocalSystem
    // services to be able to do remote read.
    // Ignore errors, as this may fail in nt4 domains.
    //
    // Before registering, see if computer sid is cached locally, in
    // registry. If not, it means that we're not in a win2k domain. In that
    // case, do not register Kerberos. This will also happen in a win2k
    // domain, if all msmq servers are msmq1.0. That's fine too, as win2k
    // LocalSystem services will use ntlm when talking with the msmq servers,
    // not Kerberos.
    // Note that Kerbeors registration below will succeed even in a nt4
    // domain, where there is no KDC to grant us any ticket. Instead of being
    // a Don Quichott, fighting lost battles trying to convince others that
    // this is a BUG, I'll just workaround it...
    // How did he say in his mail ? Be Smart !!!...
    //
    DWORD dwSidSize = 0 ;
    PSID pMachineSid = MQSec_GetLocalMachineSid( FALSE, //   fAllocate
                                                &dwSidSize ) ;
    if ((pMachineSid == NULL) && (dwSidSize == 0))
    {
        //
        // Do NOT even try Kerberos.
        //
        DBGMSG((DBGMOD_RPC, DBGLVL_WARNING,
                TEXT("MQQM: Not listening on Kerberos for remote read.")));

        return RPC_S_OK ;
    }

    //
    // kerberos needs principal name.
    //
    LPWSTR pwszPrincipalName = NULL;
    status = RpcServerInqDefaultPrincName( RPC_C_AUTHN_GSS_KERBEROS,
                                          &pwszPrincipalName );
    if (status != RPC_S_OK)
    {
        DBGMSG((DBGMOD_RPC, DBGLVL_WARNING, TEXT(
           "MQQM: RpcServerInqDefaultPrincName() returned 0x%x"), status)) ;

        LogRPCStatus(status, s_FN, 120);
        return RPC_S_OK ;
    }

    DBGMSG((DBGMOD_RPC, DBGLVL_TRACE, TEXT(
      "MQQM: RpcServerInqDefaultPrincName() returned %ls"), pwszPrincipalName)) ;

    status = RpcServerRegisterAuthInfo( pwszPrincipalName,
                                        RPC_C_AUTHN_GSS_KERBEROS,
                                        NULL,
                                        NULL );
    RpcStringFree(&pwszPrincipalName);

    DBGMSG((DBGMOD_RPC, DBGLVL_TRACE, TEXT(
       "MQQM: RpcServerRegisterAuthInfo(Kerberos) returned 0x%x"), status));

    if (status != RPC_S_OK)
    {
       LogRPCStatus(status, s_FN, 180);
    }

    return RPC_S_OK ;
}

/*====================================================

Function:  QMGetRTQMServerPort()
           QMGetQMQMServerPort()

Arguments:

Return Value:

=====================================================*/

DWORD  GetQMServerPort( IN DWORD dwPortType )
{
   DWORD dwPort = 0 ;
   PORTTYPE rrPort = (PORTTYPE) dwPortType ;

   if (dwPortType == (DWORD) -1)
   {
      // Error. return null port.
   }
   else if (rrPort == IP_HANDSHAKE)
   {
      dwPort = s_dwRpcIpPort ;
   }
   else if (rrPort == IP_READ)
   {
      dwPort = s_dwRpcIpPort2 ;
   }

   ASSERT((dwPort & 0xffff0000) == 0) ;

   return dwPort ;
}

DWORD  QMGetRTQMServerPort( /*[in]*/ handle_t hBind,
                            /*[in]*/ DWORD    dwPortType )
{
   return  GetQMServerPort( dwPortType ) ;
}

DWORD   qm2qm_v1_0_QMGetRemoteQMServerPort( /*[in]*/ handle_t hBind,
                                            /*[in]*/ DWORD    dwPortType )
{
   return  GetQMServerPort( dwPortType ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qmsecutl.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:
    qmsecutl.h

    QM security related stuff.

Author:

    Boaz Feldbaum (BoazF) 26-Mar-1996.

--*/

#ifndef _QMSECUTL_H_
#define _QMSECUTL_H_

#ifdef MQUTIL_EXPORT
#undef MQUTIL_EXPORT
#endif
#define MQUTIL_EXPORT DLL_IMPORT

#include <mqcrypt.h>
#include <qmpkt.h>
#include <cqueue.h>
#include "cache.h"
#include "csecobj.h"
#include "authz.h"
#include "autoauthz.h"


// CQMDSSecureableObject -
//      1. Holds the security descriptor of a DS object.
//      2. Provides methods to:
//      2.1 Set and get the security descriptor
//      2.2 Verify various access rights on the object.
class CQMDSSecureableObject : public CSecureableObject
{
public:
    CQMDSSecureableObject(
        AD_OBJECT eObject,
        const GUID *pGuid,
        BOOL fInclSACL,
        BOOL fTryDS,
        LPCWSTR szObjectName);

    CQMDSSecureableObject(
        AD_OBJECT eObject,
        const GUID *pGuid,
        PSECURITY_DESCRIPTOR pSD,
        LPCWSTR szObjectName);

    ~CQMDSSecureableObject();

private:
    HRESULT GetObjectSecurity();
    HRESULT SetObjectSecurity();

private:
    const GUID *m_pObjGuid;
    BOOL m_fInclSACL;
    BOOL m_fTryDS;
    BOOL m_fFreeSD;
};

// CQMSecureablePrivateObject -
//      1. Holds the security descriptor of a QM object.
//      2. Provides methods to:
//      2.1 Set and get the security descriptor
//      2.2 Verify various access rights on the object.
class CQMSecureablePrivateObject : public CSecureableObject
{
public:
    CQMSecureablePrivateObject(AD_OBJECT, ULONG ulID);
    ~CQMSecureablePrivateObject();

private:
    HRESULT GetObjectSecurity();
    HRESULT SetObjectSecurity();

private:
    ULONG m_ulID;
};


class CAuthzClientContext : public CCacheValue
{
public:
    CAUTHZ_CLIENT_CONTEXT_HANDLE m_hAuthzClientContext;

private:
    ~CAuthzClientContext() {}
};

typedef CAuthzClientContext* PCAuthzClientContext;

inline void AFXAPI DestructElements(PCAuthzClientContext* ppAuthzClientContext, int nCount)
{
    for (; nCount--; ppAuthzClientContext++)
    {
        (*ppAuthzClientContext)->Release();
    }
}


void
GetClientContext(
	PSID pSenderSid,
    USHORT uSenderIdType,
	PCAuthzClientContext* ppAuthzClientContext
	);


HRESULT
QMSecurityInit(
    void
    );

HRESULT
VerifyOpenPermission(
    CQueue* pQueue,
    const QUEUE_FORMAT* pQueueFormat,
    DWORD dwAccess,
    BOOL fJournalQueue,
    BOOL fLocalQueue
    );

HRESULT
VerifyMgmtPermission(
    const GUID* MachineId,
    LPCWSTR MachineName
    );

HRESULT
VerifyMgmtGetPermission(
    const GUID* MachineId,
    LPCWSTR MachineName
    );

HRESULT
CheckPrivateQueueCreateAccess(
    void
    );


HRESULT
SetMachineSecurityCache(
    const VOID *pSD,
    DWORD dwSDSize
    );


HRESULT
GetMachineSecurityCache(
    PSECURITY_DESCRIPTOR pSD,
    LPDWORD lpdwSDSize
    );


HRESULT
VerifySendAccessRights(
    CQueue *pQueue,
    PSID pSenderSid,
    USHORT uSenderIdType
    );


HRESULT
VerifySignature(
    CQmPacket * PktPtrs
    );

HRESULT
GetSendQMKeyxPbKey(
    IN  const GUID *pguidQM,
    IN  enum enumProvider eProvider ) ;

HRESULT
GetSendQMSymmKeyRC2(
    IN  const GUID *pguidQM,
    IN  enum enumProvider eProvider,
    HCRYPTKEY *phSymmKey,
    BYTE **ppEncSymmKey,
    DWORD *pdwEncSymmKeyLen,
    CCacheValue **ppQMCryptInfo
    );

HRESULT
GetSendQMSymmKeyRC4(
    IN  const GUID *pguidQM,
    IN  enum enumProvider eProvider,
    HCRYPTKEY *phSymmKey,
    BYTE **ppEncSymmKey,
    DWORD *pdwEncSymmKeyLen,
    CCacheValue **ppQMCryptInfo
    );

HRESULT
GetRecQMSymmKeyRC2(
    IN  const GUID *pguidQM,
    IN  enum enumProvider eProvider,
    HCRYPTKEY *phSymmKey,
    const BYTE *pbEncSymmKey,
    DWORD dwEncSymmKeyLen,
    CCacheValue **ppQMCryptInfo,
    OUT BOOL  *pfNewKey
    );

HRESULT
GetRecQMSymmKeyRC4(
    IN  const GUID *pguidQM,
    IN  enum enumProvider eProvider,
    HCRYPTKEY *phSymmKey,
    const BYTE *pbEncSymmKey,
    DWORD dwEncSymmKeyLen,
    CCacheValue **ppQMCryptInfo
    );

HRESULT
SignQMSetProps(
    IN     BYTE    *pbChallenge,
    IN     DWORD   dwChallengeSize,
    IN     DWORD_PTR dwContext,
    OUT    BYTE    *pbSignature,
    OUT    DWORD   *pdwSignatureSize,
    IN     DWORD   dwSignatureMaxSize
    );

HRESULT
QMSignGetSecurityChallenge(
    IN     BYTE    *pbChallenge,
    IN     DWORD   dwChallengeSize,
    IN     DWORD_PTR dwUnused, // dwContext
    OUT    BYTE    *pbSignature,
    IN OUT DWORD   *pdwSignatureSize,
    IN     DWORD   dwSignatureMaxSize
    );

void
InitSymmKeys(
    const CTimeDuration& CacheBaseLifetime,
    const CTimeDuration& CacheEnhLifetime,
    DWORD dwSendCacheSize,
    DWORD dwReceiveCacheSize
    );



//
// Structure for cached certificate information.
//
class CERTINFO : public CCacheValue
{
public:
	CERTINFO() : fSelfSign(false)    {}

public:
    CHCryptProv hProv;  // A CSP handle associated with the cert.
    CHCryptKey hPbKey;  // A KEY handle to the public key in the cert.
    P<VOID> pSid;       // The SID of the user that registered the certificate.
	bool fSelfSign;		// flag that indicates if the certificate is self signed
private:
    ~CERTINFO() {}
};



typedef CERTINFO *PCERTINFO;


HRESULT
GetCertInfo(
    CQmPacket *PktPtrs,
    PCERTINFO *ppCertInfo,
	BOOL fNeedSidInfo
    );


NTSTATUS
_GetDestinationFormatName(
	IN QUEUE_FORMAT *pqdDestQueue,
	IN WCHAR        *pwszTargetFormatName,
	IN OUT DWORD    *pdwTargetFormatNameLength,
	OUT WCHAR      **ppAutoDeletePtr,
	OUT WCHAR      **ppwszTargetFormatName
	);


void
InitUserMap(
    CTimeDuration CacheLifetime,
    DWORD dwUserCacheSize
    );


HRESULT
HashMessageProperties(
    IN HCRYPTHASH hHash,
    IN CONST CMessageProperty* pmp,
    IN CONST QUEUE_FORMAT* pqdAdminQueue,
    IN CONST QUEUE_FORMAT* pqdResponseQueue
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qmremote.cpp ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    qmremote.cpp

Abstract:


Author:

    Doron Juster  (DoronJ)

--*/

#include "stdh.h"
#include "cqmgr.h"
#include "cqueue.h"
#include "qmrt.h"
#include "qm2qm.h"
#include "qmthrd.h"
#include "acdef.h"
#include "acioctl.h"
#include "acapi.h"
#include "qmutil.h"
#include "cs.h"
#include "phinfo.h"
#include "crrthrd.h"
#include "_mqrpc.h"
#include "qmrpcsrv.h"
#include "mqsocket.h"
#include "license.h"
#include <Fn.h>
#include <version.h>

#include "qmremote.tmh"

static WCHAR *s_FN=L"qmremote";

//
// This object manage the threads pool used for remote reading.
//
CRRThreadsPool *pRRThreadsPool = NULL ;

#define MAX_REMOTE_THREADS  32
#define MAX_THREAD_TIMEOUT  1000

long  g_iRemoteThreadsCount = 0 ;

extern HANDLE      g_hAc;
extern CQueueMgr   QueueMgr;

extern CContextMap g_map_QM_cli_pQMQueue;
extern CContextMap g_map_QM_srv_pQMQueue;
extern CContextMap g_map_QM_srv_hQueue;
extern CContextMap g_map_QM_dwpContext;

//
// The CS protect handles mapping, to prevent AV in race condition.
//
static CCriticalSection s_csRemoteMapping ;

//
// from qmcommnd.cpp
//
extern
HRESULT
OpenQueueInternal(
    QUEUE_FORMAT*   pQueueFormat,
    DWORD           dwCallingProcessID,
    DWORD           dwDesiredAccess,
    DWORD           dwShareMode,
    DWORD           hRemoteQueue,
    LPWSTR*         lplpRemoteQueueName,
    IN DWORD        *dwpQueue,
    HANDLE		    *phQueue,
    DWORD           dwpRemoteContext,
    OUT CQueue**    ppLocalQueue
    );

//-------------------------------------------------------
//
//  Structures and macros for the remote reading code
//
//-------------------------------------------------------

#define PACKETSIZE(pMsg) \
   (((struct CBaseHeader *) pMsg)->GetPacketSize())

typedef struct {
   HANDLE   hQueue ;
   CQueue*  pQueue ; // pointer to queue object on server side.
   GUID     ClientQMGuid ;
   BOOL     fLicensed ;
   DWORD    dwpQueueMapped; //srv_pQMQueue mapped on the server (for cleanup)
   DWORD    dwpQHandleMapped; //srv_pQMQueue mapped on the server (for cleanup)
} REMOTESESSION_CONTEXT_TYPE;

typedef struct {
   HANDLE   hQueue ;
   HACCursor32 hCursor ;
   ULONG    ulTimeout ;
   ULONG    ulAction ;
   CBaseHeader*  lpPacket ;
   CPacket* lpDriverPacket;
} REMOTEREAD_CONTEXT_TYPE;

typedef struct _REMOTEREADTHREAD {
   CACRequest* pRequest ;
   CRRQueue*   pLocalQueue ;
   handle_t    hBind ;
   UCHAR       RemoteQmMajorVersion;
   UCHAR       RemoteQmMinorVersion;
   USHORT      RemoteQmBuildNumber;
} REMOTEREADTHREAD, *LPREMOTEREADTHREAD ;

typedef struct {
   HANDLE hQueue;             //srv_hACQueue
   DWORD dwpQHandleMapped;	  // hQueue mapped
   DWORD dwpContextMapped;   //dwpContext, mapped to 32 bit
   DWORD dwpQueueMapped;     //srv_pQMQueue, mapped to 32 bit
} CTX_OPENREMOTE_HANDLE_TYPE;

//-------------------------------------------------------------------
//
//  HRESULT QMGetRemoteQueueName
//
//-------------------------------------------------------------------


HRESULT QMGetRemoteQueueName(
    /* [in] */   handle_t                          hBind,
    /* [in] */   DWORD                             pQueue,
    /* [string][full][out][in] */ LPWSTR __RPC_FAR *lplpRemoteQueueName)
{
   if (!pQueue || !lplpRemoteQueueName)
   {
      //
      // This is a "hack". a remote client will call this function with
      // two null pointers just to determine which protocols are supported.
      // The caller will handle MQ_ERROR as ok status.
      // See rt\rtmain.cpp, void RTpBindQMService().
      // For all other cases this is a real error.
      //
      return LogHR(MQ_ERROR, s_FN, 10);
   }

   CRRQueue * pCRRQueue = (CRRQueue *) GET_FROM_CONTEXT_MAP(g_map_QM_cli_pQMQueue, pQueue, s_FN, 230); //may throw an exception on win64
   LPCWSTR pName = pCRRQueue->GetQueueName() ;
   LPWSTR pRName = (LPWSTR) midl_user_allocate(
                                sizeof(WCHAR) * (1 + wcslen(pName)) ) ;
   if( pRName == NULL )
   {
	   return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 11);
   }
   wcscpy(pRName, pName) ;
   *lplpRemoteQueueName = pRName ;
   return MQ_OK ;
}

//-------------------------------------------------------------------
//
//   QMOpenRemoteQueue
//
//  Server side of RPC call. Server side of remote-reader.
//  Open a queue for remote-read on behalf of a client machine.
//
//-------------------------------------------------------------------

HRESULT
QMOpenRemoteQueue(
    handle_t  hBind,
    PCTX_OPENREMOTE_HANDLE_TYPE *phContext,
    DWORD                       *dwpContext,
    QUEUE_FORMAT* pQueueFormat,
    DWORD dwCallingProcessID,
    DWORD dwAccess,
    DWORD fExclusiveReceive,
    GUID* pLicGuid,
    DWORD dwOperatingSystem,
    DWORD *pQueue,
    DWORD *phQueue
    )
{
    DBGMSG((DBGMOD_RPC, DBGLVL_INFO, _TEXT("In QMOpenRemoteQueue")));

    if((dwpContext == 0) || (phQueue == NULL) || (pQueue == NULL) || (pQueueFormat == NULL))
    {
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 19);
    }

    if(!pQueueFormat->IsValid())
    {
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 191);
    }


    *phContext = NULL;
    *dwpContext = 0 ;
    *phQueue = NULL ;
    *pQueue = 0;

    if (!g_QMLicense.NewConnectionAllowed(!OS_SERVER(dwOperatingSystem), pLicGuid))
    {
        return LogHR(MQ_ERROR_DEPEND_WKS_LICENSE_OVERFLOW, s_FN, 20);
    }

    CQueue *pLocalQueue = NULL;
	HANDLE hQueue;
    HRESULT hr = OpenQueueInternal(
                        pQueueFormat,
                        GetCurrentProcessId(),
                        dwAccess,
                        fExclusiveReceive,
                        NULL,
                        NULL,
                        NULL /* dwpRemoteQueue */,
                        &hQueue,
                        0,
                        &pLocalQueue
                        ) ;

    if (SUCCEEDED(hr) && (hQueue != NULL))
    {
        //
        // Create a context to hold the queue handle.
        //
        P<CTX_OPENREMOTE_HANDLE_TYPE> pctx = new CTX_OPENREMOTE_HANDLE_TYPE ; //for cleanup in case of exception later
        DWORD dwContext = ADD_TO_CONTEXT_MAP(g_map_QM_dwpContext, (CTX_OPENREMOTE_HANDLE_TYPE *)pctx, s_FN, 320); //may throw a bad_alloc exception
        CAutoDeleteDwordContext cleanup_dwpContext(g_map_QM_dwpContext, dwContext); //for local cleanup in case of exception later

		DWORD dwpQueue = ADD_TO_CONTEXT_MAP(g_map_QM_srv_pQMQueue, pLocalQueue, s_FN, 330); //may throw a bad_alloc exception
        CAutoDeleteDwordContext cleanup_dwpQueue(g_map_QM_srv_pQMQueue, dwpQueue); //for local cleanup in case of exception later

		DWORD dwphQueue = ADD_TO_CONTEXT_MAP(g_map_QM_srv_hQueue, hQueue, s_FN, 390); //may throw a bad_alloc exception

        cleanup_dwpContext.detach(); //local cleanup not needed anymore
		cleanup_dwpQueue.detach(); //local cleanup not needed anymore

        //
        // save mapped values in context for rundown/cleanup
        //
        pctx->hQueue = hQueue;
        pctx->dwpContextMapped = dwContext;
        pctx->dwpQueueMapped = dwpQueue;
		pctx->dwpQHandleMapped = dwphQueue;

        //
        // set return values
        //
        *dwpContext = dwContext;
        *phContext = (PCTX_OPENREMOTE_HANDLE_TYPE) pctx.detach();

        //
        // set srv_pQMQueue and srv_hQueue for RPC client
        //
        *pQueue = dwpQueue;
		*phQueue = dwphQueue;
    }

    return LogHR(hr, s_FN, 30);
}

//-------------------------------------------------------------------
//
//   QMCloseRemoteQueueContext
//
//  Close the context handle create in QMOpenRemoteQueue.
//
//-------------------------------------------------------------------

void QMCloseRemoteQueueContext(
    /* [out][in] */ PCTX_OPENREMOTE_HANDLE_TYPE __RPC_FAR *pphContext)
{
    DBGMSG((DBGMOD_RPC, DBGLVL_TRACE, _T("In QMCloseRemoteQueueContext")));

    if(*pphContext == 0)
        return;

    PCTX_OPENREMOTE_HANDLE_TYPE_rundown( *pphContext) ;
    *pphContext = NULL;
}

//---------------------------------------------------------------
//
//  RunDown functions to handle cleanup in case of RPC failure.
//
//---------------------------------------------------------------

void __RPC_USER
 PCTX_OPENREMOTE_HANDLE_TYPE_rundown( PCTX_OPENREMOTE_HANDLE_TYPE phContext)
{
    CTX_OPENREMOTE_HANDLE_TYPE *pContext = (CTX_OPENREMOTE_HANDLE_TYPE *) phContext;

    CS Lock(s_csRemoteMapping) ;

    DBGMSG((DBGMOD_RPC,DBGLVL_WARNING,_TEXT("In OPENREMOTE_rundown")));
    if (pContext->hQueue) //it can be zeroed out by the remote read session than needs the queue opened as well
    {
        ACCloseHandle(pContext->hQueue) ;
		
		DELETE_FROM_CONTEXT_MAP(g_map_QM_srv_hQueue, pContext->dwpQHandleMapped, s_FN, 400);
    }

    DELETE_FROM_CONTEXT_MAP(g_map_QM_dwpContext, pContext->dwpContextMapped, s_FN, 280);

	if (pContext->dwpQueueMapped) //it can be zeroed out by the remote read session than needs it in the map as well
    {
        DELETE_FROM_CONTEXT_MAP(g_map_QM_srv_pQMQueue, pContext->dwpQueueMapped, s_FN, 290);
    }

    delete pContext ;
}

//-------------------------------------------------------------------
//
//  HRESULT QMCreateRemoteCursor
//
//  Server side of RPC call. Server side of remote-reader.
//  Create a cursor for remote-read, on behalf of a client reader.
//
//-------------------------------------------------------------------

HRESULT QMCreateRemoteCursor(
    /* [in] */  handle_t          hBind,
    /* [in] */  struct CACTransferBufferV1 __RPC_FAR *,
    /* [in] */  DWORD             hQueue,
    /* [out] */ DWORD __RPC_FAR * phCursor)
{
   DBGMSG((DBGMOD_RPC,DBGLVL_INFO,_TEXT("In QMCreateRemoteCursor")));

   HANDLE hQueueReal = GET_FROM_CONTEXT_MAP(g_map_QM_srv_hQueue, hQueue, s_FN, 410);

   CACCreateLocalCursor cc;
   HRESULT rc = ACCreateCursor(hQueueReal, cc) ;
   *phCursor = (DWORD) cc.hCursor;

   return LogHR(rc, s_FN, 40);
}

//-------------------------------------------------------------------
//
// HRESULT qm2qm_v1_0_QMRemoteCloseCursor(
//
//  Server side of RPC call. Server side of remote-reader.
//  Close a remote cursor in local driver.
//
//-------------------------------------------------------------------

/* [call_as] */ HRESULT qm2qm_v1_0_QMRemoteCloseCursor(
    /* [in] */ handle_t hBind,
    /* [in] */ DWORD hQueue,
    /* [in] */ DWORD hCursor)
{
   DBGMSG((DBGMOD_RPC,DBGLVL_INFO,_TEXT("In QMRemoteCloseCursor")));

   __try
   {
      HRESULT hr = ACCloseCursor(g_hAc, (HACCursor32)hCursor);
      return LogHR(hr, s_FN, 50);
   }
   __except(EXCEPTION_EXECUTE_HANDLER)
   {
      //
      //  The exception is due to invalid parameter
      //
      DWORD dwStatus = GetExceptionCode();
      return LogNTStatus(dwStatus, s_FN, 55);
   }
}

//-------------------------------------------------------------------
//
// HRESULT qm2qm_v1_0_QMRemotePurgeQueue(
//
//  Server side of RPC call. Server side of remote-reader.
//  Purge local queue.
//
//-------------------------------------------------------------------

/* [call_as] */ HRESULT qm2qm_v1_0_QMRemotePurgeQueue(
    /* [in] */ handle_t hBind,
    /* [in] */ DWORD hQueue)
{
   DBGMSG((DBGMOD_RPC,DBGLVL_INFO,_TEXT("In QMRemoteCloseCursor")));

   __try
   {
	  HANDLE hQueueReal = GET_FROM_CONTEXT_MAP(g_map_QM_srv_hQueue, hQueue, s_FN, 370);

      HRESULT hr = ACPurgeQueue(hQueueReal);
      return LogHR(hr, s_FN, 60);
   }
   __except(EXCEPTION_EXECUTE_HANDLER)
   {
      //
      //  The exception is due to invalid parameter
      //
      DWORD dwStatus = GetExceptionCode();
      return LogNTStatus(dwStatus, s_FN, 70);

   }
}


static
bool
QMpIsLatestRemoteReadInterfaceSupported(
    UCHAR  Major,
    UCHAR  Minor,
    USHORT BuildNumber
    )
/*++

Routine Description:

    Check if the specified MSMQ version supports the latest RPC remote read interface.

Arguments:

    Major       - Major MSMQ version.

    Minor       - Minor MSMQ version.

    BuildNumber - MSMQ build number.

Return Value:

    true -  The specified MSMQ version supports latest interface.
    false - The specified MSMQ version doesn't support latest interface.

--*/
{
    //
    // Latest remote read RPC interface is supported from version 5.1.951
    //

    if (Major > 5)
    {
        return true;
    }

    if (Major < 5)
    {
        return false;
    }

    if (Minor > 1)
    {
        return true;
    }

    if (Minor < 1)
    {
        return false;
    }

    return (BuildNumber >= 951);

} // QMpIsLatestRemoteReadInterfaceSupported


static
HRESULT
QMpIssueRemoteRead(
    handle_t &                   hBind,
    PCTX_RRSESSION_HANDLE_TYPE & hRemoteContext,
    REMOTEREADDESC2 &            stRemoteReadDesc2,
    bool                         fRemoteQmSupportsLatest,
    bool                         fLookupId,
    ULONGLONG                    LookupId
    )
    throw()
/*++

Routine Description:

    Issue the RPC call on the client side remote read.
    Translate RPC exception to error codes.

Arguments:

    hBind             - Binding handle.

    hRemoteContext    - Remote read context structure.

    stRemoteReadDesc2 - Information and flags for the remote operation.

    fRemoteQmSupportsLatest - Flag indicating whether the remote QM supports latest remote read interface or not.

    fLookupId         - Flag indicating whether to remote read by lookupid or not.

    LookupId          - Lookupid index, relevant only when fLookupId is true.

Return Value:

    MQ_OK - The operation completed successfully.

    MQ_ERROR_QUEUE_NOT_AVAILABLE - RPC raises exception on client side.

    MQ_ERROR_OPERATION_NOT_SUPPORTED_BY_REMOTE_COMPUTER - Remote QM does not
      support the requested operation.

--*/
{
    if (fLookupId && !fRemoteQmSupportsLatest)
    {
        return LogHR(MQ_ERROR_OPERATION_NOT_SUPPORTED_BY_REMOTE_COMPUTER, s_FN, 75);
    }

    HANDLE hThread = NULL;
    __try
    {
        RegisterRRCallForCancel(&hThread, stRemoteReadDesc2.pRemoteReadDesc->ulTimeout);

        __try
        {
            if (fLookupId)
            {
                ASSERT(fRemoteQmSupportsLatest);

                HRESULT hr = R_RemoteQMStartReceiveByLookupId(
                           hBind,
                           LookupId,
                           &hRemoteContext,
                           &stRemoteReadDesc2);

                return LogHR(hr, s_FN, 77);
            }

            if (fRemoteQmSupportsLatest)
            {
                return LogHR(R_RemoteQMStartReceive2(hBind, &hRemoteContext, &stRemoteReadDesc2), s_FN, 78);
            }

            return LogHR(R_RemoteQMStartReceive(hBind, &hRemoteContext, stRemoteReadDesc2.pRemoteReadDesc), s_FN, 79);
        }
        __finally
        {
            UnregisterRRCallForCancel(hThread);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return LogHR(MQ_ERROR_QUEUE_NOT_AVAILABLE, s_FN, 81);
    }
} // QMpIssueRemoteRead


//---------------------------------------------------------
//
//  DWORD WINAPI RemoteReadThread(LPVOID pV)
//
//  Thread on local machine which connect to remote QM and get a
//  message from it. At present (apr-96), each call to MQReceive()
//  will create a separate thread.
//  To be optimized in the future.
//
//---------------------------------------------------------


DWORD WINAPI RemoteReadThread(LPVOID pV)
{
    RRTHREADDISPATCHDATA *pDispatchData = (RRTHREADDISPATCHDATA*) pV ;

    while(1)
    {
        {   // Ref scope
            LPREMOTEREADTHREAD pRRThread = (LPREMOTEREADTHREAD)
                                               pDispatchData->pRRThreadData ;

            if ((pDispatchData->dwLastActiveTime == 0) && !pRRThread)
            {
                //
                // We're asked to exit. NULL hEvent tell the dispatcher
                // that the thread does not exist.
                //
                CloseHandle( pDispatchData->hEvent ) ;
                delete pDispatchData ;
                return 0 ;
            }

            ASSERT(pRRThread) ;
            ASSERT(pRRThread->hBind) ;

            //
            // Auto-Release the queue when thread terminate (end of remote read).
            //
            R<CRRQueue> Ref = pRRThread->pLocalQueue ;

            CACRequest *pRequest = pRRThread->pRequest ;
            ASSERT(pRequest) ;

            REMOTEREADDESC stRemoteReadDesc;
            REMOTEREADDESC2 stRemoteReadDesc2;
            stRemoteReadDesc2.pRemoteReadDesc = &stRemoteReadDesc;
            stRemoteReadDesc2.SequentialId = 0;

            handle_t hBind = (handle_t) pRRThread->hBind ;
            stRemoteReadDesc.hRemoteQueue = pRequest->Remote.Context.srv_hACQueue;
            stRemoteReadDesc.hCursor      = pRequest->Remote.Read.hRemoteCursor ;
            stRemoteReadDesc.ulAction     = pRequest->Remote.Read.ulAction ;
            stRemoteReadDesc.ulTimeout    = pRequest->Remote.Read.ulTimeout ;
            stRemoteReadDesc.dwSize       = 0 ;
            stRemoteReadDesc.lpBuffer     = NULL ;
            stRemoteReadDesc.dwpQueue     = pRequest->Remote.Context.srv_pQMQueue;
            stRemoteReadDesc.dwRequestID  = pRequest->Remote.Read.ulTag;
            stRemoteReadDesc.Reserved     = 0;
            stRemoteReadDesc.eAckNack     = RR_UNKNOWN ;
            stRemoteReadDesc.dwArriveTime = 0;

            HRESULT hr;

            BOOL fSendEnd = (stRemoteReadDesc.ulAction & MQ_ACTION_PEEK_MASK) != MQ_ACTION_PEEK_MASK &&
                            (stRemoteReadDesc.ulAction & MQ_LOOKUP_PEEK_MASK) != MQ_LOOKUP_PEEK_MASK;
            //
            // This critical section guard against the possibility that an
            // "end" message of operation #N will arrive the server machine
            // after a new "start" of operation #(N+1). If this happen, and
            // the reader use cursor, then on operation #(N+1) he'll get the
            // error ALREADY_RECEIVED. This is because message from operation
            // #N is still marked as received and the cursor move only when
            // it is unmarked.
            // Note that EnterCriticalSection cannot raise since spinlock was already allocated.
            //
            EnterCriticalSection(
                (CRITICAL_SECTION *)pRequest->Remote.Context.pCloseCS) ;
            LeaveCriticalSection(
                (CRITICAL_SECTION *)pRequest->Remote.Context.pCloseCS) ;

            PCTX_RRSESSION_HANDLE_TYPE hRemoteContext = NULL ;

            bool fRemoteQmSupportsLatest = QMpIsLatestRemoteReadInterfaceSupported(
                                                   pRRThread->RemoteQmMajorVersion,
                                                   pRRThread->RemoteQmMinorVersion,
                                                   pRRThread->RemoteQmBuildNumber
                                               );
            bool fReceiveByLookupId = pRequest->Remote.Read.fReceiveByLookupId;

            hr = QMpIssueRemoteRead(
                     hBind,
                     hRemoteContext,
                     stRemoteReadDesc2,
                     fRemoteQmSupportsLatest,
                     fReceiveByLookupId,
                     pRequest->Remote.Read.LookupId
                     );

            if (hr == MQ_OK)
            {
                //
                // Message received ok from remote QM. Try to insert it into
                // local "proxy" queue.
                // Note that EnterCriticalSection cannot raise since spinlock was already allocated.
                //
                if (fSendEnd)
                {
                    EnterCriticalSection(
                        (CRITICAL_SECTION *)pRequest->Remote.Context.pCloseCS) ;
                }

                CACPacketPtrs packetPtrs = {NULL, NULL};
                hr = ACAllocatePacket(  g_hAc,
                                        ptReliable,
                                        stRemoteReadDesc.dwSize,
                                        packetPtrs,
                                        FALSE);

                HRESULT hrPut = MQ_OK;
                if (hr == MQ_OK)
                {
                    ASSERT(packetPtrs.pPacket) ;
                    MoveMemory( packetPtrs.pPacket,
                                stRemoteReadDesc.lpBuffer,
                                stRemoteReadDesc.dwSize ) ;

                    if (stRemoteReadDesc.lpBuffer)
                    {
                        delete stRemoteReadDesc.lpBuffer ;
                        stRemoteReadDesc.lpBuffer = NULL ;
                    }

                    CPacketInfo* ppi = reinterpret_cast<CPacketInfo*>(packetPtrs.pPacket) - 1;
                    ppi->ArrivalTime(stRemoteReadDesc.dwArriveTime);
                    ppi->SequentialID(stRemoteReadDesc2.SequentialId);

                    hrPut = ACPutRemotePacket(
                            pRequest->Remote.Context.cli_hACQueue,
                            pRequest->Remote.Read.ulTag,
                            packetPtrs.pDriverPacket
                            );
                    LogHR(hrPut, s_FN, 146);
                }

                //
                // notify server side about success/failure of the "put".
                // Only for GET. No need to ack/nack for PEEK.
                //
                if (fSendEnd)
                {
                    if ((FAILED(hr)) || (FAILED(hrPut)))
                    {
                        stRemoteReadDesc.eAckNack = RR_NACK ;
                    }
                    else
                    {
                        stRemoteReadDesc.eAckNack = RR_ACK ;
                    }

                    HANDLE hThread = NULL;
                    RegisterRRCallForCancel( &hThread, 0) ;

                    try
                    {
                        ASSERT(hRemoteContext) ;
                        HRESULT hr1 = RemoteQMEndReceive(
                                        hBind,
                                        &hRemoteContext,
                                        (DWORD) stRemoteReadDesc.eAckNack) ;
                        LogHR(hr1, s_FN, 126);
                    }
                    catch(...)
                    {
                        //
                        //  RPC failed. Do nothing.
                        //
                        LogIllegalPoint(s_FN, 62);
                    }

                    UnregisterRRCallForCancel(hThread) ;

                    LeaveCriticalSection(
                        (CRITICAL_SECTION *)pRequest->Remote.Context.pCloseCS) ;
                }
            }

            if (hr != MQ_OK)
            {
                LogHR(hr, s_FN, 127);

                // Error on remote QM. Notify local driver so it terminte the
                // read request.
                //
                if (hr != MQ_INFORMATION_REMOTE_CANCELED_BY_CLIENT)
                {
                    hr =  ACCancelRequest(
                            pRequest->Remote.Context.cli_hACQueue,
                            hr,
                            pRequest->Remote.Read.ulTag );
                }
                else
                {
                    DBGMSG((DBGMOD_RPC,DBGLVL_INFO,
                        _TEXT("RemoteReadThread: Cancelled by client"))) ;
                }
            }

            if (stRemoteReadDesc.lpBuffer)
            {
                delete stRemoteReadDesc.lpBuffer ;
            }

            delete pRequest ;
            delete pRRThread ;
        }  // end of Ref scope

        pDispatchData->pRRThreadData = NULL ;
        pDispatchData->dwLastActiveTime = GetTickCount() ;
        DWORD dwResult = WaitForSingleObject( pDispatchData->hEvent, INFINITE ) ;
        if (dwResult != WAIT_OBJECT_0)
        {
            LogNTStatus(GetLastError(), s_FN, 196);
        }
    }

    return (0) ;
}

//********************************************************************
//
//  Methods of CRRQueue.
//
//  This is a special "proxy" queue object on client side of
//  remote-read.
//
//********************************************************************

//---------------------------------------------------------
//
// Function:         CRRQueue::CRRQueue
//
// Description:      Constructor
//
//---------------------------------------------------------

CRRQueue::CRRQueue(
    IN const QUEUE_FORMAT* pQueueFormat,
    IN PQueueProps         pQueueProp
    ) :
    m_hRemoteBind(NULL),
    m_hRemoteBind2(NULL),
    m_RemoteQmMajorVersion(0),
    m_RemoteQmMinorVersion(0),
    m_RemoteQmBuildNumber(0)
{
    m_dwSignature = QUEUE_SIGNATURE ;
    m_fRemoteProxy = TRUE ;

    ASSERT(pQueueFormat != NULL);

    DBGMSG((DBGMOD_QM, DBGLVL_INFO, _TEXT("CQueue Constructor for queue: %ls"),pQueueProp->lpwsQueuePathName));

    ASSERT(!pQueueProp->fIsLocalQueue) ;

    m_fLocalQueue  = FALSE ;

    InitNameAndGuid( pQueueFormat,
                     pQueueProp ) ;

//  BUGBUG
//   PerfRegisterQueue();

    m_dwcli_pQMQueueMapped = 0;
}

//---------------------------------------------------------
//
//  Function:      CRRQueue::~CRRQueue
//
//  Description:   destructor
//
//---------------------------------------------------------

CRRQueue::~CRRQueue()
{
    m_dwSignature = 0 ;

    UnBindRemoteQMService() ;

    if (m_qName)
    {
       delete [] m_qName;
    }
    if (m_qid.pguidQueue)
    {
       delete m_qid.pguidQueue;
    }

//  BUGBUG
//    PerfRemoveQueue();

    if (m_dwcli_pQMQueueMapped)
    {
       DELETE_FROM_CONTEXT_MAP(g_map_QM_cli_pQMQueue, m_dwcli_pQMQueueMapped, s_FN, 300);
    }
}

//---------------------------------------------------------
//
//  RPC_STATUS CRRQueue::UnBindRemoteQMService
//
//  Utility function to disconnect from a remote RPC QM.
//  This function free the binding handle.
//
//---------------------------------------------------------

HRESULT CRRQueue::UnBindRemoteQMService()
{
   RPC_STATUS rc = RPC_S_OK ;
   if (m_hRemoteBind)
   {
      rc = mqrpcUnbindQMService(&m_hRemoteBind, NULL);
      m_hRemoteBind  = NULL;
   }
   ASSERT(rc == RPC_S_OK);

   rc = RPC_S_OK ;
   if (m_hRemoteBind2)
   {
      rc = mqrpcUnbindQMService(&m_hRemoteBind2, NULL);
      m_hRemoteBind2 = NULL;
   }
   ASSERT(rc == RPC_S_OK);

   return LogHR(rc, s_FN, 80);
}


static
void
RemoteQueueNameToMachineName(
	LPCWSTR RemoteQueueName,
	AP<WCHAR>& MachineName
	)
/*++
Routine description:
    RemoteQueueName as returned by QMGetRemoteQueueName() and R_QMOpenQueue()
	functions from the QM, has a varying format. this function extracts the
	Machine name from that string

Arguments:
	MachineName - Allocated string holding the machine name.
 --*/
{
	LPCWSTR RestOfNodeName;

	try
	{
		//
		// Skip direct token type if it exists (like "OS:" or "HTTP://"...)
		//
		DirectQueueType Dummy;
		RestOfNodeName = FnParseDirectQueueType(RemoteQueueName, &Dummy);
	}
	catch(const exception&)
	{
		RestOfNodeName = RemoteQueueName;
		LogIllegalPoint(s_FN, 305);
	}

	try
	{
		//
		// Extracts machine name until seperator (one of "/" "\" ":")
		//
		FnExtractMachineNameFromDirectPath(
			RestOfNodeName,
			MachineName
			);
	}
	catch(const exception&)
	{
		//
		// No seperator found, so assume whole string is machine name
		//
		MachineName = newwcs(RestOfNodeName);
		LogIllegalPoint(s_FN, 315);
	}
}


VOID
qm2qm_v1_0_R_QMRemoteGetVersion(
    handle_t           /*hBind*/,
    UCHAR  __RPC_FAR * pMajor,
    UCHAR  __RPC_FAR * pMinor,
    USHORT __RPC_FAR * pBuildNumber
    )
/*++

Routine Description:

    Return version of this QM. RPC server side.

Arguments:

    hBind        - Binding handle.

    pMajor       - Points to output buffer to receive major version. May be NULL.

    pMinor       - Points to output buffer to receive minor version. May be NULL.

    pBuildNumber - Points to output buffer to receive build number. May be NULL.

Return Value:

    None.

--*/
{
    if (pMajor != NULL)
    {
        (*pMajor) = rmj;
    }

    if (pMinor != NULL)
    {
        (*pMinor) = rmm;
    }

    if (pBuildNumber != NULL)
    {
        (*pBuildNumber) = rup;
    }
} // qm2qm_v1_0_R_QMRemoteGetVersion


static
VOID
QMpGetRemoteQmVersion(
    handle_t & hBind,
    UCHAR *    pMajor,
    UCHAR *    pMinor,
    USHORT *   pBuildNumber
    )
    throw()
/*++

Routine Description:

    Query remote QM for its version. RPC client side.
    This RPC call was added in MSMQ 3.0 so querying an older QM will raise
    RPC exception and this routine will return 0 as the version (major=0,
    minor=0, BuildNumber=0).

Arguments:

    hBind        - Binding handle.

    pMajor       - Points to output buffer to receive remote QM major version. May be NULL.

    pMinor       - Points to output buffer to receive remote QM minor version. May be NULL.

    pBuildNumber - Points to output buffer to receive remote QM build number. May be NULL.

Return Value:

    None.

--*/
{
    HANDLE hThread = NULL ;
    RegisterRRCallForCancel(&hThread, 0) ;

    __try
    {
        R_RemoteQmGetVersion(hBind, pMajor, pMinor, pBuildNumber);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        (*pMajor) = 0;
        (*pMinor) = 0;
        (*pBuildNumber) = 0;
		LogIllegalPoint(s_FN, 325);
    }

    UnregisterRRCallForCancel(hThread) ;

} // QMpGetRemoteQmVersion


//---------------------------------------------------------
//
//  HRESULT  CRRQueue::BindRemoteQMService
//
//  Utility function to connect to a remote RPC QM.
//  This function creates the binding handle.
//
//---------------------------------------------------------

HRESULT  CRRQueue::BindRemoteQMService()
{
    if (m_hRemoteBind != 0)
    {
        return MQ_OK ;
    }

    //
    // Bug 507667
    // Albeit its name, use this CS to initialize the binding handle
    // at first open.
    //
    CS lock(m_cli_csRemoteClose) ;

    if (m_hRemoteBind != 0)
    {
        return MQ_OK ;
    }

    HRESULT hr = MQ_ERROR_SERVICE_NOT_AVAILABLE ;

    AP<WCHAR> MachineName;
	RemoteQueueNameToMachineName(GetQueueName(), MachineName);

    TCHAR* pPort =  g_wszRpcIpPort ;
    TCHAR* pPort2 =  g_wszRpcIpPort2 ;
    DWORD dwPortType  = (DWORD) IP_HANDSHAKE ;
    DWORD dwPortType2 = (DWORD) IP_READ ;

    GetPort_ROUTINE pfnGetPort = RemoteQMGetQMQMServerPort ;
    if (!g_fUsePredefinedEP)
    {
        //
        // Using dynamic endpoints.
        //
        pPort  =  NULL ;
        pPort2 =  NULL ;
    }

   MQRPC_AUTHENTICATION_LEVEL _eAuthnLevel = MQRPC_SEC_LEVEL_NONE ;
   hr = mqrpcBindQMService(
            MachineName.get(),
            IP_ADDRESS_TYPE,
            pPort,
            &_eAuthnLevel,
            NULL,
            &m_hRemoteBind,
            dwPortType,
            pfnGetPort,
            NULL,
            RPC_C_AUTHN_WINNT
            ) ;

   if (FAILED(hr))
   {
       return LogHR(hr, s_FN, 340);
   }

   ASSERT(_eAuthnLevel == MQRPC_SEC_LEVEL_NONE) ;
   hr = mqrpcBindQMService(
            MachineName.get(),
            IP_ADDRESS_TYPE,
            pPort2,
            &_eAuthnLevel,
            NULL,
            &m_hRemoteBind2,
            dwPortType2,
            pfnGetPort,
            NULL,
            RPC_C_AUTHN_WINNT
            ) ;

  if (FAILED(hr))
  {
     //
     // Free the first binding handle.
     //
     UnBindRemoteQMService() ;
     return LogHR(hr, s_FN, 350);
  }

  QMpGetRemoteQmVersion(m_hRemoteBind, &m_RemoteQmMajorVersion, &m_RemoteQmMinorVersion, &m_RemoteQmBuildNumber);

  return RPC_S_OK;
}


//---------------------------------------------------------
//
//  void CRRQueue::CreateThread(PVOID pThreadFunction, CACRequest *pRequest)
//
//  Create the thread for remote-read operation.
//
//---------------------------------------------------------

void
CRRQueue::CreateThread(PVOID pThreadFunction, CACRequest *pRequest)
{
   if (g_iRemoteThreadsCount > MAX_REMOTE_THREADS)
   {
      //
      // Too many threads are already running.
      //
      DBGMSG((DBGMOD_QM, DBGLVL_ERROR,
       _TEXT("ERROR (CRRQueue::CreateThread): Too many remote threads.")));
      LogIllegalPoint(s_FN, 360);
      return ;
   }

   CACRequest *pLocalRequest = new CACRequest(*pRequest);
   LPREMOTEREADTHREAD pRRThread = new REMOTEREADTHREAD ;

   pRRThread->pRequest = pLocalRequest ;

   pRRThread->hBind = m_hRemoteBind ;
   pRRThread->RemoteQmMajorVersion = m_RemoteQmMajorVersion;
   pRRThread->RemoteQmMinorVersion = m_RemoteQmMinorVersion;
   pRRThread->RemoteQmBuildNumber  = m_RemoteQmBuildNumber;
   pRRThread->pLocalQueue = this ;

   DWORD dwID ;
   HANDLE hThread = ::CreateThread( NULL,
                                    0,
                                    (LPTHREAD_START_ROUTINE) pThreadFunction,
                                    (LPVOID) pRRThread,
                                    0,
                                    &dwID ) ;
   ASSERT(hThread) ;
   if (hThread)
   {
      InterlockedIncrement(&g_iRemoteThreadsCount) ;
      WaitForSingleObject(hThread, MAX_THREAD_TIMEOUT) ;
      CloseHandle(hThread) ;
   }
}

//---------------------------------------------------------
//
//  void CRRQueue::RemoteRead(CACRequest *pRequest)
//
//  Client side of RPC for remote reading. MQReceive() was
//  called on this machine.
//  This function create a thread which will connects to the RPC server
//  side (remote QM machine) and ask it to read from its local queue.
//
//---------------------------------------------------------
void CRRQueue::RemoteRead(CACRequest *pRequest)
{
    BOOL fSuccess = TRUE ;
    CACRequest *pLocalRequest = NULL ;
    LPREMOTEREADTHREAD pRRThread = NULL ;

    try
    {
        ASSERT(m_hRemoteBind2) ;

        //
        // Increment reference count. It will be released when the read thread
        // terminate. This ensure that queue won't be deleted while remote
        // read is in progress.
        //
        AddRef() ;

        if (!pRRThreadsPool)
        {
            pRRThreadsPool = new CRRThreadsPool ;
        }

        pLocalRequest = new CACRequest(*pRequest);
        pRRThread = new REMOTEREADTHREAD ;

        pRRThread->pRequest = pLocalRequest ;

        pRRThread->hBind = m_hRemoteBind2;
        pRRThread->RemoteQmMajorVersion = m_RemoteQmMajorVersion;
        pRRThread->RemoteQmMinorVersion = m_RemoteQmMinorVersion;
        pRRThread->RemoteQmBuildNumber  = m_RemoteQmBuildNumber;
        pRRThread->pLocalQueue = this ;

        ASSERT(pLocalRequest->Remote.Context.pCloseCS) ;

        fSuccess = pRRThreadsPool->Dispatch(pRRThread) ;
    }
    catch(const bad_alloc&)
    {
        //
        // We reach here if any of the "new" operation fail, either above
        // or in the CRRThreadsPool code.
        //
        fSuccess = FALSE ;
        LogIllegalPoint(s_FN, 63);
    }

    if (!fSuccess)
    {
        //
        // We're short of resources. Request not handled by a thread.
        //
        // Release the queue object.
        //
        Release() ;
        //
        // Free any allocated data.
        //
        if (pLocalRequest)
        {
            delete pLocalRequest ;
        }
        if (pRRThread)
        {
            delete pRRThread ;
        }
        //
        // Terminate the read request, which will now return to caller
        // with the error code.
        //
        HRESULT hr =  ACCancelRequest(
                        pRequest->Remote.Context.cli_hACQueue,
                        MQ_ERROR_INSUFFICIENT_RESOURCES,
                        pRequest->Remote.Read.ulTag
                        );
        LogHR(hr, s_FN, 141);
    }
}

//---------------------------------------------------------
//
//  void CRRQueue::RemoteCloseQueue( PCTX_RRSESSION_HANDLE_TYPE pRRContext )
//
//  Client side of RPC for remote reading.
//  Perform MQCloseQueue() on remote machine.
//
//---------------------------------------------------------

void
CRRQueue::RemoteCloseQueue( PCTX_RRSESSION_HANDLE_TYPE pRRContext )
{
    ASSERT(m_hRemoteBind) ;

    HANDLE hThread = NULL ;
    RegisterRRCallForCancel( &hThread, 0) ;

    try
    {
        HRESULT hr;
        hr = RemoteQMCloseQueue(
                m_hRemoteBind,
                &pRRContext
                );

        ASSERT(pRRContext == 0) ;
    }
    catch(...)
    {
        // protect against network problems, although this is a void method.
        LogIllegalPoint(s_FN, 64);
    }

    UnregisterRRCallForCancel(hThread) ;
}

//---------------------------------------------------------
//
//  DWORD WINAPI RemoteCloseQueueThread(LPVOID pV)
//
//  Client side of RPC for remote reading.
//  Perform MQCloseQueue() on remote machine.
//
//---------------------------------------------------------

DWORD WINAPI RemoteCloseQueueThread(LPVOID pV)
{
   LPREMOTEREADTHREAD pRRThread = (LPREMOTEREADTHREAD) pV ;
   ASSERT(pRRThread) ;
   ASSERT(pRRThread->hBind) ;

   CACRequest *pRequest = pRRThread->pRequest ;
   ASSERT(pRequest) ;

   CRRQueue *pQueue = pRRThread->pLocalQueue ;
   ASSERT(pQueue) ;

   CS lock(pQueue->m_cli_csRemoteClose) ;

   ASSERT(pRequest->Remote.Context.pRRContext);
   ASSERT(pRequest->Remote.Context.pCloseCS);
   ASSERT(pRequest->Remote.Context.srv_pQMQueue);

   //
   // Note that EnterCriticalSection cannot raise since spinlock was already allocated.
   //
   EnterCriticalSection(
       (CRITICAL_SECTION *)pRequest->Remote.Context.pCloseCS) ;

   pQueue->RemoteCloseQueue( (PCTX_RRSESSION_HANDLE_TYPE)pRequest->Remote.Context.pRRContext ) ;

   ACCloseHandle(pRequest->Remote.Context.cli_hACQueue);

   LeaveCriticalSection((CRITICAL_SECTION *)pRequest->Remote.Context.pCloseCS) ;
   DeleteCriticalSection((CRITICAL_SECTION *)pRequest->Remote.Context.pCloseCS) ;
   delete (CRITICAL_SECTION *)pRequest->Remote.Context.pCloseCS;

   //
   //  Decrement the reference count and delete object if null referece.
   //
   ASSERT(pQueue->GetRef() > 1);
   pQueue->Release() ;

   delete pRequest ;
   delete pRRThread ;

   InterlockedDecrement(&g_iRemoteThreadsCount) ;
   return 0 ;
}

void CRRQueue::RemoteCloseQueue(CACRequest *pRequest)
{
   ASSERT(pRequest->Remote.Context.pCloseCS) ;
   CreateThread(RemoteCloseQueueThread, pRequest) ;
}

//---------------------------------------------------------
//
//  void CRRQueue::RemoteCloseCursor()
//
//  Client side of RPC for remote reading.
//  Perform MQCloseCursor() on remote machine.
//
//---------------------------------------------------------

DWORD WINAPI RemoteCloseCursorThread(LPVOID pV)
{
   LPREMOTEREADTHREAD pRRThread = (LPREMOTEREADTHREAD) pV ;
   ASSERT(pRRThread) ;
   ASSERT(pRRThread->hBind) ;

   CACRequest *pRequest = pRRThread->pRequest ;
   ASSERT(pRequest) ;

   CRRQueue *pQueue = pRRThread->pLocalQueue ;
   ASSERT(pQueue) ;

   CS lock(pQueue->m_cli_csRemoteClose);

   ASSERT(pRequest->Remote.Context.pCloseCS);
   ASSERT(pRequest->Remote.Context.srv_pQMQueue);

   HANDLE hThread = NULL ;
   RegisterRRCallForCancel( &hThread, 0) ;

   try
   {
       HRESULT hr;
       hr = RemoteQMCloseCursor(
               pRRThread->hBind,
               pRequest->Remote.Context.srv_hACQueue,
               pRequest->Remote.CloseCursor.hRemoteCursor
               );
   }
   catch(...)
   {
       // protect against network problems, although this is a void method.
       LogIllegalPoint(s_FN, 66);
   }

   UnregisterRRCallForCancel( hThread ) ;

   delete pRequest ;
   delete pRRThread ;

   InterlockedDecrement(&g_iRemoteThreadsCount) ;
   return 0 ;
}

void CRRQueue::RemoteCloseCursor(CACRequest *pRequest)
{
   CreateThread(RemoteCloseCursorThread, pRequest) ;
}

//---------------------------------------------------------
//
//  void CRRQueue::RemotePurgeQueue()
//
//  Client side of RPC for remote reading.
//  Perform MQPurgeQueue() on remote machine.
//
//---------------------------------------------------------

DWORD WINAPI RemotePurgeQueueThread(LPVOID pV)
{
   LPREMOTEREADTHREAD pRRThread = (LPREMOTEREADTHREAD) pV ;
   ASSERT(pRRThread) ;
   ASSERT(pRRThread->hBind) ;

   CACRequest *pRequest = pRRThread->pRequest ;
   ASSERT(pRequest) ;

   CRRQueue *pQueue = pRRThread->pLocalQueue ;
   ASSERT(pQueue) ;

   CS lock(pQueue->m_cli_csRemoteClose);

   ASSERT(pRequest->Remote.Context.pCloseCS);
   ASSERT(pRequest->Remote.Context.srv_pQMQueue);

   HANDLE hThread = NULL ;
   RegisterRRCallForCancel( &hThread, 0) ;

   try
   {
       HRESULT hr;
       hr = RemoteQMPurgeQueue(
               pRRThread->hBind,
               pRequest->Remote.Context.srv_hACQueue
               );
   }
   catch(...)
   {
       // protect against network problems, although this is a void method.
       LogIllegalPoint(s_FN, 67);
   }

   UnregisterRRCallForCancel( hThread ) ;

   delete pRequest ;
   delete pRRThread ;

   InterlockedDecrement(&g_iRemoteThreadsCount) ;
   return 0 ;
}

void CRRQueue::RemotePurgeQueue(CACRequest *pRequest)
{
   CreateThread(RemotePurgeQueueThread, pRequest) ;
}

//---------------------------------------------------------
//
//  void CRRQueue::RemoteCancelRead()
//
//  Client side of RPC for remote reading.
//  NT kernel called AcCancelRead in the driver (on client machine) to
//  cancel a pending read request which was remoted to a server QM.
//  Call the server side to cancel the request on it too.
//
//---------------------------------------------------------

DWORD WINAPI RemoteCancelReadThread(LPVOID pV)
{
   LPREMOTEREADTHREAD pRRThread = (LPREMOTEREADTHREAD) pV ;
   ASSERT(pRRThread) ;
   ASSERT(pRRThread->hBind) ;

   CACRequest *pRequest = pRRThread->pRequest ;
   ASSERT(pRequest) ;

   CRRQueue *pQueue = pRRThread->pLocalQueue ;
   ASSERT(pQueue) ;

   pQueue->AddRef() ;
   CS lock(pQueue->m_cli_csRemoteClose) ;

   R<CRRQueue> Ref = pQueue ;

   ASSERT(pRRThread->hBind) ;

   HANDLE hThread = NULL ;
   RegisterRRCallForCancel( &hThread, 0) ;

   try
   {
      ASSERT(pRequest->Remote.Context.srv_pQMQueue) ;
      ASSERT(pRequest->Remote.Context.srv_hACQueue) ;

      HRESULT hr ;
      hr = RemoteQMCancelReceive(
                     pRRThread->hBind,
                     pRequest->Remote.Context.srv_hACQueue,
                     pRequest->Remote.Context.srv_pQMQueue,
                     pRequest->Remote.Read.ulTag);
   }
   catch(...)
   {
      // protect against network problems, although this is a void method.
      LogIllegalPoint(s_FN, 68);
   }

   UnregisterRRCallForCancel( hThread ) ;

   delete pRequest ;
   delete pRRThread ;

   InterlockedDecrement(&g_iRemoteThreadsCount) ;
   return 0 ;
}

void CRRQueue::RemoteCancelRead(CACRequest *pRequest)
{
   CreateThread(RemoteCancelReadThread, pRequest) ;
}

//---------------------------------------------------------
//
//  HRESULT CRRQueue::OpenRRSession()
//
//  Open remote session with the server. pass the server the
//  handle and queue pointer
//
//---------------------------------------------------------

HRESULT CRRQueue::OpenRRSession( ULONG srv_hACQueue,
                                 ULONG srv_pQMQueue,
                                 PCTX_RRSESSION_HANDLE_TYPE *ppRRContext,
                                 DWORD  dwpContext )
{
    HRESULT hrpc =  BindRemoteQMService() ;
    if (FAILED(hrpc))
    {
        LogHR(hrpc, s_FN, 120);
        return MQ_ERROR;
    }

    HRESULT hr ;
    HANDLE hThread = NULL ;
    RegisterRRCallForCancel( &hThread, 0) ;

    try
    {
        hr = RemoteQMOpenQueue(
                m_hRemoteBind,
                ppRRContext,
                (GUID *) QueueMgr.GetQMGuid(),
                (IsNonServer() ? SERVICE_NONE : SERVICE_SRV),  // [adsrv] QueueMgr.GetMQS(),  We simulate old?
                srv_hACQueue,
                srv_pQMQueue,
                dwpContext ) ;
    }
    catch(...)
    {
        //
        // guard against net problem. Do nothing special.
        //
        hr = MQ_ERROR_SERVICE_NOT_AVAILABLE ;
        LogIllegalPoint(s_FN, 69);
    }

    UnregisterRRCallForCancel( hThread ) ;

    return LogHR(hr, s_FN, 130);
}

//-----------------------------------------------
//
//  HRESULT CQueue::CancelPendRemoteRead()
//
//  This method is called on the server side to cancel a pending remote
//  read request. It is the responsibility of the client side to request
//  this cancelation.
//  The client side supply its own irp and the server side uses it to
//  retreive the server side irp.
//
//-----------------------------------------------

HRESULT CQueue::CancelPendingRemoteRead(ULONG hRemote, HRESULT hr, DWORD cli_tag)
{
    CS lock(m_srvr_RemoteMappingCS) ;

    DWORD srv_tag;
    RR_CLIENT_INFO ci = {hRemote, cli_tag};
    if( (m_srvr_pRemoteMapping == 0) ||
        !m_srvr_pRemoteMapping->Lookup(ci, srv_tag))
    {
        return LogHR(MQ_ERROR, s_FN, 140);
    }

    HRESULT hr1 = ACCancelRequest(
            m_hQueue,
            hr,
            srv_tag);

    return LogHR(hr1, s_FN, 150);
}

//-------------------------------------------------------------
//
//  void CQueue::RegisterReadRequest( HANDLE hRemote,
//                                          DWORD  cli_tag,
//                                          DWORD  srv_tag )
//
//-------------------------------------------------------------

void CQueue::RegisterReadRequest(ULONG hRemote, ULONG cli_tag, ULONG srv_tag)
{
    CS lock(m_srvr_RemoteMappingCS) ;

#ifdef _DEBUG
      m_cPendings++ ;
#endif

    if(!m_srvr_pRemoteMapping)
    {
        m_srvr_pRemoteMapping = new CRemoteMapping;
    }

    RR_CLIENT_INFO ci = {hRemote, cli_tag};
    m_srvr_pRemoteMapping->SetAt(ci, srv_tag);
}

//-------------------------------------------------------------
//
//  void CQueue::UnregisterReadRequest( HANDLE hRemote,
//                                          DWORD  cli_tag,
//                                          DWORD  srv_tag )
//
//-------------------------------------------------------------

void CQueue::UnregisterReadRequest(ULONG hRemote, DWORD cli_tag)
{
    CS lock(m_srvr_RemoteMappingCS) ;

#ifdef _DEBUG
      m_cPendings-- ;
      ASSERT(m_cPendings >= 0) ;
#endif

    if(!m_srvr_pRemoteMapping)
    {
        return;
    }

    RR_CLIENT_INFO ci = {hRemote, cli_tag};
    m_srvr_pRemoteMapping->RemoveKey(ci);
}

//---------------------------------------------------------
//
// /* [call_as] */ HRESULT qm2qm_v1_0_R_QMRemoteStartReceive
// /* [call_as] */ HRESULT qm2qm_v1_0_QMRemoteEndReceive
//
//  Server side of RPC for remote reading.
//  This function read from local queue and transfers the
//  packet to the client QM, on which MQReceive() was called.
//
//  Reading from driver is done in two phases:
//  1. Client side call R_QMRemoteStartReceive. Server side get a packet
//     from queue, mark it as received and returned it to client.
//     Marking the packet as received (in the driver) prevent other receive
//     requests from getting this packet.
//  2. Client side put the packet in the temporary queue it created and the
//     driver will return it to the caller. If driver successfully delivered
//     it then client send an ACK to server and server delete the packet
//     (for GET). if the driver can't deliver it then client send a NACK
//     to server and server re-insert the packet in its original place
//     in queue.
//
//---------------------------------------------------------

HRESULT   QMRemoteEndReceiveInternal( HANDLE        hQueue,
                                      HACCursor32   hCursor,
                                      ULONG         ulTimeout,
                                      ULONG         ulAction,
                                      REMOTEREADACK eRRAck,
                                      CBaseHeader*  lpPacket,
                                      CPacket*      pDriverPacket)
{
   CACGet2Remote g2r ;
   g2r.Cursor = hCursor ;
   g2r.Action = ulAction ;
   g2r.RequestTimeout = ulTimeout ;
   g2r.fReceiveByLookupId = false;

   if (eRRAck == RR_NACK)
   {
      //
      // To keep the packet in queue we replace the "GET" action
      // with "PEEK_CURRENT", so the packet remain in queue and
      // cursor is not moved.
      //
      g2r.Action = MQ_ACTION_PEEK_CURRENT ;
   }
   else
   {
      ASSERT(eRRAck == RR_ACK) ;
   }

   g2r.lpPacket = lpPacket ;
   g2r.lpDriverPacket = pDriverPacket ;
   ASSERT(g2r.lpPacket) ;
   HRESULT hr = ACEndGetPacket2Remote( hQueue, g2r );
   return LogHR(hr, s_FN, 160);
}

/* [call_as] */ HRESULT qm2qm_v1_0_QMRemoteEndReceive(
    /* [in]      */ handle_t                              hBind,
    /* [in, out] */ PCTX_REMOTEREAD_HANDLE_TYPE __RPC_FAR *phContext,
    /* [in]      */ DWORD                                 dwAck )
{
    REMOTEREAD_CONTEXT_TYPE* pRemoteReadContext = (REMOTEREAD_CONTEXT_TYPE*) *phContext;

    if(pRemoteReadContext == NULL)
        return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 169);

    HRESULT hr;
    hr = QMRemoteEndReceiveInternal(pRemoteReadContext->hQueue,
                                    pRemoteReadContext->hCursor,
                                    pRemoteReadContext->ulTimeout,
                                    pRemoteReadContext->ulAction,
                                    (REMOTEREADACK) dwAck,
                                    pRemoteReadContext->lpPacket,
                                    pRemoteReadContext->lpDriverPacket) ;
    midl_user_free(*phContext) ;
    *phContext = NULL;
    return LogHR(hr, s_FN, 170);
}

//---------------------------------------------------------
//
//  HRESULT QMpRemoteStartReceive
//
//---------------------------------------------------------

static
HRESULT
QMpRemoteStartReceive(
    handle_t hBind,
    PCTX_REMOTEREAD_HANDLE_TYPE __RPC_FAR *phContext,
    REMOTEREADDESC2 __RPC_FAR *lpRemoteReadDesc2,
    bool fReceiveByLookupId,
    ULONGLONG LookupId
    )
{
    //
    // Validate network incomming parameters
    //
    if(lpRemoteReadDesc2 == NULL)
        return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 1690);

    REMOTEREADDESC __RPC_FAR *lpRemoteReadDesc = lpRemoteReadDesc2->pRemoteReadDesc;

    if(lpRemoteReadDesc == NULL)
        return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 1691);

    if(lpRemoteReadDesc->dwpQueue == 0)
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 1692);

    if(fReceiveByLookupId && (lpRemoteReadDesc->ulTimeout != 0))
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 1693);

    if(fReceiveByLookupId && (lpRemoteReadDesc->hCursor != 0))
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 1694);


    //
    // This is server side of remote read. It may happen that before client
    // perform a read, the server crashed and reboot. In that case,
    // a subsequent read, using the same binding handle in the client side,
    // will reach here, where pQueue is not valid. The try/except will
    // guard against such bad events.  Bug #1921
    //
    HRESULT hr = MQ_ERROR ;

    __try
    {
      CQueue* pQueue = (CQueue *)GET_FROM_CONTEXT_MAP(g_map_QM_srv_pQMQueue, lpRemoteReadDesc->dwpQueue, s_FN, 240) ; //may throw an exception on win64
	  HANDLE hQueue = GET_FROM_CONTEXT_MAP(g_map_QM_srv_hQueue, lpRemoteReadDesc->hRemoteQueue, s_FN, 420);

      if (pQueue->GetSignature() !=  QUEUE_SIGNATURE)
      {
         DBGMSG((DBGMOD_RPC,DBGLVL_ERROR,
                    _TEXT("Exit QMpRemoteStartReceive, Invalid Signature"))) ;
         return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 180);
      }

      CACPacketPtrs  packetPtrs = {NULL, NULL} ;
      OVERLAPPED Overlapped = {0};
      Overlapped.hEvent = GetThreadEvent();

      ULONG ulTag;
      CACGet2Remote g2r ;

      g2r.Cursor = (HACCursor32) lpRemoteReadDesc->hCursor ;
      g2r.Action = lpRemoteReadDesc->ulAction ;
      g2r.RequestTimeout = lpRemoteReadDesc->ulTimeout ;
      g2r.pTag = &ulTag;
      g2r.fReceiveByLookupId = fReceiveByLookupId;
      g2r.LookupId = LookupId;

      hr = ACBeginGetPacket2Remote(hQueue,
                                   g2r,
                                   packetPtrs,
                                   &Overlapped ) ;

      //
      // Receive by lookup ID should never return status pending
      //
      ASSERT(hr != STATUS_PENDING || !fReceiveByLookupId);

      if (hr == STATUS_PENDING)
      {
          //
          //  Register this pending read request.
          //
          pQueue->RegisterReadRequest(
                     lpRemoteReadDesc->hRemoteQueue,
                     lpRemoteReadDesc->dwRequestID,
                     ulTag );

          //
          //  Wait for receive completion
          //
          DWORD dwResult;
          dwResult = WaitForSingleObject( Overlapped.hEvent,
                                          INFINITE );
          ASSERT(dwResult == WAIT_OBJECT_0);
          if (dwResult != WAIT_OBJECT_0)
          {
              LogNTStatus(GetLastError(), s_FN, 197);
          }

          hr = DWORD_PTR_TO_DWORD(Overlapped.Internal);

          pQueue->UnregisterReadRequest(
                  lpRemoteReadDesc->hRemoteQueue,
                  lpRemoteReadDesc->dwRequestID);
      }

      if (hr == MQ_OK)
      {
         //
         // MSMQ 1.0 sees the reserved field as a packet pointer and asserts that is non zero.
         //
         lpRemoteReadDesc->Reserved = 1;
         CPacketInfo* pInfo = reinterpret_cast<CPacketInfo*>(packetPtrs.pPacket) - 1;
         lpRemoteReadDesc->dwArriveTime = pInfo->ArrivalTime() ;
         lpRemoteReadDesc2->SequentialId = pInfo->SequentialId();

         DWORD dwSize = PACKETSIZE(packetPtrs.pPacket) ;
         lpRemoteReadDesc->dwSize = dwSize ;
         lpRemoteReadDesc->lpBuffer = new unsigned char [ dwSize ] ;
         MoveMemory(lpRemoteReadDesc->lpBuffer, packetPtrs.pPacket, dwSize) ;

         if ((lpRemoteReadDesc->ulAction & MQ_ACTION_PEEK_MASK) == MQ_ACTION_PEEK_MASK ||
             (lpRemoteReadDesc->ulAction & MQ_LOOKUP_PEEK_MASK) == MQ_LOOKUP_PEEK_MASK)
         {
            //
            // For PEEK we don't need any ack/nack from client side because
            // packet remain in queue anyway.
            // Neverthless we need to free the clone packet we've got.
            //
            g2r.lpPacket = packetPtrs.pPacket ;
            g2r.lpDriverPacket = packetPtrs.pDriverPacket ;
            hr = ACFreePacket(
                    hQueue,
                    packetPtrs.pDriverPacket
                    );
            ASSERT(SUCCEEDED(hr));
         }
         else
         {
            //
            //  Prepare a rpc context, in case that EndRecieve will not
            //  be called because of client side crash or net problems.
            //
            REMOTEREAD_CONTEXT_TYPE *pRemoteReadContext =
                 (REMOTEREAD_CONTEXT_TYPE *)
                       midl_user_allocate(sizeof(REMOTEREAD_CONTEXT_TYPE));

            pRemoteReadContext->hQueue = hQueue;
            pRemoteReadContext->hCursor = (HACCursor32) lpRemoteReadDesc->hCursor ;
            pRemoteReadContext->lpPacket = packetPtrs.pPacket ;
            pRemoteReadContext->lpDriverPacket = packetPtrs.pDriverPacket ;
            pRemoteReadContext->ulTimeout = lpRemoteReadDesc->ulTimeout ;
            pRemoteReadContext->ulAction = lpRemoteReadDesc->ulAction ;

            *phContext = (PCTX_REMOTEREAD_HANDLE_TYPE) pRemoteReadContext ;
         }
      }
      else
      {
         ASSERT(packetPtrs.pPacket == NULL) ;
         LogHR(hr, s_FN, 138);
      }
   }
   __except(EXCEPTION_EXECUTE_HANDLER)
   {
      DWORD dwStatus = GetExceptionCode();
      LogNTStatus(dwStatus, s_FN, 189);

      hr = MQ_ERROR_INVALID_HANDLE ;
   }

   DBGMSG((DBGMOD_RPC,DBGLVL_INFO,
                _TEXT("Exit QMpRemoteStartReceive, hr-%lxh"), (DWORD) hr)) ;

   return LogHR(hr, s_FN, 190);

} // QMpRemoteStartReceive

//---------------------------------------------------------
//
//  HRESULT qm2qmV2_v1_0_R_QMRemoteStartReceiveByLookupId
//
//  Server side of RPC for remote reading using lookup ID.
//  Handle MSMQ 3.0 (Whistler) or higher clients.
//
//---------------------------------------------------------

HRESULT
qm2qm_v1_0_R_QMRemoteStartReceiveByLookupId(
    handle_t hBind,
    ULONGLONG LookupId,
    PCTX_REMOTEREAD_HANDLE_TYPE __RPC_FAR *phContext,
    REMOTEREADDESC2 __RPC_FAR *pDesc2
    )
{
    return QMpRemoteStartReceive(
               hBind,
               phContext,
               pDesc2,
               true,
               LookupId
               );
} // qm2qm_v1_0_R_QMRemoteStartReceiveByLookupId

//-------------------------------------------------------------------------
//
//  HRESULT qm2qm_v1_0_R_QMRemoteStartReceive
//
//  Server side of RPC for remote reading.
//  Handle MSMQ 1.0 and 2.0 clients.
//
//-------------------------------------------------------------------------

HRESULT
qm2qm_v1_0_R_QMRemoteStartReceive(
    handle_t hBind,
    PCTX_REMOTEREAD_HANDLE_TYPE __RPC_FAR *phContext,
    REMOTEREADDESC __RPC_FAR *pDesc
    )
{
    REMOTEREADDESC2 Desc2;
    Desc2.pRemoteReadDesc = pDesc;
    Desc2.SequentialId = 0;

    return QMpRemoteStartReceive(
               hBind,
               phContext,
               &Desc2,
               false,
               0
               );
} // qm2qm_v1_0_R_QMRemoteStartReceive


//-------------------------------------------------------------------------
//
//  HRESULT qm2qm_v1_0_R_QMRemoteStartReceive2
//
//  Server side of RPC for remote reading.
//  Handle MSMQ 3.0 (Whistler) or higher clients.
//
//-------------------------------------------------------------------------

HRESULT
qm2qm_v1_0_R_QMRemoteStartReceive2(
    handle_t hBind,
    PCTX_REMOTEREAD_HANDLE_TYPE __RPC_FAR *phContext,
    REMOTEREADDESC2 __RPC_FAR *pDesc2
    )
{
    return QMpRemoteStartReceive(
               hBind,
               phContext,
               pDesc2,
               false,
               0
               );
} // qm2qm_v1_0_R_QMRemoteStartReceive2


//---------------------------------------------------------------
//
//   /* [call_as] */ HRESULT qm2qm_v1_0_QMRemoteOpenQueue
//
//  Server side of RPC. Open a session with the queue.
//  This function merely construct the context handle for this
//  Remote-Read session.
//
//---------------------------------------------------------------

/* [call_as] */ HRESULT qm2qm_v1_0_QMRemoteOpenQueue(
    /* [in] */ handle_t hBind,
    /* [out] */ PCTX_RRSESSION_HANDLE_TYPE __RPC_FAR *phContext,
    /* [in] */ GUID  *pLicGuid,
    /* [in] */ DWORD dwMQS,
    /* [in] */ DWORD hQueue,
    /* [in] */ DWORD dwpQueue,
    /* [in] */ DWORD dwpContext )
{
   DBGMSG((DBGMOD_RPC,DBGLVL_INFO,_TEXT("In QMRemoteOpenQueue")));

   if (pLicGuid == NULL)
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 1931);

   if(dwpQueue == 0)
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 1933);

   CS Lock(s_csRemoteMapping) ;

   //
   // Reset the queue handle kept in the rpc context which was created
   // when client RT called server side QM. This is necessary to prevent
   // double run-down which will close the same queue.
   // "dwpContext" is the pointer allocated by server side QM when called
   // from RT (in "QMOpenRemoteQueue()").
   //
   ASSERT_BENIGN(dwpContext != 0);
   CTX_OPENREMOTE_HANDLE_TYPE *pctx = (CTX_OPENREMOTE_HANDLE_TYPE*)
      GET_FROM_CONTEXT_MAP(g_map_QM_dwpContext, dwpContext, s_FN, 250) ; //may throw an exception on win64


   REMOTESESSION_CONTEXT_TYPE *pRemoteSessionContext =
           (REMOTESESSION_CONTEXT_TYPE *)
                     midl_user_allocate(sizeof(REMOTESESSION_CONTEXT_TYPE));
   ASSERT(pRemoteSessionContext) ;

   pRemoteSessionContext->ClientQMGuid = *pLicGuid ;
   pRemoteSessionContext->fLicensed = (dwMQS == SERVICE_NONE); //[adsrv] Keeping - RR protocol is ironclade

   //
   // transfer ownership of mapped srv_pQMQueue and srv_hQueue from RT context to RRSession context
   // the mapped handles are zeroed in order not to be removed from maps when rt closes connection
   //
   pRemoteSessionContext->hQueue = pctx->hQueue;
   pctx->hQueue = 0;

   ASSERT_BENIGN(pctx->dwpQHandleMapped == hQueue);
   pRemoteSessionContext->dwpQHandleMapped = pctx->dwpQHandleMapped;
   pctx->dwpQHandleMapped = 0; //we need dwpQHandleMapped still in the map (srv_hQueue), so we don't want the RT rundown to remove it

   pRemoteSessionContext->pQueue = (CQueue*)GET_FROM_CONTEXT_MAP(g_map_QM_srv_pQMQueue, dwpQueue, s_FN, 260);

   ASSERT_BENIGN(pctx->dwpQueueMapped == dwpQueue);
   pRemoteSessionContext->dwpQueueMapped = pctx->dwpQueueMapped;
   pctx->dwpQueueMapped = 0; //we need dwpQueue still in the map (srv_pQMQueue), so we don't want the RT rundown to remove it


   *phContext = (PCTX_RRSESSION_HANDLE_TYPE) pRemoteSessionContext ;

   if (pRemoteSessionContext->fLicensed)
   {
       g_QMLicense.IncrementActiveConnections(pLicGuid, L"", NULL) ;
   }

   return MQ_OK ;
}

//---------------------------------------------------------------
//
//   /* [call_as] */ HRESULT qm2qm_v1_0_QMRemoteCloseQueue
//
//  Server side of RPC. Close the queue and free the rpc context.
//
//---------------------------------------------------------------

/* [call_as] */ HRESULT qm2qm_v1_0_QMRemoteCloseQueue(
    /* [in] */ handle_t hBind,
    /* [in, out] */ PCTX_RRSESSION_HANDLE_TYPE __RPC_FAR *phContext )
{
    DBGMSG((DBGMOD_RPC,DBGLVL_INFO,_TEXT("In QMRemoteCloseQueue")));

    if(*phContext == 0)
        return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 3001);

    REMOTESESSION_CONTEXT_TYPE *pRemoteSessionContext =
                             (REMOTESESSION_CONTEXT_TYPE*) *phContext;

    HANDLE hQueue = pRemoteSessionContext->hQueue ;

    if (pRemoteSessionContext->fLicensed)
    {
        g_QMLicense.DecrementActiveConnections(
                                &(pRemoteSessionContext->ClientQMGuid)) ;
    }

	DELETE_FROM_CONTEXT_MAP(g_map_QM_srv_pQMQueue, pRemoteSessionContext->dwpQueueMapped, s_FN, 310);
	DELETE_FROM_CONTEXT_MAP(g_map_QM_srv_hQueue, pRemoteSessionContext->dwpQHandleMapped, s_FN, 380);

    midl_user_free(*phContext);
    *phContext = NULL;

    return LogHR(ACCloseHandle(hQueue), s_FN, 200);
}

//---------------------------------------------------------------
//
//  /* [call_as] */ HRESULT qm2qm_v1_0_QMRemoteCancelReceive
//
//  Server side of RPC. Cancel a pending read request
//
//---------------------------------------------------------------

/* [call_as] */ HRESULT qm2qm_v1_0_QMRemoteCancelReceive(
    /* [in] */ handle_t hBind,
    /* [in] */ DWORD hQueue,
    /* [in] */ DWORD dwpQueue,
    /* [in] */ DWORD Tag)
{
    if(dwpQueue == 0)
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 2001);

    HRESULT hr = MQ_ERROR_INVALID_HANDLE ;

    __try
    {
        DBGMSG((DBGMOD_RPC, DBGLVL_INFO, _TEXT("In QMRemoteCancelReceive")));

        CQueue* pQueue = (CQueue *)GET_FROM_CONTEXT_MAP(g_map_QM_srv_pQMQueue, dwpQueue, s_FN, 270);

        if ((pQueue->GetSignature() != QUEUE_SIGNATURE) ||
            (pQueue->GetQueueHandle() == NULL))
        {
            //
            // the queue was already released. Ignore. Such a scenario
            // can happen in the following way:
            // 1. start client app, open remote queue for read and start a
            //    read
            // 2. while read wait on server side, kill the app.
            // 3. the msmq service on client issue two rpc calls to server:
            //    one to close the queue, the other to cancel the read.
            // 4. on server side, the following sequence of events may happen
            //    because of timing:
            //   a. rpc call to close queue was received and queue was close.
            //   b. CQMGR object perform cleanup and delete the queue
            //      instance.
            //   c. rpc call to cancel read is received, but queue object
            //      does not exist anymore => gpf.
            // So to fix 4763, we check sanity of pQueue and we also add
            // try/catch, to be on the safe side.
            //
        }
        else
        {
			//
			// hQueue here is the mapped value of queue handle.
			// It is the same value that is used in RegisterReadRequest() and
			// UnregisterReadRequest()
			//
            hr = pQueue->CancelPendingRemoteRead(
                                hQueue,
                                MQ_INFORMATION_REMOTE_CANCELED_BY_CLIENT,
                                Tag ) ;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = MQ_ERROR_INVALID_HANDLE ;
    }

    return LogHR(hr, s_FN, 210);
}

//---------------------------------------------------------------
//
//  RunDown functions to handle cleanup in case of RPC failure.
//  Calls from client QM to remote QM
//
//---------------------------------------------------------------

void __RPC_USER
PCTX_RRSESSION_HANDLE_TYPE_rundown( PCTX_RRSESSION_HANDLE_TYPE hContext)
{
    DBGMSG((DBGMOD_RPC,DBGLVL_WARNING,_TEXT("In RRSESSION_rundown")));

    qm2qm_v1_0_QMRemoteCloseQueue(
       0,
       &hContext
       );
}


void __RPC_USER
PCTX_REMOTEREAD_HANDLE_TYPE_rundown( PCTX_REMOTEREAD_HANDLE_TYPE phContext )
{
   DBGMSG((DBGMOD_RPC,DBGLVL_WARNING,_TEXT("In REMOTEREAD_rundown")));
   ASSERT(phContext) ;

   HRESULT hr = MQ_ERROR ;
   if (phContext)
   {
      //
      // on rundown we nack the packet and return it to the queue.
      // If the remote client actually read it (network failed after
      // it read) then the packet is duplicated. The rundown prevents
      // loss of packets.
      //
      REMOTEREAD_CONTEXT_TYPE *pRemoteReadContext =
                              (REMOTEREAD_CONTEXT_TYPE *) phContext ;
      hr = QMRemoteEndReceiveInternal( pRemoteReadContext->hQueue,
                                       pRemoteReadContext->hCursor,
                                       pRemoteReadContext->ulTimeout,
                                       pRemoteReadContext->ulAction,
                                       RR_NACK,
                                       pRemoteReadContext->lpPacket,
                                       pRemoteReadContext->lpDriverPacket) ;
      LogHR(hr, s_FN, 220);
      midl_user_free(phContext) ;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qmsecutl.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    qmsecutl.cpp

Abstract:

    Various QM security related functions.

Author:

    Boaz Feldbaum (BoazF) 26-Mar-1996.

--*/

#include "stdh.h"
#include "cqmgr.h"
#include "cqpriv.h"
#include "qmsecutl.h"
#include "regqueue.h"
#include "qmrt.h"
#include <mqsec.h>
#include <_registr.h>
#include <mqcrypt.h>
#include "cache.h"
#include <mqformat.h>
#include "ad.h"
#include "_propvar.h"
#include "VerifySignMqf.h"
#include "cry.h"
#include "mqexception.h"
#include <mqcert.h>
#include "Authz.h"
#include "autoauthz.h"
#include "mqexception.h"
#include "DumpAuthzUtl.h"
#include <ev.h>

#include "qmsecutl.tmh"

extern CQueueMgr QueueMgr;
extern LPTSTR g_szMachineName;

static WCHAR *s_FN=L"qmsecutl";

const TraceIdEntry QmSecUtl = L"QM SECUTIL";

//
// Windows bug 633909. see _mqini.h for more details about these two flags.
//
BOOL g_fSendEnhRC2WithLen40 = FALSE ;
BOOL g_fRejectEnhRC2WithLen40 = FALSE ;

/***************************************************************************

Function:
    SetMachineSecurityCache

Description:
    Store the machine security descriptor in the registry. This is done
    in order to allow creation of private queues also while working
    off line.

***************************************************************************/
HRESULT SetMachineSecurityCache(const VOID *pSD, DWORD dwSDSize)
{
    LONG  rc;
    DWORD dwType = REG_BINARY ;
    DWORD dwSize = dwSDSize ;

    rc = SetFalconKeyValue(
                      MSMQ_DS_SECURITY_CACHE_REGNAME,
                      &dwType,
                      (PVOID) pSD,
                      &dwSize ) ;

    LogNTStatus(rc, s_FN, 10);
    return ((rc == ERROR_SUCCESS) ? MQ_OK : MQ_ERROR);
}


/***************************************************************************

Function:
    GetMachineSecurityCache

Description:
    Retrive the machine security descriptor from the registry. This is done
    in order to allow creation of private queues also while working
    off line.

***************************************************************************/
HRESULT GetMachineSecurityCache(PSECURITY_DESCRIPTOR pSD, LPDWORD lpdwSDSize)
{
    LONG rc;
    DWORD dwType;
    HRESULT hr;

    rc = GetFalconKeyValue( MSMQ_DS_SECURITY_CACHE_REGNAME,
                            &dwType,
                            (PVOID) pSD,
                            lpdwSDSize) ;

    switch (rc)
    {
      case ERROR_SUCCESS:
        hr = MQ_OK;
        break;

      case ERROR_MORE_DATA:
        hr = MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL;
        break;

      default:
        hr = MQ_ERROR;
        break;
    }

    return LogHR(hr, s_FN, 20);
}

/***************************************************************************

Function:
    GetObjectSecurity

Description:
    Get the security descriptor of a DS object. When working on line, the
    security descriptor of the DS objects is retrived from the DS. When
    working off line, it is possible to retrive only the security descriptor
    of the local machine. This is done in order to allow creation of private
    queues also while working off line.

***************************************************************************/
HRESULT
CQMDSSecureableObject::GetObjectSecurity()
{
    m_SD = NULL;

    char SD_buff[512];
    PSECURITY_DESCRIPTOR pSD = (PSECURITY_DESCRIPTOR)SD_buff;
    DWORD dwSDSize = sizeof(SD_buff);
    DWORD dwLen = 0;
    HRESULT hr = MQ_ERROR_NO_DS;

    if (m_fTryDS && QueueMgr.CanAccessDS())
    {
        SECURITY_INFORMATION RequestedInformation =
                              OWNER_SECURITY_INFORMATION |
                              GROUP_SECURITY_INFORMATION |
                              DACL_SECURITY_INFORMATION;

        //
        // We need the SACL only if we can generate audits and if the
        // object is a queue object. The QM generates audits only for
        // queues, so we do not need the SACL of objects that are not
        // queue objects.
        //
        if (m_fInclSACL)
        {
            RequestedInformation |= SACL_SECURITY_INFORMATION;
			TrTRACE(mqsecutl, "Try to Get Security Descriptor including SACL");

            //
            // Enable SE_SECURITY_NAME since we want to try to get the SACL.
            //
            HRESULT hr1 = MQSec_SetPrivilegeInThread(SE_SECURITY_NAME, TRUE);
            ASSERT(SUCCEEDED(hr1));
            LogHR(hr1, s_FN, 197);
        }

        int  cRetries = 0;
        BOOL fDoAgain = FALSE;
        do
        {
           fDoAgain = FALSE;
           if (m_fInclSACL &&
                    ((m_eObject == eQUEUE) ||
                     (m_eObject == eMACHINE)))
           {
               hr = ADQMGetObjectSecurity(
                              m_eObject,
                              m_pObjGuid,
                              RequestedInformation,
                              pSD,
                              dwSDSize,
                              &dwLen,
                              QMSignGetSecurityChallenge,
                              0);
           }
           else
           {
                PROPID      propId = PROPID_Q_SECURITY;
                PROPVARIANT propVar;

                propVar.vt = VT_NULL;

                if (m_eObject == eQUEUE)
                {
                    propId= PROPID_Q_SECURITY;

                }
                else if (m_eObject == eMACHINE)
                {
                    propId = PROPID_QM_SECURITY;

                }
                else if (m_eObject == eSITE)
                {
                    propId = PROPID_S_SECURITY;

                }
                else if (m_eObject == eENTERPRISE)
                {
                    propId = PROPID_E_SECURITY;

                }
                else
                {
                    ASSERT(0);
                }


               hr = ADGetObjectSecurityGuid(
                        m_eObject,
                        NULL,       // pwcsDomainController
						false,	    // fServerName
                        m_pObjGuid,
                        RequestedInformation,
                        propId,
                        &propVar
                        );
               if (SUCCEEDED(hr))
               {
                    ASSERT(!m_SD);
                    pSD = m_SD  = propVar.blob.pBlobData;
                    dwSDSize = propVar.blob.cbSize;
               }


           }

           if (FAILED(hr))
           {
			  TrWARNING(mqsec, "Failed to get security descriptor, fIncludeSacl = %d, hr = 0x%x", m_fInclSACL, hr);
              if (hr == MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL)
              {
				  //
                  //  Allocate a larger buffer.
                  //

				  TrTRACE(qmsecutl, "allocated security descriptor buffer to small need %d chars", dwLen);

				  //
				  // The m_SD buffer might be already allocated, this is theoraticaly.
				  // It might happened if between the first try and the second try
				  // the SECURITY_DESCRIPTOR Size has increased.
				  // If someone on the root has change the queue SECURITY_DESCRIPTOR
				  // between the first and second DS access we will have this ASSERT.
				  // (ilanh, bug 5094)
				  //
				  ASSERT(!m_SD);
			      delete[] m_SD;

                  pSD = m_SD = (PSECURITY_DESCRIPTOR) new char[dwLen];
                  dwSDSize = dwLen;
                  fDoAgain = TRUE;
                  cRetries++ ;
              }
			  else if (hr != MQ_ERROR_NO_DS)
              {
                  //
                  // On Windows 2000, we'll get only the ACCESS_DENIED from
                  // ADS. on MSMQ1.0, we got the PRIVILEGE_NOT_HELD.
                  // So test for both, to be on the safe side.
				  // Now we are getting MQ_ERROR_QUEUE_NOT_FOUND
				  // So we as long as the DS ONLINE we will try again without SACL. ilanh 23-Aug-2000
                  //
                  if (RequestedInformation & SACL_SECURITY_INFORMATION)
                  {
                      ASSERT(m_fInclSACL);
                      //
                      // Try giving up on the SACL.
                      // Remove the SECURITY privilege.
                      //
                      RequestedInformation &= ~SACL_SECURITY_INFORMATION;
                      fDoAgain = TRUE;

                      HRESULT hr1 = MQSec_SetPrivilegeInThread(SE_SECURITY_NAME, FALSE);
                      ASSERT(SUCCEEDED(hr1));
                      LogHR(hr1, s_FN, 186);

					  TrTRACE(mqsec, "retry: Try to Get Security Descriptor without SACL");
                      m_fInclSACL = FALSE;
                  }
              }
           }
        }
        while (fDoAgain && (cRetries <= 2)) ;

        if (m_fInclSACL)
        {
			HRESULT hr1 = MQSec_SetPrivilegeInThread(SE_SECURITY_NAME, FALSE);
            ASSERT(SUCCEEDED(hr1)) ;
            LogHR(hr1, s_FN, 187);
            if (m_eObject == eSITE)
            {
                //
                // Get the site's name for in case we will audit this.
                //
                PROPID PropId = PROPID_S_PATHNAME;
                PROPVARIANT PropVar;

                PropVar.vt = VT_NULL;
                hr = ADGetObjectPropertiesGuid(
                            eSITE,
                            NULL,       // pwcsDomainController
							false,	    // fServerName
                            m_pObjGuid,
                            1,
                            &PropId,
                            &PropVar);
                if (FAILED(hr))
                {
                    return LogHR(hr, s_FN, 30);
                }
                m_pwcsObjectName = PropVar.pwszVal;
            }

        }

        if (SUCCEEDED(hr))
        {
            if ((m_eObject == eMACHINE) && QmpIsLocalMachine(m_pObjGuid))
            {
                SetMachineSecurityCache(pSD, dwSDSize);
            }
        }
        else if (m_SD)
        {
           delete[] m_SD;

           ASSERT(pSD == m_SD) ;
           if (pSD == m_SD)
           {
                //
                // Bug 8560.
                // This may happen if first call to Active Directory return
                // with error MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL and then
                // second call fail too, for example, network failed and
                // we are now offline.
                // We didn't reset pSD to its original value, so code below
                // that use pSD can either AV (pSD point to freed memory)
                // or trash valid memory if pointer was recycled by another
                // thread.
                //
                pSD = (PSECURITY_DESCRIPTOR)SD_buff;
                dwSDSize = sizeof(SD_buff);
           }
           m_SD = NULL;
        }
        else
        {
            ASSERT(pSD == (PSECURITY_DESCRIPTOR)SD_buff) ;
        }
    }

    if (hr == MQ_ERROR_NO_DS)
    {
       //
       // MQIS not available. Try local registry.
       //
        if (m_eObject == eQUEUE)
        {
           PROPID aProp;
           PROPVARIANT aVar;

           aProp = PROPID_Q_SECURITY;

           aVar.vt = VT_NULL;

           hr = GetCachedQueueProperties( 1,
                                          &aProp,
                                          &aVar,
                                          m_pObjGuid ) ;
           if (SUCCEEDED(hr))
           {
              m_SD =  aVar.blob.pBlobData ;
           }
        }
        else if ((m_eObject == eMACHINE) &&
                 (QmpIsLocalMachine(m_pObjGuid)))
        {
            // Get the nachine security descriptor from a cached copy in the
            // registry.
            hr = GetMachineSecurityCache(pSD, &dwSDSize);
            if (FAILED(hr))
            {
                if (hr == MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL)
                {
                    m_SD = (PSECURITY_DESCRIPTOR) new char[dwSDSize];
                    hr = GetMachineSecurityCache(m_SD, &dwSDSize);
                }

                if (FAILED(hr))
                {
                    delete[] m_SD;
                    m_SD = NULL;
                    hr = MQ_ERROR_NO_DS;
                }
            }
        }
        else
        {
            hr = MQ_ERROR_NO_DS;
        }
    }

    if (SUCCEEDED(hr) && !m_SD)
    {
        // Allocate a buffer for the security descriptor and copy
        // the security descriptor from stack to the allocated buffer.
        //
        ASSERT(pSD == SD_buff) ;
        dwSDSize = GetSecurityDescriptorLength((PSECURITY_DESCRIPTOR)SD_buff);
        m_SD = (PSECURITY_DESCRIPTOR) new char[dwSDSize];
        memcpy(m_SD, SD_buff, dwSDSize);
    }

    ASSERT(FAILED(hr) || IsValidSecurityDescriptor(m_SD));
    return LogHR(hr, s_FN, 40);
}

/***************************************************************************

Function:
    SetObjectSecurity

Description:
    We do not want to modify the security of any of the DS objects from the
    QM. This function is not implemented and always return MQ_ERROR.

***************************************************************************/
HRESULT
CQMDSSecureableObject::SetObjectSecurity()
{
    return LogHR(MQ_ERROR, s_FN, 50);
}

/***************************************************************************

Function:
    CQMDSSecureableObject

Description:
    The constructor of CQMDSSecureableObject

***************************************************************************/
CQMDSSecureableObject::CQMDSSecureableObject(
    AD_OBJECT eObject,
    const GUID *pGuid,
    BOOL fInclSACL,
    BOOL fTryDS,
    LPCWSTR szObjectName) :
    CSecureableObject(eObject)
{
    m_pObjGuid = pGuid;
    m_fImpersonate = TRUE;
    m_pwcsObjectName = const_cast<LPWSTR>(szObjectName);
    m_fInclSACL = fInclSACL && MQSec_CanGenerateAudit() ;
    m_fTryDS = fTryDS;
    m_fFreeSD = TRUE;
    m_hr = GetObjectSecurity();
}

/***************************************************************************

Function:
    CQMDSSecureableObject

Description:
    The constructor of CQMDSSecureableObject

***************************************************************************/
CQMDSSecureableObject::CQMDSSecureableObject(
    AD_OBJECT eObject,
    const GUID *pGuid,
    PSECURITY_DESCRIPTOR pSD,
    LPCWSTR szObjectName) :
    CSecureableObject(eObject)
{
    m_pObjGuid = pGuid;
    m_fImpersonate = TRUE;
    m_pwcsObjectName = const_cast<LPWSTR>(szObjectName);
    m_fTryDS = FALSE;
    m_fFreeSD = FALSE;
    ASSERT(pSD && IsValidSecurityDescriptor(pSD));
    m_SD = pSD;

    m_hr = MQ_OK;
}

/***************************************************************************

Function:
    ~CQMDSSecureableObject

Description:
    The distractor of CQMDSSecureableObject

***************************************************************************/
CQMDSSecureableObject::~CQMDSSecureableObject()
{
    if (m_fFreeSD)
    {
        delete[] (char*)m_SD;
    }
}


/***************************************************************************

Function:
    CQMSecureablePrivateObject

Description:
    The constructor of CQMSecureablePrivateObject

***************************************************************************/
CQMSecureablePrivateObject::CQMSecureablePrivateObject(
    AD_OBJECT eObject,
    ULONG ulID) :
    CSecureableObject(eObject)
{
    ASSERT(m_eObject == eQUEUE);

    m_fImpersonate = TRUE;
    m_ulID = ulID;

    m_hr = GetObjectSecurity();
}

/***************************************************************************

Function:
    ~CQMSecureablePrivateObject

Description:
    The distractor of CQMSecureablePrivateObject

***************************************************************************/
CQMSecureablePrivateObject::~CQMSecureablePrivateObject()
{
    delete[] (char*)m_SD;
    delete[] m_pwcsObjectName;
}

/***************************************************************************

Function:

    GetObjectSecurityPropIDs

Parameters:
    dwObjectType - Identifies the type of the object.

Description:
    The function returns the security property id for the given object
    (i.e., returns PROPID_Q_SECURITY for MQQM_QUEUE).

***************************************************************************/

#define NAME_INDEX 0
#define SECURITY_INDEX 1

STATIC
void
GetObjectSecurityPropIDs(
    AD_OBJECT eObject,
    PROPID *aPropId)
{
    ASSERT(eObject == eQUEUE);

    aPropId[NAME_INDEX] = PROPID_Q_PATHNAME;
    aPropId[SECURITY_INDEX] = PROPID_Q_SECURITY;
}

/***************************************************************************

Function:

    GetObjectSecurity

Description:
    The function retrieves the security descriptor for a given object. The
    buffer for the security descriptor is allocated by the data base manager
    and should be freed when not needed. The function does not validate access
    rights. The calling code sohuld first validate the user's access
    permissions to set the security descriptor of the object.

***************************************************************************/
HRESULT
CQMSecureablePrivateObject::GetObjectSecurity()
{
    ASSERT(m_eObject == eQUEUE);

    m_SD = NULL;
    m_pwcsObjectName = NULL;

    HRESULT hr;
    PROPID aPropID[2];
    PROPVARIANT aPropVar[2];

    GetObjectSecurityPropIDs(m_eObject, aPropID);
    aPropVar[NAME_INDEX].vt = aPropVar[SECURITY_INDEX].vt = VT_NULL;

    hr = g_QPrivate.QMGetPrivateQueuePropertiesInternal(m_ulID,
                                                        2,
                                                        aPropID,
                                                        aPropVar);

    if (!SUCCEEDED(hr))
    {
        return LogHR(hr, s_FN, 60);
    }

    //m_pwcsObjectName = new WCHAR[9];
    //wsprintf(m_pwcsObjectName, TEXT("%08x"), m_ulID);

    ASSERT(aPropVar[NAME_INDEX].vt == VT_LPWSTR);
    ASSERT(aPropVar[SECURITY_INDEX].vt == VT_BLOB);
    m_pwcsObjectName = aPropVar[NAME_INDEX].pwszVal;
    m_SD = (PSECURITY_DESCRIPTOR)aPropVar[SECURITY_INDEX].blob.pBlobData;
    ASSERT(IsValidSecurityDescriptor(m_SD));

    return(MQ_OK);
}

/***************************************************************************

Function:
    SetObjectSecurity

Description:
    Sets the security descriptor of a QM object. The calling code sohuld
    first validate the user's access permissions to set the security
    descriptor of the object.

***************************************************************************/
HRESULT
CQMSecureablePrivateObject::SetObjectSecurity()
{
    HRESULT hr;
    PROPID aPropID[2];
    PROPVARIANT PropVar;

    GetObjectSecurityPropIDs(m_eObject, aPropID);
    PropVar.vt = VT_BLOB;
    PropVar.blob.pBlobData = (BYTE*)m_SD;
    PropVar.blob.cbSize = GetSecurityDescriptorLength(m_SD);

    hr = g_QPrivate.QMSetPrivateQueuePropertiesInternal(
			m_ulID,
			1,
			&aPropID[SECURITY_INDEX],
			&PropVar);

    return LogHR(hr, s_FN, 70);
}

/***************************************************************************

Function:
    CheckPrivateQueueCreateAccess

Description:
    Verifies that the user has access rights to create a private queue.

***************************************************************************/
HRESULT
CheckPrivateQueueCreateAccess()
{
    CQMDSSecureableObject DSMacSec(
                            eMACHINE,
                            QueueMgr.GetQMGuid(),
                            TRUE,
                            FALSE,
                            g_szMachineName);

    return LogHR(DSMacSec.AccessCheck(MQSEC_CREATE_QUEUE), s_FN, 80);
}


PUCHAR
SubAuthorityCountSid95(
    IN PSID Sid
    )
/*++

Routine Description:

    This function returns the address of the sub-authority count field of
    an SID.

Arguments:

    Sid - Pointer to the SID data structure.

Return Value:


--*/
{
    PISID ISid;

    //
    //  Typecast to the opaque SID
    //

    ISid = (PISID)Sid;

    return &(ISid->SubAuthorityCount);

}

//++
//
//  ULONG
//  SeLengthSid(
//      IN PSID Sid
//      );
//
//  Routine Description:
//
//      This routine computes the length of a SID.
//
//  Arguments:
//
//      Sid - Points to the SID whose length is to be returned.
//
//  Return Value:
//
//      The length, in bytes of the SID.
//
//--

#define LengthSid95( Sid ) \
    (8 + (4 * ((SID *)Sid)->SubAuthorityCount))

#define EqualSid EqualSid95

BOOL
EqualSid95 (
    IN PSID Sid1,
    IN PSID Sid2
    )

/*++

Routine Description:

    This procedure tests two SID values for equality.

Arguments:

    Sid1, Sid2 - Supply pointers to the two SID values to compare.
        The SID structures are assumed to be valid.

Return Value:

    BOOL - TRUE if the value of Sid1 is equal to Sid2, and FALSE
        otherwise.

--*/

{
   ULONG SidLength;

   //
   // Make sure they are the same revision
   //

   if ( ((SID *)Sid1)->Revision == ((SID *)Sid2)->Revision ) {

       //
       // Check the SubAuthorityCount first, because it's fast and
       // can help us exit faster.
       //

       if ( *SubAuthorityCountSid95( Sid1 ) == *SubAuthorityCountSid95( Sid2 )) {

           SidLength = LengthSid95( Sid1 );
           return( memcmp( Sid1, Sid2, SidLength) == 0 );
       }
   }

   return( FALSE );

}


static
void
CheckClientContextSendAccess(
    const void* pSD,
	AUTHZ_CLIENT_CONTEXT_HANDLE ClientContext
    )
/*++

Routine Description:
	Check if the client has send access.
	normal termination means access is granted.
	can throw bad_win32_error() if AuthzAccessCheck() fails.
	or bad_hresult() if access is not granted

Arguments:
	pSD - pointer to the security descriptor
	ClientContext - handle to authz client context.

Returned Value:
	None.	
	
--*/
{
	ASSERT(IsValidSecurityDescriptor(const_cast<PSECURITY_DESCRIPTOR>(pSD)));

	AUTHZ_ACCESS_REQUEST Request;

	Request.DesiredAccess = MQSEC_WRITE_MESSAGE;
	Request.ObjectTypeList = NULL;
	Request.ObjectTypeListLength = 0;
	Request.PrincipalSelfSid = NULL;
	Request.OptionalArguments = NULL;

	AUTHZ_ACCESS_REPLY Reply;

	DWORD dwErr;
	Reply.Error = (PDWORD)&dwErr;

	ACCESS_MASK AcessMask;
	Reply.GrantedAccessMask = (PACCESS_MASK) &AcessMask;
	Reply.ResultListLength = 1;
	Reply.SaclEvaluationResults = NULL;

	if(!AuthzAccessCheck(
			0,
			ClientContext,
			&Request,
			NULL,
			const_cast<PSECURITY_DESCRIPTOR>(pSD),
			NULL,
			0,
			&Reply,
			NULL
			))
	{
		DWORD gle = GetLastError();
		DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _TEXT("QM: AuthzAccessCheck() failed, err = 0x%x"), gle));
        LogHR(HRESULT_FROM_WIN32(gle), s_FN, 83);

		ASSERT(("AuthzAccessCheck failed", 0));
		throw bad_win32_error(gle);
	}

	if(!(Reply.GrantedAccessMask[0] & MQSEC_WRITE_MESSAGE))
	{
		DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _TEXT("QM: AuthzAccessCheck() did not GrantedAccess AuthzAccessCheck(), err = 0x%x"), Reply.Error[0]));
        LogHR(HRESULT_FROM_WIN32(Reply.Error[0]), s_FN, 85);

		ASSERT(!IsAllGranted(
					MQSEC_WRITE_MESSAGE,
					const_cast<PSECURITY_DESCRIPTOR>(pSD)
					));

		DumpAccessCheckFailureInfo(
			MQSEC_WRITE_MESSAGE,
			const_cast<PSECURITY_DESCRIPTOR>(pSD),
			ClientContext
			);
		
		throw bad_hresult(MQ_ERROR_ACCESS_DENIED);
	}
}



HRESULT
VerifySendAccessRights(
    CQueue *pQueue,
    PSID pSenderSid,
    USHORT uSenderIdType
    )
/*++

Routine Description:
	This function perform access check:
	it verify the the sender has access rights to the queue.

Arguments:
    pQueue - (In) pointer to the Queue
	pSenderSid - (In) pointer to the sender sid
	uSenderIdType - (in) sender sid type

Returned Value:
	MQ_OK(0) if access allowed else error code

--*/
{
    ASSERT(pQueue->IsLocalQueue());

	//
    // Get the queue security descriptor.
	//
    const void* pSD = pQueue->GetSecurityDescriptor();

    if (!pSD)
    {
		//
		// The queue is local queue but MSMQ can't retrieve the SD of the queue. This can be happened when the
		// queue is deleted. The QM succeeded to fetch the queue properties but when it tried to fetch the SD
		// the queue object didn't exist anymore. In this case we want to reject the message since the queue
		// doesn't exist any moreand the QM can't verify the send permission
		//
		return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 95);
    }

    R<CAuthzClientContext> pAuthzClientContext;

	try
	{
		GetClientContext(
			pSenderSid,
			uSenderIdType,
			&pAuthzClientContext.ref()
			);
	}
	catch(const bad_api&)
	{
		//
		// If we failed to build client context from the sid
		// Check if the queue allow all write message permission
		//

		if(ADGetEnterprise() == eMqis)
		{
			//
			// We are in NT4 environment and Queues are created with everyone permissions and not anonymous permissions
			// need to check if the security descriptor allow everyone to write message.
			//
			if(IsEveryoneGranted(MQSEC_WRITE_MESSAGE, const_cast<PSECURITY_DESCRIPTOR>(pSD)))			
			{
				TrTRACE(QmSecUtl, "Access allowed: NT4 environmet, Queue %ls allow everyone write message permission", pQueue->GetQueueName());
				return LogHR(MQ_OK, s_FN, 103);
			}
			TrERROR(QmSecUtl, "Access denied: NT4 environment, Queue %ls does not allow everyone write message permission", pQueue->GetQueueName());
			return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 104);
		}

		if(IsAllGranted(MQSEC_WRITE_MESSAGE, const_cast<PSECURITY_DESCRIPTOR>(pSD)))
		{

			//
			// Queue security descriptor allow all to write message.
			//
			TrTRACE(QmSecUtl, "Access allowed: Queue %ls allow all write message permission", pQueue->GetQueueName());
			return LogHR(MQ_OK, s_FN, 106);
		}

		TrERROR(QmSecUtl, "Access denied: Queue %ls does not allow all write message permission", pQueue->GetQueueName());
		return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 108);
	}

	try
	{
		CheckClientContextSendAccess(
			pSD,
			pAuthzClientContext->m_hAuthzClientContext
			);
	}
	catch(const bad_api&)
	{
		TrERROR(QmSecUtl, "Access denied: failed to grant write message permission for Queue %ls", pQueue->GetQueueName());
		return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 97);
	}

	TrTRACE(QmSecUtl, "Allowed write message permission for Queue %ls", pQueue->GetQueueName());
	return LogHR(MQ_OK, s_FN, 99);

}


inline void AFXAPI DestructElements(PCERTINFO *ppCertInfo, int nCount)
{
    for (; nCount--; ppCertInfo++)
    {
        (*ppCertInfo)->Release();
    }
}

//
// A map from cert digest to cert info.
//
static CCache <GUID, const GUID &, PCERTINFO, PCERTINFO> g_CertInfoMap;


static
bool
IsCertSelfSigned(
	CMQSigCertificate* pCert
	)
/*++

Routine Description:
	This function check if the certificate is self signed

Arguments:
    pCert - pointer to the certificate

Returned Value:
	false if the certificate is not self sign, true otherwise

--*/
{
    //
    // Check if the certificate is self sign.
    //
    HRESULT hr = pCert->IsCertificateValid(
							pCert, // pIssuer
							x_dwCertValidityFlags,
							NULL,  // pTime
							TRUE   // ignore NotBefore.
							);

    if (hr == MQSec_E_CERT_NOT_SIGNED)
    {
		//
		// This error is expected if the certificate is not self sign.
		// the signature validation with the certificate public key has failed.
		// So the certificate is not self sign
		//
        return false;
    }

	//
	// We did not get signature error so it is self sign certificate
	//
	return true;
}



static
HRESULT
GetCertInfo(
	const UCHAR *pCertBlob,
	ULONG        ulCertSize,
	LPCWSTR      wszProvName,
	DWORD        dwProvType,
	BOOL         fNeedSidInfo,
	PCERTINFO   *ppCertInfo
	)
/*++
Routine Description:
	Get certificate info

Arguments:

Returned Value:
	MQ_OK, if successful, else error code.

--*/
{
    //
    // Create the certificate object.
    //
    R<CMQSigCertificate> pCert;

    HRESULT hr = MQSigCreateCertificate(
					 &pCert.ref(),
					 NULL,
					 const_cast<UCHAR *> (pCertBlob),
					 ulCertSize
					 );

    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 100);
        return MQ_ERROR_INVALID_CERTIFICATE;
    }

    //
    // Compute the certificate digets. The certificate digest is the key
    // for the map and also the key for searchnig the certificate in the
    // DS.
    //

    GUID guidCertDigest;

    hr = pCert->GetCertDigest(&guidCertDigest);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 110);
    }

    CS lock(g_CertInfoMap.m_cs);
    BOOL fReTry;

    do
    {
        fReTry = FALSE;

        //
        // Try to retrieve the information from the map.
        //
        if (!g_CertInfoMap.Lookup(guidCertDigest, *ppCertInfo))
        {
            //
            // The map does not contain the required information yet.
            //

            //
            // Convert the provider name strings to ANSI. This is
            // required for Win95. It is also required for working around a
            // bug in the default base RSA CSP. The default RSA CSP fails in
            // the unicode version of CryptAcquireContext when invoked with
            // the CRYPT_VERIFYCONTEXT flag.
            //

            DWORD dwProvNameLen = wcslen(wszProvName);
            P<char> szProvName = new char [dwProvNameLen + 1];

            WideCharToMultiByte(
				CP_ACP,
				0,
				wszProvName,
				-1,
				szProvName,
				dwProvNameLen + 1,
				NULL,
				NULL
				);

            R<CERTINFO> pCertInfo = new CERTINFO;

            //
            // Get a handle to the CSP verification context.
            //
            if (!CryptAcquireContextA(
					 &pCertInfo->hProv,
					 NULL,
					 szProvName,
					 dwProvType,
					 CRYPT_VERIFYCONTEXT
					 ))
            {
                LogNTStatus(GetLastError(), s_FN, 120);
                return MQ_ERROR_INVALID_CERTIFICATE;
            }

            //
            // Get a handle to the public key in the certificate.
            //
            hr = pCert->GetPublicKey(
							pCertInfo->hProv,
							&pCertInfo->hPbKey
							);

            if (FAILED(hr))
            {
                LogHR(hr, s_FN, 130);
                return MQ_ERROR_INVALID_CERTIFICATE;
            }

			//
			// COMMENT - need to add additional functions to query the DS
			// meanwhile only MQDS_USER, guidCertDigest	is supported
			// ilanh 24.5.00
			//

			//
            // Get the sernder's SID.
            //
            PROPID PropId = PROPID_U_SID;
            PROPVARIANT PropVar;

            PropVar.vt = VT_NULL;
            hr = ADGetObjectPropertiesGuid(
                            eUSER,
                            NULL,       // pwcsDomainController
							false,	    // fServerName
                            &guidCertDigest,
                            1,
                            &PropId,
                            &PropVar
							);

            if (SUCCEEDED(hr))
            {
                DWORD dwSidLen = PropVar.blob.cbSize;
                pCertInfo->pSid = (PSID)new char[dwSidLen];
                DWORD bRet = CopySid(dwSidLen, pCertInfo->pSid, PropVar.blob.pBlobData);
                ASSERT(bRet);
				DBG_USED(bRet);

				ASSERT((pCertInfo->pSid != NULL) && IsValidSid(pCertInfo->pSid));

                delete[] PropVar.blob.pBlobData;
            }
			
            //
            // Store the certificate information in the map.
            //
            g_CertInfoMap.SetAt(guidCertDigest, pCertInfo.get());
            *ppCertInfo = pCertInfo.detach();
        }
        else
        {
            if (fNeedSidInfo && (*ppCertInfo)->pSid == NULL)
            {
                //
                // If we need the SID inofrmation, but the cached certificate
                // information does not contain the SID, we should go to the
                // DS once more in order to see whether the certificate was
                // regitered in the DS in the mean time. So we remove the
                // certificate from the cache and do the loop once more.
                // In the second interation, the certificate will not be found
                // in the cache so we'll go to the DS.
                //
                g_CertInfoMap.RemoveKey(guidCertDigest);
                (*ppCertInfo)->Release();
                *ppCertInfo = NULL;
                fReTry = TRUE;
            }
        }
    } while(fReTry);

	if((*ppCertInfo)->pSid == NULL)
	{
		//
		// If the certificate was not found in the DS
		// Check if the certificate is self signed
		//
		(*ppCertInfo)->fSelfSign = IsCertSelfSigned(pCert.get());
	}

    return MQ_OK;
}


HRESULT
GetCertInfo(
    CQmPacket *PktPtrs,
    PCERTINFO *ppCertInfo,
	BOOL fNeedSidInfo
    )
/*++
Routine Description:
	Get certificate info

Arguments:
	PktPtrs - pointer to the packet
	ppCertInfo - pointer to certinfo class
	fNeedSidInfo - flag for retrieve sid info from the ds

Returned Value:
	MQ_OK, if successful, else error code.

--*/
{
    ULONG ulCertSize;
    const UCHAR *pCert;

    pCert = PktPtrs->GetSenderCert(&ulCertSize);

    if (!ulCertSize)
    {
        //
        // That's an odd case, the message was sent with a signature, but
        // without a certificate. Someone must have tampered with the message.
        //
		ASSERT(("Dont have Certificate info", ulCertSize != 0));
        return LogHR(MQ_ERROR, s_FN, 140);
    }

    //
    // Get the CSP information from the packet.
    //
    BOOL bDefProv;
    LPCWSTR wszProvName = NULL;
    DWORD dwProvType = 0;

    PktPtrs->GetProvInfo(&bDefProv, &wszProvName, &dwProvType);

    if (bDefProv)
    {
        //
        // We use the default provider.
        //
        wszProvName = MS_DEF_PROV;
        dwProvType = PROV_RSA_FULL;
    }

    HRESULT hr = GetCertInfo(
					 pCert,
					 ulCertSize,
					 wszProvName,
					 dwProvType,
					 fNeedSidInfo,
					 ppCertInfo
					 );

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 150);
    }

    return(MQ_OK);
}


static
HRESULT
VerifySid(
    CQmPacket * PktPtrs,
    PCERTINFO *ppCertInfo
    )
/*++
Routine Description:
    Verify that the sender identity in the massage matches the SID that is
    stored with the certificate in the DS.

Arguments:
	PktPtrs - pointer to the packet
	ppCertInfo - pointer to certinfo class

Returned Value:
	MQ_OK, if successful, else error code.

--*/
{

    //
    // Verify that the sender identity in the massage matches the SID that is
    // stored with the certificate in the DS.
    //
    if (PktPtrs->GetSenderIDType() == MQMSG_SENDERID_TYPE_SID)
    {
        USHORT wSidLen;

        PSID pSid = (PSID)PktPtrs->GetSenderID(&wSidLen);
        if (!pSid ||
            !(*ppCertInfo)->pSid ||
            !EqualSid(pSid, (*ppCertInfo)->pSid))
        {
            //
            // No match, the message is illegal.
            //
            return LogHR(MQ_ERROR, s_FN, 160);
        }
    }

    return(MQ_OK);
}


static
HRESULT
GetCertInfo(
    CQmPacket *PktPtrs,
    PCERTINFO *ppCertInfo
    )
/*++
Routine Description:
	Get certificate info
	and Verify that the sender identity in the massage matches the SID that is
    stored with the certificate in the DS.

Arguments:
	PktPtrs - pointer to the packet
	ppCertInfo - pointer to certinfo class

Returned Value:
	MQ_OK, if successful, else error code.

--*/
{
	HRESULT hr = GetCertInfo(
					 PktPtrs,
					 ppCertInfo,
					 PktPtrs->GetSenderIDType() == MQMSG_SENDERID_TYPE_SID
					 );

	if(FAILED(hr))
		return(hr);

    return(VerifySid(PktPtrs, ppCertInfo));
}


PSID
AppGetCertSid(
	const BYTE*  pCertBlob,
	ULONG        ulCertSize,
	bool		 fDefaultProvider,
	LPCWSTR      pwszProvName,
	DWORD        dwProvType
	)
/*++
Routine Description:
	Get user sid that match the given certificate blob

Arguments:
	pCertBlob - Certificate blob.
	ulCertSize - Certificate blob size.
	fDefaultProvider - default provider flag.
	pwszProvName - Provider name.
	dwProvType - provider type.

Returned Value:
	PSID or NULL if we failed to find user sid.

--*/

{
	if (fDefaultProvider)
	{
		//
		// We use the default provider.
		//
		pwszProvName = MS_DEF_PROV;
		dwProvType = PROV_RSA_FULL;
	}

	R<CERTINFO> pCertInfo;
	HRESULT hr = GetCertInfo(
					pCertBlob,
					ulCertSize,
					pwszProvName,
					dwProvType,
					true,  // fNeedSidInfo
					&pCertInfo.ref()
					);

	if(FAILED(hr) || (pCertInfo->pSid == NULL))
	{
		return NULL;
	}

	ASSERT(IsValidSid(pCertInfo->pSid));

	DWORD SidLen = GetLengthSid(pCertInfo->pSid);
	AP<BYTE> pCleanSenderSid = new BYTE[SidLen];
	BOOL fSuccess = CopySid(SidLen, pCleanSenderSid, pCertInfo->pSid);
	ASSERT(fSuccess);
	if (!fSuccess)
	{
		return NULL;
	}

	return reinterpret_cast<PSID>(pCleanSenderSid.detach());
}


class QMPBKEYINFO : public CCacheValue
{
public:
    CHCryptKey hKey;

private:
    ~QMPBKEYINFO() {}
};

typedef QMPBKEYINFO *PQMPBKEYINFO;

inline void AFXAPI DestructElements(PQMPBKEYINFO *ppQmPbKeyInfo, int nCount)
{
    for (; nCount--; ppQmPbKeyInfo++)
    {
        (*ppQmPbKeyInfo)->Release();
    }
}

//
// A map from QM guid to public key.
//
static CCache <GUID, const GUID&, PQMPBKEYINFO, PQMPBKEYINFO> g_MapQmPbKey;

/*************************************************************************

  Function:
    GetQMPbKey

  Parameters -
    pQmGuid - The QM's ID (GUID).
    phQMPbKey - A pointer to a buffer that receives the key handle
    fGoToDs - Always try to retrieve the public key from the DS and update
        the cache.

  Return value-
    MQ_OK if successful, else an error code.

  Comments -
    The function creates a handle to the public signing key of the QM.

*************************************************************************/
STATIC
HRESULT
GetQMPbKey(
    const GUID *pguidQM,
    PQMPBKEYINFO *ppQmPbKeyInfo,
    BOOL fGoToDs)
{
    HRESULT hr;
    BOOL fFoundInCache;

    if (!g_hProvVer)
    {
#ifdef _DEBUG
        static BOOL s_fAlreadyAsserted = FALSE ;
        if (!s_fAlreadyAsserted)
        {
            ASSERT(g_hProvVer) ;
            s_fAlreadyAsserted = TRUE ;
        }
#endif
        return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 170);
    }

    CS lock(g_MapQmPbKey.m_cs);

    fFoundInCache = g_MapQmPbKey.Lookup(*pguidQM, *ppQmPbKeyInfo);

    if (!fFoundInCache)
    {
        fGoToDs = TRUE;
    }

    if (fGoToDs)
    {
        if (!QueueMgr.CanAccessDS())
        {
            return LogHR(MQ_ERROR_NO_DS, s_FN, 180);
        }

        //
        // Get the public key blob.
        //
        PROPID prop = PROPID_QM_SIGN_PK;
        CMQVariant var;

        hr = ADGetObjectPropertiesGuid(
                eMACHINE,
                NULL,       // pwcsDomainController
				false,	    // fServerName
                pguidQM,
                1,
                &prop,
                var.CastToStruct()
                );
        if (FAILED(hr))
        {
            LogHR(hr, s_FN, 190);
            return MQ_ERROR_INVALID_OWNER;
        }

        R<QMPBKEYINFO> pQmPbKeyNewInfo = new QMPBKEYINFO;

        //
        // Import the public key blob and get a handle to the public key.
        //
        if (!CryptImportKey(
                g_hProvVer,
                (var.CastToStruct())->blob.pBlobData,
                (var.CastToStruct())->blob.cbSize,
                NULL,
                0,
                &pQmPbKeyNewInfo->hKey))
        {
            DWORD dwErr = GetLastError() ;
            DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _TEXT(
               "GetQMPbKey(), fail at CryptImportKey(), err- %lxh"), dwErr));

            LogNTStatus(dwErr, s_FN, 200);
            return MQ_ERROR_CORRUPTED_SECURITY_DATA;
        }

        if (fFoundInCache)
        {
            //
            // Remove the key so it'll be destroyed.
            //
            (*ppQmPbKeyInfo)->Release();
            g_MapQmPbKey.RemoveKey(*pguidQM);
        }

        //
        // Update the map
        //
        g_MapQmPbKey.SetAt(*pguidQM, pQmPbKeyNewInfo.get());

        //
        // Pass on the result.
        //
        *ppQmPbKeyInfo = pQmPbKeyNewInfo.detach();
    }

    return MQ_OK;
}

//+-----------------------------------------------------------------------
//
//  NTSTATUS  _GetDestinationFormatName()
//
//  Input:
//      pwszTargetFormatName- fix length buffer. Try this one first, to
//          save a "new" allocation.
//      pdwTargetFormatNameLength- on input, length (in characters) of
//          pwszTargetFormatName. On output, length (in bytes) of string,
//          including NULL termination.
//
//  Output string is return in  ppwszTargetFormatName.
//
//+-----------------------------------------------------------------------

NTSTATUS
_GetDestinationFormatName(
	IN QUEUE_FORMAT *pqdDestQueue,
	IN WCHAR        *pwszTargetFormatName,
	IN OUT DWORD    *pdwTargetFormatNameLength,
	OUT WCHAR      **ppAutoDeletePtr,
	OUT WCHAR      **ppwszTargetFormatName
	)
{
    *ppwszTargetFormatName = pwszTargetFormatName;
    ULONG dwTargetFormatNameLengthReq = 0;

    NTSTATUS rc = MQpQueueFormatToFormatName(
					  pqdDestQueue,
					  pwszTargetFormatName,
					  *pdwTargetFormatNameLength,
					  &dwTargetFormatNameLengthReq ,
                      false
					  );

    if (rc == MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL)
    {
        ASSERT(dwTargetFormatNameLengthReq > *pdwTargetFormatNameLength);
        *ppAutoDeletePtr = new WCHAR[ dwTargetFormatNameLengthReq ];
        *pdwTargetFormatNameLength = dwTargetFormatNameLengthReq;

        rc = MQpQueueFormatToFormatName(
				 pqdDestQueue,
				 *ppAutoDeletePtr,
				 *pdwTargetFormatNameLength,
				 &dwTargetFormatNameLengthReq,
                 false
				 );

        if (FAILED(rc))
        {
            ASSERT(0);
            return LogNTStatus(rc, s_FN, 910);
        }
        *ppwszTargetFormatName = *ppAutoDeletePtr;
    }

    if (SUCCEEDED(rc))
    {
        *pdwTargetFormatNameLength =
                     (1 + wcslen(*ppwszTargetFormatName)) * sizeof(WCHAR);
    }
    else
    {
        *pdwTargetFormatNameLength = 0;
    }

    return LogNTStatus(rc, s_FN, 915);
}

//+------------------------------------------------------------------------
//
//  BOOL  _AcceptOnlyEnhAuthn()
//
//  Return TRUE if local computer is configured to accept only messages
//  with enhanced authentication.
//
//+------------------------------------------------------------------------

STATIC BOOL  _AcceptOnlyEnhAuthn()
{
    static BOOL s_fRegistryRead = FALSE ;
    static BOOL s_fUseOnlyEnhSig = FALSE ;

    if (!s_fRegistryRead)
    {
        DWORD dwVal  = DEFAULT_USE_ONLY_ENH_MSG_AUTHN  ;
        DWORD dwSize = sizeof(DWORD);
        DWORD dwType = REG_DWORD;

        LONG rc = GetFalconKeyValue( USE_ONLY_ENH_MSG_AUTHN_REGNAME,
                                    &dwType,
                                    &dwVal,
                                    &dwSize );
        if ((rc == ERROR_SUCCESS) && (dwVal == 1))
        {
            DBGMSG((DBGMOD_SECURITY, DBGLVL_WARNING, _TEXT(
             "QM: This computer will accept only Enh authentication"))) ;

            s_fUseOnlyEnhSig = TRUE ;
        }
        s_fRegistryRead = TRUE ;
    }

    return s_fUseOnlyEnhSig ;
}

//
// Function -
//      HashMessageProperties
//
// Parameters -
//     hHash - A handle to a hash object.
//     pmp - A pointer to the message properties.
//     pRespQueueFormat - The responce queue.
//     pAdminQueueFormat - The admin queue.
//
// Description -
//      The function calculates the hash value for the message properties.
//
HRESULT
HashMessageProperties(
    IN HCRYPTHASH hHash,
    IN CONST CMessageProperty* pmp,
    IN CONST QUEUE_FORMAT* pqdAdminQueue,
    IN CONST QUEUE_FORMAT* pqdResponseQueue
    )
{
    HRESULT hr;

    hr = HashMessageProperties(
            hHash,
            pmp->pCorrelationID,
            PROPID_M_CORRELATIONID_SIZE,
            pmp->dwApplicationTag,
            pmp->pBody,
            pmp->dwBodySize,
            pmp->pTitle,
            pmp->dwTitleSize,
            pqdResponseQueue,
            pqdAdminQueue);

    return(hr);
}


//+------------------------------------
//
//  HRESULT _VerifySignatureEx()
//
//+------------------------------------

static
HRESULT
_VerifySignatureEx(
	IN CQmPacket    *PktPtrs,
	IN HCRYPTPROV    hProv,
	IN HCRYPTKEY     hPbKey,
	IN ULONG         dwBodySize,
	IN const UCHAR  *pBody,
	IN QUEUE_FORMAT *pRespQueueformat,
	IN QUEUE_FORMAT *pAdminQueueformat,
	IN bool fMarkAuth
	)
{
    ASSERT(hProv);
    ASSERT(hPbKey);

    const struct _SecuritySubSectionEx * pSecEx =
                    PktPtrs->GetSubSectionEx(e_SecInfo_User_Signature_ex);

    if (!pSecEx)
    {
        //
        // Ex signature not available. Depending on registry setting, we
        // may reject such messages.
        //
        if (_AcceptOnlyEnhAuthn())
        {
            return LogHR(MQ_ERROR_FAIL_VERIFY_SIGNATURE_EX, s_FN, 916);
        }
        return LogHR(MQ_INFORMATION_ENH_SIG_NOT_FOUND, s_FN, 917);
    }

    //
    // Compute the hash value and then validate the signature.
    //
    DWORD dwErr = 0;
    CHCryptHash hHash;

    if (!CryptCreateHash(hProv, PktPtrs->GetHashAlg(), 0, 0, &hHash))
    {
        dwErr = GetLastError();
        LogNTStatus(dwErr, s_FN, 900);
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _TEXT(
          "QM: _VerifySignatureEx(), fail at CryptCreateHash(), err- %lxh"), dwErr));

        return MQ_ERROR_CANNOT_CREATE_HASH_EX ;
    }

    HRESULT hr = HashMessageProperties(
                    hHash,
                    PktPtrs->GetCorrelation(),
                    PROPID_M_CORRELATIONID_SIZE,
                    PktPtrs->GetApplicationTag(),
                    pBody,
                    dwBodySize,
                    PktPtrs->GetTitlePtr(),
                    PktPtrs->GetTitleLength() * sizeof(WCHAR),
                    pRespQueueformat,
                    pAdminQueueformat
					);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 1010);
    }

    //
    // Get FormatName of target queue.
    //
    QUEUE_FORMAT qdDestQueue;
    BOOL f = PktPtrs->GetDestinationQueue(&qdDestQueue);
    ASSERT(f);
	DBG_USED(f);

    WCHAR  wszTargetFormatNameBuf[256];
    ULONG dwTargetFormatNameLength = sizeof(wszTargetFormatNameBuf) /
                                     sizeof(wszTargetFormatNameBuf[0]);
    WCHAR *pwszTargetFormatName = NULL;
    P<WCHAR> pCleanName = NULL;

    NTSTATUS rc = _GetDestinationFormatName(
						&qdDestQueue,
						wszTargetFormatNameBuf,
						&dwTargetFormatNameLength,
						&pCleanName,
						&pwszTargetFormatName
						);
    if (FAILED(rc))
    {
        return LogNTStatus(rc, s_FN, 920);
    }
    ASSERT(pwszTargetFormatName);

    //
    // Prepare user flags.
    //
    struct _MsgFlags sUserFlags;
    memset(&sUserFlags, 0, sizeof(sUserFlags));

    sUserFlags.bDelivery  = (UCHAR)  PktPtrs->GetDeliveryMode();
    sUserFlags.bPriority  = (UCHAR)  PktPtrs->GetPriority();
    sUserFlags.bAuditing  = (UCHAR)  PktPtrs->GetAuditingMode();
    sUserFlags.bAck       = (UCHAR)  PktPtrs->GetAckType();
    sUserFlags.usClass    = (USHORT) PktPtrs->GetClass();
    sUserFlags.ulBodyType = (ULONG)  PktPtrs->GetBodyType();

    //
    // Prepare array of properties to hash.
    // (_MsgHashData already include one property).
    //
    DWORD dwStructSize = sizeof(struct _MsgHashData) +
                            (3 * sizeof(struct _MsgPropEntry));
    P<struct _MsgHashData> pHashData =
                        (struct _MsgHashData *) new BYTE[dwStructSize];

    pHashData->cEntries = 3;
    (pHashData->aEntries[0]).dwSize = dwTargetFormatNameLength;
    (pHashData->aEntries[0]).pData = (const BYTE*) pwszTargetFormatName;
    (pHashData->aEntries[1]).dwSize = sizeof(GUID);
    (pHashData->aEntries[1]).pData = (const BYTE*) PktPtrs->GetSrcQMGuid();
    (pHashData->aEntries[2]).dwSize = sizeof(sUserFlags);
    (pHashData->aEntries[2]).pData = (const BYTE*) &sUserFlags;
    LONG iIndex = pHashData->cEntries;

    GUID guidConnector = GUID_NULL;
    const GUID *pConnectorGuid = &guidConnector;

    if (pSecEx->_u._UserSigEx.m_bfConnectorType)
    {
        const GUID *pGuid = PktPtrs->GetConnectorType();
        if (pGuid)
        {
            pConnectorGuid = pGuid;
        }

        (pHashData->aEntries[ iIndex ]).dwSize = sizeof(GUID);
        (pHashData->aEntries[ iIndex ]).pData = (const BYTE*) pConnectorGuid;
        iIndex++;
        pHashData->cEntries = iIndex;
    }

    hr = MQSigHashMessageProperties(hHash, pHashData);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 1030);
    }

    //
    // It's time to verify if signature is ok.
    //
    ULONG ulSignatureSize = ((ULONG) pSecEx ->wSubSectionLen) -
                                    sizeof(struct _SecuritySubSectionEx);
    const UCHAR *pSignature = (const UCHAR *) &(pSecEx->aData[0]);

    if (!CryptVerifySignatureA(
				hHash,
				pSignature,
				ulSignatureSize,
				hPbKey,
				NULL,
				0
				))
    {
        dwErr = GetLastError();
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _TEXT(
         "QM: _VerifySignatureEx(), fail at CryptVerifySignature(), err- %lxh"),
                                                           dwErr));

        ASSERT_BENIGN(0);
        return LogHR(MQ_ERROR_FAIL_VERIFY_SIGNATURE_EX, s_FN, 918);
    }

    DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("QM: VerifySignatureEx completed ok")));

	//
	// mark the message as authenticated only when needed.
	// Certificate was found in the DS or certificate is not self signed
	//
	if(!fMarkAuth)
	{
        DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("QM: The message will not mark as autheticated")));
	    return MQ_OK;
	}

	//
	// mark the authentication flag and the level of authentication as SIG20
	//
	PktPtrs->SetAuthenticated(TRUE);
	PktPtrs->SetLevelOfAuthentication(MQMSG_AUTHENTICATED_SIG20);
    return MQ_OK;
}

/***************************************************************************

Function:
    VerifySignature

Description:
    Verify that the signature in the packet fits the message body and the
    public key in certificate.

***************************************************************************/

HRESULT
VerifySignature(CQmPacket * PktPtrs)
{
    HRESULT hr;
    ULONG ulSignatureSize = 0;
    const UCHAR *pSignature;

    ASSERT(!PktPtrs->IsEncrypted());
    PktPtrs->SetAuthenticated(FALSE);
    PktPtrs->SetLevelOfAuthentication(MQMSG_AUTHENTICATION_NOT_REQUESTED);


	//
    // Get the signature from the packet.
    //
    pSignature = PktPtrs->GetSignature((USHORT *)&ulSignatureSize);
    if ((!ulSignatureSize) && (PktPtrs->GetSignatureMqfSize() == 0))
    {
		//
        // No signature, nothing to verify.
		//
        return(MQ_OK);
    }

    BOOL fRetry = FALSE;
	bool fMarkAuth = true;

    do
    {
        HCRYPTPROV hProv = NULL;
        HCRYPTKEY hPbKey = NULL;
        R<QMPBKEYINFO> pQmPbKeyInfo;
        R<CERTINFO> pCertInfo;

        switch (PktPtrs->GetSenderIDType())
        {
        case MQMSG_SENDERID_TYPE_QM:
			{
				//
				// Get the QM's public key.
				//
				USHORT uSenderIDLen;

				GUID *pguidQM =((GUID *)PktPtrs->GetSenderID(&uSenderIDLen));
				ASSERT(uSenderIDLen == sizeof(GUID));
				if (uSenderIDLen != sizeof(GUID))
				{
					return LogHR(MQ_ERROR, s_FN, 210);
				}

				hr = GetQMPbKey(pguidQM, &pQmPbKeyInfo.ref(), fRetry);
				if (FAILED(hr))
				{
					if (hr == MQ_ERROR_INVALID_OWNER)
					{
						//
						// The first replication packet of a site is generated by
						// the new site's PSC. This PSC is not yet in the DS of the
						// receiving server. So if we could not find the machine in
						// the DS, we let the signature validation to complete with no
						// error. The packet is not marked as authenticated. The
						// code that receives the replication message recognizes
						// this packet as the first replication packet from a site.
						// It goes to the site object, that should already exist,
						// retrieves the public key of the PSC from the site object
						// and verify the packet signature.
						//
						return(MQ_OK);
					}

					return LogHR(hr, s_FN, 220);
				}
				hProv = g_hProvVer;
				hPbKey = pQmPbKeyInfo->hKey;
			}
			break;

        case MQMSG_SENDERID_TYPE_SID:
        case MQMSG_SENDERID_TYPE_NONE:
            //
            // Get the CSP information for the message certificate.
            //
            hr = GetCertInfo(PktPtrs, &pCertInfo.ref());
			if(SUCCEEDED(hr))
			{
				ASSERT(pCertInfo.get() != NULL);
				hProv = pCertInfo->hProv;
				hPbKey = pCertInfo->hPbKey;
				if((pCertInfo->pSid == NULL) && (pCertInfo->fSelfSign))
				{
					//
					// Certificate was not found in the DS (pSid == NULL)
					// and is self signed certificate.
					// In this case we will not mark the packet as authenticated
					// after verifying the signature.
					//
					fMarkAuth = false;
				}
			}

			break;
			
        default:
            ASSERT(0);
            hr = MQ_ERROR;
            break;
        }

        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_QM,
                    DBGLVL_ERROR,
                    TEXT("VerifySignature: Failed to authenticate a message, ")
                    TEXT("error = %x"), hr));
            return LogHR(hr, s_FN, 230);
        }

		if(PktPtrs->GetSignatureMqfSize() != 0)
		{
			//
			// SignatureMqf support Mqf formats
			//
			try
			{
				VerifySignatureMqf(
						PktPtrs,
						hProv,
						hPbKey,
						fMarkAuth
						);
				return MQ_OK;
			}
			catch (const bad_CryptoApi& exp)
			{
				DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _TEXT("QM: VerifySignature(), bad Crypto Class Api Excption ErrorCode = %x"), exp.error()));
				DBG_USED(exp);
				return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 232);
			}
			catch (const bad_hresult& exp)
			{
				DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _TEXT("QM: VerifySignature(), bad hresult Class Api Excption ErrorCode = %x"), exp.error()));
				DBG_USED(exp);
				return LogHR(exp.error(), s_FN, 233);
			}
			catch (const bad_alloc&)
			{
				DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _TEXT("QM: VerifySignature(), bad_alloc Excption")));
				return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 234);
			}
		}

		ULONG dwBodySize;
        const UCHAR *pBody = PktPtrs->GetPacketBody(&dwBodySize);

        QUEUE_FORMAT RespQueueformat;
        QUEUE_FORMAT *pRespQueueformat = NULL;

        if (PktPtrs->GetResponseQueue(&RespQueueformat))
        {
            pRespQueueformat = &RespQueueformat;
        }

        QUEUE_FORMAT AdminQueueformat;
        QUEUE_FORMAT *pAdminQueueformat = NULL;

        if (PktPtrs->GetAdminQueue(&AdminQueueformat))
        {
            pAdminQueueformat = &AdminQueueformat;
        }

        if (PktPtrs->GetSenderIDType() != MQMSG_SENDERID_TYPE_QM)
        {
            hr = _VerifySignatureEx(
						PktPtrs,
						hProv,
						hPbKey,
						dwBodySize,
						pBody,
						pRespQueueformat,
						pAdminQueueformat,
						fMarkAuth
						);

            if (hr == MQ_INFORMATION_ENH_SIG_NOT_FOUND)
            {
                //
                // Enhanced signature not found. validate the msmq1.0
                // signature.
                //
            }
            else
            {
                return LogHR(hr, s_FN, 890);
            }
        }

        //
        // Compute the hash value and then validate the signature.
        //
        CHCryptHash hHash;

        if (!CryptCreateHash(hProv, PktPtrs->GetHashAlg(), 0, 0, &hHash))
        {
            LogNTStatus(GetLastError(), s_FN, 235);
            return MQ_ERROR_CORRUPTED_SECURITY_DATA;
        }

        hr = HashMessageProperties(
                    hHash,
                    PktPtrs->GetCorrelation(),
                    PROPID_M_CORRELATIONID_SIZE,
                    PktPtrs->GetApplicationTag(),
                    pBody,
                    dwBodySize,
                    PktPtrs->GetTitlePtr(),
                    PktPtrs->GetTitleLength() * sizeof(WCHAR),
                    pRespQueueformat,
                    pAdminQueueformat
					);

        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 240);
        }

        if (!CryptVerifySignatureA(
					hHash,
					pSignature,
					ulSignatureSize,
					hPbKey,
					NULL,
					0
					))
        {
            if (PktPtrs->GetSenderIDType() == MQMSG_SENDERID_TYPE_QM)
            {
                fRetry = !fRetry;
                if (!fRetry)
                {
                    //
                    // When the keys of a PSC are replaced, the new public
                    // key is written in the site object directly on the PEC.
                    // The PEC replicates the change in the site object, so
                    // the signature can be verified according to the site
                    // object, similarly to the case where the QM is not
                    // found in the DS yet (after installing the new PSC).
                    // The packet is not marked as authenticated, so the
                    // code that handles the replication message will try
                    // to verify the signature according to the public key
                    // that is in the site object.
                    //
                    return(MQ_OK);
                }
            }
            else
            {
                return LogHR(MQ_ERROR, s_FN, 250);
            }
        }
        else
        {
            fRetry = FALSE;
        }
    } while (fRetry);

    DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("QM: VerifySignature10 completed ok")));

	//
	// mark the message as authenticated only when needed.
	// Certificate was found in the DS or certificate is not self signed
	//
	if(!fMarkAuth)
	{
        DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("QM: The message will not mark as autheticated")));
	    return MQ_OK;
	}

	//
	// All is well, mark the message that it is an authenticated message.
	// mark the authentication flag and the level of authentication as SIG10
	//
	PktPtrs->SetAuthenticated(TRUE);
	PktPtrs->SetLevelOfAuthentication(MQMSG_AUTHENTICATED_SIG10);

    return(MQ_OK);
}

/***************************************************************************

Function:
    QMSecurityInit

Description:
    Initialize the QM security module.

***************************************************************************/

HRESULT
QMSecurityInit()
{
    // XP SP1 bug 596791.
    MQSec_CanGenerateAudit() ;

    DWORD dwType;
    DWORD dwSize;
    ULONG lError;
    //
    // Initialize symmetric keys map parameters.
    //

    BOOL  fVal ;
    dwSize = sizeof(DWORD);
    lError = GetFalconKeyValue(
                    MSMQ_RC2_SNDEFFECTIVE_40_REGNAME,
					&dwType,
					&fVal,
					&dwSize
					);
    if (lError == ERROR_SUCCESS)
    {
        g_fSendEnhRC2WithLen40 = !!fVal ;

        if (g_fSendEnhRC2WithLen40)
        {
	        TrERROR(SECURITY, "will encrypt with enhanced RC2 symm key but only 40 bits effective key length");
///////////////    EvReport(EVENT_USE_RC2_LEN40) ; // new events not allowed in xp sp1.
        }
    }

    dwSize = sizeof(DWORD);
    lError = GetFalconKeyValue(
                     MSMQ_REJECT_RC2_IFENHLEN_40_REGNAME,
					&dwType,
					&fVal,
					&dwSize
					);
    if (lError == ERROR_SUCCESS)
    {
        g_fRejectEnhRC2WithLen40 = !!fVal ;

        if (g_fRejectEnhRC2WithLen40)
        {
	        TrTRACE(SECURITY, "will reject received messages that use enhanced RC2 symm key with 40 bits effective key length");
        }
    }

    DWORD dwCryptKeyBaseExpirationTime;

    dwSize = sizeof(DWORD);
    lError = GetFalconKeyValue(
					CRYPT_KEY_CACHE_EXPIRATION_TIME_REG_NAME,
					&dwType,
					&dwCryptKeyBaseExpirationTime,
					&dwSize
					);

    if (lError != ERROR_SUCCESS)
    {
        dwCryptKeyBaseExpirationTime = CRYPT_KEY_CACHE_DEFAULT_EXPIRATION_TIME;
    }

    DWORD dwCryptKeyEnhExpirationTime;

    dwSize = sizeof(DWORD);
    lError = GetFalconKeyValue(
					CRYPT_KEY_ENH_CACHE_EXPIRATION_TIME_REG_NAME,
					&dwType,
					&dwCryptKeyEnhExpirationTime,
					&dwSize
					);

    if (lError != ERROR_SUCCESS)
    {
        dwCryptKeyEnhExpirationTime = CRYPT_KEY_ENH_CACHE_DEFAULT_EXPIRATION_TIME;
    }

    DWORD dwCryptSendKeyCacheSize;

    dwSize = sizeof(DWORD);
    lError = GetFalconKeyValue(
					CRYPT_SEND_KEY_CACHE_REG_NAME,
					&dwType,
					&dwCryptSendKeyCacheSize,
					&dwSize
					);

    if (lError != ERROR_SUCCESS)
    {
        dwCryptSendKeyCacheSize = CRYPT_SEND_KEY_CACHE_DEFAULT_SIZE;
    }

    DWORD dwCryptReceiveKeyCacheSize;

    dwSize = sizeof(DWORD);
    lError = GetFalconKeyValue(
					CRYPT_RECEIVE_KEY_CACHE_REG_NAME,
					&dwType,
					&dwCryptReceiveKeyCacheSize,
					&dwSize
					);

    if (lError != ERROR_SUCCESS)
    {
        dwCryptReceiveKeyCacheSize = CRYPT_RECEIVE_KEY_CACHE_DEFAULT_SIZE;
    }

    InitSymmKeys(
        CTimeDuration::FromMilliSeconds(dwCryptKeyBaseExpirationTime),
        CTimeDuration::FromMilliSeconds(dwCryptKeyEnhExpirationTime),
        dwCryptSendKeyCacheSize,
        dwCryptReceiveKeyCacheSize
        );

    //
    // Initialize Certificates map parameters.
    //

    DWORD dwCertInfoCacheExpirationTime;

    dwSize = sizeof(DWORD);
    lError = GetFalconKeyValue(
					CERT_INFO_CACHE_EXPIRATION_TIME_REG_NAME,
					&dwType,
					&dwCertInfoCacheExpirationTime,
					&dwSize
					);

    if (lError != ERROR_SUCCESS)
    {
        dwCertInfoCacheExpirationTime = CERT_INFO_CACHE_DEFAULT_EXPIRATION_TIME;
    }

    g_CertInfoMap.m_CacheLifetime = CTimeDuration::FromMilliSeconds(dwCertInfoCacheExpirationTime);

    DWORD dwCertInfoCacheSize;

    dwSize = sizeof(DWORD);
    lError = GetFalconKeyValue(
					CERT_INFO_CACHE_SIZE_REG_NAME,
					&dwType,
					&dwCertInfoCacheSize,
					&dwSize
					);

    if (lError != ERROR_SUCCESS)
    {
        dwCertInfoCacheSize = CERT_INFO_CACHE_DEFAULT_SIZE;
    }

    g_CertInfoMap.InitHashTable(dwCertInfoCacheSize);

    //
    // Initialize QM public key map parameters.
    //

    DWORD dwQmPbKeyCacheExpirationTime;

    dwSize = sizeof(DWORD);
    lError = GetFalconKeyValue(
					QM_PB_KEY_CACHE_EXPIRATION_TIME_REG_NAME,
					&dwType,
					&dwQmPbKeyCacheExpirationTime,
					&dwSize
					);

    if (lError != ERROR_SUCCESS)
    {
        dwQmPbKeyCacheExpirationTime = QM_PB_KEY_CACHE_DEFAULT_EXPIRATION_TIME;
    }

    g_MapQmPbKey.m_CacheLifetime = CTimeDuration::FromMilliSeconds(dwQmPbKeyCacheExpirationTime);

    DWORD dwQmPbKeyCacheSize;

    dwSize = sizeof(DWORD);
    lError = GetFalconKeyValue(
					QM_PB_KEY_CACHE_SIZE_REG_NAME,
					&dwType,
					&dwQmPbKeyCacheSize,
					&dwSize
					);

    if (lError != ERROR_SUCCESS)
    {
        dwQmPbKeyCacheSize = QM_PB_KEY_CACHE_DEFAULT_SIZE;
    }

    g_MapQmPbKey.InitHashTable(dwQmPbKeyCacheSize);


    //
    // Initialize User Authz context map parameters.
    //

    DWORD dwUserCacheExpirationTime;

    dwSize = sizeof(DWORD);
    lError = GetFalconKeyValue(
					USER_CACHE_EXPIRATION_TIME_REG_NAME,
					&dwType,
					&dwUserCacheExpirationTime,
					&dwSize
					);

    if (lError != ERROR_SUCCESS)
    {
        dwUserCacheExpirationTime = USER_CACHE_DEFAULT_EXPIRATION_TIME;
    }

    DWORD dwUserCacheSize;

    dwSize = sizeof(DWORD);
    lError = GetFalconKeyValue(
					USER_CACHE_SIZE_REG_NAME,
					&dwType,
					&dwUserCacheSize,
					&dwSize
					);

    if (lError != ERROR_SUCCESS)
    {
        dwUserCacheSize = USER_CACHE_SIZE_DEFAULT_SIZE;
    }

    InitUserMap(
        CTimeDuration::FromMilliSeconds(dwUserCacheExpirationTime),
        dwUserCacheSize
        );

    return MQ_OK;
}

/***************************************************************************

Function:
    SignProperties

Description:
    Sign the challenge and the properties.

***************************************************************************/

STATIC
HRESULT
SignProperties(
    HCRYPTPROV  hProv,
    BYTE        *pbChallenge,
    DWORD       dwChallengeSize,
    DWORD       cp,
    PROPID      *aPropId,
    PROPVARIANT *aPropVar,
    BYTE        *pbSignature,
    DWORD       *pdwSignatureSize)
{
    HRESULT hr;
    CHCryptHash hHash;

    //
    // Create a hash object and hash the challenge.
    //
    if (!CryptCreateHash(hProv, CALG_MD5, NULL, 0, &hHash) ||
        !CryptHashData(hHash, pbChallenge, dwChallengeSize, 0))
    {
        LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 260);
    }

    if (cp)
    {
        //
        // Hash the properties.
        //
        hr = HashProperties(hHash, cp, aPropId, aPropVar);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 270);
        }
    }

    //
    // Sign it all.
    //
    if (!CryptSignHashA(
            hHash,
            AT_SIGNATURE,
            NULL,
            0,
            pbSignature,
            pdwSignatureSize))
    {
        DWORD dwerr = GetLastError();
        if (dwerr == ERROR_MORE_DATA)
        {
            return LogHR(MQ_ERROR_USER_BUFFER_TOO_SMALL, s_FN, 280);
        }
        else
        {
            LogNTStatus(dwerr, s_FN, 290);
            return MQ_ERROR_CORRUPTED_SECURITY_DATA;
        }
    }

    return(MQ_OK);
}

/***************************************************************************

Function:
    SignQMSetProps

Description:
    This is the callback function that the DS calls to sign the challenge
    and the properties. This way we let the QM to set it's own machnie's
    properties.

***************************************************************************/

HRESULT
SignQMSetProps(
    IN     BYTE    *pbChallenge,
    IN     DWORD   dwChallengeSize,
    IN     DWORD_PTR dwContext,
    OUT    BYTE    *pbSignature,
    IN OUT DWORD   *pdwSignatureSize,
    IN     DWORD   dwSignatureMaxSize)
{

    struct DSQMSetMachinePropertiesStruct *s =
        (struct DSQMSetMachinePropertiesStruct *)dwContext;
    DWORD cp = s->cp;
    PROPID *aPropId = s->aProp;
    PROPVARIANT *aPropVar = s->apVar;

    *pdwSignatureSize = dwSignatureMaxSize;

    //
    // challenge is always signed with base provider.
    //
    HCRYPTPROV hProvQM = NULL ;
    HRESULT hr = MQSec_AcquireCryptoProvider( eBaseProvider,
                                             &hProvQM ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 310);
    }

    ASSERT(hProvQM) ;
    hr = SignProperties(
            hProvQM,
            pbChallenge,
            dwChallengeSize,
            cp,
            aPropId,
            aPropVar,
            pbSignature,
            pdwSignatureSize);

    return LogHR(hr, s_FN, 320);
}

HRESULT
QMSignGetSecurityChallenge(
    IN     BYTE    *pbChallenge,
    IN     DWORD   dwChallengeSize,
    IN     DWORD_PTR dwUnused, // dwContext
    OUT    BYTE    *pbChallengeResponce,
    IN OUT DWORD   *pdwChallengeResponceSize,
    IN     DWORD   dwChallengeResponceMaxSize)
{

    *pdwChallengeResponceSize = dwChallengeResponceMaxSize;

    //
    // challenge is always signed with base provider.
    //
    HCRYPTPROV hProvQM = NULL ;
    HRESULT hr = MQSec_AcquireCryptoProvider( eBaseProvider,
                                             &hProvQM ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 340) ;
    }

    ASSERT(hProvQM) ;
    hr = SignProperties(
            hProvQM,
            pbChallenge,
            dwChallengeSize,
            0,
            NULL,
            NULL,
            pbChallengeResponce,
            pdwChallengeResponceSize);

    return LogHR(hr, s_FN, 350);
}


HRESULT
GetCertInfo(
    CACSendParameters * pSendParams,
    PCERTINFO *         ppCertInfo
    )
{
    HRESULT hr;

    //
    // Get the CSP information for the message certificate.
    //

    LPCWSTR wszProvName;
    DWORD dwProvType;

    //
    // Get the CSP information from the packet.
    //
    if (pSendParams->MsgProps.fDefaultProvider)
    {
        //
        // We use the default provider.
        //
        wszProvName = MS_DEF_PROV;
        dwProvType = PROV_RSA_FULL;
    }
    else
    {
        if (!pSendParams->MsgProps.ppwcsProvName ||
            !pSendParams->MsgProps.pulProvType)
        {
            //
            // The mesage signature should be verified with some other CSP
            // than the default CSP, but the CSP info is messing. This is
            // an illegal message.
            //
            return LogHR(MQ_ERROR, s_FN, 390);
        }

        wszProvName = *pSendParams->MsgProps.ppwcsProvName;
        dwProvType = *pSendParams->MsgProps.pulProvType;
    }

    if (!pSendParams->MsgProps.ppSenderCert)
    {
        //
        // The message does not contain a certificate, but it contains a
        // signature, this is an illegal message.
        //
        return LogHR(MQ_ERROR, s_FN, 400);
    }

    BOOL fShouldVerifySid = !pSendParams->MsgProps.pulSenderIDType ||
                            *pSendParams->MsgProps.pulSenderIDType == MQMSG_SENDERID_TYPE_SID;

    hr = GetCertInfo(*pSendParams->MsgProps.ppSenderCert,
                     pSendParams->MsgProps.ulSenderCertLen,
                     wszProvName,
                     dwProvType,
                     fShouldVerifySid,
                     ppCertInfo);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 410);
    }


    if (fShouldVerifySid &&
        (!pSendParams->MsgProps.ppSenderID ||
         !*pSendParams->MsgProps.ppSenderID ||
         !(*ppCertInfo)->pSid ||
         !EqualSid(*pSendParams->MsgProps.ppSenderID, (*ppCertInfo)->pSid)))
    {
        //
        // The SID in the message does not match the SID that is
        // associated with the certificate. This message is illegal.
        //
        return LogHR(MQ_ERROR, s_FN, 420);
    }

    return MQ_OK;
}


/***************************************************************************

Function:
    GetAdminGroupSecurityDescriptor

Description:
    Get local admin group security descriptor, with the right premissions.

Environment:
    Windows NT only

***************************************************************************/
STATIC
PSECURITY_DESCRIPTOR
GetAdminGroupSecurityDescriptor(
    DWORD AccessMask
    )
{
    //
    // Get the SID of the local administrators group.
    //
    PSID pAdminSid;
    SID_IDENTIFIER_AUTHORITY NtSecAuth = SECURITY_NT_AUTHORITY;

    if (!AllocateAndInitializeSid(
                &NtSecAuth,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0,
                0,
                0,
                0,
                0,
                0,
                &pAdminSid))
    {
        return 0;
    }

    P<SECURITY_DESCRIPTOR> pSD = new SECURITY_DESCRIPTOR;

    //
    // Allocate a DACL for the local administrators group
    //
    DWORD dwDaclSize = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + GetLengthSid(pAdminSid);
    P<ACL> pDacl = (PACL) new BYTE[dwDaclSize];

    //
    // Create the security descriptor and set the it as the security
    // descriptor of the administrator group.
    //

    if(
        //
        // Construct DACL with administrator
        //
        !InitializeAcl(pDacl, dwDaclSize, ACL_REVISION) ||
        !AddAccessAllowedAce(pDacl, ACL_REVISION, AccessMask, pAdminSid) ||

        //
        // Construct Security Descriptor
        //
        !InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION) ||
        !SetSecurityDescriptorOwner(pSD, pAdminSid, FALSE) ||
        !SetSecurityDescriptorGroup(pSD, pAdminSid, FALSE) ||
        !SetSecurityDescriptorDacl(pSD, TRUE, pDacl, FALSE))
    {
        FreeSid(pAdminSid);
        return 0;
    }

    pDacl.detach();
    return pSD.detach();
}


/***************************************************************************

Function:
    FreeAdminGroupSecurityDescriptor

Description:
    Free Security descriptor allocated by GetAdminGroupSecurityDescriptor

Environment:
    Windows NT only

***************************************************************************/
STATIC
void
FreeAdminGroupSecurityDescriptor(
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    SECURITY_DESCRIPTOR* pSD = static_cast<SECURITY_DESCRIPTOR*>(pSecurityDescriptor);
    FreeSid(pSD->Owner);
    delete ((BYTE*)pSD->Dacl);
    delete pSD;
}


/***************************************************************************

Function:
    MapMachineQueueAccess

Description:
    Converts the access mask passed to MQOpenQueue for a machine queue to the
    access mask that should be used when checking the access rights in the
    security descriptor.

Environment:
    Windows NT only

***************************************************************************/
STATIC
DWORD
MapMachineQueueAccess(
    DWORD dwAccess,
    BOOL fJournalQueue)
{
    DWORD dwDesiredAccess = 0;

    ASSERT(!(dwAccess & MQ_SEND_ACCESS));

    if (dwAccess & MQ_RECEIVE_ACCESS)
    {
        dwDesiredAccess |=
            fJournalQueue ? MQSEC_RECEIVE_JOURNAL_QUEUE_MESSAGE :
                            MQSEC_RECEIVE_DEADLETTER_MESSAGE;
    }

    if (dwAccess & MQ_PEEK_ACCESS)
    {
        dwDesiredAccess |=
            fJournalQueue ? MQSEC_PEEK_JOURNAL_QUEUE_MESSAGE :
                            MQSEC_PEEK_DEADLETTER_MESSAGE;
    }

    return dwDesiredAccess;
}


/***************************************************************************

Function:
    MapQueueOpenAccess

Description:
    Converts the access mask passed to MQOpenQueue to the access mask that
    should be used when checking the access rights in the security
    descriptor.

Environment:
    Windows NT only

***************************************************************************/
STATIC
DWORD
MapQueueOpenAccess(
    DWORD dwAccess,
    BOOL fJournalQueue)
{
    DWORD dwDesiredAccess = 0;

    if (dwAccess & MQ_RECEIVE_ACCESS)
    {
        dwDesiredAccess |=
            fJournalQueue ? MQSEC_RECEIVE_JOURNAL_MESSAGE :
                            MQSEC_RECEIVE_MESSAGE;
    }

    if (dwAccess & MQ_SEND_ACCESS)
    {
        ASSERT(!fJournalQueue);
        dwDesiredAccess |= MQSEC_WRITE_MESSAGE;
    }

    if (dwAccess & MQ_PEEK_ACCESS)
    {
        dwDesiredAccess |= MQSEC_PEEK_MESSAGE;
    }

    return dwDesiredAccess;
}


/***************************************************************************

Function:
    DoDSAccessCheck
    DoDSAccessCheck
    DoPrivateAccessCheck
    DoAdminAccessCheck

Description:
    Helper funcitons for VerifyOpenQueuePremissions

Environment:
    Windows NT only

***************************************************************************/
STATIC
HRESULT
DoDSAccessCheck(
    AD_OBJECT eObject,
    const GUID *pID,
    BOOL fInclSACL,
    BOOL fTryDS,
    LPCWSTR pObjectName,
    DWORD dwDesiredAccess
    )
{
    CQMDSSecureableObject so(eObject, pID, fInclSACL, fTryDS, pObjectName);
    return LogHR(so.AccessCheck(dwDesiredAccess), s_FN, 460);
}


STATIC
HRESULT
DoDSAccessCheck(
    AD_OBJECT eObject,
    const GUID *pID,
    PSECURITY_DESCRIPTOR pSD,
    LPCWSTR pObjectName,
    DWORD dwDesiredAccess
    )
{
	if(pSD == NULL)
	{
        return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 465);
	}

	ASSERT(IsValidSecurityDescriptor(pSD));
    CQMDSSecureableObject so(eObject, pID, pSD, pObjectName);
    return LogHR(so.AccessCheck(dwDesiredAccess), s_FN, 470);
}


STATIC
HRESULT
DoPrivateAccessCheck(
    AD_OBJECT eObject,
    ULONG ulID,
    DWORD dwDesiredAccess
    )
{
    CQMSecureablePrivateObject so(eObject, ulID);
    return LogHR(so.AccessCheck(dwDesiredAccess), s_FN, 480);
}


STATIC
HRESULT
DoAdminAccessCheck(
    AD_OBJECT eObject,
    const GUID* pID,
    LPCWSTR pObjectName,
    DWORD dwAccessMask,
    DWORD dwDesiredAccess
    )
{
    PSECURITY_DESCRIPTOR pSD = GetAdminGroupSecurityDescriptor(dwAccessMask);

    if(pSD == 0)
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 500);

    HRESULT hr;
    hr = DoDSAccessCheck(eObject, pID, pSD, pObjectName, dwDesiredAccess);
    FreeAdminGroupSecurityDescriptor(pSD);
    return LogHR(hr, s_FN, 510);
}


/***************************************************************************

Function:
    VerifyOpenPermissionRemoteQueue

Description:
    Verify open premissions on non local queues

Environment:
    Windows NT only

***************************************************************************/
STATIC
HRESULT
VerifyOpenPermissionRemoteQueue(
    const CQueue* pQueue,
    const QUEUE_FORMAT* pQueueFormat,
    DWORD dwAccess
    )
{
    //
    // Check open queue premissions on non local queues only (outgoing)
    //
    HRESULT hr2;

    switch(pQueueFormat->GetType())
    {
        case QUEUE_FORMAT_TYPE_PUBLIC:
        case QUEUE_FORMAT_TYPE_PRIVATE:
        case QUEUE_FORMAT_TYPE_DIRECT:
        case QUEUE_FORMAT_TYPE_MULTICAST:
            if(dwAccess & MQ_SEND_ACCESS)
            {
                //
                // We do not check send permissions on remote machines. We say
                // that it's OK. The remote machine will accept or reject the
                // message.
                //
                // System direct queues should have been replaced with machine queues
                // at this stage
                //
                ASSERT(!pQueueFormat->IsSystemQueue());
                return MQ_OK;
            }

            ASSERT(dwAccess & MQ_ADMIN_ACCESS);

            hr2 = DoAdminAccessCheck(
                        eQUEUE,
                        pQueue->GetQueueGuid(),
                        pQueue->GetQueueName(),
                        MQSEC_QUEUE_GENERIC_READ,
                        MQSEC_RECEIVE_MESSAGE);
            return LogHR(hr2, s_FN, 520);


        case QUEUE_FORMAT_TYPE_CONNECTOR:
            if(!IsRoutingServer())  //[adsrv] CQueueMgr::GetMQS() == SERVICE_NONE) - Raphi
            {
                //
                // Connector queue can only be opend on MSMQ servers
                //
                return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 530);
            }

            hr2 = DoDSAccessCheck(
                        eSITE,
                        &pQueueFormat->ConnectorID(),
                        TRUE,
                        TRUE,
                        NULL,
                        MQSEC_CN_OPEN_CONNECTOR);
            return LogHR(hr2, s_FN, 535);

        case QUEUE_FORMAT_TYPE_MACHINE:
        default:
            ASSERT(0);
            return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 540);
    }
}


/***************************************************************************

Function:
    VerifyOpenPermissionLocalQueue

Description:
    Verify open premissions on local queues only

Environment:
    Windows NT only

***************************************************************************/
STATIC
HRESULT
VerifyOpenPermissionLocalQueue(
    CQueue* pQueue,
    const QUEUE_FORMAT* pQueueFormat,
    DWORD dwAccess,
    BOOL fJournalQueue
    )
{
    //
    // Check open queue premissions on local queues only.
    //

    HRESULT hr2;

    switch(pQueueFormat->GetType())
    {
        case QUEUE_FORMAT_TYPE_PUBLIC:
            hr2 = DoDSAccessCheck(
                        eQUEUE,
                        &pQueueFormat->PublicID(),
                        const_cast<PSECURITY_DESCRIPTOR>(pQueue->GetSecurityDescriptor()),
                        pQueue->GetQueueName(),
                        MapQueueOpenAccess(dwAccess, fJournalQueue));
            return LogHR(hr2, s_FN, 550);

        case QUEUE_FORMAT_TYPE_MACHINE:
            hr2 = DoDSAccessCheck(
                        eMACHINE,
                        &pQueueFormat->MachineID(),
                        TRUE,
                        FALSE,
                        g_szMachineName,
                        MapMachineQueueAccess(dwAccess, fJournalQueue));
            return LogHR(hr2, s_FN, 560);

        case QUEUE_FORMAT_TYPE_PRIVATE:
            hr2 = DoPrivateAccessCheck(
                        eQUEUE,
                        pQueueFormat->PrivateID().Uniquifier,
                        MapQueueOpenAccess(dwAccess, fJournalQueue));
            return LogHR(hr2, s_FN, 570);

        case QUEUE_FORMAT_TYPE_DIRECT:
            //
            // This is a local DIRECT queue.
            // The queue object is either of PUBLIC or PRIVATE type.
            //
            switch(pQueue->GetQueueType())
            {
                case QUEUE_TYPE_PUBLIC:
                     hr2 = DoDSAccessCheck(
                                eQUEUE,
                                pQueue->GetQueueGuid(),
                                const_cast<PSECURITY_DESCRIPTOR>(pQueue->GetSecurityDescriptor()),
                                pQueue->GetQueueName(),
                                MapQueueOpenAccess(dwAccess, fJournalQueue));
                     return LogHR(hr2, s_FN, 580);

                case QUEUE_TYPE_PRIVATE:
                    hr2 = DoPrivateAccessCheck(
                                eQUEUE,
                                pQueue->GetPrivateQueueId(),
                                MapQueueOpenAccess(dwAccess, fJournalQueue));
                    return LogHR(hr2, s_FN, 590);

                default:
                    ASSERT(0);
                    return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 600);
            }

        case QUEUE_FORMAT_TYPE_CONNECTOR:
        default:
            ASSERT(0);
            return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 610);
    }
}


/***************************************************************************

Function:
    VerifyOpenPermission

Description:
    Verify open premissions for any queue

Environment:
    Windows NT, Windows 9x

***************************************************************************/
HRESULT
VerifyOpenPermission(
    CQueue* pQueue,
    const QUEUE_FORMAT* pQueueFormat,
    DWORD dwAccess,
    BOOL fJournalQueue,
    BOOL fLocalQueue
    )
{
    if(fLocalQueue)
    {
        return LogHR(VerifyOpenPermissionLocalQueue(pQueue, pQueueFormat, dwAccess, fJournalQueue), s_FN, 620);
    }
    else
    {
        return LogHR(VerifyOpenPermissionRemoteQueue(pQueue, pQueueFormat, dwAccess), s_FN, 630);
    }

}

/***************************************************************************

Function:
    VerifyMgmtPermission

Description:
    Verify Managment premissions for the machine
    This function is used for "admin" access, i.e., to verify if
    caller is local admin.

Environment:
    Windows NT

***************************************************************************/

HRESULT
VerifyMgmtPermission(
    const GUID* MachineId,
    LPCWSTR MachineName
    )
{
    HRESULT hr = DoAdminAccessCheck(
                    eMACHINE,
                    MachineId,
                    MachineName,
                    MQSEC_MACHINE_GENERIC_ALL,
                    MQSEC_SET_MACHINE_PROPERTIES
                    );
    return LogHR(hr, s_FN, 640);
}

/***************************************************************************

Function:
    VerifyMgmtGetPermission

Description:
    Verify Managment "get" premissions for the machine
    Use local cache of security descriptor.

Environment:
    Windows NT

***************************************************************************/

HRESULT
VerifyMgmtGetPermission(
    const GUID* MachineId,
    LPCWSTR MachineName
    )
{
    HRESULT hr = DoDSAccessCheck( eMACHINE,
                                  MachineId,
                                  TRUE,   // fInclSACL,
                                  FALSE,  // fTryDS,
                                  MachineName,
                                  MQSEC_GET_MACHINE_PROPERTIES ) ;

    return LogHR(hr, s_FN, 660);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qmta.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    qmta.h

Abstract:
    Definition of well known size TA_ADDRESS

Author:
    Uri Habusha (urih), 23-May-2000

--*/

#ifndef __QMTA_H__
#define __QMTA_H__

#include "_ta.h"

class CAddress
{
public:
    USHORT AddressLength;
    USHORT AddressType;
    UCHAR Address[FOREIGN_ADDRESS_LEN];
};

C_ASSERT(FIELD_OFFSET(CAddress, AddressLength) == FIELD_OFFSET(TA_ADDRESS, AddressLength));
C_ASSERT(FIELD_OFFSET(CAddress, AddressType) == FIELD_OFFSET(TA_ADDRESS, AddressType));
C_ASSERT(FIELD_OFFSET(CAddress, Address)  == FIELD_OFFSET(TA_ADDRESS, Address));
C_ASSERT(sizeof(USHORT) + sizeof(USHORT)  == TA_ADDRESS_SIZE);

#endif //__QMTA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qmutil.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    qmutil.cpp

Abstract:

    QM utilities

--*/

#include "stdh.h"
#include "uniansi.h"
#include "qmutil.h"
#include "_rstrct.h"
#include "cqueue.h"
#include "_registr.h"
#include "mqprops.h"
#include "sessmgr.h"
#include "mqformat.h"
#include "mqsocket.h"
#include "ad.h"
#include "acioctl.h"
#include "acapi.h"
#include <nspapi.h>
#include <Fn.h>

#include "qmutil.tmh"

extern LPTSTR           g_szMachineName;
extern CSessionMgr      SessionMgr;
extern AP<WCHAR> g_szComputerDnsName;


static WCHAR *s_FN=L"qmutil";


void TA2StringAddr(IN const TA_ADDRESS * pa, OUT LPTSTR psz)
{
    WCHAR  szTmp[100];


    ASSERT(psz != NULL);
    ASSERT(pa != NULL);
    ASSERT(pa->AddressType == IP_ADDRESS_TYPE ||
           pa->AddressType == FOREIGN_ADDRESS_TYPE);

    switch(pa->AddressType)
    {
        case IP_ADDRESS_TYPE:
        {
            char * p = inet_ntoa(*(struct in_addr *)(pa->Address));
            swprintf(szTmp, TEXT("%S"), p);
            break;
        }

        case FOREIGN_ADDRESS_TYPE:
        {
            GUID_STRING strUuid;
            MQpGuidToString((GUID*)(pa->Address), strUuid);
            swprintf(szTmp, L"%s", strUuid);
            break;
        }

        default:
            ASSERT(0);
    }

    swprintf(psz, TEXT("%d %s"), pa->AddressType, szTmp);
}


void String2TA(IN LPCTSTR psz, OUT TA_ADDRESS** ppa)
{
    ASSERT(psz != NULL);
    ASSERT(ppa != NULL);
    AP<WCHAR> szTmp = new WCHAR[wcslen(psz)];

    DWORD dw, type;
    _stscanf(psz, TEXT("%d %s"), &type, szTmp.get());

    switch(type)
    {
        case IP_ADDRESS_TYPE:
        {
            AP<char> chTemp = new char[wcslen(szTmp) + 1];

            *ppa = (TA_ADDRESS *) new char [TA_ADDRESS_SIZE + IP_ADDRESS_LEN];

            sprintf(chTemp,"%S", szTmp);
            dw = inet_addr(chTemp);

            (*ppa)->AddressLength = IP_ADDRESS_LEN;
            (*ppa)->AddressType =  IP_ADDRESS_TYPE;
            * ((DWORD *)&((*ppa)->Address)) = dw;

            break;
        }

        case FOREIGN_ADDRESS_TYPE:
        {
            *ppa = (TA_ADDRESS *) new char [TA_ADDRESS_SIZE + FOREIGN_ADDRESS_LEN];

            (*ppa)->AddressLength = FOREIGN_ADDRESS_LEN;
            (*ppa)->AddressType =  FOREIGN_ADDRESS_TYPE;
            RPC_STATUS rs = UuidFromString(szTmp, ((GUID *)&((*ppa)->Address)));
            ASSERT(rs == RPC_S_OK);
			DBG_USED(rs);

            break;
        }

        default:
            ASSERT(0);
    }
}

//
// CRefreshIntervals class is used to encapsulate the different refresh
// intervals - site, enterprise and error retry. It reads the values from
// the registry, handles defaults and converts all the values to Miliseconds.
// YoelA, 24-Oct-2000
//
class CRefreshIntervals
{
public:
    unsigned __int64 GetSiteInterval();
    unsigned __int64 GetEnterpriseInterval();
    unsigned __int64 GetErrorRetryInterval();
    CRefreshIntervals();

private:
    void InitOnce(); // Initialize Values if not initialized yet
    void GetTimeIntervalFromRegistry (
        LPCTSTR pszValueName,
        unsigned __int64 *pui64Value,
        DWORD dwUnitMultiplier,
        unsigned __int64 ui64DefaultInMiliseconds);

    unsigned __int64 m_ui64SiteInterval;
    unsigned __int64 m_ui64EnterpriseInterval;
    unsigned __int64 m_ui64ErrorRetryInterval;
    bool m_fInitialized;
} s_RefreshIntervals;

//
// GetSystemTimeAsFileTime gives the time in 100 nanoseconds intervals, while we keep
// our intervals in miliseconds, so convertion is needed.
//
const DWORD x_dwSysTimeIntervalsInMilisecond = 10000;

//
// WriteFutureTimeToRegistry - this function writes a future time into the registry,
// given the time interval from present in miliseconds.
//
LONG
WriteFutureTimeToRegistry(
    LPCTSTR          pszValueName,
    unsigned __int64 ui64MilisecondsInterval)
{
    union {
        unsigned __int64 ft_scalar;
        FILETIME ft_struct;
    } ft;


    GetSystemTimeAsFileTime(&ft.ft_struct);

    ft.ft_scalar += ui64MilisecondsInterval * x_dwSysTimeIntervalsInMilisecond;

    DWORD dwSize = sizeof(ft);
    DWORD dwType = REG_QWORD;

    LONG rc = SetFalconKeyValue( pszValueName,
                                 &dwType,
                                 &ft.ft_scalar,
                                 &dwSize) ;

    return rc;
}

//
// DidRegTimeArrive returns true if a time, that was stored in the registry under pszValueName,
// already passed.
// If the time did not pass, it returns false, and *pui64MilisecondsToWait
// will hold the time interval, in miliseconds, till the time stored in the registry will arrive.
//
bool
DidRegTimeArrive(
    LPCTSTR pszValueName,
    unsigned __int64 *pui64MilisecondsToWait
    )
{
    //
    // Tolerance - how much time before the time arrives will be considered OK.
    // the values is 1 minute, converted to units of 100 nanoseconds (same units
    // as GetSystemTimeAsFileTime)
    //
    const unsigned __int64 x_ui64Tolerance = x_dwSysTimeIntervalsInMilisecond * 1000 * 60;

    //
    // x_ui64Max is not defined as a standard constant, like ULONG_MAX, so we have to
    // define it here.
    //
    const unsigned __int64 x_ui64Max = 0xffffffffffffffff;

    //
    // If the time already ellapsed, the time to wait for it to arrive is
    // as close to infinite as possible...
    //
    *pui64MilisecondsToWait = x_ui64Max;

    //
    // Get current time
    //
    union {
        unsigned __int64 ft_scalar;
        FILETIME ft_struct;
    } ftCurrent;
    GetSystemTimeAsFileTime(&ftCurrent.ft_struct);

    unsigned __int64 ui64RegTime;

    DWORD dwSize = sizeof(ui64RegTime);
    DWORD dwType = REG_QWORD;

    LONG rc = GetFalconKeyValue( pszValueName,
                                 &dwType,
                                 &ui64RegTime,
                                 &dwSize) ;

    if ((rc != ERROR_SUCCESS) || (dwSize != sizeof(ui64RegTime)))
    {
        //
        // Assume there is no such value in registry. Return true.
        // As far as registry is concerned, it's legal to have
        // (rc == ERROR_SUCCESS) but size not equal size of QWORD if you
        // manually erase part of registry value using regedt32.
        //
        return true;
    }

    if (ui64RegTime <= ftCurrent.ft_scalar + x_ui64Tolerance)
    {
        //
        // The time passed
        //
        return true;
    }

    //
    // Time did not pass. Return the remaining time in Miliseconds
    //
    *pui64MilisecondsToWait = (ui64RegTime - ftCurrent.ft_scalar) / x_dwSysTimeIntervalsInMilisecond;
    return false;
}

//
// CRefreshIntervals Implementation
//
CRefreshIntervals::CRefreshIntervals() :
    m_ui64SiteInterval(0) ,
    m_ui64EnterpriseInterval (0) ,
    m_ui64ErrorRetryInterval (0) ,
    m_fInitialized(false)
{}

unsigned __int64 CRefreshIntervals::GetSiteInterval()
{
    InitOnce();
    return m_ui64SiteInterval;
}

unsigned __int64 CRefreshIntervals::GetEnterpriseInterval()
{
    InitOnce();
    return m_ui64EnterpriseInterval;
}

unsigned __int64 CRefreshIntervals::GetErrorRetryInterval()
{
    InitOnce();
    return m_ui64ErrorRetryInterval;
}

//
//  GetTimeIntervalFromRegistry - Reads a time interval (at key pszValueName) from
//                                the registry and returns it in Miliseconds.
//                                If the key does not exist in the registry, the default is returned.
//
void CRefreshIntervals::GetTimeIntervalFromRegistry (
    LPCTSTR             pszValueName,
    unsigned __int64    *pui64Value,
    DWORD               dwUnitMultiplier, // 3600 * 1000 for hours, 60 * 1000 for minutes
    unsigned __int64    ui64DefaultInMiliseconds
    )
{
    DWORD dwSize = sizeof(DWORD) ;
    DWORD dwType = REG_DWORD;

    DWORD dwValueInTimeUnits;

    LONG res = GetFalconKeyValue(
                            pszValueName,
                            &dwType,
                            &dwValueInTimeUnits,
                            &dwSize);

    if (res == ERROR_SUCCESS)
    {
        *pui64Value = static_cast<unsigned __int64>(dwValueInTimeUnits) *
                      static_cast<unsigned __int64>(dwUnitMultiplier);
    }
    else
    {
        *pui64Value = ui64DefaultInMiliseconds;
    }
}


void CRefreshIntervals::InitOnce()
{
    if (m_fInitialized)
    {
        return;
    }
    m_fInitialized = true;


    const DWORD x_MiliSecondsInHour = 60 * 60 * 1000;
    const DWORD x_MiliSecondsInMinute = 60 * 1000;

    unsigned __int64 ui64DefaultSiteInterval, ui64DefaultEnterpriseInterval;

    ui64DefaultSiteInterval =
                  MSMQ_DEFAULT_DS_SITE_LIST_REFRESH * x_MiliSecondsInHour;
    ui64DefaultEnterpriseInterval =
            MSMQ_DEFAULT_DS_ENTERPRISE_LIST_REFRESH * x_MiliSecondsInHour;

    //
    // Get the site and enterprise refresh intervals.
    // Note - the reg value is in hours, and we translate it to miliseconds.
    // If the old value was specified, it is used as a default. Otherwise,
    // the constant default is used.
    //

    //
    // Get site refresh value
    //
    GetTimeIntervalFromRegistry (
        MSMQ_DS_SITE_LIST_REFRESH_REGNAME,
        &m_ui64SiteInterval,
        x_MiliSecondsInHour,
        ui64DefaultSiteInterval
    );

    //
    // Get enterprise refresh value
    //
    GetTimeIntervalFromRegistry (
        MSMQ_DS_ENTERPRISE_LIST_REFRESH_REGNAME,
        &m_ui64EnterpriseInterval,
        x_MiliSecondsInHour,
        ui64DefaultEnterpriseInterval
    );

    //
    // Get Retry on error value
    //
    unsigned __int64 ui64DefaultErrorRetryInterval = MSMQ_DEFAULT_DSLIST_REFRESH_ERROR_RETRY_INTERVAL * x_MiliSecondsInMinute;

    GetTimeIntervalFromRegistry (
        MSMQ_DSLIST_REFRESH_ERROR_RETRY_INTERVAL,
        &m_ui64ErrorRetryInterval,
        x_MiliSecondsInMinute,
        ui64DefaultErrorRetryInterval
    );
}
/*======================================================

Function:         GetDsServerList

Description:      This routine gets the list of ds
                  servers from the DS

========================================================*/

DWORD g_dwDefaultTimeToQueue = MSMQ_DEFAULT_LONG_LIVE ;

DWORD GetDsServerList(OUT WCHAR *pwcsServerList,
                      IN  DWORD dwLen)
{
    #define MAX_NO_OF_PROPS 21

    //
    //  Get the names of all the servers that
    //  belong to the site
    //

    ASSERT (dwLen >= MAX_REG_DSSERVER_LEN);

    HRESULT       hr = MQ_OK;
    HANDLE        hQuery;
    DWORD         dwProps = MAX_NO_OF_PROPS;
    PROPVARIANT   result[ MAX_NO_OF_PROPS ] ;
    PROPVARIANT*  pvar;
    DWORD         index = 0;

    GUID guidEnterprise = McGetEnterpriseId();
    GUID guidSite = McGetSiteId();

    //
    // Get the default Time-To-Queue from MQIS
    //
    PROPID      aProp[1];
    PROPVARIANT aVar[1];

    aProp[0] = PROPID_E_LONG_LIVE ;
    aVar[0].vt = VT_UI4;

    hr = ADGetObjectPropertiesGuid(
				eENTERPRISE,
				NULL,       // pwcsDomainController
				false,	    // fServerName
				&guidEnterprise,
				1,
				aProp,
				aVar
				);
    if (FAILED(hr))
    {
       return 0 ;
    }

    DWORD dwSize = sizeof(DWORD) ;
    DWORD dwType = REG_DWORD;

    LONG rc = SetFalconKeyValue( MSMQ_LONG_LIVE_REGNAME,
                                 &dwType,
                                 (PVOID) &aVar[0].ulVal,
                                 &dwSize ) ;
    ASSERT(rc == ERROR_SUCCESS) ;
	DBG_USED(rc);
    g_dwDefaultTimeToQueue = aVar[0].ulVal ;




	//
	//	First assume NT5 DS server, and ask for the DNS names
	//	of the DS servers
	//
    CColumns      Colset;
    Colset.Add(PROPID_QM_PATHNAME_DNS);
	Colset.Add(PROPID_QM_PATHNAME);

    DWORD   lenw;

    hr =  ADQuerySiteServers(
                    NULL,           // pwcsDomainController
					false,			// fServerName
                    &guidSite,      // In  this machine's Site
                    eDS,            // DS server only
                    Colset.CastToStruct(),
                    &hQuery
                    );
	if ( hr == MQ_ERROR)
	{
		//
		//	Most likely, the DS server is not NT5
		//

		CColumns      ColsetNT4;
		ColsetNT4.Add(PROPID_QM_PATHNAME);
		ColsetNT4.Add(PROPID_QM_PATHNAME);
		hr = ADQuerySiteServers(
                    NULL,           // pwcsDomainController
					false,			// fServerName
                    &guidSite,      // In  this machine's Site
                    eDS,            // DS server only
					ColsetNT4.CastToStruct(),
					&hQuery
                    );
	}

    BOOL fAlwaysLast = FALSE ;
    BOOL fForceFirst = FALSE ;

    if ( SUCCEEDED(hr))
    {
        while ( SUCCEEDED ( hr = ADQueryResults( hQuery, &dwProps, result)))
        {
            //
            //  No more results to retrieve
            //
            if (!dwProps)
                break;

            pvar = result;

            for (DWORD i = 0; i < (dwProps/2) ; i++, pvar+=2)
            {
                //
                //  Add the server name to the list
                //  For load balancing, write sometimes at the
                //  beginning of the string, sometimes at the end. Like
                //  that we will have  BSCs and PSC in a random order
                //
                WCHAR * p;
				WCHAR * pwszVal;
				AP<WCHAR> pCleanup1;
				AP<WCHAR> pCleanup2 = (pvar+1)->pwszVal;

				if ( pvar->vt != VT_EMPTY)
				{
					//
					// there may be cases where server will not have DNS name
					// ( migration)
					//
					pwszVal = pvar->pwszVal;
					pCleanup1 = pwszVal;
				}
				else
				{
					pwszVal = (pvar+1)->pwszVal;
				}
                lenw = wcslen( pwszVal);

                if ( index + lenw + 4 <  MAX_REG_DSSERVER_LEN)
                {
                   if (!_wcsicmp(g_szMachineName, pwszVal))
                   {
                      //
                      // Our machine should be first on the list.
                      //
                      ASSERT(!fForceFirst) ;
                      fForceFirst = TRUE ;
                   }
                   if(index == 0)
                   {
                      //
                      // Write the 1st string
                      //
                      p = &pwcsServerList[0];
                      if (fForceFirst)
                      {
                         //
                         // From now on write all server at the end
                         // of the list is our machine remain the
                         // first in the list.
                         //
                         fAlwaysLast = TRUE ;
                      }
                   }
                   else if (fAlwaysLast ||
                             ((rand() > (RAND_MAX / 2)) && !fForceFirst))
                   {
                      //
                      // Write at the end of the string
                      //
                      pwcsServerList[index] = DS_SERVER_SEPERATOR_SIGN;
                      index ++;
                      p = &pwcsServerList[index];
                   }
                   else
                   {
                      if (fForceFirst)
                      {
                         //
                         // From now on write all server at the end
                         // of the list is our machine remain the
                         // first in the list.
                         //
                         fAlwaysLast = TRUE ;
                      }
                      //
                      // Write at the beginning of the string
                      //
                      DWORD dwSize = lenw                 +
                                     2 /* protocols flags */ +
                                     1 /* Separator    */ ;
                      //
                      // Must use memmove because buffers overlap.
                      //
                      memmove( &pwcsServerList[dwSize],
                               &pwcsServerList[0],
                               index * sizeof(WCHAR));
                      pwcsServerList[dwSize - 1] = DS_SERVER_SEPERATOR_SIGN;
                      p = &pwcsServerList[0];
                      index++;
                   }

                   //
                   // Mark only IP as supported protocol
                   //
                   *p++ = TEXT('1');
                   *p++ = TEXT('0');

                   memcpy(p, pwszVal, lenw * sizeof(WCHAR));
                   index += lenw + 2;

                }
            }
        }
        pwcsServerList[ index] = '\0';
        //
        // close the query handle
        //
        hr = ADEndQuery( hQuery);

    }

    return((index) ? index+1 : 0);
}

//+------------------------------------------------------------------------
//
//   RefreshSiteServersList()
//
// RefreshSiteServersList - refresh the list of servers, that belong to
// the current site, in the registry
//
//+------------------------------------------------------------------------

HRESULT
RefreshSiteServersList()
{
    WCHAR pwcsServerList[ MAX_REG_DSSERVER_LEN ];

    DWORD dwLen = GetDsServerList(pwcsServerList, MAX_REG_DSSERVER_LEN);

    if (dwLen == 0)
    {
        return MQ_ERROR;
    }

    //
    //  Write into registry, if succeeded to retrieve any servers
    //
    DWORD dwSize = dwLen * sizeof(WCHAR) ;
    DWORD dwType = REG_SZ;
    LONG rc = SetFalconKeyValue( MSMQ_DS_SERVER_REGNAME,
                                 &dwType,
                                 pwcsServerList,
                                 &dwSize) ;
    //
    // Update Site name in registry (only on client machines)
    //
    if (IsNonServer())   // [adsrv]  == SERVICE_NONE) - should it be only clients? Not FRS?
    {
        GUID guidSite = McGetSiteId();


       PROPID      aProp[1];
       PROPVARIANT aVar[1];
       aProp[0] =   PROPID_S_PATHNAME ;
       aVar[0].vt = VT_NULL ;
       HRESULT hr1 = ADGetObjectPropertiesGuid(
							eSITE,
							NULL,       // pwcsDomainCOntroller
							false,	    // fServerName
							&guidSite,
							1,
							aProp,
							aVar 
							);
       if (SUCCEEDED(hr1))
       {
          ASSERT(aVar[0].vt == VT_LPWSTR) ;
          AP<WCHAR> lpwsSiteName =  aVar[0].pwszVal ;

          dwType = REG_SZ;
          dwSize = (wcslen(lpwsSiteName) + 1) * sizeof(WCHAR) ;
          rc = SetFalconKeyValue( MSMQ_SITENAME_REGNAME,
                                  &dwType,
                                  lpwsSiteName,
                                  &dwSize) ;
       }
    }

    return MQ_OK ;
}

/*======================================================

Function:         TimeToUpdateDsServerList()

Description:      This routine updates the list of ds
                  servers in the registry

========================================================*/

void
WINAPI
TimeToUpdateDsServerList(
    CTimer* pTimer
    )
{
    //
    // We check the timer at least every day. Units are miliseconds
    //
    const DWORD x_dwMaximalRefreshInterval = 60 * 60 * 24 * 1000;
    DWORD dwNextUpdateInterval = x_dwMaximalRefreshInterval;

    try
    {
        //
        //  Get the names of all the servers that
        //  belong to the site
        //
        unsigned __int64 ui64NextSiteInterval;
        if (DidRegTimeArrive( MSMQ_DS_NEXT_SITE_LIST_REFRESH_TIME_REGNAME,
                             &ui64NextSiteInterval))
        {

            HRESULT hr = RefreshSiteServersList();

            if SUCCEEDED(hr)
            {
                ui64NextSiteInterval = s_RefreshIntervals.GetSiteInterval();
            }
            else
            {
                ui64NextSiteInterval = s_RefreshIntervals.GetErrorRetryInterval();
            }

            WriteFutureTimeToRegistry(
                MSMQ_DS_NEXT_SITE_LIST_REFRESH_TIME_REGNAME,
                ui64NextSiteInterval
                );

        }
        dwNextUpdateInterval = static_cast<DWORD>
                     (min(dwNextUpdateInterval, ui64NextSiteInterval)) ;

        //
        //  Update the registry key of server cache - each Enterprise refresh
        //  interval. This is not performed by routing servers, who are not
        //  expected to change site.
        //  msmq on Domain controller always prepare this cache. Bug 6698.
        //
        if (!IsRoutingServer())
        {
            unsigned __int64 ui64NextEnterpriseInterval;
            if (DidRegTimeArrive(
                    MSMQ_DS_NEXT_ENTERPRISE_LIST_REFRESH_TIME_REGNAME,
                    &ui64NextEnterpriseInterval)
               )
            {
                HRESULT hr = ADCreateServersCache() ;

                if SUCCEEDED(hr)
                {
                    ui64NextEnterpriseInterval = s_RefreshIntervals.GetEnterpriseInterval();
                }
                else
                {
                    ui64NextEnterpriseInterval = s_RefreshIntervals.GetErrorRetryInterval();
                }

                WriteFutureTimeToRegistry(
                    MSMQ_DS_NEXT_ENTERPRISE_LIST_REFRESH_TIME_REGNAME,
                    ui64NextEnterpriseInterval
                    );
            }
            dwNextUpdateInterval = static_cast<DWORD>
                (min(dwNextUpdateInterval, ui64NextEnterpriseInterval));
        }
    }
    catch(const bad_alloc&)
    {
        LogIllegalPoint(s_FN, 69);
    }

    ExSetTimer(pTimer, CTimeDuration::FromMilliSeconds(dwNextUpdateInterval)) ;
}


/*====================================================

IsDSAddressExist

Arguments:

Return Value:


=====================================================*/
BOOLEAN IsDSAddressExist(const CAddressList* AddressList,
                         TA_ADDRESS*     ptr,
                         DWORD AddressLen)
{
    POSITION        pos, prevpos;
    TA_ADDRESS*     pAddr;

    if (AddressList)
    {
        pos = AddressList->GetHeadPosition();
        while(pos != NULL)
        {
            prevpos = pos;
            pAddr = AddressList->GetNext(pos);

            if (memcmp(&(ptr->Address), &(pAddr->Address), AddressLen) == 0)
            {
                //
                // Same IP address
                //
               return TRUE;
            }
        }
    }

    return FALSE;
}

/*====================================================

IsDSAddressExistRemove

Arguments:

Return Value:


=====================================================*/
BOOL IsDSAddressExistRemove( IN const TA_ADDRESS*     ptr,
                             IN DWORD AddressLen,
                             IN OUT CAddressList* AddressList)
{
    POSITION        pos, prevpos;
    TA_ADDRESS*     pAddr;
    BOOLEAN         rc = FALSE;

    pos = AddressList->GetHeadPosition();
    while(pos != NULL)
    {
        prevpos = pos;
        pAddr = AddressList->GetNext(pos);

        if (memcmp(&(ptr->Address), &(pAddr->Address), AddressLen) == 0)
        {
            //
            // Same address
            //
           AddressList->RemoveAt(prevpos);
           delete pAddr;
           rc = TRUE;
        }
    }

    return rc;
}
/*====================================================

IsDSAddressExistRemove

Arguments:

Return Value:


=====================================================*/
BOOL IsTAAddressExistRemove( IN const TA_ADDRESS*     ptr,
                             IN OUT CAddressList* AddressList)
{
    POSITION        pos, prevpos;
    TA_ADDRESS*     pAddr;
    BOOLEAN         rc = FALSE;

    pos = AddressList->GetHeadPosition();
    while(pos != NULL)
    {
        prevpos = pos;
        pAddr = AddressList->GetNext(pos);

        if (ptr->AddressLength == pAddr->AddressLength &&
            memcmp(ptr, pAddr, TA_ADDRESS_SIZE + ptr->AddressLength) == 0)
        {
            //
            // Same address
            //
           AddressList->RemoveAt(prevpos);
           delete pAddr;
           rc = TRUE;
        }
    }

    return rc;
}

/*====================================================

IsUnknownIPAddress

Arguments:

Return Value: TRUE if "unknown" IP address.

=====================================================*/

#define  IPADDRS_UNKNOWN   0
#define  IPADDRS_LOOPBACK  0x0100007f

BOOL IsUnknownIPAddress(IN const TA_ADDRESS* pAddr)
{
    ASSERT(IP_ADDRESS_LEN == sizeof(DWORD));
    if (pAddr->AddressType != IP_ADDRESS_TYPE)
    {
        return FALSE ;
    }

    DWORD Address = IPADDRS_UNKNOWN ;
    if (!memcmp(pAddr->Address, &Address, IP_ADDRESS_LEN))
    {
        return TRUE ;
    }

    Address = IPADDRS_LOOPBACK ;
    if (!memcmp(pAddr->Address, &Address, IP_ADDRESS_LEN))
    {
        return TRUE ;
    }

    return FALSE ;
}

/*====================================================

SetAsUnknownIPAddress

Arguments:

Return Value:

=====================================================*/

void SetAsUnknownIPAddress(IN OUT TA_ADDRESS * pAddr)
{
    pAddr->AddressType = IP_ADDRESS_TYPE;
    pAddr->AddressLength = IP_ADDRESS_LEN;
    memset(pAddr->Address, 0, IP_ADDRESS_LEN);
}

STATIC void GetMachineDNSNames(LPWSTR** paLocalMachineNames)
/*++

  Routine Description:
	The Routine retrieves the local machine DNS names and cache them in array.

  Arguments:
	paLocalMachineNames	- pointer to that array where the data is stored

  Returned Value:
	None.

 --*/
{
    //
    // If the machine is network disconnected, don't try to resolve the DNS
    // name. On RAS enviroment it can cause auto-dialing
    //
    if(!CQueueMgr::IsConnected())
        return;

    //
    // Get the machine DNS NAME
    //
    struct hostent* pHost = gethostbyname(NULL);
    if (pHost == NULL)
    {
        DBGMSG((DBGMOD_ALL,
                DBGLVL_ERROR,
                _T("gethostbyname failed. WSAGetLastError: %d"), WSAGetLastError()));
        return;
    }

    //
    // Calculate the number of DNS Names
    //
    DWORD size = 1 + sizeof(pHost->h_aliases);

    LPWSTR* aNames = NULL;
    try
    {
        //
        // copy the Names from pHost to internal data structure
        //
        aNames = new LPWSTR[size];
        memset(aNames, 0, size * sizeof(LPWSTR));

        DWORD length = strlen(pHost->h_name) +1;
        aNames[0] = new WCHAR[length];		
        ConvertToWideCharString(pHost->h_name, aNames[0], length);

        for (DWORD i = 0; (pHost->h_aliases[i] != NULL); ++i)
        {
            length = strlen(pHost->h_aliases[i])	+ 1;
            aNames[i+1] = new WCHAR[length];
            ConvertToWideCharString(pHost->h_aliases[i], aNames[i+1], length);
        }
    }
    catch(const bad_alloc&)
    {
        //
        // free all the allocated memory
        //
        if (aNames != NULL)
        {
            for (DWORD i = 0; i < size; ++i)
            {
                delete aNames[i];
            }
            delete aNames;
        }
        LogIllegalPoint(s_FN, 71);
        return;
    }

    //
    // free previous data
    //
    if (*paLocalMachineNames != NULL)
    {
        for (LPWSTR const* pName = *paLocalMachineNames; (*pName != NULL); ++pName)
        {
            delete *pName;
        }
        delete *paLocalMachineNames;
    }

    *paLocalMachineNames = aNames;
}


const DWORD DNS_REFRESH_TIME = 15 * 60 * 1000;   // 15 minutes
static LPWSTR* aLocalMachineNames = NULL;
CCriticalSection    csLocalMachineNames;


STATIC void RefreshLocalComputerDnsCache()
/*++

  Routine Description:
        This routine refresh the computer DNS names cache.

  Arguments:
        none

  Returned value:
	none

 --*/
{
    static LastRefreshTime = 0;

    DWORD CurrntTime = GetTickCount();

    if ((aLocalMachineNames == 0) || (LastRefreshTime == 0) ||
    (CurrntTime - LastRefreshTime >= DNS_REFRESH_TIME))
    {
        //
        // refresh the internal data structure
        //
        GetMachineDNSNames(&aLocalMachineNames);
        LastRefreshTime = CurrntTime;
    }
}

BOOL
QmpIsLocalMachine(
	LPCWSTR MachineName,
	BOOL* pfDNSName
	)
/*++

  Routine Description:
	The routine checks that the given machine name is local. It comapres
	the machine name to the Local Machine NetBios name or the DNS names
	of the local machine.

	The routine uses the data-structure that contains the DNS names of the machine.
	However, when the routine retreives the information (using gethostbyname API), it doesn't
	get any indication if the data retreive from the machine internal cache (WINS) or from the
	DNS server.  Therfore, the routine try to refresh its internal data-structure every 15
	minutes

  Arguments:
	- path name that should be checked
	- pointer to BOOL varaiables, that used to return if the machine name is DNS name or not

  Returned value:
	TRUE if the machine is local machine, FALSE otherwise

 --*/
{
    *pfDNSName = FALSE;
    if (CompareStringsNoCase(MachineName, g_szMachineName) == 0)
        return TRUE;

	 if (CompareStringsNoCase(MachineName,L"localhost") == 0)
        return TRUE;


    //
    // Check if the given machine name is DNS name. If the given name isn't DNS name
    // we don't need to compare it agains the local machine dns name
    //
    if (wcschr(MachineName,L'.') == NULL)
        return FALSE;

    //
    // Check if the prefix of the DNS name is equal to NetBios name
    //
    if ((CompareSubStringsNoCase(MachineName, g_szMachineName, wcslen(g_szMachineName)) != 0) ||
        (MachineName[wcslen(g_szMachineName)] != L'.'))
        return FALSE;

	//
	// Check if the given name is the full dns name got from GetComputerNameEx call
	//
	if(g_szComputerDnsName != NULL &&  _wcsicmp(g_szComputerDnsName, MachineName) == 0)
	{
		*pfDNSName = TRUE;
		return TRUE;
	}

    CS lock( csLocalMachineNames);

    RefreshLocalComputerDnsCache();

    if (aLocalMachineNames == NULL)
    {
        //
        // We failed to retrieve the local machine DNS names.
        //
        return FALSE;
    }

    for (LPCWSTR const* pName = aLocalMachineNames; (*pName != NULL); ++pName)
    {
        if (CompareStringsNoCase(MachineName, *pName) == 0)
        {
	        *pfDNSName = TRUE;
	        return TRUE;
        }
    }

    return FALSE;
}


BOOL
IsPathnameForLocalMachine(
	LPCWSTR PathName,
	BOOL* pfDNSName
	)
{
    AP<WCHAR> MachineName;
	try
	{
		FnExtractMachineNameFromPathName(
			PathName,
			MachineName
			);
	}
	catch(const exception&)
	{
		return FALSE;
	}

	return QmpIsLocalMachine(MachineName.get(), pfDNSName);
}


void
GetDnsNameOfLocalMachine(
    WCHAR ** ppwcsDnsName
	)
/*++

  Routine Description:
	The routin returns a name from an internal data-structure that contains
    the DNS names of the machine.
	It doesn't try to refresh it.

  Arguments:
    ppwcsDnsName    - 	a pointer to the DNS name, or NULL if there isn't one

  Returned value:
    none


 --*/
{
    CS lock( csLocalMachineNames);

    RefreshLocalComputerDnsCache();

    if (aLocalMachineNames == NULL)
    {
        //
        // We failed to retrieve the local machine DNS names.
        //
        *ppwcsDnsName = NULL;
        return;
    }
    *ppwcsDnsName = new WCHAR[ wcslen(*aLocalMachineNames) +1];
    wcscpy( *ppwcsDnsName, *aLocalMachineNames);
    return;

}

/*====================================================

IsLocalDirectQueue

Return Value:    TRUE if the direct queue is local queue

Arguments:       pQueueFormat - pointer to QUEUE_FORMAT

=====================================================*/
BOOL IsLocalDirectQueue(const QUEUE_FORMAT* pQueueFormat, bool fInReceive)
{
    ASSERT(pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_DIRECT);

	try
	{
		LPCWSTR lpwcsDirectQueuePath = pQueueFormat->DirectID();
		ASSERT((*lpwcsDirectQueuePath != L'\0') && !iswspace(*lpwcsDirectQueuePath));

		DirectQueueType QueueType;
		lpwcsDirectQueuePath = FnParseDirectQueueType(lpwcsDirectQueuePath, &QueueType);

		AP<WCHAR> MachineName;
		FnExtractMachineNameFromDirectPath(lpwcsDirectQueuePath, MachineName);

		switch (QueueType)
		{
			case dtOS:
			{
				BOOL temp;
				return QmpIsLocalMachine(MachineName.get(), &temp);
			}

			case dtHTTP:
			case dtHTTPS:
			{
				BOOL temp;
				if(QmpIsLocalMachine(MachineName.get(), &temp))
					return TRUE;
				//
				// else fall through to case dtTCP, and check if local ip address
				//
			}

			case dtTCP:
			{
				//
				// If we received a message in direct tcp format, it should always
				// be local. (QFE 5772, YoelA, 3-Aug-2000)
				//
				if (fInReceive)
				{
					return TRUE;
				}

				AP<WCHAR> psz = new WCHAR[wcslen(MachineName.get()) + 10];
				swprintf(psz, TEXT("%d %s"), IP_ADDRESS_TYPE, MachineName.get());

				P<TA_ADDRESS> pa;
				String2TA(psz,&pa);

				return (IsDSAddressExist(SessionMgr.GetIPAddressList(), pa, IP_ADDRESS_LEN));

			}
			default:
				ASSERT(0);
				return FALSE;
		}
	}
	catch(const exception&)
	{
		return FALSE;
	}
}


/*====================================================

GetIPAddresses

Arguments:

Return Value:


=====================================================*/
CAddressList* GetIPAddresses(void)
{
    CAddressList* plIPAddresses = new CAddressList;

    //
    // Check if TCP/IP is installed and enabled
    //
    char szHostName[ MQSOCK_MAX_COMPUTERNAME_LENGTH ];
    DWORD dwSize = sizeof( szHostName);

    //
    //  Just checking if socket is initialized
    //
    if (gethostname(szHostName, dwSize) != SOCKET_ERROR)
    {
        GetMachineIPAddresses(szHostName,plIPAddresses);
    }

    return plIPAddresses;
}


/*====================================================

Function: void GetMachineIPAddresses()

Arguments:

Return Value:

=====================================================*/

void GetMachineIPAddresses(const char * szHostName, CAddressList* plIPAddresses)
{
    DBGMSG((DBGMOD_QM, DBGLVL_INFO, L"QM: GetMachineIPAddresses for %hs", szHostName));
	
    //
    // Obtain the IP information for the machine
    //
    PHOSTENT pHostEntry = gethostbyname(szHostName);

    if ((pHostEntry == NULL) || (pHostEntry->h_addr_list == NULL))
    {
	    DBGMSG((DBGMOD_QM, DBGLVL_INFO, L"QM: gethostbyname found no IP addresses for %hs", szHostName));
        return;
    }

    //
    // Add each IP address to the list of IP addresses
    //
    TA_ADDRESS * pAddr = NULL;
    for ( DWORD uAddressNum = 0 ;
          pHostEntry->h_addr_list[uAddressNum] != NULL ;
          uAddressNum++)
    {
        //
        // Keep the TA_ADDRESS format of local IP address
        //
        pAddr = (TA_ADDRESS *)new char [IP_ADDRESS_LEN + TA_ADDRESS_SIZE];
        pAddr->AddressLength = IP_ADDRESS_LEN;
        pAddr->AddressType = IP_ADDRESS_TYPE;
        memcpy( &(pAddr->Address), pHostEntry->h_addr_list[uAddressNum], IP_ADDRESS_LEN);

        DBGMSG((
            DBGMOD_QM,
            DBGLVL_INFO,
            L"QM: gethostbyname found IP address %hs ",
            inet_ntoa(*(struct in_addr *)pHostEntry->h_addr_list[uAddressNum])
            ));

        plIPAddresses->AddTail(pAddr);
    }
}


/*====================================================

CompareElements  of PQUEUE_ID

Arguments:

Return Value:


=====================================================*/


BOOL AFXAPI  CompareElements(IN const QUEUE_ID** pQueue1,
                             IN const QUEUE_ID** pQueue2)
{
    ASSERT(AfxIsValidAddress((*pQueue1)->pguidQueue, sizeof(GUID), FALSE));
    ASSERT(AfxIsValidAddress((*pQueue2)->pguidQueue, sizeof(GUID), FALSE));

    if ((*((*pQueue1)->pguidQueue) == *((*pQueue2)->pguidQueue)) &&
        ((*pQueue1)->dwPrivateQueueId == (*pQueue2)->dwPrivateQueueId))
        return TRUE;

    return FALSE;

}

/*====================================================

DestructElements of PQUEUE_ID

Arguments:

Return Value:


=====================================================*/


void AFXAPI DestructElements(IN const QUEUE_ID** ppNextHop, int n)
{
}

/*====================================================

HashKey For PQUEUE_ID

Arguments:

Return Value:


=====================================================*/
UINT AFXAPI HashKey(IN const QUEUE_ID* key)
{
    ASSERT(AfxIsValidAddress(key->pguidQueue, sizeof(GUID), FALSE));

    return((UINT)((key->pguidQueue)->Data1 + key->dwPrivateQueueId));

}

/*======================================================

Function:        GetRegistryStoragePath

Description:     Get storage path for Falcon data

Arguments:       None

Return Value:    None

========================================================*/
BOOL GetRegistryStoragePath(PCWSTR pKey, PWSTR pPath, PCWSTR pSuffix)
{
    DWORD dwValueType = REG_SZ ;
    DWORD dwValueSize = MAX_PATH;

    LONG rc;
    rc = GetFalconKeyValue(
            pKey,
            &dwValueType,
            pPath,
            &dwValueSize
            );

    if(rc != ERROR_SUCCESS)
    {
        return FALSE;
    }

    if(dwValueSize < (3 * sizeof(WCHAR)))
    {
        return FALSE;
    }

    //
    //  Check for absolute path, drive or UNC
    //
    if(!(
        (isalpha(pPath[0]) && (pPath[1] == L':')) ||
        ((pPath[0] == L'\\') && (pPath[1] == L'\\'))
        ))
    {
        return FALSE;
    }

    wcscat(pPath, pSuffix);
    return TRUE;
}

//---------------------------------------------------------
//
//  Thread Event and handle routines
//
//---------------------------------------------------------

DWORD g_dwThreadEventIndex = (DWORD)-1;
DWORD g_dwThreadHandleIndex = (DWORD)-1;

void AllocateThreadTLSs(void)
{
    ASSERT(g_dwThreadEventIndex == (DWORD)-1);
    g_dwThreadEventIndex = TlsAlloc();
    ASSERT(g_dwThreadEventIndex != (DWORD)-1);

    ASSERT(g_dwThreadHandleIndex == (DWORD)-1);
    g_dwThreadHandleIndex = TlsAlloc();
    ASSERT(g_dwThreadHandleIndex != (DWORD)-1);
}

HANDLE GetHandleForRpcCancel(void)
{
    if (g_dwThreadHandleIndex == (DWORD)-1)
    {
        ASSERT(0) ;
        return NULL ;
    }

    HANDLE hThread = (HANDLE) TlsGetValue(g_dwThreadHandleIndex);

    if (hThread == NULL)
    {
        //
        //  First time
        //
        //  Get the thread handle
        //
        HANDLE hT = GetCurrentThread();
        BOOL fResult = DuplicateHandle(
                            GetCurrentProcess(),
                            hT,
                            GetCurrentProcess(),
                           &hThread,
                            0,
                            FALSE,
                            DUPLICATE_SAME_ACCESS ) ;
        ASSERT(fResult) ;
        ASSERT(hThread);

        fResult = TlsSetValue( g_dwThreadHandleIndex, hThread );
        ASSERT(fResult) ;

        //
        // Set the lower bound on the time to wait before timing
        // out after forwarding a cancel.
        //
        RPC_STATUS status = RpcMgmtSetCancelTimeout(0);
        ASSERT(status == RPC_S_OK);
		DBG_USED(status);
    }

    return hThread ;
}

void  FreeHandleForRpcCancel(void)
{
    //
    //  If not TLS was allocated, the hThread returned is 0
    //
    HANDLE hThread = (HANDLE) TlsGetValue(g_dwThreadHandleIndex);
    if (hThread)
    {
        CloseHandle(hThread) ;
    }
}

HANDLE GetThreadEvent(void)
{
    ASSERT(g_dwThreadEventIndex != (DWORD)-1);
    HANDLE hEvent = (HANDLE) TlsGetValue(g_dwThreadEventIndex);
    if(hEvent == NULL)
    {
        //
        // Event was never allocated. This is the first
        // time this function has ever been called for this thread.
        //
        hEvent = CreateEvent(0, TRUE,FALSE, 0);

        //
        //  Set the Event first bit to disable completion port posting
        //
        hEvent = (HANDLE)((DWORD_PTR)hEvent | (DWORD_PTR)0x1);

        BOOL fSuccess = TlsSetValue(g_dwThreadEventIndex, hEvent);
        ASSERT(fSuccess);
		DBG_USED(fSuccess);
    }

    return hEvent;
}

void FreeThreadEvent(void)
{
    //
    //  If not TLS was allocated, the hEvent returned is 0
    //
    HANDLE hEvent = (HANDLE) TlsGetValue(g_dwThreadEventIndex);
    if(hEvent != 0)
    {
        CloseHandle(hEvent);
    }
}


void GetMachineQuotaCache(OUT DWORD* pdwQuota, OUT DWORD* pdwJournalQuota)
{
    DWORD dwType = REG_DWORD;
    DWORD dwSize = sizeof(DWORD);
    DWORD defaultValue = DEFAULT_QM_QUOTA;
    LONG rc;

    rc = GetFalconKeyValue(
            MSMQ_MACHINE_QUOTA_REGNAME,
            &dwType,
            pdwQuota,
            &dwSize,
            (LPCTSTR)&defaultValue
            );

    ASSERT(rc == ERROR_SUCCESS);

    defaultValue = DEFAULT_QM_JOURNAL_QUOTA;
    rc = GetFalconKeyValue(
            MSMQ_MACHINE_JOURNAL_QUOTA_REGNAME,
            &dwType,
            pdwJournalQuota,
            &dwSize,
            (LPCTSTR)&defaultValue
            );

    ASSERT(rc == ERROR_SUCCESS);
}

void SetMachineQuotaChace(IN DWORD dwQuota)
{
    DWORD dwType = REG_DWORD ;
    DWORD dwSize = sizeof(DWORD);
    LONG rc;

    rc = SetFalconKeyValue(MSMQ_MACHINE_QUOTA_REGNAME,
                           &dwType,
                           &dwQuota,
                           &dwSize);
    ASSERT(rc == ERROR_SUCCESS);
}

void SetMachineJournalQuotaChace(IN DWORD dwJournalQuota)
{
    DWORD dwType = REG_DWORD ;
    DWORD dwSize = sizeof(DWORD);
    LONG rc;

    rc = SetFalconKeyValue(MSMQ_MACHINE_JOURNAL_QUOTA_REGNAME,
                           &dwType,
                           &dwJournalQuota,
                           &dwSize);
    ASSERT(rc == ERROR_SUCCESS);

}



LPWSTR
GetReadableNextHop(
    const TA_ADDRESS* pta
    )
{
    LPCWSTR AddressType;
    switch(pta->AddressType)
    {
    case IP_ADDRESS_TYPE:
        AddressType = L"IP";
        break;

    case FOREIGN_ADDRESS_TYPE:
        AddressType =  L"FOREIGN";
        break;

    default:
        ASSERT(0);
        return NULL;
    }

    WCHAR TempBuf[100];
    TA2StringAddr(pta, TempBuf);

    LPCWSTR  lpcsTemp = wcschr(TempBuf,L' ');
    ASSERT(lpcsTemp != NULL);

    DWORD length;
    length = wcslen(AddressType) +
             1 +                             // =
             wcslen(lpcsTemp+1) +
             1;                              // \0

    LPWSTR pNextHop = new WCHAR[length];
    swprintf(pNextHop,L"%s=%s", AddressType, lpcsTemp+1);

    return pNextHop;
}

/*====================================================
operator== for QUEUE_FORMAT
=====================================================*/
BOOL operator==(const QUEUE_FORMAT &key1, const QUEUE_FORMAT &key2)
{
    if ((key1.GetType() != key2.GetType()) ||
        (key1.Suffix() != key2.Suffix()))
    {
        return FALSE;
    }

    switch(key1.GetType())
    {
        case QUEUE_FORMAT_TYPE_UNKNOWN:
            return TRUE;

        case QUEUE_FORMAT_TYPE_PUBLIC:
            return (key1.PublicID() == key2.PublicID());

        case QUEUE_FORMAT_TYPE_PRIVATE:
            return ((key1.PrivateID().Lineage == key2.PrivateID().Lineage) &&
                   (key1.PrivateID().Uniquifier == key2.PrivateID().Uniquifier));

        case QUEUE_FORMAT_TYPE_DIRECT:
            return (CompareStringsNoCase(key1.DirectID(), key2.DirectID()) == 0);

        case QUEUE_FORMAT_TYPE_MACHINE:
            return (key1.MachineID() == key2.MachineID());

        case QUEUE_FORMAT_TYPE_CONNECTOR:
            return (key1.ConnectorID() == key2.ConnectorID());

    }
    return FALSE;
}

/*====================================================
Helper function for copying QueueFormat with direct name reallocation
====================================================*/
void CopyQueueFormat(QUEUE_FORMAT &qfTo, const QUEUE_FORMAT &qfFrom)
{
    qfTo.DisposeString();
    qfTo = qfFrom;

    if (qfFrom.GetType() == QUEUE_FORMAT_TYPE_DIRECT)
    {
        LPWSTR pw = new WCHAR[(wcslen(qfFrom.DirectID()) + 1)];
        wcscpy(pw, qfFrom.DirectID());
        qfTo.DirectID(pw);
        //
        // BUGBUG: What about setting the suffix? See ac\acp.h (ShaiK, 18-May-2000)
        //
    }

    if (qfFrom.GetType() == QUEUE_FORMAT_TYPE_DL &&
        qfFrom.DlID().m_pwzDomain != NULL)
    {
        DL_ID id;
        id.m_DlGuid    = qfFrom.DlID().m_DlGuid;
        id.m_pwzDomain = new WCHAR[wcslen(qfFrom.DlID().m_pwzDomain) + 1];

        wcscpy(id.m_pwzDomain, qfFrom.DlID().m_pwzDomain);
        qfTo.DlID(id);
    }
}


/*====================================================
Helper function for printing out blobs (e.g. for tracing purposes)
====================================================*/
int StringFromBlob(unsigned char *blobAddress, DWORD cbAddress, LPWSTR str, DWORD len)
{
	static WCHAR digits[17]=L"0123456789ABCDEF";
	for (DWORD i=0, j=0; i<cbAddress && i<len/2-2; i++, j+=2)
	{
		unsigned char c = blobAddress[i];
		str[j]  =	digits[(c%0x0F)];
		str[j+1]=	digits[(c%0xF0)>>4];
		str[j+2]=	L'\0';
	}
	return j;
}


GUID s_EnterpriseId;
GUID s_SiteId;

void McInitialize()
{

    //
    // Read Enterprise ID from registry
    //
    DWORD dwSize = sizeof(GUID);
    DWORD dwType = REG_BINARY;

    LONG rc;
    rc = GetFalconKeyValue(
                MSMQ_ENTERPRISEID_REGNAME,
                &dwType,
                &s_EnterpriseId,
                &dwSize
                );

    if (rc != ERROR_SUCCESS)
    {
        throw exception();
    }

    ASSERT(dwSize == sizeof(GUID)) ;
    ASSERT(dwType == REG_BINARY) ;


    //
    // Read Site ID from registry
    //
    dwSize = sizeof(GUID);
    dwType = REG_BINARY;
    rc = GetFalconKeyValue(
                MSMQ_SITEID_REGNAME,
                &dwType,
                &s_SiteId,
                &dwSize
                );

    if (rc != ERROR_SUCCESS)
    {
        throw exception();
    }

    ASSERT(dwSize == sizeof(GUID)) ;
    ASSERT(dwType == REG_BINARY) ;
}


const GUID& McGetEnterpriseId()
{
    return s_EnterpriseId;
}


const GUID& McGetSiteId()
{
    return s_SiteId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qmthrd.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    qmthrd.cpp

Abstract:


Author:

    Uri Habusha (urih)

--*/
#include "stdh.h"
#include <mqexcept.h>

#include "cqmgr.h"
#include "qmthrd.h"
#include "ac.h"
#include "qmutil.h"
#include "session.h"
#include "xact.h"
#include "xactout.h"
#include "xactin.h"
#include "lms.h"
#include "localsend.h"
#include <Fn.h>

#include "qmthrd.tmh"

extern HANDLE g_hAc;
extern CCriticalSection g_csGroupMgr;

static WCHAR *s_FN=L"qmthrd";

// HANDLE to Io Completion Port
HANDLE g_hIoPort;

#ifdef _DEBUG

static void DBG_MSGTRACK(CQmPacket* pPkt, LPCWSTR msg)
{
    OBJECTID MessageId;
    pPkt->GetMessageId(&MessageId);
    DBGMSG((
        DBGMOD_MSGTRACK,
        DBGLVL_TRACE,
        TEXT("%ls: ID=") TEXT(LOG_GUID_FMT) TEXT("\\%u"),
        msg,
        LOG_GUID(&MessageId.Lineage),
        MessageId.Uniquifier));
}


static void DBG_CompletionKey(LPCWSTR Key, DWORD dwErrorCode)
{
    DWORD dwthreadId = GetCurrentThreadId();

    if(dwErrorCode == ERROR_SUCCESS)
    {
        DBGMSG((DBGMOD_QM, DBGLVL_INFO,
            _T("%x: GetQueuedCompletionPort for %ls. time=%d"),
            dwthreadId,  Key, GetTickCount()));
    }
    else
    {
        DBGMSG((DBGMOD_QM, DBGLVL_WARNING,
            _T("%x: GetQueuedCompletionPort for %ls FAILED, Error=%u. time=%d"),
            dwthreadId, Key, dwErrorCode, GetTickCount()));
    }
}

#else
#define DBG_MSGTRACK(pPkt, msg)             ((void)0)
#define DBG_CompletionKey(Key, dwErrorCode) ((void)0)
#endif



/*======================================================

Function:       QMAckPacket

Description:    This packet requires acking, it could
                be that the admin queue does NOT exists

NOTE:           The packet should be copied now and canot
                be overwriten

Return Value:   VOID

========================================================*/
STATIC
void
QMAckPacket(
    const CBaseHeader* pBase,
    CPacket* pDriverPacket,
    USHORT usClass,
    BOOL fUser,
    BOOL fOrder
    )
{
    ASSERT(fUser || fOrder);

    CQmPacket qmPacket(const_cast<CBaseHeader*>(pBase), pDriverPacket);

	//
	// BUGBUG: gilsh 28-Jun-2000, no order ack to http messages.
	// he condition !IsDirectHttpFormatName(&qdDestQueue) is added because we
	// don't support order acking http\https messages at the moment
	//
	QUEUE_FORMAT qdDestQueue;
	qmPacket.GetDestinationQueue(&qdDestQueue);
	if(fOrder && !FnIsDirectHttpFormatName(&qdDestQueue) )
    {
        OBJECTID MessageId;
        qmPacket.GetMessageId(&MessageId);
				
        SendXactAck(&MessageId,
                    qdDestQueue.GetType() == QUEUE_FORMAT_TYPE_DIRECT ,
				    qmPacket.GetSrcQMGuid(),
                    qmPacket.GetSrcQMAddress(),
					usClass,
                    qmPacket.GetPriority(),
                    qmPacket.GetSeqID(),
                    qmPacket.GetSeqN(),
                    qmPacket.GetPrevSeqN(),
                    &qdDestQueue);
    }

    // Send user ack, except the cases when .
    // the source QM produces them based on the SeqAck.
    if(fUser)
    {
        qmPacket.CreateAck(usClass);
    }

    HRESULT rc;
    rc = ACAckingCompleted(
            g_hAc,
            pDriverPacket
            );

    REPORT_ILLEGAL_STATUS(rc, L"QMAckPacket");
    LogHR(rc, s_FN, 111);
}

/*======================================================

Function:       QMTimeoutPacket

Description:    This packet timer has expired,
                it is an ordered packet

Return Value:   VOID

========================================================*/
STATIC
void
QMTimeoutPacket(
    const CBaseHeader* pBase,
    CPacket * pDriverPacket,
    BOOL fTimeToBeReceived
    )
{
    SeqPktTimedOut(const_cast<CBaseHeader *>(pBase), pDriverPacket, fTimeToBeReceived);
}

/*======================================================

Function:       QMUpdateMessageID

Description:

NOTE:

Return Value:   VOID

========================================================*/
STATIC void QMUpdateMessageID(ULONGLONG MessageId)
{
    ULONG MessageIdLow32 = static_cast<ULONG>(MessageId & 0xFFFFFFFF);

    DWORD dwType = REG_DWORD;
    DWORD dwSize = sizeof(DWORD);
    SetFalconKeyValue(
        MSMQ_MESSAGE_ID_LOW_32_REGNAME,
        &dwType,
        &MessageIdLow32,
        &dwSize
        );

    ULONG MessageIdHigh32 = static_cast<ULONG>(MessageId >> 32);

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    SetFalconKeyValue(
        MSMQ_MESSAGE_ID_HIGH_32_REGNAME,
        &dwType,
        &MessageIdHigh32,
        &dwSize
        );
}


/*======================================================

Function:       QMWriteEventLog

Description:

NOTE:

Return Value:   VOID

========================================================*/
STATIC void QMWriteEventLog(ACPoolType pt, BOOL fSuccess, ULONG ulFileCount)
{
    WCHAR wcsFileName[MAX_PATH];
    WCHAR wcsPathName[MAX_PATH];
    LPCWSTR regname = NULL;

    swprintf(wcsFileName, L"\\r%07x.mq", (ulFileCount & 0x0fffffff));

    switch(pt)
    {
        case ptReliable:
            wcsFileName[1] = L'r';
            regname = MSMQ_STORE_RELIABLE_PATH_REGNAME;
            break;

        case ptPersistent:
            wcsFileName[1] = L'p';
            regname = MSMQ_STORE_PERSISTENT_PATH_REGNAME;
            break;

        case ptJournal:
            wcsFileName[1] = L'j';
            regname = MSMQ_STORE_JOURNAL_PATH_REGNAME;
            break;

        case ptLastPool:
            wcsFileName[1] = L'l';
            regname = MSMQ_STORE_LOG_PATH_REGNAME;
            break;

        default:
            ASSERT(0);
    }

    if(!GetRegistryStoragePath(regname, wcsPathName, wcsFileName))
    {
        return;
    }


    REPORT_WITH_STRINGS_AND_CATEGORY((
        CATEGORY_KERNEL,
        (fSuccess ? AC_CREATE_MESSAGE_FILE_SUCCEDDED : AC_CREATE_MESSAGE_FILE_FAILED),
        1,
        wcsPathName));


}


/*======================================================

Function:        CreateAcServiceRequest

Description:     Create GetACServiceRequest from the AC

Arguments:       hDrv - HANDLE to AC driver

Return Value:    MQ_OK if the creation successeded, MQ_ERROR otherwise

Thread Context:

History Change:

========================================================*/
HRESULT CreateAcServiceRequest(HANDLE hDrv, QMOV_ACGetRequest* pAcRequestOv)
{

    ASSERT(hDrv != NULL);
    ASSERT(pAcRequestOv != NULL);

    HRESULT rc = ACGetServiceRequest(
                    hDrv,
                    &(pAcRequestOv->request),
                    &pAcRequestOv->qmov
                    );

    return LogHR(rc, s_FN, 10);
}

/*======================================================

Function:        CreateAcPutPacketRequest

Description:     Create put packet overlapped structure

Arguments:

Return Value:    MQ_OK if the creation successeded, MQ_ERROR otherwise

Thread Context:

History Change:

========================================================*/

HRESULT CreateAcPutPacketRequest(IN CTransportBase* pSession,
                                 IN DWORD_PTR dwPktStoreAckNo,
                                 OUT QMOV_ACPut** ppAcPutov
                                )
{
    //
    // Create an overlapped for AcPutPacket
    //
    *ppAcPutov = NULL;
    try
    {
        *ppAcPutov = new QMOV_ACPut();
    }
    catch(const bad_alloc&)
    {
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 20);
    }

    (*ppAcPutov)->pSession = pSession;
    (*ppAcPutov)->dwPktStoreAckNo = dwPktStoreAckNo;

    return MQ_OK;
}

/*======================================================

Function:        CreateAcPutOrderedPacketRequest

Description:     Create put ordered packet overlapped structure

Arguments:

Return Value:    MQ_OK if the creation successeded, MQ_ERROR otherwise

Thread Context:

History Change:

========================================================*/

HRESULT CreateAcPutOrderedPacketRequest(
                                 IN  CQmPacket      *pPkt,
                                 IN  HANDLE         hQueue,
                                 IN  CTransportBase *pSession,
                                 IN  DWORD_PTR       dwPktStoreAckNo,
                                 OUT QMOV_ACPutOrdered** ppAcPutov
                                )
{
    //
    // Create an overlapped for AcPutPacket
    //
    *ppAcPutov = NULL;
    try
    {
        *ppAcPutov = new QMOV_ACPutOrdered();
    }
    catch(const bad_alloc&)
    {
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 30);
    }

    (*ppAcPutov)->pSession = pSession;
    (*ppAcPutov)->dwPktStoreAckNo = dwPktStoreAckNo;
    (*ppAcPutov)->packetPtrs.pPacket = pPkt->GetPointerToPacket();
    (*ppAcPutov)->packetPtrs.pDriverPacket = pPkt->GetPointerToDriverPacket();
    (*ppAcPutov)->hQueue      = hQueue;

    return MQ_OK;
}

/*======================================================

Function: HRESULT CreateAcGetPacketRequest()

Description:

Arguments:
    IN BOOL  fAfterFailure- TRUE if we're called after completion port
        return with a failure. So we try again.

Return Value:

Thread Context:

History Change:

========================================================*/

HRESULT CreateAcGetPacketRequest(IN HANDLE           hGroup,
                                 IN QMOV_ACGetMsg*   pAcGetOv,
                                 IN CTransportBase*  pSession,
                                 IN BOOL             fAfterFailure
                                )
{
    ASSERT(pAcGetOv != NULL);

    pAcGetOv->hGroup = hGroup;
    pAcGetOv->pSession = pSession;

    if ((pAcGetOv->packetPtrs.pPacket == NULL) && !fAfterFailure)
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 40);
    }
    pAcGetOv->packetPtrs.pPacket = NULL;

    //
    // Create new GetPacket request from the group
    //
    HRESULT rc;
    rc = ACGetPacket(
            hGroup,
            pAcGetOv->packetPtrs,
            &pAcGetOv->qmov
            );

    if (FAILED(rc))
    {
        DBGMSG((DBGMOD_QM,
                DBGLVL_ERROR,
                _TEXT("Get Packet from a group failed, ntstatus %x"), rc));
    }  else {

        DBGMSG((DBGMOD_QM,
                DBGLVL_INFO,
                _TEXT("Succeeded to Create get packet request form group: %p"), hGroup));
    }

    return LogHR(rc, s_FN, 50);

}


VOID WINAPI GetServiceRequestFailed(EXOVERLAPPED* pov)
{
	//
	// Get request failed. Issue a new request
	//
    ASSERT(FAILED(pov->GetStatus()));

    DBG_CompletionKey(L"GetServiceRequestFailed", pov->GetStatus());
    LogHR(pov->GetStatus(), s_FN, 214);

    QMOV_ACGetRequest* pParam = CONTAINING_RECORD (pov, QMOV_ACGetRequest, qmov);

    HRESULT rc;
	
	rc = CreateAcServiceRequest(g_hAc, pParam);     //resume a new request
	LogHR(rc, s_FN, 100);
	REPORT_ILLEGAL_STATUS(rc, L"GetServiceRequestFailed");
}


VOID WINAPI GetServiceRequestSucceeded(EXOVERLAPPED* pov)
{
    QMOV_ACGetRequest* pParam;

    //
    // GetQueuedCompletionStatus Complete successfully but the
    // ACGetServiceRequest failed. This can happened only if the
    // the service request parameters are not correct, or the buffer
    // size is small.
    // This may also happen when service is shut down.
    //
    ASSERT(SUCCEEDED(pov->GetStatus()));
    DBG_CompletionKey(L"GetServiceRequestSucceeded", pov->GetStatus());
    LogHR(pov->GetStatus(), s_FN, 185);

    try
    {
        pParam = CONTAINING_RECORD (pov, QMOV_ACGetRequest, qmov);

        CACRequest* pRequest = &pParam->request;
        switch(pParam->request.rf)
        {
            case CACRequest::rfAck:
                QMAckPacket(
                    pRequest->Ack.pPacket,
                    pRequest->Ack.pDriverPacket,
                    (USHORT)pRequest->Ack.ulClass,
                    pRequest->Ack.fUser,
                    pRequest->Ack.fOrder
                    );
                break;

            case CACRequest::rfStorage:
                QMStorePacket(
                    pRequest->Storage.pPacket,
                    pRequest->Storage.pDriverPacket,
                    pRequest->Storage.pAllocator,
					pRequest->Storage.ulSize
                    );
                break;

            case CACRequest::rfCreatePacket:
                QMpCreatePacket(
                    pRequest->CreatePacket.pPacket,
                    pRequest->CreatePacket.pDriverPacket,
                    pRequest->CreatePacket.fProtocolSrmp
                    );
                break;

            case CACRequest::rfTimeout:
                QMTimeoutPacket(
                    pRequest->Timeout.pPacket,
                    pRequest->Timeout.pDriverPacket,
                    pRequest->Timeout.fTimeToBeReceived
                    );
                break;

            case CACRequest::rfMessageID:
                QMUpdateMessageID(
                    pRequest->MessageID.Value
                    );
                break;

            case CACRequest::rfEventLog:
                QMWriteEventLog(
                    pRequest->EventLog.pt,
                    pRequest->EventLog.fSuccess,
                    pRequest->EventLog.ulFileCount
                    );
                break;

            case CACRequest::rfRemoteRead:
                {
                   DBGMSG((DBGMOD_QM, DBGLVL_INFO,
                           _TEXT("QmMainThread: rfRemoteRead")));
                   ASSERT(pRequest->Remote.Context.cli_pQMQueue) ;
                   CRRQueue *pRRQueue;

				   //
				   // cli_pQMQueue2 is the real pointer to the queue, while
				   // cli_pQMQueue is  just a mapping.
				   //
                   ASSERT(pRequest->Remote.Context.cli_pQMQueue2) ;
                   pRRQueue = (CRRQueue *)pRequest->Remote.Context.cli_pQMQueue2;

                   pRRQueue->RemoteRead(pRequest);
                }
                break;

            case CACRequest::rfRemoteCloseQueue:
                {
                   DBGMSG((DBGMOD_QM, DBGLVL_INFO,
                           _TEXT("QmMainThread: rfRemoteCloseQueue")));
                   ASSERT(pRequest->Remote.Context.cli_pQMQueue) ;
                   CRRQueue *pRRQueue;

				   //
				   // cli_pQMQueue2 is the real pointer to the queue, while
				   // cli_pQMQueue is  just a mapping.
				   //
                   ASSERT(pRequest->Remote.Context.cli_pQMQueue2) ;
                   pRRQueue = (CRRQueue *) pRequest->Remote.Context.cli_pQMQueue2;

                   pRRQueue->RemoteCloseQueue(pRequest);
                }
                break;

            case CACRequest::rfRemoteCloseCursor:
                {
                   DBGMSG((DBGMOD_QM, DBGLVL_INFO,
                           _TEXT("QmMainThread: rfRemoteCloseCursor")));
                   ASSERT(pRequest->Remote.Context.cli_pQMQueue) ;
                   CRRQueue *pRRQueue;

				   //
				   // cli_pQMQueue2 is the real pointer to the queue, while
				   // cli_pQMQueue is  just a mapping.
				   //
                   ASSERT(pRequest->Remote.Context.cli_pQMQueue2) ;
                   pRRQueue = (CRRQueue *) pRequest->Remote.Context.cli_pQMQueue2;

                   pRRQueue->RemoteCloseCursor(pRequest);
                }
                break;

            case CACRequest::rfRemoteCancelRead:
                {
                   DBGMSG((DBGMOD_QM, DBGLVL_INFO,
                           _TEXT("QmMainThread: rfRemoteCancelRead")));
                   ASSERT(pRequest->Remote.Context.cli_pQMQueue) ;
                   CRRQueue *pRRQueue;

				   //
				   // cli_pQMQueue2 is the real pointer to the queue, while
				   // cli_pQMQueue is  just a mapping.
				   //
                   ASSERT(pRequest->Remote.Context.cli_pQMQueue2) ;
                   pRRQueue = (CRRQueue *) pRequest->Remote.Context.cli_pQMQueue2;

                   pRRQueue->RemoteCancelRead(pRequest);
                }
                break;

            case CACRequest::rfRemotePurgeQueue:
                {
                   DBGMSG((DBGMOD_QM, DBGLVL_INFO,
                           _TEXT("QmMainThread: rfRemotePurgeQueue")));
                   ASSERT(pRequest->Remote.Context.cli_pQMQueue) ;
                   CRRQueue *pRRQueue;

				   //
				   // cli_pQMQueue2 is the real pointer to the queue, while
				   // cli_pQMQueue is  just a mapping.
				   //
                   ASSERT(pRequest->Remote.Context.cli_pQMQueue2) ;
                   pRRQueue = (CRRQueue *) pRequest->Remote.Context.cli_pQMQueue2;

                   pRRQueue->RemotePurgeQueue(pRequest);
                }
                break;

            default:
              ASSERT(0);
        }
    }
    catch(const bad_alloc&)
    {
        //
        //  No resources; Continue the Service request.
        //
        LogIllegalPoint(s_FN, 61);
    }

    HRESULT rc;
    rc = CreateAcServiceRequest(g_hAc, pParam);     //resume a new request
    LogHR(rc, s_FN, 105);
    REPORT_ILLEGAL_STATUS(rc, L"GetServiceRequestSucceeded");
}


VOID WINAPI GetMsgFailed(EXOVERLAPPED* pov)
{
    ASSERT(FAILED(pov->GetStatus()));

    DBG_CompletionKey(L"GetMsgFailed", pov->GetStatus());
    LogHR(pov->GetStatus(), s_FN, 213);
    //
    //  The only case we know is cancled
    //
    ASSERT(pov->GetStatus() == STATUS_CANCELLED);

    //
    // Decrement Session Reference count on get message from the session group.
    // the refernce count is increment when create the session ghroup or after
    // session resume.
    //
    // SP4 - bug 2794 (SP4SS: Exception! Transport is closed during message send)
    // Decrement the refernce count only after handling of sending message
    // is completed
    //      Uri Habusha (urih), 17-6-98
    //
    QMOV_ACGetMsg* pParam = CONTAINING_RECORD (pov, QMOV_ACGetMsg, qmov);
    pParam->pSession->Release();
}


VOID WINAPI GetMsgSucceeded(EXOVERLAPPED* pov)
{
    ASSERT(SUCCEEDED(pov->GetStatus()));
    ASSERT( pov->GetStatus() != STATUS_PENDING);

    DBG_CompletionKey(L"GetMsgSucceeded", pov->GetStatus());
    LogHR(pov->GetStatus(), s_FN, 212);

    BOOL fGetNext = FALSE;
    QMOV_ACGetMsg* pParam = CONTAINING_RECORD (pov, QMOV_ACGetMsg, qmov);



    ASSERT(pParam->packetPtrs.pPacket != NULL);

    //
    // Create CQmPacket object
    //
    CQmPacket* pPkt  = NULL;
    try
    {
        pPkt = new CQmPacket(pParam->packetPtrs.pPacket, pParam->packetPtrs.pDriverPacket);
    }
    catch(const bad_alloc&)
    {
        //
        // No resource. Return the packet to queue
        //
        LogIllegalPoint(s_FN, 62);
        CQmPacket QmPkt(pParam->packetPtrs.pPacket, pParam->packetPtrs.pDriverPacket);

        BOOL fGetRealQ = QmpIsLocalMachine(QmPkt.GetSrcQMGuid()) ||
                         QmpIsLocalMachine(QmPkt.GetConnectorQM());

        QUEUE_FORMAT DestinationQueue;
        QmPkt.GetDestinationQueue(&DestinationQueue, !fGetRealQ);

		ASSERT(!FnIsDirectHttpFormatName(&DestinationQueue));
		
        CQueue* pQueue;
        BOOL fSuccess;
        fSuccess = QueueMgr.LookUpQueue(
									&DestinationQueue,
									&pQueue,
                                    false,
                                    true
									);
        ASSERT(fSuccess);

        HRESULT rc;
        rc = ACPutPacket(
                pQueue->GetQueueHandle(),
                pParam->packetPtrs.pDriverPacket
                );

        LogHR(rc, s_FN, 106);
        REPORT_ILLEGAL_STATUS(rc, L"GetMsgSucceeded");

        pQueue->Release();

        //
        // Decrement Session Reference count on get message from the session group.
        // the refernce count is increment when create the session ghroup or after
        // session resume.
        //
        // SP4 - bug 2794 (SP4SS: Exception! Transport is closed during message send)
        // Decrement the refernce count only after handling of sending message
        // is completed
        //      Uri Habusha (urih), 17-6-98
        //
        pParam->pSession->Release();

        return;
    }

    //
    // Check the packet sent to transacted foreign queue that was opened
    // offline. In such a case we don't know the connector QM during packet
    // generation. we need to update it now.
    //
    if (pPkt->ConnectorQMIncluded() &&
        (*(pPkt->GetConnectorQM()) == GUID_NULL))
    {
        QUEUE_FORMAT DestinationQueue;
        CQueue* pQueue = NULL;

        pPkt->GetDestinationQueue(&DestinationQueue);
        QueueMgr.LookUpQueue(&DestinationQueue, &pQueue, false, true);
		ASSERT(pQueue != NULL);

        R<CQueue> Ref = pQueue;

        if (pQueue->IsForeign() && pQueue->IsTransactionalQueue())
        {
            ASSERT((pQueue->GetConnectorQM() != NULL) &&
                   (*(pQueue->GetConnectorQM()) != GUID_NULL));

            pPkt->SetConnectorQM(pQueue->GetConnectorQM());

            BOOL fSuccess = FlushViewOfFile(
                                pPkt->GetConnectorQM(),
                                sizeof(GUID)
                                );
            ASSERT(fSuccess);
			DBG_USED(fSuccess);

        }
    }

    HRESULT rc;

    // Do we need exactly-once receiving processing?
    if (pPkt->IsOrdered() && QmpIsLocalMachine(pPkt->GetSrcQMGuid()))
    {
        //
        // Ordered packet on the source node
        // Packet came out of driver
        //

        CPacketInfo* pInfo = reinterpret_cast<CPacketInfo*>(pPkt->GetPointerToPacket()) - 1;


		BOOL fSend = g_OutSeqHash.PreSendProcess(pPkt, true) ||
                     pInfo->InConnectorQueue();


        if (fSend)
        {
            DBG_MSGTRACK(pPkt, _T("GetMessage (EOD)"));

            // Sending the packet really
            rc = pParam->pSession->Send(pPkt, &fGetNext);
        }
        else
        {
            // Not sending but keeping
            fGetNext = TRUE;
            // For ordered packet on the source node - inserting in ordering resend set

			g_OutSeqHash.PostSendProcess(pPkt);

        }
    }
    else
    {
        //
        //  Non-Ordered packet or this is not a source node
        //

        // Sending the packet really
        DBG_MSGTRACK(pPkt, _T("GetMessage"));
        rc = pParam->pSession->Send(pPkt, &fGetNext);
    }

    if (fGetNext)
    {
        //
        // create new GetPacket request from Session group
        //
        pParam->pSession->GetNextSendMessage();
    }

    //
    // Decrement Session Reference count on get message from the session group.
    // the refernce count is increment when create the session ghroup or after
    // session resume.
    //
    // SP4 - bug 2794 (SP4SS: Exception! Transport is closed during message send)
    // Decrement the refernce count only after handling of sending message
    // is completed
    //      Uri Habusha (urih), 17-6-98
    //
    pParam->pSession->Release();
}


static void RetryGettingNonactiveMessage(QMOV_ACGetMsg* pParam)
{
    HRESULT rc;
	
	do
	{
		//
		// Let's sleep a little (one second).
		// Otherwise, in low resources condition, we may enter an
		// endless loop of failures.
		//
		Sleep(1000) ;

		rc = CreateAcGetPacketRequest(
								pParam->hGroup,
                                pParam,
                                NULL,
                                TRUE /*fAfterFailure*/
								);
		LogHR(rc, s_FN, 116);

	} while (FAILED(rc));
}


VOID WINAPI GetNonactiveMessageFailed(EXOVERLAPPED* pov)
{
    ASSERT(FAILED(pov->GetStatus()));

    DBG_CompletionKey(L"GetNonactiveMessageFailed", pov->GetStatus());
    LogHR(pov->GetStatus(), s_FN, 211);

    //
    // create new GetPacket request from NonActive group
    //
    QMOV_ACGetMsg* pParam = CONTAINING_RECORD (pov, QMOV_ACGetMsg, qmov);
	RetryGettingNonactiveMessage(pParam);
}


VOID WINAPI GetNonactiveMessageSucceeded(EXOVERLAPPED* pov)
{
	ASSERT(SUCCEEDED(pov->GetStatus()));

    CQueue*  pQueue = NULL;
    HRESULT  rc = MQ_OK;
    QMOV_ACGetMsg* pParam = CONTAINING_RECORD (pov, QMOV_ACGetMsg, qmov);

    DBG_CompletionKey(L"GetNonactiveMessageSucceeded", pov->GetStatus());
    LogHR(pov->GetStatus(), s_FN, 210);

    try
    {
        CQmPacket QmPkt(pParam->packetPtrs.pPacket, pParam->packetPtrs.pDriverPacket);

        ASSERT(QmPkt.GetType() == FALCON_USER_PACKET);
        //
        // Get destination queue. Using for finding the CQueue object
        //

        QUEUE_FORMAT DestinationQueue;

        BOOL fGetRealQ = QmpIsLocalMachine(QmPkt.GetSrcQMGuid()) ||
                         QmpIsLocalMachine(QmPkt.GetConnectorQM());

        QmPkt.GetDestinationQueue(&DestinationQueue, !fGetRealQ);

		//
		// Translate the queue format name according to local mapping (qal.lib)
		//
		QUEUE_FORMAT_TRANSLATOR  RealDestinationQueue(&DestinationQueue);
  	
	
        BOOL fSuccess = QueueMgr.LookUpQueue(
										RealDestinationQueue.get(),
                                        &pQueue,
                                        false,
                                        true
										);

        R<CQueue> Ref = pQueue;

        if (!fSuccess)
        {
            //
            // the queue must be record in hash table since it must be opened
            // before sending. If the queue doesn't exist it is internal error.
            //
            DBGMSG((DBGMOD_ALL, DBGLVL_ERROR, _TEXT("qmthrd.cpp: Internal error, Get message for unopening queue")));
            ASSERT(0);
            rc = MQ_ERROR;
        }
        else
        {
            ASSERT(pQueue != NULL);
            //
            // Return the packet to the queue. It will call immediatly
            // since there is a pending request created for that new session.
            // Please note: The non active group GetPacket request should NOT
            // be applied prior to this call.
            //
            rc = ACPutPacket(
                    pQueue->GetQueueHandle(),
                    pParam->packetPtrs.pDriverPacket
                    );
            LogHR(rc, s_FN, 107);
            REPORT_ILLEGAL_STATUS(rc, L"GetNonactiveMessageSucceeded");

            //
            // When the queue is marked as "OnHold" or the machine is disconnected.
            // The QM move the queue from "NonActive" group to "Disconnected" group.
            // The Queue return to "NonActive" group either when the Queue resumes
            // or the machine is reconnected to the network
            //
            if (QueueMgr.IsOnHoldQueue(pQueue))
            {
                QueueMgr.MoveQueueToOnHoldGroup(pQueue);
            }
            else
            {
                //
                // Create connection
                //
                if (pQueue->IsDirectHttpQueue())
                {
                    pQueue->CreateHttpConnection();
                }
                else if(RealDestinationQueue.get()->GetType() == QUEUE_FORMAT_TYPE_MULTICAST)
                {
                    pQueue->CreateMulticastConnection(RealDestinationQueue.get()->MulticastID());
                }
                else
                {
                    pQueue->CreateConnection();
                }
            }
        }
    }
    catch(const exception&)
    {
        //
        //  No resources; get next packet from non active group.
        //
        LogIllegalPoint(s_FN, 63);
    }

    //
    // create new GetPacket request from NonActive group
    //
    rc = CreateAcGetPacketRequest(pParam->hGroup,
                                  pParam,
                                  NULL,
                                  FALSE /*fAfterFailure*/);

	if (FAILED(rc))
	{
		LogHR(rc, s_FN, 108);
		RetryGettingNonactiveMessage(pParam);
	}
}

//+---------------------------------------------
//
//  VOID STATIC  _GetAnotherInternalMsg()
//
//+---------------------------------------------

STATIC
HRESULT
_GetAnotherInternalMsg(
    EXOVERLAPPED* pov,
    QMOV_ACGetInternalMsg* pParam
    )
{
    //
    // Wait to incoming packet
    //
    HRESULT rc = ACGetPacket(
                    pParam->hQueue,
                    pParam->packetPtrs,
                    pov
                    );

    REPORT_ILLEGAL_STATUS(rc, L"QmMainThread");
    LogHR( rc, s_FN, 110);

    DBGMSG((DBGMOD_QM,
            DBGLVL_INFO,
            _TEXT("Succeeded to Create get packet request form internal queue %p"),
            pParam->hQueue));
	
	return rc;
}


VOID WINAPI GetInternalMessageFailed(EXOVERLAPPED* pov)
{
	ASSERT(FAILED(pov->GetStatus()));

    DBG_CompletionKey(L"GetInternalMessageFailed", pov->GetStatus());
    LogHR(pov->GetStatus(), s_FN, 215);

    QMOV_ACGetInternalMsg* pParam = CONTAINING_RECORD (pov, QMOV_ACGetInternalMsg, qmov);

	HRESULT rc;

	do
	{
		//
		// Let's sleep a little (one second).
		// Otherwise, in low resources condition, we may enter an
		// endless loop of failures.
		//
		Sleep(1000) ;

		rc = _GetAnotherInternalMsg(pov, pParam);

	}while (FAILED(rc));
}


VOID WINAPI GetInternalMessageSucceeded(EXOVERLAPPED* pov)
{
	ASSERT(SUCCEEDED(pov->GetStatus()));

    DBG_CompletionKey(L"AcGetInternalMsg", pov->GetStatus());
    LogHR(pov->GetStatus(), s_FN, 186);

    QMOV_ACGetInternalMsg* pParam = CONTAINING_RECORD (pov, QMOV_ACGetInternalMsg, qmov);
    ASSERT(pParam->lpCallbackReceiveRoutine != NULL);

    CQmPacket packet(pParam->packetPtrs.pPacket, pParam->packetPtrs.pDriverPacket);
    CMessageProperty mp(&packet);

    QUEUE_FORMAT qfResponseQ;

    //
    // Internal message should not have response MQF.
    //
    ASSERT(packet.GetNumOfResponseMqfElements() == 0);
    packet.GetResponseQueue(&qfResponseQ);

    BOOL fReceiveNext = TRUE;
    try
    {
        fReceiveNext = pParam->lpCallbackReceiveRoutine(&mp, &qfResponseQ);
    }
    catch(const bad_alloc&)
    {
        //
        //  No resources; nevertheless get next packet
        //
        LogIllegalPoint(s_FN, 66);
    }

    HRESULT rc = ACFreePacket(g_hAc, pParam->packetPtrs.pDriverPacket);

    //
    // BUGBUG:: Illegal case should be handled
    //
    REPORT_ILLEGAL_STATUS(rc, L"QmMainThread");
    LogHR(rc, s_FN, 109);

    if (fReceiveNext)
    {
        //
        // Wait to incoming packet
        //
        rc = _GetAnotherInternalMsg(pov, pParam);
		if (FAILED(rc))
		{
			pov->SetStatus(rc);
			GetInternalMessageFailed(pov);
		}
    }
    else
    {
        delete pov;
    }
}


VOID WINAPI PutPacketFailed(EXOVERLAPPED* pov)
{
	ASSERT(FAILED(pov->GetStatus()));
    DBG_CompletionKey(L"PutPacketFailed", pov->GetStatus());
    LogHR(pov->GetStatus(), s_FN, 218);

    P<QMOV_ACPut> pParam = CONTAINING_RECORD (pov, QMOV_ACPut, qmov);
    ASSERT(pParam->pSession != NULL);

	//
	// Close the connection. Seesion acknowledgemnt will not sent and the message
	// will resent
	//
    Close_Connection(pParam->pSession, L"Put packet to the driver failed");
    (pParam->pSession)->Release();
}


VOID WINAPI PutPacketSucceeded(EXOVERLAPPED* pov)
{
    ASSERT(SUCCEEDED(pov->GetStatus()));
    DBG_CompletionKey(L"PutPacketSucceeded", pov->GetStatus());
    LogHR(pov->GetStatus(), s_FN, 184);

    P<QMOV_ACPut> pParam = CONTAINING_RECORD (pov, QMOV_ACPut, qmov);
    ASSERT(pParam->pSession != NULL);

    //
    // inform the session to Send stored ack
    //
    if (pParam->dwPktStoreAckNo != 0)
    {
        (pParam->pSession)->SetStoredAck(pParam->dwPktStoreAckNo);
    }

    //
    // Decrement Session refernce count
    //
    (pParam->pSession)->Release();
}


VOID WINAPI PutOrderedPacketFailed(EXOVERLAPPED* pov)
{
	ASSERT(FAILED(pov->GetStatus()));
    DBG_CompletionKey(L"PutPacketFailed", pov->GetStatus());
    LogHR(pov->GetStatus(), s_FN, 219);

    P<QMOV_ACPutOrdered> pParam = CONTAINING_RECORD (pov, QMOV_ACPutOrdered, qmov);
    ASSERT(pParam->pSession != NULL);

	//
	// Close the connection. Seesion acknowledgemnt will not sent and the message
	// will resent
	//
    Close_Connection(pParam->pSession, L"Put packet to the driver failed");
    (pParam->pSession)->Release();
}


/*======================================================

Function:   PutOrderedPacketSucceeded

Description:  Is called via completion port when the newwly-arrived
                ordered packet is stored with a Received flag.
              Initiates registering it in InSeqHash and waits till
                flush will pass
Arguments:

Return Value:

Thread Context:

History Change:

========================================================*/
VOID WINAPI PutOrderedPacketSucceeded(EXOVERLAPPED* pov)
{
    ASSERT(SUCCEEDED(pov->GetStatus()));

    QMOV_ACPutOrdered* pParam = CONTAINING_RECORD (pov, QMOV_ACPutOrdered, qmov);
    DBG_CompletionKey(L"PutOrderedPacketSucceeded", pov->GetStatus());

    ASSERT(pParam->pSession != NULL);
    LogHR(pov->GetStatus(), s_FN, 183);

    // Normal treatment (as in HandlePutPacket)
    if (pParam->dwPktStoreAckNo != 0)
    {
        (pParam->pSession)->SetStoredAck(pParam->dwPktStoreAckNo);
    }
    //
    // Decrement Session refernce count
    //
    (pParam->pSession)->Release();

    // We know the packet is stored. Registering the packet in InSeq database
    // After InSeqHash will be flushed, notification function InSeqFlushed will be called.
    ASSERT(g_pInSeqHash);
    CQmPacket Pkt(pParam->packetPtrs.pPacket, pParam->packetPtrs.pDriverPacket);
    HRESULT hr = g_pInSeqHash->Register(&Pkt, pParam->hQueue);
	UNREFERENCED_PARAMETER(hr);
    delete pov;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qmthrd.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    qmthrd.h

Abstract:



Author:

    Uri Habusha (urih)

--*/
#ifndef __QMTHRD_H__
#define __QMTHRD_H__


#include <Ex.h>
#include "Qmp.h"
#include "ac.h"

class CTransportBase;
struct CDebugSection;
struct CSessionSection;


VOID WINAPI PutPacketFailed(EXOVERLAPPED* pov);
VOID WINAPI PutPacketSucceeded(EXOVERLAPPED* pov);

VOID WINAPI PutOrderedPacketFailed(EXOVERLAPPED* pov);
VOID WINAPI PutOrderedPacketSucceeded(EXOVERLAPPED* pov);

VOID WINAPI GetInternalMessageSucceeded(EXOVERLAPPED* pov);
VOID WINAPI GetInternalMessageFailed(EXOVERLAPPED* pov);

VOID WINAPI GetMsgSucceeded(EXOVERLAPPED* pov);
VOID WINAPI GetMsgFailed(EXOVERLAPPED* pov);

VOID WINAPI GetNonactiveMessageSucceeded(EXOVERLAPPED* pov);
VOID WINAPI GetNonactiveMessageFailed(EXOVERLAPPED* pov);

VOID WINAPI GetServiceRequestSucceeded(EXOVERLAPPED* pov);
VOID WINAPI GetServiceRequestFailed(EXOVERLAPPED* pov);



//
// QMOV_ACGetRequest
//
struct QMOV_ACGetRequest 
{
    EXOVERLAPPED qmov;
    CACRequest request;

    QMOV_ACGetRequest() :
        qmov(GetServiceRequestSucceeded, GetServiceRequestFailed),
        request(CACRequest::rfAck)
    {
    }

};

//
//   QMOV_ACGetMsg
//
struct QMOV_ACGetMsg
{
    EXOVERLAPPED    qmov;
    HANDLE          hGroup;            // handle to the group from which the packet is gotten
    CTransportBase* pSession;          // Pointer to session object
    CACPacketPtrs   packetPtrs;   // packet pointers

    QMOV_ACGetMsg(
		EXOVERLAPPED::COMPLETION_ROUTINE pSuccess,
        EXOVERLAPPED::COMPLETION_ROUTINE pFailure
        ) :
        qmov(pSuccess, pFailure)
    {
        packetPtrs.pPacket = (CBaseHeader *)((LONG_PTR)-1);
    }
};

//
//  QMOV_ACGetInternalMsg
//
struct QMOV_ACGetInternalMsg
{
    EXOVERLAPPED   qmov;
    HANDLE         hQueue;             // Handle to the queue
    CACPacketPtrs  packetPtrs;   // pointers to packet
    LPRECEIVE_COMPLETION_ROUTINE  lpCallbackReceiveRoutine;

    QMOV_ACGetInternalMsg() :
        qmov(GetInternalMessageSucceeded, GetInternalMessageFailed)
    {
    }
};


//
// QMOV_ACPut
//
struct QMOV_ACPut
{
    EXOVERLAPPED   qmov;
    CTransportBase* pSession;          // pointer to session. Used for sending storage ACK
    DWORD_PTR      dwPktStoreAckNo;    // storage Ack No.

    QMOV_ACPut() :
        qmov(PutPacketSucceeded, PutPacketFailed)
    {
    }
};

//
// QMOV_ACPutOrdered
//
struct QMOV_ACPutOrdered 
{
    EXOVERLAPPED   qmov;
    CTransportBase* pSession;          // pointer to session. Used for sending storage ACK
    DWORD_PTR      dwPktStoreAckNo;    // storage Ack No.
	HANDLE          hQueue;
    CACPacketPtrs   packetPtrs;   // packet pointers

    QMOV_ACPutOrdered() :
        qmov(PutOrderedPacketSucceeded, PutOrderedPacketFailed)
    {
    }
};


//
// Function decleration
//
HRESULT
CreateAcServiceRequest(
    HANDLE hDrv,
    QMOV_ACGetRequest* lpQmOverLapped
    );


HRESULT
CreateAcGetPacketRequest(
    IN HANDLE          GroupHandle,
    IN QMOV_ACGetMsg*  lpQmOverlapped,
    IN CTransportBase* pSession,
    IN BOOL            fAfterFailure
    );


HRESULT
CreateAcPutPacketRequest(
    IN CTransportBase* pSession,
    IN DWORD_PTR dwPktStoreAckNo,
    OUT QMOV_ACPut** ppov
    );


HRESULT
CreateAcPutOrderedPacketRequest(
    IN  CQmPacket *pPkt,
    IN  HANDLE  hQueue,
    IN  CTransportBase  *pSession,
    IN  DWORD_PTR dwPktStoreAckNo,
    OUT QMOV_ACPutOrdered** ppAcPutov
    );

#endif //  __QMTHRD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qmutil.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    qmutil.h

Abstract:

    QM utilities interface

Author:

    Uri Habusha (urih)

--*/

#ifndef __QM_QMUTIL__
#define __QM_QMUTIL__

#include "qformat.h"

#define REPORT_ILLEGAL_STATUS(rc, FunctionName)                                 \
    {                                                                           \
        if (FAILED(rc))                                                         \
        {                                                                       \
            REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL,                  \
                                              MSMQ_INTERNAL_ERROR,              \
                                              1,                                \
                                              FunctionName));                   \
        }                                                                       \
    }

typedef struct  _QUEUEID {    // size is 20
    GUID* pguidQueue;         // Queue Guid.
    DWORD dwPrivateQueueId;   // Private Queue Id
} QUEUE_ID, *PQUEUE_ID;

class CAddressList : public CList<TA_ADDRESS*, TA_ADDRESS*&> {/**/};

extern BOOL IsPathnameForLocalMachine(LPCWSTR PathName, BOOL* pfDNSName);

extern BOOL IsLocalDirectQueue(const QUEUE_FORMAT* pQueueFormat, bool fInReceive);

extern CAddressList* GetIPAddresses(void);
extern void GetMachineIPAddresses(IN const char * szHostName,
                                  OUT CAddressList* plIPAddresses);


extern BOOLEAN IsDSAddressExist(const CAddressList* AddressList,
                                TA_ADDRESS*     ptr,
                                DWORD AddressLen);
extern BOOL IsDSAddressExistRemove(IN const TA_ADDRESS*     ptr,
                                   IN DWORD AddressLen,
                                   IN OUT CAddressList* AddressList);
extern BOOL IsTAAddressExistRemove(IN const TA_ADDRESS*     ptr,
                                   IN OUT CAddressList* AddressList);
extern BOOL IsUnknownIPAddress(IN const TA_ADDRESS* ptr);
extern void SetAsUnknownIPAddress(IN OUT TA_ADDRESS * ptr);

extern HRESULT IsValidDirectPathName(LPCWSTR lpwcsDirectQueue);

extern BOOL AFXAPI  CompareElements(IN const QUEUE_ID** pQueue1,
                                    IN const QUEUE_ID** pQueue2);
extern void AFXAPI DestructElements(IN const QUEUE_ID** ppNextHop, int n);
extern UINT AFXAPI HashKey(IN const QUEUE_ID * key);

extern void String2TA(IN LPCTSTR psz, OUT TA_ADDRESS * * ppa);
extern void TA2StringAddr(IN const TA_ADDRESS *pa, OUT LPTSTR pString);
extern BOOL GetRegistryStoragePath(PCWSTR pKey, PWSTR pPath, PCWSTR pSuffix);

extern void GetMachineQuotaCache(OUT DWORD*, OUT DWORD*);
extern void SetMachineQuotaChace(IN DWORD);
extern void SetMachineJournalQuotaChace(IN DWORD);

void AllocateThreadTLSs(void);

HANDLE GetThreadEvent(void);
void   FreeThreadEvent(void);

HANDLE GetHandleForRpcCancel(void) ;
void   FreeHandleForRpcCancel(void) ;

#define OS_SERVER(os)	(os == MSMQ_OS_NTS || os == MSMQ_OS_NTE)

LPWSTR
GetReadableNextHop(
    const TA_ADDRESS* pAddr
    );


// Auxiliary functions for hashing
extern void CopyQueueFormat(QUEUE_FORMAT &qfTo,  const QUEUE_FORMAT &qfFrom);
extern BOOL operator==(const QUEUE_FORMAT &key1, const QUEUE_FORMAT &key2);

extern void  GetDnsNameOfLocalMachine(
    WCHAR ** ppwcsDnsName
	);

extern int StringFromBlob(unsigned char *blobAddress, DWORD cbAddress, LPWSTR str, DWORD len);

void McInitialize();
const GUID& McGetEnterpriseId();
const GUID& McGetSiteId();

LPCWSTR GetHTTPQueueName(LPCWSTR URL);

#endif //__QM_QMUTIL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qmwarning.h ===
#include <warning.h>

// There is a MIDL bug #91337 that generates warnings in qm2qm_s.c.
// Until it is solved we need to ignore warning 4090 (Win64) and
// warning 4047 (Win32).
// This is done using local warning file that is included in every
// compiled .c file.   erezh 3-May-2000
#ifndef __cplusplus
    #ifdef _WIN64
        #pragma warning(disable:4090)
    #else
        #pragma warning(disable:4047)
    #endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\qos.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    QoS.cpp

Abstract:
    Support for QoS implementation for SIA

Author:
    Yoel Arnon (YoelA) 8-Nov-2000

--*/
#include "stdh.h"
#include <qossp.h>
#include <qospol.h>
#include "qmp.h"
#include "sessmgr.h"

#include "QoS.tmh"

static WCHAR *s_FN=L"QoS";


/*======================================================
Function:         FindQoSProtocol

Description:      Looks for a protocol in this computer 
                  that supports QoS
========================================================*/
LPWSAPROTOCOL_INFO FindQoSProtocol(OUT UCHAR **pucBufferToFree)
{
//
// ISSUE-2000/10/22-YoelA:
//      This function is called each time a QoS socket is created. This approach is 
//      not optimized, and may cause a performance problem in case QM needs to contact with
//      a large number of direct queues on different computers. The right way to handle the protocol
//      list is by keeping a protocols cache, and update it using a callback routine. This callback
//      can be registered using WSAProviderConfigChange API.
//      For now, only SIA uses QoS, so unless they complain about performance, we can probably leave this
//      as is.
//

    *pucBufferToFree = 0;

    INT    Protocols[2];

    Protocols[0] = IPPROTO_TCP;
    Protocols[1] = 0;
    DWORD dwSize = 0;

    //
    // First call - get buffer size
    //
	int iStatus = WSAEnumProtocols(	Protocols,
		    					    0,
			                        &dwSize  );
    if (iStatus != SOCKET_ERROR)
    {
        //
        // The only legitimate reason for NOT returning an error
        // here is that there are no protocols, and therefore 
        // iStatus is 0
        //
        if (iStatus != 0)
        {
            ASSERT(0);
            DBGMSG((DBGMOD_NETSESSION, DBGLVL_ERROR,
                TEXT("FindQoSProtocol - WSAEnumProtocols returned %d, but did not fill the buffer"),
                iStatus));
            LogHR(MQ_ERROR,  s_FN, 10);       
        }

        return 0;
    }

    DWORD dwErrorCode = WSAGetLastError();
    if (dwErrorCode != WSAENOBUFS)
    {
        //
        // Some undefined error happend. Return
        //
        DBGMSG((DBGMOD_NETSESSION, DBGLVL_ERROR,
            TEXT("FindQoSProtocol - WSAEnumProtocols Failed. Error %d"),
            dwErrorCode));
        LogNTStatus(dwErrorCode,  s_FN, 20);
        ASSERT(0);
        return 0;
    }

    //
    // Allocate the right buffer and continue
    //
    AP<UCHAR>  pProtocolInfoBuf = new UCHAR[dwSize];

    //
    // Call to get the protocols
    //
	iStatus = WSAEnumProtocols(	Protocols,
		    					(LPWSAPROTOCOL_INFO)(UCHAR *)pProtocolInfoBuf,
			                    &dwSize  );

    if (iStatus == SOCKET_ERROR)
    {
        //
        // We should not fail here...
        //
        dwErrorCode = WSAGetLastError();
        DBGMSG((DBGMOD_NETSESSION, DBGLVL_ERROR,
            TEXT("FindQoSProtocol - WSAEnumProtocols Failed. Error %d"),
            dwErrorCode));
        LogNTStatus(dwErrorCode,  s_FN, 30);
        ASSERT(0);
        return 0;
    }

    //
    // If iStatus is not SOCKET_ERROR, it will contain the number of protocols
    // returned. For readability, we will put it in another variavble named
    // dwNumProtocols
    //
    DWORD dwNumProtocols = iStatus;

    LPWSAPROTOCOL_INFO  pProtoInfo = (LPWSAPROTOCOL_INFO)(UCHAR *)pProtocolInfoBuf;

    DWORD iProtocols;
    for (iProtocols = 0; iProtocols < dwNumProtocols; iProtocols++)
    {
        if (pProtoInfo[iProtocols].dwServiceFlags1 & XP1_QOS_SUPPORTED)
        {
            *pucBufferToFree = pProtocolInfoBuf.detach();
            return &pProtoInfo[iProtocols];
        }
    }

    //
    // No QoS supporting protocol found. .
    //
    DBGMSG((DBGMOD_NETSESSION, DBGLVL_INFO,
        TEXT("FindQoSProtocol - No QoS supported protocol found.")
        ));
    LogHR(MQ_ERROR,  s_FN, 40);

    return 0;

}

/*======================================================
Function:         QmpCreateSocket

Description:      Creates a socket (using WSASocket).
                  if Using QoS:
                  Attempts to find a protocol with QoS support, and use it if possible.
                  Otherwise, creates a regular socket.
                  Returns INVALID_SOCKET if fails

========================================================*/
SOCKET QmpCreateSocket(bool fQoS)
{
    SOCKET sReturnedSocket;

    LPWSAPROTOCOL_INFO pProtoInfo = 0;
    AP<UCHAR> pucProtocolsBufferToFree;

    if (fQoS)
    {
        PUCHAR pTempBufferToFree;
        pProtoInfo = FindQoSProtocol(&pTempBufferToFree);
        pucProtocolsBufferToFree = pTempBufferToFree;
    }

    sReturnedSocket = WSASocket( AF_INET,
                        SOCK_STREAM,
                        0,
                        pProtoInfo,
                        0,
                        WSA_FLAG_OVERLAPPED ) ;

    if(sReturnedSocket == INVALID_SOCKET)
    {
        DWORD gle = WSAGetLastError();
        DBGMSG((DBGMOD_NETSESSION, DBGLVL_ERROR,
                TEXT("QmpCreateSocket - Cant create a socket")));
        LogNTStatus(gle,  s_FN, 100);
    }

    return sReturnedSocket;
}


//
// The following two functions (BuildPsBuf, ConstructAppIdPe) contruct 
// the provider specific buffer of QoS.
// They were copied from Ramesh Pabbati's mail, with some modifications.
// (YoelA - 12-Oct-2000)
//
const USHORT x_usPolicyInfoHeaderSize = sizeof(RSVP_POLICY_INFO) - sizeof(RSVP_POLICY);
/*======================================================
Function:         ConstructAppIdPe

Description:      
========================================================*/
USHORT 
ConstructAppIdPe(
    LPCSTR               szAppName, 
    LPCSTR               szPolicyLocator,
    ULONG               *pulAppIdPeBufLen,
    LPRSVP_POLICY_INFO  pPolicyInfo)
/*+++
 *  Description:
 *      This routine generates the application identity PE give the name
 *      and policy locator strings for the application. 
 *      	
 *      The first argument szAppName is used to construct the CREDENTIAL 
 *      attribute of the Identity PE. The subtype is set to ASCII_ID.
 *      The second argument szPolicyLocator is used to construct the
 *      POLICY_LOCATOR attribute of the Identity PE. They subtype is
 *      set to ASCII_DN.
 *
 *      For details on the Identity Policy Elements,
 *      refer to rfc2752 (http://www.ietf.org/rfc/rfc2752.txt)
 *      	
 *      For details on the App Id,
 *      refer to rfc2872 (http://www.ietf.org/rfc/rfc2872.txt)
 *      	
 *      For Microsoft implementation and the original sample, refer to
 *      http://wwd/windows/server/Technical/networking/enablingQOS.asp
 *
 *      The PE is generated in the supplied buffer. If the length of
 *      the buffer is not enough required length is returned.
 *      	
 *  Parameters:  szAppName          app name, string, caller supply
 *               szPolicyLocator    Policy Locator string, caller supply
 *               pulAppIdPeBufLen   length of caller allocated buffer
 *               pPolicyInfo        pointer to caller allocated buffer
 *      		 
 *  Return Values:
 *       0 : Fail, pulAppIdPeBufLen will hold number of bytes needed
 *      >0 : Length of the application indetity PE
--*/
{
    if ( !szAppName ||  !szPolicyLocator )
        return 0;

    USHORT usPolicyLocatorAttrLen = numeric_cast<USHORT>(IDPE_ATTR_HDR_LEN + strlen(szPolicyLocator));
    USHORT usAppIdAttrLen         = numeric_cast<USHORT>(IDPE_ATTR_HDR_LEN + strlen(szAppName));
    
    // Calculcate the length of the buffer required
    USHORT usTotalPaddedLen = RSVP_POLICY_HDR_LEN + 
                              RSVP_BYTE_MULTIPLE(usAppIdAttrLen) +
                              RSVP_BYTE_MULTIPLE(usPolicyLocatorAttrLen);
	       
    // If the supplied buffer is not long enough, return error and the
    // required buffer length
    if (*pulAppIdPeBufLen < usTotalPaddedLen) {
            *pulAppIdPeBufLen = usTotalPaddedLen;
        return 0;
    }

    ASSERT(pPolicyInfo != 0);

	RSVP_POLICY *pAppIdPe = (RSVP_POLICY *)pPolicyInfo->PolicyElement;
    memset(pAppIdPe, 0, usTotalPaddedLen);

    pPolicyInfo->NumPolicyElement = 1;
    pPolicyInfo->ObjectHdr.ObjectType = RSVP_OBJECT_POLICY_INFO;
    pPolicyInfo->ObjectHdr.ObjectLength = x_usPolicyInfoHeaderSize;    
    
    
    // Set up RSVP_POLICY header
    pAppIdPe->Len  = usTotalPaddedLen;
    pAppIdPe->Type = PE_TYPE_APPID;
    
    // Application ID Policy Element (PE) attributes follow the PE header
    
    IDPE_ATTR   *pRsvp_pe_app_attr = (IDPE_ATTR *)((char*)pAppIdPe + RSVP_POLICY_HDR_LEN);

    // Construct the POLICY_LOCATOR attribute with simple ASCII_DN 
    //  subtype using the supplied Policy Locator.  Since the RSVP service 
    //  does not look into the attributes, set the attribute length in 
    //  network order.
    pRsvp_pe_app_attr->PeAttribLength  = htons(usPolicyLocatorAttrLen);
    pRsvp_pe_app_attr->PeAttribType    = PE_ATTRIB_TYPE_POLICY_LOCATOR;
    pRsvp_pe_app_attr->PeAttribSubType = POLICY_LOCATOR_SUB_TYPE_ASCII_DN;
    strcpy((char *)pRsvp_pe_app_attr->PeAttribValue, szPolicyLocator);
    
    // Advance pRsvp_pe_app_attr 
    pRsvp_pe_app_attr = (IDPE_ATTR *)
	   ((char*)pAppIdPe + 
           RSVP_POLICY_HDR_LEN + 
	   RSVP_BYTE_MULTIPLE(usPolicyLocatorAttrLen));
		   
    // Construct the CREDENTIALS attribute with simple ASCII_ID subtype 
    //  using the supplied Application name.  Since the RSVP service does 
    //  not look into the attributes, set the attribute length in 
    //  network order.
    pRsvp_pe_app_attr->PeAttribLength   = htons(usAppIdAttrLen);
    pRsvp_pe_app_attr->PeAttribType     = PE_ATTRIB_TYPE_CREDENTIAL;
    pRsvp_pe_app_attr->PeAttribSubType  = CREDENTIAL_SUB_TYPE_ASCII_ID;
    strcpy((char *)pRsvp_pe_app_attr->PeAttribValue, szAppName);

    pPolicyInfo->ObjectHdr.ObjectLength += usTotalPaddedLen;

    return usTotalPaddedLen;
}


/*======================================================
Function:         BuildPsBuf

Description:      Build the provider specific MSMQ buffer
========================================================*/
bool
BuildPsBuf(
    IN      char    *buf, 
    IN OUT  ULONG  *pulRsvp_buf_len,
    LPCSTR  pszMsmqAppName,
    LPCSTR  pszMsmqPolicyLocator
    )
{
    ASSERT(pszMsmqAppName != 0);
    ASSERT(pszMsmqPolicyLocator != 0);

    const USHORT x_usReserveInfoHeaderSize = sizeof(RSVP_RESERVE_INFO);
    const USHORT x_usHeaderSize = x_usReserveInfoHeaderSize + x_usPolicyInfoHeaderSize;

    LPRSVP_POLICY_INFO   pPolicyInfo = 0;
    LPRSVP_RESERVE_INFO	 rsvp_reserve_info = 0;

    ULONG ulAppIdPeBufLen = 0;
    if (*pulRsvp_buf_len > x_usHeaderSize)
    {
	    rsvp_reserve_info = (LPRSVP_RESERVE_INFO)buf;
        //
        // Fill the header if there is enough space. Otherwise, continue, leave ulAppIdPeBufLen
        // as 0 and just return the size needed.
        //
        // Init RSVP_RESERVE_INFO with appropriate values
        rsvp_reserve_info->Style = RSVP_FIXED_FILTER_STYLE;
        rsvp_reserve_info->ConfirmRequest = 0;
        rsvp_reserve_info->NumFlowDesc = 0;
        rsvp_reserve_info->FlowDescList = NULL;
        pPolicyInfo = (LPRSVP_POLICY_INFO)(buf+x_usReserveInfoHeaderSize);
        rsvp_reserve_info->PolicyElementList = pPolicyInfo;
 
        // Construct the policy element that holds app id 
        //   and policy locator attributes (as per RFC 2750)
        ulAppIdPeBufLen = *pulRsvp_buf_len - x_usHeaderSize;
    }

    if (0 ==
        ConstructAppIdPe( 
            pszMsmqAppName,  
            pszMsmqPolicyLocator,
            &ulAppIdPeBufLen, 
            pPolicyInfo))
    {
        *pulRsvp_buf_len = ulAppIdPeBufLen + x_usHeaderSize;
        return false;
    }

    ASSERT(rsvp_reserve_info != 0);

	// Set the type and length of the RSVP_RESERVE_INFO finally
    rsvp_reserve_info->ObjectHdr.ObjectLength = 
	    sizeof(RSVP_RESERVE_INFO) + rsvp_reserve_info->PolicyElementList->ObjectHdr.ObjectLength;

    rsvp_reserve_info->ObjectHdr.ObjectType = RSVP_OBJECT_RESERVE_INFO; 

	*pulRsvp_buf_len = rsvp_reserve_info->ObjectHdr.ObjectLength ;

    return true;
}


/*======================================================
Function:         QmpFillQoSBuffer

Description:      Fills a QoS buffer with the correct parameters 
                  for MSMQ QoS session
========================================================*/
void QmpFillQoSBuffer(QOS  *pQos)
{
    static char *pchProviderBuf = 0;
    static ULONG ulPSBuflen = 0;
    static CCriticalSection csProviderBuf;
    memset ( pQos, QOS_NOT_SPECIFIED, sizeof(QOS) );

    //
    // First time - fill the buffer
    //
    if (pchProviderBuf == 0)
    {
        CS lock(csProviderBuf);
        //
        // Check again to avoid critical race (we did not want to enter the critical section
        // earlier for performance reasons
        //
        if (pchProviderBuf == 0)
        {

            //
            // Fill in the Provider Specific (MSMQ) buffer
            //

            //
            // First call - calculate the buffer size
            //
            BuildPsBuf(0, &ulPSBuflen, CSessionMgr::m_pszMsmqAppName, CSessionMgr::m_pszMsmqPolicyLocator);

            ASSERT(0 != ulPSBuflen);

            pchProviderBuf = new char[ulPSBuflen];

            bool fBuildSuccessful = BuildPsBuf(pchProviderBuf, &ulPSBuflen, CSessionMgr::m_pszMsmqAppName, CSessionMgr::m_pszMsmqPolicyLocator);

            ASSERT(fBuildSuccessful);

            if (!fBuildSuccessful)
            {
                delete pchProviderBuf;

                pchProviderBuf = 0;
                ulPSBuflen = 0;
            }
        }
    }

    if (pchProviderBuf != 0)
    {
	    pQos->ProviderSpecific.len = ulPSBuflen;
        pQos->ProviderSpecific.buf = pchProviderBuf;
    }
    else
    {
	    pQos->ProviderSpecific.len = 0;
        pQos->ProviderSpecific.buf = 0;
    }

    //
    // sending flowspec 
    //
    pQos->SendingFlowspec.ServiceType = SERVICETYPE_QUALITATIVE;

    //
    // recving flowspec
    //
    pQos->ReceivingFlowspec.ServiceType = SERVICETYPE_QUALITATIVE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\recovery.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    recovery.cpp

Abstract:

    Packet & Transaction Recovery

Author:

    Erez Haba (erezh) 3-Jul-96

Revision History:

--*/

#include "stdh.h"
#include <ph.h>
#include <phinfo.h>
#include <ac.h>
#include "cqueue.h"
#include "cqmgr.h"
#include "pktlist.h"
#include "mqformat.h"
#include "qmutil.h"
#include "xact.h"
#include "xactrm.h"
#include "xactin.h"
#include "xactout.h"
#include "proxy.h"
#include "rmdupl.h"
#include "xactmode.h"
#include <Fn.h>
#include <mqstl.h>

#include "recovery.tmh"

extern BOOL g_fQMIDChanged;

extern HANDLE g_hAc;
extern HANDLE g_hMachine;
extern LPTSTR g_szMachineName;
BOOL GetStoragePath(PWSTR PathPointers[AC_PATH_COUNT]);

static WCHAR *s_FN=L"recovery";

/*====================================================

CompareElements  of OBJECTID

=====================================================*/
BOOL AFXAPI  CompareElements(IN const OBJECTID* pKey1,
                             IN const OBJECTID* pKey2)
{
    return ((pKey1->Lineage == pKey2->Lineage) &&
            (pKey1->Uniquifier == pKey2->Uniquifier));
}

/*====================================================

HashKey For OBJECTID

=====================================================*/
UINT AFXAPI HashKey(IN const OBJECTID& key)
{
    return((UINT)((key.Lineage).Data1 + key.Uniquifier));

}

inline PWSTR PathSuffix(PWSTR pPath)
{
    return wcsrchr(pPath, L'\\') + 2;
}

static DWORD CheckFileName(PWSTR pPath, PWSTR pSuffix)
{
    wcscpy(PathSuffix(pPath), pSuffix);
    return GetFileAttributes(pPath);
}

static DWORD GetFileID(PCWSTR pName)
{
    DWORD id = 0;
    _stscanf(pName, TEXT("%x"), &id);
    return id;
}

class CPacketConverter : public CReference 
{
private:
	int m_nOutstandingConverts;
	HANDLE m_hConversionCompleteEvent;
	CCriticalSection m_CriticalSection;
	HRESULT m_hr;

public:
	CPacketConverter();
	~CPacketConverter();
	HRESULT IssueConvert(CPacket * pDriverPacket, BOOL fSequentialIdMsmq3Format);
	HRESULT WaitForFinalStatus();
    void    SetStatus(HRESULT hr);

private:
	void SignalDone();
	void IssueConvertRequest(EXOVERLAPPED *pov);
	void ConvertComplete(EXOVERLAPPED *pov);
	static VOID WINAPI HandleConvertComplete(EXOVERLAPPED* pov);
};

CPacketConverter *g_pPacketConverter;

CPacketConverter::CPacketConverter()
{
	m_hr = MQ_OK;
	m_nOutstandingConverts = 0;
	m_hConversionCompleteEvent = CreateEvent(0, FALSE,TRUE, 0);
	g_pPacketConverter = this;
}

CPacketConverter::~CPacketConverter()
{
	g_pPacketConverter = 0;
	CloseHandle(m_hConversionCompleteEvent);
}

void CPacketConverter::SignalDone()
{
	SetEvent(m_hConversionCompleteEvent);
}

void CPacketConverter::SetStatus(HRESULT hr)
{
	CS lock(m_CriticalSection);

    m_hr = hr;
}

HRESULT CPacketConverter::IssueConvert(CPacket * pDriverPacket, BOOL fSequentialIdMsmq3Format)
{
    //
    // AC need to compute checksum and store
    //
    BOOL fStore = !g_fDefaultCommit;

    //
    // AC possibly need to convert packet sequential ID to MSMQ 3.0 (Whistler) format
    //
    BOOL fConvertSequentialId = !fSequentialIdMsmq3Format;

    //
    // AC need to convert QM GUID on packet to current QM GUID
    //
    BOOL fConvertQmId = g_fQMIDChanged;

    //
    // Nothing is needed from AC. This is a no-op.
    //
    
	if (!fStore &&
        !fConvertSequentialId &&
        !fConvertQmId)
    {
        return MQ_OK;
    }

    //
    // Call AC to do the work
    //
	CS lock(m_CriticalSection);

	EXOVERLAPPED *pov = new EXOVERLAPPED(HandleConvertComplete, HandleConvertComplete);

	AddRef();

	HRESULT hr = ACConvertPacket(g_hAc, pDriverPacket, fStore, pov);
	if(FAILED(hr))
	{
		Release();

		m_hr = hr;
		return LogHR(hr, s_FN, 10);
	} 

	m_nOutstandingConverts++;
	ResetEvent(m_hConversionCompleteEvent);
	return MQ_OK;
}

VOID WINAPI CPacketConverter::HandleConvertComplete(EXOVERLAPPED* pov)
{
	ASSERT(g_pPacketConverter);
	R<CPacketConverter> ar = g_pPacketConverter;

	g_pPacketConverter->ConvertComplete(pov);
}


void CPacketConverter::ConvertComplete(EXOVERLAPPED* pov)
{
	CS lock(m_CriticalSection);
	HRESULT hr = pov->GetStatus();

	delete pov;
		
	if(FAILED(hr))
	{
		m_hr = hr;
	}

	if(--m_nOutstandingConverts <= 0)
	{
		SignalDone();
	}
}


HRESULT CPacketConverter::WaitForFinalStatus()
{
	DWORD dwResult = WaitForSingleObject(m_hConversionCompleteEvent, INFINITE);
	ASSERT(dwResult == WAIT_OBJECT_0);
    if (dwResult != WAIT_OBJECT_0)
    {
        LogNTStatus(GetLastError(), s_FN, 199);
    }

	return LogHR(m_hr, s_FN, 20);
}

static
HRESULT
LoadPacketsFile(
    CPacketList* pList,
    PWSTR pLPath,
    PWSTR pPPath,
    PWSTR pJPath
    )
{
    PWSTR pName = PathSuffix(pLPath);
    DWORD dwFileID = GetFileID(pName);

    DWORD dwResult;
    ACPoolType pt;
    if((dwResult = CheckFileName(pPPath, pName)) != 0xffffffff)
    {
        pName = pPPath;
        pt = ptPersistent;
    }
    else if((dwResult = CheckFileName(pJPath, pName)) != 0xffffffff)
    {
        pName = pJPath;
        pt = ptJournal;
    }
    else
    {
        //
        //  Error condition we got a log file with no packet file
        //
        DeleteFile(pLPath);
        return MQ_OK;
    }

    HRESULT rc;
    rc = ACRestorePackets(g_hAc, pLPath, pName, dwFileID, pt);

    if(FAILED(rc))
    {
        TCHAR szReturnCode[20];
        _ultot(rc,szReturnCode,16);
        REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL,RESTORE_PACKET_FAILED, 3, pName, pLPath, szReturnCode));
        LogHR(rc, s_FN, 30);
        return MQ_ERROR;
    }

	R<CPacketConverter> conv = new CPacketConverter;

    BOOL fSequentialIdMsmq3Format = FALSE;
    READ_REG_DWORD(fSequentialIdMsmq3Format, MSMQ_SEQUENTIAL_ID_MSMQ3_FORMAT_REGNAME, &fSequentialIdMsmq3Format);

    //
    //  Get all packets in this pool
    //
    for(;;)
    {
        CACRestorePacketCookie PacketCookie;
        rc = ACGetRestoredPacket(g_hAc, &PacketCookie);
        if (FAILED(rc))
        {
            conv->SetStatus(rc);
            return rc;
        }
		
        if(PacketCookie.pDriverPacket == 0)
        {
			//
            //  no more packets
            //
			break;
        }

		rc = conv->IssueConvert(PacketCookie.pDriverPacket, fSequentialIdMsmq3Format);
		if(FAILED(rc))
		{
			//
			// Failed to issue  convert
			//
			return rc;
		}

        pList->insert(PacketCookie.SeqId, PacketCookie.pDriverPacket);
    }

	return LogHR(conv->WaitForFinalStatus(), s_FN, 40);
}


static void DeleteExpressFiles(PWSTR pEPath)
{
    PWSTR pEName = PathSuffix(pEPath);
    wcscpy(pEName, L"*.mq");
    --pEName;

    HANDLE hEnum;
    WIN32_FIND_DATA ExpressFileData;
    hEnum = FindFirstFile(
                pEPath,
                &ExpressFileData
                );

    if(hEnum == INVALID_HANDLE_VALUE)
        return;

    do
    {
        wcscpy(pEName, ExpressFileData.cFileName);
        if(!DeleteFile(pEPath))
            break;

    } while(FindNextFile(hEnum, &ExpressFileData));

    FindClose(hEnum);
}


static HRESULT LoadPersistentPackets(CPacketList* pList)
{
    WCHAR StoragePath[AC_PATH_COUNT][MAX_PATH];
    PWSTR StoragePathPointers[AC_PATH_COUNT];
    for(int i = 0; i < AC_PATH_COUNT; i++)
    {
        StoragePathPointers[i] = StoragePath[i];
    }

    BOOL fSuccess = GetStoragePath(StoragePathPointers);
    ASSERT(fSuccess == TRUE);
	DBG_USED(fSuccess);


    DeleteExpressFiles(StoragePath[0]);

    PWSTR pPPath = StoragePath[1];
    PWSTR pJPath = StoragePath[2];
    PWSTR pLPath = StoragePath[3];

    PWSTR pLogName = PathSuffix(pLPath);
    wcscpy(pLogName, L"*.mq");
    --pLogName;

    //
    //  Ok now we are ready with the log path template
    //
    HANDLE hLogEnum;
    WIN32_FIND_DATA LogFileData;
    hLogEnum = FindFirstFile(
                pLPath,
                &LogFileData
                );

    if(hLogEnum == INVALID_HANDLE_VALUE)
    {
        //
        //  need to do something, check what happen if no file in directory
        //
        return MQ_OK;
    }

    HRESULT rc = MQ_OK;
    do
    {
        QmpReportServiceProgress();
        wcscpy(pLogName, LogFileData.cFileName);
        rc = LoadPacketsFile(pList, pLPath, pPPath, pJPath);
        if (FAILED(rc))
        {
            break;
        }

    } while(FindNextFile(hLogEnum, &LogFileData));

    FindClose(hLogEnum);
    return LogHR(rc, s_FN, 50);
}

inline NTSTATUS PutRestoredPacket(CPacket* p, CQueue* pQueue)
{
	NTSTATUS rc;

	HANDLE hQueue = g_hMachine;
	if(pQueue != 0)
	{
		hQueue = pQueue->GetQueueHandle();
	}

    rc = ACPutRestoredPacket(hQueue, p);
	if(FAILED(rc))
		return LogHR(rc, s_FN, 60);

	return LogHR(rc, s_FN, 70);
}

inline BOOL ValidUow(const XACTUOW *pUow)
{
	for(int i = 0; i < 16; i++)
	{
		if(pUow->rgb[i] != 0)
			return(TRUE);
	}

	return(FALSE);
}

inline HRESULT GetQueue(CQmPacket& QmPkt, LPVOID p, CQueue **ppQueue)
{
    CPacketInfo* ppi = static_cast<CPacketInfo*>(p) - 1;

    if(ppi->InDeadletterQueue() || ppi->InMachineJournal())
	{
		*ppQueue = 0;
		return MQ_OK;
	}

    QUEUE_FORMAT DestinationQueue;

	if (ppi->InConnectorQueue())
	{
        // This code added as part of QFE 2738 that fixed connector 
		// recovery problem (urih, 3-Feb-98)
		//
		GetConnectorQueue(QmPkt, DestinationQueue);
	}
	else
	{
		BOOL fGetRealQ = ppi->InSourceMachine() || QmpIsLocalMachine(QmPkt.GetConnectorQM());
		//
		// If FRS retreive the destination according to the destination queue;
		// otherwise, retrive the real detination queue and update the Connector QM
		// accordingly
		//
		QmPkt.GetDestinationQueue(&DestinationQueue, !fGetRealQ);
	}

	//
	// Translate the queue format name according to local mapping (qal.lib)
	//
	//
	QUEUE_FORMAT_TRANSLATOR  RealDestinationQueue(&DestinationQueue);
  

    //
    // If the destination queue format name is direct with TCP or IPX type,
    // and we are in the Target queue we lookup/open the queue with ANY direct type. 
    // We do it from 2 reasons:
    //       - on RAS the TCP/IPX address can be changed between one conection 
    //         to another. However if the message was arrived to destination we 
    //         want to pass to the queue.
    //       - On this stage we don't have the machine IP/IPX address list. Therefor
    //         all the queue is opened as non local queue. 
    //

	bool fInReceive = false;

    if ((RealDestinationQueue.get()->GetType() == QUEUE_FORMAT_TYPE_DIRECT) && 
        (ppi->InTargetQueue() || ppi->InJournalQueue()) )
    {
		fInReceive = true;
	}

	BOOL fOutgoingOrdered;
        
	fOutgoingOrdered =  QmPkt.IsOrdered() &&       // ordered packet
                        ppi->InSourceMachine() &&  // sent from here
                        !ppi->InConnectorQueue();


	//
    // Retreive the Connector QM ID
    //
    const GUID* pgConnectorQM = (fOutgoingOrdered) ? QmPkt.GetConnectorQM() : NULL;
    if (pgConnectorQM && *pgConnectorQM == GUID_NULL)
    {
        //
        // The message was generated for offline DS queue. As a result we didn't know 
        // if the queue is foreign transacted queue. In such a case we have place
        // holder on the packet, but it doesn't mean that the queue is real
        // foreign transacted queue
        //
        pgConnectorQM = NULL;
    }



	CQueue* pQueue;
	HRESULT rc = QueueMgr.GetQueueObject(
								 RealDestinationQueue.get(),
                                 &pQueue,
                                 pgConnectorQM,
                                 fInReceive
								 );

    // BUGBUG what will be the consequences for the xact if the real destinatrion queue was deleted before recovery ??
    // BUGBUG in the usual non-xacted case Uri throws away the packet.

    if (FAILED(rc))
    {
        ASSERT ((rc == MQDS_OBJECT_NOT_FOUND) ||
                (rc == MQ_ERROR_QUEUE_NOT_FOUND) ||
                (rc == MQDS_GET_PROPERTIES_ERROR));
        //
        // produce Event log
        //
        WCHAR QueueFormatName[128];
        DWORD FormatNameLength;

        MQpQueueFormatToFormatName(RealDestinationQueue.get(),
                                   QueueFormatName,
                                   128,
                                   &FormatNameLength,
                                   false
                                   );

        REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL,
                                          RESTORE_FAILED_QUEUE_NOT_FOUND, 
                                          1, 
                                          &QueueFormatName));

		return LogHR(rc, s_FN, 80);
	}

	*ppQueue = pQueue;

	return(MQ_OK);
}


inline
HRESULT
ProcessPacket(
	CTransaction*& pCurrentXact,
	CQmPacket& QmPkt,
	CBaseHeader* p,
	CQueue* pQueue
	)
{
	CPacketInfo* ppi = reinterpret_cast<CPacketInfo*>(p) - 1;
	
	//
	// Treat non-fully-processed ordered incomimg messages
	//
	
	if(pQueue != 0)
	{
		if (
			QmPkt.IsOrdered()     &&           // ordered
			(pQueue->IsLocalQueue() || ppi->InConnectorQueue()) &&           // message is incoming
			!ppi->InSourceMachine())  // sent from other machine
		{	
			g_pInSeqHash->Restored(&QmPkt);
		}
	}

	//
    // Add the message ID to the Message map to eliminate duplicates. If the 
    // message was sent from the local machine, ignore it.
    //
    if (!ppi->InSourceMachine()  && !QmPkt.IsOrdered())
    {
        DpInsertMessage(QmPkt);
    }

	//
	// We recover transactions one by one.  If the transaction contains at least
	// one sent packet, we recover (complete) the tranasction after we see the
	// last packet (it is always a sent packet). If the transaction cotains no sent
	// packets, we recover it after we read all packets.
	//


	//
	// Check if we need to recover the previous transaction
	//
	if(pCurrentXact != 0)
	{
		if(*pCurrentXact->GetUow() != *ppi->Uow())
		{
			//
			// We have seen the last packet for the current transaction
			// We must recover it now to restore messages to the 
			// right order in the queue
			//
			HRESULT hr = pCurrentXact->Recover();
			if(FAILED(hr))
				return LogHR(hr, s_FN, 90);

			pCurrentXact->Release();
			pCurrentXact = 0;
		}
	}

	//
	// Is this message not a part of a transaction?
	//
	if((!g_fDefaultCommit && !ppi->InTransaction()) || !ValidUow(ppi->Uow()))
	{
		return LogHR(PutRestoredPacket(QmPkt.GetPointerToDriverPacket(), pQueue), s_FN, 100);
	}

	//
	// Handle the current packet
	//

	if(pCurrentXact != 0)
	{
		//
		// This send packet is part of the current transaction
		// Put packet back on it's queue. It's transaction will take care of it
		//
		ASSERT(pCurrentXact->ValidTransQueue());
		ASSERT(ppi->TransactSend());
#ifdef XACT_TRACE
		pCurrentXact->nsMsgs++;
#endif
		return LogHR(PutRestoredPacket(QmPkt.GetPointerToDriverPacket(), pQueue), s_FN, 110);
	}

	//
	// Find the transaction this packet belongs to.
	//
	CTransaction *pTrans = g_pRM->FindTransaction(ppi->Uow());

	if(pTrans == 0)
	{
		//
		// There is no transaction it belongs to.
		//
		if(!g_fDefaultCommit && ppi->TransactSend())
		{
			//
			// Throw it away - we are not in DefaultCommit mode
			// and this is a sent packet.
			//
			return LogHR(ACFreePacket(g_hAc, QmPkt.GetPointerToDriverPacket()), s_FN, 120);
		}

		//
		// Put packet back on it's queue. 
		// This packet does not belong to an
		// active transaction.
		//
		return LogHR(PutRestoredPacket(QmPkt.GetPointerToDriverPacket(), pQueue), s_FN, 130);
	}

	//
	// The packet belongs to a transaction
	//

	if(!pTrans->ValidTransQueue())
	{
		//
		// Make sure we create a tranasction
		// before we add packets to it
		//
		HRESULT rc;
		HANDLE hQueueTrans;
		rc = XactCreateQueue(&hQueueTrans, ppi->Uow());
		if (FAILED(rc)) 
			return LogHR(rc, s_FN, 140);

		pTrans->SetTransQueue(hQueueTrans);
#ifdef XACT_TRACE
		if(ppi->TransactSend()) 
		{
			pTrans->nsMsgs = 1;
			pTrans->nrMsgs = 0;
		}
		else
		{
			pTrans->nsMsgs = 0;
			pTrans->nrMsgs = 1;
		}
#endif
	}
#ifdef XACT_TRACE
	else
	{
		if(ppi->TransactSend())
			pTrans->nsMsgs++;
		else
			pTrans->nrMsgs++;
	}
#endif
				
	if(ppi->TransactSend())
	{
		//
		// This is a new unit of work
		//
		pCurrentXact = pTrans;
	}
									
	//
	// Put packet back on it's queue.  It's tranasction will take care of it.
	//
	return LogHR(PutRestoredPacket(QmPkt.GetPointerToDriverPacket(), pQueue), s_FN, 150);
}

inline void XactTrace(LPSTR s)
{
#ifdef XACT_TRACE
	OutputDebugStringA(s);
	OutputDebugStringA("\n");
#endif
}


static
CBaseHeader*
QMpGetPacketByCookie(
    CPacket* pDriverPacket
    )
/*++

Routine Description:

    Call AC to translate a packet cookie to a valid packet pointer
    in QM process address space.

Arguments:

    pDriverPacket - A cookie to the packet in kernel address space.

Return Value:

    A valid pointer in QM process address space.

--*/
{
    ASSERT(pDriverPacket != NULL);

    //
    // Pack the pointers to a structure recognized by AC
    //
    CACPacketPtrs PacketPtrs;
    PacketPtrs.pDriverPacket = pDriverPacket;

    //
    // Call AC to get a packet in QM address space
    //
    ACGetPacketByCookie(g_hAc, &PacketPtrs);

    return PacketPtrs.pPacket;

} // QMpGetPacketByCookie


static HRESULT RestorePackets(CPacketList* pList)
{
    HRESULT rc = MQ_OK;
	CTransaction *pCurrentXact = 0;
   
	//
	// Release all complete trasnactions
	//
	g_pRM->ReleaseAllCompleteTransactions();

	XactTrace("Recovering packets");
    // Cycle by all restored packets
    for(int n = 0; !pList->isempty(); pList->pop(), ++n)
    {
        if((n % 1024) == 0)
        {
            QmpReportServiceProgress();
        }

        //
        // Get the first packet cookie from the list
        //
        CPacket* pDriverPacket = pList->first();

        //
        // Translate the cookie to pointer in QM address space
        //
		CBaseHeader* pBaseHeader = QMpGetPacketByCookie(pDriverPacket);
        if (pBaseHeader == NULL)
        {
            return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 158);
        }

		CQmPacket QmPkt(pBaseHeader, pDriverPacket);

        CQueue* pQueue;
		rc = GetQueue(QmPkt, pBaseHeader, &pQueue);
		if(FAILED(rc))
		{
			XactTrace("Get Queue failed");
			CPacketInfo* ppi = reinterpret_cast<CPacketInfo*>(pBaseHeader) - 1;
			USHORT usClass = ppi->InTargetQueue() ?
                        MQMSG_CLASS_NACK_Q_DELETED :
                        MQMSG_CLASS_NACK_BAD_DST_Q;

            ACFreePacket(g_hAc, pDriverPacket, usClass);
			continue;
		}

		rc = ProcessPacket(pCurrentXact, QmPkt, pBaseHeader, pQueue);
		if(pQueue != 0)
		{
			pQueue->Release();
		}

		if(FAILED(rc))
			return LogHR(rc, s_FN, 160);
	}

	//
	// The transactions left all either contain no messages or recieved only 
	// messages.  We need to recover them as well.
	//
	// N.B.  There  might be still one transaction with a sent message. The
	//       current transaction.  It will be recovered with the rest.
	//
    QmpReportServiceProgress();
	XactTrace("recovered all packets. Recovering left transactions");
	rc = g_pRM->RecoverAllTransactions();
	if(FAILED(rc)) 
	{
		XactTrace("Recovery failed");
	}
	return LogHR(rc, s_FN, 170);
}

static void WINAPI ReleaseMessageFile(CTimer *pTimer);
static CTimer s_ReleaseMessageFileTimer(ReleaseMessageFile);
static CTimeDuration s_ReleaseMessageFilePeriod;

static void WINAPI ReleaseMessageFile(CTimer *pTimer)
{
    ASSERT(pTimer == &s_ReleaseMessageFileTimer);
    HRESULT rc = ACReleaseResources(g_hAc);
    LogHR(rc, s_FN, 124);
    ExSetTimer(pTimer, s_ReleaseMessageFilePeriod);
}


static void InitializeMessageFileRelease(void)
{
    DWORD Duration = MSMQ_DEFAULT_MESSAGE_CLEANUP;
    READ_REG_DWORD(
        Duration,
        MSMQ_MESSAGE_CLEANUP_INTERVAL_REGNAME,
        &Duration
        );

    s_ReleaseMessageFilePeriod = CTimeDuration::FromMilliSeconds(Duration);
    ReleaseMessageFile(&s_ReleaseMessageFileTimer);
}

static void SetMappedLimit(bool IsLimitNeeded )
{

	ULONG MaxMappedFiles;
	if(IsLimitNeeded)
	{
		MEMORYSTATUS MemoryStatus;

		GlobalMemoryStatus(&MemoryStatus);
	
		ULONG ulMessageFileSize = MSMQ_DEFAULT_MESSAGE_SIZE_LIMIT;
		ULONG ulDefault = MSMQ_DEFAULT_MESSAGE_SIZE_LIMIT;
		READ_REG_DWORD(
			ulMessageFileSize,
			MSMQ_MESSAGE_SIZE_LIMIT_REGNAME,
			&ulDefault
            );
		MaxMappedFiles = numeric_cast<ULONG>((MemoryStatus.dwAvailPhys * 0.8) / ulMessageFileSize);
		if (MaxMappedFiles < 1)
		{
			MaxMappedFiles = 1;
		}
	}
	else
	{
		MaxMappedFiles = 0xffffffff;
	}
	
	ACSetMappedLimit(g_hAc, MaxMappedFiles);
}

HRESULT RecoverPackets()
{
    HRESULT rc;
    CPacketList packet_list;

    //
    // Performance feauture: to avoid paging
    // limit the max number of MMFs to fetch in RAM
    //
    SetMappedLimit(true);

    rc = LoadPersistentPackets(&packet_list);
    if(FAILED(rc))
    {
        return LogHR(rc, s_FN, 180);
    }
	

    rc = RestorePackets(&packet_list);
    InitializeMessageFileRelease();
    
    //
    // Remove the limit on the number of mapped files 
    //
    SetMappedLimit(false);    
    return LogHR(rc, s_FN, 190);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\regqueue.cpp ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    regqueue.cpp

Abstract:

    This module implements function to write/read queue properties
    from local registry.
    Used for private queues and for cache of public queues, when working
    wihtout MQIS.

Author:

    Doron Juster  (DoronJ)

--*/

#include "stdh.h"
#include <Msm.h>
#include <mqexception.h>
#include "cqmgr.h"
#include "regqueue.h"
#include "lqs.h"
#include "mqaddef.h"

#include "regqueue.tmh"

static WCHAR *s_FN=L"regqueue";

void
CopySecurityDescriptor(
    PSECURITY_DESCRIPTOR *ppSD,
    CSecureableObject    *pSec ) ;

/*============================================================
*
*  HRESULT GetCachedQueueProperties()
*
=============================================================*/

HRESULT GetCachedQueueProperties( IN DWORD       cpObject,
                                  IN PROPID      aProp[],
                                  IN PROPVARIANT apVar[],
                                  IN const GUID* pQueueGuid,
                                  IN LPWSTR      lpPathIn )
{
    HRESULT hr;
    CHLQS hLQS;

    if (pQueueGuid)
    {
        ASSERT(!lpPathIn) ;
        hr = LQSOpen(pQueueGuid, &hLQS, NULL);
    }
    else
    {
        ASSERT(!pQueueGuid) ;
        hr = LQSOpen(lpPathIn, &hLQS, NULL);
    }

    if (FAILED(hr))
    {
        //
        // This particular error code is important to the functions
        // that calls this function.
        //
        LogHR(hr, s_FN, 10);
        return MQ_ERROR_NO_DS;
    }

    //
    // Get the properties.
    //
    return LogHR(LQSGetProperties( hLQS, cpObject, aProp, apVar), s_FN, 20);
}

HRESULT DeleteCachedQueueOnTimeStamp(const GUID* pGuid, time_t TimeStamp)
/*++
Routine Description:
	This Routine deletes the cached queue if its time stamp property value does not 
	match the 'TimeStamp' argument.

Arguments:

Return Value:

--*/
{
    ASSERT(pGuid) ;

    CHLQS hLQS;
    HRESULT hr = LQSOpen(pGuid, &hLQS, NULL);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 30);
    }

    PROPID Prop = PPROPID_Q_TIMESTAMP;
    PROPVARIANT Var;

    Var.vt = VT_NULL;

    hr = LQSGetProperties(hLQS, 1, &Prop, &Var);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 40);
    }

    ASSERT(Var.blob.cbSize == sizeof(time_t)) ;

	time_t& QueriedTimeStamp = *reinterpret_cast<time_t*>(Var.blob.pBlobData);

    if (QueriedTimeStamp < TimeStamp)
    {
        //
        // The file is older than the last update, delete the queue.
        // It can happen that the file is newer in a scenario were an additional update
        // occurs when a message arrives while updating public queues cache; that is,
        // right after the update but before looking for queues to delete.
        // See  #8316; erezh 4-Jul-2001
        //
        hr = DeleteCachedQueue(pGuid);
    }

    delete Var.blob.pBlobData ;

	return LogHR(hr, s_FN, 50);
}

/*============================================================
*
*  HRESULT DeleteCachedQueue()
*
=============================================================*/

HRESULT DeleteCachedQueue(IN const GUID* pQueueGuid)
{
    HRESULT hr = LQSDelete(pQueueGuid);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 60);
    }

    //
    // Try to remove from queue manager, also.
    //
    QueueMgr.NotifyQueueDeleted(pQueueGuid);
    
    QUEUE_FORMAT qf(*pQueueGuid);
    MsmUnbind(qf);
	
	return hr;
}

//******************************************************************
//
//
//******************************************************************

HRESULT SetCachedQueueProp(IN const GUID* pQueueGuid,
                           IN DWORD       cpObject,
                           IN PROPID      pPropObject[],
                           IN PROPVARIANT pVarObject[],
                           IN BOOL        fCreatedQueue,
                           IN BOOL        fAddTimeSec,
                           IN time_t      TimeStamp )
{
extern BOOL              g_fWorkGroupInstallation;
	ASSERT( !g_fWorkGroupInstallation);
    HRESULT hr;
    ASSERT(pQueueGuid) ;
    CHLQS hLQS;

    if (fCreatedQueue)
    {
        //
        // Create the queue.
        //
        hr = LQSCreate(NULL,
                       pQueueGuid,
                       cpObject,
                       pPropObject,
                       pVarObject,
                       &hLQS);
        if (hr == MQ_ERROR_QUEUE_EXISTS)
        {
            //
            // If the queue aready exists, ust set it's properties.
            //
            hr = LQSSetProperties(hLQS, cpObject, pPropObject, pVarObject);
        }
    }
    else
    {
        //
        // Open the queue and set it's properties.
        //
        hr = LQSOpen(pQueueGuid, &hLQS, NULL);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 70);
        }
        hr = LQSSetProperties(hLQS, cpObject, pPropObject, pVarObject);
    }

    if (fAddTimeSec && SUCCEEDED(hr))
    {
       ASSERT(hLQS) ;

       //
       // Now handle security.
       // also, add the time stamp for cleanup.
       //
       // If this routine is called as result of a received notification,
       // the queue security is included in the property array.
       // And it was already written into registry, when all the rest
       // of the properties were written.
       //
       // If this routine is called from TimeToPublicCacheUpdate, queue
       // security property is not included ( because the queue
       // properties were retrieved using lookup, which doesn't return
       // queue security
       //
       PROPID         propsecid[2] ;
       PROPVARIANT    secresult[2] ;
       PROPVARIANT*   psecvar;
       PROPVARIANT*   ptimevar;
       BOOL fFoundSecurity = FALSE;
       PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;


       for ( DWORD i = 0; i < cpObject; i++)
       {
           if (pPropObject[i] == PROPID_Q_SECURITY)
           {
               fFoundSecurity = TRUE;
               break;
           }
       }

       DWORD dwNumProps = fFoundSecurity ? 1 : 2;

       propsecid[0] = PPROPID_Q_TIMESTAMP ;
       ptimevar = &secresult[0] ;
       ptimevar->blob.pBlobData = reinterpret_cast<BYTE*>(&TimeStamp);
       ptimevar->blob.cbSize = sizeof(time_t) ;
       ptimevar->vt = VT_BLOB;

       if (!fFoundSecurity)
       {
           CQMDSSecureableObject DsSec(eQUEUE, pQueueGuid, TRUE, TRUE, NULL);
           CopySecurityDescriptor(&pSecurityDescriptor, &DsSec);

           propsecid[1] = PROPID_Q_SECURITY;
           psecvar = &secresult[1] ;
           psecvar->blob.pBlobData = (BYTE *) pSecurityDescriptor ;
           psecvar->blob.cbSize =
              ((pSecurityDescriptor) ? GetSecurityDescriptorLength(pSecurityDescriptor) : 0);
           psecvar->vt = VT_BLOB;
		   if ( pSecurityDescriptor == NULL)
		   {
			   //
			   //	We failed to retrieve the security descriptor ( i.e no
			   //   access to DS server and the security attribute is not
			   //   in the cache (LQS file))
			   //	If this is the case, then delete the LQS file ( otherwise further
			   //   access check will come out with wrong results)
			   //
			   hr = LQSDelete( hLQS);
		   }
       }

	   if (SUCCEEDED(hr))
	   {
			hr = LQSSetProperties( hLQS, dwNumProps, propsecid, secresult);
	   }

       delete pSecurityDescriptor ;
    }

    return LogHR(hr, s_FN, 80);
}

/*======================================================

Function:      UpdateCachedQueueProp

Description:   public Queue was created. The function add the queue to
               public queue cache

Arguments:     pguidQueue - Guid of the Queue

Return Value:  None

========================================================*/
HRESULT UpdateCachedQueueProp(IN const GUID* pQueueGuid,
                              IN DWORD       cpObject,
                              IN PROPID      pPropObject[],
                              IN PROPVARIANT pVarObject[],
                              IN time_t		 TimeStamp)
{
	//
	// Crete the key in registry.
	//
	HRESULT hr = SetCachedQueueProp(  
					pQueueGuid,
					cpObject,
					pPropObject,
					pVarObject,
					FALSE,
					TRUE,
					TimeStamp 
					);
	if(FAILED(hr))
	{
		//
		// Maybe file was corrupted and deleted.
		// Try to create a new one.
		//
		hr = SetCachedQueueProp(  
				pQueueGuid,
				cpObject,
				pPropObject,
				pVarObject,
				TRUE,
				TRUE,
				TimeStamp 
				);
	}

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 90);
    }

    //
    // Try to update queue properties in the queue manager.
    // Build the queue format as public queue type, since bind/unbind
    // to multicast group is done only for private or public queues (not direct).
    //
    QUEUE_FORMAT QueueFormat(*pQueueGuid);
    QueueMgr.UpdateQueueProperties(&QueueFormat, cpObject, pPropObject, pVarObject);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\rmdupl.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    rmdupl.h

Abstract:
    Remove Duplicate function decleration

Author:
    Uri Habusha (urih), 1-Oct-98

Revision History:

--*/

#ifndef __RMDUPL_H__
#define __RMDUPL_H__

BOOL DpInsertMessage(const CQmPacket& QmPkt);
void DpRemoveMessage(const CQmPacket& QmPkt);

///////////////////////////////////////////////////////////////////////////
//
// Class that clean given packet from the remove duplicate map
// Used  to clean packet that were rejected from the duplicate map
//
///////////////////////////////////////////////////////////////////////////
class CAutoDeletePacketFromDuplicateMap
{
public:
	CAutoDeletePacketFromDuplicateMap(
		const CQmPacket* packet
		):
		m_packet(packet)
	{
	}

	~CAutoDeletePacketFromDuplicateMap()
	{
		if(m_packet != NULL)
		{
			DpRemoveMessage(*m_packet);			
		}
	}

	void detach()
	{
		m_packet = NULL;		
	}

private:
	const CQmPacket* m_packet;
};



#endif //__RMDUPL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\session.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    session.cpp

Abstract:
    Implementation of Network session class.

Author:
    Uri Habusha (urih) 1-Jan-96

--*/

#include "stdh.h"

#include "session.h"
#include "sessmgr.h"
#include "cqmgr.h"
#include "qmp.h"
#include "perf.h"
#include "qmthrd.h"
#include "cgroup.h"
#include "admin.h"
#include "qmutil.h"
#include "xact.h"
#include "xactrm.h"
#include "xactout.h"
#include "xactin.h"
#include "ping.h"
#include "rmdupl.h"
#include <uniansi.h>
#include <privque.h>


#include "session.tmh"

extern DWORD g_dwOperatingSystem;

extern HANDLE g_hAc;
extern CQueueMgr QueueMgr;
extern CSessionMgr SessionMgr;
extern CQGroup* g_pgroupNonactive;
extern CQGroup* g_pgroupWaiting;
extern BOOL  g_bCluster_IP_BindAll;

UINT  g_dwIPPort;


static WCHAR *s_FN=L"session";

//
// Extern variables
//
extern CAdmin      Admin;

TCHAR tempBuf[100];

CCriticalSection g_critVerifyOrdered;  // Serializes Verify & PutOrderedPacket treatment

//
// Define decleration
//
#define INIT_UNACKED_PACKET_NO 0
#define HOP_COUNT_RETRY 15
#define HOP_COUNT_EXPIRATION (HOP_COUNT_RETRY*2) //must be < 32 (only 5 bits)
#define ESTABLISH_CONNECTION_TIMEOUT 60*1000
#define MSMQ_MIN_ACKTIMEOUT          1000*20     // define minimum ack timeout to 20 seconds
#define MSMQ_MAX_ACKTIMEOUT          1000*60*2   // define maximum ack timeout to 2 minutes
#define MSMQ_MIN_STORE_ACKTIMEOUT    500         // define minimum ack timeout to 0.5 second

#define PING_TIMEOUT 1000

#ifdef _DEBUG

static void DBG_MSGTRACK(DWORD mode, CQmPacket* pPkt, LPCWSTR msg)
{
    OBJECTID MessageId;
    pPkt->GetMessageId(&MessageId);
    DBGMSG((mode, DBGLVL_TRACE, TEXT("%ls: ID=") TEXT(LOG_GUID_FMT) TEXT("\\%u (ackno=%u)"), msg, LOG_GUID(&MessageId.Lineage), MessageId.Uniquifier, pPkt->GetAcknowladgeNo()));
}

#else
#define DBG_MSGTRACK(mode, pPkt, msg) ((void)0)
#endif



inline DWORD GetBytesTransfered(EXOVERLAPPED* pov)
{
    return numeric_cast<DWORD>(pov->InternalHigh);
}

//
// Description:
//      the function stores in the class message property that
//      is required for sending a report message
//
// Arguments:
//      pointer to the packet
//
// Returned Value:
//      None.
//
void
ReportMsgInfo::SetReportMsgInfo(
    CQmPacket* pPkt
    )
{
    m_msgClass = pPkt->GetClass();
    m_msgTrace = pPkt->GetTrace();
    m_msgHopCount = pPkt->GetHopCount();

    pPkt->GetMessageId(&m_MessageId);
    pPkt->GetDestinationQueue(&m_TargetQueue);
    if (pPkt->IsDbgIncluded())
    {
        BOOL rc = pPkt->GetReportQueue(&m_OriginalReportQueue);
        ASSERT(rc);
        DBG_USED(rc);
    }
    else
    {
        m_OriginalReportQueue.UnknownID(0);
    }
}


//
// Description:
//      the function send a report message according to the message
//      properties that were stored in the class
//
// Arguments:
//      pcsNextHope - The name of the next hope
//
// Returned Value:
//      None.
//
void
ReportMsgInfo::SendReportMessage(
    LPCWSTR pcsNextHope
    )
{
    if (m_msgClass == MQMSG_CLASS_REPORT)
    {
        //
        // If the message is report mesaage ignore it.
        //
        return;
    }

    QUEUE_FORMAT QmReportQueue;
    if (
        //
        // Packet should be traced.
        //
        (m_msgTrace == MQMSG_SEND_ROUTE_TO_REPORT_QUEUE) &&

        //
        // Valid report queue is on packet.
        //
        // Note that invalid (unknown) report queue may be on packet,
        // for example when MQF header is included, so that reporting
        // QMs 1.0/2.0 will not append their Debug header to packet.
        //
        (m_OriginalReportQueue.GetType() != QUEUE_FORMAT_TYPE_UNKNOWN)
        )
    {
        //
        // Send report to the report queue that is on packet.
        //
        Admin.SendReport(&m_OriginalReportQueue,
                         &m_MessageId,
                         &m_TargetQueue,
                         pcsNextHope,
                         m_msgHopCount);


        //
        // This is a reporting QM with valid report queue by itself.
        // BUGBUG: Conflict message should be sent only if report queue
        // of this QM is not the one on packet. (ShaiK, 18-May-2000)
        //
        //
        if (SUCCEEDED(Admin.GetReportQueue(&QmReportQueue)))
        {

            Admin.SendReportConflict(&QmReportQueue,
                                     &m_OriginalReportQueue,
                                     &m_MessageId,
                                     &m_TargetQueue,
                                     pcsNextHope);
        }

        return;
    }

    if (
        //
        // This is a reporting QM, or packet should be traced.
        //
        (CQueueMgr::IsReportQM() ||(m_msgTrace == MQMSG_SEND_ROUTE_TO_REPORT_QUEUE)) &&

        //
        // There is a valid report queue for this QM.
        //
        (SUCCEEDED(Admin.GetReportQueue(&QmReportQueue))))

    {
        //
        // Send report to the report queue of this QM.
        //
        Admin.SendReport(&QmReportQueue,
                  &m_MessageId,
                  &m_TargetQueue,
                  pcsNextHope,
                  m_msgHopCount);
    }
} // ReportMsgInfo::SendReportMessage


/*====================================================

GetDstQueueObject

Arguments:

Return Value:

=====================================================*/
HRESULT GetDstQueueObject(IN  CQmPacket* pPkt,
                          OUT CQueue** ppQueue,
                          IN  bool     fInReceive)
{
    HRESULT  rc;
    QUEUE_FORMAT DestinationQueue;
    BOOL fGetRealQueue = QmpIsLocalMachine(pPkt->GetSrcQMGuid()) ||
                         (pPkt->ConnectorQMIncluded() && QmpIsLocalMachine(pPkt->GetConnectorQM()));

    pPkt->GetDestinationQueue(&DestinationQueue, !fGetRealQueue);
    rc = QueueMgr.GetQueueObject(&DestinationQueue, ppQueue, 0, fInReceive);

    return LogHR(rc, s_FN, 10);
}

/*====================================================

CTransportBase::GetNextSendMessage

Arguments: None

Return Value: None

=====================================================*/
HRESULT CTransportBase::GetNextSendMessage(void)
{
    HRESULT hr = MQ_ERROR;
    CS lock(m_cs);


    if ((GetGroupHandle() != NULL) && (GetSessionStatus() != ssNotConnect))
    {
        //
        // Increament Session refence count. This refernce count is for get message
        // request from the session group. The refernce conunt is decremented when
        // the session is closed or when the session is suspended.
        //
        // SP4 - bug 2794 (SP4SS: Exception! Transport is closed during message send)
        // Fix: Increment the refernce count before trying to get new message
        //                           Uri Habusha (urih), 17-6-98
        //
        AddRef();

        hr = CreateAcGetPacketRequest(
                GetGroupHandle(),
                &m_GetSendOV,
                this,
                FALSE /*fAfterFailure*/);

        if (FAILED(hr))
        {
            Release();
            Close_Connection(this, L"Get next send message Request is failed");
        }
    }

    return LogHR(hr, s_FN, 30);
}

/*====================================================

CTransportBase::RequeuePacket

Arguments:

Return Value:

=====================================================*/
HRESULT CTransportBase::RequeuePacket(CQmPacket* pPkt)
{
    CQueue* pQueue;
    HRESULT rc;

    //
    // RequeuePacket is done only to packets that are going to be sent
    //
    GetDstQueueObject(pPkt, &pQueue, false);
    ASSERT(pQueue != NULL);

    //
    // put packet in AC
    //
    rc = ACPutPacket(
            pQueue->GetQueueHandle(),
            pPkt->GetPointerToDriverPacket()
            );

    pQueue->Release();
    if(FAILED(rc))
    {
        //
        // BUGBUG: what to do if requing failed.
        // Can fail due allocation failed
        //
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR,
             _TEXT("::RequeuePacket- Can't keep message in AC, ntstatus %xh"), rc));
    }
    else
    {
        DBG_MSGTRACK(DBGMOD_MSGTRACK, pPkt, TEXT("Requeued message"));
    }
    return LogHR(rc, s_FN, 40);
}

/*======================================================

Function:      VerifyTransactRights

Description:  Checks that the packet and queue are appropriate for transaction
              If the packet is transacted,     then the queue must be transactional
              If the packet is not transacted, then the queue must be non-transactional

Return value:
    The acknowledgment class.
    if packet is OK, MQMSG_CLASS_NORMAL is returned
========================================================*/
USHORT VerifyTransactRights(CQmPacket* pPkt, CQueue* pQ)
{
    if(pPkt->IsOrdered() == pQ->IsTransactionalQueue())
    {
        return(MQMSG_CLASS_NORMAL);
    }

    return (pPkt->IsOrdered() ?
                MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_Q :
                MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_MSG
            );
}

/*====================================================

VerifyRecvMsg

Arguments:

Return Value:
    The acknowledgment class.
    if packet is OK, MQMSG_CLASS_NORMAL is returned

=====================================================*/
USHORT VerifyRecvMsg(CQmPacket* pPkt, CQueue* pQueue)
{
    if(!pQueue->IsLocalQueue())
    {
        //
        // Not Local Machine (FRS)
        //
        if (!IsRoutingServer())   // [adsrv] CQueueMgr::GetMQS() < SERVICE_SRV
        {
            //
            // Can't handle the packet. return NACK if needed
            //
            return(MQMSG_CLASS_NACK_BAD_DST_Q);
        }
    }
    else
    {
        //
        // Verify the the sender has write access permission on the queue.
        //
        WORD wSenderIdLen;
        HRESULT hr = VerifySendAccessRights(
                       pQueue,
                       (PSID)pPkt->GetSenderID(&wSenderIdLen),
                       pPkt->GetSenderIDType()
                       );

        if (FAILED(hr))
        {
            //
            // Access was denied, send NACK.
            //
            return(MQMSG_CLASS_NACK_ACCESS_DENIED);
        }

        //
        // Destination machine, check queue permission and privacy
        //
        switch(pQueue->GetPrivLevel())
        {
        case MQ_PRIV_LEVEL_BODY:
            if (!pPkt->IsEncrypted() && pPkt->IsBodyInc())
            {
                //
                // The queue enforces that any message sent to it sohlud be
                // enctrpted. The message is not encrypted so NACK it.
                //
                return(MQMSG_CLASS_NACK_BAD_ENCRYPTION);
            }
            break;
        case MQ_PRIV_LEVEL_NONE:
            if (pPkt->IsEncrypted())
            {
                //
                // The queue enforces that any message sent to it sohlud not be
                // enctrpted. The message is encrypted so NACK it.
                //
                return(MQMSG_CLASS_NACK_BAD_ENCRYPTION);
            }
            break;

        case MQ_PRIV_LEVEL_OPTIONAL:
            break;

        default:
            ASSERT(0);
            break;
        }

        hr = pPkt->Decrypt() ;
        if (FAILED(hr))
        {
            if (hr == MQ_ERROR_ENCRYPTION_PROVIDER_NOT_SUPPORTED)
            {
                return(MQMSG_CLASS_NACK_UNSUPPORTED_CRYPTO_PROVIDER);
            }
            else
            {
                return(MQMSG_CLASS_NACK_BAD_ENCRYPTION);
            }
        }

        if (FAILED(VerifySignature(pPkt)))
        {
            //
            // Bad signature, send NACK.
            //
            return(MQMSG_CLASS_NACK_BAD_SIGNATURE);
        }

        if (pQueue->ShouldMessagesBeSigned() && !pPkt->IsAuthenticated())
        {
            //
            // The queue enforces that any message sent to it should be signed.
            // But the message does not contain a signature, send NACK.
            //
            return(MQMSG_CLASS_NACK_BAD_SIGNATURE);
        }
    }

    return(MQMSG_CLASS_NORMAL);
}

/********************************************************************************/
/*                   C S e s s i o n                                            */
/********************************************************************************/
CTransportBase::CTransportBase() :
    m_GetSendOV(GetMsgSucceeded, GetMsgFailed)
{
    m_SessGroup     = NULL;             // Initialize group
    m_SessionStatus = ssNotConnect;     // Session not connect status
    m_guidDstQM     = GUID_NULL;        // null QM guid
    m_pAddr         = 0;                // Null Address
    m_fClient       = FALSE;            // not client
    m_fUsed         = TRUE;             // used
    m_fDisconnect   = FALSE;
    m_fQoS          = false;            // Not QoS

}

CTransportBase::~CTransportBase()
{

#ifdef _DEBUG
    if (m_pAddr != NULL)
    {
        DBGMSG((DBGMOD_NETSESSION, DBGLVL_TRACE,
             TEXT("~CTransportBase: Delete Session Object with %ls"), GetStrAddr()));
    }
#endif
    delete m_pAddr;
}

/*======================================================

   FUNCTION: CSockTransport::ResumeSendSession

========================================================*/
HRESULT
CSockTransport::ResumeSendSession(void)
{
    HRESULT rc;

    DBGMSG((DBGMOD_NETSESSION,
            DBGLVL_TRACE,
            TEXT("ResumeSendSession- Resume session to %ls. (Window size, My = %d, Other = %d)"),
                               GetStrAddr(), SessionMgr.GetWindowSize(),m_wRecvWindowSize));
    //
    // Create a get request from session group
    //
    rc = GetNextSendMessage();
    if (SUCCEEDED(rc))
    {
        m_fSessionSusspended = FALSE;
    }

    return LogHR(rc, s_FN, 50);
}

/*======================================================

   FUNCTION: CSockTransport::IsSusspendSession

========================================================*/
BOOL
CSockTransport::IsSusspendSession(void)
{
    BOOL   f = FALSE;
    if (GetSendUnAckPacketNo() >= SessionMgr.GetWindowSize())
    {
        f = TRUE;
        m_fSessionSusspended = TRUE;
    }
    return (f);
}


/*====================================================

CSockTransport::Send

Arguments:

Return Value:

Thread Context: Session

=====================================================*/
HRESULT CSockTransport::Send(IN  CQmPacket* pPkt,
                             OUT BOOL*      pfGetNext)
{
    //
    // Send the packet
    //

    if (IsDisconnected())
    {
        DBGMSG((DBGMOD_NETSESSION,
                DBGLVL_TRACE,
                _T("Session %ls is disconnected. Reque the packet and don't send any more message on this session"),
                                   GetStrAddr()));

        //
        // The session is disconnected. return the packet to the driver
        // and don't get a new packet for sending on this session. All
        // the queues move latter to nonactive group and rerouted using
        // a new session.
        //
        RequeuePacket(pPkt);
        delete pPkt;

        return MQ_OK;
    }

    if (pPkt->GetHopCount() >= HOP_COUNT_EXPIRATION &&
       !(pPkt->IsOrdered() && QmpIsLocalMachine(pPkt->GetSrcQMGuid())))
    {
        ASSERT(pPkt->GetHopCount() == HOP_COUNT_EXPIRATION);

        ACFreePacket(
            g_hAc,
            pPkt->GetPointerToDriverPacket(),
            MQMSG_CLASS_NACK_HOP_COUNT_EXCEEDED
            );
        delete pPkt;

        //
        // Get the next message for sending on the session. Generally, MSMQ requests the
        // next message for sending only after completed the sending of current message.
        // In this case the message isn't sent, therefor the next message for sending
        // requested now
        //
        GetNextSendMessage();
        return MQ_OK;
    }

    try
    {
        BOOL fHopCountRetry = (pPkt->GetHopCount() >= HOP_COUNT_RETRY);
        CQueue* pQueue = NULL;

        //
        // Handle Hop count retry in two steps. First we found the relevant
        // queue object, and second after sending the packet we mark the queue
        // and move it to waiting state. We do in this way since the packet can be
        // deleted during the sending or after when getting the acknowledge. In such
        // a case we got GF when trying to retreive the queue object
        //

        if (fHopCountRetry)
        {
            //
            // Find the queue object
            //
            QUEUE_FORMAT DestinationQueue;
            BOOL fSuccess;
            BOOL fLocalSource = QmpIsLocalMachine(pPkt->GetSrcQMGuid());

            pPkt->GetDestinationQueue(&DestinationQueue, !fLocalSource);
            fSuccess = QueueMgr.LookUpQueue(&DestinationQueue,
                                            &pQueue,
                                            false,
                                            false);
            ASSERT(fSuccess);
        }

        SetUsedFlag(TRUE);
        NetworkSend(pPkt);

        if (fHopCountRetry)
        {
            ASSERT(pQueue);

            pQueue->SetHopCountFailure(TRUE);
            //
            // Move queue from session group to Non active group
            //
            CQGroup::MoveQueueToGroup(pQueue, g_pgroupNonactive);

            //
            // Decrement the reference count
            //
            pQueue->Release();
        }
    }

    catch(const bad_alloc&)
    {
        //
        // We could not send the packet
        // return the packet to the sender
        //
        RequeuePacket(pPkt);
        delete pPkt;

        Close_Connection(this, L"Exception in CSockTransport::Send");
        return LogHR(MQ_ERROR, s_FN, 60);
    }

    return MQ_OK;

}

/*====================================================

CSockTransport::NeedAck

Arguments:

Return Value:

Thread Context: Session

=====================================================*/
void CSockTransport::NeedAck(CQmPacket* pPkt)
{
    CS lock(m_cs);

    if (m_sock == 0)
    {
        //
        // The session close. MSMQ doesn't get an acknowledge for the
        // message. return it to the queue
        //
        ASSERT(GetSessionStatus() == ssNotConnect);
        RequeuePacket(pPkt);
        delete pPkt;
    }

    //
    // Add the packet to the list of unacknowledged packets
    //
    m_listUnackedPkts.AddTail(pPkt);
    DBG_MSGTRACK(DBGMOD_QMACK, pPkt, _T("READACK: Added message to list in NeedAck"));
    DBGMSG((DBGMOD_QMACK, DBGLVL_TRACE, TEXT("Window size, My = %d, Other = %d"), SessionMgr.GetWindowSize(),m_wRecvWindowSize));

    if (!m_fCheckAckReceivedScheduled)
    {
        //
        // Increment Session referance count for the CheckForAck. we don't want to free the
        // session while all the scheduling routines are not completed.
        //
        AddRef();

        ExSetTimer(&m_CheckAckReceivedTimer, CTimeDuration::FromMilliSeconds(m_dwAckTimeout));
        m_fCheckAckReceivedScheduled = TRUE;
    }
}

/*====================================================

CSockTransport::IncReadAck

Arguments:

Return Value:

Thread Context: Session

=====================================================*/
void CSockTransport::IncReadAck(CQmPacket* pPkt)
{
    //
    // Mark the session as alive.
    //
    m_fRecvAck = TRUE;
    //
    // Increment the number of packet on session
    //
    WORD wAckNo = m_wUnAckRcvPktNo + 1;
    if (wAckNo == 0)
    {
        wAckNo++;
    }
    pPkt->SetAcknowldgeNo(wAckNo);

    //
    // Increment storage packet number
    //
    if (pPkt->IsRecoverable())
    {
        m_wUnackStoredPktNo++;
        if (m_wUnackStoredPktNo == 0)
        {
            m_wUnackStoredPktNo++;
        }

        //
        // We keep the number on the packet such when the storage is completed we
        // can return storage ack to the sender
        //
        pPkt->SetStoreAcknowldgeNo(m_wUnackStoredPktNo);

        //
        // Increement the number of recoverable packet that were received but
        // didn't ack yet
        //

        LONG PrevVal = InterlockedIncrement(&m_lStoredPktReceivedNoAckedCount);
        ASSERT(PrevVal >= 0);
        DBG_USED(PrevVal);

        DBGMSG((DBGMOD_QMACK,
                DBGLVL_TRACE,
                _T("(0x%p %ls) Storage Ack 0x%x. No of Recover receove packet: %d"),
                    this, this->GetStrAddr(), m_wUnackStoredPktNo, m_lStoredPktReceivedNoAckedCount));
    }
    else
    {
        pPkt->SetStoreAcknowldgeNo(0);
    }

    #ifdef _DEBUG
    {
        OBJECTID MessageId;
        pPkt->GetMessageId(&MessageId);

        DBGMSG((
            DBGMOD_QMACK,
            DBGLVL_TRACE,
            _T("Acknowledge Number for  packet ") _T(LOG_GUID_FMT) _T("\\%u are: Session Ack %u, StorageAck %u"),
            LOG_GUID(&MessageId.Lineage),
            MessageId.Uniquifier,
            wAckNo,
            m_wUnackStoredPktNo
            ));

    }
    #endif

    DBGMSG((DBGMOD_QMACK, DBGLVL_INFO, TEXT("Window size, My = %d, Other = %d"), SessionMgr.GetWindowSize(),m_wRecvWindowSize));

    //
    //  if we return back to zero or Window limit has reached,
    //  send the session acks now
    //
    if (GetRecvUnAckPacketNo() >= (m_wRecvWindowSize/2))
    {
        DBGMSG((DBGMOD_QMACK,
                DBGLVL_WARNING,
                _TEXT("Unacked packet no. reach the limitation (%d). ACK packet was sent"), m_wRecvWindowSize));
        DBGMSG((DBGMOD_QMACK, DBGLVL_TRACE, TEXT("Window size, My = %d, Other = %d"), SessionMgr.GetWindowSize(),m_wRecvWindowSize));
        SendReadAck(eStandAlone);
    }
}

/*====================================================

CSockTransport::SetStoredAck

Arguments:

Return Value:

Thread Context: Session

=====================================================*/

void CSockTransport::SetStoredAck(DWORD_PTR wStoredAckNo)
{
    CS lock(m_cs);
    DBGMSG((DBGMOD_QMACK, DBGLVL_INFO,
         _TEXT("SetStoreAck - Enter: param wStoredAckNo=0x%Ix, data m_wAckRecoverNo=%u"), wStoredAckNo, (DWORD)m_wAckRecoverNo));

    if (m_sock == 0)
        return;

    //
    // Indicates that need to send an  acknowledge
    //
    m_fSendAck = TRUE;

    if ((m_wAckRecoverNo != 0) &&
        ((wStoredAckNo - m_wAckRecoverNo) > STORED_ACK_BITFIELD_SIZE))
    {
        //
        // There is no place in storage bit field to set acknowledge information.
        // Previous Stored Ack should be sent before the new value can be set
        //
        DBGMSG((DBGMOD_QMACK, DBGLVL_INFO,
             _TEXT("SetStoreAck- No place in storage bitfield")));

        SendReadAck(eStandAlone);
        ASSERT(m_wAckRecoverNo == 0);
    }

    if (m_wAckRecoverNo == 0)
    {
        //
        // Bit field must be zero if the base naumber is not set
        //
        ASSERT(m_dwAckRecoverBitField == 0);

        m_wAckRecoverNo = DWORD_TO_WORD(DWORD_PTR_TO_DWORD(wStoredAckNo));
        DBGMSG((DBGMOD_QMACK, DBGLVL_TRACE,
             _TEXT("SetStoreAck- Set Recover base number m_wAckRecoverNo = %ut"), (DWORD)m_wAckRecoverNo));

        //
        // try to cancel send acknowledge timer, and set a new one with shorter period.
        // If cancel failed, it means that the scheduler is already expired. In such a case
        // only set a new timer
        //
        if (!ExCancelTimer(&m_SendAckTimer))
        {
            ++m_nSendAckSchedules;
            AddRef();
        }

        m_fSendAck = TRUE;

        ExSetTimer(&m_SendAckTimer, CTimeDuration::FromMilliSeconds(m_dwSendStoreAckTimeout));
        return;
    }

    ASSERT(STORED_ACK_BITFIELD_SIZE >= (wStoredAckNo - m_wAckRecoverNo));

    m_dwAckRecoverBitField |= (1 << (wStoredAckNo - m_wAckRecoverNo -1));
    DBGMSG((DBGMOD_QMACK, DBGLVL_TRACE,
        _TEXT("SetStoreAck- Storage ack. Base %ut, BitField %xh"),
                            m_wAckRecoverNo, m_dwAckRecoverBitField));
}

/*====================================================

CSockTransport::UpdateAcknowledgeNo

Arguments:

Return Value:

Thread Context: Session

=====================================================*/
void
CSockTransport::UpdateAcknowledgeNo(IN CQmPacket* pPkt)
{
    //
    // Increment the packet no. on the session
    //
    m_wSendPktCounter++;
    if (m_wSendPktCounter == 0)
    {
        m_wPrevUnackedSendPkt = INIT_UNACKED_PACKET_NO;
        m_wSendPktCounter++;
    }
    pPkt->SetAcknowldgeNo(m_wSendPktCounter);

    if (pPkt->IsRecoverable())
    {
        m_wStoredPktCounter++;
        if (m_wStoredPktCounter == 0)
        {
            ++m_wStoredPktCounter;
        }
        pPkt->SetStoreAcknowldgeNo(m_wStoredPktCounter);
    }

    DBGMSG((DBGMOD_QMACK,
            DBGLVL_TRACE,
            _TEXT("Update Acknowledge Numbers. m_wSendPktCounter %d , m_wStoredPktCounter %d"), m_wSendPktCounter,m_wStoredPktCounter));

}

/*====================================================

IsValidAcknowledge

    The function returnes TRUE if the received acknowledge number
    is valid. FALSE otherwise.

Arguments:
    listUnackedPkts - list of un-acked packets
    wAckNumber - Received acknowledge number

Return Value: TRUE is valid, FALSE otherwise

=====================================================*/
BOOL IsValidAcknowledge(CList<CQmPacket *, CQmPacket *&> & listUnackedPkts,
                        WORD wAckNumber)
{
    BOOL fRet = FALSE;

    if (!listUnackedPkts.IsEmpty())
    {
        //
        // Get the Acknowledge number of the first packet and of the last
        // packet.
        //
        WORD wStartAck = (listUnackedPkts.GetHead())->GetAcknowladgeNo();
        WORD wEndAck = (listUnackedPkts.GetTail())->GetAcknowladgeNo();

        if (wEndAck >= wStartAck)
        {
            fRet = (wAckNumber >= wStartAck) && (wEndAck >= wAckNumber);
        }
        else
        {
            fRet = (wAckNumber >= wStartAck) || (wEndAck >= wAckNumber);
        }

        DBGMSG((DBGMOD_QMACK,
                DBGLVL_TRACE,
                _TEXT("IsValidAcknowledge:: Start %d, End %d, Ack No. %d, IsValid %d"), wStartAck, wEndAck, wAckNumber, fRet));
    }
    return fRet;
}

/*====================================================

CSockTransport::HandleAckPacket

Arguments:

Return Value:

Thread Context: Session

=====================================================*/

void CSockTransport::HandleAckPacket(CSessionSection * pcSessionSection)
{
    CQmPacket* pPkt;
    POSITION  posInList;
    POSITION  posCurrent;

    CS lock(m_cs);

    //
    // if session sending was susspended utill
    // receiving an ack, resume it.
    //
    if (m_fSessionSusspended)
    {
        HRESULT rc;

        rc = ResumeSendSession();
        if (FAILED(rc))
        {
            return;
        }
    }

    //
    // Get Synchronization Numbers
    //
    WORD wSyncAckSequenceNo, wSyncAckRecoverNo;

    pcSessionSection->GetSyncNo(&wSyncAckSequenceNo,
                                &wSyncAckRecoverNo);
    //
    // Print debug information
    //
    DBGMSG((DBGMOD_QMACK,
            DBGLVL_WARNING,
            _T("ACKINFO: Get Acknowledge packet from %ls. (time %d) \
               \n\t\tm_wAckSequenceNo %d\n\t\tm_wAckRecoverNo %d\n\t\tm_wAckRecoverBitField 0x%x\n\t\tm_wSyncAckSequenceNo %d\n\t\tm_wSyncAckRecoverNo %d\n\t\tm_wWinSize %d\n\t\t"),
              GetStrAddr(),
              GetTickCount(),
              pcSessionSection->GetAcknowledgeNo(),
              pcSessionSection->GetStorageAckNo(),
              pcSessionSection->GetStorageAckBitField(),
              wSyncAckSequenceNo,
              wSyncAckRecoverNo,
              pcSessionSection->GetWindowSize()));

    DBGMSG((DBGMOD_NETSESSION,
            DBGLVL_TRACE,
            TEXT("Get Acknowledge packet from %ls"), GetStrAddr()));

    //
    // Synchronization check
    //
    if (!IsDisconnected())
    {
        if ((wSyncAckSequenceNo != m_wUnAckRcvPktNo) ||
            (wSyncAckRecoverNo != m_wUnackStoredPktNo))
        {
            DBGMSG((DBGMOD_QMACK,
                    DBGLVL_ERROR,
                    _TEXT("SyncAckSequenceNo: Expected - %u Received - %u"),m_wUnAckRcvPktNo,wSyncAckSequenceNo));
            DBGMSG((DBGMOD_QMACK,
                    DBGLVL_ERROR,
                    _TEXT("SyncAckRecoverNo: Expected - %u Received - %u"), m_wUnackStoredPktNo,wSyncAckRecoverNo));
            Close_Connection(this, L"Un-synchronized Acknowledge number");
            return;
        }
    }
    //
    // Update the other side window size
    //
#ifdef _DEBUG
    if (m_wRecvWindowSize != pcSessionSection->GetWindowSize())
    {
        DBGMSG((DBGMOD_QMACK,
                DBGLVL_TRACE,
                _TEXT("Update SenderWindowSize. The new Window Size: %d"),pcSessionSection->GetWindowSize()));

    }
#endif

	if (pcSessionSection->GetWindowSize() == 0)
	{
        DBGMSG((DBGMOD_QMACK,
                DBGLVL_ERROR,
                _TEXT("Ack Packet is not valid, Window size is 0")));
		ASSERT_BENIGN(("Ack Packet is not valid",0));
		throw exception();
	}
    m_wRecvWindowSize = pcSessionSection->GetWindowSize();

    //
    // Look for the packet in the list of unacknowledged packets
    //
    DBGMSG((DBGMOD_QMACK,
            DBGLVL_WARNING,
            TEXT("READACK: Looking for %u in Express unAcked packet list"), pcSessionSection->GetAcknowledgeNo()));

    if (IsValidAcknowledge(m_listUnackedPkts, pcSessionSection->GetAcknowledgeNo()))
    {
        WORD wPktAckNo;

        posInList = m_listUnackedPkts.GetHeadPosition();
        do
        {
            if (posInList == NULL)
            {
                //
                // BUGBUG: after RTM it should be removed
                //
                ASSERT(posInList);
                break;
            }

            posCurrent = posInList;
            pPkt = m_listUnackedPkts.GetNext(posInList);
            wPktAckNo = pPkt->GetAcknowladgeNo();
            //
            // Remove the packet from the list
            //
            m_listUnackedPkts.RemoveAt(posCurrent);

            DBG_MSGTRACK(DBGMOD_QMACK, pPkt, _T("READACK: Removed message in PktAcked"));
            DBGMSG((DBGMOD_QMACK, DBGLVL_TRACE, TEXT("READACK: %d Packet have not been acked yet"), GetSendUnAckPacketNo()));
            DBGMSG((DBGMOD_QMACK, DBGLVL_TRACE, TEXT("Window size, My = %d, Other = %d"), SessionMgr.GetWindowSize(),m_wRecvWindowSize));

            if (pPkt->IsRecoverable())
            {
                if ( pPkt->IsOrdered() && QmpIsLocalMachine(pPkt->GetSrcQMGuid()))
                {
                    //
                    // Ordered packet on the sender node: resides in a separate list in COutSeq
                    //
                    DBG_MSGTRACK(DBGMOD_QMACK,
                                 pPkt, _T("READACK: Added message in NeedAck to Transaction list waiting to order ack"));
                    g_OutSeqHash.PostSendProcess(pPkt);
                }
                else
                {
                    DBG_MSGTRACK(DBGMOD_QMACK, pPkt, _T("READACK: Added message to Storage list in NeedAck"));
                    m_listStoredUnackedPkts.AddTail(pPkt);
                }
            }
            else
            {
                //
                // Update the duplicate message map. For FRS, we want to allow getting
                // a duplicate message in order to try alternative route
                //
                DpRemoveMessage(*pPkt);

                ACFreePacket(g_hAc, pPkt->GetPointerToDriverPacket());
                delete pPkt;
            }

        }
        while (wPktAckNo != pcSessionSection->GetAcknowledgeNo());
    }
    else
    {
        DBGMSG((DBGMOD_QMACK,
                DBGLVL_TRACE, TEXT("READACK: Out of order Ack Packet - O.K")));
    }
    //
    // Handle Storage Ack
    //
    WORD wBaseAckNo = pcSessionSection->GetStorageAckNo();
    if ( wBaseAckNo != 0)
    {
        DBGMSG((DBGMOD_QMACK,
                DBGLVL_WARNING,
                TEXT("READACK: Looking for  Storage Ack. Base %u,  BitField %x"),pcSessionSection->GetStorageAckNo(), pcSessionSection->GetStorageAckBitField()));

        posInList = m_listStoredUnackedPkts.GetHeadPosition();
        int  i = 0;

        while (posInList != NULL)
        {
            posCurrent = posInList;
            pPkt = m_listStoredUnackedPkts.GetNext(posInList);

            DBG_MSGTRACK(DBGMOD_QMACK, pPkt,
                      _T("HandleAckPacket: Next packet to analyze")) ;

			//
			// Here we treat the case when wBaseAckNo is less than pPkt->GetStoreAcknowledgeNo()
			// It can happen if there was transacted message not entering the list of waiters for the storage ack
			//
            // Calculate the next Acking Packet number
            //
            while (wBaseAckNo < pPkt->GetStoreAcknowledgeNo() && (i < STORED_ACK_BITFIELD_SIZE))
            {
                if (pcSessionSection->GetStorageAckBitField() & (1 << i))
                {
                    wBaseAckNo = numeric_cast<WORD>
                                (pcSessionSection->GetStorageAckNo()+i+1) ;

				    if (wBaseAckNo >= pPkt->GetStoreAcknowledgeNo())
				    {
				 	   break;
				    }
                }
			    i++;
            }

            DBGMSG((DBGMOD_QMACK, DBGLVL_INFO,
             TEXT("HandleAckPacket: next storage ack to analyze: %u (i=%d) in Storage PktAcked"), wBaseAckNo, i ));

            if (wBaseAckNo == pPkt->GetStoreAcknowledgeNo())
            {

                DBG_MSGTRACK(DBGMOD_QMACK, pPkt, _T("READACK: Removed message in Storage PktAcked"));

                m_listStoredUnackedPkts.RemoveAt(posCurrent);

                //
                // Packet was sent successfully to the next hop
                // Deleting packet, except of the ordered packet on the source node
                //

                if ( !(pPkt->IsOrdered() && QmpIsLocalMachine(pPkt->GetSrcQMGuid())))
                {

					DBG_MSGTRACK(DBGMOD_QMACK, pPkt,
                             _T("HandleAckPacket: ACFreePacket")) ;

                    //
                    // Update the duplicate message map. For FRS, we want to allow getting
                    // a duplicate message in order to try alternative route
                    //
                    DpRemoveMessage(*pPkt);

                    ACFreePacket(g_hAc, pPkt->GetPointerToDriverPacket());
                    delete pPkt;
                }
            }
        }
    }
}

/*====================================================

CSockTransport::CheckForAck

Arguments:

Return Value:

Thread Context: Scheduler

=====================================================*/
void CSockTransport::CheckForAck()
{
    POSITION  posInList;
    CQmPacket* pPkt;

    CS lock(m_cs);

    ASSERT(m_fCheckAckReceivedScheduled);
    m_fCheckAckReceivedScheduled = FALSE;

    if (m_sock == 0)
    {
        //
        // Connection already closed. Decrement Session refernce count
        //
        Release();
        return;
    }

    DBGMSG((DBGMOD_QMACK,
            DBGLVL_TRACE,
            TEXT("CHECKFORACK: m_fRecvAck = %d (time %ls, %d)"), m_fRecvAck, _tstrtime(tempBuf), GetTickCount()));
    //
    // Check if there are any packets waiting for acknowledgment
    //
    posInList = m_listUnackedPkts.GetHeadPosition();
    if (posInList != NULL)
    {
        //
        // If no sent packets have been acknowledged during the lifespan
        // of the timer, the session is no longer valid
        //
        pPkt = m_listUnackedPkts.GetNext(posInList);
        //
        // Ack number cant be zero. We take to it when the the Acknowledge number is round.
        //
        ASSERT(pPkt->GetAcknowladgeNo());
        if ((m_wPrevUnackedSendPkt == pPkt->GetAcknowladgeNo()) && !m_fRecvAck)
        {
            DBGMSG((DBGMOD_QMACK,
                    DBGLVL_TRACE,
                    TEXT("CHECKFORACK: Packet on session %ls have not been acknowledged. \n\t \
                         Last Unacked %u. Current Packet number %u (time %ls)"),GetStrAddr(), m_wPrevUnackedSendPkt, pPkt->GetAcknowladgeNo(), _tstrtime(tempBuf)));
            DBGMSG((DBGMOD_QMACK, DBGLVL_TRACE, TEXT("Window size, My = %d, Other = %d"), SessionMgr.GetWindowSize(),m_wRecvWindowSize));

            Close_Connection(this, L"Packet have not been acknowledged");
            Release();

            return;
        }
    }

    //
    // Mark the session as non receive ack
    //
    m_fRecvAck = FALSE;

    //
    // Store the ID of the first unacknowledged packet in the list
    //
    if (!m_listUnackedPkts.IsEmpty())
    {
        posInList = m_listUnackedPkts.GetHeadPosition();
        pPkt = m_listUnackedPkts.GetNext(posInList);
        m_wPrevUnackedSendPkt = pPkt->GetAcknowladgeNo();

        //
        // There is another message that wait for acknowledge. Restart the timer to check for
        // acknowledgments
        //
        ExSetTimer(&m_CheckAckReceivedTimer, CTimeDuration::FromMilliSeconds(m_dwAckTimeout));
        m_fCheckAckReceivedScheduled = TRUE;
    }
    else
    {
        m_wPrevUnackedSendPkt = INIT_UNACKED_PACKET_NO;

        //
        // There is no more messages that wait for ack. Don't reschedule checkAck
        //
        Release();
    }

    DBGMSG((DBGMOD_QMACK,
            DBGLVL_WARNING,
            TEXT("ACKINFO: Set the m_wPrevUnackedSendPkt on session %ls to  %d. (time %d)"),GetStrAddr(), m_wPrevUnackedSendPkt, GetTickCount()));

}

/*====================================================

CTransportBase::AddQueueToSessionGroup

Arguments: pQueue - Pointer to queue object

Return Value: None. Throws an exception.

Thread Context:

=====================================================*/
void CTransportBase::AddQueueToSessionGroup(CQueue* pQueue) throw(bad_alloc)
{
    CS lock(m_cs);

    if (m_SessGroup == NULL) {
        //
        // Create a new group
        //
        m_SessGroup = new CQGroup;
        try
        {
            m_SessGroup->InitGroup(this, TRUE);
        }
        catch (const bad_alloc&)
        {
            //
            // Creation of new group for the session failed. Move the queue
            // to waiting group, such the QM doesn't try immediately to create
            // a new session and close the connection
            //
            pQueue->SetSessionPtr(NULL);
            CQGroup::MoveQueueToGroup(pQueue, g_pgroupWaiting);
            SessionMgr.AddWaitingQueue(pQueue);
            //
            // Close the session
            //
            Close_Connection(this, L"Creation of new group failed");

            LogIllegalPoint(s_FN, 780);
            return;
        }
        //
        // If the session is not active yet, don't create a get request. We do it
        // later when the session establishment connection is completed
        //
        if (GetSessionStatus() == ssActive)
        {
            //
            // Create a get request from new group. It will decrement on qmthrd
            // when the session is closed, or the session is suspended. (no new
            // get request is produced)
            //
            HRESULT hr = GetNextSendMessage();
            ASSERT(SUCCEEDED(hr));
            LogHR(hr, s_FN, 182);
        }
    }

    CQGroup::MoveQueueToGroup(pQueue, m_SessGroup);

    //
    // If the seeion is active we succeeded to get a session to the queue
    // and therfore we clear the rety index. If the session has not been established
    // don't clear it until the session becomes active
    //
    if (GetSessionStatus() == ssActive)
    {
        pQueue->ClearRoutingRetry();
    }

}

/*====================================================
=====================================================*/

#define HDR_READ_STATE              1
#define USER_HEADER_MSG_READ_STATE  2
#define USER_MSG_READ_STATE         3
#define READ_ACK_READ_STATE         4

#define BASE_PACKET_SIZE 1024
#define MAX_WRITE_SIZE  (16*1024)


VOID WINAPI CSockTransport::SendDataFailed(EXOVERLAPPED* pov)
{
    long rc = pov->GetStatus();
    DBG_USED(rc);

    ASSERT((rc == STATUS_CANCELLED) ||
           (rc ==  STATUS_NETWORK_NAME_DELETED)  ||
           (rc ==  STATUS_LOCAL_DISCONNECT)      ||
           (rc ==  STATUS_REMOTE_DISCONNECT)     ||
           (rc ==  STATUS_ADDRESS_CLOSED)        ||
           (rc ==  STATUS_CONNECTION_DISCONNECTED) ||
           (rc ==  STATUS_CONNECTION_RESET)      ||
           (GetBytesTransfered(pov) == 0));

    DBGMSG((DBGMOD_QM, DBGLVL_WARNING, L"%x: SendData FAILED, Error %ut. time %d",GetCurrentThreadId(), rc, GetTickCount()));

    P<QMOV_WriteSession> ps = CONTAINING_RECORD (pov, QMOV_WriteSession, qmov);

    //
    // Clean up - If user packet requeuing it to the original queue
    // and delete the CQmPacket structure. Otherwise remove the temporary
    // Buffer.
    //
    if (ps->fUserMsg)
    {
        if (ps->fEncryptedMsg)
        {
            //
            // delete the temporary buffer used for encryption
            //
            delete ps->lpWriteBuffer;
        }
    }
    else
    {
        delete ps->lpBuffer;
    }


    Close_Connection(ps->pSession, L"Write packet to socket Failed");

    //
    // decrement session refernce count
    //
    (ps->pSession)->Release();
}


VOID WINAPI CSockTransport::SendDataSucceeded(EXOVERLAPPED* pov)
{
    ASSERT(SUCCEEDED(pov->GetStatus()));
    if (GetBytesTransfered(pov) == 0)
    {
        SendDataFailed(pov);
        return;
    }

    DBGMSG((DBGMOD_QM, DBGLVL_INFO, L"%x: SendData Succeeded. time %d", GetCurrentThreadId(), GetTickCount()));

    QMOV_WriteSession* ps = CONTAINING_RECORD (pov, QMOV_WriteSession, qmov);

    (ps->pSession)->WriteCompleted(ps);
}


/*====================================================

CSockTransport::WriteCompleted()

Arguments:

Return Value:

Thread Context: Session

Asynchronous write completion routine.
Called when some bytes are written into a socket. This routine
is actually a state machine. Waiting for all the bytes from a
certain state to be written, and then upon the current state deciding
what to do next.

=====================================================*/

void
CSockTransport::WriteCompleted(
    QMOV_WriteSession* po
    )
{
    ASSERT(po != NULL);

    CSockTransport* pSess = po->pSession;
    DWORD cbTransferred = GetBytesTransfered(&po->qmov);

    //
    //  we've Written to the socket. Mark the session in use
    //
    SetUsedFlag(TRUE);

    po->dwWrittenSize += cbTransferred;
    ASSERT(po->dwWrittenSize <=  po->dwWriteSize);

    //
    // Update the outgoing bytes number.
    // We need to check that there is a valid Static buffer
    //
    {
        //
        // bug 5480.
        // m_pStats can be released in ::CloseConnection.
        // so protect it with m_cs.
        // Note that a critical section here doesn't really change
        // threads timing dramatically, as same critical section is
        // is used in WriteUserMsgCompleted() too.
        //
        CS lock(m_cs);
        if ((m_pStats.get() != NULL) && po->fUserMsg)
        {
            m_pStats->UpdateBytesSent(cbTransferred);
        }
    }

    //
    // Check if we wrote all the expected data
    //

    DBGMSG((DBGMOD_NETSESSION,
            DBGLVL_INFO,
            _T("Write to socket %ls Completed. Wrote %d bytes"),GetStrAddr(), po->dwWrittenSize));

    if(po->dwWrittenSize ==  po->dwWriteSize)
    {
        //
        // Write was completely.
        //
        if (po->fUserMsg)
        {
            ASSERT(po->fFreeSemaphore || po->fEncryptedMsg);
            //
            // Call write completion routine
            //
            bool fOvlInUse;
            if (po->fEncryptedMsg)
            {
                fOvlInUse = WriteEncryptedMsgCompleted(static_cast<QMOV_EncryptedWriteSession*>(po));
            }
            else
            {
                fOvlInUse = WriteUserMsgCompleted(po);
            }

            if (!fOvlInUse && po->fFreeSemaphore )
            {
                ReleaseSendSemaphore();
                delete po;
            }
        }
        else
        {
            if (po->fFreeSemaphore)
            {
                ReleaseSendSemaphore();
            }
            delete po->lpBuffer;
            delete po;
        }

        pSess->Release();
        return;
    }

    HRESULT hr = WriteToSocket(po);
    if (SUCCEEDED(hr))
        return;

    //
    // write to socket failed ==> close of session ==> requeue the packet
    //
    ASSERT(m_sock == 0);

    if (po->fUserMsg)
    {
        if (po->fEncryptedMsg)
        {
            //
            // delete the temporary buffer used for encryption
            //
            delete po->lpWriteBuffer;
        }
    }
    else
    {
        delete po->lpBuffer;
    }
    delete po;
}


bool
CSockTransport::WriteEncryptedMsgCompleted(
    QMOV_EncryptedWriteSession* peo
    )
{
    CS lock(m_cs);

    ASSERT(peo->fUserMsg);

    HRESULT hr;

    if (peo->dwEncryptedWriteSize)
    {
        if (m_sock == 0)
        {
            //
            // The session has been closed and the packet was returned to the queue.
            // In such a case the CQmPacket was deleted, so don't try to access it
            //
            hr = MQ_ERROR;
        }
        else
        {
            hr = WriteEncryptedBody(peo);
        }

        if(SUCCEEDED(hr))
            return true;

        //
        // send encrypted buffer failed. The session should be closed
        //
        ASSERT(m_sock == 0);
        delete peo->lpWriteBuffer;
        peo->fFreeSemaphore = TRUE;
        return false;
    }

    //
    // All the packet send, delete the temporary buffer used for writing the encrypted
    // packet
    //
    delete peo->lpWriteBuffer;

    //
    // Complete to write the encrypted message.
    //
    peo->fFreeSemaphore = TRUE;

    //
    // All the message body ecrypted and send successfully. Check if there is an
    // extra data that should be sent
    //
    CQmPacket* pPkt = reinterpret_cast<CQmPacket*>(peo->lpBuffer);
    if (pPkt->IsDbgIncluded())
    {
        ASSERT(peo->lpDebugSectionBuf == NULL);

        //
        // Get pointer to debug section
        //
        UCHAR* pDebug = pPkt->GetPointerToDebugSection();
        ASSERT(("Debug section must exist", pDebug != NULL));

        DWORD dwSize = pPkt->GetSize() - DWORD_PTR_TO_DWORD(pDebug - (const UCHAR*)pPkt->GetPointerToPacket());

        peo->lpWriteBuffer = pDebug;
        peo->dwWriteSize = dwSize;
        peo->dwWrittenSize = 0;
        peo->fEncryptedMsg = FALSE;

        //
        // Increment Session Refernce Cont. The reference count is decrement on WriteCompleted.
        //
        AddRef();
        hr = WriteToSocket(peo);

        if (SUCCEEDED(hr))
        {
            return true;
        }

        //
        // send encrypted buffer failed. The session should be closed
        //
        ASSERT(m_sock == 0);
        return false;
    }


    //
    // Complete the handling of sending message, send debug section and acknowledge
    //
    return WriteUserMsgCompleted(peo);
}


/*====================================================

CSockTransport::WriteUserMsgCompleted

Arguments:
    po - address of structure with I/O information

Return Value: true if asyncronus operation started with the given overlapp.
              (caller should keep this overllap alive !!) false otherwise
              (caller can free the overllap)

Thread Context: Session

Asynchronous completion routine. Called when Send is completed.

=====================================================*/
bool CSockTransport::WriteUserMsgCompleted(IN QMOV_WriteSession* po)
{
    CS lock(m_cs);

    ASSERT(po->fUserMsg);

    //
    // Send Debug Section
    //
    HRESULT hr = MQ_OK;
    if (po->lpDebugSectionBuf)
    {
        CDebugSection* pDebug = po->lpDebugSectionBuf;

        DWORD dwWriteSize = DWORD_PTR_TO_DWORD(pDebug->GetNextSection() - (PCHAR)pDebug);

        DBGMSG((DBGMOD_NETSESSION,
                DBGLVL_INFO,
                _T("Write to socket %ls Debug section. Write %d bytes"), GetStrAddr(), dwWriteSize));
        hr = CreateSendRequest(pDebug,
                               pDebug,
                               dwWriteSize,
                               FALSE,                 // don't free send event
                               FALSE,                // fUserMsg
                               po->fSendAck);        // fSendAck
    }

    if (po->fSendAck && SUCCEEDED(hr))
    {
        SendReadAck(ePigyback);
    }

    //
    // Send Report message if needed. First check that the session
    // wasn't closed.
    //
    if (GetSessionStatus() == ssActive)
    {
        TCHAR szAddr[30];

        TA2StringAddr(GetSessionAddress(), szAddr);
        m_MsgInfo.SendReportMessage(szAddr);
    }

    //
    // Update performance counters
    //
    if (m_pStats.get() != NULL)
    {
        m_pStats->UpdateMessagesSent();
    }

    if (!IsSusspendSession())
    {
        //
        // Create a get request from group
        //
        DBGMSG((DBGMOD_NETSESSION,
               DBGLVL_TRACE,
               _TEXT("Session Get new message from group 0x%p. (time %ls)"), GetGroupHandle(),  _tstrtime(tempBuf)));
        hr = GetNextSendMessage();
    }
    else
    {
        DBGMSG((DBGMOD_NETSESSION,
                DBGLVL_WARNING,
                _TEXT("Session to %ls was suspended due max unacked packet. (time %ls)"), GetStrAddr(),  _tstrtime(tempBuf)));
    }
    return false;
}


void CSockTransport::ReportErrorToGroup()
{
	CS lock(m_cs);

    CQGroup* pGroup = GetGroup();
	if(pGroup == NULL)
		return;

	pGroup->OnRetryableDeliveryError();
}


HRESULT CSockTransport::WriteToSocket(QMOV_WriteSession* po)
{
    SetUsedFlag(TRUE);

    DWORD dwWrites = min((po->dwWriteSize - po->dwWrittenSize), MAX_WRITE_SIZE);
    DWORD dwNoBytesWritten;

    DBGMSG((DBGMOD_NETSESSION,
            DBGLVL_INFO,
            TEXT("Write %d bytes to Session %ls"), dwWrites,(po->pSession)->GetStrAddr()));

    BOOL fSucc = WriteFile(
                    (HANDLE) m_sock,
                    (PUCHAR) po->lpWriteBuffer + po->dwWrittenSize,
                    dwWrites,
                    &dwNoBytesWritten,
                    &po->qmov
                    );
    //
    // Check if the connection has been closed
    //
    DWORD dwErrorCode;
    if (!fSucc && ((dwErrorCode = GetLastError()) != ERROR_IO_PENDING))
    {

        ASSERT((dwErrorCode == ERROR_OPERATION_ABORTED)   ||
               (dwErrorCode == ERROR_NETNAME_DELETED)     ||
               (dwErrorCode == ERROR_INVALID_HANDLE)      ||
               (dwErrorCode == ERROR_NO_SYSTEM_RESOURCES) ||
               (dwErrorCode == WSAECONNRESET)             ||  // possible in win95
               (dwErrorCode == WSAENOTSOCK)               ||  // possible in win95
               (dwErrorCode == ERROR_WORKING_SET_QUOTA)   ||
               (dwErrorCode ==  ERROR_BAD_COMMAND)
               );

        LogNTStatus(dwErrorCode, s_FN, 71);

        //
        // Decrement the window size
        //
        if (dwErrorCode == ERROR_NO_SYSTEM_RESOURCES || dwErrorCode == ERROR_WORKING_SET_QUOTA )
        {
            SessionMgr.SetWindowSize(1);
        }

	
        //
        // Close the connection and move the queues to non-active state.
        //
        Close_Connection(this, L"Write on socket failed");
        //
        // Decrement reference count. the reference count is increment before
        // writing to the socket. since the write failed we decrement the
        // refernce count here.
        //
        Release();
        return LogHR(MQ_ERROR, s_FN, 70);
    }

    return MQ_OK;
}

HRESULT
CSockTransport::CreateSendRequest(PVOID                       lpReleaseBuffer,
                                  PVOID                       lpWriteBuffer,
                                  DWORD                       dwWriteSize,
                                  BOOL                        fFreeSemaphore,
                                  BOOL                        fUserMsg,
                                  BOOL                        fSendAck,
                                  CDebugSection*              pDebug
                                )
{
    QMOV_WriteSession* po = NULL;
    HRESULT hr;

    try
    {
        po = new QMOV_WriteSession;
    }
    catch(const bad_alloc&)
    {
        SessionMgr.SetWindowSize(1);
        Close_Connection(this, L"Insufficent resources. Can't issue send request");

        LogIllegalPoint(s_FN, 790);
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 80);
    }

    po->pSession = this;
    po->lpBuffer = lpReleaseBuffer;
    po->lpWriteBuffer = lpWriteBuffer;
    po->dwWrittenSize = 0;
    po->dwWriteSize = dwWriteSize;
    po->fEncryptedMsg = FALSE;
    po->fFreeSemaphore = fFreeSemaphore;
    po->fUserMsg = fUserMsg;
    po->lpDebugSectionBuf = pDebug;
    po->fSendAck = fSendAck;

    //
    // Increment Session Refernce Cont. The reference count is decrement on
    // SendReadAckCompleted or SockSendCompleted, after the write to socket is completed.
    //
    AddRef();
    hr = WriteToSocket(po);


    if (FAILED(hr))
    {
	    delete po;
    }
    return LogHR(hr, s_FN, 100);
}
/*====================================================

  ReadHeaderCompleted

Arguments:     po - pointer to Read Session operation overlapped structure

Return Value:  MQ_ERROR if invalid packet, MQ_OK otherwise

======================================================*/
HRESULT WINAPI CSockTransport::ReadHeaderCompleted(IN QMOV_ReadSession*  po)
{
    CBaseHeader *       pcBaseHeader;
    //
    // We just read the header.
    //
    pcBaseHeader = po->pPacket;

    //
    // Check if packet signature is correct
    //
    try
    {
	    pcBaseHeader->SectionIsValid(QueueMgr.GetMessageSizeLimit());
    }
    catch (const exception&)
    {
        DBGMSG((DBGMOD_NETSESSION,
                DBGLVL_ERROR,
                TEXT("Base header corrupted. Session with %ls. (time %d)"),(po->pSession)->GetStrAddr(), GetTickCount()));


         ASSERT_BENIGN(0);
         //
         // Close the session & decrement session refernce count
         //
         Close_Connection(po->pSession, L"Base header corrupted");
         (po->pSession)->Release();
         return LogHR(MQ_ERROR, s_FN, 110);
     }


    DBGMSG((DBGMOD_NETSESSION,
            DBGLVL_TRACE,
            TEXT("Begin read packet from %ls. Packet Type %d, Packet Size %d"),
            (po->pSession)->GetStrAddr(), pcBaseHeader->GetType(), pcBaseHeader->GetPacketSize()));
    //
    // Check if the packet is a read acknowledgment
    //
    if (pcBaseHeader->GetType() == FALCON_INTERNAL_PACKET)
    {

        //
        // set the packet size should be read
        //
        po->dwReadSize  = pcBaseHeader->GetPacketSize();

        //
        // Check if the current buffer big enough to hold the whole packet
        // If no, allocate a new buffer, copy the packet base header and free
        // the previous buffer
        //
        if  (pcBaseHeader->GetPacketSize() > BASE_PACKET_SIZE)
        {
            po->pbuf = new UCHAR[pcBaseHeader->GetPacketSize()];
            memcpy(po->pbuf,pcBaseHeader,po->read);
            delete [] (UCHAR*)pcBaseHeader;
        }
        //
        // Set the next state to be Read Internal Packet Is completed
        //
        po->lpReadCompletionRoutine = ReadInternalPacketCompleted;
    }
    //
    // Otherwise, the packet contains a user message
    //
    else
    {
        po->dwReadSize = min(BASE_PACKET_SIZE,pcBaseHeader->GetPacketSize());
        po->lpReadCompletionRoutine = ReadUsrHeaderCompleted;
    }

    return MQ_OK;
}

/*====================================================

  ReadInternalPacketCompleted

  Arguments:     po - pointer to Read Session operation overlapped structure

  Return Value:  MQ_ERROR if invalid packet, MQ_OK otherwise

======================================================*/

HRESULT WINAPI CSockTransport::ReadInternalPacketCompleted(IN QMOV_ReadSession*  po)
{
    //
    // Process the internal message
    //
    (po->pSession)->Receive(po->pPacket, po->pDriverPacket);

    delete[] po->pPacket;
    po->pbuf = NULL;

    //
    // Begin to read next packet
    //
    po->lpReadCompletionRoutine = ReadHeaderCompleted;
    po->pbuf = new UCHAR[BASE_PACKET_SIZE];

    po->dwReadSize = sizeof(CBaseHeader);
    po->read = 0;

    return MQ_OK;
}

/*====================================================

  ReadAckCompleted

  Arguments:     po - pointer to Read Session operation overlapped structure

  Return Value:  MQ_ERROR if invalid packet, MQ_OK otherwise

======================================================*/

HRESULT WINAPI CSockTransport::ReadAckCompleted(IN QMOV_ReadSession*  po)
{
    //
    // Process the acknowledgment
    //
    po->pSession->HandleAckPacket( po->pSessionSection);
    delete[] po->pPacket;
    po->pPacket = NULL;

    //
    // Begin to read next packet
    //
    po->lpReadCompletionRoutine = ReadHeaderCompleted;
    po->pbuf = new UCHAR[BASE_PACKET_SIZE];

    po->dwReadSize = sizeof(CBaseHeader);
    po->read = 0;

    return MQ_OK;
}

/*====================================================

  ReadUserMsgCompleted

  Arguments:     po - pointer to Read Session operation overlapped structure

  Return Value:  MQ_ERROR if invalid packet, MQ_OK otherwise

======================================================*/
HRESULT WINAPI CSockTransport::ReadUserMsgCompleted(IN QMOV_ReadSession*  po)
{
    CBaseHeader* pBaseHeader = po->pPacket;
    ASSERT(po->dwReadSize == pBaseHeader->GetPacketSize());

    CUserHeader* pUserHeader = pBaseHeader->section_cast<CUserHeader*>(pBaseHeader->GetNextSection());
    QUEUE_FORMAT DestinationQueue;

    pUserHeader->GetDestinationQueue(&DestinationQueue);

    //
    //  If this packet arrived into the direct destination queue,
    //
    if (DestinationQueue.GetType() == QUEUE_FORMAT_TYPE_DIRECT)
    {
        // Keep sender's address in DestGUID field
        const TA_ADDRESS *pa = (po->pSession)->GetSessionAddress();
        ASSERT(pa->AddressType != FOREIGN_ADDRESS_TYPE &&
              (pa->AddressLength <= sizeof(GUID) - 2*sizeof(USHORT)));

        pUserHeader->SetAddressSourceQM(pa);
    }

    //
    // Check If session section included
    //
    BOOL fSessionIncluded = pBaseHeader->SessionIsIncluded();
    //
    // Clear session included bit. We need it for FRS, since
    // packet is re-sent
    //
    pBaseHeader->IncludeSession(FALSE);
    //
    // Put Packet in AC driver
    //
    (po->pSession)->Receive(pBaseHeader, po->pDriverPacket);
    if (fSessionIncluded) {
        //
        // Begin to read the Session Section
        //
        po->lpReadCompletionRoutine = ReadAckCompleted;
        po->pbuf  = new UCHAR[sizeof(CSessionSection)];
        po->dwReadSize  = sizeof(CSessionSection);
        po->read  = 0;
    } else {
        //
        // Begin to read next packet
        //
        po->lpReadCompletionRoutine = ReadHeaderCompleted;
        po->pbuf = new UCHAR[BASE_PACKET_SIZE];
        po->dwReadSize = sizeof(CBaseHeader);
        po->read = 0;
    }

    return MQ_OK;
}

/*====================================================

  SetAbsoluteTimeToQueue

  Arguments:     pcBaseHeader - pointer to Read BaseHeader section

 The function replace the relative time that send with the packet on the net
 with absolute time.

======================================================*/
void SetAbsoluteTimeToQueue(IN CBaseHeader* pcBaseHeader)
{
    //
    // Set Absolute timeout. Change the relative time to absolute
    //
    DWORD dwTimeout = pcBaseHeader->GetAbsoluteTimeToQueue();

    if(dwTimeout != INFINITE)
    {
        DWORD ulAbsoluteTimeToQueue = MqSysTime() + dwTimeout;
        if(ulAbsoluteTimeToQueue < dwTimeout)
        {
            //
            // Overflow, timeout too large.
            //
            ulAbsoluteTimeToQueue = LONG_MAX;
        }
        ulAbsoluteTimeToQueue = min(ulAbsoluteTimeToQueue,  LONG_MAX);
        pcBaseHeader->SetAbsoluteTimeToQueue(ulAbsoluteTimeToQueue);
    }
}

bool IsDestinationNotificationQueue(QUEUE_FORMAT& DestinationQueue)
{
    //
    // Assumes the queue format structure of a notification queue has
    // a private queue type
    //

    if(DestinationQueue.GetType() != QUEUE_FORMAT_TYPE_PRIVATE)
        return false;

    if(DestinationQueue.PrivateID().Uniquifier != NOTIFICATION_QUEUE_ID)
        return false;

    if(DestinationQueue.PrivateID().Lineage != *CQueueMgr::GetQMGuid())
        return false;

    return true;
}

/*====================================================

  ReadUsrHeaderCompleted

  Arguments:     po - pointer to Read Session operation overlapped structure

  Return Value:  MQ_ERROR if invalid packet, MQ_OK otherwise

======================================================*/
HRESULT WINAPI CSockTransport::ReadUsrHeaderCompleted(IN QMOV_ReadSession*  po)
{
    P<CBaseHeader> pReadBuff = po->pPacket;
    CBaseHeader* pcBaseHeader = po->pPacket;

    //
    //  very important - we should set buffer to NULL to make sure it will not
    //  be freed twice by the caller  if ACAllocatePacket fails.
    //
    //
    po->pPacket = NULL;


    CUserHeader* pcUserHeader = NULL;
	try
	{
   		pcUserHeader = pcBaseHeader->section_cast<CUserHeader*>(pcBaseHeader->GetNextSection());
   		pcUserHeader->SectionIsValid((PCHAR)pcBaseHeader + po->read);
	}
	catch (const exception&)
	{
        DBGMSG((DBGMOD_QM,
                DBGLVL_ERROR,
                _TEXT("User Header is not valid")));

		ASSERT_BENIGN(0);
		//
		// Close the session & decrement session refernce count
		//
		Close_Connection(po->pSession, L"Base Header is not valid");
		(po->pSession)->Release();
		return LogHR(MQ_ERROR, s_FN, 310);
	}

    //
    // Allocate a shared memory, and copy the fist bytes in it
    //

    ACPoolType acPoolType = ptReliable;
    if(pcUserHeader->GetDelivery() == MQMSG_DELIVERY_RECOVERABLE)
    {
        acPoolType = ptPersistent;
    }

    //
    // Check if target queue is the notification queue (private$\notify_queue$).
    //

    QUEUE_FORMAT DestinationQueue;

    pcUserHeader->GetDestinationQueue(&DestinationQueue);

    BOOL fCheckMachineQuota = !IsDestinationNotificationQueue(DestinationQueue);

    CACPacketPtrs packetPtrs = {NULL, NULL};

    DWORD dwPktSize = pcBaseHeader->GetPacketSize() ;
    if (CSessionMgr::m_fAllocateMore)
    {
        dwPktSize = ALIGNUP4_ULONG(ALIGNUP4_ULONG(dwPktSize) + sizeof(GUID));
    }

    HRESULT hr = ACAllocatePacket(
                    g_hAc,
                    acPoolType,
                    dwPktSize,
                    packetPtrs,
                    fCheckMachineQuota
                    );

    if (FAILED(hr))
    {

        DBGMSG((DBGMOD_QM,
                DBGLVL_ERROR,
                _TEXT("No more resources in AC driver. Error %xh"), hr));
        //
        // No more resources in AC driver.
        // Decrease the session window size. This caused the sender to slow down the
        // packet sending and allow the driver to overcome this situation.
        //
        SessionMgr.SetWindowSize(1);
        // We do not allow more read on this session. The client side
        // continue to write to the session but doesn't get an acknowledge.
        // After ACK timeout the client closes the session and try to open
        // it again. If sources are freed the Server side is ready to get packets
        // otherwise they refused.
        //
        (po->pSession)->Release();
        return LogHR(hr, s_FN, 120);
    }
    po->pPacket = packetPtrs.pPacket;
    po->pDriverPacket = packetPtrs.pDriverPacket;

    //
  	// Need to set the completion routine anyway so if something fail laiter
	// the ReadCompleated func will know to call ACFreePacket instead of
  	// delete after this point
	//
    po->lpReadCompletionRoutine = ReadUserMsgCompleted;

    //
    // Set Absolute timeout. Change the relative time to absolute
    //
    SetAbsoluteTimeToQueue(pcBaseHeader);
    //
    // Copy the packet and update the QM_OVERLAPPED structure for
    // reading the rest of the packet
    //
    memcpy(po->pPacket,pcBaseHeader,po->read);

    if (po->read == pcBaseHeader->GetPacketSize())
    {
        //
        // Whole packet was read. Go To USER_MSG_READ_STATE
        //
        hr = ReadUserMsgCompleted(po);
        return LogHR(hr, s_FN, 130);
    }

    ASSERT((LONG)(po->read) < (LONG) (pcBaseHeader->GetPacketSize())) ;
    //
    // Read the whole packet
    //
    po->dwReadSize = pcBaseHeader->GetPacketSize();

    return MQ_OK;
}


VOID WINAPI CSockTransport::ReceiveDataFailed(EXOVERLAPPED* pov)
{
    long rc = pov->GetStatus();
    DBG_USED(rc);

    ASSERT((rc == STATUS_CANCELLED) ||
           (rc ==  STATUS_NETWORK_NAME_DELETED)  ||
           (rc ==  STATUS_LOCAL_DISCONNECT)      ||
           (rc ==  STATUS_REMOTE_DISCONNECT)     ||
           (rc ==  STATUS_ADDRESS_CLOSED)        ||
           (rc ==  STATUS_CONNECTION_DISCONNECTED) ||
           (rc ==  STATUS_CONNECTION_RESET)      ||
           (GetBytesTransfered(pov) == 0));

    DBGMSG((DBGMOD_QM, DBGLVL_WARNING, L"%x: ReceiveData FAILED, Error %ut. time %d",GetCurrentThreadId(), rc, GetTickCount()));

    P<QMOV_ReadSession> pr = CONTAINING_RECORD (pov, QMOV_ReadSession, qmov);

    Close_Connection(pr->pSession, L"Read packet from socket Failed");
    (pr->pSession)->Release();

    //
    // If we arrive here the read failed from any reason.
    // delete the temporary buffer that is used for read
    //
    if (pr->lpReadCompletionRoutine == ReadUserMsgCompleted)
    {
        //
        // free the AC buffer
        //
        HRESULT hr = ACFreePacket(g_hAc, pr->pDriverPacket);
        REPORT_ILLEGAL_STATUS(hr, L"SockReadCompleted");
    }
    else
    {
        delete[] pr->pbuf;
    }
}


VOID WINAPI CSockTransport::ReceiveDataSucceeded(EXOVERLAPPED* pov)
{
    ASSERT(SUCCEEDED(pov->GetStatus()));
    if (GetBytesTransfered(pov) == 0)
    {
        ReceiveDataFailed(pov);
        return;
    }

    DBGMSG((DBGMOD_QM, DBGLVL_INFO, L"%x: ReceiveData Succeeded. time %d", GetCurrentThreadId(), GetTickCount()));

    QMOV_ReadSession* pr = CONTAINING_RECORD (pov, QMOV_ReadSession, qmov);

    (pr->pSession)->ReadCompleted(pr);
}

/*====================================================

CSockTransport::ReadCompleted()

Arguments:

Return Value:

Thread Context: Session

Asynchronous read completion routine.
Called when some bytes are read into a buffer. This routine
is actually a state machine. Waiting for all the bytes from a
certain state to be read, and then upon the current state deciding
what to do next.

=====================================================*/

void
CSockTransport::ReadCompleted(
    QMOV_ReadSession*  po
    )
{
    ASSERT(po != NULL);
    ASSERT(po->pbuf != NULL);


    HRESULT hr = MQ_OK;
    DWORD NoBytesRead;

    DWORD cbTransferred = GetBytesTransfered(&po->qmov);

    //
    //  we've received a packet, i.e., the session is in use
    //
    SetUsedFlag(TRUE);
    m_fRecvAck = TRUE;
    //
    // If we read user packet set the send ack flag. We need it to handle big
    // messages (3 MG) their read can take more than Ack timeout.
    //
    if (po->lpReadCompletionRoutine == ReadUserMsgCompleted)
    {
        m_fSendAck = TRUE;
    }


    po->read += cbTransferred;
    ASSERT(po->read <=  po->dwReadSize);
    //
    // Check if we read all the expected data
    //
    DBGMSG((DBGMOD_QM,
            DBGLVL_INFO,
            _TEXT("Read Compled from session %ls,. Read %d. m_fRecvAck = %d"),
                  GetStrAddr(), po->read, m_fRecvAck));
    if(po->read == po->dwReadSize)
    {
        //
        // A buffer was completely read. Call the completed function
        // to handle the current state
        //
        DBGMSG((DBGMOD_NETSESSION,
                DBGLVL_INFO,
                _T("Read from socket Completed. Read %d bytes"), po->dwReadSize));


        hr = po->lpReadCompletionRoutine(po);
    }

    //
    // Re-arm the fast acknowledge timer, since the session is active.
    // Do it at this point to insure that for the user message the acknowledge
    // number is already set. Otherwise, doing it before handling the message
    // can expire the timer before setting the acknowledge number. As a result
    // the acknowledgment will not be sent.
    //
    SetFastAcknowledgeTimer();


    if (SUCCEEDED(hr) && (m_sock != NULL))
    {

        //
        // Reissue a read until all data is received
        //
        DWORD ReadSize = po->dwReadSize - po->read;
        BOOL rc = ReadFile(
                        (HANDLE) m_sock,
                        po->pbuf + po->read,
                        ReadSize,
                        &NoBytesRead,
                        &po->qmov
                        );

        //
        // Check if the connection has been closed
        //
        DWORD dwErr = GetLastError();
        if (rc == FALSE &&
            (dwErr != ERROR_IO_PENDING) &&
            //
            // If a IPX socket is being read and the next packet is longer than
            // the Size parameter specifies, ReadFile returns FALSE and
            // GetLastError returns ERROR_MORE_DATA. The remainder
            // of the packet may be read by a subsequent call to the ReadFile.
            //
            dwErr != ERROR_MORE_DATA )
        {
            DBGMSG((DBGMOD_QM,
                   DBGLVL_WARNING,
                   _TEXT("Failed to read from session %ls, error %d"),GetStrAddr(), dwErr));

            LogNTStatus(dwErr, s_FN, 72);

            Close_Connection(this, L"Read from socket Failed");
            //
            // decrement session refernce count
            //
            Release();
        }
        else
        {
             DBGMSG((DBGMOD_NETSESSION,
                    DBGLVL_INFO,
                    _TEXT("Begin new Read phase from session %ls,. Read %d. (time %d)"),
                          GetStrAddr(), ReadSize, GetTickCount()));

            return;
        }
    }

    //
    // If we arrive here the read failed from any reason.
    // delete the temporary buffer that is used for read
    //
    if (po->lpReadCompletionRoutine == ReadUserMsgCompleted)
    {
        //
        // free the AC buffer
        //
        HRESULT hr = ACFreePacket(g_hAc, po->pDriverPacket);
        REPORT_ILLEGAL_STATUS(hr, L"SockReadCompleted");
    }
    else
    {
        delete[] po->pbuf;
    }
    delete po;
}


/********************************************************************************/
/*                   C S o c k S e s s i o n                                    */
/********************************************************************************/
/*====================================================

CSockTransport::CSockTransport

Arguments:

Return Value:

Thread Context: Scheduler

=====================================================*/
CSockTransport::CSockTransport() :
    m_pStats(new CSessionPerfmon),
    m_FastAckTimer(SendFastAcknowledge),
    m_fCheckAckReceivedScheduled(FALSE),
    m_CheckAckReceivedTimer(TimeToCheckAckReceived),
    m_nSendAckSchedules(0),
    m_SendAckTimer(TimeToSendAck),
    m_fSendPendingAckScheduled(FALSE),
    m_SendPendingAckTimer(TimeToSendPendingAck),
    m_CancelConnectionTimer(TimeToCancelConnection),
    m_fCloseDisconnectedScheduled(FALSE),
    m_CloseDisconnectedTimer(TimeToCloseDisconnectedSession)
{
    //
    //
    //
    ClearRecvUnAckPacketNo();
    m_wUnAckRcvPktNo = 0;
    m_fSendAck = FALSE;
    m_fRecvAck = FALSE;
    m_dwLastTimeRcvPktAck = GetTickCount();
    //
    // Initialize the data write acknoledgments
    //
    m_wSendPktCounter     = 0;
    m_wPrevUnackedSendPkt = INIT_UNACKED_PACKET_NO;
    //
    // initialize the data read Stored acknowledgments
    //
    m_wUnackStoredPktNo = 0;
    //
    // Initialize Data write stored acknowledge
    //
    DBGMSG((DBGMOD_NETSESSION, DBGLVL_TRACE,
           TEXT("New CSockSession Object, m_wAckRecoverNo = 0")));

    m_wStoredPktCounter = 0;
    m_wAckRecoverNo = 0;
    m_dwAckRecoverBitField = 0;
    m_lStoredPktReceivedNoAckedCount = 0;

    m_sock          = 0;

    m_fSessionSusspended = FALSE;

    m_fSendBusy = FALSE;
}

/*====================================================

CSockTransport::~CSockTransport

Arguments:

Return Value:

=====================================================*/

CSockTransport::~CSockTransport()
{
    ASSERT(!m_FastAckTimer.InUse());
    ASSERT(!m_CheckAckReceivedTimer.InUse());
    ASSERT(!m_SendAckTimer.InUse());
    ASSERT(!m_CancelConnectionTimer.InUse());
    ASSERT(!m_CloseDisconnectedTimer.InUse());

    ASSERT(m_listPendingAck.IsEmpty());

}

/*====================================================

CSockTransport::BeginReceive

Arguments:

Return Value:

Thread Context: Session

=====================================================*/

void CSockTransport::BeginReceive()
{
    BOOL rc;
    DWORD NoBytesRead = 0;

    ASSERT(m_sock != 0);

    //
    // Increment the Session refence count. We don't delete the
    // session object before the read operation completed.
    // The refernce is decrement on qmthrd when the session is closed
    // (read operation is cancled).
    //
    AddRef();

    //
    // Begin to read next packet
    //
    QMOV_ReadSession* lpQmOv = NULL;
    try
    {
        lpQmOv = new QMOV_ReadSession;
    }
    catch(const bad_alloc&)
    {
        DBGMSG((DBGMOD_QM, DBGLVL_WARNING,
            _TEXT("Insufficent resources. BeginReceive with %ls Failed"),  GetStrAddr()));

        Close_Connection(this, L"Insufficent resources. BeginReceive failed");
        //
        // Decrement Session refernce count
        //
        Release();
        LogIllegalPoint(s_FN, 74);
        return;
    }

    lpQmOv->pSession =  this;
    lpQmOv->pbuf = new UCHAR[BASE_PACKET_SIZE];
    lpQmOv->dwReadSize =sizeof(CBaseHeader);
    lpQmOv->read =      0;
    lpQmOv->lpReadCompletionRoutine =     ReadHeaderCompleted;
    //
    // Issue a read until all data is received
    //
    DBGMSG((DBGMOD_NETSESSION, DBGLVL_INFO,
        TEXT("::BeginReceive- call ReadFile, %lu bytes, from socket- %Ix"),
                                       lpQmOv->dwReadSize, (DWORD_PTR) m_sock)) ;

    rc = ReadFile((HANDLE) m_sock,
                  lpQmOv->pbuf,
                  lpQmOv->dwReadSize,
                  &NoBytesRead,
                  &lpQmOv->qmov);

    //
    // Check if the connection has been closed
    //
    DWORD dwErr = GetLastError();
    if (rc == FALSE &&
        dwErr != ERROR_IO_PENDING &&
        //
        // If a IPX socket is being read and the next packet is longer than
        // the lpQmOv->dwReadSize parameter specifies, ReadFile returns
        // FALSE and GetLastError returns ERROR_MORE_DATA. The remainder
        // of the packet may be read by a subsequent call to the ReadFile.
        //
        dwErr != ERROR_MORE_DATA )
    {
        DBGMSG((DBGMOD_QM, DBGLVL_WARNING,
            _TEXT("::BeginReceive- Read from socket %ls failed, Error=0x%x"),
                                           GetStrAddr(), dwErr));

        LogNTStatus(dwErr, s_FN, 73);

        Close_Connection(this, L"Read from socket failed");
        //
        // Decrement Session refernce count
        //
        Release();

        delete lpQmOv->pbuf;
        delete lpQmOv;
    }
}

/*====================================================

CSockTransport::NewSession


Arguments:

Return Value:

Called when a new session was created

Thread Context: Scheduler

=====================================================*/

void CSockTransport::NewSession(void)
{
    TCHAR szAddr[256];
    _snwprintf(szAddr, TABLE_SIZE(szAddr), L"TCP: %S", inet_ntoa(*(struct in_addr *)(GetSessionAddress()->Address)));
    szAddr[ TABLE_SIZE(szAddr)-1 ] = L'\0' ;

    //
    // Create Stats structure
    //
    m_pStats->CreateInstance(szAddr);

    //
    // Optimize buffer size
    //
    int opt = 18 * 1024;
    setsockopt(m_sock, SOL_SOCKET, SO_SNDBUF, (const char *)&opt, sizeof(opt));

    //
    // Optimize to no Nagling (based on registry)
    //
    extern BOOL g_fTcpNoDelay;
    setsockopt(m_sock, IPPROTO_TCP, TCP_NODELAY, (const char *)&g_fTcpNoDelay, sizeof(g_fTcpNoDelay));

    //
    // Connect the socket to completion port
    //
    ExAttachHandle((HANDLE)m_sock);

    //
    // Begin read from a session
    //
    BeginReceive();
}


/*====================================================

CSockTransport::BindToFirstIpAddress

Arguments: None

Return Value: true - Operation was successful, false - Operation failed

Called by CreateConnection when QM is a cluster resource.

Thread Context:

=====================================================*/
bool
CSockTransport::BindToFirstIpAddress(
    VOID
    )
{
    PHOSTENT    phe = gethostbyname(NULL);
    if (phe == NULL)
    {
        DWORD gle = WSAGetLastError();
        DBGMSG((DBGMOD_NETSESSION, DBGLVL_ERROR, TEXT("::CreateConnection- Cant get host by name")));
        LogNTStatus(gle,  s_FN, 280);
        return false;
    }

    SOCKADDR_IN local;
    memcpy(&local.sin_addr.s_addr, phe->h_addr_list[0], IP_ADDRESS_LEN);

    local.sin_family = AF_INET;
    local.sin_port   = 0;

    DBGMSG((DBGMOD_NETSESSION, DBGLVL_TRACE, L"Binding to IP address [%hs]\n",
        inet_ntoa(*((in_addr *)&local.sin_addr.S_un.S_addr))));


    if(bind(m_sock, (struct sockaddr FAR *)&local, sizeof(local)) == SOCKET_ERROR)
    {
        DWORD gle = WSAGetLastError();
        DBGMSG((DBGMOD_NETSESSION, DBGLVL_ERROR, TEXT("::CreateConnection- Cant get host by name")));
        LogNTStatus(gle,  s_FN, 290);
        return false;
    }

    return true;

} // CSockTransport::BindToFirstIpAddress


/*====================================================

CSockTransport::NetworkConnect

Arguments:

Return Value:

Thread Context: Scheduler

=====================================================*/
HRESULT
CSockTransport::CreateConnection(
    IN const TA_ADDRESS* pa,
    IN const GUID* pguidQMId,
    BOOL fQuick /* = TRUE*/
    )
{
    ASSERT(m_sock == 0);

    if (CSessionMgr::m_fUseQoS)
    {
        if (*pguidQMId == GUID_NULL)
        {
            m_fQoS = true;
        }
    }

    //
    // Keep the TA_ADDRESS format
    //
    SetSessionAddress(pa);

    ASSERT(pa->AddressType == IP_ADDRESS_TYPE);

    SOCKADDR_IN dest_in;    //Destination Address
    DWORD dwAddress;

    dwAddress = * ((DWORD *) &(pa->Address));
    ASSERT(g_dwIPPort) ;
    m_uPort = DWORD_TO_WORD(g_dwIPPort) ;

    dest_in.sin_family = AF_INET;
    dest_in.sin_addr.S_un.S_addr = dwAddress;
    dest_in.sin_port = htons(m_uPort);

    if(fQuick)
    {
        BOOL f = FALSE;

        if (CSessionMgr::m_fUsePing)
        {
            f = ping((SOCKADDR*)&dest_in, PING_TIMEOUT);
        }

        if (!f)
        {
            DBGMSG((DBGMOD_NETSESSION,
                    DBGLVL_WARNING,
                    TEXT("::CreateConnection- ping to %ls Failed."),GetStrAddr()));
			
		    return LogHR(MQ_ERROR, s_FN, 140);
        }
    }

    m_sock = QmpCreateSocket(m_fQoS);
    if(m_sock == INVALID_SOCKET)
    {
        DBGMSG((DBGMOD_NETSESSION, DBGLVL_ERROR, TEXT("::CreateConnection- Cant create a socket")));
        LogBOOL(FALSE, s_FN, 150);
	    return MQ_ERROR;
    }

    //
    // On a cluster system, bind to first IP (depending on registry flag)
    //
    if (IsLocalSystemCluster())
    {
        if (!g_bCluster_IP_BindAll)
        {
            bool rc = BindToFirstIpAddress();
            if (!rc)
            {
				return LogHR(MQ_ERROR, s_FN, 152);
            }
        }
    }

    //
    // Connect to socket
    //
    HRESULT hr = ConnectSocket(&dest_in, m_fQoS);
    if (FAILED(hr))
    {
		return LogHR(hr, s_FN, 160);
    }

    //
    // Increament Session refence count. This refernce count is used for complete
    // the session establish phase. we don't want that the session is free while we
    // wait to establish connection
    //
    AddRef();

    // set session status to connect
    SetSessionStatus(ssConnect);

    // store that this is the client side
    SetClientConnect(TRUE);

    // keep the destination QM ID
    if (!pguidQMId)
    {
        pguidQMId = &GUID_NULL;
    }

    SetQMId(pguidQMId);
    DBGMSG((DBGMOD_NETSESSION, DBGLVL_TRACE,
         TEXT("::CreateConnection- Session created with %ls"), GetStrAddr()));

    //
    // connect the session to complition port and begin read on the socket
    //
    NewSession();

    //
    // Send Establish connection packet - at this stage we can't fail because ther
    // is receiver on this connection.
    //
    SendEstablishConnectionPacket(pguidQMId, !fQuick);


    return LogHR(hr, s_FN, 220);
}

/*====================================================
CSockTransport::ConnectSocket

Arguments:

Return Value:
=====================================================*/
HRESULT
CSockTransport::ConnectSocket(
    SOCKADDR_IN const *pdest_in,
    bool              fUseQoS)
{
    QOS Qos;
    QOS *pQoS = 0;
    if (fUseQoS)
    {
        pQoS = &Qos;
        QmpFillQoSBuffer(pQoS);
    }

    int ret = WSAConnect(m_sock,
                         (PSOCKADDR)pdest_in,
                         sizeof(SOCKADDR),
                         0,
                         0,
                         pQoS,
                         0
                         );

    if(ret == SOCKET_ERROR)
    {
        DWORD dwErrorCode = WSAGetLastError();

        DBGMSG((DBGMOD_NETSESSION, DBGLVL_ERROR,
            TEXT("CSockTransport::ConnectSocket - connect to %ls Failed. Error=0x%x"),
            GetStrAddr(), dwErrorCode));
        closesocket(m_sock);
        m_sock = 0;
        LogNTStatus(dwErrorCode,  s_FN, 340);

        if (fUseQoS)
        {
            //
            // Try again - no QoS this time
            //
            return LogHR(ConnectSocket(pdest_in, false), s_FN, 342);
        }

        return LogHR(MQ_ERROR, s_FN, 344);
    }

    return MQ_OK;
}

/*====================================================

CSockTransport::Connect

Arguments:

Return Value:

Thread Context: Scheduler

=====================================================*/
void CSockTransport::Connect(IN TA_ADDRESS *pa,
                             IN SOCKET sock)
{
    ASSERT(m_sock == 0);

    m_sock = sock;
    SetSessionAddress(pa);

    //
    // Increament Session refence count. This refernce count is used for complete
    // the session establish phase. we don't want that the session is free while we
    // wait to establish connection
    //
    AddRef();

    // set session status to connect
    SetSessionStatus(ssConnect);

    // store that this is the client side
    SetClientConnect(FALSE);

    // connect the session to complition port and begin read on the socket
    NewSession();

    //
    // Set timer to check that the connection completed successfully. If yes, the function
    // is removed from the scheduler wakeup list and never is called. Otherwise, the function
    // close the session and move all the associated queues to non-active group.
    //
    ExSetTimer(&m_CancelConnectionTimer, CTimeDuration::FromMilliSeconds(ESTABLISH_CONNECTION_TIMEOUT));

}

/*====================================================

CSockTransport::CloseConnection

Arguments:

Return Value:

Thread Context:

=====================================================*/
void CSockTransport::CloseConnection(
                                     LPCWSTR lpcwsDbgMsg,
									 bool fClosedOnError
                                     )
{
    CS lock(m_cs);

    //
    // WinSE bug 27985
    // We can reach here from the timeout that cancel the connection
    // establish process, if we didn't get a reply for "estalbish" packet.
    // In that case, a WAIT_INFO structure is still in the waiting list,
    // see sessmgr.cpp.  Reset it's "connect" flag, so we try again to
    // connect to this address.
    //
    SessionMgr.MarkAddressAsNotConnecting( GetSessionAddress(),
                                           m_guidDstQM,
                                           m_fQoS ) ;
	//
	// If we got delivery error - we report it to the group
	// so all it's queues will be moved to the wating group when
	// the session group is closed.
	//
	if(fClosedOnError)
	{
		ReportErrorToGroup();
	}

    //
    // Delete the group. move all the queues that associated
    // to this session to non-active group.
    //
    CQGroup*pGroup = GetGroup();
    if (pGroup != NULL)
    {
        pGroup->CloseGroup();


        pGroup->Release();
        SetGroup(NULL);
    }
    //
    // Check if the connection has already been closed
    //
    if (m_sock == 0)
    {
        return;
    }

    DBGMSG((DBGMOD_NETSESSION,
            DBGLVL_ERROR,
            _TEXT("Close Connection with %ls at %ls. %ls (Session id: %p), (tick=%u)"),
                      GetStrAddr(),  _tstrtime(tempBuf), lpcwsDbgMsg, this, GetTickCount()));
    //
    // Close the socket handle and set the flags appropriately
    //
    if (!IsOtherSideServer() && GetSessionStatus() == ssActive)
    {
        //
        // Decrement the number of active session
        //
        g_QMLicense.DecrementActiveConnections(&m_guidDstQM);
    }

    // set session status to connect
    //
    SetSessionStatus(ssNotConnect);
    closesocket(m_sock);
    m_sock = 0;

    //
    // Requeue all the unacknowledged packets
    //
    POSITION posInList = m_listUnackedPkts.GetHeadPosition();
    while (posInList != NULL)
    {
        CQmPacket* pPkt;

        pPkt = m_listUnackedPkts.GetNext(posInList);

        RequeuePacket(pPkt);
        delete pPkt;
    }
    m_listUnackedPkts.RemoveAll();

    //
    // Requeue all the unacknowledged Storage packets
    //
    posInList = m_listStoredUnackedPkts.GetHeadPosition();
    while (posInList != NULL)
    {
        CQmPacket* pPkt;

        pPkt = m_listStoredUnackedPkts.GetNext(posInList);

        RequeuePacket(pPkt);
        delete pPkt;
    }
    m_listStoredUnackedPkts.RemoveAll();

    //
    // Cleaning. Delete all the pending acknowledge packet that waiting for sending
    //
    posInList = m_listPendingAck.GetHeadPosition();
    while (posInList != NULL)
    {
        CBaseHeader* pPkt;

        pPkt = m_listPendingAck.GetNext(posInList);

        delete pPkt;
    }
    m_listPendingAck.RemoveAll();

    //
    // Remove performance counters
    //
    SafeRelease(m_pStats.detach());
}


HRESULT
CSockTransport::WriteBasicHeader(IN const CQmPacket *pPkt,
                                 IN BOOL fSendAck,
                                 IN DWORD dwDbgSectionSize
                                )
{
    //
    // Copy base header, and changed the relevant flags
    //
    CBaseHeader* pBaseHeader = new CBaseHeader(*(CBaseHeader*)pPkt->GetPointerToPacket());

    //
    // Update timeout field. On network we send relative timeout.
    //
    pBaseHeader->SetAbsoluteTimeToQueue(pPkt->GetRelativeTimeToQueue());
    //
    // Check if linking Acknwoldge information
    //
    if (fSendAck)
    {
        pBaseHeader->IncludeSession(TRUE);
    }
    //
    // Debug section included
    //
    if (dwDbgSectionSize != 0)
    {
        pBaseHeader->IncludeDebug(TRUE);
        pBaseHeader->SetTrace(MQMSG_SEND_ROUTE_TO_REPORT_QUEUE);
        pBaseHeader->SetPacketSize(pPkt->GetSize()+dwDbgSectionSize);
    }

    //
    // Set the packet signature
    //
    pBaseHeader->ClearOnDiskSignature();
    pBaseHeader->SetSignature();

    DBGMSG((DBGMOD_NETSESSION,
            DBGLVL_INFO,
            _T("Write to socket %ls Base Header. Write %d bytes"), GetStrAddr(), CBaseHeader::CalcSectionSize()));
    HRESULT hr = CreateSendRequest(pBaseHeader,
                                   pBaseHeader,
                                   CBaseHeader::CalcSectionSize(),
                                   FALSE      // don't free send event
                                  );

    return LogHR(hr, s_FN, 219);
}

#define BUFF_SIZE 4*1024

HRESULT CSockTransport::WriteEncryptedBody(IN QMOV_EncryptedWriteSession* po)
{

    BOOL fFinal;

    fFinal = (BUFF_SIZE >= po->dwEncryptedBodySize);
    DWORD dwBufferSize = (fFinal) ?  po->dwEncryptedBodySize : BUFF_SIZE;

    //
    // handle the case that the buffer is large enough for the original packet
    // but not for the encrypted packet.
    //
    if (fFinal && (po->dwEncryptedWriteSize > BUFF_SIZE))
    {
        //
        // Use cipher block divisible size, since this is not a final call.
        //
        dwBufferSize =  BUFF_SIZE / 2;

        //
        // Verify that dwBufferSize is smaller than BodySize left to send
        //
        ASSERT(po->dwEncryptedBodySize >= dwBufferSize);
        fFinal = FALSE;
    }

    //
    // Get the body Address that should be encrypted
    //
    CQmPacket* pPkt = (CQmPacket *) po->lpBuffer;
    DWORD dwBodySize;

    const UCHAR* pBody = pPkt->GetPacketBody(&dwBodySize);
    pBody = pBody + dwBodySize - po->dwEncryptedBodySize;
    memcpy(po->lpWriteBuffer, pBody, dwBufferSize);

    // Encrypt the message body.
    BOOL fSucc = CryptEncrypt(po->hKey,
                              NULL,
                              fFinal,
                              0,
                              (PUCHAR)po->lpWriteBuffer,
                              &dwBufferSize,
                              BUFF_SIZE);
    if (!fSucc)
    {
        DWORD gle = GetLastError();

        DBGMSG((DBGMOD_NETSESSION, DBGLVL_ERROR, _T("Encryption Failed. Error %d "), gle));
        Close_Connection(this, L"Error computed security data");

        LogNTStatus(gle, s_FN, 224);
        return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 225);
    }

    DWORD dwWriteSize = (fFinal) ?  po->dwEncryptedWriteSize: dwBufferSize;
    po->dwEncryptedWriteSize = po->dwEncryptedWriteSize - dwWriteSize;
    po->dwEncryptedBodySize = po->dwEncryptedBodySize - dwWriteSize;

    po->dwWrittenSize = 0;
    po->dwWriteSize = dwWriteSize;

    //
    // Increment Session Refernce Cont. The reference count is decrement on
    // SendReadAckCompleted or SockSendCompleted, after the write to socket is completed.
    //
    AddRef();
    HRESULT hr = WriteToSocket(po);
    return LogHR(hr, s_FN, 230);
}

HRESULT
CSockTransport::WriteRecoverEncryptPacket(IN const CQmPacket *pPkt,
                                          IN BOOL  fSendAck,
                                          IN CDebugSection* pDebug,
                                          IN HCRYPTKEY hKey,
                                          IN BYTE *pbSymmKey,
                                          IN DWORD dwSymmKeyLen
                                          )
{
    HRESULT hr = MQ_OK;
    ASSERT(hKey != NULL);
    ASSERT(pPkt->GetPointerToSecurHeader());
    const UCHAR* pBody;
    DWORD dwBodySize;
    BOOL fSucc;
    DWORD dwWriteSize;

    //
    // write User and XACT sections
    //
    pBody = pPkt->GetPacketBody(&dwBodySize);
    ASSERT(dwBodySize);
    DWORD dwEncryptBodySize = dwBodySize;
    //
    // Get the encrypted message size inorder to set the packet size on the packet
    //
    fSucc = CryptEncrypt(hKey,
                         NULL,
                         TRUE,
                         0,
                         NULL,
                         &dwEncryptBodySize,
                         pPkt->GetAllocBodySize());
    ASSERT(fSucc);
    ASSERT(pPkt->GetAllocBodySize() >= dwBodySize);

    //
    // Write the security section
    //
    dwWriteSize = DWORD_PTR_TO_DWORD(pBody-(pPkt->GetPointerToUserHeader()));

    //
    // Handle the case that the security section is greater than the BUFFER_SIZE
    //
    PUCHAR pBuff = new UCHAR[dwWriteSize];
    memcpy(pBuff, pPkt->GetPointerToUserHeader(), dwWriteSize);
    //
    // set the symmetric key in the message packet.
    //
    CSecurityHeader* pSecur = (CSecurityHeader*)(pBuff + (pPkt->GetPointerToSecurHeader() - pPkt->GetPointerToUserHeader()));
    CPropertyHeader* pProp = (CPropertyHeader*)(pSecur->GetNextSection());
	

    pSecur->SetEncryptedSymmetricKey(pbSymmKey, (USHORT)dwSymmKeyLen);
    pSecur->SetEncrypted(TRUE);
    //
    // set the encrypted message size
    //
    pProp->SetBodySize(dwEncryptBodySize);

    DBGMSG((DBGMOD_NETSESSION,
            DBGLVL_INFO,
            _T("Write to socket %ls All the packet headers of recoverable encrypted message. Write %d bytes"), GetStrAddr(), dwWriteSize));
    hr = CreateSendRequest(pBuff, pBuff,dwWriteSize,FALSE);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 240);
    }

    P<QMOV_EncryptedWriteSession> po;
    po = new QMOV_EncryptedWriteSession;
    P<UCHAR> EncryptedBuffer = new UCHAR[BUFF_SIZE];

    //
    // Calculate the size of the rest of the property section that should be sent. Don't use
    // the allocatedBodySize since when the property section isn't aligned, the QM padding it
    // with unused bytes
    //
    char* pEndOfPropSection = reinterpret_cast<CPropertyHeader*>(pPkt->GetPointerToPropertySection())->GetNextSection();
    dwWriteSize = DWORD_PTR_TO_DWORD(reinterpret_cast<UCHAR*>(pEndOfPropSection) - pPkt->GetPointerToUserHeader()) - dwWriteSize;

    po->pSession = this;
    po->lpBuffer = (PVOID) pPkt;
    po->lpWriteBuffer = EncryptedBuffer;
    po->dwWrittenSize = 0;
    po->dwWriteSize = 0;
    po->fEncryptedMsg = TRUE;
    po->fFreeSemaphore = FALSE;
    po->fUserMsg = TRUE;
    po->lpDebugSectionBuf = pDebug;
    po->fSendAck = fSendAck;
    po->dwEncryptedWriteSize = dwWriteSize;
    po->dwEncryptedBodySize = dwBodySize;
    po->hKey = hKey;

    hr = WriteEncryptedBody(po);

    if (FAILED(hr))
        return LogHR(hr, s_FN, 250);

    EncryptedBuffer.detach();
    po.detach();

    return MQ_OK;
}


HRESULT
CSockTransport::WriteExpressPacket(IN CQmPacket* pPkt,
                                   IN HCRYPTKEY hKey,
                                   IN BYTE *pbSymmKey,
                                   IN DWORD dwSymmKeyLen,
                                   IN BOOL  fSendAck,
                                   IN CDebugSection* pDebug
                                  )
{
    HRESULT hr;

    if (hKey &&
        FAILED(pPkt->EncryptExpressPkt(hKey, pbSymmKey, dwSymmKeyLen)))
    {
        ACFreePacket(
            g_hAc,
            pPkt->GetPointerToDriverPacket(),
            MQMSG_CLASS_NACK_COULD_NOT_ENCRYPT
            );

        Close_Connection(this, L"Error computed security data");
        //
        // Decrement reference count
        //
        Release();
        delete pPkt;
        delete pDebug;

        return MQ_OK;
    }
    else
    {
        DWORD dwWriteSize = pPkt->GetSize() - sizeof(CBaseHeader);
        DBGMSG((DBGMOD_NETSESSION,
                DBGLVL_INFO,
                _T("Write to socket %ls User message (without base header). Write %d bytes"), GetStrAddr(), dwWriteSize));
        hr = CreateSendRequest(pPkt,
                               pPkt->GetPointerToUserHeader(),
                               dwWriteSize,
                               TRUE,            // Free Send event
                               TRUE,            // fUserMsg
                               fSendAck,
                               pDebug);
    }

    return LogHR(hr, s_FN, 260);
}


/*====================================================

CSockTransport::NetworkSend

Arguments:

Return Value:

Thread Context: Session

=====================================================*/

void CSockTransport::NetworkSend(IN CQmPacket* pPkt)
{
    HRESULT hr = MQ_OK;
    QUEUE_FORMAT ReportQueue;
    BOOL fSendAck = FALSE;
    DWORD dwDbgSectionSize = 0;
    P<CDebugSection> pDbgSection = NULL;

    HCRYPTKEY hSymmKey = NULL;
    BYTE *pbSymmKey = 0;
    DWORD dwSymmKeyLen = 0;

    ASSERT(pPkt->IsSessionIncluded() == FALSE);

    R<CCacheValue> pCacheValue;

    if (pPkt->IsBodyInc() &&
        !pPkt->IsEncrypted() &&
        (pPkt->GetPrivLevel() != MQMSG_PRIV_LEVEL_NONE))
    {
        //
        // Get the symmetric key of the destination. In order to avoid the case that we
        // begin to send the packet and than find that Symmetric key can't be obtain, we do
        // now.
        //
        hr = pPkt->GetDestSymmKey( &hSymmKey,
                                   &pbSymmKey,
                                   &dwSymmKeyLen,
                                  (PVOID *)&pCacheValue );
        if (FAILED(hr))
        {
            if (pPkt->IsOrdered() && QmpIsLocalMachine(pPkt->GetSrcQMGuid()))
            {
                // Special case. Send couldn't encrypt, so send is - and will remain - impossible
                // We must treat it as timeout: delete packet, keep the number in time-out block
                //
                if(MQCLASS_MATCH_ACKNOWLEDGMENT(MQMSG_CLASS_NACK_COULD_NOT_ENCRYPT, pPkt->GetAckType()))
                {
                    pPkt->CreateAck(MQMSG_CLASS_NACK_COULD_NOT_ENCRYPT);
                }

                // NonSendProcess free the packet internally.
                g_OutSeqHash.NonSendProcess(pPkt, MQMSG_CLASS_NACK_COULD_NOT_ENCRYPT);
            }
            else
            {
                //
                // Sorry, the destination QM doesn't support encryption. Create ack and free
                // the packet
                //
                ACFreePacket(
                    g_hAc,
                    pPkt->GetPointerToDriverPacket(),
                    MQMSG_CLASS_NACK_COULD_NOT_ENCRYPT
                    );
                delete pPkt;
            }

            //
            // Get the next message for sending now
            //
            GetNextSendMessage();
            return;
        }
    }

    {
        //
        // Before sending message get the critical section. We need it since
        // at the same time the SendReadAck timeout can be expired and ack
        // packet can be send
        //
        CS lock(m_cs);

        //
        // Check if linking Acknwoldge information
        // We linking Acknowledge section only if 75% of the SendAcknowldge
        // timeout is passed
        //
        if (((GetTickCount() - m_dwLastTimeRcvPktAck)> ((3*m_dwSendAckTimeout)/4)) &&
            (m_fSendAck || (m_wAckRecoverNo != 0)))
        {
            fSendAck = TRUE;
        }
        DBGMSG((DBGMOD_QMACK, DBGLVL_INFO,
             _TEXT("NetworkSend - linking Acknowledge information: decided %d, m_wAckRecoverNo=%d"), fSendAck,(DWORD)m_wAckRecoverNo));

    }

    //
    // Check if debug information should be sent. If yes create the debug
    // section such we will be sure we can send it.
    //
    if (
        //
        // Verify that Debug header not already included.
        // Debug header may be included for example when the MQF header is
        // included, to prevent reporting QMs 1.0/2.0 to append their Debug
        // header to the packet.
        //
        (!pPkt->IsDbgIncluded()) &&

        //
        // Verify this is not a report message by itself.
        //
        (pPkt->GetClass() != MQMSG_CLASS_REPORT) &&

        //
        // This is a reporting QM, or packet should be traced.
        //
        (QueueMgr.IsReportQM() || (pPkt->GetTrace() == MQMSG_SEND_ROUTE_TO_REPORT_QUEUE)) &&

        //
        // There is a valid report queue.
        //
        SUCCEEDED(Admin.GetReportQueue(&ReportQueue))
        )
    {
        dwDbgSectionSize = CDebugSection::CalcSectionSize(&ReportQueue);

        PVOID pv = new UCHAR[dwDbgSectionSize];
        #ifdef _DEBUG
        #undef new
        #endif
                pDbgSection = new(pv) CDebugSection(&ReportQueue);

        #ifdef _DEBUG
        #define new DEBUG_NEW
        #endif
    }

    //
    // Get the send Semaphore
    //
    if (GetSendSemaphore() == FALSE)
    {
        //
        // The session is busy with write another packet. We requeue the
        // packet and ask for getting another packet for send.
        //
        RequeuePacket(pPkt);
        delete pPkt;

        //
        // Get the next message for sending now
        //
        GetNextSendMessage();

        DBGMSG((DBGMOD_NETSESSION,
                DBGLVL_TRACE,
                TEXT("Send on session %ls is Busy. Send packet is requeuing. "), GetStrAddr()));

        return;
    }


    DBG_MSGTRACK(DBGMOD_MSGTRACK, pPkt, _T("SEND message"));

    #ifdef _DEBUG
    {

        OBJECTID MessageId;
        pPkt->GetMessageId(&MessageId);

        DBGMSG((DBGMOD_NETSESSION,
                DBGLVL_WARNING,
                TEXT("Send packet to %ls. Packet ID = ") _T(LOG_GUID_FMT) _T("\\%u"),
                GetStrAddr(), LOG_GUID(&MessageId.Lineage), MessageId.Uniquifier));
    }
    #endif


    DBGMSG((DBGMOD_NETSESSION,
            DBGLVL_TRACE,
            _T("::NetworkSend. Packet Size %d, Send Ack section %d, Send debug Section %d"),  pPkt->GetSize(),  fSendAck, dwDbgSectionSize));

    //
    // Set The acnowledge number of the packet
    //
    UpdateAcknowledgeNo(pPkt);

    //
    // Save the packet info for later use when sending the report message
    //
    m_MsgInfo.SetReportMsgInfo(pPkt);

    hr = WriteBasicHeader(pPkt, fSendAck, dwDbgSectionSize);
    if (SUCCEEDED(hr))
    {

        CS lock(m_cs);
        //
        // Write packet on net
        //
        if ((hSymmKey == NULL) ||
            pPkt->GetDeliveryMode() == MQMSG_DELIVERY_EXPRESS)
        {
            hr = WriteExpressPacket(pPkt, hSymmKey, pbSymmKey, dwSymmKeyLen, fSendAck, pDbgSection);
        }
        else
        {
            hr = WriteRecoverEncryptPacket(pPkt, fSendAck, pDbgSection, hSymmKey, pbSymmKey, dwSymmKeyLen);
        }

        if (SUCCEEDED(hr))
        {
            //
            // SP4 - Bug# 3380. (closing a session while sending a messge)
            //
            // Add the packet to the list of unacknowledged packets before
            // the sending is completed. If the send is failed the session will
            // be closed and the message is returned to the Queue. Otherwise,
            // when a acknowledge is received the message will free
            //              Uri Habusha (urih), 11-Aug-98
            //
            NeedAck(pPkt);

            pDbgSection.detach();


            return;
        }
    }


    //
    // sending of packet was failed, the session should be closed
    //
    ASSERT(m_sock == 0);

    //
    // return the message to queue and delete the internal structures
    //
    RequeuePacket(pPkt);
    delete pPkt;
}


void
CSockTransport::SendAckPacket(
    void
    )
{
    CS lock(m_cs);

    ASSERT(m_nSendAckSchedules > 0);
    --m_nSendAckSchedules;

    if (m_fSendAck)
    {
        SendReadAck(eStandAlone);
    }

    Release();
}

void
CSockTransport::SetAckInfo(
    CSessionSection* pAckSection
    )
/*++

  Routine description:
    the routine gets a pointer to the session section and it set the session
    acknowledge information on it.

  Parameters:
    pointer to the session acknowledge section.

  Returned value:
    None

 --*/
{
    //
    // Set the ackconweledge section
    //
    WORD WinSize = (WORD)(IsDisconnected() ? 1 : SessionMgr.GetWindowSize());

#ifdef _DEBUG
#undef new
#endif

    DBGMSG((DBGMOD_NETSESSION, DBGLVL_INFO, TEXT("new CSessionSection: m_wAckRecoverNo=%d"),(DWORD)m_wAckRecoverNo));

    new(pAckSection) CSessionSection(
                                m_wUnAckRcvPktNo,
                                m_wAckRecoverNo,
                                m_dwAckRecoverBitField,
                                m_wSendPktCounter,
                                m_wStoredPktCounter,
                                WinSize
                                );

#ifdef _DEBUG
    #define new DEBUG_NEW
#endif

    //
    // Initialize m_wAckRecoverNo
    //
    m_wAckRecoverNo = 0;
    m_dwAckRecoverBitField = 0;

    DBGMSG((DBGMOD_NETSESSION, DBGLVL_INFO, TEXT("SetAckInfo: m_wAckRecoverNo=0")));
}


void
CSockTransport::CreateAckPacket(
    PVOID* ppSendPacket,
    CSessionSection** ppAckSection,
    DWORD* pSize
    )
/*++

  Routine Description:
    The routine creates an acknowledge packet for sending

  Argumets:
    All the arguments are out arguments and uses to return information to the caller:
        - pointer to the acknowledge packet
        - pointer to the session acknowledgment section
        - packet size

  Returned value:
    None
 --*/
{
    DWORD dwPacketSize = sizeof(CBaseHeader) + sizeof(CInternalSection) + sizeof(CSessionSection);
    PVOID pAckPacket = new UCHAR[dwPacketSize];

    *ppSendPacket = pAckPacket;
    *pSize = dwPacketSize;

#ifdef _DEBUG
#undef new
#endif
    //
    // Set Falcon Packet Header
    //
    CBaseHeader* pBase = new(pAckPacket) CBaseHeader(dwPacketSize);
    pBase->SetType(FALCON_INTERNAL_PACKET);
    pBase->IncludeSession(TRUE);

    //
    // Set the Internal packet header
    //
    PVOID pSect = (PVOID) pBase->GetNextSection();
    CInternalSection* pInternalSect = new(pSect) CInternalSection(INTERNAL_SESSION_PACKET);

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

    *ppAckSection = reinterpret_cast<CSessionSection*>(pInternalSect->GetNextSection());
    SetAckInfo(*ppAckSection);
}


inline
void
CSockTransport::CreateAckSection(
    PVOID* ppSendSection,
    CSessionSection** ppAckSection,
    DWORD* pSize
    )
/*++

  Routine Description:
    The routine creates an acknowledge section for pick-back acknowledge

  Argumets:
    All the arguments are out arguments and uses to return information to the caller:
        - pointer to the acknowledge packet
        - pointer to the session acknowledgment section
        - packet size

  Returned value:
    None

 --*/
{
    *pSize = sizeof(CSessionSection);
    *ppSendSection = new UCHAR[*pSize];
    *ppAckSection = static_cast<CSessionSection*>(*ppSendSection);

    SetAckInfo(*ppAckSection);
}


#ifdef _DEBUG
void
CSockTransport::DisplayAcnowledgeInformation(
    CSessionSection* pAck
    )
{
    //
    // Get Synchronization Numbers
    //
    WORD wSyncAckSequenceNo, wSyncAckRecoverNo;
    pAck->GetSyncNo(&wSyncAckSequenceNo, &wSyncAckRecoverNo);

    //
    // Print debug information
    //
    DBGMSG((DBGMOD_QMACK,
            DBGLVL_WARNING,
            _T("ACKINFO: Send Acknowledge packet to %ls. (time %d) \
               \n\t\tm_wAckSequenceNo %d\n\t\tm_wAckRecoverNo %d\n\t\tm_wAckRecoverBitField 0x%x\n\t\tm_wSyncAckSequenceNo %d\n\t\tm_wSyncAckRecoverNo %d\n\t\tm_wWinSize %d\n\t\t"),
              GetStrAddr(),
              GetTickCount(),
              pAck->GetAcknowledgeNo(),
              pAck->GetStorageAckNo(),
              pAck->GetStorageAckBitField(),
              wSyncAckSequenceNo,
              wSyncAckRecoverNo,
              pAck->GetWindowSize()));
}
#endif

/*====================================================

CSockTransport::SendReadAck

Arguments:

Return Value:

Thread Context: Session

=====================================================*/
void
CSockTransport::SendReadAck(
    AckType type
    )
{
    CS lock(m_cs);

    if (m_sock == 0)
        return;

    //
    // Cancel the sending acknowledge timer & Fast acknowledge timer
    //
    if (ExCancelTimer(&m_SendAckTimer))
    {
        --m_nSendAckSchedules;
        Release();
    }

    if (ExCancelTimer(&m_FastAckTimer))
    {
        Release();
    }

    DBGMSG((DBGMOD_QMACK,
            DBGLVL_TRACE,
            TEXT("READACK: Send Read Acknowledge for session %ls\n\tTime passed from last Ack Sending - %d. Send Packet: %ls)"),
            GetStrAddr(),
            (GetTickCount() - m_dwLastTimeRcvPktAck),
            ((type == eStandAlone) ? L"TRUE" : L"FALSE")
            ));

    //
    // Create a packet containing the read acknowledgment
    //
    P<VOID>   pAckPacket;
    DWORD   dwWriteSize;
    CSessionSection* pAckSection;
    if (type == eStandAlone)
    {
        CreateAckPacket(&pAckPacket, &pAckSection, &dwWriteSize);

        //
        // Get the critical section of the send. It it is a send packet
        // we try to send it only if we can take the send semaphore;
        //
        if (!GetSendSemaphore())
        {
            //
            // The session is busy in sending another message. schedule for sending the
            // pending ack
            //
            DBGMSG((DBGMOD_QMACK,
                    DBGLVL_INFO,
                    TEXT("Send on session %ls is Busy. Send Acknowledge packet is rescheduling to 200 msec.  (time %d)"), GetStrAddr(), GetTickCount()));

            m_listPendingAck.AddTail(reinterpret_cast<CBaseHeader*>(static_cast<PVOID>(pAckPacket)));
            pAckPacket.detach();

            if (!m_fSendPendingAckScheduled)
            {
                AddRef();
                ExSetTimer(&m_SendPendingAckTimer, CTimeDuration::FromMilliSeconds(200));
                m_fSendPendingAckScheduled = TRUE;
            }

            return;
        }
    }
    else
    {
        CreateAckSection(&pAckPacket, &pAckSection, &dwWriteSize);
    }

    //
    // The session is ready for sending the acknowledge
    //

    DisplayAcnowledgeInformation(pAckSection);

    //
    // Store the number for later used. The numbers on the object have been set to
    // zero and the packet can be released before calling UpdateNumberOfStorageUnackedand.
    //
    WORD StorageAckNo = pAckSection->GetStorageAckNo();
    DWORD StorageAckBitField = pAckSection->GetStorageAckBitField();

    HRESULT hr = CreateSendRequest(
                            pAckPacket,
                            pAckPacket,
                            dwWriteSize,
                            FALSE
                            );

    //
    // NOTE: The acknowledgment section/packet isn't valid here anymore
    //

    if (type == eStandAlone)
    {
        ReleaseSendSemaphore();
    }

    if (FAILED(hr))
        return;

    pAckPacket.detach();

    //
    // Update the number of recoverable messages that were received but
    // didn't ack
    //
    UpdateNumberOfStorageUnacked(StorageAckNo, StorageAckBitField);

    //
    // Clear the Recveive Un-acknowledge counter. Begin a new phase
    //
    m_fSendAck = FALSE;
    ClearRecvUnAckPacketNo();

    //
    // Set The last time acknowledge was sent
    //
    m_dwLastTimeRcvPktAck = GetTickCount();
}


/*====================================================

CSockTransport::SendPendingReadAck

Arguments:

Return Value:

Thread Context: Session

=====================================================*/
void CSockTransport::SendPendingReadAck()
{
    CS lock(m_cs);

    ASSERT(m_fSendPendingAckScheduled);
    m_fSendPendingAckScheduled = FALSE;

    if (m_sock == 0)
    {
        //
        // All the packets were deleted when the session was closed
        //
        ASSERT(m_listPendingAck.IsEmpty());
        Release();
        return;
    }

    ASSERT(!m_listPendingAck.IsEmpty());

    //
    // Get the critical section of the send. It it is a send packet
    // we try to send it only if we can take the send ent; otherwise we
    // sechedule it again. If we send ack session. It is part of user message
    // and the event already set.
    //
    if (!GetSendSemaphore())
    {
        DBGMSG((DBGMOD_QMACK,
                DBGLVL_INFO,
                TEXT("Send on session %ls is Busy. Send Acknowledge packet is rescheduling to 200 msec. (time %d)"), GetStrAddr(),GetTickCount()));

        m_fSendPendingAckScheduled = TRUE;
        ExSetTimer(&m_SendPendingAckTimer, CTimeDuration::FromMilliSeconds(200));
        return;
    }

    //
    // Send all the pending message
    //
    while(!m_listPendingAck.IsEmpty())
    {
        CBaseHeader* pPacket = m_listPendingAck.RemoveHead();

        ASSERT(pPacket->SignatureIsValid());

        //
        // Update internal packet with session section
        //
        CInternalSection* pInternalSect =
            reinterpret_cast<CInternalSection*>(pPacket->GetNextSection());

        CSessionSection* pSect =
            reinterpret_cast<CSessionSection*>(pInternalSect->GetNextSection());

        WORD wStorageAck = pSect->GetStorageAckNo();
        DWORD dwStorageAckBitField =  pSect->GetStorageAckBitField();

        if (!m_fSendAck && (wStorageAck == 0))
        {
            //
            // No need to send an acknowledge there is no a new information
            // that should be send.
            // The session acknowledge for the last received message has been sent,
            // and this pending ack doesn't contain storage information.
            //
            delete pPacket;
            continue;
        }

#ifdef _DEBUG
#undef new
#endif
        CSessionSection* pAckSession = new(pSect) CSessionSection(m_wUnAckRcvPktNo,
                                                                  wStorageAck,
                                                                  dwStorageAckBitField,
                                                                  m_wSendPktCounter,
                                                                  m_wStoredPktCounter,
                                                                  SessionMgr.GetWindowSize()
                                                                 );
#ifdef _DEBUG
        #define new DEBUG_NEW
#endif

        DisplayAcnowledgeInformation(pAckSession);

        //
        // Store the number for later used. The packet can be released before
        // calling UpdateNumberOfStorageUnackedand.
        //
        WORD StorageAckNo =pAckSession->GetStorageAckNo();
        DWORD StorageAckBitField = pAckSession->GetStorageAckBitField();

        DWORD dwWriteSize = sizeof(CBaseHeader) + sizeof(CInternalSection) + sizeof(CSessionSection);
        HRESULT hr = CreateSendRequest(
                        pPacket,
                        pPacket,
                        dwWriteSize,
                        FALSE
                        );

        if (FAILED(hr))
        {
            //
            // All the packets were deleted when the session was closed
            //
            ASSERT(m_listPendingAck.IsEmpty());

            ReleaseSendSemaphore();

            delete pPacket;
            Release();
            return;
        }

        //
        // Update the number of recoverable messages that were received but
        // didn't ack
        //
        UpdateNumberOfStorageUnacked(StorageAckNo, StorageAckBitField);

        //
        // Clear the Recveive Un-acknowledge counter. Begin a new phase
        //
        m_fSendAck = FALSE;
        ClearRecvUnAckPacketNo();
    }

    //
    // Set The last time acknowledge was sent
    //
    m_dwLastTimeRcvPktAck = GetTickCount();

    //
    // free the send semaphore to enable another thread to send on the session
    //
    ReleaseSendSemaphore();
    Release();
}


/*====================================================

CSockTransport::RcvStats

Arguments:

Return Value:

Thread Context:
=====================================================*/
void CSockTransport::RcvStats(DWORD size)
{
    //
    // use critical section to insure that the session will not close while
    // we update the parameters. (CloseConnection function delete the m_pStats structure).
    //
    CS lock(m_cs);

    if (m_pStats.get() != NULL)
    {
        m_pStats->UpdateBytesReceived(size);
        m_pStats->UpdateMessagesReceived();
    }
}


/*====================================================

CSockTransport::Receive

Arguments:

Return Value:

Thread Context:
=====================================================*/
void CSockTransport::Receive(CBaseHeader* pBaseHeader, CPacket * pDriverPacket)
{
	try
	{
		if (pBaseHeader->GetType() == FALCON_INTERNAL_PACKET)
		{
		    CInternalSection* pInternal = pBaseHeader->section_cast<CInternalSection*>(pBaseHeader->GetNextSection());
    		pInternal->SectionIsValid(pBaseHeader->GetPacketEnd());

		    switch (pInternal->GetPacketType())
		    {
		        case INTERNAL_SESSION_PACKET:
		            HandleAckPacket(pBaseHeader->section_cast<CSessionSection*>(pInternal->GetNextSection()));
		            break;

		        case INTERNAL_ESTABLISH_CONNECTION_PACKET:
		            HandleEstablishConnectionPacket(pBaseHeader);
		            break;

		        case INTERNAL_CONNECTION_PARAMETER_PACKET:
		            HandleConnectionParameterPacket(pBaseHeader);
		            break;

		        default:
		            ASSERT(0);
		    }
		}
		else
		{
		    HandleReceiveUserMsg(pBaseHeader, pDriverPacket);
		}
	}
	catch (const exception&)
	{
        TrERROR(NETWORKING, "Packet is not valid");

		ASSERT_BENIGN(0);
		//
		// Close the session, we dont decrease the ref count so it will be released when ReadComplited
		// will try to continue reading from the close socket and will fire exception
		//
		Close_Connection(this, L"Internal Header is not valid");
		LogHR(MQ_ERROR, s_FN, 350);
		return;
	}
}


/*====================================================

CSockTransport::UpdateRecvAcknowledgeNo

Arguments:

Return Value:

Thread Context:
=====================================================*/
void CSockTransport::UpdateRecvAcknowledgeNo(CQmPacket* pPkt)
{
    CS lock(m_cs);

    //
    // Set the acknowledge number such the sender
    // get indication it was received and will not send it again.
    //
    m_wUnAckRcvPktNo = pPkt->GetAcknowladgeNo();
    //
    // Send read ack to source machine
    //
    m_fSendAck = TRUE;

    //
    // Increament the number of unacked packet
    //
    IncRecvUnAckPacketNo();
    //
    //  if the Window limit has reached, send the session acks now
    //
    if (GetRecvUnAckPacketNo() >= (m_wRecvWindowSize/2))
    {
        DBGMSG((DBGMOD_QMACK,
                DBGLVL_WARNING,
                _TEXT("Unacked packet no. reach the limitation (%d). ACK packet was sent"), m_wRecvWindowSize));
        DBGMSG((DBGMOD_QMACK, DBGLVL_TRACE, TEXT("Window size, My = %d, Other = %d"), SessionMgr.GetWindowSize(),m_wRecvWindowSize));

        SendReadAck(eStandAlone);
        return;
    }

    if (m_nSendAckSchedules == 0)
    {
        //
        // Increment Session referance count for the SendReadAck. The refernce is decremented
        // when the session is closed.
        //
        AddRef();

        ++m_nSendAckSchedules;
        ExSetTimer(&m_SendAckTimer, CTimeDuration::FromMilliSeconds(m_dwSendAckTimeout));
    }
}

/*====================================================

CSockTransport::RejectPacket

Arguments:

Return Value:

Thread Context:
=====================================================*/
void CSockTransport::RejectPacket(CQmPacket* pPkt, USHORT usClass)
{
    //
    // Update the receive packet nomber such we can send a session acknowledge
    // for it.
    //
    UpdateRecvAcknowledgeNo(pPkt);
    //
    // Update the session storage acknowledge no.
    //
    if (pPkt->GetStoreAcknowledgeNo() != 0)
    {
        SetStoredAck(pPkt->GetStoreAcknowledgeNo());
    }

    ACFreePacket(g_hAc, pPkt->GetPointerToDriverPacket(), usClass);
}


/*====================================================

CSockTransport::ReceiveOrderedMsg

Arguments:

Return Value:

Thread Context:
=====================================================*/
void CSockTransport::ReceiveOrderedMsg(CQmPacket *pPkt,
                                       CQueue* pQueue,
                                       BOOL fDuplicate
                                       )
{

    ASSERT(g_pInSeqHash);

    // We need to tie together Verify and PutOrderedPacket
    CS lock(g_critVerifyOrdered);

    if(!g_pInSeqHash->Verify(pPkt))
    {
        // Packet has a wrong seq number. Send back Seq Ack with last good number.
        // g_pInSeqHash->SendSeqAckForPacket(pPkt);
        RejectPacket(pPkt, 0);
        return;
    }

    USHORT usClass = VerifyRecvMsg(pPkt, pQueue);
    if(MQCLASS_NACK(usClass))
    {
        // We want to register number in database, log it, send seq ack,
        //    but we don't want any ACPutPAcket in AppendCallback
        g_pInSeqHash->Register(pPkt, NULL);
        RejectPacket(pPkt, (USHORT)(fDuplicate ? 0 : usClass));
        return;
    }

    //
    // Accepted. Mark as received (to be invisible to readers yet) and store in the queue.
    //
    HRESULT rc = pQueue->PutOrderedPkt(pPkt, FALSE, this);
    if (FAILED(rc))
    {
        ACFreePacket(g_hAc, pPkt->GetPointerToDriverPacket());
        LogIllegalPoint(s_FN, 774);
        Close_Connection(this, L"Allocation Failure in receive packet procedure");

        return;
    }
}

/*====================================================

CSockTransport::HandleReceiveUserMsg

Arguments:

Return Value:

Thread Context:
=====================================================*/

void CSockTransport::HandleReceiveUserMsg(CBaseHeader* pBaseHeader,
                                          CPacket * pDriverPacket)
{

    //
    // The whole packet is read.
    //
    CQmPacket thePacket(pBaseHeader, pDriverPacket, true);
    CQmPacket* pPkt = &thePacket;

    if (IsDisconnected())
    {
        DBGMSG((DBGMOD_NETSESSION,
                DBGLVL_TRACE,
                _T("Discard received user message. The session %ls is disconnected"), GetStrAddr())) ;

        //
        // If the network is disconnected, MSMQ doesn't ready to
        // get a new user packet. The QM discard the incoming
        // user packet. Only the internal packet is handled
        //
        ACFreePacket(g_hAc, pPkt->GetPointerToDriverPacket(), 0);
        return;
    }

    //
    // Update statistics
    //
    RcvStats(pPkt->GetSize());

    //
    // Send Report message if needed
    //
    ReportMsgInfo MsgInfo;
    MsgInfo.SetReportMsgInfo(pPkt);
    MsgInfo.SendReportMessage(NULL);

    //
    // Increment read and store acknowledgment No.
    //
    IncReadAck(pPkt);

    //
    // Increment Hop Count
    //
    pPkt->IncHopCount();

    #ifdef _DEBUG
    {
        OBJECTID MessageId;
        pPkt->GetMessageId(&MessageId);

        DBGMSG((DBGMOD_NETSESSION,
                DBGLVL_WARNING,
                _TEXT("Receive packet from %ls, Packet ID = %!guid!\\%u"),GetStrAddr(), &MessageId.Lineage, MessageId.Uniquifier));

    }
    #endif

    DBG_MSGTRACK(DBGMOD_MSGTRACK, pPkt, _T("RECEIVE message"));

    DBGMSG((DBGMOD_NETSESSION,
            DBGLVL_INFO,
            _T("::HandleReceiveUserMsg. for session %ls Packet Size %d, Include Ack section %d, Include debug Section %d"),
                GetStrAddr(), pPkt->GetSize(),  pPkt->IsSessionIncluded(), pPkt->IsDbgIncluded()));

    //
    // Insert the message to remove duplicate tabel. If the message already exist,
    // the insertion failed and the routine returns FALSE.
    // Don't throw the packet here, give the transactional mechanism chance to look at it.
    //
    OBJECTID MsgIdDup;
    BOOL fDuplicate = FALSE;
    BOOL fToDupInserted = FALSE;
    if (!pPkt->IsOrdered())
    {
        pPkt->GetMessageId(&MsgIdDup);
        fDuplicate = !DpInsertMessage(thePacket);
        fToDupInserted = !fDuplicate;

        if (fDuplicate)
        {
            DBGMSG((DBGMOD_NETSESSION,
                    DBGLVL_ERROR,
                    _T("RECEIVE DUPLICATE %ls MESSAGE: %!guid!\\%d"),
                    (pPkt->IsOrdered() ? L"xact" : L""), &MsgIdDup.Lineage, MsgIdDup.Uniquifier));
        }

    }

    //
    // In any case of packet rejection we delete it from the remove duplicate map
    //
    CAutoDeletePacketFromDuplicateMap AutoDeletePacketFromDuplicateMap(fToDupInserted ? pPkt : NULL);

    //
    //  Get the packet destination queue object
    //
    HRESULT rc;
    CQueue* pQueue = NULL;
    rc = GetDstQueueObject(pPkt, &pQueue, true);
    R<CQueue> Ref = pQueue;

    if(FAILED(rc))
    {
        RejectPacket(pPkt, (USHORT)(fDuplicate ? 0 : MQMSG_CLASS_NACK_BAD_DST_Q));
        return;
    }

    //
    //  Handle local queue cases
    //
    USHORT usClass;
    if(pQueue->IsLocalQueue())
    {
        //
        //  Match ordered packets with transactional queue
        //
        usClass = VerifyTransactRights(pPkt, pQueue);
        if(MQCLASS_NACK(usClass))
        {
            RejectPacket(pPkt, (USHORT)(fDuplicate ? 0 : usClass));
            return;
        }

        //
        //  Verify packet is not a duplicate ordered packet
        //
        if(pPkt->IsOrdered())
        {
            // Process ordered incoming message
            ReceiveOrderedMsg(pPkt, pQueue, fDuplicate);
            //
            // packet handling completed successfully. Set the packet acknowledge number
            //
            UpdateRecvAcknowledgeNo(pPkt);
            return;
        }
    }

    if (fDuplicate)
    {
        //
        // Duplicate message. Update the acknowledge numbers and
        // throw the packet
        //
        RejectPacket(pPkt, 0);
        return;
    }

    // From here on we deal only with non-ordered message

    usClass = VerifyRecvMsg(pPkt, pQueue);
    if(MQCLASS_NACK(usClass))
    {
        RejectPacket(pPkt, usClass);
        return;
    }

    //
    // We get the crtical section here in order to elimante the case that
    // storage ack is updated before the Sync ack. In such a case the
    // storage ack is ignored by the sender.
    //
    CS lock(m_cs);

    rc = pQueue->PutPkt(pPkt, FALSE, this);

    if (FAILED(rc))
    {
        ACFreePacket(g_hAc, pDriverPacket);
        LogIllegalPoint(s_FN, 775);
        Close_Connection(this, L"Allocation Failure in receive packet procedure");
    }
    //
    // packet handling completed successfully. Set the packet acknowledge number
    //
    UpdateRecvAcknowledgeNo(pPkt);

    //
    // The packet was accepted so we keep it in the duplicate map
    //
    AutoDeletePacketFromDuplicateMap.detach();
}


/*====================================================

  CSockTransport::HandleEstablishConnectionPacket

  Arguments:    pcPacket - pointer to Establish  Connection Packet

  Return Value: none

=====================================================*/
void CSockTransport::HandleEstablishConnectionPacket(CBaseHeader* pBase)
{
    PVOID pPkt = NULL;
    DWORD dwPacketSize;
    {
        PVOID pSect = NULL;
        CS lock(m_cs);

        if (GetSessionStatus() >= ssEstablish)
        {
        	//
        	// this can not be unless someone is hacking us
        	//
            DBGMSG((DBGMOD_NETSESSION,
	            DBGLVL_ERROR,
    		    _T("Recieved Establish Connection Packet twice")));
            ASSERT_BENIGN(0);
			throw exception();
        }

        CInternalSection* pInternal = pBase->section_cast<CInternalSection*>(pBase->GetNextSection());
        CECSection* pECP = pBase->section_cast<CECSection*>(pInternal->GetNextSection());

        ASSERT(pInternal->GetPacketType() == INTERNAL_ESTABLISH_CONNECTION_PACKET);

        DBGMSG((DBGMOD_NETSESSION,
                DBGLVL_INFO,
                _T("ESTABLISH CONNECTION: Get Establish connection packet (client=%d). Client Id %!guid!, Server Id %!guid!"), IsClient(), pECP->GetClientQMGuid(), pECP->GetServerQMGuid()));

        if (m_sock == 0)
        {
            // the session was closed.
            return;
        }

        SetSessionStatus(ssEstablish);
        //
        // Set the other side type. we need it inorder to update the number
        // of active session later
        //
        OtherSideIsServer(pECP->IsOtherSideServer());

        GUID * pOtherQMGuid ;
        if (IsClient())
        {
            pOtherQMGuid = const_cast<GUID*>(pECP->GetServerQMGuid()) ;
        }
        else
        {
            pOtherQMGuid = const_cast<GUID*>(pECP->GetClientQMGuid()) ;
        }

        BOOL fAllowNewSession = !pECP->CheckAllowNewSession() ||
                                 g_QMLicense.NewConnectionAllowed(!pECP->IsOtherSideServer(), pOtherQMGuid);

        if (IsClient())
        {
        	if ((!QmpIsLocalMachine(pECP->GetClientQMGuid())) || (pECP->GetVersion() != FALCON_PACKET_VERSION))
        	{
                DBGMSG((DBGMOD_NETSESSION,
                    DBGLVL_ERROR,
                    _T("Establish Connection Packet is not valid")));
	            ASSERT_BENIGN(QmpIsLocalMachine(pECP->GetClientQMGuid()));
    	        ASSERT_BENIGN(pECP->GetVersion() == FALCON_PACKET_VERSION);
				throw exception();
        	}

            if (pInternal->GetRefuseConnectionFlag() || (! fAllowNewSession))
            {
                if (!fAllowNewSession)
                {
                    DBGMSG((DBGMOD_NETSESSION,
                        DBGLVL_WARNING,
                        _T("create a new session with %ls Failed, due session limitation"), GetStrAddr()));
                }
                else
                {
                    DBGMSG((DBGMOD_NETSESSION,
                        DBGLVL_WARNING,
                        _T("create a new session with %ls Failed. Other side refude to create the connection"), GetStrAddr()));
                }

                //
                // Move all the queues in the session to the waiting group. otherwise
                // the Qm try immidiatly to create a session again this session will be refused
                // and so on and so on.
                //
                R<CQueue> pQueue;

                if (GetGroup())
                {
                    pQueue = GetGroup()->RemoveHeadFromGroup();
                }

                while (pQueue.get())
                {
#ifdef _DEBUG
                    if (pQueue->GetRoutingRetry() == 1)
                    {
                        WCHAR StrAddr[100];
                        TA2StringAddr(GetSessionAddress(), StrAddr);

                        DBGMSG((DBGMOD_ALL,
                            DBGLVL_ERROR,
                            _TEXT("Create connection refused by %ls. Cannot route messages to queue %ls"),
                            (StrAddr+2),pQueue->GetQueueName()));
                    }
#endif

                    pQueue->SetSessionPtr(NULL);
                    g_pgroupWaiting->AddToGroup(pQueue.get());
                    SessionMgr.AddWaitingQueue(pQueue.get());

                    pQueue = GetGroup()->RemoveHeadFromGroup();
                }

                // connection refused. Close the session
                Close_Connection(this, L"Connection refused");
                //
                // Decrement reference count
                //
                Release();

                return;
            }
            else
            {
                //
                // Either the server ID matches expected ID or this is
                // a DIRECT connection
                //
                if ((*GetQMId() != *pECP->GetServerQMGuid()) && (*GetQMId() != GUID_NULL))
                {
		                DBGMSG((DBGMOD_NETSESSION,
        		            DBGLVL_ERROR,
                		    _T("Establish Connection Packet is not valid, Server side")));
		                ASSERT_BENIGN(*GetQMId() == *pECP->GetServerQMGuid());
	    	            ASSERT_BENIGN(*GetQMId() == GUID_NULL);
					    throw exception();
                }
                SetQMId(pECP->GetServerQMGuid());

                // Get time
                DWORD dwECTime = GetTickCount() - pECP->GetTimeStamp();
                // Create CP Packet
                CreateConnectionParameterPacket(dwECTime, (CBaseHeader**)&pPkt, &dwPacketSize);
            }
        }
        else
        {
            // Create Return Packet
            dwPacketSize = pBase->GetPacketSize();
            pPkt = new UCHAR[dwPacketSize];
            memset(pPkt, 0x5a, dwPacketSize) ; // bug 5483

            if (CSessionMgr::m_fUseQoS)
            {
                m_fQoS = pECP->IsOtherSideQoS();
            }

    #ifdef _DEBUG
    #undef new
    #endif
            CBaseHeader* pBase = new(pPkt) CBaseHeader(dwPacketSize);
            pBase->SetType(FALCON_INTERNAL_PACKET);
            pSect = (PVOID) pBase->GetNextSection();

            CInternalSection* pInternalSect = new(pSect) CInternalSection(INTERNAL_ESTABLISH_CONNECTION_PACKET);
            pSect = pInternalSect->GetNextSection();

            CECSection* pECSection = new(pSect) CECSection(pECP->GetClientQMGuid(),
                                                           CQueueMgr::GetQMGuid(),
                                                           pECP->GetTimeStamp(),
                                                           OS_SERVER(g_dwOperatingSystem),
                                                           m_fQoS);
            pECSection->CheckAllowNewSession(pECP->CheckAllowNewSession());

    #ifdef _DEBUG
    #define new DEBUG_NEW
    #endif
            //
            // server side. check if there is a free session on the macine and
            // if the DestGuid is me and the supported packet version
            //
            // we arrive here only if the another machine
            // We don't check the number of active session in accept since we want to limited
            // the situation that the other side try to create a new session immidiatly.
            // If we use the refuse mechanism the queue move to waiting group only after some
            // time, we try to create connection again. This come to limit unnecessary network
            // traffic
            //
            if (((*(pECP->GetServerQMGuid()) != GUID_NULL) && (! QmpIsLocalMachine(pECP->GetServerQMGuid()))) ||
                (pECP->GetVersion() != FALCON_PACKET_VERSION) ||
                (!fAllowNewSession))
            {
                pInternalSect->SetRefuseConnectionFlag();
            }
            else
            {
                SetQMId(pECP->GetClientQMGuid());
            }
        }
    }

    DBGMSG((DBGMOD_NETSESSION,
            DBGLVL_INFO,
            _T("Write to socket %ls Handle establish. Write %d bytes"),  GetStrAddr(), dwPacketSize));
    HRESULT hr = CreateSendRequest(pPkt, pPkt, dwPacketSize, FALSE);
    UNREFERENCED_PARAMETER(hr);
}

/*====================================================

  CSockTransport::HandleConnectionParameterPacket

  Arguments:    pcPacket - pointer to Connection Parameter Packet

  Return Value: None. Throws an exception.

=====================================================*/
void
CSockTransport::HandleConnectionParameterPacket(
    CBaseHeader* pBase
    )
    throw(bad_alloc)
{
    CS lock(m_cs);

    if (GetSessionStatus() != ssEstablish)
    {
    	//
    	// this can not be unless someone is hacking us
    	//
        DBGMSG((DBGMOD_NETSESSION,
            DBGLVL_ERROR,
		    _T("Recieved EConnection Parameter Packet twice")));
        ASSERT_BENIGN(0);
		throw exception();
    }

    HRESULT hr;
    CInternalSection* pInternal = pBase->section_cast<CInternalSection*>(pBase->GetNextSection());
    CCPSection* pCP = pBase->section_cast<CCPSection*>(pInternal->GetNextSection());

    ASSERT(pInternal->GetPacketType() == INTERNAL_CONNECTION_PARAMETER_PACKET);

    DBGMSG((DBGMOD_NETSESSION,
            DBGLVL_TRACE,
            _T("Get connection Parameter packet from: %ls (Client = %d)\n\t\tAckTimeout %d, Recover  %d, window size %d"),
                GetStrAddr(), IsClient(),pCP->GetAckTimeout(), pCP->GetRecoverAckTimeout(), pCP->GetWindowSize()));

    if (m_sock == 0)
    {
        //The session was closed
        return;
    }

    if (!IsClient())
    {
        //
        // Set the connection parameters
        //
        m_dwAckTimeout =          pCP->GetAckTimeout();
        m_dwSendAckTimeout =      m_dwAckTimeout/2;
        m_dwSendStoreAckTimeout = pCP->GetRecoverAckTimeout();
        //
        // Set Server window size. And send CP Packet to the client
        //
        m_wRecvWindowSize = pCP->GetWindowSize();

        DWORD dwPacketSize = sizeof(CBaseHeader) + sizeof(CInternalSection) + sizeof(CCPSection);
        PVOID pPkt = new UCHAR[dwPacketSize];
        CCPSection* pCPSection;
#ifdef _DEBUG
#undef new
#endif
        CBaseHeader* pBaseSend = new(pPkt) CBaseHeader(dwPacketSize);
        pBaseSend->SetType(FALCON_INTERNAL_PACKET);
        PVOID pSect = (PVOID) pBaseSend->GetNextSection();

        CInternalSection* pInternal = new(pSect) CInternalSection(INTERNAL_CONNECTION_PARAMETER_PACKET);
        pSect = (PVOID) pInternal->GetNextSection();

        pCPSection = new(pSect) CCPSection(SessionMgr.GetWindowSize(),
                                           m_dwSendStoreAckTimeout,
                                           m_dwAckTimeout,
                                           0);
#ifdef _DEBUG
#define new DEBUG_NEW
#endif
        //
        // In this stage no one else can catch the m_csSend since the
        // SendAck wasn't set yet and user messages are not send
        //
        DBGMSG((DBGMOD_NETSESSION,
                DBGLVL_INFO,
                _T("Write to socket %ls Create Connection Packet. Write %d bytes"), GetStrAddr(),  dwPacketSize));
        hr = CreateSendRequest(pPkt, pPkt, dwPacketSize, FALSE);

        //
        // Check if the connection has been closed
        //
        if (FAILED(hr))
        {
            return;
        }
    }
    else
    {
        // client side
		if ((m_dwAckTimeout != pCP->GetAckTimeout()) || (m_dwSendStoreAckTimeout != pCP->GetRecoverAckTimeout()))
		{
	        DBGMSG((DBGMOD_NETSESSION,
	            DBGLVL_ERROR,
			    _T("Connection Parameter Packet is not valid")));
		    ASSERT_BENIGN(m_dwAckTimeout == pCP->GetAckTimeout());
		    ASSERT_BENIGN(m_dwSendStoreAckTimeout == pCP->GetRecoverAckTimeout());
			throw exception();
		}
		m_wRecvWindowSize = pCP->GetWindowSize();

    }

    SessionMgr.NotifyWaitingQueue(GetSessionAddress(), this);

#ifdef _DEBUG
    DBGMSG((DBGMOD_NETSESSION,DBGLVL_TRACE,_T("Session created with %ls, Sock Handle %Ix"), GetStrAddr(), m_sock));
    DBGMSG((DBGMOD_NETSESSION,DBGLVL_INFO,_T("\tAckTimeout value: %d"), m_dwAckTimeout)) ;
    DBGMSG((DBGMOD_NETSESSION,DBGLVL_INFO,_T("\tSend Storage AckTimeout value: %d"), m_dwSendStoreAckTimeout)) ;
    DBGMSG((DBGMOD_NETSESSION,DBGLVL_INFO,_T("\tSend window size: %d"), SessionMgr.GetWindowSize()));
    DBGMSG((DBGMOD_NETSESSION,DBGLVL_INFO,_T("\tReceive window size: %d"), m_wRecvWindowSize));
#endif



    if (GetGroup() != NULL)
    {
        //
        // Set all the queues in group as active
        //
        GetGroup()->EstablishConnectionCompleted();
        //
        // Create a get request from new group
        //
        hr = GetNextSendMessage();
    }

    //
    // The establish connection completed successfully. Remove the callinig to failure
    // handling function
    //
    SetSessionStatus(ssActive);
    if(ExCancelTimer(&m_CancelConnectionTimer))
    {
        Release();  // Release Establish connection reference count
    }

    if (!IsOtherSideServer())
    {
        //
        // Increment the number of active session
        //
        g_QMLicense.IncrementActiveConnections(&m_guidDstQM, L"", NULL);
    }

    if (IsDisconnected())
    {
        Disconnect();
    }

}

/*====================================================

  CSockTransport::CreateConnectionParameterPacket

  Arguments:

  Return Value:

=====================================================*/
void
CSockTransport::CreateConnectionParameterPacket(IN DWORD dwSendTime,
                                               OUT CBaseHeader** ppPkt,
                                               OUT DWORD* pdwPacketSize)
{

    //
    // Set session acking timeout
    //
    if (CSessionMgr::m_dwSessionAckTimeout != INFINITE)
    {
        m_dwAckTimeout = CSessionMgr::m_dwSessionAckTimeout;
    }
    else
    {
        //
        // ACK Timeout
        //
        m_dwAckTimeout = dwSendTime * 80 * 10;
        //
        // Check if less than the minimume or grater than the maximume
        //
        if (MSMQ_MIN_ACKTIMEOUT > m_dwAckTimeout)
        {
            m_dwAckTimeout = MSMQ_MIN_ACKTIMEOUT;
        }
        if (m_dwAckTimeout > MSMQ_MAX_ACKTIMEOUT)
        {
            m_dwAckTimeout  = MSMQ_MAX_ACKTIMEOUT;
        }
    }

    //
    // Set send ack timeout
    //
    m_dwSendAckTimeout = m_dwAckTimeout / 4;

    //
    // Set storage ack timeout
    //
    if (CSessionMgr::m_dwSessionStoreAckTimeout != INFINITE)
    {
        m_dwAckTimeout = CSessionMgr::m_dwSessionStoreAckTimeout;
    }
    else
    {
        //
        // ACK Timeout
        //
        m_dwSendStoreAckTimeout = dwSendTime * 8;

        //
        // Check if greater than the minimume value
        //
        if (MSMQ_MIN_STORE_ACKTIMEOUT > m_dwSendStoreAckTimeout)
        {
            m_dwSendStoreAckTimeout = MSMQ_MIN_STORE_ACKTIMEOUT;
        }
        //
        // Set storage ack sending timeout
        //
        if (m_dwSendStoreAckTimeout > m_dwSendAckTimeout)
        {
            m_dwSendStoreAckTimeout = m_dwSendAckTimeout;
        }
    }

    DWORD dwPacketSize = sizeof(CBaseHeader) + sizeof(CInternalSection) + sizeof(CCPSection);
    PVOID pPkt = new UCHAR[dwPacketSize];
#ifdef _DEBUG
#undef new
#endif
    CBaseHeader* pBase = new(pPkt) CBaseHeader(dwPacketSize);
    pBase->SetType(FALCON_INTERNAL_PACKET);
    PVOID pSect = (PVOID) pBase->GetNextSection();

    CInternalSection* pInternal = new(pSect) CInternalSection(INTERNAL_CONNECTION_PARAMETER_PACKET);
    pSect = pInternal->GetNextSection();

    CCPSection* pCPSection = new(pSect) CCPSection((WORD)SessionMgr.GetWindowSize(),
                                                   m_dwSendStoreAckTimeout,
                                                   m_dwAckTimeout,
                                                   0);
    UNREFERENCED_PARAMETER(pCPSection);

    DBGMSG((DBGMOD_NETSESSION,
            DBGLVL_INFO,
            _T("ESTABLISH CONNECTION (client): Send Connection Parameter packet: AckTimeout %d, Recover  %d, window size %d"),
                                               m_dwAckTimeout, m_dwSendStoreAckTimeout, SessionMgr.GetWindowSize()));
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

    *ppPkt = pBase;
    *pdwPacketSize = dwPacketSize;
}



/*====================================================

SendEstablishConnectionPacket

Arguments:

Return Value:

Note : This function cant throw   exception because receiver already listen on the connection
=====================================================*/
void
CSockTransport::SendEstablishConnectionPacket(
    const GUID* pDstQMId,
    BOOL fCheckNewSession
    )throw()
{

    try
    {
        //
        // Set timer to check that the connection completed successfully. If yes, the function
        // is removed from the scheduler wakeup list and never is called. Otherwise, the function
        // close the session and move all the associated queues to non-active group.
        //
        ExSetTimer(&m_CancelConnectionTimer, CTimeDuration::FromMilliSeconds(ESTABLISH_CONNECTION_TIMEOUT));


        DWORD dwPacketSize;
        PVOID pPacket;
        HRESULT hr;
        CECSection* pECSession;


        dwPacketSize = sizeof(CBaseHeader) + sizeof(CInternalSection) + sizeof(CECSection);
        pPacket = new UCHAR[dwPacketSize];

    #ifdef _DEBUG
    #undef new
    #endif
        CBaseHeader* pBase = new(pPacket) CBaseHeader(dwPacketSize);
        pBase->SetType(FALCON_INTERNAL_PACKET);
        PVOID pSect = (PVOID) pBase->GetNextSection();

        CInternalSection* pInternal = new(pSect) CInternalSection(INTERNAL_ESTABLISH_CONNECTION_PACKET);
        pSect = pInternal->GetNextSection();

        pECSession = new(pSect) CECSection(CQueueMgr::GetQMGuid(),
                                           pDstQMId,
                                           OS_SERVER(g_dwOperatingSystem),
                                           m_fQoS
                                           );
        pECSession->CheckAllowNewSession(fCheckNewSession);
    #ifdef _DEBUG
    #define new DEBUG_NEW
    #endif

        DBGMSG((DBGMOD_NETSESSION,
                DBGLVL_INFO,
                _T("Write to socket %ls Establish Connection Packet. Write %d bytes"), GetStrAddr(),  dwPacketSize));
        hr = CreateSendRequest(pPacket, pPacket, dwPacketSize, FALSE);

        //
        // Check if the connection has been closed
        //
        if (FAILED(hr))
        {
            delete [] pPacket;
            return;
        }

        DBGMSG((DBGMOD_NETSESSION,
                DBGLVL_INFO,
                _T("ESTABLISH CONNECTION (client): Send Establish connection packet to ") _T(LOG_GUID_FMT), LOG_GUID(pDstQMId)));

    }

    catch(const std::exception&)
    {
        DBGMSG((DBGMOD_NETSESSION,  DBGLVL_ERROR,_T("Unexpected error in function CSockTransport::SendEstablishConnectionPacket")));
        LogIllegalPoint(s_FN, 800);
    }
}





void
CTransportBase::EstablishConnectionNotCompleted(void)
{
    CS lock(m_cs);


    //
    // Close connection. If this function is called the establish
    // connection not completed from any reason.
    //
    Close_Connection(this, L"EstablishConnectionNotCompleted");
    //
    // Decrement reference count
    //
    Release();

}


void
CSockTransport::CloseDisconnectedSession(
    void
    )
{
    ASSERT(IsDisconnected());
    ASSERT(m_fCloseDisconnectedScheduled);

    if (!IsUsedSession())
    {
        Close_Connection(this, L"Disconnect network");
        Release();

        return;
    }

    SetUsedFlag(FALSE);
    ExSetTimer(&m_CloseDisconnectedTimer, CTimeDuration::FromMilliSeconds(1000));
}


void
CSockTransport::Disconnect(
    void
    )
{
    CS lock(m_cs);

    SetDisconnected();
    if ((GetSessionStatus() == ssActive) && !m_fCloseDisconnectedScheduled)
    {
        DBGMSG((DBGMOD_NETSESSION,
                DBGLVL_TRACE,
                _T("Disconnect ssesion with %ls"), GetStrAddr()));

        SendReadAck(eStandAlone);

        m_fCloseDisconnectedScheduled = TRUE;
        AddRef();
        ExSetTimer(&m_CloseDisconnectedTimer, CTimeDuration::FromMilliSeconds(1000));
    }
}

void
CSockTransport::UpdateNumberOfStorageUnacked(
    WORD BaseNo,
    DWORD BitField
    )
{
    if (BaseNo == 0)
        return;

    DBGMSG((DBGMOD_QMACK,
        DBGLVL_TRACE,
        _T("(0x%p %ls) UpdateNumberOfStorageUnacked. \n\tBaseNo: %d, \n\tBitField: 0x%x \n\tm_lStoredPktReceivedNoAckedCount %d"),
            this, this->GetStrAddr(), BaseNo, BitField, m_lStoredPktReceivedNoAckedCount));

    LONG RetVal = InterlockedDecrement(&m_lStoredPktReceivedNoAckedCount);

    ASSERT(RetVal >= 0);
    DBG_USED(RetVal);

    for (DWORD i = 0; i < STORED_ACK_BITFIELD_SIZE; ++i)
    {
       if (BitField & (1 << i))
       {
            LONG RetVal = InterlockedDecrement(&m_lStoredPktReceivedNoAckedCount);
            ASSERT(RetVal >= 0);
            DBG_USED(RetVal);
       }
    }
}

/*======================================================

   FUNCTION: CSockTransport::IsUsedSession

========================================================*/
inline BOOL
CSockTransport::IsUsedSession(void) const
{
    //
    // The session already closed, it Is n't used any more
    //
    if (m_sock == 0)
        return FALSE;

    //
    // The session was used for receive or send from the last check point
    //
    if (GetUsedFlag())
        return TRUE;

    //
    // There is pending message that waiting for acknowledgment
    //
    if (!(m_listUnackedPkts.IsEmpty() && m_listStoredUnackedPkts.IsEmpty()))
        return TRUE;

    //
    // Acknowledge message must be sent
    //
    if (m_fSendAck || (m_lStoredPktReceivedNoAckedCount != 0))
        return TRUE;

    return FALSE;
}

void
WINAPI
CSockTransport::SendFastAcknowledge(
    CTimer* pTimer
    )
/*++
Routine Description:
    The function is called from scheduler when fast sending acknowledge
    timeout is expired.

Arguments:
    pTimer - Pointer to Timer structure. pTimer is part of the sock transport
             object and it use to retrive the transport object.

Return Value:
    None

--*/
{
    CSockTransport* pSock = CONTAINING_RECORD(pTimer, CSockTransport, m_FastAckTimer);

    DBGMSG((DBGMOD_QMACK,
            DBGLVL_TRACE,
            _T("Send Fast acknowledge for session %ls"), pSock->GetStrAddr()));
    pSock->SendFastAckPacket();
}


void
CSockTransport::SetFastAcknowledgeTimer(
    void
    )
{
    //
    // try to cancel the previous sceduling
    //
    if (!ExCancelTimer(&m_FastAckTimer))
    {
        //
        // cancel failed. It means that there is no pending timer.
        // As a result begin a new timer and increment the sock transport
        // reference count
        //
        AddRef();
    }
    else
    {
        DBGMSG((DBGMOD_QMACK,
                DBGLVL_TRACE,
                _T("Cancel Fast acknowledge for session %ls"), GetStrAddr()));
    }

    //
    // Set a new timer for sending fast acknowledge
    //
    ExSetTimer(&m_FastAckTimer, CTimeDuration::FromMilliSeconds(CSessionMgr::m_dwIdleAckDelay));

    DBGMSG((DBGMOD_QMACK,
            DBGLVL_TRACE,
            _T("Set Fast acknowledge for session %ls, Max Delay %d ms"), GetStrAddr(), CSessionMgr::m_dwIdleAckDelay));

}


inline
void
CSockTransport::SendFastAckPacket(
    void
    )
{
    //
    // when the session is in disconnected mode, MSMQ doesn't return an acknowledge
    // for receiving messages.
    // An acknowledge for recoverable messages are handled using the SendAck mechanism
    //
    if (m_fSendAck && !IsDisconnected())
    {
        SendReadAck(eStandAlone);
    }

    Release();
}


void
WINAPI
CSockTransport::TimeToCheckAckReceived(
    CTimer* pTimer
    )
/*++
Routine Description:
    The function is called from scheduler when Check for ack
    timeout is expired.

Arguments:
    pTimer - Pointer to Timer structure. pTimer is part of the sock transport
             object and it use to retrive the transport object.

Return Value:
    None

--*/
{
    CSockTransport* pSock = CONTAINING_RECORD(pTimer, CSockTransport, m_CheckAckReceivedTimer);
    pSock->CheckForAck();
}


void
WINAPI
CSockTransport::TimeToSendAck(
    CTimer* pTimer
    )
/*++
Routine Description:
    The function is called from scheduler when need to send an acknowledge

Arguments:
    pTimer - Pointer to Timer structure. pTimer is part of the sock transport
             object and it use to retrive the transport object.

Return Value:
    None

--*/
{
    CSockTransport* pSock = CONTAINING_RECORD(pTimer, CSockTransport, m_SendAckTimer);
    pSock->SendAckPacket();
}


void
WINAPI
CSockTransport::TimeToSendPendingAck(
    CTimer* pTimer
    )
/*++
Routine Description:
    The function is called from scheduler when need to send a pending acknowledge

Arguments:
    pTimer - Pointer to Timer structure. pTimer is part of the sock transport
             object and it use to retrive the transport object.

Return Value:
    None

--*/
{
    CSockTransport* pSock = CONTAINING_RECORD(pTimer, CSockTransport, m_SendPendingAckTimer);
    pSock->SendPendingReadAck();
}


void
CSockTransport::ReleaseSendSemaphore(
    void
    )
{
    if (InterlockedExchange(&m_fSendBusy, FALSE) != TRUE)
    {
        ASSERT(0);
    }

    DBGMSG((
        DBGMOD_NETSESSION,
        DBGLVL_INFO,
        L"Release send semaphore for session %ls (Time %d)",
        GetStrAddr(),
        GetTickCount()
        ));
}


BOOL
CSockTransport::GetSendSemaphore(
    void
    )
{
    BOOL f = TRUE;

    if (InterlockedExchange(&m_fSendBusy, TRUE))
    {
        f = FALSE;
    }

    DBGMSG((
        DBGMOD_NETSESSION,
        DBGLVL_INFO,
        L"Get send semaphore for session %ls. Status %d (Time %d)",
        GetStrAddr(),
        f,
        GetTickCount()
        ));

    return f;
}


void
WINAPI
CSockTransport::TimeToCancelConnection(
    CTimer* pTimer
    )
{
    CSockTransport* pSock = CONTAINING_RECORD(pTimer, CSockTransport, m_CancelConnectionTimer);
    pSock->EstablishConnectionNotCompleted();
}


void
WINAPI
CSockTransport::TimeToCloseDisconnectedSession(
    CTimer* pTimer
    )
{
    CSockTransport* pSock = CONTAINING_RECORD(pTimer, CSockTransport, m_CloseDisconnectedTimer);
    pSock->CloseDisconnectedSession();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\rmdupl.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:
    rmdupl.cpp

Abstract:
    Remove Duplicate implementation

Author:
    Uri Habusha (urih)   18-Oct-98

Enviroment:
    Pltform-independent 

--*/

#include "stdh.h"
#include <qmpkt.h>
#include "list.h"
#include "rmdupl.h"
#include <Tr.h>
#include <Ex.h>

#include "rmdupl.tmh"

static WCHAR *s_FN=L"rmdupl";

//
//  STL include files are using placment format of new
//

#ifdef new
#undef new
#endif

#include <map>
#include <set>

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

using namespace std;


struct CMsgEntry;

struct msg_entry_less : public std::binary_function<const CMsgEntry*, const CMsgEntry*, bool> 
{
    bool operator()(const CMsgEntry* k1, const CMsgEntry* k2) const;
};


typedef set<CMsgEntry*, msg_entry_less> SET_MSG_ID;
typedef map<GUID, SET_MSG_ID> MAP_SOURCE;

struct CMsgEntry
{
public:
    CMsgEntry(
        DWORD id, 
        MAP_SOURCE::iterator it
        );

    void UpdateTimeStamp(void);

public:
    LIST_ENTRY  m_link;

    DWORD m_MsgId;
    DWORD m_TimeStamp;
    MAP_SOURCE::iterator m_it;
};

bool msg_entry_less::operator()(const CMsgEntry* k1, const CMsgEntry* k2) const
{
    return (k1->m_MsgId < k2->m_MsgId);
}

inline bool operator < (const GUID& k1, const GUID& k2)
{
    return (memcmp(&k1, &k2, sizeof(GUID)) < 0);
}


inline
CMsgEntry::CMsgEntry(
    DWORD id, 
    MAP_SOURCE::iterator it
    ) :
    m_MsgId(id),
    m_it(it),
    m_TimeStamp(GetTickCount())
{
    m_link.Flink = NULL;
    m_link.Blink = NULL;
}

inline
void 
CMsgEntry::UpdateTimeStamp(
    void
    )
{
    m_TimeStamp = GetTickCount();
}


class CMessageMap
{
public:
    CMessageMap();
    ~CMessageMap();

    BOOL InsertMessage(const OBJECTID& MsgId);
    void RemoveMessage(const OBJECTID& MsgId);

    static void WINAPI TimeToCleanup(CTimer* pTimer);

private:
    CMsgEntry* GetNewMessageEntry(DWORD MessageID, MAP_SOURCE::iterator it);

    void HandelCleanupSchedule(void);
    void CleanUp(DWORD CleanUpInterval);

#ifdef _DEBUG
    void DebugMsg(LPCWSTR msg, const GUID& MachineId, DWORD MsgId) const;
#else
    #define DebugMsg(msg, MachineId, MsgId) ((void) 0 )
#endif

    
private:
    CCriticalSection m_cs;

    List<CMsgEntry> m_OrderedList;
    MAP_SOURCE m_ReceivedMsgMap;
    CTimer m_CleanupTimer;
    BOOL m_fCleanupScheduled;

    DWORD m_CleanUpInterval;
    DWORD m_MaxSize;

    DWORD m_DuplicateStatics;
};


CMessageMap::CMessageMap() :
    m_fCleanupScheduled(FALSE),
    m_CleanupTimer(TimeToCleanup),
    m_CleanUpInterval(MSMQ_DEFAULT_REMOVE_DUPLICATE_CLEANUP),
    m_MaxSize(MSMQ_DEFAULT_REMOVE_DUPLICATE_SIZE),
    m_DuplicateStatics(0)
{
    //
    // Get the tabel size
    //
    DWORD size = sizeof(DWORD);
    DWORD type = REG_DWORD;
    GetFalconKeyValue(
        MSMQ_REMOVE_DUPLICATE_SIZE_REGNAME,
        &type,
        &m_MaxSize,
        &size
        );

    //
    // Get the Cleanup Interval
    //
    GetFalconKeyValue(
        MSMQ_REMOVE_DUPLICATE_CLEANUP_REGNAME,
        &type,
        &m_CleanUpInterval,
        &size
        );
}


CMessageMap::~CMessageMap()
{
    CS lock(m_cs);

    //
    // remove all the entries from the map and free the memory
    //
    CleanUp(0);
    ASSERT(m_ReceivedMsgMap.empty());
    ASSERT(m_OrderedList.getcount() == 0);
}


CMsgEntry* 
CMessageMap::GetNewMessageEntry(
    DWORD MessageID, 
    MAP_SOURCE::iterator it
    )
/*++

  Routine Description:
    The routine returns Message Entry for the new messge. If the tabel size reach the 
    limitation the routine removes the oldest entry and reuse it for the new one

  Parameters:
    MessageID - the message Id of the stored message
    it - iterator to the source map.

  Return value:
    pointer to the new message entry. If the new failed due lack of resources an
    exception is raised and handel at the API level

 --*/
{
    if (numeric_cast<DWORD>(m_OrderedList.getcount()) < m_MaxSize)
    {
        return new CMsgEntry(MessageID, it);
    }

    //
    // We reach the size limitation. Remove the oldest message
    // Id and use its structure for saving the new message
    //
    CMsgEntry* pMsgEntry = m_OrderedList.gethead();
    ASSERT(pMsgEntry != NULL);

    SET_MSG_ID& MsgMap = pMsgEntry->m_it->second;

    //
    // remove the entry from the source machine message ID
    //
    MsgMap.erase(pMsgEntry);

    //
    // if it was the last message in the map and it is not the entry
    // where the new one should be entered, remove it 
    //
    if (MsgMap.empty() && (pMsgEntry->m_it != it))
    {
        m_ReceivedMsgMap.erase(pMsgEntry->m_it);
    }

    #ifdef _DEBUG
    #undef new
    #endif

    return new(pMsgEntry) CMsgEntry(MessageID, it);

    #ifdef _DEBUG
    #define new DEBUG_NEW
    #endif
}

BOOL
CMessageMap::InsertMessage(
    const OBJECTID& MsgId
    )
/*++

  Routine Description:
    The routine insert a message to the remove duplicate tabel if 
    it doesn't exist

  Parameter:
    MsgId - a message ID that consist from GUID that specify the source machine
            and unique ID

  Returned Value:
    TRUE - if it is a new message ( the message inserted). FALSE otherwise.

 --*/
{
    //
    // MaxSize = 0 indicates not using the remove duplicate mechanism.
    // Don't try to enter the message, return immidietly.
    //
    if (m_MaxSize == 0)
        return TRUE;

    CS lock(m_cs);

    MAP_SOURCE::iterator it;

    //
    // Check if the source is already isn the map. If no, insert the source to the map. 
    // Generaly, the source will be in the map, therfore call find before insert
    // insert returnes the iterator. 
    //
    it = m_ReceivedMsgMap.find(MsgId.Lineage);
    if (it == m_ReceivedMsgMap.end())
    {
        pair<MAP_SOURCE::iterator, bool> p;
        p = m_ReceivedMsgMap.insert(MAP_SOURCE::value_type(MsgId.Lineage, SET_MSG_ID()));
        it = p.first;
    }
    
    //
    // Create message entry to add to the map
    //
    CMsgEntry* pMsgEntry = GetNewMessageEntry(MsgId.Uniquifier, it);

    //
    // Insert the message entry to the map. If it already exist, the inset fails
    // and it the returns FALSE (in pair.second)
    //
    SET_MSG_ID& MsgMap = it->second;
    pair<SET_MSG_ID::iterator, bool> MsgPair = MsgMap.insert(pMsgEntry);
    if (!MsgPair.second)
    {
        DebugMsg(L"Insert - DUPLICATE message", MsgId.Lineage, MsgId.Uniquifier);

        //
        // already exist. Get the existing entry and move it to the end of the 
        // racent use list
        //
        CMsgEntry* pExist = *(MsgPair.first);
        m_OrderedList.remove(pExist);
        m_OrderedList.insert(pExist);
        pExist->UpdateTimeStamp();

        delete pMsgEntry;

        //
        // Update duplicate statics
        //
        ++m_DuplicateStatics;

        return FALSE;
    }

    //
    // A new entry. Add it to the last recent use list
    //
    DebugMsg(L"Insert", MsgId.Lineage, MsgId.Uniquifier);
    m_OrderedList.insert(pMsgEntry);

    //
    // Check if the cleanup secduler already set.
    //
    if (!m_fCleanupScheduled)
    {
        //
        // The scheduler was not set. Begin the cleanup scheduler
        //
        ExSetTimer(&m_CleanupTimer, CTimeDuration::FromMilliSeconds(m_CleanUpInterval));
        m_fCleanupScheduled = TRUE;
    }

    return TRUE;
}


void 
CMessageMap::RemoveMessage(
    const OBJECTID& MsgId
    )
/*++

  Routine Description:
    The routine remove a message from the remove duplicate tabel if 
    it exist

  Parameter:
    MsgId - a message ID that consist from GUID that specify the source machine
            and unique ID

  Returned Value:
    None

 --*/
{
    CS lock(m_cs);

    //
    // Look if the source machine exist in map. If no the message doesn't exist
    //
    MAP_SOURCE::iterator it;
    it = m_ReceivedMsgMap.find(MsgId.Lineage);
    if (it == m_ReceivedMsgMap.end())
        return;

    //
    // Look for the message ID in the message Id map
    //
    SET_MSG_ID& MsgMap = it->second;
    SET_MSG_ID::iterator it1;
	CMsgEntry MsgEntry(MsgId.Uniquifier, NULL);
    it1 = MsgMap.find(&MsgEntry);
    if (it1 == MsgMap.end())
        return;

    CMsgEntry* pMsgEntry = *it1;
    
    //
    // Remove the message from the recent use list
    //
    m_OrderedList.remove(pMsgEntry);

    //
    // remove the message from the map
    //
    MsgMap.erase(it1);
    delete pMsgEntry;

    //
    // if it was the last message in the source map. remove the source from the map.
    //
    if (MsgMap.empty())
    {
        m_ReceivedMsgMap.erase(it);
    }
}


void 
CMessageMap::CleanUp(
    DWORD CleanUpInterval
    )
/*++

  Routine Description:
    the routine called periodically ( default each 30 minutes) and uses to clean
    the remove duplicate tabel. All the messages that are before the cleanup 
    interval are removed

  Parameters:
    fCleanAll - TRUE, indicates to remove all the elements from the tabel. 
                FALSE, using the cleanup interval
                    
  Returned Value:
    None.
 --*/
{
    DWORD CurrentTime = GetTickCount();

    //
    // Get the oldest message from the "recent use" list
    //
    for(;;)
    {
        CMsgEntry* pMsg = m_OrderedList.peekhead();
        if(pMsg == NULL)
            return;

        if (CleanUpInterval > (CurrentTime - pMsg->m_TimeStamp))
        {
            //
            // the message are ordered accoring the receiving time. If this
            // message received after the cleanup interval, it means that 
            // the rest of the message also. 
            //
            return;
        }

        //
        // Remove the message from the list and from the tabel
        //
        m_OrderedList.gethead();
        SET_MSG_ID& MsgMap = pMsg->m_it->second;

        MsgMap.erase(pMsg);
        if (MsgMap.empty())
        {
            m_ReceivedMsgMap.erase(pMsg->m_it);
        }
        delete pMsg;
    }
}

inline 
void
CMessageMap::HandelCleanupSchedule(
    void
    )
{
    CS lock(m_cs);

    CleanUp(m_CleanUpInterval);

    //
    // If the map isn't empty, begin the cleanup scheduler
    //
    if (!m_ReceivedMsgMap.empty())
    {
        ExSetTimer(&m_CleanupTimer, CTimeDuration::FromMilliSeconds(m_CleanUpInterval));
    }
    else
    {
        m_fCleanupScheduled = FALSE;
    }

}


#ifdef _DEBUG

inline
void 
CMessageMap::DebugMsg(
    LPCWSTR msg, 
    const GUID& MachineId,
    DWORD MsgId
    ) const
{
    DBGMSG((DBGMOD_NETSESSION,
            DBGLVL_TRACE,
            _T("CMessageMap %ls: ") _T(LOG_GUID_FMT) _T("\\%d"), msg, &MachineId, MsgId)); 
}

#endif


void 
WINAPI 
CMessageMap::TimeToCleanup(
    CTimer* pTimer
    )
{
    CMessageMap* pMsgMap = CONTAINING_RECORD(pTimer, CMessageMap, m_CleanupTimer);
    pMsgMap->HandelCleanupSchedule();

}



static CMessageMap s_DuplicateMessageMap;

BOOL 
DpInsertMessage(
    const CQmPacket& QmPkt
    )
{
    //
    // Packets sent to multiple destination queues have several copies with same msgid
    // so we do not insert them to the dup removal database.
    //
    if (QmPkt.GetNumOfDestinationMqfElements() != 0)
    {
        return TRUE;
    }

	OBJECTID MsgId;
    QmPkt.GetMessageId(&MsgId);
	
    try
    {
        return s_DuplicateMessageMap.InsertMessage(MsgId);
    }
    catch(const ::bad_alloc&)
    {
        //
        // Continue. If insert failed due to recource limitation, we don't care. The 
        // worst thing that can cause is duplicate message
        // 
        DBGMSG((DBGMOD_NETSESSION,
                DBGLVL_WARNING,
                _T("Insert Message to Remove Duplicate Data structure failed due recource limitation"))); 

        LogIllegalPoint(s_FN, 73);
    }
    
    return TRUE;
}


void 
DpRemoveMessage(
    const CQmPacket& QmPkt
    )
{
    //
    // Packets sent to multiple destination queues have several copies with same msgid
    // so we do not insert them to the dup removal database.
    //
    if (QmPkt.GetNumOfDestinationMqfElements() != 0)
    {
        return;
    }

	OBJECTID MsgId;
    QmPkt.GetMessageId(&MsgId);

    s_DuplicateMessageMap.RemoveMessage(MsgId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\regqueue.h ===
/*+++

Copyright (c) 1995-1996  Microsoft Corporation

File Name:

    regqueue.h

Abstract:

Author:

    Doron Juster  (DoronJ)

--*/

HRESULT GetCachedQueueProperties( IN DWORD       cpObject,
                                  IN PROPID      aProp[],
                                  IN PROPVARIANT apVar[],
                                  IN const GUID* pQueueGuid,
                                  IN LPWSTR      lpPath = NULL ) ;

void  WINAPI TimeToPublicCacheUpdate(CTimer* pTimer) ;
HRESULT UpdateAllPublicQueuesInCache() ;

HRESULT DeleteCachedQueueOnTimeStamp(const GUID *pGuid, time_t TimeStamp);

HRESULT DeleteCachedQueue(IN const GUID* pQueueGuid);

HRESULT SetCachedQueueProp(IN const GUID* pQueueGuid,
                           IN DWORD       cpObject,
                           IN PROPID      pPropObject[],
                           IN PROPVARIANT pVarObject[],
                           IN BOOL        fCreatedQueue,
                           IN BOOL        fAddTimeSec,
                           IN time_t      TimeStamp) ;

HRESULT UpdateCachedQueueProp( IN const GUID* pQueueGuid,
                               IN DWORD       cpObject,
                               IN PROPID      pPropObject[],
                               IN PROPVARIANT pVarObject[],
                               IN time_t      TimeStamp);

#define PPROPID_Q_TIMESTAMP     5000
#define PPROPID_Q_SYSTEMQUEUE   5001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\setup.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    setup.h

Abstract:

    Header for auto configuration of QM

Author:

    Shai Kariv (shaik) Mar 18, 1999

Revision History:

--*/

#ifndef _MQQM_SETUP_H_
#define _MQQM_SETUP_H_

#include "stdh.h"
#include "mqreport.h"


struct CSelfSetupException
{
    CSelfSetupException(EVENTLOGID id):m_id(id) {};
    ~CSelfSetupException() {};

    EVENTLOGID m_id;
};


VOID
CreateStorageDirectories(
    VOID
    );

VOID
CreateMachineQueues(
    VOID
    );

VOID
CompleteMsmqSetupInAds(
    VOID
    );

HRESULT
CreateTheConfigObj(
    VOID
	);


void   AddMachineSecurity();

VOID  CompleteServerUpgrade();

#endif //_MQQM_SETUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\session.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    session.h

Abstract:
    Network session definition

Author:
    RaphiR

--*/
#ifndef __SESSION_H__
#define __SESSION_H__

#include <winsock.h>
#include "qmpkt.h"
#include "factory.h"
#include "qmperf.h"
#include "cgroup.h"
#include "qmutil.h"
#include "qmthrd.h"

#define SESSION_CHECK_EXIST     0x00000001
#define SESSION_ONE_TRY         0x00000002
#define SESSION_RETRY           0x00000004

class CQueue;           //forward reference


#define Close_Connection(pSession, msg) pSession->CloseConnection(msg, true)
#define Close_ConnectionNoError(pSession, msg) 	pSession->CloseConnection(msg, false)



typedef enum _SessionStatus
{
    ssNotConnect   = 0,    //  0 - Session not connected yet
    ssConnect      = 1,    //  1 - session is connected
    ssEstablish    = 2,    //  2 - Falcon Establish connection completed
    ssActive       = 3     //  3 - Falcon Connection parameter was exchange
} SessionStatus;

class CTransportBase : public CInterlockedSharedObject
{
    public:
        CTransportBase();
        ~CTransportBase();

        void SetUsedFlag(BOOLEAN f);
        BOOL GetUsedFlag(void) const;

        void  SetQMId(const GUID* pguidQMID);
        const GUID* GetQMId(void) const;

        void SetSessionAddress(const TA_ADDRESS*);
        const TA_ADDRESS* GetSessionAddress(void) const;
        LPCWSTR GetStrAddr(void) const;

        HANDLE GetGroupHandle(void) const;
        CQGroup* GetGroup(void) const;
        void SetGroup(CQGroup*);

        void SetSessionStatus(SessionStatus);
        SessionStatus GetSessionStatus(void) const;

        void SetClientConnect(BOOL);
        BOOL IsClient(void) const;

        static HRESULT RequeuePacket(IN CQmPacket *pPkt);

        HRESULT GetNextSendMessage(void);
        void AddQueueToSessionGroup(CQueue* pQueue) throw(std::bad_alloc);

        void EstablishConnectionNotCompleted(void);

        virtual void CloseConnection(LPCWSTR, bool fClosedOnError) = 0;
        virtual HRESULT CreateConnection(IN const TA_ADDRESS *pAddr,
                                         IN const GUID* pguidQMId,
                                         IN BOOL fQuick = TRUE
                                         ) = 0;
        virtual HRESULT Send(IN CQmPacket* pPkt,
                             OUT BOOL* pfGetNext) = 0;
        virtual void Receive(CBaseHeader* pBaseHeader,
                             CPacket* pDriverPacket) = 0;

        virtual void SetStoredAck(IN DWORD_PTR wStoredAckNo) = 0;
        virtual void HandleAckPacket(CSessionSection * pcSessionSection) = 0;
        virtual BOOL IsUsedSession(void) const;

        virtual void Disconnect(void) = 0;
        BOOL IsDisconnected(void) const;
        void SetDisconnected(void);

        BOOL IsQoS(void) const;

    protected:
        CCriticalSection    m_cs;                   // Critical section
        GUID                m_guidDstQM;            // Next side QM GUID
        bool                m_fQoS;                 // Session for Direct queues (In QoS)



    private:
        CQGroup *           m_SessGroup;            // Group info
        QMOV_ACGetMsg m_GetSendOV;
        SessionStatus       m_SessionStatus;        // Transfer status
        BOOL                m_fClient;              // Is client side. Craete the connection
        long                m_fUsed;                // Used flag
        TA_ADDRESS*         m_pAddr;                // TA_ADDRESS format address
        BOOL                m_fDisconnect;



#ifdef _DEBUG
        WCHAR               m_lpcsStrAddr[50];
#endif
};


/*======================================================

   FUNCTION: CTransportBase::SetUsedFlag

========================================================*/
inline void
CTransportBase::SetUsedFlag(BOOLEAN f)
{
    InterlockedExchange(&m_fUsed,  f);
}

/*======================================================

   FUNCTION: CTransportBase::GetUsedFlag

========================================================*/
inline BOOL
CTransportBase::GetUsedFlag(void) const
{
    return m_fUsed;
}

/*======================================================

   FUNCTION: CTransportBase::SetSessionAddress

========================================================*/
inline void
CTransportBase::SetSessionAddress(const TA_ADDRESS* pa)
{
    //Keep the TA_ADDRESS format
    m_pAddr = (TA_ADDRESS*) new char [pa->AddressLength + TA_ADDRESS_SIZE];
    memcpy(m_pAddr, pa, pa->AddressLength + TA_ADDRESS_SIZE);
#ifdef _DEBUG
    TA2StringAddr(pa, m_lpcsStrAddr);
#endif
}

/*======================================================

   FUNCTION: CTransportBase::GetSessionAddress

========================================================*/
inline const TA_ADDRESS*
CTransportBase::GetSessionAddress(void) const
{
    return m_pAddr;
}

/*======================================================

  FUNCTION: CTransportBase::SetQMId

========================================================*/
inline LPCWSTR
CTransportBase::GetStrAddr(void) const
{
#ifdef _DEBUG
    return m_lpcsStrAddr;
#else
    return L"";
#endif
}

/*======================================================

  FUNCTION: CTransportBase::SetQMId

========================================================*/
inline void
CTransportBase::SetQMId(const GUID* pguidQMId)
{
    m_guidDstQM = *pguidQMId;
}

/*======================================================

  FUNCTION: CTransportBase::GetQMId

========================================================*/
inline const GUID*
CTransportBase::GetQMId(void) const
{
    return &m_guidDstQM;
}

/*======================================================

  FUNCTION: CTransportBase::SetSessionStatus

========================================================*/
inline void
CTransportBase::SetSessionStatus(SessionStatus sStatus)
{
    m_SessionStatus = sStatus;
}

/*======================================================

  FUNCTION: CTransportBase::GetSessionStatus

========================================================*/
inline SessionStatus
CTransportBase::GetSessionStatus(void) const
{
    return m_SessionStatus;
}

/*======================================================

   FUNCTION:CTransportBase::GetGroupHandle

========================================================*/
inline HANDLE
CTransportBase::GetGroupHandle(void) const
{
    return((m_SessGroup != NULL) ? m_SessGroup->GetGroupHandle() : NULL);
}

/*======================================================

   FUNCTION:CTransportBase::SetClientConnect

========================================================*/
inline void
CTransportBase::SetClientConnect(BOOL f)
{
    m_fClient = f;
}

/*======================================================

   FUNCTION:CTransportBase::IsClient

========================================================*/
inline BOOL
CTransportBase::IsClient(void) const
{
    return m_fClient;
}

/*======================================================

   FUNCTION:CTransportBase::GetGroup

========================================================*/
inline CQGroup*
CTransportBase::GetGroup(void) const
{
    return m_SessGroup;
}
/*======================================================

   FUNCTION:CTransportBase::SetGroup

========================================================*/
inline void
CTransportBase::SetGroup(CQGroup* pGroup)
{
    m_SessGroup = pGroup;
}

/*======================================================

   FUNCTION:CTransportBase::IsUsedSession

========================================================*/
inline BOOL
CTransportBase::IsUsedSession(void) const
{
    return GetUsedFlag();
}

inline
BOOL 
CTransportBase::IsDisconnected(
    void
    ) const
{
    return m_fDisconnect;
}

inline
void
CTransportBase::SetDisconnected(
    void
    )
{
    m_fDisconnect = TRUE;
}

inline
BOOL 
CTransportBase::IsQoS(
    void
    ) const
{
    return m_fQoS;
}

//
// SP4 - Bug 3380 (closing a session while sending a messge)
//
// ReportMsgInfo structure is used to hold messgae information 
// for sending a report message. Due the bug fix the message can
// be freed before the report message is sent, As a result we need
// to save the message information for later use
//              Uri Habusha (urih), 11-Aug-98
//
class ReportMsgInfo
{
    public:
        void SetReportMsgInfo(CQmPacket* pPkt);
        void SendReportMessage(LPCWSTR pcsNextHope);

    private:
        USHORT m_msgClass;
        USHORT m_msgTrace;
        QUEUE_FORMAT m_OriginalReportQueue;
        QUEUE_FORMAT m_TargetQueue;
        OBJECTID m_MessageId;
        DWORD m_msgHopCount;
};

class CSockTransport : public CTransportBase
{
    public:

        CSockTransport();
        ~CSockTransport();

        HRESULT CreateConnection(IN const TA_ADDRESS *pAddr,
                                 IN const GUID* pguidQMId,
                                 IN BOOL fQuick = TRUE
                                 );
        void CloseConnection(LPCWSTR,bool fClosedOnError);
        void HandleAckPacket(CSessionSection * pcSessionSection);

        void SendPendingReadAck();

        void CheckForAck();
        void SetStoredAck(IN DWORD_PTR wStoredAckNo);

        void Connect(IN TA_ADDRESS *pAddr, IN SOCKET sock);
        void Receive(CBaseHeader* pBaseHeader,
                     CPacket* pDriverPacket);
        BOOL IsUsedSession(void) const;

        void Disconnect(void);

        void CloseDisconnectedSession(void);

	private:
		struct QMOV_ReadSession;
		typedef HRESULT (WINAPI *LPREAD_COMPLETION_ROUTINE)(QMOV_ReadSession* po);

		static VOID WINAPI SendDataFailed(EXOVERLAPPED* pov);
		static VOID WINAPI SendDataSucceeded(EXOVERLAPPED* pov);

		static VOID WINAPI ReceiveDataFailed(EXOVERLAPPED* pov);
		static VOID WINAPI ReceiveDataSucceeded(EXOVERLAPPED* pov);

		static HRESULT WINAPI ReadHeaderCompleted(QMOV_ReadSession*  pov);
		static HRESULT WINAPI ReadAckCompleted(IN QMOV_ReadSession*  pov);
		static HRESULT WINAPI ReadUsrHeaderCompleted(IN QMOV_ReadSession*  pov);
		static HRESULT WINAPI ReadInternalPacketCompleted(IN QMOV_ReadSession*  pov);
		static HRESULT WINAPI ReadUserMsgCompleted(IN QMOV_ReadSession*  pov);

	private:
		//
		// Overlapped strcucture for asynchronous operatios
		//
		struct QMOV_WriteSession
		{
			EXOVERLAPPED               qmov;
			CSockTransport*             pSession;
			PVOID                       lpBuffer;       // pointer to Release Buffer
			PVOID                       lpWriteBuffer;  // Pointer to write buffer
			DWORD                       dwWriteSize;    // How many bytes should be writen
			DWORD                       dwWrittenSize;  // How many bytes was written
			BOOL                        fEncryptedMsg;
			BOOL                        fFreeSemaphore;     // free send event when the write completed
			BOOL                        fUserMsg;       // User Message
			BOOL                        fSendAck;
			CDebugSection*              lpDebugSectionBuf;

			QMOV_WriteSession(void) :
				qmov(SendDataSucceeded, SendDataFailed)
			{
			}

		};


		struct QMOV_EncryptedWriteSession : public QMOV_WriteSession
		{
			HCRYPTKEY hKey;
			DWORD     dwEncryptedWriteSize;
			DWORD     dwEncryptedBodySize;

			QMOV_EncryptedWriteSession(void)
			{
			}

			//
			// NOTE: Don't add a destructor that free data. When session.cpp free
			//       the overlapped it doesn't distinguish between QMOV_WriteSession
			//       and QMOV_EncryptedWriteSession.; Therefor the destructor of 
			//       this object will not call. See WriteCompleted in session.cpp.
			//                                          Uri Habusha, 10-Jan-2001
			//
		};

		struct QMOV_ReadSession
		{
			EXOVERLAPPED    qmov;
			CSockTransport*   pSession;  // Pointer to session object
			union {
				UCHAR *       pbuf;
				CBaseHeader * pPacket;
				CSessionSection * pSessionSection;
			};
			CPacket *  pDriverPacket;
			DWORD            dwReadSize; // Size of buffer
			DWORD            read;       // How many bytes already read
			LPREAD_COMPLETION_ROUTINE  lpReadCompletionRoutine;

			QMOV_ReadSession() :
				qmov(ReceiveDataSucceeded, ReceiveDataFailed)
			{
			}
		};

     private:
		void ReportErrorToGroup();
        void WriteCompleted(QMOV_WriteSession*  po);  
        void ReadCompleted(QMOV_ReadSession*  po);  

        HRESULT ResumeSendSession(void);

        HRESULT CreateSendRequest(PVOID          lpReleaseBuffer,
                                  PVOID          lpWriteBuffer,
                                  DWORD          dwWriteSize,
                                  BOOL           fFreeEvent,
                                  BOOL           fUserMsg = FALSE,
                                  BOOL           fSendAck = FALSE,
                                  CDebugSection* pDebug = NULL
                                );

        void    CreateConnectionParameterPacket(IN DWORD dwSendTime,
                                                OUT CBaseHeader** ppPkt,
                                                OUT DWORD* pdwPacketSize);

        void SendEstablishConnectionPacket(const GUID* pDstQMId,
                                              BOOL fCheckNewSession)throw();
        void BeginReceive();
        void NewSession(void);

        HRESULT WriteToSocket(QMOV_WriteSession*  po);

        HRESULT WriteBasicHeader(IN const CQmPacket *pPkt,
                                 IN BOOL fSendAck,
                                 IN DWORD dwDbgSectionSize
                                );
        HRESULT WriteExpressPacket(IN CQmPacket* pPkt,
                                   IN HCRYPTKEY hKey,
                                   IN BYTE *pbSymmKey,
                                   IN DWORD dwSymmKeyLen,
                                   IN BOOL  fSendReadAck,
                                   IN CDebugSection* pDebug
                                  );

        HRESULT WriteEncryptedBody(IN QMOV_EncryptedWriteSession*  po);

        HRESULT WriteRecoverEncryptPacket(IN const CQmPacket *pPkt,
                                          IN BOOL  fSendAck,
                                          IN CDebugSection* pDebug,
                                          IN HCRYPTKEY hKey,
                                          IN BYTE *pbSymmKey,
                                          IN DWORD dwSymmKeyLen
                                          );

        bool WriteUserMsgCompleted(IN QMOV_WriteSession*  po);
		bool WriteEncryptedMsgCompleted(QMOV_EncryptedWriteSession* peo);

        HRESULT Send(IN CQmPacket* pPkt,
                     OUT BOOL* pfGetNext);
        void IncReadAck(CQmPacket*);
        void UpdateAcknowledgeNo(IN CQmPacket* pPkt);
        void ClearRecvUnAckPacketNo(void);
        void IncRecvUnAckPacketNo(void);
        WORD GetRecvUnAckPacketNo(void) const;
        void NetworkSend(IN CQmPacket *pPkt);
        void RcvStats(DWORD size);
        void NeedAck(IN CQmPacket *pInfo);

        void HandleEstablishConnectionPacket(CBaseHeader*);
        void HandleConnectionParameterPacket(CBaseHeader*) throw(std::bad_alloc);
        void HandleReceiveUserMsg(CBaseHeader* pBaseHeader,
                                  CPacket* pDriverPacket);
        void ReceiveOrderedMsg(
                CQmPacket *pPkt, 
                CQueue* pQueue, 
                BOOL fDuplicate
                );

        WORD GetSendUnAckPacketNo(void) const;
        void UpdateRecvAcknowledgeNo(CQmPacket*);

        BOOL IsSusspendSession();
        DWORD GetSendAckTimeout(void) const;
        void RejectPacket(CQmPacket* pPkt, USHORT usClass);

        void OtherSideIsServer(BOOL);
        BOOL IsOtherSideServer(void) const;

        void ReleaseSendSemaphore(void);
        BOOL GetSendSemaphore(void);

        void
        UpdateNumberOfStorageUnacked(
            WORD BaseNo,
            DWORD BitField
            );

        enum AckType {ePigyback, eStandAlone};
        void SendReadAck(AckType type);

        void SetFastAcknowledgeTimer(void);
        void SendFastAckPacket(void);
        void SendAckPacket(void);
        void SetAckInfo(CSessionSection* pAckSection);


        void 
        CreateAckPacket(
            PVOID* ppSendPacket,
            CSessionSection** ppAckSection,
            DWORD* pSize
            );
        
        void 
        CreateAckSection(
            PVOID* ppSendSection,
            CSessionSection** ppAckSection,
            DWORD* pSize
            );

        bool
        BindToFirstIpAddress(
            VOID
            );

        HRESULT
        CSockTransport::ConnectSocket(
            SOCKADDR_IN const *pdest_in,
            bool              fUseQoS
            );

#ifdef _DEBUG
        void DisplayAcnowledgeInformation(CSessionSection* pAck);
#else
        #define DisplayAcnowledgeInformation(pAck) ((void) 0)
#endif

        static void WINAPI SendFastAcknowledge(CTimer* pTimer);
        static void WINAPI TimeToCheckAckReceived(CTimer* pTimer);
        static void WINAPI TimeToSendAck(CTimer* pTimer);
        static void WINAPI TimeToSendPendingAck(CTimer* pTimer);
        static void WINAPI TimeToCancelConnection(CTimer* pTimer);
        static void WINAPI TimeToCloseDisconnectedSession(CTimer* pTimer);

    private:
        WORD                m_wUnAckRcvPktNo;
        BOOL                m_fSendAck;
        BOOL                m_fRecvAck;
        DWORD               m_dwLastTimeRcvPktAck;
        WORD                m_wSendPktCounter;
        WORD                m_wPrevUnackedSendPkt;

        CList<CQmPacket *, CQmPacket *&> m_listUnackedPkts;
        //
        // Store Acking
        //
        WORD                m_wStoredPktCounter;
        WORD                m_wUnackStoredPktNo;      // Index of the last stored packet that
                                                       // received
        WORD                m_wAckRecoverNo;
        DWORD               m_dwAckRecoverBitField;

        LONG                m_lStoredPktReceivedNoAckedCount;
        //
        //
        //
        WORD                m_wRecvUnAckPacketNo;

        CList<CQmPacket *, CQmPacket *&> m_listStoredUnackedPkts;


        DWORD m_dwAckTimeout;
        DWORD m_dwSendAckTimeout;
        DWORD m_dwSendStoreAckTimeout;
        WORD  m_wRecvWindowSize;
        BOOL  m_fSessionSusspended;

        SOCKET  m_sock;                 // Connected socket
        USHORT  m_uPort;                // Conection port
        BOOL    m_fOtherSideServer;     // True if the other side of the connection
                                        // is MSMQ server

        LONG    m_fSendBusy;            // FALSE - not in send

        ReportMsgInfo m_MsgInfo;

        R<CSessionPerfmon> m_pStats; //Statistics

        CTimer m_FastAckTimer;

        BOOL m_fCheckAckReceivedScheduled;
        CTimer m_CheckAckReceivedTimer;

        BOOL m_fSendPendingAckScheduled;
        CTimer m_SendPendingAckTimer;
        CList<CBaseHeader*, CBaseHeader*> m_listPendingAck;

        DWORD m_nSendAckSchedules;
        CTimer m_SendAckTimer;

        BOOL m_fCloseDisconnectedScheduled;
        CTimer m_CloseDisconnectedTimer;

        CTimer m_CancelConnectionTimer;
};

/*======================================================

   FUNCTION: CSockTransport::GetSendUnAckPacketNo

========================================================*/
inline WORD
CSockTransport::GetSendUnAckPacketNo(void) const
{
    return DWORD_TO_WORD(m_listUnackedPkts.GetCount());
}

/*======================================================

   FUNCTION: CSockTransport::ClearRecvUnAckPacketNo

========================================================*/
inline void
CSockTransport::ClearRecvUnAckPacketNo(void)
{
    m_wRecvUnAckPacketNo = 0;
}

/*======================================================

   FUNCTION: CSockTransport::IncRecvUnAckPacketNo

========================================================*/
inline void
CSockTransport::IncRecvUnAckPacketNo(void)
{
    m_wRecvUnAckPacketNo++;
}

/*======================================================

   FUNCTION: CSockTransport::GetRecvUnAckPacketNo

========================================================*/
inline WORD
CSockTransport::GetRecvUnAckPacketNo(void) const
{
    return m_wRecvUnAckPacketNo;
}

/*======================================================

   FUNCTION: CSockTransport::GetSendAckTimeout

========================================================*/
inline DWORD
CSockTransport::GetSendAckTimeout(void) const
{
    return m_dwSendAckTimeout;
}

/*======================================================

   FUNCTION: CSockTransport::OtherSideIsServer

========================================================*/
inline void
CSockTransport::OtherSideIsServer(BOOL f)
{
    m_fOtherSideServer = f;
}

/*======================================================

   FUNCTION: CSockTransport::IsOtherSideServer

========================================================*/
inline BOOL
CSockTransport::IsOtherSideServer(void) const
{
    return m_fOtherSideServer;
}


#endif // __SESSION_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\stdh.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    stdh.h

Abstract:

    Standard include file for QM componenet

Author:

    Erez Haba (erezh) 17-Jan-96

--*/

#ifndef __STDH_H
#define __STDH_H

#include <_stdh.h>

#include "transact.h"

#include <mqsymbls.h>
#include <mqprops.h>
#include <mqtypes.h>
#include <_mqdef.h>
#include <mqutil.h>
#include <cs.h>
#include <mqlog.h>

// [adsrv] Globally-available functions for finding out current machine capabilities
bool IsRoutingServer(void);
bool IsDepClientsServer(void);
bool IsNonServer(void);

#endif // __STDH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\sessmgr.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    sessionMgr.cpp

Abstract:

    Implementation of Network session mennager class.

Author:

    Uri Habusha (urih)
--*/


#include "stdh.h"
#include "uniansi.h"
#include <malloc.h>
#include "qmp.h"
#include "sessmgr.h"
#include "cqmgr.h"
#include "qmthrd.h"
#include "cgroup.h"
#include "admin.h"
#include "qmutil.h"
#include "proxy.h"
#include "ping.h"
#include <Fn.h>
#include "qmta.h"

#include "sessmgr.tmh"

extern CQueueMgr QueueMgr;
extern CQGroup* g_pgroupNonactive;
extern CQGroup* g_pgroupWaiting;
extern LPTSTR  g_szMachineName;

extern UINT  g_dwIPPort ;
extern DWORD g_dwThreadsNo ;

static WCHAR *s_FN=L"sessmgr";

//
// Extern variables
//
extern CSessionMgr SessionMgr;
extern CAdmin      Admin;


DWORD CSessionMgr::m_dwSessionCleanTimeout  = MSMQ_DEFAULT_CLIENT_CLEANUP;
DWORD CSessionMgr::m_dwQoSSessionCleanTimeoutMultiplier  = MSMQ_DEFAULT_QOS_CLEANUP_MULTIPLIER;
DWORD CSessionMgr::m_dwSessionAckTimeout = INFINITE;
DWORD CSessionMgr::m_dwSessionStoreAckTimeout = INFINITE;
DWORD CSessionMgr::m_dwIdleAckDelay = MSMQ_DEFAULT_IDLE_ACK_DELAY;
BOOL  CSessionMgr::m_fUsePing = TRUE;
HANDLE CSessionMgr::m_hAcceptAllowed = NULL;
bool  CSessionMgr::m_fUseQoS = false;
AP<char> CSessionMgr::m_pszMsmqAppName;       // = 0 - initialized by AP<> constructor
AP<char> CSessionMgr::m_pszMsmqPolicyLocator; //                    "
bool  CSessionMgr::m_fAllocateMore = false;
DWORD CSessionMgr::m_DeliveryRetryTimeOutScale = DEFAULT_MSMQ_DELIVERY_RETRY_TIMEOUT_SCALE;



BOOL g_fTcpNoDelay = FALSE;

#define MAX_ADDRESS_SIZE 16

struct CWaitingQueue
{
    CWaitingQueue(CQueue* pQueue, CTimer::CALLBACK_ROUTINE pfnCallback);

    CTimer m_Timer;
    CQueue* m_pQueue;
};

inline
CWaitingQueue::CWaitingQueue(
    CQueue* pQueue,
    CTimer::CALLBACK_ROUTINE pfnCallback
    ) :
    m_Timer(pfnCallback),
    m_pQueue(pQueue)
{
}



/*====================================================

DestructElements of LPCTSTR

Arguments:

Return Value:


=====================================================*/
static void AFXAPI DestructElements(LPCTSTR* ppNextHop, int n)
{
    for ( ; n--; )
        delete[] (WCHAR*)*ppNextHop++;
}


/*====================================================

CompareElements  of WAIT_INFO

Arguments:

Return Value:


=====================================================*/


BOOL AFXAPI  CompareElements(IN WAIT_INFO** pElem1,
                             IN WAIT_INFO** pElem2)
{
    const WAIT_INFO* pInfo1 = *pElem1;
    const WAIT_INFO* pInfo2 = *pElem2;

    const TA_ADDRESS* pAddr1 = pInfo1->pAddr;
    const TA_ADDRESS* pAddr2 = pInfo2->pAddr;

    if(pAddr1->AddressType != pAddr2->AddressType)
        return FALSE;

    if(memcmp(pAddr1->Address, pAddr2->Address, pAddr1->AddressLength) != 0)
        return FALSE;

    if (pInfo1->fQoS != pInfo2->fQoS)
        return FALSE;

    if(pInfo1->guidQMId == GUID_NULL)
        return TRUE;

    if(pInfo2->guidQMId == GUID_NULL)
        return TRUE;

    if(pInfo1->guidQMId == pInfo2->guidQMId)
        return TRUE;

    return FALSE;
}

/*====================================================

DestructElements of WAIT_INFO

Arguments:

Return Value:


=====================================================*/


void AFXAPI DestructElements(IN WAIT_INFO** ppNextHop, int n)
{
    for (int i=0; i<n ; i++)
    {
        delete (*ppNextHop)->pAddr;
        delete *ppNextHop;
        ppNextHop++;
    }
}

/*====================================================

HashKey For WAIT_INFO

Arguments:

Return Value:


=====================================================*/
UINT AFXAPI HashKey(IN WAIT_INFO* key)
{
    TA_ADDRESS* pAddr = key->pAddr;
    UINT nHash = 0;
    PUCHAR  p = pAddr->Address;

    for (int i = 0; i < pAddr->AddressLength; i++)
        nHash = (nHash<<5) + *p++;

    return nHash;
}

/*====================================================

DestructElements of CAddressList

Arguments:

Return Value:


=====================================================*/


void AFXAPI DestructElements(IN CAddressList** ppNextHop, int n)
{
    for (int i=0; i<n ; i++)
    {
        POSITION pos;

        pos = (*ppNextHop)->GetHeadPosition();
        while(pos != NULL)
        {
            TA_ADDRESS* pta = (*ppNextHop)->GetNext(pos);
            delete pta;
        }
        delete *ppNextHop;

        ppNextHop++;
    }
}

/********************************************************************************/
/*           I P     H E L P E R     R O U T I N E S                            */
/********************************************************************************/
SOCKET g_sockListen;



STATIC void AcceptIPThread(DWORD kuku)
{

    SOCKADDR_IN acc_sin;
    int acc_sin_len = sizeof(acc_sin);
    SOCKET RcvSock;

    char buff[TA_ADDRESS_SIZE + IP_ADDRESS_LEN];
    TA_ADDRESS* pa = (TA_ADDRESS*)&buff[0];

    for(;;)
    {
        try
        {
            RcvSock = WSAAccept( g_sockListen, (struct sockaddr FAR *)&acc_sin,
                            (int FAR *) &acc_sin_len, 0, 0);

            ASSERT(RcvSock != NULL);
            if (RcvSock == INVALID_SOCKET)
            {
                DWORD rc = WSAGetLastError();
                DBGMSG((DBGMOD_ALL,DBGLVL_ERROR,TEXT("IP accept failed, error = %d"),rc));
                DBG_USED(rc);
                continue;
            }
            else
            {
                DBGMSG((DBGMOD_NETSESSION,DBGLVL_TRACE,TEXT("Socket accept() successfully and Client IP address is [%hs]\n"),
                       inet_ntoa(*((in_addr *)&acc_sin.sin_addr.S_un.S_addr))));
            }


            if (CSessionMgr::m_fUseQoS)
            {
                QOS  Qos;
                memset ( &Qos, QOS_NOT_SPECIFIED, sizeof(QOS) );

                //
                // ps buf is not required
                //
                Qos.ProviderSpecific.len = 0;
                Qos.ProviderSpecific.buf = NULL;

                //
                // sending flowspec
                //
                Qos.SendingFlowspec.ServiceType = SERVICETYPE_QUALITATIVE;

                //
                // receiving flowspec
                //
                Qos.ReceivingFlowspec.ServiceType = SERVICETYPE_QUALITATIVE;

                DWORD  dwBytesRet ;

                int rc = WSAIoctl( RcvSock,
                                   SIO_SET_QOS,
                                  &Qos,
                                   sizeof(QOS),
                                   NULL,
                                   0,
                                  &dwBytesRet,
                                   NULL,
                                   NULL ) ;
                if (rc != 0)
                {
                    DWORD dwErrorCode = WSAGetLastError();
                    DBGMSG((DBGMOD_NETSESSION, DBGLVL_WARNING,
                            TEXT("AcceptIPThread - WSAIoctl() failed, Error %d"),
                            dwErrorCode));
                    LogNTStatus(dwErrorCode,  s_FN, 110);

                    //
                    // Continue anyway...
                    //
                }
            }

            //
            // If the machine is in disconnected state, don't accept the incoming
            // connection.
            //
            DWORD dwResult = WaitForSingleObject(CSessionMgr::m_hAcceptAllowed, INFINITE);
            if (dwResult != WAIT_OBJECT_0)
            {
                LogNTStatus(GetLastError(), s_FN, 201);
            }

            //
            // Build a TA format address
            //
            pa->AddressLength = IP_ADDRESS_LEN;
            pa->AddressType =  IP_ADDRESS_TYPE;
            * ((DWORD *)&(pa->Address)) = acc_sin.sin_addr.S_un.S_addr;

            //
            // Tell the session manager to create an Sock sesion object
            //
            SessionMgr.AcceptSockSession(pa, RcvSock);
        }
        catch(const bad_alloc&)
        {
            //
            //  No resources; accept next
            //
            LogIllegalPoint(s_FN, 76);
        }
    }
}

/*====================================================

CSessionMgr::CSessionMgr  - Constructor

Arguments:

Return Value:

=====================================================*/
CSessionMgr::CSessionMgr() :
    m_pIP_Address(NULL),
    m_fCleanupTimerScheduled(FALSE),
    m_CleanupTimer(TimeToSessionCleanup),
    m_fUpdateWinSizeTimerScheduled(FALSE),
    m_wCurrentWinSize(MSMQ_DEFAULT_WINDOW_SIZE_PACKET),
    m_wMaxWinSize(MSMQ_DEFAULT_WINDOW_SIZE_PACKET),
    m_UpdateWinSizeTimer(TimeToUpdateWindowSize),
    m_fTryConnectTimerScheduled(FALSE),
    m_TryConnectTimer(TimeToTryConnect)
{
    m_hAcceptAllowed = CreateEvent(NULL, TRUE, TRUE, NULL);
}

/*====================================================

CSessionMgr::~CSessionMgr

arguments:

Return Value:

=====================================================*/
CSessionMgr::~CSessionMgr()
{
    POSITION        pos;
    TA_ADDRESS*     pAddr;

    if (m_pIP_Address)
    {
       pos = m_pIP_Address->GetHeadPosition();
       while(pos != NULL)
       {
           pAddr = m_pIP_Address->GetNext(pos);
           delete pAddr;
       }
       m_pIP_Address->RemoveAll();

       delete m_pIP_Address;
    }
}

/*====================================================

CSessionMgr::Init

Arguments:

Return Value:

Thread Context: Main

=====================================================*/

HRESULT CSessionMgr::Init()
{

    DWORD dwSize = sizeof(DWORD);
    DWORD dwType;
    DWORD dwDefaultVal;
    HRESULT rc;
    //
    // Set Session clean-up timeout
    //
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    if (!IsRoutingServer())   //[adsrv] CQueueMgr::GetMQS() == SERVICE_NONE)
    {
        //
        // In Client the default Release session timeout is 5 minitues
        //
        dwDefaultVal = MSMQ_DEFAULT_CLIENT_CLEANUP;
    }
    else
    {
        //
        // In FRS the default Release session timeout is 2 minitues
        //
        dwDefaultVal = MSMQ_DEFAULT_SERVER_CLEANUP;
    }

    rc = GetFalconKeyValue(
            MSMQ_CLEANUP_INTERVAL_REGNAME,
            &dwType,
            &m_dwSessionCleanTimeout,
            &dwSize,
            (LPCTSTR)&dwDefaultVal
            );

    if (rc != ERROR_SUCCESS)
    {
        m_dwSessionCleanTimeout = dwDefaultVal;
    }

    //
    // Get Cleanup interval multiplier for QoS sessions
    //
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;

    rc = GetFalconKeyValue(MSMQ_QOS_CLEANUP_INTERVAL_MULTIPLIER_REGNAME,
                           &dwType,
                           &m_dwQoSSessionCleanTimeoutMultiplier,
                           &dwSize
                          );

    if (rc != ERROR_SUCCESS)
    {
        m_dwQoSSessionCleanTimeoutMultiplier = MSMQ_DEFAULT_QOS_CLEANUP_MULTIPLIER;
    }

    //
    // Get Max Unacked packet number
    //
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    DWORD dwWindowSize;

    rc = GetFalconKeyValue(MSMQ_MAX_WINDOW_SIZE_REGNAME,
                           &dwType,
                           &dwWindowSize,
                           &dwSize
                          );

    if (rc != ERROR_SUCCESS)
    {
        m_wMaxWinSize = MSMQ_DEFAULT_WINDOW_SIZE_PACKET;
    }
    else
    {
        m_wMaxWinSize = (WORD) dwWindowSize;
    }

    m_wCurrentWinSize = m_wMaxWinSize;

    //
    // Get session Storage ack timeout
    //
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    rc = GetFalconKeyValue(MSMQ_ACKTIMEOUT_REGNAME,
                           &dwType,
                           &m_dwSessionAckTimeout,
                           &dwSize
                          );
    if  (rc != ERROR_SUCCESS)
    {
        m_dwSessionAckTimeout = INFINITE;
    }


    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    rc = GetFalconKeyValue(MSMQ_STORE_ACKTIMEOUT_REGNAME,
                           &dwType,
                           &m_dwSessionStoreAckTimeout,
                           &dwSize
                          );
    if  (rc != ERROR_SUCCESS)
    {
        m_dwSessionStoreAckTimeout = INFINITE;
    }


    //
    // Get session Maximum acknowledge delay
    //
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    rc = GetFalconKeyValue(MSMQ_IDLE_ACK_DELAY_REGNAME,
                           &dwType,
                           &m_dwIdleAckDelay,
                           &dwSize
                          );

    //
    // Get Max wait time
    //
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;

    rc = GetFalconKeyValue(FALCON_WAIT_TIMEOUT_REGNAME,
                           &dwType,
                           &m_dwMaxWaitTime,
                           &dwSize
                           );
    if  (rc != ERROR_SUCCESS)
    {
        m_dwMaxWaitTime = 0;
    }

    //
    // use ping mechanism
    //
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    DWORD dwUsePing;

    rc = GetFalconKeyValue(FALCON_USING_PING_REGNAME,
                           &dwType,
                           &dwUsePing,
                           &dwSize
                          );
    if  ((rc != ERROR_SUCCESS) || (dwUsePing != 0))
    {
        m_fUsePing = TRUE;
    }
    else
    {
        m_fUsePing = FALSE;
    }

    //
    // Use TCP_NODELAY socket option flag
    //
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    DWORD dwNoDelay = 0;

    rc = GetFalconKeyValue(
            MSMQ_TCP_NODELAY_REGNAME,
            &dwType,
            &dwNoDelay,
            &dwSize
            );

    if((rc == ERROR_SUCCESS) && (dwNoDelay != 0))
    {
        g_fTcpNoDelay = TRUE;
    }
    else
    {
        g_fTcpNoDelay = FALSE;
    }

    //
    // use Quality Of Service (QoS)
    //
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    DWORD dwUseQoS;

    rc = GetFalconKeyValue(MSMQ_USING_QOS_REGNAME,
                           &dwType,
                           &dwUseQoS,
                           &dwSize
                          );
    if  ((rc != ERROR_SUCCESS) || (dwUseQoS == 0))
    {
        m_fUseQoS = false;
    }
    else
    {
        m_fUseQoS = true;
    }

    if (m_fUseQoS)
    {
        //
        // Application name and policy locator name - used for the header of a QoS session
        //
        GetAndAllocateCharKeyValue(
            MSMQ_QOS_SESSIONAPP_REGNAME,
            &m_pszMsmqAppName,
            DEFAULT_MSMQ_QOS_SESSION_APP_NAME
            );

        GetAndAllocateCharKeyValue(
            MSMQ_QOS_POLICYLOCATOR_REGNAME,
            &m_pszMsmqPolicyLocator,
            DEFAULT_MSMQ_QOS_POLICY_LOCATOR
            );
    }

    //
    // Allocate More (for connector)
    //
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    DWORD dwAllocateMore;

    rc = GetFalconKeyValue(MSMQ_ALLOCATE_MORE_REGNAME,
                           &dwType,
                           &dwAllocateMore,
                           &dwSize
                          );
    if  ((rc != ERROR_SUCCESS) || (dwAllocateMore == 0))
    {
        m_fAllocateMore = false;
    }
    else
    {
        m_fAllocateMore = true;
    }

	//
	// Read from registry flag that scales the retry timeout  on delivery error
	// by a factor
	//
	rc = GetFalconKeyValue(
					MSMQ_DELIVERY_RETRY_TIMEOUT_SCALE_REGNAME,
					&dwType,
                    &m_DeliveryRetryTimeOutScale,
                    &dwSize
					);

	if(rc != ERROR_SUCCESS)
	{
		m_DeliveryRetryTimeOutScale = DEFAULT_MSMQ_DELIVERY_RETRY_TIMEOUT_SCALE;		
	}
	m_DeliveryRetryTimeOutScale = min(m_DeliveryRetryTimeOutScale, 10);
	

    return(MQ_OK);
}

/*====================================================

CSessionMgr::GetAndAllocateCharKeyValue
Utility private function (used by Init()) to get a char
value out of the MSMQ registry
Two versions: With default and without default.
=====================================================*/
void  CSessionMgr::GetAndAllocateCharKeyValue(
        LPCTSTR pszValueName,
        char  **ppchResult,
        const char *pchDefault
        )
{
    if (GetAndAllocateCharKeyValue(pszValueName, ppchResult))
    {
        return;
    }

    //
    // Either there is no reg. key, or some error happend during read.
    // Get the default.
    //
    *ppchResult = new char[strlen(pchDefault) + 1];
    strcpy(*ppchResult, pchDefault);
}

//
// GetAndAllocateCharKeyValue without default (used by the version with default)
// Returns true if the key was found, false otherwise.
//
bool CSessionMgr::GetAndAllocateCharKeyValue(
        LPCTSTR pszValueName,
        char  **ppchResult
        )
{
    DWORD dwSize = 0;
    DWORD dwType = REG_SZ;

    //
    // First call - get the size
    //
    HRESULT rc =
        GetFalconKeyValue(
            pszValueName,
            &dwType,
            0,
            &dwSize
            );

    if (rc != ERROR_SUCCESS || dwType != REG_SZ)
    {
        //
        // Probably there is no key
        //
        return false;
    }

    //
    // There is a reg key - we did not supply buffer, but we have the
    // right size (note - size is in bytes)
    //

    AP<WCHAR> pwstrBuf = new WCHAR[dwSize / sizeof(WCHAR)];
    rc = GetFalconKeyValue(
            pszValueName,
            &dwType,
            pwstrBuf,
            &dwSize
            );

    if (rc != ERROR_SUCCESS || dwType != REG_SZ)
    {
        //
        // We got the size allright. We should not fail here
        //
        ASSERT(0);
        LogHR(MQ_ERROR, s_FN, 150);
        return false;
    }

    //
    // We got the UNICODE value OK. Convert it to ANSI
    //
    DWORD dwMultibyteBufferSize = dwSize;
    *ppchResult = new char[dwMultibyteBufferSize];
    DWORD dwBytesCopied =
        ConvertToMultiByteString(pwstrBuf, *ppchResult, dwMultibyteBufferSize);

    if (dwBytesCopied == 0)
    {
        ASSERT(0); // Should not fail....
        delete [] *ppchResult;
        LogHR(MQ_ERROR, s_FN, 155);

        return false;
    }

    //
    // Success - got the value from the registry
    //
    return true;
}






/*====================================================

CSessionMgr::BeginAccept

Arguments:

Return Value:

Thread Context: Main

=====================================================*/
void CSessionMgr::BeginAccept()
{
    StartPingServer();
    StartPingClient();

    //
    // Init various protocols
    //
    m_pIP_Address = GetIPAddresses();

    //
    // In WIN95/SP4 RAS, it is possible that the list is empty
    // if we are currently offline, and the IP RAS addresses are released.
    // However later we may dial.
    // We want to have an accept thread on IP even if the list is empty.
    //
    IPInit();
}


bool
CSessionMgr::IsReusedSession(
    const CTransportBase* pSession,
    DWORD noOfAddress,
    const CAddress* pAddress,
    const GUID** pGuid,
    bool         fQoS
    )
{
    //
    // If the connection is closed
    //
    if((pSession->GetSessionStatus() == ssNotConnect) || pSession->IsDisconnected())
        return false;

    const TA_ADDRESS* pa = pSession->GetSessionAddress();

    for(DWORD i = 0; i < noOfAddress; ++i)
    {
        if (memcmp(&pAddress[i], pa, (TA_ADDRESS_SIZE + pa->AddressLength)) != 0)
            continue;

        //
        // Check that destination QM guid is identical
        //

        //
        // If we do not use QoS, We would like to use the session if either:
        // 1. We opened a session to a private or public queue, and the other QM's
        //    GUID match the GUID of the QM, on which the queue resides (This check
        //    will catch multiple QM and change of address).
        // 2. We opened a session for a direct queue (we don't know the QMID
        //    anyway, so address match is good enough for us).
        //
        // However, if we use QoS, we want to use one session for public or
        // private queues (no QoS), and one session for direct queues (with QoS).
        //

        if (m_fUseQoS)
        {
            if (!fQoS && !pSession->IsQoS())
            {
                ASSERT(*pGuid[i] != GUID_NULL);

                if (*pSession->GetQMId() == *pGuid[i])
                    return true;

                continue;
            }

            if (fQoS && pSession->IsQoS())
            {
                ASSERT(*pGuid[i] == GUID_NULL);

                return true;
            }

            continue;
        }

        //
        // !m_fUseQoS
        //
        ASSERT(!fQoS);
        if (*pSession->GetQMId() == *pGuid[i])
            return true;

        if(*pGuid[i] == GUID_NULL)
            return true;
    }

    return false;
}


/*====================================================

CSessionMgr::GetSessionForDirectQueue

Arguments:

Return Value:

Thread Context:

=====================================================*/
HRESULT
CSessionMgr::GetSessionForDirectQueue(IN  CQueue*     pQueue,
                                      OUT CTransportBase**  ppSession)
{
    HRESULT rc;

    DirectQueueType dqt;
    AP<WCHAR> MachineName;

    try
    {
        LPCWSTR lpwsDirectQueuePath = FnParseDirectQueueType(pQueue->GetQueueName(), &dqt);
        FnExtractMachineNameFromPathName(
            lpwsDirectQueuePath,
            MachineName
            );
    }
    catch(const exception&)
    {
        return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 10);
    }

    DWORD dwMachineNameLen = wcslen(MachineName.get()) + 1;

    CAddress* apTaAddr;
    DWORD dwAddressNo = 0;

    DBGMSG((DBGMOD_NETSESSION,
            DBGLVL_TRACE,
            TEXT("Try to create direct connection with %ls"), MachineName.get()));

    switch (dqt)
    {
        case dtTCP:
            {
                LPSTR cTCPAddress = static_cast<LPSTR>(_alloca(sizeof(char) * dwMachineNameLen));

                wcstombs(cTCPAddress, MachineName.get(), dwMachineNameLen);
                cTCPAddress[dwMachineNameLen-1] = '\0';

                //
                // Check if TCP/IP is installed and enabled
                //
                ULONG Address = inet_addr(cTCPAddress);
                if (Address == INADDR_NONE)
                {
                    return LogHR(MQ_ERROR, s_FN, 30);
                }

                apTaAddr = static_cast<CAddress*>(_alloca(sizeof(CAddress)));
                apTaAddr[0].AddressType = IP_ADDRESS_TYPE;
                apTaAddr[0].AddressLength = IP_ADDRESS_LEN;
                *reinterpret_cast<ULONG*>(&(apTaAddr[0].Address)) = Address;

                dwAddressNo++;

                break;
            }

        case dtOS:
            {
                CAddressList* plAddresses = NULL;
                POSITION pos;

                if (pQueue->GetRoutingRetry() == 1)
                {
                    m_MapAddr.Lookup(MachineName.get(), plAddresses);
                }
                else
                {
                    m_MapAddr.RemoveKey(MachineName.get());
                }

                if (!plAddresses)
                {
                    DWORD dwBufferSize = dwMachineNameLen*2;
                    LPSTR cMachineName = static_cast<LPSTR>(_alloca(sizeof(char) * dwBufferSize));

                    DWORD dwBytesCopied = ConvertToMultiByteString(MachineName.get(), cMachineName, dwBufferSize);
                    if (dwBytesCopied == 0)
                    {
                        ASSERT(0); // Should not fail....
                        return LogHR(MQ_ERROR, s_FN, 45);
                    }
                    cMachineName[dwBufferSize-1] = '\0';

                    plAddresses = new CAddressList;
                    //
                    // Check if TCP/IP is installed and enabled
                    //
                    GetMachineIPAddresses(cMachineName,plAddresses);

                    m_MapAddr[newwcs(MachineName.get())] = plAddresses;
                }

                if (plAddresses->GetCount() == 0)
                {
                    return LogHR(MQ_ERROR, s_FN, 40);
                }

                apTaAddr = static_cast<CAddress*>(_alloca(sizeof(CAddress) * plAddresses->GetCount()));

                pos = plAddresses->GetHeadPosition();
                while(pos != NULL )
                {
                    TA_ADDRESS* pta = plAddresses->GetNext(pos);

                    ASSERT(pta->AddressType == IP_ADDRESS_TYPE);

                    apTaAddr[dwAddressNo].AddressType = IP_ADDRESS_TYPE;
                    apTaAddr[dwAddressNo].AddressLength = IP_ADDRESS_LEN;
                    memcpy(apTaAddr[dwAddressNo].Address, pta->Address, pta->AddressLength);

                    dwAddressNo++;
                }

                break;
            }
        default:
            return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 50);
    }

    const GUID** paQmId = static_cast<const GUID**>(_alloca(sizeof(GUID*) * dwAddressNo));
    for (DWORD i=0; i < dwAddressNo; i++)
    {
        paQmId[i] = &GUID_NULL;
    }

    //
    // Get session. If we use QoS, we ask for a session with QoS
    // flag set for direct queue
    //
    rc = GetSession(SESSION_RETRY,
                    pQueue,
                    dwAddressNo,
                    apTaAddr,
                    paQmId,
                    m_fUseQoS,
                    ppSession
                    );

    return LogHR(rc, s_FN, 70);
}


/*====================================================

CSessionMgr::GetSession

Arguments:

Return Value:

Called by the routing component to get a session
pointer for  a specific GUID.

=====================================================*/
HRESULT  CSessionMgr::GetSession(
                IN DWORD            dwFlag,
                IN const CQueue*    pDstQ,
                IN DWORD            dwNo,
                IN const CAddress*  apTaAddr,
                IN const GUID*      apQMId[],
                IN bool             fQoS,
                OUT CTransportBase** ppSession)
{
    DWORD            i;
    POSITION         pos;
    HRESULT          rc;

    *ppSession = NULL;

    {
        //
        //Scan the list to see if there is already a opened session
        //Dont have to make it under critical section, because no other
        //thread is supposed to change that list
        //Scan the map of queue handles
        // We use all addresses, it's a fast operation, not blocking, can save sessions
        //
        CTransportBase* pSess;

        CS lock(m_csListSess);

        pos = m_listSess.GetHeadPosition();
        while(pos != NULL)
        {
            pSess = m_listSess.GetNext(pos);
            if(IsReusedSession(pSess, dwNo, apTaAddr, apQMId, fQoS))
            {
                *ppSession = pSess;
                return(MQ_OK);
            }
        }
    }

    if(dwFlag == SESSION_CHECK_EXIST)
    {
        //
        // We just wanted to see
        // if we had such a session, and we
        // did not find such.
        //
        return LogHR(MQ_ERROR, s_FN, 80);
    }

    //
    //  No Open sessions, so try to open one. First check if this machine
    // can create a new session according to its license
    //

    //
    // This is a blocking path. Do not try on too many addresses if all fail
    // This is important for example if trying to connect to a site with many
    // FRSs when line is down
    // In case that we fail, we will try later with all the list
    //
    #define MAX_ADDRESSES_SINGLE_TRY    5
    DWORD dwLimit = (dwNo > MAX_ADDRESSES_SINGLE_TRY) ? MAX_ADDRESSES_SINGLE_TRY : dwNo;
    for(i = 0; i < dwLimit; i++)
    {

        P<CTransportBase> pSess;

        switch (apTaAddr[i].AddressType)
        {
            case IP_ADDRESS_TYPE:
                pSess = (CTransportBase *)new CSockTransport();
                break;

            case FOREIGN_ADDRESS_TYPE:
                pSess = (CTransportBase *)new CProxyTransport();
                break;

            default:
                ASSERT(0);
                continue;
        }

        //
        // Notify of a newly created session
        //
        rc = pSess->CreateConnection(reinterpret_cast<const TA_ADDRESS*>(&apTaAddr[i]), apQMId[i]);
        if(SUCCEEDED(rc))
        {
            NewSession(pSess);
            *ppSession = pSess.detach();
            return(MQ_OK);
        }

    }

    //
    //What to do next? We cant find a session, we cant create
    //a new one. The flag will tell us if to retry or to give up
    //
    if(dwFlag == SESSION_ONE_TRY)
    {
        return LogHR(MQ_ERROR, s_FN, 90);
    }

    ASSERT(dwFlag == SESSION_RETRY);

    //
    // use all addresses, it is not blocking
    //
    AddWaitingSessions(dwNo, apTaAddr, apQMId, fQoS, const_cast<CQueue*>(pDstQ));

    return(MQ_OK);
}

//+---------------------------------------------------------------------
//
// CSessionMgr::NotifyWaitingQueue()
//
//  This function is called from the session object, after session is
//  successfully established with remote side.
//
//+----------------------------------------------------------------------

void
CSessionMgr::NotifyWaitingQueue(
    IN const TA_ADDRESS* pa,
    IN CTransportBase * pSess
    )
    throw(bad_alloc)
{
    //
    // Connect succeeded
    //
    CS lock(m_csMapWaiting);

    CList <const CQueue *, const CQueue *&>* plist;
    POSITION pos = NULL;

    WAIT_INFO WaitInfo(const_cast<TA_ADDRESS*>(pa), *pSess->GetQMId(), pSess->IsQoS());

    //
    // Connect succeeded, check that no one remove the entry from the map
    //
    if (m_mapWaiting.Lookup(&WaitInfo, plist))
    {
        //
        // Remove the address from the map
        //
        m_mapWaiting.RemoveKey(&WaitInfo);

        //
        // And tell all the queues waiting that there is
        // a session for them
        //
        pos = plist->GetHeadPosition();
        //
        // A queue might be waiting for multiple
        // sessions. So delete the queue from all other
        // sessions that the queue was waiting for.
        //
        while(pos != NULL)
        {
            CQueue* pQ;

            pQ = (CQueue *)(plist->GetNext(pos));
            pQ->Connect(pSess);
            //
            // Scan the map of all the waiting sessions
            //
            RemoveWaitingQueue(pQ);
        }
        //
        // Remove the queue list
        //
        plist->RemoveAll();
        delete plist;

    }

}
/*======================================================

Function:      CSessionMgr::AddWaitingQueue

Description:   add queue to waiting queue list

========================================================*/
void
CSessionMgr::AddWaitingQueue(CQueue* pQueue)
{
	static DWORD RequeueWaitTimeOut[] = {
         4 * 1000,
         8 * 1000,
         12 * 1000,
         16 * 1000,
         24  * 1000,
		 32 * 1000,
		 42 * 1000,
		 54 * 1000,
		 64 * 1000
    };
	const int  MaxTimeOutIndex = TABLE_SIZE(RequeueWaitTimeOut);



    CS lock(m_csMapWaiting);

#ifdef _DEBUG
    AP<WCHAR> lpcsQueueName;

    pQueue->GetQueue(&lpcsQueueName);
    DBGMSG((DBGMOD_QM,
            DBGLVL_INFO,
            TEXT("Add queue: %ls to m_listWaitToConnect (AddWaitingQueue)"),lpcsQueueName));
#endif
    //
    // Increment the refernce count. We do it to promise that the queue object doen't remove
    // during the cleaning-up, while we continue to wait for conection. (can happen when the
    // message is expired and the application close the handle to it
    //
    pQueue->AddRef();
    R<CQueue> pRefQueue = pQueue;

    m_listWaitToConnect.AddTail(pQueue);

    ASSERT(pQueue->GetRoutingRetry() > 0);

    DWORD dwTime;
    if (m_dwMaxWaitTime == 0)
    {
        if (pQueue->GetRoutingRetry() > MaxTimeOutIndex)
        {
            dwTime = RequeueWaitTimeOut[MaxTimeOutIndex -1];
        }
        else
        {
            dwTime = RequeueWaitTimeOut[pQueue->GetRoutingRetry() -1];
        }
    }
    else
    {
        //
        // take the waiting time from the registery
        //
        dwTime = m_dwMaxWaitTime;
    }
	try
	{
		//
		// Schedule a retry sometimes in the near future
		//
		CWaitingQueue* p = new CWaitingQueue(pQueue, TimeToRemoveFromWaitingGroup);
		ExSetTimer(&p->m_Timer, CTimeDuration::FromMilliSeconds(dwTime * m_DeliveryRetryTimeOutScale));

		pRefQueue.detach();
	}
	catch(const bad_alloc&)
	{
		ASSERT(("The list should not be empty", !m_listWaitToConnect.IsEmpty()));
		m_listWaitToConnect.RemoveTail();
		throw;
	}
}

/*======================================================

Function:      CQueueMgr::MoveQueueFromWaitingToNonActiveGroup

Description:   Move queue from waiting to Nonactive Group

Arguments:

Return Value:  None

Thread Context:

History Change:

========================================================*/
void
CSessionMgr::MoveQueueFromWaitingToNonActiveGroup(
    CQueue* pQueue
    )
{
    POSITION poslist;

    CS lock(m_csMapWaiting);

    if (m_listWaitToConnect.IsEmpty() ||
        ((poslist = m_listWaitToConnect.Find(pQueue, NULL)) == NULL))
    {
        return;
    }
    //
    // Move the queue to NON-active group
    //
    CQGroup::MoveQueueToGroup(pQueue, g_pgroupNonactive);
    RemoveWaitingQueue(pQueue);
    //
    // The queue is removed from the list in SessionMgr.RemoveWaitingQueue
    //
}


void CSessionMgr::MoveAllQueuesFromWaitingToNonActiveGroup(void)
{
    CS lock(m_csMapWaiting);

    POSITION pos = m_listWaitToConnect.GetHeadPosition();
    while (pos)
    {
        CQueue* pQueue = const_cast<CQueue*>(m_listWaitToConnect.GetNext(pos));

		//
		// Move the queue to NON-active group
		//
		CQGroup::MoveQueueToGroup(pQueue, g_pgroupNonactive);
		RemoveWaitingQueue(pQueue);
		//
		// The queue is removed from the list in SessionMgr.RemoveWaitingQueue
		//
    }

}

void
WINAPI
CSessionMgr::TimeToRemoveFromWaitingGroup(
    CTimer* pTimer
    )
{
    CWaitingQueue* p = CONTAINING_RECORD(pTimer, CWaitingQueue, m_Timer);
    SessionMgr.MoveQueueFromWaitingToNonActiveGroup(p->m_pQueue);

    delete p;
}


STATIC BOOL IsDuplicateAddress(const CAddress* apTaAddr, DWORD i)
{
    for (DWORD j = 0; j < i; j++)
    {
        if ((apTaAddr[i].AddressType == apTaAddr[j].AddressType) &&
            !(memcmp(apTaAddr[i].Address, apTaAddr[j].Address, apTaAddr[i].AddressLength)))
        {
            //
            // Identical address skip it.
            //
            return TRUE;
        }
    }

    return FALSE;
}

/*====================================================

CSessionMgr::AddWaitingSessions

Arguments:

Return Value:

=====================================================*/
void CSessionMgr::AddWaitingSessions(IN DWORD dwNo,
                                     IN const CAddress* apTaAddr,
                                     IN const GUID* aQMId[],
                                     IN bool        fQoS,
                                     IN CQueue *pDstQ)
{
    CS lock(m_csMapWaiting);

    try
    {
        for(DWORD i = 0; i < dwNo; i++)
        {
            if(IsDuplicateAddress(apTaAddr, i))
                continue;


            CList<const CQueue*, const CQueue*&>* plist;
            TA_ADDRESS *pa = reinterpret_cast<TA_ADDRESS*>(const_cast<CAddress*>(&apTaAddr[i]));
            P<WAIT_INFO> pWaitRouteInfo = new WAIT_INFO(pa, *aQMId[i], fQoS);
            if(m_mapWaiting.Lookup(pWaitRouteInfo, plist) == FALSE)
            {
                //
                // copy the TA address, only if the entry was not found (performance)
                //
                pWaitRouteInfo->pAddr = (TA_ADDRESS*) new UCHAR[TA_ADDRESS_SIZE + pa->AddressLength];
                memcpy(pWaitRouteInfo->pAddr, pa, TA_ADDRESS_SIZE+pa->AddressLength);

                plist = new CList<const CQueue*, const CQueue*&>;
                m_mapWaiting[pWaitRouteInfo] = plist;

                pWaitRouteInfo.detach();
            }

            #ifdef _DEBUG

                TCHAR szAddr[30];

                TA2StringAddr(pa, szAddr);
                DBGMSG((DBGMOD_NETSESSION,
                        DBGLVL_TRACE,
                        TEXT("Add queue %ls to Waiting map for address %ls"), pDstQ->GetQueueName(), szAddr));

            #endif

            plist->AddTail(pDstQ);
        }

        SessionMgr.AddWaitingQueue(pDstQ);
        CQGroup::MoveQueueToGroup(pDstQ, g_pgroupWaiting);

        if (! m_fTryConnectTimerScheduled)
        {
            //
            // The try connect scheduler wasn't set yet. Set it now
            //
            ExSetTimer(&m_TryConnectTimer, CTimeDuration::FromMilliSeconds(5000));
            m_fTryConnectTimerScheduled = TRUE;
        }
    }
    catch(const bad_alloc&)
    {
        RemoveWaitingQueue(pDstQ);
        LogIllegalPoint(s_FN, 78);
        throw;
    }
}

/*====================================================

CSessionMgr::ReleaseSession

Arguments:

Return Value:

Some queue wants to release the use of a session.

Thread Context:

=====================================================*/
inline void CSessionMgr::ReleaseSession(void)
{
    POSITION pos,  prevpos;
    CTransportBase* pSession;

    CS lock(m_csListSess);

    static DWORD dwReleaseSessionCounter = 0;
    dwReleaseSessionCounter++;

    ASSERT(m_fCleanupTimerScheduled);

    pos = m_listSess.GetHeadPosition();
    while(pos != NULL)
    {
        prevpos = pos;
        pSession = m_listSess.GetNext(pos);

        //
        // For QoS (direct) sessions, execute cleanup only once each
        // m_dwQoSSessionCleanTimeoutMultiplier times
        //

        if (m_fUseQoS && pSession->IsQoS())
        {
            if ((dwReleaseSessionCounter % m_dwQoSSessionCleanTimeoutMultiplier) != 0)
            {
                continue;
            }
        }

        if(! pSession->IsUsedSession())
        {
            //
            // If no one is waiting on the session or it is
            // not used in last period, remove it from
            // the session manager and delete it
            //
            Close_ConnectionNoError(pSession, L"Release Unused session");
            if (pSession->GetRef() == 0)
            {
                m_listSess.RemoveAt(prevpos);
                delete pSession;
            }
        }
        else
        {
            pSession->SetUsedFlag(FALSE);
        }

    }

    if (m_listSess.IsEmpty())
    {
        m_fCleanupTimerScheduled = FALSE;
        return;
    }

    //
    // Still active session. Set a new timer for Session cleaning
    //
    ExSetTimer(&m_CleanupTimer, CTimeDuration::FromMilliSeconds(m_dwSessionCleanTimeout));
}


void
WINAPI
CSessionMgr::TimeToSessionCleanup(
    CTimer* pTimer
    )
/*++
Routine Description:
    The function is called from scheduler when fast session cleanup
    timeout is expired. The routine retrive the session manager
    object and calls the ReleaseSession function member.

Arguments:
    pTimer - Pointer to Timer structure. pTimer is part of the CSessionMgr
             object and it use to retrive the transport object.

Return Value:
    None

--*/
{
    CSessionMgr* pSessMgr = CONTAINING_RECORD(pTimer, CSessionMgr, m_CleanupTimer);

    DBGMSG((DBGMOD_NETSESSION, DBGLVL_TRACE, _T("Call Session Cleanup")));
    pSessMgr->ReleaseSession();
}


/*====================================================

CSessionMgr::RemoveWaitingQueue

Arguments:

Return Value:

  remove queue from waiting list. It should be done in following cases:
     - when a connection is established
     - when a queue is closed/deleted
     - when queue is moved from waiting group to nonactive group.

=====================================================*/
void
CSessionMgr::RemoveWaitingQueue(CQueue* pQueue)
{
    CS lock(m_csMapWaiting);

    //
    // Scan the map of all the waiting sessions
    //
    POSITION posmap;
    POSITION poslist;
    posmap = m_mapWaiting.GetStartPosition();
    while(posmap != NULL)
    {
        WAIT_INFO* pWaitRouteInfo;
        CList <const CQueue *, const CQueue *&>* plist;

        m_mapWaiting.GetNextAssoc(posmap, pWaitRouteInfo, plist);

        //
        // Get the list of queue waiting for
        // a specific session
        //
        poslist = plist->Find(pQueue, NULL);
        if (poslist != NULL)
        {
            plist->RemoveAt(poslist);
        }

        //
        // Even if the list of queues  waiting for session is empty,
        // do not delete it, and leave the entry in the map. This is
        // in order to fix WinSE bug 27985.
        // Before fix, we had the following code:
        //
        // if (plist->IsEmpty())
        // {
        //     m_mapWaiting.RemoveKey(pWaitRouteInfo);
        //     delete plist;
        // }
        //
        // Code moved to ::TryConnect() below.
    }

    //
    // Remove the queue from waiting queue list.
    //
    poslist = m_listWaitToConnect.Find(pQueue, NULL);
    if (poslist != NULL)
    {
 #ifdef _DEBUG
        AP<WCHAR> lpcsQueueName;

        pQueue->GetQueue(&lpcsQueueName);
        DBGMSG((DBGMOD_QM,
                DBGLVL_TRACE,
                TEXT("Remove queue: %ls from m_listWaitToConnect (RemoveWaitingQueue)"), lpcsQueueName.get()));
#endif
        m_listWaitToConnect.RemoveAt(poslist);
        pQueue->Release();
    }
}


/*====================================================

CSessionMgr::ListPossibleNextHops
    The routine is used for administration purpose. The routine returnes a
    list of addresses that can be the next hop for a waiting queue

Arguments:
    pQueue - pointer to the queue object
    pNextHopAddress - pointer to array of strings in which the routine
                      returnes the next hops.
    pNoOfNextHops - pointer to DWORD in which the routine returnes the
                    number of next hops

Return Value:
    HRESULT: MQ_ERROR is returned when the queue isn't in waiting state; MQ_OK otherwise.

=====================================================*/
HRESULT
CSessionMgr::ListPossibleNextHops(
    const CQueue* pQueue,
    LPWSTR** pNextHopAddress,
    DWORD* pNoOfNextHops
    )
{
    *pNoOfNextHops = 0;
    *pNextHopAddress = NULL;

    CS lock(m_csMapWaiting);

    if (m_listWaitToConnect.IsEmpty() ||
        ((m_listWaitToConnect.Find(pQueue, NULL)) == NULL))
    {
        return LogHR(MQ_ERROR, s_FN, 100);
    }


    CList <const TA_ADDRESS*, const TA_ADDRESS*> NextHopAddressList;

    //
    // Scan the map of all the waiting sessions
    //
    POSITION pos = m_mapWaiting.GetStartPosition();
    while(pos != NULL)
    {
        WAIT_INFO* pWaitRouteInfo;
        CList <const CQueue *, const CQueue *&>* plist;
        m_mapWaiting.GetNextAssoc(pos, pWaitRouteInfo, plist);

        //
        // Get the list of queue waiting for
        // a specific session
        //
        POSITION poslist = plist->Find(pQueue, NULL);
        if (poslist != NULL)
        {
            NextHopAddressList.AddTail(pWaitRouteInfo->pAddr);
        }
    }

    //
    // In some cases the queue can be in waiting state and don't have
    // next waiting hop. It can happened when the queue is a direct queue
    // and getHostByName failed
    //
    if (NextHopAddressList.IsEmpty())
    {
        return MQ_OK;
    }

    int Index = 0;
    AP<LPWSTR> pNext = new LPWSTR[NextHopAddressList.GetCount()];

    try
    {
        pos = NextHopAddressList.GetHeadPosition();
        while(pos != NULL)
        {
            const TA_ADDRESS* pAddr = NextHopAddressList.GetNext(pos);

            pNext[Index] = GetReadableNextHop(pAddr);
            ++Index;
        }
    }
    catch(const bad_alloc&)
    {
        while(Index)
        {
            delete [] pNext[--Index];
        }

        LogIllegalPoint(s_FN, 79);
        throw;
    }

    ASSERT(Index == NextHopAddressList.GetCount());

    *pNoOfNextHops = NextHopAddressList.GetCount();
    *pNextHopAddress = pNext.detach();

    return MQ_OK;
}

//+-----------------------------------------------------------------------
//
//  CSessionMgr::MarkAddressAsNotConnecting()
//
//  this function reset the "fInConnectionProcess" flag to FALSE.
//
//+-----------------------------------------------------------------------

void  CSessionMgr::MarkAddressAsNotConnecting(const TA_ADDRESS *pAddr,
                                              const GUID&       guidQMId,
                                              BOOL              fQoS )
{
    CS lock(m_csMapWaiting);

    CList <const CQueue *, const CQueue *&>* plist;
    WAIT_INFO WaitInfo(const_cast<TA_ADDRESS*> (pAddr), guidQMId, fQoS) ;

    if (m_mapWaiting.Lookup(&WaitInfo, plist))
    {
        POSITION pos = m_mapWaiting.GetStartPosition();

        while(pos != NULL)
        {
            WAIT_INFO *pWaitInfo ;
            CList<const CQueue*, const CQueue*&>* plistTmp ;

            m_mapWaiting.GetNextAssoc(pos, pWaitInfo, plistTmp);

            if (plistTmp == plist)
            {
                //
                // entry found. reset the flag.
                // Can it already be false ? yes:
                //
                // -Send a message to a remote computer. New session is created.
                // -Remote computer close the session. On local computer,
                //  ReadCompleted() fail and session is closed. Session object
                //  is alive, with status ssNotConnected.
                // -Stop msmq on remote computer (in real life, network may
                //  fail between the two computers).
                // -Before RelaseSession() is called, send another message
                //  to same remote queue.
                // -In IsThatYou(), FALSE is return due to ssNotConnected,
                //  and local computer try to create a new session.
                // -remote msmq is not available, so WAIT_INFO structure is
                //  created and inserted in CSessMgr::m_mapWaiting.
                // -ReleaseSession() is called for first session object. It
                //  call MarkAddressAsNotConnecting(), find the WAIT_INFO for the second
                //  session (the one not yet created) and its fInConnectionProcess value may
                //  be either FALSE or TRUE, sporadical
                //
                // Setting it to FALSE doesn't do any harm, it just make the
                // fix to WinSE bug 27985 less than optimal.
                //
                pWaitInfo->fInConnectionProcess = FALSE ;
                return ;
            }
        }
    }
}

//+-----------------------------------------------------------------------
//
//  BOOL  CSessionMgr::GetAddressToTryConnect()
//
// Get an address of remote computer so we can try to connect to.
// Do not return addresses that are now used by other threads.
// Fix for 6375, where multiple worker threads tried to connect to same
// address.
//
//+-----------------------------------------------------------------------

BOOL  CSessionMgr::GetAddressToTryConnect( OUT WAIT_INFO **ppWaitConnectInfo )
{
    static int s_iteration = 0;

    CS lock(m_csMapWaiting);

    //
    // Check which session to try
    //
    int iMaxIteration = m_mapWaiting.GetCount() ;

    s_iteration++;
    if (s_iteration > iMaxIteration)
    {
        s_iteration = 1;
    }

    //
    // And get to it
    //
    int i = 0 ;
    CList<const CQueue*, const CQueue*&>* plist;
    POSITION pos = m_mapWaiting.GetStartPosition();

    for ( ; i < s_iteration; i++)
    {
        m_mapWaiting.GetNextAssoc(pos, *ppWaitConnectInfo, plist);
    }

    //
    // Check if no other thread is trying to connect to this address.
    //
    if (!((*ppWaitConnectInfo)->fInConnectionProcess))
    {
        return TRUE ;
    }

    //
    // Try other addresses, from present position to end of map.
    //
    for ( ; i < iMaxIteration ; i++)
    {
        m_mapWaiting.GetNextAssoc(pos, *ppWaitConnectInfo, plist);

        if (!((*ppWaitConnectInfo)->fInConnectionProcess))
        {
            return TRUE ;
        }
    }

    //
    // Address not found. Try to find one in the first entries of the map.
    //
    pos = m_mapWaiting.GetStartPosition();
    for ( i = 0 ; i < (s_iteration-1) ; i++)
    {
        m_mapWaiting.GetNextAssoc(pos, *ppWaitConnectInfo, plist);

        if (!((*ppWaitConnectInfo)->fInConnectionProcess))
        {
            return TRUE ;
        }
    }

    //
    // didn't find a suitable address.
    //
    return FALSE ;
}

/*====================================================

CSessionMgr::TryConnect

Arguments:

Return Value:

Check if there are some waiting sessions, and try to connect
to them

Thread Context: Scheduler

=====================================================*/

inline void CSessionMgr::TryConnect()
{
    static DWORD s_dwConnectingThreads = 0 ;
    //
    // This count the number of threads that call CreateConnection().
    // We want that at any givem time, at least one worker thread will
    // be availalbe for other operations and won't be blocked on
    // CreateConnection(). Fix for bug 6375.
    //

    GUID gQMId;
    BOOL fQoS;
    P<TA_ADDRESS> pa;

    {
        CS lock(m_csMapWaiting);

        ASSERT(m_fTryConnectTimerScheduled);

        //
        // First, cleanup entries that need to be removed.
        //
        POSITION posmap;
        posmap = m_mapWaiting.GetStartPosition();
        while(posmap != NULL)
        {
            WAIT_INFO* pWaitRouteInfo;
            CList <const CQueue *, const CQueue *&>* plist;

            m_mapWaiting.GetNextAssoc(posmap, pWaitRouteInfo, plist);

            //
            // If the list of queues waiting for session is empty,
            // delete it, and delete the entry from the map.
            // If we're trying now to connect to this address, then
            // leave entry in map. It will be removed later.
            //
            if ( plist->IsEmpty()                        &&
                !(pWaitRouteInfo->fInConnectionProcess) )
            {
                m_mapWaiting.RemoveKey(pWaitRouteInfo);
                delete plist;
            }
        }

        //
        // If no waiting sessions, return
        //
        if(m_mapWaiting.IsEmpty())
        {
            m_fTryConnectTimerScheduled = FALSE;
            return;
        }

        //
        // Reschedule the timer. The address is removed from the map only when the
        // connection is completed successfully, therfore we need to reschedule the time
        // even if it is the last address in the map. However if the connection was successed,
        // next time the scheduler is called, the map will be empty and the scheduler doesn't
        // set anymore
        //
        ExSetTimer(&m_TryConnectTimer, CTimeDuration::FromMilliSeconds(5000));

        if (s_dwConnectingThreads >= (g_dwThreadsNo - 1))
        {
            //
            // enough threads are trying to connect. Leave this one
            // free for other operations.
            //
            return ;
        }

        WAIT_INFO* pWaitRouteInfo;
        BOOL f = GetAddressToTryConnect( &pWaitRouteInfo) ;
        if (!f)
        {
            //
            // Didn't find any address.
            //
            return ;
        }
        pWaitRouteInfo->fInConnectionProcess = TRUE ;

        //
        // since the key can be destruct during the Network connect, we copy the address
        // and the QM guid. We can use a CriticalSection to avoid this situation, but the
        // the NetworkConnect function can take lot of time (access to DNS) and try to avoid
        // the case that all the threads are waiting for this critical section.
        //
        pa = (TA_ADDRESS*) new UCHAR[sizeof(TA_ADDRESS)+ (pWaitRouteInfo->pAddr)->AddressLength];
        memcpy(pa,pWaitRouteInfo->pAddr, TA_ADDRESS_SIZE+(pWaitRouteInfo->pAddr)->AddressLength);
        gQMId = pWaitRouteInfo->guidQMId;
        fQoS = pWaitRouteInfo->fQoS ;

        s_dwConnectingThreads++ ;
    }

    //
    // And try to open a session with it.
    //
    P<CTransportBase> pSess = new CSockTransport();
    HRESULT rcCreate = pSess->CreateConnection(pa, &gQMId, FALSE);
    if(SUCCEEDED(rcCreate))
    {
        //
        // Notify the Session Manager of a newly created session
        //
        NewSession(pSess);
        pSess.detach();
    }

    {
        CS lock(m_csMapWaiting);

        if (FAILED(rcCreate))
        {
            MarkAddressAsNotConnecting( pa, gQMId, fQoS ) ;
        }

        s_dwConnectingThreads-- ;
        ASSERT(((LONG)s_dwConnectingThreads) >= 0) ;
    }
}


void
WINAPI
CSessionMgr::TimeToTryConnect(
    CTimer* pTimer
    )
/*++
Routine Description:
    The function is called from scheduler to try connecton to next address,
    when timeout is expired. The routine retrive the session manager
    object and calls the TryConnect memeber function

Arguments:
    pTimer - Pointer to Timer structure. pTimer is part of the SessionMgr
             object and it use to retrive it.

Return Value:
    None

--*/
{
    CSessionMgr* pSessMgr = CONTAINING_RECORD(pTimer, CSessionMgr, m_TryConnectTimer);

    DBGMSG((DBGMOD_NETSESSION, DBGLVL_TRACE, _T("Call Try Connect")));
    pSessMgr->TryConnect();
}


/*====================================================

CSessionMgr::AcceptSockSession

Arguments:

Return Value:

Called when a Sock connection was accepted.

=====================================================*/
void CSessionMgr::AcceptSockSession(IN TA_ADDRESS *pa,
                                    IN SOCKET sock)
{
    ASSERT(pa != NULL);

    //
    // Create a new session
    //
    CSockTransport* pSess = new CSockTransport;

    //
    // And pass to the session object
    //
    pSess->Connect(pa, sock);

    //
    // Notify of a newly created session
    //
    NewSession(pSess);
}


void
CSessionMgr::IPInit(void)
{
    SOCKADDR_IN local_sin;  /* Local socket - internet style */
    DWORD  dwThreadId,rc;

    g_sockListen = QmpCreateSocket(m_fUseQoS);

    if(g_sockListen == INVALID_SOCKET)
        return;
    local_sin.sin_family = AF_INET;

    ASSERT(g_dwIPPort);
    local_sin.sin_port = htons(DWORD_TO_WORD(g_dwIPPort));        /* Convert to network ordering */


    // to make sure that we open the port exclusivly
    BOOL exclusive = TRUE;
    rc = setsockopt( g_sockListen, SOL_SOCKET, SO_EXCLUSIVEADDRUSE , (char *)&exclusive, sizeof(exclusive));
    if (rc != 0)
    {
        rc = WSAGetLastError();
        DBGMSG((
            DBGMOD_ALL,
            DBGLVL_ERROR,
            TEXT("failed to set SO_EXCLUSIVEADDRUSE option to listening socket, rc = %d, QM Terminates"),
            rc));

        return;
    }


    if (IsLocalSystemCluster())
    {
        //
        // BUGBUG:
        //
        // On cluster we can not use INADDR_ANY because we will bind to
        // all addresses on the machine, including addresses in cluster
        // groups that are currently hosted on this machine.
        // We need to iterate the IP addresses and explicitly bind to each.
        // This way we are cluster-safe and do not need to know if we're on
        // cluster or not (thus our service would not depend on cluster service).
        // That means listenning on a different socket for each IP address.
        // This is too risky / complex at this point, so on cluster we bind
        // only to one IP address.  (ShaiK, 26-Apr-1999)
        //
		char szBuff[1000];
		DWORD dwSize = sizeof(szBuff);

		size_t res = wcstombs(szBuff, g_szMachineName, dwSize);
		ASSERT(res != (size_t)(-1));
		DBG_USED(res);

		PHOSTENT phe;
        phe = gethostbyname(szBuff);
        ASSERT(("must have an IP address", NULL != phe));

        memcpy(&local_sin.sin_addr.s_addr, phe->h_addr_list[0], IP_ADDRESS_LEN);
    }
    else
    {
        //
        //  Bind to all IP addresses
        //
        local_sin.sin_addr.s_addr = INADDR_ANY;
    }

    rc = bind( g_sockListen, (struct sockaddr FAR *) &local_sin, sizeof(local_sin));
    if (rc != 0)
    {
        rc = WSAGetLastError();
        DBGMSG((DBGMOD_ALL,DBGLVL_ERROR,TEXT("bind failed, rc = %d, QM Terminates"),rc));
        return;
    }

    rc = listen( g_sockListen, 5 ); // 5 is the maximum allowed length the queue of pending connections may grow
    if (rc != 0)
    {
        rc = WSAGetLastError();
        DBGMSG((DBGMOD_ALL,DBGLVL_ERROR,TEXT("Listen failed, rc = %d, QM Terminates"),rc));
        return;
    }

    HANDLE hThread;
    hThread = CreateThread(
                    NULL,
                    0,
                    (LPTHREAD_START_ROUTINE)AcceptIPThread,
                    NULL,
                    0,
                    &dwThreadId
                    );

    if(hThread == NULL)
    {
        rc = GetLastError();
        DBGMSG((
            DBGMOD_ALL,
            DBGLVL_ERROR,
            TEXT("Creation of listening thread failed , rc = %d, QM Terminates"),
            rc
            ));
        LogHR(rc, s_FN, 160);
        throw bad_alloc();
    }
    CloseHandle(hThread);
}





/*====================================================

CSessionMgr::SetWindowSize

Arguments: Window size

Return Value:  None

Called when the write to socket failed .

=====================================================*/
void CSessionMgr::SetWindowSize(WORD wWinSize)
{
    CS lock(m_csWinSize);

    m_wCurrentWinSize = wWinSize;

    //
    // The routine can calls multiple times. If the timer already set, try to cancel
    // it. If the cancel failed, don't care, it means there is another timer that already
    // expired but doesn't execute yet. This timer will update the window size and reschedule
    // the timer
    //
    if (!m_fUpdateWinSizeTimerScheduled || ExCancelTimer(&m_UpdateWinSizeTimer))
    {
        ExSetTimer(&m_UpdateWinSizeTimer, CTimeDuration::FromMilliSeconds(90*1000));
        m_fUpdateWinSizeTimerScheduled = TRUE;
    }

    DBGMSG((DBGMOD_QMACK,
            DBGLVL_TRACE,
            TEXT("QM window size set to: %d"), m_wCurrentWinSize));
}

/*====================================================

CSessionMgr::UpdateWindowSize

Arguments: None

Return Value:  None

Called from the scheduler to update the window size.

=====================================================*/
inline void CSessionMgr::UpdateWindowSize()
{
    CS lock(m_csWinSize);

    //
    // Update the window size until it reach the max size
    //
    m_wCurrentWinSize = (WORD)min((m_wCurrentWinSize * 2), m_wMaxWinSize);

    DBGMSG((DBGMOD_QMACK,
            DBGLVL_TRACE,
            TEXT("QM window size set to: %d"), m_wCurrentWinSize));

    if (m_wCurrentWinSize != m_wMaxWinSize)
    {
        //
        // Doesn't reach the maximum, reschedule for update
        //
        ExSetTimer(&m_UpdateWinSizeTimer, CTimeDuration::FromMilliSeconds(30*1000));
        return;
    }

    m_fUpdateWinSizeTimerScheduled = FALSE;
}


void
WINAPI
CSessionMgr::TimeToUpdateWindowSize(
    CTimer* pTimer
    )
/*++
Routine Description:
    The function is called from scheduler to update the machine window size,
    when timeout is expired. The routine retrive the session manager
    object and calls the UpdateWindowSize function member.

Arguments:
    pTimer - Pointer to Timer structure. pTimer is part of the SessionMgr
             object and it use to retrive the transport object.

Return Value:
    None

--*/
{
    CSessionMgr* pSessMgr = CONTAINING_RECORD(pTimer, CSessionMgr, m_UpdateWinSizeTimer);

    DBGMSG((DBGMOD_NETSESSION, DBGLVL_TRACE, _T("Call window update size")));
    pSessMgr->UpdateWindowSize();
}


void
CSessionMgr::NetworkConnection(
    BOOL fConnected
    )
//
// Routine Description:
//      The routine move the network from connected state to disconnected and
// vise-versa. The routine, resume/suspend the accept threads to allow/disallow
// acception of new session, and inform all the active session about the new state
//
// Arguments:
//      fConnected - Indicate the new state. TRUE if the network connected. FALSE
//                   otherwise
//
// Returned Value:
//      HRESULT. MQ_OK the network status change complete successfully. MQ_ERROR
//               otherwise
//
{
    CS lock(m_csListSess);

    if (fConnected)
    {
        //
        // Allow accept of incoming connection
        //                                    '
        SetEvent(m_hAcceptAllowed);
        return;
    }

    //
    // Don't allow accept of incoming connection
    //
    ResetEvent(m_hAcceptAllowed);

    //
    // move all the waiting queues to nonactive group for re-routing
    //
	MoveAllQueuesFromWaitingToNonActiveGroup();

    //
    // scan the open session and return them to connected state
    //
    POSITION pos = m_listSess.GetHeadPosition();
    while(pos != NULL)
    {
        CTransportBase* pSess = m_listSess.GetNext(pos);
        pSess->Disconnect();
    }
}


void
CSessionMgr::NewSession(
    CTransportBase *pSession
    )
{
    CS lock(m_csListSess);

    //
    // Add the session to the list of sessions
    //
    m_listSess.AddTail(pSession);

    //
    // Set the cleanup timer, if it was not set yet
    //
    if (!m_fCleanupTimerScheduled)
    {
        ExSetTimer(&m_CleanupTimer, CTimeDuration::FromMilliSeconds(m_dwSessionCleanTimeout));
        m_fCleanupTimerScheduled = TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\sessmgr.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    sessmgr.h

Abstract:
    Network session Menager definition

Author:
    Uri Habusha (urih)

--*/
#ifndef __SESSIONMGR_H__
#define __SESSIONMGR_H__

#include <winsock.h>
#include "qmpkt.h"
#include "factory.h"
#include "qmperf.h"
#include "cgroup.h"
#include "session.h"
#include "license.h"

//
// struct WAIT_INFO represent addresses of remote comptuers that wait to
// be connected, i.e., local QM need to establish a session with each of
// these addresses.
//

struct WAIT_INFO
{
    WAIT_INFO(TA_ADDRESS* _pAddr, const GUID& _guidQMId, BOOL _fQoS);

    TA_ADDRESS* pAddr;
    GUID guidQMId;
    BOOL fQoS;

    BOOL fInConnectionProcess ;
     //
     // fInConnectionProcess is set to TRUE when and while trying to connect
     // to this address. It's FALSE in all other timers. See WinSE bug 27985.
     // This flag is needed to prevent the scenario where multiple worker
     // threads try to connect to same address and so pool of worker threads
     // is exhausted.
     //
};

//
// CMap helper function decleration
//
void AFXAPI DestructElements(IN WAIT_INFO** ppNextHop, int n);
UINT AFXAPI HashKey(IN WAIT_INFO* key);
BOOL AFXAPI CompareElements(IN WAIT_INFO** pElem1,
                            IN WAIT_INFO** pElem2);


class CQueue;
class CTransportBase;
class CAddress;


class CSessionMgr
{
    public:

        CSessionMgr();
        ~CSessionMgr();

        HRESULT Init();
        void    BeginAccept();

        HRESULT GetSession(IN DWORD             dwFlag,
                           IN const CQueue *    hDstQ,
                           IN DWORD             dwNoOfTargets,
                           IN const CAddress* apTaAddr,
                           IN const GUID*       aQMId[],
                           IN bool              fQoS,
                           OUT CTransportBase**  ppSession);

        HRESULT GetSessionAnyFRS(IN const CQueue *  /*hDstQ*/,
                                 OUT CTransportBase**    /*ppSession*/)
                                {return MQ_ERROR;};

        HRESULT GetSessionForDirectQueue(IN  CQueue*     pQueue,
                                         OUT CTransportBase**  ppSession);

        void    RemoveWaitingQueue(CQueue* pQueue);
        void    AddWaitingQueue(CQueue* pQueue);
        void    MoveQueueFromWaitingToNonActiveGroup(CQueue* pQueue);

        void
        NotifyWaitingQueue(
            IN const TA_ADDRESS* pa,
            IN CTransportBase * pSess
            )
            throw(std::bad_alloc);


        void    TryConnect();

        void    ReleaseSession(void);

        void    AcceptSockSession(IN TA_ADDRESS *pa, IN SOCKET sock);

        const   CAddressList* GetIPAddressList(void);

        //
        // Administration routines
        //
        HRESULT
        ListPossibleNextHops(
            const CQueue* pQueue,
            LPWSTR** pNextHopAddress,
            DWORD* pNoOfNextHops
            );

        void
        NetworkConnection(
            BOOL fConnected
            );

        WORD    GetWindowSize() const;
        void    SetWindowSize(WORD);
        void    UpdateWindowSize(void);

        static DWORD m_dwSessionAckTimeout;
        static DWORD m_dwSessionStoreAckTimeout;
        static BOOL  m_fUsePing;
        static HANDLE m_hAcceptAllowed;
        static DWORD m_dwIdleAckDelay;
        static bool  m_fUseQoS;
        static AP<char> m_pszMsmqAppName;
        static AP<char> m_pszMsmqPolicyLocator;
        static bool  m_fAllocateMore;
		static DWORD m_DeliveryRetryTimeOutScale;

        static void WINAPI TimeToSessionCleanup(CTimer* pTimer);
        static void WINAPI TimeToUpdateWindowSize(CTimer* pTimer);
        static void WINAPI TimeToTryConnect(CTimer* pTimer);
        static void WINAPI TimeToRemoveFromWaitingGroup(CTimer* pTimer);

        void  MarkAddressAsNotConnecting(const TA_ADDRESS  *pAddr,
                                         const GUID&        guidQMId,
                                         BOOL               fDirect) ;


    private:           //Private Methods

        void AddWaitingSessions(IN DWORD dwNo,
                                IN const CAddress* apTaAddr,
                                IN const GUID* aQMId[],
                                bool           fQoS,
                                CQueue *pDstQ);

        void NewSession(IN CTransportBase *pSession);

        BOOL GetAddressToTryConnect( OUT WAIT_INFO **ppWaitConnectInfo ) ;

        bool
        IsReusedSession(
            const CTransportBase* pSession,
            DWORD noOdAddress,
            const CAddress* pAddress,
            const GUID** pGuid,
            bool         fQoS
            );

		void CSessionMgr::MoveAllQueuesFromWaitingToNonActiveGroup(void);

        static void IPInit(void);

        static void
        GetAndAllocateCharKeyValue(
            LPCTSTR     pszValueName,
            char      **ppchResult,
            const char *pchDefault
        );

        static bool
        GetAndAllocateCharKeyValue(
            LPCTSTR     pszValueName,
            char      **ppchResult
        );

    private:         // Private Data Member

        CCriticalSection    m_csListSess;       // Critical section protect m_listSess
        CCriticalSection    m_csMapWaiting;     // Critical section protect m_mapWaiting, m_listWaitToConnect
        //
        // List of opened sessions
        //
        CList<CTransportBase*, CTransportBase*&>         m_listSess;

        //
        // Map of list of queues waiting for a specific session
        //
        CMap<WAIT_INFO*,
             WAIT_INFO*,
             CList<const CQueue*, const CQueue*&>*,
             CList<const CQueue*, const CQueue*&>*& > m_mapWaiting;

        CList <const CQueue *, const CQueue *&> m_listWaitToConnect;

        CMap<LPCTSTR, LPCTSTR, CAddressList*, CAddressList*&> m_MapAddr;

        CAddressList*    m_pIP_Address;   // List of machine IP Address

        static DWORD m_dwSessionCleanTimeout;
        static DWORD m_dwQoSSessionCleanTimeoutMultiplier;

        //
        // Handle dynamic window size
        //

        CCriticalSection m_csWinSize;       // Critical section protect Dynamic Window size
        WORD m_wCurrentWinSize;
        WORD m_wMaxWinSize;
        DWORD m_dwMaxWaitTime;

        BOOL m_fUpdateWinSizeTimerScheduled;
        CTimer m_UpdateWinSizeTimer;

        //
        // Clean Up member variables
        //
        BOOL m_fCleanupTimerScheduled;
        CTimer m_CleanupTimer;

        //
        // Try Connect
        //
        BOOL m_fTryConnectTimerScheduled;
        CTimer m_TryConnectTimer;


};


/*======================================================

   FUNCTION: CSessionMgr::GetIPAddressList

========================================================*/
inline const CAddressList*
CSessionMgr::GetIPAddressList(void)
{
    return m_pIP_Address;
}


inline WORD
CSessionMgr::GetWindowSize() const
{
    return m_wCurrentWinSize;
}

/*======================================================

   WAIT_INFO implementation

========================================================*/
inline WAIT_INFO::WAIT_INFO(TA_ADDRESS* _pAddr, const GUID& _guidQMId, BOOL _fQoS) :
    pAddr(_pAddr),
    guidQMId(_guidQMId),
    fInConnectionProcess(FALSE),
    fQoS(_fQoS)
    {}

#endif          // __SESSIONMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\strcore.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdh.h"
#include <winnls.h>

#define SafeStrlen(lpsz) (((lpsz) == 0) ? 0 : lstrlen(lpsz))

#ifdef AFX_CORE1_SEG
#pragma code_seg(AFX_CORE1_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

// afxChNil is left for backward compatibility
AFX_DATADEF TCHAR afxChNil = '\0';

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
static int rgInitData[] = { -1, 0, 0, 0 };
static AFX_DATADEF CStringData* afxDataNil = (CStringData*)&rgInitData;
static LPCTSTR afxPchNil = (LPCTSTR)(((BYTE*)&rgInitData)+sizeof(CStringData));
// special function to make afxEmptyString work even during initialization
const CString& AFXAPI AfxGetEmptyString()
	{ return *(CString*)&afxPchNil; }

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CString::CString()
{
	Init();
}

CString::CString(const CString& stringSrc)
{
	ASSERT(stringSrc.GetData()->nRefs != 0);
	if (stringSrc.GetData()->nRefs >= 0)
	{
		ASSERT(stringSrc.GetData() != afxDataNil);
		m_pchData = stringSrc.m_pchData;
		InterlockedIncrement(&GetData()->nRefs);
	}
	else
	{
		Init();
		*this = stringSrc.m_pchData;
	}
}

void CString::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
{
	ASSERT(nLen >= 0);
	ASSERT(nLen <= INT_MAX-1);    // max size (enough room for 1 extra)

	if (nLen == 0)
		Init();
	else
	{
		CStringData* pData =
			(CStringData*)new BYTE[sizeof(CStringData) + (nLen+1)*sizeof(TCHAR)];
		pData->nRefs = 1;
		pData->data()[nLen] = '\0';
		pData->nDataLength = nLen;
		pData->nAllocLength = nLen;
		m_pchData = pData->data();
	}
}

void CString::Release()
{
	if (GetData() != afxDataNil)
	{
		ASSERT(GetData()->nRefs != 0);
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			delete[] (BYTE*)GetData();
		Init();
	}
}

void PASCAL CString::Release(CStringData* pData)
{
	if (pData != afxDataNil)
	{
		ASSERT(pData->nRefs != 0);
		if (InterlockedDecrement(&pData->nRefs) <= 0)
			delete[] (BYTE*)pData;
	}
}

void CString::Empty()
{
	if (GetData()->nRefs >= 0)
		Release();
	else
		*this = &afxChNil;
	ASSERT(GetData()->nDataLength == 0);
	ASSERT(GetData()->nRefs < 0 || GetData()->nAllocLength == 0);
}

void CString::CopyBeforeWrite()
{
	if (GetData()->nRefs > 1)
	{
		CStringData* pData = GetData();
		Release();
		AllocBuffer(pData->nDataLength);
		memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(TCHAR));
	}
	ASSERT(GetData()->nRefs <= 1);
}

void CString::AllocBeforeWrite(int nLen)
{
	if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
	{
		Release();
		AllocBuffer(nLen);
	}
	ASSERT(GetData()->nRefs <= 1);
}

CString::~CString()
//  free any attached data
{
	if (GetData() != afxDataNil)
	{
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			delete[] (BYTE*)GetData();
	}
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

void CString::AllocCopy(CString& dest, int nCopyLen, int nCopyIndex,
	 int nExtraLen) const
{
	// will clone the data attached to this string
	// allocating 'nExtraLen' characters
	// Places results in uninitialized string 'dest'
	// Will copy the part or all of original data to start of new string

	int nNewLen = nCopyLen + nExtraLen;
	if (nNewLen == 0)
	{
		dest.Init();
	}
	else
	{
		dest.AllocBuffer(nNewLen);
		memcpy(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(TCHAR));
	}
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CString::CString(LPCTSTR lpsz)
{
	Init();
	if (lpsz != NULL && HIWORD(lpsz) == NULL)
	{
	     ASSERT(0);
#if 0
		if (!LoadString(nID))
			TRACE1("Warning: implicit LoadString(%u) failed\n", nID);
            */
#endif

	}
	else
	{
		int nLen = SafeStrlen(lpsz);
		if (nLen != 0)
		{
			AllocBuffer(nLen);
			memcpy(m_pchData, lpsz, nLen*sizeof(TCHAR));
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

#ifdef _UNICODE
CString::CString(LPCSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	if (nSrcLen != 0)
	{
		AllocBuffer(nSrcLen);
		_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
		ReleaseBuffer();
	}
}
#else //_UNICODE
CString::CString(LPCWSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	if (nSrcLen != 0)
	{
		AllocBuffer(nSrcLen*2);
		_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
		ReleaseBuffer();
	}
}
#endif //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CString&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CString::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
	AllocBeforeWrite(nSrcLen);
	memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
	GetData()->nDataLength = nSrcLen;
	m_pchData[nSrcLen] = '\0';
}

const CString& CString::operator=(const CString& stringSrc)
{
	if (m_pchData != stringSrc.m_pchData)
	{
		if ((GetData()->nRefs < 0 && GetData() != afxDataNil) ||
			stringSrc.GetData()->nRefs < 0)
		{
			// actual copy necessary since one of the strings is locked
			AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
		}
		else
		{
			// can just copy references around
			Release();
			ASSERT(stringSrc.GetData() != afxDataNil);
			m_pchData = stringSrc.m_pchData;
			InterlockedIncrement(&GetData()->nRefs);
		}
	}
	return *this;
}

const CString& CString::operator=(LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	AssignCopy(SafeStrlen(lpsz), lpsz);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion assignment

#ifdef _UNICODE
const CString& CString::operator=(LPCSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	AllocBeforeWrite(nSrcLen);
	_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
	ReleaseBuffer();
	return *this;
}
#else //!_UNICODE
const CString& CString::operator=(LPCWSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	AllocBeforeWrite(nSrcLen*2);
	_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
	ReleaseBuffer();
	return *this;
}
#endif  //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CString + CString
// and for ? = TCHAR, LPCTSTR
//          CString + ?
//          ? + CString

void CString::ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data,
	int nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CString object

	int nNewLen = nSrc1Len + nSrc2Len;
	if (nNewLen != 0)
	{
		AllocBuffer(nNewLen);
		memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(TCHAR));
		memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(TCHAR));
	}
}

CString AFXAPI operator+(const CString& string1, const CString& string2)
{
	CString s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData,
		string2.GetData()->nDataLength, string2.m_pchData);
	return s;
}

CString AFXAPI operator+(const CString& string, LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	CString s;
	s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData,
        SafeStrlen(lpsz), lpsz);
	return s;
}

CString AFXAPI operator+(LPCTSTR lpsz, const CString& string)
{
	ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	CString s;
	s.ConcatCopy(SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength,
		string.m_pchData);
	return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CString::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
	//  -- the main routine for += operators

	// concatenating an empty string is a no-op!
	if (nSrcLen == 0)
		return;

	// if the buffer is too small, or we have a width mis-match, just
	//   allocate a new buffer (slow but sure)
	if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
	{
		// we have to grow the buffer, use the ConcatCopy routine
		CStringData* pOldData = GetData();
		ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
		ASSERT(pOldData != NULL);
		CString::Release(pOldData);
	}
	else
	{
		// fast concatenation when buffer big enough
		memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(TCHAR));
		GetData()->nDataLength += nSrcLen;
		ASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
		m_pchData[GetData()->nDataLength] = '\0';
	}
}

const CString& CString::operator+=(LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	ConcatInPlace(SafeStrlen(lpsz), lpsz);
	return *this;
}

const CString& CString::operator+=(TCHAR ch)
{
	ConcatInPlace(1, &ch);
	return *this;
}

const CString& CString::operator+=(const CString& string)
{
	ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
	return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

LPTSTR CString::GetBuffer(int nMinBufLength)
{
	ASSERT(nMinBufLength >= 0);

	if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
	{
		// we have to grow the buffer
		CStringData* pOldData = GetData();
		int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
		if (nMinBufLength < nOldLen)
			nMinBufLength = nOldLen;
		AllocBuffer(nMinBufLength);
		memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(TCHAR));
		GetData()->nDataLength = nOldLen;
		CString::Release(pOldData);
	}
	ASSERT(GetData()->nRefs <= 1);

	// return a pointer to the character storage for this string
	ASSERT(m_pchData != NULL);
	return m_pchData;
}

void CString::ReleaseBuffer(int nNewLength)
{
	CopyBeforeWrite();  // just in case GetBuffer was not called

	if (nNewLength == -1)
		nNewLength = lstrlen(m_pchData); // zero terminated

	ASSERT(nNewLength <= GetData()->nAllocLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
}

LPTSTR CString::GetBufferSetLength(int nNewLength)
{
	ASSERT(nNewLength >= 0);

	GetBuffer(nNewLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
	return m_pchData;
}

void CString::FreeExtra()
{
	ASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
	if (GetData()->nDataLength != GetData()->nAllocLength)
	{
		CStringData* pOldData = GetData();
		AllocBuffer(GetData()->nDataLength);
		memcpy(m_pchData, pOldData->data(), pOldData->nDataLength*sizeof(TCHAR));
		ASSERT(m_pchData[GetData()->nDataLength] == '\0');
		CString::Release(pOldData);
	}
	ASSERT(GetData() != NULL);
}

LPTSTR CString::LockBuffer()
{
	LPTSTR lpsz = GetBuffer(0);
	GetData()->nRefs = -1;
	return lpsz;
}

void CString::UnlockBuffer()
{
	ASSERT(GetData()->nRefs == -1);
	if (GetData() != afxDataNil)
		GetData()->nRefs = 1;
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)

int CString::Find(TCHAR ch) const
{
	// find first single character
	LPTSTR lpsz = _tcschr(m_pchData, (_TUCHAR)ch);

	// return -1 if not found and index otherwise
	return (lpsz == NULL) ? -1 : INT_PTR_TO_INT(lpsz - m_pchData);
}

int CString::FindOneOf(LPCTSTR lpszCharSet) const
{
	ASSERT(AfxIsValidString(lpszCharSet, FALSE));
	LPTSTR lpsz = _tcspbrk(m_pchData, lpszCharSet);
	return (lpsz == NULL) ? -1 : INT_PTR_TO_INT(lpsz - m_pchData);
}

void CString::MakeUpper()
{
	CopyBeforeWrite();
	::_wcsupr(m_pchData);
}

void CString::MakeLower()
{
	CopyBeforeWrite();
	::_wcslwr(m_pchData);
}

void CString::MakeReverse()
{
	CopyBeforeWrite();
	_tcsrev(m_pchData);
}

void CString::SetAt(int nIndex, TCHAR ch)
{
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);

	CopyBeforeWrite();
	m_pchData[nIndex] = ch;
}

#ifndef _UNICODE
void CString::AnsiToOem()
{
	CopyBeforeWrite();
	::AnsiToOem(m_pchData, m_pchData);
}
void CString::OemToAnsi()
{
	CopyBeforeWrite();
	::OemToAnsi(m_pchData, m_pchData);
}
#endif

///////////////////////////////////////////////////////////////////////////////
// CString conversion helpers (these use the current system locale)

int AFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
{
	if (count == 0 && mbstr != NULL)
		return 0;

	int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1,
		mbstr, numeric_cast<int>(count), NULL, NULL);
	ASSERT(mbstr == NULL || result <= (int)count);
	if ( result <= (int)count && result > 0)
		mbstr[result-1] = 0;
	return result;
}

int AFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
{
	if (count == 0 && wcstr != NULL)
		return 0;

	int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1,
		wcstr, numeric_cast<int>(count));
	ASSERT(wcstr == NULL || result <= (int)count);
	if ( result <= (int)count && result > 0)
		wcstr[result-1] = 0;
	return result;
}

LPWSTR AFXAPI AfxA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
	if (lpa == NULL)
		return NULL;
	ASSERT(lpw != NULL);
	// verify that no illegal character present
	// since lpw was allocated based on the size of lpa
	// don't worry about the number of chars
	lpw[0] = '\0';
	VERIFY(MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars));
	return lpw;
}

LPSTR AFXAPI AfxW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
	if (lpw == NULL)
		return NULL;
	ASSERT(lpa != NULL);
	// verify that no illegal character present
	// since lpa was allocated based on the size of lpw
	// don't worry about the number of chars
	lpa[0] = '\0';
	VERIFY(WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL));
	return lpa;
}

///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\setup.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    setup.cpp

Abstract:

    Auto configuration of QM

Author:

    Shai Kariv (shaik) Mar 18, 1999

Revision History:

--*/

#include "stdh.h"
#include "setup.h"
#include "cqpriv.h"
#include <mqupgrd.h>
#include <mqsec.h>
#include "cqmgr.h"
#include <mqnames.h>
#include "joinstat.h"
  
#include "setup.tmh"

extern LPTSTR       g_szMachineName;

static WCHAR *s_FN=L"setup";

//+---------------------------------------
//
//  CreateDirectoryIdempotent()
//
//+---------------------------------------

VOID
CreateDirectoryIdempotent(
    LPCWSTR pwzFolder
    )
{
    ASSERT(("must get a valid directory name", NULL != pwzFolder));

    if (CreateDirectory(pwzFolder, 0) ||
        ERROR_ALREADY_EXISTS == GetLastError())
    {
        return;
    }

    DWORD gle = GetLastError();
    DBGMSG((DBGMOD_ALL,DBGLVL_ERROR, L"failed to create directory %ls", pwzFolder));
    ASSERT(("Failed to create directory!", 0));
    LogNTStatus(gle, s_FN, 166);
    throw CSelfSetupException(CreateDirectory_ERR);

} //CreateDirectoryIdempotent


bool
SetDirectorySecurity(
	LPCWSTR pwzFolder
    )
/*++

Routine Description:

    Sets the security of the given directory such that any file that is created
    in the directory will have full control for  the local administrators group
    and no access at all to anybody else.

    Idempotent.

Arguments:

    pwzFolder - the folder to set the security for

Return Value:

    true - The operation was successfull.

    false - The operation failed.

--*/
{
    //
    // Get the SID of the local administrators group.
    //
    PSID pAdminSid;
    SID_IDENTIFIER_AUTHORITY NtSecAuth = SECURITY_NT_AUTHORITY;

    if (!AllocateAndInitializeSid(
                &NtSecAuth,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0,
                0,
                0,
                0,
                0,
                0,
                &pAdminSid
                ))
    {
        LogBOOL(FALSE, s_FN, 221);
        return false;
    }

    //
    // Create a DACL so that the local administrators group will have full
    // control for the directory and full control for files that will be
    // created in the directory. Anybody else will not have any access to the
    // directory and files that will be created in the directory.
    //
    P<ACL> pDacl;
    DWORD dwDaclSize;

    WORD dwAceSize = (WORD)(sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pAdminSid) - sizeof(DWORD));
    dwDaclSize = sizeof(ACL) + 2 * (dwAceSize);
    pDacl = (PACL)(char*) new BYTE[dwDaclSize];
    P<ACCESS_ALLOWED_ACE> pAce = (PACCESS_ALLOWED_ACE) new BYTE[dwAceSize];

    pAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    pAce->Header.AceFlags = OBJECT_INHERIT_ACE;
    pAce->Header.AceSize = dwAceSize;
    pAce->Mask = FILE_ALL_ACCESS;
    memcpy(&pAce->SidStart, pAdminSid, GetLengthSid(pAdminSid));

    bool fRet = true;

    //
    // Create the security descriptor and set the it as the security
    // descriptor of the directory.
    //
    SECURITY_DESCRIPTOR SD;

    if (!InitializeSecurityDescriptor(&SD, SECURITY_DESCRIPTOR_REVISION) ||
        !InitializeAcl(pDacl, dwDaclSize, ACL_REVISION) ||
        !AddAccessAllowedAce(pDacl, ACL_REVISION, FILE_ALL_ACCESS, pAdminSid) ||
        !AddAce(pDacl, ACL_REVISION, MAXDWORD, (LPVOID) pAce, dwAceSize) ||
        !SetSecurityDescriptorDacl(&SD, TRUE, pDacl, FALSE) ||
        !SetFileSecurity(pwzFolder, DACL_SECURITY_INFORMATION, &SD))
    {
        fRet = false;
    }

    FreeSid(pAdminSid);

    LogBOOL((fRet?TRUE:FALSE), s_FN, 222);
    return fRet;

} //SetDirectorySecurity


VOID
CreateStorageDirectories(
    VOID
    )
{
    //
    // Keep this routine idempotent !
    //

    WCHAR MsmqRootDir[MAX_PATH];
    DWORD dwType = REG_SZ ;
    DWORD dwSize = MAX_PATH;
    LONG rc = GetFalconKeyValue(
                  MSMQ_ROOT_PATH,
                  &dwType,
                  MsmqRootDir,
                  &dwSize
                  );

    if (ERROR_SUCCESS != rc)
    {
        DBGMSG((DBGMOD_ALL,DBGLVL_ERROR, L"failed to read msmq root path from registry"));
        ASSERT(("failed to get msmq root path from registry", 0));
        LogNTStatus(rc, s_FN, 167);
        throw CSelfSetupException(ReadRegistry_ERR);
    }

	CreateDirectoryIdempotent(MsmqRootDir);
    SetDirectorySecurity(MsmqRootDir);

    WCHAR MsmqStorageDir[MAX_PATH];
    wcscpy(MsmqStorageDir, MsmqRootDir);
    wcscat(MsmqStorageDir, DIR_MSMQ_STORAGE);
    CreateDirectoryIdempotent(MsmqStorageDir);
    SetDirectorySecurity(MsmqStorageDir);

    WCHAR MsmqLqsDir[MAX_PATH];
    wcscpy(MsmqLqsDir, MsmqRootDir);
    wcscat(MsmqLqsDir, DIR_MSMQ_LQS);
    CreateDirectoryIdempotent(MsmqLqsDir);
    SetDirectorySecurity(MsmqLqsDir);

    dwType = REG_SZ;
    dwSize = (wcslen(MsmqStorageDir) + 1) * sizeof(WCHAR);
    rc = SetFalconKeyValue(MSMQ_STORE_RELIABLE_PATH_REGNAME, &dwType, MsmqStorageDir, &dwSize);
    ASSERT(("Failed to write to registry", ERROR_SUCCESS == rc));

    dwType = REG_SZ;
    dwSize = (wcslen(MsmqStorageDir) + 1) * sizeof(WCHAR);
    rc = SetFalconKeyValue(MSMQ_STORE_PERSISTENT_PATH_REGNAME, &dwType, MsmqStorageDir, &dwSize);
    ASSERT(("Failed to write to registry", ERROR_SUCCESS == rc));

    dwType = REG_SZ;
    dwSize = (wcslen(MsmqStorageDir) + 1) * sizeof(WCHAR);
    rc = SetFalconKeyValue(MSMQ_STORE_JOURNAL_PATH_REGNAME, &dwType, MsmqStorageDir, &dwSize);
    ASSERT(("Failed to write to registry", ERROR_SUCCESS == rc));

    dwType = REG_SZ;
    dwSize = (wcslen(MsmqStorageDir) + 1) * sizeof(WCHAR);
    rc = SetFalconKeyValue(MSMQ_STORE_LOG_PATH_REGNAME, &dwType, MsmqStorageDir, &dwSize);
    ASSERT(("Failed to write to registry", ERROR_SUCCESS == rc));

    dwType = REG_SZ;
    dwSize = (wcslen(MsmqStorageDir) + 1) * sizeof(WCHAR);
    rc = SetFalconKeyValue(FALCON_XACTFILE_PATH_REGNAME, &dwType, MsmqStorageDir, &dwSize);
    ASSERT(("Failed to write to registry", ERROR_SUCCESS == rc));

} // CreateStorageDirectories


VOID
CreateMachineQueues(
    VOID
    )
{
    //
    // Keep this routine idempotent !
    //

    WCHAR wzQueuePath[MAX_PATH] = {0};

    wsprintf(wzQueuePath, L"%s\\private$\\%s", g_szMachineName, ADMINISTRATION_QUEUE_NAME);
    HRESULT hr =  g_QPrivate.QMSetupCreateSystemQueue(wzQueuePath, ADMINISTRATION_QUEUE_ID);
    ASSERT(("failed to create admin_queue$", MQ_OK == hr));

    wsprintf(wzQueuePath, L"%s\\private$\\%s", g_szMachineName, NOTIFICATION_QUEUE_NAME);
    hr =  g_QPrivate.QMSetupCreateSystemQueue(wzQueuePath, NOTIFICATION_QUEUE_ID);
    ASSERT(("failed to create notify_queue$", MQ_OK == hr));

    wsprintf(wzQueuePath, L"%s\\private$\\%s", g_szMachineName, ORDERING_QUEUE_NAME);
    hr =  g_QPrivate.QMSetupCreateSystemQueue(wzQueuePath, ORDERING_QUEUE_ID);
    ASSERT(("failed to create order_queue$", MQ_OK == hr));

    wsprintf(wzQueuePath, L"%s\\private$\\%s", g_szMachineName, REPLICATION_QUEUE_NAME);
    hr =  g_QPrivate.QMSetupCreateSystemQueue(wzQueuePath, REPLICATION_QUEUE_ID);
    ASSERT(("failed to create mqis_queue$", MQ_OK == hr));

    //
    // This queue is created for fresh install to support migration of
    // a clustered PEC. In this case the migration tool is running on 
    // a fresh install and needs this queue.
    //
    wsprintf(wzQueuePath, L"%s\\private$\\%s", g_szMachineName, NT5PEC_REPLICATION_QUEUE_NAME);
    hr =  g_QPrivate.QMSetupCreateSystemQueue(wzQueuePath, NT5PEC_REPLICATION_QUEUE_ID);
    ASSERT(("failed to create nt5pec_mqis_queue$", MQ_OK == hr));

    DWORD dwValue = 0x0f;
	DWORD dwType = REG_DWORD;
	DWORD dwSize = sizeof(DWORD);
	LONG rc = SetFalconKeyValue(
                  L"LastPrivateQueueId",
                  &dwType,
                  &dwValue,
                  &dwSize
                  );
    ASSERT(("failed to write LastPrivateQueueId to registry", ERROR_SUCCESS == rc));
    LogNTStatus(rc, s_FN, 223);

} //CreateMachineQueues


//+------------------------------------------------------------------------
//
//  HRESULT  CreateTheConfigObj()
//
//  Create the msmqConfiguration object in the Active Directory.
//
//+------------------------------------------------------------------------

HRESULT  CreateTheConfigObj()
{
    TCHAR tBuf[ 24 ] ;

    CAutoFreeLibrary hLib = LoadLibrary(MQUPGRD_DLL_NAME);

    if (!hLib)
    {
        _stprintf(tBuf, TEXT("%lut"), GetLastError()) ;
        REPORT_WITH_STRINGS_AND_CATEGORY(( CATEGORY_KERNEL,
                                           LoadMqupgrd_ERR,
                                           1, tBuf )) ;
        return LogHR(MQ_ERROR, s_FN, 10);
    }

    pfCreateMsmqObj_ROUTINE pfCreateMsmqObj = (pfCreateMsmqObj_ROUTINE)
                                   GetProcAddress(hLib, "MqCreateMsmqObj") ;
    if (NULL == pfCreateMsmqObj)
    {
        _stprintf(tBuf, TEXT("%lut"), GetLastError()) ;
        REPORT_WITH_STRINGS_AND_CATEGORY(( CATEGORY_KERNEL,
                                           GetAdrsCreateObj_ERR,
                                           1, tBuf )) ;
        return LogHR(MQ_ERROR, s_FN, 20);
    }

    HRESULT hr = pfCreateMsmqObj();

    if (SUCCEEDED(hr))
    {                
        //
        // We successfully created the object in active directory.
        // Store distinguished name of computer in registry. This will
        // be used later if machine move between domains.
        //
        SetMachineForDomain() ;
	}

    return LogHR(hr, s_FN, 30);
}

//+------------------------------------------------------------------------
//
//  VOID  CompleteMsmqSetupInAds()
//
//  Create the msmqConfiguration object in the Active Directory. that's
//  part of setup, and it's actually complete setup of msmq client on
//  machine that's part of Win2000 domain.
//
//+------------------------------------------------------------------------

VOID  CompleteMsmqSetupInAds()
{
    HRESULT hr = MQ_ERROR ;

    try
    {
        //
        // Guarantee that the code below never generate an unexpected
        // exception. The "throw" below notify any error to the msmq service.
        //
        DWORD dwType = REG_DWORD ;
        DWORD dwSize = sizeof(DWORD) ;
        DWORD dwCreate = 0 ;

        LONG rc = GetFalconKeyValue( MSMQ_CREATE_CONFIG_OBJ_REGNAME,
                                    &dwType,
                                    &dwCreate,
                                    &dwSize ) ;
        if ((rc != ERROR_SUCCESS) || (dwCreate == 0))
        {
            //
            // No need to create the msmq configuration object.
            //
            return ;
        }

        hr = CreateTheConfigObj();

        QmpReportServiceProgress();

        //
        // Write hr to registry. Setup is waiting for it, to terminate.
        //
        dwType = REG_DWORD ;
        dwSize = sizeof(DWORD) ;

        rc = SetFalconKeyValue( MSMQ_CONFIG_OBJ_RESULT_REGNAME,
                               &dwType,
                               &hr,
                               &dwSize ) ;
        ASSERT(rc == ERROR_SUCCESS) ;

        if (SUCCEEDED(hr))
        {
            //
            // Reset the create flag in registry.
            //
            dwType = REG_DWORD ;
            dwSize = sizeof(DWORD) ;
            dwCreate = 0 ;

            rc = SetFalconKeyValue( MSMQ_CREATE_CONFIG_OBJ_REGNAME,
                                   &dwType,
                                   &dwCreate,
                                   &dwSize ) ;
            ASSERT(rc == ERROR_SUCCESS) ;

            //
            // write successful join status. Needed for code that test
            // for join/leave transitions.
            //
            DWORD dwJoinStatus = MSMQ_JOIN_STATUS_JOINED_SUCCESSFULLY ;
            dwSize = sizeof(DWORD) ;
            dwType = REG_DWORD ;

            rc = SetFalconKeyValue( MSMQ_JOIN_STATUS_REGNAME,
                                   &dwType,
                                   &dwJoinStatus,
                                   &dwSize ) ;
            ASSERT(rc == ERROR_SUCCESS) ;
        }
    }
    catch(...)
    {
         LogIllegalPoint(s_FN, 81);
    }

    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 168);
        throw CSelfSetupException(CreateMsmqObj_ERR);
    }
}

//+------------------------------------------------------------------
//
//  void   AddMachineSecurity()
//
//  Save cached default machine security descriptor in registry.
//  This descriptor grant full control to everyone.
//
//+------------------------------------------------------------------

void   AddMachineSecurity()
{
    PSECURITY_DESCRIPTOR pDescriptor = NULL ;
    HRESULT hr = MQSec_GetDefaultSecDescriptor(
                                  MQDS_MACHINE,
                                 &pDescriptor,
                                  FALSE,  // fImpersonate
                                  NULL,
                                  0,      // seInfoToRemove
                                  e_GrantFullControlToEveryone ) ;
    if (FAILED(hr))
    {
        return ;
    }

    P<BYTE> pBuf = (BYTE*) pDescriptor ;

    DWORD dwSize = GetSecurityDescriptorLength(pDescriptor) ;

    hr = SetMachineSecurityCache(pDescriptor, dwSize) ;
    LogHR(hr, s_FN, 226);
}

//+------------------------------------------------------------------------
//
//  VOID  CompleteServerUpgrade()
//
//  This function only update the MSMQ_MQS_ROUTING_REGNAME
//  for server upgrade.
//	All other Ds related updates are done in mqdssvc (mqds service)
//
//+------------------------------------------------------------------------

VOID  CompleteServerUpgrade()
{
    //
    // get MQS value from registry to know what service type was before upgrade
    // don't change this flag in registry: we need it after QmpInitializeInternal
    // (in order to change machine setting) !!!
    //
    DWORD dwDef = 0xfffe ;
    DWORD dwMQS;
    READ_REG_DWORD(dwMQS, MSMQ_MQS_REGNAME, &dwDef);

    if (dwMQS == dwDef)
    {
       DBGMSG((DBGMOD_ALL,
              DBGLVL_WARNING,
              _TEXT("QMInit :: Could not retrieve data for value MQS in registry")));
	      return ;
    }

    if (dwMQS < SERVICE_BSC || dwMQS > SERVICE_PSC)
    {
        //
        // this machine was neither BSC nor PSC. do nothing
        //
        return;
    }

    //
    // We are here iff this computer was either BSC or PSC 
    //

    //
    // change MQS_Routing value to 1. this server is routing server
    //

    DWORD dwSize = sizeof(DWORD) ;
    DWORD dwType = REG_DWORD ;		
	DWORD  dwValue;

    DWORD dwErr = GetFalconKeyValue( 
						MSMQ_MQS_ROUTING_REGNAME,
						&dwType,
						&dwValue,
						&dwSize 
						);

	if (dwErr != ERROR_SUCCESS)
    {
        //
        // Set routing flag to 1 only if not set at all.
        // If it's 0, then keep it 0. We're only concerned here with upgrade
        // of nt4 BSC and we don't want to change functionality of win2k
        // server after dcunpromo.
        //
        dwValue = 1;
        dwErr = SetFalconKeyValue( 
					MSMQ_MQS_ROUTING_REGNAME,
					&dwType,
					&dwValue,
					&dwSize 
					);

        if (dwErr != ERROR_SUCCESS)
        {
            DBGMSG((DBGMOD_ALL, DBGLVL_WARNING, _T(
             "CompleteServerUpgrade()- Could not set MQS_Routing. Err- %lut"), dwErr));
        }
    }

	ASSERT(dwValue == 1);

    //
    // Update Queue Manager
    //
    dwErr = QueueMgr.SetMQSRouting();
    if(FAILED(dwErr))
    {
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\strex.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdh.h"

#ifdef AFX_AUX_SEG
#pragma code_seg(AFX_AUX_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CString::CString(TCHAR ch, int nLength)
{
	ASSERT(!_istlead(ch));    // can't create a lead byte string
	Init();
	if (nLength >= 1)
	{
		AllocBuffer(nLength);
#ifdef _UNICODE
		for (int i = 0; i < nLength; i++)
			m_pchData[i] = ch;
#else
		memset(m_pchData, ch, nLength);
#endif
	}
}

CString::CString(LPCTSTR lpch, int nLength)
{
	Init();
	if (nLength != 0)
	{
		ASSERT(AfxIsValidAddress(lpch, nLength, FALSE));
		AllocBuffer(nLength);
		memcpy(m_pchData, lpch, nLength*sizeof(TCHAR));
	}
}

//////////////////////////////////////////////////////////////////////////////
// Assignment operators

const CString& CString::operator=(TCHAR ch)
{
	ASSERT(!_istlead(ch));    // can't set single lead byte
	AssignCopy(1, &ch);
	return *this;
}

//////////////////////////////////////////////////////////////////////////////
// less common string expressions

CString AFXAPI operator+(const CString& string1, TCHAR ch)
{
	CString s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, 1, &ch);
	return s;
}

CString AFXAPI operator+(TCHAR ch, const CString& string)
{
	CString s;
	s.ConcatCopy(1, &ch, string.GetData()->nDataLength, string.m_pchData);
	return s;
}

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CString CString::Mid(int nFirst) const
{
	return Mid(nFirst, GetData()->nDataLength - nFirst);
}

CString CString::Mid(int nFirst, int nCount) const
{
	// out-of-bounds requests return sensible things
	if (nFirst < 0)
		nFirst = 0;
	if (nCount < 0)
		nCount = 0;

	if (nFirst + nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength - nFirst;
	if (nFirst > GetData()->nDataLength)
		nCount = 0;

	CString dest;
	AllocCopy(dest, nCount, nFirst, 0);
	return dest;
}

CString CString::Right(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	else if (nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength;

	CString dest;
	AllocCopy(dest, nCount, GetData()->nDataLength-nCount, 0);
	return dest;
}

CString CString::Left(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	else if (nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength;

	CString dest;
	AllocCopy(dest, nCount, 0, 0);
	return dest;
}

// strspn equivalent
CString CString::SpanIncluding(LPCTSTR lpszCharSet) const
{
	ASSERT(AfxIsValidString(lpszCharSet, FALSE));
	return Left(numeric_cast<int>(_tcsspn(m_pchData, lpszCharSet)));
}

// strcspn equivalent
CString CString::SpanExcluding(LPCTSTR lpszCharSet) const
{
	ASSERT(AfxIsValidString(lpszCharSet, FALSE));
	return Left(numeric_cast<int>(_tcscspn(m_pchData, lpszCharSet)));
}

//////////////////////////////////////////////////////////////////////////////
// Finding

int CString::ReverseFind(TCHAR ch) const
{
	// find last single character
	LPTSTR lpsz = _tcsrchr(m_pchData, (_TUCHAR)ch);

	// return -1 if not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : INT_PTR_TO_INT(lpsz - m_pchData);
}

// find a sub-string (like strstr)
int CString::Find(LPCTSTR lpszSub) const
{
	ASSERT(AfxIsValidString(lpszSub, FALSE));

	// find first matching substring
	LPTSTR lpsz = _tcsstr(m_pchData, lpszSub);

	// return -1 for not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : INT_PTR_TO_INT(lpsz - m_pchData);
}

/////////////////////////////////////////////////////////////////////////////
// CString formatting

#ifdef _MAC
	#define TCHAR_ARG   int
	#define WCHAR_ARG   unsigned
	#define CHAR_ARG    int
#else
	#define TCHAR_ARG   TCHAR
	#define WCHAR_ARG   WCHAR
	#define CHAR_ARG    char
#endif

#if defined(_68K_) || defined(_X86_)
	#define DOUBLE_ARG  _AFX_DOUBLE
#else
	#define DOUBLE_ARG  double
#endif

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000

void CString::FormatV(LPCTSTR lpszFormat, va_list argList)
{
	ASSERT(AfxIsValidString(lpszFormat, FALSE));

	va_list argListSave = argList;

	// make a guess at the maximum length of the resulting string
	INT_PTR nMaxLen = 0;
	for (LPCTSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
	{
		// handle '%' character, but watch out for '%%'
		if (*lpsz != '%' || *(lpsz = _tcsinc(lpsz)) == '%')
		{
			nMaxLen += _tclen(lpsz);
			continue;
		}

		INT_PTR nItemLen = 0;

		// handle '%' character with format
		int nWidth = 0;
		for (; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
		{
			// check for valid flags
			if (*lpsz == '#')
				nMaxLen += 2;   // for '0x'
			else if (*lpsz == '*')
				nWidth = va_arg(argList, int);
			else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' ||
				*lpsz == ' ')
				;
			else // hit non-flag character
				break;
		}
		// get width and skip it
		if (nWidth == 0)
		{
			// width indicated by
			nWidth = _ttoi(lpsz);
			for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
				;
		}
		ASSERT(nWidth >= 0);

		int nPrecision = 0;
		if (*lpsz == '.')
		{
			// skip past '.' separator (width.precision)
			lpsz = _tcsinc(lpsz);

			// get precision and skip it
			if (*lpsz == '*')
			{
				nPrecision = va_arg(argList, int);
				lpsz = _tcsinc(lpsz);
			}
			else
			{
				nPrecision = _ttoi(lpsz);
				for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
					;
			}
			ASSERT(nPrecision >= 0);
		}

		// should be on type modifier or specifier
		int nModifier = 0;
		switch (*lpsz)
		{
		// modifiers that affect size
		case 'h':
			nModifier = FORCE_ANSI;
			lpsz = _tcsinc(lpsz);
			break;
		case 'l':
			nModifier = FORCE_UNICODE;
			lpsz = _tcsinc(lpsz);
			break;

		// modifiers that do not affect size
		case 'F':
		case 'N':
		case 'L':
			lpsz = _tcsinc(lpsz);
			break;
		}

		// now should be on specifier
		switch (*lpsz | nModifier)
		{
		// single characters
		case 'c':
		case 'C':
			nItemLen = 2;
			va_arg(argList, TCHAR_ARG);
			break;
		case 'c'|FORCE_ANSI:
		case 'C'|FORCE_ANSI:
			nItemLen = 2;
			va_arg(argList, CHAR_ARG);
			break;
		case 'c'|FORCE_UNICODE:
		case 'C'|FORCE_UNICODE:
			nItemLen = 2;
			va_arg(argList, WCHAR_ARG);
			break;

		// strings
		case 's':
			nItemLen = lstrlen(va_arg(argList, LPCTSTR));
			nItemLen = max(1, nItemLen);
			break;

		case 'S':
#ifndef _UNICODE
			nItemLen = wcslen(va_arg(argList, LPWSTR));
#else
			nItemLen = lstrlenA(va_arg(argList, LPCSTR));
#endif
			nItemLen = max(1, nItemLen);
			break;

		case 's'|FORCE_ANSI:
		case 'S'|FORCE_ANSI:
			nItemLen = lstrlenA(va_arg(argList, LPCSTR));
			nItemLen = max(1, nItemLen);
			break;
#ifndef _MAC
		case 's'|FORCE_UNICODE:
		case 'S'|FORCE_UNICODE:
			nItemLen = wcslen(va_arg(argList, LPWSTR));
			nItemLen = max(1, nItemLen);
			break;
#endif
		}

		// adjust nItemLen for strings
		if (nItemLen != 0)
		{
			nItemLen = max(nItemLen, nWidth);
			if (nPrecision != 0)
				nItemLen = min(nItemLen, nPrecision);
		}
		else
		{
			switch (*lpsz)
			{
			// integers
			case 'd':
			case 'i':
			case 'u':
			case 'x':
			case 'X':
			case 'o':
				va_arg(argList, int);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			case 'e':
			case 'f':
			case 'g':
			case 'G':
				va_arg(argList, DOUBLE_ARG);
				nItemLen = 128;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			case 'p':
				va_arg(argList, void*);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			// no output
			case 'n':
				va_arg(argList, int*);
				break;

			default:
				ASSERT(FALSE);  // unknown formatting option
			}
		}

		// adjust nMaxLen for output nItemLen
		nMaxLen += nItemLen;
	}

	GetBuffer(INT_PTR_TO_INT(nMaxLen));
	VERIFY(_vstprintf(m_pchData, lpszFormat, argListSave) <= GetAllocLength());
	ReleaseBuffer();

	va_end(argListSave);
}

// formatting (using wsprintf style formatting)
void AFX_CDECL CString::Format(LPCTSTR lpszFormat, ...)
{
	ASSERT(AfxIsValidString(lpszFormat, FALSE));

	va_list argList;
	va_start(argList, lpszFormat);
	FormatV(lpszFormat, argList);
	va_end(argList);
}

void AFX_CDECL CString::Format(UINT nFormatID, ...)
{
    ASSERT(0);
#if 0
	CString strFormat;
	VERIFY(strFormat.LoadString(nFormatID) != 0);

	va_list argList;
	va_start(argList, nFormatID);
	FormatV(strFormat, argList);
	va_end(argList);
#endif 
}

#ifndef _MAC

#if 0
// formatting (using FormatMessage style formatting)
void AFX_CDECL CString::FormatMessage(LPCTSTR lpszFormat, ...)
{
	// format message into temporary buffer lpszTemp
	va_list argList;
	va_start(argList, lpszFormat);
	LPTSTR lpszTemp;
	::FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
		lpszFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList);
	if (lpszTemp == NULL)
		AfxThrowMemoryException();

	// assign lpszTemp into the resulting string and free the temporary
	*this = lpszTemp;
	LocalFree(lpszTemp);
	va_end(argList);
}
#endif

void AFX_CDECL CString::FormatMessage(UINT nFormatID, ...)
{
    ASSERT(0);
#if 0
	// get format string from string table
	CString strFormat;
	VERIFY(strFormat.LoadString(nFormatID) != 0);

	// format message into temporary buffer lpszTemp
	va_list argList;
	va_start(argList, nFormatID);
	LPTSTR lpszTemp;
	::FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
		strFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList);
	if (lpszTemp == NULL)
		AfxThrowMemoryException();

	// assign lpszTemp into the resulting string and free lpszTemp
	*this = lpszTemp;
	LocalFree(lpszTemp);
	va_end(argList);
#endif
}
#endif //!_MAC

void CString::TrimRight()
{
	CopyBeforeWrite();

	// find beginning of trailing spaces by starting at beginning (DBCS aware)
	LPTSTR lpsz = m_pchData;
	LPTSTR lpszLast = NULL;
	while (*lpsz != '\0')
	{
		if (_istspace(*lpsz))
		{
			if (lpszLast == NULL)
				lpszLast = lpsz;
		}
		else
			lpszLast = NULL;
		lpsz = _tcsinc(lpsz);
	}

	if (lpszLast != NULL)
	{
		// truncate at trailing space start
		*lpszLast = '\0';
		GetData()->nDataLength = INT_PTR_TO_INT(lpszLast - m_pchData);
	}
}

void CString::TrimLeft()
{
	CopyBeforeWrite();

	// find first non-space character
	LPCTSTR lpsz = m_pchData;
	while (_istspace(*lpsz))
		lpsz = _tcsinc(lpsz);

	// fix up data and length
	int nDataLength = GetData()->nDataLength - INT_PTR_TO_INT(lpsz - m_pchData);
	memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
	GetData()->nDataLength = nDataLength;
}

///////////////////////////////////////////////////////////////////////////////
// CString support for template collections

void AFXAPI ConstructElements(CString* pElements, int nCount)
{
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pElements, nCount * sizeof(CString)));

	for (; nCount--; ++pElements)
		memcpy(pElements, &afxEmptyString, sizeof(*pElements));
}

void AFXAPI DestructElements(CString* pElements, int nCount)
{
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pElements, nCount * sizeof(CString)));

	for (; nCount--; ++pElements)
		pElements->~CString();
}

void AFXAPI CopyElements(CString* pDest, const CString* pSrc, int nCount)
{
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pDest, nCount * sizeof(CString)));
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pSrc, nCount * sizeof(CString)));

	for (; nCount--; ++pDest, ++pSrc)
		*pDest = *pSrc;
}

UINT AFXAPI HashKey(LPCTSTR key)
{
	UINT nHash = 0;
	while (*key)
		nHash = (nHash<<5) + nHash + *key++;
	return nHash;
}

///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\symmkey.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    symmkey.cpp

Abstract:

    Encryption/Decryption symmetric key caching and handling.

Author:

    Boaz Feldbaum (BoazF) 30-Oct-1996.

--*/

#include "stdh.h"
#include <ds.h>
#include "qmsecutl.h"
#include <mqtempl.h>
#include "cache.h"
#include <mqsec.h>

#include "symmkey.tmh"

extern BOOL g_fSendEnhRC2WithLen40 ;

#define QMCRYPTINFO_KEYXPBK_EXIST   1
#define QMCRYPTINFO_HKEYXPBK_EXIST  2
#define QMCRYPTINFO_RC4_EXIST       4
#define QMCRYPTINFO_RC2_EXIST       8

static WCHAR *s_FN=L"symmkey";

// This is the structure where we store the cached symmetric keys.
class QMCRYPTINFO : public CCacheValue
{
public:
    QMCRYPTINFO();

    CHCryptKey hKeyxPbKey;      // A handle to the QM key exchange public key.
    AP<BYTE> pbPbKeyxKey;       // The QM key exchange public key blob.
    DWORD dwPbKeyxKeyLen;       // The QM key exchange public key blob length.

    CHCryptKey hRC4Key;         // A handle to the RC4 symmetric key.
    AP<BYTE> pbRC4EncSymmKey;   // The RC4 symmetric key blob.
    DWORD dwRC4EncSymmKeyLen;   // The RC4 symmetric key blob length.

    CHCryptKey hRC2Key;         // A handle to the RC2 symmetric key.
    AP<BYTE> pbRC2EncSymmKey;   // The RC2 symmetric key blob.
    DWORD dwRC2EncSymmKeyLen;   // The RC2 symmetric key blob length.

    DWORD dwFlags;              // Flags that indicates which of the fields are valid.
    enum enumProvider eProvider ;
    HCRYPTPROV        hProv ;
    HRESULT           hr ;

private:
    ~QMCRYPTINFO() {}
};

typedef QMCRYPTINFO *PQMCRYPTINFO;

QMCRYPTINFO::QMCRYPTINFO() :
    dwPbKeyxKeyLen(0),
    dwRC4EncSymmKeyLen(0),
    dwRC2EncSymmKeyLen(0),
    eProvider(eBaseProvider),
    dwFlags(0),
    hProv(NULL)
{
}

inline void AFXAPI DestructElements(PQMCRYPTINFO *ppQmCryptInfo, int nCount)
{
    for (; nCount--; ppQmCryptInfo++)
    {
        (*ppQmCryptInfo)->Release();
    }
}

//
// Make two partitions of the time array. Return an index into
// the array from which. All the elements before the returned
// index are smaller than all the elements after the returned
// index.
//
// This is the partition function of qsort.
//
int PartitionTime(ULONGLONG* t, int p, int r)
{
    ULONGLONG x = t[p];
    int i = p - 1;
    int j = r + 1;

    while (1)
    {
        while (t[--j] > x);
        while (t[++i] < x);
        if (i < j)
        {
            ULONGLONG ti = t[i];
            t[i] = t[j];
            t[j] = ti;
        }
        else
        {
            return j;
        }
    }
}

//
// Find the median time of the time array.
//
ULONGLONG FindMedianTime(ULONGLONG * t, int p, int r, int i)
{
    if (p == r)
    {
        return t[p];
    }

    int q = PartitionTime(t, p, r);
    int k = q - p + 1;

    if (i <= k)
    {
        return FindMedianTime(t, p, q, i);
    }
    else
    {
        return FindMedianTime(t, q + 1, r, i - k);
    }
}

//
// Mapping from a QM GUID to QM crypto info.
//
typedef CCache
   <GUID, const GUID&, PQMCRYPTINFO, PQMCRYPTINFO> GUID_TO_CRYPTINFO_MAP;

//
// The cached symmetric keys for destination QMs.
//
static GUID_TO_CRYPTINFO_MAP g_MapSendQMGuidToBaseCryptInfo;
static GUID_TO_CRYPTINFO_MAP g_MapSendQMGuidToEnhCryptInfo;

#define SET_SEND_CRYPTINFO_MAP(eprovider, pMap)     \
    if (eProvider == eEnhancedProvider)             \
    {                                               \
        pMap = &g_MapSendQMGuidToEnhCryptInfo;      \
    }                                               \
    else                                            \
    {                                               \
        pMap = &g_MapSendQMGuidToBaseCryptInfo;     \
    }

//
// Get a pointer to the structure that holds the cached information for the
// destination QM.
//
STATIC
PQMCRYPTINFO
GetSendQMCryptInfo( const GUID *pguidQM,
                    enum enumProvider eProvider )
{
    GUID_TO_CRYPTINFO_MAP  *pMap ;
    SET_SEND_CRYPTINFO_MAP(eProvider, pMap) ;

    PQMCRYPTINFO pQMCryptInfo;

    if (!pMap->Lookup(*pguidQM, pQMCryptInfo))
    {
        //
        // No cached data so far, allocate the structure and store it in
        // the map.
        //
        pQMCryptInfo = new QMCRYPTINFO;
        pQMCryptInfo->eProvider = eProvider ;

        HRESULT hr = MQSec_AcquireCryptoProvider( eProvider,
                                             &(pQMCryptInfo->hProv) ) ;
        pQMCryptInfo->hr = hr ;

        pMap->SetAt(*pguidQM, pQMCryptInfo);
    }

    return(pQMCryptInfo);
}

//
// Get the public ker blob of the destination QM. Get it either from the
// cached data, or from the DS.
//
STATIC
HRESULT
GetSendQMKeyxPbKey(
    const GUID *pguidQM,
    PQMCRYPTINFO pQMCryptInfo,
    BYTE **ppbPbKeyBlob =NULL,
    DWORD *pdwPbKeyBlobLen =NULL)
{
    HRESULT rc;

    if (!(pQMCryptInfo->dwFlags & QMCRYPTINFO_KEYXPBK_EXIST))
    {
        // No cached data.
        P<BYTE> abPbKey = NULL ;
        DWORD dwReqLen = 0 ;

        rc = MQSec_GetPubKeysFromDS( pguidQM,
                                     NULL,
                                     pQMCryptInfo->eProvider,
                                     PROPID_QM_ENCRYPT_PKS,
                                    &abPbKey,
                                    &dwReqLen ) ;
        if (FAILED(rc))
        {
            //
            // BUGBUG, handle nt5 client with nt4 server.
            //
            // Faield to get the key exchange public key from the DS.
            return LogHR(rc, s_FN, 10);
        }
        ASSERT(abPbKey) ;

        // Store the key exchange public key in the cached data.
        pQMCryptInfo->dwFlags |= QMCRYPTINFO_KEYXPBK_EXIST;

        if (dwReqLen)
        {
            pQMCryptInfo->pbPbKeyxKey = abPbKey.detach();
        }
        pQMCryptInfo->dwPbKeyxKeyLen = dwReqLen;
    }

    if (!pQMCryptInfo->dwPbKeyxKeyLen)
    {
        return LogHR(MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION, s_FN, 20);
    }

    if (ppbPbKeyBlob)
    {
        *ppbPbKeyBlob = pQMCryptInfo->pbPbKeyxKey;
    }

    if (pdwPbKeyBlobLen)
    {
        *pdwPbKeyBlobLen = pQMCryptInfo->dwPbKeyxKeyLen;
    }

    return(MQ_OK);
}

//
// Get the key exchange public key blob of the destination QM.
//
HRESULT
GetSendQMKeyxPbKey( IN const GUID *pguidQM,
                    enum enumProvider eProvider )
{
    GUID_TO_CRYPTINFO_MAP  *pMap ;
    SET_SEND_CRYPTINFO_MAP(eProvider, pMap) ;

    CS lock(pMap->m_cs);

    R<QMCRYPTINFO> pQMCryptInfo = GetSendQMCryptInfo(pguidQM, eProvider);
    ASSERT(pQMCryptInfo->eProvider == eProvider) ;

    if (pQMCryptInfo->hProv == NULL)
    {
        return pQMCryptInfo->hr ;
    }

    return LogHR(GetSendQMKeyxPbKey(pguidQM, pQMCryptInfo.get()), s_FN, 30);
}

//
// Store a handle to the key exchange public key of the destination QM in
// the cache.
//
STATIC
HRESULT
GetSendQMKeyxPbKeyHandle(
    const GUID *pguidQM,
    PQMCRYPTINFO pQMCryptInfo)
{
    HRESULT rc;

    if (!(pQMCryptInfo->dwFlags & QMCRYPTINFO_HKEYXPBK_EXIST))
    {
        // Get the key blob into the cache.
        rc = GetSendQMKeyxPbKey(pguidQM, pQMCryptInfo);

        if (FAILED(rc))
        {
            return LogHR(rc, s_FN, 40);
        }

        // Get the handle.
        ASSERT(pQMCryptInfo->hProv) ;
        if (!CryptImportKey(
                pQMCryptInfo->hProv,
                pQMCryptInfo->pbPbKeyxKey,
                pQMCryptInfo->dwPbKeyxKeyLen,
                NULL,
                0,
                &pQMCryptInfo->hKeyxPbKey))
        {
            LogNTStatus(GetLastError(), s_FN, 50);
            return MQ_ERROR_CORRUPTED_SECURITY_DATA;
        }

        pQMCryptInfo->dwFlags |= QMCRYPTINFO_HKEYXPBK_EXIST;
    }

    return (MQ_OK);
}

//+--------------------------------------
//
//
// HRESULT _ExportSymmKey()
//
//+--------------------------------------

STATIC HRESULT _ExportSymmKey( IN  HCRYPTKEY   hSymmKey,
                               IN  HCRYPTKEY   hPubKey,
                               OUT BYTE      **ppKeyBlob,
                               OUT DWORD      *pdwBlobSize )
{
    DWORD dwSize = 0 ;

    BOOL bRet = CryptExportKey( hSymmKey,
                                hPubKey,
                                SIMPLEBLOB,
                                0,
                                NULL,
                               &dwSize ) ;
    ASSERT(bRet && (dwSize > 0)) ;
    if (!bRet || (dwSize == 0))
    {
        LogNTStatus(GetLastError(), s_FN, 59);
        return LogHR(MQ_ERROR_CANNOT_EXPORT_KEY, s_FN, 60) ;
    }

    *ppKeyBlob = new BYTE[ dwSize ] ;
    if ( !CryptExportKey( hSymmKey,
                          hPubKey,
                          SIMPLEBLOB,
                          0,
                         *ppKeyBlob,
                         &dwSize ))
    {
        LogNTStatus(GetLastError(), s_FN, 70);
        return LogHR(MQ_ERROR_CANNOT_EXPORT_KEY, s_FN, 61) ;
    }

    *pdwBlobSize = dwSize ;
    return MQ_OK ;
}

//
// Get an RC4 symmetric key for the destination QM.
//
HRESULT
GetSendQMSymmKeyRC4(
    IN  const GUID *pguidQM,
    IN  enum enumProvider eProvider,
    HCRYPTKEY      *phSymmKey,
    BYTE          **ppEncSymmKey,
    DWORD          *pdwEncSymmKeyLen,
    CCacheValue   **ppQMCryptInfo )
{
    HRESULT rc;
    GUID_TO_CRYPTINFO_MAP  *pMap ;
    SET_SEND_CRYPTINFO_MAP(eProvider, pMap) ;

    CS lock(pMap->m_cs);

    PQMCRYPTINFO pQMCryptInfo = GetSendQMCryptInfo(pguidQM, eProvider);
    ASSERT(pQMCryptInfo->eProvider == eProvider) ;

    *ppQMCryptInfo = pQMCryptInfo;

    if (!(pQMCryptInfo->dwFlags & QMCRYPTINFO_RC4_EXIST))
    {
        // Get the handle to the key exchange key into the cache.
        rc = GetSendQMKeyxPbKeyHandle(pguidQM, pQMCryptInfo);
        if (FAILED(rc))
        {
            return LogHR(rc, s_FN, 80);
        }

        // Generate an RC4 symmetric key,
        ASSERT(pQMCryptInfo->hProv) ;
        if (!CryptGenKey( pQMCryptInfo->hProv,
                          CALG_RC4,
                          CRYPT_EXPORTABLE,
                          &pQMCryptInfo->hRC4Key))
        {
            LogNTStatus(GetLastError(), s_FN, 90);
            return MQ_ERROR_INSUFFICIENT_RESOURCES;
        }

        P<BYTE> abSymmKey ;
        DWORD dwSymmKeyLen = 0 ;

        rc = _ExportSymmKey( pQMCryptInfo->hRC4Key,
                             pQMCryptInfo->hKeyxPbKey,
                            &abSymmKey,
                            &dwSymmKeyLen ) ;
        if (FAILED(rc))
        {
            CryptDestroyKey(pQMCryptInfo->hRC4Key);
            pQMCryptInfo->hRC4Key = NULL;

            LogHR(rc, s_FN, 100);
            return MQ_ERROR_CORRUPTED_SECURITY_DATA;
        }

        // Store the key in the cache.
        pQMCryptInfo->dwRC4EncSymmKeyLen = dwSymmKeyLen;
        pQMCryptInfo->pbRC4EncSymmKey = abSymmKey.detach();

        pQMCryptInfo->dwFlags |= QMCRYPTINFO_RC4_EXIST;
    }

    if (phSymmKey)
    {
        *phSymmKey = pQMCryptInfo->hRC4Key;
    }

    if (ppEncSymmKey)
    {
        *ppEncSymmKey = pQMCryptInfo->pbRC4EncSymmKey;
    }

    if (pdwEncSymmKeyLen)
    {
        *pdwEncSymmKeyLen = pQMCryptInfo->dwRC4EncSymmKeyLen;
    }

    return(MQ_OK);
}

//
// Get an RC2 symmetric key for the destination QM.
//
HRESULT
GetSendQMSymmKeyRC2(
    IN  const GUID *pguidQM,
    IN  enum enumProvider eProvider,
    HCRYPTKEY *phSymmKey,
    BYTE **ppEncSymmKey,
    DWORD *pdwEncSymmKeyLen,
    CCacheValue **ppQMCryptInfo)
{
    HRESULT rc;
    GUID_TO_CRYPTINFO_MAP  *pMap ;
    SET_SEND_CRYPTINFO_MAP(eProvider, pMap) ;

    CS lock(pMap->m_cs);

    PQMCRYPTINFO pQMCryptInfo = GetSendQMCryptInfo(pguidQM, eProvider);
    ASSERT(pQMCryptInfo->eProvider == eProvider) ;

    *ppQMCryptInfo = pQMCryptInfo;

    if (!(pQMCryptInfo->dwFlags & QMCRYPTINFO_RC2_EXIST))
    {
        // Get the handle to the key exchange key into the cache.
        rc = GetSendQMKeyxPbKeyHandle(pguidQM, pQMCryptInfo);
        if (FAILED(rc))
        {
            return LogHR(rc, s_FN, 120);
        }

        // Generate an RC2 symmetric key,
        ASSERT(pQMCryptInfo->hProv) ;
        if (!CryptGenKey( pQMCryptInfo->hProv,
                          CALG_RC2,
                          CRYPT_EXPORTABLE,
                          &pQMCryptInfo->hRC2Key))
        {
            LogNTStatus(GetLastError(), s_FN, 130);
            return MQ_ERROR_INSUFFICIENT_RESOURCES;
        }

        if ((eProvider == eEnhancedProvider) && g_fSendEnhRC2WithLen40)
        {
            //
            // Windows bug 633909.
            // For backward compatibility, send RC2 with effective key
            // length of 40 bits.
            //
            const DWORD x_dwEffectiveLength = 40 ;

            if (!CryptSetKeyParam( pQMCryptInfo->hRC2Key,
                                   KP_EFFECTIVE_KEYLEN,
                                   (BYTE*) &x_dwEffectiveLength,
                                   0 ))
            {
        	    DWORD gle = GetLastError();
			    TrERROR(SECURITY, "Failed to set enhanced RC2 key len to 40 bits, gle = %!winerr!", gle);
                return MQ_ERROR_INSUFFICIENT_RESOURCES;
            }
        }

        P<BYTE> abSymmKey;
        DWORD dwSymmKeyLen = 0;

        rc = _ExportSymmKey( pQMCryptInfo->hRC2Key,
                             pQMCryptInfo->hKeyxPbKey,
                            &abSymmKey,
                            &dwSymmKeyLen ) ;
        if (FAILED(rc))
        {
            CryptDestroyKey(pQMCryptInfo->hRC2Key);
            pQMCryptInfo->hRC2Key = NULL;

            LogHR(rc, s_FN, 140);
            return MQ_ERROR_CORRUPTED_SECURITY_DATA;
        }

        // Store the key in the cache.
        pQMCryptInfo->dwRC2EncSymmKeyLen = dwSymmKeyLen;
        pQMCryptInfo->pbRC2EncSymmKey = abSymmKey.detach();

        pQMCryptInfo->dwFlags |= QMCRYPTINFO_RC2_EXIST;
    }

    if (phSymmKey)
    {
        *phSymmKey = pQMCryptInfo->hRC2Key;
    }

    if (ppEncSymmKey)
    {
        *ppEncSymmKey = pQMCryptInfo->pbRC2EncSymmKey;
    }

    if (pdwEncSymmKeyLen)
    {
        *pdwEncSymmKeyLen = pQMCryptInfo->dwRC2EncSymmKeyLen;
    }

    return(MQ_OK);
}

//
// The cached symmetric keys for source QMs.
//
static GUID_TO_CRYPTINFO_MAP g_MapRecQMGuidToBaseCryptInfo;
static GUID_TO_CRYPTINFO_MAP g_MapRecQMGuidToEnhCryptInfo;

#define SET_REC_CRYPTINFO_MAP(eProvider, pMap)      \
    if (eProvider == eEnhancedProvider)             \
    {                                               \
        pMap = &g_MapRecQMGuidToEnhCryptInfo;       \
    }                                               \
    else                                            \
    {                                               \
        pMap = &g_MapRecQMGuidToBaseCryptInfo;      \
    }

//
// Get a pointer to the structure that holds the cached information for the
// source QM.
//
STATIC
PQMCRYPTINFO
GetRecQMCryptInfo( IN  const GUID *pguidQM,
                   IN  enum enumProvider eProvider )
{
    GUID_TO_CRYPTINFO_MAP  *pMap ;
    SET_REC_CRYPTINFO_MAP(eProvider, pMap) ;

    PQMCRYPTINFO pQMCryptInfo;

    if (!pMap->Lookup(*pguidQM, pQMCryptInfo))
    {
        //
        // No cached data so far, allocate the structure and store it in
        // the map.
        //
        pQMCryptInfo = new QMCRYPTINFO;
        pQMCryptInfo->eProvider = eProvider ;

        HRESULT hr = MQSec_AcquireCryptoProvider( eProvider,
                                                &(pQMCryptInfo->hProv) ) ;
        ASSERT(SUCCEEDED(hr)) ;
        LogHR(hr, s_FN, 181);

        pMap->SetAt(*pguidQM, pQMCryptInfo);
    }

    return(pQMCryptInfo);
}

//
// Get an RC2 symmetric key for decyrpting a message that was received from
// a specific QM.
//
HRESULT
GetRecQMSymmKeyRC2(
    IN  const GUID *pguidQM,
    IN  enum enumProvider eProvider,
    HCRYPTKEY *phSymmKey,
    const BYTE *pbEncSymmKey,
    DWORD dwEncSymmKeyLen,
    CCacheValue **ppQMCryptInfo,
    OUT BOOL  *pfNewKey)
{
    GUID_TO_CRYPTINFO_MAP  *pMap ;
    SET_REC_CRYPTINFO_MAP(eProvider, pMap) ;

    CS lock(pMap->m_cs);

    PQMCRYPTINFO pQMCryptInfo = GetRecQMCryptInfo(pguidQM, eProvider);

    *ppQMCryptInfo = pQMCryptInfo;

    if (!(pQMCryptInfo->dwFlags & QMCRYPTINFO_RC2_EXIST) ||
        (pQMCryptInfo->dwRC2EncSymmKeyLen != dwEncSymmKeyLen) ||
        (memcmp(
            pQMCryptInfo->pbRC2EncSymmKey,
            pbEncSymmKey,
            dwEncSymmKeyLen) != 0))
    {
        // We either do not have a cached symmetric key, or the symmetric key
        // was modified.

        if (pQMCryptInfo->dwFlags & QMCRYPTINFO_RC2_EXIST)
        {
            // The symmetric key was modified. Free the previous one.
            ASSERT(pQMCryptInfo->hRC2Key);
            ASSERT(pQMCryptInfo->dwRC2EncSymmKeyLen);

            CryptDestroyKey(pQMCryptInfo->hRC2Key);
            pQMCryptInfo->hRC2Key = NULL;
            delete[] pQMCryptInfo->pbRC2EncSymmKey.detach();
            pQMCryptInfo->dwFlags &= ~QMCRYPTINFO_RC2_EXIST;
        }

        // Import the new key.
        ASSERT(pQMCryptInfo->hProv) ;
        if (!CryptImportKey(
                pQMCryptInfo->hProv,
                pbEncSymmKey,
                dwEncSymmKeyLen,
                NULL,
                0,
                &pQMCryptInfo->hRC2Key))
        {
            LogNTStatus(GetLastError(), s_FN, 150);
            return MQ_ERROR_CORRUPTED_SECURITY_DATA;
        }

        // Store the new key in the cache.
        pQMCryptInfo->pbRC2EncSymmKey = new BYTE[dwEncSymmKeyLen];
        pQMCryptInfo->dwRC2EncSymmKeyLen = dwEncSymmKeyLen;
        memcpy(pQMCryptInfo->pbRC2EncSymmKey, pbEncSymmKey, dwEncSymmKeyLen);

        pQMCryptInfo->dwFlags |= QMCRYPTINFO_RC2_EXIST;
        *pfNewKey = TRUE ;
    }

    *phSymmKey = pQMCryptInfo->hRC2Key;

    return(MQ_OK);
}

//
// Get an RC2 symmetric key for decyrpting a message that was received from
// a specific QM.
//
HRESULT
GetRecQMSymmKeyRC4(
    IN  const GUID *pguidQM,
    IN  enum enumProvider eProvider,
    HCRYPTKEY  *phSymmKey,
    const BYTE *pbEncSymmKey,
    DWORD dwEncSymmKeyLen,
    CCacheValue **ppQMCryptInfo)
{
    GUID_TO_CRYPTINFO_MAP  *pMap ;
    SET_REC_CRYPTINFO_MAP(eProvider, pMap) ;

    CS lock(pMap->m_cs);

    PQMCRYPTINFO pQMCryptInfo = GetRecQMCryptInfo(pguidQM, eProvider);

    *ppQMCryptInfo = pQMCryptInfo;

    if (!(pQMCryptInfo->dwFlags & QMCRYPTINFO_RC4_EXIST) ||
        (pQMCryptInfo->dwRC4EncSymmKeyLen != dwEncSymmKeyLen) ||
        (memcmp(
            pQMCryptInfo->pbRC4EncSymmKey,
            pbEncSymmKey,
            dwEncSymmKeyLen) != 0))
    {
        // We either do not have a cached symmetric key, or the symmetric key
        // was modified.

        if (pQMCryptInfo->dwFlags & QMCRYPTINFO_RC4_EXIST)
        {
            // The symmetric key was modified. Free the previous one.
            ASSERT(pQMCryptInfo->hRC4Key);
            ASSERT(pQMCryptInfo->dwRC4EncSymmKeyLen);

            CryptDestroyKey(pQMCryptInfo->hRC4Key);
            pQMCryptInfo->hRC4Key = NULL;
            delete[] pQMCryptInfo->pbRC4EncSymmKey.detach();
            pQMCryptInfo->dwFlags &= ~QMCRYPTINFO_RC4_EXIST;
        }

        // Import the new key.
        ASSERT(pQMCryptInfo->hProv) ;
        if (!CryptImportKey(
                pQMCryptInfo->hProv,
                pbEncSymmKey,
                dwEncSymmKeyLen,
                NULL,
                0,
                &pQMCryptInfo->hRC4Key))
        {
            LogNTStatus(GetLastError(), s_FN, 160);
            return MQ_ERROR_CORRUPTED_SECURITY_DATA;
        }

        // Store the new key in the cache.
        pQMCryptInfo->pbRC4EncSymmKey = new BYTE[dwEncSymmKeyLen];
        pQMCryptInfo->dwRC4EncSymmKeyLen = dwEncSymmKeyLen;
        memcpy(pQMCryptInfo->pbRC4EncSymmKey, pbEncSymmKey, dwEncSymmKeyLen);

        pQMCryptInfo->dwFlags |= QMCRYPTINFO_RC4_EXIST;
    }

    *phSymmKey = pQMCryptInfo->hRC4Key;

    return(MQ_OK);
}

void
InitSymmKeys(
    const CTimeDuration& CacheBaseLifetime,
    const CTimeDuration& CacheEnhLifetime,
    DWORD dwSendCacheSize,
    DWORD dwReceiveCacheSize
    )
{
    g_MapSendQMGuidToBaseCryptInfo.m_CacheLifetime = CacheBaseLifetime;
    g_MapSendQMGuidToBaseCryptInfo.InitHashTable(dwSendCacheSize);

    g_MapSendQMGuidToEnhCryptInfo.m_CacheLifetime = CacheEnhLifetime;
    g_MapSendQMGuidToEnhCryptInfo.InitHashTable(dwSendCacheSize);

    g_MapRecQMGuidToEnhCryptInfo.InitHashTable(dwReceiveCacheSize);
    g_MapRecQMGuidToBaseCryptInfo.InitHashTable(dwReceiveCacheSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\verifypacket.cpp ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    VerifyPacket.cpp

Abstract:

    Native Packet Verify Routines

Author:

    Tomer Weisberg (t-tomerw) 21-Jan-02

--*/
#include "stdh.h"
#include "ph.h"
#include "fn.h"
#include "phintr.h"
#include "qmpkt.h"

#include "VerifyPacket.tmh"


void ReportAndThrow(LPCSTR ErrorString)
{
	TrERROR(GENERAL, "Native Packet: %s", ErrorString);
	ASSERT_BENIGN(0);
	throw exception();
}


/*======================================================================

 Function:     CBaseHeader::SectionIsValid

 Description:  Checks the header signature

 =======================================================================*/


void CBaseHeader::SectionIsValid(DWORD MessageSizeLimit) const
{
	if (GetPacketSize() > MessageSizeLimit)
	{
		TrERROR(NETWORKING, "size mismach");
		ASSERT_BENIGN(0);
		throw exception();
	}
	
    PCHAR pSection = GetNextSection();
    if (pSection > GetPacketEnd())
    {
		TrERROR(NETWORKING, "Next section is behind packet end");
		ASSERT_BENIGN(0);
		throw exception();
    }

    if (!SignatureIsValid())
    {
		TrERROR(NETWORKING, "Signature is not valid");
		ASSERT_BENIGN(0);
		throw exception();
    }

    if (!VersionIsValid())
    {
		TrERROR(NETWORKING, "Base section is not valid: Version is not valid");
		ASSERT_BENIGN(0);
		throw exception();
    }
}


/*======================================================================

 Function:     CUserHeader::SectionIsValid

 Description:  Checks if section is valid

 =======================================================================*/

void CUserHeader::SectionIsValid(PCHAR PacketEnd) const
{
	//
	// this function is called only from native protocol
	// which can not be multicast
	//
    if (m_bfPgm)
    {
		TrERROR(NETWORKING, "can not be multicast");
		ASSERT_BENIGN(0);
		throw exception();
    }

	if ((m_bfDQT != qtGUID) && (m_bfDQT != qtPrivate) && (m_bfDQT != qtDirect) && (m_bfDQT != qtDestQM))
	{
		TrERROR(NETWORKING, "Destination queue type (%d) is not valid", m_bfDQT);
		ASSERT_BENIGN(0);
		throw exception();
	}

	if ((qtAdminQ == m_bfAQT) || (qtAdminQM == m_bfAQT))
	{
		TrERROR(NETWORKING, "Admin queue type (%d) is not valid", m_bfAQT);
		ASSERT_BENIGN(0);
		throw exception();
	}

	if ((qtNone == m_bfAQT) && (qtAdminQM == m_bfRQT))
	{
		TrERROR(NETWORKING, "Response queue type is not valid");
		ASSERT_BENIGN(0);
		throw exception();
	}

	if (!m_bfProperties)
	{
		TrERROR(NETWORKING, "Properties section flag must be set");
		ASSERT_BENIGN(0);
		throw exception();
	}

	//
	// this flag can be only 0 or 1 (but it is 2 bits length)
	//
	if (m_bfDelivery >= 2)
	{
		TrERROR(NETWORKING, "Delivery type (%d) not supported", m_bfDelivery);
		ASSERT_BENIGN(0);
		throw exception();
	}

    PCHAR pSection;
   	pSection = GetNextSection((PUCHAR)PacketEnd);
    if (pSection > PacketEnd)
  	{
		TrERROR(NETWORKING, "Next section is behind packet end");
		ASSERT_BENIGN(0);
		throw exception();
    }

	QUEUE_FORMAT qf;
	if (!GetDestinationQueue(&qf))
	{
		TrERROR(NETWORKING, "Destination queue is not valid");
		ASSERT_BENIGN(0);
		throw exception();
	}

    if(!FnIsValidQueueFormat(&qf))
    {
        TrERROR(NETWORKING, "Destination queue format is not valid");
        ASSERT_BENIGN(0);
        throw exception();
    }

}


/*======================================================================

 Function:     CXactHeader::SectionIsValid

 Description:  Checks if section is valid

 =======================================================================*/

void CXactHeader::SectionIsValid(PCHAR PacketEnd) const
{
    PCHAR pSection = GetNextSection();
    if (pSection > PacketEnd)
    {
		TrERROR(NETWORKING, "Next section is behind packet end");
		ASSERT_BENIGN(0);
		throw exception();
    }

	if (GetPrevSeqN() >= GetSeqN())
	{
		TrERROR(NETWORKING, "PrevSeqN >= GetSeqN");
		ASSERT_BENIGN(0);
		throw exception();
	}
}


/*======================================================================

 Function:     CSecurityHeader::SectionIsValid

 Description:  Checks if section is valid

 =======================================================================*/

void CSecurityHeader::SectionIsValid(PCHAR PacketEnd) const
{
	if((0 == m_wSenderIDSize) && (0 == m_wEncryptedKeySize) && (0 == m_wSignatureSize) &&
       (0 == m_ulSenderCertSize) && (0 == m_ulProvInfoSize))
	{
		TrERROR(NETWORKING, "No data");
		ASSERT_BENIGN(0);
		throw exception();
	}

    PCHAR pSection = GetNextSection();
    if (pSection > PacketEnd)
    {
		TrERROR(NETWORKING, "Next section is behind packet end");
		ASSERT_BENIGN(0);
		throw exception();
    }

	if ((m_wSignatureSize != 0) && (!m_bfDefProv) && (m_ulProvInfoSize < 6))
	{
		TrERROR(NETWORKING, "Default provider is not set but provider size is smaller than 6");
		ASSERT_BENIGN(0);
		throw exception();
	}

    const UCHAR *pProvInfo = const_cast<UCHAR*> (GetSectionExPtr()) ;
    if (pProvInfo)
    {
    	pGetSubSectionEx( e_SecInfo_Test, pProvInfo, const_cast<const UCHAR *>((UCHAR*)PacketEnd));
    }

    if ((m_bfSenderIDType == MQMSG_SENDERID_TYPE_QM) && (m_wSenderIDSize != sizeof(GUID)))
    {
		TrERROR(NETWORKING, "MQMSG_SENDERID_TYPE_QM: SenderID size (%d) is not GUID size", m_wSenderIDSize);
		ASSERT_BENIGN(0);
		throw exception();
    }

    if ((m_bfSenderIDType == MQMSG_SENDERID_TYPE_SID) && (m_wSenderIDSize == 0))
    {
		TrERROR(NETWORKING, "MQMSG_SENDERID_TYPE_SID: SenderID size is zero");
		ASSERT_BENIGN(0);
		throw exception();
    }

	USHORT Size;
	if ((m_bfSenderIDType == MQMSG_SENDERID_TYPE_SID) && (!IsValidSid((PSID)GetSenderID(&Size))))
	{
		TrERROR(NETWORKING, "SenderID SID is not valid");
		ASSERT_BENIGN(0);
		throw exception();
	}
}


/*======================================================================

 Function:     CPropertyHeader::SectionIsValid

 Description:  Checks if section is valid

 =======================================================================*/

void CPropertyHeader::SectionIsValid(PCHAR PacketEnd) const
{
    if (GetTitleLength() > MQ_MAX_MSG_LABEL_LEN)
    {
		TrERROR(NETWORKING, "label length too long");
		ASSERT_BENIGN(0);
		throw exception();
    }

	if (m_ulBodySize > m_ulAllocBodySize)
	{
		TrERROR(NETWORKING, "body size is bigger than Alloc body size");
		ASSERT_BENIGN(0);
		throw exception();
	}

    PCHAR pSection = GetNextSection();
    if (pSection > PacketEnd)
    {
		TrERROR(NETWORKING, "Next section is behind packet end");
		ASSERT_BENIGN(0);
		throw exception();
    }
}


/*======================================================================

 Function:     CDebugSection::SectionIsValid

 Description:  Checks if section is valid

 =======================================================================*/

void CDebugSection::SectionIsValid(PCHAR PacketEnd) const
{
	if ((qtNone != m_bfRQT) && (qtGUID != m_bfRQT))
	{
		TrERROR(NETWORKING, "Report Queue type is not valid");
		ASSERT_BENIGN(0);
		throw exception();
	}

    PCHAR pSection = GetNextSection();
    if (pSection > PacketEnd)
    {
		TrERROR(NETWORKING, "Next section is behind packet end");
		ASSERT_BENIGN(0);
		throw exception();
    }
}


/*======================================================================

 Function:     CBaseMqfHeader::SectionIsValid

 Description:  Checks if section is valid

 =======================================================================*/

void CBaseMqfHeader::SectionIsValid(PCHAR PacketEnd)
{
	if (!ISALIGN4_ULONG(m_cbSize))
	{
		TrERROR(NETWORKING, "Size is not aligned");
		ASSERT_BENIGN(0);
		throw exception();
	}
	
    PCHAR pSection = GetNextSection();
    if (pSection > PacketEnd)
    {
		TrERROR(NETWORKING, "Next section is behind packet end");
		ASSERT_BENIGN(0);
		throw exception();
    }

    UCHAR * pMqfBuffer = GetSerializationBuffer();
    if ((m_nMqf!=0) && (pMqfBuffer == (UCHAR *)pSection))
    {
		TrERROR(NETWORKING, "No MQF buffer");
		ASSERT_BENIGN(0);
		throw exception();
    }

    QUEUE_FORMAT qf;
    for (ULONG i=0; i<m_nMqf; i++)
    {
    	if (pSection < (PCHAR)pMqfBuffer)
    	{
			TrERROR(NETWORKING, "MQF buffer is not valid");
			ASSERT_BENIGN(0);
			throw exception();
    	}
    	pMqfBuffer = GetQueueFormat(pMqfBuffer, &qf, (UCHAR *)pSection);
    }
}


/*======================================================================

 Function:     CMqfSignatureHeader::SectionIsValid

 Description:  Checks if section is valid

 =======================================================================*/

void CMqfSignatureHeader::SectionIsValid(PCHAR PacketEnd) const
{
    PCHAR pSection = GetNextSection();
    if (pSection > PacketEnd)
    {
		TrERROR(NETWORKING, "Next section is behind packet end");
		ASSERT_BENIGN(0);
		throw exception();
    }
}


/*======================================================================

 Function:     CInternalSection::SectionIsValid

 Description:  Checks if section is valid

 =======================================================================*/

void CInternalSection::SectionIsValid(PCHAR PacketEnd) const
{
    PCHAR pSection = GetNextSection();
    if (pSection > PacketEnd)
    {
		TrERROR(NETWORKING, "Next section is behind packet end");
		ASSERT_BENIGN(0);
		throw exception();
    }

	if ((m_bfType != INTERNAL_SESSION_PACKET) &&
		(m_bfType != INTERNAL_ESTABLISH_CONNECTION_PACKET) &&
		(m_bfType != INTERNAL_CONNECTION_PARAMETER_PACKET))
	{
		TrERROR(NETWORKING, "Internal packet type is not valid");
		ASSERT_BENIGN(0);
		throw exception();
	}
}


/*======================================================================

 Function:     CQmPacket::PacketIsValid

 Description:  Checks cross section information

 =======================================================================*/

void CQmPacket::PacketIsValid() const
{
	if (m_pBasicHeader->GetType() == FALCON_USER_PACKET)
	{
		if ((m_pcUserMsg->IsOrdered()) && (m_pBasicHeader->GetPriority() != 0))
		{
			TrERROR(NETWORKING, "xact packet has to have priority = 0");
			ASSERT_BENIGN(0);
			throw exception();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\verifysignmqf.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    VerifySignMqf.cpp

Abstract:
    functions to verify mqf signature 

Author:
    Ilan Herbst (ilanh) 29-Oct-2000

Environment:
    Platform-independent,

--*/

#include "stdh.h"
#include "session.h"
#include "qmsecutl.h"
#include <mqsec.h>
#include <mqformat.h>
#include <mqf2format.h>
#include "tr.h"
#include "cry.h"
#include "mqexception.h"

#include "VerifySignMqf.tmh"

const TraceIdEntry QmSignMqf = L"QM VERIFY SIGNATURE";

static WCHAR *s_FN=L"VerifySignMqf";


static
void 
MsgBodyHash(
	IN HCRYPTHASH hHash, 	
	IN const CQmPacket* PktPtrs
	)
/*++
Routine Description:
	Message Body hash.

Arguments:
	hHash - hash object
	PktPtrs - pointer to the packet

Returned Value:
	none.

--*/
{
	//
	// Body
	//
	ULONG dwBodySize;
	const UCHAR* pBody = PktPtrs->GetPacketBody(&dwBodySize);
	if(pBody != NULL)
	{
		CryHashData(
			pBody, 
			dwBodySize,
			hHash
			);

		TrTRACE(QmSignMqf, "Hash, BodySize = %d", dwBodySize);
	}
}


static
void 
CorrelationIdHash(
	IN HCRYPTHASH hHash, 	
	IN const CQmPacket* PktPtrs
	)
/*++
Routine Description:
	CorrelationId hash.

Arguments:
	hHash - hash object
	PktPtrs - pointer to the packet

Returned Value:
	none.

--*/
{
	//
	// CorrelationID
	//
	CryHashData(
		reinterpret_cast<const BYTE*>(PktPtrs->GetCorrelation()), 
		PROPID_M_CORRELATIONID_SIZE,
		hHash
		);

	TrTRACE(QmSignMqf, "Hash, CorrelationSize = %d", PROPID_M_CORRELATIONID_SIZE);
}


static
void 
ApplicationTagHash(
	IN HCRYPTHASH hHash, 	
	IN const CQmPacket* PktPtrs
	)
/*++
Routine Description:
	Application Tag hash.

Arguments:
	hHash - hash object
	PktPtrs - pointer to the packet

Returned Value:
	none.

--*/
{
	//
	// Application tag
	//
	ULONG ApplicationTag = PktPtrs->GetApplicationTag();

	CryHashData(
		reinterpret_cast<const BYTE*>(&ApplicationTag), 
		sizeof(DWORD),
		hHash
		);

	TrTRACE(QmSignMqf, "Hash, ApplicationTag = %d", ApplicationTag);
}


static
void 
TitleHash(
	IN HCRYPTHASH hHash, 	
	IN const CQmPacket* PktPtrs
	)
/*++
Routine Description:
	Title hash.

Arguments:
	hHash - hash object
	PktPtrs - pointer to the packet

Returned Value:
	none.

--*/
{
	//
	// Title
	//
	if(PktPtrs->GetTitlePtr() != NULL)
	{
		CryHashData(
			reinterpret_cast<const BYTE*>(PktPtrs->GetTitlePtr()), 
			PktPtrs->GetTitleLength() * sizeof(WCHAR),
			hHash
			);

		TrTRACE(QmSignMqf, "Hash, TitleSize = %d", PktPtrs->GetTitleLength());
		TrTRACE(QmSignMqf, "Hash, Title = %ls", PktPtrs->GetTitlePtr());
	}
}


static
void 
MqfHash(
	IN HCRYPTHASH			hHash, 	
    IN const QUEUE_FORMAT*	pqf,
	IN ULONG				nMqf
	)
/*++
Routine Description:
	Mqf hash.

Arguments:
	hHash - hash object.
	pqf - pointer to QUEUE_FORMAT array.
	nMqf - pqf array size.

Returned Value:
	none.

--*/
{
	ULONG FormatNameLength = 0;
	AP<WCHAR> pFormatName = MQpMqfToFormatName(
								pqf, 
								nMqf, 
								&FormatNameLength 
								);

	ASSERT(("Failed to get Mqf format name", pFormatName != NULL)); 

	CryHashData(
		reinterpret_cast<const BYTE*>(pFormatName.get()), 
		FormatNameLength * sizeof(WCHAR),
		hHash
		);

	TrTRACE(QmSignMqf, "Hash, nMqf = %d", nMqf);
	TrTRACE(QmSignMqf, "Hash, FormatNameLen(mqf) = %d", FormatNameLength);
	TrTRACE(QmSignMqf, "Hash, FormatName(mqf) = %ls", pFormatName.get());
}


static
void 
ResponseMqfHash(
	IN HCRYPTHASH hHash, 	
	IN const CQmPacket* PktPtrs
	)
/*++
Routine Description:
	ResponseMqf hash.

Arguments:
	hHash - hash object
	PktPtrs - pointer to the packet

Returned Value:
	none.

--*/
{
	//
    // Get Response FormatName. 
    //
    ULONG nResponseMqf = PktPtrs->GetNumOfResponseMqfElements();

	QUEUE_FORMAT *   pResponseMqf = NULL;
	AP<QUEUE_FORMAT> pResponseMqfAutoCleanup;
    if(nResponseMqf > 0)
	{
		pResponseMqf = pResponseMqfAutoCleanup = new QUEUE_FORMAT[nResponseMqf];
		PktPtrs->GetResponseMqf(pResponseMqf, nResponseMqf);

		TrTRACE(QmSignMqf, "Hash, ResponseMqf:");
	}

	//
	// We might have the Response queue only in the old Response queue property
	// This is true if we have only 1 queue compatible to msmq2.0 format.
	// In this case we will not have the Mqf headers
	//
	QUEUE_FORMAT RespQueueformat;
	if((nResponseMqf == 0) && (PktPtrs->GetResponseQueue(&RespQueueformat)))
	{
		pResponseMqf = &RespQueueformat;
		nResponseMqf = 1;

		TrTRACE(QmSignMqf, "Hash, ResponseQueue (old property):");
	}

    if(nResponseMqf > 0)
	{
		MqfHash(
			hHash,
			pResponseMqf, 
			nResponseMqf
			);
	}
}


static
void 
AdminMqfHash(
	IN HCRYPTHASH hHash, 	
	IN const CQmPacket* PktPtrs
	)
/*++
Routine Description:
	AdminMqf hash.

Arguments:
	hHash - hash object
	PktPtrs - pointer to the packet

Returned Value:
	none.

--*/
{
    //
    // Get the string representation for the admin Format Name.
    //
    ULONG nAdminMqf = PktPtrs->GetNumOfAdminMqfElements();

	QUEUE_FORMAT *   pAdminMqf = NULL;
	AP<QUEUE_FORMAT> pAdminMqfAutoCleanup;
    if(nAdminMqf > 0)
	{
		pAdminMqf = pAdminMqfAutoCleanup = new QUEUE_FORMAT[nAdminMqf];
		PktPtrs->GetAdminMqf(pAdminMqf, nAdminMqf);

		TrTRACE(QmSignMqf, "Hash, AdminMqf:");
	}

	//
	// We might have the Admin queue only in the old Admin queue property
	// This is true if we have only 1 queue compatible to msmq2.0 format.
	// In this case we will not have the Mqf headers
	//
	QUEUE_FORMAT AdminQueueformat;
	if((nAdminMqf == 0)	&& (PktPtrs->GetAdminQueue(&AdminQueueformat)))
	{
		pAdminMqf = &AdminQueueformat;
		nAdminMqf = 1;

		TrTRACE(QmSignMqf, "Hash, AdminQueue (old property):");
	}

    if(nAdminMqf > 0)
	{
		MqfHash(
			hHash,
			pAdminMqf, 
			nAdminMqf
			);
	}
}


static
void 
ExtensionHash(
	IN HCRYPTHASH hHash, 	
	IN const CQmPacket* PktPtrs
	)
/*++
Routine Description:
	Extension hash.

Arguments:
	hHash - hash object
	PktPtrs - pointer to the packet

Returned Value:
	none.

--*/
{
	//
	// Extension
	//
	if(PktPtrs->GetMsgExtensionPtr() != NULL)
	{
		CryHashData(
			reinterpret_cast<const BYTE*>(PktPtrs->GetMsgExtensionPtr()), 
			PktPtrs->GetMsgExtensionSize(),
			hHash
			);

		TrTRACE(QmSignMqf, "Hash, ExtensionLen = %d", PktPtrs->GetMsgExtensionSize());
	}
}


static
void 
TargetFormatNameHash(
	IN HCRYPTHASH hHash, 	
	IN const CQmPacket* PktPtrs
	)
/*++
Routine Description:
	TargetFormatName hash.

Arguments:
	hHash - hash object
	PktPtrs - pointer to the packet

Returned Value:
	none.

--*/
{
	//
    // Get Destination FormatName. 
	// This is the exactly FormatName that was used in the send (different from the Destination Queue)
    //
    ULONG nDestinationMqf = PktPtrs->GetNumOfDestinationMqfElements();

	QUEUE_FORMAT *   pDestinationMqf = NULL;
	AP<QUEUE_FORMAT> pDestinationMqfAutoCleanup;
    if(nDestinationMqf > 0)
	{
		pDestinationMqf = pDestinationMqfAutoCleanup = new QUEUE_FORMAT[nDestinationMqf];
		PktPtrs->GetDestinationMqf(pDestinationMqf, nDestinationMqf);

		TrTRACE(QmSignMqf, "Hash, DestinationMqf:");

	}

	QUEUE_FORMAT DestinationQueueformat;
	if((nDestinationMqf == 0) && (PktPtrs->GetDestinationQueue(&DestinationQueueformat)))
	{
		//
		// We have the Destination queue only in the old Destination queue property
		//

		pDestinationMqf = &DestinationQueueformat;
		nDestinationMqf = 1;

		TrTRACE(QmSignMqf, "Hash, DestinationQueue (old property):");
	}

	ASSERT(nDestinationMqf >= 1);
	
	if(nDestinationMqf > 0)
	{
		MqfHash(
			hHash,
			pDestinationMqf, 
			nDestinationMqf
			);
	}
}


static
void 
SourceQmHash(
	IN HCRYPTHASH hHash, 	
	IN const CQmPacket* PktPtrs
	)
/*++
Routine Description:
	Source Qm hash.

Arguments:
	hHash - hash object
	PktPtrs - pointer to the packet

Returned Value:
	none.

--*/
{
	//
    // Guid of source qm.
    //
	CryHashData(
		reinterpret_cast<const BYTE*>(PktPtrs->GetSrcQMGuid()), 
		sizeof(GUID),
		hHash
		);

	TrTRACE(QmSignMqf, "Hash, SourceGuid = %!guid!", PktPtrs->GetSrcQMGuid());
}


static
void 
MsgFlagsInit(
	IN const CQmPacket* PktPtrs,
	OUT struct _MsgFlags& sUserFlags
	)
/*++
Routine Description:
	Prepare Message Flags.

Arguments:
	PktPtrs - pointer to the packet
	sUserFlags - structure of user flags

Returned Value:
	none.

--*/
{
    sUserFlags.bDelivery  = (UCHAR)  PktPtrs->GetDeliveryMode();
    sUserFlags.bPriority  = (UCHAR)  PktPtrs->GetPriority();
    sUserFlags.bAuditing  = (UCHAR)  PktPtrs->GetAuditingMode();
    sUserFlags.bAck       = (UCHAR)  PktPtrs->GetAckType();
    sUserFlags.usClass    = (USHORT) PktPtrs->GetClass();
    sUserFlags.ulBodyType = (ULONG)  PktPtrs->GetBodyType();
}


static
void 
MsgFlagsHash(
	IN HCRYPTHASH hHash, 	
	IN const struct _MsgFlags& sUserFlags
	)
/*++
Routine Description:
	Message Flags hash.

Arguments:
	hHash - hash object
	sUserFlags - structure of user flags

Returned Value:
	none.

--*/
{
	CryHashData(
		reinterpret_cast<const BYTE*>(&sUserFlags), 
		sizeof(sUserFlags),
		hHash
		);

	TrTRACE(QmSignMqf, "Hash, bDelivery = %d", sUserFlags.bDelivery);
	TrTRACE(QmSignMqf, "Hash, bPriority = %d", sUserFlags.bPriority);
	TrTRACE(QmSignMqf, "Hash, bAuditing = %d", sUserFlags.bAuditing);
	TrTRACE(QmSignMqf, "Hash, bAck = %d", sUserFlags.bAck);
	TrTRACE(QmSignMqf, "Hash, usClass = %d", sUserFlags.usClass);
	TrTRACE(QmSignMqf, "Hash, ulBodyType = %d", sUserFlags.ulBodyType);
}


static
void 
MsgFlagsHash(
	IN HCRYPTHASH hHash, 	
	IN const CQmPacket* PktPtrs
	)
/*++
Routine Description:
	Message Flags hash.

Arguments:
	hHash - hash object
	PktPtrs - pointer to the packet

Returned Value:
	none.

--*/
{
	//
    // user flags.
    //
    struct _MsgFlags sUserFlags;
    memset(&sUserFlags, 0, sizeof(sUserFlags));

	MsgFlagsInit(PktPtrs, sUserFlags);
	MsgFlagsHash(hHash, sUserFlags);
}


static
void 
ConnectorHash(
	IN HCRYPTHASH hHash, 	
	IN const CQmPacket* PktPtrs
	)
/*++
Routine Description:
	Connector hash.

Arguments:
	hHash - hash object
	PktPtrs - pointer to the packet

Returned Value:
	none.

--*/
{
	//
	// Connector Type
	//
    GUID guidConnector = GUID_NULL ;
    const GUID *pConnectorGuid = &guidConnector ;

    const GUID *pGuid = PktPtrs->GetConnectorType() ;
    if (pGuid)
    {
        pConnectorGuid = pGuid ;
    }

	CryHashData(
		reinterpret_cast<const BYTE*>(pConnectorGuid), 
		sizeof(GUID),
		hHash
		);

	TrTRACE(QmSignMqf, "Hash, ConnectorGuid = %!guid!", pConnectorGuid);
}


static
void 
CalcPropHash(
	IN HCRYPTHASH hHash, 	
	IN const CQmPacket* PktPtrs
	)
/*++
Routine Description:
	Calc the hash value of Qm Packet Message property

Arguments:
	hHash - hash object
	PktPtrs - pointer to the packet

Returned Value:
	none.

--*/
{
	MsgBodyHash(hHash, PktPtrs); 

	CorrelationIdHash(hHash, PktPtrs);
	ApplicationTagHash(hHash, PktPtrs);
	TitleHash(hHash, PktPtrs);
	ResponseMqfHash(hHash, PktPtrs);
	AdminMqfHash(hHash, PktPtrs);
	ExtensionHash(hHash, PktPtrs);
	TargetFormatNameHash(hHash, PktPtrs);
	SourceQmHash(hHash, PktPtrs);
	MsgFlagsHash(hHash, PktPtrs);
	ConnectorHash(hHash, PktPtrs);
}


void
VerifySignatureMqf(
	CQmPacket *PktPtrs, 
	HCRYPTPROV hProv, 
	HCRYPTKEY hPbKey,
	bool fMarkAuth
	)
/*++
Routine Description:
	Verify mqf signature.
	this function verify that the signature in the packet fits the message body
	and other references that were signed with the public key of the certificate

Arguments:
	PktPtrs - pointer to the packet
	hProv - handle of the provider
	hPbKey - handle of the sender public key
	fMarkAuth - indicate if the packet will be marked as authenticated after verifying the signature.

Returned Value:
	MQ_OK, if successful, else error code.

--*/
{
	ASSERT(!PktPtrs->IsAuthenticated());
	ASSERT(PktPtrs->GetLevelOfAuthentication() == 0);

	//
	// ISSUE-2000/11/01-ilanh Temporary till Tracing will be on the QM
	// should register the component in order to get tracing
	//
	static bool fInitialized = false;

	if(!fInitialized)
	{
		fInitialized = true;
		TrRegisterComponent(&QmSignMqf, 1);
	}
		
    //
    // Get the signature from the packet.
	//

	ASSERT(PktPtrs->GetSignatureMqfSize() > 0);

	ULONG SignatureMqfSize;
	const UCHAR* pSignatureMqf = PktPtrs->GetPointerToSignatureMqf(&SignatureMqfSize);

	TrTRACE(QmSignMqf, "SignatureMqfSize = %d", SignatureMqfSize);

	ASSERT(SignatureMqfSize > 0);
	ASSERT(hProv != NULL);
	ASSERT(hPbKey != NULL);

	CHashHandle hHash = CryCreateHash(
							hProv, 
							PktPtrs->GetHashAlg()
							);

	CalcPropHash(
		hHash, 
		PktPtrs
		);

	//
	// Validate signature
	//
	if (!CryptVerifySignatureA(
			hHash, 
			pSignatureMqf, 
			SignatureMqfSize, 
			hPbKey,
			NULL, 
			0
			)) 
	{
		DWORD dwErr = GetLastError();
		TrERROR(QmSignMqf, "VerifySignatureMqf(), fail at CryptVerifySignature(), err = 0x%x", dwErr);

		ASSERT_BENIGN(("VerifySignatureMqf: Failed to verify signature", 0));
		throw bad_hresult(MQ_ERROR_FAIL_VERIFY_SIGNATURE_EX);
	}

	TrTRACE(QmSignMqf, "Verify SignatureMqf completed ok");

	//
	// mark the message as authenticated only when needed. 
	// Certificate was found in the DS or certificate is not self signed
	//
	if(!fMarkAuth)
	{
		TrTRACE(QmSignMqf, "The message will not mark as autheticated");
		return;
	}

	//
	// All is well, mark the message that it is an authenticated message.
	// We mark the authentication flag and the level of authentication as SIG30
	//
	PktPtrs->SetAuthenticated(TRUE);
	PktPtrs->SetLevelOfAuthentication(MQMSG_AUTHENTICATED_SIG30);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\xact.cpp ===
/*++
    Copyright (c) 1996  Microsoft Corporation

Module Name:
    QmXact.cpp

Abstract:
    This module implements QM transaction object

Author:
    Alexander Dadiomov (AlexDad)

--*/

#include "stdh.h"
#include "Xact.h"
#include "XactStyl.h"
#include "Xactlog.h"
#include "QmThrd.h"
#include "acapi.h"
#include "acdef.h"
#include "cqmgr.h"
#include "xactmode.h"

#include "xact.tmh"

static WCHAR *s_FN=L"xact";

// Defines how many msec to wait between Commit/Abort retrials (set from the registry).
static DWORD  s_dwRetryInterval = 300;


//
// Restriction for commit/abort processing: 60'.
// No special reason for this number, but Infinity is too risky.
// It seems no stress can cause so big delay inside one xact's Commit or Abort.
//
#define MAX_COMMIT_ABORT_WAIT_TIME (1000 * 60 * 60)

#ifdef _DEBUG

static void PrintPI(int cb, BYTE *pb)
{
    WCHAR str[1000];
    WCHAR digits[17]=L"0123456789ABCDEF";
    for (int i=0; i<cb; i++)
    {
        str[2*i]     = digits[pb[i]>>4];
        str[2*i + 1] = digits[pb[i] & 0x0F];
    }
    str[2*cb] = L'\0';

    DBGMSG((DBGMOD_XACT, DBGLVL_INFO, TEXT("Recovery: PI=%ls"), str));
}

static void PrintUOW(LPWSTR wszText1, LPWSTR wszText2, XACTUOW *puow, ULONG ind)
{
    BYTE *pb = (BYTE *)puow;
    WCHAR str[1000];
    WCHAR digits[17]=L"0123456789ABCDEF";
    for (int i=0; i<sizeof(XACTUOW); i++)
    {
        str[2*i]     = digits[pb[i]>>4];
        str[2*i + 1] = digits[pb[i] & 0x0F];
    }
    str[2*sizeof(XACTUOW)] = L'\0';

    DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("%ls in %ls: UOW=%ls, p=1, index=%d"), wszText1, wszText2, str,ind));
}


//
//  Mechanism for controlled failure injection.  Reuses crash points registry with numbers >900
//
#define CALL_OR_INJECT_FAILURE(res, expr, num) \
    if (num==g_ulCrashPoint)            \
    {                                   \
		res = g_ulCrashLatency;	        \
    }                                   \
    else                                \
    {                                   \
        res = expr;                     \
    }

#else

#define PrintUOW(wszText1, wszText2, puow, ind)
#define PrintPI(cb, pb)

#define CALL_OR_INJECT_FAILURE(res, expr, num)  res = expr

#endif

//---------------------------------------------------------------------
// CTransaction::CTransaction
//---------------------------------------------------------------------
CTransaction::CTransaction(CResourceManager *pRM, ULONG ulIndex, BOOL fUncoordinated) :
    m_qmov(HandleTransaction, HandleTransaction),
    m_RetryAbort1Timer(TimeToRetryAbort1),
    m_RetryAbort2Timer(TimeToRetryAbort2),
    m_RetryCommit2Timer(TimeToRetryCommit2),
    m_RetryCommit3Timer(TimeToRetryCommit3)
{
    ASSERT(pRM);

    ZeroMemory(&m_Entry, sizeof(m_Entry));
    m_cRefs       = 1;                      // We are creating the first reference right now
    m_pRM         = pRM;                    // Keep RM pointer
    m_hTransQueue = INVALID_HANDLE_VALUE;   // No trans queue yet
    m_pEnlist     = NULL;                   // No interfaces yet
    m_pbCookie    = NULL;
    m_cbCookie    = 0;
    m_hDoneEvent  = 0;
    m_DoneHr	  = S_OK;
	m_fReadyForCheckpoint = false;			

    // Set initial state
    SetState(TX_UNINITIALIZED);

    // Set discriminative index
    m_Entry.m_ulIndex = (ulIndex==0 ? m_pRM->Index() : ulIndex);

    // Set Uncoordinated state
    if (fUncoordinated)
    {
        SetInternal();
        SetSinglePhase();
    }

    DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("XactConstructor, %ls, p=2,  index=%d"), (fUncoordinated ? L"Single" : L"Double"), GetIndex()));

    #ifdef _DEBUG
    m_pRM->IncXactCount();
    #endif
}

//---------------------------------------------------------------------
// CTransaction::~CTransaction
//---------------------------------------------------------------------
CTransaction::~CTransaction(void)
{
    DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("XactDestructor, p=3, index=%d"), GetIndex()));
    IsolateFlushing();
	// BUGUBG - what happens if a checkpoint starts right now?

    m_pRM->ForgetTransaction(this);
    Cleanup();

    #ifdef _DEBUG
    m_pRM->DecXactCount();
    #endif

    if (m_pbCookie)
    {
        delete []m_pbCookie;
    }

    if (m_hDoneEvent)
    {
        CloseHandle(m_hDoneEvent);
    }
}

//---------------------------------------------------------------------
// CTransaction::QueryInterface
//---------------------------------------------------------------------
STDMETHODIMP CTransaction::QueryInterface(REFIID i_iid,LPVOID *ppv)
{
    *ppv = 0;                       // Initialize interface pointer.

    if (IID_IUnknown == i_iid)
    {
        *ppv = (IUnknown *)this;
    }
    else if (IID_ITransactionResourceAsync == i_iid)
    {
        *ppv = (ITransactionResourceAsync *)this;
    }

    if (0 == *ppv)                  // Check for null interface pointer.
    {
        return LogHR(E_NOINTERFACE, s_FN, 10);
                                    // Neither IUnknown nor IResourceManagerSink
    }
    ((LPUNKNOWN) *ppv)->AddRef();   // Interface is supported. Increment
                                    // its usage count.

    return S_OK;
}


//---------------------------------------------------------------------
// CTransaction::AddRef
//---------------------------------------------------------------------
STDMETHODIMP_ (ULONG) CTransaction::AddRef(void)
{
	return InterlockedIncrement(&m_cRefs);
}

//---------------------------------------------------------------------
// CTransaction::Release
//---------------------------------------------------------------------
STDMETHODIMP_ (ULONG) CTransaction::Release(void)
{
	ULONG cRefs = InterlockedDecrement(&m_cRefs);    // Decrement usage reference count.

    if (0 != cRefs)               // Is anyone using the interface?
    {                             // The interface is in use.
        return cRefs;             // Return the number of references.
    }

    delete this;                    // Interface not in use -- delete!

    return 0;                       // Zero references returned.
}

//---------------------------------------------------------------------
// CTransaction::InternalCommit
//---------------------------------------------------------------------
HRESULT CTransaction::InternalCommit()
{
    DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("InternalCommit, p=4, index=%d"), GetIndex()));

    ASSERT(!m_pEnlist);
    ASSERT(Internal());
	
	ASSERT(m_hDoneEvent == NULL);


    m_hDoneEvent = CreateEvent(0, TRUE,FALSE, 0);
    if (m_hDoneEvent == NULL)
    {
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 181);
    }

	AddRef();       // to hold through Commit procedure

	try
	{
	    //
	    // Call normal SINGLE-PHASE StartPrepareRequest
	    //
	    StartPrepareRequest(TRUE /*fSinglePhase*/);
	}
	catch(...)
    {
        LogIllegalPoint(s_FN, 82);
        DBGMSG((DBGMOD_XACT,DBGLVL_ERROR,TEXT("Error -  EXCEPTION in CTransaction::InternalCommit")));
        REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL,
                                          MSMQ_INTERNAL_ERROR,
                                          1,
                                          L"CTransaction::InternalCommit"));

		// We failed...
        if(!FAILED(m_DoneHr))
        {
            m_DoneHr = MQ_ERROR;
        }

        Release();      // Commit work done
        return LogHR(m_DoneHr, s_FN, 192);
    }

	//
	// CRASH_POINT 1
	//
	//	Internal, Abort
	//
    CRASH_POINT(1);   // BUG: if MQSentMsg returned OK, but msg was not sent

	//
    // Wait until commit completes
	//
    DWORD dwResult = WaitForSingleObject(m_hDoneEvent, MAX_COMMIT_ABORT_WAIT_TIME);
    if (dwResult != WAIT_OBJECT_0)
    {
        LogNTStatus(GetLastError(), s_FN, 203);
        ASSERT_BENIGN(dwResult == WAIT_OBJECT_0);
        return LogHR(E_UNEXPECTED, s_FN, 192);   // we have no idea why Wait failed, so keeping the xact
    }

    HRESULT  hr = m_DoneHr;    // to save over release
    Release();                   // Commit work done

	//
	// CRASH_POINT 2
	//
	//	Internal, Commit
	//
	CRASH_POINT(2);

    return LogHR(hr, s_FN, 20);
}


//---------------------------------------------------------------------
// CTransaction::InternalAbort
//---------------------------------------------------------------------
HRESULT CTransaction::InternalAbort()
{
    DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("InternalAbort, p=5, index=%d"), GetIndex()));
    ASSERT(!m_pEnlist);
    ASSERT(Internal());

	ASSERT(m_hDoneEvent == NULL);


    m_hDoneEvent = CreateEvent(0, TRUE,FALSE, 0);
    AddRef();   // To hold through Abort procedure

    if (m_hDoneEvent == NULL)
    {
        Release();      // Not doing abort procedure
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 182);
    }

	try
	{
        //
        // Abort this transaction, do all logging neccessary
        //
	    StartAbortRequest();
	}
	catch(...)
    {
        LogIllegalPoint(s_FN, 83);
        DBGMSG((DBGMOD_XACT,DBGLVL_ERROR,TEXT("Error -  EXCEPTION in CTransaction::InternalAbort")));
        REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL,
                                          MSMQ_INTERNAL_ERROR,
                                          1,
                                          L"CTransaction::InternalAbort"));

		// We failed...
        if(!FAILED(m_DoneHr))
        {
            m_DoneHr = MQ_ERROR;
        }

        Release();      // Done with Abort procedure
        return LogHR(m_DoneHr, s_FN, 192);
    }

	//
    // Wait until abort completes
	//
    DWORD dwResult = WaitForSingleObject(m_hDoneEvent, MAX_COMMIT_ABORT_WAIT_TIME);
    if (dwResult != WAIT_OBJECT_0)
    {
        LogNTStatus(GetLastError(), s_FN, 204);
        ASSERT_BENIGN(dwResult == WAIT_OBJECT_0);
        return LogHR(E_UNEXPECTED, s_FN, 191);   // we have no idea why Wait failed, so keeping the xact
    }

    Release();      // Done with Abort procedure
    return S_OK;
}

inline void CTransaction::ACAbort1(ContinueFunction cf)
{
    DBGMSG((DBGMOD_XACT, DBGLVL_INFO, TEXT("ACAbort1, p=6, index=%d"), GetIndex()));
    PrintUOW(L"Abort1", L"", &m_Entry.m_uow, m_Entry.m_ulIndex);

	ASSERT(m_hTransQueue != INVALID_HANDLE_VALUE);

	m_funCont = cf;
    DoAbort1();
}

void WINAPI  CTransaction::DoAbort1()
{
    AddRef();
    HRESULT hr;

    //
    // In release mode, just calls ACXactAbort1. In debug mode, may inject failure instead, if asked from registry
    //
    CALL_OR_INJECT_FAILURE(hr, ACXactAbort1(m_hTransQueue, &m_qmov), 991);

    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 991);
        // Release() for the async xact abort 1 that failed
        // AddRef()  for the timer that starts now
        ExSetTimer(&m_RetryAbort1Timer, CTimeDuration::FromMilliSeconds(s_dwRetryInterval));
    }
}


void WINAPI  CTransaction::TimeToRetryAbort1  (CTimer* pTimer)
{
    CTransaction *pTrans = CONTAINING_RECORD(pTimer,  CTransaction, m_RetryAbort1Timer);
    pTrans->DoAbort1();
    pTrans->Release();
}


inline void CTransaction::ACAbort2(ContinueFunction cf)
{
    DBGMSG((DBGMOD_XACT, DBGLVL_INFO, TEXT("ACAbort2, p=7, index=%d"), GetIndex()));
	ASSERT(m_hTransQueue != INVALID_HANDLE_VALUE);
    PrintUOW(L"Abort2", L"", &m_Entry.m_uow, m_Entry.m_ulIndex);

	m_funCont = cf;
    DoAbort2();
}

void WINAPI  CTransaction::DoAbort2()
{
    HRESULT hr;

    //
    // In release mode, just calls ACXactAbort2. In debug mode, may inject failure instead, if asked from registry
    //
    CALL_OR_INJECT_FAILURE(hr, ACXactAbort2(m_hTransQueue), 992);

    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 992);

        AddRef();       // to keep alive over scheduler waiting
        ExSetTimer(&m_RetryAbort2Timer, CTimeDuration::FromMilliSeconds(s_dwRetryInterval));
        return;
    }

    ASSERT(hr != STATUS_PENDING);
    Continuation(MQ_OK);
}

void WINAPI  CTransaction::TimeToRetryAbort2  (CTimer* pTimer)
{
    CTransaction *pTrans = CONTAINING_RECORD(pTimer,  CTransaction, m_RetryAbort2Timer);
    pTrans->DoAbort2();
    pTrans->Release();
}


inline HRESULT CTransaction::ACPrepare(ContinueFunction cf)
{
    DBGMSG((DBGMOD_XACT, DBGLVL_INFO, TEXT("ACPrepare, p=8, index=%d"), GetIndex()));
	ASSERT(m_hTransQueue != INVALID_HANDLE_VALUE);
    PrintUOW(L"Prepare", L"", &m_Entry.m_uow, m_Entry.m_ulIndex);

	m_funCont = cf;
	
	AddRef();       // to keep alive over waiting for the async ACXactPrepare
	HRESULT hr = ACXactPrepare(m_hTransQueue, &m_qmov);
	if(FAILED(hr))
		Release();  // for ACXactPrepare waiting
	return LogHR(hr, s_FN, 40);
}


inline HRESULT CTransaction::ACPrepareDefaultCommit(ContinueFunction cf)
{
	HRESULT hr;
	
    DBGMSG((DBGMOD_XACT, DBGLVL_INFO, TEXT("ACPrepareDefaultCommit, p=L, index=%d"), GetIndex()));
	ASSERT(m_hTransQueue != INVALID_HANDLE_VALUE);
    PrintUOW(L"PrepareDefaultCommit", L"", &m_Entry.m_uow, m_Entry.m_ulIndex);

    m_funCont = cf;

	AddRef();       // To keep alive over waiting for async ACXactPrepareDefaultCommit
	
    //
    // In release mode, just calls ACXactPrepareDefaultCommit. In debug mode, may inject failure instead, if asked from registry
    //
    CALL_OR_INJECT_FAILURE(hr, ACXactPrepareDefaultCommit(m_hTransQueue, &m_qmov), 950);

	if(FAILED(hr))
		Release();  // Not waiting for async ACXactPrepareDefaultCommit
	return LogHR(hr, s_FN, 50);
}

inline HRESULT CTransaction::ACCommit1(ContinueFunction cf)
{
	HRESULT hr;
	
    DBGMSG((DBGMOD_XACT, DBGLVL_INFO, TEXT("ACCommit1, p=9, index=%d"), GetIndex()));
	ASSERT(m_hTransQueue != INVALID_HANDLE_VALUE);
    PrintUOW(L"Commit1", L"", &m_Entry.m_uow, m_Entry.m_ulIndex);

	m_funCont = cf;

	AddRef();       // To keep over wait for async ACXactCommit1
	
    //
    // In release mode, just calls ACXactCommit1. In debug mode, may inject failure instead, if asked from registry
    //
    CALL_OR_INJECT_FAILURE(hr, ACXactCommit1(m_hTransQueue, &m_qmov), 960);

	if(FAILED(hr))
		Release();  // No wayting for async ACXactCommit1
	return LogHR(hr, s_FN, 60);
}

inline void CTransaction::ACCommit2(ContinueFunction cf)
{
    DBGMSG((DBGMOD_XACT, DBGLVL_INFO, TEXT("ACCommit2, p=a, index=%d"), GetIndex()));
	ASSERT(m_hTransQueue != INVALID_HANDLE_VALUE);
    PrintUOW(L"Commit2", L"", &m_Entry.m_uow, m_Entry.m_ulIndex);

	m_funCont = cf;
    DoCommit2();
}

void WINAPI  CTransaction::DoCommit2()
{
    HRESULT hr;

    AddRef();

    //
    // In release mode, just calls ACXactCommit2. In debug mode, may inject failure instead, if asked from registry
    //
    CALL_OR_INJECT_FAILURE(hr, ACXactCommit2(m_hTransQueue, &m_qmov), 994);

    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 994);
        // Release() for the commit 2 that failed
        // AddRef()  for the timer that starts now
        ExSetTimer(&m_RetryCommit2Timer, CTimeDuration::FromMilliSeconds(s_dwRetryInterval));
    }
}

void WINAPI  CTransaction::TimeToRetryCommit2(CTimer* pTimer)
{
    CTransaction *pTrans = CONTAINING_RECORD(pTimer,  CTransaction, m_RetryCommit2Timer);
    pTrans->DoCommit2();
    pTrans->Release();
}


inline void CTransaction::ACCommit3(ContinueFunction cf)
{
    DBGMSG((DBGMOD_XACT, DBGLVL_INFO, TEXT("ACCommit3, p=b, index=%d"), GetIndex()));
	ASSERT(m_hTransQueue != INVALID_HANDLE_VALUE);
    PrintUOW(L"Commit3", L"", &m_Entry.m_uow, m_Entry.m_ulIndex);

	m_funCont = cf;
    DoCommit3();
}

void WINAPI  CTransaction::DoCommit3()
{
    HRESULT hr;

    //
    // In release mode, just calls ACXactCommit3. In debug mode, may inject failure instead, if asked from registry
    //
    CALL_OR_INJECT_FAILURE(hr, ACXactCommit3(m_hTransQueue), 995);

    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 995);

        AddRef();   // to keep alive over waiting for scheduler
        ExSetTimer(&m_RetryCommit3Timer, CTimeDuration::FromMilliSeconds(s_dwRetryInterval));
        return;
    }

    ASSERT(hr != STATUS_PENDING);
    Continuation(MQ_OK);
}

void WINAPI  CTransaction::TimeToRetryCommit3(CTimer* pTimer)
{
    CTransaction *pTrans = CONTAINING_RECORD(pTimer,  CTransaction, m_RetryCommit3Timer);
    pTrans->DoCommit3();
    pTrans->Release();
}



//---------------------------------------------------------------------
// CTransaction::DirtyFailPrepare
//
//  One of the prepare steps has failed.  Unfortunately, we might have
//  already written some messages to disk.  We need to Abort.
//
//---------------------------------------------------------------------
void CTransaction::DirtyFailPrepare()
{
    DBGMSG((DBGMOD_XACT, DBGLVL_INFO, TEXT("DirtyFailPrepare, p=c, index=%d"), GetIndex()));
	SetState(TX_ABORTING);


    // Remove transaction from the list of prepared - otherwise sorter will be blocked
    g_pRM->RemoveAborted(this);

	ACAbort1(cfDirtyFailPrepare2);
}

//---------------------------------------------------------------------
// CTransaction::DirtyFailPrepare2
//
//  Storage associated with the transaction has been removed.
//  Go ahead and tell drivers to update queue data structures.
//
//---------------------------------------------------------------------
void CTransaction::DirtyFailPrepare2()
{
    DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("DirtyFailPrepare2, p=d, index=%d"), GetIndex()));

	ACAbort2(cfCleanFailPrepare);
}


//---------------------------------------------------------------------
// CTransaction::CleanFailPrepare
//
//  One of the prepare steps has failed.  Report the failure to DTC if
//  neeed.
//
//---------------------------------------------------------------------
void CTransaction::CleanFailPrepare()
{
    DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("CleanFailPrepare, p=e, index=%d"), GetIndex()));

	//
	// Since the transaction is not prepared, it will be aborted on recovery.
	//
	if(m_pEnlist)
	{
		HRESULT hr;

		hr = m_pEnlist->PrepareRequestDone (E_FAIL, NULL, NULL);
		ASSERT(SUCCEEDED(hr));
        LogHR(hr, s_FN, 171);
	}
	else
	{
	    // Internal transaction
        ASSERT(SinglePhase());

		//
		// Return error to internal transaction Commit
		//
		SignalDone(E_FAIL);
	}

	Release();  // done with this transaction
}

//---------------------------------------------------------------------
// CTransaction::LogGenericInfo
//
//	Log generic information about the transaction.  This needs to be
//	called before we write the first log record describing the transaction.
//
//---------------------------------------------------------------------
HRESULT CTransaction::LogGenericInfo()
{
    DBGMSG((DBGMOD_XACT, DBGLVL_INFO, TEXT("LogGenericInfo, p=f, index=%d"), GetIndex()));
	if(!g_fDefaultCommit)
	{
		//
		// We must log a TA_CREATED record
		//
		g_Logger.LogXactPhase(m_Entry.m_ulIndex, TA_CREATED);
	}
	
	//
	// The transaction is ready for a checkpoint. We allow checkpoint to occur before
	// writing to the log because otherwise the log might be flushed and we'll lose the
	// transaction data.
	//
	SetReadyForCheckpoint();

	//
	// Tranasction data
	//
	g_Logger.LogXactData(
                GetIndex(),
                GetSeqNumber(),
                SinglePhase(),
                GetUow());

	//
	// Prepare info
	//
	if (!SinglePhase())
	{
		HRESULT hr = GetPrepareInfoAndLog();
		if(FAILED(hr))
				return LogHR(hr, s_FN, 80);

		//
		// CRASH_POINT 3
		//
		// 2 Phase, Abort
		//
		CRASH_POINT(3);
	}

	return(S_OK);
}

//---------------------------------------------------------------------
// CTransaction::Continuation: activated after wait finished
//---------------------------------------------------------------------
void CTransaction::Continuation(HRESULT  hr)
{
    DBGMSG((DBGMOD_XACT, DBGLVL_INFO, TEXT("Continuation, p=g, index=%d"), GetIndex()));

	switch (m_funCont)
    {
    case cfPrepareRequest1:
    	LogHR(hr, s_FN, 916);
        PrepareRequest1(hr);
        break;

    case cfCommitRequest1:
    	LogHR(hr, s_FN, 917);
        CommitRequest1(hr);
        break;

	case cfCommitRequest2:
    	LogHR(hr, s_FN, 918);
    	if (FAILED(hr))
    	{
    	    //
    	    // We retry the originating operation. No sleep since it is asynchronous
    	    //
            CommitRequest1(S_OK);
    	}
    	else
    	{
	    	CommitRequest2();
    	}
		break;

    case cfFinishCommitRequest3:
    	ASSERT(SUCCEEDED(hr));
        FinishCommitRequest3();
        break;

    case cfCommitRestore1:
    	LogHR(hr, s_FN, 919);
        CommitRestore1(hr);
        break;

	case cfCommitRestore2:
    	LogHR(hr, s_FN, 920);
    	if (FAILED(hr))
    	{
    	    //
    	    // We retry the originating operation. No sleep since it is asynchronous.
    	    // May hang recovery... then SCM kills the service. Still right to refuse starting.
    	    //
            CommitRestore1(S_OK);
    	}
    	else
    	{
	    	CommitRestore2(hr);
    	}
		break;

	case cfCommitRestore3:
    	ASSERT(SUCCEEDED(hr));
    	CommitRestore3();
    	break;

	case cfAbortRestore1:
    	LogHR(hr, s_FN, 921);
		AbortRestore1(hr);
		break;

	case cfAbortRestore2:
    	LogHR(hr, s_FN, 931);
		AbortRestore2();
		break;

	case cfDirtyFailPrepare2:
    	LogHR(hr, s_FN, 922);
        if(FAILED(hr))
        {
            ACAbort1(cfDirtyFailPrepare2);
        }
        else
        {
		    DirtyFailPrepare2();
        }
		break;

	case cfCleanFailPrepare:
    	ASSERT(SUCCEEDED(hr));
		CleanFailPrepare();
		break;

	case cfAbortRequest2:
    	LogHR(hr, s_FN, 923);
    	if (FAILED(hr))
    	{
    	    //
    	    // We retry the originating operation. No sleep since it is asynchronous.
    	    //
            AbortRequest1(S_OK);
    	}
    	else
    	{
	    	AbortRequest2();
    	}
		break;

    case cfAbortRequest3:
    	ASSERT(SUCCEEDED(hr));
    	AbortRequest3();
		break;

	default:
    	LogHR(hr, s_FN, 924);
		ASSERT(0);
    }
}

//---------------------------------------------------------------------
// CTransaction::LogFlushed: activated after log was flushed
//---------------------------------------------------------------------
void CTransaction::LogFlushed(TXFLUSHCONTEXT tcContext, HRESULT hr)
{
	try
	{
		DBGMSG((DBGMOD_XACT, DBGLVL_INFO, TEXT("LogFlushed, p=h, index=%d"), GetIndex()));
		switch (tcContext)
		{
		case TC_PREPARE0:
    		LogHR(hr, s_FN, 901);
			PrepareRequest0(hr);
			break;

		case TC_PREPARE2:
			LogHR(hr, s_FN, 902);
	    	PrepareRequest2(hr);
			break;

		case TC_ABORT1:
    		LogHR(hr, s_FN, 903);
			AbortRequest1(hr);
			break;

		case TC_COMMIT4:
    		LogHR(hr, s_FN, 904);
			CommitRequest4(hr);
			break;
		}

		Release();  // Done with waiting for logging
	}
    catch(...)
    {
        LogIllegalPoint(s_FN, 81);
        DBGMSG((DBGMOD_XACT,DBGLVL_ERROR,TEXT("Error -  EXCEPTION in CTransaction::LogFlushed, context")));
        WCHAR wszParam[100];
        swprintf(wszParam, L"CTransaction::LogFlushed, context %d, hr=%x", tcContext, hr);
        REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL,
                                          MSMQ_INTERNAL_ERROR,
                                          1,
                                          wszParam));

		// We failed...
		if (!FAILED(m_DoneHr))
		{
			m_DoneHr = MQ_ERROR;
    		LogHR(m_DoneHr, s_FN, 912);
		}

		// If the transaction is internal, we should signal to release thread
	    if (m_pEnlist == 0)
		{
			SignalDone(m_DoneHr);
		}
    }

}

void CTransaction::GetInformation()
{
    DBGMSG((DBGMOD_XACT, DBGLVL_INFO, TEXT("GetInformation, p=i, index=%d"), GetIndex()));
    ASSERT(m_hTransQueue != INVALID_HANDLE_VALUE);

    PrintUOW(L"GetInformation", L"", &m_Entry.m_uow, m_Entry.m_ulIndex);
    HRESULT hr = ACXactGetInformation(m_hTransQueue, &m_info);
	if(FAILED(hr))
	{
    	LogHR(hr, s_FN, 926);
    	
    	//
		// Don't optimize, treat as multi messages with many sends and recieves
		//
		m_info.nSends = 0xFFFFFFFF;
        m_info.nReceives = 0xFFFFFFFF;
	}

    if((m_info.nSends + m_info.nReceives) == 1)
    {
        SetSingleMessage();		// We won't need to log a prepared record
    }



	//
	// CRASH_POINT 6
	//
	// 1 Msg DefaultCommit, Abort
	//
	CRASH_POINT(6);
}


//---------------------------------------------------------------------
// CTransaction::StartPrepareRequest
//
//		Activated:
//				from DTC when a Commit is requested
//				from an RPC call, when InternalCommit is requested		
//
//	State Transitions:
//
//         g_fDefaultCommit=FALSE:
//				ACXactPrepare
//				On completion goto PrepareRequest1
//
//		   g_fDefaultCommit=TRUE:
//				SingleMessage()=TRUE && SinglePhase()=TRUE:
//					// we do not need to log anything for this xaction
//					goto PrepareRequest0
//
//				SingleMessage()=FALSE || SinglePhase()=FALSE:
//					// Two phase needs the prepare info logged
//					SetState(TX_PREPARING, SingleMessage())
//					Log transaction data
//					On completion goto PrepareRequest0
//					
//---------------------------------------------------------------------
void CTransaction::StartPrepareRequest(BOOL fSinglePhase)
{
    DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("StartPrepareRequest, p=%p, index=%d"), this, GetIndex()));

	ASSERT(GetState() == TX_ENLISTED);

	//
	// CRASH_POINT 4
	//
	//	All, Abort
	//
    CRASH_POINT(4);

    if (fSinglePhase)
	{
        SetSinglePhase();
    }

    // Transaction was in correct state -- indicate preparing
	SetState(TX_PREPARING);

    //
    // Explanation for bug 8969 (8911 in .NET)
    // XACt Message lost for single message transaction (and internal xact).
    // If flushter thread run now (i.e., msmq checkpoint...), before calling
    // GetInformation() below, then it record a single phase transaction in
    // the PREPATING state. single message flag is not yet raised (it's
    // raised only in GetInformation).
    // Then stop msmq before another checkpoint happen.
    // On recovery, the transaction (which is not marked as single-message
    // in the mqtrans file) is aborted and message get lost. Too bad...
    //
    // fix: when CTransaction object is created it's marked as "not ready
    // for checkpoint". then in CTransaction::Save, it's logged with the
    // ABORTED status. All transaction with that status are recoved ok, as
    // recovery code consider them "completed". See xactrm.cpp,
    //  CResourceManager::ReleaseAllCompleteTransactions()
    // Ctransation object is marked as "Ready for checkpoint" in
    // LogGenericInfo().
    //
	//
	// CRASH_POINT 5
	//
	//	All, Abort
	//
	CRASH_POINT(5);

	//
	// Assign sequential number for the transaction
	// this is used for Prepare/Commit order matching
	//
	AssignSeqNumber();		// only used on NT4-NT5 cluster rolling upgrade
	if(g_fDefaultCommit)
	{
        //
        // Figure out how many messages in this transaction
        //
		
        GetInformation();

 		if(SinglePhase() && SingleMessage())
		{
			//
			// We don't need to log anything for this xaction
			//
			PrepareRequest0(S_OK);
			return;
		}

		//
		// First time we write a log record for this transaction
		//
		HRESULT hr = LogGenericInfo();
		if(FAILED(hr))
		{
        	LogHR(hr, s_FN, 927);
			CleanFailPrepare();
			return;
		}

		//
		// CRASH_POINT 7
		//
		//	2 Phase DefaultCommit, Abort
		//	1 Phase Multi Message DefaultCommit, Abort
		//
		CRASH_POINT(7);
		
		// Log the new state; on flush, go to PrepareRequest0
		g_Logger.LogXactFlagsAndWait(TC_PREPARE0, this, TRUE);
        return;
	}

    //
    // Old transaction code, compatible with MSMQ 1.0
    //
    CS lock(g_pRM->SorterCritSection());

    //
    // Insert the prepared transaction into the list for commit
    //
    g_pRM->InsertPrepared(this);

    //
    // Call driver to write messages to be prepared
    //
	// call ac prepare
	HRESULT hr = ACPrepare(cfPrepareRequest1);
	if(FAILED(hr))
	{
    	LogHR(hr, s_FN, 928);
		DirtyFailPrepare();
		return;
	}

	//
	// CRASH_POINT 8
	//
	//	1 Phase !g_fDefaultCommit, Any
	//	2 Phase !g_fDefaultCommit, Abort
	//

	CRASH_POINT(8);
}

STDMETHODIMP
CTransaction::PrepareRequest(
    BOOL /*fRetaining*/,
    DWORD /*grfRM*/,
    BOOL /*fWantMoniker*/,
    BOOL fSinglePhase
    )
/*++

Routine Description:
    The first phase of a commit request comming from DTC

Parameters:
    fRetaining - unused
	grfRM - unused
	fWantMoniker - unused
    fSinglePhase - indicates that the RM is the only resource manager enlisted on the transaction

Returned Value:
    Always S_OK

--*/
{
    StartPrepareRequest(fSinglePhase);
    return S_OK;
}

//---------------------------------------------------------------------
// CTransaction::PrepareRequest0
//
//		Activated:
//				When the log has completed writing a TX_PREPARING
//				record for the transaction
//				Directly from PrepareRequest
//
//	State Transitions:
//
//         g_fDefaultCommit=FALSE:
//				Not Possible
//
//		   g_fDefaultCommit=TRUE:
//				ACXactPrepareDefaultCommit
//				On completion goto PrepareRequest1
//					
//---------------------------------------------------------------------
void CTransaction::PrepareRequest0(HRESULT  hr)
{
	LogHR(hr, s_FN, 905);
	DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("PrepareRequest0, p=k, index=%d"), GetIndex()));
	ASSERT(g_fDefaultCommit);

	//
	// CRASH_POINT 9
	//
	//	All g_fDefaultCommit, Abort
	//
	CRASH_POINT(9);


	//
	// Check for log success
	//
	if(FAILED(hr))
	{
    	LogHR(hr, s_FN, 929);
		CleanFailPrepare();
		return;
	}

    if(SinglePhase() && SingleMessage() && m_info.nReceives == 1)
    {
        //
        // Single message recieves in a single message
        // transaction are implictly prepared.
        //

        // Insert the prepared transaction into the list for commit
        g_pRM->InsertPrepared(this);

        PrepareRequest1(MQ_OK);
        return;
    }


    {
        CS lock(g_pRM->SorterCritSection());

        //
        // Insert the prepared transaction into the list for commit
        //
        g_pRM->InsertPrepared(this);

        //
        // Call driver to write messages to be prepared
        //
        hr = ACPrepareDefaultCommit(cfPrepareRequest1);
        if (FAILED(hr))
        {
      		LogHR(hr, s_FN, 907);
            DirtyFailPrepare();
        }
    }
}

//---------------------------------------------------------------------
// CTransaction::PrepareRequest1
//
//		Activated:
//				When the driver has completed ACXactPrepare
//				When the driver has completed ACXactPrepareDefaultCommit
//
//		State Transitions:
//
//			g_fDefaultCommit=FALSE:
//				SetState(TX_PREPARED)
//				Log transaction data
//				On completion goto PrepareRequest2
//
//			g_fDefaultCommit=TRUE:
//				SingleMessage()=TRUE && SinlgePhase()=TRUE:
//					// on disk.  If this state is recoverd through a checkpoint, we know in
//					// recovery that this is a SingleMessage SinglePhase and can recover
//					// appropriately.
//					SetState(TX_PREPARED);
//					Goto PrepareRequest2
//
//				SinlgeMessage()=TRUE && SinglePhase()=FALSE:
//					SetState(TX_PREPARED);
//					Goto PrepareRequest2		(Single message, implicitly prepared)
//
//				SingleMessage()=FALSE:
//					SetState(TX_PREPARED)
//					Log transaction data
//					On completion goto PrepareRequest2
//				
//---------------------------------------------------------------------
void CTransaction::PrepareRequest1(HRESULT  hr)
{
    DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("PrepareRequest1, p=l, index=%d"), GetIndex()));

    if (FAILED(hr))
	{
    	LogHR(hr, s_FN, 908);
        DirtyFailPrepare();
		return;
    }

	if(g_fDefaultCommit && SingleMessage() && SinglePhase())
	{
		//
		// CRASH_POINT 10
		//
		//	1 Phase 1 Msg g_fDefaultCommit, Commit
		//
		CRASH_POINT(10);

		SetState(TX_PREPARED);

		//
		// CRASH_POINT 11
		//
		//	1 Phase 1 Msg g_fDefaultCommit, Commit
		//
		CRASH_POINT(11);

		PrepareRequest2(S_OK);
		return;
	}

	if(g_fDefaultCommit && SingleMessage() && !SinglePhase())
	{
		//
		// On two phase, we are implicitly prepared by the
		// fact that the message exists.
		//
		SetState(TX_PREPARED);
		PrepareRequest2(S_OK);
		return;
	}

	if(!g_fDefaultCommit)
	{
		//
		// First time we write a log record for this transaction
		//
		hr = LogGenericInfo();
		if(FAILED(hr))
		{
        	LogHR(hr, s_FN, 909);
			DirtyFailPrepare();
			return;
		}
	}	

	//
    // Log the new state; on flush, go to Prepare2
	//
	SetState(TX_PREPARED);
    g_Logger.LogXactFlagsAndWait(TC_PREPARE2, this, TRUE);
  	
	//
	// CRASH_POINT 12
	//
	//	All, Abort
	//
	CRASH_POINT(12);
}

//---------------------------------------------------------------------
// CTransaction::PrepareRequest2
//
//		Activated:
//				When the log has completed writing TX_PREPARED state
//				for the transaction.
//				Directly from PrepareRequest1 for single message
//				tranasctions.
//
//		State Transitions:
//
//			SinglePhase()=TRUE:
//					Goto CommitRequest
//
//			SinlgePhase()=FALSE:
//					return to DTC
//
//---------------------------------------------------------------------
void CTransaction::PrepareRequest2(HRESULT  hr)
{
    DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("PrepareRequest2, p=m, index=%d"), GetIndex()));

	if(FAILED(hr))
	{
    	LogHR(hr, s_FN, 910);
		DirtyFailPrepare();
		return;
	}

	//
	// CRASH_POINT 13
	//
	//	1 Phase, Commit
	//	2 Phase, Abort
	//
	CRASH_POINT(13);

    if (SinglePhase())
    {
		StartCommitRequest();
		return;
    }

	//
	// Two phase
	//
	ASSERT(m_pEnlist);
	hr = m_pEnlist->PrepareRequestDone (S_OK, NULL, NULL);
	if(FAILED(hr))
	{
    	LogHR(hr, s_FN, 930);
    	
		// Remove the xact from the sorter's list of prepared
		DirtyFailPrepare();
	}

	//
	// CRASH_POINT 14
	//
	//	All, Commit
	//
}

//---------------------------------------------------------------------
// CTransaction::StartCommitRequest
//
//		Activated:
//			From PrepareRequest2 on a single phase transaction
//			From DTC on a two phase transaction
//
//		State Transitions:
//
//			Call SortedCommit to pass on calls to CommitRequest0 in
//			sorted order
//
//---------------------------------------------------------------------
void CTransaction::StartCommitRequest()
{
    DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("StartCommitRequest, this=%p, index=%d"), this, GetIndex()));
    m_pRM->SortedCommit(this);
}

STDMETHODIMP
CTransaction::CommitRequest(
    DWORD /*grfRM*/,
    XACTUOW* /*pNewUOW*/
    )
/*++

Routine Description:
    The second phase of a commit request comming from DTC

Parameters:
	grfRM - unused
	pNewUOW - unused

Returned Value:
    Always S_OK

--*/
{
    DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("DTC CommitRequest, this=%p, index=%d"), this, GetIndex()));
    StartCommitRequest();
    return S_OK;
}

//---------------------------------------------------------------------
// CTransaction::CommitRequest0
//
//		The transaction is prepared.
//
//		Activated:
//			From PrepareRequest2 through SortedCommit on a single
//			phase transaction.
//			From DTC through SortedCommit on a two
//			phase transaction.
//	
//		State Transitions:
//
//			g_fDefaultCommit=FALSE:
//				SetState(TX_COMMITTING)
//				ACCommit1
//				On completion goto CommitRequest1
//
//			g_fDeaultCommit=TRUE:
//				SetState(TX_COMITTING)
//				// we do not need to mark any sent message and
//				// can threfore skip ACCommit1
//				Goto CommitRequest1
//
//---------------------------------------------------------------------
void CTransaction::CommitRequest0()
{
	DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("CommitRequest0, p=o, index=%d"), GetIndex()));

	ASSERT(GetState() == TX_PREPARED);
	SetState(TX_COMMITTING);

	//
	// CRASH_POINT 15
	//
	//	All, Commit
	//
	CRASH_POINT(15);

    // We put the transaction in the list of committed to tie sorting.
    //
	m_pRM->InsertCommitted(this);


	if(g_fDefaultCommit)
	{
		CommitRequest1(S_OK);
		return;
	}

	//
	// Need to call AcXactCommit1
	//
	HRESULT hr = ACCommit1(cfCommitRequest1);
    if (FAILED(hr))
    {
    	LogHR(hr, s_FN, 931);
        CommitRequest1(hr);
    }
}

//---------------------------------------------------------------------
// CTransaction::CommitRequest1
//
//		Activated:
//				After the call to ACXactCommit1 has completed.
//				Directly from CommitRequest0.
//	
//		State Transitions:
//
//			Check for failure and call ACCommit2
//
//---------------------------------------------------------------------
void CTransaction::CommitRequest1(HRESULT  hr)
{
    DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("CommitRequest1, p=p, index=%d"), GetIndex()));

    if (FAILED(hr))
    {
    	LogHR(hr, s_FN, 932);
    	
        //
        // Treatment of ACCommit1 failures (definitely possible for Uncoordinated messages)
        //

        ASSERT(hr == STATUS_CANCELLED);    // We see no possible reason for failure here
        ASSERT(Internal());
        m_DoneHr = hr;

        // We don't want Abort or reporting in this case; let next recovery finish it
        return;
    }

	//
	// Call Commit2 to issue DeleteStorage for recieved messages
	//
	ACCommit2(cfCommitRequest2);

}

//---------------------------------------------------------------------
// CTransaction::CommitRequest2
//
//		Activated:
//			After the call to ACXactCommit2 has completed
//	
//		State Transitions:
//
//			Goto CommitRequest3 through SortedCommit3
//	
//---------------------------------------------------------------------
void CTransaction::CommitRequest2()
{
    DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("CommitRequest2, p=q, index=%d"), GetIndex()));

	//
	// We now must go through the sorter, since we are
	// going to call Commit3. We need to call Commit3 anyway
	// so we pass hr.
	//

	m_DoneHr = MQ_OK;
	m_pRM->SortedCommit3(this);
}

//---------------------------------------------------------------------
// CTransaction::CommitRequest3
//
//		Activated:
//			Through SortedCommit3 when to call to ACCommit2 has
//			completed
//	
//		State Transitions:
//
//			g_fDefaultCommit=FALSE:
//				ACCommit3
//				Goto ComitRequest4
//	
//			g_fDefaultCommit=TRUE:
//				SinglePhase()=TRUE && SingleMessage()=TRUE:
//					// Sent messages are in effect committed to disk
//					// and will be in recovery.  For recieved message, we will be
//					// removing the message and
//					// also update the queue data strutures.
//					ACCommit3
//					Goto CommitRequest4
//				
//				SinglePhase()=TRUE && SingleMessage()=FALSE:
//					// We have already logged the fact that we are prepared.
//					// We are single phase therefore, we will be committed on recovery.
//					// We can go ahead complete the commit and report completion to the caller.
//					ACCommit3
//					Goto CommitRequest4
//
//				SinglePhase()=FALSE:
//					// We have already logged (implicitly or explicitly) the fact
//					// that we are prepared.   We are two phase, therefore we must
//					// not report completion to DTC before a commit record is logged
//					ACCommit3
//					SetState(TX_COMMITTED)
//					Lazily log transaction data
//					On completion, go to CommitRequest4
//
//---------------------------------------------------------------------
void CTransaction::CommitRequest3()
{
    DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("CommitRequest3, p=r, index=%d"), GetIndex()));

    ASSERT(SUCCEEDED(m_DoneHr));

	ACCommit3(cfFinishCommitRequest3);
}

//---------------------------------------------------------------------
// CTransaction::FinishCommitRequest3
//
//	Activated:
//		When CommitRequest3 succeeded with ACCommit3 (maybe after severat retries)
//
//---------------------------------------------------------------------
void CTransaction::FinishCommitRequest3()
{
    DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("CommitRequest3, p=M, index=%d"), GetIndex()));

	SetState(TX_COMMITTED);

	if(!SinglePhase())
	{
		//
		// We cannot call CommitRequest4 until we have logged the fact that
		// the transaction was committed.
		//

		//
		// Log the new state; on flush, go to CommitRequest4
		//
		g_Logger.LogXactFlagsAndWait(TC_COMMIT4, this, FALSE);
	}
	else
	{
		//
		// Single phase
		//
		if(!SingleMessage() || !g_fDefaultCommit)
		{
			//
			// We must not log anything unless we have allready logged something.
			//
			// It helps recovery to know the transaction was committed.  The transaction
			// will go away in the next checkpoint.
			//
		
			LogFlags();
		}

	    CommitRequest4(MQ_OK);
	}
}

//---------------------------------------------------------------------
// CTransaction::CommitRequest4
//
//	Activated:
//			When a two phase tranasction has been logged as committed.
//			On a single phase transaction directly from CommitRequest3
//
//		Everything has completed, report result to DTC
//		or unblock waiting RPC call for internal transaction
//
//		When we report results back to DTC it is allowed to forget about
//	    a 2 phase transaction.
//
//		On a 2 phase transaction we can only report CommitRequestDone when
//		the commit record was written to disk or if we are using DefaultAbort
//		semantics and have already removed the UOW from the msgs.
//
//		We need to add another phase here if we need to write to Commit record.
//		also, we need to add Wait without flush.
//
//
//---------------------------------------------------------------------
void CTransaction::CommitRequest4(HRESULT hr)
{
    DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("CommitRequest4, p=s, index=%d"), GetIndex()));
    CRASH_POINT(18);    //* Send/Rcv;  internal N-msg or single or DTC or SQL+DTC;  Commit [for single may be abort]

	if(FAILED(hr))
	{
    	LogHR(hr, s_FN, 943);
    	
		//
		// We only get here on two phase
		//
		ASSERT(!SinglePhase());

		//
		// We can't tell DTC to forget about the transaction.  Let recovery
		// deal with it the next time we come up
		//
		return;
	}

	//
    // report commit finish to the TM
	//
    if (m_pEnlist)
    {
        // What should we report to DTC?
        if (SinglePhase())
        {
			m_pEnlist->PrepareRequestDone(XACT_S_SINGLEPHASE,  NULL, NULL);
        }
        else
        {
            m_pEnlist->CommitRequestDone(S_OK);
        }
   }
   else
   {
        // Internal transaction
        ASSERT(SinglePhase());
		
		//
		// Return okay to internal transaction Commit
		//
		SignalDone(S_OK);       // propagate hr to Commit
	}

	//
    // Destroy transaction
	//
    Release();      // to kill
}

//---------------------------------------------------------------------
// CTransaction::AbortRestore
//
//	Activated:
//		From Recover
//	
//		We need to tell Recover what the status of recovering the
//		transction is.
//
//---------------------------------------------------------------------

HRESULT CTransaction::AbortRestore()
{
    DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("AbortRestore, p=t, index=%d"), GetIndex()));

	ASSERT(m_hDoneEvent == NULL);


	m_hDoneEvent = CreateEvent(0, TRUE,FALSE, 0);
    if (m_hDoneEvent == NULL)
    {
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 183);
    }

	AddRef();   // to keep alive over wait for wait for ACAbort1 results
	ACAbort1(cfAbortRestore1);

	DWORD dwResult = WaitForSingleObject(m_hDoneEvent, MAX_COMMIT_ABORT_WAIT_TIME);
    if (dwResult != WAIT_OBJECT_0)
    {
        LogNTStatus(GetLastError(), s_FN, 205);
        ASSERT_BENIGN(dwResult == WAIT_OBJECT_0);
        // No Release here: we have no idea why Wait failed, so keeping the xact to hang till recovery
        return LogHR(E_UNEXPECTED, s_FN, 193);
    }

    HRESULT hr = m_DoneHr;    // to save over release
    Release();      // Done with this transaction
	return LogHR(hr, s_FN, 100);
}

//---------------------------------------------------------------------
// CTransaction::AbortRestore1
//
//	Activated:
//		When ACXActAbort1 completes
//
//	State Transitions:
//
//		report completion status to caller.
//
//---------------------------------------------------------------------
void CTransaction::AbortRestore1(HRESULT hr)
{
    DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("AbortRestore1, p=u, index=%d"), GetIndex()));

   	LogHR(hr, s_FN, 946);
    m_DoneHr = hr;
   	
	ACAbort2(cfAbortRestore2);
}

void CTransaction::AbortRestore2()
{
    DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("AbortRestore1, p=O, index=%d"), GetIndex()));
	SignalDone(m_DoneHr);
}


//---------------------------------------------------------------------
// CTransaction::CommitRestore
//
//	Activated:
//		From Recover
//	
//		We need to tell Recover what the status of recovering the
//		transction is.
//
//		We arrive here on recovery when a transaction is in either in
//		the TX_PREPARED state and DTC has told us to commit the
//		transaction or we are in the TX_COMMITTING state
//
//		Goto CommitRestore0 through SortedCommit
//---------------------------------------------------------------------
HRESULT CTransaction::CommitRestore()
{
    DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("CommitRestore, p=v, index=%d"), GetIndex()));

	ASSERT(m_hDoneEvent == NULL);

	m_hDoneEvent = CreateEvent(0, TRUE,FALSE, 0);
    if (m_hDoneEvent == NULL)
    {
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 184);
    }

	//
	// We recover transactions in order, therefore we no longer
	// need to sort.  Call directly.
	//
    AddRef();   // during waiting
	CommitRestore0();

	//
	// We use this event to wait the restore completion. This is
	// actually needed when g_fDefaultCommit == FALSE, otherwise
	// all calls are synchronous.
	//
    DWORD dwResult = WaitForSingleObject(m_hDoneEvent, MAX_COMMIT_ABORT_WAIT_TIME);
    if (dwResult != WAIT_OBJECT_0)
    {
        LogNTStatus(GetLastError(), s_FN, 206);
        ASSERT_BENIGN(dwResult == WAIT_OBJECT_0);
        return LogHR(E_UNEXPECTED, s_FN, 194);   // we have no idea why Wait failed, so keeping the xact
    }

    HRESULT  hr = m_DoneHr;    // to save over release
    Release();                   // done with the transaction

	return LogHR(hr, s_FN, 105);
}

//---------------------------------------------------------------------
// CTransaction::CommitRestore0
//
//	Activated:
//		From CommitRestore through SortedCommit
//		Directly from CommitRestore
//
//
//	State Transitions:
//
//		g_fDefaultCommit=FALSE:
//			Call ACXactCommit1
//			On completion goto CommitRestore1
//
//		g_fDefaultCommit=TRUE:
//			Goto CommitRestore1
//
//---------------------------------------------------------------------
void CTransaction::CommitRestore0()
{
    DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("CommitRestore0, p=w, index=%d"), GetIndex()));
	if(g_fDefaultCommit)
	{
		CommitRestore1(S_OK);
		return;
	}

    CRASH_POINT(22);    //* Recovery for all commiting cases;  Commit
    HRESULT hr;

	hr = ACCommit1(cfCommitRestore1);

    CRASH_POINT(23);    //* Recovery for all commiting cases;  Commit
    if (FAILED(hr))
    {
    	LogHR(hr, s_FN, 950);
        SignalDone(hr);
    }
}		


//---------------------------------------------------------------------
// CTransaction::CommitRestore1
//
//	Activated:
//		When ACXActCommit1 completes
//		Directly from CommitRestore1
//
//	State Transitions:
//
//		We never log anything during recovery. All we need to do
//		is call ACXactCommit2.
//
//---------------------------------------------------------------------
void CTransaction::CommitRestore1(HRESULT hr)
{
    DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("CommitRestore1, p=x, index=%d"), GetIndex()));
    CRASH_POINT(24);    //* Recovery for all commiting cases;  Commit

	if(FAILED(hr))
	{
    	LogHR(hr, s_FN, 951);
		SignalDone(hr);
		return;
	}

    ACCommit2(cfCommitRestore2);

    CRASH_POINT(25);    //* Recovery for all commiting cases;  Commit
}

//---------------------------------------------------------------------
// CTransaction::CommitRestore2
//
//	Activated:
//		When ACXActCommit2 completes
//
//	State Transitions:
//
//		report completion status to caller.
//
//---------------------------------------------------------------------
void CTransaction::CommitRestore2(HRESULT hr)
{
   	DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("CommitRestore2, p=y, index=%d"), GetIndex()));

   	LogHR(hr, s_FN, 953);
   	m_DoneHr = hr;
   	
	ACCommit3(cfCommitRestore3);
}

//---------------------------------------------------------------------
// CTransaction::CommitRestore3
//
//	Activated:
//		When CommitRestore2 succeeded with ACCommit3 (maybe after severat retries)
//
//---------------------------------------------------------------------
void CTransaction::CommitRestore3()
{
    DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("CommitRestore2, p=N, index=%d"), GetIndex()));
	SignalDone(m_DoneHr);
}


//---------------------------------------------------------------------
// CTransaction::StartAbortRequest
//---------------------------------------------------------------------
void CTransaction::StartAbortRequest()
{
    DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("StartAbortRequest, p=z, index=%d, this=%p"), GetIndex(), this));

	//
    // Remove the xact from the sorter's list of prepared
	//
    m_pRM->RemoveAborted(this);

	//
	// If we are prepared we must log the fact
	// that we are aborting.  Otherwise, on recovery we
	// will ask DTC for status when we have already told
	// it the transaction is complete.
	//
	BOOL fLogAbort = GetState() == TX_PREPARED;
	
	//
	// SinglePhase transactions may get abort from the app only in ENLISTED state (nothing was done).
    // Though, failing DTC can cause ABORT on any stage
	//

    switch (GetState())
    {
    case TX_ENLISTED:
        //
        //  If we only enlisted it is ok to abort immidiately.
        //
	case TX_PREPARING:
    case TX_PREPARED:
		SetState(TX_ABORTING);

		if(fLogAbort)
		{
			// Log state and wait; on flush, go to Abort1
			g_Logger.LogXactFlagsAndWait(TC_ABORT1, this);
			return;
		}

		//
		// We don't need to wait for a log flush
		//
		AbortRequest1(S_OK);
		return;

    default:
		//
		// If DTC fails, we can get here with any other state.
        // The safest way is to keep the xact hanging till next recovery.
		//
		return;
    }
}


STDMETHODIMP
CTransaction::AbortRequest(
    BOID* /*pboidReason*/,
    BOOL /*fRetaining*/,
    XACTUOW* /*pNewUOW*/
    )
/*++

Routine Description:
    The MS DTC proxy calls this method to abort a transaction.

Parameters:
	pboidReason - unused
	fRetaining - unused
	pNewUOW - unused

Returned Value:
    Always S_OK

--*/
{
    DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("DTC AbortRequest, this=%p, index=%d"), this, GetIndex()));
    StartAbortRequest();
    return S_OK;
}

//---------------------------------------------------------------------
// CTransaction::AbortRequest1
//
// Activated:
//		When an abort record was written to the log
//		Directly from AbortRequest
//
//---------------------------------------------------------------------
void CTransaction::AbortRequest1(HRESULT  hr)
{
    DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("AbortRequest1, p=A, index=%d"), GetIndex()));
	if(FAILED(hr))
	{
    	LogHR(hr, s_FN, 955);
		ASSERT(!SinglePhase());

		//
		// We failed to write an abort log record.
		// This is a serious problem.  We will have to
		// refrain from reporting that we failed, and leave DTC
		// (and the abort caler..) hanging.  Recovery would try
		// to abort the transaction again.
        //
		AddRef();   // to hang
		return;
	}

	ACAbort1(cfAbortRequest2);
	
}

//---------------------------------------------------------------------
// CTransaction::AbortRequest2
//
// Activated:
//		When the driver has completed deleting storage
//		associatde with the transaction.
//
//---------------------------------------------------------------------
void CTransaction::AbortRequest2()
{
    DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("AbortRequest2, p=B, index=%d"), GetIndex()));

	ACAbort2(cfAbortRequest3);
}

//---------------------------------------------------------------------
// CTransaction::AbortRequest3
//
// Activated:
//		When AbortRequest2 succeeded with ACAbort2 (maybe after severat retries)
//
//---------------------------------------------------------------------
void CTransaction::AbortRequest3()
{
    DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("AbortRequest2, p=P, index=%d"), GetIndex()));
    // report abort finish to TM
    if (m_pEnlist)
    {
        m_pEnlist->AbortRequestDone(S_OK);
    }
	else
	{
		SignalDone(S_OK);
	}

    CRASH_POINT(28);    //* Any abort case;  Abort

    // Destroy transaction
    Release();      // to kill
}

//---------------------------------------------------------------------
// CTransaction::TMDown
//
// The MS DTC proxy calls this method if connection to the transaction
// manager goes down and the resource manager's transaction object is
// prepared (after the resource manager has called the
// ITransactionEnlistmentAsync::PrepareRequestDone method).
//
//
//---------------------------------------------------------------------
STDMETHODIMP CTransaction::TMDown(void)
{
    DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("TMDown, p=C, index=%d"), GetIndex()));

	//
	// We don't have to do anything.   We are in doubt and we are going
	// to stay in doubt apparently.  Next recover is going to tell us what
	// to do with this transaction.
	//

    // We must remove xact from the sorter list - to avoid sorter blocking
    g_pRM->RemoveAborted(this);


    //
    // If there are prepared xacts when DTC dies, QM has to die as well -
    //    otherwise we risk data loss and order violation
    // Here is the scenario:
    //    xacts T1, T2 and T3 are prepared, and CommitRequest has been called for T1 and T3
    //    DTC dies, CommitRequest for T2 did not come yet (quite possible)
    //    Sent messages from T1,T3 had gone to the net; T2 is hung in doubt till next recovery
    //    On the next recovery T2 will be committed and messages will be sent,
    //       but they may be rejected or come in a wrong order
    //         because T3 msgs could have been accepted already due to relinking
    //
    if (GetState() == TX_PREPARED && !SinglePhase())
    {
        //
        // MSDTC failed, we don't have warm recovery, cannot continue.
        // Shutting down
        //
        REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL,
                                          FAIL_MSDTC_TMDOWN,
                                          0));
        LogIllegalPoint(s_FN, 135);

        exit(EXIT_FAILURE);
    }

    return S_OK;
}

//---------------------------------------------------------------------
// CTransaction::GetPrepareInfoAndLog
//---------------------------------------------------------------------
HRESULT CTransaction::GetPrepareInfoAndLog()
{
    HRESULT         hr            = S_OK;
    R<IPrepareInfo> pIPrepareInfo = NULL;
    IsolateFlushing();

    try
    {
        DBGMSG((DBGMOD_XACT, DBGLVL_INFO, TEXT("GetPrepareInfoAndLog, p=D, index=%d"), GetIndex()));

        // Get the IPrepareInfo interface of the Enlistment object
        hr = m_pEnlist->QueryInterface (IID_IPrepareInfo,(LPVOID *) &pIPrepareInfo);
        if (FAILED(hr) || pIPrepareInfo.get() == NULL)
        {
            return LogHR(MQ_ERROR_TRANSACTION_PREPAREINFO, s_FN, 110);
        }

        // Get PrepareInfo size
        ULONG  ul = 0;
        pIPrepareInfo->GetPrepareInfoSize(&ul);
        if (ul == 0)
        {
            return LogHR(MQ_ERROR_TRANSACTION_PREPAREINFO, s_FN, 250);
        }

		m_Entry.m_pbPrepareInfo = new UCHAR[ul];

        // get prepare info
        hr = pIPrepareInfo->GetPrepareInfo(m_Entry.m_pbPrepareInfo);
        if (FAILED(hr))
        {
            delete [] m_Entry.m_pbPrepareInfo;
            return LogHR(MQ_ERROR_TRANSACTION_PREPAREINFO, s_FN, 120);
        }

		//
		// The update of m_cbPrepareInfo is done only here, when m_pbPrepareInfo
		// is allocated and valid. If we update m_cbPrepareInfo before m_pbPrepareInfo
		// and a context switch happens, another thread will think that m_Entry is
		// valid, because m_cbPrepareInfo != 0.
		//
        m_Entry.m_cbPrepareInfo = (USHORT)ul;

        // Log down the prepare info
        g_Logger.LogXactPrepareInfo(
                    m_Entry.m_ulIndex,
                    m_Entry.m_cbPrepareInfo,
                    m_Entry.m_pbPrepareInfo);
    }

    catch(...)
    {
        LogIllegalPoint(s_FN, 125);
        if (SUCCEEDED(hr))
            hr = MQ_ERROR;
        DBGMSG((DBGMOD_XACT,DBGLVL_ERROR,TEXT("Error -  EXCEPTION in CTransaction::GetPrepareInfo")));
        REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL,
                                          MSMQ_INTERNAL_ERROR,
                                          1,
                                          L"CTransaction::GetPrepareInfo"));

    }

    return LogHR(hr, s_FN, 130);
}


//---------------------------------------------------------------------
// CTransaction::CreateTransQueue(void)
//---------------------------------------------------------------------
HRESULT CTransaction::CreateTransQueue(void)
{
    HRESULT  hr;

    // Create the transaction Queue
    hr = XactCreateQueue(&m_hTransQueue, &m_Entry.m_uow );

    return LogHR(hr, s_FN, 140);
}

//---------------------------------------------------------------------
// CTransaction::AssignSeqNumber
//---------------------------------------------------------------------
void CTransaction::AssignSeqNumber()
{
    IsolateFlushing();
    m_Entry.m_ulSeqNum = m_pRM->AssignSeqNumber();
}

//---------------------------------------------------------------------
// CTransaction::GetSeqNumber
//---------------------------------------------------------------------
ULONG CTransaction::GetSeqNumber() const
{
    return m_Entry.m_ulSeqNum;
}

//---------------------------------------------------------------------
// CTransaction::SetState
//---------------------------------------------------------------------
void CTransaction::SetState(TXSTATE state)
{
    IsolateFlushing();
    m_Entry.m_ulFlags = (m_Entry.m_ulFlags & ~XACTION_MASK_STATE) | state;
}

//---------------------------------------------------------------------
// CTransaction::LogFlags
//---------------------------------------------------------------------
void CTransaction::LogFlags()
{
    g_Logger.LogXactFlags(this);
}

//---------------------------------------------------------------------
// CTransaction::SinglePhase
//---------------------------------------------------------------------
inline BOOL CTransaction::SinglePhase(void) const
{
    return m_Entry.m_ulFlags & XACTION_MASK_SINGLE_PHASE;
}

//---------------------------------------------------------------------
// CTransaction::SetSinglePhase
//---------------------------------------------------------------------
inline void CTransaction::SetSinglePhase()
{
    IsolateFlushing();
    m_Entry.m_ulFlags |= XACTION_MASK_SINGLE_PHASE;
}

//---------------------------------------------------------------------
// CTransaction::SingleMessage
//---------------------------------------------------------------------
inline BOOL CTransaction::SingleMessage(void) const
{
    return m_Entry.m_ulFlags & XACTION_MASK_SINGLE_MESSAGE;
}

//---------------------------------------------------------------------
// CTransaction::SetSingleMessage
//---------------------------------------------------------------------
inline void CTransaction::SetSingleMessage()
{
    IsolateFlushing();
    m_Entry.m_ulFlags |= XACTION_MASK_SINGLE_MESSAGE;
}

//---------------------------------------------------------------------
// CTransaction::Internal
//---------------------------------------------------------------------
inline BOOL CTransaction::Internal(void) const
{
    return m_Entry.m_ulFlags & XACTION_MASK_UNCOORD;
}

//---------------------------------------------------------------------
// CTransaction::SetInternal
//---------------------------------------------------------------------
inline void CTransaction::SetInternal()
{
    m_Entry.m_ulFlags |= XACTION_MASK_UNCOORD;
}

//---------------------------------------------------------------------
// CTransaction::SetUow
//---------------------------------------------------------------------
void CTransaction::SetUow(const XACTUOW *pUOW)
{
    IsolateFlushing();
    CopyMemory(&m_Entry.m_uow, pUOW, sizeof(XACTUOW));
}

//---------------------------------------------------------------------
// CTransaction::SetCookie
//---------------------------------------------------------------------
void CTransaction::SetCookie(DWORD cbCookie, unsigned char *pbCookie)
{
    IsolateFlushing();
    if (m_pbCookie)
    {
        delete []m_pbCookie;
    }

    m_cbCookie = cbCookie;
    if (cbCookie)
    {
        m_pbCookie = new unsigned char[cbCookie];
        ASSERT(m_pbCookie);
        CopyMemory(m_pbCookie, pbCookie, cbCookie);
    }
}

//---------------------------------------------------------------------
// CTransaction::IsComplete - check if transaction is complete
//
//---------------------------------------------------------------------
BOOL CTransaction::IsComplete()
{
	if(g_fDefaultCommit && SinglePhase() && SingleMessage())
	{
		if(GetState() == TX_ABORTING)
		{
			
			//
			// This is a single phase single message transaction that
			// has failed in the prepare process.  We need to abort it.
			//
			
			return(FALSE);
		}

		return(TRUE);
	}

	switch(GetState())
	{
		case TX_COMMITTED:
        case TX_ABORTED:
			return(TRUE);
	}

	return(FALSE);
}

//---------------------------------------------------------------------
// CTransaction::Recover - Recover one transaction
//
//    Called from CResourceManager::Init()
//
//
//		TX_UNINITIALIZED - Clean Abort, nothing done yet
//		TX_INITIALIZED   - Clean Abort, nothing done yet.
//		TX_ENLISTED      - Clean Abort, nothing done yet.
//		TX_PREPARING	 - Dirty abort, we could possibly have
//						   msgs marked with a UOW
//		TX_PREPARED		 - In doubt. Dirty abort or commit
//						   based on TM decision.
//		TX_COMMITTING	 - Commit
//		TX_ABORTING		 - Dirty abort, we could possibly have
//						   msgs marked with a UOW to clean
//
//   If not succefull, then the transaction could not be recovered.
//
//---------------------------------------------------------------------
HRESULT CTransaction::Recover()
{
    HRESULT         hr = MQ_OK;
    XACTSTAT        xactOutcome;

	m_pRM->ForgetTransaction(this);

	//
	// We never recover single phase single message transactions
	//
	ASSERT(!(SinglePhase() && SingleMessage()));

    if(m_hTransQueue == INVALID_HANDLE_VALUE)
	{
        //
        // There are no messages with the UOW
        // for this transaction.
        // we can safely ignore it.
        //
        return(MQ_OK);
    }
	
	try
    {
        CRASH_POINT(31);    //* Recovery;  Commit/Abort as was before crash

        // Process non-finished transaction
        // NB: not all states are persistent; only some may be mentioned in the file

		//
		// Patch up state for implicitly prepared transactions (TwoPhase, SingleMessage)
		//
		if(g_fDefaultCommit && (GetState() == TX_PREPARING) && SingleMessage())
		{
			SetState(TX_PREPARED);
#ifdef _DEBUG
			//
			// We never get here with no messages in the transaction
			//
            CACXactInformation info;
            PrintUOW(L"GetInformation", L"", &m_Entry.m_uow, m_Entry.m_ulIndex);
            HRESULT hr = ACXactGetInformation(m_hTransQueue, &info);
            ASSERT(SUCCEEDED(hr));
            LogHR(hr, s_FN, 172);
			ASSERT((info.nSends + info.nReceives) == 1);
#endif
		}

        switch (GetState())
        {
        case TX_ABORTING:
            // aborting state:  we were in the process of aborting
            // We are going to finish it now
            // falling down...

        case TX_COMMITTING:
            // committing state:  we were in the process of committing
            // We are going to finish it now

        case TX_PREPARED:
            // in-doubt state:  we voted Yes, but don't know what other RMs did
            // reeenlist, then follow the TM's decision

            // Get PrepareInfo from the transaction
            if (!SinglePhase())
            {
				if (GetState() == TX_COMMITTING)
                {
                    xactOutcome = XACTSTAT_COMMITTED;
                }
                else if (GetState() == TX_ABORTING)
                {
                    xactOutcome = XACTSTAT_ABORTED;
                }
				else if (m_Entry.m_cbPrepareInfo > 0)
                {
					hr = g_pRM->ProvideDtcConnection();
					if(FAILED(hr))
						return LogHR(hr, s_FN, 150);
					
                    // Reenlist with MS DTC to determine the outcome of the in-doubt transaction
                    hr = m_pRM->GetIResMgr()->Reenlist (
                                                m_Entry.m_pbPrepareInfo,
                                                m_Entry.m_cbPrepareInfo,
                                                XACTCONST_TIMEOUTINFINITE,          // Is it always OK???
                                                &xactOutcome);
	                PrintPI(m_Entry.m_cbPrepareInfo, m_Entry.m_pbPrepareInfo);
    				if(FAILED(hr))
					{
						LogHR(hr, s_FN, 160);
                        return MQ_ERROR_RECOVER_TRANSACTIONS;
					}
                }
                else
                {
					//
					// We cannot be prepared and not have PrepareInfo
					//
                    ASSERT(GetState() == TX_PREPARED);
                    return LogHR(MQ_ERROR_RECOVER_TRANSACTIONS, s_FN, 170);
                }
            }
            else
            {
				if(GetState() == TX_COMMITTING || GetState() == TX_PREPARED)
				{
					xactOutcome = XACTSTAT_COMMITTED;
				}
				else
				{
					xactOutcome = XACTSTAT_ABORTED;
				}
			}

            // Reenlistment is successful -- act on transaction outcome.
            switch(xactOutcome)
            {
            case XACTSTAT_ABORTED :
                DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("RecoveryAbort, p=E, index=%d"), GetIndex()));
                hr = AbortRestore();
				return LogHR(hr, s_FN, 180);

            case XACTSTAT_COMMITTED :
                DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("RecoveryCommit, p=F, index=%d"), GetIndex()));
                hr = CommitRestore();
				return LogHR(hr, s_FN, 190);

            default:
                // we shouldn't get anything else
                DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("RecoveryError, p=G, index=%d"), GetIndex()));
                ASSERT(FALSE);
                return LogHR(MQ_ERROR_RECOVER_TRANSACTIONS, s_FN, 200);
            }


        case TX_ENLISTED:
            // active state:  we were in the process of getting send/receive orders
            // Abort: presumed abort
		       // falling down...

        case TX_PREPARING:
            // preparing state:  we started preparing but not reported it yet
            // Abort: presumed abort
            // falling down...

            //
            //  Abort without calling DTC, we don't have the prepare info for
            //  that transaction.
            //

        case TX_INITIALIZED:
        case TX_UNINITIALIZED:
            // we did nothing revertable yet, so taking it easy


        case TX_INVALID_STATE:

            // In all these cases we clean up (== Abort)

            DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("RecoveryAbort2, p=H, index=%d"), GetIndex()));
            hr = AbortRestore();
			return LogHR(hr, s_FN, 210);

		case TX_COMMITTED:
        case TX_ABORTED:
			//
			// Internal Error, recovering complete transaction
			//
			ASSERT(FALSE);
        default:
            // These states should not become persistent at all
            ASSERT(FALSE);
            DBGMSG((DBGMOD_XACT, DBGLVL_TRACE, TEXT("RecoveryError2, p=I, index=%d"), GetIndex()));
            return LogHR(MQ_ERROR_RECOVER_TRANSACTIONS, s_FN, 220);
        }
    }

    catch(...)
    {
        LogIllegalPoint(s_FN, 215);
        if (SUCCEEDED(hr))
            hr = MQ_ERROR;
        DBGMSG((DBGMOD_XACT,DBGLVL_ERROR,TEXT("Error -  EXCEPTION in CTransaction::Recover")));
        REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL,
                                          MSMQ_INTERNAL_ERROR,
                                          1,
                                          L"CTransaction::Recover"));

    }

    return LogHR(hr, s_FN, 230);
}

/*====================================================
CTransaction::Cleanup
    Robbs transaction of everything it posessed, including TransQueue
=====================================================*/
void CTransaction::Cleanup()
{
    if (m_Entry.m_pbPrepareInfo)
    {
        delete []m_Entry.m_pbPrepareInfo;
        m_Entry.m_pbPrepareInfo = NULL;
    }

    // Release interfaces
    if (m_pEnlist)
    {
        m_pEnlist->Release();
        m_pEnlist = NULL;
    }

    // release trans queue
    if (m_hTransQueue!=INVALID_HANDLE_VALUE)
    {
        ACCloseHandle(m_hTransQueue);
        m_hTransQueue = INVALID_HANDLE_VALUE;
    }
}


/*====================================================
CTransaction::Save
    Saves transaction persistent data
=====================================================*/
BOOL CTransaction::Save(HANDLE hFile)
{
    PERSIST_DATA;
	XACTION_ENTRY EntryToSave = m_Entry;

	if (!IsReadyForCheckpoint())
	{
		//
		// The transaction is not ready for checkpoint. Save a dummy record instead.
		// Since we set the flags to TX_ABORTED, the transaction will be ignored
		// in recovery.
		//
		EntryToSave.m_ulFlags = TX_ABORTED;
		EntryToSave.m_cbPrepareInfo = 0;
		EntryToSave.m_pbPrepareInfo = NULL;
	}

	SAVE_DATA(&EntryToSave, (sizeof(XACTION_ENTRY)-sizeof(UCHAR *)));
	if (EntryToSave.m_cbPrepareInfo)
	{
	    SAVE_DATA(EntryToSave.m_pbPrepareInfo, EntryToSave.m_cbPrepareInfo);
	}

    return TRUE;
}

/*====================================================
CTransaction::Load
    Loads transaction persistent data
=====================================================*/
BOOL CTransaction::Load(HANDLE hFile)
{
    PERSIST_DATA;

    LOAD_DATA(m_Entry, (sizeof(XACTION_ENTRY)-sizeof(UCHAR *)));
    if (m_Entry.m_cbPrepareInfo)
    {
        LOAD_ALLOCATE_DATA(m_Entry.m_pbPrepareInfo, m_Entry.m_cbPrepareInfo, PUCHAR);
    }
    else
    {
        m_Entry.m_pbPrepareInfo = NULL;
    }

    return TRUE;
}


/*====================================================
CTransaction::PrepInfoRecovery
    Recovers xact PrepareInfo from the log record
=====================================================*/
void CTransaction::PrepInfoRecovery(ULONG cbPrepInfo, UCHAR *pbPrepInfo)
{
    ASSERT(m_Entry.m_pbPrepareInfo == NULL);

    DBGMSG((DBGMOD_LOG, DBGLVL_INFO, TEXT("PrepInfo Recovery: p=J, index=%d"),GetIndex()));

    m_Entry.m_cbPrepareInfo = (USHORT)cbPrepInfo;
    m_Entry.m_pbPrepareInfo = new UCHAR[cbPrepInfo];
    ASSERT(m_Entry.m_pbPrepareInfo);
    CopyMemory(m_Entry.m_pbPrepareInfo, pbPrepInfo, cbPrepInfo);
}


/*====================================================
CTransaction::XactDataRecovery
    Recovers xact data (uow, seqnum) from the log record
=====================================================*/
void CTransaction::XactDataRecovery(ULONG ulSeqNum, BOOL fSinglePhase, const XACTUOW *puow)
{
    //ASSERT(m_Entry.m_ulSeqNum == 0);

    DBGMSG((DBGMOD_LOG, DBGLVL_INFO, TEXT("XatData Recovery: p=K, index=%d"),GetIndex()));

    m_Entry.m_ulSeqNum = ulSeqNum;
    CopyMemory(&m_Entry.m_uow, puow, sizeof(XACTUOW));
    if (fSinglePhase)
    {
        SetSinglePhase();
    }
}

//---------------------------------------------------------------------
// XactCreateQueue: creation of the transaction queue
//---------------------------------------------------------------------
HRESULT XactCreateQueue(HANDLE* phTransQueue, const XACTUOW* puow)
{
    HRESULT hr;
    hr = ACCreateTransaction(puow, phTransQueue);

    if (SUCCEEDED(hr))
    {

        //
        // Attach the transaction handle to the completion port
        //
        ExAttachHandle(*phTransQueue);
    }

    return LogHR(hr, s_FN, 240);
}


/*====================================================
CTransaction::HandleTransaction
    Handle overlapped operation asynchronous completion
=====================================================*/
VOID WINAPI CTransaction::HandleTransaction(EXOVERLAPPED* pov)
{
    CTransaction* pXact = CONTAINING_RECORD (pov, CTransaction, m_qmov);

    ASSERT(pXact != NULL);
    ASSERT(pov->GetStatus() != STATUS_CANCELLED);
    pXact->Continuation(pov->GetStatus());
    pXact->Release();                       // done with waiting for async result
}

/*====================================================
QMPreInitResourceManager
    Pre-initialization of the xact mechanism
=====================================================*/
void QMPreInitXact()
{
    //
    // Get fine-tuning  parameters from registry
    //

    DWORD dwDef = FALCON_DEFAULT_XACT_RETRY_INTERVAL;
    READ_REG_DWORD(s_dwRetryInterval,
                   FALCON_XACT_RETRY_REGNAME,
                   &dwDef ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\xact.h ===
/*++
    Copyright (c) 1996  Microsoft Corporation

Module Name:
    Xact.h

Abstract:
    Transaction object definition

Author:
    Alexander Dadiomov (AlexDad)

--*/

#ifndef __XACT_H__
#define __XACT_H__

#include "txdtc.h"
#include "xactping.h"
#include "xactrm.h"
#include "acdef.h"
#include "qmthrd.h"

// forward declaration
class CResourceManager;

//
// TXSTATE:  Transaction states
//
typedef enum
{
	//
	// The following three states are equaivalent and should be merged into one
	//
	TX_UNINITIALIZED,
	TX_INITIALIZED,
	TX_ENLISTED,

	TX_PREPARING,
	TX_PREPARED,
	TX_COMMITTING,
	TX_COMMITTED,
	TX_ABORTING,
	TX_ABORTED,
	TX_DONE,			// obsolete
	TX_TMDOWN,			// obsolete 
	TX_INVALID_STATE	// obsolete
} TXSTATE;


//
// TXACTION:  Actions upon transaction
//
typedef enum
{
	TA_CREATED,
	TA_STATUS_CHANGE,
	TA_DELETED
} TXACTION;

//
// TXFLUSHCONTEXT:  Context of waiting for log flush
//
typedef enum
{
	TC_PREPARE2,
    TC_ABORT1,
	TC_PREPARE0,
	TC_COMMIT4
} TXFLUSHCONTEXT;

//
// TXSORTERTYPE:  type of sorter usage
//
typedef enum
{
	TS_PREPARE,
    TS_COMMIT
} TXSORTERTYPE;

//
// Masks for flag keeping
//
#define XACTION_MASK_UNCOORD        0x0040
#define XACTION_MASK_SINGLE_PHASE   0x0020
#define XACTION_MASK_FAILURE        0x0010	/* obsolete */
#define XACTION_MASK_STATE          0x000F
#define XACTION_MASK_SINGLE_MESSAGE 0x0080

//---------------------------------------------------------------------
// Transaction Persistent Entry (resides in a persistent Transaction File)
//---------------------------------------------------------------------
typedef struct XACTION_ENTRY {

    ULONG   m_ulIndex;                      //Xact discriminative index 
    ULONG   m_ulFlags;                      //Flags
    ULONG   m_ulSeqNum;                     //Seq Number of the prepared transaction
    XACTUOW m_uow;			                //Transaction ID  (16b.)
    USHORT  m_cbPrepareInfo;                //PrepareInfo length 
    UCHAR  *m_pbPrepareInfo;                //PrepareInfo address
            // This pointer must be last!
} XACTION_ENTRY;


//---------------------------------------------------------------------
// CTransaction: Transaction Object in Falcon RM
//---------------------------------------------------------------------
class CTransaction: public ITransactionResourceAsync
{
    friend HRESULT CResourceManager::EnlistTransaction(
            const XACTUOW* pUow,
            DWORD cbCookie,
            unsigned char *pbCookie);

    friend HRESULT CResourceManager::EnlistInternalTransaction(
            XACTUOW *pUow,
            RPC_INT_XACT_HANDLE *phXact);

    friend void CResourceManager::Destroy();

public:

	// Current data
	enum ContinueFunction {
      cfPrepareRequest1,
      cfCommitRequest1,
	  cfCommitRequest2,
	  cfFinishCommitRequest3,
      cfCommitRestore1,
	  cfCommitRestore2,
	  cfCommitRestore3,
	  cfAbortRestore1,
	  cfAbortRestore2, 
	  cfDirtyFailPrepare2,
	  cfCleanFailPrepare,
	  cfAbortRequest2,
	  cfAbortRequest3,
	};


    // Construction and COM
    //
    CTransaction(CResourceManager *pRM, ULONG ulIndex=0, BOOL fUncoordinated=FALSE);
    ~CTransaction( void );

    STDMETHODIMP    QueryInterface( REFIID i_iid, void **ppv );
    STDMETHODIMP_   (ULONG) AddRef( void );
    STDMETHODIMP_   (ULONG) Release( void );

    // ITransactionResourceAsync interface
    // Interfaces implementing ITransactionResourceAsync interface.
    //      PrepareRequest  -- Phase 1 notification from TM.
    //      CommitRequest   -- Phase 2 commit decision from TM.
    //      AbortRequest    -- Phase 2 abort decision from TM.
    //      TMDown          -- callback received when the TM goes down
    //
    STDMETHODIMP    PrepareRequest(BOOL fRetaining,
                                   DWORD grfRM,
                                   BOOL fWantMoniker,
                                   BOOL fSinglePhase);
    STDMETHODIMP    CommitRequest (DWORD grfRM,
                                   XACTUOW *pNewUOW);
    STDMETHODIMP    AbortRequest  (BOID *pboidReason,
                                   BOOL fRetaining,
                                   XACTUOW *pNewUOW);
    STDMETHODIMP    TMDown        (void);

    HRESULT		    InternalCommit();
	HRESULT			InternalAbort();

    // Recovery
    //
    void            PrepInfoRecovery(ULONG cbPrepInfo, 
                                     UCHAR *pbPrepInfo);
    void            XactDataRecovery(ULONG ulSeqNum, 
                                     BOOL fSinglePhase, 
                                     const XACTUOW *puow);
    HRESULT         Recover();
    HRESULT	        CommitRestore(void);
    void	        CommitRestore0(void);
    void            CommitRestore1(HRESULT hr);
	void			CommitRestore2(HRESULT hr);
    void             CommitRestore3();
	HRESULT			AbortRestore();
	void			AbortRestore1(HRESULT hr);
    void             AbortRestore2();
    void             AbortRequest3();

    // Cleanup
    void			Cleanup();

    // asynchronous completion routines
	void			PrepareRequest0(HRESULT  hr);
    void            PrepareRequest2(HRESULT hr);
    void            PrepareRequest1(HRESULT hr);
	void			DirtyFailPrepare2();

    void            CommitRequest0();
    void            CommitRequest1(HRESULT hr);
    void            CommitRequest2();
    void            CommitRequest3();
    void            FinishCommitRequest3();
	void			CommitRequest4(HRESULT hr);

	void			AbortRequest1(HRESULT  hr);
	void			AbortRequest2();
 
	void            Continuation(HRESULT hr);
    void            LogFlushed(TXFLUSHCONTEXT tcContext, HRESULT hr);
    

    // Persistency
    BOOL            Save(HANDLE hFile);
    BOOL            Load(HANDLE hFile);
    
    //
    // Auxiliary methods
    //
    TXSTATE         GetState(void) const;           // gets transaction state
    ULONG           GetFlags(void) const;           // gets transaction flags
    void            SetFlags(ULONG ulFlags);        // sets transaction flags
    void            SetState(TXSTATE state);        // sets transaction state
    void            LogFlags();                     // logs transaction flags


    BOOL            SinglePhase(void) const;        // gets SinglePhase status
    void            SetSinglePhase();               // sets SinglePhase status

	BOOL            SingleMessage(void) const;      // gets SingleMessage status
    void            SetSingleMessage();             // sets SingleMessage status

    BOOL            Internal(void) const;           // gets Internal status
    void            SetInternal();                  // sets Internal status

    const XACTUOW*  GetUow() const;                 // gets UOW pointer

    ULONG           GetIndex(void) const;           // gets discriminative index 

                                                    // Sets the Enlist ponter
    void            SetEnlist(ITransactionEnlistmentAsync *pEnlist) {m_pEnlist = pEnlist; };
                                                    // Sets the Cookie
    void            SetCookie(DWORD cbCookie, unsigned char *pbCookie);

    ULONG           GetSeqNumber() const;           // Provides the Prepare seq.number

    void            SetUow(const XACTUOW *pUOW);    // sets UOW value

 	void			SignalDone(HRESULT hr);				// Report async completion

	void            SetTransQueue(HANDLE hQueue);
	BOOL			ValidTransQueue();
	BOOL			IsComplete();
    void            GetInformation();

	//
	// Driver interface functions
	//
	void			ACAbort1(ContinueFunction cf);
	void			ACAbort2(ContinueFunction cf);
	HRESULT			ACPrepare(ContinueFunction cf);
	HRESULT			ACPrepareDefaultCommit(ContinueFunction cf);
	HRESULT			ACCommit1(ContinueFunction cf);
	void			ACCommit2(ContinueFunction cf);
	void			ACCommit3(ContinueFunction cf);

	bool			IsReadyForCheckpoint(void) const;
	void			SetReadyForCheckpoint(void);
 
private:

    HRESULT         GetPrepareInfoAndLog(void);     // sets prepare info members
    void            AssignSeqNumber();              // Assigns sequential number for the prepared transaction

    // AC driver transaction queue operations
    HRESULT         CreateTransQueue(void);       // persistent queue control
    HRESULT         OpenTransQueue(void);
    void            CloseTransQueue(void);


    void			DirtyFailPrepare();
    void			CleanFailPrepare();
	HRESULT			LogGenericInfo();

    void StartPrepareRequest(BOOL fSinglePhase);
    void StartCommitRequest();
    void StartAbortRequest();

    void WINAPI DoAbort1  ();
    void WINAPI DoAbort2  ();
    void WINAPI DoCommit2();
    void WINAPI DoCommit3();

    static void WINAPI TimeToRetryAbort1  (CTimer* pTimer);
    static void WINAPI TimeToRetryAbort2  (CTimer* pTimer);
    static void WINAPI TimeToRetryCommit2(CTimer* pTimer);
    static void WINAPI TimeToRetryCommit3(CTimer* pTimer);

	static VOID WINAPI HandleTransaction(EXOVERLAPPED* pov);

    // Data
    //
private:

    LONG              m_cRefs;          // IUnknown reference count - for self-destruction
    XACTION_ENTRY     m_Entry;          // Transaction Entry: all transaction's persistent data
    HANDLE            m_hTransQueue;    // Transaction queue handle
    CResourceManager *m_pRM;            // Back pointer to the parent RM object

    ITransactionEnlistmentAsync *m_pEnlist; // Pointer to an MS DTC enlistment object
                                            //  with methods [Prepare/Commit/Abort]RequestDone

    DWORD             m_cbCookie;       // Cookie for enlistment
    unsigned char    *m_pbCookie;

	ContinueFunction m_funCont;

    HANDLE            m_hDoneEvent;    
    HRESULT           m_DoneHr;

    CACXactInformation m_info;

	//
	// Driver transaction request
	//
    EXOVERLAPPED m_qmov;

	//
	// Timers for retry of routines that should always succeed before continuation
	//
    CTimer  m_RetryAbort1Timer;
    CTimer  m_RetryAbort2Timer;
    CTimer  m_RetryCommit2Timer;
    CTimer  m_RetryCommit3Timer;

	bool m_fReadyForCheckpoint;		// Should the transaction be written to checkpoint?

};


//---------------------------------------------------------------------
// CTransaction::ValidTransQueue
//---------------------------------------------------------------------
inline BOOL CTransaction::ValidTransQueue()
{
	return(m_hTransQueue != INVALID_HANDLE_VALUE);
}

//---------------------------------------------------------------------
// CTransaction::SetTransQueue
//---------------------------------------------------------------------
inline void CTransaction::SetTransQueue(HANDLE hQueue)
{
    m_hTransQueue = hQueue;
}

//---------------------------------------------------------------------
// CTransaction::SignalDone
//---------------------------------------------------------------------
inline void CTransaction::SignalDone(HRESULT hr)
{
	m_DoneHr = hr;
	ASSERT(m_hDoneEvent != 0);
	BOOL b = SetEvent(m_hDoneEvent);
    ASSERT(b);
	DBG_USED(b);
}

// trans queue creation
extern HRESULT XactCreateQueue(HANDLE *phTransQueue, const XACTUOW *puow );


//---------------------------------------------------------------------
// CTransaction::GetUow
//---------------------------------------------------------------------
inline const XACTUOW* CTransaction::GetUow() const
{
    return &m_Entry.m_uow;
}

//---------------------------------------------------------------------
// CTransaction::GetIndex
//---------------------------------------------------------------------
inline ULONG CTransaction::GetIndex(void) const
{
    return m_Entry.m_ulIndex;
}

//---------------------------------------------------------------------
// CTransaction::GetState
//---------------------------------------------------------------------
inline TXSTATE CTransaction::GetState(void) const
{
    return (TXSTATE)(m_Entry.m_ulFlags & XACTION_MASK_STATE);
}

//---------------------------------------------------------------------
// CTransaction::GetFlags
//---------------------------------------------------------------------
inline ULONG CTransaction::GetFlags(void) const
{
    return m_Entry.m_ulFlags;
}

//---------------------------------------------------------------------
// CTransaction::SetFlags
//---------------------------------------------------------------------
inline void CTransaction::SetFlags(ULONG ulFlags)
{
    m_Entry.m_ulFlags = ulFlags;
}

//---------------------------------------------------------------------
// CTransaction::IsReadyForCheckpoint
//---------------------------------------------------------------------
inline bool CTransaction::IsReadyForCheckpoint(void) const
{
    return m_fReadyForCheckpoint;
}

//---------------------------------------------------------------------
// CTransaction::SetReadyForCheckpoint
//---------------------------------------------------------------------
inline void CTransaction::SetReadyForCheckpoint(void)
{
    m_fReadyForCheckpoint = true;
}

extern void QMPreInitXact();

#endif __XACT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\verifysignmqf.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    VerifySignMqf.h

Abstract:
    functions to verify mqf signature 

Author:
    Ilan Herbst (ilanh) 29-Oct-2000

Environment:
    Platform-independent,

--*/

#ifndef _VERIFYSIGNMQF_H_
#define _VERIFYSIGNMQF_H_


void
VerifySignatureMqf(
	CQmPacket *PktPtrs, 
	HCRYPTPROV hProv, 
	HCRYPTKEY hPbKey,
	bool fMarkAuth
	);


#endif // _VERIFYSIGNMQF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\xactdata.cpp ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactData.cpp

Abstract:
    Static GUID definitions for xact processing

Author:
    Alexander Dadiomov (AlexDad)

--*/

#include <stdh.h>

#define   INITGUID	
#include "initguid.h"			   
#include "TXDTC.H"
#include "Xact.h"    
#include "logmgrgu.h"

#include "xactdata.tmh"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\usermap.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    usermap.cpp

Abstract:

    Maps a users to the global groups that they belongs to.

Author:

    Boaz Feldbaum (BoazF) 2-May-1996

--*/

#include "stdh.h"
#include "qmsecutl.h"
#include "cache.h"
#include "mqsec.h"
#include "Authz.h"
#include "autoauthz.h"
#include "mqexception.h"
#include "cm.h"

#include "usermap.tmh"

static WCHAR *s_FN=L"usermap";

const TraceIdEntry UserMap = L"USER MAP";

extern BOOL g_fWorkGroupInstallation;

// A class that holds the group SIDs of a user.
class CSids : public CCacheValue
{
public:
    CSids();

public:
    void SetSidCount(int);  // Define the number of group SIDs
    int GetSidCount() { return m_cSIDs; }; // Get the number of group SIDs
    const void *GetSid(int nSid) { return m_pSIDs[nSid]; }; // Get a certain group SID.
    void SetSid(int nSid, PSID pSid); // Set a certain group SID.
    void Clear(); // Clear the group SIDs.

private:
    ~CSids();

private:
    int m_cSIDs; // Holds the number of SIDs
    PSID *m_pSIDs; // A pointer to a buffer that holds pointers to the SIDs.
};

class CUserSid
{
public:
    CUserSid(); // Constructor.
    CUserSid(const CUserSid &); // Copy constructor.
    ~CUserSid(); // Destractor.

public:
    void SetSid(const void *PSID); // Set the SID.
    const void *GetSid() const; // Get the SID.
    CUserSid& CUserSid::operator=(const CUserSid &UserSid); // Copy the SID when assigning.

private:
    PSID m_pSid;
};

extern LPTSTR  g_szMachineName;

/***************************************************************************

Function:
    CUserSid::CUserSid

Description:
    Constructor. The CUserSid class is used for holding the SID of a user
    in a CMap.

***************************************************************************/
CUserSid::CUserSid()
{
    m_pSid = NULL;
}

/***************************************************************************

Function:
    CUserSid::CUserSid

Description:
    Copy constructor.

***************************************************************************/
CUserSid::CUserSid(const CUserSid &UserSid)
{
    PSID pSid = const_cast<PSID>(UserSid.GetSid());
    DWORD n = GetLengthSid(pSid);

    m_pSid = (PSID)new char[n];
    CopySid(n, m_pSid, pSid);
}

/***************************************************************************

Function:
    CUserSid::CUserSid

Description:
    Destractor.

***************************************************************************/
CUserSid::~CUserSid()
{
    delete[] (char*)m_pSid;
}

/***************************************************************************

Function:
    CUserSid::SetSid

Description:
    Set the SID of the object. Allocate memory for the SID and copy the SID
    into the object.

***************************************************************************/
inline
void CUserSid::SetSid(const void *pSid)
{
    DWORD n = GetLengthSid(const_cast<PSID>(pSid));

    delete[] (char*)m_pSid;

    m_pSid = (PSID)new char[n];
    CopySid(n, m_pSid, const_cast<PSID>(pSid));
}

/***************************************************************************

Function:
    CUserSid::GetSid

Description:
    Get the SID from the object.

***************************************************************************/
inline
const void *CUserSid::GetSid() const
{
    return m_pSid;
}

/***************************************************************************

Function:
    CUserSid::operator=

Description:
    Copy the SID when assigning value from one CUserSid object to another.

***************************************************************************/
inline CUserSid& CUserSid::operator=(const CUserSid &UserSid)
{
    SetSid(UserSid.GetSid());

    return *this;
}

// Calculate the CRC value of a buffer.
inline UINT Crc(BYTE *pBuff, DWORD n)
{
    DWORD i;
    UINT nHash = 0;

    for (i = 0; i < n; i++, pBuff++)
    {
        nHash = (nHash<<5) + nHash + *pBuff;
    }

    return nHash;
}

// Helper function for the CMap.
inline UINT AFXAPI HashKey(const CUserSid &UserSid)
{
    DWORD n = GetLengthSid(const_cast<PSID>(UserSid.GetSid()));

    return Crc((BYTE*)UserSid.GetSid(), n);
}

// Helper function for the CMap.
inline BOOL AFXAPI CompareElements(const CUserSid *pSid1, const CUserSid *pSid2)
{
    return EqualSid(const_cast<PSID>((*pSid1).GetSid()),
                    const_cast<PSID>((*pSid2).GetSid()));
}

inline void AFXAPI DestructElements(CSids **ppSids, int nCount)
{
    for (; nCount--; ppSids++)
    {
        (*ppSids)->Release();
    }
}

/***************************************************************************

Function:
    CSids::CSids

Description:
    Constructor. The CSids class is used for holding an array of SIDs that
    represents the global groups in which a user is a member.

***************************************************************************/
CSids::CSids() :
    m_cSIDs(0),
    m_pSIDs(NULL)
{
}

/***************************************************************************

Function:
    CSids::~CSids

Description:
    Distractor.

***************************************************************************/
CSids::~CSids()
{
    Clear();
}

/***************************************************************************

Function:
    CSids::SetSidCount

Parameter:
    nSids - The number of SIDs in the array.

Description:
    Allocates an array for the SIDs and places a zero in each of the entries.
    If an array already exist it is being freed first.

***************************************************************************/
void CSids::SetSidCount(int nSids)
{
    int i;

    Clear();

    m_pSIDs = new PSID[nSids];
    for (i = 0; i < nSids; i++)
    {
        m_pSIDs[i] = NULL;
    }
    m_cSIDs = nSids;
}

/***************************************************************************

Function:
    CSids::Clear

Description:
    Free all the SIDs in the array and free the array.

***************************************************************************/
void CSids::Clear()
{
    int i;

    if (!m_cSIDs)
        return;

    ASSERT(m_pSIDs);

    for (i = 0; i < m_cSIDs; i++)
        delete[] m_pSIDs[i];

    delete[] m_pSIDs;

    m_pSIDs = NULL;
    m_cSIDs = 0;
}

/***************************************************************************

Function:
    CSids::SetSid

Parameter:
    nSid - The index for the SID.
    pSid - A pointer to the SID.

Description:
    Places an SID in the array of SIDs.

***************************************************************************/
void CSids::SetSid(int nSid, PSID pSid)
{
    DWORD cbSid = GetLengthSid(pSid);

    ASSERT(nSid < m_cSIDs);

    if (m_pSIDs[nSid])
        delete[] m_pSIDs[nSid];

    m_pSIDs[nSid] = (PSID) new char[cbSid];
    CopySid(cbSid, m_pSIDs[nSid], pSid);
}


static
DWORD 
GetAuthzFlags()
/*++

Routine Description:
    Read Authz flags from registry

Arguments:
	None

Return Value:
	Authz flags from registry
--*/
{
	//
	// Reading this registry only at first time.
	//
	static bool s_fInitialized = false;
	static DWORD s_fAuthzFlags = 0;

	if(s_fInitialized)
	{
		return s_fAuthzFlags;
	}

	const RegEntry xRegEntry(MSMQ_AUTHZ_FLAGS_REGKEY, MSMQ_AUTHZ_FLAGS_REGVALUE, 0);
	CmQueryValue(xRegEntry, &s_fAuthzFlags);

	s_fInitialized = true;

	return s_fAuthzFlags;
}

//
// ISSUE-2001/04/15-ilanh Temporary registry that enable
// mask the failure ASSERT of AuthzInitializeContextFromSid()
//

static DWORD MaskAuthzAssert()
/*++

Routine Description:
    Read MaskAuthzAssert registry

Arguments:
	None

Return Value:
	registry value, 0 if not exist
--*/
{
	//
	// Reading this registry only at first time.
	//
	static bool s_fInitialized = false;
	static DWORD s_fMaskAuthzAssert = 0;

	if(s_fInitialized)
	{
		return s_fMaskAuthzAssert;
	}

	const RegEntry xRegEntry(TEXT("security"), TEXT("MaskAuthzAssert"), 0);
	CmQueryValue(xRegEntry, &s_fMaskAuthzAssert);

	s_fInitialized = true;
	return s_fMaskAuthzAssert;
}


static
bool
MaskAuthzAssert(
	DWORD gle
	)
/*++

Routine Description:
    Check if we should mask authz assert

Arguments:
	gle - GetLastError() value

Return Value:
	true if we should mask the assert
--*/
{
	return ((gle & MaskAuthzAssert()) == gle);
}


static CAUTHZ_RESOURCE_MANAGER_HANDLE s_ResourceManager;


static 
AUTHZ_RESOURCE_MANAGER_HANDLE 
GetResourceManager()
/*++

Routine Description:
	Get Resource Manager for authz.
	can throw bad_win32_error() if AuthzInitializeResourceManager() fails.

Arguments:
	None.

Returned Value:
	AUTHZ_RESOURCE_MANAGER_HANDLE	
	
--*/
{
    if(s_ResourceManager != NULL)
	{
		return s_ResourceManager;
	}

	//
    // Initilize RM for Access check
	//
	CAUTHZ_RESOURCE_MANAGER_HANDLE ResourceManager;
	if(!AuthzInitializeResourceManager(
			0,
			NULL,
			NULL,
			NULL,
			0,
			&ResourceManager 
			))
	{
		DWORD gle = GetLastError();
	    TrERROR(UserMap, "AuthzInitializeResourceManager() failed, gle = 0x%x", gle);
        LogHR(HRESULT_FROM_WIN32(gle), s_FN, 90);

	    ASSERT(("AuthzInitializeResourceManager failed", 0));
		throw bad_win32_error(gle);
	}

	if(NULL == InterlockedCompareExchangePointer(
					reinterpret_cast<PVOID*>(&s_ResourceManager), 
					ResourceManager, 
					NULL
					))
	{
		//
		// The exchange was done
		// Only the thread that perform the assignment should assign the size.
		//
		ASSERT(s_ResourceManager == ResourceManager);
		ResourceManager.detach();

	}

	ASSERT(s_ResourceManager != NULL);
	return s_ResourceManager;
}

//
// A cache object that maps from a user SID to AUTHZ_CLIENT_CONTEXT_HANDLE
//
static CCache <CUserSid, const CUserSid&, PCAuthzClientContext, PCAuthzClientContext> g_UserAuthzContextMap;

void
GetClientContext(
	PSID pSenderSid,
    USHORT uSenderIdType,
	PCAuthzClientContext* ppAuthzClientContext
	)
/*++

Routine Description:
	Get Client context from sid.
	can throw bad_win32_error() if AuthzInitializeContextFromSid() fails.

Arguments:
	pSenderSid - pointer to the sender sid 
	uSenderIdType - sender sid type
	ppAuthzClientContext - pointer to authz client context cache value

Returned Value:
	AUTHZ_CLIENT_CONTEXT_HANDLE	
	
--*/
{
	bool fAnonymous = false;
	PSID pSid = NULL;
	
	//
	// For MQMSG_SENDERID_TYPE_SID, MQMSG_SENDERID_TYPE_QM
	// if the message is not signed we trust the information that
	// is in the packet regarding the sid.
	// this is a security hole.
	// this is true for msmq messages (not http messages).
	// In order to solve this security hole, we can reverse the order of receiving
	// msmq messages in session.cpp\VerifyRecvMsg() 
	// first check the signature, if the message is not signed replace the 
	// pSenderSid to NULL, and uSenderIdType to MQMSG_SENDERID_TYPE_NONE.
	//

	DWORD Flags = GetAuthzFlags();
	switch (uSenderIdType)
	{
		case MQMSG_SENDERID_TYPE_NONE:
			fAnonymous = true;
			pSid = MQSec_GetAnonymousSid();
			break;

		case MQMSG_SENDERID_TYPE_SID:
			pSid = pSenderSid;
			break;

		case MQMSG_SENDERID_TYPE_QM:
			//
			// QM is considered as Everyone
			// pSenderSid in this case will be the sending QM guid.
			// which is meaningless as a sid
			//
			pSid = MQSec_GetWorldSid();

			//
			// ISSUE-2001/06/12-ilanh Temporary workaround
			// for Authz failure for everyone sid.
			// need to specify AUTHZ_SKIP_TOKEN_GROUPS 
			// till Authz will fixed the bug regarding well known sids.
			// bug 8190
			//
			Flags |= AUTHZ_SKIP_TOKEN_GROUPS;

			break;

		default:
		    TrERROR(UserMap, "illegal SenderIdType %d", uSenderIdType);
			ASSERT(("illegal SenderIdType", 0));
			throw bad_win32_error(ERROR_INVALID_SID);
	}

	ASSERT((pSid != NULL) && IsValidSid(pSid));

	TrTRACE(UserMap, "SenderIdType = %d, Sender sid = %!sid!", uSenderIdType, pSid);

	CUserSid UserSid;
	UserSid.SetSid(pSid);

    CS lock(g_UserAuthzContextMap.m_cs);

	if (g_UserAuthzContextMap.Lookup(UserSid, *ppAuthzClientContext))
	{
		return;
	}

	if(g_fWorkGroupInstallation)
	{ 
		//
		// For workgroup or offline scenario you must specify 
		// AUTHZ_SKIP_TOKEN_GROUPS, otherwise AuthzInitializeContextFromSid()
		// will fail
		//
		Flags |= AUTHZ_SKIP_TOKEN_GROUPS;
	}

	LUID luid = {0};
	R<CAuthzClientContext> pAuthzClientContext = new CAuthzClientContext;

	if(!AuthzInitializeContextFromSid(
			Flags,
			pSid,
			GetResourceManager(),
			NULL,
			luid,
			NULL,
			&pAuthzClientContext->m_hAuthzClientContext
			))
	{
		DWORD gle = GetLastError();
	    TrERROR(UserMap, "AuthzInitializeContextFromSid() failed, gle = 0x%x", gle);
        LogHR(HRESULT_FROM_WIN32(gle), s_FN, 10);

		//
		// ISSUE-2001/04/15-ilanh Temporary registry that enable
		// mask the failure ASSERT of AuthzInitializeContextFromSid()
		// ERROR_NO_SUCH_DOMAIN, RPC_S_SERVER_UNAVAILABLE - offline scenario is legitimate error.
		// so we don't want the ASSERT in that case
		//
		if((gle != ERROR_NO_SUCH_DOMAIN) && 
		   (gle != RPC_S_SERVER_UNAVAILABLE) &&
		   (!MaskAuthzAssert(gle)))
		{
			ASSERT_BENIGN(("AuthzInitializeContextFromSid failed", 0));
		}

		throw bad_win32_error(gle);
	}

	g_UserAuthzContextMap.SetAt(UserSid, pAuthzClientContext.get());
	*ppAuthzClientContext = pAuthzClientContext.detach();
}


//
// Initialize the cache parameters for the users map.
//
void
InitUserMap(
    CTimeDuration CacheLifetime,
    DWORD dwUserCacheSize
    )
{
    g_UserAuthzContextMap.m_CacheLifetime = CacheLifetime;
    g_UserAuthzContextMap.InitHashTable(dwUserCacheSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\xactmode.h ===
/*++
    Copyright (c) 1998  Microsoft Corporation

Module Name:
    xactmode.h

Abstract:
    This module deals with figuring out the transactional mode
	(g_fDefaultCommit)

Author:
    Amnon Horowitz (amnonh)

--*/

extern BOOL	g_fDefaultCommit;
NTSTATUS	ConfigureXactMode();
void		ReconfigureXactMode();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\xactin.cpp ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactIn.cpp

Abstract:
    Incoming Sequences objects implementation

Author:
    Alexander Dadiomov (AlexDad)

--*/

#include "stdh.h"
#include "Xact.h"
#include "XactStyl.h"
#include "QmThrd.h"
#include "acapi.h"
#include "qmpkt.h"
#include "qmutil.h"
#include "qformat.h"
#include "cqmgr.h"
#include "privque.h"
#include "xactstyl.h"
#include "xactping.h"
#include "xactrm.h"
#include "xactout.h"
#include "xactin.h"
#include "xactlog.h"
#include "xactunfr.h"
#include "fntoken.h"
#include "mqformat.h"
#include "uniansi.h"
#include "mqstl.h"
#include "mp.h"
#include "fn.h"

#include "xactin.tmh"

#define INSEQS_SIGNATURE         0x1234
const GUID xSrmpKeyGuidFlag = {0xd6f92979,0x16af,0x4d87,0xb3,0x57,0x62,0x3e,0xae,0xd6,0x3e,0x7f};
const char xXactIn[] = "XactIn"; 


// Default value for the order ack delay
DWORD CInSeqHash::m_dwIdleAckDelay = MSMQ_DEFAULT_IDLE_ACK_DELAY;
DWORD CInSeqHash::m_dwMaxAckDelay  = FALCON_MAX_SEQ_ACK_DELAY;

static BOOL  s_ReceivingState = FALSE;

static WCHAR *s_FN=L"xactin";

static XactDirectType GetDirectType(QUEUE_FORMAT *pqf)
{
	if(FnIsDirectHttpFormatName(pqf))
	{
		return dtxHttpDirectFlag;	
	}
	if(pqf->GetType() == QUEUE_FORMAT_TYPE_DIRECT)
	{
		return dtxDirectFlag;		
	}
	return 	dtxNoDirectFlag;
}

static R<CWcsRef> SafeGetStreamId(const CQmPacket& Pkt)
{
	if(!Pkt.IsEodIncluded())
		return R<CWcsRef>(NULL);

	const WCHAR* pStreamId = reinterpret_cast<const WCHAR*>(Pkt.GetPointerToEodStreamId());
	ASSERT(pStreamId != NULL);
	ASSERT(ISALIGN2_PTR(pStreamId));
	ASSERT(Pkt.GetEodStreamIdSizeInBytes() == (wcslen(pStreamId) + 1)*sizeof(WCHAR));

	return 	R<CWcsRef>(new CWcsRef(pStreamId));
}


static R<CWcsRef> SafeGetOrderQueue(const CQmPacket& Pkt)
{
	if(!Pkt.IsEodIncluded())
		return R<CWcsRef>(NULL);

	if(Pkt.GetEodOrderQueueSizeInBytes() == 0)
		return R<CWcsRef>(NULL);

	const WCHAR* pOrderQueue = reinterpret_cast<const WCHAR*>(Pkt.GetPointerToEodOrderQueue());
	ASSERT(pOrderQueue != NULL);
	ASSERT(ISALIGN2_PTR(pOrderQueue));
	ASSERT(Pkt.GetEodOrderQueueSizeInBytes() == (wcslen(pOrderQueue) + 1)*sizeof(WCHAR));

	return 	R<CWcsRef>(new CWcsRef(pOrderQueue));
}





//---------------------------------------------------------
//
//  Global object (single instance for DLL)
//
//---------------------------------------------------------
CInSeqHash *g_pInSeqHash = NULL;

//--------------------------------------
//
// Class  CKeyInSeq
//
//--------------------------------------
CKeyInSeq::CKeyInSeq(const GUID *pGuid,
                     QUEUE_FORMAT *pqf,
					 const R<CWcsRef>& StreamId)
{
    IsolateFlushing();
    CopyMemory(&m_Guid, pGuid, sizeof(GUID));
    CopyQueueFormat(m_QueueFormat, *pqf);
	m_StreamId = StreamId;
}


CKeyInSeq::CKeyInSeq()
{
    IsolateFlushing();
    ZeroMemory(&m_Guid, sizeof(GUID));
    m_QueueFormat.UnknownID(NULL);
}




CKeyInSeq::~CKeyInSeq()
{
    IsolateFlushing();
    m_QueueFormat.DisposeString();
}


const GUID  *CKeyInSeq::GetQMID()  const
{
    return &m_Guid;
}


const QUEUE_FORMAT  *CKeyInSeq::GetQueueFormat() const
{
    return &m_QueueFormat;
}


const WCHAR* CKeyInSeq::GetStreamId() const
{
	if(m_StreamId.get() == NULL)
		return NULL;

	ASSERT(m_StreamId->getstr() != NULL);
	return m_StreamId->getstr();
}


static BOOL SaveQueueFormat(const QUEUE_FORMAT& qf, HANDLE hFile)
{
	PERSIST_DATA;
	SAVE_FIELD(qf);
    if (qf.GetType() == QUEUE_FORMAT_TYPE_DIRECT)
    {
        LPCWSTR pw = qf.DirectID();
        ULONG  ul = (wcslen(pw) + 1) * sizeof(WCHAR);

        SAVE_FIELD(ul);
        SAVE_DATA(pw, ul);
    }
	return TRUE;
}



BOOL CKeyInSeq::SaveSrmp(HANDLE hFile)
{
	PERSIST_DATA;
	SAVE_FIELD(xSrmpKeyGuidFlag);
	SaveQueueFormat(m_QueueFormat, hFile);

	ASSERT(m_StreamId->getstr() != NULL);
	ULONG  ul = (wcslen(m_StreamId->getstr()) + 1) * sizeof(WCHAR);
	ASSERT(ul > sizeof(WCHAR));
	SAVE_FIELD(ul);
    SAVE_DATA(m_StreamId->getstr(), ul);
	return TRUE;
}




BOOL CKeyInSeq::SaveNonSrmp(HANDLE hFile)
{
	PERSIST_DATA;
	SAVE_FIELD(m_Guid);
	SaveQueueFormat(m_QueueFormat, hFile);
    return TRUE;
}


BOOL CKeyInSeq::Save(HANDLE hFile)
{
    if(m_StreamId.get() != NULL)
	{
		return SaveSrmp(hFile);
	}
	return SaveNonSrmp(hFile);
	
}

BOOL CKeyInSeq::LoadSrmpStream(HANDLE hFile)
{
	PERSIST_DATA;
	ULONG ul;
    LOAD_FIELD(ul);
	ASSERT(ul > sizeof(WCHAR));

    LPWSTR pw;
    LOAD_ALLOCATE_DATA(pw,ul,PWCHAR);
	m_StreamId = R<CWcsRef>(new CWcsRef(pw, 0));
	ASSERT(ul > sizeof(WCHAR));

	return TRUE;
}

BOOL CKeyInSeq::LoadSrmp(HANDLE hFile)
{
	if(!LoadQueueFormat(hFile))
		return FALSE;


	LoadSrmpStream(hFile);
	return TRUE;
}



static bool IsValidKeyQueueFormatType(QUEUE_FORMAT_TYPE QueueType)
{
	if(QueueType !=  QUEUE_FORMAT_TYPE_DIRECT  && 
	   QueueType !=  QUEUE_FORMAT_TYPE_PRIVATE &&
	   QueueType !=  QUEUE_FORMAT_TYPE_PUBLIC)
	{
		return false;
	}

	return true;
}



BOOL CKeyInSeq::LoadQueueFormat(HANDLE hFile)
{
	PERSIST_DATA;
	LOAD_FIELD(m_QueueFormat);

	if(!IsValidKeyQueueFormatType(m_QueueFormat.GetType()))
	{
		TrERROR(xXactIn, "invalid queue format type %d found in check point file", m_QueueFormat.GetType());
		return FALSE;
	}

    if (m_QueueFormat.GetType() == QUEUE_FORMAT_TYPE_DIRECT)
    {
        ULONG ul;
        LOAD_FIELD(ul);

        LPWSTR pw;
        LOAD_ALLOCATE_DATA(pw,ul,PWCHAR);

        m_QueueFormat.DirectID(pw);
    }
	return TRUE;

}


BOOL CKeyInSeq::LoadNonSrmp(HANDLE hFile)
{
	return LoadQueueFormat(hFile);
}



BOOL CKeyInSeq::Load(HANDLE hFile)
{
    PERSIST_DATA;
    LOAD_FIELD(m_Guid);
	if(m_Guid ==  xSrmpKeyGuidFlag)
	{
		return LoadSrmp(hFile);
	}
	return LoadNonSrmp(hFile);
}

/*====================================================
HashGUID::
    Makes ^ of subsequent double words
=====================================================*/
DWORD HashGUID(const GUID &guid)
{
    return((UINT)guid.Data1);
}


/*====================================================
Hash QUEUE_FROMAT to integer
=====================================================*/
static UINT AFXAPI HashFormatName(const QUEUE_FORMAT* qf)
{
	DWORD dw1 = 0;
	DWORD dw2 = 0;

	switch(qf->GetType())
    {
        case QUEUE_FORMAT_TYPE_UNKNOWN:
            break;

        case QUEUE_FORMAT_TYPE_PUBLIC:
            dw1 = HashGUID(qf->PublicID());
            break;

        case QUEUE_FORMAT_TYPE_PRIVATE:
            dw1 = HashGUID(qf->PrivateID().Lineage);
            dw2 = qf->PrivateID().Uniquifier;
            break;

        case QUEUE_FORMAT_TYPE_DIRECT:
            dw1 = HashKey(qf->DirectID());
            break;

        case QUEUE_FORMAT_TYPE_MACHINE:
            dw1 = HashGUID(qf->MachineID());
            break;
    }
	return dw1 ^ dw2;
}

/*====================================================
Hash srmp key(Streamid, destination queue format)
=====================================================*/
static UINT AFXAPI SrmpHashKey(CKeyInSeq& key)
{
	ASSERT(QUEUE_FORMAT_TYPE_DIRECT == key.GetQueueFormat()->GetType());
	DWORD dw1 = key.GetQueueFormat()->GetType();		
	DWORD dw2 = HashFormatName(key.GetQueueFormat());
	DWORD dw3 = HashKey(key.GetStreamId());

	return dw1 ^ dw2 ^ dw3;
}

/*====================================================
Hash non srmp key(guid, destination queue format)
=====================================================*/
static UINT AFXAPI NonSrmpHashKey(CKeyInSeq& key)
{
    DWORD dw1 = HashGUID(*(key.GetQMID()));
    DWORD dw2 = key.GetQueueFormat()->GetType();
    DWORD dw3 = HashFormatName(key.GetQueueFormat());

    return dw1 ^ dw2 ^ dw3;
}



/*====================================================
HashKey for CKeyInSeq
    Makes ^ of subsequent double words
=====================================================*/
UINT AFXAPI HashKey(CKeyInSeq& key)
{
	if(key.GetStreamId() != NULL)
	{
		return SrmpHashKey(key);
	}
	return NonSrmpHashKey(key);
}


/*====================================================
operator== for CKeyInSeq
=====================================================*/
BOOL operator==(const CKeyInSeq  &key1, const CKeyInSeq &key2)
{
	if(key1.GetStreamId() == NULL &&  key2.GetStreamId() == NULL)
	{
		return ((*key1.GetQMID()        == *key2.GetQMID()) &&
                (*key1.GetQueueFormat() == *key2.GetQueueFormat()));
	}

	if(key1.GetStreamId() == NULL && key2.GetStreamId() != NULL)
		return FALSE;


	if(key2.GetStreamId() == NULL && key1.GetStreamId() != NULL)
		return FALSE;

	return (wcscmp(key1.GetStreamId(), key2.GetStreamId()) == 0 &&
		    *key1.GetQueueFormat() == *key2.GetQueueFormat());
}

/*====================================================												
operator= for CKeyInSeq
    Reallocates direct id string
=====================================================*/
CKeyInSeq &CKeyInSeq::operator=(const CKeyInSeq &key2 )
{
	m_StreamId = key2.m_StreamId;
    m_Guid = key2.m_Guid;
    CopyQueueFormat(m_QueueFormat, key2.m_QueueFormat);
	return *this;
}

//---------------------------------------------------------
//
//  class CInSequence
//
//---------------------------------------------------------


#pragma warning(disable: 4355)  // 'this' : used in base member initializer list
/*====================================================
CInSequence::CInSequence
    Constructs In Sequence
=====================================================*/
CInSequence::CInSequence(const CKeyInSeq &key,
                         const LONGLONG liSeqID,
                         const ULONG ulSeqN,
                         XactDirectType  DirectType,
                         const GUID  *pgTaSrcQm,
						 const R<CWcsRef>&  HttpOrderAckQueue) :
    m_Unfreezer(this),
    m_fSendOrderAckScheduled(FALSE),
    m_SendOrderAckTimer(TimeToSendOrderAck),
	m_HttpOrderAckQueue(HttpOrderAckQueue)
{
    IsolateFlushing();
    m_liSeqIDVer    = liSeqID;
    m_ulLastSeqNVer = ulSeqN;
    m_DirectType    = DirectType;
    m_key           = key;

    if (DirectType == dtxDirectFlag)
    {
        CopyMemory(&m_gDestQmOrTaSrcQm, pgTaSrcQm, sizeof(GUID));
    }

    time(&m_timeLastActive);
    time(&m_timeLastAccess);
    time(&m_timeLastAck);

    m_AdminRejectCount = 0;
}



/*====================================================
CInSequence::CInSequence
    Empty Constructor with a key
=====================================================*/
CInSequence::CInSequence(const CKeyInSeq &key)
  : m_Unfreezer(this),
    m_fSendOrderAckScheduled(FALSE),
    m_SendOrderAckTimer(TimeToSendOrderAck)
{
    IsolateFlushing();
    m_liSeqIDVer    = 0;
    m_ulLastSeqNVer = 0;
    m_timeLastActive= 0;
    time(&m_timeLastAccess);
    m_timeLastAck   = 0;
    m_DirectType    = dtxNoDirectFlag;
    m_key           = key;
	m_AdminRejectCount = 0;
}
#pragma warning(default: 4355)  // 'this' : used in base member initializer list

/*====================================================
CInSequence::~CInSequence
    Destructs In Sequence
=====================================================*/
CInSequence::~CInSequence()
{
    if (m_fSendOrderAckScheduled)
    {
        ExCancelTimer(&m_SendOrderAckTimer);
    }
}




/*====================================================
CInSequence::SeqIDVer
    Get for Sequence ID verified
=====================================================*/
LONGLONG CInSequence::SeqIDVer() const
{
    return m_liSeqIDVer;
}

/*====================================================
CInSequence::SeqIDReg
    Get for Sequence ID registered
=====================================================*/
LONGLONG CInSequence::SeqIDReg() const
{
    return m_Unfreezer.SeqIDReg();
}

/*====================================================
CInSequence::SeqNVer
    Get for last verified seq number
=====================================================*/
ULONG  CInSequence::SeqNVer() const
{
    return m_ulLastSeqNVer;
}

/*====================================================
CInSequence::SeqNReg
    Get for last registered seq number
=====================================================*/
ULONG  CInSequence::SeqNReg() const
{
    return m_Unfreezer.SeqNReg();
}

/*====================================================
CInSequence::LastActive
Get for time of last activity: last msg verified and passed
=====================================================*/
time_t CInSequence::LastActive() const
{
    return m_timeLastActive;
}

/*====================================================
CInSequence::LastAccessed
Get for time of last activuty: last msg verified, maybe rejected
=====================================================*/
time_t CInSequence::LastAccessed() const
{
    return m_timeLastAccess;
}

/*====================================================
CInSequence::LastAcked
Get for time of last order ack sending
=====================================================*/
time_t CInSequence::LastAcked() const
{
    return m_timeLastAck;
}

/*====================================================
CInSequence::SetSourceQM
Set for SourceQM TA_Address (or Destination QM Guid)
=====================================================*/
void CInSequence::SetSourceQM(const GUID  *pgTaSrcQm)
{
    CopyMemory(&m_gDestQmOrTaSrcQm, pgTaSrcQm, sizeof(GUID));
}

/*====================================================
CInSequence::RenewHttpOrderAckQueue
Renew http order queue 
=====================================================*/
void  CInSequence::RenewHttpOrderAckQueue(const R<CWcsRef>& OrderAckQueue)
{
	CS lock(m_critInSeq);
	m_HttpOrderAckQueue = OrderAckQueue;	
}


/*====================================================
CInSequence::SetSourceQM
Accounts for the rejects - for statistics, perf, admin
=====================================================*/
void CInSequence::UpdateRejectCounter(BOOL b)
{
	m_AdminRejectCount = (b ?  0 : m_AdminRejectCount+1);
}

/*====================================================
CInSequence::TimeToSendOrderAck
    Sends adequate Seq Ack
=====================================================*/
void WINAPI CInSequence::TimeToSendOrderAck(CTimer* pTimer)
{
    CInSequence* pInSeq = CONTAINING_RECORD(pTimer, CInSequence, m_SendOrderAckTimer);

    pInSeq->SendAdequateOrderAck();
}



static
HRESULT
SendSrmpXactAck(
		OBJECTID   *pMessageId,
        const WCHAR* pHttpOrderAckQueue,
		const WCHAR* pStreamId,
		USHORT     usClass,
		USHORT     usPriority,
		LONGLONG   liSeqID,
		ULONG      ulSeqN,
		ULONG      ulPrevSeqN,
		const QUEUE_FORMAT *pqdDestQueue
		)
{
	ASSERT(usClass == MQMSG_CLASS_ORDER_ACK);
	ASSERT(pStreamId != NULL);
	ASSERT(pHttpOrderAckQueue != NULL);


	DBGMSG((DBGMOD_XACT_RCV,  DBGLVL_INFO,
            _T("Exactly1 receive: Sending status ack: Class=%x, SeqID=%x / %x, SeqN=%d ."),
            usClass, HighSeqID(liSeqID), LowSeqID(liSeqID), ulSeqN));

    //
    // Create Message property on stack
    // with the correlation holding the original packet ID
    //
    CMessageProperty MsgProperty(
							usClass,
							(PUCHAR) pMessageId,
							usPriority,
							MQMSG_DELIVERY_EXPRESS
							);

    MsgProperty.dwTitleSize     = STRLEN(ORDER_ACK_TITLE) +1 ;
    MsgProperty.pTitle          = ORDER_ACK_TITLE;
    MsgProperty.bDefProv        = TRUE;
	MsgProperty.pEodAckStreamId = (UCHAR*)pStreamId;
	MsgProperty.EodAckStreamIdSizeInBytes = (wcslen(pStreamId) + 1) * sizeof(WCHAR);
	MsgProperty.EodAckSeqId  = liSeqID;
	MsgProperty.EodAckSeqNum =	ulSeqN;

	QUEUE_FORMAT XactQueue;
	XactQueue.DirectID(const_cast<WCHAR*>(pHttpOrderAckQueue));
	HRESULT hr = QmpSendPacket(&MsgProperty,&XactQueue, NULL, pqdDestQueue);
	return LogHR(hr, s_FN, 11);
}


/*====================================================
CInSequence::TimeToSendOrderAck
    Sends adequate Seq Ack
=====================================================*/
void CInSequence::SendAdequateOrderAck()
{
    HRESULT  hr = MQ_ERROR;
    OBJECTID MsgId;
    CS lock(m_critInSeq);

    RememberActivation();

    m_fSendOrderAckScheduled = FALSE;

	if(SeqNReg() == 0)
   		return;
   		
	

    DBGMSG((DBGMOD_XACT_RCV,
            DBGLVL_INFO,
            _T("Exactly1 receive: SendXactAck MQMSG_CLASS_ORDER_ACK:SeqID=%x / %x, SeqN=%d ."),
            HighSeqID(SeqIDReg()), LowSeqID(SeqIDReg()),
            SeqNReg()));

	if(m_DirectType == dtxHttpDirectFlag)
	{
		ASSERT(m_HttpOrderAckQueue.get() != NULL);
		ASSERT(m_key.GetStreamId() != NULL);

		hr = SendSrmpXactAck(
				&MsgId,
				m_HttpOrderAckQueue->getstr(),
				m_key.GetStreamId(),
				MQMSG_CLASS_ORDER_ACK,
				0,
				SeqIDReg(),
				SeqNReg(),
				SeqNReg()-1,
				m_key.GetQueueFormat());
	}
	else
	{

		//  Send SeqAck (non srmp)
		hr = SendXactAck(
					&MsgId,
					m_DirectType == dtxDirectFlag,
					m_key.GetQMID(),
					&m_taSourceQM,
					MQMSG_CLASS_ORDER_ACK,
					0,
					SeqIDReg(),
					SeqNReg(),
					SeqNReg()-1,
					m_key.GetQueueFormat());
	}
    if (SUCCEEDED(hr))
    {
        time(&m_timeLastAck);
    }
    return;
}

/*====================================================
CInSequence::PlanOrderAck
    Plans sending adequate Seq Ack
=====================================================*/
void CInSequence::PlanOrderAck()
{
    CS lock(m_critInSeq);

    // Get current time
    time_t tNow;
    time(&tNow);

    // Plan next order ack for m_dwIdleAckDelay from now,
    //   this saves extra order acking (batches )
    // But do not delay order ack too much,
    //   otherwise sender will switch to resend
    //
    if (m_fSendOrderAckScheduled &&
        tNow - m_timeLastAck < (time_t)CInSeqHash::m_dwMaxAckDelay)
    {
        if (ExCancelTimer(&m_SendOrderAckTimer))
        {
            m_fSendOrderAckScheduled = FALSE;
        }
    }

    if (!m_fSendOrderAckScheduled)
    {
        ExSetTimer(&m_SendOrderAckTimer, CTimeDuration::FromMilliSeconds(CInSeqHash::m_dwIdleAckDelay));
        m_fSendOrderAckScheduled = TRUE;
    }
}

/*====================================================
CInSequence::Advance
    If SeqID changed, sets it and resets counter to 1
=====================================================*/
void CInSequence::Advance(LONGLONG liSeqID, ULONG ulSeqN, BOOL fPropagate)
{
    //ASSERT(   liSeqID >=  m_liSeqIDVer);
    IsolateFlushing();

    if (liSeqID >  m_liSeqIDVer)
    {
        m_liSeqIDVer    = liSeqID;
        m_ulLastSeqNVer = ulSeqN;
    }
    else if (liSeqID == m_liSeqIDVer &&
             ulSeqN  >  m_ulLastSeqNVer)
    {
        m_ulLastSeqNVer = ulSeqN;
    }

    if (fPropagate)
    {
        // Called at recovery time
        m_Unfreezer.Recover(m_ulLastSeqNVer, m_liSeqIDVer);
    }

    time(&m_timeLastActive);
}

void CInSequence::RememberActivation()
{
    time(&m_timeLastAccess);
}

void CInSequence::SortedUnfreeze(CInSeqFlush *pInSeqFlush,
                                 const GUID  *pSrcQMId,
                                 const QUEUE_FORMAT *pqdDestQueue)
{
    m_Unfreezer.SortedUnfreeze(pInSeqFlush, pSrcQMId, pqdDestQueue);
}

BOOL CInSequence::Save(HANDLE hFile)
{
    PERSIST_DATA;
    LONGLONG  liIDReg = SeqIDReg();
    ULONG     ulNReg  = SeqNReg();

    SAVE_FIELD(liIDReg);
    SAVE_FIELD(ulNReg);
    SAVE_FIELD(m_timeLastActive);
    SAVE_FIELD(m_DirectType);
    SAVE_FIELD(m_gDestQmOrTaSrcQm);

	//
	// If no direct http - no order queue to save
	//
	if(m_DirectType != dtxHttpDirectFlag)
		return TRUE;
	
	//
	//Save order queue url
	//
	DWORD len = (DWORD)(m_HttpOrderAckQueue.get() ?  (wcslen(m_HttpOrderAckQueue->getstr()) +1)*sizeof(WCHAR) : 0);

	SAVE_FIELD(len);
	if(len != 0)
	{
		SAVE_DATA(m_HttpOrderAckQueue->getstr(), len);
	}

    return TRUE;
}

BOOL CInSequence::Load(HANDLE hFile)
{
    PERSIST_DATA;
    LONGLONG  liIDReg;
    ULONG     ulNReg;

    LOAD_FIELD(liIDReg);
    m_liSeqIDVer = liIDReg;

    LOAD_FIELD(ulNReg);
    m_ulLastSeqNVer = ulNReg;

    // Unfreezer should be set in a same way, because the freezing bit does not survive reboot
    m_Unfreezer.Recover(ulNReg, liIDReg);

    LOAD_FIELD(m_timeLastActive);
	m_timeLastAccess = m_timeLastActive;
    LOAD_FIELD(m_DirectType);
    LOAD_FIELD(m_gDestQmOrTaSrcQm);

	if(m_DirectType == dtxHttpDirectFlag)
	{
		DWORD OrderQueueStringSize;
		LOAD_FIELD(OrderQueueStringSize);
		LPWSTR pHttpOrderAckQueue;
		if(OrderQueueStringSize != 0)
		{
			LOAD_ALLOCATE_DATA(pHttpOrderAckQueue, OrderQueueStringSize, PWCHAR);
			m_HttpOrderAckQueue =   R<CWcsRef>(new CWcsRef(pHttpOrderAckQueue, 0));
		}
	}
		

    DBGMSG((DBGMOD_XACT_RCV,
            DBGLVL_INFO,
            _TEXT("Exactly1 receive restore: Sequence %x / %x, LastSeqN=%d"),
            HighSeqID(m_liSeqIDVer), LowSeqID(m_liSeqIDVer), m_ulLastSeqNVer));

    return TRUE;
}

//--------------------------------------
//
// Class  CInSeqHash
//
//--------------------------------------

#pragma warning(disable: 4355)  // 'this' : used in base member initializer list
/*====================================================
CInSeqHash::CInSeqHash
    Constructor
=====================================================*/
CInSeqHash::CInSeqHash() :
    m_fCleanupScheduled(FALSE),
    m_CleanupTimer(TimeToCleanupDeadSequence),
    m_PingPonger(this,
                 FALCON_DEFAULT_INSEQFILE_PATH,
                 FALCON_INSEQFILE_PATH_REGNAME,
                 FALCON_INSEQFILE_REFER_NAME)
{
    DWORD dwDef1 = MSMQ_DEFAULT_IDLE_ACK_DELAY;
    READ_REG_DWORD(m_dwIdleAckDelay,
                  MSMQ_IDLE_ACK_DELAY_REGNAME,
                  &dwDef1 ) ;

    DWORD dwDef2 = FALCON_MAX_SEQ_ACK_DELAY;
    READ_REG_DWORD(m_dwMaxAckDelay,
                  FALCON_MAX_SEQ_ACK_DELAY_REGNAME,
                  &dwDef2 ) ;

    DWORD dwDef3 = FALCON_DEFAULT_INSEQS_CHECK_INTERVAL;
    READ_REG_DWORD(m_ulRevisionPeriod,
                  FALCON_INSEQS_CHECK_REGNAME,
                  &dwDef3 ) ;

    m_ulRevisionPeriod *= 60;

    DWORD dwDef4 = FALCON_DEFAULT_INSEQS_CLEANUP_INTERVAL;
    READ_REG_DWORD(m_ulCleanupPeriod,
                  FALCON_INSEQS_CLEANUP_REGNAME,
                  &dwDef4 ) ;

    m_ulCleanupPeriod *= (24 * 60 *60);

    m_bFinishing = FALSE;
}
#pragma warning(default: 4355)  // 'this' : used in base member initializer list

/*====================================================
CInSeqHash::~CInSeqHash
    Destructor
=====================================================*/
CInSeqHash::~CInSeqHash()
{
    m_bFinishing = TRUE;

    if (m_fCleanupScheduled)
    {
        ExCancelTimer(&m_CleanupTimer);
    }
}

/*====================================================
CInSeqHash::Destroy
    Destroys everything
=====================================================*/
void CInSeqHash::Destroy()
{
    CS lock(m_critInSeqHash);

    POSITION posInList = m_mapInSeqs.GetStartPosition();
    while (posInList != NULL)
    {
        CKeyInSeq    key;
        CInSequence *pInSeq;

        m_mapInSeqs.GetNextAssoc(posInList, key, pInSeq);

        m_mapInSeqs.RemoveKey(key);
        delete pInSeq;
   }
}

/*====================================================
CInSeqHash::Lookup
    Looks for the InSequence; TRUE = Found
=====================================================*/
BOOL CInSeqHash::Lookup(
       const GUID    *pQMID,
       QUEUE_FORMAT  *pqf,
	   const R<CWcsRef>&  StreamId,
       CInSequence  **ppInSeq)
{
    CS lock(m_critInSeqHash);

    CInSequence *pInSeq;
    CKeyInSeq    key(pQMID,  pqf ,StreamId);

    if (m_mapInSeqs.Lookup(key, pInSeq))
    {
        if (ppInSeq)
        {
            *ppInSeq = pInSeq;
        }
        pInSeq->RememberActivation();
        return TRUE;
    }

    return FALSE;
}

/*====================================================
CInSeqHash::Add
    Looks for / Adds new InSequence to the hash; FALSE=existed before
=====================================================*/
BOOL CInSeqHash::Add(
       const GUID   *pQMID,
       QUEUE_FORMAT *pqf,
       LONGLONG      liSeqID,
       ULONG         ulSeqN,
       BOOL          fPropagate,
       XactDirectType   DirectType,
       const GUID   *pgTaSrcQm,
	   const R<CWcsRef>&  HttpOrderAckQueue,
	   const R<CWcsRef>&  StreamId)
{
    CInSequence *pInSeq;
    CS           lock(m_critInSeqHash);
    CKeyInSeq    key(pQMID,  pqf ,StreamId);
    IsolateFlushing();

	ASSERT(!( StreamId.get() != NULL && !FnIsDirectHttpFormatName(pqf)) );
	ASSERT(!( StreamId.get() == NULL && FnIsDirectHttpFormatName(pqf)) );


    // lookup for existing
    if (m_mapInSeqs.Lookup(key, pInSeq))
    {
        pInSeq->Advance(liSeqID, ulSeqN, fPropagate);
        return FALSE;
    }

	//
	// We don't allow new entry to be created without order queue
	//
	if(StreamId.get() != NULL &&  HttpOrderAckQueue.get() == NULL)
	{
		return FALSE;
	}

	
    // Adding new CInSequence
    pInSeq = new CInSequence(key, liSeqID, ulSeqN, DirectType, pgTaSrcQm, HttpOrderAckQueue);

    m_mapInSeqs.SetAt(key, pInSeq);
    if (!m_fCleanupScheduled)
    {
        ExSetTimer(&m_CleanupTimer, CTimeDuration::FromMilliSeconds(m_ulRevisionPeriod * 1000));
        m_fCleanupScheduled = TRUE;
    }

    if (fPropagate)
    {
        pInSeq->Advance(liSeqID, ulSeqN, fPropagate);
    }

    DBGMSG((DBGMOD_XACT_RCV,
            DBGLVL_INFO,
            _TEXT("Exactly1 receive: Adding new sequence: SeqID=%x / %x"),
            HighSeqID(liSeqID), LowSeqID(liSeqID)));

    return TRUE;
}



/*====================================================
CInSeqHash::Verify
    Verifies that the packet is valid for ordering
    Returns TRUE if the packet should be put into the queue
=====================================================*/
BOOL CInSeqHash::Verify(
						CQmPacket* pPkt
						)
{
    ASSERT(pPkt);
    QUEUE_FORMAT qf;

    // Get destination queue format name
    if (!pPkt->GetDestinationQueue(&qf))
    {
        ASSERT(FALSE);
        return FALSE;
        // BUGBUG: can it occur ?
    }

    LONGLONG      liSeqID  = pPkt->GetSeqID();
    ULONG          ulSeqN  = pPkt->GetSeqN();
    ULONG      ulPrevSeqN  = pPkt->GetPrevSeqN();
    const GUID *gSenderID  = pPkt->GetSrcQMGuid();
    const GUID   *gDestID  = pPkt->GetDstQMGuid();  // For direct: keeps source address
    CInSequence *pInSeq    = NULL;
    BOOL              b    = FALSE;


	XactDirectType   DirectType = GetDirectType(&qf);
  	R<CWcsRef> OrderAckQueue = SafeGetOrderQueue(*pPkt);
	R<CWcsRef> StreamId = SafeGetStreamId(*pPkt);
	

    if (!m_bFinishing)
    {
         // Regular non-aborted message. Checking by numbers.
        if (!Lookup(gSenderID, &qf, StreamId ,&pInSeq))
        {
            //It is a new direction (QMID*QFormat)
            b = (ulPrevSeqN == 0);

            // Is it a wrong message from new direction?
            if (!b)
            {
				
                // Adding sequence so that SeqAck/0 will be sent: otherwise no emergency detection
                Add(
				gSenderID,
				&qf,
				liSeqID,
				0,
				FALSE,
				DirectType,
				gDestID,
				OrderAckQueue,
				StreamId
				);
				//
				// retrieve the pInSeq
				//
				Lookup(gSenderID, &qf, StreamId, &pInSeq);
            }
        }
        else
        {
            // It is a known direction.
            b = VerifyPlace(ulSeqN,
                            ulPrevSeqN,
                            liSeqID,
                            pInSeq->SeqNVer(),
                            pInSeq->SeqIDVer());

            // Update reject statistics
            pInSeq->UpdateRejectCounter(b);

            // Renew the source TA_ADDRESS (it could change from previous message)
            if (DirectType == dtxDirectFlag)
            {
                pInSeq->SetSourceQM(gDestID);   // DestID union keeps the source QM TA_Address
            }

			//
			//On http - Renew order queue if we have new one on the packet
			//
			if(DirectType ==  dtxHttpDirectFlag && OrderAckQueue.get() != NULL)
			{
				pInSeq->RenewHttpOrderAckQueue(OrderAckQueue);
			}
        }

        if (b)
        {
            // Look for the sequence or create one
            Add(
			gSenderID,
			&qf,
			liSeqID,
			ulSeqN,
			FALSE,
			DirectType,
			gDestID,
			OrderAckQueue,
			StreamId
			);
        }

        //
        // Plan sending order ack (delayed properly)
        // we should send it even after reject, otherwise lost ack will
        //  cause a problem.
        //
        if (pInSeq == NULL)
        {
		    Lookup(gSenderID, &qf, StreamId, &pInSeq);
        }
        if (pInSeq != NULL)
        {
            pInSeq->PlanOrderAck();
        }

    }

    DBGMSG((DBGMOD_XACT_RCV,
            DBGLVL_WARNING,
            _TEXT("Exactly1 receive: Verify packet: SeqID=%x / %x, SeqN=%d, Prev=%d. %ls"),
            HighSeqID(liSeqID), LowSeqID(liSeqID),
            ulSeqN,
            ulPrevSeqN,
            (b ? _TEXT("PASS") : _TEXT("REJECT"))));

    if (b != s_ReceivingState)
    {
        DBGMSG((DBGMOD_XACT_RCV,
                DBGLVL_WARNING,
                _TEXT("Exactly1 receive: SeqID=%x / %x, SeqN=%d, Prev=%d. %ls"),
                HighSeqID(liSeqID), LowSeqID(liSeqID),
                ulSeqN,
                ulPrevSeqN,
                (b ? _TEXT("PASS") : _TEXT("REJECT"))));
        s_ReceivingState = b;
    }

    return b;
}



/*====================================================
SendXactAck
    Sends Seq.Ack or status update to the source QM
=====================================================*/
HRESULT SendXactAck(OBJECTID   *pMessageId,
                    bool    fDirect,
					const GUID *pSrcQMId,
                    const TA_ADDRESS *pa,
                    USHORT     usClass,
                    USHORT     usPriority,
                    LONGLONG   liSeqID,
                    ULONG      ulSeqN,
                    ULONG      ulPrevSeqN,
                    const QUEUE_FORMAT *pqdDestQueue)
{

    OrderAckData    OrderData;
    HRESULT hr;

    DBGMSG((DBGMOD_XACT_RCV,  DBGLVL_INFO,
            _T("Exactly1 receive: Sending status ack: Class=%x, SeqID=%x / %x, SeqN=%d ."),
            usClass, HighSeqID(liSeqID), LowSeqID(liSeqID), ulSeqN));

    //
    // Define delivery. We want final acks to be recoverable, and order ack - express
    //
    UCHAR ucDelivery = (UCHAR)(usClass == MQMSG_CLASS_ORDER_ACK ?
                                   MQMSG_DELIVERY_EXPRESS :
                                   MQMSG_DELIVERY_RECOVERABLE);
    //
    // Create Message property on stack
    //     with the correlation holding the original packet ID
    //
    CMessageProperty MsgProperty(usClass,
                     (PUCHAR) pMessageId,
                     usPriority,
                     ucDelivery);

    if (usClass == MQMSG_CLASS_ORDER_ACK || MQCLASS_NACK(usClass))
    {
        //
        // Create Order structure to send as a body
        //
        OrderData.m_liSeqID     = liSeqID;
        OrderData.m_ulSeqN      = ulSeqN;
        OrderData.m_ulPrevSeqN  = ulPrevSeqN;
        CopyMemory(&OrderData.MessageID, pMessageId, sizeof(OBJECTID));

        MsgProperty.dwTitleSize     = STRLEN(ORDER_ACK_TITLE) + 1;
        MsgProperty.pTitle          = ORDER_ACK_TITLE;
        MsgProperty.dwBodySize      = sizeof(OrderData);
        MsgProperty.dwAllocBodySize = sizeof(OrderData);
        MsgProperty.pBody           = (PUCHAR) &OrderData;
        MsgProperty.bDefProv        = TRUE;
    }


	QUEUE_FORMAT XactQueue;
	WCHAR wsz[150], wszAddr[100];

    if (fDirect)
    {
        TA2StringAddr(pa, wszAddr);
        ASSERT(pa->AddressType == IP_ADDRESS_TYPE);

        wcscpy(wsz, FN_DIRECT_TCP_TOKEN);
        wcscat(wsz, wszAddr+2); // +2 jumps over not-needed type
        wcscat(wsz, FN_PRIVATE_SEPERATOR);
        wcscat(wsz, PRIVATE_QUEUE_PATH_INDICATIOR);
        wcscat(wsz, ORDERING_QUEUE_NAME);

        XactQueue.DirectID(wsz);
    }
    else
    {
        XactQueue.PrivateID(*pSrcQMId, ORDER_QUEUE_PRIVATE_INDEX);
    }

    hr = QmpSendPacket(&MsgProperty,&XactQueue, NULL, pqdDestQueue);
    return LogHR(hr, s_FN, 10);
}



/*====================================================
CInSeqHash::Register
    Does all processing of the valid packed accounting
=====================================================*/
HRESULT CInSeqHash::Register(CQmPacket * pPkt, HANDLE hQueue)
{
    HRESULT hr;

    // Get the sender's QMID, packet's SeqID, SeqN
    LONGLONG       liSeqID = pPkt->GetSeqID();
    ULONG          ulSeqN  = pPkt->GetSeqN();
    ULONG      ulPrevSeqN  = pPkt->GetPrevSeqN();
    const GUID *gSenderID  = pPkt->GetSrcQMGuid();
    const GUID *pgTaSrcQm  = pPkt->GetDstQMGuid();  // For direct: keeps source address

	

    // Get message ID
    OBJECTID MsgId;
    pPkt->GetMessageId(&MsgId);

    DBGMSG((DBGMOD_XACT_RCV,
            DBGLVL_INFO,
            _TEXT("Exactly1 receive: Register: SeqID=%x / %x, SeqN=%u"),
            HighSeqID(liSeqID), LowSeqID(liSeqID),
            ulSeqN));

    // Get destination queue format name
    QUEUE_FORMAT qf;
    if (!pPkt->GetDestinationQueue(&qf))
    {
        ASSERT(FALSE);
        return LogHR(MQ_ERROR, s_FN, 20);
    }

    XactDirectType DirectType  = GetDirectType(&qf);

	ASSERT((DirectType == dtxHttpDirectFlag &&  pPkt->IsEodIncluded()) ||
		   (DirectType != dtxHttpDirectFlag &&  !pPkt->IsEodIncluded()));

	

    ASSERT(liSeqID > 0);
    CRASH_POINT(101);

	R< CWcsRef> Streamid = SafeGetStreamId(*pPkt);


    // Notification element keeps all data for seq ack later
	CInSeqFlush  *pNotify = new CInSeqFlush(
        (pPkt ? pPkt->GetPointerToPacket() : NULL),
        (pPkt ? pPkt->GetPointerToDriverPacket() : NULL),
         hQueue,
         &MsgId,
         gSenderID,
         MQMSG_CLASS_ORDER_ACK,
         pPkt->GetPriority(),
         liSeqID,
         ulSeqN,
         ulPrevSeqN,
         &qf,
		 Streamid
		 );

    time_t timeCur;
    time(&timeCur);

	if(dtxHttpDirectFlag == DirectType)
	{
		
		P<CInSeqRecordSrmp> plogRec = new CInSeqRecordSrmp(
			qf.DirectID(),
			Streamid,
			liSeqID,
			ulSeqN,
			timeCur,
			SafeGetOrderQueue(*pPkt)
			);

		// Log down the newcomer
		hr = g_Logger.LogInSeqRecSrmp(
				 FALSE,                         // flush hint
				 pNotify,                       // notification element
				 plogRec);                      // log data

	
		return LogHR(hr, s_FN, 30);
	}

    // Log record with all relevant data
    P<CInSeqRecord> plogRec = new CInSeqRecord(
        gSenderID,
        &qf,
        liSeqID,
        ulSeqN,
        timeCur,
        pgTaSrcQm
	    );

    // Log down the newcomer
    hr = g_Logger.LogInSeqRec(
             FALSE,                         // flush hint
             pNotify,                       // notification element
             plogRec);                      // log data

    return LogHR(hr, s_FN, 35);
}

/*====================================================
CInSeqHash::Restored
    Correct info based on this restored packet
=====================================================*/
VOID CInSeqHash::Restored(CQmPacket* pPkt)
{
    // Get the sender's QMID, packet's SeqID, SeqN
    LONGLONG       liSeqID = pPkt->GetSeqID();
    ULONG          ulSeqN  = pPkt->GetSeqN();
    const GUID *gSenderID  = pPkt->GetSrcQMGuid();

    // Get destination queue format name
    QUEUE_FORMAT qf;
    if (!pPkt->GetDestinationQueue(&qf))
    {
        ASSERT(FALSE);
        return;
        // BUGBUG: can it occur ?
    }
	
    XactDirectType   DirectType   = GetDirectType(&qf);
    const GUID   *pgTaSrcQm = pPkt->GetDstQMGuid();  // For direct: keeps source address

    R<CWcsRef> OrderAckQueue = SafeGetOrderQueue(*pPkt);
	R<CWcsRef> StreamId = SafeGetStreamId(*pPkt);

	ASSERT( !(StreamId.get() == NULL &&  OrderAckQueue.get() != NULL) );

	// Remember this one
    Add(gSenderID, &qf, liSeqID, ulSeqN, TRUE, DirectType, pgTaSrcQm, OrderAckQueue, StreamId);

    DBGMSG((DBGMOD_XACT_RCV,
            DBGLVL_TRACE,
            _T("Exactly1 receive: Restored: SeqID=%x / %x, SeqN=%d ."),
            HighSeqID(liSeqID), LowSeqID(liSeqID),
            ulSeqN));
    return;
}


BOOL CInSeqHash::Save(HANDLE  hFile)
{
    PERSIST_DATA;

    ULONG cLen = m_mapInSeqs.GetCount();
    SAVE_FIELD(cLen);

    POSITION posInList = m_mapInSeqs.GetStartPosition();
    while (posInList != NULL)
    {
        CKeyInSeq    key;
        CInSequence *pInSeq;

        m_mapInSeqs.GetNextAssoc(posInList, key, pInSeq);

        if (!key.Save(hFile))
        {
            return FALSE;
        }

        if (!pInSeq->Save(hFile))
        {
            return FALSE;
        }
    }

    SAVE_FIELD(m_ulPingNo);
    SAVE_FIELD(m_ulSignature);

    return TRUE;
}

BOOL CInSeqHash::Load(HANDLE hFile)
{
    PERSIST_DATA;

    ULONG cLen;
    LOAD_FIELD(cLen);

    for (ULONG i=0; i<cLen; i++)
    {
        CKeyInSeq    key;

        if (!key.Load(hFile))
        {
            return FALSE;
        }

        CInSequence *pInSeq = new CInSequence(key);
        if (!pInSeq->Load(hFile))
        {
            return FALSE;
        }

        m_mapInSeqs.SetAt(key, pInSeq);
        if (!m_fCleanupScheduled)
        {
            ExSetTimer(&m_CleanupTimer, CTimeDuration::FromMilliSeconds(m_ulRevisionPeriod * 1000));
            m_fCleanupScheduled = TRUE;
        }
    }

    LOAD_FIELD(m_ulPingNo);
    LOAD_FIELD(m_ulSignature);

    return TRUE;
}

/*====================================================
CInSeqHash::SaveInFile
    Saves the InSequences Hash in the file
=====================================================*/
HRESULT CInSeqHash::SaveInFile(LPWSTR wszFileName, ULONG, BOOL)
{
    CS      lock(m_critInSeqHash);
    HANDLE  hFile = NULL;
    HRESULT hr = MQ_OK;

    hFile = CreateFile(
             wszFileName,                                       // pointer to name of the file
             GENERIC_WRITE,                                     // access mode: write
             0,                                                 // share  mode: exclusive
             NULL,                                              // no security
             OPEN_ALWAYS,                                      // open existing or create new
             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, // file attributes and flags: we need to avoid lazy write
             NULL);                                             // handle to file with attributes to copy


    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = MQ_ERROR;
    }
    else
    {
        hr = (Save(hFile) ? MQ_OK : MQ_ERROR);
    }

    if (hFile)
    {
        CloseHandle(hFile);
    }

    DBGMSG((DBGMOD_XACT_RCV,
             DBGLVL_TRACE,
             _TEXT("Saved InSeqs: %ls (ping=%d)"), wszFileName, m_ulPingNo));

    return LogHR(hr, s_FN, 40);
}



/*====================================================
CInSeqHash::LoadFromFile
    Loads the InSequences Hash from the file
=====================================================*/
HRESULT CInSeqHash::LoadFromFile(LPWSTR wszFileName)
{
    CS      lock(m_critInSeqHash);
    HANDLE  hFile = NULL;
    HRESULT hr = MQ_OK;

    hFile = CreateFile(
             wszFileName,                       // pointer to name of the file
             GENERIC_READ,                      // access mode: write
             0,                                 // share  mode: exclusive
             NULL,                              // no security
             OPEN_EXISTING,                     // open existing
             FILE_ATTRIBUTE_NORMAL,             // file attributes: we may use Hidden once
             NULL);                             // handle to file with attributes to copy

    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = MQ_ERROR;
    }
    else
    {
        hr = (Load(hFile) ? MQ_OK : MQ_ERROR);
    }

    if (hFile)
    {
        CloseHandle(hFile);
    }

#ifdef _DEBUG
    if (SUCCEEDED(hr))
    {
        DBGMSG((DBGMOD_XACT_RCV,
                 DBGLVL_TRACE,
                 _TEXT("Loaded InSeqs: %ls (ping=%d)"), wszFileName, m_ulPingNo));
    }
#endif

    return LogHR(hr, s_FN, 50);
}

/*====================================================
CInSeqHash::Check
    Verifies the state
=====================================================*/
BOOL CInSeqHash::Check()
{
    return (m_ulSignature == INSEQS_SIGNATURE);
}


/*====================================================
CInSeqHash::Format
    Formats the initial state
=====================================================*/
HRESULT CInSeqHash::Format(ULONG ulPingNo)
{
     m_ulPingNo = ulPingNo;
     m_ulSignature = INSEQS_SIGNATURE;

     return MQ_OK;
}

/*====================================================
QMPreInitInSeqHash
    PreInitializes Incoming Sequences Hash
=====================================================*/
HRESULT QMPreInitInSeqHash(ULONG ulVersion, TypePreInit tpCase)
{
   ASSERT(!g_pInSeqHash);
   g_pInSeqHash = new CInSeqHash();

   ASSERT(g_pInSeqHash);
   return LogHR(g_pInSeqHash->PreInit(ulVersion, tpCase), s_FN, 60);
}


/*====================================================
QMFinishInSeqHash
    Frees Incoming Sequences Hash
=====================================================*/
void QMFinishInSeqHash()
{
   if (g_pInSeqHash)
   {
        delete g_pInSeqHash;
        g_pInSeqHash = NULL;
   }
   return;
}

void CInSeqHash::HandleInSecSrmp(void* pData, ULONG cbData)
{
	CInSeqRecordSrmp   TheInSeqRecordSrmp((BYTE*)pData,cbData);
	GUID guidnull (GUID_NULL);
	QUEUE_FORMAT DestinationQueueFormat;
	DestinationQueueFormat.DirectID(TheInSeqRecordSrmp.m_pDestination.get());
	Add(
		&guidnull,
		&DestinationQueueFormat,
		TheInSeqRecordSrmp.m_StaticData.m_liSeqID,
		numeric_cast<ULONG>(TheInSeqRecordSrmp.m_StaticData.m_ulNextSeqN),
		TRUE,
		dtxHttpDirectFlag,
		&guidnull,
		TheInSeqRecordSrmp.m_pHttpOrderAckDestination,
		TheInSeqRecordSrmp.m_pStreamId
		);
}

void CInSeqHash::HandleInSec(PVOID pData, ULONG cbData)
{
	InSeqRecord *pInSeqRecord = (InSeqRecord *)pData;

    ASSERT(cbData == (
               sizeof(InSeqRecord) -
               sizeof(pInSeqRecord->wszDirectName)+
               sizeof(WCHAR) * ( wcslen(pInSeqRecord->wszDirectName) + 1)));				

    XactDirectType DirectType = pInSeqRecord->QueueFormat.GetType() == QUEUE_FORMAT_TYPE_DIRECT ? dtxDirectFlag : dtxNoDirectFlag;

    if(DirectType == dtxDirectFlag)
    {
		ASSERT(DirectType == dtxDirectFlag);
        pInSeqRecord->QueueFormat.DirectID(pInSeqRecord->wszDirectName);
    }

    Add(&pInSeqRecord->Guid,
        &pInSeqRecord->QueueFormat,
        pInSeqRecord->liSeqID,
        pInSeqRecord->ulNextSeqN,
        TRUE,
        DirectType,
        &pInSeqRecord->guidDestOrTaSrcQm,
		NULL,
		NULL);


    DBGMSG((DBGMOD_LOG,
            DBGLVL_INFO,
            _TEXT("InSeq recovery: Sequence %x / %x, LastSeqN=%d, direct=%ls"),
            HighSeqID(pInSeqRecord->liSeqID), LowSeqID(pInSeqRecord->liSeqID), pInSeqRecord->ulNextSeqN, pInSeqRecord->wszDirectName));

}


/*====================================================
CInSeqHash::InSeqRecovery
Recovery function: called per each log record
=====================================================*/
void CInSeqHash::InSeqRecovery(USHORT usRecType, PVOID pData, ULONG cbData)
{
    switch (usRecType)
    {
      case LOGREC_TYPE_INSEQ:
      HandleInSec(pData,cbData);
      break;

	  case LOGREC_TYPE_INSEQ_SRMP:
	  HandleInSecSrmp(pData,cbData);
	  break;
	
	
    default:
        ASSERT(0);
        break;
    }
}


/*====================================================
CInSeqHash::PreInit
    PreIntialization of the In Seq Hash (load)
=====================================================*/
HRESULT CInSeqHash::PreInit(ULONG ulVersion, TypePreInit tpCase)
{
    switch(tpCase)
    {
    case piNoData:
        m_PingPonger.ChooseFileName();
        Format(0);
        return MQ_OK;
    case piNewData:
        return LogHR(m_PingPonger.Init(ulVersion), s_FN, 70);
    case piOldData:
        return LogHR(m_PingPonger.Init_Legacy(), s_FN, 80);
    default:
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 90);
    }
}

/*====================================================
CInSeqHash::Save
    Saves in appropriate file
=====================================================*/
HRESULT CInSeqHash::Save()
{
    return LogHR(m_PingPonger.Save(), s_FN, 100);
}

/*====================================================
 provides access to the sorter's critical section
=====================================================*/
CCriticalSection &CInSeqHash::InSeqCritSection()
{
    return m_critInSeqHash;
}


// Get/Set methods
ULONG &CInSeqHash::PingNo()
{
    return m_ulPingNo;
}

void AFXAPI DestructElements(CInSequence ** ppInSeqs, int n)
{
//    for (int i=0;i<n;i++)
//        delete *ppInSeqs++;
}

/*====================================================
TimeToCleanupDeadSequence
    Scheduled periodically to delete dead incomong sequences
=====================================================*/
void WINAPI CInSeqHash::TimeToCleanupDeadSequence(CTimer* pTimer)
{
    g_pInSeqHash->CleanupDeadSequences();
}

void CInSeqHash::CleanupDeadSequences()
{
    // Serializing all outgoing hash activity on the highest level
    CS lock(m_critInSeqHash);

    ASSERT(m_fCleanupScheduled);

    time_t timeCur;
    time(&timeCur);

    // Loop upon all sequences
    POSITION posInList = m_mapInSeqs.GetStartPosition();
    while (posInList != NULL)
    {
        CKeyInSeq    key;
        CInSequence *pInSeq;

        m_mapInSeqs.GetNextAssoc(posInList, key, pInSeq);

        // Is it inactive?
        if (timeCur - pInSeq->LastAccessed()  > (long)m_ulCleanupPeriod)
        {
            m_mapInSeqs.RemoveKey(key);
            delete pInSeq;
        }
     }

    if (m_mapInSeqs.IsEmpty())
    {
        m_fCleanupScheduled = FALSE;
        return;
    }

    ExSetTimer(&m_CleanupTimer, CTimeDuration::FromMilliSeconds(m_ulRevisionPeriod * 1000));
}

void
CInSeqHash::GetInSequenceInformation(
    const QUEUE_FORMAT *pqf,
    LPCWSTR QueueName,
    GUID** ppSenderId,
    ULARGE_INTEGER** ppSeqId,
    DWORD** ppSeqN,
    LPWSTR** ppSendQueueFormatName,
    TIME32** ppLastActiveTime,
    DWORD** ppRejectCount,
    DWORD* pSize
    )
{
    CList<POSITION, POSITION> FindPosList;
    CS lock(m_critInSeqHash);

    POSITION pos;
    POSITION PrevPos;
    pos = m_mapInSeqs.GetStartPosition();

    while (pos)
    {
        PrevPos = pos;

        CKeyInSeq InSeqKey;
        CInSequence* InSeq;
        m_mapInSeqs.GetNextAssoc(pos, InSeqKey, InSeq);

        const QUEUE_FORMAT* KeyFormatName = InSeqKey.GetQueueFormat();
        if (*KeyFormatName == *pqf)
        {
            FindPosList.AddTail(PrevPos);
        }
        else
        {
            if (KeyFormatName->GetType() == QUEUE_FORMAT_TYPE_DIRECT)
            {
                LPCWSTR DirectId = KeyFormatName->DirectID();

                LPWSTR DirectQueueName = wcschr(DirectId, L'\\');
                ASSERT(DirectQueueName != NULL);
                DirectQueueName++;

                if (CompareStringsNoCase(DirectQueueName, QueueName) == 0)
                {
                    FindPosList.AddTail(PrevPos);
                }
            }
        }
    }

    DWORD count = FindPosList.GetCount();

    if (count == 0)
    {
        *ppSenderId = NULL;
        *ppSeqId = NULL;
        *ppSeqN = NULL;
        *ppSendQueueFormatName = NULL;
        *ppLastActiveTime = NULL;
        *pSize = count;

        return;
    }

    //
    // Allocates Arrays to return the Data
    //
    AP<GUID> pSenderId = new GUID[count];
    AP<ULARGE_INTEGER> pSeqId = new ULARGE_INTEGER[count];
    AP<DWORD> pSeqN = new DWORD[count];
    AP<LPWSTR> pSendQueueFormatName = new LPWSTR[count];
    AP<TIME32> pLastActiveTime = new TIME32[count];
    AP<DWORD> pRejectCount = new DWORD[count];

    DWORD Index = 0;
    pos = FindPosList.GetHeadPosition();

    try
    {
        while(pos)
        {
            POSITION mapPos = FindPosList.GetNext(pos);

            CKeyInSeq InSeqKey;
            CInSequence* pInSeq;
            m_mapInSeqs.GetNextAssoc(mapPos, InSeqKey, pInSeq);

            pSenderId[Index] = *InSeqKey.GetQMID();
            pSeqId[Index].QuadPart = pInSeq->SeqIDReg();
            pSeqN[Index] = pInSeq->SeqNReg();
            pLastActiveTime[Index] = INT_PTR_TO_INT(pInSeq->LastActive()); //BUGBUG bug year 2038
            pRejectCount[Index] = pInSeq->GetRejectCount();

            //
            // Copy the format name
            //
            WCHAR QueueFormatName[1000];
            DWORD RequiredSize;
            HRESULT hr = MQpQueueFormatToFormatName(
                            InSeqKey.GetQueueFormat(),
                            QueueFormatName,
                            1000,
                            &RequiredSize,
                            false
                            );
            ASSERT(SUCCEEDED(hr));
            LogHR(hr, s_FN, 174);
            pSendQueueFormatName[Index] = new WCHAR[RequiredSize + 1];
            wcscpy(pSendQueueFormatName[Index], QueueFormatName);

            ++Index;
        }
    }
    catch (const bad_alloc&)
    {
        while(Index)
        {
            delete [] pSendQueueFormatName[--Index];
        }

        LogIllegalPoint(s_FN, 84);
        throw;
    }

    ASSERT(Index == count);

    *ppSenderId = pSenderId.detach();
    *ppSeqId = pSeqId.detach();
    *ppSeqN = pSeqN.detach();
    *ppSendQueueFormatName = pSendQueueFormatName.detach();
    *ppLastActiveTime = pLastActiveTime.detach();
    *ppRejectCount = pRejectCount.detach();
    *pSize = count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\xactmode.cpp ===
/*++
    Copyright (c) 1998  Microsoft Corporation

Module Name:
    xactmode.cpp

Abstract:
    This module deals with figuring out the transactional mode
	(g_fDefaultCommit)
 
Author:
    Amnon Horowitz (amnonh)

--*/

#include "stdh.h"
#include "xactmode.h"
#include "clusapi.h"

#include "xactmode.tmh"

BOOL g_fDefaultCommit;
BOOL g_fNewLoggerData;

static const LPWSTR szDefaultCommit = TEXT("DefaultCommit");

static WCHAR *s_FN=L"xactmode";

//---------------------------------------------------------------------
// InDefaultCommit
//
//	Consult registry and figure out if we are DefaultCommit Mode
//---------------------------------------------------------------------
inline LONG InDefaultCommit(LPBOOL pf) 
{
	WCHAR buf[64];
	DWORD  dwSize;
	DWORD  dwType;
	const LPWSTR szDefault = TEXT("No");
	LONG rc;

	dwSize = 64 * sizeof(WCHAR);
	dwType = REG_SZ;
	rc = GetFalconKeyValue(MSMQ_TRANSACTION_MODE_REGNAME,
								 &dwType,
								 buf,
								 &dwSize,
								 szDefault);

	if(rc == ERROR_SUCCESS)
	{
		if(dwType == REG_SZ && wcscmp(buf, szDefaultCommit) == 0)
			*pf = TRUE;
		else
			*pf = FALSE;
	}
	else if(rc == ERROR_MORE_DATA)
	{
		rc = ERROR_SUCCESS;
		*pf = FALSE;
	}

	return(rc);
}

//---------------------------------------------------------------------
// InLoggingMode
//
//	Consult registry and figure out if the logger data are in a new style
//    (there is consolidation record with checkpoint foles versions)
//---------------------------------------------------------------------
HRESULT InLoggingMode(LPBOOL pf) 
{
    DWORD   dwDef = 0, 
            dwLogDataExist,
            dwSize = sizeof(DWORD),
            dwType = REG_DWORD ;
     LONG res = GetFalconKeyValue( FALCON_LOGDATA_CREATED_REGNAME,
                                   &dwType,
                                   &dwLogDataExist,
                                   &dwSize,
                                   (LPCTSTR) &dwDef ) ;
     if (res != ERROR_SUCCESS)
     {
         REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL,
                                           REGISTRY_FAILURE,
                                           1,
                                           L"RecoverLoggedSubsystems - InLoggingMode"));
         return LogHR(MQ_ERROR, s_FN, 10);
     }
     ASSERT(dwType == REG_DWORD) ;

     *pf = (dwLogDataExist==1);
     return MQ_OK;
}

//---------------------------------------------------------------------
// SetDefaultCommit
//
//	Set DefaultCommit mode in the registry
//---------------------------------------------------------------------
inline LONG SetDefaultCommit()
{
	LONG rc;
	DWORD	dwType = REG_SZ;
	DWORD	dwSize = (wcslen(szDefaultCommit) + 1) * sizeof(WCHAR);

	rc = SetFalconKeyValue(MSMQ_TRANSACTION_MODE_REGNAME, 
						   &dwType,
						   szDefaultCommit,
						   &dwSize);

	if(rc == ERROR_SUCCESS)
		g_fDefaultCommit = TRUE;

	return rc;
}


//---------------------------------------------------------------------
// SetDefaultCommit
//
//	Set DefaultCommit mode in the registry
//---------------------------------------------------------------------
HRESULT SetLoggerMode(DWORD dwMode)
{
    if (!g_fNewLoggerData)
    {
    	LONG rc;
	    DWORD	dwType = REG_DWORD;
	    DWORD	dwSize = sizeof(DWORD);
        DWORD   dwVal  = dwMode;

	    rc = SetFalconKeyValue(FALCON_LOGDATA_CREATED_REGNAME, 
						   &dwType,
						   &dwVal,
						   &dwSize);
        if (rc != ERROR_SUCCESS)
        {
            REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL,
                                              REGISTRY_FAILURE,
                                              1,
                                              L"RecoverLoggedSubsystems - SetLoggerMode"));
            return LogHR(MQ_ERROR, s_FN, 20);
        }
    }
    return MQ_OK;
}


#ifdef SUPPORT_CLUSTER
//---------------------------------------------------------------------
// GetClusterNodeId
//
//	Get the cluster node id
//---------------------------------------------------------------------
inline LPWSTR GetClusterNodeId()
{
#ifdef WIN95   // use MQNWIN95 or something else
	return(0);
#else
	WCHAR	buf[1];
	LPWSTR	szNodeId;
	DWORD	ccNodeId = 1;
	NTSTATUS rc;

	rc  = GetClusterNodeId(NULL, buf, &ccNodeId);
	if(rc != ERROR_SUCCESS && rc != ERROR_MORE_DATA)
		return(NULL);

	ccNodeId++;
	szNodeId = new WCHAR[ccNodeId];
	rc = GetClusterNodeId(NULL, buf, &ccNodeId);
	if(rc != ERROR_SUCCESS)
	{
		delete szNodeId;
		return(NULL);
	}

	return(szNodeId);
#endif
}
#endif

//---------------------------------------------------------------------
// GetActiveNodeId
//
//	Consult registry and figure out the last active node id
//---------------------------------------------------------------------
inline LPWSTR GetActiveNodeId() {
	LPWSTR buf[1];
	DWORD  dwSize = 1 * sizeof(WCHAR);
	DWORD  dwType = REG_SZ;
	LPWSTR	szActiveNodeId;
	
	LONG rc = GetFalconKeyValue(MSMQ_ACTIVE_NODE_ID_REGNAME,
								 &dwType,
								 buf,
								 &dwSize,
								 NULL);

	if(rc != ERROR_SUCCESS && rc != ERROR_MORE_DATA)
		return(NULL);

	szActiveNodeId = new WCHAR[dwSize / sizeof(WCHAR)];

	rc = GetFalconKeyValue(MSMQ_ACTIVE_NODE_ID_REGNAME,
								 &dwType,
								 szActiveNodeId,
								 &dwSize,
								 NULL);
	if(rc != ERROR_SUCCESS)
    {
        delete szActiveNodeId;
		return(NULL);
    }

	return(szActiveNodeId);
}

inline BOOL ForceNoSwitch()
{
	WCHAR buf[1];
	DWORD dwType = REG_SZ;
	DWORD dwSize = sizeof(buf);

	LONG rc = GetFalconKeyValue(MSMQ_FORCE_NOT_TRANSACTION_MODE_SWITCH_REGNAME,
									&dwType,
									buf,
									&dwSize,
									NULL);
	if(rc == ERROR_SUCCESS || rc == ERROR_MORE_DATA)
	{
		return(TRUE);
	}

	return(FALSE);
}

//---------------------------------------------------------------------
// SetActiveNodeId
//
//	Set the last active node id in the registry
//---------------------------------------------------------------------
inline LONG SetActiveNodeId(LPWSTR szActiveNodeId) {
	LONG rc;
	DWORD	dwType = REG_SZ;
	DWORD	dwSize = (wcslen(szActiveNodeId) + 1) * sizeof(WCHAR);

	rc = SetFalconKeyValue(MSMQ_ACTIVE_NODE_ID_REGNAME, 
						   &dwType,
						   szActiveNodeId,
						   &dwSize);
	return(rc);
}

//---------------------------------------------------------------------
// ConfigureXactMode
//
//	Called prior to recovery to figure out which transactional mode
//	we are in, and if we want to try and switch to a different mode.
//---------------------------------------------------------------------
NTSTATUS ConfigureXactMode()
{
    NTSTATUS rc = InDefaultCommit(&g_fDefaultCommit);
	if(FAILED(rc))
        return rc;

    rc = InLoggingMode(&g_fNewLoggerData);

    return LogNTStatus(rc, s_FN, 30);
}

//---------------------------------------------------------------------
// ReconfigureXactMode
//
//	Called after succesfull recovery, to possiby switch to 
//	DefaultCommit mode.
//---------------------------------------------------------------------
void ReconfigureXactMode()
{
    // Set new logger mode 
    SetLoggerMode(1);

	if(g_fDefaultCommit)
		return;

	//
	// Now, figure out if we want to try to switch to DefaultCommit
	// at the end of recovery
	//
	if(ForceNoSwitch()) 
	{
		return;
	}

	//
	// Are we not on a two node cluter?
	//
	if(/* !fOnTwoNodeCluster*/ TRUE) 
	{
		SetDefaultCommit();
		return;
	}

#ifdef SUPPORT_CLUSTER
	fSwitchToDef

	//
	// We need to figure out if the second node is already 
	// running this code.
	//
	AP<WCHAR> szNodeId = GetClusterNodeId();
	if(szNodeId == NULL)
	{
		//
		// We can't figure out our node id.
		// Never mind, we will try to switch next time.
		//
		ASSERT(szNodeId != NULL);
		return;
	}

	AP<WCHAR> szActiveNodeId = GetActiveNodeId();
	if(szActiveNodeId == NULL)
	{
		//
		// Second node is not running this code, 
		// otherwise it would have set the active
		// node id.
		//
		rc = SetActiveNodeId(szNodeId);
		ASSERT(rc == ERROR_SUCCESS);
		return;
	}


	if(wcscmp(szNodeId, szActiveNodeId) != 0)
	{
		//
		// The second node is running this code!
		// Set the active node id again just in case 
		// we fail to switch modes
		//
		SetActiveNodeId(szNodeId);
	} 

#endif

	SetDefaultCommit();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\xactlog.cpp ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactLog.cpp

Abstract:
    Logging implementation - synchronous logging

Author:
    Alexander Dadiomov (AlexDad)

--*/

#include "stdh.h"
#include "QmThrd.h"
#include "acapi.h"
#include "qmpkt.h"
#include "qmutil.h"
#include "qformat.h"
#include "mqtempl.h"
#include "xactstyl.h"
#include "xact.h"
#include "xactping.h"
#include "xactrm.h"
#include "xactin.h"
#include "xactlog.h"
#include "logmgrgu.h"

#include "xactlog.tmh"

#define MAX_WAIT_FOR_FLUSH_TIME  100000

static WCHAR *s_FN=L"xactlog";

//#include "..\..\tools\viper96\resdll\enu\msdtcmsg.h"
// Copy/paste from there
#define IDS_DTC_W_LOGENDOFFILE           ((DWORD)0x8000102AL)
#define IDS_DTC_W_LOGNOMOREASYNCHWRITES  ((DWORD)0x8000102CL)

extern void SeqPktTimedOutEx(LONGLONG liSeqID, ULONG ulSeqN, ULONG ulPrevSeqN);

typedef HRESULT  (STDAPICALLTYPE * GET_CLASS_OBJECT)(REFCLSID clsid,
													 REFIID riid,
													 void ** ppv);
// Counter of the pending logger notifications
LONG g_lPendingNotifications = 0;

// Flusher thread routine
static DWORD WINAPI FlusherThreadRoutine(LPVOID);
STATIC void RecoveryFromLogFn(USHORT usRecType, PVOID pData, ULONG cbData);

static CCriticalSection  g_crFlushing;      // Separates flushing/logging
static CCriticalSection  g_crLogging;       // Serializes usage of m_lprCurrent 

// static CCriticalSection  g_crUnfreezing;    // Serializes calls to AcPutPacket which unfreeze incoming packets

// Single Global Instance of the logger
CLogger  g_Logger;

// Names for debug print
WCHAR *g_RecoveryRecords[] = 
{
    L"None",
    L"Empty",
    L"InSeq",
    L"XactStatus",
    L"PrepInfo",
    L"XactData",
    L"ConsRec"
};



CInSeqRecordSrmp::CInSeqRecordSrmp(
		const WCHAR* pDestination,
		const R<CWcsRef>&  StreamId,
        LONGLONG      liSeqID,
		ULONG         ulNextSeqN,
		time_t        timeLastActive,
		const R<CWcsRef>&  HttpOrderAckDestination
        ):
		m_StaticData(liSeqID, ulNextSeqN, timeLastActive),
		m_pStreamId(StreamId),
		m_pHttpOrderAckDestination(HttpOrderAckDestination),
		m_pDestination(newwcs(pDestination))
{
													
}



CInSeqRecordSrmp::CInSeqRecordSrmp(
						const BYTE* pdata, 
						DWORD len
						)
						
							  	
{
	ASSERT(len >=  sizeof(m_StaticData));
	memcpy(&m_StaticData, pdata,sizeof(m_StaticData));
	pdata += sizeof(m_StaticData);


	const WCHAR* pDestination = reinterpret_cast<const WCHAR*>(pdata) ;
	ASSERT(pDestination);
	ASSERT(ISALIGN2_PTR(pDestination)); //allignment  assert
	m_pDestination = newwcs(pDestination);
	

	const WCHAR* pStreamId = pDestination +wcslen(pDestination) +1;
	ASSERT((BYTE*)pStreamId < pdata +  len);
 	m_pStreamId = R<CWcsRef>(new CWcsRef(pStreamId));


	const WCHAR* pHttpOrderAckDestination = pStreamId + wcslen(pStreamId) +1;
	ASSERT((BYTE*)pHttpOrderAckDestination < pdata +  len);
	if(pHttpOrderAckDestination[0] != L'\0')
	{
		m_pHttpOrderAckDestination = R<CWcsRef>(new CWcsRef(pHttpOrderAckDestination));
	}
}


const BYTE* CInSeqRecordSrmp::Serialize(DWORD* plen)
{
	ASSERT(m_pStreamId.get() != NULL);
	ASSERT(m_pStreamId->getstr() != NULL);

	const WCHAR* pOrderQueue = (m_pHttpOrderAckDestination.get() != 0) ? m_pHttpOrderAckDestination->getstr() : L"";
	size_t DestinationQueueLen =  (wcslen(m_pDestination.get()) +1)* sizeof(WCHAR);
	size_t StreamIdlen = (wcslen(m_pStreamId->getstr()) +1)* sizeof(WCHAR);
    size_t HttpOrderAckDestinationLen = (wcslen(pOrderQueue) +1)* sizeof(WCHAR);
	

	*plen =  numeric_cast<DWORD>(sizeof(m_StaticData) + StreamIdlen + HttpOrderAckDestinationLen + DestinationQueueLen);

	m_tofree = new BYTE[*plen];
	BYTE* ptr= 	m_tofree.get();

	memcpy(ptr,&m_StaticData,sizeof(m_StaticData));
	ptr += 	sizeof(m_StaticData);

	memcpy(ptr, m_pDestination.get() , DestinationQueueLen); 
	ptr += DestinationQueueLen;
	
	memcpy(ptr, m_pStreamId->getstr() , StreamIdlen); 
	ptr += StreamIdlen;
	
	memcpy(ptr, pOrderQueue, HttpOrderAckDestinationLen); 
	
	return 	m_tofree.get();
}






//--------------------------------------
//
// Class CInSeqRecord
//
//--------------------------------------
CInSeqRecord::CInSeqRecord(
		const GUID	  *pGuidSrcQm,
		QUEUE_FORMAT  *pQueueFormat,
        LONGLONG      liSeqID,
		ULONG         ulNextSeqN,
		time_t        timeLastActive,
        const GUID   *pGuidDestOrTaSrcQm)
	
{
	memcpy(&m_Data.Guid,                pGuidSrcQm,         sizeof(GUID));
	memcpy(&m_Data.guidDestOrTaSrcQm,   pGuidDestOrTaSrcQm, sizeof(GUID));
    memcpy(&m_Data.QueueFormat,         pQueueFormat,       sizeof(QUEUE_FORMAT));

    m_Data.liSeqID			= liSeqID;
    m_Data.ulNextSeqN		= ulNextSeqN;
    m_Data.timeLastActive	= timeLastActive;

    if (m_Data.QueueFormat.GetType() == QUEUE_FORMAT_TYPE_DIRECT)
    {
	    wcsncpy(m_Data.wszDirectName, 
                m_Data.QueueFormat.DirectID(), 
                MY_DN_LENGTH);
	    m_Data.wszDirectName[MY_DN_LENGTH-1] = L'\0';
    }
    else
    {
        m_Data.wszDirectName[0] = L'\0';
    }
}

CInSeqRecord::~CInSeqRecord()
{
}


//--------------------------------------
//
// Class CInSeqFlush
//
//--------------------------------------

CInSeqFlush::CInSeqFlush(
    CBaseHeader  *pPktBasePtr, 
    CPacket      *pDriverPacket,
    HANDLE        hQueue,
    OBJECTID     *pMessageId,
    const GUID   *pSrcQMId,
    USHORT        usClass,
    USHORT        usPriority,
    LONGLONG      liSeqID,
    ULONG         ulSeqN,
    ULONG         ulPrevSeqN,
    QUEUE_FORMAT *pqdDestQueue,
	const R<CWcsRef>& StreamId
    ) :
    m_Timer(TimeToCallback)
{
    m_pPktBasePtr = pPktBasePtr;
    m_pDriverPacket = pDriverPacket;
    m_hQueue      = hQueue;
    m_usClass     = usClass;
    m_usPriority  = usPriority;
    m_liSeqID     = liSeqID;
    m_ulSeqN      = ulSeqN;
    m_ulPrevSeqN  = ulPrevSeqN,
	m_StreamId = StreamId;

    CopyMemory(&m_MessageId,   pMessageId, sizeof(OBJECTID));
    CopyMemory(&m_SrcQMId,     pSrcQMId,   sizeof(GUID));

    CopyQueueFormat(m_qdDestQueue, *pqdDestQueue);
}

CInSeqFlush::~CInSeqFlush()
{
    m_qdDestQueue.DisposeString();
}

/*====================================================
CInSeqFlush::AppendCallback
    Called per each log record after flush has been finished
=====================================================*/
VOID CInSeqFlush::AppendCallback(HRESULT hr, LRP lrpAppendLRP)
{
    InterlockedDecrement(&g_lPendingNotifications);
	CRASH_POINT(102);
    DBGMSG((DBGMOD_LOG, DBGLVL_INFO, TEXT("CInSeqFlush::AppendCallback : lrp=%I64x, hr=%x"), lrpAppendLRP.QuadPart, hr));

    m_hr           = hr;
    m_lrpAppendLRP = lrpAppendLRP;
    ExSetTimer(&m_Timer, CTimeDuration(0));
}

/*====================================================
CInSeqFlush::TimeToCallback 
    Called by timer when scheduled by notification
=====================================================*/
void WINAPI CInSeqFlush::TimeToCallback(CTimer* pTimer)
{
    CInSeqFlush* pFlush = CONTAINING_RECORD(pTimer, CInSeqFlush, m_Timer);
    pFlush->AppendCallbackWork();
}

/*====================================================
CInSeqFlush::AppendCallbackWork 
    Real work on callback
    If m_hQueue==0 or m_pPkt==0 then don't touch the packet
=====================================================*/
void CInSeqFlush::AppendCallbackWork()
{
	// Make packet visible to readers

    if (SUCCEEDED(m_hr))
    {
        // Looking for the Incoming Sequence
        CInSequence *pInSeq;

        // We have to lock InSeqHAsh
        CS lock(g_pInSeqHash->InSeqCritSection());

        if (g_pInSeqHash->Lookup(&m_SrcQMId, &m_qdDestQueue, m_StreamId, &pInSeq))
        {
            // Now we can unfreeze the packet with the sequence's unfreezer
            pInSeq->SortedUnfreeze(this, &m_SrcQMId, &m_qdDestQueue);
        }
        else
        {
            // We should hold sequence up to everybody is unfreezed
            ASSERT(0);
        }
        // SortedUnfreeze will delete CInSeqFlush
    }
    else
    {
        // SortedUnfreeze is not called, so deleting here 
        delete this;
    }
}

/*====================================================
CInSeqFlush::Unfreeze
    Unfreezes the packet (does it visible to the reader)
=====================================================*/
HRESULT CInSeqFlush::Unfreeze()
{
    HRESULT hr = MQ_OK;

    if (m_hQueue && m_pPktBasePtr)
    {
        hr = ACPutPacket(m_hQueue, m_pDriverPacket);
    }

    delete this;
    return LogHR(hr, s_FN, 10);
}


/*====================================================
CInSeqFlush::ChkPtCallback
    Called per each checkpoint after it has been written
=====================================================*/
VOID CInSeqFlush::ChkPtCallback (HRESULT hr, LRP lrpAppendLRP)
{

}

//--------------------------------------
//
// Class CConsolidationRecord
//
//--------------------------------------
CConsolidationRecord::CConsolidationRecord(
        ULONG ulInseq,
        ULONG ulXact)
{
    m_Data.m_ulInSeqVersion = ulInseq;
    m_Data.m_ulXactVersion  = ulXact;
}

CConsolidationRecord::~CConsolidationRecord()
{
}

//--------------------------------------
//
// Class CXactStatusRecord
//
//--------------------------------------
CXactStatusRecord::CXactStatusRecord(
    ULONG    ulIndex,
    TXACTION taAction,
    ULONG    ulFlags)
{
    m_Data.m_ulIndex    = ulIndex;
    m_Data.m_taAction   = taAction;
    m_Data.m_ulFlags    = ulFlags;
}

CXactStatusRecord::~CXactStatusRecord()
{
}

//--------------------------------------
//
// Class CPrepInfoRecord
//
//--------------------------------------

CPrepInfoRecord::CPrepInfoRecord(
    ULONG    ulIndex,
    ULONG    cbPrepInfo,
    UCHAR    *pbPrepInfo)
{
    m_pData = (PrepInfoRecord *) new CHAR[sizeof(PrepInfoRecord) +  cbPrepInfo];
    m_pData->m_ulIndex    = ulIndex;
    m_pData->m_cbPrepInfo = cbPrepInfo;
	memcpy(&m_pData->m_bPrepInfo[0], pbPrepInfo, cbPrepInfo);
}

CPrepInfoRecord::~CPrepInfoRecord()
{
    delete [] m_pData;
}

//--------------------------------------
//
// Class CXactDataRecord
//
//--------------------------------------

CXactDataRecord::CXactDataRecord(
    ULONG    ulIndex,
    ULONG    ulSeqNum,
    BOOL     fSinglePhase,
    const XACTUOW  *pUow)
{
    m_Data.m_ulIndex      = ulIndex;
    m_Data.m_ulSeqNum     = ulSeqNum;
    m_Data.m_fSinglePhase = fSinglePhase;
	memcpy(&m_Data.m_uow, pUow, sizeof(XACTUOW));
}

CXactDataRecord::~CXactDataRecord()
{
}



//--------------------------------------
//
// Class CXactStatusFlush
//
//--------------------------------------

CXactStatusFlush::CXactStatusFlush(
    CTransaction   *pCTrans, 
    TXFLUSHCONTEXT tcContext
    ) :
    m_Timer(TimeToCallback) 
{
	m_pTrans     = pCTrans;
    m_tcContext  = tcContext;
}

CXactStatusFlush::~CXactStatusFlush()
{
}

/*====================================================
CXactStatusFlush::AppendCallback
    Called per each log record after flush has been finished
=====================================================*/
VOID CXactStatusFlush::AppendCallback(HRESULT hr, LRP lrpAppendLRP)
{
    InterlockedDecrement(&g_lPendingNotifications);
	CRASH_POINT(103);
    DBGMSG((DBGMOD_LOG, DBGLVL_INFO, TEXT("CXactStatusFlush::AppendCallback : lrp=%I64x, hr=%x"), lrpAppendLRP.QuadPart, hr));

    m_hr           = hr;
    m_lrpAppendLRP = lrpAppendLRP;
    ExSetTimer(&m_Timer, CTimeDuration(0));
}

/*====================================================
CXactStatusFlush::TimeToCallback 
    Called by timer when scheduled by notification
=====================================================*/
void WINAPI CXactStatusFlush::TimeToCallback(CTimer* pTimer)
{
    CXactStatusFlush* pFlush = CONTAINING_RECORD(pTimer, CXactStatusFlush, m_Timer);
    pFlush->AppendCallbackWork();
}

/*====================================================
CXactStatusFlush::TimeToCallback
    Real work on callback
=====================================================*/
void CXactStatusFlush::AppendCallbackWork()
{
    m_pTrans->LogFlushed(m_tcContext, m_hr);
    delete this;
}

/*====================================================
CXactStatusFlush::ChkPtCallback
    Called per each checkpoint after it has been written
=====================================================*/
VOID CXactStatusFlush::ChkPtCallback (HRESULT hr, LRP lrpAppendLRP)
{

}

//--------------------------------------
//
// Class CConsolidationFlush
//
//--------------------------------------

CConsolidationFlush::CConsolidationFlush(HANDLE hEvent)
{
	m_hEvent = hEvent;
}

CConsolidationFlush::~CConsolidationFlush()
{
}

/*====================================================
CConsolidationFlush::AppendCallback
    Called per each log record after flush has been finished
=====================================================*/
VOID CConsolidationFlush::AppendCallback(HRESULT hr, LRP lrpAppendLRP)
{
    DBGMSG((DBGMOD_LOG, DBGLVL_INFO, TEXT("CConsolidationFlush::AppendCallback : lrp=%I64x, hr=%x"), lrpAppendLRP.QuadPart, hr));

    InterlockedDecrement(&g_lPendingNotifications);
    SetEvent(m_hEvent);

    delete this;
}

/*====================================================
CConsolidationFlush::ChkPtCallback
    Called per each checkpoint after it has been written
=====================================================*/
VOID CConsolidationFlush::ChkPtCallback (HRESULT hr, LRP lrpAppendLRP)
{

}

//--------------------------------------
//
// Class CChkptNotification
//
//--------------------------------------

CChkptNotification::CChkptNotification(
    HANDLE hEvent)
{
	m_hEvent     = hEvent;
}

CChkptNotification::~CChkptNotification()
{
}

/*====================================================
CChkptNotification::AppendCallback
=====================================================*/
VOID CChkptNotification::AppendCallback(HRESULT hr, LRP lrpAppendLRP)
{
}

/*====================================================
CChkptNotification::ChkPtCallback
    Called after checkpoint has been written
=====================================================*/
VOID CChkptNotification::ChkPtCallback (HRESULT hr, LRP lrpAppendLRP)
{
    BOOL b = SetEvent(m_hEvent);
    ASSERT(b);
    DBG_USED(b);
    DBGMSG((DBGMOD_LOG, DBGLVL_WARNING, TEXT("CChkptNotification::ChkPtCallback : lrp=%I64x, hr=%x"), lrpAppendLRP.QuadPart, hr));

    delete this;
}

//--------------------------------------
//
// Class CLogger
//
//--------------------------------------
CLogger::CLogger() :
    m_CheckpointTimer(TimeToCheckpoint),
    m_fStop(false)
{
    m_pCF               = NULL;
    m_pILogInit         = NULL;
    m_pILogStorage      = NULL;
    m_ILogRecordPointer = NULL;
    m_pILogRead         = NULL;
    m_pILogWrite        = NULL;
    m_pILogWriteAsynch  = NULL;

    m_szFileName[0]     = '\0';;
    memset(&m_lrpCurrent, 0, sizeof(LRP));
    m_ulAvailableSpace  = 0;
    m_ulFileSize        = 0;
	m_uiTimerInterval   = 0;  
 	m_uiFlushInterval   = 0;  
	m_uiChkPtInterval   = 0;  
	m_uiSleepAsynch     = 0;
    m_uiAsynchRepeatLimit = 0;
    m_ulLogBuffers		= 0;
	m_ulLogSize			= 0;
    m_fDirty            = FALSE;
    m_hFlusherEvent     = NULL;
    m_hCompleteEvent    = NULL;
    m_hFlusherThread    = NULL;
    m_fActive           = FALSE;
    m_fInRecovery       = FALSE;
    m_hChkptReadyEvent  = CreateEvent(0, TRUE,FALSE, 0);
    if (m_hChkptReadyEvent == NULL)
    {
        LogNTStatus(GetLastError(), s_FN, 106);
        ASSERT(m_hChkptReadyEvent != NULL);
    }
}

CLogger::~CLogger()
{
}

/*====================================================
CLogger::Finish
    Releases all log manager interfaces
=====================================================*/
void CLogger::Finish()
{
    if (m_pILogWrite)
    {
        m_pILogWrite->Release();
    }

    if (m_pILogWriteAsynch)
    {
        m_pILogWriteAsynch->Release();
    }

    if (m_ILogRecordPointer)
    {
        m_ILogRecordPointer->Release();
    }

    if (m_pILogStorage)
    {
        m_pILogStorage->Release();
    }

    if (m_pILogInit)
    {
        m_pILogInit->Release();
    }

    if (m_pILogRead)
    {
        m_pILogRead->Release();
    }
}

/*====================================================
CLogger::LogExists
    Checks existance of the log file
=====================================================*/
BOOL CLogger::LogExists()
{
  HANDLE hFile = CreateFileA(
        m_szFileName,           // pointer to name of the file
        GENERIC_READ,           // access (read-write) mode
        FILE_SHARE_READ,        // share mode
        0,                      // pointer to security attributes
        OPEN_EXISTING,          // how to create
        0,                      // file attributes
        NULL);                  // handle to file with attributes to copy)

  if (hFile != INVALID_HANDLE_VALUE)
  {
      CloseHandle(hFile);
      return TRUE;
  }
  else
  {
      return FALSE;
  }
}


/*====================================================
CLogger::PreInit
    PreInits the logger 
=====================================================*/
HRESULT CLogger::PreInit(BOOL *pfLogExists)
{
    // Get log filename from registry or from default
    ChooseFileName(FALCON_DEFAULT_LOGMGR_PATH, FALCON_LOGMGR_PATH_REGNAME); 

    // Load log manager and get it's CF interface
	HRESULT hr = GetLogMgr();
    if (FAILED(hr))
    {
       REPORT_CATEGORY(MQ_ERROR_CANT_INIT_LOGGER, CATEGORY_KERNEL);
       return LogHR(hr, s_FN, 20);
    }

    // Consult storage directory and figure out whether the QMLog exists
    if (LogExists())
    {
        *pfLogExists = TRUE;
    }
    else
    {
        *pfLogExists = FALSE;

        hr = CreateLogFile();
        if (FAILED(hr))
        {
           REPORT_CATEGORY(MQ_ERROR_CANT_INIT_LOGGER, CATEGORY_KERNEL);
           return LogHR(hr, s_FN, 30);
        }

        hr = InitLog();						// Try to init log file
	    CHECK_RETURN(1010);

	    hr = CreateInitialChkpoints();	    // We need 2 checkpoints in the very beginning
		CHECK_RETURN(1020);

        hr = InitLogRead();					// Get Read interface
	    CHECK_RETURN(1030);

        hr = m_pILogRead->GetCheckpoint(1, &m_lrpCurrent);
        DBGMSG((DBGMOD_LOG, DBGLVL_INFO, TEXT("GetCheckpoint in ReadToEnd: lrp=%I64x, hr=%x"), m_lrpCurrent.QuadPart, hr));
	    CHECK_RETURN(1040);
    }

    return MQ_OK;
}


/*====================================================
CLogger::Init
    Inits the logger data
=====================================================*/
HRESULT CLogger::Init(PULONG pulVerInSeq, 
                      PULONG pulVerXact, 
                      ULONG ulNumCheckpointFromTheEnd)
{
    HRESULT hr = MQ_OK;

	hr = InitLog();						// Try to init log file
	CHECK_RETURN(1050);

    hr = InitLogRead();					// Get Read interface
	CHECK_RETURN(1060);

    // Find LRP of the 1st record after X-st checkpoint
	hr = m_pILogRead->GetCheckpoint(ulNumCheckpointFromTheEnd, &m_lrpCurrent);
    DBGMSG((DBGMOD_LOG, DBGLVL_INFO, TEXT("GetCheckpoint: lrp=%I64x, hr=%x"), m_lrpCurrent.QuadPart, hr));
	CHECK_RETURN(1070);

    // Read 1st record after last checkpoint
    ULONG   ulSize;
	USHORT  usType;

    hr = m_pILogRead->ReadLRP(m_lrpCurrent,	&ulSize, &usType);
    DBGMSG((DBGMOD_LOG, DBGLVL_INFO, TEXT("ReadLRP in ReadLRP: lrp=%I64x, hr=%x"), m_lrpCurrent.QuadPart, hr));
	CHECK_RETURN(1080);

    if (usType != LOGREC_TYPE_CONSOLIDATION ||
        ulSize != sizeof(ConsolidationRecord))
    {
        DBGMSG((DBGMOD_LOG, DBGLVL_ERROR, TEXT("No consolidation record")));
        return LogHR(MQ_ERROR_CANNOT_READ_CHECKPOINT_DATA, s_FN, 40);
    }

    ConsolidationRecord ConsData;
    hr = m_pILogRead->GetCurrentLogRecord((PCHAR)&ConsData);
	CHECK_RETURN(1090);

    *pulVerInSeq = ConsData.m_ulInSeqVersion;
    *pulVerXact  = ConsData.m_ulXactVersion; 

    return LogHR(hr, s_FN, 50);
}

/*====================================================
CLogger::Init_Legacy
    Inits the logger data from the old-style data after upgrade
=====================================================*/
HRESULT CLogger::Init_Legacy()
{
    HRESULT hr;

	hr = InitLog();						// Try to init log file
	CHECK_RETURN(1100);

	hr = InitLogRead();					// Get Read interface
	CHECK_RETURN(1120);

    // Find LRP of the 1st record after last checkpoint
	hr = m_pILogRead->GetCheckpoint(1, &m_lrpCurrent);
    DBGMSG((DBGMOD_LOG, DBGLVL_INFO, TEXT("GetCheckpoint: lrp=%I64x, hr=%x"), m_lrpCurrent.QuadPart, hr));
	CHECK_RETURN(1130);

    return MQ_OK;
}

/*====================================================
CLogger::Recover
    Recovers from the logger data
=====================================================*/
HRESULT CLogger::Recover()
{
    HRESULT hr = MQ_OK;

    try
    {
        // Starting recovery stage
        m_fInRecovery = TRUE;

		hr = ReadToEnd(RecoveryFromLogFn);	// Recover record after record
        DBGMSG((DBGMOD_LOG, DBGLVL_INFO, TEXT("Log init: Read to end, hr=%x"),hr));
        if (hr == IDS_DTC_W_LOGENDOFFILE) 		        // normally returns EOF code
        {
            hr = S_OK;
        }
		CHECK_RETURN(1140);

        // Starting recovery stage
        m_fInRecovery = FALSE;

		ReleaseReadStream();				
		
		hr = InitLogWrite();
		CHECK_RETURN(1150);

		ReleaseLogInit();
		ReleaseLogCF();

        // Create flushing thread and coordinating event
        m_hFlusherEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        ASSERT(m_hFlusherEvent);
        if (m_hFlusherEvent == NULL)
        {
            return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 184);
        }

        DWORD dwThreadId;
        m_hFlusherThread = CreateThread( NULL,
                                    0,
                                    FlusherThreadRoutine,
                                    0,
                                    0,
                                    &dwThreadId);
        ASSERT(m_hFlusherThread);

        // Schedule first periodical flushing
        DWORD   dwDef = FALCON_DEFAULT_RM_FLUSH_INTERVAL;
        READ_REG_DWORD(m_ulCheckpointInterval,
                       FALCON_RM_FLUSH_INTERVAL_REGNAME,
                       &dwDef ) ;
    
        ExSetTimer(&m_CheckpointTimer, CTimeDuration::FromMilliSeconds(m_ulCheckpointInterval));
    }
	catch(...)
	{
        REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL,
                                          MSMQ_INTERNAL_ERROR,
                                          1,
                                          L"CLogger::Init"));
        hr = MQ_ERROR;
	}

    return LogHR(hr, s_FN, 60);
}

/*====================================================
CLogger::Activate
    Activates the logger writing
=====================================================*/
void CLogger::Activate()
{
    m_fActive = TRUE;
}

/*====================================================
CLogger::Active
    Indicates that the logger is active
=====================================================*/
BOOL CLogger::Active()
{
    return m_fActive;
}

/*====================================================
CLogger::InRecovery
    Indicates that the logger is in a recovery stage
=====================================================*/
BOOL CLogger::InRecovery()
{
    return m_fInRecovery;
}

/*====================================================
CLogger::ChooseFileName
    Gets from Registry or from defaults file pathname
=====================================================*/
void CLogger::ChooseFileName(WCHAR *wszDefFileName, WCHAR *wszRegKey)
{
	WCHAR  wsz[1000];
    WCHAR  wszFileName[1000]; // log storage name

	// Prepare initial log file pathname
	wcscpy(wsz, L"\\");
	wcscat(wsz, wszDefFileName);

    if(!GetRegistryStoragePath(wszRegKey, wszFileName, wsz))
    {
        if (!GetRegistryStoragePath(FALCON_XACTFILE_PATH_REGNAME, wszFileName, wsz))
        {
            wcscpy(wszFileName,L"C:");
			wcscat(wszFileName,wsz);
        }
    }

    size_t sz = wcstombs(m_szFileName, wszFileName, sizeof(m_szFileName));
    ASSERT(sz == wcslen(wszFileName));

	DBG_USED(sz);

	// Prepare logger parameters 
	DWORD dwDef;

    dwDef = FALCON_DEFAULT_LOGMGR_TIMERINTERVAL;
    READ_REG_DWORD(m_uiTimerInterval,
                   FALCON_LOGMGR_TIMERINTERVAL_REGNAME,
                   &dwDef ) ;

    dwDef = FALCON_DEFAULT_LOGMGR_FLUSHINTERVAL;
    READ_REG_DWORD(m_uiFlushInterval,
                   FALCON_LOGMGR_FLUSHINTERVAL_REGNAME,
                   &dwDef ) ;

    dwDef = FALCON_DEFAULT_LOGMGR_CHKPTINTERVAL;
    READ_REG_DWORD(m_uiChkPtInterval,
                   FALCON_LOGMGR_CHKPTINTERVAL_REGNAME,
                   &dwDef ) ;

    dwDef = FALCON_DEFAULT_LOGMGR_SLEEP_ASYNCH;
    READ_REG_DWORD(m_uiSleepAsynch,
                   FALCON_LOGMGR_SLEEP_ASYNCH_REGNAME,
                   &dwDef ) ;
    
    dwDef = FALCON_DEFAULT_LOGMGR_REPEAT_ASYNCH;
    READ_REG_DWORD(m_uiAsynchRepeatLimit,
                   FALCON_LOGMGR_REPEAT_ASYNCH_REGNAME,
                   &dwDef ) ;
    
    dwDef = FALCON_DEFAULT_LOGMGR_BUFFERS;
    READ_REG_DWORD(m_ulLogBuffers,
                   FALCON_LOGMGR_BUFFERS_REGNAME,
                   &dwDef ) ;

    dwDef = FALCON_DEFAULT_LOGMGR_SIZE;
    READ_REG_DWORD(m_ulLogSize,
                   FALCON_LOGMGR_SIZE_REGNAME,
                   &dwDef ) ;

}

/*====================================================
CLogger::GetLogMgr
    Loads the log mgr library and gets ClassFactory interface
=====================================================*/
HRESULT CLogger::GetLogMgr(void)
{
	HRESULT   hr;
	HINSTANCE hIns;
	FARPROC   farproc;
	GET_CLASS_OBJECT getClassObject;
	                                                                             	                                                                             
    hIns = LoadLibrary(L"MqLogMgr.dll");
	if (!hIns)
	{
		return LogHR(MQ_ERROR_LOGMGR_LOAD, s_FN, 70);
	}

	farproc = GetProcAddress(hIns,"DllGetClassObject");
	getClassObject = (GET_CLASS_OBJECT) farproc;
	if (!getClassObject)
	{
		return LogHR(MQ_ERROR_LOGMGR_LOAD, s_FN, 80);
	}

 	hr = getClassObject(
 				CLSID_CLogMgr, 
 				IID_IClassFactory, 
 				(void **)&m_pCF);
	if (FAILED(hr))
	{
		LogHR(hr, s_FN, 90);
        return MQ_ERROR_LOGMGR_LOAD;
	}
	
	return LogHR(hr, s_FN, 100);
}

/*===================================================
CLogger::InitLog
    Loads the log mgr library and gets it's interfaces
=====================================================*/
HRESULT CLogger::InitLog()
{
	// Create LogInit instance
	ASSERT(m_pCF);
	HRESULT hr = m_pCF->CreateInstance(
 					NULL, 
 					IID_ILogInit, 
 					(void **)&m_pILogInit);
	CHECK_RETURN(1160);

	// Init log manager
	ASSERT(m_pILogInit);
	hr = m_pILogInit->Init(
				&m_ulFileSize,		// Total storage capacity
				&m_ulAvailableSpace,// Available space
 				m_szFileName,		// Full file spec
 				0,					// File initialization signature
 				TRUE,				// fFixedSize
 				0,					// uiTimerInterval  
 				0,					// uiFlushInterval  
				0,					// uiChkPtInterval  
				m_ulLogBuffers);    // logbuffers
	if (hr != S_OK)
	{
		m_pILogInit->Release();
		m_pILogInit = NULL;

        if(SUCCEEDED(hr))
        {
            //
            // Workaround bug 8336; logmgr might return non zero error codes
            // set the retunred value to be HRESULT value.
            //
            LogMsgHR(hr, s_FN, 110);        // Use LogMsgHR here so that we will have the failure code log
            hr = MQ_ERROR_CANT_INIT_LOGGER;
            return hr;
        }
        else
            return LogHR(hr, s_FN, 115);
		
	}

	// Get ILogStorage interface
 	hr = m_pILogInit->QueryInterface(IID_ILogStorage, (void **)&m_pILogStorage);
	CHECK_RETURN(1170);

	// Get ILogRecordPointer interface
	hr = m_pILogStorage->QueryInterface(IID_ILogRecordPointer, (void **)&m_ILogRecordPointer);
    CHECK_RETURN(1180);
	
	return LogHR(hr, s_FN, 120);
}

/*===================================================
CLogger::CreateLogFile
    Creates and preformats log file
=====================================================*/
HRESULT CLogger::CreateLogFile(void)
{
	// Get ILogCreateStorage interface
    R<ILogCreateStorage> pILogCreateStorage;
	ASSERT(m_pCF);
 	HRESULT hr = m_pCF->CreateInstance(
 					NULL, 
 					IID_ILogCreateStorage, 
 					(void **)&pILogCreateStorage.ref());
    CHECK_RETURN(1190);

	// Create storage 
	hr = pILogCreateStorage->CreateStorage(                                  
	  							m_szFileName,		// ptstrFullFileSpec       
	  							m_ulLogSize,		// ulLogSize               
 	  							0x0,				// ulInitSig               
  	  							TRUE,				// Overwrite               
 	  							m_uiTimerInterval,	
	  							m_uiFlushInterval,	
	  							m_uiChkPtInterval);	

    if (hr != S_OK)
	{
    	LogMsgHR(hr, s_FN, 1200);
        if(SUCCEEDED(hr))
        {
            //
            // Workaround bug 8336; logmgr might return non zero error codes
            // set the return value to be HRESULT value.
            //
            hr = MQ_ERROR_CANT_INIT_LOGGER;
        }
        return hr;
    }

	
    
    hr = pILogCreateStorage->CreateStream("Streamname");                     
    CHECK_RETURN(1210);

	return LogHR(hr, s_FN, 130);
}

/*===================================================
CLogger::LogEmptyRec
    Writes empty log record
=====================================================*/
HRESULT CLogger::LogEmptyRec(void)
{
    HRESULT hr = MQ_OK;
	EmptyRecord  empty;

    AP<LOGREC> plgr = CreateLOGREC(LOGREC_TYPE_EMPTY, &empty, sizeof(empty));
	ASSERT(plgr);

    LRP lrpTmpLRP;
    LRP lrpLastPerm;
	memset((char *)&lrpLastPerm, 0, sizeof(LRP));

	// Write it down to get current lrp
	ULONG ulcbNumRecs = 0;
	ASSERT(m_pILogWrite);
	hr  =  m_pILogWrite->Append(
							plgr,
							(ULONG)1,			// # records
							&lrpTmpLRP,
							&ulcbNumRecs,
							&lrpLastPerm,		// pLRPLastPerm
							TRUE,				// fFlushNow
							&m_ulAvailableSpace);				
    DBGMSG((DBGMOD_LOG, DBGLVL_INFO, TEXT("Append in LogEmptyRec: lrp=%I64x, hr=%x"), lrpTmpLRP.QuadPart, hr));

    if (hr == S_OK)
    {
        SetCurrent(lrpTmpLRP);
    }

	CHECK_RETURN(1220);
	ASSERT(ulcbNumRecs==1);

    return LogHR(hr, s_FN, 140);
}


/*===================================================
CLogger::LogConsolidationRec
    Logs down the Consolidation Record
=====================================================*/
HRESULT CLogger::LogConsolidationRec(ULONG ulInSeq, ULONG ulXact, HANDLE hEvent)
{
    if (!m_fActive)
    {
        return S_OK;
    }

    DBGMSG((DBGMOD_LOG, DBGLVL_TRACE, TEXT("Log Consolidation: InSeq=%d, Xact=%d"), ulInSeq,ulXact));

    CConsolidationRecord *plogRec = new CConsolidationRecord(ulInSeq, ulXact);
    CConsolidationFlush  *pNotify = new CConsolidationFlush(hEvent);

    HRESULT hr = Log(
        LOGREC_TYPE_CONSOLIDATION, 
        TRUE, 
        pNotify, 
        &plogRec->m_Data,
        sizeof(ConsolidationRecord)); 

    ASSERT(SUCCEEDED(hr));
    LogHR(hr, s_FN, 175);
    CRASH_POINT(107);
    
    delete plogRec;
    return LogHR(hr, s_FN, 150);
}


/*===================================================
CLogger::CreateInitialChkpoints
    Creates 2 initial checkpoints in the beginning of a new file
	They are needed for smooth recovery code
=====================================================*/
HRESULT CLogger::CreateInitialChkpoints(void)
{
	// Initial writing empty record 
	HRESULT hr = InitLogWrite();
	CHECK_RETURN(1230);

    hr = LogEmptyRec();
    CHECK_RETURN(1240);

	// Write 2 checkpoints
	hr = m_pILogWrite->SetCheckpoint(m_lrpCurrent);
    DBGMSG((DBGMOD_LOG, DBGLVL_ERROR, TEXT("SetCheckpoint in CreateInitialChkpoints1: lrp=%I64x, hr=%x"), m_lrpCurrent.QuadPart, hr));
	CHECK_RETURN(1250);

	hr = m_pILogWrite->SetCheckpoint(m_lrpCurrent);  
    DBGMSG((DBGMOD_LOG, DBGLVL_ERROR, TEXT("SetCheckpoint in CreateInitialChkpoints2: lrp=%I64x, hr=%x"), m_lrpCurrent.QuadPart, hr));
	CHECK_RETURN(1260);

	ReleaseWriteStream();
	return S_OK;
}

/*===================================================
CLogger::InitLogWrite
    Initializes the log for writing
=====================================================*/
HRESULT CLogger::InitLogWrite(void)
{
	ASSERT(m_pILogStorage);
	HRESULT hr = m_pILogStorage->OpenLogStream("Streamname", STRMMODEWRITE, (void **)&m_pILogWrite);
	CHECK_RETURN(1270);

 	hr = m_pILogWrite->QueryInterface(IID_ILogWriteAsynch, (void **)&m_pILogWriteAsynch);
	CHECK_RETURN(1280);

	hr = m_pILogWriteAsynch->Init(1000);	// cbMaxOutstandingWrites  ... tuning
	CHECK_RETURN(1290);

	return LogHR(hr, s_FN, 160);
}

/*===================================================
CLogger::InitLogRead
    Initializes the log for reading
=====================================================*/
HRESULT CLogger::InitLogRead(void)
{
	ASSERT(m_pILogStorage);
	HRESULT hr = m_pILogStorage->OpenLogStream("Streamname", STRMMODEREAD, (void **)&m_pILogRead); 	// also OpenLogStreamByClassID
	CHECK_RETURN(1300);

	ASSERT(m_pILogRead);
 	hr  =  m_pILogRead->ReadInit();
	CHECK_RETURN(1310);

	return LogHR(hr, s_FN, 170);
}


/*===================================================
CLogger::ReleaseWriteStream
    Releases log writing interfaces
=====================================================*/
void CLogger::ReleaseWriteStream(void)
{
	ASSERT(m_pILogWrite);
	m_pILogWrite->Release();
	m_pILogWrite = NULL;

	ASSERT(m_pILogWriteAsynch);
	m_pILogWriteAsynch->Release();
	m_pILogWriteAsynch = NULL;
}

/*===================================================
CLogger::ReleaseReadStream
    Releases log reading interfaces
=====================================================*/
void CLogger::ReleaseReadStream(void)
{
	ASSERT(m_pILogRead);
	m_pILogRead->Release();
	m_pILogRead = NULL;
}

/*===================================================
CLogger::ReleaseLogStorage
    Releases log storage interfaces
=====================================================*/
void CLogger::ReleaseLogStorage()
{
	ASSERT(m_pILogStorage);
	m_pILogStorage->Release();
	m_pILogStorage = NULL;

	ASSERT(m_ILogRecordPointer);
	m_ILogRecordPointer->Release();
	m_ILogRecordPointer = NULL;
}

/*===================================================
CLogger::ReleaseLogInit
    Releases log init interfaces
=====================================================*/
void CLogger::ReleaseLogInit()
{
	ASSERT(m_pILogInit);
	m_pILogInit->Release();
	m_pILogInit = NULL;
}

/*===================================================
CLogger::ReleaseLogCF
    Releases log class factory interfaces
=====================================================*/
void CLogger::ReleaseLogCF()
{
	ASSERT(m_pCF);
	m_pCF->Release();
	m_pCF = NULL;
}

/*===================================================
CLogger::CheckPoint
    Writes the checkpoint; blocks till the operation end
=====================================================*/
HRESULT CLogger::Checkpoint()
{
    if (!m_fActive)
    {
        return MQ_OK;
    }

    HRESULT hr = ResetEvent(m_hChkptReadyEvent);
    ASSERT(SUCCEEDED(hr));

    CChkptNotification *pNotify = new CChkptNotification(m_hChkptReadyEvent);
    LRP lrpCkpt;

  	ASSERT(m_pILogWriteAsynch);
    hr = m_pILogWriteAsynch->SetCheckpoint(m_lrpCurrent, pNotify, &lrpCkpt);

    // Waiting till checkpoint record is written into the log
    if (SUCCEEDED(hr))
    {
        DWORD dwResult = WaitForSingleObject(m_hChkptReadyEvent, MAX_WAIT_FOR_FLUSH_TIME);
        ASSERT(dwResult == WAIT_OBJECT_0);
        if (dwResult != WAIT_OBJECT_0)
        {
	        LogIllegalPoint(s_FN, 208);
			hr = MQ_ERROR;   
        }
    }

    DBGMSG((DBGMOD_LOG, DBGLVL_INFO, TEXT("SetCheckpoint in Checkpoint: lrp=%I64x, hr=%x"), m_lrpCurrent.QuadPart, hr));
    return LogHR(hr, s_FN, 180);
}

/*===================================================
CLogger::MakeCheckPoint
    Initiates checkpoint 
    Return code shows only success in initiating checkpoint, not of the writing checkpoint
=====================================================*/
BOOL CLogger::MakeCheckpoint(HANDLE hComplete)
{
    //
    // Don't do checkpoint if recovery did not finish
    //
    if (m_hFlusherEvent == NULL)
    {
          return LogBOOL(FALSE, s_FN, 217);
    }

    m_fDirty = TRUE;   
    m_hCompleteEvent = hComplete;

    SetEvent(m_hFlusherEvent);

    DBGMSG((DBGMOD_LOG, DBGLVL_INFO, TEXT("Log checkpoint ordered")));
    return TRUE;
}

/*===================================================
CLogger::Log
    Logs really
=====================================================*/
HRESULT CLogger::Log(
            USHORT          usRecType,      // log record type
            BOOL            fFlush,			// flush hint
            CAsynchSupport *pCAsynchSupport,// notification element
			VOID           *pData,          // log data 
            ULONG           cbData)  	
{
    HRESULT hr;
    DBGMSG((DBGMOD_LOG, DBGLVL_INFO, 
            TEXT("Log record written: type=%d, len=%d"),
            usRecType,cbData));

    if (!m_fActive)
    {
        return MQ_OK;
    }

    IsolateFlushing(); // separates from flushing

    m_fDirty = TRUE;   // remembers changes since Flush

    AP<LOGREC>plgr = CreateLOGREC (usRecType, 
								   pData, 
								   cbData);  
	ASSERT(plgr);

	LRP lrpTmpLRP;

    if (pCAsynchSupport)
    {
    	ASSERT(m_pILogWriteAsynch);

	    hr = m_pILogWriteAsynch->AppendAsynch(
									plgr, 
									&lrpTmpLRP,
									pCAsynchSupport,
									fFlush,   //hint
									&m_ulAvailableSpace);

        for (UINT iRpt=0; 
             iRpt<m_uiAsynchRepeatLimit && hr == IDS_DTC_W_LOGNOMOREASYNCHWRITES; 
             iRpt++)
        {
            Sleep(m_uiSleepAsynch);
    	    hr = m_pILogWriteAsynch->AppendAsynch(
									plgr,
									&lrpTmpLRP,
									pCAsynchSupport,
									fFlush,   //hint
									&m_ulAvailableSpace);
            DBGMSG((DBGMOD_LOG, DBGLVL_INFO, TEXT("AppendAsynch in Log: lrp=%I64x, hr=%x"), lrpTmpLRP.QuadPart, hr));
        }

        if (FAILED(hr))
        {
            // Logging failed. Shutting down.   
            TCHAR szReturnCode[20];
            _ultot(hr,szReturnCode,16);
            REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL,
                                              CANNOT_LOG, 
                                              1, 
                                              szReturnCode));
            ASSERT(0);
            exit(EXIT_FAILURE);  // BUGBUG: Not decided yet. To finalize before checkin.
        }

        InterlockedIncrement(&g_lPendingNotifications);

        #ifdef _DEBUG
        if (iRpt > 0)
        {
            DBGMSG((DBGMOD_LOG, DBGLVL_WARNING, 
                TEXT("Log: append asynch slow-down: sleep %d msec."),
                iRpt*m_uiSleepAsynch));
        }
        #endif
    }
    else
    {
	    LRP lrpLastPerm;
	    ULONG ulcbNumRecs;
    	ASSERT(m_pILogWrite);

        hr  =  m_pILogWrite->Append(
							    plgr,
							    (ULONG)1,			// # records
							    &lrpTmpLRP,
							    &ulcbNumRecs,
							    &lrpLastPerm,		
							    fFlush,				// hint
							    &m_ulAvailableSpace);				
        DBGMSG((DBGMOD_LOG, DBGLVL_INFO, TEXT("Append in Log: lrp=%I64x, hr=%x"), lrpTmpLRP.QuadPart, hr));

        if (FAILED(hr))
        {
            // Essentially we cannot continue. Should exit immediately    
            TCHAR szReturnCode[20];
            _ultot(hr,szReturnCode,16);
            REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL,
                                              CANNOT_LOG, 
                                              1, 
                                              szReturnCode));
            ASSERT(0);
            exit(EXIT_FAILURE);

        }
	    ASSERT(ulcbNumRecs==1);
    }

	if (hr == S_OK)
    {
		SetCurrent(lrpTmpLRP);
        if (m_ulAvailableSpace < m_ulLogSize * 3 / 4)
        {
            // Log is more than 3/4 full - worth to checkpoint 
            SetEvent(m_hFlusherEvent);
        }
    }

	return LogHR(hr, s_FN, 190);
}


/*===================================================
CLogger::LogInSeqRecSrmp
    Logs down the Incoming Sequence Update record with srmp order ack
=====================================================*/
HRESULT CLogger::LogInSeqRecSrmp(
            BOOL          fFlush,			// flush hint
            CInSeqFlush  *pNotify,			// notification element
			CInSeqRecordSrmp *pInSeqRecord)  	// log data 
{
    if (!m_fActive)
    {
        return MQ_OK;
    }

     
	ULONG ul;
	const BYTE* pData = pInSeqRecord->Serialize(&ul);

    HRESULT hr = Log(
                     LOGREC_TYPE_INSEQ_SRMP, 
                     fFlush, 
                     pNotify, 
                     (void*)pData,
                     ul);

    return LogHR(hr, s_FN, 200); 
}



/*===================================================
CLogger::LogInSeqRec
    Logs down the Incoming Sequence Update record
=====================================================*/
HRESULT CLogger::LogInSeqRec(
            BOOL          fFlush,			// flush hint
            CInSeqFlush  *pNotify,			// notification element
			CInSeqRecord *pInSeqRecord)  	// log data 
{
    if (!m_fActive)
    {
        return MQ_OK;
    }

    DBGMSG((DBGMOD_LOG, DBGLVL_TRACE, 
            TEXT("Log InSeq: SeqID=%I64d, SeqN=%d"),
            pInSeqRecord->m_Data.liSeqID,pInSeqRecord->m_Data.ulNextSeqN));

    // Calculating real length of the record
    ULONG ul = sizeof(InSeqRecord) - 
               sizeof(pInSeqRecord->m_Data.wszDirectName) + 
               sizeof(WCHAR) * ( wcslen(pInSeqRecord->m_Data.wszDirectName) + 1 );
			  


    HRESULT hr = Log(
                     LOGREC_TYPE_INSEQ, 
                     fFlush, 
                     pNotify, 
                     &pInSeqRecord->m_Data,
                     ul);
    return LogHR(hr, s_FN, 205); 
}

/*===================================================
CLogger::LogXactStatusRec
    Logs down the Xact Status record
=====================================================*/
HRESULT CLogger::LogXactStatusRec(
            BOOL               fFlush,			// flush hint
            CXactStatusFlush  *pNotify,			// notification element
			CXactStatusRecord *pXactStatusRecord)  	// log data 
{
    if (!m_fActive)
    {
        return MQ_OK;
    }

    HRESULT hr2 = Log(
        LOGREC_TYPE_XACT_STATUS, 
        fFlush, 
        pNotify, 
        &pXactStatusRecord->m_Data,
        sizeof(XactStatusRecord)); 
    return LogHR(hr2, s_FN, 210);

}

/*===================================================
CLogger::LogPrepInfoRec
    Logs down the PrepareInfo record
=====================================================*/
HRESULT CLogger::LogPrepInfoRec(
            BOOL              fFlush,			// flush hint
            CXactStatusFlush *pNotify,			// notification element
			CPrepInfoRecord  *pPrepInfoRecord) 	// log data 
{
    if (!m_fActive)
    {
        return MQ_OK;
    }

    HRESULT hr2 = Log(
        LOGREC_TYPE_XACT_PREPINFO, 
        fFlush, 
        pNotify, 
        pPrepInfoRecord->m_pData,
        sizeof(PrepInfoRecord) + pPrepInfoRecord->m_pData->m_cbPrepInfo); 
    return LogHR(hr2, s_FN, 220);
}

/*===================================================
CLogger::LogXactDataRec
    Logs down the XactData record
=====================================================*/
HRESULT CLogger::LogXactDataRec(
            BOOL               fFlush,			// flush hint
            CXactStatusFlush  *pNotify,			// notification element
			CXactDataRecord   *pXactDataRecord) // log data 
{
    if (!m_fActive)
    {
        return MQ_OK;
    }

    HRESULT hr2 = Log(
        LOGREC_TYPE_XACT_DATA, 
        fFlush, 
        pNotify, 
        &pXactDataRecord->m_Data,
        sizeof(XactDataRecord)); 

    return LogHR(hr2, s_FN, 230);
}


/*===================================================
CLogger::LogXactPhase
    Logs down the Xact life phase: creation, deletion
=====================================================*/
void CLogger::LogXactPhase(ULONG ulIndex, TXACTION txAction)
{
    if (!m_fActive)
    {
        return;
    }

    CXactStatusRecord *plogRec = 
        new CXactStatusRecord(ulIndex, txAction,  TX_UNINITIALIZED);
                                                  // ignored
    DBGMSG((DBGMOD_LOG, DBGLVL_TRACE, 
            TEXT("Log Xact Phase: Index=%d, Action=%d"),
            ulIndex,txAction));

    HRESULT hr = LogXactStatusRec(
        FALSE,							// flush hint
        NULL,  						    // notification element
        plogRec);						// log data 
    
    ASSERT(SUCCEEDED(hr));
    LogHR(hr, s_FN, 177);
    CRASH_POINT(107);
    
    delete plogRec;
    return;
}


/*===================================================
CLogger::LogXactFlags
    Logs down the Xact Flags
=====================================================*/
void CLogger::LogXactFlags(CTransaction *pTrans)
{
    if (!m_fActive)
    {
        return;
    }

    HRESULT  hr;

    DBGMSG((DBGMOD_LOG, DBGLVL_TRACE, 
            TEXT("Log Xact Flags: Index=%d, Flags=%d"),
            pTrans->GetIndex(), pTrans->GetFlags()));

    CXactStatusRecord *plogRec = 
        new CXactStatusRecord(pTrans->GetIndex(), TA_STATUS_CHANGE,  pTrans->GetFlags());
    hr = g_Logger.LogXactStatusRec(
             FALSE,							// flush hint
             NULL,  						// notification element
             plogRec);						// log data 

    ASSERT(SUCCEEDED(hr));
    LogHR(hr, s_FN, 178);
    CRASH_POINT(108);

    delete plogRec;
    return;
}

/*===================================================
CLogger::LogXactFlagsAndWait
    Logs down the Xact Flags; asks for continue xact after flush
=====================================================*/
void CLogger::LogXactFlagsAndWait(
                              TXFLUSHCONTEXT tcContext,
                              CTransaction   *pCTrans,
                              BOOL fFlushNow //=FALSE
							  )
{
    if (!m_fActive)
    {
        pCTrans->AddRef();  // to keep it alive during writing
        pCTrans->LogFlushed(tcContext, MQ_OK);
    }

    DBGMSG((DBGMOD_LOG, DBGLVL_TRACE, 
            TEXT("Log Xact Flags And Wait: Index=%d, Flags=%d"),
            pCTrans->GetIndex(),pCTrans->GetFlags()));

    pCTrans->AddRef();  // to keep it alive during writing

    CXactStatusRecord *plogRec = 
        new CXactStatusRecord(pCTrans->GetIndex(),
                              TA_STATUS_CHANGE,  
                              pCTrans->GetFlags());

    CXactStatusFlush *pNotify = 
        new CXactStatusFlush(pCTrans, tcContext);

    HRESULT hr = LogXactStatusRec(
             fFlushNow,						// flush hint
             pNotify,						// notification element
             plogRec);						// log data 

    ASSERT(SUCCEEDED(hr));
    LogHR(hr, s_FN, 179);
    CRASH_POINT(104);

    delete plogRec;
    return;
}


/*===================================================
CLogger::LogXactPrepareInfo
    Logs down the Xact Prepare Info
=====================================================*/
void CLogger::LogXactPrepareInfo(
                              ULONG  ulIndex,
                              ULONG  cbPrepareInfo,
                              UCHAR *pbPrepareInfo)
{
    if (!m_fActive)
    {
        return;
    }

    CPrepInfoRecord *plogRec = 
        new CPrepInfoRecord(ulIndex, 
                            cbPrepareInfo, 
                            pbPrepareInfo);

    DBGMSG((DBGMOD_LOG, DBGLVL_TRACE, 
            TEXT("Log Xact PrepInfo: Index=%d, Len=%d"),
            ulIndex,cbPrepareInfo));
        
    HRESULT hr = g_Logger.LogPrepInfoRec(
             FALSE,							// flush hint
             NULL,  						// notification element
             plogRec);						// log data 
        
    ASSERT(SUCCEEDED(hr));
    LogHR(hr, s_FN, 181);
    CRASH_POINT(105);

    delete plogRec;
    return;
}

/*===================================================
CLogger::LogXactData
    Logs down the Xact Data (uow, SeqNum)
=====================================================*/
void  CLogger::LogXactData(              
                ULONG    ulIndex,
                ULONG    ulSeqNum,
                BOOL     fSinglePhase,
                const    XACTUOW  *puow)
{
    if (!m_fActive)
    {
        return;
    }

    CXactDataRecord *plogRec = 
        new CXactDataRecord(ulIndex, 
                            ulSeqNum, 
                            fSinglePhase,
                            puow);

    DBGMSG((DBGMOD_LOG, DBGLVL_TRACE, 
            TEXT("Log Xact Data: Index=%d, SeqNum=%d, Single=%d"),
            ulIndex,ulSeqNum,fSinglePhase));
        
    HRESULT hr = g_Logger.LogXactDataRec(
             FALSE,							// flush hint
             NULL,  						// notification element
             plogRec);						// log data 
        
    ASSERT(SUCCEEDED(hr));
    LogHR(hr, s_FN, 182);
    CRASH_POINT(106);

    delete plogRec;
    return;
}

/*===================================================
CLogger::CreateLOGREC
    Creates log record
=====================================================*/
LOGREC *CLogger::CreateLOGREC(USHORT usUserType, PVOID pData, ULONG cbData)
{
	ULONG ulBytelength =  sizeof(LOGREC) + cbData;

	void *pvAlloc = new char[ulBytelength];
	ASSERT(pvAlloc);

	LOGREC * plgrLogRec = (LOGREC *)pvAlloc;
	memset(pvAlloc, 0, ulBytelength);
		
	plgrLogRec->pchBuffer	 = (char *)pvAlloc + sizeof(LOGREC);
	plgrLogRec->ulByteLength = ulBytelength - sizeof(LOGREC);
	plgrLogRec->usUserType	 = usUserType;

	memcpy(plgrLogRec->pchBuffer, pData, cbData);

	return (plgrLogRec);
}


/*===================================================
CLogger::ReadToEnd
    Recovers by reading all records from the current position
=====================================================*/
HRESULT CLogger::ReadToEnd(LOG_RECOVERY_ROUTINE pf)
{
    HRESULT hr = MQ_OK;
	ASSERT(m_pILogRead);

	hr = ReadLRP(pf);
	CHECK_RETURN(1320);

    while (hr == S_OK)
	{
		hr = ReadNext(pf);
	}

	return LogHR(hr, s_FN, 240);
}

/*===================================================
CLogger::ReadLRP
    Reads the currently pointed record and calls recover function
=====================================================*/
HRESULT CLogger::ReadLRP(LOG_RECOVERY_ROUTINE pf)
{
	ULONG   ulSize;
	USHORT  usType;

	ASSERT(m_pILogRead);
	HRESULT hr = m_pILogRead->ReadLRP(
							m_lrpCurrent,
							&ulSize,
							&usType);
    DBGMSG((DBGMOD_LOG, DBGLVL_INFO, TEXT("ReadLRP in ReadLRP: lrp=%I64x, hr=%x"), m_lrpCurrent.QuadPart, hr));
	CHECK_RETURN(1340);

	AP<CHAR> pData = new CHAR[ulSize];
	ASSERT(pData);
	ASSERT(m_pILogRead);

	hr = m_pILogRead->GetCurrentLogRecord(pData);
	CHECK_RETURN(1350);

	(*pf)(usType, pData, ulSize);

	return LogHR(hr, s_FN, 250);
}


/*===================================================
CLogger::ReadNext
    Reads the next record and calls recover function
=====================================================*/
HRESULT CLogger::ReadNext(LOG_RECOVERY_ROUTINE pf)
{
	ULONG	ulSize;
	USHORT	usType;
	LRP		lrpOut;
	memset((char *)&lrpOut, 0, sizeof(LRP));

	HRESULT hr = m_pILogRead->ReadNext(&lrpOut, &ulSize, &usType);
    DBGMSG((DBGMOD_LOG, DBGLVL_INFO, TEXT("ReadNext in ReadNext: lrp=%I64x, hr=%x"), lrpOut.QuadPart, hr));
	CHECK_RETURN(1360);

	AP<CHAR> pData = new CHAR[ulSize];
	ASSERT(pData);
	ASSERT(m_pILogRead);

	hr = m_pILogRead->GetCurrentLogRecord(pData);
	CHECK_RETURN(1370);

	(*pf)(usType, pData, ulSize);

	return LogHR(hr, s_FN, 260);
}


/*===================================================
CLogger::FlusherEvent()
    Get method for the flusher coordination event 
=====================================================*/
HANDLE CLogger::FlusherEvent()
{
    return m_hFlusherEvent;
}


/*===================================================
CLogger::FlusherThread()
    Get method for the flusher thread handle
=====================================================*/
inline HANDLE CLogger::FlusherThread()
{
    return m_hFlusherThread;
}


/*===================================================
CLogger::Dirty()
    Get method for the Dirty flag - meaning logs since flush
=====================================================*/
BOOL CLogger::Dirty()
{
    return m_fDirty  && m_fActive;
}

/*===================================================
CLogger::ClearDirty()
    Set method for the Dirty flag - clearing away the flag
=====================================================*/
void CLogger::ClearDirty()
{
    m_fDirty = FALSE;
}


/*===================================================
CLogger::SignalCheckpointWriteComplete()
    Sets the event signalling write complete
=====================================================*/
void CLogger::SignalCheckpointWriteComplete()
{
    if (m_hCompleteEvent)
    {
        SetEvent(m_hCompleteEvent);
        m_hCompleteEvent = NULL;
    }
}

/*====================================================
IsolateFlushing
    Holds the caller up to the end of flushing
=====================================================*/
void IsolateFlushing()
{
    // EnterCriticalSection holds, then immediately releases it
    CS lock(g_crFlushing);  // separates from current logging
}


/*====================================================
FlusherThreadRoutine
    Thread routine of the flusher thread
=====================================================*/
static DWORD WINAPI FlusherThreadRoutine(LPVOID)
{
    HRESULT hr;
    HANDLE  hFlusherEvent = g_Logger.FlusherEvent();
    HANDLE hConsolidationEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (hConsolidationEvent == NULL)
    {
        LogNTStatus(GetLastError(), s_FN, 188);
        ASSERT(hConsolidationEvent != NULL);
    }

    while (1)
    {
        // Wait for the signal
        DWORD dwResult = WaitForSingleObject(hFlusherEvent, INFINITE);
        if (dwResult != WAIT_OBJECT_0)
        {
            LogNTStatus(GetLastError(), s_FN, 209);
            ASSERT(dwResult == WAIT_OBJECT_0);
        }

        DBGMSG((DBGMOD_LOG, DBGLVL_TRACE, TEXT("Log checkpoint awakened")));

        if (g_Logger.Dirty())
        {
            DBGMSG((DBGMOD_LOG, DBGLVL_WARNING, TEXT("Log checkpoint executed")));

            // Prior to locking g_crFlushing, we have to lock  - otherwise deadlock occurs
            CS lock1(g_pRM->CritSection());
            CS lock2(g_pRM->SorterCritSection());
            CS lock3(g_pInSeqHash->InSeqCritSection());

            // Stops new logging: no new logging will be started past this point 
            CS lock4(g_crFlushing);  

            // Separates from current logging (prevents m_lrpCurrent advance)
            CS lock5(g_crLogging);  

            DBGMSG((DBGMOD_LOG, DBGLVL_TRACE, TEXT("Log checkpoint: lock")));
         
            // Starting anew to track changes
            g_Logger.ClearDirty();

            // Saving the whole InSeqHash in ping-pong file
            hr = g_pInSeqHash->Save();
            if (FAILED(hr))
            {
                REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL,
                                              CHECKPOINT_SAVE_ERROR,
           