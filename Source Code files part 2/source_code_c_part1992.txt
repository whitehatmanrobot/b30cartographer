 SgExecute()
        {
            SignIn(AuthContext.ClientTypes.Xenon, 4);
        }
    }

    [StressTest(Priority=0)]
    public class SignIn_KeyExchange_1User_AsyncChallenge : TestBase_Stress
    {
        protected override void SgExecute()
        {
            SignIn(AuthContext.ClientTypes.Xenon, 1, 0x0010);
        }
    }

    [StressTest(Priority = 0)]
    public class SignIn_KeyExchange_1User_PC : TestBase_Stress
    {
        protected override void SgExecute ()
        {
            SignIn(AuthContext.ClientTypes.Panorama, 1);
        }
    }

    [StressTest(Priority=0)]
    public class Optional_Recv : TestBase_Stress
    {
        protected override void SgExecute()
        {
            // We will grab an SgClient from the local store, which has already been
            // signed in to the SG.  Remove from store and add it back at end, if necessary.
            SgClient sg = SgForm.GetSignedInClient(true);
            TEST_RESULTS result;

            try
            {
                result = Recv(sg);
            }
            catch (Exception e)
            {
                // Don't want to lose the client, add to free list
                DeleteClient(sg, "Recv exception: " + e.Message);
                throw;
            }

            if (result == TEST_RESULTS.FAILED)
            {
                DeleteClient(sg, "Recv failed");
                throw new SgTestException("Recv failed");
            }
            else
            {
                SgForm.PutSignedInClient(sg, false);

                if (result == TEST_RESULTS.NOT_EXECUTED)
                {
                    throw new DidNotExecuteException("Nothing to receive.");
                }
            }
        }
    }

    [StressTest(Priority=0)]
    public class Optional_SendChalResponse_Positive : TestBase_Stress
    {
        protected override void SgExecute()
        {
            // We will grab an SgClient from the local store, which has already been
            // signed in to the SG.  Remove from store and add it back at end, if necessary.
            SgClient sg = SgForm.GetSignedInClient(true);

            try
            {
                if (sg.timeToSendChalResponse > 0 &&
                    TimerMs > sg.timeToSendChalResponse)
                {
                    sg.SendChallengeResponse(false);
                    sg.timeToSendChalResponse = 0;
                    SgForm.PutSignedInClient(sg, false);
                    return;
                }
                SgForm.PutSignedInClient(sg, false);
            }
            catch (Exception e)
            {
                // Don't want to lose the client, add to free list
                DeleteClient(sg, "Optional_SendChalResponse exception: " + e.Message);
                throw;
            }

            throw new DidNotExecuteException("No challenge to respond to.");
        }
    }

    [StressTest(Priority=0)]
    public class Optional_SendChalResponse_Negative : TestBase_Stress
    {
        protected override void SgExecute()
        {
            // We will grab an SgClient from the local store, which has already been
            // signed in to the SG.  Remove from store and add it back at end, if necessary.
            SgClient sg = SgForm.GetSignedInClient(true);

            try
            {
                if (sg.timeToSendChalResponse > 0 &&
                    TimerMs > sg.timeToSendChalResponse)
                {
                    sg.SendChallengeResponse(true);
                    sg.timeToSendChalResponse = 0;
                    DeleteClient(sg, "Challenge kick");
                    return;
                }
                SgForm.PutSignedInClient(sg, false);
            }
            catch (Exception e)
            {
                // Don't want to lose the client, add to free list
                DeleteClient(sg, "Optional_SendChalResponse exception: " + e.Message);
                throw;
            }

            throw new DidNotExecuteException("No challenge to respond to.");
        }
    }
    #endregion


    #region Throughput

    [StressTest(Priority = 0)]
    public class Throughput_4payloadReflect : Throughput_Base
    {
        protected override void SgExecute ()
        {
            GoIfSignedIn(k_payload4, SGFakeService.ActionType.Reflect, 0, this.ServiceCycle, 0);
        }
    }

    [StressTest(Priority=0)]
    public class Throughput_16payloadReflect: Throughput_Base
    {
        protected override void SgExecute()
        {
            GoIfSignedIn(k_payload16, SGFakeService.ActionType.Reflect, 0, this.ServiceCycle, 0);
        }
    }

    [StressTest(Priority = 0)]
    public class Throughput_45payloadReflect : Throughput_Base
    {
        protected override void SgExecute ()
        {
            GoIfSignedIn(k_payload45, SGFakeService.ActionType.Reflect, 0, this.ServiceCycle, 0);
        }
    }

    [StressTest(Priority=0)]
    public class Throughput_160payloadReflect: Throughput_Base
    {
        protected override void SgExecute()
        {
            GoIfSignedIn(k_payload160, SGFakeService.ActionType.Reflect, 0, this.ServiceCycle, 0);
        }
    }

    [StressTest(Priority = 0)]
    public class Throughput_1200payloadReflect : Throughput_Base
    {
        protected override void SgExecute ()
        {
            GoIfSignedIn(k_payload1200, SGFakeService.ActionType.Reflect, 0, this.ServiceCycle, 0);
        }
    }

    [StressTest(Priority = 0)]
    public class Throughput_1244payloadReflect : Throughput_Base
    {
        protected override void SgExecute ()
        {
            GoIfSignedIn(k_payload1244, SGFakeService.ActionType.Reflect, 0, this.ServiceCycle, 0);
        }
    }

    [StressTest(Priority=0)]
    public class Throughput_1400payloadReflect: Throughput_Base
    {
        protected override void SgExecute()
        {
            GoIfSignedIn(k_payload1400, SGFakeService.ActionType.Reflect, 0, this.ServiceCycle, 0);
        }
    }

    [StressTest(Priority = 0)]
    public class Throughput_4payloadDrop : Throughput_Base
    {
        protected override void SgExecute ()
        {
            GoIfSignedIn(k_payload4, SGFakeService.ActionType.Drop, 0, this.ServiceCycle, 0);
        }
    }

    [StressTest(Priority = 0)]
    public class Throughput_16payloadDrop : Throughput_Base
    {
        protected override void SgExecute ()
        {
            GoIfSignedIn(k_payload16, SGFakeService.ActionType.Drop, 0, this.ServiceCycle, 0);
        }
    }

    [StressTest(Priority = 0)]
    public class Throughput_160payloadDrop : Throughput_Base
    {
        protected override void SgExecute ()
        {
            GoIfSignedIn(k_payload160, SGFakeService.ActionType.Drop, 0, this.ServiceCycle, 0);
        }
    }

    [StressTest(Priority = 0)]
    public class Throughput_1400payloadDrop : Throughput_Base
    {
        protected override void SgExecute ()
        {
            GoIfSignedIn(k_payload1400, SGFakeService.ActionType.Drop, 0, this.ServiceCycle, 0);
        }
    }

    [StressTest(Priority = 0)]
    public class Throughput_4payloadReflect1244 : Throughput_Base
    {
        protected override void SgExecute ()
        {
            GoIfSignedIn(k_payload4, SGFakeService.ActionType.Reflect, 155, this.ServiceCycle, 0);
        }
    }

    [StressTest(Priority = 0)]
    public class Throughput_1244payloadReflect8 : Throughput_Base
    {
        protected override void SgExecute ()
        {
            GoIfSignedIn(k_payload1244, SGFakeService.ActionType.Reflect, 1, this.ServiceCycle, 0);
        }
    }

    [StressTest(Priority = 0)]
    public class Throughput_16payloadReflect64 : Throughput_Base
    {
        protected override void SgExecute ()
        {
            GoIfSignedIn(k_payload16, SGFakeService.ActionType.Reflect, 8, this.ServiceCycle, 0);
        }
    }

    [StressTest(Priority = 0)]
    public class Throughput_16payloadReflect320 : Throughput_Base
    {
        protected override void SgExecute ()
        {
            GoIfSignedIn(k_payload16, SGFakeService.ActionType.Reflect, 40, this.ServiceCycle, 0);
        }
    }

    [StressTest(Priority = 0)]
    public class Throughput_16payloadReflect1400 : Throughput_Base
    {
        protected override void SgExecute ()
        {
            GoIfSignedIn(k_payload16, SGFakeService.ActionType.Reflect, 175, this.ServiceCycle, 0);
        }
    }

    [StressTest(Priority = 0)]
    public class Throughput_16payloadReflect1448_MaxGood : Throughput_Base
    {
        protected override void SgExecute ()
        {
            GoIfSignedIn(k_payload16, SGFakeService.ActionType.Reflect, 181, this.ServiceCycle, 0);
        }
    }

    [StressTest(Priority = 0)]
    public class Throughput_16payloadReflect1456_RawnicOK_EnetBad : Throughput_Base
    {
        protected override void SgExecute ()
        {
            GoIfSignedIn(k_payload16, SGFakeService.ActionType.Reflect, 182, this.ServiceCycle, 0);
        }
    }

    [StressTest(Priority = 0)]
    public class Throughput_16payloadReflect1464_TooBig : Throughput_Base
    {
        protected override void SgExecute ()
        {
            GoIfSignedIn(k_payload16, SGFakeService.ActionType.Reflect, 183, this.ServiceCycle, 0);
        }
    }

    [StressTest(Priority=0)]
    public class Throughput_64payloadAuthdataLookup: Throughput_Base
    {
        protected override void SgExecute()
        {
            // This reflect a regular UDP packet back to us AND does an authdata lookup
            GoIfSignedIn(k_payload64, SGFakeService.ActionType.ReflectAuthdata, 0, this.ServiceCycle);
        }
    }

    [StressTest(Priority=0)]
    public class Throughput_64payloadAuthdataLookupReflect: Throughput_Base
    {
        protected override void SgExecute()
        {
            // This reflects the actual authdata back to us
            GoIfSignedIn(k_payload64, SGFakeService.ActionType.AuthdataLookup, 0, this.ServiceCycle);
        }
    }

    [StressTest(Priority = 0)]
    public class Throughput_64payloadAuthdataLookupDrop : Throughput_Base
    {
        protected override void SgExecute ()
        {
            // This reflects the actual authdata back to us
            GoIfSignedIn(k_payload64, SGFakeService.ActionType.DropAuthdata, 0, this.ServiceCycle);
        }
    }

    [StressTest(Priority=0)]
    public class Throughput_160payloadReflect_Synchronous: Throughput_Base
    {
        protected override void SgExecute()
        {
            GoIfSignedIn(k_payload160, SGFakeService.ActionType.Reflect, 0, this.ServiceCycle, 500);
        }
    }

    /// <summary>
    /// This test does not stay within the boundaries of safety that the others use.  The clients it uses can change
    /// status out from under it very easily.  For this reason, it is marked as Not Executed unless Go returns a
    /// failure.  Also, Go does not fail on sequence numbers, but the Sequence Number Gap indicates badness.
    /// </summary>
    [StressTest(Priority = 0)]
    public class Synchronous_64KClient_Check : Throughput_Base
    {
        /// <summary>
        /// The current Spi value to use.
        /// </summary>
        protected static uint CurrentSpi = 0;
        protected static object _CurrentSpi_lock = new object();

        // This assumes that the SPI_MASK is 0xFFFFFF00
        protected const byte SpiShift = 8;
        protected const uint SpiSpace = (XspHeader.XSP_SPI_MASK >> SpiShift) + 1;

        protected override void SgExecute ()
        {
            SgClient client = null;

            lock (_CurrentSpi_lock)
            {
                for (uint i = 0; i < SpiSpace; ++i)
                {
                    CurrentSpi += 1 << SpiShift;
                    client = SgForm.LookupClientFast(CurrentSpi);

                    try
                    {
                        if (client != null && client.IsSignedIn)
                        {
                            break;
                        }
                    }
                    catch (Exception e)
                    {
                        Global.RO.Debug("Got an exception while looking for a client: {0}", e.Message);
                    }

                    // in case not signed in
                    client = null;
                }
            }

            if (client == null)
            {
                throw new DidNotExecuteException("Could not find a signed in client in the SPI hash table.");
            }

            bMeasureTimestamp = true;

            try
            {
                Go(k_payload16, SGFakeService.ActionType.ReflectTimestamp, 0, this.ServiceCycle, client, 500);
            }
            catch (Exception e)
            {
                throw new DidNotExecuteException("Got an exception while executing Synchronous_64KClient_Check.  " +
                    "This is expected to happen at least sometimes.", e);
            }
        }
    }


#if false

    [StressTest(Priority=0)]
    public class Throughput_Timestamp: Throughput_Base
    {
        [ThreadStatic]
        protected static byte[] localPayload;

        protected override void SgExecute()
        {
            if (localPayload == null)
                localPayload = new byte[16];
            GoIfSignedIn(localPayload, SGFakeService.ActionType.ReflectTimestamp, 0, (ushort)SGFakeService.IServicePort.Service5, 0);
        }
    }

    [StressTest(Priority=0)]
    public class Throughput_Timestamp_Synchronous: Throughput_Base
    {
        [ThreadStatic]
        protected static byte[] localPayload = new byte[16];

        protected override void SgExecute()
        {
            bMeasureTimestamp = true;
            GoIfSignedIn(localPayload, SGFakeService.ActionType.ReflectTimestamp, 0, (ushort)SGFakeService.IServicePort.Service5, 500);
        }
    }

#endif
                
    [StressTest(Priority=0)]
    public class Throughput_Timestamp_Async_1User_1Server : Throughput_Base_1Client
    {
        protected override void InitializeTest()
        {
            base.InitializeTest();
            bMeasureTimestamp = true;
        }

        protected override void RunTest()
        {
            Go(localPayload, SGFakeService.ActionType.ReflectTimestamp, 0, servicePort, client, 0);
        }
    }
    
    [StressTest(Priority=0)]
    public class Throughput_Timestamp_Synchronous_1User_1Server : Throughput_Base_1Client
    {
        protected override void InitializeTest()
        {
            base.InitializeTest();
            bMeasureTimestamp = true;
        }

        protected override void RunTest()
        {
            Go(localPayload, SGFakeService.ActionType.ReflectTimestamp, 0, servicePort, client, 500);
        }
    }

    [StressTest(Priority=0)]
    public class Throughput_Timestamp_Synchronous_1User : Throughput_Base_1Client
    {
        protected override void InitializeTest()
        {
            base.InitializeTest();
            bMeasureTimestamp = true;
        }

        protected override void RunTest()
        {
            servicePort = ServiceCycle;
            Go(localPayload, SGFakeService.ActionType.ReflectTimestamp, 0, servicePort, client, 500);
        }
    }

    [StressTest(Priority=0)]
    public class Throughput_Timestamp_Synchronous_1User_Big : Throughput_Base_1Client
    {
        protected override void InitializeTest()
        {
            base.InitializeTest();
            bMeasureTimestamp = true;
            localPayload = new byte[1400];
        }

        protected override void RunTest()
        {
            servicePort = ServiceCycle;
            Go(localPayload, SGFakeService.ActionType.ReflectTimestamp, 0, servicePort, client, 500);
        }
    }
    
    [StressTest(Priority=0)]
    public class Throughput_SimulateXboxTcp_1User : Throughput_Base_1Client
    {
        [ThreadStatic]
        protected static ulong packetCount;

        protected override void InitializeTest()
        {
            base.InitializeTest();
            localPayload = new byte[1400];
        }

        protected override void RunTest()
        {
            // Send 2 large packets, wait for 1 small packet, repeat.
            if ((++packetCount % 2) == 0)
            {
                // Trigger a small packet reply
                // 1 means we'll get an 8 byte reply (1 << 3)
                Go(localPayload, SGFakeService.ActionType.ReflectTimestamp, 1, servicePort, client, 500);
            }
            else
            {
                // Send a big packet, no reply wanted
                Go(localPayload, SGFakeService.ActionType.Drop, 0, servicePort, client, 0);
            }

        }
    }
              
    #endregion


    #region Secmsg

    [StressTest(Priority=0)]
    public class SecMsg_DataPulse: SecMsg_Base
    {
        protected override void SendPacket(SgClient sg)
        {
            sg.SendDataPulse();
        }
    }

    [StressTest(Priority=0)]
    public class SecMsg_DataPulseStateChange: SecMsg_Base
    {
        private static uint FakeState = 0;
        protected override void SendPacket(SgClient sg)
        {
            ulong userpuid = sg.Context.Authdata.GetUser(0).qwUserID;
            sg.SendDataPulseStateChange(FakeState++, userpuid);
            if (FakeState >= uint.MaxValue)
                FakeState = 0;
        }
    }

    [StressTest(Priority=0)]
    public class SecMsg_Pulse_Simple: SecMsg_Base
    {
        protected override void SendPacket(SgClient sg)
        {
            sg.SendPulse();
        }
    }

    [StressTest(Priority=0)]
    public class SecMsg_QoS_Exchange: SecMsg_Base
    {
        protected override void SendPacket(SgClient sg)
        {
            sg.SendQos(0, false);
        }
    }

    [StressTest(Priority=0)]
    public class SecMsg_XbToXbForward: SecMsg_Base
    {
        // Arbitrary size for payload
        protected static byte[] message = new byte[256];

        protected override void SendPacket(SgClient sg)
        {
            // Send it to me
            SGAddress recipient = sg.KeyexResult.keyexResp.SGAddressInit;
            sg.SendXbToXbForward(recipient, message);
        }
    }

    
    [StressTest(Priority=0)]
    public class SecMsg_Logoff: SecMsg_Base
    {
        protected override void SendPacket(SgClient sg)
        {
            bDontPutBack = true;
            DeleteClient(sg, "SecMsg_Logoff");
        }
    }

    [StressTest(Priority=0)]
    [StressInstantiate]
    public class ForceConfigReload_NPDBSetting_Stats : TestBase
    {
        public const string SQLCommandText = @"
Update t_settings set vc_value = {0} where vc_setting = 'sg_StatsConfidenceLimitInClients'
Update t_settings set vc_value = {1} where vc_setting = 'sg_StatsPenaltyTimeInSeconds'
";
        private readonly int[] ConfidenceValues = new int[] { 2001, 2000 };
        private static int ConfidenceIndex = 0;
        private readonly int[] PenaltyValues = new int[] { 121, 120 };
        private static int PenaltyIndex = 0;

        protected override void Execute ()
        {
            string commtemp = String.Format(SQLCommandText, ConfidenceValues[ConfidenceIndex], 
                PenaltyValues[PenaltyIndex]);
            ConfidenceIndex = (ConfidenceIndex + 1) % ConfidenceValues.Length;
            PenaltyIndex = (PenaltyIndex + 1) % PenaltyValues.Length;

            Npdb npdb = new Npdb();
            npdb.ConnectToServer();

            try
            {
                npdb.ExecuteScalar(commtemp);
            }
            finally
            {
                npdb.Close();
            }

            ResultCode = TEST_RESULTS.PASSED;
        }
    }

    [StressTest(Priority = 0)]
    [StressInstantiate]
    public class ForceConfigReload_NPDBSetting_StatsReallocate : TestBase
    {
        public const string SQLCommandText = @"
Update t_settings set vc_value = {0} where vc_setting = 'sg_StatsConfidenceLimitInClients'
Update t_settings set vc_value = {1} where vc_setting = 'sg_StatsHistoryInMs'
";
        public int[] ConfidenceValues = new int[] { 2001, 2000 };
        public static int ConfidenceIndex = 0;
        public int[] HistoryValues = new int[] { 0, 60000 };
        public static int HistoryIndex = 0;

        protected override void Execute ()
        {
            string commtemp = String.Format(SQLCommandText, ConfidenceValues[ConfidenceIndex],
                HistoryValues[HistoryIndex]);
            ConfidenceIndex = (ConfidenceIndex + 1) % ConfidenceValues.Length;
            HistoryIndex = (HistoryIndex + 1) % HistoryValues.Length;

            Npdb npdb = new Npdb();
            npdb.ConnectToServer();

            try
            {
                npdb.ExecuteScalar(commtemp);
            }
            finally
            {
                npdb.Close();
            }

            ResultCode = TEST_RESULTS.PASSED;
        }
    }

    #endregion

    #region Negative Cases

    public class NegativeStressBase : TestNode
    {
        protected byte[] Payload;
        protected SimpleUdpSG SUSG;
        protected IPEndPoint SGIP;

        public override void PreRun ()
        {
            SUSG = new SimpleUdpSG();
            SGIP = Global.XEnv.GetVirtualInterface("sgsvc");
        }

        public override void Run ()
        {
            SUSG.SendFast(Payload, Payload.Length, SGIP);
        }
    }

    [StressTest(Priority=0)]
    public class BadFlags_PacketLeak : NegativeStressBase
    {
        public override void PreRun ()
        {
            base.PreRun();
            Payload = Packet_Validity.BadPacketType_Leak.ConstructPayload("Packet leak stress");
        }
    }

    [StressTest(Priority = 0)]
    public class Bad_PayloadTooSmall : NegativeStressBase
    {
        public override void PreRun ()
        {
            base.PreRun();
            Payload = new byte[]{ 6, 0xD, 0xA };
        }
    }

    public class MySgConnection : SGConnection
    {
        public MySgConnection ()
        {
            Context = new AuthContext(AuthContext.ClientTypes.Xenon);
            Context.Site = SiteInfoManager.GetDefaultSgSite().CloneDeep();
            Context.Authdata = Authdata_Base.NewDefaultFromSite(Context.Site);
            Transport = new XspUdp();

            // Set some user names.  DefaultAuthData() will detect this and
            // make up unique puids for us.
            Context.ClearUsers();
            Context.SetUser("sgtestuser" + 1, 1);

            SgClient.SetDefaultAuthdata(Context, Context.Authdata);
        }

        public byte[] PreConnect ()
        {
            KeyExchangeRequestPacket kerp;
            XspBuffer buffer;

            PreConnect(out kerp, out buffer);

            byte[] ans = (byte[])buffer.RawBuffer.Clone();
            XspBufferManager.Free(buffer);

            return ans;
        }
    }

    [StressTest]
    public class SendFixedKeyexPacket : NegativeStressBase
    {
        public override void PreRun ()
        {
            base.PreRun();
            Payload = (new MySgConnection()).PreConnect();
        }
    }

    [StressTest]
    public class ReplayPacketIncrementSequence : NegativeStressBase
    {
        protected MySgConnection Connection;
        protected DateTime LastPoke = DateTime.MinValue;

        public override void PreRun ()
        {
            base.PreRun();

            Connection = new MySgConnection();
            Connection.Connect();
            MakePayload();
        }

        protected void MakePayload ()
        {
            SecMsgPulse pulse = new SecMsgPulse();
            XspBuffer buffer = Connection.Session.EncodeSecMsg(pulse);

            Connection.Send(buffer);

            byte[] temp = (byte[])buffer.RawBuffer.Clone();
            temp[8] = (byte)((temp[8] + 1) % 256);

            Payload = temp;
        }

        public override void Run ()
        {
            if ((LastPoke - DateTime.UtcNow).TotalSeconds > 20)
            {
                LastPoke = DateTime.UtcNow;
                MakePayload();
            }

            base.Run();
        }
    }

    [StressTest]
    public class RandomBytesUdp : NegativeStressBase
    {
        public override void PreRun ()
        {
            base.PreRun();
            Payload = new byte[5000];
            RandomEx.GlobalRandGen.NextBytes(Payload);
        }

        public override void Run ()
        {
            int size = RandomEx.GlobalRandGen.Next(16, 1460);
            int offset = RandomEx.GlobalRandGen.Next() % (Payload.Length - size);

            SUSG.SendFast(Payload, offset, size, SGIP);
        }
    }

    #endregion

    #region TCP Cases to TestFD

    [StressTest]
    public class SimpleTcpReflect : TestNode
    {
        public override void Run ()
        {
            XRLReflect xrl = new XRLReflect();

            if (xrl.Execute(TestFdReflectorRequest.Caller.None, TestFdReflectorRequest.Action.Reflect, 0))
            {
                TestFdReflectorResponse resp = xrl.Response;

                if (resp == null)
                {
                    throw new UnexpectedTestResultException("Response was null");
                }
            }
            else
            {
                throw new UnexpectedTestResultException("Got a bad response: " + xrl.httpStatus);
            }
        }
    }

    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\SgTest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\test\XSGTest\SgTest\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xsgtest_none_12.4.56.0_none_7a7324713ff96245
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xsgtest_no-public-key_12.4.56.0_x-ww_1c1a1581
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xsgtest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xsgtest_no-public-key_12.4.56.0_x-ww_1c1a1581
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xsgtest_no-public-key_12.4.56.0_x-ww_1c1a1581.manifest
XP_MANIFEST_PATH=manifests\msil_xsgtest_no-public-key_12.4.56.0_x-ww_1c1a1581.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xsgtest_no-public-key_12.4.56.0_x-ww_1c1a1581.cat
XP_CATALOG_PATH=manifests\msil_xsgtest_no-public-key_12.4.56.0_x-ww_1c1a1581.cat
XP_PAYLOAD_PATH=msil_xsgtest_no-public-key_12.4.56.0_x-ww_1c1a1581
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xsgtest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\util\iphook\gui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by IpFiltUI.rc
//
#define IDD_IPFILTUI_DIALOG             100
#define IDC_EDIT_PORT_LO                1000
#define IDC_EDIT_PORT_HI                1001
#define IDC_BUTTON_FILTER_ON            1002
#define IDC_BUTTON_FILTER_OFF           1003

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\util\iphook\gui\IpFiltUI.cpp ===
// IpFiltUI.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#define _COUNTOF( x ) ( sizeof( x ) / sizeof( *(x) ) )

// Begin CIpFiltUIApp /////////////////////////////////////////////////////////

// The one and only CIpFiltUIApp object
CIpFiltUIApp theApp;

// Message Map
BEGIN_MESSAGE_MAP( CIpFiltUIApp, CWinApp )
END_MESSAGE_MAP()


// CIpFiltUIApp construction
CIpFiltUIApp::CIpFiltUIApp() :
    m_hDriver( INVALID_HANDLE_VALUE )
{
}

// CIpFiltUIApp initialization
BOOL CIpFiltUIApp::InitInstance()
{
    // Do base class initialization first
    if( !CWinApp::InitInstance() )
    {
        AfxMessageBox( _T( "Error: CWinApp::InitInstance failed" ) );
        return FALSE;
    }

    // Load the device driver
    m_hDriver = SgIpHookLoadDriver();
    if( INVALID_HANDLE_VALUE == m_hDriver )
    {
        AfxMessageBox( _T( "Error: Failed to load the device driver" ) );
        return FALSE;
    }

    CIpFiltUIDlg dlg;
    m_pMainWnd = &dlg;
    if( IDOK != dlg.DoModal() )
    {
        AfxMessageBox( _T( "Error: Failed to load main dialog" ) );
        return FALSE;
    }

    // Since the dialog has been closed, return FALSE so that we exit the
    //  application, rather than start the application's message pump.
    return FALSE;
}

// CIpFiltUIApp clean-up
int CIpFiltUIApp::ExitInstance()
{
    if( INVALID_HANDLE_VALUE != m_hDriver )
    {
        SgIpHookUnloadDriver( m_hDriver );
        m_hDriver = INVALID_HANDLE_VALUE;
    }

    return CWinApp::ExitInstance();
}

// End CIpFiltUIApp ///////////////////////////////////////////////////////////


// Begin CIpFiltUIDlg /////////////////////////////////////////////////////////

CIpFiltUIDlg::CIpFiltUIDlg() :
    CDialog( CIpFiltUIDlg::IDD, NULL ),
    m_nPortLo( 20000 ),
    m_nPortHi( 30000 )
{
}

void CIpFiltUIDlg::DoDataExchange( CDataExchange* pDX )
{
    CDialog::DoDataExchange( pDX );
    DDX_Text( pDX, IDC_EDIT_PORT_LO, m_nPortLo );
    DDV_MinMaxUInt( pDX, m_nPortLo, 1, 65535 );
    DDX_Text( pDX, IDC_EDIT_PORT_HI, m_nPortHi );
    DDV_MinMaxUInt( pDX, m_nPortHi, 1, 65535 );
}

BEGIN_MESSAGE_MAP( CIpFiltUIDlg, CDialog )
    ON_BN_CLICKED( IDC_BUTTON_FILTER_ON, OnBnClickedButtonFilterOn )
    ON_BN_CLICKED( IDC_BUTTON_FILTER_OFF, OnBnClickedButtonFilterOff )
END_MESSAGE_MAP()

void CIpFiltUIDlg::OnBnClickedButtonFilterOn()
{
    if( !UpdateData( TRUE ) )
    {
        return;
    }

    if( m_nPortLo > m_nPortHi )
    {
        AfxMessageBox( _T( "Error: High port must be greater than low port" ), MB_OK );
        return;
    }

    if( !SgIpHookSetPortRange( ( (CIpFiltUIApp*) AfxGetApp() )->GetDriverHandle(), (WORD) m_nPortLo, (WORD) m_nPortHi ) )
    {
        AfxMessageBox( _T( "Error: Failed setting port range" ) );
    }
}

void CIpFiltUIDlg::OnBnClickedButtonFilterOff()
{
    if( !SgIpHookSetPortRange( ( (CIpFiltUIApp*) AfxGetApp() )->GetDriverHandle(), 0, 0 ) )
    {
        AfxMessageBox( _T( "Error: Failed turning off filter" ) );
    }
}

// End CIpFiltUIDlg ///////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\util\iphook\gui\IpFiltUI.h ===
#pragma once


// Begin CIpFiltUIApp /////////////////////////////////////////////////////////

class CIpFiltUIApp : public CWinApp
{
public:
    CIpFiltUIApp();

    virtual BOOL InitInstance();
    virtual int ExitInstance();

    HANDLE GetDriverHandle() const { return m_hDriver; }

protected:
    DECLARE_MESSAGE_MAP()

private:
    HANDLE m_hDriver;
};

extern CIpFiltUIApp theApp;

// End CIpFiltUIApp ///////////////////////////////////////////////////////////


// Begin CIpFiltUIDlg /////////////////////////////////////////////////////////

class CIpFiltUIDlg : public CDialog
{
public:
    CIpFiltUIDlg();

    afx_msg void OnBnClickedButtonFilterOn();
    afx_msg void OnBnClickedButtonFilterOff();

// Dialog Data
    enum { IDD = IDD_IPFILTUI_DIALOG };

protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

    DECLARE_MESSAGE_MAP()

private:
    UINT m_nPortLo;
    UINT m_nPortHi;
};

// End CIpFiltUIDlg ///////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\util\iphook\gui\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently,
// but are changed infrequently

#pragma once


#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS    // some CString constructors will be explicit

// turns off MFC's hiding of some common and often safely ignored warning messages
#define _AFX_ALL_WARNINGS

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#include <afxdtctl.h>        // MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>            // MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

// Device driver includes
#include "sgiphook.h"

// Local includes
#include "resource.h"
#include "IpFiltUI.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\util\iphook\inc\sgiphook.h ===
HANDLE SgIpHookLoadDriver();
void SgIpHookUnloadDriver( HANDLE hDriver );

// Calling this with both ports set to zero turns off the hook
BOOL SgIpHookSetPortRange( HANDLE hDriver, WORD wPortLo, WORD wPortHi );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\util\iphook\inc\iphookdd.h ===
// Custom device type, can be any value between 0x8000 and 0xFFFF
#define FILE_DEVICE_IPFILTER      0x00009000

// Version
#define IPFILTER_VERSION 0x0101

// Commands that the UI can send the device driver
#define IPFILTER_CMD_GET_VERSION       (ULONG) CTL_CODE( FILE_DEVICE_IPFILTER, 0x01, METHOD_BUFFERED, FILE_ANY_ACCESS )
#define IPFILTER_CMD_SET_PORT_RANGE    (ULONG) CTL_CODE( FILE_DEVICE_IPFILTER, 0x02, METHOD_BUFFERED, FILE_ANY_ACCESS )

// Structure passed to a SET_PORT_RANGE command
struct SET_PORT_RANGE
{
    WORD wPortLo;
    WORD wPortHi;
};

// Name the driver is installed under
// NOTE: This will define the name of the file as sgiphook.sys, the name of the device
// as \Device\sgiphook, and the device symbolic link as \DosDevices\sgiphook.
#define DD_IPHOOK_NAME "sgiphook"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\util\iphook\sys\precomp.h ===
#pragma once

#include <ndis.h>
#include <windef.h>
#include <stdio.h>

#include "iphookdd.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\util\vlan\vlanio.h ===
// ---------------------------------------------------------------------------------------
// vlanio.h
//
// Interface between VLAN.SYS and VLAN.LIB
// ---------------------------------------------------------------------------------------

#ifndef __VLANIO_H__
#define __VLANIO_H__

// ---------------------------------------------------------------------------------------
// Version - should be updated for breaking API changes
// ---------------------------------------------------------------------------------------

#define VLAN_VERSION                3

// ---------------------------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------------------------

#define VLAN_DEVICE_NAME            L"\\Device\\VLAN"
#define VLAN_SYMBOLIC_NAME          L"\\DosDevices\\VLAN"
#define VLAN_PROTOCOL_NAME          L"VLAN"

#define VLAN_OPTION_OVERLAPPED      0x1

//
// The name of the EA (Extended Attribute) passed to NtCreateFile(). This
// allows us to pass adapter properties at the time we create the handle.
//
// N.B. The EA name (including the terminator) must be a multiple of eight
// to ensure natural alignment of the VLAN_OPEN_PACKET structure used as
// the EA value.
//

//                                       7654321076543210
#define VLAN_OPEN_PACKET_NAME           "VlanOpenPacket0"
#define VLAN_OPEN_PACKET_NAME_LENGTH    (sizeof(VLAN_OPEN_PACKET_NAME) - 1)
C_ASSERT( ((VLAN_OPEN_PACKET_NAME_LENGTH + 1) & 7) == 0 );

// passed in Create calls
struct VLAN_OPEN_PACKET
{
    DWORD       _dwVersion;
    DWORD       _dwAdapterNumber;
};

// passed to add/remove vadapter
struct VLAN_VADAPTER_INFO
{
    BYTE        _abEnetAddr[6];
};

//
// VLAN IOCTL code definitions.
//
// N.B. To ensure the efficient of the code generated by VLAN's
//      IOCTL dispatcher, these IOCTL codes should be contiguous
//      (no gaps).
//
// N.B. If new IOCTLs are added here, update the lookup table in
//      spfmain.cpp.
//

#define _VLAN_CTL_CODE(request, method, access)                 \
    CTL_CODE( FILE_DEVICE_NETWORK, request, method, access )

#define _VLAN_REQUEST(ioctl)                                    \
   ((((ULONG)(ioctl)) >> 2) & 0x03FF)

#define VLAN_RECEIVE                                         0
#define VLAN_SEND                                            1
#define VLAN_ADD_VADAPTER                                    2
#define VLAN_REMOVE_VADAPTER                                 3

#define VLAN_NUM_IOCTLS                                      4


#define IOCTL_VLAN_RECEIVE                                  \
    _VLAN_CTL_CODE( VLAN_RECEIVE,                           \
                   METHOD_OUT_DIRECT,                       \
                   FILE_WRITE_ACCESS )

#define IOCTL_VLAN_SEND                                     \
    _VLAN_CTL_CODE( VLAN_SEND,                              \
                   METHOD_IN_DIRECT,                        \
                   FILE_WRITE_ACCESS )

#define IOCTL_VLAN_ADD_VADAPTER                             \
    _VLAN_CTL_CODE( VLAN_ADD_VADAPTER,                      \
                   METHOD_BUFFERED,                         \
                   FILE_WRITE_ACCESS )


#define IOCTL_VLAN_REMOVE_VADAPTER                          \
    _VLAN_CTL_CODE( VLAN_REMOVE_VADAPTER,                   \
                   METHOD_BUFFERED,                         \
                   FILE_WRITE_ACCESS )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\util\iphook\sys\ipfilter.c ===
#include "precomp.h"
#pragma hdrstop

// ---------------------------------------------------------------------------------------
// Configuration
// ---------------------------------------------------------------------------------------

#ifdef DBG
#define IPHOOK_FEATURE_TRACE
#endif

// ---------------------------------------------------------------------------------------
// Definitions
// ---------------------------------------------------------------------------------------

#define INLINE __forceinline

#define IPPROTO_TCP 6
#define IPPROTO_UDP 17
#define IPPROTO_RAW 255

#define __W(x) L ##x
#define _W(x) __W(x)


// IP Header in Network Byte Order -------------------------------------------------------

#include <pshpack1.h>

struct CIpHdr
{
    BYTE            _bVerHdr;       // Version & header length
    BYTE            _bTos;          // Type of service
    WORD            _wLen;          // Total length including IP header
    WORD            _wId;           // Identification
    WORD            _wFragOff;      // Flags and fragment offset
    BYTE            _bTtl;          // Time to live
    BYTE            _bProtocol;     // Protocol
    WORD            _wChecksum;     // Header checksum
    DWORD           _ipaSrc;        // Source address
    DWORD           _ipaDst;        // Destination address
};

#include <poppack.h>

// UDP Header in Network Byte Order ------------------------------------------------------

#include <pshpack1.h>

struct CUdpHdr
{
    WORD            _ipportSrc;     // Source port
    WORD            _ipportDst;     // Destination port
    WORD            _wLen;          // Datagram length including UDP header
    WORD            _wChecksum;     // Datagram checksum
};

#include <poppack.h>

// TCP Header in Network Byte Order ------------------------------------------------------

#include <pshpack1.h>

struct CTcpInfo
{
    DWORD           _dwSeqNum;      // Sequence number
    DWORD           _dwAckNum;      // Ack number
    BYTE            _bHdrLen;       // Header length (number of DWORDs)
    BYTE            _bFlags;        // Flags
    WORD            _wWindow;       // Window
};

struct CTcpHdr
{
    WORD            _ipportSrc;     // Source port
    WORD            _ipportDst;     // Destination port
    struct CTcpInfo _info;          // CTcpInfo
    WORD            _wChecksum;     // Checksum
    WORD            _wUrgent;       // Urgent pointer
};

#include <poppack.h>

#define TCP_FIN 0x01
#define TCP_SYN 0x02
#define TCP_RST 0x04
#define TCP_PSH 0x08
#define TCP_ACK 0x10
#define TCP_URG 0x20

// IP Filter Hook Definitions ------------------------------------------------------------

typedef enum _FORWARD_ACTION
{
    FORWARD       = 0,
    DROP          = 1,
} FORWARD_ACTION;

// Definiton for a filter routine callout.
typedef FORWARD_ACTION (*IPPacketFilterPtr)(
    BYTE      *PacketHeader,
    BYTE      *Packet,
    DWORD     PacketLength,
    DWORD     RecvInterfaceIndex,
    DWORD     SendInterfaceIndex,
    DWORD     RecvLinkNextHop,
    DWORD     SendLinkNextHop);

typedef struct _IP_SET_FILTER_HOOK_INFO 
{
    IPPacketFilterPtr       FilterPtr;      // Packet filter callout.
} IP_SET_FILTER_HOOK_INFO, *PIP_SET_FILTER_HOOK_INFO;

#define IOCTL_IP_SET_FILTER_POINTER CTL_CODE(FILE_DEVICE_NETWORK, 4, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define DD_IP_DEVICE_NAME   L"\\Device\\Ip"

// ---------------------------------------------------------------------------------------
// Utilities
// -----------------------------------------------------------------------------------

#define HTONL_(ul) \
    ((ULONG)((((ul) >> 24) & 0x000000FFL) | (((ul) >>  8) & 0x0000FF00L) | \
             (((ul) <<  8) & 0x00FF0000L) | (((ul) << 24))))

#define NTOHL_(ul) HTONL_(ul)

#define HTONS_(us) \
    ((USHORT)((((us) >> 8) & 0x00FF) | (((us) << 8) & 0xFF00)))

#define NTOHS_(us) HTONS_(us)

INLINE ULONG  HTONL(ULONG  ul) { return(HTONL_(ul)); }
INLINE ULONG  NTOHL(ULONG  ul) { return(NTOHL_(ul)); }
INLINE USHORT HTONS(USHORT us) { return(HTONS_(us)); }
INLINE USHORT NTOHS(USHORT us) { return(NTOHS_(us)); }

// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------

// Device-object for the IP driver
PDEVICE_OBJECT IpDeviceObject = NULL;

// Device-object for the filter hook driver
PDEVICE_OBJECT IpHookDeviceObject = NULL;

// The port range we will operate on
WORD PortRangeLo = 20000;
WORD PortRangeHi = 30000;

// The function used by NT for IRP dispatch functions that we don't define
PDRIVER_DISPATCH pIopInvalidDeviceRequest = NULL;

// Specifies whether or not we are currently injected into the tcpip driver
BOOLEAN HookActive = FALSE;

// ---------------------------------------------------------------------------------------
// Function prototypes
// ---------------------------------------------------------------------------------------

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
IpHookUnloadDriver(
    IN PDRIVER_OBJECT  DriverObject
    );

NTSTATUS 
IpHookDispatch( 
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp 
    );

NTSTATUS
IpHookSetFilterHook(
    BOOLEAN Install
    );

FORWARD_ACTION
IpHookFilterPacket(
    BYTE      *PacketHeader,
    BYTE      *Packet,
    DWORD     PacketLength,
    DWORD     RecvInterfaceIndex,
    DWORD     SendInterfaceIndex,
    DWORD     RecvLinkNextHop,
    DWORD     SendLinkNextHop
    );

#ifdef IPHOOK_FEATURE_TRACE
VOID
IpHookLogPacket(
    BYTE      *PacketHeader,
    BYTE      *Packet,
    DWORD     PacketLength,
    BOOLEAN   fReceive
    );
#else
#define IpHookLogPacket __noop
#endif

// This puts the code for DriverEntry in an area of the binary that the OS
// knows it is allowed to remove from memory once initialization is complete.
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#endif

// ---------------------------------------------------------------------------------------
// Implementation
// ---------------------------------------------------------------------------------------

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Performs driver-initialization for the filter driver.

Arguments:

Return Value:

    STATUS_SUCCESS if initialization succeeded, error code otherwise.

--*/

{
    PFILE_OBJECT IpFileObject;
    WCHAR DeviceName[] = L"\\Device\\" _W( DD_IPHOOK_NAME );
    WCHAR LinkName[] = L"\\DosDevices\\" _W( DD_IPHOOK_NAME );
    UNICODE_STRING DeviceString;
    UNICODE_STRING LinkString;
    LONG iDispatch;
    NTSTATUS status;
    BOOL fSymLinkDone;

    // Since we indicated with the pragma above that it is safe to remove this code once
    // initialization is complete, this macro does some checking to make sure things get
    // used correctly.
    PAGED_CODE();

    KdPrint( ( "IpHook: DriverEntry \n" ) );

    fSymLinkDone = FALSE;

    // Create the device's object.
    RtlInitUnicodeString( &DeviceString, DeviceName );
    status =
        IoCreateDevice(
            DriverObject,
            0,
            &DeviceString,
            FILE_DEVICE_IPFILTER,
            FILE_DEVICE_SECURE_OPEN,
            FALSE,
            &IpHookDeviceObject
            );
    if( !NT_SUCCESS( status ) ) 
    {
        KdPrint( ( "IpHook: IoCreateDevice failed (0x%08X)\n", status ) );
        goto Exit;
    }

    // Create a symbolic link to the device object that can be used in user-mode with CreateFile
    RtlInitUnicodeString( &LinkString, LinkName );
    status =
        IoCreateSymbolicLink(
            &LinkString,
            &DeviceString
            );
    if( !NT_SUCCESS( status ) ) 
    {
        KdPrint( ( "IpHook: IoCreateSymbolicLink failed (0x%08X)\n", status ) );
        goto Exit;
    }
    fSymLinkDone = TRUE;

    // The OS fills in all slots with a common function called when a request isn't supported.  Because we want to
    // track all potential calls to us, we store this and then handle all calls with our own dispatch function.  In
    // the dispatch function we log types we don't handle and then call the original function the OS would have
    // called.
    pIopInvalidDeviceRequest = DriverObject->MajorFunction[ 0 ];

    // Set pointers to the function that the OS will call back into us with
    for( iDispatch = 0; iDispatch <= IRP_MJ_MAXIMUM_FUNCTION; iDispatch++ )
    {
        DriverObject->MajorFunction[ iDispatch ]  = IpHookDispatch;
    }
    DriverObject->DriverUnload = IpHookUnloadDriver;

    // Obtain the IP driver device-object so that we can send it commands
    RtlInitUnicodeString( &DeviceString, DD_IP_DEVICE_NAME );
    status =
        IoGetDeviceObjectPointer(
            &DeviceString,
            SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
            &IpFileObject,
            &IpDeviceObject
            );
    if( !NT_SUCCESS( status ) ) 
    {
        KdPrint( ( "IpHook: IoGetDeviceObjectPointer failed (0x%08X)\n", status ) );
        goto Exit;
    }

    // When IoGetDeviceObjectPointer returns we have a reference to both the device object and file object through 
    // the file object.  In other words, dereferencing the file object is all we need to do to free both.  Since
    // we want to keep only the device object around, first add an extra reference to the device object, then 
    // dereference the file object.
    ObReferenceObject( IpDeviceObject );
    ObDereferenceObject( (PVOID) IpFileObject );
    IpFileObject = NULL;

Exit:
    if( !NT_SUCCESS( status ) ) 
    {
        // The OS does not call our DriverUnload when DriverEntry fails so we must do clean up here.

        if( fSymLinkDone )
        {
            IoDeleteSymbolicLink( &LinkString );
        }

        if( NULL != IpHookDeviceObject )
        {
            IoDeleteDevice( IpHookDeviceObject );
            IpHookDeviceObject = NULL;
        }
    }

    return status;

} // DriverEntry


VOID
IpHookUnloadDriver(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    Performs cleanup for the filter-driver.

Arguments:

    DriverObject - reference to the module's driver-object

Return Value:

--*/

{
    WCHAR LinkName[] = L"\\DosDevices\\" _W( DD_IPHOOK_NAME );
    UNICODE_STRING LinkString;

    KdPrint( ( "IpHookUnloadDriver\n" ) );

    // If we were hooked, unhook us
    IpHookSetFilterHook( FALSE );

    // Remove the symbolic link
    RtlInitUnicodeString( &LinkString, LinkName );
    IoDeleteSymbolicLink( &LinkString );

    // Delete our device object
    IoDeleteDevice( DriverObject->DeviceObject );

    // Release references to the IP device object
    ObDereferenceObject( IpDeviceObject );

} // IpHookUnloadDriver


FORWARD_ACTION
IpHookFilterPacket(
    BYTE      *PacketHeader,
    BYTE      *Packet,
    DWORD     PacketLength,
    DWORD     RecvInterfaceIndex,
    DWORD     SendInterfaceIndex,
    DWORD     RecvLinkNextHop,
    DWORD     SendLinkNextHop
    )

/*++

Routine Description:

    Invoked to determine the fate of each received packet.

Arguments:

    none used.

Return Value:

    FORWARD_ACTION - indicates whether to forward or drop the given packet.

Environment:

    Invoked within the context of reception or transmission.

--*/

{
    struct CIpHdr*  pIpHdr;
    struct CTcpHdr* pTcpHdr;

    pIpHdr = (struct CIpHdr*) PacketHeader;
    pTcpHdr = (struct CTcpHdr*) Packet;

    if( 0xFFFFFFFF == RecvInterfaceIndex )
    {
#ifdef IPHOOK_FEATURE_VERBOSE
        IpHookLogPacket( 
            PacketHeader,
            Packet,
            PacketLength,
            FALSE );
#endif
    }
    else
    {
        if( (IPPROTO_TCP == pIpHdr->_bProtocol ||
            IPPROTO_UDP == pIpHdr->_bProtocol) &&
            NTOHS( pTcpHdr->_ipportDst ) >= PortRangeLo &&
            NTOHS( pTcpHdr->_ipportDst ) <= PortRangeHi )
        {
            IpHookLogPacket( 
                PacketHeader,
                Packet,
                PacketLength,
                TRUE );

            // Replace the protocol type with one the IP driver won't consume
            //
            // NOTE: The IP driver has already verified the checksum when we get the packet, so we won't 
            // worry about fixing it after we modify the packet.  Besides that, the SG will verify the
            // checksum after it switches the protocol back to TCP, so by not changing it here we leave 
            // it correct when the SG gets to it.
            
            pIpHdr->_bProtocol = (IPPROTO_TCP == pIpHdr->_bProtocol ? IPPROTO_RAW : IPPROTO_RAW-1);
        }
        else
        {
#ifdef IPHOOK_FEATURE_VERBOSE
            IpHookLogPacket( 
                PacketHeader,
                Packet,
                PacketLength,
                TRUE );
#endif
        }
    }

    return FORWARD;

} // IpHookFilterPacket


NTSTATUS
IpHookSetFilterHook(
    BOOLEAN Install
    )

/*++

Routine Description:

    This routine is called to set (Install==TRUE) or clear (Install==FALSE) the
    value of the filter-callout function pointer in the IP driver.

Arguments:

    Install - indicates whether to install or remove the hook.

Return Value:

    NTSTATUS - indicates success/failure

Environment:

    The routine assumes the caller is executing at PASSIVE_LEVEL.

--*/

{
    IP_SET_FILTER_HOOK_INFO HookInfo;
    IO_STATUS_BLOCK IoStatus;
    PIRP Irp;
    KEVENT LocalEvent;
    NTSTATUS status;

    if( Install && HookActive ||
        !Install && !HookActive )
    {
        // Nothing to do
        return STATUS_SUCCESS;
    }

    // Register (or deregister) as a filter driver
    if( Install )
    {
        KdPrint( ( "IpHookSetFilterHook - Altering traffic on ports %u to %u\n", PortRangeLo, PortRangeHi ) );
        HookInfo.FilterPtr = IpHookFilterPacket;
    }
    else
    {
        KdPrint( ( "IpHookSetFilterHook - unhooking\n" ) );
        HookInfo.FilterPtr = NULL;
    }

    KeInitializeEvent( &LocalEvent, SynchronizationEvent, FALSE );
    Irp =
        IoBuildDeviceIoControlRequest(
            IOCTL_IP_SET_FILTER_POINTER,
            IpDeviceObject,
            (PVOID) &HookInfo,
            sizeof( HookInfo ),
            NULL,
            0,
            FALSE,
            &LocalEvent,
            &IoStatus
            );

    if( NULL == Irp ) 
    {
        KdPrint( ( "IpHookSetFilterHook: IoBuildDeviceIoControlRequest = NULL\n" ) );
        return STATUS_UNSUCCESSFUL;
    }

    status = 
        IoCallDriver( 
            IpDeviceObject, 
            Irp );
    if( STATUS_PENDING == status )
    {
        KeWaitForSingleObject( &LocalEvent, Executive, KernelMode, FALSE, NULL );
        status = IoStatus.Status;
    }

    if( !NT_SUCCESS( status ) ) 
    {
        KdPrint( ( "IpHookSetFilterHook: SetFilterPointer=%x\n", status ) );
    }
    else
    {
        HookActive = Install;
    }

    return status;

} // IpHookSetFilterHook


NTSTATUS 
IpHookDispatch( 
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp 
    )

/*++

Routine Description:

    Accepts requests to control the filter object

Arguments:

    DriverObject - reference to the module's driver-object
    Irp - the request

Return Value:

    NTSTATUS - indicates success/failure

--*/

{
    PIO_STACK_LOCATION      irpStack;
    PVOID                   inputBuffer;
    PVOID                   outputBuffer;
    ULONG                   inputBufferLength;
    ULONG                   outputBufferLength;

    // Go ahead and set the request up as successful
    Irp->IoStatus.Status      = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    // Get a pointer to the current location in the Irp. This is where
    //     the function codes and parameters are located.
    irpStack = IoGetCurrentIrpStackLocation( Irp );

    // Get the pointer to the input/output buffer and its length
    inputBuffer             = Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength       = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBuffer            = Irp->AssociatedIrp.SystemBuffer;
    outputBufferLength      = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    switch( irpStack->MajorFunction )
    {
    default:
        KdPrint( ( "IpHookDispatch: received dispatch function %u, ignoring\n", irpStack->MajorFunction ) );
        return pIopInvalidDeviceRequest( DeviceObject, Irp );

    case IRP_MJ_CREATE:
        KdPrint( ( "IpHookDispatch: IRP_MJ_CREATE\n" ) );
        break;

    case IRP_MJ_CLEANUP:
        KdPrint( ( "IpHookDispatch: IRP_MJ_CLEANUP\n" ) );
        break;

    case IRP_MJ_CLOSE:
        KdPrint( ( "IpHookDispatch: IRP_MJ_CLOSE\n" ) );
        break;

    case IRP_MJ_DEVICE_CONTROL:
        KdPrint( ( "IpHookDispatch: IRP_MJ_DEVICE_CONTROL\n" ) );

        switch ( irpStack->Parameters.DeviceIoControl.IoControlCode ) 
        {
        case IPFILTER_CMD_SET_PORT_RANGE:

            KdPrint( ( "IpHookDispatch:   IPFILTER_CMD_SET_PORT_RANGE\n" ) );

            // The caller is setting the range of ports we manipulate traffic for
            if( sizeof( struct SET_PORT_RANGE ) > inputBufferLength ||
                NULL == inputBuffer ) 
            {
                Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
                break;
            }

            PortRangeLo = ( ( struct SET_PORT_RANGE* ) inputBuffer )->wPortLo;
            PortRangeHi = ( ( struct SET_PORT_RANGE* ) inputBuffer )->wPortHi;

            // If the port range values are zero, the hook is being turned off
            if( 0 == PortRangeLo ||
                0 == PortRangeHi )
            {
                Irp->IoStatus.Status = IpHookSetFilterHook( FALSE );
            }
            else
            {
                Irp->IoStatus.Status = IpHookSetFilterHook( TRUE );
            }

            break;

        case IPFILTER_CMD_GET_VERSION:

            KdPrint( ( "IpHookDispatch:   IPFILTER_CMD_GET_VERSION (version=0x%04X)\n", IPFILTER_VERSION ) );

            // The caller wants to know what version we are, let them know
            if( sizeof( ULONG ) > outputBufferLength ||
                NULL == outputBuffer ) 
            {
                Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
                break;
            }
            
            *( (ULONG*) outputBuffer ) = IPFILTER_VERSION;
            Irp->IoStatus.Information = sizeof( ULONG );

            break;

        default:

            KdPrint( ( "IpHookDispatch:   Unknown IOCTL = %u\n", irpStack->Parameters.DeviceIoControl.IoControlCode ) );

            Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;

            break;
        }
        break;
    }

    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return STATUS_SUCCESS;   

} // IpHookDispatch

//----------------------------------------------------------------------------------------
// Packet logging utilities
//----------------------------------------------------------------------------------------

#ifdef IPHOOK_FEATURE_TRACE

// Utility function to print formatted binary
#define MAXLINE "   0000000000000000 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF ................\n"
void PrintBinary( const BYTE* pb, DWORD cb )
{
    DWORD iRounds;

    iRounds = 0;

    while( cb > 0 )
    {
        DWORD iPos;
        DWORD dwCurBytes;
        char szBuff[ sizeof( MAXLINE )  ];
        DWORD dwBytesLeft;
        char* pszCursor;

        pszCursor = szBuff;

        dwCurBytes = min( cb, 16 );
        
        // Begin the line
        dwBytesLeft = sizeof( szBuff ) - ( pszCursor - szBuff );
        pszCursor += _snprintf( pszCursor, dwBytesLeft, "   %08X ", (DWORD_PTR) pb + ( iRounds * 16 ) );

        // Print the binary data for as many bytes as we have for this line
        for( iPos = 0; iPos < dwCurBytes; iPos++ )
        {
            dwBytesLeft = sizeof( szBuff ) - ( pszCursor - szBuff );
            pszCursor += _snprintf( pszCursor, dwBytesLeft, "%02X ", pb[ iPos ] );
        }

        // Print blanks for any remaining positions on this line
        for( iPos = dwCurBytes; iPos < 16; iPos++ )
        {
            dwBytesLeft = sizeof( szBuff ) - ( pszCursor - szBuff );
            pszCursor += _snprintf( pszCursor, dwBytesLeft, "   " );
        }

        // Print out characters for as many bytes as we have for this line
        for( iPos = 0; iPos < dwCurBytes; iPos++ )
        {
            dwBytesLeft = sizeof( szBuff ) - ( pszCursor - szBuff );
            pszCursor += _snprintf( pszCursor, dwBytesLeft, "%c", isprint( pb[ iPos ] ) ? pb[ iPos ] : '.' );
        }

        // End the line
        dwBytesLeft = sizeof( szBuff ) - ( pszCursor - szBuff );
        pszCursor += _snprintf( pszCursor, dwBytesLeft, "\n" );

        // NOTE: The string can contain '%' so we must not use it as the format string!
        KdPrint( ( "%s", szBuff ) );

        pb += dwCurBytes;
        cb -= dwCurBytes;
        iRounds++;
    }

}

// A table of strings representing IP protocols
const char* ProtocolName[ 256 ] = 
{
    "IP","ICMP","IGMP","GGP","IPV4","5","TCP","7","8","9","10","11","PUP","13","14","15",
    "16","UDP","18","19","20","21","IDP","23","24","25","26","27","28","29","30","31",
    "32","33","34","35","36","37","38","39","40","IPV6","42","ROUTING","FRAGMENT","45","46","47",
    "48","49","ESP","AH","52","53","54","55","56","57","ICMPV6","NONE","DSTOPTS","61","62","63",
    "64","65","66","67","68","69","70","71","72","73","74","75","76","ND","ICLFXBM","79",
    "80","81","82","83","84","85","86","87","88","89","90","91","92","93","94","95",
    "96","97","98","99","100","101","102","103","104","105","106","107","108","109","110","111",
    "112","113","114","115","116","117","118","119","120","121","122","123","124","125","126","127",
    "128","129","130","131","132","133","134","135","136","137","138","139","140","141","142","143",
    "144","145","146","147","148","149","150","151","152","153","154","155","156","157","158","159",
    "160","161","162","163","164","165","166","167","168","169","170","171","172","173","174","175",
    "176","177","178","179","180","181","182","183","184","185","186","187","188","189","190","191",
    "192","193","194","195","196","197","198","199","200","201","202","203","204","205","206","207",
    "208","209","210","211","212","213","214","215","216","217","218","219","220","221","222","223",
    "224","225","226","227","228","229","230","231","232","233","234","235","236","237","238","239",
    "240","241","242","243","244","245","246","247","248","249","250","251","252","253","254","RAW",
};

VOID
IpHookLogPacket(
    BYTE      *PacketHeader,
    BYTE      *Packet,
    DWORD     PacketLength,
    BOOLEAN   fReceive
    )
{
    if( IPPROTO_TCP == PacketHeader[ 9 ] && PacketLength >= sizeof( struct CTcpHdr ) )
    {
        struct CTcpHdr* pTcpHdr;

        pTcpHdr = (struct CTcpHdr*) Packet;

        KdPrint( ( "TCP[%s %u.%u.%u.%u:%u->%u.%u.%u.%u:%u %c%c%c%c%c%c (%u bytes)]\n", 
            fReceive ? "RCV" : "XMIT", // Type
            PacketHeader[ 12 ], PacketHeader[ 13 ], PacketHeader[ 14 ], PacketHeader[ 15 ], // Source IP
            NTOHS( pTcpHdr->_ipportSrc ), // Source Port
            PacketHeader[ 16 ], PacketHeader[ 17 ], PacketHeader[ 18 ], PacketHeader[ 19 ], // Dest IP
            NTOHS( pTcpHdr->_ipportDst ), // Dest Port
            pTcpHdr->_info._bFlags & TCP_FIN ? 'F' : '-', pTcpHdr->_info._bFlags & TCP_SYN ? 'S' : '-',
            pTcpHdr->_info._bFlags & TCP_RST ? 'R' : '-', pTcpHdr->_info._bFlags & TCP_PSH ? 'P' : '-',
            pTcpHdr->_info._bFlags & TCP_ACK ? 'A' : '-', pTcpHdr->_info._bFlags & TCP_URG ? 'U' : '-', // TCP Flags
            PacketLength - sizeof( struct CTcpHdr ) ) ); // Data Bytes

        PrintBinary( Packet + sizeof( struct CTcpHdr ), PacketLength - sizeof( struct CTcpHdr ) ); 
    }
    else if( IPPROTO_UDP == PacketHeader[ 9 ] && PacketLength >= sizeof( struct CUdpHdr ) )
    {
        struct CUdpHdr* pUdpHdr;

        pUdpHdr = (struct CUdpHdr*) Packet;

        KdPrint( ( "UDP[%s %u.%u.%u.%u:%u->%u.%u.%u.%u:%u (%u bytes)]\n", 
            fReceive ? "RCV" : "XMIT", // Type
            PacketHeader[ 12 ], PacketHeader[ 13 ], PacketHeader[ 14 ], PacketHeader[ 15 ], // Source IP
            NTOHS( pUdpHdr->_ipportSrc ), // Source Port
            PacketHeader[ 16 ], PacketHeader[ 17 ], PacketHeader[ 18 ], PacketHeader[ 19 ], // Dest IP
            NTOHS( pUdpHdr->_ipportSrc ), // Dest Port
            PacketLength - sizeof( struct CUdpHdr ) ) ); // Data Bytes

        PrintBinary( Packet + sizeof( struct CUdpHdr ), PacketLength - sizeof( struct CUdpHdr ) ); 
    }
    else
    {
        KdPrint( ( "IP [%s %u.%u.%u.%u->%u.%u.%u.%u %s (%u bytes)]\n", 
            fReceive ? "RCV" : "XMIT", // Type
            PacketHeader[ 12 ], PacketHeader[ 13 ], PacketHeader[ 14 ], PacketHeader[ 15 ], // Source IP
            PacketHeader[ 16 ], PacketHeader[ 17 ], PacketHeader[ 18 ], PacketHeader[ 19 ], // Dest IP
            ProtocolName[ PacketHeader[ 9 ] ], // Protocol
            PacketLength ) ); // Data Bytes

        PrintBinary( Packet, PacketLength ); 
    }
}

#endif // IPHOOK_FEATURE_TRACE

//----------------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\util\iphook\lib\instdrv.cpp ===
#include <windows.h>
#include <winioctl.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include "iphookdd.h"
#include "sgiphook.h"

#define _COUNTOF(x) ( sizeof( x ) / sizeof( *(x) ) )

//----------------------------------------------------------------------------------------
// Forward declarations
//----------------------------------------------------------------------------------------

BOOL LoadDeviceDriverW( const WCHAR* Name, const WCHAR* Path, HANDLE* phDevice );
void UnloadDeviceDriverW( const WCHAR* Name );

//----------------------------------------------------------------------------------------
// SgIpHookLoadDriver
//----------------------------------------------------------------------------------------
HANDLE SgIpHookLoadDriver()
{
    HANDLE hDriver = INVALID_HANDLE_VALUE;
    TCHAR szEnvSysRoot[ MAX_PATH ];
    TCHAR szDriverPath[ MAX_PATH ];
    TCHAR szSourcePath[ MAX_PATH ];
    DWORD dwVersion = 0;
    DWORD dwTemp;

    // Build the path to system drivers
    if( !GetEnvironmentVariable( _T( "SYSTEMROOT" ), szEnvSysRoot, _COUNTOF( szEnvSysRoot ) ) )
    {
        OutputDebugString( _T( "Error: Failed to get the SYSTEMROOT environment variable\n" ) );
        goto Fail;
    }

    _sntprintf( szDriverPath, _COUNTOF( szDriverPath ), _T( "%s\\system32\\drivers\\" ) _T( DD_IPHOOK_NAME ) _T( ".sys" ), szEnvSysRoot );
    szDriverPath[ _COUNTOF( szDriverPath ) - 1 ] = _T( '\0' );

    // Build the path to our driver
    if( !GetModuleFileName( NULL, szSourcePath, _COUNTOF( szSourcePath ) ) )
    {
        // Failed getting module file name.
        OutputDebugString( _T( "Error: Failed generating module file name.\n" ) );
        goto Fail;
    }

    TCHAR* pszSlash = _tcsrchr( szSourcePath, _T( '\\' ) );
    if( NULL == pszSlash )
    {
        // Failed to find trailing slash
        OutputDebugString( _T( "Error: Failed finding trailing slash in path.\n" ) );
        goto Fail;
    }
 
    _tcscpy( pszSlash + 1, _T( DD_IPHOOK_NAME ) _T( ".sys" ) );

    // Copy the driver to the system directory
    if( !CopyFile( szSourcePath, szDriverPath, FALSE ) )
    {
        OutputDebugString( _T( "Error: Failed copying driver\n" ) );
        goto Fail;
    }

    // Load the device driver
    if( !LoadDeviceDriverW( _T( DD_IPHOOK_NAME ), szDriverPath, &hDriver ) )
    {
        OutputDebugString( _T( "Error: Failed loading driver\n" ) );
        goto Fail;
    }

    // Check the driver's version
    if( !DeviceIoControl( hDriver, IPFILTER_CMD_GET_VERSION, NULL, 0, &dwVersion, sizeof( dwVersion ), &dwTemp, NULL ) )
    {
        OutputDebugString( _T( "Error: Failed to retrieve version from device driver\n" ) );
        goto Fail;
    }

    if( IPFILTER_VERSION != dwVersion )
    {
        OutputDebugString( _T( "Error: Driver version does not match UI version\n" ) );
        goto Fail;
    }

Exit:
    return hDriver;

Fail:
    if( INVALID_HANDLE_VALUE != hDriver )
    {
        SgIpHookUnloadDriver( hDriver );
        hDriver = INVALID_HANDLE_VALUE;
    }

    goto Exit;
}

//----------------------------------------------------------------------------------------
// SgIpHookUnloadDriver
//----------------------------------------------------------------------------------------
void SgIpHookUnloadDriver( HANDLE hDriver )
{
    CloseHandle( hDriver );

    UnloadDeviceDriverW( _T( DD_IPHOOK_NAME ) );
}

//----------------------------------------------------------------------------------------
// SgIpHookSetPortRange
//----------------------------------------------------------------------------------------
BOOL SgIpHookSetPortRange( HANDLE hDriver, WORD wPortLo, WORD wPortHi )
{
    DWORD dwTemp;
    SET_PORT_RANGE range;

    range.wPortLo = wPortLo;
    range.wPortHi = wPortHi;

    return DeviceIoControl( hDriver, IPFILTER_CMD_SET_PORT_RANGE, &range, sizeof( range ), NULL, 0, &dwTemp, NULL );
}

//----------------------------------------------------------------------------------------
// NOTE: The following functions are taken from the NT DDK samples.
//----------------------------------------------------------------------------------------

/****************************************************************************
*
*    FUNCTION: InstallDriver( IN SC_HANDLE, IN LPCWSTR, IN LPCWSTR)
*
*    PURPOSE: Creates a driver service.
*
****************************************************************************/
BOOL InstallDriver( IN SC_HANDLE SchSCManager, IN LPCWSTR DriverName, IN LPCWSTR ServiceExe )
{
    SC_HANDLE  schService;

    schService = CreateServiceW( 
        SchSCManager,          // SCManager database
        DriverName,            // name of service
        DriverName,            // name to display
        SERVICE_ALL_ACCESS,    // desired access
        SERVICE_KERNEL_DRIVER, // service type
        SERVICE_DEMAND_START,  // start type
        SERVICE_ERROR_NORMAL,  // error control type
        ServiceExe,            // service's binary
        NULL,                  // no load ordering group
        NULL,                  // no tag identifier
        NULL,                  // no dependencies
        NULL,                  // LocalSystem account
        NULL );                // no password
    if( NULL == schService )
    {
        return FALSE;
    }

    CloseServiceHandle( schService );

    return TRUE;
}


/****************************************************************************
*
*    FUNCTION: StartDriver( IN SC_HANDLE, IN LPCWSTR)
*
*    PURPOSE: Starts the driver service.
*
****************************************************************************/
BOOL StartDriver( IN SC_HANDLE SchSCManager, IN LPCWSTR DriverName )
{
    SC_HANDLE  schService;
    BOOL       ret;

    schService = OpenServiceW( 
        SchSCManager,
        DriverName,
        SERVICE_ALL_ACCESS );
    if ( NULL == schService )
    {
        return FALSE;
    }

    ret = StartServiceW( schService, 0, NULL );
    if( !ret )
    {
        if( ERROR_SERVICE_ALREADY_RUNNING == GetLastError() )
        {
            ret = TRUE;
        }
    }

    CloseServiceHandle( schService );

    return ret;
}


/****************************************************************************
*
*    FUNCTION: OpenDevice( IN LPCWSTR, HANDLE *)
*
*    PURPOSE: Opens the device and returns a handle if desired.
*
****************************************************************************/
BOOL OpenDevice( IN LPCWSTR DriverName, HANDLE* phDevice )
{
    WCHAR    szDeviceName[64];
    HANDLE   hDevice;

    //
    // Create a \\.\XXX device name that CreateFile can use
    //
    // NOTE: We're making an assumption here that the driver
    //       has created a symbolic link using it's own name
    //       (i.e. if the driver has the name "XXX" we assume
    //       that it used IoCreateSymbolicLink to create a
    //       symbolic link "\DosDevices\XXX". Usually, there
    //       is this understanding between related apps/drivers.
    //
    //       An application might also peruse the DEVICEMAP
    //       section of the registry, or use the QueryDosDevice
    //       API to enumerate the existing symbolic links in the
    //       system.
    //

    swprintf( szDeviceName, L"\\\\.\\%s", DriverName );

    hDevice = CreateFileW( szDeviceName,
                          GENERIC_READ | GENERIC_WRITE,
                          0,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL
                          );
    if( INVALID_HANDLE_VALUE == hDevice )
    {
        return FALSE;
    }

    // If user wants handle, give it to them.  Otherwise, just close it.
    if( phDevice )
    {
        *phDevice = hDevice;
    }
    else
    {
        CloseHandle( hDevice );
    }

    return TRUE;
}


/****************************************************************************
*
*    FUNCTION: StopDriver( IN SC_HANDLE, IN LPCWSTR)
*
*    PURPOSE: Has the configuration manager stop the driver (unload it)
*
****************************************************************************/
BOOL StopDriver( IN SC_HANDLE SchSCManager, IN LPCWSTR DriverName )
{
    SC_HANDLE       schService;
    BOOL            ret;
    SERVICE_STATUS  serviceStatus;

    schService = OpenServiceW( SchSCManager, DriverName, SERVICE_ALL_ACCESS );
    if( NULL == schService )
    {
        return FALSE;
    }

    ret = ControlService( schService, SERVICE_CONTROL_STOP, &serviceStatus );

    CloseServiceHandle( schService );

    return ret;
}


/****************************************************************************
*
*    FUNCTION: RemoveDriver( IN SC_HANDLE, IN LPCWSTR)
*
*    PURPOSE: Deletes the driver service.
*
****************************************************************************/
BOOL RemoveDriver( IN SC_HANDLE SchSCManager, IN LPCWSTR DriverName )
{
    SC_HANDLE  schService;
    BOOL       ret;

    schService = OpenServiceW( 
        SchSCManager,
        DriverName,
        SERVICE_ALL_ACCESS );
    if( NULL == schService )
    {
        return FALSE;
    }

    ret = DeleteService( schService );

    CloseServiceHandle( schService );

    return ret;
}


/****************************************************************************
*
*    FUNCTION: UnloadDeviceDriverW( const WCHAR *)
*
*    PURPOSE: Stops the driver and has the configuration manager unload it.
*
****************************************************************************/
void UnloadDeviceDriverW( const WCHAR * Name )
{
    SC_HANDLE schSCManager;

    schSCManager = OpenSCManager(
        NULL,                     // machine (NULL == local)
        NULL,                     // database (NULL == default)
        SC_MANAGER_ALL_ACCESS );  // access required

    StopDriver( schSCManager, Name );
    RemoveDriver( schSCManager, Name );
     
    CloseServiceHandle( schSCManager );
}

/****************************************************************************
*
*    FUNCTION: LoadDeviceDriverW( const WCHAR *, const WCHAR *, HANDLE *)
*
*    PURPOSE: Registers a driver with the system configuration manager 
*     and then loads it.
*
****************************************************************************/
BOOL LoadDeviceDriverW( const WCHAR * Name, const WCHAR * Path, HANDLE * phDevice )
{
    SC_HANDLE schSCManager;
    BOOL ret;

    schSCManager = OpenSCManager(
        NULL,                     // machine (NULL == local)
        NULL,                     // database (NULL == default)
        SC_MANAGER_ALL_ACCESS );  // access required

    // Remove old instances
    RemoveDriver( schSCManager, Name );

    // Ignore success of installation: it may already be installed.
    InstallDriver( schSCManager, Name, Path );

    // Ignore success of start: it may already be started.
    StartDriver( schSCManager, Name );

    // Do make sure we can open it.
    ret = OpenDevice( Name, phDevice );

    CloseServiceHandle( schSCManager );

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\util\vlan\inc\vlan.h ===
// ---------------------------------------------------------------------------------------
// vlan.h
//
// Virtual Lan Library
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#ifndef __VLAN_H__
#define __VLAN_H__

BOOL WINAPI VLanInit();
BOOL WINAPI VLanDriver();
BOOL WINAPI VLanAttach(const char * pszLan, BYTE * pbEnet, void * pvArg);
void WINAPI VLanRecv(BYTE * pb, UINT cb, void * pvArg);
BOOL WINAPI VLanXmit(const BYTE * pb, UINT cb);
BOOL WINAPI VLanDetach(const BYTE * pbEnet);
void WINAPI VLanTerm();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\util\vlan\lib\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

$(BASEDIR)\private\lib$(BUILD_ALT_DIR)\i386\$(TARGETNAME).lib: $(O)\$(TARGETNAME).lib
    if not exist $(BASEDIR)\private\lib$(BUILD_ALT_DIR)\i386 md $(BASEDIR)\private\lib$(BUILD_ALT_DIR)\i386
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\util\vlan\lib\vl.h ===
// ---------------------------------------------------------------------------------------
// vl.h
//
// Virtual Lan Library
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#ifndef __VL_H__
#define __VL_H__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <vlan.h>
#include <stddef.h>

#include <vlanio.h>

// ---------------------------------------------------------------------------------------
// Definitions
// ---------------------------------------------------------------------------------------

#define INLINE              __forceinline
#define VLAN_MEMORY_NAME    "$VLAN$1$MEMORY$"
#define VLAN_MUTEX_NAME     "$VLAN$1$MUTEX$1$"
#define VLAN_EVENT_FORMAT   "$VLAN$1$EVENT$%08X$%08X$"
#define CPROCINFOMAX        16                  // Maximum number of CProcInfo
#define CLANINFOMAX         256                 // Maximum number of CLanInfo
#define CBLANNAMEMAX        32                  // Maximum number of chars in a LAN segment name
#define CNICINFOMAX         2048                // Maximum number of CNicInfo
#define CFRAMEINFOMAX       (8*1024)            // Maximum number of CFrameInfo
#define CBFRAMEMAX          1522                // Maximum number of bytes in a frame
#define CBDATAMAX           (CFRAMEINFOMAX*750) // Assume average frame is 750 bytes
#define CADAPTINFOMAX       10                  // Maximum number of CAdapterInfo in a process

#define dimensionof(x)      (sizeof((x))/sizeof(*(x)))

#define STATIC_BUFFER(_name,_nbuf,_chbuf) \
    static char s_chStaticBuffer##_name[(_nbuf)*(_chbuf)]; \
    static LONG s_lStaticBuffer##_name = 0; \
    char * pch = &s_chStaticBuffer##_name[(InterlockedIncrement(&s_lStaticBuffer##_name) % (_nbuf)) * (_chbuf)]; \
    UINT cch = (_chbuf);

// ---------------------------------------------------------------------------------------
// Asserts
// ---------------------------------------------------------------------------------------

#if DBG

INLINE void VlDbgBreak()
{
    DebugBreak();
}

int VlDbgAssertPop(const char * pszExpr, const char * pszFile, int iLine, const char * pszMsg);
#define VlDbgAssert(expr,file,line,msg) do { if (VlDbgAssertPop(expr,file,line,msg)) { VlDbgBreak(); } } while (0)
char * __cdecl VlDbgAssertFmt(char const * pszFmt, ...);
#define ASSERT_BEG(x)   do { if (!(x)) { char * __pch__ = VlDbgAssertFmt(
#define ASSERT_END(x)   ); VlDbgAssert(#x,__FILE__,__LINE__,__pch__); } } while (0)
#define Assert(x) \
        do { if (!(x)) { VlDbgAssert(#x,__FILE__,__LINE__,NULL); } } while (0)
#define AssertSz(x,sz) \
        ASSERT_BEG(x) sz ASSERT_END(x)
#define AssertSz1(x,sz,a1) \
        ASSERT_BEG(x) sz,a1 ASSERT_END(x)
#define AssertSz2(x,sz,a1,a2) \
        ASSERT_BEG(x) sz,a1,a2 ASSERT_END(x)
#define AssertSz3(x,sz,a1,a2,a3) \
        ASSERT_BEG(x) sz,a1,a2,a3 ASSERT_END(x)
#define AssertSz4(x,sz,a1,a2,a3,a4) \
        ASSERT_BEG(x) sz,a1,a2,a3,a4 ASSERT_END(x)
#define AssertSz5(x,sz,a1,a2,a3,a4,a5) \
        ASSERT_BEG(x) sz,a1,a2,a3,a4,a5 ASSERT_END(x)
#define AssertSz6(x,sz,a1,a2,a3,a4,a5,a6) \
        ASSERT_BEG(x) sz,a1,a2,a3,a4,a5,a6 ASSERT_END(x)
#define AssertSz7(x,sz,a1,a2,a3,a4,a5,a6,a7) \
        ASSERT_BEG(x) sz,a1,a2,a3,a4,a5,a6,a7 ASSERT_END(x)
#define AssertSz8(x,sz,a1,a2,a3,a4,a5,a6,a7,a8) \
        ASSERT_BEG(x) sz,a1,a2,a3,a4,a5,a6,a7,a8 ASSERT_END(x)
#define AssertSz9(x,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9) \
        ASSERT_BEG(x) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9 ASSERT_END(x)
#else
#define Assert(x)
#define AssertSz(x,sz)
#define AssertSz1(x,sz,a1)
#define AssertSz2(x,sz,a1,a2)
#define AssertSz3(x,sz,a1,a2,a3)
#define AssertSz4(x,sz,a1,a2,a3,a4)
#define AssertSz5(x,sz,a1,a2,a3,a4,a5)
#define AssertSz6(x,sz,a1,a2,a3,a4,a5,a6)
#define AssertSz7(x,sz,a1,a2,a3,a4,a5,a6,a7)
#define AssertSz8(x,sz,a1,a2,a3,a4,a5,a6,a7,a8)
#define AssertSz9(x,sz, a1,a2,a3,a4,a5,a6,a7,a8,a9)
#define AssertList(ple)
#define AssertListEntry(ple,pleReq)
#endif

#undef  ASSERT
#define ASSERT(x)   Assert(x)

// ---------------------------------------------------------------------------------------
// Trace
// ---------------------------------------------------------------------------------------

#if DBG
void __cdecl VlDbgTrace(const char * szFmt, ...);
#define TRACE_BEG(t)        do { VlDbgTrace(
#define TRACE_END(t)        ); } while (0)
#define TraceSz(sz) \
        TRACE_BEG(t) sz TRACE_END(t)
#define TraceSz1(sz,a1) \
        TRACE_BEG(t) sz,a1 TRACE_END(t)
#define TraceSz2(sz,a1,a2) \
        TRACE_BEG(t) sz,a1,a2 TRACE_END(t)
#define TraceSz3(sz,a1,a2,a3) \
        TRACE_BEG(t) sz,a1,a2,a3 TRACE_END(t)
#define TraceSz4(sz,a1,a2,a3,a4) \
        TRACE_BEG(t) sz,a1,a2,a3,a4 TRACE_END(t)
#define TraceSz5(sz,a1,a2,a3,a4,a5) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5 TRACE_END(t)
#define TraceSz6(sz,a1,a2,a3,a4,a5,a6) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6 TRACE_END(t)
#define TraceSz7(sz,a1,a2,a3,a4,a5,a6,a7) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7 TRACE_END(t)
#define TraceSz8(sz,a1,a2,a3,a4,a5,a6,a7,a8) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8 TRACE_END(t)
#define TraceSz9(sz,a1,a2,a3,a4,a5,a6,a7,a8,a9) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9 TRACE_END(t)
#define TraceSz10(sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10 TRACE_END(t)
#define TraceSz11(sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11 TRACE_END(t)
#define TraceSz12(sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12 TRACE_END(t)
#define TraceSz13(sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13 TRACE_END(t)
#define TraceSz14(sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14 TRACE_END(t)
#define TraceSz15(sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15 TRACE_END(t)
#define TraceSz16(sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16 TRACE_END(t)
#else
#define TraceSz(sz)
#define TraceSz1(sz,a1)
#define TraceSz2(sz,a1,a2)
#define TraceSz3(sz,a1,a2,a3)
#define TraceSz4(sz,a1,a2,a3,a4)
#define TraceSz5(sz,a1,a2,a3,a4,a5)
#define TraceSz6(sz,a1,a2,a3,a4,a5,a6)
#define TraceSz7(sz,a1,a2,a3,a4,a5,a6,a7)
#define TraceSz8(sz,a1,a2,a3,a4,a5,a6,a7,a8)
#define TraceSz9(sz,a1,a2,a3,a4,a5,a6,a7,a8,a9)
#define TraceSz10(sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
#define TraceSz11(sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)
#define TraceSz12(sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12)
#define TraceSz13(sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13)
#define TraceSz14(sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14)
#define TraceSz15(sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15)
#define TraceSz16(sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16)
#endif

// ---------------------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------------------

#include <pshpack1.h>

struct CVLanAddr
{
    BYTE _ab[6];

    INLINE BOOL IsEqual(const CVLanAddr & ea) const { return(memcmp(_ab, ea._ab, sizeof(_ab)) == 0); }
    INLINE BOOL IsEqual(const BYTE * pb) const { return(memcmp(_ab, pb, sizeof(_ab)) == 0); }
    INLINE void SetBroadcast()                { *(DWORD *)&_ab[0] = 0xFFFFFFFF; *(WORD *)&_ab[4] = 0xFFFF; }
    INLINE void SetZero()                     { *(DWORD *)&_ab[0] = 0x00000000; *(WORD *)&_ab[4] = 0x0000; }
    INLINE BOOL IsZero() const                { return(*(DWORD *)&_ab[0] == 0 && *(WORD *)&_ab[4] == 0); }
    INLINE BOOL IsBroadcast() const           { return(*(DWORD *)&_ab[0] == 0xFFFFFFFF && *(WORD *)&_ab[4] == 0xFFFF); }
    INLINE BOOL IsMulticast() const           { return((_ab[0] & 1) != 0); }
    char * Str() const;
};

struct CVLanHdr
{
    CVLanAddr       _eaDst;
    CVLanAddr       _eaSrc;
};

#include <poppack.h>

struct CNicInfo
{
    CVLanAddr       _ea;                        // Ethernet address of the NIC
    BYTE            _iLanInfo;                  // Index of the CLanInfo this NIC is connected to
    BYTE            _iProcInfo;                 // Index of the CProcInfo owning this NIC
    void *          _pvArg;                     // Callback context
};

struct CLanInfo
{
    BOOL            _fInUse;                    // TRUE if this entry is in use
    char            _achName[CBLANNAMEMAX];     // Name of this segment
    UINT            _cNicInfo;                  // Count of CNicInfo on this segment
    UINT            _acNicInfo[CPROCINFOMAX];   // Count of CNicInfo on this segment per process
    BOOL            _fPhysicalAdapter;          // TRUE if this lan is bound to a real nic
    UINT            _iAdaptInfo;                // Index of physical adapter info
};

struct CProcInfo
{
    BOOL            _fInUse;                    // TRUE if this entry is in use
    DWORD           _dwProcessId;               // Process Id of the process
    DWORD           _dwSerial;                  // Unique serial number when allocated/deallocated
};

struct CFrameInfo
{
    UINT64          _ib;                        // Offset to the beginning of the frame
    UINT            _cb;                        // Size of the frame
    WORD            _iLanInfo;                  // Index of the CLanInfo this frame is on
    WORD            _iProcInfo;                 // Index of the CProcInfo if this frame is directed
};

struct CVLanShared
{
    BOOL            _fInit;                     // TRUE if this structure is initialized
    DWORD           _dwSerial;                  // Highest serial number
    UINT            _cProcInfo;                 // Count of CProcInfo in use
    CProcInfo       _aProcInfo[CPROCINFOMAX];   // Vector of all CProcInfo structures
    UINT            _cLanInfo;                  // Count of CLanInfo in use
    CLanInfo        _aLanInfo[CLANINFOMAX];     // Vector of all CLanInfo structures
    UINT            _cNicInfo;                  // Count of CNicInfo in use
    CNicInfo        _aNicInfo[CNICINFOMAX];     // Vector of CNicInfo (sorted by ethernet address)
    UINT64          _iFrameInfoHead;            // Offset of CFrameInfo at the head of the queue
    UINT64          _iFrameInfoTail;            // Offset of CFrameInfo at the tail of the queue
    CFrameInfo      _aFrameInfo[CFRAMEINFOMAX]; // Vector of all CFrameInfo structures
    UINT64          _ibDataFree;                // Offset of first free byte in data queue
    UINT            _cbDataFree;                // Count of free bytes in data queue
    BYTE            _abData[CBDATAMAX];         // Vector of frame data bytes
};

// ---------------------------------------------------------------------------------------
// Driver API
// ---------------------------------------------------------------------------------------


NTSTATUS
VlCreateVNet(
    IN DWORD dwAdapterNumber,
    IN DWORD dwOptions,
    OUT PHANDLE phVNet
    );

NTSTATUS
VlAddVAdapter(
    IN HANDLE hVNet,
    IN const BYTE* pEnetAddr
    );

NTSTATUS
VlRemoveVAdapter(
    IN HANDLE hVNet,
    IN const BYTE* pEnetAddr
    );

NTSTATUS
VlReceive(
    IN HANDLE hVNet,
    IN DWORD cb,
    OUT PBYTE pb,
    IN LPOVERLAPPED lpo OPTIONAL,
    OUT PDWORD pcbReceived OPTIONAL
    );

NTSTATUS
VlSend(
    IN HANDLE hVNet,
    IN DWORD cb,
    IN const BYTE* pb,
    IN LPOVERLAPPED lpo
    );


// ---------------------------------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\util\vlan\lib\vlan.cpp ===
// ---------------------------------------------------------------------------------------
// vlan.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "vl.h"
#include <stdio.h>
#include <stdlib.h>
#include <sha.h>

// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------

struct CAdapterInfo
{
    BOOL            _fInUse;                    // TRUE if this entry is in use
    BOOL            _fDoFirstRead;              // TRUE if we need to start the first read
    UINT            _iLanInfo;                  // index back to vlan
    HANDLE          _hAdapter;                  // handle to the adapter
    OVERLAPPED      _overlapped;                // OVERLAPPED
    BYTE            _abFrame[CBFRAMEMAX];       // packet buffer
};


struct CVLanLocal
{
    LONG            _lInitLock;                 // Spin lock to synchronize VLanInit/VLanTerm
    UINT            _cRefs;                     // Number of times VLanInit called
    HANDLE          _hMutex;                    // Mutex to synchronize _VLanShared data
    UINT            _cMutexLock;                // Count of times Mutex is acquired
    HANDLE          _hMapping;                  // Handle to mapping of public data
    HANDLE          _hEvent;                    // Handle to event to wakeup receive thread
    HANDLE          _hThread;                   // Handle to receive thread
    DWORD           _adwSerial[CPROCINFOMAX];   // Serial numbers of other processes
    HANDLE          _ahEvent[CPROCINFOMAX];     // Event handle to signal other processes
    CVLanAddr       _eaDispatch;                // Ethernet address of NIC being dispatched to
    BOOL            _fShutdown;                 // TRUE to shutdown the receive thread
    CVLanShared *   _pVLanShared;               // Pointer to shared memory
    CProcInfo *     _pProcInfo;                 // Pointer to CProcInfo of this client
    UINT            _iProcInfo;                 // Index of CProcInfo of this client
    UINT            _iMaxAdaptInfo;             // Highest index of _aAdaptInfo in use
    CAdapterInfo    _aAdaptInfo[CADAPTINFOMAX]; // Physical adapter info
};

CVLanLocal        g_VLanLocal;

// ---------------------------------------------------------------------------------------
// External declarations
// ---------------------------------------------------------------------------------------

extern "C" ULONG __cdecl DbgPrint(PCH Format, ...);

// ---------------------------------------------------------------------------------------
// VlReadData
// ---------------------------------------------------------------------------------------

void VlReadData(BYTE * pb, UINT cb, UINT64 ib)
{
    CVLanShared * pVLanShared = g_VLanLocal._pVLanShared;

    UINT   ibSrc = (UINT)(ib % CBDATAMAX);
    UINT   cbSrc = CBDATAMAX - ibSrc;

    if (cbSrc > cb)
        cbSrc = cb;

    memcpy(pb, &pVLanShared->_abData[ibSrc], cbSrc);

    if (cb > cbSrc)
    {
        memcpy(pb + cbSrc, pVLanShared->_abData, cb - cbSrc);
    }
}

// ---------------------------------------------------------------------------------------
// VlWriteFrame
// ---------------------------------------------------------------------------------------

void VlWriteFrame(const BYTE * pb, UINT cb, UINT iLanInfo, UINT iProcInfo)
{
    CVLanShared * pVLanShared = g_VLanLocal._pVLanShared;

    // Make room for this new frame

    while (pVLanShared->_cbDataFree < cb || pVLanShared->_iFrameInfoTail - pVLanShared->_iFrameInfoHead == CFRAMEINFOMAX)
    {
        pVLanShared->_cbDataFree += pVLanShared->_aFrameInfo[pVLanShared->_iFrameInfoHead % CFRAMEINFOMAX]._cb;
        pVLanShared->_iFrameInfoHead += 1;
    }

    // Fill in the next available frame

    CFrameInfo * pFrameInfo = &pVLanShared->_aFrameInfo[pVLanShared->_iFrameInfoTail % CFRAMEINFOMAX];

    pFrameInfo->_ib         = pVLanShared->_ibDataFree;
    pFrameInfo->_cb         = cb;
    pFrameInfo->_iLanInfo   = (WORD) iLanInfo;
    pFrameInfo->_iProcInfo  = CPROCINFOMAX;

    pVLanShared->_iFrameInfoTail  += 1;
    pVLanShared->_ibDataFree      += cb;
    pVLanShared->_cbDataFree      -= cb;

    // Copy the contents of the frame into the data buffer

    const BYTE *  pbSrc = pb;
    UINT    ibDst = (UINT)(pFrameInfo->_ib % CBDATAMAX);
    BYTE *  pbDst = &pVLanShared->_abData[ibDst];
    UINT    cbDst = CBDATAMAX - ibDst;

    if (cbDst > cb)
    {
        cbDst = cb;
    }

    memcpy(pbDst, pbSrc, cbDst);

    if (cbDst < cb)
    {
        memcpy(pVLanShared->_abData, pbSrc + cbDst, cb - cbDst);
    }
}

// ---------------------------------------------------------------------------------------
// VlCreateEvent
// ---------------------------------------------------------------------------------------

HANDLE VlCreateEvent(DWORD dwProcessId, DWORD dwSerial)
{
    char achName[64];

    _snprintf(achName, sizeof(achName) - 1, VLAN_EVENT_FORMAT, dwProcessId, dwSerial);
    achName[sizeof(achName) - 1] = 0;

    HANDLE hEvent = CreateEventA(NULL, FALSE, FALSE, achName);

    if (hEvent == NULL)
    {
        TraceSz2("VlCreateEvent: CreateEventA '%s' failed (%d)", achName, GetLastError());
    }

    return(hEvent);
}

// ---------------------------------------------------------------------------------------
// VlSetEvent
// ---------------------------------------------------------------------------------------

void VlSetEvent(UINT iProcInfo)
{
    if (iProcInfo == g_VLanLocal._iProcInfo)
    {
        SetEvent(g_VLanLocal._hEvent);
        return;
    }

    CVLanShared *   pVLanShared = g_VLanLocal._pVLanShared;
    CProcInfo *     pProcInfo   = &pVLanShared->_aProcInfo[iProcInfo];
    DWORD *         pdwSerial   = &g_VLanLocal._adwSerial[iProcInfo];
    HANDLE *        phEvent     = &g_VLanLocal._ahEvent[iProcInfo];

    if (*phEvent != NULL && (!pProcInfo->_fInUse || pProcInfo->_dwSerial != *pdwSerial))
    {
        CloseHandle(*phEvent);
        *phEvent = NULL;
    }

    if (*phEvent == NULL && pProcInfo->_fInUse)
    {
        *phEvent = VlCreateEvent(pProcInfo->_dwProcessId, pProcInfo->_dwSerial);

        if (*phEvent == NULL)
            return;

        *pdwSerial = pProcInfo->_dwSerial;
    }

    SetEvent(*phEvent);
}

// ---------------------------------------------------------------------------------------
// VlWakeLan
// ---------------------------------------------------------------------------------------

void VlWakeLan(CLanInfo * pLanInfo)
{
    UINT *  pcNicInfo = pLanInfo->_acNicInfo;
    UINT    cNicInfo  = pLanInfo->_cNicInfo;
    UINT    iProcInfo = 0;

    for (; iProcInfo < CPROCINFOMAX && cNicInfo > 0; ++iProcInfo, ++pcNicInfo)
    {
        if (*pcNicInfo > 0)
        {
            Assert(cNicInfo >= *pcNicInfo);
            cNicInfo -= *pcNicInfo;
            VlSetEvent(iProcInfo);
        }
    }
}


// ---------------------------------------------------------------------------------------
// VlMutexLock / VlMutexUnlock
// ---------------------------------------------------------------------------------------

void VlMutexLock()
{
    Assert(g_VLanLocal._hMutex);
    WaitForSingleObject(g_VLanLocal._hMutex, INFINITE);
    g_VLanLocal._cMutexLock += 1;
}

void VlMutexUnlock()
{
    Assert(g_VLanLocal._cMutexLock > 0);
    g_VLanLocal._cMutexLock -= 1;

    Assert(g_VLanLocal._hMutex);
    ReleaseMutex(g_VLanLocal._hMutex);
}

// ---------------------------------------------------------------------------------------
// VlParseHex
// ---------------------------------------------------------------------------------------

BOOL VlParseHex(const char * pch, UINT cch, BYTE * pb, UINT cb)
{
    if (cch != cb * 2)
    {
        return(FALSE);
    }

    for (; cb > 0; --cb, ++pb, ++pch)
    {
        *pb = 0;

        if (*pch >= '0' && *pch <= '9')
            *pb |= (*pch - '0');
        else if (*pch >= 'A' && *pch <= 'F')
            *pb |= (*pch - 'A' + 10);
        else if (*pch >= 'a' && *pch <= 'f')
            *pb |= (*pch - 'a' + 10);
        else
            return(FALSE);

        (*pb) <<= 4;
        pch += 1;

        if (*pch >= '0' && *pch <= '9')
            *pb |= (*pch - '0');
        else if (*pch >= 'A' && *pch <= 'F')
            *pb |= (*pch - 'A' + 10);
        else if (*pch >= 'a' && *pch <= 'f')
            *pb |= (*pch - 'a' + 10);
        else
            return(FALSE);
    }

    return(TRUE);
}

// ---------------------------------------------------------------------------------------
// VlNicInfoLookup
// ---------------------------------------------------------------------------------------

CNicInfo * VlNicInfoLookup(CVLanAddr * pea, UINT * piNicInfo = NULL)
{
    CVLanShared * pVLanShared = g_VLanLocal._pVLanShared;
    CNicInfo *    pNicInfo;

	int iLo, iHi, iMid, iCmp;
    for ( iLo = 0, iHi = (int)pVLanShared->_cNicInfo, iMid, iCmp; iLo < iHi; )
    {
        iMid     = (iLo + iHi) >> 1;
        pNicInfo = &pVLanShared->_aNicInfo[iMid];
        iCmp     = memcmp(&pNicInfo->_ea, pea, sizeof(CVLanAddr));

        if (iCmp == 0)
        {
            if (piNicInfo)
            {
                *piNicInfo = iMid;
            }

            return(pNicInfo);
        }
        
        if (iCmp < 0)
            iLo = iMid + 1;
        else
            iHi = iMid;
    }

    if (piNicInfo)
    {
        *piNicInfo = iLo;
    }

    return(NULL);
}

// ---------------------------------------------------------------------------------------
// VlLanInfoLookup
// ---------------------------------------------------------------------------------------

CLanInfo * VlLanInfoLookup(char * pszLan)
{
    CVLanShared *   pVLanShared = g_VLanLocal._pVLanShared;
    CLanInfo *      pLanInfo    = pVLanShared->_aLanInfo;
    UINT            cLanInfo    = pVLanShared->_cLanInfo;
    UINT            iLanInfo    = 0;

    for (; iLanInfo < CLANINFOMAX && cLanInfo > 0; ++iLanInfo, ++pLanInfo)
    {
        if (pLanInfo->_fInUse)
        {
            cLanInfo -= 1;

            if (_stricmp(pszLan, pLanInfo->_achName) == 0)
            {
                return(pLanInfo);
            }
        }
    }

    return(NULL);
}

// ---------------------------------------------------------------------------------------
// VlDetachNics
// ---------------------------------------------------------------------------------------

void VlDetachNics(CVLanShared * pVLanShared, UINT iProcInfo)
{
    while (1)
    {
        CNicInfo *  pNicInfo = pVLanShared->_aNicInfo;
        UINT        iNicInfo = 0;
        UINT        cNicInfo = pVLanShared->_cNicInfo;

        for (; iNicInfo < cNicInfo; ++iNicInfo, ++pNicInfo)
        {
            if (pNicInfo->_iProcInfo == iProcInfo)
                break;
        }

        if (iNicInfo == cNicInfo)
            break;

        TraceSz2("VlDetachNics: Detaching %s on '%s'",
                 pNicInfo->_ea.Str(), pVLanShared->_aLanInfo[pNicInfo->_iLanInfo]._achName);

        UINT       iLanInfo = pNicInfo->_iLanInfo;
        CLanInfo * pLanInfo = &pVLanShared->_aLanInfo[iLanInfo];

        Assert(pLanInfo->_fInUse);
        Assert(pLanInfo->_cNicInfo > 0);
        Assert(pLanInfo->_acNicInfo[iProcInfo] > 0);

        pLanInfo->_acNicInfo[iProcInfo] -= 1;

        if (--pLanInfo->_cNicInfo == 0)
        {
            memset(pLanInfo, 0, sizeof(CLanInfo));

            Assert(pVLanShared->_cLanInfo > 0);
            pVLanShared->_cLanInfo -= 1;
        }

        Assert(pVLanShared->_cNicInfo > 0);
        pVLanShared->_cNicInfo -= 1;

        if (iNicInfo < pVLanShared->_cNicInfo)
        {
            memmove(pNicInfo, pNicInfo + 1, (pVLanShared->_cNicInfo - iNicInfo) * sizeof(CNicInfo));
        }
    }
}

// ---------------------------------------------------------------------------------------
// VlCleanup
// ---------------------------------------------------------------------------------------

void VlCleanup()
{
    if (g_VLanLocal._hThread)
    {
        g_VLanLocal._fShutdown = TRUE;
        SetEvent(g_VLanLocal._hEvent);
        WaitForSingleObject(g_VLanLocal._hThread, INFINITE);
    }

    if (g_VLanLocal._pProcInfo)
    {
        VlMutexLock();

        CVLanShared * pVLanShared = g_VLanLocal._pVLanShared;

        // Manually detach any NIC left attached in this process

        VlDetachNics(pVLanShared, g_VLanLocal._iProcInfo);

        // Release the CProcInfo

        memset(g_VLanLocal._pProcInfo, 0, sizeof(CProcInfo));
        pVLanShared->_cProcInfo -= 1;

        VlMutexUnlock();

        g_VLanLocal._pProcInfo  = NULL;
        g_VLanLocal._iProcInfo  = 0;

        HANDLE * pHandle = g_VLanLocal._ahEvent;
        UINT     cHandle = CPROCINFOMAX;

        for (; cHandle > 0; --cHandle, ++pHandle)
        {
            if (*pHandle)
            {
                CloseHandle(*pHandle);
                *pHandle = NULL;
            }
        }
    }

    if (g_VLanLocal._hEvent)
    {
        CloseHandle(g_VLanLocal._hEvent);
        g_VLanLocal._hEvent = NULL;
    }

    if (g_VLanLocal._pVLanShared)
    {
        UnmapViewOfFile(g_VLanLocal._pVLanShared);
        g_VLanLocal._pVLanShared = NULL;
    }

    if (g_VLanLocal._hMapping)
    {
        CloseHandle(g_VLanLocal._hMapping);
        g_VLanLocal._hMapping = NULL;
    }

    if (g_VLanLocal._cMutexLock > 0)
    {
        VlMutexUnlock();
    }

    if (g_VLanLocal._hMutex)
    {
        Assert(g_VLanLocal._cMutexLock == 0);
        CloseHandle(g_VLanLocal._hMutex);
        g_VLanLocal._hMutex = NULL;
    }
}

// ---------------------------------------------------------------------------------------
// VlCleanupOrphans
// ---------------------------------------------------------------------------------------

void VlCleanupOrphans(CVLanShared * pVLanShared)
{
    CProcInfo * pProcInfo = pVLanShared->_aProcInfo;
    UINT        cProcInfo = CPROCINFOMAX;
    UINT        iProcInfo = 0;

    for (iProcInfo = 0; iProcInfo < cProcInfo; ++iProcInfo, ++pProcInfo)
    {
        if (pProcInfo->_fInUse)
        {
            HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pProcInfo->_dwProcessId);
            DWORD dwExitCode = STILL_ACTIVE;

            if (    hProcess == NULL
                ||  pProcInfo->_dwProcessId == GetCurrentProcessId()
                ||  (GetExitCodeProcess(hProcess, &dwExitCode) && dwExitCode != STILL_ACTIVE))
            {
                TraceSz2("VlCleanupOrphans: Cleaning up iProcInfo %d (dwProcessId %08X)",
                         iProcInfo, pProcInfo->_dwProcessId);
                VlDetachNics(pVLanShared, iProcInfo);
                memset(pProcInfo, 0, sizeof(CProcInfo));
                pVLanShared->_cProcInfo -= 1;
            }

            if (hProcess != NULL)
            {
                CloseHandle(hProcess);
            }
        }
    }
}


void VlReadVNet(CAdapterInfo * pAdaptInfo)
{
    if (pAdaptInfo->_fInUse)
    {
        UINT cFrames = 0;
       
        while (TRUE)
        {
            BOOL        fSuccess;
            NTSTATUS    Status;
            DWORD       cbFrame;

            if (!pAdaptInfo->_fDoFirstRead)
            {
                // see if we have a completed read
                
                fSuccess = GetOverlappedResult(pAdaptInfo->_hAdapter,       // adapter handle
                                               &pAdaptInfo->_overlapped,    // overlapped
                                               (PDWORD) &cbFrame,           // cbRead
                                               FALSE);                      // bWait

                if (!fSuccess)
                {
                    if (GetLastError() == ERROR_IO_INCOMPLETE)
                    {
                        // nothing to read.
                        break;
                    }
                    else
                    {
                        // read failed!
                        TraceSz1("VlThreadProc: async read failed (ERROR 0x%d)",
                                 GetLastError());
                        break;
                    }
                }

                cFrames++;

                // xmit received frame

                CVLanHdr *  pVLanHdr    = (CVLanHdr *)pAdaptInfo->_abFrame;
                BOOL        fBroadcast  = pVLanHdr->_eaDst.IsBroadcast();
                
                VlWriteFrame(pAdaptInfo->_abFrame,
                             cbFrame,
                             pAdaptInfo->_iLanInfo,
                             fBroadcast ?  CPROCINFOMAX : g_VLanLocal._iProcInfo
                             );

                if (fBroadcast)
                {
                    CVLanShared *   pVLanShared = g_VLanLocal._pVLanShared;
                    CLanInfo * pLanInfo = &pVLanShared->_aLanInfo[pAdaptInfo->_iLanInfo];
                    VlWakeLan(pLanInfo);
                }
                else
                {
                    VlSetEvent(g_VLanLocal._iProcInfo);
                }                                
                            
            }
            else
            {
                pAdaptInfo->_fDoFirstRead = FALSE;
            }
            
            // do a new read

            memset(&pAdaptInfo->_overlapped, 0, sizeof(OVERLAPPED));
            
            pAdaptInfo->_overlapped.hEvent = g_VLanLocal._hEvent;
            
            Status = VlReceive(
                            pAdaptInfo->_hAdapter,      // hVNet
                            CBFRAMEMAX,                 // cb
                            pAdaptInfo->_abFrame,       // pb
                            &pAdaptInfo->_overlapped,   // lpo
                            NULL);                      // pcbReceived

            if (!NT_SUCCESS(Status))
            {
                TraceSz1("VlThreadProc: VlReceive failed (NTSTATUS %x)",
                         Status);

                // don't try to read again
                CloseHandle(pAdaptInfo->_hAdapter);
                pAdaptInfo->_hAdapter = NULL;
                
                break;
            }
            else
            {
                // the driver doesn't do this
                AssertSz((Status == STATUS_PENDING),
                         "VlReceive returned success in-line!");
            }
            
        }

    }

}

// ---------------------------------------------------------------------------------------
// VlThreadProc
// ---------------------------------------------------------------------------------------

DWORD WINAPI VlThreadProc(void *)
{
    CVLanShared *   pVLanShared = g_VLanLocal._pVLanShared;
    CProcInfo *     pProcInfo   = g_VLanLocal._pProcInfo;
    UINT            iProcInfo   = g_VLanLocal._iProcInfo;
    UINT64          iFrameInfo  = 0;
    CFrameInfo *    pFrameInfo  = NULL;
    BYTE            abFrameOrig[CBFRAMEMAX];
    BYTE            abFrameDisp[CBFRAMEMAX];
    UINT            cbFrame     = 0;
    CVLanHdr *      pVLanHdr    = (CVLanHdr *)abFrameOrig;
    UINT            iLanInfo    = 0;
    UINT            cLanInfo    = 0;
    CLanInfo *      pLanInfo    = NULL;
    UINT            iNicInfo    = 0;
    UINT            cNicInfo    = 0;
    CNicInfo *      pNicInfo    = NULL;
    BOOL            fDispatch   = FALSE;
    BOOL            fBroadcast  = FALSE;
    void *          pvArg       = NULL;

    while (!g_VLanLocal._fShutdown)
    {
        while (!g_VLanLocal._fShutdown)
        {
            fDispatch  = FALSE;
            fBroadcast = FALSE;

            while (!g_VLanLocal._fShutdown)
            {
                VlMutexLock();

                if (fBroadcast)
                {
                    // Find the next NIC in this process on this LAN segment to dispatch the frame to

                    Assert(fDispatch);

                    pNicInfo = VlNicInfoLookup(&g_VLanLocal._eaDispatch, &iNicInfo);

                    if (pNicInfo != NULL)
                    {
                        Assert(pVLanShared->_cNicInfo > iNicInfo);
                        pNicInfo += 1;
                        cNicInfo  = pVLanShared->_cNicInfo - iNicInfo - 1;
                    }
                    else
                    {
                        pNicInfo = &pVLanShared->_aNicInfo[iNicInfo];
                        cNicInfo = pVLanShared->_cNicInfo - iNicInfo;
                    }

                    for (; cNicInfo > 0; --cNicInfo, ++pNicInfo)
                    {
                        if (     pNicInfo->_iLanInfo == iLanInfo
                            &&   pNicInfo->_iProcInfo == iProcInfo
                            &&  !pNicInfo->_ea.IsEqual(pVLanHdr->_eaSrc))
                            break;
                    }

                    if (cNicInfo > 0)
                    {
                        g_VLanLocal._eaDispatch = pNicInfo->_ea;
                        pvArg                   = pNicInfo->_pvArg;
                        goto dispatch;
                    }

                    fBroadcast = FALSE;
                }

                if (fDispatch)
                {
                    g_VLanLocal._eaDispatch.SetZero();
                    fDispatch = FALSE;
                }

                // If there are packets on the physical adapters, pick them up.

                UINT iAdaptInfo;
                CAdapterInfo * pAdaptInfo;

                for (iAdaptInfo = 0;
                     iAdaptInfo <= g_VLanLocal._iMaxAdaptInfo;
                     iAdaptInfo++)
                {
                    pAdaptInfo = &g_VLanLocal._aAdaptInfo[iAdaptInfo];
                    VlReadVNet(pAdaptInfo);

                }
                

                // If the head of the queue has advanced beyond our read point, advance to the head.

                if (iFrameInfo < pVLanShared->_iFrameInfoHead)
                {
                    // If this is the first time we've checked the queue, skip all frames and
                    // start at the very end.  This prevents a process from connecting into a VLan
                    // and getting flooded with packets that were enqueued in the past.

                    if (iFrameInfo == 0)
                        iFrameInfo = pVLanShared->_iFrameInfoTail;
                    else
                        iFrameInfo = pVLanShared->_iFrameInfoHead;
                }

                while (!g_VLanLocal._fShutdown && iFrameInfo < pVLanShared->_iFrameInfoTail)
                {
                    pFrameInfo = &pVLanShared->_aFrameInfo[iFrameInfo % CFRAMEINFOMAX];
                    iFrameInfo += 1;

                    // If this frame is directed at a different process, go on to the next one

                    if (pFrameInfo->_iProcInfo < CPROCINFOMAX && pFrameInfo->_iProcInfo != iProcInfo)
                        continue;

                    // Sanity check the frame for valid size

                    if (pFrameInfo->_cb < sizeof(CVLanHdr) || pFrameInfo->_cb > CBFRAMEMAX)
                        continue;

                    // If this frame is on a LAN segment on which this process has no NICs,
                    // go on to the next one.

                    iLanInfo = pFrameInfo->_iLanInfo;
                    pLanInfo = &pVLanShared->_aLanInfo[iLanInfo];

                    if (pLanInfo->_acNicInfo[iProcInfo] == 0)
                        continue;

                    // Read the CVLanHdr from the beginning of the frame

                    VlReadData((BYTE *)pVLanHdr, sizeof(CVLanHdr), pFrameInfo->_ib);

                    fBroadcast = pVLanHdr->_eaDst.IsBroadcast();

                    if (fBroadcast)
                    {
                        // Find the first NIC in this process that is on this LAN segment.

                        pNicInfo = pVLanShared->_aNicInfo;
                        cNicInfo = pVLanShared->_cNicInfo;

                        for (; cNicInfo > 0; --cNicInfo, ++pNicInfo)
                        {
                            if (     pNicInfo->_iLanInfo == iLanInfo
                                &&   pNicInfo->_iProcInfo == iProcInfo
                                &&  !pNicInfo->_ea.IsEqual(pVLanHdr->_eaSrc))
                                break;
                        }

                        if (cNicInfo == 0)
                        {
                            fBroadcast = FALSE;
                            continue;
                        }
                    }
                    else
                    {
                        pNicInfo = VlNicInfoLookup(&pVLanHdr->_eaDst);

                        // If the NIC doesn't exist, is not attached in this process, or is not
                        // on this LAN segment, go on to the next frame.

                        if (    pNicInfo == NULL
                            ||  pNicInfo->_iProcInfo != iProcInfo
                            ||  pNicInfo->_iLanInfo != iLanInfo)
                            continue;
                    }

                    g_VLanLocal._eaDispatch = pNicInfo->_ea;
                    pvArg                   = pNicInfo->_pvArg;
                    cbFrame                 = pFrameInfo->_cb;
                    fDispatch               = TRUE;

                    // Read the rest of the frame data

                    VlReadData(&abFrameOrig[sizeof(CVLanHdr)], cbFrame - sizeof(CVLanHdr),
                               pFrameInfo->_ib + sizeof(CVLanHdr));

                    break;
                }

            dispatch:

                VlMutexUnlock();

                if (!fDispatch)
                    break;

                if (fBroadcast)
                {
                    memcpy(abFrameDisp, abFrameOrig, cbFrame);
                    VLanRecv(abFrameDisp, cbFrame, pvArg);
                }
                else
                {
                    VLanRecv(abFrameOrig, cbFrame, pvArg);
                }
            }

            if (!fDispatch)
                break;
        }

        if (g_VLanLocal._fShutdown)
            break;

        // Sleep until there is more work to do

        WaitForSingleObject(g_VLanLocal._hEvent, INFINITE);
    }

    return(0);
}

// ---------------------------------------------------------------------------------------
// VLanInit
// ---------------------------------------------------------------------------------------

BOOL WINAPI VLanInit()
{
    BOOL fResult = FALSE;

    while (InterlockedCompareExchange(&g_VLanLocal._lInitLock, 1, 0))
    {
        Sleep(10);
    }

    if (g_VLanLocal._cRefs == 0)
    {
        // Find or create the shared Mutex by name

        g_VLanLocal._hMutex = CreateMutexA(NULL, FALSE, VLAN_MUTEX_NAME);

        if (g_VLanLocal._hMutex == NULL)
        {
            TraceSz1("VLanInit: CreateMutex failed (%d)", GetLastError());
            goto ret;
        }

        // Find or create the shared File Mapping by name

        g_VLanLocal._hMapping = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, sizeof(CVLanShared), VLAN_MEMORY_NAME);

        if (g_VLanLocal._hMapping == NULL)
        {
            TraceSz1("VLanInit: CreateFileMapping failed (%d)", GetLastError());
            goto ret;
        }

        // Map the shared memory into this process

        CVLanShared * pVLanShared = (CVLanShared *)MapViewOfFile(g_VLanLocal._hMapping, FILE_MAP_WRITE, 0, 0, 0);

        if (pVLanShared == NULL)
        {
            TraceSz1("VLanInit: MapViewOfFile failed (%d)", GetLastError());
            goto ret;
        }

        g_VLanLocal._pVLanShared = pVLanShared;

        // Init local adapter array.
        UINT iAdaptInfo;

        for (iAdaptInfo = 0; iAdaptInfo < CADAPTINFOMAX; iAdaptInfo++)
        {
            g_VLanLocal._aAdaptInfo[iAdaptInfo]._fInUse = FALSE;
        }

        g_VLanLocal._iMaxAdaptInfo = 0;

        // Acquire exclusive access to the shared memory

        VlMutexLock();

        // Initialize the shared memory if necessary

        if (!pVLanShared->_fInit)
        {
            memset(pVLanShared, 0, offsetof(CVLanShared, _abData));

            pVLanShared->_fInit        = TRUE;
            pVLanShared->_dwSerial     = GetTickCount();
            pVLanShared->_cbDataFree   = CBDATAMAX;
        }

        VlCleanupOrphans(pVLanShared);

        // Find an empty CProcInfo slot for this process

        CProcInfo * pProcInfo = pVLanShared->_aProcInfo;
        UINT        cProcInfo = CPROCINFOMAX;
        UINT        iProcInfo = 0;

        for (iProcInfo = 0; iProcInfo < cProcInfo; ++iProcInfo, ++pProcInfo)
        {
            if (!pProcInfo->_fInUse)
                break;
        }

        if (iProcInfo == cProcInfo)
            goto ret;

        // Initialize the CProcInfo

        pProcInfo->_fInUse      = TRUE;
        pProcInfo->_dwProcessId = GetCurrentProcessId();
        pProcInfo->_dwSerial    = ++pVLanShared->_dwSerial;
        
        g_VLanLocal._pProcInfo  = pProcInfo;
        g_VLanLocal._iProcInfo  = iProcInfo;

        pVLanShared->_cProcInfo += 1;

        // Create a named event for this process

        g_VLanLocal._hEvent = VlCreateEvent(pProcInfo->_dwProcessId, pProcInfo->_dwSerial);

        if (g_VLanLocal._hEvent == NULL)
            goto ret;

        // Create a thread to process received frames

        g_VLanLocal._fShutdown = FALSE;
        g_VLanLocal._hThread   = CreateThread(NULL, 0, VlThreadProc, NULL, 0, NULL);

        if (g_VLanLocal._hThread == NULL)
        {
            TraceSz1("VLanInit: CreateThread failed (%d)", GetLastError());
            goto ret;
        }

        // Release exclusive access to the shared memory

        VlMutexUnlock();

        // Increase the priority of the VlThreadProc thread so that we handle frames
        // in a timely fashion.

        SetThreadPriority(g_VLanLocal._hThread, THREAD_PRIORITY_ABOVE_NORMAL);
    }

    g_VLanLocal._cRefs += 1;
    fResult = TRUE;

ret:

    if (!fResult)
    {
        VlCleanup();
    }

    g_VLanLocal._lInitLock = 0;

    return(fResult);
}

// ---------------------------------------------------------------------------------------
// VLanTerm
// ---------------------------------------------------------------------------------------

void WINAPI VLanTerm()
{
    while (InterlockedCompareExchange(&g_VLanLocal._lInitLock, 1, 0))
    {
        Sleep(10);
    }

    Assert(g_VLanLocal._cRefs > 0);

    if (--g_VLanLocal._cRefs == 0)
    {
        VlCleanup();

        // Make sure there are no adapters

        for (UINT iAdaptInfo = 0; iAdaptInfo < CADAPTINFOMAX; iAdaptInfo++)
        {
            Assert(!g_VLanLocal._aAdaptInfo[iAdaptInfo]._fInUse);
        }
    }

    g_VLanLocal._lInitLock = 0;
}

// ---------------------------------------------------------------------------------------
// VLanAttach
// ---------------------------------------------------------------------------------------

BOOL WINAPI VLanAttach(const char * pszLan, BYTE * pbEnet, void * pvArg)
{
    BOOL fResult = FALSE;

    VlMutexLock();

    CVLanShared *   pVLanShared = g_VLanLocal._pVLanShared;

    char * pszComp;
    char achName[64];
    char achLan[64];
    const char* pchSrcConst;
    char* pchSrc;
    CVLanAddr ea;
    size_t cch;

    pszComp = getenv("COMPUTERNAME");

    if (pszComp == NULL)
        pszComp = "COMPUTERNAME";

    // Split pszLan into <achName>@<achLan>

    for (pchSrcConst = pszLan; *pchSrcConst && *pchSrcConst != '@'; ++pchSrcConst) ;

    if (*pchSrcConst != '@')
    {
        // If the string does not contain an '@' sign, then default the lan to "Lan".

        strncpy(achName, pszLan, sizeof(achName));
        achName[sizeof(achName) - 1] = 0;

        strncpy(achLan, "Lan", sizeof(achLan));
        achLan[sizeof(achLan) - 1] = 0;
    }
    else
    {
        // Copy the first part into achName and the second part into achLan

        cch = pchSrcConst - pszLan;

        if (cch > sizeof(achName) - 1)
            cch = sizeof(achName) - 1;
        
        memcpy(achName, pszLan, cch);
        achName[cch] = 0;

        cch = strlen(pszLan) - cch - 1;

        if (cch > sizeof(achLan) - 1)
            cch = sizeof(achLan) - 1;

        memcpy(achLan, pchSrcConst + 1, cch);
        achLan[cch] = 0;
    }

    // Split achLan into <achLan>:<EnetAddr>

    ea.SetZero();

    for (pchSrc = achLan; *pchSrc && *pchSrc != ':'; ++pchSrc) ;

    if (*pchSrc == ':')
    {
        cch = strlen(achLan) - (pchSrc - achLan) - 1;

        if (cch == 12 && VlParseHex(pchSrc + 1, 12, ea._ab, sizeof(ea._ab)))
        {
            *pchSrc = 0;
        }
        else
        {
            ea.SetZero();
        }
    }

    if (ea.IsZero())
    {
        // Make up an ethernet address from pszComp/achName/achLan

        A_SHA_CTX shaCtx;
        BYTE abHash[A_SHA_DIGEST_LEN];

        A_SHAInit(&shaCtx);
        A_SHAUpdate(&shaCtx, (BYTE *)pszComp, strlen(pszComp) + 1);
        A_SHAUpdate(&shaCtx, (BYTE *)achName, strlen(achName) + 1);
        A_SHAUpdate(&shaCtx, (BYTE *)achLan, strlen(achLan) + 1);
        A_SHAFinal(&shaCtx, abHash);

        abHash[0] &= ~1;

        memcpy(ea._ab, abHash, sizeof(ea._ab));
    }

    memcpy(pbEnet, ea._ab, sizeof(ea._ab));

    UINT        cchLan      = strlen(achLan);
    UINT        iProcInfo   = g_VLanLocal._iProcInfo;
    UINT        iNicInfo    = 0;
    CNicInfo *  pNicInfo    = VlNicInfoLookup((CVLanAddr *)pbEnet, &iNicInfo);

    if (pNicInfo)
    {
        TraceSz2("VLanAttach: %s already attached to '%s'",
                 pNicInfo->_ea.Str(), pVLanShared->_aLanInfo[pNicInfo->_iLanInfo]._achName);
        goto ret;
    }

    if (pVLanShared->_cNicInfo == CNICINFOMAX)
    {
        TraceSz1("VLanAttach: CNicInfo table is full (%d entries)", CNICINFOMAX);
        goto ret;
    }

    if (cchLan >= CBLANNAMEMAX)
    {
        TraceSz1("VLanAttach: '%s' must not be longer than %d characters", CBLANNAMEMAX - 1);
        goto ret;
    }

    CLanInfo * pLanInfo = VlLanInfoLookup(achLan);

    if (pLanInfo == NULL)
    {
        UINT cLanInfo = CLANINFOMAX;
        UINT iLanInfo = 0;

        for (pLanInfo = pVLanShared->_aLanInfo; iLanInfo < cLanInfo; ++iLanInfo, ++pLanInfo)
        {
            if (!pLanInfo->_fInUse)
                break;
        }

        if (iLanInfo == cLanInfo)
        {
            TraceSz1("VLanAttach: CLanInfo table is full (%d entries)", CLANINFOMAX);
            goto ret;
        }

        memset(pLanInfo, 0, sizeof(CLanInfo));

        pLanInfo->_fInUse = TRUE;
        memcpy(pLanInfo->_achName, achLan, cchLan + 1);

        pVLanShared->_cLanInfo += 1;
    }

    pNicInfo = &pVLanShared->_aNicInfo[iNicInfo];

    if (iNicInfo < pVLanShared->_cNicInfo)
    {
        memmove(pNicInfo + 1, pNicInfo, (pVLanShared->_cNicInfo - iNicInfo) * sizeof(CNicInfo));
    }

    pNicInfo->_ea        = *(CVLanAddr *)pbEnet;
    pNicInfo->_iLanInfo  = (BYTE)(pLanInfo - pVLanShared->_aLanInfo);
    pNicInfo->_iProcInfo = (BYTE) iProcInfo;
    pNicInfo->_pvArg     = pvArg;

    pLanInfo->_cNicInfo += 1;
    pLanInfo->_acNicInfo[iProcInfo] += 1;
    pVLanShared->_cNicInfo += 1;

    if (_strnicmp(achLan, "Nic/", 4) == 0 && cchLan == 5 && achLan[4] >= '0' && achLan[4] <= '9')
    {
        NTSTATUS Status;
        UINT iAdaptInfo = (UINT) achLan[4] - '0';

        pLanInfo->_fPhysicalAdapter = TRUE;
        pLanInfo->_iAdaptInfo = iAdaptInfo;

        CAdapterInfo * pAdaptInfo = &g_VLanLocal._aAdaptInfo[iAdaptInfo];

        if (!pAdaptInfo->_fInUse)
        {
            // open adapter           
            Status = VlCreateVNet(iAdaptInfo, VLAN_OPTION_OVERLAPPED, &pAdaptInfo->_hAdapter);

            if (!NT_SUCCESS(Status))
            {
                TraceSz1("VLanAttach: VlCreateVNet failed (NTSTATUS %x)", Status);
                pAdaptInfo->_hAdapter = NULL;
            }
            else
            {
                pAdaptInfo->_fInUse        = TRUE;
                pAdaptInfo->_fDoFirstRead  = TRUE;
                pAdaptInfo->_iLanInfo      = (UINT)(pLanInfo - pVLanShared->_aLanInfo);
                g_VLanLocal._iMaxAdaptInfo = max(g_VLanLocal._iMaxAdaptInfo, iAdaptInfo);
            }
        }

        if (pAdaptInfo->_fInUse)
        {
            Status = VlAddVAdapter(pAdaptInfo->_hAdapter, pbEnet);
                
            if (!NT_SUCCESS(Status))
            {
                TraceSz1("VLanAttach: VlAddVAdapter failed (NTSTATUS %x)", Status);
            }
        }

        // wake up VlThreadProc to do an initial read on the adapter
        VlSetEvent(g_VLanLocal._iProcInfo);
    }

    fResult = TRUE;

ret:

    VlMutexUnlock();

    return(fResult);
}

// ---------------------------------------------------------------------------------------
// VLanDetach
// ---------------------------------------------------------------------------------------

BOOL WINAPI VLanDetach(const BYTE * pbEnet)
{
    BOOL            fResult         = FALSE;
    CVLanShared *   pVLanShared     = g_VLanLocal._pVLanShared;
    CProcInfo *     pProcInfo       = g_VLanLocal._pProcInfo;
    UINT            iProcInfo       = g_VLanLocal._iProcInfo;
    HANDLE          hAdapter        = NULL;
    BOOL            fCloseAdapter   = FALSE;

    while (1)
    {
        VlMutexLock();

        if (!g_VLanLocal._eaDispatch.IsEqual(pbEnet))
            break;

        // VlThreadProc is currently dispatching to this NIC.  Release the mutex, yield
        // the rest of the thread quantum, and try again.

        VlMutexUnlock();

        Sleep(10);
    }

    UINT       iNicInfo;
    CNicInfo * pNicInfo = VlNicInfoLookup((CVLanAddr *)pbEnet, &iNicInfo);

    if (pNicInfo == NULL)
    {
        TraceSz1("VLanDetach: %s was not found", ((CVLanAddr *)pbEnet)->Str());
        goto ret;
    }

    if (pNicInfo->_iProcInfo != iProcInfo)
    {
        TraceSz1("VLanDetach: %s was not added in this process", ((CVLanAddr *)pbEnet)->Str());
        goto ret;
    }

    UINT       iLanInfo = pNicInfo->_iLanInfo;
    CLanInfo * pLanInfo = &pVLanShared->_aLanInfo[iLanInfo];

    Assert(pLanInfo->_fInUse);
    Assert(pLanInfo->_cNicInfo > 0);
    Assert(pLanInfo->_acNicInfo[iProcInfo] > 0);

    if (pLanInfo->_fPhysicalAdapter)
    {
        hAdapter = g_VLanLocal._aAdaptInfo[pLanInfo->_iAdaptInfo]._hAdapter;
    }
    
    if (--pLanInfo->_acNicInfo[iProcInfo] == 0 && hAdapter)
    {
        fCloseAdapter = TRUE;
        g_VLanLocal._aAdaptInfo[pLanInfo->_iAdaptInfo]._hAdapter = NULL;
        g_VLanLocal._aAdaptInfo[pLanInfo->_iAdaptInfo]._fInUse = FALSE;
    }

    if (--pLanInfo->_cNicInfo == 0)
    {
        memset(pLanInfo, 0, sizeof(CLanInfo));
        Assert(pVLanShared->_cLanInfo > 0);
        pVLanShared->_cLanInfo -= 1;
    }

    Assert(pVLanShared->_cNicInfo > 0);
    pVLanShared->_cNicInfo -= 1;

    if (iNicInfo < pVLanShared->_cNicInfo)
    {
        memmove(pNicInfo, pNicInfo + 1, (pVLanShared->_cNicInfo - iNicInfo) * sizeof(CNicInfo));
    }

    fResult = TRUE;

ret:

    VlMutexUnlock();

    if (hAdapter)
    {
        // Remove pbEnet from filter list of the adapter

        VlRemoveVAdapter(hAdapter, pbEnet);

        if (fCloseAdapter)
        {
            CloseHandle(hAdapter);
        }
    }

    return(fResult);
}

// ---------------------------------------------------------------------------------------
// VLanXmit
// ---------------------------------------------------------------------------------------

BOOL WINAPI VLanXmit(const BYTE * pb, UINT cb)
{
    if (cb < sizeof(CVLanHdr))
    {
        TraceSz2("VLanXmit: Frame is too small (%d bytes).  Must be at least %d bytes", cb, sizeof(CVLanHdr));
        return(FALSE);
    }

    if (cb > CBFRAMEMAX)
    {
        TraceSz2("VLanXmit: Frame is too large (%d bytes).  Maximum is %d bytes", cb, CBFRAMEMAX);
        return(FALSE);
    }

    BOOL            fResult     = FALSE;
    CVLanShared *   pVLanShared = g_VLanLocal._pVLanShared;
    CVLanHdr *      pVLanHdr    = (CVLanHdr *)pb;
    UINT            iProcInfo   = g_VLanLocal._iProcInfo;
    BOOL            fBroadcast  = pVLanHdr->_eaDst.IsBroadcast();
    HANDLE          hAdapter    = NULL;
    
    VlMutexLock();

    CNicInfo *      pNicInfoSrc = VlNicInfoLookup(&pVLanHdr->_eaSrc);
    CNicInfo *      pNicInfoDst = fBroadcast ? NULL : VlNicInfoLookup(&pVLanHdr->_eaDst);

    if (pNicInfoSrc == NULL)
    {
        TraceSz1("VLanXmit: Source address %s was not found", pVLanHdr->_eaSrc.Str());
        goto ret;
    }

    if (pNicInfoSrc->_iProcInfo != iProcInfo)
    {
        TraceSz1("VLanXmit: Source address %s was not added in this process", pVLanHdr->_eaSrc.Str());
        goto ret;
    }

    WORD            iLanInfo    = pNicInfoSrc->_iLanInfo;
    CLanInfo *      pLanInfo    = &pVLanShared->_aLanInfo[iLanInfo];

    if (pNicInfoDst && pNicInfoDst->_iLanInfo != iLanInfo)
    {
        // The frame is being unicast to a destination that exists on a different virtual LAN
        // segment than the segment where the sender is connected. Don't send this through
        // VlWriteFrame, but go ahead and send through VlSend in case the two physical adapters
        // are on the same segment.
        
        pNicInfoDst = NULL;
    }

    if (pNicInfoDst == pNicInfoSrc)
    {
        // The frame is being unicast to its sender.
        // Just drop the packet without error.

        fResult = TRUE;
        goto ret;
    }

    if (    pNicInfoDst == NULL
        &&  pLanInfo->_fPhysicalAdapter
        &&  g_VLanLocal._aAdaptInfo[pLanInfo->_iAdaptInfo]._fInUse)
    {
        hAdapter = g_VLanLocal._aAdaptInfo[pLanInfo->_iAdaptInfo]._hAdapter;
    }

    if (pNicInfoDst || fBroadcast)
    {
        VlWriteFrame(pb, cb, iLanInfo, fBroadcast ? CPROCINFOMAX : pNicInfoDst->_iProcInfo);

        if (fBroadcast)
        {
            VlWakeLan(pLanInfo);
        }
        else if (pNicInfoDst)
        {
            VlSetEvent(pNicInfoDst->_iProcInfo);
        }
    }

    fResult = TRUE;

ret:

    VlMutexUnlock();

    if (fResult && hAdapter)
    {
        NTSTATUS Status;
        
        // Write this frame to the adapter

        Status = VlSend(hAdapter, cb, pb, NULL);

        if (!NT_SUCCESS(Status))
        {
            TraceSz1("VLanXmit: VlSend failed (NTSTATUS %x)", Status);
        }
    }

    return(fResult);
}

// ---------------------------------------------------------------------------------------
// VLanDriver
// ---------------------------------------------------------------------------------------

BOOL WINAPI VLanDriver()
{
    HANDLE hDummyNet;
    NTSTATUS Status;

    Status = VlCreateVNet(0, 0, &hDummyNet);

    if (NT_SUCCESS(Status))
    {
        CloseHandle(hDummyNet);
    }

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND ||
        Status == STATUS_OBJECT_PATH_NOT_FOUND)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

// ---------------------------------------------------------------------------------------
// VlDbgTrace
// ---------------------------------------------------------------------------------------

void __cdecl VlDbgTrace(const char * pszFmt, ...)
{
    char ach[256];
    char * pchBuf = ach;
    int cchBuf = sizeof(ach);
    char * psz = (char *)pszFmt;
    va_list va;

    memset(ach, 0, sizeof(ach));

    if (*psz == '+')
        ++psz;
    else 
    {
        if (*psz == '\n')
        {
            *pchBuf++ = *psz++;
            cchBuf -= 1;
        }

        _snprintf(pchBuf, cchBuf - 3, "[VLAN.%03X] ", GetCurrentThreadId());
    }

    va_start(va, pszFmt);
    int cch = strlen(pchBuf);
    _vsnprintf(&pchBuf[cch], cchBuf - cch - 2, psz, va);
    va_end(va);

    cch = strlen(pchBuf);

    if (cch > 0 && *pszFmt && pszFmt[strlen(pszFmt) - 1] == '+')
        pchBuf[cch - 1] = 0;
    else
        strcpy(pchBuf + cch, "\n");

    DbgPrint("%s", ach);
}

// ---------------------------------------------------------------------------------------
// Trace Utilities
// ---------------------------------------------------------------------------------------

char * CVLanAddr::Str() const
{
    STATIC_BUFFER(CVLanAddr, 32, 18);
    _snprintf(pch, cch, "%02X-%02X-%02X-%02X-%02X-%02X", _ab[0], _ab[1], _ab[2], _ab[3], _ab[4], _ab[5]);
    return(pch);
}

// ---------------------------------------------------------------------------------------
// Assert support
// ---------------------------------------------------------------------------------------

struct MBOT { char * psz; int id; };

DWORD WINAPI VlDbgAssertPopOnThreadFn(MBOT * pmbot)
{
    pmbot->id = MessageBoxExA(NULL, pmbot->psz, "Assert",
                              MB_SYSTEMMODAL|MB_SETFOREGROUND|MB_OKCANCEL|MB_ICONWARNING|MB_DEFBUTTON2,
                              0);
    return(0);
}

int VlDbgAssertPop(const char * pszExpr, const char * pszFile, int iLine, const char * pszMsg)
{
    char ach[256];

    if (pszMsg)
        _snprintf(ach, sizeof(ach)-1, "%s\n%s\n%s (%d)", pszExpr, pszMsg, pszFile, iLine);
    else
        _snprintf(ach, sizeof(ach)-1, "%s\n%s (%d)", pszExpr, pszFile, iLine);
    ach[sizeof(ach)-1] = 0;

    MBOT  mbot = { ach, 0 };
    DWORD dwThread;
    HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)VlDbgAssertPopOnThreadFn,
                                  &mbot, 0, &dwThread);
    if (!hThread)
        VlDbgAssertPopOnThreadFn(&mbot);
    else
    {
        WaitForSingleObject(hThread, INFINITE);
        CloseHandle(hThread);
    }

    return(mbot.id == IDCANCEL);
}

char * __cdecl VlDbgAssertFmt(char const * pszFmt, ...)
{
    #define ASSERT_ENTRY_SIZE   512
    #define ASSERT_ENTRY_COUNT  8
    static char s_achAssert[ASSERT_ENTRY_SIZE * ASSERT_ENTRY_COUNT];
    static LONG s_lAssert = 0;
    char * pchBuf = &s_achAssert[(InterlockedIncrement(&s_lAssert) % ASSERT_ENTRY_COUNT) * ASSERT_ENTRY_SIZE];
    pchBuf[0] = 0;
    va_list va;
    va_start(va, pszFmt);
    _vsnprintf(pchBuf, ASSERT_ENTRY_SIZE - 1, pszFmt, va);
    va_end(va);
    pchBuf[ASSERT_ENTRY_SIZE - 1] = 0;
    return(pchBuf);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\util\vlan\sys\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

$(BASEDIR)\private\lib\i386\$(TARGETNAME).sys: $(O)\$(TARGETNAME).sys
    copy /y $** $@

$(BASEDIR)\private\lib\i386\netvlan.inf : netvlan.inf
    copy /y $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\util\vlan\sys\vladapt.cpp ===
// ---------------------------------------------------------------------------------------
// vladapt.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "vlp.h"

// ---------------------------------------------------------------------------------------
// Trace Tags
// ---------------------------------------------------------------------------------------

ExternTag(VlInit);

DefineTag(VlAdapter,        TAG_ENABLE);        // Trace misc adapter calls
DefineTag(VlEaReg,          TAG_DISABLE);       // Trace CEaReg
DefineTag(VlWarn,           TAG_ENABLE);        // Trace warnings
DefineTag(VlRecv,           TAG_DISABLE);       // Trace receive path
DefineTag(VlArp,            TAG_DISABLE);       // Trace ARP recvs
DefineTag(VlDhcp,           TAG_DISABLE);       // Trace DHCP recvs
DefineTag(VlDhcpDiscard,    TAG_DISABLE);       // Trace non-DHCP broadcasts (discarded)


// ---------------------------------------------------------------------------------------
// Forward declarations
// ---------------------------------------------------------------------------------------

void VlConfigAdapterTable(PSTR pszConfig);
void VlAddAdapterTable(CAdapter * pAdapt);
void VlRemoveAdapterTable(CAdapter * pAdapt);
void VlTermAdapterTable();


// ---------------------------------------------------------------------------------------
// CNdisRequest
// ---------------------------------------------------------------------------------------

struct CNdisRequest
{
    NDIS_REQUEST    _req;                       // The request we're sending to NDIS

    // result of the request
    PDWORD          _pBytesNeeded;
    PDWORD          _pBytesReadOrWritten;
    
};


// ---------------------------------------------------------------------------------------
// VlanBindAdapter - called once for each active adapter
// ---------------------------------------------------------------------------------------
void
VlanBindAdapter(
    PNDIS_STATUS pStatus,
    NDIS_HANDLE BindContext,
    PNDIS_STRING DeviceName,
    PVOID SystemSpecific1,
    PVOID SystemSpecific2
    )
{
    CAdapter * pAdapt = NULL;

    NDIS_STRING FriendlyName = {0, 0, NULL};

    NdisQueryAdapterInstanceName(
        &FriendlyName,
        BindContext
        );

    TraceSz3(VlInit,
        "Opening adapter \"%ws\"\n"
        "    %ws\n"
        "    %ws",
        FriendlyName.Buffer,
        DeviceName->Buffer,
        ((PNDIS_STRING)SystemSpecific1)->Buffer
        );

    //
    // allocate adapter structure
    //

    pAdapt = new CAdapter;
    if (!pAdapt)
    {
        TraceSz(VlInit, "Failed to allocate memory for an adapter");
        
        *pStatus = NDIS_STATUS_RESOURCES;
        goto fatal;
    }

    pAdapt->_pAdapterName   = FriendlyName.Buffer;
    FriendlyName.Buffer     = NULL;             // pAdapt now owns the buffer
    
    pAdapt->_dwState        = ADAPT_STATE_INIT;
    pAdapt->_powerState     = NetDeviceStateD0;
    pAdapt->_cRefs          = 1;

    pAdapt->_hLowerBinding  = NULL;
    
    pAdapt->_ea.SetZero();
    pAdapt->_dwMacOptions   = 0;
    pAdapt->_dwTdiRecvFlags = 0;

    pAdapt->_bRequestActive = FALSE;
    
    NdisInitializeEvent(&pAdapt->_evtInitTerm);

    InitializeListHead(&pAdapt->_lhEaReg);
    KeInitializeSpinLock(&pAdapt->_lockEaReg);
    pAdapt->_cEaReg = 0;

    //
    // open the lower miniport
    //

    NDIS_STATUS Sts;
    
    UINT MediumIndex;
    NDIS_MEDIUM Medium = NdisMedium802_3; // Ethernet
     
    NdisOpenAdapter(
        pStatus,                    // NDIS status code
        &Sts,                       // Adapter error code
        &pAdapt->_hLowerBinding,    // NdisBindingHandle
        &MediumIndex,               // SelectedMediumIndex
        &Medium,                    // MediumArray
        1,                          // MediumArraySize
        g_hNdisProtocol,            // NdisProtocolHandle
        pAdapt,                     // ProtocolBindingContext
        DeviceName,                 // AdapterName
        0,                          // OpenOptions
        NULL                        // AddressingInformation
        );
    
    if(*pStatus == NDIS_STATUS_PENDING)
    {
        //
        // PtOpenAdapterComplete will signal this event
        // when NdisOpenAdapter is done.
        //
        
        NdisWaitEvent(&pAdapt->_evtInitTerm, 0);
        NdisResetEvent(&pAdapt->_evtInitTerm);
        
        *pStatus = pAdapt->_statusInitTerm;
    }

    if (*pStatus != NDIS_STATUS_SUCCESS)
    {
        NdisFreeMemory(pAdapt->_pAdapterName, 0, 0);
        pAdapt->_pAdapterName = NULL;
        pAdapt->_dwState      = ADAPT_STATE_CLEANUP;
        VlanReleaseAdapter(pAdapt);
        
        TraceSz1(VlInit, "NdisOpenAdapter failed %x", *pStatus);
        goto fatal;
    }
    
    //
    // get EA from lower miniport
    //

    *pStatus = pAdapt->MakeSynchronousNdisRequest(NdisRequestQueryInformation,
                                                  OID_802_3_CURRENT_ADDRESS,
                                                  &pAdapt->_ea,
                                                  sizeof(CEnetAddr));

    if (*pStatus != NDIS_STATUS_SUCCESS)
    {
        TraceSz1(VlInit, "NdisRequest (EA) failed %x", *pStatus);
        goto fatal;
    }

    TraceSz2(VlInit, "    Read EA (%s) for adapter %p", pAdapt->_ea.Str(), pAdapt);
    
    //
    // get MAC options from lower miniport
    //

    *pStatus = pAdapt->MakeSynchronousNdisRequest(NdisRequestQueryInformation,
                                                  OID_GEN_MAC_OPTIONS,
                                                  &pAdapt->_dwMacOptions,
                                                  sizeof(DWORD));

    if (*pStatus != NDIS_STATUS_SUCCESS)
    {
        TraceSz1(VlInit, "NdisRequest (MAC_OPTIONS) failed %x", *pStatus);
        goto fatal;
    }

    if (pAdapt->_dwMacOptions & NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA)
    {
        pAdapt->_dwTdiRecvFlags = TDI_RECEIVE_COPY_LOOKAHEAD;
    }

    //
    // Done!
    //

    pAdapt->_dwState = ADAPT_STATE_READY;
    VlAddAdapterTable(pAdapt);
    
    Assert(*pStatus == NDIS_STATUS_SUCCESS);
    
    return;

fatal:

    // clean up anything we've allocated

    if (FriendlyName.Buffer)
    {
        NdisFreeMemory(FriendlyName.Buffer, 0, 0);
    }

    // don't free pAdapt, as Ndis still has a reference until PtUnbindProtocol.
    
}


// ---------------------------------------------------------------------------------------
// VlanOpenAdapterComplete
//
// Just signals the event so VlanBindAdapter can resume.
// ---------------------------------------------------------------------------------------
void        
VlanOpenAdapterComplete(
    NDIS_HANDLE ProtocolBindingContext, 
    NDIS_STATUS Status, 
    NDIS_STATUS OpenErrorStatus
    )
{
    CAdapter * pAdapt = (CAdapter *)ProtocolBindingContext;

    pAdapt->_statusInitTerm = Status;
    NdisSetEvent(&pAdapt->_evtInitTerm);
}


// ---------------------------------------------------------------------------------------
// VlanUnbindAdapter
// ---------------------------------------------------------------------------------------
void        
VlanUnbindAdapter(
    PNDIS_STATUS pStatus,
    NDIS_HANDLE ProtocolBindingContext,
    NDIS_HANDLE UnbindContext
    )
{
    CAdapter * pAdapt = (CAdapter *)ProtocolBindingContext;
    
    pAdapt->_dwState = ADAPT_STATE_CLEANUP;

    // clean up adapter name
    if (pAdapt->_pAdapterName)
    {
        NdisFreeMemory(pAdapt->_pAdapterName, 0, 0);
        pAdapt->_pAdapterName = NULL;
    }

    // close lower miniport

    if (pAdapt->_hLowerBinding)
    {
        NdisCloseAdapter(pStatus, pAdapt->_hLowerBinding);

        if(*pStatus == NDIS_STATUS_PENDING)
        {
            //
            // VlanCloseAdapterComplete will signal this event
            // when NdisCloseAdapter is done.
            //
            
            NdisWaitEvent(&pAdapt->_evtInitTerm, 0);
            NdisResetEvent(&pAdapt->_evtInitTerm);
            
            *pStatus = pAdapt->_statusInitTerm;
        }

        TraceSz3(VlInit, "VlanUnbindAdapter closed binding handle %p for adapter %p with status %x",
                 pAdapt->_hLowerBinding, pAdapt, *pStatus);

        pAdapt->_hLowerBinding = NULL;
    }

    VlRemoveAdapterTable(pAdapt);
    
}


// ---------------------------------------------------------------------------------------
// VlanCloseAdapterComplete
//
// Just signals the event so VlanUnbindAdapter can resume.
// ---------------------------------------------------------------------------------------
void        
VlanCloseAdapterComplete(
    NDIS_HANDLE ProtocolBindingContext, 
    NDIS_STATUS Status
    )
{
    CAdapter * pAdapt = (CAdapter *)ProtocolBindingContext;

    pAdapt->_statusInitTerm = Status;
    NdisSetEvent(&pAdapt->_evtInitTerm);
}

// ---------------------------------------------------------------------------------------
// VlanRequestComplete
//
// A call to NdisRequest completes by calling this function.
// ---------------------------------------------------------------------------------------
void        
VlanRequestComplete(
    NDIS_HANDLE ProtocolBindingContext, 
    PNDIS_REQUEST pNdisRequest, 
    NDIS_STATUS Status
    )
{
    CAdapter * pAdapt = (CAdapter *)ProtocolBindingContext;
    CNdisRequest * pReq = CONTAINING_RECORD(pNdisRequest, CNdisRequest, _req);

    // Wake up the caller.
    pAdapt->_statusInitTerm = Status;
    NdisSetEvent(&pAdapt->_evtInitTerm);

    VlMemFree(pReq);
}

// ---------------------------------------------------------------------------------------
// VlanResetComplete
//
// If we ever issued a reset, which we do not, Ndis would call this function on
// the completion of that reset.
// ---------------------------------------------------------------------------------------
void        
VlanResetComplete(
    NDIS_HANDLE ProtocolBindingContext, 
    NDIS_STATUS Status
    )
{
    AssertSz(FALSE, "Unexpected call to PtResetComplete!");
}

// ---------------------------------------------------------------------------------------
// VlanStatus
//
// This call tells me that the NIC is going down temporarily. We ignore this call.
// ---------------------------------------------------------------------------------------
void        
VlanStatus(
    NDIS_HANDLE ProtocolBindingContext, 
    NDIS_STATUS GeneralStatus, 
    PVOID StatusBuffer, 
    UINT StatusBufferSize
    )
{
}

// ---------------------------------------------------------------------------------------
// VlanStatusComplete
//
// This tells me that the NIC is back online. We ignore this call.
// ---------------------------------------------------------------------------------------
void        
VlanStatusComplete(
    NDIS_HANDLE ProtocolBindingContext
    )
{
}

// ---------------------------------------------------------------------------------------
// VlanPNPHandler
//
// Ndis calls this function to pass us plug-and-play events. We ignore all but two.
// First are power events, for which NDIS requires support. We're hoping to ignore
// those as well since we don't expect the adapters in the SG to ever be powered down.
// Second are global reconfiguration events that could screw up our protocol bindings.
// ---------------------------------------------------------------------------------------
NDIS_STATUS 
VlanPNPHandler(
    NDIS_HANDLE ProtocolBindingContext, 
    PNET_PNP_EVENT pNetPnPEvent
    )
{
    CAdapter *  pAdapt = (CAdapter *) ProtocolBindingContext;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    TraceSz2(VlAdapter, "VlanPNPHandler pAdapt %p, NetEvent 0x%x",
             pAdapt, pNetPnPEvent->NetEvent);

    switch(pNetPnPEvent->NetEvent)
    {
     case NetEventSetPower:
        pAdapt->_powerState = *(PNET_DEVICE_POWER_STATE)pNetPnPEvent->Buffer;
        break;

     case NetEventReconfigure :
        if(pAdapt == NULL)
        {
            // This was a global reconfiguration event.
            // Make sure our protocol is bound to underlying miniports and get out.
            NdisReEnumerateProtocolBindings(g_hNdisProtocol);
        }
        break;

    case NetEventQueryPower:
    case NetEventQueryRemoveDevice:
    case NetEventCancelRemoveDevice:
    case NetEventBindList:
    case NetEventPnPCapabilities:
        break;

    default:
        Status = NDIS_STATUS_NOT_SUPPORTED;
        break;

    }

    return Status;
}



void
VlReleaseEaReg(CEaReg * per)
{
    LONG lRefs = InterlockedDecrement(&per->_lRefs);
    Assert (lRefs >= 0);

    if (lRefs == 0)
    {
        KeSetEvent(&per->_evtShutdown, IO_NETWORK_INCREMENT, FALSE);
    }
}


BOOL      
CAdapter::AddTransport(
    CEnetAddr * pea, 
    CVirtualNet * pVirtualNet
    )
{
    CEaReg * pReg  = new CEaReg;
    KIRQL oldIrql;
    DWORD cEaReg;

    if (!pReg)
    {
        return FALSE;
    }

    pReg->_ea = *pea;
    pReg->_pVirtualNet = pVirtualNet;

    pReg->_lRefs = 1;
    KeInitializeEvent(&pReg->_evtShutdown, NotificationEvent, FALSE);

    KeAcquireSpinLock(&_lockEaReg, &oldIrql);

    InsertHeadList(&_lhEaReg, &pReg->_le);

    cEaReg = ++_cEaReg;

    KeReleaseSpinLock(&_lockEaReg, oldIrql);

    TraceSz2(VlAdapter, "AddTransport %p added %s.", this, pea->Str());
    TraceSz2(VlAdapter, "AddTransport %p has %d registered addresses.", this, cEaReg);

    if (cEaReg == 1)
    {
        // there's now at least one virtual adapter. Enable
        // promiscuous mode

        SetPromiscuousMode();
    }
    
    return TRUE;

}

void            
CAdapter::RemoveTransport(
    CEnetAddr * pea,
    CVirtualNet * pVirtualNet
    )
{
    PLIST_ENTRY pEntry;
    CEaReg * pReg = NULL;
    KIRQL oldIrql;

    DWORD cEaReg;
    
    KeAcquireSpinLock(&_lockEaReg, &oldIrql);

    cEaReg = _cEaReg;

    for (pEntry = _lhEaReg.Flink; pEntry != &_lhEaReg; pEntry = pEntry->Flink)
    {
        pReg = CONTAINING_RECORD(pEntry, CEaReg, _le);

        if (pReg->_pVirtualNet == pVirtualNet && pReg->_ea.IsEqual(*pea))
        {
            VlReleaseEaReg(pReg);
            
            // that's the one.
            RemoveEntryList(pEntry);
            pEntry->Flink = pEntry->Blink = NULL;

            cEaReg = --_cEaReg;
            
            break;
        }
        else
        {
            pReg = NULL;
        }
    }

    KeReleaseSpinLock(&_lockEaReg, oldIrql);

    TraceSz2(VlAdapter, "RemoveTransport %p has %d registered addresses.", this, cEaReg);

    if (pReg)
    {
        // wait for the refcount to drop to zero.
        KeWaitForSingleObject(
            &pReg->_evtShutdown,
            UserRequest,
            KernelMode,
            TRUE,
            NULL
            );
                            
        delete pReg;

        if (cEaReg == 0)
        {
            // there are no virtual adapters. switch off
            // promiscuous mode

            UnsetPromiscuousMode();
        }
    }

}

void            
CAdapter::RemoveAllTransport(
    CVirtualNet * pVirtualNet
    )
{
    PLIST_ENTRY pEntry;
    CEaReg * pReg;
    KIRQL oldIrql;

    DWORD cEaReg;

    while (TRUE)
    {
        pReg = NULL;

        KeAcquireSpinLock(&_lockEaReg, &oldIrql);

        cEaReg = _cEaReg;

        for (pEntry = _lhEaReg.Flink; pEntry != &_lhEaReg; pEntry = pEntry->Flink)
        {
            pReg = CONTAINING_RECORD(pEntry, CEaReg, _le);

            if (pReg->_pVirtualNet == pVirtualNet)
            {
                VlReleaseEaReg(pReg);
                
                // that's the one.
                RemoveEntryList(pEntry);
                pEntry->Flink = pEntry->Blink = NULL;

                cEaReg = --_cEaReg;
                
                break;
            }
            else
            {
                pReg = NULL;
            }
        }

        KeReleaseSpinLock(&_lockEaReg, oldIrql);

        TraceSz2(VlAdapter, "RemoveAllTransports %p has %d registered addresses.", this, cEaReg);

        if (pReg)
        {
            // wait for the refcount to drop to zero.
            KeWaitForSingleObject(
                &pReg->_evtShutdown,
                UserRequest,
                KernelMode,
                TRUE,
                NULL
                );
                                
            delete pReg;

            if (cEaReg == 0)
            {
                // there are no virtual adapters. switch off
                // promiscuous mode

                UnsetPromiscuousMode();
            }
        }
        else
        {
            break;
        }
    }
}


CEaReg *        
CAdapter::FindTransportForEa(
    CEnetAddr * pea
    )
{
    PLIST_ENTRY pEntry;
    KIRQL oldIrql;
    CEaReg * perMatch = NULL;
    
    KeAcquireSpinLock(&_lockEaReg, &oldIrql);

    for (pEntry = _lhEaReg.Flink; pEntry != &_lhEaReg; pEntry = pEntry->Flink)
    {
        CEaReg * per = CONTAINING_RECORD(pEntry, CEaReg, _le);

        if (per->_ea.IsEqual(*pea) || per->_ea.IsBroadcast())
        {
            // that's the one.
            Assert(per->_lRefs > 0);
            InterlockedIncrement(&per->_lRefs);
            
            perMatch = per;
            break;
        }
    }

    KeReleaseSpinLock(&_lockEaReg, oldIrql);

    TraceSz2(VlEaReg, "FindTransportForEa(ea = %s) returning %p",
             pea->Str(), perMatch);

    return perMatch;

}

void     
CAdapter::RecvPacket(
    CPacket * ppkt
    )
{
    TraceSz2(VlRecv, "CAdapter::RecvPacket processing packet %p, adapter %p",
             ppkt, ppkt->_pAdapt);

    //
    // Now see if we should pass the packet to a VNet adapter.
    //

    // The pb/cb variables scan down the buffer as headers are validated.  They always
    // specify the amount of the original data is remaining to be processed.

    BYTE *  pb = ppkt->_pb;
    UINT    cb = ppkt->_cb;

    // Process the Ethernet header

    CEnetHdr * pEnetHdr = ppkt->_pEnetHdr = (CEnetHdr *)pb;

    if (cb < sizeof(CEnetHdr))
    {
        TraceSz3(VlRecv, "%s: Frame (%d bytes) is smaller than CEnetHdr (%d bytes)",
                 ppkt->Str(), cb, sizeof(CEnetHdr));

        goto complete;
    }

    USHORT usType = pEnetHdr->_wType;

    if (NTOHS(usType) <= ENET_DATA_MAXSIZE)
    {
        CIeeeHdr * pIeeeHdr = (CIeeeHdr *)pEnetHdr;
        
        if (cb < sizeof(CIeeeHdr))
        {
            TraceSz3(VlRecv, "%s: Frame (%d bytes) is smaller than CIeeeHdr (%d bytes)",
                     ppkt->Str(), cb, sizeof(CIeeeHdr));
            goto complete;
        }

        if (!pIeeeHdr->IsEnetFrame())
        {
            TraceSz1(VlRecv, "%s: Frame has unrecognized ethernet header", ppkt->Str());
            goto complete;
        }

        // Update the frame type from the IEEE header

        usType = pIeeeHdr->_wTypeIeee;

        // Skip over the difference between the IEEE header and the normal ethernet header

        pb += sizeof(CIeeeHdr);
        cb -= sizeof(CIeeeHdr);
    }
    else
    {
        pb += sizeof(CEnetHdr);
        cb -= sizeof(CEnetHdr);
    }

    if (usType == ENET_TYPE_ARP)
    {
        // always accept ARP packets

        if (Tag(VlArp))
        {
            CArpMsg * pArpMsg = (CArpMsg *) pb;

            if (!ppkt->_pEnetHdr->_eaDst.IsBroadcast())
            {
                TraceSz1(VlArp, "\nARPARPARP Indicating a unicast ARP packet %s ARPARPARP\n", ppkt->Str());
            }

            TraceSz6(VlArp, "%s: [ARP %s %x %s %x %s]",
                     ppkt->Str(),
                     pArpMsg->_wOp == ARP_OP_REQUEST ? "Request" :
                     pArpMsg->_wOp == ARP_OP_REPLY ? "Reply" : "???",
                     pArpMsg->_ipaSender, pArpMsg->_eaSender.Str(),
                     pArpMsg->_ipaTarget, pArpMsg->_eaTarget.Str());
        }
        
        IndicateVnetPacket(ppkt);
        return;
    }

    if (!ppkt->_pEnetHdr->_eaDst.IsBroadcast())
    {
        // always accept unicast packets
        IndicateVnetPacket(ppkt);
        return;
    }

    if (usType == ENET_TYPE_XBOX)
    {
        // always accept Xbox ethertype broadcasts
        IndicateVnetPacket(ppkt);
        return;
    }        

    // We have a non-ARP broadcast packet. To keep vlan apps from getting
    // flooded, only accept DHCP responses. (UDP/IP on port 68).

    if (usType != ENET_TYPE_IP)
    {
        goto complete;
    }

    // process the IP header
    
    if (cb < sizeof(CIpHdr))
    {
        TraceSz1(VlDhcpDiscard, "not enough bytes for IP header %s", ppkt->Str());
        goto complete;
    }

    CIpHdr * pIpHdr = (CIpHdr *)pb;
    UINT cbIpHdrLen = (pIpHdr->_bVerHdr & 0x0F) << 2;

    if (pIpHdr->_bProtocol != IPPROTOCOL_UDP)
    {
        TraceSz2(VlDhcpDiscard, "Protocol %d is not UDP %s", pIpHdr->_bProtocol, ppkt->Str());
        goto complete;
    }

    pb += cbIpHdrLen;
    cb -= cbIpHdrLen;

    // process UDP header

    if (cb < sizeof(CUdpHdr))
    {
        TraceSz1(VlDhcpDiscard, "not enough bytes for UDP header %s", ppkt->Str());
        goto complete;
    }

    CUdpHdr * pUdpHdr = (CUdpHdr *) pb;

    if (pUdpHdr->_ipportDst != DHCP_CLIENT_PORT && pUdpHdr->_ipportDst != DHCP_SERVER_PORT)
    {
        TraceSz2(VlDhcpDiscard, "Port %d is not for DHCP %s", pUdpHdr->_ipportDst, ppkt->Str());
        goto complete;
    }

    // We have a winner. Send to vnet
    TraceSz1(VlDhcp, "Indicating a DHCP packet %s", ppkt->Str());
    
    IndicateVnetPacket(ppkt);
    return;

complete:

    ppkt->Complete();
    
}

void            
CAdapter::IndicateVnetPacket(CPacket * ppkt)
{
    CEaReg * per;
    
    if (ppkt->_pEnetHdr->_eaDst.IsBroadcast())
    {
        // Send broadcast packets to the first interface in the list.
        // User mode will take care of broadcasting the packet
        // to everyone else.
                
        KIRQL oldIrql;
        
        KeAcquireSpinLock(&_lockEaReg, &oldIrql);

        if (_cEaReg > 0)
        {
            Assert(!IsListEmpty(&_lhEaReg));
            
            per = CONTAINING_RECORD(_lhEaReg.Flink, CEaReg, _le);
            InterlockedIncrement(&per->_lRefs);            
        }
        else
        {
            per = NULL;
        }

        KeReleaseSpinLock(&_lockEaReg, oldIrql);

    }
    else
    {
        per = FindTransportForEa(&ppkt->_pEnetHdr->_eaDst);
    }

    if (per)
    {
        per->_pVirtualNet->Xmit(ppkt);
        VlReleaseEaReg(per);
    }
    else
    {
        ppkt->Complete();
    }

}


void            
CAdapter::SetPromiscuousMode()
{
    DWORD       dwFilter;
    NDIS_STATUS Status;
    
    TraceSz1(VlAdapter, "switch on promiscuous mode for adapter %p", this);

    dwFilter =   NDIS_PACKET_TYPE_PROMISCUOUS;

    // set the new packet filter

    Status = MakeSynchronousNdisRequest(NdisRequestSetInformation,
                                        OID_GEN_CURRENT_PACKET_FILTER, 
                                        &dwFilter, 
                                        sizeof(dwFilter));

    if (Status != NDIS_STATUS_SUCCESS)
    {
        TraceSz1(VlInit, "SetPromiscuousMode set (GEN_CURRENT_PACKET_FILTER) failed %x", Status);
    }

    TraceSz2(VlAdapter, "Adapter %p filter switched to %x", this, dwFilter);


}

void            
CAdapter::UnsetPromiscuousMode()
{
    DWORD       dwFilter = 0;
    NDIS_STATUS Status;
    
    TraceSz1(VlAdapter, "switch off promiscuous mode for adapter %p", this);

    Status = MakeSynchronousNdisRequest(NdisRequestSetInformation,
                                        OID_GEN_CURRENT_PACKET_FILTER, 
                                        &dwFilter, 
                                        sizeof(dwFilter));

    if (Status != NDIS_STATUS_SUCCESS)
    {
        TraceSz1(VlInit, "NdisRequest (GEN_CURRENT_PACKET_FILTER) failed %x", Status);
    }

    TraceSz2(VlAdapter, "adapter %p filter switched to %x",
             this, dwFilter);


}

BOOL            
CAdapter::MakeNdisRequest(
    NDIS_REQUEST_TYPE RequestType,
    NDIS_OID Oid, 
    PVOID InformationBuffer, 
    ULONG InformationBufferLength
    )
{
    NDIS_STATUS Status;
    CNdisRequest * pReq;

    if (_dwState == ADAPT_STATE_CLEANUP)
    {
        return FALSE;
    }

    pReq = (CNdisRequest *) VlMemAllocZ(sizeof(CNdisRequest), PTAG_CNdisRequest);

    if (!pReq)
    {
        return FALSE;
    }

    pReq->_req.RequestType = RequestType;
    pReq->_req.DATA.QUERY_INFORMATION.Oid = Oid;
    pReq->_req.DATA.QUERY_INFORMATION.InformationBuffer = InformationBuffer;
    pReq->_req.DATA.QUERY_INFORMATION.InformationBufferLength = InformationBufferLength;
    
    NdisRequest(
        &Status,
        _hLowerBinding,
        &pReq->_req
        );
    
    if(Status != NDIS_STATUS_PENDING)
    {
        VlanRequestComplete(
            (NDIS_HANDLE) this,
            &pReq->_req,
            Status
            );
    }

    return TRUE;
}


NDIS_STATUS
CAdapter::MakeSynchronousNdisRequest(
    NDIS_REQUEST_TYPE RequestType,
    NDIS_OID Oid, 
    PVOID InformationBuffer, 
    ULONG InformationBufferLength
    )
{
    BOOL fRet;
    NDIS_STATUS Status;

    fRet = MakeNdisRequest(RequestType,
                           Oid,
                           InformationBuffer,
                           InformationBufferLength);

    if (fRet)
    {
        //
        // PtRequestComplete will signal this event
        // when NdisRequest is done.
        //
        
        NdisWaitEvent(&_evtInitTerm, 0);
        NdisResetEvent(&_evtInitTerm);
        
        Status = _statusInitTerm;
    }
    else
    {
        Status = NDIS_STATUS_RESOURCES;
    }

    return Status;
    
}


void VlConfigAdapterTableFromFile()
{
    NTSTATUS          Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK   IoStatusBlock;
    UNICODE_STRING    ObjectName;

    HANDLE            hConfig   = NULL;
    PSTR              pszConfig = NULL;

    RtlInitUnicodeString(&ObjectName, L"\\??\\C:\\vladapters.txt");

    InitializeObjectAttributes(&ObjectAttributes,       // InitializedAttributes
                               &ObjectName,             // ObjectName
                               OBJ_KERNEL_HANDLE,       // Attributes
                               NULL,                    // RootDirectory
                               NULL);                   // Security Descriptor

    Status = ZwCreateFile(&hConfig,                     // FileHandle
                          GENERIC_READ | SYNCHRONIZE,   // DesiredAccess
                          &ObjectAttributes,            // ObjectAttributes
                          &IoStatusBlock,               // IoStatusBlock
                          NULL,                         // AllocationSize
                          0,                            // FileAttributes
                          FILE_SHARE_READ,              // ShareAccess
                          FILE_OPEN,                    // CreateDisposition
                          FILE_SYNCHRONOUS_IO_ALERT,    // CreateOptions
                          NULL,                         // EaBuffer
                          0);                           // EaLength
                 
                 
    if (!NT_SUCCESS(Status))
    {
        TraceSz1(VlInit, "Unable to open config file, error %x", Status);
        goto fatal;
    }

    FILE_STANDARD_INFORMATION FileInfo;

    Status = ZwQueryInformationFile(hConfig,
                                    &IoStatusBlock,
                                    &FileInfo,
                                    sizeof(FILE_STANDARD_INFORMATION),
                                    FileStandardInformation);
                                    
    if (!NT_SUCCESS(Status))
    {
        TraceSz1(VlInit, "Unable to query config file size, error %x", Status);
        goto fatal;
    }

    pszConfig = (PSTR) VlMemAlloc(FileInfo.EndOfFile.LowPart + 1, PTAG_CONFIG);
    if (!pszConfig)
    {
        TraceSz(VlInit, "Unable to allocate memory for config data");
        goto fatal;
    }

    Status = ZwReadFile(hConfig,                    // FileHandle
                        NULL,                       // Event
                        NULL,                       // ApcRoutine
                        NULL,                       // ApcContext
                        &IoStatusBlock,             // IoStatusBlock
                        pszConfig,                  // Buffer
                        FileInfo.EndOfFile.LowPart, // Length
                        NULL,                       // ByteOffset (PLARGE_INTEGER)
                        NULL);                      // Key

    if (!NT_SUCCESS(Status))
    {
        TraceSz1(VlInit, "Unable to read config file size, error %x", Status);
        goto fatal;
    }

    pszConfig[FileInfo.EndOfFile.LowPart] = '\0';
                        
    VlConfigAdapterTable(pszConfig);

    VlMemFree(pszConfig);    
    ZwClose(hConfig);
    return;

fatal:
    
    if (hConfig)
        ZwClose(hConfig);

    VlMemFree(pszConfig);    
    VlConfigAdapterTable(NULL);
}

ULONG g_cAdapters;
CAdapter * g_apAdapters[MAX_NDIS_ADAPTERS];

PWSTR g_pConfigString;
PWSTR g_apAdapterNames[MAX_NDIS_ADAPTERS];

CAdapter * VlanLookupAdapterTable(ULONG i)
{
    CAdapter * pAdapt = g_apAdapters[i];

    if (pAdapt)
    {
        LONG cRefs = InterlockedIncrement(&pAdapt->_cRefs);
        Assert(cRefs > 1);
    }
    
    return pAdapt;
}

void
VlanReleaseAdapter(CAdapter * pAdapter)
{
    LONG cRefs = InterlockedDecrement(&pAdapter->_cRefs);
    Assert (cRefs >= 0);

    if (cRefs == 0)
    {
        TraceSz1(VlInit, "Adapter %p deleted", pAdapter);
        Assert(IsListEmpty(&pAdapter->_lhEaReg));
        Assert(pAdapter->_cEaReg == 0);
        Assert(pAdapter->_dwState == ADAPT_STATE_CLEANUP);

        delete pAdapter;
    }
}

void VlConfigAdapterTable(PSTR pszConfig)
{
    Assert(!g_pConfigString);

    if (!pszConfig)
        return;
    
    g_pConfigString = (PWSTR)VlMemAllocZ((strlen(pszConfig) + 1) * sizeof(WCHAR), PTAG_CONFIG);

    if (!g_pConfigString)
        return;

    ULONG i = 1;
    WCHAR * pwch = g_pConfigString;

    g_apAdapterNames[0] = g_pConfigString;

    while (*pszConfig && i < MAX_NDIS_ADAPTERS)
    {
        *pwch = (WCHAR) *pszConfig;

        if (*pszConfig == '\r' && *(pszConfig + 1) == '\n')
        {
            *pwch = L'\0';
            g_apAdapterNames[i++] = pwch + 1;
            pszConfig++;
        }
        else if (*pszConfig == '\n')
        {
            *pwch = L'\0';
            g_apAdapterNames[i++] = pwch + 1;
        }
        else
        {
            *pwch = (WCHAR) *pszConfig;
        }

        pszConfig++;
        pwch++;
    }

    for ( ; i < MAX_NDIS_ADAPTERS; i++)
    {
        g_apAdapterNames[i] = pwch;
    }

    if (Tag(VlInit))
    {
        for (i = 0; i < MAX_NDIS_ADAPTERS; i++)
        {
            TraceSz2(VlInit, "%2d: %ws", i, g_apAdapterNames[i]);
        }
    }

}

void VlAddAdapterTable(CAdapter * pAdapt)
{
    ULONG i;
    
    if (++g_cAdapters == 1)
    {
        // read configuration file to determine adapter numbers
        VlConfigAdapterTableFromFile();
    }

    if (g_pConfigString)
    {
        for (i = 0; i < MAX_NDIS_ADAPTERS; i++)
        {
            if (   g_apAdapters[i] == NULL
                && (wcscmp(pAdapt->_pAdapterName, g_apAdapterNames[i]) == 0))
            {
                g_apAdapters[i] = pAdapt;
                TraceSz3(VlInit, "Adapter %p (%ws) assigned slot %d", pAdapt, pAdapt->_pAdapterName, i);
            }
        }
    }
    else
    {
        // find a free slot
        
        for (i = 0; i < MAX_NDIS_ADAPTERS; i++)
        {
            if (!g_apAdapters[i])
            {
                g_apAdapters[i] = pAdapt;
                TraceSz3(VlInit, "Adapter %p (%ws) assigned slot %d", pAdapt, pAdapt->_pAdapterName, i);
                break;
            }
        }
    }
    
}

void VlRemoveAdapterTable(CAdapter * pAdapt)
{
    ULONG i;

    TraceSz1(VlInit, "Removing adapter %p", pAdapt);
    
    for (i = 0; i < MAX_NDIS_ADAPTERS; i++)
    {
        if (g_apAdapters[i] == pAdapt)
        {
            // deref this adapter in VlTermAdapterTable to avoid races.
            pAdapt = NULL;
        }
    }

    if (pAdapt)
    {
        VlanReleaseAdapter(pAdapt);
    }

    if (--g_cAdapters == 0)
    {
        VlTermAdapterTable();
    }
}


void VlTermAdapterTable() 
{
    ULONG i;
    ULONG j;

    for (i = 0; i < MAX_NDIS_ADAPTERS; i++)
    {
        CAdapter * pAdapt = g_apAdapters[i];

        if (pAdapt)
        {
            TraceSz2(VlInit, "Adapter %p, slot %d, table reference removed", pAdapt, i);
            VlanReleaseAdapter(pAdapt);
            
            for (j = i; j < MAX_NDIS_ADAPTERS; j++)
            {
                if (pAdapt == g_apAdapters[j])
                {
                    g_apAdapters[j] = NULL;
                }
            }
        }
    }

    VlMemFree(g_pConfigString);
    g_pConfigString = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\util\vlan\lib\vlanio.cpp ===
// ---------------------------------------------------------------------------------------
// vlanio.cpp
//
// Interface between VLAN.SYS and VLAN.LIB
// ---------------------------------------------------------------------------------------

#include "vl.h"

// ---------------------------------------------------------------------------------------
// I/O macros
// ---------------------------------------------------------------------------------------

#define OVERLAPPED_TO_IO_STATUS( pOverlapped )                  \
    ((PIO_STATUS_BLOCK)&(pOverlapped)->Internal)

#define SET_STATUS_OVERLAPPED_TO_IO_STATUS( pOverlapped, ntstatus ) \
    do { \
        (((PIO_STATUS_BLOCK)&(pOverlapped)->Internal)->Pointer = (PVOID)(ntstatus)); \
        ASSERT( ntstatus == OVERLAPPED_TO_IO_STATUS(pOverlapped)->Status ); \
    } while (0)

// ---------------------------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------------------------

#define EA_REAL_BUFFER_LENGTH   (sizeof(VLAN_OPEN_PACKET) + VLAN_OPEN_PACKET_NAME_LENGTH + 1 + \
                                 FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) )

#define EA_BUFFER_LENGTH        (sizeof(VLAN_OPEN_PACKET) + VLAN_OPEN_PACKET_NAME_LENGTH + 1 + \
                                 sizeof(FILE_FULL_EA_INFORMATION) )

// ---------------------------------------------------------------------------------------
// Forward declarations
// ---------------------------------------------------------------------------------------

NTSTATUS
VlDeviceControl(
    HANDLE hVNet, 
    LPOVERLAPPED lpo, 
    ULONG ctl, 
    PVOID pbIn, 
    ULONG cbIn, 
    PVOID pbOut, 
    ULONG cbOut,
    PULONG pcbTransferred OPTIONAL
    );

BOOLEAN
VlStartDriver();

// ---------------------------------------------------------------------------------------
// API
// ---------------------------------------------------------------------------------------

NTSTATUS
VlCreateVNet(
    IN DWORD dwAdapterNumber,
    IN DWORD dwOptions,
    OUT PHANDLE phVNet
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    
    UNICODE_STRING deviceName;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;

    ULONG createOptions = 0;

    BYTE EaBuffer[EA_BUFFER_LENGTH];
    VLAN_OPEN_PACKET * pOpenPacket;
    PFILE_FULL_EA_INFORMATION pEaInfo;
    
    if (phVNet == NULL)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Make sure the driver is started
    //

    if (!VlStartDriver())
    {
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    //
    // Build the object attributes.
    //
    
    RtlInitUnicodeString( &deviceName, VLAN_DEVICE_NAME );

    InitializeObjectAttributes(
       &objectAttributes,                      // ObjectAttributes
       &deviceName,                            // ObjectName
       OBJ_CASE_INSENSITIVE,                   // Attributes
       NULL,                                   // RootDirectory
       NULL                                    // SecurityDescriptor
       );

    //
    // Build the EA info
    //

    pEaInfo= (PFILE_FULL_EA_INFORMATION)EaBuffer;
    pEaInfo->NextEntryOffset = 0;
    pEaInfo->Flags = 0;
    pEaInfo->EaNameLength = VLAN_OPEN_PACKET_NAME_LENGTH;
    pEaInfo->EaValueLength = sizeof(VLAN_OPEN_PACKET);

    RtlCopyMemory(
        pEaInfo->EaName,
        VLAN_OPEN_PACKET_NAME,
        VLAN_OPEN_PACKET_NAME_LENGTH + 1
        );

    pOpenPacket = (VLAN_OPEN_PACKET *)
                    (pEaInfo->EaName + pEaInfo->EaNameLength + 1);

    //
    // Build the open packet.
    //

    pOpenPacket->_dwVersion = VLAN_VERSION;
    pOpenPacket->_dwAdapterNumber = dwAdapterNumber;

    if ((dwOptions & VLAN_OPTION_OVERLAPPED) == 0)
    {
        createOptions |= FILE_SYNCHRONOUS_IO_NONALERT;
    }

    //
    // Open the device.
    //

    status = NtCreateFile(
                phVNet,                         // FileHandle
                GENERIC_READ |                  // DesiredAccess
                    GENERIC_WRITE |
                    SYNCHRONIZE,
                &objectAttributes,              // ObjectAttributes
                &ioStatusBlock,                 // IoStatusBlock
                NULL,                           // AllocationSize
                0,                              // FileAttributes
                FILE_SHARE_READ |               // ShareAccess
                    FILE_SHARE_WRITE,
                FILE_OPEN,                      // CreateDisposition
                createOptions,                  // CreateOptions
                EaBuffer,                       // EaBuffer
                EA_REAL_BUFFER_LENGTH           // EaLength
                );


    if (!NT_SUCCESS(status))
    {
        *phVNet = NULL;
    }    

    return status;

}

NTSTATUS
VlAddVAdapter(
    IN HANDLE hVNet,
    IN const BYTE* pEnetAddr
    )
{
    VLAN_VADAPTER_INFO VAdapterInfo;
    RtlCopyMemory(VAdapterInfo._abEnetAddr, pEnetAddr, sizeof(VAdapterInfo._abEnetAddr));
    
    return VlDeviceControl(
                hVNet,                      // FileHandle
                NULL,                       // Overlapped
                IOCTL_VLAN_ADD_VADAPTER,     // ioctl
                &VAdapterInfo,              // pbIn
                sizeof(VAdapterInfo),       // cbIn
                NULL,                       // pbOut
                0,                          // cbOut
                NULL                        // pcbTransferred
                );
}


NTSTATUS
VlRemoveVAdapter(
    IN HANDLE hVNet,
    IN const BYTE* pEnetAddr
    )
{
    VLAN_VADAPTER_INFO VAdapterInfo;
    RtlCopyMemory(VAdapterInfo._abEnetAddr, pEnetAddr, sizeof(VAdapterInfo._abEnetAddr));
    
    return VlDeviceControl(
                hVNet,                      // FileHandle
                NULL,                       // Overlapped
                IOCTL_VLAN_REMOVE_VADAPTER,  // ioctl
                &VAdapterInfo,              // pbIn
                sizeof(VAdapterInfo),       // cbIn
                NULL,                       // pbOut
                0,                          // cbOut
                NULL                        // pcbTransferred
                );

}

NTSTATUS
VlReceive(
    IN HANDLE hVNet,
    IN DWORD cb,
    OUT PBYTE pb,
    IN LPOVERLAPPED lpo OPTIONAL,
    OUT PDWORD pcbReceived OPTIONAL
    )
{
    return VlDeviceControl(
                hVNet,                      // FileHandle
                lpo,                        // Overlapped
                IOCTL_VLAN_RECEIVE,          // ioctl
                NULL,                       // pbIn
                0,                          // cbIn
                pb,                         // pbOut
                cb,                         // cbOut
                pcbReceived                 // pcbTransferred
                );
    
}

NTSTATUS
VlSend(
    IN HANDLE hVNet,
    IN DWORD cb,
    IN const BYTE* pb,
    IN LPOVERLAPPED lpo
    )
{
    return VlDeviceControl(
                hVNet,                      // FileHandle
                lpo,                        // Overlapped
                IOCTL_VLAN_SEND,             // ioctl
                NULL,                       // pbIn
                0,                          // cbIn
                (void*)pb,                  // pbOut
                cb,                         // cbOut
                NULL                        // pcbTransferred
                );
    
}

BOOLEAN
VlStartDriver()
{
    SC_HANDLE schScm   = NULL;
    SC_HANDLE schVlan  = NULL;
    BOOLEAN   fStarted = FALSE;

    schScm = OpenSCManagerW(NULL, NULL, SC_MANAGER_CONNECT);

    if (schScm == NULL)
        goto exit;

    schVlan = OpenServiceW(schScm, L"VLAN", SERVICE_START);

    if (schVlan == NULL)
        goto exit;

    if (StartService(schVlan, 0, NULL))
    {
        Sleep(2000);
        fStarted = TRUE;
    }
    else if (ERROR_SERVICE_ALREADY_RUNNING == GetLastError())
    {
        fStarted = TRUE;
    }
        

exit:
    if (schScm != NULL)
        CloseServiceHandle(schScm);

    if (schVlan != NULL)
        CloseServiceHandle(schVlan);
    
    return fStarted;
}


NTSTATUS 
VlDeviceControl(
    HANDLE hVNet, 
    LPOVERLAPPED lpo, 
    ULONG ctl, 
    PVOID pbIn, 
    ULONG cbIn, 
    PVOID pbOut, 
    ULONG cbOut,
    PULONG pcbTransferred OPTIONAL
    )
{
    NTSTATUS Status;

    if (lpo)
    {
        SET_STATUS_OVERLAPPED_TO_IO_STATUS(lpo, STATUS_PENDING);
    
        Status = NtDeviceIoControlFile(
                        hVNet,                          // FileHandle
                        lpo->hEvent,                    // Event
                        NULL,                           // ApcRoutine
                        (ULONG_PTR)lpo->hEvent & 1      // ApcContext
                            ? NULL : lpo,
                        OVERLAPPED_TO_IO_STATUS(lpo),   // IoStatusBlock
                        ctl,                            // IoControlCode
                        pbIn,                           // InputBuffer
                        cbIn,                           // InputBufferLength
                        pbOut,                          // OutputBuffer
                        cbOut                           // OutputBufferLength
                        );
    }
    else
    {
        IO_STATUS_BLOCK ioStatusBlock;

        ioStatusBlock.Status = STATUS_PENDING;
        ioStatusBlock.Information = 0;

        Status = NtDeviceIoControlFile(
                        hVNet,                          // FileHandle
                        NULL,                           // Event
                        NULL,                           // ApcRoutine
                        NULL,                           // ApcContext
                        &ioStatusBlock,                 // IoStatusBlock
                        ctl,                            // IoControlCode
                        pbIn,                           // InputBuffer
                        cbIn,                           // InputBufferLength
                        pbOut,                          // OutputBuffer
                        cbOut                           // OutputBufferLength
                        );

        if (Status == STATUS_PENDING)
        {
            while (ioStatusBlock.Status == STATUS_PENDING)
            {
                Sleep(0);
            }
        }

        if (pcbTransferred && Status == STATUS_SUCCESS)
        {
            *pcbTransferred = (ULONG)ioStatusBlock.Information;
        }
     }
    
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\util\vlan\sys\vldebug.cpp ===
// ----------------------------------------------------------------------------
// vldebug.cpp
//
// Copyright (C) Microsoft Corporation
// ----------------------------------------------------------------------------

#include "vlp.h"

// ---------------------------------------------------------------------------------------
// Assert
// ---------------------------------------------------------------------------------------

#ifdef VL_FEATURE_ASSERT


char * __cdecl SgDbgAssertFmt(char const * pszFmt, ...)
{
    #define ASSERT_ENTRY_SIZE   512
    #define ASSERT_ENTRY_COUNT  8
    static char s_achAssert[ASSERT_ENTRY_SIZE * ASSERT_ENTRY_COUNT];
    static LONG s_lAssert = 0;
    char * pchBuf = &s_achAssert[(InterlockedIncrement(&s_lAssert) % ASSERT_ENTRY_COUNT) * ASSERT_ENTRY_SIZE];
    pchBuf[0] = 0;
    va_list va;
    va_start(va, pszFmt);
    _vsnprintf(pchBuf, ASSERT_ENTRY_SIZE - 1, pszFmt, va);
    va_end(va);
    pchBuf[ASSERT_ENTRY_SIZE - 1] = 0;
    return(pchBuf);
}

#endif



// ---------------------------------------------------------------------------------------
// VlDbgTrace
// ---------------------------------------------------------------------------------------

void __cdecl VlDbgTrace(const char * pszTag, const char * pszFmt, ...)
{
    char ach[256];
    char * pchBuf = ach;
    int cchBuf = sizeof(ach);
    char * psz = (char *)pszFmt;
    va_list va;

    memset(ach, 0, sizeof(ach));

    if (*psz == '+')
        ++psz;
    else 
    {
        if (*psz == '\n')
        {
            *pchBuf++ = *psz++;
            cchBuf -= 1;
        }

        _snprintf(pchBuf, cchBuf - 3, "[VLAN] %s: ", pszTag);
    }

    va_start(va, pszFmt);
    int cch = strlen(pchBuf);
    _vsnprintf(&pchBuf[cch], cchBuf - cch - 2, psz, va);
    va_end(va);

    cch = strlen(pchBuf);

    if (cch > 0 && *pszFmt && pszFmt[strlen(pszFmt) - 1] == '+')
        pchBuf[cch - 1] = 0;
    else
        strcpy(pchBuf + cch, "\n");

    DbgPrint("%s", ach);
}

// ---------------------------------------------------------------------------------------
// SgDbgVerifyList
// ---------------------------------------------------------------------------------------

const char * SgDbgVerifyList(LIST_ENTRY * ple, LIST_ENTRY * pleRequire)
{
    LIST_ENTRY * plePrev;
    LIST_ENTRY * pleThis;
    BOOL fFound = FALSE;
    UINT cEnt = 0;

    if (ple->Flink == NULL || ple->Blink == NULL)
        return("List Flink is NULL");
    else if (ple->Blink == NULL)
        return("List Blink is NULL");

    if (ple->Flink == ple || ple->Blink == ple)
    {
        if (ple->Flink != ple->Blink)
        {
            return("List head corrupt");
        }

        return((!pleRequire) ? NULL : "Required entry not found");
    }

    plePrev = ple;
    pleThis = ple->Flink;

    while (1)
    {
        if (pleThis == NULL)
        {
            return("List entry has an Flink that points to NULL");
        }

        if (plePrev != pleThis->Blink)
        {
            return("List entry has a Blink that doesn't point to previous entry");
            return(FALSE);
        }

        if (pleThis == ple)
            break;

        if (pleThis == pleRequire)
        {
            if (fFound)
            {
                return("List has required entry twice.  Cycle detected.");
            }

            fFound = TRUE;
        }

        plePrev = pleThis;
        pleThis = plePrev->Flink;

        if (++cEnt > 1000)
        {
            return("List has cycle");
        }
    }

    return((!pleRequire || fFound) ? NULL : "Required entry not found");
}

// ---------------------------------------------------------------------------------------
// Trace Utilities
// ---------------------------------------------------------------------------------------

char * SgHexStr(const void * pv, size_t cb)
{
    STATIC_BUFFER(HexStr, 32, 257);
    char * pchDst = pch;
    BYTE * pb = (BYTE *)pv;
    UINT   ui;

    if (cb > ((cch - 1) / 2))
        cb = ((cch - 1) / 2);

    for (; cb > 0; --cb, ++pb)
    {
        ui = (*pb) >> 4;
        *pchDst++ = ui < 10 ? '0' + ui : 'A' + (ui - 10);
        ui = (*pb) & 0x0F;
        *pchDst++ = ui < 10 ? '0' + ui : 'A' + (ui - 10);
    }

    *pchDst = 0;

    return(pch);
}

char * CEnetAddr::Str() const
{
    STATIC_BUFFER(CEnetAddrStr, 32, 18);
    _snprintf(pch, cch, "%02X-%02X-%02X-%02X-%02X-%02X", _ab[0], _ab[1], _ab[2], _ab[3], _ab[4], _ab[5]);
    return(pch);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\util\vlan\sys\vlp.h ===
// ---------------------------------------------------------------------------------------
// vlp.h
//
// XBox Virtual Lan Driver
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#ifndef __VLP_H_
#define __VLP_H_

// ---------------------------------------------------------------------------------------
// To Do List
//
// @@@ fix max frame size
// ---------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------
// Configuration
// ---------------------------------------------------------------------------------------

#if DBG
#define VL_FEATURE_ASSERT
#endif

#define VL_FEATURE_TRACE

#ifdef VL_FEATURE_ASSERT
#pragma message("  VL_FEATURE_ASSERT")
#endif

#ifdef VL_FEATURE_TRACE
#pragma message("  VL_FEATURE_TRACE")
#endif

// ---------------------------------------------------------------------------------------
// System Includes
// ---------------------------------------------------------------------------------------


extern "C"
{
    #define NDIS_WDM 1
    #include <ndis.h>
    #include <tdikrnl.h>
    #include <windef.h>
    #define _INC_WINDOWS
}


#include <stdio.h>
#include <stddef.h>
#include <stdarg.h>

#include <vlanio.h>


// ---------------------------------------------------------------------------------------
// Pool Tags
// ---------------------------------------------------------------------------------------

#define PTAG_CEaReg             NTOHL_('SfER')
#define PTAG_CNdisRequest       NTOHL_('SfNR')
#define PTAG_CVirtualAdapter    NTOHL_('SfVA')
#define PTAG_CVirtualNet        NTOHL_('SfVN')

// ---------------------------------------------------------------------------------------
// Assert
// ---------------------------------------------------------------------------------------

#define INLINE __forceinline

INLINE
void VlDbgBreak()
{
    _asm int 3;
}

#ifdef VL_FEATURE_ASSERT

    #define VlDbgAssert(expr,file,line,msg) \
            RtlAssert((PVOID)((msg)?(msg):(expr)),file,line,NULL)

    char * __cdecl SgDbgAssertFmt(char const * pszFmt, ...);
    const char * SgDbgVerifyList(LIST_ENTRY * ple, LIST_ENTRY * pleRequire);

    #define ASSERT_BEG(x)   do { if (!(x)) { char * __pch__ = SgDbgAssertFmt(
    #define ASSERT_END(x)   ); VlDbgAssert(#x,__FILE__,__LINE__,__pch__); } } while (0)

    #define Assert(x) \
            do { if (!(x)) { VlDbgAssert(#x,__FILE__,__LINE__,NULL); } } while (0)
    #define AssertSz(x,sz) \
            ASSERT_BEG(x) sz ASSERT_END(x)
    #define AssertSz1(x,sz,a1) \
            ASSERT_BEG(x) sz,a1 ASSERT_END(x)
    #define AssertSz2(x,sz,a1,a2) \
            ASSERT_BEG(x) sz,a1,a2 ASSERT_END(x)
    #define AssertSz3(x,sz,a1,a2,a3) \
            ASSERT_BEG(x) sz,a1,a2,a3 ASSERT_END(x)
    #define AssertSz4(x,sz,a1,a2,a3,a4) \
            ASSERT_BEG(x) sz,a1,a2,a3,a4 ASSERT_END(x)
    #define AssertSz5(x,sz,a1,a2,a3,a4,a5) \
            ASSERT_BEG(x) sz,a1,a2,a3,a4,a5 ASSERT_END(x)
    #define AssertSz6(x,sz,a1,a2,a3,a4,a5,a6) \
            ASSERT_BEG(x) sz,a1,a2,a3,a4,a5,a6 ASSERT_END(x)
    #define AssertSz7(x,sz,a1,a2,a3,a4,a5,a6,a7) \
            ASSERT_BEG(x) sz,a1,a2,a3,a4,a5,a6,a7 ASSERT_END(x)
    #define AssertSz8(x,sz,a1,a2,a3,a4,a5,a6,a7,a8) \
            ASSERT_BEG(x) sz,a1,a2,a3,a4,a5,a6,a7,a8 ASSERT_END(x)
    #define AssertSz9(x,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9) \
            ASSERT_BEG(x) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9 ASSERT_END(x)
    #define AssertList(ple) \
            do { const char * __psz__ = SgDbgVerifyList(ple,NULL); \
            if (__psz__) { VlDbgAssert("AssertList("#ple")",__FILE__,__LINE__,__psz__); } } while (0)
    #define AssertListEntry(ple,pleReq) \
            do { const char * __psz__ = SgDbgVerifyList(ple,pleReq); \
            if (__psz__) { VlDbgAssert("AssertListEntry("#ple","#pleReq")",__FILE__,__LINE__,__psz__); } } while (0)

#else

    #define Assert(x)
    #define AssertSz(x,sz)
    #define AssertSz1(x,sz,a1)
    #define AssertSz2(x,sz,a1,a2)
    #define AssertSz3(x,sz,a1,a2,a3)
    #define AssertSz4(x,sz,a1,a2,a3,a4)
    #define AssertSz5(x,sz,a1,a2,a3,a4,a5)
    #define AssertSz6(x,sz,a1,a2,a3,a4,a5,a6)
    #define AssertSz7(x,sz,a1,a2,a3,a4,a5,a6,a7)
    #define AssertSz8(x,sz,a1,a2,a3,a4,a5,a6,a7,a8)
    #define AssertSz9(x,sz, a1,a2,a3,a4,a5,a6,a7,a8,a9)
    #define AssertList(ple)
    #define AssertListEntry(ple,pleReq)

#endif

#undef  ASSERT
#define ASSERT(x)   Assert(x)

// ---------------------------------------------------------------------------------------
// Trace
// ---------------------------------------------------------------------------------------

#ifdef VL_FEATURE_TRACE

    void __cdecl VlDbgTrace(const char * szTag, const char * szFmt, ...);

    #define TAG_DISABLE     0
    #define TAG_ENABLE      1
    #define TAG_BREAK       2
    #define Tag(t)  t_##t
    
    #define DefineTag(t,i)  int Tag(t) = (i)
        
    #define ExternTag(t)    extern int Tag(t)
    #define TRACE_BEG(t)    do { if (Tag(t) > 0) { VlDbgTrace(#t,
    #define TRACE_END(t)    ); if (Tag(t) > 1) VlDbgBreak(); } } while (0)

    #define TraceSz(t,sz) \
            TRACE_BEG(t) sz TRACE_END(t)
    #define TraceSz1(t,sz,a1) \
            TRACE_BEG(t) sz,a1 TRACE_END(t)
    #define TraceSz2(t,sz,a1,a2) \
            TRACE_BEG(t) sz,a1,a2 TRACE_END(t)
    #define TraceSz3(t,sz,a1,a2,a3) \
            TRACE_BEG(t) sz,a1,a2,a3 TRACE_END(t)
    #define TraceSz4(t,sz,a1,a2,a3,a4) \
            TRACE_BEG(t) sz,a1,a2,a3,a4 TRACE_END(t)
    #define TraceSz5(t,sz,a1,a2,a3,a4,a5) \
            TRACE_BEG(t) sz,a1,a2,a3,a4,a5 TRACE_END(t)
    #define TraceSz6(t,sz,a1,a2,a3,a4,a5,a6) \
            TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6 TRACE_END(t)
    #define TraceSz7(t,sz,a1,a2,a3,a4,a5,a6,a7) \
            TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7 TRACE_END(t)
    #define TraceSz8(t,sz,a1,a2,a3,a4,a5,a6,a7,a8) \
            TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8 TRACE_END(t)
    #define TraceSz9(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9) \
            TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9 TRACE_END(t)
    #define TraceSz10(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10) \
            TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10 TRACE_END(t)
    #define TraceSz11(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) \
            TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11 TRACE_END(t)
    #define TraceSz12(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12) \
            TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12 TRACE_END(t)
    #define TraceSz13(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13) \
            TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13 TRACE_END(t)
    #define TraceSz14(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14) \
            TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14 TRACE_END(t)
    #define TraceSz15(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15) \
            TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15 TRACE_END(t)
    #define TraceSz16(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16) \
            TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16 TRACE_END(t)
#else

    #define Tag(t)  0

    #define DefineTag(t,i)
    #define ExternTag(t)
    #define TraceSz(t,sz)
    #define TraceSz1(t,sz,a1)
    #define TraceSz2(t,sz,a1,a2)
    #define TraceSz3(t,sz,a1,a2,a3)
    #define TraceSz4(t,sz,a1,a2,a3,a4)
    #define TraceSz5(t,sz,a1,a2,a3,a4,a5)
    #define TraceSz6(t,sz,a1,a2,a3,a4,a5,a6)
    #define TraceSz7(t,sz,a1,a2,a3,a4,a5,a6,a7)
    #define TraceSz8(t,sz,a1,a2,a3,a4,a5,a6,a7,a8)
    #define TraceSz9(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9)
    #define TraceSz10(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
    #define TraceSz11(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)
    #define TraceSz12(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12)
    #define TraceSz13(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13)
    #define TraceSz14(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14)
    #define TraceSz15(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15)
    #define TraceSz16(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16)

#endif

// ---------------------------------------------------------------------------------------
// Forward declarations
// ---------------------------------------------------------------------------------------

class   CPacket;
struct  CAdapter;
struct  CVirtualNet;

// ---------------------------------------------------------------------------------------
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
// ---------------------------------------------------------------------------------------

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))
#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))
#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}
#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}
#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }
#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }
#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

// ---------------------------------------------------------------------------------------
// Utilities
// -----------------------------------------------------------------------------------

#define dimensionof(x)          (sizeof((x))/sizeof(*(x)))
#define BIT(n)                  (1u << (n))
#define ROUNDUP4(count)         (((count) + 3) & ~3)
#define ROUNDUP8(count)         (((count) + 7) & ~7)
#define IsListNull(_ple)        ((_ple)->Flink == NULL)

#define HTONL_(ul) \
    ((ULONG)((((ul) >> 24) & 0x000000FFL) | (((ul) >>  8) & 0x0000FF00L) | \
             (((ul) <<  8) & 0x00FF0000L) | (((ul) << 24))))

#define NTOHL_(ul) HTONL_(ul)

#define HTONS_(us) \
    ((USHORT)((((us) >> 8) & 0x00FF) | (((us) << 8) & 0xFF00)))

#define NTOHS_(us) HTONS_(us)

INLINE ULONG  HTONL(ULONG  ul) { return(HTONL_(ul)); }
INLINE ULONG  NTOHL(ULONG  ul) { return(NTOHL_(ul)); }
INLINE USHORT HTONS(USHORT us) { return(HTONS_(us)); }
INLINE USHORT NTOHS(USHORT us) { return(NTOHS_(us)); }

#define STATIC_BUFFER(_name,_nbuf,_chbuf) \
    static char s_chStaticBuffer##_name[(_nbuf)*(_chbuf)]; \
    static LONG s_lStaticBuffer##_name = 0; \
    char * pch = &s_chStaticBuffer##_name[(InterlockedIncrement(&s_lStaticBuffer##_name) % (_nbuf)) * (_chbuf)]; \
    UINT cch = (_chbuf);

#define DECLARE_NEW_DELETE(class) \
   INLINE void * operator new(size_t cb) { return(VlMemAlloc(cb, PTAG_##class)); } \
   INLINE void operator delete(void * pv) { VlMemFree(pv); }

#define DECLARE_NEW_DELETE_ZERO(class) \
   INLINE void * operator new(size_t cb) { return(VlMemAllocZ(cb, PTAG_##class)); } \
   INLINE void operator delete(void * pv) { VlMemFree(pv); }

char *          SgHexStr(const void * pv, size_t cb);


// ---------------------------------------------------------------------------------------
// CEnetAddr
// ---------------------------------------------------------------------------------------

#include <pshpack1.h>

struct CEnetAddr
{
    BYTE _ab[6];

    INLINE BOOL IsEqual(const CEnetAddr & ea) const { return(memcmp(_ab, ea._ab, sizeof(_ab)) == 0); }
    INLINE BOOL IsEqual(const BYTE * pb) const { return(memcmp(_ab, pb, sizeof(_ab)) == 0); }
    INLINE void SetBroadcast()                { *(DWORD *)&_ab[0] = 0xFFFFFFFF; *(WORD *)&_ab[4] = 0xFFFF; }
    INLINE void SetZero()                     { *(DWORD *)&_ab[0] = 0x00000000; *(WORD *)&_ab[4] = 0x0000; }
    INLINE BOOL IsBroadcast() const           { return(*(DWORD *)&_ab[0] == 0xFFFFFFFF && *(WORD *)&_ab[4] == 0xFFFF); }
    INLINE BOOL IsMulticast() const           { return((_ab[0] & 1) != 0); }
    char * Str() const;
};

#include <poppack.h>


// ---------------------------------------------------------------------------------------
// CPacketQueue
// ---------------------------------------------------------------------------------------

class CPacketQueue
{

public:

    void                InsertHead(CPacket * ppkt);
    void                InsertTail(CPacket * ppkt);
    void                InsertHead(CPacketQueue * ppq);
    CPacket *           RemoveHead();
    BOOL                Dequeue(CPacket * ppktDequeue);
    void                Complete();
    UINT                Count();

    INLINE void         Init()      { _ppktHead = NULL; _ppktTail = NULL; }
    INLINE BOOL         IsEmpty()   { return(_ppktHead == NULL); }
    INLINE CPacket *    GetHead()   { return(_ppktHead); }

private:

    CPacket *           _ppktHead;
    CPacket *           _ppktTail;

};


// ---------------------------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------------------------

#define PTAG_Sg                 NTOHL_('Sg__')
#define PTAG_CAdapter           NTOHL_('SgAD')
#define PTAG_ExternalDataBuffer NTOHL_('SgED')
#define PTAG_CPacketInfo        NTOHL_('SgPI')
#define PTAG_RSA                NTOHL_('SgRS')
#define PTAG_CONFIG             NTOHL_('SgCF')

#define MAX_NDIS_ADAPTERS       10
#define MAX_QUEUED_PACKETS      500
#define MAX_TIME_QUEUED         (5 * 10000000)



#define ENET_DATA_MAXSIZE       1500
#define ENET_TYPE_IP            HTONS_(0x0800)
#define ENET_TYPE_ARP           HTONS_(0x0806)
#define ENET_TYPE_XBOX          HTONS_(0x886F)

#define IPPROTOCOL_UDP          17

#define MAXIPHDRLEN             (15*4)
#define DONT_FRAGMENT           BIT(14)
#define MORE_FRAGMENTS          BIT(13)
#define FRAGOFFSET_MASK         0x1FFF

#define DHCP_SERVER_PORT        HTONS(67)
#define DHCP_CLIENT_PORT        HTONS(68)


// Ethernet Headers ----------------------------------------------------------------------


#include <pshpack1.h>

struct CEnetHdr
{
    CEnetAddr       _eaDst;
    CEnetAddr       _eaSrc;
    WORD            _wType;
};

struct CIeeeHdr : public CEnetHdr
{
    BYTE            _bDsap;         // 0xAA
    BYTE            _bSsap;         // 0xAA
    BYTE            _bControl;      // 0x03
    BYTE            _bOrgCode[3];   // 0x00 0x00 0x00
    WORD            _wTypeIeee;

    INLINE BOOL IsEnetFrame()   { return(*(DWORD *)&_bDsap == 0x0003AAAA && *(WORD *)&_bOrgCode[1] == 0); }
    INLINE BOOL IsValid()       { return(NTOHS(_wType) > ENET_DATA_MAXSIZE || IsEnetFrame()); }
};

#include <poppack.h>

// IP Header in Network Byte Order -------------------------------------------------------

#include <pshpack1.h>

typedef DWORD CIpAddr;
typedef WORD CIpPort;

struct CIpHdr
{
    BYTE            _bVerHdr;       // Version & header length
    BYTE            _bTos;          // Type of service
    WORD            _wLen;          // Total length including IP header
    WORD            _wId;           // Identification
    WORD            _wFragOff;      // Flags and fragment offset
    BYTE            _bTtl;          // Time to live
    BYTE            _bProtocol;     // Protocol
    WORD            _wChecksum;     // Header checksum
    CIpAddr         _ipaSrc;        // Source address
    CIpAddr         _ipaDst;        // Destination address

    INLINE UINT     GetHdrLen()     { return((_bVerHdr & 0xF) << 2); }
};

#include <poppack.h>



// UDP Header in Network Byte Order ------------------------------------------------------

#include <pshpack1.h>

struct CUdpHdr
{
    CIpPort         _ipportSrc;     // Source port
    CIpPort         _ipportDst;     // Destination port
    WORD            _wLen;          // Datagram length including UDP header
    WORD            _wChecksum;     // Datagram checksum
};

#include <poppack.h>

// ---------------------------------------------------------------------------------------
// CArpMsg
// ---------------------------------------------------------------------------------------

#include <pshpack1.h>

#define ARP_OP_REQUEST      HTONS(1)    // opcodes
#define ARP_OP_REPLY        HTONS(2)

struct CArpMsg
{
    WORD            _wHrd;      // hardware address space
    WORD            _wPro;      // protocol address space (ENET_TYPE_IP)
    BYTE            _bHln;      // hardware address length (6)
    BYTE            _bPln;      // protocol address length (4)
    WORD            _wOp;       // opcode
    CEnetAddr       _eaSender;  // sender's hardware address
    CIpAddr         _ipaSender; // sender's protocol address
    CEnetAddr       _eaTarget;  // target's hardware address
    CIpAddr         _ipaTarget; // target's protocol address
};

#include <poppack.h>

#define CBARPMSG    (sizeof(CEnetHdr) + sizeof(CArpMsg))

// ---------------------------------------------------------------------------------------
// CPacket
// ---------------------------------------------------------------------------------------

typedef void (*PFNCOMPLETE)(class CPacket * ppkt);

class CPacket
{
    // Member Functions ------------------------------------------------------------------

public:

    INLINE CPacket *    GetNextPkt()                { return(_ppktNext); }

    void                Reset();
    void                Complete();
    void                CompletePush(PFNCOMPLETE pfn);
    char *              Str() const;

    // Data ------------------------------------------------------------------------------

public:

    CPacket *           _ppktNext;          // Next packet in packet queue
    
    CAdapter *          _pAdapt;            // adapter that received packet
    PIRP                _pSendIrp;          // for outgoing vadapter packets

    UINT                _cpfn;              // Number of completion functions pushed
    DWORD               _dwPktNum;          // Serial number of packet for tracing
    LARGE_INTEGER       _liTime;            // Time at which packet was received
    BYTE *              _pb;                // Scanning byte pointer during processing
    UINT                _cb;                // Scanning byte count during processing
    CEnetHdr *          _pEnetHdr;          // Pointer to CEnetHdr in the packet buffers
    PFNCOMPLETE         _apfn[9];           // Vector of completion functions

};

BOOL            SgPacketInit();
void            SgPacketTerm();
CPacket *       SgPacketAlloc();

// ---------------------------------------------------------------------------------------
// Memory
// ---------------------------------------------------------------------------------------

void *          VlMemAlloc(size_t size, ULONG tag);
void *          VlMemAllocZ(size_t size, ULONG tag);
void            VlMemFree(void * pv);


// ---------------------------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------------------------

#define MAX_PACKET_POOL_SIZE        0x0000FFFF
#define MIN_PACKET_POOL_SIZE        0x000000FF

// CODEWORK: what should this be relative to the packet pool?
#define MAX_BUFFER_POOL_SIZE        0x0000FFFF

#define ENET_FRAME_MAXSIZE          (ENET_DATA_MAXSIZE + sizeof(CEnetHdr))

// ---------------------------------------------------------------------------------------
// Forward declarations
// ---------------------------------------------------------------------------------------

struct CAdapter;

// incoming packets
INT         VlanReceivePacket(NDIS_HANDLE ProtocolBindingContext, PNDIS_PACKET Packet);
NDIS_STATUS VlanReceiveIndication(NDIS_HANDLE ProtocolBindingContext, NDIS_HANDLE MacReceiveContext, PVOID HeaderBuffer, UINT HeaderBufferSize, PVOID LookAheadBuffer, UINT LookaheadBufferSize, UINT PacketSize);
void        VlanReceiveComplete(NDIS_HANDLE ProtocolBindingContext);
void        VlanTransferDataComplete(NDIS_HANDLE ProtocolBindingContext, PNDIS_PACKET Packet, NDIS_STATUS Status, UINT BytesTransferred);

// outgoing packets
void        VlanSendComplete(NDIS_HANDLE ProtocolBindingContext, PNDIS_PACKET pnp, NDIS_STATUS  Status);

// init/term
void        VlanBindAdapter(PNDIS_STATUS Status, NDIS_HANDLE BindContext, PNDIS_STRING DeviceName, PVOID SystemSpecific1, PVOID SystemSpecific2);
void        VlanUnbindAdapter(PNDIS_STATUS Status, NDIS_HANDLE ProtocolBindingContext, NDIS_HANDLE UnbindContext);
void        VlanOpenAdapterComplete(NDIS_HANDLE ProtocolBindingContext, NDIS_STATUS Status, NDIS_STATUS OpenErrorStatus);
void        VlanCloseAdapterComplete(NDIS_HANDLE ProtocolBindingContext, NDIS_STATUS Status);

// set/query information
void        VlanRequestComplete(NDIS_HANDLE ProtocolBindingContext, PNDIS_REQUEST NdisRequest, NDIS_STATUS Status);

// adapter state changes
void        VlanResetComplete(NDIS_HANDLE ProtocolBindingContext, NDIS_STATUS Status);
void        VlanStatus(NDIS_HANDLE ProtocolBindingContext, NDIS_STATUS GeneralStatus, PVOID StatusBuffer, UINT StatusBufferSize);
void        VlanStatusComplete(NDIS_HANDLE ProtocolBindingContext);
NDIS_STATUS VlanPNPHandler(NDIS_HANDLE ProtocolBindingContext, PNET_PNP_EVENT pNetPnPEvent);

// driver and device entry points
void            DriverUnload(PDRIVER_OBJECT pDriverObject);
extern "C"
{
    NTSTATUS        DeviceCreate(PDEVICE_OBJECT pDeviceObject, PIRP pIrp);
    NTSTATUS        DeviceCleanup(PDEVICE_OBJECT pDeviceObject, PIRP pIrp);
    NTSTATUS        DeviceClose(PDEVICE_OBJECT pDeviceObject, PIRP pIrp);
    NTSTATUS        DeviceControl(PDEVICE_OBJECT pDeviceObject, PIRP pIrp);
}


// ---------------------------------------------------------------------------------------
// Utilities
// -----------------------------------------------------------------------------------

#define STRING_CONST(x)         {sizeof(x)-2, sizeof(x), x}

// ---------------------------------------------------------------------------------------
// CPacketInfo
// ---------------------------------------------------------------------------------------

struct CPacketInfo
{
    SINGLE_LIST_ENTRY   _sle;               // for lookaside list. MUST BE FIRST

    // recv information (allocated as needed)
    PNDIS_PACKET        _pnpRecv;           // received data descriptor
    PBYTE               _pbExternal;        // external data buffer

    // send information (preallocated)
    PNDIS_PACKET        _pnpXmit;           // sent data descriptor
    PNDIS_BUFFER        _pnbXmit;           // NDIS_BUFFER to describe a packet

//  CPacket             _pkt;               // the abstracted packet object is right
                                            // after the CPacketInfo
};

#define GET_PACKET_FROM_PKTINFO(ppi)        ((CPacket *)((ppi) + 1))
#define GET_PKTINFO_FROM_PACKET(ppkt)       (((CPacketInfo *)(ppkt)) - 1)

#define GET_PKTINFO_FROM_NDIS_PACKET(pnp)   *((CPacketInfo **)((pnp)->ProtocolReserved))
#define SET_NDIS_PACKET_CONTEXT(pnp, ppi)   (*((CPacketInfo **)((pnp)->ProtocolReserved)) = (ppi))

// ---------------------------------------------------------------------------------------
// Locks
// ---------------------------------------------------------------------------------------
class CSpinLock
{
public:
    CSpinLock()
        { KeInitializeSpinLock(&_lock); }
    
    VOID
    Acquire(KIRQL * oldIrql)
        { ASSERT(oldIrql); KeAcquireSpinLock(&_lock, oldIrql); }

    VOID
    Release(KIRQL oldIrql)
        { KeReleaseSpinLock(&_lock, oldIrql); }

    VOID
    AcquireAtDpc()
        { KeAcquireSpinLockAtDpcLevel(&_lock); }

    VOID
    ReleaseAtDpc()
        { KeReleaseSpinLockFromDpcLevel(&_lock); }

private:
    KSPIN_LOCK _lock;
};


// ---------------------------------------------------------------------------------------
// Driver and device objects
// ---------------------------------------------------------------------------------------

extern HANDLE                       g_hNdisProtocol;        // Protocol Driver Handle
extern PDRIVER_OBJECT               g_pDriverObject;

// ---------------------------------------------------------------------------------------
// CEaReg
// ---------------------------------------------------------------------------------------

struct CEaReg
{
    DECLARE_NEW_DELETE(CEaReg);
    
    LIST_ENTRY      _le;
    
    CEnetAddr       _ea;
    CVirtualNet *   _pVirtualNet;

    LONG            _lRefs;
    KEVENT          _evtShutdown;
};


// ---------------------------------------------------------------------------------------
// CAdapter
// ---------------------------------------------------------------------------------------


struct CAdapter
{
    DECLARE_NEW_DELETE(CAdapter);

    #define ADAPT_STATE_INIT    0
    #define ADAPT_STATE_READY   1
    #define ADAPT_STATE_CLEANUP 2

    PWSTR                   _pAdapterName;
    DWORD                   _dwState;           // See ADAPT_STATE_*
    NET_DEVICE_POWER_STATE  _powerState;        // PnP power state
    LONG                    _cRefs;             // Reference count

    NDIS_HANDLE             _hLowerBinding;     // BindingHandle for lower miniport

    NDIS_EVENT              _evtInitTerm;       // synchronizes init/term
    NDIS_STATUS             _statusInitTerm;    // init/term status

    CEnetAddr               _ea;                // our address
    DWORD                   _dwMacOptions;      // card options
    DWORD                   _dwTdiRecvFlags;    // ok to copy lookahead data directly?

    BOOL                    _bRequestActive;

    KSPIN_LOCK              _lockEaReg;         // synchronize ea list
    LIST_ENTRY              _lhEaReg;           // list of CEaReg
    DWORD                   _cEaReg;            // number of adapters

    BOOL                    AddTransport(CEnetAddr * pea, CVirtualNet * pVirtualNet);
    void                    RemoveTransport(CEnetAddr * pea, CVirtualNet * pVirtualNet);
    void                    RemoveAllTransport(CVirtualNet * pVirtualNet);
    CEaReg *                FindTransportForEa(CEnetAddr * pea);

    void                    RecvPacket(CPacket * ppkt);

    void                    IndicateVnetPacket(CPacket * ppkt);

    void                    NicXmit(CPacket * ppkt);
    static void             NicXmitComplete(CPacket * ppkt);

    void                    SetPromiscuousMode();
    void                    UnsetPromiscuousMode();

    BOOL                    MakeNdisRequest(
                                NDIS_REQUEST_TYPE RequestType,
                                NDIS_OID Oid, 
                                PVOID InformationBuffer, 
                                ULONG InformationBufferLength);

    NDIS_STATUS             MakeSynchronousNdisRequest(
                                NDIS_REQUEST_TYPE RequestType,
                                NDIS_OID Oid, 
                                PVOID InformationBuffer, 
                                ULONG InformationBufferLength);
        

};

// ---------------------------------------------------------------------------------------
// CIrpQueue
// ---------------------------------------------------------------------------------------

class CIrpQueue
{

public:

    BOOL                InsertTail(PIRP pIrp);
    PIRP                RemoveHead();
    void                CancelAll();

    INLINE void         Init(CSpinLock * pLock) { InitializeListHead(&_lh); _pLock = pLock; }
    INLINE BOOL         IsEmpty()               { return IsListEmpty(&_lh); }

private:

    static void         IrpCancelRoutine(PDEVICE_OBJECT pDevice, PIRP pIrp);

    LIST_ENTRY          _lh;
    CSpinLock *         _pLock;

};

// ---------------------------------------------------------------------------------------
// Adapter handle
// ---------------------------------------------------------------------------------------

#define Vl_VNET_CONTEXT        NTOHL_('VNET')
#define Vl_VNET_CONTEXT_X      NTOHL_('Xvnt')

struct CVirtualNet
{
    DECLARE_NEW_DELETE(CVirtualNet);
    
    CSpinLock       _lock;          // syncronizes the queues
    CPacketQueue    _pq;            // queued incoming packets
    CIrpQueue       _iq;            // queued IRPs

    CAdapter *      _pAdapter;      // to register new EAs & send packets

    void            Xmit(CPacket * ppkt);

};


// ---------------------------------------------------------------------------------------
// Macros
// ---------------------------------------------------------------------------------------

#define MARK_VALID_VNET( pFileObject )                                      \
    ( (pFileObject)->FsContext2 = (PVOID)Vl_VNET_CONTEXT )

#define MARK_INVALID_VNET( pFileObject )                                    \
    ( (pFileObject)->FsContext2 = (PVOID)Vl_VNET_CONTEXT_X )

#define GET_VNET( pFileObject )                                             \
    ((CVirtualNet *)((pFileObject)->FsContext))

#define GET_PP_VNET( pFileObject )                                          \
    ((CVirtualNet **)&((pFileObject)->FsContext))

#define IS_VNET( pFileObject )                                              \
    ( (pFileObject)->FsContext2 == (PVOID)Vl_VNET_CONTEXT )

#define IS_EX_VNET( pFileObject )                                           \
    ( (pFileObject)->FsContext2 == (PVOID)Vl_VNET_CONTEXT_X )

// ---------------------------------------------------------------------------------------
// Forward declarations
// ---------------------------------------------------------------------------------------

NTSTATUS        VlanReceiveIoctl(PIRP pIrp, CVirtualNet * pVnet);
NTSTATUS        VlanSendIoctl(PIRP pIrp, CVirtualNet * pVnet);
NTSTATUS        VlanAddVAdapterIoctl(PIRP pIrp, CVirtualNet * pVnet);
NTSTATUS        VlanRemoveVAdapterIoctl(PIRP pIrp, CVirtualNet * pVnet);

CAdapter *      VlanLookupAdapterTable(ULONG i);
void            VlanReleaseAdapter(CAdapter * pAdapter);

extern BOOL     g_fForceIndicationPath;
extern BOOL     g_fForceTransferDataPath;
extern BOOL     g_fForceCopyPacketPath;


// ---------------------------------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\util\vlan\sys\vlmain.cpp ===
// ---------------------------------------------------------------------------------------
// vlmain.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "vlp.h"

// ---------------------------------------------------------------------------------------
// Trace Tags
// ---------------------------------------------------------------------------------------

DefineTag(VlInit,                   TAG_ENABLE);        // Trace init/term
DefineTag(VlIoctl,                  TAG_DISABLE);       // Trace IOCTL calls
DefineTag(VlCreateClose,            TAG_ENABLE);        // Trace Create/Close/Cleanup calls

// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------

PDRIVER_OBJECT g_pDriverObject;
PDEVICE_OBJECT g_pDeviceObject;
NDIS_HANDLE    g_hNdisProtocol;

BOOL           g_fForceIndicationPath;
BOOL           g_fForceTransferDataPath;
BOOL           g_fForceCopyPacketPath;

// ---------------------------------------------------------------------------------------
// Driver entry points
// ---------------------------------------------------------------------------------------

EXTERN_C
NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObject,
                     PUNICODE_STRING pRegistryPath)
{
    NDIS_PROTOCOL_CHARACTERISTICS     protocolChar;
    NDIS40_PROTOCOL_CHARACTERISTICS * pprotocolChar40 = &protocolChar.Ndis40Chars;
    NDIS30_PROTOCOL_CHARACTERISTICS * pprotocolChar30 = &pprotocolChar40->Ndis30Chars;
    NTSTATUS                          status          = STATUS_SUCCESS;
    NDIS_STRING                       protoName       = NDIS_STRING_CONST("VLAN");
    UNICODE_STRING                    ntDeviceName;
    UNICODE_STRING                    win32DeviceName;
    BOOLEAN                           fSymbolicLink   = FALSE;
    PDEVICE_OBJECT                    deviceObject    = NULL;

    UNREFERENCED_PARAMETER(pRegistryPath);

    TraceSz(VlInit, "VLAN DriverEntry");

    g_pDriverObject = pDriverObject;

    if (!SgPacketInit())
    {
        status = NDIS_STATUS_FAILURE;
        goto exit;
    }

    //
    // Create our device object using which an application can
    // access NDIS devices.
    //
    RtlInitUnicodeString(&ntDeviceName, VLAN_DEVICE_NAME);

    status = IoCreateDevice (pDriverObject,
                             0,
                             &ntDeviceName,
                             FILE_DEVICE_NETWORK,
                             FILE_DEVICE_SECURE_OPEN,
                             FALSE,
                             &deviceObject);


    if (!NT_SUCCESS (status))
    {
        //
        // Either not enough memory to create a deviceobject or another
        // deviceobject with the same name exits. This could happen
        // if you install another instance of this device.
        //
        goto exit;
    }

    RtlInitUnicodeString(&win32DeviceName, VLAN_SYMBOLIC_NAME);

    status = IoCreateSymbolicLink(&win32DeviceName, &ntDeviceName);

    if (!NT_SUCCESS(status))
    {
        goto exit;
    }

    fSymbolicLink = TRUE;

    deviceObject->Flags |= DO_DIRECT_IO;
    g_pDeviceObject = deviceObject;

    //
    // Initialize the protocol characterstic structure
    //

    NdisZeroMemory(&protocolChar,sizeof(NDIS_PROTOCOL_CHARACTERISTICS));

    pprotocolChar30->MajorNdisVersion            = 5;
    pprotocolChar30->MinorNdisVersion            = 0;
    pprotocolChar30->Name                        = protoName;
    pprotocolChar30->OpenAdapterCompleteHandler  = VlanOpenAdapterComplete;
    pprotocolChar30->CloseAdapterCompleteHandler = VlanCloseAdapterComplete;
    pprotocolChar30->SendCompleteHandler         = VlanSendComplete;
    pprotocolChar30->TransferDataCompleteHandler = VlanTransferDataComplete;
    pprotocolChar30->ResetCompleteHandler        = VlanResetComplete;
    pprotocolChar30->RequestCompleteHandler      = VlanRequestComplete;
    pprotocolChar30->ReceiveHandler              = VlanReceiveIndication;
    pprotocolChar30->ReceiveCompleteHandler      = VlanReceiveComplete;
    pprotocolChar30->StatusHandler               = VlanStatus;
    pprotocolChar30->StatusCompleteHandler       = VlanStatusComplete;
    
    pprotocolChar40->BindAdapterHandler          = VlanBindAdapter;
    pprotocolChar40->UnbindAdapterHandler        = VlanUnbindAdapter;
    pprotocolChar40->UnloadHandler               = NULL;
    pprotocolChar40->ReceivePacketHandler        = VlanReceivePacket;
    pprotocolChar40->PnPEventHandler             = VlanPNPHandler;

    if (g_fForceIndicationPath)
        pprotocolChar40->ReceivePacketHandler = NULL;

    //
    // Register as a protocol driver
    //

    NdisRegisterProtocol(
        (PNDIS_STATUS)&status,
        &g_hNdisProtocol,
        &protocolChar,
        sizeof(NDIS_PROTOCOL_CHARACTERISTICS));

    if (status != NDIS_STATUS_SUCCESS)
    {
        TraceSz(VlInit, "Failed to register protocol with NDIS");
        status = STATUS_UNSUCCESSFUL;
        goto exit;
    }


    //
    // Now set only the dispatch points we would like to handle.
    //
    pDriverObject->MajorFunction[IRP_MJ_CREATE]         = DeviceCreate;
    pDriverObject->MajorFunction[IRP_MJ_CLOSE]          = DeviceClose;
    pDriverObject->MajorFunction[IRP_MJ_CLEANUP]        = DeviceCleanup;
    pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DeviceControl;
    pDriverObject->DriverUnload                         = DriverUnload;

    status = STATUS_SUCCESS;

exit:

    if (!NT_SUCCESS(status))
    {
        if (deviceObject)
        {
            IoDeleteDevice(deviceObject);
            g_pDeviceObject = NULL;
        }

        if (fSymbolicLink)
        {
            IoDeleteSymbolicLink(&win32DeviceName);
        }

    }

    TraceSz1(VlInit, "VLAN DriverEntry exit %x", status);
    
    return status;
}


// ---------------------------------------------------------------------------------------
// DriverUnload
// ---------------------------------------------------------------------------------------
void
DriverUnload(
    IN PDRIVER_OBJECT pDriverObject
    )
{
    NDIS_STATUS     Status;
    UNICODE_STRING  win32DeviceName;

    TraceSz(VlInit, "DriverUnload called");

    // clean up stuff allocated in DriverEntry

    //
    // First delete the Control deviceobject and the corresponding
    // symbolicLink
    //
    RtlInitUnicodeString(&win32DeviceName, VLAN_SYMBOLIC_NAME);
    IoDeleteSymbolicLink(&win32DeviceName);           

    if (g_pDeviceObject)
    {
        IoDeleteDevice(g_pDeviceObject);
        g_pDeviceObject = NULL;
    }
    

    SgPacketTerm();

    if (g_hNdisProtocol)
    {
        NdisDeregisterProtocol(&Status, g_hNdisProtocol);
        g_hNdisProtocol = NULL;
        Assert(Status == NDIS_STATUS_SUCCESS);
    }

    TraceSz(VlInit, "DriverUnload exit");
    
}


// ---------------------------------------------------------------------------------------
// DeviceCreate - control channel Create entry point
// ---------------------------------------------------------------------------------------
NTSTATUS        
DeviceCreate(
    PDEVICE_OBJECT pDeviceObject, 
    PIRP pIrp
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PFILE_FULL_EA_INFORMATION pEaBuffer;
    VLAN_OPEN_PACKET * pOpenPacket;
    STRING OpenPacketName;
    ULONG NextOffset;
    
    CVirtualNet * pVnet;
    PIO_STACK_LOCATION pIrpSp;

    pEaBuffer = (PFILE_FULL_EA_INFORMATION)(pIrp->AssociatedIrp.SystemBuffer);

    if (!pEaBuffer)
    {
        TraceSz(VlCreateClose, "DeviceCreate couldn't find EA block");
        
        Status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    RtlInitString(&OpenPacketName, VLAN_OPEN_PACKET_NAME);
    pOpenPacket = NULL;

    do
    {
        STRING EaName;

        EaName.MaximumLength = pEaBuffer->EaNameLength + 1;
        EaName.Length        = pEaBuffer->EaNameLength;
        EaName.Buffer        = pEaBuffer->EaName;

        if (RtlEqualMemory(OpenPacketName.Buffer, EaName.Buffer, EaName.Length))
        {
            // found a block with the right name

            if (pEaBuffer->EaValueLength < sizeof(VLAN_OPEN_PACKET))
            {
                // buffer too small
                Status = STATUS_ACCESS_VIOLATION;
                goto complete;
            }

            pOpenPacket = (VLAN_OPEN_PACKET *) ( pEaBuffer->EaName +
                                                 pEaBuffer->EaNameLength + 1);

            break;
        }

        //
        // Goto the chained EA
        //

        NextOffset = pEaBuffer->NextEntryOffset;

        pEaBuffer = (PFILE_FULL_EA_INFORMATION)
                        ((PUCHAR) pEaBuffer + NextOffset);
        
    } while (NextOffset != 0);

    if (!pOpenPacket)
    {
        TraceSz(VlCreateClose, "DeviceCreate couldn't find EA block with matching name");
        
        Status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    if (pOpenPacket->_dwVersion != VLAN_VERSION)
    {
        TraceSz2(VlCreateClose, "DeviceCreate version mismatch. Expected %d, received %d",
                 VLAN_VERSION, pOpenPacket->_dwVersion);

        Status = STATUS_REVISION_MISMATCH;
        goto complete;
    }

    if (pOpenPacket->_dwAdapterNumber >= MAX_NDIS_ADAPTERS)
    {
        TraceSz2(VlCreateClose, "DeviceCreate adapter %d out of range. Max is %d",
                 pOpenPacket->_dwAdapterNumber, MAX_NDIS_ADAPTERS);

        Status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    pVnet = new CVirtualNet;

    if (!pVnet)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto complete;
    }

    TraceSz2(VlCreateClose, "DeviceCreate opening a vnet %p on adapter %d",
             pVnet, pOpenPacket->_dwAdapterNumber);


    pVnet->_pq.Init();
    pVnet->_iq.Init(&pVnet->_lock);

    // figure out where to send packets out
    CAdapter * pAdapter = VlanLookupAdapterTable(pOpenPacket->_dwAdapterNumber);
    
    if (pAdapter && pAdapter->_dwState == ADAPT_STATE_READY)
    {
        // remember our adapter
        pVnet->_pAdapter = pAdapter;

    }
    else
    {
        if (pAdapter)
            VlanReleaseAdapter(pAdapter);

        delete pVnet;
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto complete;
    }

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    *GET_PP_VNET(pIrpSp->FileObject) = pVnet;

    MARK_VALID_VNET(pIrpSp->FileObject);

complete:
    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
    
    return Status;
}


// ---------------------------------------------------------------------------------------
// DeviceCleanup - control channel Close entry point
// ---------------------------------------------------------------------------------------
NTSTATUS        
DeviceCleanup(
    PDEVICE_OBJECT pDeviceObject, 
    PIRP pIrp
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION pIrpSp;
    KIRQL oldIrql;
    CVirtualNet * pVnet;

    pIrpSp = IoGetCurrentIrpStackLocation( pIrp );
    ASSERT( IS_VNET(pIrpSp->FileObject) );

    if (IS_VNET(pIrpSp->FileObject))
    {
        MARK_INVALID_VNET(pIrpSp->FileObject);
        pVnet = GET_VNET(pIrpSp->FileObject);

        TraceSz2(VlCreateClose, "DeviceCleanup cleaning a vnet %p on adapter %p",
                 pVnet, pVnet->_pAdapter);

        //
        // remove all vadapters the user forgot to clean up
        //

        pVnet->_pAdapter->RemoveAllTransport(pVnet);

        // clean up I/O

        CPacketQueue pq;
        
        pq.Init();

        pVnet->_lock.Acquire(&oldIrql);

        if (!pVnet->_pq.IsEmpty())
        {
            // move queued packets to private list so they can be completed
            // outside the spin lock.
            pq.InsertHead(&pVnet->_pq);
        }

        // complete queued IRPs
        pVnet->_iq.CancelAll();

        pVnet->_lock.Release(oldIrql);

        // complete queued packets
        pq.Complete();
        
    }
    else
    {
        Status = STATUS_INVALID_DEVICE_REQUEST;
    }

    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
    
    return Status;
}

// ---------------------------------------------------------------------------------------
// DeviceClose - control channel Close entry point
// ---------------------------------------------------------------------------------------
NTSTATUS        
DeviceClose(
    PDEVICE_OBJECT pDeviceObject, 
    PIRP pIrp
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION pIrpSp;
    CVirtualNet * pVnet;

    pIrpSp = IoGetCurrentIrpStackLocation( pIrp );
    ASSERT( IS_EX_VNET(pIrpSp->FileObject) );

    if (IS_EX_VNET(pIrpSp->FileObject))
    {
        pVnet = GET_VNET(pIrpSp->FileObject);

        VlanReleaseAdapter(pVnet->_pAdapter);
        delete pVnet;
    }
    else
    {
        Status = STATUS_INVALID_DEVICE_REQUEST;
    }

    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
    
    return Status;
}

// ---------------------------------------------------------------------------------------
// DeviceControl - control channel IOCTL entry point
// ---------------------------------------------------------------------------------------
NTSTATUS        
DeviceControl(
    PDEVICE_OBJECT pDeviceObject, 
    PIRP pIrp
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION pIrpSp;
    ULONG code;
    ULONG request;

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    code = pIrpSp->Parameters.DeviceIoControl.IoControlCode;
    request = _VLAN_REQUEST(code);

    if (!IS_VNET(pIrpSp->FileObject))
    {
        ASSERT(IS_EX_VNET(pIrpSp->FileObject));

        TraceSz1(VlIoctl, "DeviceControl invalid file object %p!", pIrpSp->FileObject);

        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto complete;
    }

    if (request >= VLAN_NUM_IOCTLS)
    {
        TraceSz1(VlIoctl, "DeviceControl invalid IOCTL code %d!", request);

        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto complete;
    }

    TraceSz2(VlIoctl, "DeviceControl IOCTL code %d irp %p", request, pIrp);

    switch (request)
    {
    case VLAN_RECEIVE:
        Status = VlanReceiveIoctl(pIrp, GET_VNET(pIrpSp->FileObject));
        break;

    case VLAN_SEND:
        Status = VlanSendIoctl(pIrp, GET_VNET(pIrpSp->FileObject));
        break;

    case VLAN_ADD_VADAPTER:
        Status = VlanAddVAdapterIoctl(pIrp, GET_VNET(pIrpSp->FileObject));
        break;

    case VLAN_REMOVE_VADAPTER:
        Status = VlanRemoveVAdapterIoctl(pIrp, GET_VNET(pIrpSp->FileObject));
        break;

    default:
        //
        // shouldn't be able to get here.
        //
        
        ASSERT(!"Valid, but unhandled request IOCTL!");
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }


complete:
    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;
        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
    }
    
    return Status;
}

// ---------------------------------------------------------------------------------------
// DeviceNoop - control channel major function entry point
// ---------------------------------------------------------------------------------------
NTSTATUS        
DeviceNoop(
    PDEVICE_OBJECT pDeviceObject, 
    PIRP pIrp
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
    
    return Status;
}

// ---------------------------------------------------------------------------------------
// DeviceNoop - control channel unsupported function entry point
// ---------------------------------------------------------------------------------------
NTSTATUS        
DeviceUnsupported(
    PDEVICE_OBJECT pDeviceObject, 
    PIRP pIrp
    )
{
    NTSTATUS Status = STATUS_NOT_SUPPORTED;

    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
    
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\util\vlan\sys\vlpacket.cpp ===
// ---------------------------------------------------------------------------------------
// vlpacket.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------


#include "vlp.h"

// ---------------------------------------------------------------------------------------
// Forward declarations
// ---------------------------------------------------------------------------------------

PVOID       SgAllocPacketInfo(POOL_TYPE PoolType, SIZE_T NumberOfBytes, ULONG Tag);
void        SgFreePacketInfo(PVOID pv);
void        SgPacketFree(CPacket * ppkt);

// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------

BYTE                        g_abDummyPacket[ENET_FRAME_MAXSIZE];        // For SgAllocPacketInfo

HANDLE                      g_hNdisBufferPool;
NPAGED_LOOKASIDE_LIST       g_laCPacketNdisInfo;
HANDLE                      g_hNdisPacketPool;

// ---------------------------------------------------------------------------------------
// CPacket
// ---------------------------------------------------------------------------------------

LONG g_lPktNum = 0;

void CPacket::CompletePush(PFNCOMPLETE pfn)
{
    Assert(_cpfn < dimensionof(_apfn));
    _apfn[_cpfn++] = pfn;
}

void CPacket::Complete()
{
    Assert(_cpfn > 0);
    (*_apfn[--_cpfn])(this);
}

void CPacket::Reset()
{
    #if DBG
    memset(this, '*', sizeof(CPacket));
    #endif

    memset(this, 0, offsetof(CPacket, _dwPktNum));

    _dwPktNum = (DWORD)InterlockedIncrement((LONG *)&g_lPktNum);
}

char * CPacket::Str() const
{
    STATIC_BUFFER(CPacketStr, 64, 64);

    _snprintf(pch, cch, "%08lX", _dwPktNum);

    return(pch);
}

// ---------------------------------------------------------------------------------------
// CPacketQueue
// ---------------------------------------------------------------------------------------

void CPacketQueue::InsertHead(CPacket * ppkt)
{
    if ((ppkt->_ppktNext = _ppktHead) == NULL)
        _ppktTail = ppkt;
    _ppktHead = ppkt;
}

void CPacketQueue::InsertTail(CPacket * ppkt)
{
    if (_ppktTail)
        _ppktTail->_ppktNext = ppkt;
    else
        _ppktHead = ppkt;

    _ppktTail = ppkt;
    ppkt->_ppktNext = NULL;
}

void CPacketQueue::InsertHead(CPacketQueue * ppq)
{
    Assert(!ppq->IsEmpty());
    if (_ppktTail == NULL)
        _ppktTail = ppq->_ppktTail;
    ppq->_ppktTail->_ppktNext = _ppktHead;
    _ppktHead = ppq->_ppktHead;
    ppq->Init();
}

CPacket * CPacketQueue::RemoveHead()
{
    Assert(!IsEmpty());

    CPacket * ppkt = _ppktHead;

    if ((_ppktHead = ppkt->_ppktNext) == NULL)
        _ppktTail = NULL;
    else
        ppkt->_ppktNext = NULL;

    return(ppkt);
}

void CPacketQueue::Complete()
{
    while (!IsEmpty())
    {
        RemoveHead()->Complete();
    }
}

BOOL CPacketQueue::Dequeue(CPacket * ppktDequeue)
{
    CPacket **  pppkt    = &_ppktHead;
    CPacket *   ppktPrev = NULL;
    CPacket *   ppkt;

    for (; (ppkt = *pppkt) != NULL; ppktPrev = ppkt, pppkt = &ppkt->_ppktNext)
    {
        if (ppkt == ppktDequeue)
        {
            *pppkt = ppkt->_ppktNext;

            if (_ppktHead == NULL)
                _ppktTail = NULL;
            else if (_ppktTail == ppkt)
                _ppktTail = ppktPrev;
            return(TRUE);
        }
    }

    return(FALSE);
}

UINT CPacketQueue::Count()
{
    CPacket * ppkt;
    UINT c;

    for (c = 0, ppkt = _ppktHead; ppkt; ppkt = ppkt->_ppktNext)
    {
        c += 1;
    }

    return(c);
}



// ---------------------------------------------------------------------------------------
// CPacket allocator
// ---------------------------------------------------------------------------------------

BOOL
SgPacketInit()
{
    NDIS_STATUS NdisStatus;

    //
    // Set up the lookaside lists of CPacketNdisInfos.
    //
    
    NdisInitializeNPagedLookasideList(
        &g_laCPacketNdisInfo,           // Lookaside
        &SgAllocPacketInfo,
        &SgFreePacketInfo,
        0,                              // Reserved
        sizeof(CPacketInfo),            // Size
        PTAG_CPacketInfo,               // Tag
        0                               // Reserved
        );
    
    //
    // Set up the NDIS_PACKET pools
    //

    NdisAllocatePacketPoolEx(
        &NdisStatus,
        &g_hNdisPacketPool,
        MIN_PACKET_POOL_SIZE,
        MAX_PACKET_POOL_SIZE - MIN_PACKET_POOL_SIZE,
        sizeof(PVOID)
        );

    if (!NT_SUCCESS(NdisStatus))
    {
        goto fatal;
    }

    //
    // Set up the NDIS_BUFFER pools
    //

    NdisAllocateBufferPool(
        &NdisStatus,
        &g_hNdisBufferPool,
        MAX_BUFFER_POOL_SIZE
        );

    if (!NT_SUCCESS(NdisStatus))
    {
        goto fatal;
    }


    return TRUE;

fatal:

    SgPacketTerm();
    return FALSE;
}


void
SgPacketTerm()
{
    NdisDeleteNPagedLookasideList(&g_laCPacketNdisInfo);

    if (g_hNdisBufferPool)
    {
        NdisFreeBufferPool(g_hNdisBufferPool);
    }
    
    if (g_hNdisPacketPool)
    {
        NdisFreePacketPool(g_hNdisPacketPool);
    }

}


// ---------------------------------------------------------------------------------------
// CPacket private functions
// ---------------------------------------------------------------------------------------

CPacket *
SgPacketAlloc()
{
    CPacketInfo * ppi;
    CPacket * ppkt;

    ppi = (CPacketInfo *)NdisAllocateFromNPagedLookasideList(&g_laCPacketNdisInfo);
    
    if (ppi)
    {
        ppkt = GET_PACKET_FROM_PKTINFO(ppi);

        ppkt->Reset();

        // remember how to clean up the packet.
        ppkt->CompletePush(&SgPacketFree);
    }
    else
    {
        ppkt = NULL;
    }
    
    return ppkt;
}


PVOID
SgAllocPacketInfo(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )
{
    CPacketInfo * ppi;
    NDIS_STATUS Status;
    
    ASSERT(PoolType == NonPagedPool);
    ASSERT(NumberOfBytes == sizeof(CPacketInfo));
    ASSERT(Tag == PTAG_CPacketInfo);

    ppi = (CPacketInfo *)VlMemAllocZ(
                                sizeof(CPacketInfo) + sizeof(CPacket),
                                PTAG_CPacketInfo
                                );


    if (ppi)
    {
        // init the packet

        NdisAllocatePacket(
            &Status,
            &ppi->_pnpXmit,
            g_hNdisPacketPool
            );

        if (Status != NDIS_STATUS_SUCCESS)
        {
            goto fatal;
        }

        // allocate buffer descriptors big enough to hold a frame
        NdisAllocateBuffer(
            &Status,                                // Status
            &ppi->_pnbXmit,                         // Buffer
            g_hNdisBufferPool,                      // PoolHandle
            g_abDummyPacket,                        // VirtualAddress
            ENET_FRAME_MAXSIZE                      // Length
            );

        if (Status != NDIS_STATUS_SUCCESS)
        {
            goto fatal;
        }            
        
    }
    
    return ppi;

fatal:
    
    SgPacketFree(GET_PACKET_FROM_PKTINFO(ppi));
    return NULL;
}

VOID
SgFreePacketInfo(
    IN PVOID pv
    )
{
    CPacketInfo * ppi = (CPacketInfo *) pv;

    // clean up packet data

    if (ppi->_pnpXmit)
    {
        NdisFreePacket(ppi->_pnpXmit);
        ppi->_pnpXmit = NULL;
    }

    if (ppi->_pnbXmit)
    {
        NdisFreeBuffer(
            ppi->_pnbXmit
            );
    }

    // other fields should already be clear
    Assert(ppi->_pnpRecv == NULL);
    Assert(ppi->_pbExternal == NULL);

    VlMemFree(ppi);
}


void
SgPacketFree(CPacket * ppkt)
{
    CPacketInfo * ppi;
    
    ASSERT(ppkt);
    ASSERT(ppkt->_cpfn == 0);

    ppi = GET_PKTINFO_FROM_PACKET(ppkt);

    // fields should already be clear
    Assert(ppi->_pnpRecv == NULL);
    Assert(ppi->_pbExternal == NULL);

    // put packet back on lookaside list

    NdisFreeToNPagedLookasideList(
        &g_laCPacketNdisInfo,
        ppi
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\util\vlan\sys\vlutil.cpp ===
// ---------------------------------------------------------------------------------------
// vlutil.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "vlp.h"


void *          
VlMemAlloc(
    size_t size, 
    ULONG tag
    )
{
    PVOID pv;
    
    pv = ExAllocatePoolWithTag(
                NonPagedPool,
                size,
                tag
                );

    return pv;
}

void *          
VlMemAllocZ(
    size_t size, 
    ULONG tag
    )
{
    PVOID pv = VlMemAlloc(size, tag);

    if (pv)
    {
        NdisZeroMemory(pv, size);
    }

    return pv;
}

void
VlMemFree(
    void * pv
    )
{
    if (pv)
    {
        ExFreePool(pv);
    }
}

    
EXTERN_C 
void*
__stdcall
RSA32Alloc( unsigned long cb )
{
    return VlMemAlloc(cb, PTAG_RSA);
}


EXTERN_C 
void
__stdcall
RSA32Free( void *pv )
{
    VlMemFree(pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\util\vlan\sys\vlrecv.cpp ===
// ---------------------------------------------------------------------------------------
// vlrecv.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "vlp.h"

// ---------------------------------------------------------------------------------------
// Trace Tags
// ---------------------------------------------------------------------------------------

DefineTag(KmRecv,           TAG_DISABLE);
DefineTag(KmRecvDiscard,    TAG_DISABLE);        // Trace discarded packets


// ---------------------------------------------------------------------------------------
// Forward declarations
// ---------------------------------------------------------------------------------------

void        VlFreeNdisPacket(CPacket * ppkt);
void        VlFreeIndicatedPacketBuffer(CPacket * ppkt);

// ---------------------------------------------------------------------------------------
// VlanReceivePacket
//
// This is the primary entry point NDIS uses to pass packets to us.
// ---------------------------------------------------------------------------------------

INT
VlanReceivePacket(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  PNDIS_PACKET        pnp
    )
{
    CAdapter * pAdapt = (CAdapter *) ProtocolBindingContext;
    CPacket * ppkt;
    CPacketInfo * ppi;

    INT PacketRefs = 0;

    // Make sure we're active.

    if (pAdapt->_dwState != ADAPT_STATE_READY || pAdapt->_powerState != NetDeviceStateD0)
    {
        TraceSz1(KmRecvDiscard, "[DISCARD] PtReceivePacket adapter %p not ready", pAdapt);
        
        // nope, drop the packet
        goto exit;
    }


    // figure out ndis info
    
    PNDIS_BUFFER    pNdisBuffer;
    PVOID           pvNdisBuffer;
    UINT            cbNdisBuffer;
    UINT            cbTotalBuffer;

    NdisGetFirstBufferFromPacket(
        pnp,
        &pNdisBuffer,
        &pvNdisBuffer,
        &cbNdisBuffer,
        &cbTotalBuffer
        );

    TraceSz4(KmRecv, "PtReceivePacket received %p size %d, first buffer %p, %d",
             pnp, cbTotalBuffer, pvNdisBuffer, cbNdisBuffer);

    // get a CPacket and initialize it

    ppkt = SgPacketAlloc();

    if (!ppkt)
    {
        goto exit;
    }
    
    ppi = GET_PKTINFO_FROM_PACKET(ppkt);
    if (!ppi)
    {
        goto exit;
    }

    if (   cbNdisBuffer == cbTotalBuffer
        && NDIS_GET_PACKET_STATUS(pnp) != NDIS_STATUS_RESOURCES
        && !g_fForceCopyPacketPath)
    {
        // Save a pointer to the NDIS_PACKET so we can return it later.

        ppi->_pnpRecv = pnp;
        PacketRefs = 1;
        
        ppkt->CompletePush(&VlFreeNdisPacket);

        // set up the pointers for the upper layers.
        
        ppkt->_cb = cbNdisBuffer;
        ppkt->_pb = (PBYTE) pvNdisBuffer;    
    }
    else
    {
        // Either the packet is not all in one buffer or the miniport
        // driver is low on resources. Copy all the data into another
        // buffer and return immediately.

        ppi->_pbExternal = (PBYTE)VlMemAlloc(cbTotalBuffer, PTAG_ExternalDataBuffer);

        if (!ppi->_pbExternal)
            goto exit;

        // copy the data
        PBYTE pb = ppi->_pbExternal;

        while (pNdisBuffer != NULL)
        {
            NdisQueryBufferSafe(pNdisBuffer, &pvNdisBuffer, &cbNdisBuffer, NormalPagePriority);

            if (pvNdisBuffer == NULL)
                goto exit;

            NdisMoveMemory(pb, pvNdisBuffer, cbNdisBuffer);
            pb += cbNdisBuffer;

            NdisGetNextBuffer(pNdisBuffer, &pNdisBuffer);
        }
        Assert(pb == ppi->_pbExternal + cbTotalBuffer);

        // remember how to free this packet
        ppkt->CompletePush(&VlFreeIndicatedPacketBuffer);        

        Assert(ppi->_pnpRecv == NULL);
        Assert(PacketRefs = 0);

        // set up the pointers for the upper layers.

        ppkt->_cb = cbTotalBuffer;
        ppkt->_pb = ppi->_pbExternal;
    }

    ppkt->_pAdapt = pAdapt;
    
    pAdapt->RecvPacket(ppkt);

exit:
    return PacketRefs;
}


// ---------------------------------------------------------------------------------------
// VlanReceiveIndication
//
// This is a secondary entry point NDIS uses to pass packets to us.
// Ndis calls this function instead of PtReceivePacket when it is running
// low on memory. We have to copy the data into our own buffers before
// passing the packet on.
// ---------------------------------------------------------------------------------------

NDIS_STATUS
VlanReceiveIndication(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  NDIS_HANDLE         MacReceiveContext,
    IN  PVOID               HeaderBuffer,
    IN  UINT                HeaderBufferSize,
    IN  PVOID               LookAheadBuffer,
    IN  UINT                LookAheadBufferSize,
    IN  UINT                PacketSize
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    CAdapter * pAdapt = (CAdapter *) ProtocolBindingContext;
    UINT TotalSize = HeaderBufferSize + PacketSize;
    
    CPacket * ppkt = NULL;
    CPacketInfo * ppi = NULL;
    
    
    //
    // Make sure we're active.
    //

    if (pAdapt->_dwState != ADAPT_STATE_READY || pAdapt->_powerState != NetDeviceStateD0)
    {
        TraceSz1(KmRecvDiscard, "[DISCARD] PtReceiveIndication adapter %p not ready", pAdapt);
        
        // nope, drop the packet
        goto fatal;
    }

    TraceSz3(KmRecv, "PtReceiveIndication received data size %d, first buffer %p, %d",
             PacketSize, LookAheadBuffer, LookAheadBufferSize);

    // allocate a packet info

    ppkt = SgPacketAlloc();

    if (!ppkt)
    {
        Status = NDIS_STATUS_RESOURCES;
        goto fatal;
    }

    ppi = GET_PKTINFO_FROM_PACKET(ppkt);
    if (!ppi)
    {
        Status = NDIS_STATUS_RESOURCES;
        goto fatal;
    }

    // allocate a buffer
    ppi->_pbExternal = (PBYTE)VlMemAlloc(TotalSize, PTAG_ExternalDataBuffer);

    if (!ppi->_pbExternal)
    {
        Status = NDIS_STATUS_RESOURCES;
        goto fatal;
    }        

    // remember how to free this packet
    ppkt->CompletePush(&VlFreeIndicatedPacketBuffer);

    NdisMoveMappedMemory(ppi->_pbExternal, HeaderBuffer, HeaderBufferSize);

    if (LookAheadBufferSize == PacketSize && !g_fForceTransferDataPath)
    {    
        // copy the data
        TdiCopyLookaheadData(
            ppi->_pbExternal + HeaderBufferSize,
            LookAheadBuffer,
            LookAheadBufferSize,
            pAdapt->_dwTdiRecvFlags
            );
    }
    else
    {
        // This indication does not include the entire packet, so we must
        // call NdisTransferData to get the rest.

        MmInitializeMdl(
            (PMDL)ppi->_pnbXmit,
            ppi->_pbExternal + HeaderBufferSize,
            PacketSize
            );

        MmBuildMdlForNonPagedPool((PMDL)ppi->_pnbXmit);
        NdisChainBufferAtBack(ppi->_pnpXmit, ppi->_pnbXmit);

        SET_NDIS_PACKET_CONTEXT(ppi->_pnpXmit, ppi);

        ppkt->_pb     = ppi->_pbExternal;
        ppkt->_cb     = TotalSize;

        ppkt->_pAdapt = pAdapt;

        UINT cbTransfer = 0;

        NdisTransferData(&Status,
                         pAdapt->_hLowerBinding,
                         MacReceiveContext,
                         0,
                         PacketSize,
                         ppi->_pnpXmit,
                         &cbTransfer);

        if (Status != NDIS_STATUS_PENDING)
        {
            VlanTransferDataComplete(ProtocolBindingContext,
                                     ppi->_pnpXmit,
                                     Status,
                                     cbTransfer);
        }

        return Status;
    }

    // indicate the packet
    ppkt->_pAdapt = pAdapt;
        
    ppkt->_cb = TotalSize;
    ppkt->_pb = ppi->_pbExternal;

    pAdapt->RecvPacket(ppkt);

    return NDIS_STATUS_SUCCESS;
    
fatal:

    if (ppkt)
    {
        ppkt->Complete();
    }
    
    return Status;
}


// ---------------------------------------------------------------------------------------
// VlanReceiveComplete
//
// Ndis calls this function every now and then to let us know that we
// can do post-processing steps on previously indicated packets. We
// have no post processing to do.
// ---------------------------------------------------------------------------------------
void
VlanReceiveComplete(
    IN  NDIS_HANDLE ProtocolBindingContext
    )
{
}

// ---------------------------------------------------------------------------------------
// VlanTransferDataComplete
//
// Ndis calls this function to complete an async call to NdisTransferData, which
// we sometimes must call from VlanReceiveIndication to get the full contents of a packet
// ---------------------------------------------------------------------------------------
void
VlanTransferDataComplete(
    NDIS_HANDLE ProtocolBindingContext,
    PNDIS_PACKET Packet,
    NDIS_STATUS Status,
    UINT BytesTransferred
    )
{
    CAdapter *    pAdapt = (CAdapter *)ProtocolBindingContext;
    CPacketInfo * ppi    = GET_PKTINFO_FROM_NDIS_PACKET(Packet);
    CPacket *     ppkt   = GET_PACKET_FROM_PKTINFO(ppi);

    MmPrepareMdlForReuse(ppi->_pnbXmit);    
    NdisReinitializePacket(ppi->_pnpXmit);

    if (Status == NDIS_STATUS_SUCCESS)
    {
        pAdapt->RecvPacket(ppkt);
    }
    else
    {
        ppkt->Complete();
    }
}

// ---------------------------------------------------------------------------------------
// VlFreeNdisPacket
//
// Frees a packet allocated by PtReceivePacket.
// ---------------------------------------------------------------------------------------
void
VlFreeNdisPacket(CPacket * ppkt)
{
    CPacketInfo * ppi = GET_PKTINFO_FROM_PACKET(ppkt);
    Assert(ppi->_pnpRecv);
    Assert(!ppi->_pbExternal);

    NdisReturnPackets(&ppi->_pnpRecv, 1);
    ppi->_pnpRecv = NULL;

    ppkt->Complete();
}

// ---------------------------------------------------------------------------------------
// VlFreeIndicatedPacketBuffer
//
// Frees a packet allocated by PtReceiveIndication.
// ---------------------------------------------------------------------------------------
void
VlFreeIndicatedPacketBuffer(CPacket * ppkt)
{
    CPacketInfo * ppi = GET_PKTINFO_FROM_PACKET(ppkt);
    Assert(!ppi->_pnpRecv);
    Assert(ppi->_pbExternal);

    VlMemFree(ppi->_pbExternal);
    ppi->_pbExternal = 0;

    ppkt->Complete();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\util\vlan\sys\vlvnet.cpp ===
// ---------------------------------------------------------------------------------------
// vlvnet.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------


#include "vlp.h"

// ---------------------------------------------------------------------------------------
// Trace Tags
// ---------------------------------------------------------------------------------------

DefineTag(VlXmit,           TAG_DISABLE);       // Trace send path
DefineTag(VlVnet,           TAG_DISABLE);       // Trace vnet calls
DefineTag(VlDrop,           TAG_ENABLE);        // Trace packets dropped from queue

// ---------------------------------------------------------------------------------------
// Forward declarations
// ---------------------------------------------------------------------------------------

void VlRestartSendIoctl(CPacket * ppkt);


// ---------------------------------------------------------------------------------------
// VlanReceiveIoctl - handles VlanReceive IOCTL. METHOD_OUT_DIRECT.
// ---------------------------------------------------------------------------------------
NTSTATUS        
VlanReceiveIoctl(
    PIRP pIrp, 
    CVirtualNet * pVnet
    )
{
    PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    KIRQL oldIrql;
    CPacket * ppkt;

    TraceSz2(VlVnet, "VlanReceiveIoctl(pIrp = %p, pVnet = %p)",
             pIrp, pVnet);

    // make sure the IRP is big enough to hold a full size packet
    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < ENET_FRAME_MAXSIZE)
    {
        // nope. DeviceControl will complete the IRP
        return STATUS_BUFFER_TOO_SMALL;
    }
    
    IoMarkIrpPending(pIrp);

    pVnet->_lock.Acquire(&oldIrql);

    if (!pVnet->_pq.IsEmpty())
    {
        Assert(pVnet->_iq.IsEmpty());
        
        ppkt = pVnet->_pq.RemoveHead();
    }
    else
    {
        // no packets around. queue the IRP
        pVnet->_iq.InsertTail(pIrp);

        ppkt = NULL;
        pIrp = NULL;        
    }

    pVnet->_lock.Release(oldIrql);

    if (ppkt)
    {
        PBYTE pb;
        
        // copy the data
        TraceSz3(VlVnet, "VlanReceiveIoctl(pIrp = %p, pVnet = %p) copying packet %s to IRP",
                 pIrp, pVnet, ppkt->Str());

        Assert(ppkt->_cb <= ENET_FRAME_MAXSIZE);

        pb = (PBYTE)MmGetSystemAddressForMdlSafe(pIrp->MdlAddress, NormalPagePriority);

        if (pb)
        {
            // copy packet into the IRP
            RtlCopyMemory(pb, ppkt->_pb, ppkt->_cb);

            pIrp->IoStatus.Status = STATUS_SUCCESS;
            pIrp->IoStatus.Information = ppkt->_cb;
        }
        else
        {
            // system is out of resources
            // we're going to drop this packet. oh well.

            pIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            pIrp->IoStatus.Information = 0;
        }

        // complete the IRP
        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

        // complete the packet
        ppkt->Complete();
    }

    return STATUS_PENDING;
}

NTSTATUS        
VlanSendIoctl(
    PIRP pIrp, 
    CVirtualNet * pVnet
    )
{
    PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    CPacket * ppkt;
    PBYTE pb;
    DWORD cb;
    
    TraceSz2(VlXmit, "VlanSendIoctl(pIrp = %p, pVnet = %p)",
             pIrp, pVnet);


    // make sure the IRP is a reasonable size
    cb = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
    
    if ((cb < sizeof(CEnetHdr)) || (cb > ENET_FRAME_MAXSIZE))
    {
        TraceSz3(VlXmit, "VlanSendIoctl(pIrp = %p, pVnet = %p) invalid size %d",
                 pIrp, pVnet, cb);
        // nope. DeviceControl will complete the IRP
        return STATUS_INVALID_PARAMETER;
    }

    // grab the IRP buffer
    pb = (PBYTE)MmGetSystemAddressForMdlSafe(pIrp->MdlAddress, NormalPagePriority);
    if (!pb)
    {
        // couldn't allocate an address. DeviceControl will complete the IRP.
        return STATUS_INSUFFICIENT_RESOURCES;
    }          

    // get a packet
    ppkt = SgPacketAlloc();
    if (!ppkt)
    {
        // couldn't allocate a packet. DeviceControl will complete the IRP.
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // set up the packet buffers
    ppkt->_pb = pb;
    ppkt->_cb = cb;

    // remember IRP stuff so we can complete later
    
    IoMarkIrpPending(pIrp);
    ppkt->_pSendIrp = pIrp;

    ppkt->CompletePush(VlRestartSendIoctl);

    // actually send to the adapter

    Assert(pVnet->_pAdapter);
    pVnet->_pAdapter->NicXmit(ppkt);

    return STATUS_PENDING;
}

void
VlRestartSendIoctl(
    CPacket * ppkt
    )
{
    PIRP pIrp = (PIRP)ppkt->_pSendIrp;
    ppkt->_pSendIrp = NULL;

    Assert(pIrp);

    // complete the IRP
    pIrp->IoStatus.Status = STATUS_SUCCESS;
    pIrp->IoStatus.Information = ppkt->_cb;
    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

    // complete the packet
    ppkt->Complete();
}


NTSTATUS        
VlanAddVAdapterIoctl(
    PIRP pIrp, 
    CVirtualNet * pVnet
    )
{
    PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    VLAN_VADAPTER_INFO * pAdaptInfo;
    DWORD cb;
    
    TraceSz2(VlVnet, "VlanAddVAdapterIoctl(pIrp = %p, pVnet = %p)",
             pIrp, pVnet);


    // make sure the IRP is a reasonable size
    cb = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
    
    if (cb != sizeof(VLAN_VADAPTER_INFO))
    {
        TraceSz3(VlVnet, "VlanAddVAdapterIoctl(pIrp = %p, pVnet = %p) invalid size %d",
                 pIrp, pVnet, cb);
        // nope. DeviceControl will complete the IRP
        return STATUS_INVALID_PARAMETER;
    }

    // grab the IRP buffer
    pAdaptInfo = (VLAN_VADAPTER_INFO *)pIrp->AssociatedIrp.SystemBuffer;
    ASSERT(pAdaptInfo);

    CEnetAddr * pea = (CEnetAddr *) &pAdaptInfo->_abEnetAddr;

    if (pVnet->_pAdapter->AddTransport(pea, pVnet))
    {
        // done
        return STATUS_SUCCESS;
    }
    else
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
}

NTSTATUS        
VlanRemoveVAdapterIoctl(
    PIRP pIrp, 
    CVirtualNet * pVnet
    )
{
    PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    VLAN_VADAPTER_INFO * pAdaptInfo;
    DWORD cb;
    
    TraceSz2(VlVnet, "VlanRemoveVAdapterIoctl(pIrp = %p, pVnet = %p)",
             pIrp, pVnet);


    // make sure the IRP is a reasonable size
    cb = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
    
    if (cb != sizeof(VLAN_VADAPTER_INFO))
    {
        TraceSz3(VlVnet, "VlanRemoveVAdapterIoctl(pIrp = %p, pVnet = %p) invalid size %d",
                 pIrp, pVnet, cb);
        // nope. DeviceControl will complete the IRP
        return STATUS_INVALID_PARAMETER;
    }

    // grab the IRP buffer
    pAdaptInfo = (VLAN_VADAPTER_INFO *)pIrp->AssociatedIrp.SystemBuffer;
    ASSERT(pAdaptInfo);

    CEnetAddr * pea = (CEnetAddr *) &pAdaptInfo->_abEnetAddr;

    pVnet->_pAdapter->RemoveTransport(pea, pVnet);
    
    return STATUS_SUCCESS;
}


void
VlTraceDroppedPacket(CPacket * ppkt)
{
    LARGE_INTEGER liNow;
    LARGE_INTEGER liAge;
    KeQuerySystemTime(&liNow);

    liAge.QuadPart = liNow.QuadPart - ppkt->_liTime.QuadPart;
    liAge.QuadPart /= 10000000;
    
    TraceSz2(VlDrop, "Dropping packet %s, age %I64d",
             ppkt->Str(), liAge.QuadPart);

    ppkt->Complete();
}

void
CVirtualNet::Xmit(
    CPacket * ppkt
    )
{
    KIRQL oldIrql;
    LARGE_INTEGER liNow;
    CPacketQueue pqDrop;

    pqDrop.Init();

    _lock.Acquire(&oldIrql);

    // remember when we received the packet
    KeQuerySystemTime(&liNow);
    ppkt->_liTime = liNow;

    // try to find an IRP
    PIRP pIrp = _iq.RemoveHead();

    if (!pIrp)
    {
        // no IRPs, queue the packet.
        _pq.InsertTail(ppkt);
        ppkt = NULL;

        // make sure we don't have too many packets queued
        while (_pq.Count() > MAX_QUEUED_PACKETS)
        {
            if (Tag(VlDrop))
                _pq.GetHead()->CompletePush(VlTraceDroppedPacket);
                
            pqDrop.InsertHead(_pq.RemoveHead());
        }

        // throw away old packets
        while (_pq.GetHead()
               && (liNow.QuadPart - _pq.GetHead()->_liTime.QuadPart) > MAX_TIME_QUEUED)
        {
            if (Tag(VlDrop))
                _pq.GetHead()->CompletePush(VlTraceDroppedPacket);
                
            pqDrop.InsertHead(_pq.RemoveHead());
        }
    }
    
    _lock.Release(oldIrql);

    // drop any packets that we yanked from the queue
    pqDrop.Complete();

    // complete IRP if we have one.
    if (pIrp)
    {
        PBYTE pb;
        
        TraceSz3(VlVnet, "CVirtualNet::Xmit(ppkt = %p) copying packet %s to IRP %p",
                 ppkt, ppkt->Str(), pIrp);

        Assert(ppkt);
        
        // ok, we've got an IRP.
        // copy the data
        Assert(ppkt->_cb <= ENET_FRAME_MAXSIZE);

        pb = (PBYTE)MmGetSystemAddressForMdlSafe(pIrp->MdlAddress, NormalPagePriority);

        if (pb)
        {
            // copy packet into the IRP
            RtlCopyMemory(pb, ppkt->_pb, ppkt->_cb);

            pIrp->IoStatus.Status = STATUS_SUCCESS;
            pIrp->IoStatus.Information = ppkt->_cb;
        }
        else
        {
            // system is out of resources
            // we're going to drop this packet. oh well.

            pIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            pIrp->IoStatus.Information = 0;
        }

        // complete the IRP
        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

        // complete the packet
        ppkt->Complete();
    }
}


BOOL                
CIrpQueue::InsertTail(
    PIRP pIrp
    )
{
    PIO_STACK_LOCATION pIrpSp;
    
    // Save a pointer to the queue in the IRP. This allows us to
    // clean up properly if the IRP is cancelled.

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = this;

    // Set to these to null just in case the cancel routine runs.

    pIrp->Tail.Overlay.ListEntry.Flink = NULL;
    pIrp->Tail.Overlay.ListEntry.Blink = NULL;

    // Set the cancel routine. The routine may run as soon as it is set.
    
    IoSetCancelRoutine(pIrp, &CIrpQueue::IrpCancelRoutine);

    //
    // cancelled?
    //

    if (pIrp->Cancel)
    {
        // darn it, need to make sure the irp get's completed

        if (IoSetCancelRoutine( pIrp, NULL ) != NULL)
        {
            //
            // we are in charge of completion, IoCancelIrp didn't
            // see our cancel routine (and won't).  caller
            // must complete it
            //
            
            pIrp->IoStatus.Information = 0;
            pIrp->IoStatus.Status = STATUS_CANCELLED;

            return FALSE;
        }

        // our cancel routine will run and complete the irp,
        // don't touch it

        return TRUE;
    }

    
    // now we are safe to queue the IRP for real

    InsertTailList(
        &_lh,
        &pIrp->Tail.Overlay.ListEntry
        );

    return TRUE;
}

PIRP                
CIrpQueue::RemoveHead()
{
    PIRP pIrp = NULL;

    while (!IsListEmpty(&_lh))
    {
        PLIST_ENTRY        pEntry;

        // Found a free irp

        pEntry = RemoveHeadList(&_lh);
        pEntry->Blink = pEntry->Flink = NULL;

        pIrp = CONTAINING_RECORD(
                    pEntry,
                    IRP,
                    Tail.Overlay.ListEntry
                    );

        // pop the cancel routine

        if (IoSetCancelRoutine(pIrp, NULL) != NULL)
        {
            PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
            
            // we are free to use this irp

            Assert(this == pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer);
            pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
                
            break;
        }
        else
        {
            //
            // IoCancelIrp pop'd it first
            //
            // ok to just ignore this irp, it's been popped off the queue
            // and will be completed in the cancel routine.
            //
            // keep looking for a irp to use
            //

            pIrp = NULL;

        }

    }
    
    return pIrp;
}

void                
CIrpQueue::CancelAll()
{
    PIRP pIrp;
    
    while (pIrp = RemoveHead())
    {
        TraceSz1(VlVnet, "CIrpQueue::CancelAll pIrp = %p", pIrp);
        
        pIrp->IoStatus.Status = STATUS_CANCELLED;
        pIrp->IoStatus.Information = 0;

        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
    }
}


void
CIrpQueue::IrpCancelRoutine(
    PDEVICE_OBJECT pDevice, 
    PIRP pIrp
    )
{
    KIRQL oldIrql;
    PIO_STACK_LOCATION pIrpSp;
    CIrpQueue * pq;

    //
    // release the cancel spinlock.  This means the cancel routine
    // must be the one completing the irp (to avoid the race of
    // completion + reuse prior to the cancel routine running).
    //

    IoReleaseCancelSpinLock(pIrp->CancelIrql);
    
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    // Grab the queue off the IRP.
    
    pq = (CIrpQueue *)pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    // Remove this IRP.

    pq->_pLock->Acquire(&oldIrql);

    if (pIrp->Tail.Overlay.ListEntry.Flink)
    {
        RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);
        pIrp->Tail.Overlay.ListEntry.Flink = NULL;
        pIrp->Tail.Overlay.ListEntry.Blink = NULL;
    }

    pq->_pLock->Release(oldIrql);

    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

    // Complete the IRP.

    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;

    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\CASvc\dll\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\sg\util\vlan\sys\vlxmit.cpp ===
// ---------------------------------------------------------------------------------------
// vlxmit.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "vlp.h"

// ---------------------------------------------------------------------------------------
// Trace Tags
// ---------------------------------------------------------------------------------------

DefineTag(KmXmitFail,       TAG_ENABLE);        // Trace failed sends


// ---------------------------------------------------------------------------------------
// CAdapter::NicXmit
//
// Transmits a packet to the network.
// ---------------------------------------------------------------------------------------
void
CAdapter::NicXmit(CPacket * ppkt)
{
    NDIS_STATUS Status;
    CPacketInfo * ppi = GET_PKTINFO_FROM_PACKET(ppkt);

    // Make sure we're active.

    if (_dwState != ADAPT_STATE_READY)
    {
        TraceSz1(KmXmitFail, "[DISCARD] CAdapter::NicXmit adapter %p not ready", this);
        
        // nope, drop the packet
        goto fatal;
    }

    MmInitializeMdl(
        (PMDL)ppi->_pnbXmit,
        ppkt->_pb,
        ppkt->_cb
        );

    MmBuildMdlForNonPagedPool((PMDL)ppi->_pnbXmit);
    NdisChainBufferAtBack(ppi->_pnpXmit, ppi->_pnbXmit);

    ppkt->CompletePush(&CAdapter::NicXmitComplete);

    // Save a pointer to the packetinfo in the packet
    SET_NDIS_PACKET_CONTEXT(ppi->_pnpXmit, ppi);

    NdisSend(
        &Status,
        _hLowerBinding,
        ppi->_pnpXmit
        );

    if (Status != NDIS_STATUS_PENDING)
    {
        TraceSz2(KmXmitFail, "Packet %p xmit failed inline with status %x\n",
                 ppkt, Status);
        goto fatal;
    }

    return;

fatal:
    ppkt->Complete();
}


// ---------------------------------------------------------------------------------------
// CAdapter::NicXmitComplete (static)
//
// Resets the embedded NDIS_PACKET and associated MDLs so it can be reused.
// ---------------------------------------------------------------------------------------
void
CAdapter::NicXmitComplete(CPacket * ppkt)
{
    CPacketInfo * ppi = GET_PKTINFO_FROM_PACKET(ppkt);

    MmPrepareMdlForReuse(ppi->_pnbXmit);
    
    NdisReinitializePacket(ppi->_pnpXmit);
    ppkt->Complete();
}


// ---------------------------------------------------------------------------------------
// VlanSendComplete
//
// Called by Ndis when a pending NdisSend call completes.
// ---------------------------------------------------------------------------------------
void
VlanSendComplete(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN PNDIS_PACKET pnp,
    IN NDIS_STATUS  Status
    )
{
    CPacketInfo * ppi = GET_PKTINFO_FROM_NDIS_PACKET(pnp);
    CPacket * ppkt = GET_PACKET_FROM_PKTINFO(ppi);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        TraceSz2(KmXmitFail, "Packet %p xmit failed async with status %x\n",
                 ppkt, Status);
    }

    ppkt->Complete();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\CASvc\dll\casvc.h ===
/*******************************************************************
*
*    DESCRIPTION: CertAuth.h
*       Declaration of cross (pInvoke) interface for the CA Service
*
*******************************************************************/


//
// Prototypes
//

HRESULT
CAInitialize(
    IN  wchar_t const * wzIssuerCertName,           // Issuer certificate subject name
    IN  wchar_t const * wzCRLDP,                    // CRL URL string
    IN  wchar_t const * wzAccessInfoURI,            // CA access info identifier URI
    OUT CASvc** ppCA);                              // Return handle for future calls

HRESULT
CACertify (
    IN      CASvc *         pCA,                    // handle to the CASvc reference
    IN      wchar_t const * wzSubjectName,          // New cert subject name
                                                    // i.e. L"CN=0347515f-a81d-4209-8a98-f9515a18d6d4,OU=Xbox Online,O=Microsoft,C=US"
    IN      BYTE const *    rgKey,                  // Public RSA2048 console key
    IN      DWORD           cbKey,                  // length of key above
    IN      DWORD           dwFlags,                // flag to specify certificate details
    IN      FILETIME        dtNotBefore,            // datetime of when the cert should be valid
    IN      FILETIME        dtNotAfter,             // datetime of when the cert should expire
    IN OUT  LPBYTE          rgCert,                 // buffer to contain returned cert.
    IN OUT  LPDWORD         dwCert,                 // length of returned cert buffer (win32 model)
    OUT     LPGUID          Serial );               // serial number of generated cert

HRESULT
CASerialize(
    IN      CASvc *         pCA,                    // handle to the CASvc reference
    IN      BYTE const *    pCert,                  // cert to serialize
    IN      DWORD           cbCert,                 // size of cert to serialize
    IN OUT  LPBYTE          pSerialized,            // pre-allocated buffer to contain serialized cert
    IN OUT  LPDWORD         pcbSerialized );        // size of buffer (if pSerialized == NULL) contain required size


VOID
CATerminate(IN CASvc * pCA);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\CASvc\dll\casvc.cpp ===
/*******************************************************************
*
*    DESCRIPTION: casvc.cpp
*       Implementation of cross (pInvoke) interface for the CA Service
*
*
*******************************************************************/

// includes
#include "stdafx.h"


// Stupid HRESULT_FROM_WIN32 is a macro...
inline HRESULT HrFromWin32(DWORD const dwWin32Err)
    {
    return HRESULT_FROM_WIN32(dwWin32Err);
    }

//
// Implementation of shelling methods to expose the CA via pInvoke
// to the web service.
//


///////////////////////////////////////////////////////
// Function CAInitialize
//
// Description
//    Initializes XBL CA with location of issuer cert, CRL
//    Distribution point and Access INfo URI
//
// Parameters
//    See below
//
// Returns:
//    HRESULT
//
//
HRESULT
CAInitialize(
    IN  wchar_t const * const wzIssuerCertName,            // Issuer certificate subject name
    IN  wchar_t const * const wzCRLDP,                     // CRL URL string
    IN  wchar_t const * const wzAccessInfoURI,             // CA access info identifier URI
    OUT CASvc** ppCA)                                      // Return handle for future calls
{
    HRESULT hr  = S_OK;
    CASvc *pCA = NULL;

    if (ppCA == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppCA = NULL;
    pCA = new CASvc();

    if (pCA == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pCA->SetCRLDP(wzCRLDP);
    if (FAILED(hr)) goto Cleanup;
    hr = pCA->SetAccessInfoURI(wzAccessInfoURI);
    if (FAILED(hr)) goto Cleanup;

    hr = HrFromWin32(pCA->LoadCryptoFromStore(wzIssuerCertName));
    if (FAILED(hr)) goto Cleanup;

    *ppCA = pCA;
    pCA = NULL;

Cleanup:

    delete pCA;

    return hr;
}


///////////////////////////////////////////////////////
// Function CACertify
//
// Description
//    Issue certificate for public key signed by XBL sub-CA
//    certificate authority
//
// Parameters
//    See below
//
// Returns:
//    HRESULT
//
//
HRESULT
CACertify (
    IN      CASvc *             pCA,            // handle to the CASvc reference
    IN      wchar_t const *     wzSubjectName,  // New cert subject name
                                                // i.e. L"CN=0347515f-a81d-4209-8a98-f9515a18d6d4,OU=Xbox Online,O=Microsoft,C=US"
    IN      BYTE const * const  pKey,           // Public RSA2048 console key
    IN      DWORD const         cbKey,          // length of key above
    IN      DWORD const         dwFlags,        // flag to specify certificate details
    IN      FILETIME            dtNotBefore,    // datetime of when the cert should be valid
    IN      FILETIME            dtNotAfter,     // datetime of when the cert should expire
    IN OUT  BYTE * const        pCert,          // buffer to contain returned cert.
    IN OUT  DWORD * const       pcbCert,        // length of returned cert buffer (win32 model)
    OUT     GUID * const        pSerial )       // serial number of generated cert
{
    HRESULT hr  = S_OK;

    if (pCA == NULL || !pCA->IsValid())
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    hr = HrFromWin32(pCA->Certify( wzSubjectName,
                          pKey,
                          cbKey,
                          static_cast<CASvcExtensions>(dwFlags),
                          dtNotBefore,
                          dtNotAfter,
                          pCert,
                          pcbCert,
                          pSerial));
    if (FAILED(hr)) goto Cleanup;

Cleanup:
    return hr;
}

///////////////////////////////////////////////////////
// Function CASerialize
//
// Description
//    Return crypto-serialized version of the x509 asn.1
//    encoded certificate
//
// Parameters
//   See below
//
// Returns:
//   HRESULT versions of the following:
//     ERROR_MORE_DATA if buffer too small
//     ERRROR_INVALID_APRAMETER if any of the params is unexpected
//     WIN32/Crypto error space errors
//     ERROR_SUCCESS upon success
//
//
HRESULT
CASerialize(
    IN      CASvc *             pCA,                    // handle to the CASvc reference
    IN      BYTE const * const  pCert,                  // cert to serialize
    IN      DWORD const         cbCert,                 // size of cert to serialize
    IN OUT  BYTE * const        pSerialized,            // pre-allocated buffer to contain serialized cert
    IN OUT  DWORD * const       pcbSerialized )         // size of buffer (if pSerialized == NULL) contain required size
{
    HRESULT hr  = S_OK;

    if (pCA == NULL || !pCA->IsValid())
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    hr = HrFromWin32(pCA->Serialize(pCert, cbCert, pSerialized, pcbSerialized));
    if (FAILED(hr)) goto Cleanup;

Cleanup:
    return hr;
}


///////////////////////////////////////////////////////
// Function CATerminate
//
// Description
//    Shuts down CA Authority. There's no support for
//    re-initialize at the moment (not tested at least).
//
// Returns:
//    None.
//
//
VOID
CATerminate(IN CASvc * pCA)
{
    delete pCA;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\CASvc\dll\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// NOTE: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\CASvc\dll\certify.h ===
/*******************************************************************
*
*    DESCRIPTION: certify.h
*      Declaration of functions for certify.cpp
*      The following is Xbox Online Certificate Authority
*      native code implementation.
*
*******************************************************************/


// These are probably useful on a project-wide level, so I should find a better place for these.
template <typename T, size_t N> size_t array_size(T (&a)[N]) { return N; }

template <typename T> BOOL IsStringNullOrEmpty(T sz)
    {
    // This is a semi-hack.  Ideally we should be checking against "\0" or L"\0". But this would require
    // more code and we know that both are just 0.
    return sz == NULL || *sz == 0;
    }



//
// Enums
//

// the following AV/non-AV should be exclusive
enum CASvcExtensions : DWORD {
    ClientAuthentication = 1,
    MstvAVPolicy         = 2
};

DWORD const CASVC_MSTV_AV_CERT =    0x1;
DWORD const CASVC_MSTV_AUTH_CERT =  0x2;


///////////////////////////////////////////////////////
// class CASvc
//
// Description
//   Encapsulate all operations for CA actions. Essentially
//   it's purpose is to sign & issue certificates (served by
//   Certify())
//
// Date 2/5/2007
////
class CASvc
{
private:
// properties

    static size_t const MEMBER_URL_SIZE = 256;

    // Crypto
    HCERTSTORE          m_hIssuerStore;                     // tmp in-mem store for issuer cert
    HCRYPTPROV          m_hIssuerProv;                      // issuer (& general) crypto provider
    PCCERT_CONTEXT      m_pIssuerCert;                      // loaded issuer cert
    PCRYPT_DATA_BLOB    m_pIssuerKeyId;                     // key id extension for CA encoding
    WCHAR               m_wzCrlDP[MEMBER_URL_SIZE];         // CRL distribution point URL ptr
    WCHAR               m_wzAccessInfoURI[MEMBER_URL_SIZE]; // CA identifier URI

    // private key
    // WARNING: Can we cache it in memory?
    HCRYPTKEY           m_hPriKey;
    DWORD               m_dwKeyType;
    BOOL                m_fFreeIssuerProv;

// methods

    DWORD LoadRootCertFromStore(wchar_t const * pwzIssuerName);

    DWORD LoadPrivateKeyFromStore();

    DWORD LoadCertExtensions();
    DWORD SignAndEncodeCertificate(CERT_INFO CertInfo, LPBYTE pbCert, LPDWORD pcbCert);

    void UnloadRootCertificate();

    DWORD LoadFile(wchar_t const * pwzFile, LPBYTE pbBuffer, UINT *pcbBuffer);

    DWORD XCrypt2048KeyToCryptoKey(
            IN      BYTE const *      pbXenonKey,
            IN      DWORD       cbXenonKey,
            IN OUT  LPBYTE      pbCryptoKey,
            IN OUT  LPDWORD     pcbCryptoKey);

    DWORD XCryptConsoleKeyToCryptoKey(  // 1024-bit key
            IN      BYTE const *      pbXenonKey,
            IN      DWORD       cbXenonKey,
            IN OUT  LPBYTE      pbCryptoKey,
            IN OUT  LPDWORD     pcbCryptoKey);

    // Disable copy--don't define these.
    CASvc& operator=(const CASvc&);
    CASvc(const CASvc&);


public:
    //
    // (Un/)Initialize
    //
    CASvc();
    ~CASvc();
    VOID Unload();
    BOOL IsValid(BOOL fCheckIssuerProvider = TRUE);
    DWORD LoadCryptoFromStore(wchar_t const * pwzIssuerName);

    //
    // set properties
    //
    HRESULT SetCRLDP(wchar_t const * const pwzCRLDP)
    {
        return StringCchCopyW(m_wzCrlDP, array_size(m_wzCrlDP), pwzCRLDP);
    }
    HRESULT SetAccessInfoURI(wchar_t const * const pwzAccessInfoURI)
    {
        return StringCchCopyW(m_wzAccessInfoURI, array_size(m_wzAccessInfoURI), pwzAccessInfoURI);
    }



    //
    // Action
    //

    DWORD
    Certify(
        IN      wchar_t const *     pwzSubject,         // Cert subject: CN=...
        IN      BYTE const *        pbPubKey,           // public key to enclose
        IN      DWORD               cbPubKey,           // length of public key
        IN      CASvcExtensions     eFlags,             // specify which cert to create
        IN      FILETIME            dtNotBefore,        // datetime of when the cert should be valid
        IN      FILETIME            dtNotAfter,         // datetime of when the cert should expire
        OUT     LPBYTE              pbCert,             // OUT: certificate buffer handle
        IN OUT  LPDWORD             pcbCert,            // OUT: length of in/out buffer
        IN OUT  GUID *              pSerialNumber);    // OUT: serial number of generated certificate

    DWORD
    Serialize(
        IN      BYTE const *    pCert,              // x509 certificate to serialize
        IN      DWORD           cbCert,             // length of input cert
        IN OUT  LPBYTE          pSerialized,        // pre-allocated ptr to buffer accepting the serialized cert
        IN OUT  LPDWORD         pcbSerialized);     // ptr to length of buffer (if pSerialized == NULL) contains required length

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\CASvc\dll\certify.cpp ===
/*******************************************************************
*
*    DESCRIPTION: cerity.cpp
*
*      Implements functions to create X.509 certificate given
*      a public key blob based on given subordinate certificate
*      chain.
*
*******************************************************************/

// includes
#include "stdafx.h"


//
// File-wide constants.
//


DWORD const XBL_CERT_ISSUER_STORE_FLAGS = (CERT_STORE_OPEN_EXISTING_FLAG | CERT_SYSTEM_STORE_LOCAL_MACHINE);
// BUGBUG: review. Use specific store
wchar_t const * const XBL_CERT_ISSUER_STORE = L"MY";

// certificate properties
DWORD const ENCODING_TYPE = (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING);
WORD const CERT_DURATION_YEARS = 10;
char const * const CLIENT_AUTH_EXT_KEY_USAGE = "1.3.6.1.5.5.7.3.2"; // client authentication oid -- can be client of SSL cert
char const * const MSTV_POLICY_QUALIFIER_OID = "1.3.6.1.4.1.311.53.1.1.2";


//
// debug utilities
//


// alternate debug spew methods by re-defining DBG_OUT
//#define DBG_OUT          printf
#define DBG_OUT          DbgPrint
size_t const MAXSTR =    2048;
#ifndef ASSERT
#define ASSERT           assert
#endif

///////////////////////////////////////////////////////
// Function DbgPrint
//
// Description
//    Helper debug routine (to debug port)
//    Change DBG_OUT above to DbgPrint and it'll dump
//    to debug port, or re-define to use standard xbl
//    tracing (preferred).
//
// Parameters
//
//
// Returns:
//
//
#if DEBUG
void
DbgPrint(char const * const lpszFormat, ...)
{

    char szBuff[MAXSTR];
    va_list argList;

    va_start(argList, lpszFormat);

    (void)StringCbVPrintfA(szBuff, array_size(szBuff), lpszFormat, argList);
    OutputDebugStringA(szBuff);
    OutputDebugStringA("\r\n");

    va_end(argList);
}
#else
void DbgPrint(LPSTR, ...)
{
}
#endif


///////////////////////////////////////////////////////
//
// Generates a Guid that is garaunteed to be a positive
// number in accordance to the documentation here:
// http://msdn.microsoft.com/en-us/library/aa925727.aspx
//

// Given a pointer to a byte, make sure that byte is "positive"
// by the definition of positive in the link above.
// We do nothing on a null pointer.
static void EnsureByteIsPositive(BYTE * const pb)
{
    if (pb == NULL)
    {
        return;
    }

    // clear the first bit.
    *pb &= 0x7F;

    // If clearing the first bit made the byte 0, set the second bit.
    if (*pb == 0)
    {
        *pb = 0x40;
    }
}

// Get a pointer to the last byte of a guid structure
// or null on a null guid pointer.
static BYTE * LastByteOfGuid(GUID * const pGuid)
{
    if (pGuid == NULL)
    {
        return NULL;
    }

    return &(pGuid->Data4[sizeof(pGuid->Data4)-1]);
}

static HRESULT GeneratePositiveGuid(GUID * const pGuid)
{
    if (pGuid == NULL)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    hr = CoCreateGuid(pGuid);
    if (FAILED(hr))
    {
        return hr;
    }

    EnsureByteIsPositive(LastByteOfGuid(pGuid));

    return hr;
}



///////////////////////////////////////////////////////
//
// class CASvc
//


//
// Constructor / destructor
//
CASvc::CASvc() :
    m_hIssuerStore(NULL),
    m_hIssuerProv(NULL),
    m_pIssuerCert(NULL),
    m_pIssuerKeyId(NULL),
    m_hPriKey(NULL),
    m_dwKeyType(AT_SIGNATURE),
    m_fFreeIssuerProv(FALSE)
{
    m_wzCrlDP[0] = L'\0';
    m_wzAccessInfoURI[0] = L'\0';
}

CASvc::~CASvc()
{
    Unload();
}


VOID
CASvc::Unload()
{
    // This is technically wrong for Win2K8. m_hIssuerProv is acquired via CryptAcquireCertificatePrivateKey.
    // According to http://msdn.microsoft.com/en-us/library/aa379885(VS.85).aspx, there are cases where
    // we should call NCryptFreeObject instead of CryptReleaseContext. But since we don't build VS9, we
    // can't use that function. In practice, we will not actually need to use it anyway--that is
    // for a different type of key type.
    if (m_hIssuerProv && m_fFreeIssuerProv)
    {
        (void)CryptReleaseContext(m_hIssuerProv, 0);
        m_fFreeIssuerProv = FALSE;
        m_hIssuerProv = NULL;
    }

    UnloadRootCertificate();

    if (m_hPriKey)
    {
        (void)CryptDestroyKey(m_hPriKey);
        m_hPriKey = NULL;
    }

    delete [] m_pIssuerKeyId;
}


//
// Ensures object is reasonably initialized
//
BOOL
CASvc::IsValid(BOOL const fCheckIssuerProvider /*= TRUE*/)
{

    if (!m_pIssuerCert || (fCheckIssuerProvider && !m_hIssuerProv))
    {
        return FALSE;
    }

    return TRUE;
}


//
// Find Certificate with szCertName in the Subject name
//


///////////////////////////////////////////////////////
// Function LoadRootCertFromStore
//
// Description
//    Finds certificate of issuer name in store and
//    loads it into crypto provider handle
//
// Parameters
//    pwzIssuerName - name of issuing authority certificate
//                    subject name
//
//
DWORD
CASvc::LoadRootCertFromStore(
    IN      wchar_t const * const      pwzIssuerName)
{
    DWORD dwErr = ERROR_SUCCESS;

    m_pIssuerCert = FindCertificate(
                        pwzIssuerName,
                        XBL_CERT_ISSUER_STORE,
                        XBL_CERT_ISSUER_STORE_FLAGS,
                        ENCODING_TYPE);
    if (!m_pIssuerCert)
    {
        dwErr = ERROR_FILE_NOT_FOUND;
        DBG_OUT("Error <0x%x>: Failed to acquire crypto context [%s!%lu]\n", dwErr, __FUNCTION__, __LINE__);
        goto Cleanup;
    }

    dwErr = LoadCertExtensions();
    if (dwErr)
    {
        DBG_OUT("Error <0x%x>: Failed to load cert extensions [%s!%lu]\n", dwErr, __FUNCTION__, __LINE__);
        goto Cleanup;
    }


Cleanup:

    return dwErr;
}


///////////////////////////////////////////////////////
// Function UnloadRootCertificate
//
// Description
//    Cleanup of certificate store from memory
//
void
CASvc::UnloadRootCertificate()
{
    if (m_pIssuerCert)
    {
        CertFreeCertificateContext(m_pIssuerCert);
        m_pIssuerCert = NULL;
    }

    if (m_hIssuerStore)
    {
        CertCloseStore(m_hIssuerStore, CERT_CLOSE_STORE_FORCE_FLAG);
        m_hIssuerStore = NULL;
    }

    delete [] m_pIssuerKeyId;
    m_pIssuerKeyId = NULL;
}


///////////////////////////////////////////////////////
// Function XCrypt2048KeyToCryptoKey
//
// Description
//    Converts Xenon console XCrypt2048 key into native
//    crypto format
//
// Parameters
//  pbXenonKey - Xenon key blob
//  cbXenoneKey - size of key blob
//  pbCryptoKey - pre-allocated length of receiving converted
//                native crypto store key
//  pcbCrytoKey - IN: length of input pbCryptoKey. OUT: actual size
//
//
// Returns:
//  ERROR_MORE_DATA if insufficient buffer size
//  ERROR_SUCCESS if successfull.
//  Win32 error codes
//
//
DWORD
CASvc::XCrypt2048KeyToCryptoKey(
    IN      BYTE const * const      pbXenonKey,
    IN      DWORD const             cbXenonKey,
    IN OUT  BYTE * const            pbCryptoKey,
    IN OUT  DWORD * const           pcbCryptoKey)
{

    if (!pbXenonKey || !cbXenonKey || !pbCryptoKey || !pcbCryptoKey)
    {
        return ERROR_INVALID_PARAMETER;
    }

    bool fErr = CXoCryptoCspPk::ConvertConsoleRSA2048KeyToCspImport(
                        pbXenonKey, cbXenonKey, CXoCryptoCspPk::KeyPurposeSign,
                        pbCryptoKey, pcbCryptoKey);

    return fErr? ERROR_SUCCESS : ERROR_INVALID_DATA;
}


///////////////////////////////////////////////////////
// Function XCryptConsoleKeyToCryptoKey
//
// Description
//    Converts Xenon console key into native
//    crypto format
//
// Parameters
//  pbXenonKey - Xenon key blob
//  cbXenoneKey - size of key blob
//  pbCryptoKey - pre-allocated length of receiving converted
//                native crypto store key
//  pcbCrytoKey - IN: length of input pbCryptoKey. OUT: actual size
//
//
// Returns:
//  ERROR_MORE_DATA if insufficient buffer size
//  ERROR_SUCCESS if successfull.
//  Win32 error codes
//
//
DWORD
CASvc::XCryptConsoleKeyToCryptoKey(
    IN      BYTE const * const      pbConsoleKey,
    IN      DWORD const             cbConsoleKey,
    IN OUT  BYTE * const            pbCryptoKey,
    IN OUT  DWORD * const           pcbCryptoKey)
{

    if (!pbConsoleKey || !cbConsoleKey || !pbCryptoKey || !pcbCryptoKey)
    {
        return ERROR_INVALID_PARAMETER;
    }

    bool fErr = CXoCryptoCspPk::ConvertConsoleKeyToCspImport(
                        pbConsoleKey, cbConsoleKey, CXoCryptoCspPk::KeyPurposeSign,
                        pbCryptoKey, pcbCryptoKey);

    return fErr? ERROR_SUCCESS : ERROR_INVALID_DATA;
}


///////////////////////////////////////////////////////
// Function LoadPrivateKeyFromStore
//
// Description
//    Loads the private key from installed cert in store
//    DEPENDENCY: Cert must be loaded first (m_pIssuerCert)!
//
// Parameters
//
//
// Returns:
//
//
DWORD
CASvc::LoadPrivateKeyFromStore()
{
    BOOL fErr = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwKeyType = m_dwKeyType;
    BOOL fFreeProv = FALSE;

    if (!IsValid(FALSE))
    {
        return ERROR_NOT_READY;
    }

    // Get Crypto Context of Certificate
    fErr = CryptAcquireCertificatePrivateKey(
                               m_pIssuerCert,
                               CRYPT_ACQUIRE_SILENT_FLAG,
                               NULL,
                               &m_hIssuerProv,
                               &dwKeyType,
                               &fFreeProv);
    if (!fErr)
    {
        dwErr = GetLastError();
        DBG_OUT("Error <0x%x>: Failed to get certificate context handle\n", dwErr);
        goto Cleanup;
    }

    m_dwKeyType = dwKeyType;
    m_fFreeIssuerProv = fFreeProv;

Cleanup:

    return dwErr;
}


///////////////////////////////////////////////////////
// Function LoadCryptoFromStore
//
// Description
//    Loads crypto subsystem data from store (cert & key).
//    Essentially initialization entry point.
//
// Parameters
//    pwzIssuerName - subject name of issuer authority
//
//
// Returns:
//    win32 error code space (mostly cryto)
//
//
DWORD
CASvc::LoadCryptoFromStore(
    IN      wchar_t const * const      pwzIssuerName)
{
    DWORD dwErr = ERROR_SUCCESS;

    // Disable multiple loads.
    if (IsValid())
    {
        DBG_OUT("Error: Unexpected Reinitialization of CASvc.");
        ASSERT(!"Error: Unexpected Reinitialization of CASvc.");
        dwErr = ERROR_ALREADY_INITIALIZED;
        goto Cleanup;
    }

    // load certificate
    dwErr = LoadRootCertFromStore(pwzIssuerName);
    if (dwErr)
    {
        DBG_OUT("Error <0x%x>: Failed to load cert from store [%s!%lu]\n", dwErr, __FUNCTION__, __LINE__);
        goto Cleanup;
    }


    // load private key
    dwErr = LoadPrivateKeyFromStore();
    if (dwErr)
    {
        DBG_OUT("Error <0x%x>: Failed to load pri key from store [%s!%lu]\n", dwErr, __FUNCTION__, __LINE__);
        goto Cleanup;
    }

Cleanup:

    return dwErr;
}


///////////////////////////////////////////////////////
// Function LoadCertExtensions
//
// Description
//    Loads certificate extensions. Essentially issuer
//    authority id & related info that should be done
//    only at initialization
//
//
DWORD
CASvc::LoadCertExtensions()
{
    PCERT_EXTENSION pExtension = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    BOOL  fErr = FALSE;
    DWORD dwSize = 0;
    PCRYPT_DATA_BLOB pKeyId = NULL;

    if (!IsValid(FALSE))
    {
        DBG_OUT("Error: unexpected call in [%s!%lu]\n", __FUNCTION__, __LINE__);
        return ERROR_NOT_READY;
    }

    // Find Subject Key Identifier Extension
    pExtension = CertFindExtension(
                        szOID_SUBJECT_KEY_IDENTIFIER,
                        m_pIssuerCert->pCertInfo->cExtension,
                        m_pIssuerCert->pCertInfo->rgExtension);

    if (pExtension == NULL)
    {
        dwErr = ERROR_NOT_FOUND;
        DBG_OUT("Error <0x%x>: Certificate doesn't have expected extension subject key identifier\n");
        goto Cleanup;
    }

    // Get Size of Data Blob
    fErr = CryptDecodeObject(
                    ENCODING_TYPE,
                    szOID_SUBJECT_KEY_IDENTIFIER,
                    pExtension->Value.pbData,
                    pExtension->Value.cbData,
                    0, NULL, &dwSize);
    if (!fErr)
    {
        dwErr = GetLastError();
        DBG_OUT("Error <0x%x>: Failed to get extension for key identifier\n", dwErr);
        goto Cleanup;
    }

    // Allocate Data Blob
    pKeyId = (PCRYPT_DATA_BLOB) new BYTE[dwSize];
    if (!pKeyId)
    {
        dwErr = GetLastError();
        DBG_OUT("Error <0x%x>: Failed to allocate memory for key identifier extension\n", dwErr);
        goto Cleanup;
    }

    // Get Key Identifier Data Blob
    fErr = CryptDecodeObject(ENCODING_TYPE,
                             szOID_SUBJECT_KEY_IDENTIFIER,
                             pExtension->Value.pbData,
                             pExtension->Value.cbData,
                             0, (LPVOID)pKeyId, &dwSize);
    if (!fErr)
    {
        dwErr = GetLastError();
        DBG_OUT("Error <0x%x>: Failed to get key identifier extension\n", dwErr);
        goto Cleanup;
    }

    // Hand the pointer off to our member variable.
    if (pKeyId)
        {
        m_pIssuerKeyId = pKeyId;
        pKeyId = NULL;
        }

Cleanup:

    delete[] pKeyId;

    return dwErr;

}

DWORD EncodeAndAssignExtension(
    LPCSTR lpszStructType,
    const void* pvStructInfo,
    LPSTR pszObjId,
    CERT_EXTENSION *pCertExtension)
{
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fErr;

    LPBYTE pbEncoded = NULL;
    DWORD dwEncoded = 0;

    // Get Authority Key Id blob size
    fErr = CryptEncodeObjectEx(ENCODING_TYPE,
                            lpszStructType,
                            pvStructInfo,
                            CRYPT_ENCODE_ALLOC_FLAG,
                            NULL,
                            (LPVOID)&pbEncoded, &dwEncoded);
    if (!fErr)
    {
      dwErr = GetLastError();
      goto Cleanup;
    }

    // Set Extension
    pCertExtension->pszObjId = pszObjId;
    pCertExtension->fCritical = FALSE;
    pCertExtension->Value.cbData = dwEncoded;
    pCertExtension->Value.pbData = pbEncoded;

Cleanup:
    return dwErr;
}

#define CONSOLE_PUBLIC_KEY_EXPONENT_SIZE    4
#define CONSOLE_PUBLIC_KEY_MODULUS_SIZE     128
///////////////////////////////////////////////////////
// Function Certify
//
// Description
//    Given a data blob, return a certificate that authenticate
//    the blob
//
// Parameters
//    pwzSubject - Name of certificate subject (should be the client GUID)
//    pbData - data to "notarize" with certificate (the client public key)
//    cbData - size of pbData
//    eFlags - Flags that specify the cert request details such as:
//    dtNotBefore - the datetime the certificate starts being valid
//    dtNotAfter - the expiration datetime of the certificate
//    pbCert - A pointer to a pre-allocated buffer.
//            If not sufficient will return error.
//    pcbCert - IN: Length of buffer. OUT: Returned certificate length.
//    pSerialNumber - a ptr to stack GUID param
//
//
// Returns:
//   ERROR_SUCCESS   - if good
//   ERROR_INVALID_PARAMETER - invalid parameter
//   ERROR_MORE_DATA -  if buffer length is insufficient. pcbCert contains desired length
//   Other standard Win32 error codes
//
//
DWORD
CASvc::Certify(
    IN      wchar_t const * const      pwzSubject,
    IN      BYTE const * const         pbPubKey,
    IN      DWORD const                cbPubKey,
    IN      CASvcExtensions const      eFlags,
    IN      FILETIME                   dtNotBefore,
    IN      FILETIME                   dtNotAfter,
    OUT     BYTE * const               pbCert,
    IN OUT  DWORD * const              pcbCert,
    IN OUT  GUID * const               pSerialNumber)
{

    // general variables

    DWORD           dwErr     = ERROR_SUCCESS;
    HRESULT         hr        = S_OK;
    BOOL            fErr      = FALSE;
    DWORD           dwSize    = 0;

    // certificate data

    HCRYPTHASH                  hHash = 0;
    CERT_INFO                   CertInfo = {0};

    // cert props
    CERT_NAME_BLOB              SubjectName = {0};
    LPBYTE                      pbSubject    = NULL;
    LPBYTE                      pbPublicKeyInfo = NULL;
    DWORD                       cbPublicKeyInfo = 0;
    GUID                        SerialNumber = GUID_NULL;

    // cert exts
    const UINT                  cExts = 10;
    CERT_EXTENSION  CertExtension[cExts];
    CERT_AUTHORITY_KEY_ID_INFO  AuthorityKeyId = {0};
    LPBYTE                      pbKeyIdentifier = NULL;
    CRYPT_DATA_BLOB             CertKeyIdentifier = {0};
    BYTE                        ByteData = 0;
    CRYPT_BIT_BLOB              KeyUsage = {0};


    const UINT                  cMaxPubKey = 512;
    BYTE                        PubKeyBuffer[cMaxPubKey];
    DWORD                       cbPubKeyBuffer = cMaxPubKey;



    //
    // Params check
    //

    if (!pwzSubject || !pbPubKey || !cbPubKey ||
        !pbCert || !pcbCert || !pSerialNumber)
    {
        DBG_OUT("Error: Invalid parameters\n");
        return ERROR_INVALID_PARAMETER;
    }

    if (!IsValid())
    {
        DBG_OUT("Error: CASvc is not initialized\n");
        return ERROR_NOT_READY;
    }

    //
    // Encode Subject Name
    //

    // Alloc memory for name
    fErr = CertStrToName(ENCODING_TYPE,
                         pwzSubject,
                         CERT_X500_NAME_STR,
                         NULL,
                         NULL,
                         &dwSize, NULL);
    if (!fErr || !dwSize)
    {
        dwErr = GetLastError();
        if (!dwErr)
        {
            dwErr = ERROR_OUTOFMEMORY;
        }
        DBG_OUT("Error <0x%x>: Failed to get memory for X500 Cert name (%ls)\n", dwErr, pwzSubject);
        goto Cleanup;
    }

    pbSubject = new BYTE[dwSize];
    ZeroMemory(pbSubject, dwSize);

    LPCWSTR pDbgErr = NULL;
    // Encode name
    fErr = CertStrToName(ENCODING_TYPE,
                         pwzSubject,
                         CERT_X500_NAME_STR,
                         NULL,
                         pbSubject,
                         &dwSize,
                         &pDbgErr);
    if (!fErr)
    {
        dwErr = GetLastError();
        DBG_OUT("Error <0x%x>: Failed to encode X500 Cert name at %ls. (%ls)\n", dwErr, pDbgErr, pwzSubject);
        goto Cleanup;
    }

    SubjectName.cbData = dwSize;
    SubjectName.pbData = pbSubject;

    ZeroMemory(&PubKeyBuffer, cMaxPubKey);
    
    if ( cbPubKey == CONSOLE_PUBLIC_KEY_EXPONENT_SIZE + CONSOLE_PUBLIC_KEY_MODULUS_SIZE ) //sizeof(CONSOLE_PUBLIC_KEY)
    {
        dwErr = XCryptConsoleKeyToCryptoKey(pbPubKey, cbPubKey, PubKeyBuffer,  &cbPubKeyBuffer);
    }
    else //if ( cbPubKey == sizeof(XECRYPT_RSAPUB_2048) )
    {
        dwErr = XCrypt2048KeyToCryptoKey(pbPubKey, cbPubKey, PubKeyBuffer,  &cbPubKeyBuffer);
    }
    //else
    //    dwErr = ERROR_INVALID_DATA;
    
    if (dwErr)
    {
        DBG_OUT("Error <0x%x>: query for publickeyinfo failed\n", dwErr);
        goto Cleanup;
    }

    // Encode public key
    fErr = CryptEncodeObjectEx(ENCODING_TYPE,
                               RSA_CSP_PUBLICKEYBLOB,
                               (LPVOID)&PubKeyBuffer,
                               CRYPT_ENCODE_ALLOC_FLAG, NULL,
                               &pbPublicKeyInfo, &cbPublicKeyInfo);
    if (!fErr)
    {
        dwErr = GetLastError();
        DBG_OUT("Error <0x%x>: CryptEncodeObject() for RSA_CSP_PUBLICKEYBLOB failed\n", dwErr);
        goto Cleanup;
    }

   // Create Random Serial Number
   hr = GeneratePositiveGuid(&SerialNumber);
   if (FAILED(hr))
   {
       dwErr = hr;
       DBG_OUT("Error <0x%X>: Failed to create crypto random\n", dwErr);
       goto Cleanup;
   }

   //
   // set certificate properties
   //

   // Set Version of Certificate
   CertInfo.dwVersion = CERT_V3;

   // Serial Number
   CertInfo.SerialNumber.cbData = sizeof(SerialNumber);
   CertInfo.SerialNumber.pbData = (LPBYTE)&SerialNumber;
   *pSerialNumber = SerialNumber;

   // Signature algorithm
   CertInfo.SignatureAlgorithm.pszObjId = szOID_RSA_SHA1RSA;


   // Subject
   CertInfo.Subject = SubjectName;

   // Issuer
   CertInfo.Issuer = m_pIssuerCert->pCertInfo->Subject;

   // set validity duration

   //Not Before
   CertInfo.NotBefore = dtNotBefore;

   // Not After
   CertInfo.NotAfter = dtNotAfter;

   // Public Key info from client
   CertInfo.SubjectPublicKeyInfo.Algorithm.pszObjId = szOID_RSA_RSA;
   CertInfo.SubjectPublicKeyInfo.PublicKey.cbData = cbPublicKeyInfo;
   CertInfo.SubjectPublicKeyInfo.PublicKey.pbData = pbPublicKeyInfo;


   //
   // Extensions
   //

   ZeroMemory(CertExtension, sizeof(CertExtension));

   //
   // AuthorityKeyId
   //

   CopyMemory(&AuthorityKeyId.KeyId, m_pIssuerKeyId, sizeof(AuthorityKeyId.KeyId));
   AuthorityKeyId.CertIssuer = m_pIssuerCert->pCertInfo->Issuer;
   AuthorityKeyId.CertSerialNumber = m_pIssuerCert->pCertInfo->SerialNumber;

   // Get Authority Key Id blob size
   dwErr = EncodeAndAssignExtension(
       X509_AUTHORITY_KEY_ID,
       (LPVOID)&AuthorityKeyId,
       szOID_AUTHORITY_KEY_IDENTIFIER,
       &CertExtension[CertInfo.cExtension]);

   if (dwErr != ERROR_SUCCESS)
   {
      DBG_OUT("Error <0x%x>: query for AuthorityKeyId failed\n", dwErr);
      goto Cleanup;
   }

   // Increase extension count
   CertInfo.cExtension++;

   //
   // public key identifier extension
   //

   // Create Hash
   fErr = CryptCreateHash(m_hIssuerProv, CALG_SHA1, 0, 0, &hHash);
   if (!fErr)
   {
       dwErr = GetLastError();
       DBG_OUT("Error <0x%x>: CryptCreateHash() size calc failed\n", dwErr);
       goto Cleanup;
   }

   // Hash Public Key Info
   dwSize = CertInfo.SubjectPublicKeyInfo.PublicKey.cbData;
   fErr = CryptHashData(hHash, (LPBYTE)&(CertInfo.SubjectPublicKeyInfo.PublicKey.pbData), dwSize, 0);
   if (!fErr)
   {
       dwErr = GetLastError();
       DBG_OUT("Error <0x%x>: CryptHashData() size calc failed\n", dwErr);
       goto Cleanup;
   }

   // Get Size of Hash
   fErr = CryptGetHashParam(hHash, HP_HASHVAL, NULL, &dwSize, 0);
   if (!fErr)
   {
   }

   // Allocate Memory for Key Identifier (hash of Public Key info)
   pbKeyIdentifier = (LPBYTE)new BYTE[dwSize];
   if (!pbKeyIdentifier)
   {
       dwErr = GetLastError();
       DBG_OUT("Error <0x%x>: memory allocation failed for pbKeyIdentifier\n", dwErr);
       goto Cleanup;
   }

   // Get Hash of Public Key Info
   fErr = CryptGetHashParam(hHash, HP_HASHVAL, pbKeyIdentifier, &dwSize, 0);
   if (!fErr)
   {
       dwErr = GetLastError();
       DBG_OUT("Error <0x%x>: CryptGetHashParam for pbKeyIdentifier\n", dwErr);
       goto Cleanup;
   }

   // We will use this to set the Key Identifier extension
   CertKeyIdentifier.cbData = dwSize;
   CertKeyIdentifier.pbData = pbKeyIdentifier;


   // Assign Subject Key Identifier Extension
   dwErr = EncodeAndAssignExtension(
        szOID_SUBJECT_KEY_IDENTIFIER,
        (LPVOID)&CertKeyIdentifier,
        szOID_SUBJECT_KEY_IDENTIFIER,
        &CertExtension[CertInfo.cExtension]);

   if (dwErr != ERROR_SUCCESS)
   {
       DBG_OUT("Error <0x%x>: ...(%s!%lu)\n", dwErr, __FUNCTION__, __LINE__);
       goto Cleanup;
   }

   // Increase extension count
   CertInfo.cExtension++;


   //
   // Set Key Usage
   //

   ZeroMemory(&KeyUsage, sizeof(KeyUsage));
   KeyUsage.cbData = 1;
   ByteData = CERT_DIGITAL_SIGNATURE_KEY_USAGE |
              CERT_DATA_ENCIPHERMENT_KEY_USAGE|
              CERT_KEY_ENCIPHERMENT_KEY_USAGE;
   KeyUsage.pbData = &ByteData;

   dwErr = EncodeAndAssignExtension(
        X509_KEY_USAGE,
        (LPVOID)&KeyUsage,
        szOID_KEY_USAGE,
        &CertExtension[CertInfo.cExtension]);

   if (dwErr != ERROR_SUCCESS)
   {
       DBG_OUT("Error <0x%x>: ...(%s!%lu)\n", dwErr, __FUNCTION__, __LINE__);
       goto Cleanup;
   }

   // Increase extension count
   CertInfo.cExtension++;

   //
   // Set authorityInformationAccess
   //

   if (!IsStringNullOrEmpty(m_wzAccessInfoURI))
   {
       CERT_ACCESS_DESCRIPTION     AccessDesc;
       CERT_AUTHORITY_INFO_ACCESS  AuthInfoAccess;

       ZeroMemory(&AccessDesc, sizeof(AccessDesc));
       ZeroMemory(&AuthInfoAccess, sizeof(AuthInfoAccess));

       AccessDesc.pszAccessMethod = szOID_PKIX_OCSP;
       AccessDesc.AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
       AccessDesc.AccessLocation.pwszURL = m_wzAccessInfoURI;

       AuthInfoAccess.cAccDescr = 1;
       AuthInfoAccess.rgAccDescr = &AccessDesc;

       dwErr = EncodeAndAssignExtension(
            X509_AUTHORITY_INFO_ACCESS,
            (LPVOID)&AuthInfoAccess,
            szOID_AUTHORITY_INFO_ACCESS,
            &CertExtension[CertInfo.cExtension]);

       if (dwErr != ERROR_SUCCESS)
       {
           DBG_OUT("Error <0x%x>: ...(%s!%lu)\n", dwErr, __FUNCTION__, __LINE__);
           goto Cleanup;
       }

       // Increase extension count
       CertInfo.cExtension++;
   }

   //
   // Extended Key Usage
   //

   // Extended key usage is only mandatory for auth cert
   if (eFlags & ClientAuthentication)
   {
        CERT_ENHKEY_USAGE           CertEnhKeyUsage;
       //
       // Non-AV only extensions
       //

       LPSTR pszTmp = const_cast<LPSTR>(CLIENT_AUTH_EXT_KEY_USAGE);

       CertEnhKeyUsage.cUsageIdentifier = 1;
       CertEnhKeyUsage.rgpszUsageIdentifier = &pszTmp;

       dwErr = EncodeAndAssignExtension(
            X509_ENHANCED_KEY_USAGE,
            (LPVOID)&CertEnhKeyUsage,
            szOID_ENHANCED_KEY_USAGE,
            &CertExtension[CertInfo.cExtension]);

       if (dwErr != ERROR_SUCCESS)
       {
           DBG_OUT("Error <0x%x>: ...(%s!%lu)\n", dwErr, __FUNCTION__, __LINE__);
           goto Cleanup;
       }

       // Increase extension count
       CertInfo.cExtension++;
   }

   if (eFlags & MstvAVPolicy)
   {
        CERT_POLICIES_INFO          CertPolicies;
        CERT_POLICY_INFO            PolicyInfo;
       //
       // AV only extensions
       //

       //
       // Set certificatePolicies
       //

       ZeroMemory(&CertPolicies, sizeof(CertPolicies));
       ZeroMemory(&PolicyInfo, sizeof(PolicyInfo));

       // there are no Policy qualifiers
       // PolicyInfo.cPolicyQualifier = 0;
       PolicyInfo.pszPolicyIdentifier = const_cast<LPSTR>(MSTV_POLICY_QUALIFIER_OID);


       CertPolicies.cPolicyInfo = 1;
       CertPolicies.rgPolicyInfo = &PolicyInfo;


       dwErr = EncodeAndAssignExtension(
            X509_CERT_POLICIES,
            (LPVOID)&CertPolicies,
            szOID_CERT_POLICIES,
            &CertExtension[CertInfo.cExtension]);

       if (dwErr != ERROR_SUCCESS)
       {
           DBG_OUT("Error <0x%x>: ...(%s!%lu)\n", dwErr, __FUNCTION__, __LINE__);
           goto Cleanup;
       }

       // Increase extension count
       CertInfo.cExtension++;
   }

   //
   // CRL extension
   //
   if (!IsStringNullOrEmpty(m_wzCrlDP))
   {
       CERT_ALT_NAME_ENTRY         CrlEntry;

       ZeroMemory(&CrlEntry, sizeof(CrlEntry));
       CrlEntry.dwAltNameChoice = CERT_ALT_NAME_URL;
       CrlEntry.pwszURL = m_wzCrlDP;

       CRL_DIST_POINTS_INFO        DispPointInfo;
       CRL_DIST_POINT              DispPoint;

       ZeroMemory(&DispPoint, sizeof(DispPoint));
       DispPoint.DistPointName.dwDistPointNameChoice = CRL_DIST_POINT_FULL_NAME;
       DispPoint.DistPointName.FullName.cAltEntry = 1;
       DispPoint.DistPointName.FullName.rgAltEntry = &CrlEntry;

       DispPointInfo.cDistPoint = 1;
       DispPointInfo.rgDistPoint = &DispPoint;

       dwErr = EncodeAndAssignExtension(
            X509_CRL_DIST_POINTS,
            &DispPointInfo,
            szOID_CRL_DIST_POINTS,
            &CertExtension[CertInfo.cExtension]);

       if (dwErr != ERROR_SUCCESS)
       {
           DBG_OUT("Error <0x%x>: ...(%s!%lu)\n", dwErr, __FUNCTION__, __LINE__);
           goto Cleanup;
       }

       // Increase extension count
       CertInfo.cExtension++;
   }

   CertInfo.rgExtension = CertExtension;


   //
   // Finally - Sign and encode certificate
   // Manual Sign and encode based on given private key
   //

   dwErr = SignAndEncodeCertificate(CertInfo, pbCert, pcbCert);
   if (dwErr)
   {
       DBG_OUT("Error <0x%x>: Failed to sign/encode certificate(%s!%lu)\n", dwErr, __FUNCTION__, __LINE__);
       goto Cleanup;
   }


Cleanup:

    if (dwErr)
    {
        DBG_OUT("Error<0x%x>: %s failed\n", dwErr, __FUNCTION__);
    }

    // Free all of the allocated extensions, because default CAPI allocator uses LocalAlloc
    for (DWORD i = 0; i < CertInfo.cExtension; i++)
    {
        LocalFree(CertExtension[i].Value.pbData);
    }
    CryptDestroyHash(hHash);
    delete [] pbSubject;
    LocalFree(pbPublicKeyInfo);
    delete [] pbKeyIdentifier;

    return dwErr;
}


///////////////////////////////////////////////////////
// Function SignAndEncodeCertificate
//
// Description
//    Sign/encode certificate using crypto high level api
//
// Parameters
//    see function version above.
//
//
// Returns:
//   Win32 error codes (most likely from Crypto)
//
//
DWORD
CASvc::SignAndEncodeCertificate(
    IN      CERT_INFO       CertInfo,
    OUT     BYTE * const    pbCert,
    IN OUT  DWORD * const   pcbCert
    )
{
    DWORD dwErr          = ERROR_SUCCESS;
    BOOL  fErr           = FALSE;
    LPBYTE pbEncodedCert = NULL;
    DWORD  dwSize        = 0;

    // Get Encoded Certificate Size
    dwSize = 0;
    fErr = CryptSignAndEncodeCertificate(m_hIssuerProv, m_dwKeyType,
                                         ENCODING_TYPE, X509_CERT_TO_BE_SIGNED,
                                         (LPVOID)&CertInfo,
                                         &(m_pIssuerCert->pCertInfo->SignatureAlgorithm),
                                         NULL, NULL, &dwSize);
    if (!fErr || !dwSize)
    {
        dwErr = !fErr ? GetLastError() : ERROR_INVALID_PARAMETER;
        DBG_OUT("Error <0x%x>: ...(%s!%lu)\n", dwErr, __FUNCTION__, __LINE__);
        goto Cleanup;
    }

    if (dwSize > *pcbCert)
    {
        *pcbCert = dwSize;
        dwErr = ERROR_MORE_DATA;
        goto Cleanup;

    }

    // Allocate memory for encoded certificate
    pbEncodedCert = (LPBYTE) new BYTE[dwSize];
    if (!pbEncodedCert)
    {
        dwErr = GetLastError();
        DBG_OUT("Error <0x%x>: ...(%s!%lu)\n", dwErr, __FUNCTION__, __LINE__);
        goto Cleanup;
    }
    ZeroMemory(pbEncodedCert, dwSize);

    // Sign and Encode certificate
    fErr = CryptSignAndEncodeCertificate(m_hIssuerProv, m_dwKeyType,
                                         ENCODING_TYPE, X509_CERT_TO_BE_SIGNED,
                                         (LPVOID)&CertInfo,
                                         &(m_pIssuerCert->pCertInfo->SignatureAlgorithm),
                                         NULL, pbEncodedCert, &dwSize);

    if (!fErr)
    {
        dwErr = GetLastError();
        DBG_OUT("Error <0x%x>: ...(%s!%lu)\n", dwErr, __FUNCTION__, __LINE__);
        goto Cleanup;
    }
    else
    {
        DBG_OUT("Created Certificate (len=%lu).\n", dwSize);
        *pcbCert = dwSize;
        CopyMemory(pbCert, pbEncodedCert, dwSize);
    }

Cleanup:

    delete [] pbEncodedCert;

    return dwErr;
}


///////////////////////////////////////////////////////
// Function Serialize
//
// Description
//    Given an encoded certificate uses crypto api to
//    convert it to serialized form.
//    (needed by carbon client)
//
// Parameters
//    pCert - encoded cert
//    cbCert - size in bytes of cert buffer
//    pSerialized - buffer for serialized cert
//    cbSerialized - length of serialized buffer
//
//
// Returns:
//    ERROR_MORE_DATA  - buffer is too small
//    ERROR_SUCCESS    - no error
//    Win32 error code space (mostly crypto)
//
//
DWORD
CASvc::Serialize(
    IN      BYTE const * const  pCert,
    IN      DWORD const         cbCert,
    IN OUT  BYTE * const        pSerialized,
    IN OUT  DWORD * const       pcbSerialized )
{
    DWORD dwErr          = ERROR_SUCCESS;
    BOOL  fErr           = FALSE;
    DWORD  dwSize        = 0;
    HCERTSTORE  hStore   = NULL;
    PCCERT_CONTEXT pContext = NULL;

    //
    // parameters check
    //
    if (!pCert || !cbCert || !pSerialized || !pcbSerialized)
    {
        return ERROR_INVALID_PARAMETER;
    }


    //
    // Open a temporary store.
    //
    hStore = CertOpenStore(
                    CERT_STORE_PROV_MEMORY,
                    ENCODING_TYPE,
                    NULL,
                    CERT_STORE_CREATE_NEW_FLAG, NULL);
    if (!hStore)
    {
        dwErr = GetLastError();
        DBG_OUT("Error <0x%x>: failed to open cert store(%s!%lu)\n", dwErr, __FUNCTION__, __LINE__);
        goto Cleanup;
    }

    //
    // Add the encoded certificate to the store.
    //
    fErr = CertAddEncodedCertificateToStore(
                    hStore,
                    X509_ASN_ENCODING,
                    pCert,
                    cbCert,
                    CERT_STORE_ADD_NEW,
                    &pContext);

    if (!fErr)
    {
        dwErr = GetLastError();
        DBG_OUT("Error <0x%x>: failed to add cert to tmp store (%s!%lu)\n", dwErr, __FUNCTION__, __LINE__);
        goto Cleanup;
    }

    //
    // Serialize the certificate from the store.
    //
    fErr = CertSerializeCertificateStoreElement(
                   pContext,
                   0,
                   NULL,
                   &dwSize);

    if (!fErr)
    {
        dwErr = !dwSize ? ERROR_OUTOFMEMORY : GetLastError();
        DBG_OUT("Error <0x%x>: failed to add cert to tmp store (%s!%lu)\n", dwErr, __FUNCTION__, __LINE__);
        goto Cleanup;
    }

    if (dwSize > *pcbSerialized)
    {
        *pcbSerialized = dwSize;
        dwErr = ERROR_MORE_DATA;
        goto Cleanup;
    }

    fErr = CertSerializeCertificateStoreElement(
                    pContext,
                    0,
                    pSerialized,
                    &dwSize);



    if (!fErr)
    {
        dwErr = GetLastError();
        DBG_OUT("Error <0x%x>: failed to serialize certificate (%s!%lu)\n", dwErr, __FUNCTION__, __LINE__);
        goto Cleanup;
    }
    else
    {
        *pcbSerialized = dwSize;
    }

Cleanup:

    // Clean up
    if (hStore)
    {
        CertCloseStore(hStore, 0);
    }


    if (pContext)
    {
        CertFreeCertificateContext(pContext);
    }

    return dwErr;
}



///////////////////////////////////////////////////////
// Function LoadFile
//
// Description
//    Yet another ReadFile shelling function. A helper
//    that isn't used currently but could for UT.
//
//
DWORD
CASvc::LoadFile(
    IN      wchar_t const * const   pwzFile,
    IN OUT  BYTE * const            pbBuffer,
    IN OUT  UINT * const            pcbBuffer)
{
    DWORD dwErr = ERROR_SUCCESS;
    BOOL  fErr = FALSE;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    DWORD   dwSize = 0;

    //
    //  Create the file
    //

    hFile = CreateFile(
                pwzFile,
                GENERIC_READ,
                0,
                NULL,
                OPEN_EXISTING,
                0,
                NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        dwErr = GetLastError();
        DBG_OUT("Error <%lu>: failed to create file %ls\n", dwErr, pwzFile);
        goto Cleanup;
    }

    //
    //  Get the file size in cbBlobLen
    //

    dwSize = GetFileSize(hFile, NULL);
    if(!pbBuffer || dwSize > *pcbBuffer )
    {
        *pcbBuffer = dwSize;
        dwErr = ERROR_MORE_DATA;
        DBG_OUT("Warning <%lu>: Buffer too small (%lu)\n", dwSize);
        goto Cleanup;
    }

    //
    //  Read blob from file
    //

    fErr = ReadFile(
                hFile,
                pbBuffer,
                *pcbBuffer,
                &dwSize,
                NULL);
    if (!fErr)
    {
        dwErr = GetLastError();
        DBG_OUT("Error<%lu>: failed to read file %ls\n", dwErr, pwzFile);
        goto Cleanup;
    }

    *pcbBuffer = dwSize;

Cleanup:

    if(hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\CASvc\dll\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include <windows.h>
#include <assert.h>
#include <strsafe.h>

// defined but not used for cryptohelper.h include
struct XKERB_PA_XBOX_PPA;

// for console to xbl pubkey conversion helper routine
#include "cryptohelper.h"

// declarations (for this project)
#include "certify.h"
#include "casvc.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\CASvc\dll\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_casvc_none_12.4.56.0_none_e9d57445cfef03be
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_casvc_no-public-key_12.4.56.0_x-ww_5ac442b8
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=casvc
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_casvc_no-public-key_12.4.56.0_x-ww_5ac442b8
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_casvc_no-public-key_12.4.56.0_x-ww_5ac442b8.manifest
XP_MANIFEST_PATH=manifests\x86_casvc_no-public-key_12.4.56.0_x-ww_5ac442b8.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_casvc_no-public-key_12.4.56.0_x-ww_5ac442b8.cat
XP_CATALOG_PATH=manifests\x86_casvc_no-public-key_12.4.56.0_x-ww_5ac442b8.cat
XP_PAYLOAD_PATH=x86_casvc_no-public-key_12.4.56.0_x-ww_5ac442b8
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=casvc,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\CASvc\dll\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_casvc_none_12.4.56.0_none_e9d57445cfef03be
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_casvc_no-public-key_12.4.56.0_x-ww_5ac442b8
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=casvc
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_casvc_no-public-key_12.4.56.0_x-ww_5ac442b8
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_casvc_no-public-key_12.4.56.0_x-ww_5ac442b8.manifest
XP_MANIFEST_PATH=manifests\x86_casvc_no-public-key_12.4.56.0_x-ww_5ac442b8.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_casvc_no-public-key_12.4.56.0_x-ww_5ac442b8.cat
XP_CATALOG_PATH=manifests\x86_casvc_no-public-key_12.4.56.0_x-ww_5ac442b8.cat
XP_PAYLOAD_PATH=x86_casvc_no-public-key_12.4.56.0_x-ww_5ac442b8
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=casvc,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\CASvc\test\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_casvccmd_none_12.4.56.0_none_0fd9127065e7a588
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_casvccmd_no-public-key_12.4.56.0_x-ww_6d42372e
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=casvccmd
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_casvccmd_no-public-key_12.4.56.0_x-ww_6d42372e
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_casvccmd_no-public-key_12.4.56.0_x-ww_6d42372e.manifest
XP_MANIFEST_PATH=manifests\x86_casvccmd_no-public-key_12.4.56.0_x-ww_6d42372e.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_casvccmd_no-public-key_12.4.56.0_x-ww_6d42372e.cat
XP_CATALOG_PATH=manifests\x86_casvccmd_no-public-key_12.4.56.0_x-ww_6d42372e.cat
XP_PAYLOAD_PATH=x86_casvccmd_no-public-key_12.4.56.0_x-ww_6d42372e
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=casvccmd,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\CASvc\test\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_casvccmd_none_12.4.56.0_none_0fd9127065e7a588
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_casvccmd_no-public-key_12.4.56.0_x-ww_6d42372e
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=casvccmd
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_casvccmd_no-public-key_12.4.56.0_x-ww_6d42372e
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_casvccmd_no-public-key_12.4.56.0_x-ww_6d42372e.manifest
XP_MANIFEST_PATH=manifests\x86_casvccmd_no-public-key_12.4.56.0_x-ww_6d42372e.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_casvccmd_no-public-key_12.4.56.0_x-ww_6d42372e.cat
XP_CATALOG_PATH=manifests\x86_casvccmd_no-public-key_12.4.56.0_x-ww_6d42372e.cat
XP_PAYLOAD_PATH=x86_casvccmd_no-public-key_12.4.56.0_x-ww_6d42372e
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=casvccmd,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\CASvc\test\main.cpp ===
/*******************************************************************
*
*    DESCRIPTION: main.cpp
*                 Test engine for several ways to create a certificate
*                   - Generate a cert request from microsoft CA
*                   - Use sample code to create a cert w/ cmd line params
*                     on the fly.
*                   - modified sample to set for base for XBL CA code (i.e. unit test)
*
*    AUTHOR:
*
*    HISTORY:
*
*    DATE:1/29/2007
*
*******************************************************************/

#include <windows.h>
#include <strsafe.h>
#include "..\dll\certify.h"
#include "..\dll\casvc.h"


//
// Unit test for certify.cpp
//
wchar_t const * const XBL_CERT_ISSUER_NAME_TEST =   L"Test Xbox Sub-CA 006";
//wchar_t const * const XBL_CERT_ISSUER_NAME_TEST =   L"int-net.xboxlive.com";
wchar_t const * const XBL_CRL_DIST_POINT_TEST =     L"http://crl.microsoft.com/pki/crl/products/MicrosoftTestIPTVeCA.crl";
wchar_t const * const XBL_ACCESS_INFO_URI_TEST =    L"http://PLACEHOLDER.xbox.microsoft.com/xbl/pki/TestXboxSubCA006Public.cer";


//
// Utility function to dump certificate (add .cer to file name)
// blob to file.
//
DWORD WriteBufferToFile(wchar_t const * const pFileName, BYTE * const pBuffer, DWORD const dwSize)
{
    DWORD dwErr = ERROR_SUCCESS;
    WCHAR szName[128];
    DWORD dwWritten=0;
    BOOL fResult = TRUE;

    // create file name
    StringCchCopy(szName, ARRAYSIZE(szName), pFileName);

    // create file
    HANDLE hFile = CreateFile(szName,
                              GENERIC_WRITE,
                              0,
                              NULL,
                              CREATE_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        dwErr = GetLastError();
        printf("Error <%lu>: Failed to CreateFile %ls\n", dwErr, szName);
    }
    else
    {
        // Write PFX blob to file
        fResult = WriteFile(hFile, (LPVOID)pBuffer, dwSize, &dwWritten, NULL);
        if (!fResult)
        {
            dwErr = GetLastError();
            printf("Error <%lu>: Failed to WriteFile %ls\n", dwErr, szName);
        }
        else
        {
            printf("Created certificate file %ls (size=%lu)\n", szName, dwSize);
        }
        CloseHandle(hFile);
    }

    return dwErr;
}

DWORD
LoadBufferFromFile(
    IN      wchar_t const * const   pwzFile,
    IN OUT  BYTE * const            pbBuffer,
    IN OUT  UINT * const            pcbBuffer)
{
    DWORD dwErr = ERROR_SUCCESS;
    BOOL  fErr = FALSE;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    DWORD   dwSize = 0;


    //
    //  Create the file
    //

    hFile = CreateFile(
                pwzFile,
                GENERIC_READ,
                0,
                NULL,
                OPEN_EXISTING,
                0,
                NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        dwErr = GetLastError();
        printf("Error <%lu>: failed to create file %ls\n", dwErr, pwzFile);
        goto Cleanup;
    }

    //
    //  Get the file size in cbBlobLen
    //

    dwSize = GetFileSize(hFile, NULL);
    if(!pbBuffer || dwSize > *pcbBuffer )
    {
        *pcbBuffer = dwSize;
        dwErr = ERROR_MORE_DATA;
        // printf("Warning <%lu>: Buffer too small (%lu)\n", dwSize);
        goto Cleanup;
    }

    //
    //  Read blob from file
    //

    fErr = ReadFile(
                hFile,
                pbBuffer,
                *pcbBuffer,
                &dwSize,
                NULL);
    if (!fErr)
    {
        dwErr = GetLastError();
        printf("Error<%lu>: failed to read file %ls\n", dwErr, pwzFile);
        goto Cleanup;
    }

    *pcbBuffer = dwSize;

Cleanup:

    if(hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }


    return dwErr;
}


LPWSTR
GetDN(
    wchar_t const * const   OU,
    wchar_t * const         pwzDN,
    DWORD const             cch)
{
    //
    // Rough test code. No error checking.
    // Do not copy/paste!
    //

    GUID CNGuid = GUID_NULL;
    WCHAR  wzGuidBuffer[64];
    LPWSTR pwzGuid;
    DWORD  dwID;
    const UINT cchSN = 32;
    WCHAR  wzSN[cchSN];

    // Create Guid for CN name
    (void)CoCreateGuid(&CNGuid);
    (void)StringFromGUID2(CNGuid, wzGuidBuffer, ARRAYSIZE(wzGuidBuffer));

    // get rid of enclosing '{}'
    pwzGuid = wcschr(wzGuidBuffer, '}');
    if (pwzGuid)
    {
        // get rid of closing '}' in guid
        *pwzGuid = '\0';
        // skip leading '{'
        pwzGuid = wcschr(wzGuidBuffer, '{');
        pwzGuid++;
    }

    if (!pwzGuid)
    {
        return NULL;
    }

    // convert guid to lower
    _wcslwr_s(pwzGuid, wcslen(pwzGuid)+1);

    // create fake serial number
    dwID = GetTickCount();
    _ultow_s(dwID, wzSN, cchSN, 16);


    // construct DN
    (void)StringCchCopy(pwzDN, cch, L"SN=");
    (void)StringCchCat(pwzDN, cch, wzSN);
    (void)StringCchCat(pwzDN, cch, L", CN=");
    (void)StringCchCat(pwzDN, cch, pwzGuid);
    (void)StringCchCat(pwzDN, cch, L", OU=");
    (void)StringCchCat(pwzDN, cch, OU);
    (void)StringCchCat(pwzDN, cch, L", O=006, C=US");

    return pwzDN;
}


void CATest(
    wchar_t const * const pwzIssuerName,
    wchar_t const * const pwzCRLDP,
    wchar_t const * const pwzAccessInfoURI,
    wchar_t const * const pwzPubKeyFile
    )
{
    const UINT cKeyLen = 512;
    const UINT cbCertLen = 2048;
    const UINT cchCN = 256;

    DWORD dwErr = ERROR_SUCCESS;
    HRESULT hr = S_OK;

    CASvc *pCA = NULL;
    BYTE rgCert[cbCertLen];
    DWORD dwCert = cbCertLen;
    BYTE rgSerialized[cbCertLen];
    DWORD dwSerialized = cbCertLen;

    UINT cbKey = cKeyLen;
    BYTE rgKey[cKeyLen];

    GUID Serial = GUID_NULL;
    WCHAR  wzCN[cchCN];

    SYSTEMTIME stTime;
    FILETIME ftNotBefore, ftNotAfter;

    GetSystemTime(&stTime);
    SystemTimeToFileTime(&stTime, &ftNotBefore);

    //  This is the length that the MSTV certificates are supposed to last.
    stTime.wYear += 10;
    SystemTimeToFileTime(&stTime, &ftNotAfter);

    //
    // Load public key from file
    //

    dwErr = LoadBufferFromFile(pwzPubKeyFile, rgKey, &cbKey);


    if (dwErr)
    {
        printf("Warning: Cannot find %ls. Using random junk for key\n", pwzPubKeyFile);
        cbKey = cKeyLen;
        for (UINT i=0; i<cbKey; i++)
        {
            rgKey[i] = (BYTE)(rand() % 0xFF);
        }
    }


    //
    // Initialize CA
    //

//    hr = CAInitialize(pwzIssuerName, pwzCRLDP, pwzAccessInfoURI, &pCA);
    hr = CAInitialize(pwzIssuerName, L"", L"", &pCA);
    if (FAILED(hr))
    {
        printf("Error <0x%x>: Failed to initialize CA\n", hr);
        return;
    }

    //
    // Generate client authentication certificate
    //

    GetDN(L"Client Authentication", wzCN, cchCN);
    hr = CACertify(
                pCA,
                wzCN,
                rgKey,
                cbKey,
                ClientAuthentication,
                ftNotBefore,
                ftNotAfter,
                rgCert,
                &dwCert,
                &Serial);
    if (FAILED(hr))
    {
        printf("Error <0x%x>: Failed to create cert (%ls)\n", hr, wzCN);
        return;
    }

    WriteBufferToFile(L"XblAuth.cer", rgCert, dwCert);

    hr = CASerialize(pCA, rgCert, dwCert, rgSerialized, &dwSerialized);
    if (FAILED(hr))
    {
        printf("Error <0x%x>: Failed to serialize cert (%ls)\n", hr, wzCN);
        return;
    }

    WriteBufferToFile(L"XblAuth.ser", rgSerialized, dwSerialized);


    //
    // Generate AV content protection CA
    //

    dwCert = cbCertLen;
    ZeroMemory(rgCert, cbCertLen);

    GetDN(L"AV Content Protection", wzCN, cchCN);
    hr = CACertify(
                pCA,
                wzCN,
                rgKey,
                cbKey,
                ClientAuthentication,
                ftNotBefore,
                ftNotAfter,
                rgCert,
                &dwCert,
                &Serial);
    if (FAILED(hr))
    {
        printf("Error <0x%x>: Failed to create cert\n", hr);
        return;
    }

    WriteBufferToFile(L"XblAV.cer", rgCert, dwCert);

    ZeroMemory(rgSerialized, cbCertLen);

    dwSerialized = cbCertLen;
    hr = CASerialize(pCA, rgCert, dwCert, rgSerialized, &dwSerialized);
    if (FAILED(hr))
    {
        printf("Error <0x%x>: Failed to serialize cert (%ls)\n", hr, wzCN);
        return;
    }

    WriteBufferToFile(L"XblAV.ser", rgSerialized, dwSerialized);


    CATerminate(pCA);
}



int
__cdecl
wmain(int argc, LPWSTR argv[])
{
    //
    // Certify.cpp unit test
    //


    if (argc != 2 && argc != 3)
    {
        printf("Usage: %ls PubKeyFile [IssuerName]\n", argv[0]);
        return -1;
    }

    LPWSTR pwzPubKey = argv[1];

    LPCWSTR pwszIssuer = argc == 3 ? argv[2] : XBL_CERT_ISSUER_NAME_TEST;
    CATest(
        pwszIssuer,
        XBL_CRL_DIST_POINT_TEST,
        XBL_ACCESS_INFO_URI_TEST,
        pwzPubKey);

   return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\Block_PlayReadyDeviceCert.cs ===
using System;
using System.Resources;
using System.Text;
using System.IO;
using System.Reflection;
using System.Collections.Specialized;
using xonline.common.health;

namespace xonline.server.signature
{
    internal class XsigPlayReadyDeviceCertHealthCheck : IHealthBlock
    {
        public ResourceTypeEnum ResourceType { get { return ResourceTypeEnum.Remote; } }

        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            byte[] cert = CreatePlayReadyCertificateImpl.CreatePlayReadyCertificate(0xDEADBEEFCAFEBABE, new byte[64], new byte[64]);
            report.ErrorDetails = "Successfully created a test device certificate";
            report.HealthStatus = HealthStatusEnum.Green;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\AcknowledgeLicensesDelivery.cs ===
using System;
using System.Web;

using xonline.common.protocol;
using xonline.common.service;
using xonline.common.mgmt;

namespace xonline.server.signature
{
    public sealed class AcknowledgeLicensesDelivery: IHttpHandler
    {
        /// Breakpoint: xonline.server.signature.AcknowledgeLicensesDelivery.ProcessRequest
        public void ProcessRequest(HttpContext context)
        {
            try
            {
                AcknowledgeLicensesDeliveryRequest request = new AcknowledgeLicensesDeliveryRequest();
                request.ReadFromRequest(context.Request);

                Acknowledgement[] acknowledgements = LicenseImpl.GenericLicenseApi<AcknowledgeLicenseApiResponseGenerator, Acknowledgement>(request.idPairs, request.userPuid, null);

                AcknowledgeLicensesDeliveryResponse response = new AcknowledgeLicensesDeliveryResponse();
                response.acknowledgements = acknowledgements;
                response.acknowledgementsLength = (ushort)response.acknowledgements.Length;

                XRLUtil.SetXRLResponse(context.Response, XOService.Signature_Server, HResult.S_OK, response);
            }
            catch (XRLException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XRLException(XRLException.ToHResult(e, HResult.XONLINE_E_SIGNATURE_ACKNOWLEDGE_LICENSE_DELIVERY_ERROR), XEvent.Id.LICENSE_GENERAL, "AcknowledgeLicensesDelivery failed.", e);
            }
        }

        ///
        /// Can this instance be reusable?
        /// Since we hold no state in these requests, the answer is yes.
        ///
        public bool IsReusable { get { return true; } }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\Block_Wmrm.cs ===
using System;
using System.Resources;
using System.Text;
using System.IO;
using System.Reflection;
using System.Collections.Specialized;
using xonline.common.health;

using WMRMOBJSLib;
using LICENSESERVERLib;


/*
 * This could also be placed in the common health check code. However, that would mean we'd need to sign the interop dlls,
 * which makes installation harder, especially given that only xsig uses this right now. If that changes, perhaps it
 * would be worth it to sign those dlls or something like that.
 */
namespace xonline.server.signature
{
    internal class XsigWmrmHealthCheck : IHealthBlock
    {
        public ResourceTypeEnum ResourceType { get { return ResourceTypeEnum.Local; } }

        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            try
            {
                WmrmCertReport wmrmReport = ReportWmrmCertValidity();
                report.ExtendedReport = wmrmReport;
                if (wmrmReport.DaysTillExpiry > 0)
                {
                    // attempt to obtain a certificate
                    GenerateResponse(ClientInfo);
                    if (wmrmReport.DaysTillExpiry < 60)
                    {
                        report.ErrorDetails = String.Format("The wmrm certificate will expire in {0} days.", wmrmReport.DaysTillExpiry);
                        report.HealthStatus = HealthStatusEnum.Yellow;
                    }
                    else
                    {
                        report.HealthStatus = HealthStatusEnum.Green;
                    }
                }
                else
                {
                    report.ErrorDetails = "The wmrm certificate has expired.";
                    report.HealthStatus = HealthStatusEnum.Red;
                }
            }
            catch (FileNotFoundException e)
            {
                report.ErrorDetails = String.Format("The file {0} could not be found.", e.FileName);
                report.HealthStatus = HealthStatusEnum.Red;
            }
            catch (System.Runtime.InteropServices.COMException e)
            {
                report.HealthStatus = HealthStatusEnum.Red;

                switch ((uint)e.ErrorCode)
                {
                    case 0x80040154:    //  REGDB_E_CLASSNOTREG
                        {
                            report.ErrorDetails = "A COM class could not be found - likely because WMDRM SDK is not installed.";
                            break;
                        }

                    case 0xC004291C:    //  DRM_E_LICENSE_SERVER_INFO_MISSING
                        {
                            report.ErrorDetails = "A licensing service error occured - likely because the WMRM certificates have not been installed.";
                            break;
                        }

                    default:
                        {
                            report.ErrorDetails = String.Format("Could not generate the WMRM response because of: 0x{0:X8} ({1}).  Ensure WMRM certificates have been installed.", e.ErrorCode, e.Message);
                            break;
                        }
                }
            }
            catch (Exception e)
            {
                report.ErrorDetails = String.Format("Could not generate the WMRM response because of: {0}", e.ToString());
                report.HealthStatus = HealthStatusEnum.Red;
            }
        }

        private static WmrmCertReport ReportWmrmCertValidity()
        {
            WmrmCertReport report = new WmrmCertReport();
            ILicenseGenerator licObj = new LicenseGenerator();

            object result = null;
            licObj.Get("Cert1_days_to_expiry", out result);
            report.DaysTillExpiry = ParseDaysToExpiry((string)result);
            System.Runtime.InteropServices.Marshal.FinalReleaseComObject(licObj);

            return report;
        }

        private static int ParseDaysToExpiry(string daysToExpiry)
        {
            // WMRM 10 isn't very consistent with what it reports as "days to expiry" if
            // the certificate is expired. So if we can't parse it as a number,
            // we assume it's expired at set it to 0.
            int result = 0;
            Int32.TryParse(daysToExpiry, out result);
            return result;
        }

        private static string GenerateResponse(string clientInfo)
        {
            string keyId = "1";
            string seed = "c52LF06QftMXc1DCRQf48sIMSmf00xsJbIn34vAW";

            WMRMKeys keysObj = new WMRMKeys();
            keysObj.KeyID = keyId;
            keysObj.Seed = seed;

            WMRMLicGen licgenObj = new WMRMLicGen();
            licgenObj.KeyID = keyId;
            licgenObj.SetKey("MSDRM", keysObj.GenerateKey());

            WMRMRights rightsObj = new WMRMRights();

            rightsObj.MinimumAppSecurity = 500;
            rightsObj.AllowPlayOnPC = 1;
            rightsObj.AllowBackupRestore = 1;
            rightsObj.AllowTransferToSDMI = 1;
            rightsObj.Playcount = 2;
            rightsObj.PMRights = 51;
            rightsObj.PMAppSecurity = 150;

            licgenObj.Rights = rightsObj.GetAllRights();
            licgenObj.ClientInfo = clientInfo;

            string rawLicense = licgenObj.GetLicenseToDeliver();

            WMRMResponse response = new WMRMResponse();
            response.AddLicense("2.0.0.0", rawLicense);
            return response.GetLicenseResponse();
        }

        // TODO: Determine expected life-time and re-use of this object so I can decide about caching.
        private static string ClientInfo
        {
            get
            {
                ResourceManager rm = new ResourceManager("Resources", Assembly.GetExecutingAssembly());
                return rm.GetString("CLIENTINFO");
            }
        }
    }

    public class WmrmCertReport : IExtendedHealthReport
    {
        public int DaysTillExpiry;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\AcquireMediaLicenses.cs ===
using System;
using System.Web;

using xonline.common.protocol;
using xonline.common.service;
using xonline.common.mgmt;

namespace xonline.server.signature
{
    public sealed class AcquireMediaLicenses : IHttpHandler
    {
        /// Breakpoint: xonline.server.signature.AcquireMediaLicenses.ProcessRequest
        public void ProcessRequest(HttpContext context)
        {
            try
            {
                AcquireMediaLicensesRequest request = new AcquireMediaLicensesRequest();
                request.ReadFromRequest(context.Request);

                BlockDeserializer deserializer = new BlockDeserializer(request.clientInfoBlocks);
                string clientInfo = System.Text.Encoding.Unicode.GetString(deserializer.Deserialize());

                MediaLicense[] mediaLicenses = LicenseImpl.GenericLicenseApi<AcquireLicenseApiResponseGenerator, MediaLicense>(request.idPairs, request.userPuid, clientInfo);

                foreach (MediaLicense license in mediaLicenses)
                {
                    if (license.license != null && license.license.Length > 0)
                    {
                        BlockSerializer serializer = new BlockSerializer(license.license, 1, MediaLicense.LICENSE_BLOCK_MAX_COUNT);
                        if (serializer.IsEmptyBlockCount)
                        {
                            throw new XRLException(HResult.E_FAIL, XEvent.Id.LICENSE_GENERAL, "License is empty.");
                        }
                        if (serializer.IsBlockCountOutOfRange)
                        {
                            throw new XRLException(HResult.E_FAIL, XEvent.Id.LICENSE_GENERAL, "The license we created is too big for a MediaLicense");
                        }
                        license.licenseBlocks = serializer.Serialize();
                        license.licenseBlockCount = (ushort)license.licenseBlocks.Length;
                    }
                }

                AcquireMediaLicensesResponse response = new AcquireMediaLicensesResponse();
                response.mediaLicenses = mediaLicenses;
                response.mediaLicensesLength = (ushort)response.mediaLicenses.Length;

                XRLUtil.SetXRLResponse(context.Response, XOService.Signature_Server, HResult.S_OK, response);
            }
            catch (XRLException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XRLException(XRLException.ToHResult(e, HResult.XONLINE_E_SIGNATURE_ACQUIRE_MEDIA_LICENSES_ERROR), XEvent.Id.LICENSE_GENERAL, "AcquireMediaLicenses failed.", e);
            }
        }

        ///
        /// Can this instance be reusable?
        /// Since we hold no state in these requests, the answer is yes.
        ///
        public bool IsReusable { get { return true; } }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\ClientCertificateGenerator.cs ===
using System;
using System.Data.SqlClient;
using System.Collections.Generic;
using System.Runtime.InteropServices;

using xonline.common.service;
using xonline.common.config;
using xonline.common.utilities;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.sql.sqlclient;

namespace xonline.server.signature
{
    ///
    /// A factory class to create the certificates we hand out to consoles.
    /// Right now the factory has a singleton per appId though
    /// it is not gauranteed to be that way in the future.
    /// Just call GetCertificateGenerator and then GenerateCertificate.
    ///
    sealed class ClientCertificateGenerator
    {
        static ClientCertificateGenerator()
        {
            Config.SettingChange += OnSettingChange;
        }

        static void OnSettingChange(object sender, SettingChangeEventArgs args)
        {
            // The setting is only available right before the callback happens, so this will result in some thrashing
            // since potentially several reloads will happen at a time.  The assumption here is that relatively
            // few entries will actually exist, so this occurance is rare.
            if (args.Setting.StartsWith("casvc", StringComparison.InvariantCultureIgnoreCase))
            {
                Flush();
            }
        }

        ///
        /// Get a certificate generator.
        /// Classic double-checked locking method. The only wrinkle is
        /// that if we fail to init the casvc dll, we need to tear it
        /// down before the next request, which will attempt to initialize
        /// it again.
        ///
        public static ClientCertificateGenerator GetCertificateGenerator(string appId)
        {
            if (!_generators.ContainsKey(appId))
            {
                lock (_syncRoot)
                {
                    if (!_generators.ContainsKey(appId))
                    {
                        ClientCertificateGenerator temp = new ClientCertificateGenerator(appId);
                        // Because the dictionary class is not thread safe for updates, the safest approach
                        // ends up being to replace the entire data structure all at once.  Someday there will
                        // be a single writer/multi reader dictionary.. 
                        Dictionary<string, ClientCertificateGenerator> tempCollection =
                            new Dictionary<string, ClientCertificateGenerator>(_generators);
                        tempCollection.Add(appId, temp);
                        _generators = tempCollection;
                    }
                }
            }
            return _generators[appId];
        }

        /// 
        /// Throws away all of the entries to refresh the settings that may need to be updated.  This doesn't
        /// attempt to clean up the old dictionary because there is no guarantee of when there are no other
        /// threads attempting to access the object.  The safest approach is to allow the GC to clean it up.
        /// 
        internal static void Flush()
        {
            _generators = new Dictionary<string, ClientCertificateGenerator>();
        }

        ///
        /// Generate a certificate.
        ///
        /// Params: consoleId:   format is 'XE.DDDDDDDDDDDC'
        ///         publicKey:  public key to use to generate the certificate.
        ///         type:       the type of certificate to create.  This is passed to the native function.
        ///
        /// Returns:    The certificate we generate (for details see the ClientCertificate class).
        ///
        public ClientCertificate GenerateCertificate(string consoleId, byte[] publicKey)
        {
            // Size is the original size of the certificate arrays, but then is used
            // to re-size the arrays so we pass the smallest array possible to the
            // the client and we can tell them the exact size of the certificate.
            // Note that is re-used for both the certificate and the serialized version.
            UInt32 size = ClientCertificate.MAX_CERTIFICATE_SIZE;

            // The actual certificates.
            byte[] certificate = new byte[ClientCertificate.MAX_CERTIFICATE_SIZE];
            byte[] serialized = new byte[ClientCertificate.MAX_CERTIFICATE_SIZE];

            // Eventually we need this is a byte-array but it works best to have a Guid
            // while we actually create it.
            Guid serialNumber = new Guid();

            // Create the basis for our certificate.
            string subjectName = FormatSubjectName(consoleId);

            // Call the native code and resize the certificate array.
            _nativeWrapper.CallCACertify(
                subjectName,
                publicKey,
                (UInt32)publicKey.Length,
                DateTime.UtcNow.AddSeconds(_appIdSettings.NotBeforeClockSkewInSeconds),
                DateTime.UtcNow.AddHours(_appIdSettings.CertLifetimeInHours),
                certificate,
                ref size,
                ref serialNumber);
            Array.Resize(ref certificate, (int)size);

            // Call the native code and resize the serialized certificate array.
            size = ClientCertificate.MAX_CERTIFICATE_SIZE;
            _nativeWrapper.CallCASerialize(certificate, (UInt32)certificate.Length, serialized, ref size);
            Array.Resize(ref serialized, (int)size);

            // Package our certificate all squeaky-clean.
            return new ClientCertificate(certificate, serialized, serialNumber.ToByteArray());
        }

        ///
        /// Private helper functions from here down, the documentation will be limitted.
        ///

        private ClientCertificateGenerator(string appId)
        {
            _appIdSettings = new AppIdSettings(appId);

            // Initialize our certificate generator.
            _nativeWrapper = new NativeCertificateWrapper(_appIdSettings.IssuerName, _appIdSettings.ExtensionFlags, _appIdSettings.CrlDistributionPoint, _appIdSettings.AltUrl);
        }

        private string FormatSubjectName(string consoleId)
        {
            return String.Format(_appIdSettings.SubjectNameFormatString, ConsoleIdUtil.TrimConsoleIdPrefix(consoleId));
        }

        private volatile static Dictionary<string, ClientCertificateGenerator> _generators = new Dictionary<string, ClientCertificateGenerator>();
        private readonly static Object _syncRoot = new Object();

        private readonly AppIdSettings _appIdSettings;
        private readonly NativeCertificateWrapper _nativeWrapper;
    }

    ///
    /// A read-only class that represents the casvc settings for a
    /// given appid.
    ///
    internal sealed class AppIdSettings
    {
        public string IssuerName { get { return _issuerName; } }
        public string SubjectNameFormatString { get { return _subjectNameFormatString; } }
        public int CertLifetimeInHours { get { return _certLifetimeInHours; } }
        public CASvcExtensionFlags ExtensionFlags { get { return _extensionFlags; } }
        public int NotBeforeClockSkewInSeconds { get { return _notBeforeClockSkewInSeconds; } }
        public string CrlDistributionPoint { get { return _crlDistributionPoint; } }
        public string AltUrl { get { return _altUrl; } }

        public AppIdSettings(string appId)
        {
            _crlDistributionPoint = String.Empty;
            _altUrl = String.Empty;

            using (SqlClient client = new SqlClient(Interface.npdb))
            {
                client.StoredProc = "p_casvc_get_settings_for_appid";

                client.AddParameter("@vc_appid", appId);

                using (SqlDataReader reader = client.Execute())
                {
                    if (!reader.Read())
                    {
                        throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST,
                            XEvent.Id.CASVC_INVALID_REQUEST,
                            "Unable to find any certificate configuration for appid {0}",
                            appId);
                    }

                    _issuerName = Config.GetSetting(reader.GetString(0));

                    _subjectNameFormatString = reader.GetString(1);
                    _certLifetimeInHours = reader.GetInt32(2);
                    _extensionFlags = (CASvcExtensionFlags)reader.GetByte(3);
                    _notBeforeClockSkewInSeconds = reader.GetInt32(4);
                }
            }
        }

        private readonly string _issuerName;
        private readonly string _subjectNameFormatString;
        private readonly int _certLifetimeInHours;
        private readonly CASvcExtensionFlags _extensionFlags;
        private readonly int _notBeforeClockSkewInSeconds;
        private readonly string _crlDistributionPoint;
        private readonly string _altUrl;
    }

    ///
    /// A read-only class that represents a single certificate.  This holds
    /// everything we really need about a certificate and verifies the
    /// sizes of the byte-arrays as you construct one.
    ///
    sealed class ClientCertificate
    {
        ///
        /// Constructor.  the sizes of the certificates and the serial number will
        /// be verified and an exception thrown if invalid.
        public ClientCertificate(byte[] certificate, byte[] serializedCertificate, byte[] serialNumber)
        {
            VerifyArguments(certificate, serializedCertificate, serialNumber);
            _certificate = certificate;
            _serializedCertificate = serializedCertificate;
            _serialNumber = serialNumber;
        }

        ///
        /// Read-only properties for the elements in this certificate.
        ///
        public byte[] Certificate { get { return (byte[])_certificate.Clone(); } }
        public byte[] SerializedCertificate { get { return (byte[])_serializedCertificate.Clone(); } }
        public byte[] SerialNumber { get { return (byte[])_serialNumber.Clone(); } }

        ///
        /// Private helper functions from here down, the documentation will be limitted.
        ///
        private void VerifyArguments(byte[] certificate, byte[] serializedCertificate, byte[] serialNumber)
        {
            if (certificate.Length > MAX_CERTIFICATE_SIZE)
            {
                throw new ArgumentException(String.Format("Certificates must be no longer than {0}.", MAX_CERTIFICATE_SIZE));
            }
            if (serializedCertificate.Length > MAX_CERTIFICATE_SIZE)
            {
                throw new ArgumentException(String.Format("Serialized Certificates must be no longer than {0}.", MAX_CERTIFICATE_SIZE));
            }
            if (serialNumber.Length != SERIAL_NUMBER_SIZE)
            {
                throw new ArgumentException(String.Format("Serial Number must have size exactly {0}", SERIAL_NUMBER_SIZE));
            }
        }

        /// These must be kept consistent with XmstvCreateCertifiateRequest/Response
        /// C# does not have a CASSERT that I can find, though.
        public const int SERIAL_NUMBER_SIZE = 16;
        public const int MAX_CERTIFICATE_SIZE = XmstvCreateCertificateResponse.MAX_CERT_SIZE;

        private readonly byte[] _certificate;
        private readonly byte[] _serializedCertificate;
        private readonly byte[] _serialNumber;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\ContentLicense.cs ===
//
// This file contains classes to verify, update and sign the content license
// header of content packages.
//
// The license is a fixed size blob that's part of the content package header:
//
//   -------------------------------------
//   | License  |  Meta-Data  |  Content |
//   -------------------------------------
//
// We're only concerned with the format of the License part, which is defined
// by the class 'ContentLicenseHeader' in this same file.
//
// The License, among other things, include a table of licensees, a content-id
// and a signature. The content-id is also the sha1 of the entire meta-data
// section. Since the Meta-data contains the sha1 of the Content section, it's
// safe to say that the content-id uniquely identifies the package with very
// (neglegible) chances of collision.
//
// The table of licensees is a table with 16 licensee descriptors. Each
// licensee descriptor contains the licensee-id, the license-bits and the
// license flags. The licensee-id can be an user-id or a console-id (not machine
// id) or 0xFFFFFFFFFFFFFFFF which means that the license is unrestricted. The
// license-bits are the OR'd bits of all offers of that content package acquired
// by the licensee.
//
// The signature field of the license is the RSA (PKCS1-V1.5) signature of the
// entire license section minus the signature field itself, obviously. As of
// now, three authorities can sign the license: the console, PIRS and Live. We
// (live) don't care about console signature and we don't trust them. We should
// trust PIRS signatures but we don't currently support it.
//

using System;
using System.Diagnostics;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Web;
using System.Data;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Threading;

using xonline.common.billing;
using xonline.common.config;
using xonline.common.crypto;
using xonline.common.diagnostics;
using xonline.common.machine;
using xonline.common.offer;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.user;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.xcrypto;
using xonline.common.utilities;

using Microsoft.Webstore.WstClient;

namespace xonline.server.signature
{

    // This is the format of the content license header. All integer fields
    // are big-endian
    public class ContentLicense : WireData
    {
        public const int    LiveSignatureLen         = 256;
        public const int    ReservedLen              = 296;
        public const int    LicenseesLen             = 16;
        public const UInt64 UnrestrictedLicensee     = 0xFFFFFFFFFFFFFFFF;
        public const UInt32 LicenseFlagRequireOnline = 0x1;
        public const UInt32 LicenseTypeLive          = 0x4c495645;

        public ContentLicenseSignature signature;
        public ContentLicenseBody      body;
    }

    public class ContentLicenseSignature : WireData
    {
        [WireInfo(BigEndian=true)]
        public UInt32 signatureType;

        [WireInfo(ArraySize=ContentLicense.LiveSignatureLen)]
        public byte[] signature;

        [WireInfo(ArraySize=ContentLicense.ReservedLen)]
        public byte[] reserved;
    }

    public class ContentLicenseBody : WireData
    {
        [WireInfo(ArraySize=ContentLicense.LicenseesLen)]
        public ContentLicensee[] licensees;

        [WireInfo(ArraySize=(int)XOn.XONLINE_CONTENT_ID_LEN)]
        public byte[] ContentId;

        [WireInfo(BigEndian=true)]
        public UInt32 SizeOfHeaders;
    }

    public class ContentLicensee : WireData
    {
        [WireInfo(BigEndian=true)]
        public UInt64 licenseeId;
        [WireInfo(BigEndian=true)]
        public UInt32 licenseBits;
        [WireInfo(BigEndian=true)]
        public UInt32 licenseFlags;
    }

    // ContentLicenseUtil
    // Handles the verification and the updating of the content license header
    // of content packages
    static public class ContentLicenseUtil
    {
        // This is the format of a content license as modeled in the database
        public class License
        {
            public UInt64 machineId;
            public UInt32 licenseBits;
            public UInt32 policyFlags;
        }

        // RefreshGameLicense
        // This will process the Refresh-License request
        public static RefreshGameLicenseResponse RefreshGameLicense(
            RefreshGameLicenseRequest request,
            ref Guid mediaInstanceId,
            out string[] logLines
            )
        {
            byte[] licenseBody = null;

            // Parse license from the request
            ContentLicense license = new ContentLicense();
            license.ReadBytes(request.license);

            // Verify signature
            UInt32 licenseType = license.signature.signatureType;
            if(licenseType == ContentLicense.LicenseTypeLive)
            {
                licenseBody = license.body.ToArray();

                if (!CryptoKeyProxy.VerifySignature(CONTAINER_CLASS,
                                                    (new SHA1Managed()).ComputeHash(licenseBody),
                                                    license.signature.signature))
                {
                    // Signature doesn't check. Reset all license information.
                    // Bug 47059 - Don't log an event. Turns out that the content
                    // packaging tool is signing all packages using the test DRM key.
                    // Therefore all downloads in prod result in this event being fired.
                    
                    license.body.licensees = CreateEmptyLicenseeArray();
                }
            }
            else
            {
                // We don't honor any other type of signatures for now. Reset
                // all license information.
                license.body.licensees = CreateEmptyLicenseeArray();
            }

            // Retrieve licenses from the database
            License[] licenses = GetContentLicensesFromDatabase(
                request.userId,
                license.body.ContentId,
                out mediaInstanceId,
                out logLines);

            // Resolve the requestor's console id using his machine id
            ulong consoleId = 0;
            UInt64[] validMachineIds = null;
            if (!SGInfo.IsInternal())
            {
                // HACK - PCs are treated differently than consoles
                if (SGInfo.Current.GetPlatformType() == XOn.XPLT_XBOX360)
                {
                    string consoleName = ConsoleIdUtil.GetXbox360ConsoleIdStringFromMachineId( request.machineId );
                    consoleId = ConsoleIdUtil.ConvertConsoleIdFromDecimalStringToUInt64( consoleName );

                    validMachineIds = Array.ConvertAll(
                        MachinePuidUtil.GetMachineIdsFromConsoleId( consoleName ),
                        ( u => (UInt64)(u) )
                        );
                }
                else 
                {
                    // Preserve Original Logic --- If the console isn't an Xbox 360, attempt
                    // to get the UINT64 version of the console id
                    consoleId = ConsoleIdUtil.GetConsoleIdFromMachineId(request.machineId, SGInfo.Current.GetPlatformType());

                    validMachineIds = new UInt64[1] { request.machineId };
                }
            }

            // Update the licensee array by processing the licenses
            ProcessLicenses(request.userId,
                            validMachineIds,
                            consoleId,
                            license.body.licensees,
                            licenses);

            // Update the signature
            licenseBody = license.body.ToArray();

            license.signature.signatureType = ContentLicense.LicenseTypeLive;
            license.signature.signature = new byte[ContentLicense.LiveSignatureLen];
            UInt32 sigLen = 0;
            CryptoKeyProxy.Sign(CONTAINER_CLASS,
                                (new SHA1Managed()).ComputeHash(licenseBody),
                                license.signature.signature,
                                out sigLen);

            // Prepare response
            RefreshGameLicenseResponse response = new RefreshGameLicenseResponse();
            response.license = license.ToArray();

            return response;
        }

        public static ContentLicensee[] CreateEmptyLicenseeArray()
        {
            ContentLicensee[] licensees = new ContentLicensee[ContentLicense.LicenseesLen];

            for(int i=0; i < licensees.Length; i++)
            {
                licensees[i] = new ContentLicensee();
                licensees[i].licenseeId   = 0;
                licensees[i].licenseBits  = 0;
                licensees[i].licenseFlags = 0;
            }

            return licensees;
        }

        // UpdateLicensee
        // This will insert/update one license descriptor from a ContentLicensee
        // table. The following scheme will be used:
        //
        // * If the entry is already in the table, it will be updated and the licenseBits 
        // will be OR'd with the existing entry.
        // * If the entry is not in the table and the table is not full, the
        // entry will inserted at the first available slot.
        // * If the table is full, the first entry will be removed and the new
        // entry will be added to the end of the table
        //
        private static void UpdateLicensee(
            ContentLicensee[] licensees,
            UInt64 licenseeId,
            UInt32 licenseBits,
            UInt32 licenseFlags
        )
        {
            Assert.AreEqual(licensees.Length, ContentLicense.LicenseesLen);

            for(int i=0; i < licensees.Length; i++)
            {
                if(licensees[i].licenseeId == licenseeId)
                {
                    // Update
                    licensees[i].licenseeId    = licenseeId;
                    licensees[i].licenseBits  |= licenseBits;
                    licensees[i].licenseFlags  = licenseFlags;
                    return;
                }
                else if(licensees[i].licenseeId == 0)
                {
                    // Insert
                    licensees[i].licenseeId   = licenseeId;
                    licensees[i].licenseBits  = licenseBits;
                    licensees[i].licenseFlags = licenseFlags;
                    return;
                }
            }

            // The list is full. Remove the first entry from the list and
            // add the new licensee descriptor at end.
            for(int i=0; i < licensees.Length-1; i++)
                licensees[i] = licensees[i+1];

            int n = licensees.Length-1;
            licensees[n] = new ContentLicensee();
            licensees[n].licenseeId   = licenseeId;
            licensees[n].licenseBits  = licenseBits;
            licensees[n].licenseFlags = licenseFlags;
        }

        // RemoveLicensee
        // This will remove a licensee descriptor from a ContentLicensee table.
        // If the licensee is not found, the table will not be changed.
        //
        private static void RemoveLicensee(
            ContentLicensee[] licensees,
            UInt64 licenseeId
        )
        {
            Assert.AreEqual(licensees.Length, ContentLicense.LicenseesLen);

            for(int i=0; i < licensees.Length && licensees[i].licenseeId != 0; i++)
            {
                if(licensees[i].licenseeId == licenseeId)
                {
                    for(; i < licensees.Length-1; i++)
                        licensees[i] = licensees[i+1];

                    // Fill in the hole
                    licensees[i] = new ContentLicensee();
                    licensees[i].licenseeId   = 0;
                    licensees[i].licenseBits  = 0;
                    licensees[i].licenseFlags = 0;

                    break;
                }
            }
        }

        // ProcessLicenses
        //
        // This uses an array of Licenses to update the licensee array. This looks a bit 
        // complicated because the way we store the stuff in the database is not the same 
        // the way we represent the stuff in the content package. There following scheme 
        // will be used:
        //
        // * Two DWORDs will be calculated. One containing the ORed license mask bits of 
        // all restricted offers (restrictedLicenseBits) and one containing the ORed 
        // license mask bits of all unrestricted offers (unrestrictedLicenseBits).
        //
        // * If there are any *user restricted* licenses, use "restrictedLicenseBits" to 
        // update the license mask for that user in the licensee table. Otherwise, remove 
        // any references to that user from the licensee table.
        //
        // * If there are any *machine restricted* licenses for the console id that is 
        // making the request, use "restrictedLicenseBits" to update the license mask for 
        // that console in the licensee table. The license-mask will be or'd with the 
        // current entry in the table if one exists. Yes, the machine licensee is treated 
        // differently because Uodb is partitioned by user and with the current design it 
        // would require a partition scan to find all the content licenses for a specific 
        // console. 
        //
        // * If there are any *unrestricted* licenses, update the "unrestricted" entry on 
        // the licensee table using "unrestrictedLicenseBits". Otherwiser, remove any 
        // unrestricted entries in the licensee table.
        //
        // Parameters:
        //
        // * userId - requestor's userId
        // * machineId - requestor's machineId
        // * consoleId - the consoleId associated to the machineId (the license uses 
        // consoleIds, but machine-ids are used in the database)
        // * licensees - array of licensees that will be updated
        // * licenses  - array of licenses that are going to be processed in order to 
        // update licensees
        //
        private static void ProcessLicenses(
            UInt64 userId,
            UInt64[] validMachineIds,
            UInt64 consoleId,
            ContentLicensee[] licensees,
            License[] licenses
        )
        {
            bool fUnrestrictedLicenses = false;
            bool fPerMachineRights     = false;
            bool fPerUserRights        = false;
            bool fPerUserPcRights      = false;
            bool fPerUserOfflineRights = false;
            UInt32 unrestrictedLicenseBits = 0;
            UInt32 restrictedLicenseBits   = 0;
            UInt32 restrictedLicenseConsoleBits = 0;
            HashSet<UInt64> validMachineSet;

            //
            // Build a hash set of the valid machine IDs in order to facilitate 
            // searching of the individual licenses
            // 

            if (validMachineIds != null && validMachineIds.Length > 0)
            {
                validMachineSet = new HashSet<UInt64>( validMachineIds );
            }
            else
            {
                validMachineSet = new HashSet<UInt64>( );
            }

            //
            // Remove existing entries for the unrestricted licensee and the userId. These 
            // will be completely replaced with super-fresh data from the database. The 
            // console licensee is different - we'll update an existing entry. 
            //
            
            RemoveLicensee(licensees, ContentLicense.UnrestrictedLicensee);
            RemoveLicensee(licensees, userId);

            for(int i=0; i < licenses.Length; i++)
            {
                if((licenses[i].policyFlags & Offer.UNRESTRICTED) != 0)
                {
                    fUnrestrictedLicenses = true;
                    unrestrictedLicenseBits |= licenses[i].licenseBits;
                }
                else
                {
                    restrictedLicenseBits |= licenses[i].licenseBits;

                    if (validMachineSet.Contains ( licenses[i].machineId ) == true
                       && (licenses[i].policyFlags & Offer.PER_MACHINE_RIGHTS) != 0 )
                    {
                        restrictedLicenseConsoleBits |= licenses[i].licenseBits;
                        fPerMachineRights = true;
                    }

                    if ((licenses[i].policyFlags & Offer.PER_USER_RIGHTS) != 0)
                    {
                        fPerUserRights = true;
                    }

                    if ((licenses[i].policyFlags & Offer.PER_USER_OFFLINE_RIGHTS) != 0)
                    {
                        fPerUserOfflineRights = true;
                    }

                    if ((licenses[i].policyFlags & Offer.PER_USER_PC_RIGHTS) != 0)
                    {
                        fPerUserPcRights = true;
                    }
                }
            }

            //Update the user License with LicenseFlagRequireOnline set to 0
            //fPerUserOfflineRights is checked prior to checking fPerUserRights to ensure that if both rights are specified in single xml 
            //we default to useronly online.
            if (fPerUserOfflineRights)
            {
                UpdateLicensee(licensees, userId, restrictedLicenseBits, 0);
            }

            // Update unrestricted Licensee
            if(fUnrestrictedLicenses)
            {
                UpdateLicensee(licensees, ContentLicense.UnrestrictedLicensee, unrestrictedLicenseBits, 0);
            }

            // Update user licensee with LicenseFlagRequireOnline set to 1
            if(fPerUserRights)
            {
                UpdateLicensee(licensees, userId, restrictedLicenseBits, ContentLicense.LicenseFlagRequireOnline);
            }

            //Update pc user licensee.
            if (fPerUserPcRights)
            {
                UpdateLicensee(licensees, userId, restrictedLicenseBits, 0);
            }

            // Update console licensee
            if(fPerMachineRights)
            {
                UpdateLicensee(licensees, consoleId, restrictedLicenseConsoleBits, 0);
            }
        }

        // GetContentLicensesFromDatabase
        // Given an user-id and a console-id, this will return an array of
        // content-licenses as they are stored in the db
        private static License[] GetContentLicensesFromDatabase(
            UInt64 userId,
            byte[] contentId,
            out Guid mediaInstanceId,
            out string[] logLines
        )
        {
            ArrayList licenseList = new ArrayList(32);
            ArrayList logList = new ArrayList(32);

            string[] offerIdsToReportOn = Config.GetMultiSetting(MultiSetting.xbos_ContentOfferIdsForReporting);

            Guid[] mis = new Guid[1];

            mediaInstanceId = CatalogUtil.ContentIdToMediaInstanceId(contentId);
            mis[0] = mediaInstanceId;

            List<UserRightsUtil.MediaInstanceRights> mirs = UserRightsUtil.GetUserMediaInstanceRights(userId, mis);
            if (mirs.Count == 0)
            {
                throw new XRLException(HResult.XONLINE_E_CONTENT_NOT_FOUND, XEvent.Id.HACK_CONTENT_NOT_FOUND,
                    "GetUserMediaInstanceRights returned an empty list of offers, meaning that the contentId was not found. This may be a hack attempt.");
            }

            UserMediaInstanceRightsUtil.EnsureMachineId(mirs);

            foreach (UserRightsUtil.MediaInstanceRights mir in mirs)
            {
                Validator validator = Validator.MakeValidatorChain(true, new GeoFencingValidator(userId, mir, "RefreshGameLicense"));
                if (!validator.DoCheck())
                {
                    throw new XRLException(validator.Hr, XEvent.Id.LICENSE_INVALID_REQUEST,
                                            "RefreshGameLicense: Geofencing error for miid {0}.", mir.mediaInstanceId);
                }

                uint policy = 0;

                //
                // Note the assumptions the types are mutually exclusive!!
                //
                XmlDocumentAndNamespaceManagerCache.PutXmlDocumentAndNamespaceManager(mir.licenseXml, mir.licenseTypeId);
                LicenseXmlHelper xmlHelper = new LicenseXmlHelper(mir.licenseTypeId);

                foreach (System.Xml.XmlNode node in xmlHelper.SelectNodes("//ns:DrmRights"))
                {
                    foreach (System.Xml.XmlNode child in node.ChildNodes)
                    {
                        if (child.InnerText.Equals("True", StringComparison.OrdinalIgnoreCase))
                        {
                            if (child.Name.Equals("UnrestrictedGameRights", StringComparison.OrdinalIgnoreCase))
                            {
                                policy |= Offer.UNRESTRICTED;
                            }
                            else if (child.Name.Equals("PerMachineGameRights", StringComparison.OrdinalIgnoreCase))
                            {
                                policy |= Offer.PER_MACHINE_RIGHTS;
                            }
                            else if (child.Name.Equals("PerUserGameRights", StringComparison.OrdinalIgnoreCase))
                            {
                                policy |= Offer.PER_USER_RIGHTS;
                            }
                            else if (child.Name.Equals("PerUserPCGameRights", StringComparison.OrdinalIgnoreCase))
                            {
                                policy |= Offer.PER_USER_PC_RIGHTS;
                            }
                            else if (child.Name.Equals("PerUserOfflineGameRights", StringComparison.OrdinalIgnoreCase))
                            {
                                policy |= Offer.PER_USER_OFFLINE_RIGHTS;
                            }
                        }
                    }
                }

                if( 0 == policy )
                {
                    //
                    // if the associated policy is invalid we abort the request
                    //
                    throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.LICENSE_XML_ERROR,
                                           "RefreshGameLicense: Invalid XML license type Id {0}, for miid {1}.",
                                           mir.licenseTypeId,
                                           mir.mediaInstanceId);
                }

                License dbLicense = new License();
                dbLicense.machineId = mir.machineId;
                dbLicense.licenseBits = mir.licenseExtensionBits;
                dbLicense.policyFlags = policy;

                UserMediaInstanceRightsUtil.UpdatePurchaseRecordWithMachineId(userId, mir);

                licenseList.Add(dbLicense);

                if (offerIdsToReportOn.Length >= 0)
                {
                    if (Array.Exists(offerIdsToReportOn,
                                    delegate(string offerId) { return offerId.Equals(mir.offerId.ToString(), StringComparison.OrdinalIgnoreCase); }))
                    {
                        logList.Add(String.Join("|", new String[] { "CRL_OFFERID", mir.offerId.ToString(), mir.machineId.ToString() }));
                    }
                }
            }

            logLines = (string[])logList.ToArray(typeof(string));

            return (License[])licenseList.ToArray(typeof(License));
        }

        private const EContainerClasses CONTAINER_CLASS = EContainerClasses.Drm;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\CreatePlayReadyCertificateImpl.cs ===
using System;
using System.Runtime.InteropServices;

using xonline.common.config;
using xonline.common.crypto;
using xonline.common.service;
using xonline.common.utilities;
using xonline.common.utilities2;

namespace xonline.server.signature
{
    public static class CreatePlayReadyCertificateImpl
    {
        public static byte[] CreatePlayReadyCertificate(ulong consoleId, byte[] publicSigningKey, byte[] publicEncryptionKey)
        {
            byte[] cert = new byte[xonline.server.signature.CreatePlayReadyCertificate.MAX_DEVICE_CERT_LENGTH];
            uint cbCert;
            byte[] serialNum = SerialNumberFromConsoleId(consoleId);
            byte[] modelPrivateKey = CryptoReader.GetKey(KEY_TYPE_PLAYREADY_XBOX360_MODEL_PRIVATE_KEY, PLAYREADY_XBOX360_MODEL_PRIVATE_KEY_VERSION);
            byte[] modelCert = Config.GetBlobSetting("playready_model_cert");

            HResult hr = PlayReadyDeviceCertDll.CreateDeviceCertificate(modelPrivateKey, modelCert, serialNum , publicSigningKey, publicEncryptionKey, cert, out cbCert);

            if (hr.IsFailure())
            {
                throw new XRLException(hr, XEvent.Id.PLAYREADY_DEVICE_CERT_GENERATION_FAILURE, "Interop call to CreateDeviceCertificate failed.");
            }

            Array.Resize(ref cert, (int)cbCert);

            return cert;
        }


        // Calculate the serial number. This is the console id, compressed to five bytes, repeated enough to make 16 bytes.
        public static byte[] SerialNumberFromConsoleId(ulong consoleId)
        {
            byte[] bytesToRepeat = null;
            byte[] bytesToIgnore = null;
            ArrayUtil.SplitArray(BitConverter.GetBytes(consoleId), 5, out bytesToRepeat, out bytesToIgnore);
            return ArrayUtil.CombineArrays(bytesToRepeat, bytesToRepeat, bytesToRepeat, new byte[] { bytesToRepeat[0] });
        }

        private const int KEY_TYPE_PLAYREADY_XBOX360_MODEL_PRIVATE_KEY = 17;
        private const int PLAYREADY_XBOX360_MODEL_PRIVATE_KEY_VERSION = 1;
    }


    public static class PlayReadyDeviceCertDll
    {
        [DllImport("PlayReadyDeviceCert.dll")]
        private static extern UInt32 CreateDeviceCertificate(
            byte[] pbModelPrivateKey,
            UInt32 cbModelPrivateKey,
            byte[] pbModelCert,
            UInt32 cbModelCert,
            byte[] pbSerialNum,
            UInt32 cbSerialNum,
            byte[] pbSignKey,
            byte[] pbEncryptKey,
            byte[] pbCert,
            ref UInt32 pcbCert);

        public static HResult CreateDeviceCertificate(
            byte[] pbModelPrivateKey,
            byte[] pbModelCert,
            byte[] pbSerialNum,
            byte[] pbSignKey,
            byte[] pbEncryptKey,
            byte[] pbCert,
            out UInt32 pcbCert)
        {
            pcbCert = (uint)pbCert.Length;
            return CreateDeviceCertificate(pbModelPrivateKey, (uint)pbModelPrivateKey.Length, pbModelCert, (uint)pbModelCert.Length, pbSerialNum, (uint)pbSerialNum.Length, pbSignKey, pbEncryptKey, pbCert, ref pcbCert);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\CreatePlayReadyCertificate.cs ===
using System;
using System.Web;

using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.utilities;

namespace xonline.server.signature
{
    public sealed class CreatePlayReadyCertificate : IHttpHandler
    {
        public void ProcessRequest(HttpContext context)
        {
            byte[] signKey = new byte[0];
            byte[] encryptKey = new byte[0];
            ulong consoleId = 0;
            HResult hrInternal = HResult.S_OK;
            HResult hrReturn = HResult.S_OK;

            try
            {
                CreatePlayReadyCertificateRequest request = new CreatePlayReadyCertificateRequest();
                request.ReadFromRequest(context.Request);

                signKey = request.publicSigningKey;
                encryptKey = request.publicEncryptionKey;
                consoleId = ConsoleIdUtil.GetConsoleIdFromMachineId(SGInfo.Current.MachineId, XOn.XboxId.GetPlatformType(SGInfo.Current.MachineId));

                Validator validator = Validator.MakeValidatorChain(true, PlatformValidator.MakeXbox360PlatformValidator());
                if (!validator.DoCheck())
                {
                    throw new XRLException(HResult.E_ACCESSDENIED, XEvent.Id.PLAYREADY_DEVICE_CERT_INVALID_DEVICE,
                        "{0}.", validator.ErrorMessage);
                }

                byte[] cert = CreatePlayReadyCertificateImpl.CreatePlayReadyCertificate(consoleId, signKey, encryptKey);

                BlockSerializer serializer = new BlockSerializer(cert, 1, CreatePlayReadyCertificateResponse.CERTIFICATE_BLOCK_MAX_COUNT);
                if (serializer.IsEmptyBlockCount)
                {
                    throw new XRLException(HResult.XONLINE_E_SIGNATURE_PLAYREADY_DEVICE_CERT_EMPTY, XEvent.Id.PLAYREADY_DEVICE_CERT_EMPTY,
                        "Playready device cert is empty.");
                }
                if (serializer.IsBlockCountOutOfRange)
                {
                    throw new XRLException(HResult.XONLINE_E_SIGNATURE_PLAYREADY_DEVICE_CERT_TOO_BIG, XEvent.Id.PLAYREADY_DEVICE_CERT_TOO_LONG,
                        "Playready device cert is too long. Expected >= {0}; actual = {1}", MAX_DEVICE_CERT_LENGTH, cert.Length);
                }
                CreatePlayReadyCertificateResponse response = new CreatePlayReadyCertificateResponse();
                response.certBlocks = serializer.Serialize();
                response.certBlockCount = (ushort)response.certBlocks.Length;

                XRLUtil.SetXRLResponse(context.Response, XOService.Signature_Server, HResult.S_OK, response);
            }
            catch (Exception e)
            {
                hrInternal = XRLException.DeepToHResult(e, HResult.XONLINE_E_INTERNAL_ERROR);
                hrReturn = HResult.XONLINE_E_SIGNATURE_PLAYREADY_DEVICE_CERT_FAILED;
                throw new XRLException(hrReturn, XRLException.ToEventId(e, XEvent.Id.PLAYREADY_DEVICE_CERT_GENERAL_ERROR),
                    String.Format("Error in CreatePlayReadyCertificate. Hr = 0x{0:X8}. ConsoleId = 0x{1:X16}.", hrReturn, consoleId),
                    e);
            }
            finally
            {
                string logLine = String.Join("|", new string[] {
                    "PRDEVCERT",
                    hrReturn.ToString(),
                    hrInternal.ToString(),
                    String.Format("0x{0:X16}", BitConverter.ToUInt64(signKey, 8)),
                    String.Format("0x{0:X16}", BitConverter.ToUInt64(encryptKey, 8)),
                    consoleId.ToString("X16")
                });
                Xom.Log(XomAreaName.xsiglog, logLine);
            }
        }

        public bool IsReusable { get { return true; } }

        public const uint MAX_DEVICE_CERT_LENGTH = CreatePlayReadyCertificateResponse.CERTIFICATE_BLOCK_MAX_COUNT * XeGenericBlock.BLOCK_MAX_LEN;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\CreateCertificate2.cs ===
using System;
using System.Web;

using xonline.common.mgmt;      
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.utilities; // need ConsoleIdUtil

namespace xonline.server.signature
{
    public sealed class CreateCertificate2 : IHttpHandler
    {
        public void ProcessRequest(HttpContext context)
        {
            const int CONSOLE_ID_SIZE = 5;
            const int CONSOLE_CERT_PART_NUMBER_SIZE = 11;
            const int CONSOLE_CERTIFICATE_RESERVED_SIZE = 4;
            const int CONSOLE_PUBLIC_KEY_EXPONENT_SIZE = 4;
            const int CONSOLE_PUBLIC_KEY_MODULUS_SIZE = 128;

            HResult hr = HResult.S_OK;
            string appId = String.Empty;
            
            try
            {
                CreateCertificate2Request request = new CreateCertificate2Request();
                CreateCertificate2Response response = new CreateCertificate2Response();
                //XEConsoleCertificate cert = new XEConsoleCertificate();
                byte[] ConsolePublicKey = new byte[CONSOLE_PUBLIC_KEY_EXPONENT_SIZE + CONSOLE_PUBLIC_KEY_MODULUS_SIZE];

                request.ReadFromRequest(context.Request);

                // Use Request Data
                Array.Copy( request.ConsoleCertificate, // Source Array
                            sizeof( ushort ) + CONSOLE_ID_SIZE + CONSOLE_CERT_PART_NUMBER_SIZE + CONSOLE_CERTIFICATE_RESERVED_SIZE + sizeof( ushort ) + sizeof( uint ) + sizeof( ulong ),  // Source Index
                            ConsolePublicKey,   // Destination array
                            0,                  // Destination Index
                            CONSOLE_PUBLIC_KEY_EXPONENT_SIZE + CONSOLE_PUBLIC_KEY_MODULUS_SIZE // Length
                            );
                appId = request.appId;

                if ( 0 == appId.Length )
                    appId = "generic_ssl";  // BUGBUG: Investigate why appId is not getting here (Unicode?)
                        
                //cert.ReadBytes( request.ConsoleCertificate );

                CreateCertificate2Impl.CreateCertificate2( 
                    appId, request.ConsoleCertificate, request.Signature, ConsolePublicKey, out response.Certificate, out response.SerializedCertificate );

                response.CertificateSize = (ushort) response.Certificate.Length;
                response.SerializedCertificateSize = (ushort) response.SerializedCertificate.Length;

                XRLUtil.SetXRLResponse(context.Response, XOService.Signature_Server, HResult.S_OK, response);
            }
            catch (Exception e)
            {
                hr = XRLException.ToHResult(e, HResult.XONLINE_E_SIGNATURE_CREATE_CERTIFICATE_ERROR);
                throw new XRLException( hr, XEvent.Id.LICENSE_GENERAL, "CreateCertificate2 failed.", e);
            }
            finally
            {
                UInt64 consoleId = ConsoleIdUtil.GetConsoleIdFromMachineId(SGInfo.Current.MachineId, SGInfo.Current.GetPlatformType());
                
                string szLog = String.Join("|", new string[]
                    {
                        "CREATECERTIFICATE2",
                        appId,
                        SGInfo.Current.MachineId.ToString("X"),
                        ConsoleIdUtil.ConvertConsoleIdFromUInt64ToDecimalString(consoleId),
                        hr.ToString(),
                    });
                Xom.Log(XomAreaName.xsiglog, szLog);
            }
        }

        ///
        /// Can this instance be reusable?
        /// Since we hold no state in these requests, the answer is yes.
        ///
        public bool IsReusable { get { return true; } }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\CreateCertificate2Impl.cs ===
using System;
using System.Security.Cryptography;
using System.Web;

using xonline.common.protocol;
using xonline.common.service;
using xonline.common.utilities;

namespace xonline.server.signature
{
    public static class CreateCertificate2Impl
    {
        public static void CreateCertificate2( string appId, byte[] certificateBytes, byte[] signatureBytes, byte[] consolePublicKey, out byte[] clientCertificate, out byte[] serializedClientCertificate )
        {
            
            SGInfo.VerifyPlatformType(XOn.XPLT_XBOX360);
            SGInfo.VerifyServiceId(XOService.Signature_Server);
            string consoleId = ConsoleIdUtil.GetXbox360ConsoleIdStringFromMachineId(SGInfo.Current.MachineId);

            if ( !ValidateCertificate( consoleId, certificateBytes, signatureBytes ))
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_SIGNATURE_CREATE_CERTIFICATE_ERROR,   // ToDo: Create specific SIGNATURE ERROR for this case
                    "Console certificate signature error" );
            }


            // Actually create the certificates.
            ClientCertificateGenerator generator = ClientCertificateGenerator.GetCertificateGenerator( appId );
            ClientCertificate certificate = generator.GenerateCertificate( consoleId, consolePublicKey );

            // Create the response.  
            clientCertificate = certificate.Certificate;
            serializedClientCertificate = certificate.SerializedCertificate;
        }
        
        ///
        /// Private helper functions from here down, the documentation will be limitted.
        ///

        private static bool ValidateCertificate( string consoleId, byte[] certificateBytes, byte[] signatureBytes )
        {
            const int CONSOLE_ID_SIZE = 5;
            
            // This is g_XenonMasterSigningProdBsafePub2048 after being converted by CXoCryptoCspPk::ConvertKeyPubBsafeToCspImport
            byte[] xenonMasterSigningCspBytes = new byte[] {
6,2,0,0,0,36,0,0,82,83,65,49,0,8,0,0,3,0,0,0,187,55,77,153,111,73,95,221,67,184,166,93,242,152,91,228,172,212,164,60,253,16,211,190,175,99,59,219,121,58,
146,230,249,1,114,133,229,160,205,56,226,173,75,8,91,90,95,14,131,83,52,133,51,66,42,160,99,142,53,191,143,91,229,30,53,196,220,3,255,140,40,216,187,159,
54,193,26,13,228,2,63,16,134,236,78,222,237,144,37,120,58,217,150,253,31,228,132,189,150,31,139,211,225,56,36,168,208,186,86,42,94,246,147,235,154,161,60,
143,2,229,123,223,196,218,153,27,215,89,191,23,58,204,18,154,193,208,107,127,42,212,135,120,77,110,194,206,245,78,141,205,47,158,18,254,173,159,15,163,90,
160,228,82,92,242,111,32,116,101,130,209,174,13,37,60,193,176,234,139,205,229,68,215,96,124,206,2,12,122,27,181,128,108,63,74,54,57,61,81,36,12,0,86,129,
141,131,207,18,211,222,182,236,234,134,121,100,180,135,187,78,53,171,123,53,138,19,144,243,225,140,71,29,234,170,243,242,7,130,85,151,39,123,142,163,116,
143,71,83,249,138,171,251,203,119,252,184,174
                };

            //
            // Verify the Console Id versus the SG info
            //
            
            byte[] xenonConsoleId = new byte[CONSOLE_ID_SIZE];

            Array.Copy( certificateBytes,   // Source Array
                        sizeof( ushort ),   // Source Index
                        xenonConsoleId,     // Destination array
                        0,                  // Destination Index
                        CONSOLE_ID_SIZE     // Length
                        );

            string certificateDashConsoleId = ConsoleIdUtil.ConvertConsoleIdFromByteArrayToDecimalString( xenonConsoleId );

            if ( certificateDashConsoleId != consoleId )
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_SIGNATURE_CREATE_CERTIFICATE_ERROR,   // ToDo: Create specific SIGNATURE ERROR for this case
                    "Certificate validation ConsoleId mismatch error: Certificate: {0} SG : {1}", certificateDashConsoleId, consoleId );
            }

            //
            // Verify the certficate with the signature
            //
            
            // Get the sha1 digest.
            SHA1 sha1 = new SHA1Managed();
            RSACryptoServiceProvider csp = new RSACryptoServiceProvider();

            byte[] localSignature = new byte[signatureBytes.Length];

            // http://msdn.microsoft.com/en-us/library/system.security.cryptography.rsacryptoserviceprovider.aspx
            // *Interoperation with the Microsoft Cryptographic API (CAPI)*
            // Unlike the RSA implementation in unmanaged CAPI, the RSACryptoServiceProvider class reverses the
            // order of an encrypted array of bytes after encryption and before decryption. By default, data 
            // encrypted by the RSACryptoServiceProvider class cannot be decrypted by the CAPI CryptDecrypt 
            // function and data encrypted by the CAPI CryptEncrypt method cannot be decrypted by the 
            // RSACryptoServiceProvider class.
            Array.Copy(signatureBytes, localSignature, signatureBytes.Length);
            Array.Reverse(localSignature);
            signatureBytes = null; // Now we will throw an exception if we use this in the future, rather than having a subtle bug.

            byte[] computedDigest = sha1.ComputeHash( certificateBytes );

            // Master Public Key
            csp.ImportCspBlob( xenonMasterSigningCspBytes );

            // http://support.microsoft.com/kb/948080
            // The KB article above describes something similar to what was seen in Xbox 360 Console Software bug 132284
            // The article mentions a slowdown in attempting to reach the DC in order to perform "SHA" -> OID resolution,
            // and reflector showed that the RSAPKCS1SignatureDeformatter class is basically performing the same operation.
            // To prevent the calls to the DC from happening, the below signature was suggested.  Since the formatter class
            // was basically doing the same thing, there was no reason to continue to use that class, and just replaced the call.
            return csp.VerifyHash(computedDigest, null, localSignature);
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\CreateCertificate.cs ===
using System;
using System.Web;

using xonline.common.protocol;
using xonline.common.service;
using xonline.common.utilities;
using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;


namespace xonline.server.signature
{
    ///
    /// This is the class that hooks into ASP.NET to handle requests for
    /// certificate creation.  Most of the work involved is handed off to
    /// helper classes.
    ///
    public sealed class CreateCertificate : IHttpHandler
    {
        ///
        /// The central point that all certificate requests go through.
        /// The basic steps here are
        ///  1) Generate the certificates.
        ///  2) Send the certificates back to the client.
        /// Plus we have some ASP.NET process handling, errors, and logging thrown
        /// in for good measure.
        ///
        /// Breakpoint: xonline.server.signature.XmstvCreateCertificate.ProcessRequest
        public void ProcessRequest(HttpContext context)
        {
            uint hr = HResult.S_OK;
            string appId = String.Empty;
            ulong userPuid = 0;
            ulong machineId = 0;

            try
            {
                // Get the input request.
                CreateCertificateRequest request = new CreateCertificateRequest();
                request.ReadFromRequest(context.Request);

                SGInfo.VerifyPlatformType(XOn.XPLT_XBOX360);
                SGInfo.VerifyUserId(request.userPuid);
                SGInfo.VerifyServiceId(XOService.Signature_Server);

                appId = request.appId;
                userPuid = request.userPuid;
                machineId = SGInfo.Current.MachineId;

                // Actually create the certificates.
                string consolId = GetCurrentConsoleId();
                ClientCertificateGenerator generator = ClientCertificateGenerator.GetCertificateGenerator(request.appId);
                ClientCertificate certificate = generator.GenerateCertificate(consolId, request.PubKey);

                // Create the response.  
                CreateCertificateResponse response = CreateResponse(certificate);

                // Now send our response.
                XRLUtil.SetXRLResponse(context.Response, XOService.Signature_Server, HResult.S_OK, response);
            }
            catch (Exception e)
            {
                hr = XRLException.ToHResult(e, HResult.XONLINE_E_SIGNATURE_CREATE_CERTIFICATE_ERROR);
                throw;
            }
            finally
            {
                string szLog = String.Join("|", new string[]
                    {
                        "CASVC_CERTGEN",
                        machineId.ToString("X16"),
                        appId,
                        userPuid.ToString("X"),
                        hr.ToString("X"),
                    });
                Xom.Log(XomAreaName.xsiglog, szLog);
            }
        }

        ///
        /// Can this instance be reusable?
        /// Since we hold no state in these requests, the answer is yes.
        ///
        public bool IsReusable { get { return true; } }

        ///
        /// Private helper functions from here down, the documentation will be limitted.
        ///
        private static string GetCurrentConsoleId()
        {
            return ConsoleIdUtil.GetXbox360ConsoleIdStringFromMachineId(SGInfo.Current.MachineId);
        }

        private CreateCertificateResponse CreateResponse(ClientCertificate certificate)
        {
            CreateCertificateResponse response = new CreateCertificateResponse();

            response.CertificateSize = (ushort)certificate.Certificate.Length;
            response.Certificate = certificate.Certificate;
            response.SerializedCertificateSize = (ushort)certificate.SerializedCertificate.Length;
            response.SerializedCertificate = certificate.SerializedCertificate;

            return response;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\GetAAInfo.cs ===
// 
// GetAAInfo.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Allows the AAInfoInternetTier class to retrieve the AAInfo for a user based on 
// PassportPuid. For simplicity, it's being implemented in the Signature service. It may 
// move later on, as this isn't really the ideal place for this API to live.
//
// Author: kgoodier 7/2007
//

using System;
using System.Web;
using System.Collections;

using xonline.common.service;
using xonline.common.protocol;
using xonline.common.config;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using xonline.common.mgmt;

// Our protocol definition actually lives in AAInfoInternetTier.cs in 
// xonline.common.service, to reduce build dependences for it (not for us).

namespace xonline.server.signature
{
public sealed class GetAAInfo : IHttpHandler
{
    public void ProcessRequest(HttpContext ctx)
    {
        uint hr = HResult.S_OK;

        // @@@ review: how do we turn off the retrieval of SGInfo when exceptions are 
        // thrown?  Normally one does:
        //
        // EventBuilder.ShowSGInfo = false;
        //
        // But that is static, and will turn it off for the entire application. That's not 
        // what I want.

        // Check to make sure call is from DataCenter
        if (CallSource.Check(VirtualInterface.xsig_int) == VirtualInterface.None)
        {
            // Bad source
            GetAAInfoCounter.Counters.FailuresPerSecondGeneral.Increment();
            GetAAInfoCounter.Counters.FailuresTotalGeneral.Increment();
            throw new XRLException(HResult.XONLINE_E_ACCESS_DENIED, 
                                   XEvent.Id.SIGNATURE_CONFIG_CALLSOURCE, 
                                   "Request was not sent to the expected xsig_int interface.");
        }

        GetAAInfoRequest request = new GetAAInfoRequest();
        GetAAInfoResponse response = new GetAAInfoResponse();
            
        // Start time
        XomRequestTimeElapsed startTime = new XomRequestTimeElapsed();
            
        try
        {
            // We support versioning, yay!
            request.SchemaVersion = WireData.GetSchemaVersion(ctx.Request);
            request.ReadFromRequest(ctx.Request);

            // Load everything up from the database. Because all flavors of AAInfo use 
            // xbanc, we need to override it here and NOT use it. It's already been 
            // determined that xbanc doesn't have the info we need, and we don't want to 
            // doubly-insert stuff to it.

            // request.LiveXuid may be 0, in which case we need to look up the LiveXuid 
            // ourself.
            AAInfo aa = AAInfoMiddleTier.NewLocalInstance(
                request.PassportPuid,
                request.LiveXuid == 0 ? (ulong?)null : (ulong?)request.LiveXuid,
                request.IpAddressInternet);

            response.SchemaVersion = WireData.GetSchemaVersion(ctx.Request);
            response.LiveXuid = aa.LiveXuid;
            response.CountryId = aa.CountryId;
            response.UserPrivileges = AAInfo.BitArrayToIntArray(aa.UserPrivileges);

            XRLUtil.SetXRLResponse(ctx.Response, XOService.Signature_Server, HResult.S_OK, response);
           
            if (response.LiveXuid != 0)
            {
                // Success!
                GetAAInfoCounter.Counters.RequestsPerSecond.Increment();
                GetAAInfoCounter.Counters.RequestsTotal.Increment();
            }
            else
            {
                // Not found failure
                GetAAInfoCounter.Counters.FailuresPerSecondNotFound.Increment();
                GetAAInfoCounter.Counters.FailuresTotalNotFound.Increment();
            }

        }
        catch (Exception e)
        {
            // General failure
            GetAAInfoCounter.Counters.FailuresPerSecondGeneral.Increment();
            GetAAInfoCounter.Counters.FailuresTotalGeneral.Increment();

            hr = XRLException.ToHResult(e, HResult.XONLINE_E_SIGNATURE_GET_AA_INFO_ERROR);
            if (e is XRLException)
            {
                throw;
            }
            else
            {
                throw new XRLException(hr, 
                                       XEvent.Id.AAINFO_GETAAINFO_GENERAL, 
                                       e, 
                                       "Generic GetAAInfo failure.");
            }
        }
        finally
        {
            // Elapsed time counters
            GetAAInfoCounter.Counters.AverageExecutionTime.IncrementBy(startTime.TimeElapsed * 1000);
            GetAAInfoCounter.Counters.AverageExecutionTimeBase.Increment();

            string szLog = String.Join("|", new string[]
            {
                "GETAAINFO",
                request.PassportPuid.ToString("X"),
                request.IpAddressInternet,
                response.LiveXuid.ToString("X"),
                hr.ToString("X"),
                response.LiveXuid != 0 ? "1" : "0",     // ok?
            });
            Xom.Log(XomAreaName.xsiglog, szLog);
        }
    }


    // We hold no state, thus we are reusable.
    public bool IsReusable { get { return true; } }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\GetSignedHeader.cs ===
using System;
using System.Web;

using xonline.common.protocol;
using xonline.common.service;

namespace xonline.server.signature
{
    public sealed class GetSignedHeader : IHttpHandler
    {
        public void ProcessRequest(HttpContext context)
        {
            try
            {
                GetSignedHeaderRequest request = new GetSignedHeaderRequest();
                request.ReadFromRequest(context.Request);

                GetSignedHeaderResponse response = new GetSignedHeaderResponse();
                response.header = GetSignedHeaderImpl.GetHeaderForFile(request.fileSize, request.fileType, request.fileHash);

                XRLUtil.SetXRLResponse(context.Response, XOService.Signature_Server, HResult.S_OK, response);
            }
            catch (XRLException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XRLException(XRLException.ToHResult(e, HResult.XONLINE_E_SIGNATURE_GET_SIGNED_HEADER_ERROR), XEvent.Id.LICENSE_GENERAL, "GetSignedHeader failed.", e);
            }
        }

        ///
        /// Can this instance be reusable?
        /// Since we hold no state in these requests, the answer is yes.
        ///
        public bool IsReusable { get { return true; } }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\LicenseAvailabilityImpl.cs ===
using System;
using System.Xml.Serialization;

using xonline.common.protocol;
using xonline.common.service;


namespace xonline.server.signature
{
    public class Availability : ILicenseApiResponse
    {
        public MediaInstanceIdOfferIdPair idPair;

        public HResult hr;

        [XmlIgnoreAttribute]
        public MediaInstanceIdOfferIdPair IdPair { get { return idPair; } set { idPair = value; } }
        [XmlIgnoreAttribute]
        public HResult Hr { get { return hr; } set { hr = value; } }
    }

    class AvailabilityLicenseApiResponseGenerator : ILicenseApiResponseGenerator<Availability>
    {
        public void ProcessResponse(LicenseApiParams apiParams, Availability avail)
        {
            Validator validator = LicenseAvailabilityValidatorFactory.GetValidator(apiParams);
            if (!validator.DoCheck())
            {
                apiParams.LogMessage = validator.LogError;
                avail.hr = validator.Hr;
            }
            else
            {
                avail.hr = HResult.S_OK;
            }
        }

        public string LogTitle { get { return "LICENSE_AVAIL"; } }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\GetSignedHeaderImpl.cs ===
using System;
using System.Security.Cryptography;

using xonline.common.service;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.xcrypto;

namespace xonline.server.signature
{
    public static class GetSignedHeaderImpl
    {
        public static byte[] GetHeaderForFile(uint fileSize, uint fileType, byte[] fileHash)
        {
            uint hr = HResult.S_OK;
            SignedHeader signedHeader = null;

            try
            {
                CallSource.Check(VirtualInterface.xsig_int);

                if (fileSize == 0)
                {
                    throw new ArgumentException("fileSize must be non-zero", "filesize");
                }

                if (fileHash.Length != GetSignedHeaderRequest.XONLINE_HEADER_HASH_SIZE)
                {
                    throw new ArgumentException(String.Format(
                        "fileHash.Length must be exactly {0}, but is {1}.", GetSignedHeaderRequest.XONLINE_HEADER_HASH_SIZE, fileHash.Length),
                        "fileHash");
                }

                signedHeader = new SignedHeader();
                signedHeader.fileType = fileType;
                signedHeader.headerVersion = HeaderVersion.V1;
                signedHeader.headerSize = SignedHeader.SerializedHeaderSize;
                signedHeader.fileSize = fileSize;
                signedHeader.flags = HeaderFlagsFromKeyType(CryptoKeyProxy.QueryKeyType(SIGNING_CONTAINER));
                signedHeader.signedDateTime = DateTime.UtcNow;
                signedHeader.fileHash = fileHash;

                signedHeader.signature = new byte[SignedHeader.SIGNATURE_SIZE];
                uint sigLength;
                CryptoKeyProxy.Sign(SIGNING_CONTAINER, s_sha1.ComputeHash(signedHeader.SerializeForHash()), signedHeader.signature, out sigLength);
                return signedHeader.ToArray();
            }
            catch (Exception e)
            {
                hr = XRLException.ToHResult(e, HResult.XONLINE_E_SIGNATURE_ERROR);
                throw;
            }
            finally
            {
                string logLine = String.Join("|", new string[]
                    {
                        "GET_SIGNED_HEADER",
                        hr.ToString("X"),
                        fileSize.ToString(),
                        fileType.ToString(),
                        signedHeader == null ? HeaderVersion.VError.ToString() : signedHeader.headerVersion.ToString(),
                        signedHeader == null ? "0" : signedHeader.headerSize.ToString(),
                        signedHeader == null ? "fail" : signedHeader.signedDateTime.ToString(),
                        signedHeader == null ? "0" : signedHeader.flags.ToString("X"),
                    });
                Xom.Log(XomAreaName.xsiglog, logLine);
            }
        }

        private static readonly SHA1Managed s_sha1 = new SHA1Managed();

        private const EContainerClasses SIGNING_CONTAINER = EContainerClasses.Drm;

        public enum HeaderVersion : uint
        {
            VError = 0,
            V1 = 1,
        }

        [Flags]
        public enum HeaderFlags : uint
        {
            None = 0,

            RedSigned = 0x80000000,
        }

        private static HeaderFlags HeaderFlagsFromKeyType(XCryptoKeyType keyType)
        {
            return keyType == XCryptoKeyType.Test ? HeaderFlags.RedSigned : HeaderFlags.None;
        }

        public sealed class SignedHeader : WireData
        {
            public UInt32 fileType;
            public HeaderVersion headerVersion;
            public UInt32 headerSize;
            public DateTime signedDateTime;
            public UInt32 fileSize;
            public HeaderFlags flags;

            [WireInfo(ArraySize = GetSignedHeaderRequest.XONLINE_HEADER_HASH_SIZE, LimitString = true)]
            public byte[] fileHash;

            [WireInfo(ArraySize = SIGNATURE_SIZE, LimitString = true)]
            public byte[] signature;

            public const int SIGNATURE_SIZE = 256;

            public byte[] SerializeForHash()
            {
                byte[] bytes = this.ToArray();
                Array.Resize(ref bytes, bytes.Length - SIGNATURE_SIZE);
                return bytes;
            }

            public static uint SerializedHeaderSize { get { return s_serializedSize; } }

            static SignedHeader()
            {
                SignedHeader dummy = new SignedHeader();
                dummy.fileType = 0;
                dummy.headerVersion = HeaderVersion.V1;
                dummy.headerSize = 0;
                dummy.signedDateTime = DateTime.UtcNow;
                dummy.fileSize = 0;
                dummy.flags = HeaderFlags.None;
                dummy.fileHash = new byte[GetSignedHeaderRequest.XONLINE_HEADER_HASH_SIZE];
                dummy.signature = new byte[SIGNATURE_SIZE];

                s_serializedSize = (uint) dummy.Size();
            }

            private readonly static uint s_serializedSize;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\LicenseAcknowledgementImpl.cs ===
using System;

using xonline.common.protocol;
using xonline.common.service;


namespace xonline.server.signature
{
    class AcknowledgeLicenseApiResponseGenerator : ILicenseApiResponseGenerator<Acknowledgement>
    {
        public void ProcessResponse(LicenseApiParams apiParams, Acknowledgement ack)
        {
            if (!LicenseStateUtil.IsLicenseAcknowledged(apiParams.Xuid, apiParams.Rights.mediaInstanceId, apiParams.Rights.offerInstanceId))
            {
                return;
            }

            Validator validator = AcknowledgeLicensesValidatorFactory.GetValidator(apiParams);
            if (!validator.DoCheck())
            {
                apiParams.LogMessage = validator.LogError;
                throw new XRLException(LicenseMisc.MapToWhiteListedHResult(validator.Hr), XEvent.Id.LICENSE_INVALID_REQUEST, validator.ErrorMessage);
            }

            LicenseStateUtil.SetLicenseState(apiParams.Xuid, apiParams.Rights.mediaInstanceId, apiParams.Rights.offerInstanceId, LicenseState.Acknowledged);
        }

        public string LogTitle { get { return "LICENSE_ACK"; } }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\LicenseImpl.cs ===
using System;
using System.Collections.Generic;

using xonline.common.protocol;
using xonline.common.service;
using xonline.common.billing;
using xonline.common.mgmt;
using xonline.common.config;

using RightsList = System.Collections.Generic.List<xonline.common.billing.UserRightsUtil.MediaInstanceRights>;

namespace xonline.server.signature
{
    static class LicenseImpl
    {
        //
        // Highly generic function that can be used to process a licensing api request.
        //
        public static TResponse[] GenericLicenseApi<TGenerator, TResponse>(MediaInstanceIdOfferIdPair[] idPairs, ulong xuid, string clientInfo)
            where TGenerator: ILicenseApiResponseGenerator<TResponse>, new()
            where TResponse: ILicenseApiResponse, new()
        {
            CallSource.Check(VirtualInterface.xsig, VirtualInterface.xsig_int);

            RightsList mirs = UserMediaInstanceRightsUtil.GetVideoMediaInstanceRights(xuid, idPairs);
            UserMediaInstanceRightsUtil.EnsureMachineId(mirs);
            UserMediaInstanceRightsUtil.EnsureAllItemsPresentInRights(idPairs, mirs);

            mirs.ForEach(delegate(UserRightsUtil.MediaInstanceRights rights)
                { XmlDocumentAndNamespaceManagerCache.PutXmlDocumentAndNamespaceManager(rights.licenseXml, rights.licenseTypeId); } );

            TGenerator generator = new TGenerator();
            TResponse[] responses = new TResponse[mirs.Count];
            for (int idx = 0; idx < mirs.Count; ++idx)
            {
                LicenseApiParams apiParams = new LicenseApiParams(mirs[idx], xuid, clientInfo);
                responses[idx] = GenerateGenericLicenseApiResponse<TResponse>(generator, apiParams);
            }

            UserMediaInstanceRightsUtil.FlushPurchaseHistory(xuid, mirs);

            return responses;
        }

        //
        // Highly generic function to generate a single response for the licensing apis--call this multiple times to
        // create a full response.
        private static TResponse GenerateGenericLicenseApiResponse<TResponse>(ILicenseApiResponseGenerator<TResponse> generator, LicenseApiParams apiParams)
            where TResponse : ILicenseApiResponse, new()
        {
            // Do the initial population of the license. The only failure we could have here
            // is a memory failure, and that's highly unlikely so we'll let that slide.
            TResponse response = new TResponse();
            response.IdPair = new MediaInstanceIdOfferIdPair();
            response.IdPair.miid = apiParams.Rights.mediaInstanceId;
            response.IdPair.oid = apiParams.Rights.offerId;
            response.Hr = HResult.S_OK;

            // Now actually get the license. Note that we swallow *all* exceptions. Generally I don't like
            // to do this, but we want to be able to return a Response no matter what, with an
            // error code if it's bad.
            try
            {
                generator.ProcessResponse(apiParams, response);
            }
            catch (Exception e)
            {
                response.Hr = XRLException.ToHResult(e, HResult.XONLINE_E_SIGNATURE_GENERATE_LICENSE_RESPONSE_ERROR);
                Xom.NtEvent(XEvent.Id.LICENSE_GENERAL, e, "{0} request failed, hr = {1}.", generator.LogTitle, response.Hr);
            }
            finally
            {
                string logLine = String.Join("|", new string[]
                    {
                        generator.LogTitle,
                        apiParams.Rights.mediaInstanceId.ToString(),
                        apiParams.Rights.offerInstanceId.ToString(),
                        apiParams.Rights.machineId.ToString("x"),
                        SGVsAAHelper.CurrentMachineId.ToString("x"),
                        apiParams.Xuid.ToString("x"),
                        response.Hr.ToString(),
                        apiParams.Rights.licenseTypeId.ToString(),
                        apiParams.Rights.scoid,
                        apiParams.Rights.syncCastKey,
                        apiParams.LogMessage,
                    });
                Xom.Log(XomAreaName.xsiglog, logLine);
                Xom.Log(XomAreaName.Reporting, logLine);
            }

            return response;
        }
    }


    //
    // Parameters for licensing apis. This makes it easier to pass everything we need around.
    //
    class LicenseApiParams
    {
        public LicenseApiParams(UserRightsUtil.MediaInstanceRights rights, ulong xuid, string clientInfo)
        {
            _rights = rights;
            _xuid = xuid;
            _clientInfo = clientInfo;
        }

        public UserRightsUtil.MediaInstanceRights Rights { get { return _rights; } }
        public ulong Xuid { get { return _xuid; } }
        public string ClientInfo { get { return _clientInfo; } }
        public string LogMessage
        {
            get { return _logMessage; }
            set { _logMessage = value; }
        }

        private readonly UserRightsUtil.MediaInstanceRights _rights;
        private readonly ulong _xuid;
        private readonly string _clientInfo;
        private string _logMessage = String.Empty;
    }


    interface ILicenseApiResponseGenerator<TResponse>
    {
        void ProcessResponse(LicenseApiParams apiParams, TResponse response);
        string LogTitle { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\LicenseTransferImpl.cs ===
using System;
using System.Collections;
using System.Collections.Generic;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.utilities;

namespace xonline.server.signature
{
    class TransferStateTransitions
    {
        public LicenseTransferStatusEnum currentStatus;

        public UpdateTransferStateEnum[] validCommands;

        public TransferStateTransitions(LicenseTransferStatusEnum status, UpdateTransferStateEnum[] commands)
        {
            currentStatus = status;
            validCommands = commands;
        }
    }

    internal sealed class LicenseCounter
    {
        public static void GetLicenseCounts(WstDataReader reader, GetLicenseTransferStateResponse state)
        {
            LicenseCounter counter = new LicenseCounter(reader);
            counter.GetLicenseCounts(state);
        }

        private LicenseCounter(WstDataReader reader)
        {
            _reader = reader;
        }

        private void GetLicenseCounts(GetLicenseTransferStateResponse state)
        {
            state.sourceConsoles = ReadSetOfLicenseCounts();

            // Second result is video licenses.
            if (_reader.NextResult())
            {
                state.sourceVideoConsoles = ReadSetOfLicenseCounts();
            }
        }

        private string GetConsoleId(Int64 puid)
        {
            if (!_consoleLookup.ContainsKey(puid))
            {
                _consoleLookup[puid] = LicenseTransferUtil.ConsoleIdFromMachinePuid((UInt64)puid);
            }

            return _consoleLookup[puid];
        }

        private ConsoleLicenseCount[] ReadSetOfLicenseCounts()
        {
            ArrayList consoleList = new ArrayList();

            while (_reader.Read())
            {
                ConsoleLicenseCount entry = new ConsoleLicenseCount();
                entry.licenseCount = (uint)_reader.GetInt32(0);
                entry.consoleId = GetConsoleId(_reader.GetInt64(1));
                consoleList.Add(entry);
            }

            return (ConsoleLicenseCount[])consoleList.ToArray(typeof(ConsoleLicenseCount));
        }

        private readonly WstDataReader _reader;
        private readonly Dictionary<Int64, string> _consoleLookup = new Dictionary<Int64, string>();
    }

    static class LicenseTransferUtil
    {
        internal static string ConsoleIdFromMachinePuid(UInt64 machinePuid)
        {
            if (machinePuid == 0)
            {
                return String.Empty;
            }
            else
            {
                return ConsoleIdUtil.TrimConsoleIdPrefix(ConsoleIdUtil.GetXbox360ConsoleIdStringFromMachineId(machinePuid));
            }
        }

        static TransferStateTransitions[] _validTransitions = new TransferStateTransitions[]
            {
                new TransferStateTransitions(
                    LicenseTransferStatusEnum.MultipleSignInDetected,
                    new UpdateTransferStateEnum[] { UpdateTransferStateEnum.Cancel, UpdateTransferStateEnum.Start }
                    ),
                new TransferStateTransitions(
                    LicenseTransferStatusEnum.LicenseTransferTimeout,
                    new UpdateTransferStateEnum[] { UpdateTransferStateEnum.Cancel, UpdateTransferStateEnum.Start }
                    ),
                new TransferStateTransitions(
                    LicenseTransferStatusEnum.NotStarted,
                    new UpdateTransferStateEnum[] { UpdateTransferStateEnum.Start }
                    ),
                new TransferStateTransitions(
                    LicenseTransferStatusEnum.PendingConsoleSignIn,
                    new UpdateTransferStateEnum[] { UpdateTransferStateEnum.Cancel }
                    ),
                new TransferStateTransitions(
                    LicenseTransferStatusEnum.PendingUserConfirmation,
                    new UpdateTransferStateEnum[] { UpdateTransferStateEnum.Complete, UpdateTransferStateEnum.Cancel }
                    ),
                new TransferStateTransitions(
                    LicenseTransferStatusEnum.Completed,
                    new UpdateTransferStateEnum[] { UpdateTransferStateEnum.Start }
                    )
            };

        static bool CommandAllowed(UpdateTransferStateEnum command, LicenseTransferStatusEnum status, DateTime lastUpdated)
        {
            bool valid;

            valid = Array.Exists(_validTransitions,
                        delegate (TransferStateTransitions transition)
                        {
                            return transition.currentStatus == status &&
                                Array.Exists(transition.validCommands,
                                             delegate (UpdateTransferStateEnum cmd) { return cmd == command; });
                        }
            );

            // If passes basic state transition check, add check for completed restart interval
            if (valid && status == LicenseTransferStatusEnum.Completed)
            {
                valid = LicenseTransferStateUtil.CompletedTransferRestartAllowed(lastUpdated);
            }

            return valid;
        }

        public static void UpdateLicenseTransferState(UInt64 userPuid, UpdateTransferStateEnum command)
        {
            LicenseTransferStateUtil.VerifyValidUser(userPuid);

            int dbState = 0;
            DateTime lastUpdated = DateTime.MinValue;

            // Get the current status of the transfer and validate it against the state machine
            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_user_license_transfer_get_state";
                ws.SetHashVal(userPuid);
                ws.AddParameter("@bi_xuid", userPuid);
                ws.AddParameter("@i_licenses_fetch_level", 0);

                using (WstDataReader response = ws.Execute())
                {
                    if (response.Read())
                    {
                        dbState = response.GetInt32(2);
                        lastUpdated = response.GetDateTime(3);
                    }
                }
            }

            LicenseTransferStatusEnum status = LicenseTransferStateUtil.MapDbStateToLicenseTransferStatus(dbState, lastUpdated);
            if (!CommandAllowed(command, status, lastUpdated))
            {
                throw new XRLException(
                        HResult.XONLINE_E_SIGNATURE_LICENSE_TRANSFER_BAD_COMMAND,
                        XEvent.Id.LICENSE_GENERAL,
                        "License transfer attempt for user 0x{0:X16} failed due to invalid command {1} for status {2}.", userPuid, command, status);
            }

            switch (command)
            {
                case UpdateTransferStateEnum.Start:
                    if (!SGInfo.IsXbox360())
                    {
                      BeginLicenseTransferProcess(userPuid);
                    }
		    else
                    {
                      BeginLicenseTransferProcessXbox360(userPuid);
                    }
                    break;
                case UpdateTransferStateEnum.Complete:
                    uint hr = CommitUserLicenseTransfer(userPuid);
                    if (hr != HResult.S_OK)
                    {
                        throw new XRLException(hr, XEvent.Id.LICENSE_GENERAL, "Failed to update the user licenses.");
                    }
                    break;
                case UpdateTransferStateEnum.Cancel:
                    CancelUserLicenseTransfer(userPuid);
                    break;
            }
        }

        static void BeginLicenseTransferProcess(UInt64 xuid)
        {
            // Before beginning the transfer process, kick the user off of live to force a login
            KickMsg kick = new KickMsg();

            kick.qwUserID = xuid;
            kick.fFlushTickets = 0; // This logout does not require a ticket reload

            uint hr = XRLUtil.PostXrlRequest(VirtualInterface.xpnfd_presence_int, kick.Xrl, kick);

            if (HResult.Failed(hr))
            {
                throw new XRLException(hr, XEvent.Id.LICENSE_GENERAL, "Unable to kick user from presence");
            }

            using (WSClient ws = CreateLicenseTransferWsClient("dbo.p_user_license_transfer_begin", xuid, false))
            {
                ws.AddParameter("@si_hash_bucket", ws.Partition);
                ws.ExecuteNonQuery();
            }
        }

        static void BeginLicenseTransferProcessXbox360(UInt64 userPuid)
        {
            //first we get it started with the transfer begin
            //sets transfer state to 1 and adds a transfer record
            using (WSClient ws = CreateLicenseTransferWsClient("dbo.p_user_license_transfer_begin", userPuid, false))
            {
                ws.AddParameter("@si_hash_bucket", ws.Partition);
                ws.ExecuteNonQuery();
            }

            //Since we are not forcing the client to relog, disconnect, go back through presence
            //then we have to push the next step here since the normal triggers will not happen
            //when this is being done through the xbox360 client
            //sets the transfer state to 2 
            using (WSClient ws = CreateLicenseTransferWsClient("dbo.p_user_license_transfer_set_destination_console",  
                                                                userPuid, false))
            {
               ws.PartitionType = WstPartitionType.Logical;
               ws.SetHashVal(userPuid);
               ws.AddParameter("@bi_destination_machine_puid", SGInfo.Current.MachineId);

               ws.ExecuteNonQuery();
            } 

            //To push to the next step (status to 3) you need to call with the completed
            //state just as when you do a transfer from xbox.com

        }

        static uint CommitUserLicenseTransfer(UInt64 xuid)
        {
            using (WSClient ws = CreateLicenseTransferWsClient("dbo.p_user_license_transfer_commit", xuid, true))
            {
                ws.AddParameter("@vc_new_ip_address", SGVsAAHelper.CurrentIpAddress);
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                ws.ExecuteNonQuery();

                return (uint)ws.GetIntParameter("@RETVAL");
            }
        }

        static void CancelUserLicenseTransfer(UInt64 xuid)
        {
            using (WSClient ws = CreateLicenseTransferWsClient("dbo.p_user_license_transfer_cancel", xuid, false))
            {
                ws.ExecuteNonQuery();
            }
        }

        static WSClient CreateLicenseTransferWsClient(string sproc, UInt64 xuid, bool useRetVal)
        {
            WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE);
            ws.StoredProc = sproc;
            ws.SetHashVal(xuid);
            ws.AddParameter("@bi_xuid", xuid);
            if (useRetVal)
            {
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
            }
            return ws;
        }

    }

    static class LicenseTransferStateUtil
    {
        static uint _minDaysToRestart;
        static uint _completionTimeout;

        static LicenseTransferStateUtil()
        {
            Config.SettingChange += OnSettingChange;

            // Register interest in the settings that need to be read.
            // Should care if the values fail to load, but not as part of static constructor.
            _minDaysToRestart = Config.GetUIntSetting(Setting.signature_licenseTransferMinDaysToRestart);
            _completionTimeout = Config.GetUIntSetting(Setting.signature_licenseTransferTimeoutInMinutes);
        }

        static void OnSettingChange(object sender, SettingChangeEventArgs args)
        {
            switch (args.Setting)
            {
                case Setting.signature_licenseTransferMinDaysToRestart:
                    _minDaysToRestart = UInt32.Parse(args.ValueNew);
                    break;
                case Setting.signature_licenseTransferTimeoutInMinutes:
                    _completionTimeout = UInt32.Parse(args.ValueNew);
                    break;
            }
        }

        public static GetLicenseTransferStateResponse GetLicenseTransferStatus(UInt64 xuid)
        {
            VerifyValidUser(xuid);

            GetLicenseTransferStateResponse state = new GetLicenseTransferStateResponse();

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_user_license_transfer_get_state";
                ws.SetHashVal(xuid);
                ws.AddParameter("@bi_xuid", xuid);
                ws.AddParameter("@i_licenses_fetch_level", 1);

                using (WstDataReader response = ws.Execute())
                {
                    if (response.Read())
                    {
                        int dbState;
                        DateTime lastUpdated;

                        state.consoleId = LicenseTransferUtil.ConsoleIdFromMachinePuid((UInt64)response.GetInt64(1));

                        dbState = response.GetInt32(2);
                        lastUpdated = response.GetDateTime(3);

                        state.currentStatus = MapDbStateToLicenseTransferStatus(dbState, lastUpdated);

                        if (state.currentStatus == LicenseTransferStatusEnum.Completed)
                        {
                            // Only allow a license transfer restart if the date is in the past
                            state.restartAllowed = CompletedTransferRestartAllowed(lastUpdated);
                        }
                        state.lastUpdated = lastUpdated;

                        state.nextAvailableTransfer = lastUpdated.AddDays(_minDaysToRestart);
                    }

                    if (!response.NextResult())
                    {
                        throw new Exception("Internal error: can't enumerate license counts from db");
                    }

                    LicenseCounter.GetLicenseCounts(response, state);
                }
            }

            return state;
        }

        internal static bool CompletedTransferRestartAllowed(DateTime lastUpdated)
        {
            DateTime allowRestartDate = lastUpdated.AddDays(_minDaysToRestart);
            return allowRestartDate.CompareTo(DateTime.UtcNow) <= 0;
        }

        internal static LicenseTransferStatusEnum MapDbStateToLicenseTransferStatus(int dbState, DateTime lastUpdated)
        {
            DateTime timeoutDate = lastUpdated.AddMinutes(_completionTimeout);

            switch (dbState)
            {
                case 0:
                    return LicenseTransferStatusEnum.NotStarted;
                case 1:
                    return StatusOrTimeout(LicenseTransferStatusEnum.PendingConsoleSignIn, timeoutDate);
                case 2:
                    return StatusOrTimeout(LicenseTransferStatusEnum.PendingUserConfirmation, timeoutDate);
                case 3:
                    return LicenseTransferStatusEnum.Completed;
                case -1:
                    return LicenseTransferStatusEnum.MultipleSignInDetected;
                default:
                    throw new Exception("Unknown DbState: " + dbState);
            }
        }

        static LicenseTransferStatusEnum StatusOrTimeout(LicenseTransferStatusEnum state, DateTime timeoutDate)
        {
            return timeoutDate.CompareTo(DateTime.UtcNow) >= 0 ? state : LicenseTransferStatusEnum.LicenseTransferTimeout;
        }

        internal static void VerifyValidUser(ulong xuid)
        {
            // Fail early on a bad user--this provides a better error than what we'd get 
            // in the sproc below.
            if (XCache.IsInvalidGamertag(XCache.LookupGamerTag(xuid)))
            {
                throw new XRLException(
                        HResult.E_INVALIDARG,
                        XEvent.Id.LICENSE_GENERAL,
                        "User 0x{0:X16} passed into license transfer API is invalid.", xuid);
            }

            SGVsAAHelper.VerifyUser(xuid);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\LicenseGenerationImpl.cs ===
using System;
using System.IO;
using System.Xml;
using System.Security.Cryptography;
using System.Reflection;
using System.Runtime.ConstrainedExecution;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Permissions;

using xonline.common.protocol;
using xonline.common.service;
using xonline.common.billing;
using xonline.common.mgmt;
using xonline.common.crypto;
using xonline.common.sql.webstore;
using xonline.common.config;

using WMRMOBJSLib;
using Microsoft.Webstore.WstClient;

[assembly: XomAreaDefinition(XomAreaName.Reporting)]


namespace xonline.server.signature
{
    class AcquireLicenseApiResponseGenerator : ILicenseApiResponseGenerator<MediaLicense>
    {
        public void ProcessResponse(LicenseApiParams apiParams, MediaLicense license)
        {
            FixupPpvRepurchase(apiParams);
            Validator validator = AcquireLicenseValidatorFactory.GetValidator(apiParams);
            if (!validator.DoCheck())
            {
                if (validator.Hr == HResult.XONLINE_E_SIGNATURE_LICENSE_NOT_ACQUIRABLE)
                {
                    LicenseStateUtil.SetLicenseState(apiParams.Xuid, apiParams.Rights.mediaInstanceId, apiParams.Rights.offerInstanceId, LicenseState.Expired);
                }
                apiParams.LogMessage = validator.LogError;
                throw new XRLException(LicenseMisc.MapToWhiteListedHResult(validator.Hr), XEvent.Id.LICENSE_INVALID_REQUEST, validator.ErrorMessage);
            }

            EmsLicenseGenerator licenseGenerator = new EmsLicenseGenerator(apiParams);

            license.license = licenseGenerator.GenerateLicense();

            RecordLicenseAcquisition(apiParams);
            ReportLicenseAcquisition(apiParams);
            UserMediaInstanceRightsUtil.UpdatePurchaseRecordWithMachineId(apiParams.Xuid, apiParams.Rights);
        }

        public string LogTitle { get { return "LICENSE_REQUEST"; } }


        private static void FixupPpvRepurchase(LicenseApiParams apiParams)
        {
            // Short circuit if they don't have rights to this--we will catch this later.
            // Alternately I could set up two validator chains--the pre-validator and post-validator
            // Since we only have the one check, I'll do this.
            if (apiParams.Rights.licenseTypeId == UserMediaInstanceRightsUtil.NO_LICENSE_TYPE)
            {
                return;
            }

            ulong xuid = apiParams.Xuid;
            Guid miid = apiParams.Rights.mediaInstanceId;
            Guid oiid = apiParams.Rights.offerInstanceId;

            LicenseXmlHelper xmlHelper = new LicenseXmlHelper(apiParams.Rights.licenseTypeId, CatalogEnumMap.ClientEnumFromXplt(SGVsAAHelper.GetPlatform()));
            if (xmlHelper.IsOfferType("PPV"))
            {
                if (!LicenseStateUtil.IsLicenseAcknowledged(xuid, miid, oiid))
                {
                    DateTime dt;
                    if (LicenseStateUtil.TryGetLicenseStateChangedDate(xuid, miid, oiid, out dt))
                    {
                        if (apiParams.Rights.purchaseDate > dt)
                        {
                            LicenseStateUtil.RemoveLicenseState(xuid, miid, oiid);
                        }
                    }
                }
            }
        }

        private static void RecordLicenseAcquisition(LicenseApiParams apiParams)
        {
            if (LicenseXmlHelper.LicenseTypeRequiresCounting(apiParams.Rights.licenseTypeId, CatalogEnumMap.ClientEnumFromXplt(SGVsAAHelper.GetPlatform())))
            {
                LicenseStateUtil.SetLicenseState(apiParams.Xuid, apiParams.Rights.mediaInstanceId, apiParams.Rights.offerInstanceId, LicenseState.AcquiredTrackLicenseCount);
            }
        }

        private static void ReportLicenseAcquisition(LicenseApiParams apiParams)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.SetHashVal(apiParams.Xuid);
                ws.StoredProc = "p_report_pending_dmp";

                ws.AddParameter("@bi_xuid", apiParams.Xuid);
                ws.AddParameter("@bi_machine_puid", apiParams.Rights.machineId);
                ws.AddParameter("@uid_offer_instance_id", apiParams.Rights.offerInstanceId);
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                ws.ExecuteNonQuery();
            }
        }
    }

    [SuppressUnmanagedCodeSecurity, HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
    internal sealed class SafeLibraryHandle : Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid
    {
        // Methods
        internal SafeLibraryHandle()
            : base(true)
        {
        }

        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success), DllImport("kernel32.dll", CharSet = CharSet.Unicode)]
        private static extern bool FreeLibrary(IntPtr hModule);

        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
        internal static extern SafeLibraryHandle LoadLibraryEx(string libFilename, IntPtr reserved, int flags);

        protected override bool ReleaseHandle()
        {
            return FreeLibrary(base.handle);
        }
    }

    internal class EmsLicenseGenerator
    {
        // Xenon 120372 -- on the assumption that the process is going bad due to constant loading and unloading dlls, we are going to take
        // a lock on the wmrm library and msxml3 (which it uses internally) to keep them in memory.

        static SafeLibraryHandle msxml3Lib;
        static SafeLibraryHandle wmrmobjsLib;
        static EmsLicenseGenerator()
        {
            msxml3Lib = SafeLibraryHandle.LoadLibraryEx("msxml3.dll", IntPtr.Zero, 0);
            Microsoft.Win32.RegistryKey key = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(@"CLSID\{11582EB3-3A56-4e50-B786-9B121E9C20D9}\InprocServer32");

            if (key != null)
            {
                wmrmobjsLib = SafeLibraryHandle.LoadLibraryEx((string)key.GetValue("", "wmrmobjs.dll"), IntPtr.Zero, 0);
            }
            else
            {
                wmrmobjsLib = SafeLibraryHandle.LoadLibraryEx("wmrmobjs.dll", IntPtr.Zero, 0);
            }
        }

        public EmsLicenseGenerator(LicenseApiParams apiParams)
        {
            _xmlHelper = new LicenseXmlHelper(apiParams.Rights.licenseTypeId, CatalogEnumMap.ClientEnumFromXplt(SGVsAAHelper.GetPlatform()));
            _syncCastProtectedContent = _xmlHelper.IsContentDistributer("SyncCast");
            _rights = apiParams.Rights;

            if (_syncCastProtectedContent && !SyncCastInformationPresent(_rights))
            {
                throw new XRLException(HResult.XONLINE_E_INTERNAL_ERROR, XEvent.Id.LICENSE_XML_ERROR, "We no longer support SyncCast pass-through.");
            }

            _xuid = apiParams.Xuid;
            _clientInfo = apiParams.ClientInfo;
        }

        public byte[] GenerateLicense()
        {
            // Initialize the license generation and rights objects.
            WMRMLicGen licgen = new WMRMLicGen();
            licgen.KeyID = GetKeyID();
            WMRMRights rightsObj = new WMRMRights();

            // Each of these handles takes care of some "logical" chunk of the license.
            // This kind of begs for a decorator pattern (and in fact it kind of resembles such a beast)
            // but let's keep it straight-forward until we have a use for something more flexible.
            HandleInclusionList(licgen);
            HandleAttributes(licgen);
            HandleKey(licgen);
            HandleCopyProtectionLevel(rightsObj);
            HandleBeginDate(rightsObj);
            HandleEndDate(rightsObj);
            HandleOpls(rightsObj);
            HandleLiteralProperties(licgen, rightsObj);

            // Form up the real response.
            licgen.Rights = rightsObj.GetAllRights();
            licgen.ClientInfo = _clientInfo;
            WMRMResponse response = new WMRMResponse();
            response.AddLicense("2.0.0.0", licgen.GetLicenseToDeliver());
            response.AddRevocationData(null /*revInfo*/, licgen.SupportedCRLS, 1);
            return System.Text.Encoding.ASCII.GetBytes(response.GetLicenseResponse());
        }


        private string GetKeyID()
        {
            if (_syncCastProtectedContent)
            {
                return _rights.syncCastKey;
            }
            else
            {
                return Convert.ToBase64String(_rights.mediaInstanceId.ToByteArray());
            }
        }

        private string GetSeed()
        {
            if (_syncCastProtectedContent)
            {
                byte[] aesKey = null;
                byte[] decryptedSeed = null;
                byte[] trimmed = null;
                try
                {
                    // Get the encrypted seed.
                    byte[] encryptedSeed = Convert.FromBase64String(_rights.encryptedSeed);

                    // Get the AES key.
                    aesKey = CryptoReader.GetKey(KEY_TYPE_WMRM_SYNCCAST_AES_KEY, WMRM_EMS_SEED_ID_VERSION);

                    // Decrypt the seed with the key.
                    using (Rijndael aes = Rijndael.Create())
                    {
                        using (ICryptoTransform optimus = aes.CreateDecryptor(aesKey, new byte[16]))
                        {
                            decryptedSeed = new byte[encryptedSeed.Length];

                            using (MemoryStream ms = new MemoryStream(decryptedSeed))
                            {
                                using (CryptoStream cs = new CryptoStream(ms, optimus, CryptoStreamMode.Write))
                                {
                                    cs.Write(encryptedSeed, 0, encryptedSeed.Length);
                                }
                            }
                            UInt32 length = BitConverter.ToUInt32(decryptedSeed, 0);
                            trimmed = new byte[length];
                            Array.ConstrainedCopy(decryptedSeed, 4, trimmed, 0, trimmed.Length);
                            return System.Text.Encoding.ASCII.GetString(trimmed);
                        }
                    }
                }
                finally
                {
                    if (decryptedSeed != null)
                    {
                        Array.Clear(decryptedSeed, 0, decryptedSeed.Length);
                    }
                    if (trimmed != null)
                    {
                        Array.Clear(trimmed, 0, trimmed.Length);
                    }
                }
            }
            else
            {
                int seedId = Int32.Parse(_xmlHelper.GetSingleNodeText("//ns:LicenseXml/ns:SeedID"));
                byte[] seedBytes = CryptoReader.GetKey(KEY_TYPE_WMRM_EMS_SEED_ID, seedId);
                return System.Text.Encoding.ASCII.GetString(seedBytes);
            }
        }

        private static string FormatDateTime(DateTime dt)
        {
            string formattedDate = dt.ToString("#yyyyMMdd HH:mm:ssZ#");
            return formattedDate;
        }

        private static WMRM_RESTRICTION_TYPE RestrictionTypeFromString(string resType)
        {
            switch (resType)
            {
                case "MinCompressedDigitAudio":
                case "MinimumCompressedDigitAudio":
                    return WMRM_RESTRICTION_TYPE.WMRM_COMPRESSEDDIGITALAUDIO;

                case "MinUncompressedDigitalAudio":
                case "MinimumUncompressedDigitalAudio":
                    return WMRM_RESTRICTION_TYPE.WMRM_UNCOMPRESSEDDIGITALAUDIO;

                case "MinCompressedDigitVideo":
                case "MinimumCompressedDigitVideo":
                    return WMRM_RESTRICTION_TYPE.WMRM_COMPRESSEDDIGITALVIDEO;

                case "MinUncompressedDigitalVideo":
                case "MinimumUncompressedDigitalVideo":
                    return WMRM_RESTRICTION_TYPE.WMRM_UNCOMPRESSEDDIGITALVIDEO;

                case "MinAnalogVideoOutput":
                case "MinimumAnalogVideoOutput":
                    return WMRM_RESTRICTION_TYPE.WMRM_ANALOGVIDEO;

                default:
                    throw new XRLException(HResult.XONLINE_E_INTERNAL_ERROR, XEvent.Id.LICENSE_XML_ERROR,
                        String.Format("We don't know about output protection level '{0}'.", resType));
            }
        }

        private void HandleAttributes(WMRMLicGen licgen)
        {
            AuthorityType authorityType = _syncCastProtectedContent ? AuthorityType.Mixed : AuthorityType.AllXbl;
            string[] attribs = WmrmAttributeHelper.GetAttributes(_rights, _xuid, authorityType);

            for (int idx = 0; idx < attribs.Length; idx += 2)
            {
                licgen.set_Attribute(attribs[idx], attribs[idx + 1]);
            }
        }

        private void HandleLiteralProperties(WMRMLicGen licgen, WMRMRights rightsObj)
        {
            string format = "//ns:{0}/*[@xblType = \"Literal\"]";
            SetEachPropertyOnObject(licgen, String.Format(format, "LicenseXml"));
            SetEachPropertyOnObject(rightsObj, String.Format(format, "DrmRights"));
            SetEachPropertyOnObject(rightsObj, String.Format(format, "TimeRestrictions"));
            SetEachPropertyOnObject(rightsObj, String.Format(format, "DrmCopyRights"));
        }

        private void HandleInclusionList(WMRMLicGen licgen)
        {
            WMRMRestrictions restrictions = new WMRMRestrictions();

            string[] inclusionStrings = new String[] { "InclusionListItemSend", "InclusionListItemMtpIPSync", "InclusionListItemUnknownConnectorConstrainedResolution" };
            
            foreach (string inclusion in inclusionStrings)
            {
                XmlNode node = _xmlHelper.SelectSingleNode(String.Format("//ns:{0}", inclusion));
                if (node != null)
                {
                    restrictions.AddInclusion(node.InnerText);
                }
            }

            licgen.SetInclusionList(restrictions.GetInclusionList());
        }


        private void HandleOpls(WMRMRights rightsObj)
        {
            WMRMRestrictions restrictions = new WMRMRestrictions();

            foreach (XmlNode node in _xmlHelper.SelectNodes("//ns:OutputProtectionLevel/*"))
            {
                restrictions.AddRestriction(RestrictionTypeFromString(node.Name), UInt32.Parse(node.InnerText));
            }

            foreach (XmlNode node in _xmlHelper.SelectNodes("//*[@bConfigData]"))
            {
                byte b;
                if (!Byte.TryParse(node.Attributes.GetNamedItem("bConfigData").InnerText, out b))
                {
                    b = 0;
                }
                restrictions.AddExtension(node.InnerText, b);
            }

            rightsObj.PlayRestrictions = restrictions.GetRestrictions();
        }

        private void HandleBeginDate(WMRMRights rightsObj)
        {
            DateTime dt;
            if (_xmlHelper.TryGetBeginDate(_rights, out dt))
            {
                rightsObj.BeginDate = FormatDateTime(dt);
            }
        }

        private void HandleEndDate(WMRMRights rightsObj)
        {
            DateTime dt;
            if (_xmlHelper.TryGetEndDate(_rights, out dt))
            {
                rightsObj.ExpirationDate = FormatDateTime(dt);
            }
        }

        private void HandleExpirationHoursAfterFirstUse(WMRMRights rightsObj)
        {
            string text = null;
            if (_xmlHelper.TryGetSingleNodeText("//ns:TimeRestrictions/ns:ExpirationHoursAfterFirstUse", out text))
            {
                rightsObj.ExpirationAfterFirstUse = UInt32.Parse(text);
            }
        }

        private void HandleCopyProtectionLevel(WMRMRights rightsObj)
        {
            string text = null;
            if (_xmlHelper.TryGetSingleNodeText("//ns:DrmCopyRights/ns:CopyProtectionLevel", out text))
            {
                WMRMRestrictions restrictions = new WMRMRestrictions();
                restrictions.AddRestriction(WMRM_RESTRICTION_TYPE.WMRM_COPY, UInt32.Parse(text));
                rightsObj.CopyRestrictions = restrictions.GetRestrictions();
            }
        }


        private void HandleKey(WMRMLicGen licgen)
        {
            WMRMKeys keys = new WMRMKeys();
            keys.KeyID = GetKeyID();
            keys.Seed = GetSeed();

            licgen.SetKey("MSDRM", keys.GenerateKey());
        }

        private void SetEachPropertyOnObject(object o, string xpathExpression)
        {
            foreach (XmlNode node in _xmlHelper.SelectNodes(xpathExpression))
            {
                SetPropertyOnObject(o, node.Name, node.InnerText);
            }
        }

        private static void SetPropertyOnObject(object o, string name, string val)
        {
            PropertyInfo property = o.GetType().GetProperty(name);

            MethodInfo conversionMethod = property.PropertyType.GetMethod("Parse", BindingFlags.Public | BindingFlags.Static, null, new Type[1] {typeof(String)}, null);

            property.GetSetMethod().Invoke(o, new object[1] { conversionMethod.Invoke(null, new object[1] {val}) } );
        }

        private static bool SyncCastInformationPresent(UserRightsUtil.MediaInstanceRights rights)
        {
            return !String.IsNullOrEmpty(rights.scoid)
                && !String.IsNullOrEmpty(rights.syncCastKey)
                && !String.IsNullOrEmpty(rights.encryptedSeed);
        }


        private LicenseXmlHelper _xmlHelper;
        private UserRightsUtil.MediaInstanceRights _rights;
        private ulong _xuid;
        private bool _syncCastProtectedContent;
        private string _clientInfo;

        private const int KEY_TYPE_WMRM_EMS_SEED_ID = 10;
        private const int KEY_TYPE_WMRM_SYNCCAST_AES_KEY = 11;
        private const int WMRM_EMS_SEED_ID_VERSION = 1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\LicenseUtil.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Web;

using xonline.common.sql.webstore;
using xonline.common.catalogutil;
using xonline.common.config;
using xonline.common.service;
using xonline.common.user;
using xonline.common.billing;
using xonline.common.utilities;
using xonline.common.protocol;
using xonline.common.fse;
using xonline.common.mgmt;

using Microsoft.Webstore.WstClient;

namespace xonline.server.signature
{

    enum LicenseState : int
    {
        None                        = 0,
        Acknowledged                = 1,
        Expired                     = 2,
        AcquiredTrackLicenseCount   = 3,
    }

    class LicenseCountingInfo
    {
        public LicenseCountingInfo(uint licensesAcquired, uint extraLicensesAllowed)
        {
            _licensesAcquired = licensesAcquired;
            _extraLicensesAllowed = extraLicensesAllowed;
        }

        public uint LicensesAcquired { get { return _licensesAcquired; } }
        public uint ExtraLicensesAllowed { get { return _extraLicensesAllowed; } }

        private readonly uint _licensesAcquired;
        private readonly uint _extraLicensesAllowed;
    }

    static class LicenseStateUtil
    {
        public static void SetLicenseState(ulong xuid, Guid miid, Guid oiid, LicenseState state)
        {
            using (WSClient ws = CreateWSClient(xuid, miid, oiid, "dbo.p_set_user_media_instance_license_state", CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.AddParameter(ParamType.INPUT, "@i_state", (int)state);
                ws.AddParameter(ParamType.INPUT, "@si_hash_bucket", ws.Partition);

                ws.ExecuteNonQuery();
            }
        }

        public static bool IsLicenseAcknowledged(ulong xuid, Guid miid, Guid oiid)
        {
            LicenseStateProperties ls;
            if (TryGetLicenseState(xuid, miid, oiid, out ls))
            {
                return IsLicenseStateAcquirable(ls.state);
            }
            else
            {
                return true;
            }
        }

        public static bool TryGetLicenseStateChangedDate(ulong xuid, Guid miid, Guid oiid, out DateTime dt)
        {
            LicenseStateProperties ls;
            if (TryGetLicenseState(xuid, miid, oiid, out ls))
            {
                dt = ls.dt;
                return true;
            }
            else
            {
                dt = new DateTime();
                return false;
            }
        }

        public static void RemoveLicenseState(ulong xuid, Guid miid, Guid oiid)
        {
            using (WSClient ws = CreateWSClient(xuid, miid, oiid, "dbo.p_remove_user_media_instance_license_state", CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.ExecuteNonQuery();
            }
        }

        public static LicenseCountingInfo GetLicenseCountingInfo(ulong xuid, Guid miid, Guid oiid)
        {
            LicenseStateProperties ls;
            if (TryGetLicenseState(xuid, miid, oiid, out ls))
            {
                return new LicenseCountingInfo(ls.licensesAcquired, ls.extraLicensesAllowed);
            }
            else
            {
                return new LicenseCountingInfo(0, 0);
            }
        }

        private static bool IsLicenseStateAcquirable(LicenseState state)
        {
            return state == LicenseState.None;
        }

        private class LicenseStateProperties
        {
            public LicenseState state;
            public DateTime dt;
            public uint licensesAcquired;
            public uint extraLicensesAllowed;
        }

        private static bool TryGetLicenseState(ulong xuid, Guid miid, Guid oiid, out LicenseStateProperties ls) 
        {
            using (WSClient ws = CreateWSClient(xuid, miid, oiid, "dbo.p_get_user_media_instance_license_state", CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                using (WstDataReader response = ws.Execute())
                {
                    ls = new LicenseStateProperties();
                    if (response.Read())
                    {
                        ls.state = (LicenseState)response.GetInt32(0);
                        ls.dt = response.GetDateTime(1);
                        ls.licensesAcquired = (uint)response.GetInt32(2);
                        ls.extraLicensesAllowed = (uint)response.GetInt32(3);
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }
            }
        }

        private static WSClient CreateWSClient(ulong xuid, Guid miid, Guid oiid, string storedProc, CmdType cmdType)
        {
            WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), cmdType);

            ws.SetHashVal(xuid);

            ws.StoredProc = storedProc; 
            ws.AddParameter(ParamType.INPUT, "@bi_user_puid", xuid);
            ws.AddParameter(ParamType.INPUT, "@uid_media_instance_id", miid);
            ws.AddParameter(ParamType.INPUT, "@uid_offer_instance_id", oiid);

            return ws;
        }
    }


    static class SGVsAAHelper
    {
        public static string CurrentIpAddress
        {
            get
            {
                if (SGInfo.IsActiveAuth())
                {
                    return AAInfo.Current.IpAddressInternet;
                }
                else
                {
                    return SGInfo.Current.ClientIP.ToString();
                }
            }
        }

        public static ulong CurrentMachineId
        {
            get
            {
                if (SGInfo.IsActiveAuth())
                {
                    return 0;
                }
                else
                {
                    return SGInfo.Current.MachineId;
                }
            }
        }

        public static void VerifyUser(ulong userPuid)
        {
            if (SGInfo.IsActiveAuth())
            {
                if (userPuid != AAInfoMiddleTier.Current.LiveXuid)
                {
                    throw new XRLException(HResult.XONLINE_E_SIGNATURE_ERROR, XEvent.Id.LICENSE_AUTHDATA_VERIFICATION_FAILED,
                        String.Format("VerifyUser: userPuid (0x{0:x}) does not match AAInfo.LiveXuid (0x{1:x})!", userPuid, AAInfoMiddleTier.Current.LiveXuid));
                }
            }
            else
            {
                SGInfo.VerifyUserId(userPuid);
            }
        }

        public static byte GetPlatform()
        {
            if (SGInfo.IsActiveAuth())
            {
                return XOn.XPLT_WEB;
            }
            else
            {
                byte platform = SGInfo.Current.GetPlatformType();

                if (SGInfo.IsFromLiveCache())
                {
                    string OnBehalfHeader = HttpContext.Current.Request.Headers[XHttpHdr.XPLT_I];

                    if (!String.IsNullOrEmpty(OnBehalfHeader))
                    {
                        platform = byte.Parse(OnBehalfHeader);
                    }
                }
                return platform;
            }
        }
    }


    public enum AuthorityType
    {
        AllSyncCast,
        AllXbl,
        Mixed,
    }

    static class WmrmAttributeHelper
    {
        public static string[] GetAttributes(UserRightsUtil.MediaInstanceRights rights, ulong xuid, AuthorityType authorityType)
        {
            ArrayList al = new ArrayList();

            al.AddRange(new string[]
                        {
                        "version",              VERSION,
                        "user_puid",            xuid.ToString("x"),
                        "offer_type",           OfferIdStringFromLicenseClassId(rights.licenseClassId),
                        "media_instance_id",    rights.mediaInstanceId.ToString(),
                        "offer_id",             rights.offerId.ToString(),
                        "issue_date",           rights.purchaseDate.ToString(),
                        "authority",            AttributeFromAuthorityType(authorityType)
                        });

            if (rights.machineId != 0)
            {
                al.AddRange(new string[] {"console_id", GetFormattedConsoleIdFromMachineId(rights.machineId)});
            }

            return (string[])al.ToArray(typeof(string));
        }

        private static string OfferIdStringFromLicenseClassId(int licenseClassId)
        {
            // TODO: This *might* work, but it's ugly and should fixed up. We don't yet have the info we need, though.
            switch (licenseClassId)
            {
                case 0:
                    return "FAKE";

                case 1:
                    return "DTO";

                case 2:
                    return "PPV";

                default:
                    throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.LICENSE_XML_ERROR, "We don't know about license class {0}.", licenseClassId);
            }
        }

        private static string GetFormattedConsoleIdFromMachineId(ulong machinePuid)
        {
            if (machinePuid == 0)
            {
                return "No owning consoleid";
            }

            // This makes the assumption that we can get a machinepuid from *purchasing* 
            // puid. If that is ever not true, then this will throw, and we will need to 
            // fix this and probably more.
            string sConsoleId = ConsoleIdUtil.GetConsoleIdFromMachineId(machinePuid, XOn.XboxId.GetPlatformType(machinePuid)).ToString("x");

            // extract the lowest significant 5 bytes of the id
            return sConsoleId.Substring(sConsoleId.Length-10);
        }

        private static string AttributeFromAuthorityType(AuthorityType at)
        {
            switch(at)
            {
                case AuthorityType.AllSyncCast:
                    return "SyncCast Content; Syncast License";
                case AuthorityType.AllXbl:
                    return "EMS Content; ESP License";
                case AuthorityType.Mixed:
                    return "SyncCast Content; ESP License";
                default:
                    throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.LICENSE_XML_ERROR, "We don't know about authority type {0}.", at);
            }
        }

        private const string VERSION = "2";
    }


    // This admittedly seems overkill, but I really think that there will be more things 
    // to put in this map in the near future. If I'm wrong, perhaps I will get fed up
    // with this construct and put something simpler elsewhere.
    static class CatalogEnumMap
    {
        public static byte XpltFromClientEnum(CatalogClientTypeEnum catalogClient)
        {
            return LookupMapEntry(catalogClient).xplt;
        }

        public static byte XpltFromInt(int catalogClient)
        {
            return XpltFromClientEnum((CatalogClientTypeEnum) catalogClient);
        }

        public static CatalogClientTypeEnum ClientEnumFromXplt(byte xplt)
        {
            return LookupMapEntry(xplt).catalogClient;
        }

        public static byte[] XpltsFromClientEnums(params CatalogClientTypeEnum[] catalogClients)
        {
            return Array.ConvertAll<CatalogClientTypeEnum, byte>(catalogClients, XpltFromClientEnum);
        }

        public static byte[] XpltsFromInts(params int[] catalogClients)
        {
            return Array.ConvertAll<int, byte>(catalogClients, XpltFromInt);
        }

        public static CatalogClientTypeEnum[] ClientEnumsFromXplts(params byte[] xplts)
        {
            return Array.ConvertAll<byte, CatalogClientTypeEnum>(xplts, ClientEnumFromXplt);
        }

        private static CatalogClientEnumMapEntry LookupMapEntry(CatalogClientTypeEnum catalogClient)
        {
            CatalogClientEnumMapEntry entry = Array.Find(_map, delegate(CatalogClientEnumMapEntry mapEntry) { return mapEntry.catalogClient == catalogClient; } );
            if (entry == null)
            {
                throw new Exception(String.Format("No entry in the CatalogClientEnumMap for CatalogClientTypeEnum {0}.", catalogClient));
            }
            else
            {
                return entry;
            }
        }

        private static CatalogClientEnumMapEntry LookupMapEntry(byte xplt)
        {
            CatalogClientEnumMapEntry entry = Array.Find(_map, delegate(CatalogClientEnumMapEntry mapEntry) { return mapEntry.xplt == xplt; } );
            if (entry == null)
            {
                throw new Exception(String.Format("No entry in the CatalogClientEnumMap for xplt {0}.", xplt));
            }
            else
            {
                return entry;
            }
        }

        private class CatalogClientEnumMapEntry
        {
            public CatalogClientEnumMapEntry(CatalogClientTypeEnum catalogClient, byte xplt)
                { this.catalogClient = catalogClient; this.xplt = xplt; }
            public CatalogClientTypeEnum catalogClient;
            public byte xplt;
        }
        private static readonly CatalogClientEnumMapEntry[] _map = new CatalogClientEnumMapEntry[]
            {
                new CatalogClientEnumMapEntry(CatalogClientTypeEnum.Xbox360, XOn.XPLT_XBOX360),
                new CatalogClientEnumMapEntry(CatalogClientTypeEnum.WindowsPcClient, XOn.XPLT_WEB),
                new CatalogClientEnumMapEntry(CatalogClientTypeEnum.Xbox1, XOn.XPLT_XBOX1),
                new CatalogClientEnumMapEntry(CatalogClientTypeEnum.ZuneDeviceV1, XOn.XPLT_ZUNEV1),
                new CatalogClientEnumMapEntry(CatalogClientTypeEnum.ZuneDeviceV2, XOn.XPLT_ZUNEV2),
                new CatalogClientEnumMapEntry(CatalogClientTypeEnum.MediaCenterDevice, XOn.XPLT_MEDIA_CENTER),
                new CatalogClientEnumMapEntry(CatalogClientTypeEnum.ZuneDeviceV3, XOn.XPLT_ZUNEV3),
                new CatalogClientEnumMapEntry(CatalogClientTypeEnum.ZuneMobileDevice, XOn.XPLT_ZUNE_MOBILE),
            };

    }

    static class LicenseMisc
    {
        public static HResult MapToWhiteListedHResult(uint hrOrig)
        {
            if (Array.Exists(s_hrWhiteList, delegate(uint hr) { return hr == hrOrig; } ))
            {
                return hrOrig;
            }
            else
            {
                return DEFAULT_HR;
            }
        }
        private static readonly uint[] s_hrWhiteList = new uint[]
            {
                HResult.E_ACCESSDENIED,
                HResult.XONLINE_E_SIGNATURE_LICENSE_NOT_ACQUIRABLE,
                HResult.XONLINE_E_GEO_DENIED,
                HResult.XONLINE_E_SIGNATURE_LICENSE_COUNT_EXCEEDED,
                HResult.XONLINE_E_SIGNATURE_INVALID_WMRM_RSA_VERSION,
            };

        private const uint DEFAULT_HR = HResult.E_ACCESSDENIED;
    }

    internal sealed class PurchasedOffer
    {
        public Guid offerId;
        public Guid offerInstanceId;
        public ulong machinePuid;
        public DateTime purchaseDate;
    }

    static class UserMediaInstanceRightsUtil
    {
        public static List<UserRightsUtil.MediaInstanceRights> GetVideoMediaInstanceRights(ulong xuid, MediaInstanceIdOfferIdPair[] miops)
        {
            Dictionary<bool, List<PurchasedOffer>> offerLocations;
            offerLocations = GetUserPurchases(xuid, miops);

            User u = new User();
            u.Load(xuid);
            string isoCountryCode = CountryDictionary.CountryCode(u.CountryId);

            List<UserRightsUtil.MediaInstanceRights> mirs = new List<UserRightsUtil.MediaInstanceRights>();
            foreach (bool isZune in offerLocations.Keys)
            {
                List<PurchasedOffer> offersForDb = offerLocations[isZune];
                MediaInstanceIdOfferIdPair[] miopsPerDb;

                miopsPerDb = Array.FindAll(miops,
                    delegate(MediaInstanceIdOfferIdPair miop)
                    {
                        return offersForDb.Exists(
                            delegate(PurchasedOffer p)
                            {
                                return p.offerId == miop.oid;
                            });
                    });

                // get all the catalogInfo on the miid/oid pair
                List<UserRightsUtil.MediaInstanceRights> mirsPerDb = UserRightsUtil.GetMediaInstanceRights(isoCountryCode, miopsPerDb, isZune);
                mirsPerDb.ForEach(
                    delegate(UserRightsUtil.MediaInstanceRights mir)
                    {
                        PurchasedOffer p = offersForDb.Find(delegate(PurchasedOffer pFind) { return pFind.offerInstanceId == mir.offerInstanceId; });

                        // It is possible that the purchase was for the same offer, but a different offer instance.  Only mark as purchased if the
                        // offer instances agree.
                        if (p != null)
                        {
                            mir.purchased = true;
                            mir.machineId = p.machinePuid;
                            mir.purchaseDate = p.purchaseDate;
                        }
                    });

                mirs.AddRange(mirsPerDb);
            }

            // remove any mediaInstanceRights that have not been purchased
            mirs.RemoveAll(delegate(UserRightsUtil.MediaInstanceRights mir) { return !mir.purchased; });

            return mirs;
        }

        public static Dictionary<bool, List<PurchasedOffer>> GetUserPurchases(ulong xuid, MediaInstanceIdOfferIdPair[] miops)
        {
            if (miops == null)
            {
                throw new ArgumentException("miops");
            }

            Dictionary<bool, List<PurchasedOffer>> offerLocations = new Dictionary<bool, List<PurchasedOffer>>();

            StringBuilder instanceXml = new StringBuilder();
            foreach (MediaInstanceIdOfferIdPair miop in miops)
            {
                if (miop == null || miop.oid == null)
                {
                    throw new ArgumentException("miops (null element)");
                }

                instanceXml.Append(string.Format("<item oid=\"{0}\"/>", miop.oid.ToString()));
            }

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(xuid);

                ws.StoredProc = "dbo.p_xbos_get_user_offer_purchases";

                ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                ws.AddParameter("@bi_user_puid", xuid);
                ws.AddParameter("@xml_offers", instanceXml.ToString());

                using (WstDataReader r = ws.Execute())
                {
                    while (r.Read())
                    {
                        Guid offerId = r.GetGuid(0);
                        Guid offerInstanceId = r.GetGuid(1);
                        ulong machinePuid = (ulong)r.GetInt64(2);
                        DateTime purchaseDate = r.GetDateTime(3);
                        int storeId = r.GetInt32(4);
                        int mediaTypeId = r.GetInt32(5);

                        PurchasedOffer p = new PurchasedOffer();
                        p.offerId = offerId;
                        p.offerInstanceId = offerInstanceId;
                        p.machinePuid = machinePuid;
                        p.purchaseDate = purchaseDate;

                        bool isZuneCatalog = CatalogUtil.IsInZuneCatalog(storeId, mediaTypeId);
                        if (!offerLocations.ContainsKey(isZuneCatalog))
                        {
                            offerLocations[isZuneCatalog] = new List<PurchasedOffer>();
                        }

                        offerLocations[isZuneCatalog].Add(p);
                    }

                    r.Close();

                    HResult hr = (uint)ws.GetIntParameter("@ret");
                    if (HResult.Failed(hr))
                    {
                        string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                        Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_ERROR, msg);

                        throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_100, msg);
                    }
                }
            }

            return offerLocations;
        }

        public static void EnsureMachineId(List<UserRightsUtil.MediaInstanceRights> mirs)
        {
            ulong machinePuid = SGVsAAHelper.CurrentMachineId;
            if (!IsEmptyMachinePuid(machinePuid))
            {
                foreach (UserRightsUtil.MediaInstanceRights mir in mirs)
                {
                    if (IsEmptyMachinePuid(mir.machineId))
                    {
                        mir.machineId = machinePuid;
                        mir.lateBindingMachineState = UserRightsUtil.LateBindingMachineState.Dirty;
                    }
                }
            }
        }

        public static void EnsureAllItemsPresentInRights(MediaInstanceIdOfferIdPair[] idPairs, List<UserRightsUtil.MediaInstanceRights> mirs)
        {
            if (mirs.Count < idPairs.Length)
            {
                foreach (MediaInstanceIdOfferIdPair idPair in idPairs)
                {
                    if (!mirs.Exists(delegate(UserRightsUtil.MediaInstanceRights rights) { return rights.mediaInstanceId == idPair.miid && rights.offerId == idPair.oid; }))
                    {
                        mirs.Add(CreateEmptyRights(idPair));
                    }
                }
            }
        }

        public static void UpdatePurchaseRecordWithMachineId(ulong xuid, UserRightsUtil.MediaInstanceRights mir)
        {
            ulong machinePuid = SGVsAAHelper.CurrentMachineId;
            if (!MachineIdUpdateNecessary(mir) || IsEmptyMachinePuid(machinePuid))
            {
                return;
            }

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(xuid);

                ws.StoredProc = "dbo.p_bind_user_offer_purchase_to_machine";
                ws.AddParameter("@bi_xuid", xuid);
                ws.AddParameter("@uid_offer_instance_id", mir.offerInstanceId);
                ws.AddParameter("@bi_machine_puid", machinePuid);

                ws.ExecuteNonQuery();
            }

            mir.lateBindingMachineState = UserRightsUtil.LateBindingMachineState.Updated;
        }

        public static bool IsEmptyMachinePuid(ulong machinePuid)
        {
            return machinePuid == 0;
        }

        public static void FlushPurchaseHistory(ulong xuid, List<UserRightsUtil.MediaInstanceRights> mirs)
        {
            if (mirs.Exists(delegate(UserRightsUtil.MediaInstanceRights mir) { return mir.lateBindingMachineState == UserRightsUtil.LateBindingMachineState.Updated; }))
            {
                FlushPurchaseHistory(xuid);
            }
        }

        private static bool MachineIdUpdateNecessary(UserRightsUtil.MediaInstanceRights mir)
        {
            return !IsEmptyMachinePuid(mir.machineId) && (mir.lateBindingMachineState == UserRightsUtil.LateBindingMachineState.Dirty);
        }

        private static UserRightsUtil.MediaInstanceRights CreateEmptyRights(MediaInstanceIdOfferIdPair idPair)
        {
            UserRightsUtil.MediaInstanceRights rights = new UserRightsUtil.MediaInstanceRights();
            rights.mediaInstanceId = idPair.miid;
            rights.offerId = idPair.oid;
            rights.isAcquirable = false;
            rights.purchased = false;
            rights.clientTypes = new List<int>(0);
            rights.licenseTypeId = NO_LICENSE_TYPE;

            return rights;
        }

        private static void FlushPurchaseHistory(ulong userPuid)
        {
            try
            {
                string[] historyFlushValues = new string[] { userPuid.ToString() };
                _billingService.Flush("PurchaseHistory", historyFlushNames, historyFlushValues, false);
                _billingService.Flush("PurchaseHistoryV2", historyFlushNames, historyFlushValues, false);
                _billingService.Flush("PurchaseHistoryV2UCDB", historyFlushNames, historyFlushValues, false);
                _billingService.Flush("OfferPurchaseHistory", historyFlushNames, historyFlushValues, false);
                _billingService.Flush("OfferPurchaseHistoryZune", historyFlushNames, historyFlushValues, false);
            }

            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.PURCHASE_HISTORY_FLUSH_ERROR, e, "Error flushing purchase history for user = {0}.", (Puid) userPuid);
            }
        }

        private static FseService _billingService = new FseService("Billing", "npdb", new CatalogResultHandler(), new CatalogPageHandler());
        private static string[] historyFlushNames = new string[] { "UserPuid" };

        public const int NO_LICENSE_TYPE = -1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\PerfCounters.cs ===
using System;
using System.Threading;
using System.Diagnostics;
using xonline.common.mgmt;
using xonline.common.service;
	
namespace xonline.server.signature 
{

	[XomPerformanceCounterCategoryAttr( "Signature FD: GetSigningKey", "Xbox Live: Signature server performance counters(GetSigningKey)" )]
	public class XSigGetSignKeyCounter : XomPerformanceCounterCategory
	{
		[XomPerformanceCounterAttr(
			"GetSigningKey per second", 
			"Number of operations executed per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

        [XomPerformanceCounterAttr(
             "GetSigningKey total", 
             "Total requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsTotal;

        [XomPerformanceCounterAttr(
             "GetSigningKey total failed requests", 
             "Total failed requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailuresTotal;

		static public XSigGetSignKeyCounter Counters = new XSigGetSignKeyCounter();
	}


    [XomPerformanceCounterCategoryAttr( "Signature FD: VerifySignature", "Xbox Live: Signature server performance counters (VerifySignature)" )]

    public class XSigVerifySignatureCounter : XomPerformanceCounterCategory
    {
        [XomPerformanceCounterAttr(
             "VerifySignature per second", 
             "Number of operations executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecond;

        [XomPerformanceCounterAttr(
             "VerifySignature total", 
             "Total requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsTotal;

        [XomPerformanceCounterAttr(
             "VerifySignature failures/sec", 
             "Number of unsuccessful results returned by VerifySignature per second in the current AppDomain.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailuresPerSecond;

        [XomPerformanceCounterAttr(
             "VerifySignature total failures", 
             "Total number unsuccessful results returned by VerifySignature in the current AppDomain.",  
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
             "VerifySignature total invalid signatures", 
             "Total requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter InvalidSignaturesTotal;


        static public XSigVerifySignatureCounter Counters = new XSigVerifySignatureCounter();
    }

    [XomPerformanceCounterCategoryAttr( "Signature FD: SignOnBehalf", "Xbox Live: Signature server performance counters(SignOnBehalf)" )]
    public class XSigSignOnBehalfCounter : XomPerformanceCounterCategory
    {
        [XomPerformanceCounterAttr(
             "SignOnBehalf requests per second", 
             "Number of operations executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecond;

        [XomPerformanceCounterAttr(
             "SignOnBehalf requests total", 
             "Total requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsTotal;

        [XomPerformanceCounterAttr(
             "SignOnBehalf total failures", 
             "Total failed requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailuresTotal;

        static public XSigSignOnBehalfCounter Counters = new XSigSignOnBehalfCounter();
    }
    
    
    [XomPerformanceCounterCategoryAttr( "Signature FD: CheckRevocation", "Xbox Live: Signature server performance counters (CheckRevocation)" )]

    public class XSigCheckRevocationCounter : XomPerformanceCounterCategory
    {
        [XomPerformanceCounterAttr(
             "CheckRevocation per second", 
             "Number of operations executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecond;

        [XomPerformanceCounterAttr(
             "CheckRevocation total", 
             "Total requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsTotal;

        [XomPerformanceCounterAttr(
             "CheckRevocation failures/sec", 
             "Number of unsuccessful results returned by CheckRevocation per second in the current AppDomain.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailuresPerSecond;

        [XomPerformanceCounterAttr(
             "CheckRevocation total failures", 
             "Total number unsuccessful results returned by CheckRevocation in the current AppDomain.",  
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
             "CheckRevocation total invalid signatures", 
             "Total requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter InvalidSignaturesTotal;


        static public XSigCheckRevocationCounter Counters = new XSigCheckRevocationCounter();
    }

   
    [XomPerformanceCounterCategoryAttr( "Signature FD: GetAAInfo", "Xbox Live: Signature server performance counters(GetAAInfo)" )]
    public class GetAAInfoCounter : XomPerformanceCounterCategory
    {
        [XomPerformanceCounterAttr(
             "Requests/sec succeeded", 
             "Number of successful operations executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Requests/sec failed (user not found)", 
             "Number of failed operations per second. Reason is Passport user couldn't be found.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailuresPerSecondNotFound;

        [XomPerformanceCounterAttr(
             "Requests/sec failed (general)", 
             "Number of failed operations per second. Reason is unknown, please check event log.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailuresPerSecondGeneral;

        [XomPerformanceCounterAttr(
             "Requests succeeded total", 
             "Total successful requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsTotal;

        [XomPerformanceCounterAttr(
             "Requests failed total (user not found)", 
             "Total failed requests recorded in the the current AppDomain. Reason is Passport user couldn't be found.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailuresTotalNotFound;

        [XomPerformanceCounterAttr(
             "Requests failed total (general)", 
             "Total failed requests recorded in the the current AppDomain. Reason is unknown, please check event log.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailuresTotalGeneral;

        [XomPerformanceCounterAttr(
             "Average execution time (ms)", 
             "Average request execution time, in milliseconds, for the current AppDomain", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTime;
        
        [XomPerformanceCounterAttr(
             "Average execution time base", 
             "Base for the average request execution time in the current AppDomain", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBase;

        static public GetAAInfoCounter Counters = new GetAAInfoCounter();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\PlayReadyTableUtil.cs ===
using System;
using System.Transactions;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;


namespace xonline.server.signature
{
    public static class DomainKeysUtil
    {
        public const string Ecc = "ECC";
        public const string EccParam = "1";
    }

    public static class DomainsUtil
    {
        public const string DomainNameDefault = "My Devices";
    }

    public enum DomainMembershipType : uint
    {
        StandardMember = 1,
    }

    [FlagsAttribute]
    public enum DomainUserRoles : uint
    {
        AllRoles = 0xFFFFFFFF,
    }

    public enum MachineDomainStatus : uint
    {
        None = 0,
        Joined = 1,
        UnjoinPending = 2,
    }

    public enum AddModifyRemoveOption
    {
        Add = 1,
        Modify = 2,
        Remove = 3,
    }

    public static class PlayReadyTableWrapper
    {
        public static void AddRemoveUserOnDomain(Int64 xuid, Guid domainId, bool fAdd)
        {
            using (TransactionScope transaction = new TransactionScope())
            {
                AddRemoveUserOnDomainImpl(xuid, domainId, fAdd, "p_add_remove_user_on_domain", domainId.GetHashCode());
                AddRemoveUserOnDomainImpl(xuid, domainId, fAdd, "p_add_remove_user_on_domain_by_user", xuid);
                transaction.Complete();
            }
        }

        public static void AddModifyMachineOnDomain(AddModifyRemoveOption option, UInt64 machineId, Guid domainId, UInt64 keyVersion, MachineDomainStatus domainStatus)
        {
            using (TransactionScope transaction = new TransactionScope())
            {
                switch (option)
                {
                    case AddModifyRemoveOption.Add:
                    {
                        AddModifyMachineOnDomainImpl(machineId, domainId, keyVersion, domainStatus);
                        AddRemoveMachineOnDomainByMachineImpl(machineId, domainId, true);
                        break;
                    }

                    case AddModifyRemoveOption.Modify:
                    {
                        AddModifyMachineOnDomainImpl(machineId, domainId, keyVersion, domainStatus);
                        break;
                    }

                    case AddModifyRemoveOption.Remove:
                    {
                        RemoveMachineOnDomainImpl(machineId, domainId);
                        AddRemoveMachineOnDomainByMachineImpl(machineId, domainId, false);
                        break;
                    }
                }

                transaction.Complete();
            }
        }

        private static void AddRemoveUserOnDomainImpl(Int64 xuid, Guid domainId, bool fAdd, string sproc, Int64 hashVal)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(hashVal);

                ws.StoredProc = sproc;

                ws.AddParameter("@bi_xuid", xuid);
                ws.AddParameter("@uid_domain_id", domainId);
                ws.AddParameter("@f_add", Convert.ToInt32(fAdd));
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                ws.ExecuteNonQuery();
            }
        }

        private static void AddModifyMachineOnDomainImpl(UInt64 machineId, Guid domainId, UInt64 keyVersion, MachineDomainStatus domainStatus)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(domainId.GetHashCode());

                ws.StoredProc = "p_add_update_machine_on_domain";

                ws.AddParameter("@bi_machine_id", machineId);
                ws.AddParameter("@uid_domain_id", domainId);
                ws.AddParameter("@bi_key_version", keyVersion);
                ws.AddParameter("@i_status", (uint)domainStatus);
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                ws.ExecuteNonQuery();
            }
        }

        private static void RemoveMachineOnDomainImpl(UInt64 machineId, Guid domainId)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(domainId.GetHashCode());

                ws.StoredProc = "p_remove_machine_from_domain";

                ws.AddParameter("@bi_machine_id", machineId);
                ws.AddParameter("@uid_domain_id", domainId);

                ws.ExecuteNonQuery();
            }
        }

        private static void AddRemoveMachineOnDomainByMachineImpl(UInt64 machineId, Guid domainId, bool fAdd)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(machineId);

                ws.StoredProc = "p_add_remove_machine_on_domain_by_machine";

                ws.AddParameter("@bi_machine_id", machineId);
                ws.AddParameter("@uid_domain_id", domainId);
                ws.AddParameter("@f_add", Convert.ToInt32(fAdd));
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                ws.ExecuteNonQuery();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\NativeCertificateWrapper.cs ===
using System;
using System.Runtime.InteropServices;
using System.Security;

using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.signature
{
///
/// Wrapper to the native calls to create our certificates.
///
/// Note that I've wrapped all of these in a way to throws exceptions on error.
///
    [Flags]
    enum CASvcExtensionFlags
    {
        None = 0,
        ClientAuthentication = 1,
        MstvAVPolicy = 2
    }

    internal sealed class NativeCertificateWrapper : IDisposable
    {
        public NativeCertificateWrapper(string bstrIssuerCertName, CASvcExtensionFlags extensionFlags, string bstrCRLDP, string bstrAccessInfoURI)
        {
            UInt32 hr = CAInitialize(bstrIssuerCertName, bstrCRLDP, bstrAccessInfoURI, out _ptr);
            if (HResult.Failed(hr) || _ptr == null || _ptr.IsInvalid)
            {
                throw new XRLException(hr, XEvent.Id.XMSTV_CA,
                    "Failed to initialize the CASvc.  hr = 0x{0:X8}, IssuerCertName = {1}, crldp = {2}, AccessinfoURI = {3}.",
                    hr, bstrIssuerCertName, bstrCRLDP, bstrAccessInfoURI);
            }
            _extensionFlags = extensionFlags;
        }

        ///
        /// Create the certificate.  Multiple calls to this can be made
        /// after one call to Initialize.
        ///
        public void CallCACertify(
            string bstrSubjectName,
            byte[] pKey,
            UInt32 cbKey,
            DateTime dtNotBefore,
            DateTime dtNotAfter,
            byte[] pCert,
            ref UInt32 pcbCert,
            ref Guid pSerial)
        {
            UInt32 hr = CACertify(
                _ptr,
                bstrSubjectName,
                pKey, cbKey,
                (UInt32)_extensionFlags,
                dtNotBefore.ToFileTimeUtc(), dtNotAfter.ToFileTimeUtc(),
                pCert, ref pcbCert, ref pSerial);
            if (HResult.Failed(hr))
            {
                if (hr == HResult.E_INVALID_DATA)
                {
                    throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.CASVC_INVALID_REQUEST,
                        "Could not create certificate due to invalid public key.  hr = 0x{0:X8}, SubjectName = {1}, Flags = {2}.",
                        hr, bstrSubjectName, _extensionFlags);
                }
                else
                {
                    throw new XRLException(hr, XEvent.Id.XMSTV_CA,
                        "Failed to create a certificate with CASvc.  hr = 0x{0:X8}, SubjectName = {1}, Flags = {2}.",
                        hr, bstrSubjectName, _extensionFlags);
                }
            }
        }

        ///
        /// Serialize a certifcate.
        ///
        public void CallCASerialize(
            byte[] pCert,
            UInt32 cbCert,
            byte[] pSerialized,
            ref UInt32 pcbSerialized)
        {
            UInt32 hr = CASerialize(_ptr, pCert, cbCert, pSerialized, ref pcbSerialized);
            if (HResult.Failed(hr))
            {
                throw new XRLException(hr, XEvent.Id.XMSTV_CA, 
                    "Failed to serialize a certificate with CASvc.  hr = 0x{0:X8}.",
                    hr);
            }
        }

        ///
        /// Call this once per session--after you are done certifying.
        ///
        public void Dispose()
        {
            _ptr.Dispose();
        }

        CASvcExtensionFlags _extensionFlags;
        private SafeCACertifyPointer _ptr;

        ///
        /// These are the actual native calls.
        ///
        [DllImport("CASvc.dll", CharSet=CharSet.Unicode)]
        private static extern UInt32 CAInitialize(
            string bstrIssuerCertName, string bstrCRLDP, string bstrAccessInfoURI, out SafeCACertifyPointer ptr);

        [DllImport("CASvc.dll", CharSet=CharSet.Unicode)]
        private static extern UInt32 CACertify(
            SafeCACertifyPointer ptr,
            string bstrSubjectName,
            byte[] pKey,
            UInt32 cbKey,
            UInt32 dwFlags,
            long dtNotBefore,
            long dtNotAfter,
            byte[] pCert,
            ref UInt32 pcbCert,
            ref Guid pSerial);

        [DllImport("CASvc.dll")]
        private static extern UInt32 CASerialize(
            SafeCACertifyPointer ptr,
            byte[] pCert,
            UInt32 cbCert,
            byte[] pSerialized,
            ref UInt32 pcbSerialized);

        [SuppressUnmanagedCodeSecurity]
        sealed class SafeCACertifyPointer : Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid
        {
            internal SafeCACertifyPointer()
                : base(true)
            {
            }

            protected override bool ReleaseHandle()
            {
                CATerminate(base.handle);
                return true;
            }

            [DllImport("CASvc.dll")]
            private static extern void CATerminate(
                IntPtr ptr);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\LicensingValidators.cs ===
using System;
using System.Collections.Generic;
using System.Xml;
using System.Text;
using System.Data.SqlClient;

using xonline.common.service;
using xonline.common.billing;
using xonline.common.geofence;
using xonline.common.mgmt;
using xonline.common.utilities2;
using xonline.common.user;
using xonline.common.sql.sqlclient;
using xonline.common.config;

namespace xonline.server.signature
{
    static class AcquireLicenseValidatorFactory
    {
        public static Validator GetValidator(LicenseApiParams apiParams)
        {
            return Validator.MakeValidatorChain(
                true,
                new LicenseXmlValidator(apiParams.Rights.licenseTypeId),
                new SecurityVersionValidator(apiParams.ClientInfo),
                new MediaInstanceRightsValidator(apiParams.Rights, true),
                new PlatformValidator(SGVsAAHelper.GetPlatform(), CatalogEnumMap.XpltsFromInts(apiParams.Rights.clientTypes.ToArray())),
                new ClientTypeValidator(apiParams.Rights.licenseTypeId, apiParams.Rights.clientTypes),
                new ClientTypeValidator(apiParams.Rights.licenseTypeId, CatalogEnumMap.ClientEnumFromXplt(SGVsAAHelper.GetPlatform())),
                new UserValidator(apiParams.Xuid),
                new AcknowledgementValidator(apiParams.Rights, apiParams.Xuid),
                new GeoFencingValidator(apiParams.Xuid, apiParams.Rights, "AcquiremediaLicense"),
                new PpvExpirationValidator(apiParams.Rights.licenseTypeId, apiParams.Rights),
                new LicenseCountingValidator(apiParams.Rights, apiParams.Xuid)
                );
        }
    }

    static class LicenseAvailabilityValidatorFactory
    {
        public static Validator GetValidator(LicenseApiParams apiParams)
        {
            return Validator.MakeValidatorChain(
                true,
                new LicenseXmlValidator(apiParams.Rights.licenseTypeId),
                new MediaInstanceRightsValidator(apiParams.Rights, true),
                new PlatformValidator(SGVsAAHelper.GetPlatform(), CatalogEnumMap.XpltsFromInts(apiParams.Rights.clientTypes.ToArray())),
                new ClientTypeValidator(apiParams.Rights.licenseTypeId, apiParams.Rights.clientTypes),
                new ClientTypeValidator(apiParams.Rights.licenseTypeId, CatalogEnumMap.ClientEnumFromXplt(SGVsAAHelper.GetPlatform())),
                new UserValidator(apiParams.Xuid),
                new AcknowledgementValidator(apiParams.Rights, apiParams.Xuid),
                new GeoFencingValidator(apiParams.Xuid, apiParams.Rights, "AcquiremediaLicense"),
                new PpvExpirationValidator(apiParams.Rights.licenseTypeId, apiParams.Rights),
                new LicenseCountingValidator(apiParams.Rights, apiParams.Xuid)
                );
        }
    }


    static class AcknowledgeLicensesValidatorFactory
    {
        public static Validator GetValidator(LicenseApiParams apiParams)
        {
            return Validator.MakeValidatorChain(
                true,
                new LicenseXmlValidator(apiParams.Rights.licenseTypeId),
                new MediaInstanceRightsValidator(apiParams.Rights, false),
                new PlatformValidator(SGVsAAHelper.GetPlatform(), CatalogEnumMap.XpltsFromInts(apiParams.Rights.clientTypes.ToArray())),
                new ClientTypeValidator(apiParams.Rights.licenseTypeId, apiParams.Rights.clientTypes),
                new ClientTypeValidator(apiParams.Rights.licenseTypeId, CatalogEnumMap.ClientEnumFromXplt(SGVsAAHelper.GetPlatform())),
                new UserValidator(apiParams.Xuid),
                new GeoFencingValidator(apiParams.Xuid, apiParams.Rights, "AcknowledgeLicensesDelivery"),
                new AcknowledgementRequiredValidator(apiParams.Rights.licenseTypeId)
                );
        }
    }


    class PpvExpirationValidator : Validator
    {
        public PpvExpirationValidator(int licenseTypeId, UserRightsUtil.MediaInstanceRights rights)
        {
            _rights = rights;
            _licenseTypeId = licenseTypeId;
        }

        protected override DoCheckResults DoCheckImpl()
        {
            LicenseXmlHelper xmlHelper = new LicenseXmlHelper(_licenseTypeId, CatalogEnumMap.ClientEnumFromXplt(SGVsAAHelper.GetPlatform()));
            if (xmlHelper.IsOfferType("PPV"))
            {
                DateTime licenseExpirationDate = GetEndDate(xmlHelper);

                if (licenseExpirationDate < DateTime.Now)
                {
                    Hr = HResult.XONLINE_E_SIGNATURE_LICENSE_NOT_ACQUIRABLE;
                    return DoCheckResults.AbsoluteNo;
                }
            }

            return DoCheckResults.NoOpinion;
        }

        private DateTime GetEndDate(LicenseXmlHelper xmlHelper)
        {
            if (xmlHelper.IsContentDistributer("SyncCast"))
            {
                return _rights.purchaseDate.AddDays(SYNCCAST_PPV_LICENSE_DAYS);
            }

            else
            {
                DateTime dt;
                if (!xmlHelper.TryGetEndDate(_rights, out dt))
                {
                    dt = DateTime.MaxValue;
                }
                return dt;
            }
        }

        private readonly int _licenseTypeId;
        private readonly UserRightsUtil.MediaInstanceRights _rights;

        private const int SYNCCAST_PPV_LICENSE_DAYS = 14;
    }


    //  If this license-type requires an acknowledgement, make sure it hasn't been 
    //  acknowledged yet.
    //
    class AcknowledgementValidator : Validator
    {
        public AcknowledgementValidator(UserRightsUtil.MediaInstanceRights rights, ulong xuid)
        {
            _licenseTypeId = rights.licenseTypeId;
            _xuid = xuid;
            _miid = rights.mediaInstanceId;
            _oiid = rights.offerInstanceId;
        }

        protected override DoCheckResults DoCheckImpl()
        {
            bool requiresValidation = LicenseXmlHelper.LicenseTypeRequiresAcknowledgement(_licenseTypeId);
            if (requiresValidation && AcknowledgementExists())
            {
                ErrorMessage = String.Format("The user {0:X16} already acknowledged the media {1} with offer {2}.", _xuid, _miid, _oiid);
                return DoCheckResults.AbsoluteNo;
            }

            return DoCheckResults.NoOpinion;
        }

        public bool AcknowledgementExists()
        {
            return !LicenseStateUtil.IsLicenseAcknowledged(_xuid, _miid, _oiid);
        }

        private readonly int _licenseTypeId;
        private readonly ulong _xuid;
        private readonly Guid _miid;
        private readonly Guid _oiid;
    }


    class ClientTypeValidator : Validator
    {
        public ClientTypeValidator(int licenseTypeId, CatalogClientTypeEnum clientType)
            : this(licenseTypeId)
        {
            _clientTypes = new List<int>(1);
            _clientTypes.Add((int)clientType);
        }

        public ClientTypeValidator(int licenseTypeId, List<int> clientTypes)
            : this(licenseTypeId)
        {
            _clientTypes = clientTypes;
        }

        private ClientTypeValidator(int licenseTypeId)
        {
            _licenseTypeId = licenseTypeId;
        }

        protected override DoCheckResults DoCheckImpl()
        {
            LicenseXmlHelper xmlHelper = new LicenseXmlHelper(_licenseTypeId);

            List<int> supportedClientTypes = new List<int>();

            foreach (XmlNode node in xmlHelper.SelectNodes("//ns:ClientPolicy/ns:ClientType/*/@ClientTypeId"))
            {
                int clientType = Int32.Parse(node.InnerText);
                if (_clientTypes.Contains(clientType))
                {
                    return DoCheckResults.NoOpinion;
                }
                supportedClientTypes.Add(clientType);
            }

            ErrorMessage = String.Format(
                EnumerableFormatter.Instance,
                "None of the Client Type Ids purchased ({0:ef}) exist in the license xml ({1:ef}).",
                _clientTypes, 
                supportedClientTypes);
            return DoCheckResults.AbsoluteNo;
        }

        private readonly int _licenseTypeId;
        private readonly List<int> _clientTypes;
    }


    //
    // I'm trying to find the right balance between seperation of logic and
    // a reasonable number of classes and instantiations...
    //
    class MediaInstanceRightsValidator : Validator
    {
        public MediaInstanceRightsValidator(UserRightsUtil.MediaInstanceRights rights, bool checkDate)
        {
            _rights = rights;
            _checkDate = checkDate;
        }

        protected override DoCheckResults DoCheckImpl()
        {
            // Fairly obvious.
            if (!(_rights.isAcquirable && _rights.purchased))
            {
                ErrorMessage = String.Format("Trying to get a license for media that the user doesn't have rights to. isAcuqireable = {0}. purchased = {1}",
                                             _rights.isAcquirable, _rights.purchased);
                LogError = "No user rights";
                return DoCheckResults.AbsoluteNo;
            }

            // If the absolute expiration date would be less than today, then this really isn't going to work.
            if (_checkDate && _rights.absoluteExpiration != DateTime.MinValue && _rights.absoluteExpiration < DateTime.Now)
            {
                ErrorMessage = String.Format("AbsoluteExpirationDate ({0}) of the license would be before today.", _rights.absoluteExpiration);
                LogError = "Absolute Expiration";
                return DoCheckResults.AbsoluteNo;
            }

            // This is only for video licenses.
            if (_rights.licenseExtensionBits != 0)
            {
                ErrorMessage = String.Format("License Extension Bits are game-specific and should be zero for video license acquires, but they are 0x{0:X8}", _rights.licenseExtensionBits);
                LogError = "Extension bits";
                return DoCheckResults.AbsoluteNo;
            }

            return DoCheckResults.NoOpinion;
        }

        private readonly UserRightsUtil.MediaInstanceRights _rights;
        private readonly bool _checkDate;
    }


    //
    // Make sure the user is somewhat valid.
    //
    class UserValidator : Validator
    {
        public UserValidator(ulong xuid)
        {
            _xuid = xuid;
        }

        protected override DoCheckResults DoCheckImpl()
        {
            User u = new User();
            u.Load(_xuid);

            if ( u.AccountType != User.XenonAccount)
            {
                ErrorMessage = String.Format("Expected user account type to be {0}, but it's {1}.", User.XenonAccount, u.AccountType);
                return DoCheckResults.AbsoluteNo;
            }

            return DoCheckResults.NoOpinion;
        }

        private readonly ulong _xuid;
    }


    class GeoFencingValidator : Validator
    {
        public GeoFencingValidator(ulong xuid, UserRightsUtil.MediaInstanceRights rights, string apiName)
        {
            _performCheck = rights.isGeofenced;
            if (_performCheck)
            {
                _xuid = xuid;
                _oiid = rights.offerInstanceId;
                _apiName = apiName;
            }
        }

        protected override DoCheckResults DoCheckImpl()
        {
            if (_performCheck && GeoFenceClient.VideoGeoFencingEnabled)
            {
                User u = new User();
                u.Load(_xuid);

                try
                {
                    GeoFenceClient.EnforceUserInAccountCountry(_apiName, u, SGVsAAHelper.CurrentIpAddress, SGVsAAHelper.CurrentMachineId, _oiid);
                }
                catch (GeoFenceException e)
                {
                    ErrorMessage = e.LogLine;
                    Hr = HResult.XONLINE_E_GEO_DENIED;
                    Xom.Log(XomAreaName.Reporting, ErrorMessage);
                    return DoCheckResults.AbsoluteNo;
                }
            }

            return DoCheckResults.NoOpinion;
        }

        private readonly ulong _xuid;
        private readonly Guid _oiid;
        private readonly bool _performCheck;
        private readonly string _apiName;
    }


    class AcknowledgementRequiredValidator : Validator
    {
        public AcknowledgementRequiredValidator(int licenseTypeId)
        {
            _licenseTypeId = licenseTypeId;
        }

        protected override DoCheckResults DoCheckImpl()
        {
            if (!LicenseXmlHelper.LicenseTypeRequiresAcknowledgement(_licenseTypeId))
            {
                ErrorMessage = String.Format("Acknowledging license with offer type other than PPV");
                return DoCheckResults.AbsoluteNo;
            }
            return DoCheckResults.NoOpinion;
        }

        private readonly int _licenseTypeId;
    }


    class LicenseCountingValidator : Validator
    {
        public LicenseCountingValidator(UserRightsUtil.MediaInstanceRights rights, ulong xuid)
        {
            _rights = rights;
            _xuid = xuid;
        }

        protected override DoCheckResults DoCheckImpl()
        {
            uint maximumLicenses;
            if (LicenseXmlHelper.TryGetMaximumLicenseCount(_rights.licenseTypeId, CatalogEnumMap.ClientEnumFromXplt(SGVsAAHelper.GetPlatform()), out maximumLicenses))
            {
                LicenseCountingInfo info = LicenseStateUtil.GetLicenseCountingInfo(_xuid, _rights.mediaInstanceId, _rights.offerInstanceId);
                if (info.LicensesAcquired >= maximumLicenses + info.ExtraLicensesAllowed)
                {
                    ErrorMessage = String.Format(
                        "License acquisition would put the user over the maximum for this license type. License type maximum = {0}, current = {1} extra licenses allowed (via support calls, etc) = {2}.",
                        maximumLicenses, info.LicensesAcquired, info.ExtraLicensesAllowed);
                    Hr = HResult.XONLINE_E_SIGNATURE_LICENSE_COUNT_EXCEEDED;
                    return DoCheckResults.AbsoluteNo;
                }
            }

            return DoCheckResults.NoOpinion;
        }

        private readonly UserRightsUtil.MediaInstanceRights _rights;
        private readonly ulong _xuid;
    }

    class LicenseXmlValidator : Validator
    {
        public LicenseXmlValidator(int licenseTypeId)
        {
            _licenseTypeId = licenseTypeId;
        }

        protected override DoCheckResults DoCheckImpl()
        {
            if (_licenseTypeId == UserMediaInstanceRightsUtil.NO_LICENSE_TYPE)
            {
                ErrorMessage = "Calling a licesning API for media the user does not own.";
                return DoCheckResults.AbsoluteNo;
            }

            try
            {
                LicenseXmlHelper xmlHelper = new LicenseXmlHelper(_licenseTypeId);
                return DoCheckResults.NoOpinion;
            }
            catch (Exception e)
            {
                ErrorMessage = String.Format("LicenseTypeId {0} failed to load with exception '{1}'.", _licenseTypeId, e);
                return DoCheckResults.AbsoluteNo;
            }

        }

        private readonly int _licenseTypeId;
    }

    class SecurityVersionValidator : Validator
    {
        private const string MACHINECERTIFICATE_ELEMENT_START_TAG = "<MACHINECERTIFICATE>";
        private const string MACHINECERTIFICATE_ELEMENT_END_TAG = "</MACHINECERTIFICATE>";
        private const string DEVCERT_ELEMENT_START_TAG = "<DEVCERT";
        private const string DEVCERT_ELEMENT_END_TAG = "</DEVCERT>";
        private const string DEVCERT_EMPTY_ELEMENT_TAG = "<DEVCERT/>";
        private const string CLIENTVERSION_START_TAG = "<CLIENTVERSION>";
        private const string CLIENTVERSION_END_TAG = "</CLIENTVERSION>";
        private const string SECURITYVERSION_START_TAG = "<c:SecurityVersion>";
        private const string SECURITYVERSION_END_TAG = "</c:SecurityVersion>";

        private static bool minVersionsLoaded = false;
        private static object syncLock = new object();
        private static int[] minimumSecurityVersion = null;
        private static int[] minimumClientVersion = null;

        public SecurityVersionValidator(string clientInfo)
        {
            this.ClientInfo = clientInfo;
            LoadMinSecurityVersionsFromNpdb();
        }

        protected override DoCheckResults DoCheckImpl()
        {
            if (String.IsNullOrEmpty(this.ClientInfo))
            {
                this.ErrorMessage = "Invalid clientInfo. ClientInfo is null or empty.";
                goto HandleError;
            }

            bool hasMachineCert = this.ClientInfo.Contains(MACHINECERTIFICATE_ELEMENT_START_TAG);
            bool hasDevCert = this.ClientInfo.Contains(DEVCERT_ELEMENT_START_TAG);

            if (hasMachineCert && hasDevCert)
            {
                this.ErrorMessage = "ClientInfo has both DEVCERT and MACHINECERT elements.";
                goto HandleError;
            }
            else if (!hasMachineCert && !hasDevCert)
            {
                this.ErrorMessage = "ClientInfo has neither DEVCERT and MACHINECERT elements.";
                goto HandleError;
            }
            else if(hasDevCert && !ValidateDevCert(this.ClientInfo))
            {
                this.ErrorMessage = "ClientInfo has empty DEVCERT element.";
                goto HandleError;
            }

            if(hasDevCert)
            {
                return DoCheckResults.NoOpinion;
            }

            // Verify ClientVersion
            string errorMessage = null;
            if (!VerifyVersion(this.ClientInfo, CLIENTVERSION_START_TAG, CLIENTVERSION_END_TAG, minimumClientVersion, out errorMessage))
            {
                this.ErrorMessage = "ClientVersion: " + errorMessage;
                goto HandleError;
            }

            int machineCertStart = this.ClientInfo.IndexOf(MACHINECERTIFICATE_ELEMENT_START_TAG);
            machineCertStart += MACHINECERTIFICATE_ELEMENT_START_TAG.Length;
            // We know it has one so we dont bother worrying about it having one.
            
            int machineCertEnd = this.ClientInfo.IndexOf(MACHINECERTIFICATE_ELEMENT_END_TAG, machineCertStart);
            if(machineCertEnd == -1)
            {
                this.ErrorMessage = "ClientInfo has no </MACHINECERTIFICATE> tag.";
                goto HandleError;
            }

            string machineCertificateAsXmlText = null;
            try
            {
                string machineCertificateAsBase64 = ClientInfo.Substring(machineCertStart, machineCertEnd - machineCertStart).Trim().Replace('!', '+').Replace('*', '/');
                if (String.IsNullOrEmpty(machineCertificateAsBase64))
                {
                    throw new FormatException();
                }

                machineCertificateAsXmlText = Encoding.UTF8.GetString(Convert.FromBase64String(machineCertificateAsBase64));
            }
            catch (FormatException)
            {
                this.ErrorMessage = "Cannot decode MACHINECERTIFICATE";
                goto HandleError;
            }
            
            if (!VerifyVersion(machineCertificateAsXmlText, SECURITYVERSION_START_TAG, SECURITYVERSION_END_TAG, minimumSecurityVersion, out errorMessage))
            {
                this.ErrorMessage = "SecurityVersion: " + errorMessage;
                goto HandleError;
            }

HandleError:
            if (!String.IsNullOrEmpty(this.ErrorMessage))
            {
                this.Hr = HResult.XONLINE_E_SIGNATURE_INVALID_WMRM_RSA_VERSION;
                return DoCheckResults.AbsoluteNo;
            }
            else
            {
                return DoCheckResults.NoOpinion;
            }
        }


        private static bool ValidateDevCert(string clientInfo)
        {
            if (clientInfo.Contains(DEVCERT_EMPTY_ELEMENT_TAG))
            {
                // This is actually a pretty week check as we are only checking one possible XML form
                // it would be better to use XML processing but I'm concerned about perf.
                return false;
            }
            else
            {
                int devCertStart = clientInfo.IndexOf(DEVCERT_ELEMENT_START_TAG);
                devCertStart += MACHINECERTIFICATE_ELEMENT_START_TAG.Length + 1;
                // We know it has one so we dont bother worrying about it having one.

                int devCertEnd = clientInfo.IndexOf(DEVCERT_ELEMENT_END_TAG, devCertStart);
                if (devCertEnd == -1)
                {
                    return false;
                }

                string devCert = clientInfo.Substring(devCertStart, devCertEnd - devCertStart).Trim();
                if (string.IsNullOrEmpty(devCert))
                {
                    return false;
                }

                try
                {
                    Convert.FromBase64String(devCert.Replace('!', '+').Replace('*', '/'));
                }
                catch
                {
                    return false;
                }
            }

            return true;
        }

        private static bool VerifyVersion(string sourceString, string startTag, string endTag, int[] minVersion, out string errorMessage)
        {
            int tagStart = sourceString.IndexOf(startTag);
            if (tagStart == -1)
            {
                errorMessage = String.Format("Element {0} not found in source string.", startTag);
                return false;
            }
            tagStart += startTag.Length;

            int tagEnd = sourceString.IndexOf(endTag, tagStart);
            if (tagEnd == -1)
            {
                errorMessage = String.Format("Element {0} is corupt in source string.", startTag);
                return false;
            }

            string versionAsString = sourceString.Substring(tagStart, tagEnd - tagStart);
            if (string.IsNullOrEmpty(versionAsString))
            {
                errorMessage = String.Format("Element {0} empty in source string.", startTag);
                return false;
            }

            if (!ValidateVersion(versionAsString, minVersion, out errorMessage))
            {
                errorMessage = String.Format("Version validation failure for {0}: {1}", startTag, errorMessage);
                return false;
            }

            errorMessage = null;
            return true;
        }

        private static bool ValidateVersion(string versionAsString, int[] minVersion, out string errorMessage)
        {
            if (String.IsNullOrEmpty(versionAsString))
            {
                errorMessage = "Version element is empty";
                return false;
            }

            int[] versionAsIntArray;
            try
            {
                versionAsIntArray = VersionStringToIntArray(versionAsString);
            }
            catch (FormatException e)
            {
                errorMessage = e.Message;
                return false;
            }

            if (!ValidateVersion(versionAsIntArray, minVersion))
            {
                errorMessage = String.Format("Version is less than minimum required.  Got: {0}, expected {1}.{2}.{3}.{4} or greater.", versionAsString, minVersion[0], minVersion[1], minVersion[2], minVersion[3]);
                return false;
            }

            errorMessage = null;
            return true;
        }

        private static bool ValidateVersion(int[] version, int[] minVersion)
        {
            for (int i = 0; i < version.Length; i++)
            {
                if (version[i] < minVersion[i])
                {
                    return false;
                }
                else if (version[i] > minVersion[i])
                {
                    return true;
                }
            }

            return true;
        }

        private static int[] VersionStringToIntArray(string securityVersion)
        {
            string[] securityVersionElements = securityVersion.Split('.');
            if (securityVersionElements.Length != 4)
            {
                throw new FormatException("SecurityVersionElement is not 4 elements: " + securityVersion);
            }

            int[] securityVersionAsIntArray = new int[4];

            for (int i = 0; i < securityVersionElements.Length; i++)
            {
                try
                {
                    securityVersionAsIntArray[i] = int.Parse(securityVersionElements[i]);
                }
                catch (FormatException e)
                {
                    throw new FormatException("Illegal character in SecurityVersionElement: " + securityVersion, e);
                }
            }

            return securityVersionAsIntArray;
        }

        private static void LoadMinSecurityVersionsFromNpdb()
        {
            if (!minVersionsLoaded)
            {
                lock (syncLock)
                {
                    if (!minVersionsLoaded)
                    {
                        string minSecurityVersionAsString;
                        string minClientVersionAsString;

                        // I load defaults here on an NPDB failure as we know that the min security version 
                        // will NEVER be less than these values.
                        try
                        {
                            minSecurityVersionAsString = Config.GetSetting("signature_minimum_WMRM_Security_Version");
                        }
                        catch
                        {
                            minSecurityVersionAsString = "3.8.0.1";
                        }

                        try
                        {
                            minClientVersionAsString = Config.GetSetting("signature_minimum_WMRM_Client_Version");
                        }
                        catch
                        {
                            minClientVersionAsString = "0.0.0.0";
                        }
                        minimumClientVersion = VersionStringToIntArray(minClientVersionAsString);
                        minimumSecurityVersion = VersionStringToIntArray(minSecurityVersionAsString);
                        minVersionsLoaded = true;
                    }
                }
            }
        }


        public string ClientInfo
        {
            get;
            private set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\LicenseXmlUtil.cs ===
using System;
using System.Xml;
using System.Web;

using xonline.common.billing;
using xonline.common.service;


namespace xonline.server.signature
{
    class XmlDocumentAndNamespaceManager
    {
        public XmlDocumentAndNamespaceManager(XmlDocument xmlDoc, XmlNamespaceManager nsMgr)
        {
            _xmlDoc = xmlDoc;
            _nsMgr = nsMgr;
        }

        public XmlDocument Document { get { return _xmlDoc; } }
        public XmlNamespaceManager NamespaceManager { get {return _nsMgr; } }

        private readonly XmlDocument _xmlDoc;
        private readonly XmlNamespaceManager _nsMgr;
    }

    static class XmlDocumentAndNamespaceManagerCache
    {
        public static XmlDocumentAndNamespaceManager GetXmlDocumentAndNamespaceManager(int licenseTypeId)
        {
            return (XmlDocumentAndNamespaceManager) HttpContext.Current.Items[FormatHttpContextIndex(licenseTypeId)];
        }

        public static void PutXmlDocumentAndNamespaceManager(string licenseXml, int licenseTypeId)
        {
            string index = FormatHttpContextIndex(licenseTypeId);
            XmlDocumentAndNamespaceManager xmlDocNsMgr = (XmlDocumentAndNamespaceManager) HttpContext.Current.Items[index];

            if (HttpContext.Current.Items[index] == null && !String.IsNullOrEmpty(licenseXml))
            {
                XmlDocument xmlDoc = new XmlDocument();
                xmlDoc.LoadXml(licenseXml);
                XmlNamespaceManager nsMgr = new XmlNamespaceManager(xmlDoc.NameTable);
                nsMgr.AddNamespace("ns", "http://www.microsoft.com/ems/license");

                HttpContext.Current.Items[index] = new XmlDocumentAndNamespaceManager(xmlDoc, nsMgr);
            }
        }

        private static string FormatHttpContextIndex(int licenseTypeId)
        {
            return String.Format("LICENSE_XML_{0}", licenseTypeId);
        }
    }

    //
    // This is essentially a facade over the XmlNode/XPath queries we need to make.
    // You can still make generic XPath queries, but this helps with more common tasks
    // I've found myself doing with license xml.
    //
    class LicenseXmlHelper
    {
        public LicenseXmlHelper(int licenseTypeId, CatalogClientTypeEnum clientType)
            : this(licenseTypeId)
        {
            _clientType = clientType;
        }

        public LicenseXmlHelper(int licenseTypeId)
        {
            _licenseTypeId = licenseTypeId;
            XmlDocumentAndNamespaceManager xmlDocNsMgr = XmlDocumentAndNamespaceManagerCache.GetXmlDocumentAndNamespaceManager(_licenseTypeId);
            if (xmlDocNsMgr == null)
            {
                throw new XRLException(HResult.XONLINE_E_INTERNAL_ERROR, XEvent.Id.LICENSE_XML_ERROR,
                                       "Attempting to acquire a licenseXml that evidently doesn't exist. Id = {0}.", _licenseTypeId);
            }
            _xmlDoc = xmlDocNsMgr.Document;
            _nsmgr = xmlDocNsMgr.NamespaceManager;
        }

        public bool IsContentDistributer(string contentDistributer)
        {
            string query = String.Format("//*[@ContentDistributor = \"{0}\"]", contentDistributer);
            return SelectSingleNode(query) != null;
        }

        public bool IsOfferType(string offerType)
        {
            string query = String.Format("//*[@OfferType = \"{0}\"]", offerType);
            return SelectSingleNode(query) != null;
        }

        public string GetSingleNodeText(string query)
        {
            return SelectSingleNode(query).InnerText;
        }

        public bool TryGetSingleNodeText(string query, out string text)
        {
            text = null;
            XmlNode node = SelectSingleNode(query);
            if (node != null)
            {
                text = node.InnerText;
            }
            return node != null;
        }

        public XmlNodeList SelectNodes(string query)
        {
            // If there's no client type, just run the query as given to us.
            if (!_clientType.HasValue)
            {
                return _xmlDoc.SelectNodes(query, _nsmgr);
            }
            
            // If there is a client type, try the client-specific query. If that fails, 
            // try a client-exclusive query.
            else
            {
                XmlNodeList nodes = _xmlDoc.SelectNodes(FormatClientRestrictedQuery(query), _nsmgr);

                if (nodes == null || nodes.Count == 0)
                {
                    nodes = _xmlDoc.SelectNodes(FormatClientExclusiveQuery(query), _nsmgr);
                }
                return nodes;
            }
        }

        public XmlNode SelectSingleNode(string query)
        {
            // If there's no client type, just run the query as given to us.
            if (!_clientType.HasValue)
            {
                return _xmlDoc.SelectSingleNode(query, _nsmgr);
            }
            
            // If there is a client type, try the client-specific query. If that fails, 
            // try a client-exclusive query.
            else
            {
                XmlNode node = _xmlDoc.SelectSingleNode(FormatClientRestrictedQuery(query), _nsmgr);

                if (node == null)
                {
                    node = _xmlDoc.SelectSingleNode(FormatClientExclusiveQuery(query), _nsmgr);
                }
                return node;
            }
        }

        public bool TryGetBeginDate(UserRightsUtil.MediaInstanceRights rights, out DateTime dt)
        {
            dt = DateTime.MinValue;

            XmlNode nodeFixBegin = SelectSingleNode("//ns:TimeRestrictions/ns:FixedExpiration/@beginDate");
            XmlNode nodeSkewBegin = SelectSingleNode("//ns:TimeRestrictions/ns:BeginDateClockSkew");

            if (nodeFixBegin != null && nodeSkewBegin != null)
            {
                throw new XRLException(HResult.XONLINE_E_INTERNAL_ERROR, XEvent.Id.LICENSE_XML_ERROR, 
                    String.Format("We don't support both ExpriationFixBeginDate and BeginDateClockSkew, but license type {0} has both.", _licenseTypeId));
            }
            else if (nodeFixBegin != null)
            {
                dt = DateTime.Parse(nodeFixBegin.InnerText);
            }
            else if (nodeSkewBegin != null)
            {
                dt = rights.purchaseDate.AddMinutes(-Int32.Parse(nodeSkewBegin.InnerText));
            }

            return dt != DateTime.MinValue;
        }

        public bool TryGetEndDate(UserRightsUtil.MediaInstanceRights rights, out DateTime dt)
        {
            dt = rights.absoluteExpiration;
            XmlNode nodeFixEnd = SelectSingleNode("//ns:TimeRestrictions/ns:FixedExpiration/@expirationDate");
            XmlNode nodeRelativeEnd = SelectSingleNode("//ns:TimeRestrictions/ns:ExpirationDaysPurchaseRelativeEnd");

            if (nodeFixEnd != null && nodeRelativeEnd != null)
            {
                throw new XRLException(HResult.XONLINE_E_INTERNAL_ERROR, XEvent.Id.LICENSE_XML_ERROR, 
                    String.Format("We don't support both ExpirationFixEndDate and ExpirationPurchaseRelativeEnd, but license type {0} has both.", _licenseTypeId));
            }
            else if (nodeFixEnd != null)
            {
                dt = NormalizeDateForAbsoluteEnd(DateTime.Parse(nodeFixEnd.InnerText), dt);
            }
            else if (nodeRelativeEnd != null)
            {
                dt = NormalizeDateForAbsoluteEnd(rights.purchaseDate.AddDays(Int32.Parse(nodeRelativeEnd.InnerText)), dt);
            }

            // Due to an overflow issue on the console when the expiration date is crazy (like 200 years in the future),
            // we need to cap it at a reasonable limit.
            DateTime max = DateTime.UtcNow.AddYears(40);
            if (dt > max)
            {
                dt = max;
            }

            return dt != DateTime.MinValue;
        }

        public static bool LicenseTypeRequiresAcknowledgement(int licenseTypeId)
        {
            LicenseXmlHelper xmlHelper = new LicenseXmlHelper(licenseTypeId);
            return xmlHelper.IsOfferType("PPV");
        }

        public static bool TryGetMaximumLicenseCount(int licenseTypeId, CatalogClientTypeEnum clientType, out uint maximumLicenses)
        {
            maximumLicenses = 0;

            LicenseXmlHelper xmlHelper = new LicenseXmlHelper(licenseTypeId, clientType);

            string maximumString;
            if (xmlHelper.TryGetSingleNodeText(LICENSE_MAXIMUM_QUERY, out maximumString))
            {
                maximumLicenses = UInt32.Parse(maximumString);
                return true;
            }

            return false;
        }

        public static bool LicenseTypeRequiresCounting(int licenseTypeId, CatalogClientTypeEnum clientType)
        {
            LicenseXmlHelper xmlHelper = new LicenseXmlHelper(licenseTypeId, clientType);

            return xmlHelper.SelectSingleNode(LICENSE_MAXIMUM_QUERY) != null;
        }
        private const string LICENSE_MAXIMUM_QUERY = "//ns:LicenseCountMax";

        private static DateTime NormalizeDateForAbsoluteEnd(DateTime dt, DateTime absoluteEnd)
        {
            if (absoluteEnd != DateTime.MinValue && absoluteEnd < dt)
            {
                return absoluteEnd;
            }
            else
            {
                return dt;
            }
        }

        private string FormatClientRestrictedQuery(string originalQuery)
        {
            const string CLIENT_RESTRICTION_FORMAT = "//ns:ClientPolicy[ns:ClientType/*/@ClientTypeId={0:d}]{1}";
            return String.Format(CLIENT_RESTRICTION_FORMAT, _clientType, originalQuery);
        }

        private string FormatClientExclusiveQuery(string originalQuery)
        {
            const string CLIENT_EXCLUSIVE_FORMAT = "{0}[not(ancestor::ns:ClientPolicy)]";
            return String.Format(CLIENT_EXCLUSIVE_FORMAT, originalQuery);
        }

        private readonly XmlDocument _xmlDoc;
        private readonly XmlNamespaceManager _nsmgr;
        private readonly int _licenseTypeId;
        private CatalogClientTypeEnum? _clientType;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\ValidateCertificateImpl.cs ===
using System;
using System.Collections.Generic;
using System.Security.Cryptography.X509Certificates;
using System.Web;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.server.signature
{
    public static class ValidateCertificateImpl
    {
        public static HResult ValidateCertificate(
            byte[] certificateBlob, out X509Certificate2 certificate, out DateTime validUntil
        )
        {
            // when we give someone a response,  that  response  is
            // good for a configured period of time.  get that here

            int validUntilMinutes = GetIntSetting(
                Setting.signature_validateCertificateValidUntilMinutes
            );

            validUntil = DateTime.UtcNow.AddMinutes(validUntilMinutes);

            // deserialize the certificate, if we can't then return
            // an error, and tell them  to  go  away  for  a  while

            try {
                certificate = new X509Certificate2(certificateBlob);
            }
            catch (Exception) {
                certificate = null;
                return HResult.XONLINE_E_SIGNATURE_CERTIFICATE_INVALID;
            }

            // see if the certificate is expired.  if so then  tell
            // them and again - don't come back for a little  while

            HResult hr;
            DateTime expirationDate;

            hr = ValidateCertificateExpiration(certificate, out expirationDate);
            if (hr != HResult.S_OK) return hr;

            // if not expired, but it will expire before validUntil
            // then change validUntil to the certificate expiration

            if (expirationDate < validUntil) validUntil = expirationDate;

            // and then finally the real stuff we want to check  is
            // the key usage,  and  a  validate  certificate  chain

            X509ValidationConfiguration validationConfiguration = new X509ValidationConfiguration(certificate);

            hr = ValidateCertificateUsage(certificate, validationConfiguration, X509KeyUsageFlags.KeyEncipherment);
            if (hr != HResult.S_OK) return hr;

            return ValidateCertificateChain(certificate, validationConfiguration.RevocationMode);
        }


        private static HResult ValidateCertificateExpiration(
            X509Certificate2 certificate, out DateTime expirationDate
        )
        {
            expirationDate = DateTime.Parse(
                certificate.GetExpirationDateString()
            );

            return expirationDate < DateTime.UtcNow ?
                HResult.XONLINE_E_SIGNATURE_CERTIFICATE_EXPIRED : HResult.S_OK;
        }

        private static HResult ValidateCertificateUsage(X509Certificate2 certificate, X509ValidationConfiguration validationConfig, X509KeyUsageFlags flags)
        {
            if (!validationConfig.HasKeyUsageFlags) return HResult.S_OK;
            return ((validationConfig.KeyUsageFlags & flags) != 0) ? HResult.S_OK : HResult.XONLINE_E_SIGNATURE_CERTIFICATE_USAGE_INVALID;
        }
        
        private static HResult ValidateCertificateChain(X509Certificate2 certificate, X509RevocationMode revocationMode)
        {
            X509Chain chain = new X509Chain();
            chain.ChainPolicy.RevocationMode = revocationMode;
            if (chain.Build(certificate))
            {
                if (Array.TrueForAll(chain.ChainStatus, ValidateChainStatus))
                {
                    return HResult.S_OK;
                }
            }
            return HResult.XONLINE_E_SIGNATURE_CERTIFICATE_CHAIN_INVALID;
        }

        private static bool ValidateChainStatus(X509ChainStatus chainStatus)
        {
            return chainStatus.Status == X509ChainStatusFlags.NoError;
        }

        private static int GetIntSetting(string name)
        {
            try {
                return int.Parse(Config.GetSetting(name));
            }

            catch (Exception e) {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_SIGNATURE_VALIDATE_CERTIFICATE_ERROR, e,
                    "Required configuration setting '" + name + "' was not found"
                );
            }
        }

        private sealed class X509ValidationConfiguration
        {
            public X509ValidationConfiguration(X509Certificate2 certificate)
            {
                foreach (X509Extension extension in certificate.Extensions)
                {
                    if (s_extensionMap.ContainsKey(extension.Oid.FriendlyName))
                    {
                        s_extensionMap[extension.Oid.FriendlyName](this, extension);
                    }
                }
            }

            public bool HasKeyUsageFlags
            {
                get
                {
                    return _hasFlags;
                }
            }

            public X509KeyUsageFlags KeyUsageFlags
            {
                get
                {
                    return _flags;
                }
            }

            public X509RevocationMode RevocationMode
            {
                get
                {
                    return _revocationMode;
                }
            }

            static X509ValidationConfiguration()
            {
                s_extensionMap = new Dictionary<string, ExtensionProcessor>();
                s_extensionMap.Add("Key Usage", ProcessKeyUsageExtension);
                s_extensionMap.Add("CRL Distribution Points", ProcessCrlExtension);
            }

            private delegate void ExtensionProcessor(X509ValidationConfiguration config, X509Extension extension);

            private static void ProcessKeyUsageExtension(X509ValidationConfiguration config, X509Extension extension)
            {
                config._hasFlags = true;
                config._flags |= ((X509KeyUsageExtension)extension).KeyUsages;
            }

            private static void ProcessCrlExtension(X509ValidationConfiguration config, X509Extension extension)
            {
                string revocationMode = Config.GetSetting(Setting.signature_crlRevocationMode).ToLower();

                if (revocationMode == "nocheck")
                    config._revocationMode = X509RevocationMode.NoCheck;
                else if (revocationMode == "online")
                    config._revocationMode = X509RevocationMode.Online;
                else if (revocationMode == "offline")
                {
                    config._revocationMode = X509RevocationMode.Offline;
                }
            }

            private bool _hasFlags = false;
            private X509KeyUsageFlags _flags = 0;
            private X509RevocationMode _revocationMode = X509RevocationMode.NoCheck;

            private readonly static Dictionary<string, ExtensionProcessor> s_extensionMap;
        }
    }
 }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\TransferUserLicenses.cs ===
using System;
using System.Web;
using System.Diagnostics;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.mgmt;

namespace xonline.server.signature
{
    public sealed class GetLicenseTransferState : IHttpHandler
    {
        public void ProcessRequest(HttpContext context)
        {
            CallSource.Check(VirtualInterface.xsig_int, VirtualInterface.xsig);

            uint hr = HResult.S_OK;
            GetLicenseTransferStateResponse response = new GetLicenseTransferStateResponse();
            GetLicenseTransferStateRequest request = new GetLicenseTransferStateRequest();

            try
            {
                request.ReadFromRequest(context.Request);
                response = LicenseTransferStateUtil.GetLicenseTransferStatus(request.userPuid);

                XRLUtil.SetXRLResponse(context.Response, XOService.Signature_Server, 0, HResult.S_OK, response);
            }
            catch (Exception e)
            {
                hr = XRLException.ToHResult(e, HResult.XONLINE_E_SIGNATURE_TRANSFER_USER_LICENSES_ERROR);
                if (e is XRLException)
                {
                    throw;
                }
                else
                {
                    throw new XRLException(hr, XEvent.Id.LICENSE_GENERAL, "GetLicenseTransferState failed.", e);
                }
            }
            finally
            {
                string logLine = String.Join("|", new string[]
                    {
                        "LICTRAN_GET",
                        request.userPuid.ToString("X"),
                        hr.ToString("X"),
                        response.currentStatus.ToString(),
                        response.restartAllowed.ToString(),
                        response.lastUpdated.ToString(),
                        response.consoleId,
                        response.nextAvailableTransfer.ToString(),
                    }
                );
                Xom.Log(XomAreaName.xsiglog, logLine);
            }
        }

        ///
        /// Can this instance be reusable?
        /// Since we hold no state in these requests, the answer is yes.
        ///
        public bool IsReusable { get { return true; } }
    }

    public sealed class UpdateLicenseTransferState : IHttpHandler
    {
        public void ProcessRequest(HttpContext context)
        {
            CallSource.Check(VirtualInterface.xsig_int, VirtualInterface.xsig);

            uint hr = HResult.S_OK;
            UpdateLicenseTransferStateRequest request = new UpdateLicenseTransferStateRequest();

            try
            {
                request.ReadFromRequest(context.Request);

                LicenseTransferUtil.UpdateLicenseTransferState(request.userPuid, request.command);

                XRLUtil.SetXRLResponse(context.Response, XOService.Signature_Server, 0, HResult.S_OK);
            }
            catch (Exception e)
            {
                hr = XRLException.ToHResult(e, HResult.XONLINE_E_SIGNATURE_TRANSFER_USER_LICENSES_ERROR);
                if (e is XRLException)
                {
                    throw;
                }
                else
                {
                    throw new XRLException(hr, XEvent.Id.LICENSE_GENERAL, "UpdateLicenseTransferState failed.", e);
                }
            }
            finally
            {
                string logLine = String.Join("|", new string[]
                    {
                        "LICTRAN_UPDATE",
                        request.userPuid.ToString("X"),
                        request.command.ToString(),
                        hr.ToString("X"),
                    }
                );
                Xom.Log(XomAreaName.xsiglog, logLine);
            }
        }

        ///
        /// Can this instance be reusable?
        /// Since we hold no state in these requests, the answer is yes.
        ///
        public bool IsReusable { get { return true; } }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\RefreshGameLicense.cs ===
using System;
using System.Diagnostics;
using System.Web;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.mgmt;

namespace xonline.server.signature
{
    public sealed class RefreshGameLicense : IHttpHandler
    {
        public void ProcessRequest(HttpContext context)
        {
            uint hr = HResult.S_OK;
            Guid mediaInstanceId = new Guid();

            RefreshGameLicenseRequest request = new RefreshGameLicenseRequest();

            try
            {
                CallSource.Check(VirtualInterface.xsig, VirtualInterface.xsig_int);

                // make sure we stop unwelcome visitors
                SGInfo.VerifyServiceId(XOService.Signature_Server);

                request.ReadFromRequest(context.Request);

                if (!SGInfo.IsPc())
                {
                    SGInfo.VerifyMachineId(request.machineId);
                }

                if (request.userId != 0)
                {
                    SGInfo.VerifyUserId(request.userId);
                }

                // process the request

                string[] logLines;
                RefreshGameLicenseResponse response = new RefreshGameLicenseResponse();
                response = ContentLicenseUtil.RefreshGameLicense(request, ref mediaInstanceId, out logLines);

                foreach (string logLine in logLines)
                {
                    Xom.Log(XomAreaName.Reporting, logLine);
                }

                // write out the response
                XRLUtil.SetXRLResponse(context.Response, XOService.Signature_Server, HResult.S_OK, response);
            }
            catch (Exception e)
            {
                hr = XRLException.ToHResult(e, HResult.XONLINE_E_SIGNATURE_REFRESH_GAME_LICENSE_ERROR);

                if (e is XRLException)
                {
                    throw;
                }
                else
                {
                    throw new XRLException(hr, XEvent.Id.LICENSE_GENERAL, "RefreshGameLicense failed.", e);
                }
            }
            finally
            {
                string szLog = String.Join("|", new string[]
                    {
                        "RefreshGameLicense",
                        hr.ToString("X"),
                        SGInfo.Current == null ? "" : SGInfo.Current.Nonce.ToString("d"),
                        mediaInstanceId.ToString(),
                        request == null ? "" : request.userId.ToString("x"),
                        request == null ? "" : request.machineId.ToString("x")
                    });
                Xom.Log(XomAreaName.xsiglog, szLog);
            }
        }

        ///
        /// Can this instance be reusable?
        /// Since we hold no state in these requests, the answer is yes.
        ///
        public bool IsReusable { get { return true; } }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\XmstvCreateCertificate.cs ===
using System;
using System.Web;

using xonline.common.protocol;
using xonline.common.service;
using xonline.common.utilities;
using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;


namespace xonline.server.signature
{
    ///
    /// This is the class that hooks into ASP.NET to handle requests for
    /// IPTV certificates.  Most of the work involved is handed off to
    /// helper classes.
    ///
    public sealed class XmstvCreateCertificate : IHttpHandler
    {
        ///
        /// The central point that all certificate requests go through.
        /// The basic steps here are
        ///  1) Make sure the request is valid.
        ///  2) Generate the certificates.
        ///  3) Update our tables.
        ///  4) Send the certificates back to the client.
        /// Plus we have some ASP.NET process handling, errors, and logging thrown
        /// in for good measure.
        ///
        /// Breakpoint: xonline.server.signature.XmstvCreateCertificate.ProcessRequest
        public void ProcessRequest(HttpContext context)
        {
            uint hr = HResult.S_OK;
            uint flags = 0;

            try
            {
                // Get the input request.
                XmstvCreateCertificateRequest request = new XmstvCreateCertificateRequest();
                request.ReadFromRequest(context.Request);
                flags = request.Flags;

                // Determine if this is a valid request.  For full details see the CertificateRequesChecker class.
                // If it is not a valid request, error out.
                Validator validator = CertificateValidatorFactory.GetCertificateValidator(request);
                if (!validator.DoCheck())
                {
                    throw new XRLException(HResult.E_ACCESSDENIED, XEvent.Id.XMSTV_CERT_REQUEST_CHECK,
                        "{0}.  puid = 0x{1:X16}", validator.ErrorMessage, SGInfo.Current.MachineId);
                }

                // Actually create the certificates.
                string consolId = GetCurrentConsoleId();
                XmstvCertificateGenerator generator = XmstvCertificateGenerator.GetCertificateGenerator();
                XmstvCertificate avCertificate = generator.GenerateCertificate(consolId, request.AvPubKey, true);
                XmstvCertificate nonAvCertificate = generator.GenerateCertificate(consolId, request.NonAvPubKey, false);

                // Create the response.  Do this here so if we fail out we haven't yet updated our
                // tables.
                XmstvCreateCertificateResponse response = CreateResponse(avCertificate, nonAvCertificate);

                // Update our tables.
                CertificateTableUpdater updater = new CertificateTableUpdater(
                    SGInfo.Current.MachineId, avCertificate, nonAvCertificate);
                updater.DoUpdate();

                // Now send our response.
                XRLUtil.SetXRLResponse(context.Response, XOService.Signature_Server, HResult.S_OK, response);
            }
            catch (Exception e)
            {
                hr = XRLException.ToHResult(e, HResult.XONLINE_E_SIGNATURE_CREATE_CERTIFICATE_ERROR);
                throw;
            }
            finally
            {
                string szLog = String.Join("|", new string[]
                    {
                        "XMSTV_CERTAUTH",
                        SGInfo.Current.MachineId.ToString("X16"),
                        flags.ToString("X8"),
                        hr.ToString("X"),
                    });
                Xom.Log(XomAreaName.xsiglog, szLog);
            }
        }

        ///
        /// Can this instance be reusable?
        /// Since we hold no state in these requests, the answer is yes.
        ///
        public bool IsReusable { get { return true; } }

        ///
        /// Private helper functions from here down, the documentation will be limitted.
        ///
        private static string GetCurrentConsoleId()
        {
            return ConsoleIdUtil.GetXbox360ConsoleIdStringFromMachineId(SGInfo.Current.MachineId);
        }

        private XmstvCreateCertificateResponse CreateResponse(XmstvCertificate avCertificate, XmstvCertificate nonAvCertificate)
        {
            XmstvCreateCertificateResponse response = new XmstvCreateCertificateResponse();

            response.AvCertificateSize = (ushort)avCertificate.Certificate.Length;
            response.AvCertificate = avCertificate.Certificate;
            response.AvSerializedCertificateSize = (ushort)avCertificate.SerializedCertificate.Length;
            response.AvSerializedCertificate = avCertificate.SerializedCertificate;

            response.NonAvCertificateSize = (ushort)nonAvCertificate.Certificate.Length;
            response.NonAvCertificate = nonAvCertificate.Certificate;
            response.NonAvSerializedCertificateSize = (ushort)nonAvCertificate.SerializedCertificate.Length;
            response.NonAvSerializedCertificate = nonAvCertificate.SerializedCertificate;

            return response;
        }
    }


///
/// This class abstracts the necessary table updates.
/// Right now there's not much to it but the future is an unwoven tapestry.
///
    sealed class CertificateTableUpdater
    {
        ///
        /// Constructor.  We need the machine puid and (for now) the serial numbers we've created.
        /// Since XmstvCertificate already does size-verification on the serial numbers we
        /// don't need to do it ourselves.  Also, using that class instead serial-number byte-arrays
        /// allows us to easily expand what we update.
        ///
        public CertificateTableUpdater(UInt64 machinePuid, XmstvCertificate avCertificate, XmstvCertificate nonAvCertificate)
        {
            _machinePuid = machinePuid;
            _avSerialNumber = avCertificate.SerialNumber;
            _nonAvSerialNumber = nonAvCertificate.SerialNumber;
        }

        ///
        /// Update the tables.  This is a pretty standard table-update that just passes
        /// our data on to the table.
        ///
        public void DoUpdate()
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                int retval = 0;

                ws.StoredProc = "dbo.p_xmstv_insert_certificate";
                ws.AddParameter(ParamType.INPUT, "@puid", _machinePuid);
                ws.AddParameter(ParamType.INPUT, "@av_sn", _avSerialNumber, _avSerialNumber.Length);
                ws.AddParameter(ParamType.INPUT, "@nonav_sn", _nonAvSerialNumber, _nonAvSerialNumber.Length);
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", retval);
                ws.SetHashVal(_machinePuid);

                ws.ExecuteNonQuery();

                retval = ws.GetIntParameter("@RETVAL");

                if (retval != 0)
                {
                    Xom.NtEvent(XEvent.Id.XMSTV_GENERAL, 
                        "Failed to update tables for certificate creation. puid = {0}, AvSerialNumber = {1}, NonAvSerialNumber = {2}.",
                        (Puid) _machinePuid, _avSerialNumber, _nonAvSerialNumber);
                    throw new ApplicationException("Failed to hand out certificate.");
                }
            }
        }

        private readonly UInt64 _machinePuid;
        private readonly byte[] _avSerialNumber;
        private readonly byte[] _nonAvSerialNumber;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\ValidateCertificate.cs ===
using System;
using System.Web;
using System.Security.Cryptography.X509Certificates;

using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.server.signature
{
    public sealed class ValidateCertificate : IHttpHandler
    {
        public void ProcessRequest(HttpContext context)
        {
            HResult hr = HResult.S_OK;

            X509Certificate2 certificate = null;
            ValidateCertificateRequest request = null;
            ValidateCertificateResponse response = null;

            try
            {
                // deserialize the request buffer into  an  object
                request = new ValidateCertificateRequest();
                request.ReadFromRequest(context.Request);

                // setup response in advance to make things easier
                // and read some fields directly into the response

                response = new ValidateCertificateResponse();

                hr = ValidateCertificateImpl.ValidateCertificate(
                    request.certificate, out certificate, out response.validUntil
                );

                // we intentionally do  not  give  clients  useful
                // information on why their certificate is invalid.

                response.hr = hr.IsSuccess() ? hr : (HResult) HResult.XONLINE_E_SIGNATURE_CERTIFICATE_INVALID;
                XRLUtil.SetXRLResponse(context.Response, XOService.Signature_Server, HResult.S_OK, response);
            }
            catch (Exception e)
            {
                // if the exception has an event or explicitly  does  not
                // want to generate an event then rethrow, otherwise wrap

                hr = XRLException.ToHResult(e, HResult.XONLINE_E_SIGNATURE_VALIDATE_CERTIFICATE_ERROR);
                if ((e is ExceptionWithEvent) || (e is ExceptionWithoutEvent)) throw;

                throw new XRLException(hr, XEvent.Id.SIGNATURE_VALIDATE_CERTIFICATE_ERROR, "Error validating certificate.", e);
            }
            finally
            {
                string logLine = String.Join("|", new string[]
                    {
                        "VALIDATECERTIFICATE", 
                        hr.ToString(),                                                           // the real hr
                        response    == null ? string.Empty : response.hr.ToString(),             // the hr returned to the user
                        certificate == null ? string.Empty : certificate.Subject,                        
                        request     == null ? string.Empty : request.certificateSize.ToString(),
                    }
                );

                Xom.Log(XomAreaName.xsiglog, logLine);
            }
        }

        ///
        /// Can this instance be reusable?
        /// Since we hold no state in these requests, the answer is yes.
        ///
        public bool IsReusable { get { return true; } }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\XmstvRequestChecker.cs ===
using System;
using System.Security.Cryptography;

using xonline.common.service;
using xonline.common.config;
using xonline.common.sql.webstore;
using xonline.common.protocol;
using xonline.common.utilities2;
using xonline.common.utilities;
using xonline.common.xcrypto;

namespace xonline.server.signature
{
    static class CertificateValidatorFactory
    {
        ///
        /// Makes our Validator chain for us.
        ///
        public static Validator GetCertificateValidator(XmstvCreateCertificateRequest request)
        {
            return Validator.MakeValidatorChain(true, PlatformValidator.MakeXbox360PlatformValidator(), new CertificateLimitValidator(), new KeyedHashValidator(request));
        }

        ///
        /// Ensures that the request would not put the client over its limit of certificates.
        ///
        sealed private class CertificateLimitValidator : Validator
        {
            override protected DoCheckResults DoCheckImpl()
            {
                bool valid = true;

                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    ulong puid = SGInfo.Current.MachineId;
                    int allowedCertificates = Config.GetIntSetting(Setting.xmstv_maximumCertificatesAllowed);
                    DateTime serverLastRevocation = new DateTime(Config.GetLongSetting(Setting.xmstv_lastCaRevocationTicks));
                    int iValid = 0;

                    ws.StoredProc = "dbo.p_xmstv_check_over_limit";
                    ws.AddParameter(ParamType.INPUT, "@puid", puid);
                    ws.AddParameter(ParamType.INPUT, "@limit", allowedCertificates);
                    ws.AddParameter(ParamType.INPUT, "@countIfAfter", serverLastRevocation);
                    ws.AddParameter(ParamType.RETVAL, "@RETVAL", iValid);
                    ws.SetHashVal(puid);

                    ws.ExecuteNonQuery();

                    valid = (ws.GetIntParameter("@retval") == 0 ? false : true);

                    if (!valid)
                    {
                        this.ErrorMessage = String.Format(
                            "Console has requested more than {0} xmstv certificates.", allowedCertificates);
                    }
                }

                return (valid ? DoCheckResults.NoOpinion : DoCheckResults.AbsoluteNo);
            }
        }    

        ///
        /// Verifies the request by analyzing the KeyedHash. The KeyedHash is created on the 
        /// console side as follows:
        ///     1) Sha1 Digest of the request (not including the KeyedHash) is put into 
        ///     KeyedHash
        ///     2) The first 16 bytes of KeyedHash are AES encrypted using the consoles 
        ///     Primary Activation Key.
        ///
        /// So to verify the Keyed Hash, we must do the following:
        ///     1) Sha1 Digest the request (not including the KeyedHash)
        ///     2) Verify the sizeof(KeyedHash)-16 last bytes of the digest
        ///     3) Obtain the console's Primary Activation Key
        ///     4) AES encrypt the first 16 bytes of the digest wth the Primary Activation Key
        ///     5) Verify the first 16 bytes of the KeyedHash against the encrypted 16 bytes 
        ///     of the digest
        ///
        sealed class KeyedHashValidator : Validator
        {
            public KeyedHashValidator(XmstvCreateCertificateRequest request)
            {
                _requestBytes = GetBytesFromRequest(request);
                _keyedHash = request.KeyedHash;
            }

            override protected DoCheckResults DoCheckImpl()
            {
                // Get the sha1 digest.
                SHA1 sha1 = new SHA1Managed();
                byte[] computedDigest = sha1.ComputeHash(_requestBytes);

                // If they aren't the same size, this is totally wrong.
                if (computedDigest.Length != _keyedHash.Length)
                {
                    this.ErrorMessage = String.Format(
                        "Keyed hash length ({0}) does not match the size of our computed digest ({1}).", _keyedHash.Length, computedDigest.Length);
                    return DoCheckResults.AbsoluteNo;
                }

                // We are going to compare the encrypted and non-encrypted portions 
                // seperately, so we need to split them.
                byte[] computedEncrypted;
                byte[] computedClear;
                byte[] requestEncrypted;
                byte[] requestClear;
                ArrayUtil.SplitArray(computedDigest, ENCRYPTED_PORTION_SIZE, out computedEncrypted, out computedClear);
                ArrayUtil.SplitArray(_keyedHash, ENCRYPTED_PORTION_SIZE, out requestEncrypted, out requestClear);

                // Compare the clear-text portions.
                if (!ArrayUtil.CompareArrays(computedClear, requestClear))
                {
                    this.ErrorMessage = String.Format(EnumerableFormatter.Instance,
                        "Non-encrypted portions of the hash are not equal. Request: {0:efX}. Computed: {1:efX}.",
                        requestClear, computedClear);
                    return DoCheckResults.AbsoluteNo;
                }

                // Compare the encrypted portions. This requires a call into xcrypto.
                if (!CryptoKeyProxy.VerifyConsolePak(ConsoleIdUtil.GetConsoleIdFromMachineId(SGInfo.Current.MachineId, XOn.XPLT_XBOX360),
                        computedEncrypted, requestEncrypted))
                {
                    this.ErrorMessage = String.Format("Encrypted portions of the hash are not equal.");
                    return DoCheckResults.AbsoluteNo;
                }

                // If we get here, the validator passes.
                return DoCheckResults.NoOpinion;
            }

            private static byte[] GetBytesFromRequest(XmstvCreateCertificateRequest request)
            {
                byte[][] requestElements = new byte[][] 
                {
                    ConvertPrimitive(request.Flags, BitConverter.GetBytes),
                    request.AvPubKey,
                    request.NonAvPubKey,
                    ConvertPrimitive(request.KeyNonce, BitConverter.GetBytes)
                };
                return ArrayUtil.CombineArrays(requestElements);
            }

            private static byte[] ConvertPrimitive<T>(T prim, Converter<T, byte[]> converter)
            {
                byte[] bytes = converter(prim);
                Array.Reverse(bytes);
                return bytes;
            }

            private readonly byte[] _requestBytes;
            private readonly byte[] _keyedHash;

            private const int ENCRYPTED_PORTION_SIZE = 16;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\XmstvCertificateGenerator.cs ===
using System;
using System.Runtime.InteropServices;

using xonline.common.service;
using xonline.common.config;
using xonline.common.utilities;
using xonline.common.mgmt;


namespace xonline.server.signature
{
    ///
    /// A factory class to create the certificates we hand out to consoles.
    /// Right now the factory itself is implemented as a singleton though
    /// it is not gauranteed to be that way in the future.
    /// Just call GetCertificateGenerator and then GenerateCertificate.
    ///
    sealed class XmstvCertificateGenerator
    {
        ///
        /// Get a certificate generator.
        /// Classic double-checked locking method. The only wrinkle is
        /// that if we fail to init the casvc dll, we need to tear it
        /// down before the next request, which will attempt to initialize
        /// it again.
        ///
        public static XmstvCertificateGenerator GetCertificateGenerator()
        {
            if (_singleton == null)
            {
                lock(_syncRoot)
                {
                    if (_singleton == null)
                    {
                        XmstvCertificateGenerator temp = null;
                        try
                        {
                            temp = new XmstvCertificateGenerator();
                            temp.Initialize();
                            _singleton = temp;
                        }
                        catch (ExternalException)
                        {
                            if (temp != null)
                            {
                                temp.Dispose();
                            }
                            throw;
                        }
                    }
                }
            }
            return _singleton;
        }

        ///
        /// Generate a certificate.
        ///
        /// Params: consoleId:   format is 'XE.DDDDDDDDDDDC'
        ///         publicKey:  public key to use to generate the certificate.
        ///         type:       the type of certificate to create.  This is passed to the native function.
        ///
        /// Returns:    The certificate we generate (for details see the XmstvCertificate class).
        ///
        public XmstvCertificate GenerateCertificate(string consoleId, byte[] publicKey, bool avCert)
        {
            // Seriously, this should never, ever happen. I can't imagine how it would.
            if (_disposed)
            {
                throw new ObjectDisposedException("XmstvCertificateGenerator");
            }

            NativeCertificateWrapper wrapper = avCert ? _nativeWrapperAV : _nativeWrapperNonAV;

            // Size is the original size of the certificate arrays, but then is used
            // to re-size the arrays so we pass the smallest array possible to the
            // the client and we can tell them the exact size of the certificate.
            // Note that is re-used for both the certificate and the serialized version.
            UInt32 size = XmstvCertificate.MAX_CERTIFICATE_SIZE;

            // The actual certificates.
            byte[] certificate = new byte[XmstvCertificate.MAX_CERTIFICATE_SIZE];
            byte[] serialized = new byte[XmstvCertificate.MAX_CERTIFICATE_SIZE];

            // Eventually we need this is a byte-array but it works best to have a Guid
            // while we actually create it.
            Guid serialNumber = new Guid();

            // Create the basis for our certificate.
            string guid = GenerateGuid(consoleId);
            string subjectName = FormatSubjectName(consoleId, guid);

            // Call the native code and resize the certificate array.
            wrapper.CallCACertify(
                subjectName,
                publicKey,
                (UInt32) publicKey.Length,
                DateTime.UtcNow,
                DateTime.UtcNow.AddYears(10),
                certificate,
                ref size,
                ref serialNumber);
            Array.Resize(ref certificate, (int)size);

            // Call the native code and resize the serialized certificate array.
            size = XmstvCertificate.MAX_CERTIFICATE_SIZE;
            wrapper.CallCASerialize(certificate, (UInt32)certificate.Length, serialized, ref size);
            Array.Resize(ref serialized, (int)size);

            // Package our certificate all squeaky-clean.
            return new XmstvCertificate(certificate, serialized, serialNumber.ToByteArray());
        }

        ///
        /// Private helper functions from here down, the documentation will be limitted.
        ///

        private void Initialize()
        {
            _disposed = false;

            string issuerName = Config.GetSetting(Setting.xmstv_issuerCertName);
            string crldp = Config.GetSetting(Setting.xmstv_crldp);
            string infoUri = Config.GetSetting(Setting.xmstv_accessInfoUri);

            // Get the subject name.
            _subjectNameSuffix = Config.GetSetting(Setting.xmstv_subjectNameSuffix);

            // Initialize our certificate generators.
            _nativeWrapperAV = new NativeCertificateWrapper(issuerName, CASvcExtensionFlags.MstvAVPolicy, crldp, infoUri);
            _nativeWrapperNonAV = new NativeCertificateWrapper(issuerName, CASvcExtensionFlags.ClientAuthentication, crldp, infoUri);
        }

        // Implement the Dispose pattern without implementing IDisposable. Since we
        // are currently implemented as a singleton we don't want to let people
        // call Dispose on us. We only need this for initialization and tear-down.
        private void Dispose()
        {
            if (_nativeWrapperAV != null)
            {
                _nativeWrapperAV.Dispose();
                _nativeWrapperAV = null;
            }
            if (_nativeWrapperNonAV != null)
            {
                _nativeWrapperNonAV.Dispose();
                _nativeWrapperNonAV = null;
            }
            _disposed = true;
        }

        private static string GenerateGuid(string consoleId)
        {
            // The Guid we use breaks down thusly:
            // xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
            // |--sig-| |--pad--| |---console-id--|
            //
            // where
            //  sig (4 bytes)           = Unique Signature generated by us.
            //  pad (4 bytes)           = padding (all '0')
            //  console-id (8 bytes)    = Decimal representation of the console-id.
            //
            // So if the console-id is 'XE.DDDDDDDDDDDC' then the GUID is
            //  09291997-0000-0000-0000-DDDDDDDDDDDC
            return String.Format("09201997-0000-0000-0000-{0}", ConsoleIdUtil.TrimConsoleIdPrefix(consoleId));
        }

        private string FormatSubjectName(string consoleId, string guid)
        {
            return String.Format("SN={0},CN={1}{2}", consoleId, guid, _subjectNameSuffix);
        }

        private static volatile XmstvCertificateGenerator _singleton = null;
        private readonly static Object _syncRoot = new Object();

        private string _subjectNameSuffix;
        private bool _disposed;

        private NativeCertificateWrapper _nativeWrapperAV;
        private NativeCertificateWrapper _nativeWrapperNonAV;
    }

    ///
    /// A read-only class that represents a single certificate.  This holds
    /// everything we really need about a certificate and verifies the
    /// sizes of the byte-arrays as you construct one.
    ///
    sealed class XmstvCertificate
    {
        ///
        /// Constructor.  the sizes of the certificates and the serial number will
        /// be verified and an exception thrown if invalid.
        public XmstvCertificate(byte[] certificate, byte[] serializedCertificate, byte[] serialNumber)
        {
            VerifyArguments(certificate, serializedCertificate, serialNumber);
            _certificate = certificate;
            _serializedCertificate = serializedCertificate;
            _serialNumber = serialNumber;
        }

        ///
        /// Read-only properties for the elements in this certificate.
        ///
        public byte[] Certificate { get { return (byte[])_certificate.Clone(); } }
        public byte[] SerializedCertificate { get { return (byte[])_serializedCertificate.Clone(); } }
        public byte[] SerialNumber { get { return (byte[])_serialNumber.Clone(); } }

        ///
        /// Private helper functions from here down, the documentation will be limitted.
        ///
        private void VerifyArguments(byte[] certificate, byte[] serializedCertificate, byte[] serialNumber)
        {
            if (certificate.Length > MAX_CERTIFICATE_SIZE)
            {
                throw new ArgumentException(String.Format("Certificates must be no longer than {0}.", MAX_CERTIFICATE_SIZE));
            }
            if (serializedCertificate.Length > MAX_CERTIFICATE_SIZE)
            {
                throw new ArgumentException(String.Format("Serialized Certificates must be no longer than {0}.", MAX_CERTIFICATE_SIZE));
            }
            if (serialNumber.Length != SERIAL_NUMBER_SIZE)
            {
                throw new ArgumentException(String.Format("Serial Number must have size exactly {0}", SERIAL_NUMBER_SIZE));
            }
        }

        /// These must be kept consistent with XmstvCreateCertifiateRequest/Response
        /// C# does not have a CASSERT that I can find, though.
        public const int SERIAL_NUMBER_SIZE = 16;
        public const int MAX_CERTIFICATE_SIZE = 1500;

        private readonly byte[] _certificate;
        private readonly byte[] _serializedCertificate;
        private readonly byte[] _serialNumber;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\XSigGetSignKey.cs ===
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
// Author: Natalyp
//

using System;
using System.IO;
using System.Web;
using System.Security.Cryptography;
using System.Text;

using xonline.common.config;
using xonline.common.crypto;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;
using xonline.common.blacklist;


[assembly: XomAreaDefinition(XomAreaName.xsig)]
[assembly: XomAreaDefinition(XomAreaName.xsiglog)]



namespace xonline.server.signature
{
    //-----------------------------------------------------
    // XSigSignature class represents signature structure
    //
    //-----------------------------------------------------
    // create signature key from for given request
    //
public class XSigUtil
{


    static public byte[] CreateSignatureKey (XSigSignature sig)
{

    int keyType = Config.GetIntSetting(Setting.signature_serviceKeyType);
    byte[] key = CryptoReader.GetKey(keyType, sig._keyVersion);

    MemoryStream ms = new MemoryStream();
    BinaryWriter wr = new BinaryWriter(ms);

    wr.Write(sig._serviceId);
    wr.Write(sig._timeStamp);
    wr.Write(sig._authData._titleID);
    wr.Write(sig._authData._titleVersion);
    wr.Write(sig._authData._XboxID);
    wr.Write(sig._authData._userID1);
    wr.Write(sig._authData._userID2);
    wr.Write(sig._authData._userID3);
    wr.Write(sig._authData._userID4);

    byte[] data = ms.ToArray();

    HMACSHA1 shaM = new HMACSHA1(key);

    shaM.ComputeHash(data);

    return shaM.Hash;

}

}
    public class XSigGetSignKey : IHttpHandler
    {
        //-----------------------------------------------------
        // ProcessRequest (IHttpHandler)
        //
        // the main entry point for http requests.
        //
        public void ProcessRequest(HttpContext ctx)
        {
            XSigGetSignKeyCounter.Counters.RequestsPerSecond.Increment();
            XSigGetSignKeyCounter.Counters.RequestsTotal.Increment();

            XSigListMgr.Init();

            // Check to make sure call is from Internet
            CallSource.Check(VirtualInterface.xsig);

            if (ctx.Request.InputStream.Length > 0)
            {
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.SIGNATURE_CODE_1,
                    "XSigGetSignKey: the request contains input data. That's invalid.");
            }

            XSigSignature resp = new XSigSignature();
            resp._authData = new XSigAuthData();

            resp._timeStamp = DateTime.UtcNow.Ticks;
            try
            {
                GetSGInfo(resp);
            }
            catch (Exception e)
            {
                XSigGetSignKeyCounter.Counters.FailuresTotal.Increment();
                throw new XRLException(HResult.XONLINE_E_SIGNATURE_GET_BAD_AUTH_DATA, XEvent.Id.SIGNATURE_CODE_2, e.Message);
            }

            // check the machine permissions.
            if ( XSigListMgr.MachineBlackList.IsBlackListed( resp._authData._XboxID ) )
            {
                Xom.Log(XomAreaName.xsiglog, "BAN|" + resp.ToString() );
                Xom.Trace(XomAreaName.xsig, LogLevel.L_LOW, "XSigGetSignKey:  Machine Blacklisted.  " + resp.ToString());
                XSigGetSignKeyCounter.Counters.FailuresTotal.Increment();
                throw new XRLException(HResult.XONLINE_E_SIGNATURE_BANNED_XBOX, XEvent.Id.SIGNATURE_INFO_0, "XSigGetSignKey: Machine Blacklisted.  " + resp.ToString() );
            }

            // check title id and version
            if ( XSigListMgr.TitleBlackList.IsBlackListed( resp._authData._titleID, resp._authData._titleVersion ) )
            {
                Xom.Log(XomAreaName.xsiglog, "BAN|" + resp.ToString() );
                Xom.Trace(XomAreaName.xsig, LogLevel.L_WARNING, "XSigGetSignKey:  Title Blacklisted.  " + resp.ToString());
                XSigGetSignKeyCounter.Counters.FailuresTotal.Increment();
                throw new XRLException(HResult.XONLINE_E_SIGNATURE_BANNED_TITLE, XEvent.Id.SIGNATURE_INFO_1, "XSigGetSignKey: Failed:  " + resp.ToString() );
            }

            // check the users.
            if ( XSigListMgr.UserBlackList.IsBlackListed( resp._authData._userID1 ) ||
                XSigListMgr.UserBlackList.IsBlackListed( resp._authData._userID2 ) ||
                XSigListMgr.UserBlackList.IsBlackListed( resp._authData._userID3 ) ||
                XSigListMgr.UserBlackList.IsBlackListed( resp._authData._userID4 )
                )
            {
                Xom.Log(XomAreaName.xsiglog, "BAN|" + resp.ToString() );
                Xom.Trace(XomAreaName.xsig, LogLevel.L_WARNING, "XSigGetSignKey:  User Blacklisted.  " + resp.ToString());
                XSigGetSignKeyCounter.Counters.FailuresTotal.Increment();

                throw new XRLException(HResult.XONLINE_E_SIGNATURE_BANNED_USER, XEvent.Id.SIGNATURE_INFO_2,  "XSigGetSignKey: User Blacklisted. " + resp.ToString());
            }

            // set the key in the response.
            resp._keyVersion = (short) (Config.GetIntSetting(Setting.signature_serviceKeyVersion));
            resp._reserved = new byte [XSigSignature.XONLINE_XSIG_RESERVED_SIZE];

            try
            {
                resp._signature = XSigUtil.CreateSignatureKey(resp);
            }
            catch (System.IndexOutOfRangeException e)
            {
                Xom.NtEvent(XEvent.Id.SIGNATURE_CONFIG_0, e, "XSigGetSignKey: Current signature server KeyVersion is :" + resp._keyVersion +
                    " No master signature key found. Server is misconfigured");

                XSigGetSignKeyCounter.Counters.FailuresTotal.Increment();
                throw new XRLException(HResult.XONLINE_E_SIGNATURE_SERVICE_UNAVAILABLE, XEvent.Id.SIGNATURE_CODE_3, "XSigGetSignKey: misconfigured Signature Server. Version number "
                    + resp._keyVersion.ToString("d") + " is unknown", e);
            }

            Xom.Trace(XomAreaName.xsig, LogLevel.L_LOW, "XSigGetSignKey: New signature key is created successfully. \r\nSignature data: " + resp.ToString());
            Xom.Log(XomAreaName.xsiglog, "KEY|"+ resp.ToString());
            XRLUtil.SetXRLResponse(ctx.Response, XOService.Signature_Server, HResult.S_OK, resp);
        }

        //-----------------------------------------------------
        // IsReusable (IHttpHandler)
        //
        //      this dll doesn't hold request-specific state, so
        //      it's fine to reuse the same instance.
        //
        public bool IsReusable
        {
            get { return true; }
        }

        //-----------------------------------------------------
        //  SGInfo is required to create a signing key
        //
        private void GetSGInfo(XSigSignature resp)
        {
            if( AuthToggle.On )
            {
                SGInfo.VerifyServiceId(XOService.Signature_Server);

                resp._authData._titleID = SGInfo.Current.TitleId;
                resp._authData._titleVersion = SGInfo.Current.TitleVersion;
                resp._authData._XboxID = SGInfo.Current.MachineId;
                resp._liNonce = SGInfo.Current.Nonce;

                XUIDAndTrust[] xUsers = new XUIDAndTrust[4];
                xUsers = SGInfo.Current.LogonUsers;
                resp._authData._userID1 = xUsers[0].qwUserID;
                resp._authData._userID2 = xUsers[1].qwUserID;
                resp._authData._userID3 = xUsers[2].qwUserID;
                resp._authData._userID4 = xUsers[3].qwUserID;
            }
            else
            {   // should not happen in production environment for testing purposes only
                // resp._timeStamp = (DateTime.Parse("1/1/2000")).Ticks;
                resp._keyVersion = 1;
                resp._authData._titleID = (int) 11231231;
                resp._authData._titleVersion =(int) 111;
                resp._authData._XboxID = (ulong) 0x23423423423432;
                resp._authData._userID1 = (ulong) 23423234;
                resp._authData._userID2 = (ulong) 0x12341234;
                resp._authData._userID3 = (ulong) 0;
                resp._authData._userID4 = (ulong) 0xfffeab23;
            }
        }
    }

 }   // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\XSigSignOnBehalf.cs ===
using System;
using System.IO;
using System.Web;
using System.Security.Cryptography;
using System.Text;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;
using xonline.common.crypto;
using xonline.common.blacklist;

namespace xonline.server.signature
{
    //-----------------------------------------------------
    // XSigSignOnBehalf class used for signing data by a server
    //

    public class XSigSignOnBehalf : IHttpHandler
    {
        //-----------------------------------------------------
        // ProcessRequest (IHttpHandler)
        //
        // the main entry point for http requests.
        //
        //
        public void ProcessRequest(HttpContext ctx)
        {
            XSigSignOnBehalfCounter.Counters.RequestsPerSecond.Increment();
            XSigSignOnBehalfCounter.Counters.RequestsTotal.Increment();

            XSigListMgr.Init();

            // Check to make sure call is from DataCenter
            CallSource.Check(VirtualInterface.xsig_int);

            try
            {
                ParseRequest();
            }
            catch (Exception e)
            {
                XSigSignOnBehalfCounter.Counters.FailuresTotal.Increment();
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.SIGNATURE_CODE_4, e.Message);
            }

            try
            {
                ComputeSignature();
            }
            catch (Exception e)
            {
                XSigSignOnBehalfCounter.Counters.FailuresTotal.Increment();
                Xom.NtEvent(XEvent.Id.SIGNATURE_CONFIG_1, e, "Server is misconfigured.");
                throw new XRLException(HResult.XONLINE_E_SIGNATURE_SERVICE_UNAVAILABLE, XEvent.Id.SIGNATURE_CODE_5, "XSigSignOnBehalf: misconfigured Signature Server. Current key version "+
                    Config.GetIntSetting(Setting.signature_serviceKeyVersion), e);
            }


            XRLUtil.SetXRLResponse(ctx.Response, XOService.Signature_Server, 0, HResult.S_OK);

            for( int i = 0; i < _recordsCount; i++ )
            {
                _resSignatures[i].WriteStream(ctx.Response.OutputStream);
                Xom.Log(XomAreaName.xsiglog, "KEYONBEHALF|" + ByteConvert.ToString(_resSignatures[i]._signature._signature) + "|"+
                    _requests[i].ToString() + "|" +
                    _resSignatures[i]._signature._signatureVersion.ToString("X4")       + "|" +
                    _resSignatures[i]._signature._keyVersion.ToString("X4")       + "|" +
                    _resSignatures[i]._signature._timeStamp.ToString("X16")  + "|" +
                    ByteConvert.ToString(_resSignatures[i]._signature._signature)  );
            }

        }
        //-----------------------------------------------------
        // IsReusable (IHttpHandler)
        //
        //      this dll doesn't hold request-specific state, so
        //      it's fine to reuse the same instance.
        //
        public bool IsReusable
        {
            get { return true; }
        }

        //-----------------------------------------------------
        // Request might include multiple structures for signing.
        //
        private void ParseRequest()
        {
            _recordsCount = 0;
            HttpContext ctx = HttpContext.Current;
            if (ctx.Request.InputStream.Length > System.Int32.MaxValue)
            {
                Xom.Trace(XomAreaName.xsig, LogLevel.L_ERROR, "XSigSignOnBehalf: Incoming request is too long, size = " + ctx.Request.InputStream.Length);
                throw new System.ArgumentOutOfRangeException();
            }

            int totalBytesSize = (int) ctx.Request.InputStream.Length;

            int oneRecordSize = XSigSignOnBehalfRequest.GetSizeInBytes();
            if( totalBytesSize % oneRecordSize !=0)
            {
                string msg = "XSigSignOnBehalf: Data blob of invalid size is received . Total size in bytes :"+ totalBytesSize +
                    " Record size in bytes: " + oneRecordSize;
                Xom.Trace(XomAreaName.xsig, LogLevel.L_ERROR, msg);

                throw new System.ArgumentException(msg);
            }

            _recordsCount = totalBytesSize / oneRecordSize;

            Xom.Trace(XomAreaName.xsig, LogLevel.L_LOW, "XSigSignOnBehalf: " +_recordsCount + " records received");

            _requests = new XSigSignOnBehalfRequest[_recordsCount];
            _resSignatures = new XSigSignOnBehalfResponse[_recordsCount];

            BinaryReader reader = new BinaryReader(ctx.Request.InputStream);

            for (int i = 0 ; i < _recordsCount; i++)
            {
                _requests[i] = new XSigSignOnBehalfRequest();
                _requests[i]._authData = new XSigAuthData();

                _requests[i].ReadStream(ctx.Request.InputStream);
                if(_requests[i]._serviceId <= (uint) XOService.InvalidService )
                {
                    string msg = "Record no. "+i+" includes invalid serviceId: "+_requests[i]._serviceId;
                    Xom.Trace(XomAreaName.xsig, LogLevel.L_ERROR, "XSigSignOnBehalf: Request: " + _requests[i].ToString() +
                        " contains invlaid serviceId");
                    _requests = null;
                    _resSignatures = null;
                    _recordsCount = 0;
                    throw new System.ArgumentException(msg);
                }
                Xom.Trace(XomAreaName.xsig, LogLevel.L_LOW, "XSigSignOnBehalf: Request: " + _requests[i].ToString() );
            }
        }

        //-----------------------------------------------------
        // For every record received, create a signature structure
        //
        private void ComputeSignature()
        {
            _resSignatures = new XSigSignOnBehalfResponse[_recordsCount];
            for (int i = 0; i < _recordsCount; i++)
            {
                _resSignatures[i] = new XSigSignOnBehalfResponse();
                _resSignatures[i]._signature = new XSigSignature();
                _resSignatures[i]._signature._authData = new XSigAuthData();
                _resSignatures[i]._signature._serviceId = _requests[i]._serviceId;
                _resSignatures[i]._signature._timeStamp = DateTime.UtcNow.Ticks;
                _resSignatures[i]._signature._keyVersion = (short) (Config.GetIntSetting(Setting.signature_serviceKeyVersion));
                _resSignatures[i]._signature._authData._titleID = _requests[i]._authData._titleID;
                _resSignatures[i]._signature._authData._titleVersion = _requests[i]._authData._titleVersion;
                _resSignatures[i]._signature._authData._XboxID = _requests[i]._authData._XboxID;
                _resSignatures[i]._signature._authData._userID1 = _requests[i]._authData._userID1;
                _resSignatures[i]._signature._authData._userID2 = _requests[i]._authData._userID2;
                _resSignatures[i]._signature._authData._userID3 = _requests[i]._authData._userID3;
                _resSignatures[i]._signature._authData._userID4 = _requests[i]._authData._userID4;
                _resSignatures[i]._signature._reserved = new byte [XSigSignature.XONLINE_XSIG_RESERVED_SIZE];

                byte[] sigKey = XSigUtil.CreateSignatureKey(_resSignatures[i]._signature);

                HMACSHA1 hmacFinal = new HMACSHA1(sigKey);
                hmacFinal.ComputeHash(_requests[i]._digest);
                _resSignatures[i]._signature._signature = hmacFinal.Hash;
                _resSignatures[i]._hresult = HResult.S_OK;
                Xom.Trace(XomAreaName.xsig, LogLevel.L_LOW, "XSigSignOnBehalf: HRESULT = " +
                    _resSignatures[i]._hresult+ " Signature struct created " + _resSignatures[i]._signature.ToString());

            }
        }

        //-----------------------------------------------------
        // data
        private int _recordsCount;    // number of records to create a signature structure for
        private XSigSignOnBehalfRequest[]  _requests; // records to create the signature for
        private XSigSignOnBehalfResponse[] _resSignatures; // resulting array of signature structure/hresult pairs, one structure is created
        // per every record, the order of signature structures is the same as the order of incoming requests

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\XSigMgmt.cs ===
using System;
using System.ComponentModel;
using System.Security.Cryptography;

using xonline.common.mgmt;
using xonline.common.billing;
using xonline.common.config;
using xonline.common.geofence;
using xonline.common.installer;
using xonline.common.service;
using xonline.common.crypto;
using xonline.common.blacklist;

[assembly: XomIisInstallerAttribute( Interface.xsig )]
[assembly: XomIisInstallerAttribute( Interface.xsig_int )]
[assembly: ConfigAttribute(xonline.common.config.Component.xsig)]

[assembly: FrontEndAppInitialization(typeof(xonline.server.signature.XSigMgmt), "Init")]
[assembly: FrontEndAppInitialization(typeof(xonline.common.blacklist.XSigListMgr), "Init")]

namespace xonline.server.signature
{
    //-----------------------------------------------------
    // XSigSignOnBehalf class used for signing data by a server
    //
    public class XSigMgmt
    {
        static XSigMgmt()
        {
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(XSigMgmt.OnControlRequest);
        }

        // the only purpose of this function is to ensure instantiation of the class
        private static void Init()
        {
            MSCOMGeoAPIWrapper.InitControl();
            GeoFenceClient.Init();
        }

        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            switch(args.Command.ToLower())
            {
                case "help":
                    XomControlConnection.SendMessage(
                        "Signature Server help. To reload signature server keys :\r\n" +
                        "  ReloadKeys\r\n" +
                        "  MachineLoad -- wakes machine blacklist loader thread.  Waits for thread to finish before returning.\r\n" +
                        "  DigestLoad\r\n" +
                        "  TitleLoad \r\n" +
                        "  UserLoad \r\n" +
                        "  blacklistload -- wakes all blacklist loader threads.  Waits for all threads to finish before returning.\r\n" +
                        "  flushcasettings -- deletes the cached entries that correspond to previously loaded CA settings.\r\n"
                        , args.RequestId);
                    args.Handled = true;
                    break;
                case "reloadkeys":
                    XomControlConnection.SendMessage(ProcessReloadKeysRequest(args), args.RequestId);
                    args.Handled = true;
                    break;
                case "machineload":
                    XomControlConnection.SendMessage(ProcessMachineBlackListLoad(args), args.RequestId);
                    args.Handled = true;
                    break;
                case "titleload":
                    XomControlConnection.SendMessage(ProcessTitleBlackListLoad(args), args.RequestId);
                    args.Handled = true;
                    break;
                case "digestload":
                    XomControlConnection.SendMessage(ProcessDigestBlackListLoad(args), args.RequestId);
                    args.Handled = true;
                    break;
                case "userload":
                    XomControlConnection.SendMessage(ProcessUserBlackListLoad(args), args.RequestId);
                    args.Handled = true;
                    break;
                case "blacklistload":
                    XomControlConnection.SendMessage(ProcessMachineBlackListLoad(args), args.RequestId);
                    XomControlConnection.SendMessage(ProcessDigestBlackListLoad(args), args.RequestId);
                    XomControlConnection.SendMessage(ProcessTitleBlackListLoad(args), args.RequestId);
                    XomControlConnection.SendMessage(ProcessUserBlackListLoad(args), args.RequestId);
                    args.Handled = true;
                    break;
                case "flushcasettings":
                    XomControlConnection.SendMessage(ProcessFlushCASettings(args), args.RequestId);
                    args.Handled = true;
                    break;
            }
        }

        public static string ProcessReloadKeysRequest(ControlRequestEventArgs args)
        {
            CryptoReader.ReloadKeys();
            return "Signature server keys will be reloaded on the next http request\r\n" ;
        }

        public static string ProcessMachineBlackListLoad(ControlRequestEventArgs args)
        {
            XSigListMgr.MachineBlackList.ForceLoad();
            return "Signature server machine blacklist load is complete.\r\n" ;
        }

        public static string ProcessDigestBlackListLoad(ControlRequestEventArgs args)
        {
            XSigListMgr.DigestBlackList.ForceLoad();
            return "Signature server digest blacklist load is complete.\r\n" ;
        }

        public static string ProcessTitleBlackListLoad(ControlRequestEventArgs args)
        {
            XSigListMgr.TitleBlackList.ForceLoad();
            return "Signature server title blacklist load is complete.\r\n" ;
        }

        public static string ProcessUserBlackListLoad(ControlRequestEventArgs args)
        {
            XSigListMgr.UserBlackList.ForceLoad();
            return "Signature server user blacklist load is complete.\r\n" ;
        }

        private static string ProcessFlushCASettings(ControlRequestEventArgs args)
        {
            ClientCertificateGenerator.Flush();
            return "Signature server CA cache flush successful.\r\n";
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\XSigCheckRevocation.cs ===
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
// Author: slamb
//

using System;
using System.IO;
using System.Web;
using System.Security.Cryptography;
using System.Text;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;
using xonline.common.blacklist;

namespace xonline.server.signature
{
    public class XSigCheckRevocation : IHttpHandler
    {
        //-----------------------------------------------------
        // ProcessRequest (IHttpHandler)
        //
        // the main entry point for http requests.
        //
        //
        public void ProcessRequest(HttpContext ctx)
        {
            XSigCheckRevocationCounter.Counters.RequestsPerSecond.Increment();
            XSigCheckRevocationCounter.Counters.RequestsTotal.Increment();
            uint hr = HResult.S_OK;

            CheckRevocationRequest req = new CheckRevocationRequest();
            CheckRevocationResponse resp = new CheckRevocationResponse();
            string callingUserIds = "";

            try
            {
                XSigListMgr.Init();

                // Call can come from either Internet or DataCenter
                string viface = CallSource.Check(VirtualInterface.xsig, VirtualInterface.xsig_int);

                req.ReadFromRequest(ctx.Request);

                callingUserIds = SGInfo.Current.LogonUsers[0].qwUserID.ToString("x") + "," +
                                 SGInfo.Current.LogonUsers[1].qwUserID.ToString("x") + "," +
                                 SGInfo.Current.LogonUsers[2].qwUserID.ToString("x") + "," +
                                 SGInfo.Current.LogonUsers[3].qwUserID.ToString("x");

                resp.Hrs = new uint[req.Tuples.Length];

                for (int i = 0; i < req.Tuples.Length; i++)
                {
                    // check the digest blacklisting.
                    if ( XSigListMgr.DigestBlackList.IsBlackListed( req.Tuples[i].Digest ) )
                    {
                        resp.Hrs[i] = HResult.XONLINE_E_SIGNATURE_BANNED_DIGEST;
                        continue;
                    }

                    // check the machine puid permissions.
                    if ( XSigListMgr.MachineBlackList.IsBlackListed( req.Tuples[i].ConsolePuid ) )
                    {
                        resp.Hrs[i] = HResult.XONLINE_E_SIGNATURE_BANNED_XBOX;
                        continue;
                    }

                    // check the machine id permissions.
                    if ( XSigListMgr.MachineBlackList.IsBlackListed( req.Tuples[i].ConsoleId ) )
                    {
                        resp.Hrs[i] = HResult.XONLINE_E_SIGNATURE_BANNED_XBOX;
                        continue;
                    }

                    // check title id and version
                    if ( XSigListMgr.TitleBlackList.IsBlackListed( req.Tuples[i].TitleId, req.Tuples[i].TitleVersion ) )
                    {
                        resp.Hrs[i] = HResult.XONLINE_E_SIGNATURE_BANNED_TITLE;
                        continue;
                    }

                    // check the users.
                    if (XSigListMgr.UserBlackList.IsBlackListed( req.Tuples[i].UserPuid[0] ) ||
                        XSigListMgr.UserBlackList.IsBlackListed( req.Tuples[i].UserPuid[1] ) ||
                        XSigListMgr.UserBlackList.IsBlackListed( req.Tuples[i].UserPuid[2] ) ||
                        XSigListMgr.UserBlackList.IsBlackListed( req.Tuples[i].UserPuid[3] )
                        )
                    {
                        resp.Hrs[i] = HResult.XONLINE_E_SIGNATURE_BANNED_USER;
                        continue;
                    }
                }

                XRLUtil.SetXRLResponse(ctx.Response, XOService.Signature_Server, 0, HResult.S_OK, resp);
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {

                StringBuilder bldr = new StringBuilder();
                bldr.Append("CRV|" + hr.ToString("x") + "|" + req.NumContentTuples.ToString("x"));

                bldr.Append("|");

                // hresults
                for (int i = 0; i < resp.Hrs.Length; i++)
                {
                    bldr.Append(resp.Hrs[i].ToString("x"));
                    if (i < resp.Hrs.Length - 1)
                        bldr.Append(",");
                }

                bldr.Append("|");

                // from users
                bldr.Append(callingUserIds);

                bldr.Append("|");

                // title id
                for (int i = 0; i < req.Tuples.Length; i++)
                {
                    bldr.Append(req.Tuples[i].TitleId.ToString("x"));
                    if (i + 1  < req.Tuples.Length)
                        bldr.Append(",");
                }

                bldr.Append("|");

                // title ver
                for (int i = 0; i < req.Tuples.Length; i++)
                {
                    bldr.Append(req.Tuples[i].TitleVersion.ToString("x"));
                    if (i + 1  < req.Tuples.Length)
                        bldr.Append(",");
                }

                bldr.Append("|");

                // console id
                for (int i = 0; i < req.Tuples.Length; i++)
                {
                    bldr.Append(ByteConvert.ToString(req.Tuples[i].ConsoleId));
                    if (i + 1  < req.Tuples.Length)
                        bldr.Append(",");
                }

                bldr.Append("|");

                // Console Puid
                for (int i = 0; i < req.Tuples.Length; i++)
                {
                    bldr.Append(req.Tuples[i].ConsolePuid.ToString("x"));
                    if (i + 1  < req.Tuples.Length)
                        bldr.Append(",");
                }

                bldr.Append("|");

                // user puid
                for (int i = 0; i < req.Tuples.Length; i++)
                {
                    bldr.Append(req.Tuples[i].UserPuid[0].ToString("x"));
                    if (i + 1  < req.Tuples.Length)
                        bldr.Append(",");
                }

                Xom.Log(XomAreaName.xsiglog, bldr.ToString());

            }

        }


        //-----------------------------------------------------
        // IsReusable (IHttpHandler)
        //
        //      this dll doesn't hold request-specific state, so
        //      it's fine to reuse the same instance.
        //
        public bool IsReusable
        {
            get { return true; }
        }



    }
}   // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\XSigVerifySignature.cs ===
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
// Author: Natalyp
//

using System;
using System.IO;
using System.Web;
using System.Security.Cryptography;
using System.Text;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;
using xonline.common.blacklist;

namespace xonline.server.signature
{
    public class XSigVerifySignature : IHttpHandler
    {
        //-----------------------------------------------------
        // ProcessRequest (IHttpHandler)
        //
        // the main entry point for http requests.
        //
        //
        public void ProcessRequest(HttpContext ctx)
        {
            XSigVerifySignatureCounter.Counters.RequestsPerSecond.Increment();
            XSigVerifySignatureCounter.Counters.RequestsTotal.Increment();

            XSigListMgr.Init();

            // Call can come from either Internet or DataCenter
            string viface = CallSource.Check(VirtualInterface.xsig, VirtualInterface.xsig_int);

            try
            {
                ParseRequest();
            }
            catch (Exception e)
            {
                Xom.Trace(XomAreaName.xsig, LogLevel.L_ERROR, "XSigVerifySignature: exception was thrown: " + e.Message );
                XRLUtil.SetXRLResponse(ctx.Response, XOService.Signature_Server, 0, HResult.XONLINE_E_INVALID_REQUEST);

                XSigVerifySignatureResponse resp = new XSigVerifySignatureResponse();
                resp._hresult = HResult.E_FAIL;
                for( int i = 0; i < _recordsCount; i++ )
                {
                    resp.WriteStream (ctx.Response.OutputStream);
                }

                XSigVerifySignatureCounter.Counters.FailuresPerSecond.Increment();
                XSigVerifySignatureCounter.Counters.FailuresTotal.Increment();
                return;
            }

            VerifySignature();

            XRLUtil.SetXRLResponse(ctx.Response, XOService.Signature_Server, 0, HResult.S_OK);

            for( int i = 0; i < _recordsCount; i++ )
            {
                StringBuilder bldrAuthLog = new StringBuilder();

                HttpContext context = HttpContext.Current;
                if (context != null)
                {
                    if( viface == VirtualInterface.xsig )
                    {
                        SGInfo sg = SGInfo.Current;
                        if ( sg != null )
                        {
                            bldrAuthLog.Append( sg.ToXomLogString() );
                        }
                    }
                }

                if ( bldrAuthLog.ToString() == String.Empty )
                {
                    bldrAuthLog.Append( "No auth data" );
                }

                _resultArr[i].WriteStream(ctx.Response.OutputStream);
                Xom.Log(XomAreaName.xsiglog, "VER|"+ ByteConvert.ToString(_signatureArr[i]._digest) + "|"
                    + _signatureArr[i]._signature.ToString()+ "|"+bldrAuthLog.ToString()+"|"
                    + _resultArr[i]._hresult.ToString("X8"));
            }
        }

        //-----------------------------------------------------
        // IsReusable (IHttpHandler)
        //
        //      this dll doesn't hold request-specific state, so
        //      it's fine to reuse the same instance.
        //
        public bool IsReusable
        {
            get { return true; }
        }

        //-----------------------------------------------------
        // Multiple digests with corresponding signature structures
        // could be received. Every digest is followed by the corresponding
        // signature structure.
        //
        private void ParseRequest()
        {
            _recordsCount = 0;
            HttpContext ctx = HttpContext.Current;
            if (ctx.Request.InputStream.Length > System.Int32.MaxValue)
            {
                Xom.Trace(XomAreaName.xsig, LogLevel.L_ERROR, "XSigVerifySignature: Incoming request is too long, size = " + ctx.Request.InputStream.Length);
                throw new System.ArgumentOutOfRangeException();
            }

            int totalBytesSize = (int) ctx.Request.InputStream.Length;

            int oneRecordSize = XSigVerifySignatureRequest.GetSizeInBytes();
            if( totalBytesSize % oneRecordSize !=0)
            {
                string msg = "XSigVerifySignature: Data blob of invalid size is received . Total size in bytes :"+ totalBytesSize +
                    " Record size in bytes: " + oneRecordSize;
                Xom.Trace(XomAreaName.xsig, LogLevel.L_ERROR, msg);

                throw new System.ArgumentException(msg);
            }

            _recordsCount = totalBytesSize / oneRecordSize;

            Xom.Trace(XomAreaName.xsig, LogLevel.L_LOW, "XSigVerifySignature: " + _recordsCount  + " records received");

            _signatureArr = new XSigVerifySignatureRequest [_recordsCount];
            _resultArr = new XSigVerifySignatureResponse [_recordsCount];

            for (int i = 0 ; i < _recordsCount; i++)
            {
                _signatureArr[i] = new XSigVerifySignatureRequest();
                _signatureArr[i]._signature = new XSigSignature();
                _signatureArr[i].ReadStream(ctx.Request.InputStream);

                Xom.Trace(XomAreaName.xsig, LogLevel.L_LOW, "XSigVerifySignature: Request : Digest: " + ByteConvert.ToString(_signatureArr[i]._digest) + " with signature data: " + _signatureArr[i]._signature.ToString());

                // set to S_OK as a default.
                _resultArr[i] = new XSigVerifySignatureResponse();
                _resultArr[i]._hresult = 0;

             }
        }

        //-----------------------------------------------------
        // For every digest and signature structure calculate the final signature
        // and compare with one presented in the signature structure
        //
        private void VerifySignature()
        {
            int nFailuresCount = 0;

            for (int i = 0; i < _signatureArr.Length; i ++)
            {
                if (_signatureArr[i]._signature._signatureVersion != XSigSignature.XONLINE_XSIG_SIGNATURE_VERSION)
                {
                    _resultArr[i]._hresult = HResult.XONLINE_E_SIGNATURE_VER_UNKNOWN_SIGNATURE_VER;
                    Xom.NtEvent(XEvent.Id.SIGNATURE_CONFIG_2, "XSigVerifySignature: Invalid signature version received from client :"
                        +_signatureArr[i]._signature.ToString() + " probably server is misconfigured"
                    );

                    Xom.Trace(XomAreaName.xsig, LogLevel.L_ERROR, "XSigVerifySignature: Invalid signature version : " + _signatureArr[i]._signature._signatureVersion +
                        " found " + _signatureArr[i]._signature.ToString());

                    nFailuresCount++;
                    continue;
                }

                // check the digest blacklisting.
                if ( XSigListMgr.DigestBlackList.IsBlackListed( _signatureArr[i]._digest ) )
                {
                    _resultArr[i]._hresult = HResult.XONLINE_E_SIGNATURE_BANNED_DIGEST;
                    Xom.Trace(XomAreaName.xsig, LogLevel.L_ERROR, "XSigVerifySignature: XONLINE_E_SIGNATURE_BANNED_DIGEST starting with: "
                        + _signatureArr[i]._digest[0].ToString("X") + _signatureArr[i]._digest[1].ToString("X")
                        + _signatureArr[i]._digest[2].ToString("X") + _signatureArr[i]._digest[3].ToString("X") +
                        " found in " + _signatureArr[i]._signature.ToString());
                    nFailuresCount++;
                    continue;
                }

                // check the machine permissions.
                if ( XSigListMgr.MachineBlackList.IsBlackListed( _signatureArr[i]._signature._authData._XboxID ) )
                {
                    _resultArr[i]._hresult = HResult.XONLINE_E_SIGNATURE_BANNED_XBOX;
                    Xom.Trace(XomAreaName.xsig, LogLevel.L_ERROR, "XSigVerifySignature: XONLINE_E_SIGNATURE_BANNED_XBOX found in " + _signatureArr[i]._signature.ToString());
                    nFailuresCount++;
                    continue;
                }

                // check title id and version
                if ( XSigListMgr.TitleBlackList.IsBlackListed( _signatureArr[i]._signature._authData._titleID, _signatureArr[i]._signature._authData._titleVersion ) )
                {
                    _resultArr[i]._hresult = HResult.XONLINE_E_SIGNATURE_BANNED_TITLE;
                    Xom.Trace(XomAreaName.xsig, LogLevel.L_ERROR, "XSigVerifySignature: XONLINE_E_SIGNATURE_BANNED_TITLE found in " + _signatureArr[i]._signature.ToString());
                    nFailuresCount++;
                    continue;
                }

                // check the users.
                if (XSigListMgr.UserBlackList.IsBlackListed( _signatureArr[i]._signature._authData._userID1 ) ||
                    XSigListMgr.UserBlackList.IsBlackListed( _signatureArr[i]._signature._authData._userID2 ) ||
                    XSigListMgr.UserBlackList.IsBlackListed( _signatureArr[i]._signature._authData._userID3 ) ||
                    XSigListMgr.UserBlackList.IsBlackListed( _signatureArr[i]._signature._authData._userID4 )
                    )
                {
                    _resultArr[i]._hresult = HResult.XONLINE_E_SIGNATURE_BANNED_USER;
                    Xom.Trace(XomAreaName.xsig, LogLevel.L_ERROR, "XSigVerifySignature: XONLINE_E_SIGNATURE_BANNED_USER found in " + _signatureArr[i].ToString());
                    nFailuresCount++;
                    continue;
                }

                byte[] sigKey = null;
                try
                {
                    sigKey = XSigUtil.CreateSignatureKey(_signatureArr[i]._signature);
                }
                catch (System.IndexOutOfRangeException e)
                {
                    _resultArr[i]._hresult = HResult.XONLINE_E_SIGNATURE_VER_UNKNOWN_KEY_VER;
                    Xom.NtEvent(XEvent.Id.SIGNATURE_CONFIG_3, e, "XSigVerifySignature: KeyVersion sent :" + _signatureArr[i]._signature._keyVersion +
                        " by Xbox: " + _signatureArr[i]._signature.ToString());

                    nFailuresCount++;
                    continue;
                }

                // that should never happen
                catch (Exception e)
                {
                    Xom.NtEvent(XEvent.Id.SIGNATURE_CODE_0, e, "XSigVerifySignature: Exception thrown by client: " + _signatureArr[i]._signature.ToString());
                    _resultArr[i]._hresult = HResult.XONLINE_E_INTERNAL_ERROR;

                    nFailuresCount++;
                    continue;
                }

                HMACSHA1 hmacFinal = new HMACSHA1(sigKey);
                hmacFinal.ComputeHash(_signatureArr[i]._digest);


                if (0 == ByteConvert.ToString(hmacFinal.Hash).CompareTo (ByteConvert.ToString(_signatureArr[i]._signature._signature)))
                {
                    _resultArr[i]._hresult = HResult.S_OK;
                    Xom.Trace(XomAreaName.xsig, LogLevel.L_LOW, "XSigVerifySignature: Digest: " + ByteConvert.ToString(_signatureArr[i]._digest) +
                        " with signature data: " + _signatureArr[i]._signature.ToString() + " has passed verification successfully");
                }
                else
                {
                    _resultArr[i]._hresult = HResult.XONLINE_E_SIGNATURE_VER_INVALID_SIGNATURE;

                    Xom.NtEvent(XEvent.Id.SIGNATURE_HACK_0, "XSigVerifySignature: Invalid signature data received from client :"
                        +_signatureArr[i]._signature.ToString());
                    Xom.Trace(XomAreaName.xsig, LogLevel.L_ERROR, "XSigVerifySignature: Verification for Digest: " + ByteConvert.ToString(_signatureArr[i]._digest) +
                        " with signature data: " + _signatureArr[i]._signature.ToString() + " has failed");

                    nFailuresCount++;
                    XSigVerifySignatureCounter.Counters.InvalidSignaturesTotal.Increment();
                    continue;
                }

            }

            XSigVerifySignatureCounter.Counters.FailuresPerSecond.IncrementBy((long)nFailuresCount);
            XSigVerifySignatureCounter.Counters.FailuresTotal.IncrementBy((long)nFailuresCount);

        }



        //-----------------------------------------------------
        // data
        private int                _recordsCount; // number of digest/signature structure pairs in the current http request
        private  XSigVerifySignatureRequest [] _signatureArr;  // array of all signature structures/digest structures
        private  XSigVerifySignatureResponse[] _resultArr;     // result of signature calculation for every digest/signature pair
    }
}   // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\fd\XSigWeb.cs ===
//
// XSigWeb.cs
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//

using System;
using System.IO;
using System.Web;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Data;
using System.Data.SqlClient;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;
using xonline.common.config;
using xonline.common.sql.sqlclient;
using xonline.common.blacklist;

[assembly: XomAreaDefinition(XomAreaName.log)]

namespace xonline.server.signature
{
    [WebService(Namespace = "urn:schemas-xbox-com:xsigweb-data")]
    public class XSigWeb
    {
        [WebMethod]
        public string TestConnection(string inputMessage)
        {
            return inputMessage;
        }


        // HttpPost limits the types of data we can transmit, so this version of the API 
        // only uses certain pol types.
        //
        // Since we can't use complex data-types, the input must match and the output must 
        // match (but the input and output don't necessarily match. So:
        //
        // miids[i] must correspond to oids[i] and clientInfo[i]
        //
        // However, miids[i] and middsReturned[i] don't necessarily correspond.
        //
        [WebMethod]
        public MediaLicense[] AcquireMediaLicenses(
            string[] miids,             // Media instance ids. Guids in format "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx". 
            string[] oids,              // Offer ids. Guids in format "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx".
            ulong xuid,                 // User puid.
            string clientInfo           // Client info (from WMRM).
        )
        {
            try
            {
                // internal - only called from livecache
                CallSource.Check(VirtualInterface.xsig, VirtualInterface.xsig_int);

                SGVsAAHelper.VerifyUser(xuid);
                MediaInstanceIdOfferIdPair[] idPairs = JoinMediaIntanceIdOfferIdPairs(miids, oids);

                return LicenseImpl.GenericLicenseApi<AcquireLicenseApiResponseGenerator, MediaLicense>(idPairs, xuid, clientInfo);
            }
            catch (Exception e)
            {
                FrontEndApp.LogException(e);
                throw;
            }
        }


        [WebMethod]
        public Acknowledgement[] AcknowledgeLicensesDelivery(
            string[] miids,             // Media instance ids. Guids in format "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx". 
            string[] oids,              // Offer ids. Guids in format "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx".
            ulong xuid                  // User puid.
        )
        {
            try
            {
                // internal - only called from livecache
                CallSource.Check(VirtualInterface.xsig, VirtualInterface.xsig_int);

                SGVsAAHelper.VerifyUser(xuid);
                MediaInstanceIdOfferIdPair[] idPairs = JoinMediaIntanceIdOfferIdPairs(miids, oids);

                return LicenseImpl.GenericLicenseApi<AcknowledgeLicenseApiResponseGenerator, Acknowledgement>(idPairs, xuid, null);
            }
            catch (Exception e)
            {
                FrontEndApp.LogException(e);
                throw;
            }
        }


        [WebMethod]
        public Availability[] CheckLicensesAvailability(
            string[] miids,             // Media instance ids. Guids in format "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx". 
            string[] oids,              // Offer ids. Guids in format "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx".
            ulong xuid                  // User puid.
        )
        {
            try
            {
                // internal - only called from livecache
                CallSource.Check(VirtualInterface.xsig, VirtualInterface.xsig_int);
                SGVsAAHelper.VerifyUser(xuid);

                MediaInstanceIdOfferIdPair[] idPairs = JoinMediaIntanceIdOfferIdPairs(miids, oids);
                return LicenseImpl.GenericLicenseApi<AvailabilityLicenseApiResponseGenerator, Availability>(idPairs, xuid, null);
            }
            catch (Exception e)
            {
                FrontEndApp.LogException(e);
                throw;
            }
        }

        private static MediaInstanceIdOfferIdPair[] JoinMediaIntanceIdOfferIdPairs(string[] miids, string[] oids)
        {
            if (miids == null)
            {
                throw new ArgumentNullException("miids", "miids must not be null");
            }
            if (oids == null)
            {
                throw new ArgumentNullException("oids", "oids must not be null");
            }
            if (miids.Length != oids.Length)
            {
                throw new ArgumentException("miids and oids must be the same length--their elements must correspond to each other.");
            }

            MediaInstanceIdOfferIdPair[] idPairs = new MediaInstanceIdOfferIdPair[miids.Length];

            for (int idx = 0; idx < idPairs.Length; ++idx)
            {
                idPairs[idx] = new MediaInstanceIdOfferIdPair();
                idPairs[idx].miid = new Guid(miids[idx]);
                idPairs[idx].oid = new Guid(oids[idx]);
            }

            return idPairs;
        }

        /*
        [WebMethod]
        public LicenseCount CountLicenses(UInt64 xuid)
        {
            uint hr = HResult.S_OK;
            LicenseCount licenseCount = new LicenseCount();
            try
            {
                licenseCount = LicenseTransferUtil.GetLicenseCountForUser(xuid);
                return licenseCount;
            }
            catch (Exception e)
            {
                hr = XRLException.ToHResult(e);
                if (e is XRLException)
                {
                    throw;
                }
                else
                {
                    // TODO: Correct event.
                    throw new XRLException(XRLException.ToHResult(e), XEvent.Id.LICENSE_GENERAL, "CountLicenses failed.", e);
                }
            }
            finally
            {
                string logLine = String.Join("|", new string[]
                    {
                        "COUNT_LICENSES",
                        xuid.ToString("X16"),
                        licenseCount.gameLicenseCount.ToString(),
                        licenseCount.videoLicenseCount.ToString(),
                        licenseCount.currentConsoleIds.Length.ToString(),
                        hr.ToString("X8"),
                    });
                Xom.Log(XomAreaName.xsiglog, logLine);
            }
        }

        [WebMethod]
        public LicenseTransferState GetCurrentLicenseTransferState(UInt64 xuid)
        {
            uint hr = HResult.S_OK;
            LicenseTransferState state = new LicenseTransferState();
            try
            {
                state = LicenseTransferStateUtil.GetLicenseTransferStateForUser(xuid);
                return state;
            }
            catch (Exception e)
            {
                hr = XRLException.ToHResult(e);
                if (e is XRLException)
                {
                    throw;
                }
                else
                {
                    // TODO: Correct event.
                    throw new XRLException(XRLException.ToHResult(e), XEvent.Id.LICENSE_GENERAL, "GetCurrentLicenseTransferState failed.", e);
                }
            }
            finally
            {
                string logLine = String.Join("|", new string[]
                    {
                        "GET_LICENSE_TRANSFER_STATE",
                        xuid.ToString("X16"),
                        state.destinationConsoleId,
                        state.currentStatus.ToString(),
                        state.lastChanged.ToString(),
                        hr.ToString("X8"),
                    });
                Xom.Log(XomAreaName.xsiglog, logLine);
            }
        }

        [WebMethod]
        public void BeginLicenseTransfer(UInt64 xuid)
        {
        }

        [WebMethod]
        public void CompleteLicenseTransfer(UInt64 xuid, String consoleId)
        {
        }
         */

        [WebMethod]
        public void SetBlacklistDigestState(byte[] digest, byte status, byte deliveryType, string reason)
        {
            uint hr = HResult.S_OK;
            try
            {
                if (VirtualInterface.None.Equals(CallSource.Check(VirtualInterface.xsig_int)))
                {
                    throw new XRLException(HResult.E_ACCESSDENIED, XEvent.Id.XSIG_BLACKLIST_DIGEST_FAILURE, 
                    "XSigWeb.SetBlacklistDigestState is an internal-only interface but is being called externally.");
                }

                CallBlacklistDigestSproc(digest, ConvertToEnum<DigestRevocationStatus>(status), ConvertToEnum<DigestRevocationDeliveryType>(deliveryType), reason);
            }
            catch (Exception e)
            {
                hr = XRLException.ToHResult(e, HResult.XONLINE_E_SIGNATURE_ERROR);
                if (e is XRLException)
                {
                    throw;
                }
                else
                {
                    throw new XRLException(hr, XEvent.Id.XSIG_BLACKLIST_DIGEST_FAILURE,
                        String.Format("BlacklistDigest failed with hr = {0}", hr), e);
                }
            }
            finally
            {
                string logLine = String.Join("|", new string[]
                    {
                    "SIG_BLACKLIST",
                    hr.ToString("X"),
                    status.ToString(),
                    deliveryType.ToString(),
                    SmartTrimFront(reason, 10),
                    });
                Xom.Log(XomAreaName.xsiglog, logLine);
                Xom.Log(XomAreaName.Reporting, logLine);
            }
        }

        private static TEnum ConvertToEnum<TEnum>(byte value)
        {
            if (!Enum.IsDefined(typeof(TEnum), value))
            {
                throw new ArgumentException(String.Format("{0} is not a member of enum {1}.", value, typeof(TEnum)), "value");
            }
            return (TEnum) Enum.Parse(typeof(TEnum), value.ToString());
        }

        private static string SmartTrimFront(string s, int length)
        {
            return s.Length <= length ? s : s.Substring(0, length);
        }

        private void CallBlacklistDigestSproc(byte[] digest, DigestRevocationStatus status, DigestRevocationDeliveryType deliveryType, string reason)
        {
            using (SqlClient sqlClient = new SqlClient(Interface.npdb))
            {
                sqlClient.StoredProc = "dbo.p_xcbt_blacklist_digest";

                sqlClient.AddParameter("@bin_digest", digest);
                sqlClient.AddParameter("@ti_is_blacklisted", (byte) status);
                sqlClient.AddParameter("@ti_revocation_delivery_type", (byte) deliveryType);
                sqlClient.AddParameter("@vc_revocation_reason", reason);

                sqlClient.AddParameter(ParameterDirection.ReturnValue, "@RETVAL", 0);

                sqlClient.ExecuteNonQuery();

                if (sqlClient.GetIntParameter("@RETVAL") != 0)
                {
                    throw new XRLException(HResult.XONLINE_E_INTERNAL_ERROR, XEvent.Id.XSIG_BLACKLIST_DIGEST_FAILURE,
                        "Error blacklisting digest");
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\dll\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\dll\CreateBinaryDeviceCertificate.cpp ===
#include "stdafx.h"


/*****************************************************************************
** Function:    _CreateBinaryDeviceCertificate
**
** Synopsis:    Gets the Device's binary certificate chain, creating the leaf node.
**
** Arguments:   [pbSerialNum]       : A pointer a buffer that contains the serial number of the cert
**              [cbSerialNum]       : Serial number size (must be DRM_BCERT_CLIENT_ID_LENGTH)
**              [pSignKey]          : The public signing key of the cert
**              [pEncrypKey]        : The public encryption key of the cert
**              [pbCert]            : A pointer to a bcert chain buffer to fill in
**              [pbCert]            : The size of the bcert chain buffer; updated
**              [pCryptoContext]            : Pointer to DRM_CRYPTO_CONTEXT used for temporary data in crypto code.
**
** Returns:     DRM_SUCCESS                            - on success
**              DRM_E_INVALIDDEVICECERTIFICATETEMPLATE - group cert chain too big
**              DRM_E_DEVCERTREADERROR                 - failure to get the dev cert chain
**              DRM_E_INVALIDARG                       - if any required pointer parameter is NULL
**              or other return code from a function called within
**
** Notes:       None.
**
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL _CreateBinaryDeviceCertificate(
    PRIVKEY_P256 * GCPrivKey,
    DRM_DWORD cbGCPrivKey,
    DRM_BYTE * pbModelCert,
    DRM_DWORD cbModelCert,
    DRM_BYTE *pbSerialNum,
    DRM_DWORD cbSerialNum,
    PUBKEY_P256 *pSignKey,
    PUBKEY_P256 *pEncryptKey,
    DRM_BYTE *pbCert,
    DRM_DWORD *pcbCert
    )
{
    DRM_RESULT                     dr                = DRM_SUCCESS;
    DRM_DWORD                      cbDevCert         = 0;
    PUBKEY_P256                    IssuerKey         = {0};
    DRM_BCERT_CERT_ID              CertificateID     = {0};
    DRM_BCERT_CLIENT_ID            SerialNum         = {0};
    DRM_BCERT_BUILDER_DATA         BuilderData       = {0};
    DRMFILETIME                    ftUnlimited       = {0};
    DRM_DWORD                      rgdwFeatureSet[2] = {0};
    DRM_BCERT_BUILDER_CERTKEY      oCertKeys[DRM_BINARY_DEVICE_CERT_MAX_KEYUSAGES] = {0};
    DRM_DWORD                      rgdwKeyUsages[]   = { DRM_BCERT_KEYUSAGE_SIGN, DRM_BCERT_KEYUSAGE_ENCRYPT_KEY };
    DRM_BCERT_VERIFICATIONCONTEXT  oVerificationContext = {0};
    DRM_CRYPTO_CONTEXT             cryptoContext = {0};
    DRM_BYTE                      *parentChain       = NULL;
    DRM_BYTE                       devCert[MAX_DEVICE_CERT_SIZE];

    /*
    ** Initialize verification context: full verification.
    ** We only accept certs that don't expire (i.e. expire at 0xFFFFFFFF).
    ** Device cert key must have Sign and Encrypt key usages
    */
    CREATE_FILE_TIME( MAX_UNSIGNED_TYPE( DRM_DWORD ), ftUnlimited );

    ChkDR( DRM_BCert_InitVerificationContext( &ftUnlimited,
        (const PUBKEY_P256*) g_rgbMSPlayReadyRootIssuerPubKey,
        DRM_BCERT_CERTTYPE_DEVICE,
        &cryptoContext,
        TRUE,
        FALSE,
        rgdwKeyUsages,
        NO_OF(rgdwKeyUsages),
        FALSE,
        NULL, /* Cert caching parameters NULL as we generally don't verify signatures on device certs so optimization not needed here */
        NULL,
        NULL,
        &oVerificationContext ) );


    /*
    ** Load the group/model certificate (a.k.a. the parent chain) into the bottom
    ** half of the buffer provided.
    */
    parentChain = pbModelCert;
    cbDevCert = cbModelCert;

    if( dr == DRM_E_BUFFERTOOSMALL )
    {
        ChkDR( DRM_E_INVALIDDEVICECERTIFICATETEMPLATE );
    }
    else if( DRM_FAILED( dr ) )
    {
        ChkDR( DRM_E_DEVCERTREADERROR );
    }

    /*
    ** Generate a unique Identifier for this certificate.
    ** Generate an ECC P256 key pairs.
    */
    ChkDR( Oem_Random_GetBytes( NULL, CertificateID.rgb, DRM_BCERT_CERT_ID_LENGTH ) );
    MEMCPY(oCertKeys[0].KeyValue.rgb, (DRM_BYTE *)pSignKey, SIZEOF (PUBKEY_P256));
    MEMCPY(oCertKeys[1].KeyValue.rgb, (DRM_BYTE *)pEncryptKey, SIZEOF (PUBKEY_P256));

    /*
    ** Get the device's serial number.
    ** Get the "issuer key" (the group/model cert's public key).
    ** Get the private key with which to sign this certificate (the group/model cert's private key).
    */
    MEMCPY (SerialNum.rgb, pbSerialNum, cbSerialNum);
    ChkDR( DRM_BCert_GetPublicKey( parentChain, cbDevCert, 0, &IssuerKey ) );

    /*
    ** Fill-in the input data structure used by the binary certificate builder
    */
    BCert_SetDefaultBuilderData( &CertificateID,
        DRM_BCERT_CERTTYPE_DEVICE,
        GCPrivKey,
        &IssuerKey,
        &BuilderData );

    oCertKeys[0].dwNumKeyUsages = 1;
    oCertKeys[0].pKeyUsageSet = (DRM_DWORD*)&rgdwKeyUsages[0];
    oCertKeys[1].dwNumKeyUsages = 1;
    oCertKeys[1].pKeyUsageSet = (DRM_DWORD*)&rgdwKeyUsages[1];
    BCert_SetKeyInfoBuilderData( (DRM_BCERT_BUILDER_CERTKEY*)oCertKeys, 2, &BuilderData );

    BCert_SetDeviceBuilderData( &SerialNum, &BuilderData );

    /*
    ** Set the feature flags in the binary cert builder
    */
    BuilderData.dwNumFeatureEntries = 0;
    BuilderData.prgdwFeatureSet = rgdwFeatureSet;

    rgdwFeatureSet[BuilderData.dwNumFeatureEntries++] = DRM_BCERT_FEATURE_ANTIROLLBACK_CLOCK;

    /*
    ** Use the security level from the group/model certificate in this leaf certificate
    */
    DRM_BCert_GetLeafSecurityLevel( BuilderData.dwSecurityLevel, parentChain );

    cbDevCert = MAX_DEVICE_CERT_SIZE;
    ChkDR( BCert_AddCert( parentChain, devCert, &cbDevCert, &BuilderData, &cryptoContext ) );

    /*
    ** Verify the newly built device certificate chain, then save it on the device.
    */
    ChkDR( DRM_BCert_ParseCertificateChain( devCert, cbDevCert, &oVerificationContext ) );

    /*
    ** Verify that we have enough space in the output buffer.
    */
    if (*pcbCert < cbDevCert)
    {
        ChkDR(DRM_E_BUFFERTOOSMALL)
    }

    ZeroMemory(pbCert, *pcbCert);
    MEMCPY (pbCert, devCert, cbDevCert);
    *pcbCert = cbDevCert;

ErrorExit:
    OEM_SECURE_ZERO_MEMORY( &GCPrivKey,   SIZEOF( PRIVKEY_P256 ) );

    return dr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\dll\stdafx.h ===
#pragma once

#include <windows.h>
#include <drmcommon.h>
#include "drmbcertbuilder.h"
#include "drmbcertparser.h"
#include "drmcontextsizes.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\dll\stdafx.cpp ===
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\dll\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_playreadydevicecert_none_12.4.56.0_none_25eaae128109d975
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_playreadydevicecert_no-public-key_12.4.56.0_x-ww_175eefff
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=playreadydevicecert
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_playreadydevicecert_no-public-key_12.4.56.0_x-ww_175eefff
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_playreadydevicecert_no-public-key_12.4.56.0_x-ww_175eefff.manifest
XP_MANIFEST_PATH=manifests\x86_playreadydevicecert_no-public-key_12.4.56.0_x-ww_175eefff.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_playreadydevicecert_no-public-key_12.4.56.0_x-ww_175eefff.cat
XP_CATALOG_PATH=manifests\x86_playreadydevicecert_no-public-key_12.4.56.0_x-ww_175eefff.cat
XP_PAYLOAD_PATH=x86_playreadydevicecert_no-public-key_12.4.56.0_x-ww_175eefff
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=playreadydevicecert,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\dll\PlayReadyDeviceCertDll.cpp ===
#include "stdafx.h"

DRM_API DRM_RESULT DRM_CALL _CreateBinaryDeviceCertificate(
    PRIVKEY_P256 * GCPrivKey,
    DRM_DWORD cbGCPrivKey,
    DRM_BYTE *pbModelCert,
    DRM_DWORD cbModelCert,
    DRM_BYTE *pbSerialNum,
    DRM_DWORD cbSerialNum,
    PUBKEY_P256 *pSignKey,
    PUBKEY_P256 *pEncryptKey,
    DRM_BYTE *pbCert,
    DRM_DWORD *pcbCert
    );

HRESULT CreateDeviceCertificate(BYTE const * const pbModelPrivateKey, DWORD const cbModelPrivateKey, BYTE const * const pbModelCert, DWORD const cbModelCert, BYTE const * const pbSerialNum, DWORD const cbSerialNum, BYTE const * const pbSignKey, BYTE const * const pbEncryptKey, BYTE * const pbCert, DWORD * const pcbCert)
{
    PRIVKEY_P256 modelPrivateKey = {0};
    // For some reason the APIs really want a PRIVKEY_P256, not matter how big the private key actually is. The 256 should be sufficient, but just
    // in case we're going to fall here if it isn't.
    if (_countof(modelPrivateKey.m_rgbPrivkey) > cbModelPrivateKey)
    {
        // TODO: Better error? How will we know what's going on?
        return E_INVALIDARG;
    }
    memcpy_s(modelPrivateKey.m_rgbPrivkey, _countof(modelPrivateKey.m_rgbPrivkey), pbModelPrivateKey, cbModelPrivateKey);
    DRM_DWORD cbdrmModelPrivateKey= cbModelPrivateKey;
    DRM_BYTE * pdrmbModelCert = const_cast<DRM_BYTE *>(pbModelCert);
    DRM_DWORD cbdrmModelCert = cbModelCert;
    DRM_BYTE * pdrmbSerialNum = const_cast<DRM_BYTE *>(pbSerialNum);
    DRM_DWORD cbdrmSerialNum = cbSerialNum;
    PUBKEY_P256 signKey = {0};
    memcpy_s(signKey.m_rgbPubkey, _countof(signKey.m_rgbPubkey), pbSignKey, _countof(signKey.m_rgbPubkey));
    PUBKEY_P256 encryptKey = {0};
    memcpy_s(encryptKey.m_rgbPubkey, _countof(encryptKey.m_rgbPubkey), pbEncryptKey, _countof(encryptKey.m_rgbPubkey));
    DRM_BYTE * pbdrmCert =pbCert;
    DRM_DWORD * pcbdrmCert = const_cast<DRM_DWORD *>(pcbCert);

    DRM_RESULT drm = _CreateBinaryDeviceCertificate(&modelPrivateKey, cbdrmModelPrivateKey, pdrmbModelCert, cbdrmModelCert, pdrmbSerialNum, cbdrmSerialNum, &signKey, &encryptKey, pbdrmCert, pcbdrmCert);

    return drm;
}

// ---------------------------------------------------------------------------
// VerifyDeviceCertificateChain
//
// Description:
//  Tests the Playready device certificate, verifying it has a valid certificate
//  chain.
//  
//
// Return:
//  HRESULT - Actually a DRM_RESULT contained in an HRESULT.
//            The result of verifying the certificate chain.  Whether it was 
//            successful or not can be verified using DRM_SUCCEEDED(DRM_RESULT);
// ---------------------------------------------------------------------------
HRESULT VerifyDeviceCertChain(IN const BYTE *pabDeviceCertificate, IN const DWORD cbDeviceCertificate)
{
    DRM_CRYPTO_CONTEXT context;

    DRM_RESULT dr;
    DRM_DWORD rgdwKeyUsages[DRM_BINARY_DEVICE_CERT_MAX_KEYUSAGES]   = { DRM_BCERT_KEYUSAGE_SIGN, DRM_BCERT_KEYUSAGE_ENCRYPT_KEY };
    DRM_BCERT_VERIFICATIONCONTEXT           oVerificationContext    = {0};
    DRMFILETIME                             ftUnlimited             = {0};

    //
    // Init verification context
    //
    CREATE_FILE_TIME (MAX_UNSIGNED_TYPE( DRM_DWORD ), ftUnlimited);

    dr = DRM_BCert_InitVerificationContext ( &ftUnlimited,
        (const PUBKEY_P256*) g_rgbMSPlayReadyRootIssuerPubKey, DRM_BCERT_CERTTYPE_DEVICE,
        &context, TRUE, FALSE, rgdwKeyUsages, NO_OF(rgdwKeyUsages), FALSE, NULL, NULL, NULL,
        &oVerificationContext);


    //A #define identifier in Janus drmerr.h
    //If dr is a DRM_RESULT < 0, goto ErrorExit
    //Else if it's a DRM_RESULT > 0, do nothing.
    ChkDR(dr);

    //
    // Verify the certificate chain.
    //
    dr = DRM_BCert_ParseCertificateChain ((DRM_BYTE *)pabDeviceCertificate, (DRM_DWORD)cbDeviceCertificate, &oVerificationContext);

ErrorExit:

    return dr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\dll\MakeTestPRCert.cpp ===
#include "stdafx.h"


static BYTE s_PRGroupCert [] =
{
    0x43,0x48,0x41,0x49,0x00,0x00,0x00,0x01,0x00,0x00,0x07,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x43,0x45,
    0x52,0x54,0x00,0x00,0x00,0x01,0x00,0x00,0x02,0x88,0x00,0x00,0x01,0xf8,0x00,0x01,0x00,0x01,0x00,0x00,0x00,0x58,
    0x6e,0x53,0x05,0x7a,0xdf,0xd7,0xcb,0x71,0xf1,0x65,0x47,0xbc,0xe6,0x6d,0xc6,0x19,0x00,0x00,0x00,0x96,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x04,0x15,0x4e,0x53,0xe2,0xdb,0x1f,0xee,0xa3,0xd7,0xf7,0x3e,0xd4,0xc5,0xd8,0xe9,0x4f,
    0x34,0xc1,0x90,0x2e,0xe0,0x35,0xeb,0x85,0x74,0xd3,0xeb,0x74,0x9e,0x53,0xc4,0xd1,0xff,0xff,0xff,0xff,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x05,0x00,0x00,0x00,0x10,
    0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x04,0x00,0x01,0x00,0x06,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x01,0x00,0x01,
    0x02,0x00,0x00,0x00,0x00,0x00,0x20,0xd2,0xf0,0x7c,0xd7,0xf7,0x4a,0x60,0x59,0x4d,0x4a,0x3d,0xa3,0xda,0x31,0x26,
    0x6b,0x66,0x31,0xfc,0xa3,0xfc,0xe4,0xb8,0x12,0x5c,0x9b,0xd7,0x03,0x6a,0x19,0xcf,0xcf,0x16,0xce,0x39,0x2c,0xc5,
    0x64,0xcf,0xc3,0x85,0xda,0x9c,0x09,0x20,0xe7,0xb7,0x52,0xd5,0x18,0x14,0xe9,0x23,0x9b,0xd8,0x25,0xc4,0xb9,0x34,
    0x12,0x1b,0xf9,0xb1,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x07,0x00,0x00,
    0x01,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x43,0x6f,0x6e,0x74,0x6f,0x73,0x6f,0x00,0x00,0x00,0x00,0x80,
    0x43,0x6f,0x6f,0x6c,0x20,0x44,0x65,0x76,0x69,0x63,0x65,0x20,0x4e,0x61,0x6d,0x65,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
    0x41,0x42,0x43,0x2d,0x58,0x59,0x5a,0x2d,0x31,0x32,0x33,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x08,
    0x00,0x00,0x00,0x90,0x00,0x01,0x00,0x40,0x0f,0x8c,0x15,0x98,0x6e,0xbb,0xd0,0xf2,0xd3,0x30,0xe6,0x9f,0x66,0xc9,
    0x02,0x47,0x3c,0x81,0xb6,0xe7,0xf4,0x81,0x00,0x21,0x32,0x73,0x2c,0x76,0xb2,0x57,0x94,0x80,0x47,0x26,0x4a,0x73,
    0x0f,0x44,0xb9,0xc1,0x0c,0x04,0xf8,0xce,0x50,0x7b,0x2c,0x05,0xf8,0x5c,0x42,0x0b,0x52,0x96,0x45,0x58,0x02,0x95,
    0xf1,0x46,0x6e,0x6b,0x06,0xdc,0x00,0x00,0x02,0x00,0x80,0x15,0x00,0x66,0x46,0x2f,0xdb,0x56,0x93,0x3b,0x62,0x6c,
    0x74,0x26,0xc0,0xb4,0xf4,0x21,0x14,0x56,0xa1,0x03,0x6a,0xad,0xf5,0x9a,0x80,0xe4,0x1b,0x4f,0x73,0x64,0x6d,0x91,
    0x04,0x3e,0x20,0x5b,0xf7,0x01,0x4d,0xf3,0x60,0x7c,0x6c,0x83,0xfd,0x6e,0x5e,0x08,0x43,0x17,0x5e,0x59,0x18,0xe6,
    0x15,0x84,0xb5,0x30,0xdf,0xbc,0x85,0xa9,0x43,0x45,0x52,0x54,0x00,0x00,0x00,0x01,0x00,0x00,0x01,0x8c,0x00,0x00,
    0x00,0xfc,0x00,0x01,0x00,0x01,0x00,0x00,0x00,0x58,0xef,0xd7,0x82,0xa7,0x39,0x15,0x6a,0xbc,0xbf,0xfa,0xa3,0x8a,
    0xe7,0xe6,0x25,0x12,0x00,0x00,0x00,0x96,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0xc1,0xd5,0x4c,0xa8,0x69,0x54,
    0x19,0xbe,0x12,0xf3,0xe0,0x0f,0x66,0xff,0x84,0xf4,0x05,0x48,0xc6,0x17,0xaa,0xa9,0x2d,0x83,0x20,0x58,0x2e,0xf4,
    0x92,0x6c,0xb5,0x40,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x01,0x00,0x05,0x00,0x00,0x00,0x0c,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x06,0x00,0x00,0x00,0x60,
    0x00,0x00,0x00,0x01,0x00,0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x80,0x15,0x00,0x66,0x46,0x2f,0xdb,0x56,0x93,0x3b,
    0x62,0x6c,0x74,0x26,0xc0,0xb4,0xf4,0x21,0x14,0x56,0xa1,0x03,0x6a,0xad,0xf5,0x9a,0x80,0xe4,0x1b,0x4f,0x73,0x64,
    0x6d,0x91,0x04,0x3e,0x20,0x5b,0xf7,0x01,0x4d,0xf3,0x60,0x7c,0x6c,0x83,0xfd,0x6e,0x5e,0x08,0x43,0x17,0x5e,0x59,
    0x18,0xe6,0x15,0x84,0xb5,0x30,0xdf,0xbc,0x85,0xa9,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x06,
    0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x43,0x6f,0x6e,0x74,0x6f,0x73,
    0x6f,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x08,
    0x00,0x00,0x00,0x90,0x00,0x01,0x00,0x40,0xb9,0xc7,0xbd,0x64,0x77,0xbc,0x62,0xcb,0x22,0x9d,0x62,0xf1,0x5e,0xad,
    0x65,0x06,0x57,0x18,0x9d,0xac,0x47,0xf7,0x6c,0xa3,0x35,0xb4,0x86,0x8f,0x97,0x0f,0xf7,0xa2,0x20,0x3a,0x0b,0x71,
    0xca,0x33,0x7f,0x07,0x3c,0x66,0xb1,0xb4,0xbe,0x93,0x54,0x67,0x8b,0x1a,0xe3,0xb0,0x91,0x8a,0xac,0x04,0x68,0xfc,
    0xee,0xff,0x56,0xf3,0x6f,0x64,0x00,0x00,0x02,0x00,0xb8,0x51,0x86,0xca,0x93,0xa9,0x5c,0xe9,0x87,0x64,0x7b,0x8a,
    0xb7,0x6b,0xe7,0xe9,0xd0,0x0a,0xe2,0x61,0x03,0x60,0x88,0xbb,0xbd,0x5f,0x74,0x03,0xf0,0x59,0xcf,0x52,0x75,0x9b,
    0x82,0x07,0xa6,0x03,0x34,0x04,0x99,0x46,0x71,0xf5,0x13,0x7d,0xd0,0xfa,0xfc,0x9e,0xce,0xb1,0x54,0x02,0xaf,0x64,
    0x29,0x3c,0x93,0xe1,0x7f,0x1f,0xa6,0x45,0x43,0x45,0x52,0x54,0x00,0x00,0x00,0x01,0x00,0x00,0x02,0xfc,0x00,0x00,
    0x02,0x6c,0x00,0x01,0x00,0x01,0x00,0x00,0x00,0x58,0xea,0x56,0xdd,0xb9,0x37,0x7e,0x84,0xd4,0xa5,0x9c,0xac,0xed,
    0x6f,0x4a,0x4b,0xc5,0x00,0x00,0x07,0xd0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0xd6,0x4a,0x60,0xd5,0xc6,0x59,
    0x9d,0x54,0x87,0xa2,0xeb,0x53,0xde,0x36,0x48,0x83,0x72,0xb9,0xd3,0x9e,0x31,0x12,0x95,0x19,0x66,0xa3,0xa8,0xab,
    0x2f,0xef,0x03,0x05,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x01,0x00,0x05,0x00,0x00,0x00,0x0c,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x06,0x00,0x00,0x00,0x60,
    0x00,0x00,0x00,0x01,0x00,0x01,0x02,0x00,0x00,0x00,0x00,0x00,0xb8,0x51,0x86,0xca,0x93,0xa9,0x5c,0xe9,0x87,0x64,
    0x7b,0x8a,0xb7,0x6b,0xe7,0xe9,0xd0,0x0a,0xe2,0x61,0x03,0x60,0x88,0xbb,0xbd,0x5f,0x74,0x03,0xf0,0x59,0xcf,0x52,
    0x75,0x9b,0x82,0x07,0xa6,0x03,0x34,0x04,0x99,0x46,0x71,0xf5,0x13,0x7d,0xd0,0xfa,0xfc,0x9e,0xce,0xb1,0x54,0x02,
    0xaf,0x64,0x29,0x3c,0x93,0xe1,0x7f,0x1f,0xa6,0x45,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x06,
    0x00,0x00,0x00,0x07,0x00,0x00,0x01,0x98,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x4d,0x69,0x63,0x72,0x6f,0x73,
    0x6f,0x66,0x74,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x50,0x6c,0x61,0x79,0x52,0x65,
    0x61,0x64,0x79,0x20,0x53,0x4c,0x32,0x30,0x30,0x30,0x20,0x44,0x65,0x76,0x69,0x63,0x65,0x20,0x2b,0x20,0x4c,0x69,
    0x6e,0x6b,0x20,0x52,0x6f,0x6f,0x74,0x20,0x43,0x41,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x31,0x2e,0x30,0x2e,0x30,0x2e,
    0x31,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x08,0x00,0x00,0x00,0x90,0x00,0x01,
    0x00,0x40,0xe9,0xeb,0x63,0xe5,0xf1,0xba,0x51,0xcd,0x37,0xc0,0xbd,0x4e,0x2e,0x63,0x95,0x0b,0x2e,0x20,0x10,0x4a,
    0xfe,0xb9,0x95,0xa9,0x7d,0xeb,0xd3,0x4c,0x46,0x28,0x76,0x73,0xb3,0x9c,0xeb,0xe7,0x5d,0x9a,0x76,0x4b,0xd2,0x05,
    0x5a,0x87,0x75,0x56,0x1f,0xc1,0xfe,0x4e,0x72,0x91,0xda,0x44,0x57,0x98,0xad,0xca,0xe5,0x40,0x0f,0x71,0x15,0x2e,
    0x00,0x00,0x02,0x00,0x86,0x4d,0x61,0xcf,0xf2,0x25,0x6e,0x42,0x2c,0x56,0x8b,0x3c,0x28,0x00,0x1c,0xfb,0x3e,0x15,
    0x27,0x65,0x85,0x84,0xba,0x05,0x21,0xb7,0x9b,0x18,0x28,0xd9,0x36,0xde,0x1d,0x82,0x6a,0x8f,0xc3,0xe6,0xe7,0xfa,
    0x7a,0x90,0xd5,0xca,0x29,0x46,0xf1,0xf6,0x4a,0x2e,0xfb,0x9f,0x5d,0xcf,0xfe,0x7e,0x43,0x4e,0xb4,0x42,0x93,0xfa,
    0xc5,0xab
};

static BYTE s_PRGPrivKey [] = {
    0x6e,0xb9,0xd6,0x17,0x03,0x72,0x35,0x3b,0xc4,0x02,0xac,0xe4,0x98,0x0b,0x30,0x77,
    0xbd,0xb7,0x5a,0xc2,0x73,0xf0,0xef,0x7d,0xce,0xa3,0x6f,0x1a,0xf3,0x8b,0x36,0x93
};



/*****************************************************************************
** Function:    _CreateTestBinaryDeviceCertificate
**
** Synopsis:    Gets the Device's binary certificate chain, creating the leaf node.
**
** Arguments:   [pbSerialNum]       : A pointer a buffer that contains the serial number of the cert
**              [cbSerialNum]       : Serial number size (must be DRM_BCERT_CLIENT_ID_LENGTH)
**              [pSignKey]          : The public signing key of the cert
**              [pEncrypKey]        : The public encryption key of the cert
**              [pbCert]            : A pointer to a bcert chain buffer to fill in
**              [pbCert]            : The size of the bcert chain buffer; updated
**              [pCryptoContext]            : Pointer to DRM_CRYPTO_CONTEXT used for temporary data in crypto code.
**
** Returns:     DRM_SUCCESS                            - on success
**              DRM_E_INVALIDDEVICECERTIFICATETEMPLATE - group cert chain too big
**              DRM_E_DEVCERTREADERROR                 - failure to get the dev cert chain
**              DRM_E_INVALIDARG                       - if any required pointer parameter is NULL
**              or other return code from a function called within
**
** Notes:       None.
**
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL _CreateTestBinaryDeviceCertificate(
    PRIVKEY_P256 * GCPrivKey,
    DRM_DWORD cbGCPrivKey,
    DRM_BYTE * pbModelCert,
    DRM_DWORD cbModelCert,
    DRM_BYTE *pbSerialNum,
    DRM_DWORD cbSerialNum,
    PUBKEY_P256 *pSignKey,
    PUBKEY_P256 *pEncryptKey,
    DRM_BYTE *pbCert,
    DRM_DWORD *pcbCert
    )
{
    DRM_RESULT                     dr                = DRM_SUCCESS;
    DRM_DWORD                      cbDevCert         = 0;
    PUBKEY_P256                    IssuerKey         = {0};
    DRM_BCERT_CERT_ID              CertificateID     = {0};
    DRM_BCERT_CLIENT_ID            SerialNum         = {0};
    DRM_BCERT_BUILDER_DATA         BuilderData       = {0};
    DRMFILETIME                    ftUnlimited       = {0};
    DRM_DWORD                      rgdwFeatureSet[2] = {0};
    DRM_BCERT_BUILDER_CERTKEY      oCertKeys[DRM_BINARY_DEVICE_CERT_MAX_KEYUSAGES] = {0};
    DRM_DWORD                      rgdwKeyUsages[]   = { DRM_BCERT_KEYUSAGE_SIGN, DRM_BCERT_KEYUSAGE_ENCRYPT_KEY };
    DRM_BCERT_VERIFICATIONCONTEXT  oVerificationContext = {0};
    DRM_CRYPTO_CONTEXT             cryptoContext = {0};
    DRM_BYTE                       parentChain[MAX_DEVICE_CERT_SIZE] = {0};
//    DRM_BYTE                      *parentChain       = NULL;
    DRM_BYTE                       devCert[MAX_DEVICE_CERT_SIZE];

    /*
    ** Initialize verification context: full verification.
    ** We only accept certs that don't expire (i.e. expire at 0xFFFFFFFF).
    ** Device cert key must have Sign and Encrypt key usages
    */
    CREATE_FILE_TIME( MAX_UNSIGNED_TYPE( DRM_DWORD ), ftUnlimited );

    ChkDR( DRM_BCert_InitVerificationContext( &ftUnlimited,
        (const PUBKEY_P256*) g_rgbMSPlayReadyRootIssuerPubKey,
        DRM_BCERT_CERTTYPE_DEVICE,
        &cryptoContext,
        TRUE,
        FALSE,
        rgdwKeyUsages,
        NO_OF(rgdwKeyUsages),
        FALSE,
        NULL, /* Cert caching parameters NULL as we generally don't verify signatures on device certs so optimization not needed here */
        NULL,
        NULL,
        &oVerificationContext ) );


    /*
    ** Load the group/model certificate (a.k.a. the parent chain) into the bottom
    ** half of the buffer provided.
    */
    MEMCPY(parentChain, s_PRGroupCert, SIZEOF(s_PRGroupCert));
//    parentChain = s_PRGroupCert; //pbModelCert;
    cbDevCert = SIZEOF(s_PRGroupCert);//cbModelCert;

    if( dr == DRM_E_BUFFERTOOSMALL )
    {
        ChkDR( DRM_E_INVALIDDEVICECERTIFICATETEMPLATE );
    }
    else if( DRM_FAILED( dr ) )
    {
        ChkDR( DRM_E_DEVCERTREADERROR );
    }

    /*
    ** Generate a unique Identifier for this certificate.
    ** Generate an ECC P256 key pairs.
    */
    ChkDR( Oem_Random_GetBytes( NULL, CertificateID.rgb, DRM_BCERT_CERT_ID_LENGTH ) );
    MEMCPY(oCertKeys[0].KeyValue.rgb, (DRM_BYTE *)pSignKey, SIZEOF (PUBKEY_P256));
    MEMCPY(oCertKeys[1].KeyValue.rgb, (DRM_BYTE *)pEncryptKey, SIZEOF (PUBKEY_P256));

    /*
    ** Get the device's serial number.
    ** Get the "issuer key" (the group/model cert's public key).
    ** Get the private key with which to sign this certificate (the group/model cert's private key).
    */
    MEMCPY (SerialNum.rgb, pbSerialNum, cbSerialNum);
    ChkDR( DRM_BCert_GetPublicKey( parentChain, cbDevCert, 0, &IssuerKey ) );

    /*
    ** Fill-in the input data structure used by the binary certificate builder
    */
    BCert_SetDefaultBuilderData( &CertificateID,
        DRM_BCERT_CERTTYPE_DEVICE,
        GCPrivKey,
        &IssuerKey,
        &BuilderData );

    oCertKeys[0].dwNumKeyUsages = 1;
    oCertKeys[0].pKeyUsageSet = (DRM_DWORD*)&rgdwKeyUsages[0];
    oCertKeys[1].dwNumKeyUsages = 1;
    oCertKeys[1].pKeyUsageSet = (DRM_DWORD*)&rgdwKeyUsages[1];
    BCert_SetKeyInfoBuilderData( (DRM_BCERT_BUILDER_CERTKEY*)oCertKeys, 2, &BuilderData );

    BCert_SetDeviceBuilderData( &SerialNum, &BuilderData );

    /*
    ** Set the feature flags in the binary cert builder
    */
    BuilderData.dwNumFeatureEntries = 0;
    BuilderData.prgdwFeatureSet = rgdwFeatureSet;

    rgdwFeatureSet[BuilderData.dwNumFeatureEntries++] = DRM_BCERT_FEATURE_ANTIROLLBACK_CLOCK;

    /*
    ** Use the security level from the group/model certificate in this leaf certificate
    */
    DRM_BCert_GetLeafSecurityLevel( BuilderData.dwSecurityLevel, parentChain );

    cbDevCert = MAX_DEVICE_CERT_SIZE;
    ChkDR( BCert_AddCert( parentChain, devCert, &cbDevCert, &BuilderData, &cryptoContext ) );

    /*
    ** Verify the newly built device certificate chain, then save it on the device.
    */
    ChkDR( DRM_BCert_ParseCertificateChain( devCert, cbDevCert, &oVerificationContext ) );

    /*
    ** Verify that we have enough space in the output buffer.
    */
    if (*pcbCert < cbDevCert)
    {
        ChkDR(DRM_E_BUFFERTOOSMALL)
    }

    ZeroMemory(pbCert, *pcbCert);
    MEMCPY (pbCert, devCert, cbDevCert);
    *pcbCert = cbDevCert;

ErrorExit:
    OEM_SECURE_ZERO_MEMORY( &GCPrivKey,   SIZEOF( PRIVKEY_P256 ) );

    return dr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\dll\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_playreadydevicecert_none_12.4.56.0_none_25eaae128109d975
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_playreadydevicecert_no-public-key_12.4.56.0_x-ww_175eefff
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=playreadydevicecert
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_playreadydevicecert_no-public-key_12.4.56.0_x-ww_175eefff
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_playreadydevicecert_no-public-key_12.4.56.0_x-ww_175eefff.manifest
XP_MANIFEST_PATH=manifests\x86_playreadydevicecert_no-public-key_12.4.56.0_x-ww_175eefff.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_playreadydevicecert_no-public-key_12.4.56.0_x-ww_175eefff.cat
XP_CATALOG_PATH=manifests\x86_playreadydevicecert_no-public-key_12.4.56.0_x-ww_175eefff.cat
XP_PAYLOAD_PATH=x86_playreadydevicecert_no-public-key_12.4.56.0_x-ww_175eefff
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=playreadydevicecert,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\bignum.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
/*

       File bignum.c
       Version 20 February 2005

       This file has extern definitions of functions
       which are ordinarily inlined.  In particular, it exists to
       support compilers which don't support inlining.
       It also has simple routines defined nowhere else.
*/
#define BIGNUM_C 1
#include "bignum.h"
#include "drmsal.h"

ENTER_PK_NAMESPACE_CODE;
/*
        DRM_DWORD mp_significant_digit_count(a, lng) --  Count the number
                                            of significant bits in a.
                                            This is one more than the
                                            truncated base 2 logarithm of a.

        DRM_DWORD significant_bit_count(d) -- Compute the number of
                                          significant bits in d (d != 0).
                                          This is one more than the
                                          truncated base 2 logarithm of d.

        DRM_BOOL two_adic_inverse(d, &dinv, &ctx) -- Returns dinv so that
                                           d*dinv == 1 (mod RADIX).
                                           d must be odd.

*/
/****************************************************************************/

DRM_API DRM_BOOL DRM_CALL two_adic_inverse( const digit_t d, digit_t *pdinv )
/*
      Find *pdinv so that (*pdinv)*d == 1 (mod RADIX)
*/
{
    DRM_BOOL OK = TRUE;

    if (IS_EVEN(d)) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "two_adic_inverse");
    } else {
        digit_t dinv = (3*d)^2;     // 5-bit  2-adic inverse approximation
        digit_t err = 1 - d*dinv;
        DRM_DWORD nbits;   // Bits of accuracy so far

        DRMASSERT((err & 31) == 0);
        for (nbits = 5; nbits < RADIX_BITS/2; nbits *= 2) {
            dinv += dinv*err;
            err = err*err;
            DRMASSERT(err == (digit_t)(1 - d*dinv));
        }
        *pdinv = dinv*err + dinv;
    }
    return OK;
} // two_adic_inverse

/****************************************************************************/


/*
        Here are some simple routines which fit nowhere else.

      carry  = accumulate(a, mult, b, lng)   -- b := b + mult*a, where a, b
                                                           have length lng


borrow = decumulate(a, mult, b, lng)   -- b := b - mult*a, where a, b
                                                           have length lng
carry  = multiply_immediate(a, mult, b, lng) -- b := mult*a, where a, b
                                                            have length lng

        DRM_BOOL mp_shift(a, amt, b, lng)    -- Compute lower lng words
                                            of b = a*2^amt, where
                                            amt can be arbitrarily large.
                                            Overflow/underflow is lost.
                                            Does left shift if amt >= 0,
                                            right shift if amt < 0.

        digit_t mp_shift_lost(a, amt, b, lng, plost)
                                         -- Compute lower lng words
                                            of b = a*2^amt, where
                                            |amt| <= RADIX_BITS.
                                            *plost will receive bits
                                            lost due to overflow/underflow.

        DRM_BOOL multiply(a, lnga, b, lngb, c) - Compute c = a * b
                                             (classical algorithm).

        DRM_BOOL set_immediate(a, ivalue, lngs) -- Set  a = ivalue (a scalar)

         multiply_low(a, b, c, lng)    -- c := a * b (mod RADIX^lng)
         (see file multlow.c)
*/
/***************************************************************************/
DRM_API DRM_NO_INLINE digit_t DRM_CALL accumulate(
                        const digit_t   a[],
                        const digit_t   mult,
    __inout_ecount(lng)       digit_t   b[],
                        const DRM_DWORD lng)
/*
        Compute b = b + mult*a, where a and b have length lng.
        Function value is carry out of leftmost digit.
*/
{
    digit_t carry = 0;
    DRM_DWORD i;

    for (i = 0; i != lng; i++) {
        const DRM_UINT64 dtemp = MULTIPLY_ADD2(mult, a[i], b[i], carry);
        b[i] = DRM_UI64Low32(dtemp);
        carry = DRM_UI64High32(dtemp);
    }
    return carry;
}  /* accumulate */

/****************************************************************************/
DRM_API DRM_NO_INLINE digit_t DRM_CALL decumulate(
                        const digit_t   a[],
                        const digit_t   mult,
    __inout_ecount(lng)       digit_t   b[],
                        const DRM_DWORD lng )
/*
        Compute b = b - mult*a, where a and b have length lng.
        Function value is borrow out of leftmost digit.
*/
{
    digit_t borrow = 0;
    DRM_DWORD i;

    for (i = 0; i != lng; i++) {
        const DRM_UINT64 dtemp = DRM_UI64Sub(DRM_UI64Sub(DRM_UI64(b[i]),
                                                DRM_UI64(borrow)),
                                     DPRODUU(mult, a[i]));
        b[i] = DRM_UI64Low32(dtemp);
        borrow = 0 - DRM_UI64High32(dtemp);
    }
    return borrow;
}  /* decumulate */
/***************************************************************************/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL mp_shift(
                        const digit_t   a[],
                        const DRM_INT   ishift,
    __inout_ecount(lng)       digit_t   b[],
                        const DRM_DWORD lng)
/*
//              Compute  b = a << ishift     (if ishift >= 0)
//                   or  b = a >> (-ishift)  (if ishift < 0).
//
//              Both input and output are length lng.
//              Unlike mp_shift, the shift count may
//              exceed RADIX_BITS bits (either direction).
//              It may even exceed lng*RADIX_BITS.
//              Bits shifted past either end are lost.
*/
{
    const DRM_INT itranslate = (ishift >= 0 ?   (DRM_INT) (DRM_DWORD)ishift/RADIX_BITS
                                   : - (DRM_INT)((DRM_DWORD)(-ishift)/RADIX_BITS));
                   /* Round quotient ishift/RADIX_BITS towards zero */
    DRM_DWORD i;
    DRM_BOOL OK = TRUE;
    digit_t lost = 0;

    OK = OK && mp_shift_lost(a, ishift - RADIX_BITS*itranslate, b,
                             lng, &lost);

    if (!OK) {
    } else if (itranslate < 0) {               /* Right shift, multiple words */
        const DRM_DWORD dtranslate = (DRM_DWORD)(-itranslate);
        for (i = 0; i < lng; i++) {
            DRM_DWORD j = i + dtranslate;
            b[i] = 0;
            
            // Skip the following assignment if integer overflow occurrs.

            //
            // Xbox LIVE specific: disabling conversion warning (C4296) after review.
            //
            #pragma warning( disable:4296 )
            if ( j >= i && j >= dtranslate && j < lng && j >= 0 )
            #pragma warning( default:4296 )
            //
            // End Xbox LIVE specific
            //
            {
                b[i] = b[j];
            }
        }
    } else if (itranslate > 0) {        /* Left shift, multiple words */
        const DRM_DWORD dtranslate = (DRM_DWORD)itranslate;
        for (i = lng; (i--) > 0; /*null*/) {
            b[i] = (i >= dtranslate ? b[i - dtranslate] : 0);
        }
    }
    return OK;
} /* mp_shift */
/****************************************************************************/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL mp_shift_lost(
                        const digit_t    a[],
                        const DRM_INT    shift_amt,
    __inout_ecount(lng)       digit_t    b[],
                        const DRM_DWORD  lng,
                              digit_t   *plost)
/*
//      Compute b = a*2^shift_amt.
//      Require -RADIX_BITS <= shift_amt <= RADIX_BITS.
//      Function value reflects bits shifted off the
//      right or off the left.

//      The arrays a and b should be identical, or not overlap.
*/
{
    DRM_DWORD i;
    DRM_BOOL OK = TRUE;
    digit_t bits_lost = 0;

    if (DRMCRT_abs(shift_amt) > RADIX_BITS) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "mp_shift_lost -- bad shift count");
    } else if (lng == 0) {
    } else if (shift_amt > 0) {           /* left shift */
        if (shift_amt == RADIX_BITS) {
            bits_lost = a[lng-1];
            for (i = lng-1; i != 0; i--) b[i] = a[i-1];
            b[0] = 0;
        } else {
            for (i = 0; i != lng; i++) {
                const digit_t bnew = (a[i] << shift_amt) | bits_lost;

                bits_lost = a[i] >> (RADIX_BITS - shift_amt);
                b[i] = bnew;
            }
        }
    } else if (shift_amt < 0) {
        if (shift_amt == -RADIX_BITS) {
            bits_lost = a[0];
            for (i = 1; i != lng; i++) b[i-1] = a[i];
            b[lng-1] = 0;
        } else {

            for (i = lng; (i--) > 0; /*null*/) {
                const digit_t bnew = (a[i] >> (-shift_amt) ) | bits_lost;
                bits_lost = a[i] << (RADIX_BITS + shift_amt);
                b[i] = bnew;
            }
            bits_lost >>= (RADIX_BITS + shift_amt); /* Move to bottom of word */
        }
    } else {
        MEMCPY( b,a,( lng)*SIZEOF( digit_t ));
    }
    if (OK) *plost = bits_lost;
    return OK;
} /* mp_shift_lost */

/****************************************************************************/
DRM_API DRM_NO_INLINE digit_t DRM_CALL multiply_immediate(
                        const digit_t     a[],
                        const digit_t     mult,
    __inout_ecount(lng)       digit_t     b[],
                        const DRM_DWORD   lng )
/*
        Compute b = mult*a, where a and b have length lng.
        Function value is carry out of leftmost digit.
*/
{
    digit_t carry = 0;
    DRM_DWORD i;
    
    for (i = 0; i < lng; i++) {
        const DRM_UINT64 dtemp = MULTIPLY_ADD1(mult, a[i], carry);
        b[i] = DRM_UI64Low32(dtemp);
        carry = DRM_UI64High32(dtemp);
    }
    return carry;
} /* multiply_immediate */
/****************************************************************************/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL set_immediate(
    digit_t             a[],          // OUT
    const digit_t       ivalue,       // IN
    const DRM_DWORD     lnga,         // IN
    struct bigctx_t    *f_pBigCtx )
{
    DRM_BOOL OK = TRUE;
    if (lnga == 0) {
        if (ivalue != 0) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_OVERFLOW,
                            "set_immediate");
        }
    } else {
        a[0] = ivalue;
        ZEROMEM(a + 1,( lnga - 1)*SIZEOF( digit_t ));
    }
    return OK;
} // end set_immediate
/****************************************************************************/


/*
** This is pretty much a no-op function that is needed for prebuilt
** stublibs for testing.
*/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL mp_initialization( struct bigctx_t *f_pBigCtx )
{
    return TRUE;
}

#if !DRM_INLINING_SUPPORTED
/****************************************************************************/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL multiply(
    const digit_t   a[],
    const DRM_DWORD lnga,
    const digit_t   b[],
    const DRM_DWORD lngb,
          digit_t   c[] )
/*
//        Multiply a (length lnga) times b (length lngb),
//        getting a product c (length lnga + lngb).

//        The output should not overlap the inputs.
*/
{
    DRM_BOOL OK = TRUE;
    const digit_t *p1, *p2;
    DRM_DWORD i, lng1, lng2;

    if (lnga > lngb) {           /* Put longer operand in p1 */
        p1 = a; p2 = b; lng1 = lnga; lng2 = lngb;
    } else {
        p2 = a; p1 = b; lng2 = lnga; lng1 = lngb;
    }

    if (!OK) {
    } else if (a == c || b == c) {
        OK = FALSE;        
    } else if (lng2 == 0) {       /* If an operand has length zero */
        ZEROMEM(c,( lng1)*SIZEOF( digit_t ));
    } else {
        c[lng1] = multiply_immediate(p1, p2[0], c, lng1);
        for (i = 1; i != lng2; i++) {
            c[i + lng1] = accumulate(p1, p2[i], &c[i], lng1);
        }
    }
    return OK;
} /* multiply */
#endif



EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\blackbox.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmpkcrypto.h>
#include <drmcipher.h>
#include <drmsha1.h>
#include <drmmanager.h>
#include <drmblackbox.h>
#include <drmaes.h>
#include <drmhmac.h>
#include <drmxmrbuilder.h>
#include <drmdomainkeyxmrparser.h>
#include <drmdomainstore.h>
#include <oem.h>

ENTER_PK_NAMESPACE_CODE;

#define HASH_RESIDUAL_LEN       6

DRM_VOID compile_time_asserts( DRM_VOID )
{    
    DRMCASSERT( SIZEOF( DRM_DECRYPT_CONTEXT ) == SIZEOF( DRM_CIPHER_CONTEXT ) );    
}

static DRM_RESULT _FindKeyPair(
    __inout_ecount( 1 )    DRM_BB_CONTEXT *f_pcontextBBX,
    __in_ecount( 1 ) const PUBKEY         *f_pPubkey,
    __out_ecount( 1 )      PRIVKEY        *f_pPrivKey );

static DRM_RESULT _GetDevicePrivkey( 
    __inout_ecount( 1 )    DRM_BB_CONTEXT *f_pcontextBBX,
    __out_ecount( 1 )      PRIVKEY        *f_pDevPrivkey );

static DRM_RESULT _GetDeviceECC256KeyPair(
    __in      DRM_BB_CONTEXT  *f_poBBXContext,
    __out_opt PUBKEY_P256     *f_poDevPubKey,
    __out_opt PRIVKEY_P256    *f_poDevPrivKey,
    __in      eDRM_BINARY_DEVICE_CERT_KEYUSAGE f_eDevKeyUsage );

static DRM_RESULT _DecryptContentKeyXML( 
    __in_ecount( f_dwChainLen ) const DRM_BINDING_INFO    *f_pBindingInfo,
    __in                              DRM_DWORD            f_dwChainLen,
    __inout_ecount( 1 )               DRM_BB_CONTEXT      *f_pcontextBBX,     
    __in                              DRM_BOOL             f_fIgnoreChecksum,
    __in                              DRM_DWORD            f_cbKeyBuff,       /* the size of the key buffer */
    __out_bcount( f_cbKeyBuff )       DRM_BYTE            *f_pbKeyBuff,       /* the key buffer */
    __out_ecount( 1 )                 DRM_DWORD           *f_pcbKey,          /* the size of the key */
    __out_opt                         PRIVKEY             *f_pPrivKey );      /* return the private key that was used to decrypt the content key */

static DRM_RESULT _DecryptContentKeyXMR( 
    __in_ecount( f_dwChainLen ) const DRM_BINDING_INFO    *f_pBindingInfo,
    __in                              DRM_DWORD            f_dwChainLen,
    __inout_ecount( 1 )               DRM_BB_CONTEXT      *f_pContextBBX,   
    __in                              DRM_BOOL             f_fIgnoreChecksum,
    __in                              DRM_BOOL             f_fIncludeCIKey,   /* Specifies to include content key in the returned key data */
    __in                              DRM_DWORD            f_cbKeyBuff,       /* the size of the key buffer */
    __out_bcount( f_cbKeyBuff )       DRM_BYTE            *f_pbKeyBuff,       /* the key buffer */
    __out_ecount( 1 )                 DRM_DWORD           *f_pcbKey,          /* the size of the key */
    __out_ecount_opt( 1 )             PRIVKEY_P256        *f_pPrivKey );      /* returns the privkey used to decrypt */    

static DRM_RESULT _VerifyChecksum( 
    __in_bcount( f_cbKey ) const DRM_BYTE                *f_pbKey, 
    __in                         DRM_DWORD                f_cbKey, 
    __in_ecount( 1 )       const DRM_BB_CHECKSUM_CONTEXT *f_pChecksum,
    __inout_ecount( 1 )          DRM_BB_CONTEXT          *f_pcontextBBX );

static DRM_RESULT DRM_CALL _TestDeviceKeyPair( DRM_BB_CONTEXT *f_pcontextBBX  )
{
    DRM_RESULT  dr          = DRM_SUCCESS;
    PRIVKEY     privkey     = { 0 }; 
    DRM_BYTE   *pbIn        = NULL;
    DRM_BYTE   *pbOut       = NULL;
    DRM_BYTE   *pbEncrypted = NULL;
    DRM_DWORD   cbEncrypted = SIZEOF( f_pcontextBBX->CryptoContext.union_cert.cert );
    DRM_DWORD   cbClear     = SIZEOF( f_pcontextBBX->CryptoContext.pubKey2 );
    
    /* Some basic assumptions about the environment */
    DRMCASSERT( DRM_ECC160_PLAINTEXT_LEN  <= SIZEOF( f_pcontextBBX->CryptoContext.pubKey2 ) );
    DRMCASSERT( DRM_ECC160_CIPHERTEXT_LEN <= SIZEOF( f_pcontextBBX->CryptoContext.union_cert.cert ) );

    ChkDR(_GetDevicePrivkey(f_pcontextBBX, &privkey));
    
    pbIn = ( DRM_BYTE * )&( f_pcontextBBX->CryptoContext.pubKey2 );
    MEMSET(pbIn, 'a', SIZEOF( PUBKEY ) );

    pbEncrypted = (DRM_BYTE *)&(f_pcontextBBX->CryptoContext.union_cert.cert);
    pbOut       = (DRM_BYTE *)&(f_pcontextBBX->CryptoContext.signature);
                           
    ChkDR( DRM_PK_Encrypt( NULL,
                           f_pcontextBBX->CryptoContext.rgbCryptoContext, 
                           eDRM_ECC_P160,
                           DRM_ECC160_PUBLIC_KEY_LEN,
                           ( DRM_BYTE * )&f_pcontextBBX->cachedCertValues.pubkeyCurrent, 
                           cbClear,
                           pbIn, 
                           &cbEncrypted,
                           pbEncrypted ) );                           

    ChkDR( DRM_PK_Decrypt( f_pcontextBBX->CryptoContext.rgbCryptoContext,
                           eDRM_ECC_P160,
                           DRM_ECC160_PRIVATE_KEY_LEN, 
                           ( const DRM_BYTE * )&privkey, 
                           cbEncrypted,
                           pbEncrypted, 
                           &cbClear,
                           pbOut ) );                               

    if (MEMCMP(pbIn, pbOut, cbClear) !=0)
    {
        ChkDR ( DRM_E_KEY_MISMATCH );
    }

ErrorExit:
    OEM_SECURE_ZERO_MEMORY( &privkey, SIZEOF(privkey) );
    return dr;
}

DRM_API DRM_RESULT DRM_CALL DRM_BBX_Initialize( 
    __in_opt            DRM_VOID           *f_pOEMContext,
    __inout_ecount( 1 ) DRM_BB_CONTEXT     *f_pcontextBBX )
{
    DRM_RESULT dr = DRM_SUCCESS;
    
    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_BLACKBOX, PERF_FUNC_DRM_BBX_Initialize);

    ChkArg( f_pcontextBBX != NULL );
    
    ZEROMEM( &f_pcontextBBX->CryptoContext, SIZEOF( DRM_CRYPTO_CONTEXT ) );
    
    /*
    ** Initializes pointer to OEM context in BIG_NUM context. 
    ** Pointer to BIG_NUM is passed to all crypto and bignum functions
    ** Thus OEM context becames available to all  bignum, in particular to 
    ** "random_bytes" function in bignum code 
    */
    DRM_ECC_PKInit( &f_pcontextBBX->CryptoContext.rgbCryptoContext, f_pOEMContext );

    f_pcontextBBX->pOEMContext = f_pOEMContext;
    
#if DRM_SUPPORT_DOMAINS
    f_pcontextBBX->pDomainStoreContext = NULL; 
#endif /* DRM_SUPPORT_DOMAINS */

#if DBG
    f_pcontextBBX->fInited = FALSE;
    ChkDR(_TestDeviceKeyPair(f_pcontextBBX));
#endif

    f_pcontextBBX->fInited = TRUE;

ErrorExit:
    
    DRM_PROFILING_LEAVE_SCOPE;
    
    return dr;
}

DRM_API DRM_RESULT DRM_CALL DRM_BBX_Shutdown( __inout_ecount( 1 ) DRM_BB_CONTEXT     *f_pcontextBBX )
{
    f_pcontextBBX->fInited = TRUE;
    return DRM_SUCCESS;
}

DRM_API DRM_RESULT DRM_CALL DRM_BBX_GetClientId(
    __out_ecount( 1 )    CLIENTID          *f_pClientId,
    __inout_ecount( 1 )  DRM_BB_CONTEXT    *f_pcontextBBX )
{
    DRM_RESULT     dr          = DRM_SUCCESS;
    RC4_KEYSTRUCT *prc4KS      = NULL;
    DRM_DWORD      cbEncrypted = DRM_ECC160_CIPHERTEXT_LEN;
    DRM_BYTE       rgbRandBuf[__CB_DECL(DRM_ECC160_PLAINTEXT_LEN)] = {0};    
    

    ChkArg( f_pClientId   != NULL 
         && f_pcontextBBX != NULL
         && f_pcontextBBX->fInited );

    MEMCPY( f_pClientId->version, CLIENT_ID_VER, VERSION_LEN );
    MEMCPY( &(f_pClientId->pk), &(f_pcontextBBX->cachedCertValues.m_BBCompatibilityCert), SIZEOF( PKCERT ) );
    
    ChkDR( Oem_Random_GetBytes( f_pcontextBBX->pOEMContext, rgbRandBuf, SIZEOF( rgbRandBuf ) ) );
    ChkDR( DRM_PK_Encrypt( NULL,
                           f_pcontextBBX->CryptoContext.rgbCryptoContext, 
                           eDRM_ECC_P160,
                           DRM_ECC160_PUBLIC_KEY_LEN,
                           ( DRM_BYTE * )&g_pubkeyLicenseServer, 
                           DRM_ECC160_PLAINTEXT_LEN,
                           rgbRandBuf, 
                           &cbEncrypted,
                           f_pClientId->randNum ) );                            
    
    prc4KS = (RC4_KEYSTRUCT*)f_pcontextBBX->CryptoContext.rgbCryptoContext;
    /* Encrypt the other data with RC4 using the random number as the key     */
    DRM_RC4_KeySetup( prc4KS, DRMCIPHERKEYLEN_RC4,    rgbRandBuf );
    DRM_RC4_Cipher(   prc4KS, SIZEOF(f_pClientId->pk), (DRM_BYTE *)&(f_pClientId->pk) );    

ErrorExit:
    return dr;
}


/*  
    Test whether or not a key is valid and can be used to decrypt
    content.
*/
DRM_API DRM_BOOL DRM_CALL DRM_BBX_CanBind( 
    __in_ecount( f_dwChainLength ) const DRM_BINDING_INFO *f_pBindingInfo,
    __in                                 DRM_DWORD         f_dwChainLength,
    __inout_ecount( 1 )                  DRM_BB_CONTEXT   *f_pcontextBBX,
    __out_opt                            DRM_RESULT       *f_pDr )
{
    DRM_BYTE    rgbKey [__CB_DECL( DRM_AES_KEYSIZE_128 )] = { 0 };   /* 16 BYTES */
    DRM_DWORD   f_cbKey = 0;
    DRM_RESULT  dr      = DRM_SUCCESS;
    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BLACKBOX, PERF_FUNC_DRM_BBX_CanBind );    

    ChkArg( f_pBindingInfo != NULL );

    if ( f_pBindingInfo[0].m_fXMRLicense )
    {    
        dr = _DecryptContentKeyXMR( f_pBindingInfo,
                                    f_dwChainLength, 
                                    f_pcontextBBX,
                                    TRUE,
                                    FALSE,
                                    DRM_AES_KEYSIZE_128, 
                                    rgbKey, 
                                   &f_cbKey,
                                    NULL );
                                                   
    }
    else
    {
        dr = _DecryptContentKeyXML( f_pBindingInfo,
                                    f_dwChainLength, 
                                    f_pcontextBBX,
                                    TRUE,
                                    DRM_AES_KEYSIZE_128, 
                                    rgbKey, 
                                   &f_cbKey,
                                    NULL );
    }
    if ( f_pDr != NULL )
    {
        *f_pDr = dr;
    }
                                                  
ErrorExit:        
    DRM_PROFILING_LEAVE_SCOPE;
    return DRM_SUCCEEDED( dr );                                        
}

/*********************************************************************
**
** Function: DRM_BBX_SymmetricBind
**
** Synopsis: Function that does symmetric binding of the passed in data
**           to the current blackbox - using a symmetric key derived from 
**           the device private key.
**           If f_fUseLegacyCrypto is TRUE, will use the ECC-160 priv key,
**           otherwise will use the ECC-256 priv key.
**
** Arguments:
** [f_poBBXContext]     : Specifies a pre-initialized blackbox context
** [f_fEncrypt]         : Specifies that encryption should be done instead of decryption
**                        (ignored for RC4)
** [f_fUseLegacyCrypto] : Specifies whether to use legacy crypto algorithms and keys
**                        (SHA-1, RC4), or new ones (SHA-256, AES-ECB)
** [f_pbDataIn]         : Pointer to a buffer of data to be
**                        ciphered.
** [f_pbDataOut]        : Pointer to a buffer that the result of
**                        the ciphering is stored. If NULL, ciphering
**                        will be done in place.
** [f_cbData]           : Size (number of bytes) of both the input
**                        and output buffers. The size of the input
**                        buffer and output buffer is the same
**                        since symmetric ciphering is used.
**
** Returns: 
**      DRM_SUCCESS
**          Success.
**      DRM_E_INVALIDARG 
**          One of the arguments is invalid or improperly initialized
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_BBX_SymmetricBind(
    __inout_ecount( 1 )          DRM_BB_CONTEXT *f_poBBXContext,
    __in                         DRM_BOOL        f_fEncrypt,
    __in                         DRM_BOOL        f_fUseLegacyCrypto,
    __in_bcount( f_cbData )      DRM_BYTE       *f_pbDataIn,
    __out_bcount_opt( f_cbData ) DRM_BYTE       *f_pbDataOut,
    __in                         DRM_DWORD       f_cbData )
{
    DRM_RESULT dr    = DRM_SUCCESS; 
    DRM_DWORD  cbKey = SIZEOF( PRIVKEY_P256 );
    DRM_BYTE   rgbKey[SIZEOF( PRIVKEY_P256 )] = { 0 };

    ChkArg( f_poBBXContext != NULL );
    ChkArg( f_poBBXContext->fInited );

    if ( f_fUseLegacyCrypto )
    {
        ChkDR( _GetDevicePrivkey( f_poBBXContext, ( PRIVKEY * )rgbKey ) );
        cbKey = SIZEOF( PRIVKEY );
    }
    else
    {
        ChkDR( _GetDeviceECC256KeyPair( f_poBBXContext, NULL, ( PRIVKEY_P256 * )rgbKey, DRM_BINARY_DEVICE_CERT_KEY_ENCRYPT ) );
    }

    ChkDR( DRM_BBX_SymmetricCipher( f_fEncrypt,
                                    f_fUseLegacyCrypto,
                                    rgbKey,
                                    cbKey,
                                    f_pbDataIn,
                                    f_pbDataOut,
                                    f_cbData ) );

ErrorExit:
    OEM_SECURE_ZERO_MEMORY( rgbKey, SIZEOF( PRIVKEY_P256 ) );
    return dr;
}

/*********************************************************************
**
** Function: DRM_BBX_SymmetricCipher
**
** Synopsis: Function that does symmetric ciphering (encrypt or decrypt)
**           of the passed in data using a symmetric key, which
**           is a key derived from a private key. 
**
**           The private key is hashed using either SHA-1 or SHA-256, 
**           and the hash is used as an RC4 or AES key to cipher the
**           data.
**
** Arguments:
** [f_fEncrypt]         : Specifies that encryption should be done instead of decryption
**                        (ignored for RC4)
** [f_fUseLegacyCrypto] : Specifies whether to use legacy crypto algorithms and keys
**                        (SHA-1, RC4), or new ones (SHA-256, AES-ECB)
** [f_pbKey]            : Specifies a key to hash to the symmetric key. 
** [f_cbKey]            : The length of f_pbKey
** [f_pbDataIn]         : Pointer to a buffer of data to be
**                        ciphered.
** [f_pbDataOut]        : Pointer to a buffer that the result of
**                        the ciphering is stored. If NULL, ciphering
**                        will be done in place.
** [f_cbData]           : Size (number of bytes) of both the input
**                        and output buffers. The size of the input
**                        buffer and output buffer is the same
**                        since symmetric ciphering is used.
**
** Returns: 
**      DRM_SUCCESS
**          Success.
**      DRM_E_INVALIDARG 
**          One of the arguments is invalid or improperly initialized
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_BBX_SymmetricCipher(
    __in                         DRM_BOOL        f_fEncrypt,
    __in                         DRM_BOOL        f_fUseLegacyCrypto,
    __in_bcount_opt( f_cbKey )   DRM_BYTE       *f_pbKey,
    __in                         DRM_DWORD       f_cbKey,
    __in_bcount( f_cbData )      DRM_BYTE       *f_pbDataIn,
    __out_bcount_opt( f_cbData ) DRM_BYTE       *f_pbDataOut,
    __in                         DRM_DWORD       f_cbData )
{
    DRM_RESULT      dr         = DRM_SUCCESS; 
    DRM_SHA_CONTEXT shaContext = DRM_SHA_CONTEXT_DEFAULT;
    DRM_BYTE        rgbDigest[__CB_DECL( DRM_SHA_DIGEST_LEN_MAX )] = { 0 };
    DRM_BYTE        rgbOutputKey[DRM_AES_BLOCKLEN] = {0};
    DRM_AES_KEY     aesKey = { 0 };

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BLACKBOX, PERF_FUNC_DRM_BBX_SymmetricCipher );

    ChkArg( f_pbDataIn  != NULL );  
    ChkArg( f_pbKey     != NULL );    
    ChkArg( f_cbData > 0 );
    ChkArg( f_cbKey > 0 );
    
    if ( f_pbDataOut != NULL )
    {
        MEMCPY( f_pbDataOut, f_pbDataIn, f_cbData );
    }
    else
    {
        f_pbDataOut = f_pbDataIn;
    }

    if ( f_fUseLegacyCrypto )
    {
        /*
        **  1. Get a hash of the privkey
        **  2. Generate a RC4 key using this hash
        **  3. Decrypt ciphertext using this RC4 key
        */
        RC4_KEYSTRUCT rc4Key = { 0 };

        ChkDR( DRM_SHA_Init( &shaContext, eDRM_SHA_1 ) );
        ChkDR( DRM_SHA_Update( f_pbKey, f_cbKey, &shaContext ) );
        ChkDR( DRM_SHA_Finalize( &shaContext, DRM_SHA1_DIGEST_LEN, rgbDigest ) );

        DRM_RC4_KeySetup( &rc4Key, DRM_SHA1_DIGEST_LEN, rgbDigest );
        DRM_RC4_Cipher( &rc4Key, f_cbData, f_pbDataOut );

        OEM_SECURE_ZERO_MEMORY( &rc4Key, SIZEOF( RC4_KEYSTRUCT ) );
    }
    else
    {
        /*
        **  1. Get an OMAC1 of the privkey
        **  2. Generate an AES key using this hash
        **  3. Decrypt or encrypt ciphertext using this AES key
        */
        DRM_BYTE    rgbConstantBlock[DRM_AES_BLOCKLEN] = {0};

        ChkBOOL( f_cbKey >= DRM_AES_KEYSIZE_128, DRM_E_CH_BAD_KEY );
        ChkDR( Oem_Aes_SetKey( f_pbKey, &aesKey ) ); 
        ChkDR( DRM_Omac1_Sign(&aesKey, rgbConstantBlock, 0, SIZEOF(rgbConstantBlock), rgbOutputKey) );
        ChkDR( Oem_Aes_ZeroKey(&aesKey) );

        ChkDR( Oem_Aes_SetKey( rgbOutputKey, &aesKey ) );

        if ( f_fEncrypt )
        {
            ChkDR( DRM_Aes_EcbEncryptData( &aesKey, f_pbDataOut, f_cbData ) );
        }
        else
        {
            ChkDR( DRM_Aes_EcbDecryptData( &aesKey, f_pbDataOut, f_cbData ) );
        }
    }

ErrorExit:    
    OEM_SECURE_ZERO_MEMORY( &shaContext, SIZEOF( DRM_SHA_CONTEXT ) );
    OEM_SECURE_ZERO_MEMORY( rgbDigest, DRM_SHA_DIGEST_LEN_MAX );
    OEM_SECURE_ZERO_MEMORY( &aesKey, SIZEOF( DRM_AES_KEY ) );
    OEM_SECURE_ZERO_MEMORY( rgbOutputKey, SIZEOF( rgbOutputKey ) );
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

#if DRM_SUPPORT_DOMAINS

/*********************************************************************
**
** Function: DRM_BBX_EncryptDomainPrivateKey
**
** Synopsis: 
**           Encrypt the passed in clear domain private key using the
**           device's symmetric key.
**
** Arguments:
**
** [f_poBBXContext]         -- Pointer to a DRM_BB_CONTEXT context.
** [f_pszBase]              -- Pointer to a DRM_CHAR buffer. Part of it contains
**                             the domain private key specified by a substring
**                             named f_pdasstrInputPrivKey.
** [f_pdasstrInputPrivKey]  -- Pointer to a DRM substring that defines the
**                             domain private key in the buffer pointed by f_pszBase.
**                             The data defined by f_pdasstrInputPrivKey will
**                             be B64 decoded in place so the content defined by
**                             f_pdasstrInputPrivKey will change after the function
**                             call.
** [f_poOutputPrivKey]      -- Pointer to a buffer that receives an encrypted
**                             domain private key using device's symmetric key.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_BBX_EncryptDomainPrivateKey(
    __inout_ecount( 1 )                         DRM_BB_CONTEXT   *f_poBBXContext,
    __in_bcount( f_pdasstrInputPrivKey->m_ich + f_pdasstrInputPrivKey->m_cch )
                                                DRM_CHAR         *f_pszBase,
    __in                                        DRM_SUBSTRING    *f_pdasstrInputPrivKey,
    __out_ecount( 1 )                           PRIVKEY_P256     *f_poOutputPrivKey )
{
    DRM_RESULT   dr     = DRM_SUCCESS;
    DRM_DWORD    cbSize = 0;
    PRIVKEY_P256 oClearDomainPrivKey = { 0 };

    ChkArg( f_poBBXContext != NULL );
    ChkArg( f_pszBase != NULL );
    ChkArg( f_pdasstrInputPrivKey != NULL );
    ChkArg( f_poOutputPrivKey != NULL );
    
    cbSize = SIZEOF( PRIVKEY_P256 );

    ChkDR( DRM_B64_DecodeA( f_pszBase,
                            f_pdasstrInputPrivKey,
                            &cbSize,
                            NULL,
                            DRM_BASE64_DECODE_IN_PLACE ) );
 
    /*
    ** The size of the B64 decoded data should be the size of an
    ** ECC-256 private key.
    */
    DRMASSERT( cbSize == SIZEOF( PRIVKEY_P256 ) );

    DRM_BYT_MoveBytes( ( DRM_BYTE * )&oClearDomainPrivKey,
                       0,
                       f_pszBase,
                       f_pdasstrInputPrivKey->m_ich,
                       SIZEOF( PRIVKEY_P256 ) );

    ChkDR( DRM_BBX_SymmetricBind( f_poBBXContext,
                                  TRUE,
                                  FALSE, 
                                  ( DRM_BYTE * )&oClearDomainPrivKey,
                                  ( DRM_BYTE * )f_poOutputPrivKey,
                                   SIZEOF( PRIVKEY_P256 ) ) );

    /* 
    ** Fill the passed in domain private key with valid XML characters
    ** to prevent XML parsing error.
    */
    DRM_BYT_SetBytes( f_pszBase,
                      f_pdasstrInputPrivKey->m_ich,
                      f_pdasstrInputPrivKey->m_cch,
                      ' ' );

ErrorExit:

    OEM_SECURE_ZERO_MEMORY( &oClearDomainPrivKey, SIZEOF( PRIVKEY_P256 ) );

    return dr;
}

#endif /* DRM_SUPPORT_DOMAINS */

/*  Decrypt a content key and place it in the given key buffer. */
static DRM_RESULT _DecryptContentKeyXML( 
    __in_ecount( f_dwChainLen ) const DRM_BINDING_INFO    *f_pBindingInfo,
    __in                              DRM_DWORD            f_dwChainLen,
    __inout_ecount( 1 )               DRM_BB_CONTEXT      *f_pcontextBBX,
    __in                              DRM_BOOL             f_IgnoreChecksum,  /* Specifies whether to ignore checksum over content key */
    __in                              DRM_DWORD            f_cbKeyBuff,       /* the size of the key buffer */
    __out_bcount( f_cbKeyBuff )       DRM_BYTE            *f_pbKeyBuff,       /* the key buffer */
    __out_ecount( 1 )                 DRM_DWORD           *f_pcbKey,          /* the size of the key */
    __out_opt                         PRIVKEY             *f_pPrivKey )       /* return the private key that was used to decrypt the content key */
{
    DRM_RESULT dr       = DRM_SUCCESS;
    PRIVKEY    privkey  = { 0 };
    DRM_BYTE   rgbDecContKey [__CB_DECL( DRM_ECC160_PLAINTEXT_LEN )] = { 0 }; 
    DRM_BYTE   bSize    = 0;
    const DRM_XML_BINDING_INFO *pXmlBindingInfo = NULL; 

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_BLACKBOX, PERF_FUNC__DecryptContentKey);

    ChkArg( f_pcbKey != NULL );

    *f_pcbKey = 0;    

    ChkArg( f_pcontextBBX  != NULL
         && f_pBindingInfo != NULL
         && f_pbKeyBuff    != NULL
         && f_dwChainLen    > 0
         && f_pcontextBBX->fInited
         && !f_pBindingInfo[f_dwChainLen-1].m_fXMRLicense );

    pXmlBindingInfo = &( f_pBindingInfo[f_dwChainLen-1].m_BindingInfo.m_XML );

    /* 
    **  Find the private key that corresponds to
    **  the public key used to encrypt the content key.
    **  The last value in the chain *must* be the key encrypted to the machine key.  It *must*
    **  be of type eMSDRM_PK or eMSDRM_SYM
    */
    ChkBOOL( pXmlBindingInfo->m_dwAlgorithm == eMSDRM_PK
          || pXmlBindingInfo->m_dwAlgorithm == eMSDRM_SYM, DRM_E_UNSUPPORTEDALGORITHM );
           
    ChkDR( _FindKeyPair( f_pcontextBBX, &( pXmlBindingInfo->m_oPublKey ), &privkey ) );

    if ( f_pBindingInfo[0].m_BindingInfo.m_XML.m_dwAlgorithm == eMSDRM_SYM )
    {
        /* Even if this is a license chain, if the leaf license is symmetrically optimized
           we can directly decrypt it */
        f_dwChainLen = 1;
        pXmlBindingInfo = &( f_pBindingInfo[0].m_BindingInfo.m_XML );
    }

    /*
    ** Decrypt the content key with that private key. 
    */
    if ( pXmlBindingInfo->m_dwAlgorithm == eMSDRM_PK )
    {
        *f_pcbKey = DRM_ECC160_PLAINTEXT_LEN;
        ChkDR( DRM_PK_Decrypt( f_pcontextBBX->CryptoContext.rgbCryptoContext,
                               eDRM_ECC_P160,
                               DRM_ECC160_PRIVATE_KEY_LEN, 
                               ( const DRM_BYTE * )&privkey, 
                               DRM_ECC160_CIPHERTEXT_LEN,
                               pXmlBindingInfo->m_rgbContentKey, 
                               f_pcbKey,
                               rgbDecContKey ) );                                          
    }
    else
    {        
        /*
        ** Also, just decrypt the entire buffer, even if we only want a small portion of it.
        ** We won't know how large the key is until we finish the call and can look at the
        ** first byte.
        */
        DRMCASSERT( SIZEOF( pXmlBindingInfo->m_rgbContentKey ) >= SIZEOF( rgbDecContKey ) );
        ChkDR( DRM_BBX_SymmetricCipher( FALSE,
                                        TRUE,
                                       ( DRM_BYTE * )&privkey,
                                       SIZEOF( privkey ),                                       
                                       ( DRM_BYTE * )pXmlBindingInfo->m_rgbContentKey,                                       
                                       rgbDecContKey,
                                       SIZEOF( rgbDecContKey ) ) );
    }

    bSize = GET_BYTE( rgbDecContKey, 0 );
    DRM_BYT_MoveBytes( rgbDecContKey, 0, rgbDecContKey, 1, SIZEOF( rgbDecContKey ) - 1);

    if ( !f_IgnoreChecksum )
    {
        ChkDR( _VerifyChecksum( rgbDecContKey, 
                                bSize, 
                               &f_pBindingInfo[f_dwChainLen-1].m_oChecksum, 
                                f_pcontextBBX ) );
    }

    /*
    ** Verify the key signature. 
    */
    if ( pXmlBindingInfo->m_dwAlgorithm == eMSDRM_PK )                                            
    {
        ChkDR( DRM_PK_Verify( f_pcontextBBX->CryptoContext.rgbCryptoContext, 
                              eDRM_ECC_P160,
                              DRM_ECC160_PUBLIC_KEY_LEN,
                              ( const DRM_BYTE * )&pXmlBindingInfo->m_oLsPublKey, 
                              ( DRM_DWORD ) bSize, 
                              rgbDecContKey, 
                              DRM_ECC160_SIGNATURE_LEN,
                              pXmlBindingInfo->m_rgbSignature ) );
    }
   
    for ( f_dwChainLen--; f_dwChainLen > 0; f_dwChainLen-- )
    {                
        pXmlBindingInfo = &f_pBindingInfo[f_dwChainLen-1].m_BindingInfo.m_XML;

        /*
        ** We are now in chained licenses enabling bits.  The algorithm *must* be eMSDRM_CK 
        */
        ChkBOOL( pXmlBindingInfo->m_dwAlgorithm == eMSDRM_CK
              && bSize == DES_KEYSIZE, 
                 DRM_E_UNSUPPORTEDALGORITHM );        

        /*
        ** Use the current content key we extracted as a DES key and decrypt the next section 
        */
        DRM_DES_KeySetup( ( DESTable * )( f_pcontextBBX->CryptoContext.rgbCryptoContext ), rgbDecContKey );
        
        DRM_DES_Decrypt( pXmlBindingInfo->m_rgbContentKey, 
                         rgbDecContKey, /* output buffer */
                        ( DESTable * )( f_pcontextBBX->CryptoContext.rgbCryptoContext ) );
        DRM_DES_Decrypt( ( pXmlBindingInfo->m_rgbContentKey ) + __CB_DECL( DES_BLOCKLEN ), 
                        rgbDecContKey + __CB_DECL( DES_BLOCKLEN ),
                        ( DESTable * )( f_pcontextBBX->CryptoContext.rgbCryptoContext ) );

        bSize = GET_BYTE( rgbDecContKey, 0 );
        DRM_BYT_MoveBytes( rgbDecContKey, 0, rgbDecContKey, 1, SIZEOF( rgbDecContKey ) - 1 );

        if ( !f_IgnoreChecksum )
        {
            ChkDR( _VerifyChecksum( rgbDecContKey, 
                                    bSize, 
                                   &f_pBindingInfo[f_dwChainLen-1].m_oChecksum, 
                                    f_pcontextBBX ) );
        }

        /*
        ** Verify the key signature. 
        */
        ChkBOOL( DRM_SUCCEEDED( DRM_PK_Verify( f_pcontextBBX->CryptoContext.rgbCryptoContext, 
                                               eDRM_ECC_P160,
                                               DRM_ECC160_PUBLIC_KEY_LEN,
                                               ( const DRM_BYTE * )&pXmlBindingInfo->m_oLsPublKey, 
                                               ( DRM_DWORD ) bSize, 
                                               rgbDecContKey, 
                                               DRM_ECC160_SIGNATURE_LEN,
                                               pXmlBindingInfo->m_rgbSignature ) ),
                DRM_E_LIC_SIGNATURE_FAILURE );            
   } /* end-for chainlen */
    
    *f_pcbKey = ( DRM_DWORD )bSize;   

    ChkBOOL( f_cbKeyBuff >= *f_pcbKey, DRM_E_BUFFERTOOSMALL );    

    /*
    ** Everything passed.  Return the key. 
    */
    MEMCPY( f_pbKeyBuff, rgbDecContKey, *f_pcbKey );
    if ( f_pPrivKey != NULL )
    {
        MEMCPY( f_pPrivKey, &privkey, SIZEOF( privkey ) );
    }

ErrorExit:
    OEM_SECURE_ZERO_MEMORY( &privkey, SIZEOF( PRIVKEY ) );
    
    DRM_PROFILING_LEAVE_SCOPE;
    
    return dr;
}

/*  Verify the checksum on a content key. */
static DRM_RESULT _VerifyChecksum( 
    __in_bcount( f_cbKey ) const DRM_BYTE                *f_pbKey, 
    __in                         DRM_DWORD                f_cbKey, 
    __in_ecount( 1 )       const DRM_BB_CHECKSUM_CONTEXT *f_pChecksum,
    __inout_ecount( 1 )          DRM_BB_CONTEXT          *f_pcontextBBX )
{
    DRM_RESULT dr     = DRM_SUCCESS;
    DRM_BYTE   rgbTemp[__CB_DECL( max( LEGACY_KID_B64ENC_LEN, DRM_SHA1_DIGEST_LEN + 1 ) )] = { 0 };    
    DRM_AES_KEY aesKey = {0};

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BLACKBOX, PERF_FUNC_VerifyChecksum );

    ChkArg( f_pChecksum   != NULL
         && f_pcontextBBX != NULL )

    ChkBOOL( f_pbKey != NULL && f_cbKey != 0, DRM_E_CH_BAD_KEY );  

    ZEROMEM( rgbTemp, SIZEOF( rgbTemp ) );

    if ( f_pChecksum->m_fIgnoreChecksum )
    {
        goto ErrorExit;
    }
   
    if ( f_pChecksum->m_pbV1KID != NULL )
    {
        DRM_CIPHER_CONTEXT *pCipherContext = ( DRM_CIPHER_CONTEXT * )( f_pcontextBBX->CryptoContext.rgbCryptoContext );
        
        ChkDR( DRM_CPHR_Init( pCipherContext, eDRM_RC4_CIPHER, f_cbKey, f_pbKey ) ); 

        /* 
        ** Verify the secret data: 
        ** The secret is the encrypted blob of the base64 encoded KID with the content key
        */
        ChkBOOL( f_pChecksum->m_cbChecksum >= LEGACY_KID_B64ENC_LEN, DRM_E_CH_BAD_KEY );               

        DRM_BYT_CopyBytes( rgbTemp,
                           0,
                           f_pChecksum->m_rgbChecksumData,
                           LEGACY_KID_B64ENC_LEN - DRM_CPHR_CB_FOR_INITDECRYPT,
                           DRM_CPHR_CB_FOR_INITDECRYPT );

        ChkDR( DRM_CPHR_InitDecrypt( pCipherContext,
                                     rgbTemp,
                                     LEGACY_KID_B64ENC_LEN ) );

        MEMCPY( rgbTemp, f_pChecksum->m_rgbChecksumData, LEGACY_KID_B64ENC_LEN );
        ChkDR( DRM_CPHR_Decrypt( pCipherContext, NULL, LEGACY_KID_B64ENC_LEN, rgbTemp ) );

        ChkBOOL( MEMCMP( f_pChecksum->m_pbV1KID, rgbTemp, LEGACY_KID_B64ENC_LEN ) == 0, DRM_E_CH_BAD_KEY );
    }
    else if( f_pChecksum->m_cbChecksum == DRM_AES_CK_CHECKSUM_LENGTH )
    {
        DRM_BYTE rgbBlock[SIZEOF( DRM_KID )] = {0};

        ChkArg( f_cbKey == DRM_AES_KEYSIZE_128 );
        ChkDR( Oem_Aes_SetKey( f_pbKey, &aesKey ) );
        MEMCPY( rgbBlock, f_pChecksum->m_KID.rgb, SIZEOF( DRM_KID ) );
        dr = DRM_Aes_EcbEncryptData(&aesKey, rgbBlock, SIZEOF( DRM_KID ) );
        Oem_Aes_ZeroKey( &aesKey );
        ChkDR( dr );
        ChkBOOL( MEMCMP( f_pChecksum->m_rgbChecksumData, rgbBlock, DRM_AES_CK_CHECKSUM_LENGTH ) == 0,
                 DRM_E_CH_BAD_KEY );
    }
    else
    {
        DRM_LONG         lCount  = 0;
        DRM_SHA_CONTEXT *pShaVal = ( DRM_SHA_CONTEXT * )( f_pcontextBBX->CryptoContext.rgbCryptoContext );

        /* Run SHA on key SHA_ITERATIONS times. */
        /* First copy key into rgbTemp. */
        if ( f_cbKey > SIZEOF( rgbTemp ) )
        {
            f_cbKey = SIZEOF( rgbTemp ); /* Make sure we don't exceed buffer capacity in rgbTemp. */
        }

        MEMCPY( rgbTemp, f_pbKey, f_cbKey );

        for ( lCount = 0; lCount < SHA_ITERATIONS; lCount++ )
        {
            ChkDR( DRM_SHA_Init( pShaVal, eDRM_SHA_1 ) );
            ChkDR( DRM_SHA_Update( rgbTemp, DRM_SHA1_DIGEST_LEN + 1, pShaVal ) );
            ChkDR( DRM_SHA_Finalize( pShaVal, DRM_SHA1_DIGEST_LEN, rgbTemp ) );
        }

        ChkBOOL( MEMCMP( rgbTemp, f_pChecksum->m_rgbChecksumData, CHECKSUM_LENGTH ) == 0, 
                 DRM_E_CH_BAD_KEY );
    }

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;    
    return dr;
}


/*  
    Decrypt a license that was encryted for privacy reasons (not 
    security reasons) while traveling on the net during license
    acquisition.
*/
DRM_API DRM_BOOL DRM_CALL DRM_BBX_DecryptLicense(
    __inout_bcount( f_cbEncryptedLicense )   DRM_BYTE       *f_pbEncryptedLicense,
    __in                                     DRM_DWORD       f_cbEncryptedLicense,
    __out_bcount_opt( f_cbEncryptedLicense - DRM_ECC160_CIPHERTEXT_LEN )
                                             DRM_BYTE       *f_pbLicense,
    __inout_ecount( 1 )                      DRM_BB_CONTEXT *f_pcontextBBX )

{
    DRM_RESULT     dr      = DRM_SUCCESS;        
    DRM_DWORD      cbKey   = DRM_ECC160_PLAINTEXT_LEN;
    PRIVKEY        privkey = { 0 };
    RC4_KEYSTRUCT *prc4KS  = NULL;
    DRM_BYTE       rgbKey[__CB_DECL( DRM_ECC160_PLAINTEXT_LEN )] = { 0 };

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_BLACKBOX, PERF_FUNC_DRM_BBX_DecryptLicense);

    ChkArg( f_pcontextBBX        != NULL
         && f_cbEncryptedLicense >= DRM_ECC160_CIPHERTEXT_LEN 
         && f_pcontextBBX->fInited );

    /* use device privkey to decrypt the license blob */
    ChkDR(_GetDevicePrivkey(f_pcontextBBX, &privkey));
    ChkDR( DRM_PK_Decrypt( f_pcontextBBX->CryptoContext.rgbCryptoContext,
                           eDRM_ECC_P160,
                           DRM_ECC160_PRIVATE_KEY_LEN, 
                           ( const DRM_BYTE * )&privkey, 
                           DRM_ECC160_CIPHERTEXT_LEN,
                           f_pbEncryptedLicense, 
                           &cbKey,
                           rgbKey ) );                          

    if ( GET_BYTE(rgbKey, 1) != PKSYMM_ALG_TYPE_RC4 )
    {
        ChkDR( DRM_E_UNSUPPORTEDALGORITHM );
    }

    f_cbEncryptedLicense -= DRM_ECC160_CIPHERTEXT_LEN;

    if ( f_pbLicense == NULL )
    {
        /* This means decrypt in place.  Caller must know that decrpyted content starts at pELicense + DRM_ECC160_CIPHERTEXT_LEN */
        f_pbLicense = f_pbEncryptedLicense + __CB_DECL(DRM_ECC160_CIPHERTEXT_LEN);
    }
    else
    {
        DRM_BYT_CopyBytes( f_pbLicense, 0, f_pbEncryptedLicense, DRM_ECC160_CIPHERTEXT_LEN, f_cbEncryptedLicense );
    }

    prc4KS = (RC4_KEYSTRUCT*)(f_pcontextBBX->CryptoContext.rgbCryptoContext);
    DRM_RC4_KeySetup(prc4KS, GET_BYTE(rgbKey, 0), rgbKey + __CB_DECL(2));
    DRM_RC4_Cipher  (prc4KS, f_cbEncryptedLicense, f_pbLicense );

ErrorExit:
    
    OEM_SECURE_ZERO_MEMORY(&privkey, SIZEOF(PRIVKEY));
    
    DRM_PROFILING_LEAVE_SCOPE;
    
    return (DRM_SUCCEEDED(dr) ? TRUE : FALSE);
}


/*  Used for computing the secure store password. */
DRM_API DRM_RESULT DRM_CALL DRM_BBX_HashValue(
    __in_bcount( f_cbValue )  const     DRM_BYTE       *f_pbValue,
    __in                                DRM_DWORD       f_cbValue,
    __in_bcount( DRM_SHA1_DIGEST_LEN )  DRM_BYTE        f_rgbHashValue[__CB_DECL(DRM_SHA1_DIGEST_LEN)],
    __inout_ecount( 1 )                 DRM_BB_CONTEXT *f_pcontextBBX )
{
    DRM_RESULT       dr          = DRM_SUCCESS;
    PRIVKEY          privkey     = { 0 };
    DRM_SHA_CONTEXT *pcontextSHA = NULL;
    
    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_BLACKBOX, PERF_FUNC_DRM_BBX_HashValue);

    ChkArg( f_pbValue      != NULL
         && f_cbValue       > 0 
         && f_rgbHashValue != NULL
         && f_pcontextBBX  != NULL
         && f_pcontextBBX->fInited );

    /* use device privkey */
    ChkDR(_GetDevicePrivkey(f_pcontextBBX, &privkey));

    pcontextSHA = (DRM_SHA_CONTEXT*)&(f_pcontextBBX->CryptoContext);
    ChkDR( DRM_SHA_Init( pcontextSHA, eDRM_SHA_1 ) );
    ChkDR( DRM_SHA_Update( ( DRM_BYTE * )&privkey, SIZEOF( PRIVKEY ), pcontextSHA ) );    
    ChkDR( DRM_SHA_Finalize( pcontextSHA, DRM_SHA1_DIGEST_LEN, f_rgbHashValue ) );

    /*  Now hash the given data (pValue). */
    ChkDR( DRM_SHA_Init( pcontextSHA, eDRM_SHA_1 ) );
    ChkDR( DRM_SHA_Update( f_rgbHashValue, HASH_RESIDUAL_LEN, pcontextSHA ) );
    ChkDR( DRM_SHA_Update( f_pbValue,      f_cbValue,           pcontextSHA ) );
    ChkDR( DRM_SHA_Finalize( pcontextSHA, DRM_SHA1_DIGEST_LEN, f_rgbHashValue ) );

ErrorExit:

    OEM_SECURE_ZERO_MEMORY(&privkey, SIZEOF(PRIVKEY));
    
    DRM_PROFILING_LEAVE_SCOPE;
    
    return dr;
}

/******************************************************************************
** 
** Function :   DRM_BBX_CipherKeySetup
** 
** Synopsis :   Set up the content key data ( decryption or encryption )    
** 
** Arguments :  
**          [f_pBindingInfo]     : Binding information
**          [f_dwChainLength]    : Chain length
**          [f_pCipherContext]   : Cipher context to set up
**          [f_pcontextBBX]      : Blackbox content
** 
** Returns :    
**          DRM_SUCCESS
**              Success
**          DRM_E_INVALIDARG
**              A required parameter was NULL or improperly initialized
**          DRM_E_CH_BAD_KEY
**              The checksum over the content key failed
**          DRM_E_UNSUPPORTEDALGORITHM
**              The symmetric encryption type specified in f_pBindingInfo is
**              unsupported or unrecognized
**
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_BBX_CipherKeySetup( 
    __in_ecount( f_dwChainLength ) const DRM_BINDING_INFO    *f_pBindingInfo,    
    __in                                 DRM_DWORD            f_dwChainLength,
    __out_ecount( 1 )                    DRM_CIPHER_CONTEXT  *f_pCipherContext,
    __inout_ecount( 1 )                  DRM_BB_CONTEXT      *f_pcontextBBX )
{
    DRM_RESULT dr      = DRM_SUCCESS;
    DRM_DWORD  f_cbKey = 0;
    DRM_BYTE   rgbKey[__CB_DECL( DRM_AES_KEYSIZE_128 )] = { 0 };
    DRM_SUPPORTED_CIPHERS eCipherType = eDRM_RC4_CIPHER;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BLACKBOX, PERF_FUNC_DRM_BBX_CipherKeySetup );

    ChkArg( f_pBindingInfo   != NULL 
         && f_pCipherContext != NULL
         && f_pcontextBBX    != NULL
         && f_pcontextBBX->fInited );

    if ( f_pBindingInfo[0].m_fXMRLicense )
    {
        ChkDR( _DecryptContentKeyXMR( f_pBindingInfo, 
                                      f_dwChainLength, 
                                      f_pcontextBBX, 
                                      FALSE,
                                      FALSE,
                                      SIZEOF( rgbKey ), 
                                      rgbKey, 
                                     &f_cbKey,
                                      NULL ) );
    
        if ( f_pBindingInfo[0].m_BindingInfo.m_XMR.m_pxmrContentKey->wSymmetricCipherType 
             == XMR_SYMMETRIC_ENCRYPTION_TYPE_AES_128_CTR )
        {
            eCipherType = eDRM_AES_COUNTER_CIPHER;  
        }
        else if ( f_pBindingInfo[0].m_BindingInfo.m_XMR.m_pxmrContentKey->wSymmetricCipherType 
                  != XMR_SYMMETRIC_ENCRYPTION_TYPE_RC4_CIPHER && 
                  f_pBindingInfo[0].m_BindingInfo.m_XMR.m_pxmrContentKey->wSymmetricCipherType 
                  != XMR_SYMMETRIC_ENCRYPTION_TYPE_COCKTAIL )
        {
            ChkDR( DRM_E_UNSUPPORTEDALGORITHM );
        } 
    }
    else
    {
        ChkDR( _DecryptContentKeyXML( f_pBindingInfo, 
                                      f_dwChainLength, 
                                      f_pcontextBBX, 
                                      FALSE, 
                                      SIZEOF( rgbKey ), 
                                      rgbKey, 
                                      &f_cbKey, 
                                      NULL ) );        
    }
    ChkDR( DRM_CPHR_Init( f_pCipherContext, eCipherType, f_cbKey, rgbKey ) );

ErrorExit:
    
    DRM_PROFILING_LEAVE_SCOPE;
    
    return dr;
}

/*  
    Search the current and old keys for a private key
    corresponding to the given public key.
*/
static DRM_RESULT _FindKeyPair(
    __inout_ecount( 1 )    DRM_BB_CONTEXT *f_pcontextBBX,
    __in_ecount( 1 ) const PUBKEY         *f_pPubkey,
    __out_ecount( 1 )      PRIVKEY        *f_pPrivKey )
{
    DRM_RESULT dr = DRM_S_FALSE; 

    ChkArg( f_pPrivKey != NULL );

    if (MEMCMP(f_pPubkey, &(f_pcontextBBX->cachedCertValues.pubkeyCurrent), SIZEOF( PUBKEY ) ) == 0 )
    {
        ChkDR(_GetDevicePrivkey(f_pcontextBBX, f_pPrivKey));
    }
    else
    {
        /* A matching key pair wasn't found */
        dr = DRM_E_UNKNOWN_BINDING_KEY;
    }
ErrorExit:
    return dr;
}

static DRM_RESULT _GetDevicePrivkey( 
    __inout_ecount( 1 )    DRM_BB_CONTEXT *f_pcontextBBX,
    __out_ecount( 1 )      PRIVKEY        *f_pDevPrivkey )
{
    DRM_RESULT dr          = DRM_SUCCESS;
    PRIVKEY    GCPrivkey   = {0};
    DRM_DWORD  cbGCPrivKey = SIZEOF( PRIVKEY );
    

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BLACKBOX, PERF_FUNC__GetDevicePrivkey );

    ChkArg( f_pcontextBBX != NULL); 
    ChkArg( f_pDevPrivkey != NULL);

    ChkDR( Oem_Device_GetKey( f_pcontextBBX->pOEMContext, 
                               DRM_DKT_WMDRMPD_GROUP, 
                               (DRM_BYTE *)&GCPrivkey, 
                               &cbGCPrivKey ) );

    ChkDR( DRM_BBX_SymmetricCipher( FALSE,
                                    TRUE,
                                    ( DRM_BYTE * )&GCPrivkey,
                                    SIZEOF( GCPrivkey ),                                    
                                    f_pcontextBBX->cachedCertValues.m_blobDevicePrivkey,
                                    ( DRM_BYTE * )f_pDevPrivkey,
                                    SIZEOF( PRIVKEY ) ) );

ErrorExit:    
    OEM_SECURE_ZERO_MEMORY( (DRM_BYTE*)&GCPrivkey, SIZEOF( PRIVKEY ) );  /* trash the key in memory */    
    DRM_PROFILING_LEAVE_SCOPE;    
    return dr;    
}

/******************************************************************************
** Function :   DRM_BBX_SignData
** Synopsis :   Sign data with the machine private key 
** Arguments :  f_pcontextBBX       - Blackbox context
**              f_pbData            - Data to be signed
**              f_cbData            - Size of data to be signed
**              f_rgbSignature      - Signature
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_BBX_SignData(
    __inout_ecount( 1 )                      DRM_BB_CONTEXT *f_pcontextBBX,
    __in_bcount( f_cbData )  const           DRM_BYTE       *f_pbData,
    __in                                     DRM_DWORD       f_cbData,
    __in                                     DRM_DWORD       f_ePrivKeyType,
    __out_bcount( DRM_ECC160_SIGNATURE_LEN ) DRM_BYTE        f_rgbSignature[__CB_DECL( DRM_ECC160_SIGNATURE_LEN )] )
{
    PRIVKEY     privkey     = { 0 };
    DRM_RESULT  dr          = DRM_SUCCESS;
    DRM_DWORD   cbSignature = DRM_ECC160_SIGNATURE_LEN; 
    
    ChkArg( f_pcontextBBX  != NULL 
         && f_ePrivKeyType == eBBX_PRIVKEY_MACHINE
         && f_pcontextBBX->fInited );
    
    ChkDR( _GetDevicePrivkey(f_pcontextBBX, &privkey) );

    ChkDR( DRM_PK_Sign( f_pcontextBBX->CryptoContext.rgbCryptoContext, 
                        eDRM_ECC_P160,
                        DRM_ECC160_PRIVATE_KEY_LEN,
                        ( const DRM_BYTE * )&privkey, 
                        f_cbData,
                        f_pbData,
                        &cbSignature,
                        f_rgbSignature) );                                                          
        
ErrorExit:
    OEM_SECURE_ZERO_MEMORY(&privkey, SIZEOF(PRIVKEY));
    return dr;
}

/*********************************************************************
**
**  Function:  DRM_BBX_SymmetricSign
**
**  Synopsis:  Creates a symmetric signature (that only the current blackbox can verify) over the data provided 
**             by the caller
**
**  Arguments:  
**     [f_pcontextBBX] -- Pointer to an initialized blackbox context
**     [f_pbData]      -- Pointer to the data to sign
**     [f_cbData]      -- Length of f_pbData in DRM_BYTEs
**     [f_rgbSymSig]   -- Buffer to place the resultant 'symmetric signature'
**
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_BBX_SymmetricSign(
    __inout_ecount( 1 )                  DRM_BB_CONTEXT *f_pcontextBBX,
    __in_bcount( f_cbData )  const       DRM_BYTE       *f_pbData,
    __in                                 DRM_DWORD       f_cbData,
    __out_bcount( DRM_SHA1_DIGEST_LEN )  DRM_BYTE        f_rgbSymSig[__CB_DECL( DRM_SHA1_DIGEST_LEN )] )
{
    PRIVKEY     privkey = { 0 };
    DRM_RESULT  dr      = DRM_SUCCESS;
    
    ChkArg( f_pcontextBBX  != NULL 
         && f_pbData       != NULL
         && f_cbData       != 0
         && f_pcontextBBX->fInited );
    
    ChkDR( _GetDevicePrivkey(f_pcontextBBX, &privkey) );

    ChkDR( DRM_HMAC_CreateMAC( eDRM_SHA_1,
                               (DRM_BYTE*)&privkey, 
                                SIZEOF( privkey ),
                                f_pbData,
                                0,
                                f_cbData, 
                                f_rgbSymSig,
                                0,
                                DRM_SHA1_DIGEST_LEN ) );
ErrorExit:
    OEM_SECURE_ZERO_MEMORY(&privkey, SIZEOF(PRIVKEY));
    return dr;
}

/*********************************************************************
**
**  Function:  DRM_BBX_SymmetricVerify
**
**  Synopsis:  Verifies a symmetric signtaure that was created by a call to DRM_BBX_SymmetricSign
**
**  Arguments:  
**     [f_pcontextBBX] -- Pointer to an initialized blackbox context
**     [f_pbData]      -- Pointer to the data to sign
**     [f_cbData]      -- Length of f_pbData in DRM_BYTEs
**     [f_pslk]        -- Optional.  If this parameter is provided the caller is asking to verify
**                        the signature with a BBX protected SLK key.
**     [f_rgbSymSig]   -- Buffer containing the signtature to compare against.
**
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_BBX_SymmetricVerify(
    __inout_ecount( 1 )                      DRM_BB_CONTEXT *f_pcontextBBX,
    __in_bcount( f_cbData )            const DRM_BYTE       *f_pbData,
    __in                                     DRM_DWORD       f_cbData,
    __in_opt                           const DRM_SLK        *f_pslk,
    __in_bcount( DRM_SHA1_DIGEST_LEN ) const DRM_BYTE        f_rgbSymSig[__CB_DECL( DRM_SHA1_DIGEST_LEN )] )
{
    PRIVKEY     privkey = { 0 }; 
    DRM_RESULT  dr      = DRM_SUCCESS;
    
    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_BLACKBOX, PERF_FUNC_DRM_BBX_SymmetricVerify);
    
    ChkArg( f_pcontextBBX  != NULL 
         && f_pbData       != NULL
         && f_cbData       != 0
         && f_pcontextBBX->fInited );
    
    ChkDR( _GetDevicePrivkey(f_pcontextBBX, &privkey) );

    if ( f_pslk == NULL )
    {
        ChkDR( DRM_HMAC_VerifyMAC( eDRM_SHA_1,
                                   ( DRM_BYTE * )&privkey,
                                   SIZEOF( privkey ),
                                   f_pbData,
                                   0,
                                   f_cbData,
                                   f_rgbSymSig,
                                   0,
                                   DRM_SHA1_DIGEST_LEN ) );
    }
    else
    {
        DRM_SLK slkClear = { 0 };

        ChkDR( DRM_BBX_SymmetricCipher( FALSE,
                                        TRUE,
                                        ( DRM_BYTE * )&privkey,
                                        SIZEOF( privkey ),                                                                        
                                        ( DRM_BYTE * ) f_pslk,                               
                                        ( DRM_BYTE * )&slkClear,
                                        DES_KEYSIZE ) );  /* Only decrypt the first 8 bytes */

        ChkDR( DRM_HMAC_VerifyMAC( eDRM_SHA_1,
                                   ( DRM_BYTE * )&slkClear,
                                   DES_KEYSIZE,
                                   f_pbData,
                                   0,
                                   f_cbData,     
                                   f_rgbSymSig,
                                   0,
                                   DRM_SHA1_DIGEST_LEN ) );
    }

ErrorExit:
    
    OEM_SECURE_ZERO_MEMORY( &privkey, SIZEOF( PRIVKEY ) );
    
    DRM_PROFILING_LEAVE_SCOPE;
    
    return dr;
}

/*********************************************************************
**
**  Function:  _UpdateXMRWithSymmKey
**
**  Synopsis:  Takes an XMR license (bound to an asymmetric key or symmetric SLK),
**             a content integrity key (clear), and a new content and integrity key (re-encrypted symmetrically), 
**             and updates the license with the symmetric key and new signature.
**             This function expects that the XMR license already contains an optimized content key object
**             
**  Arguments:  
**     [f_rgbCIKey]        : Buffer containing the clear CI key
**     [f_rgbEncryptedKeys]: Buffer containing the re-encrypted content and CI keys
**     [f_pXmrLicense]     : Pointer to the license object
**
*********************************************************************/
static DRM_RESULT DRM_CALL _UpdateXMRWithSymmKey(
    __in_bcount( DRM_AES_KEYSIZE_128 )     DRM_BYTE         f_rgbCIKey[__CB_DECL( DRM_AES_KEYSIZE_128 )],
    __in_bcount( DRM_AES_KEYSIZE_128 * 2 ) DRM_BYTE         f_rgbEncryptedKeys[__CB_DECL( DRM_AES_KEYSIZE_128 * 2 )],
    __inout_ecount( 1 )                    DRM_XMR_LICENSE *f_pXmrLicense )
{
    DRM_RESULT  dr     = DRM_SUCCESS;
    DRM_AES_KEY aesKey = {0};
    DRM_BYTE    rgbSignature[__CB_DECL(XMR_AES_OMAC_SIGNATURE_LENGTH)];

    ChkArg( f_pXmrLicense != NULL );
    
    ChkArg( f_pXmrLicense->containerOuter.containerKeys.OptimizedContentKey.fValid );

    ChkBOOL( f_pXmrLicense->containerOuter.containerKeys.OptimizedContentKey.cbEncryptedKey == DRM_AES_BLOCKLEN * 2,
             DRM_E_INVALIDLICENSE );
    DRM_BYT_CopyBytes( f_pXmrLicense->containerOuter.containerKeys.OptimizedContentKey.pbEncryptedKeyBuffer,
                       f_pXmrLicense->containerOuter.containerKeys.OptimizedContentKey.iEncryptedKey,
                       f_rgbEncryptedKeys,
                       0,
                       DRM_AES_BLOCKLEN * 2 );                                   
        
    f_pXmrLicense->containerOuter.containerKeys.OptimizedContentKey.wKeyEncryptionCipherType = XMR_SYMMETRIC_KEY_ENCRYPTION_TYPE_AES_128_ECB;
        
    /*
    ** Copy the new encryption type to the license buffer
    */
    ChkBOOL( f_pXmrLicense->containerOuter.containerKeys.OptimizedContentKey.iEncryptedKey > 2 * SIZEOF( DRM_WORD ),
             DRM_E_INVALIDLICENSE );
    WORD_TO_NETWORKBYTES( f_pXmrLicense->containerOuter.containerKeys.OptimizedContentKey.pbEncryptedKeyBuffer,
                          f_pXmrLicense->containerOuter.containerKeys.OptimizedContentKey.iEncryptedKey - SIZEOF( DRM_WORD ) * 2,
                          XMR_SYMMETRIC_KEY_ENCRYPTION_TYPE_AES_128_ECB ); 

        
    ChkDR( Oem_Aes_SetKey(f_rgbCIKey, &aesKey) );
    dr = DRM_Omac1_Sign(&aesKey, f_pXmrLicense->pbSignedDataBuffer, f_pXmrLicense->iSignedData, f_pXmrLicense->cbSignedData, rgbSignature );
    Oem_Aes_ZeroKey(&aesKey);
    DRM_BYT_CopyBytes(f_pXmrLicense->containerOuter.signature.pbSignatureBuffer, f_pXmrLicense->containerOuter.signature.iSignature, rgbSignature, 0, XMR_AES_OMAC_SIGNATURE_LENGTH);
    ChkDR( dr );

           
ErrorExit:
    return dr;
}


/*********************************************************************
**
**  Function:  DRM_BBX_AsymmetricToSymmetricKeyXML
**
**  Synopsis:  Takes an asymmetrically encrypted XML license and symmetrically
**             rebinds it to the current blackbox. 
**
**  Arguments:  
**     [f_pcontextBBX] : Pointer to an initialized blackbox context
**     [f_pbindinfo]   : Pointer to the binding info of the license that is being optmized 
**     [f_pcbSymmKey]  : Length of the resultant symmetric content key 
**
**  Notes:  The content key will be reencrypted and returned in the same buffer.  
**          The new length of the symmetric key is returned in f_pcbSymmKey.
**
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_BBX_AsymmetricToSymmetricKeyXML(
    __inout_ecount( 1 )      DRM_BB_CONTEXT    *f_pcontextBBX,
    __inout_ecount_opt( 1 )  DRM_BINDING_INFO  *f_pbindinfo,
    __out_ecount( 1 )        DRM_DWORD         *f_pcbSymmKey )  
{
    DRM_RESULT dr      = DRM_SUCCESS;
    PRIVKEY    privkey = { 0 };    
    DRM_BYTE   rgbKey[__CB_DECL( DRM_ECC160_PLAINTEXT_LEN )] = { 0 };

    ChkArg( f_pcontextBBX != NULL )
    ChkArg( f_pcbSymmKey  != NULL );
    ChkArg( f_pbindinfo   != NULL );
    ChkArg( f_pbindinfo->m_BindingInfo.m_XML.m_dwAlgorithm == eMSDRM_PK ); /* Must be an asymmetric encryption */
    ChkArg( f_pcontextBBX->fInited );    
    
    ChkDR( _DecryptContentKeyXML( f_pbindinfo, 
                                  1, 
                                  f_pcontextBBX, 
                                  TRUE,
                                  SIZEOF( rgbKey ), 
                                  rgbKey, 
                                  f_pcbSymmKey,
                                 &privkey ) );

    DRM_BYT_CopyBytes( f_pbindinfo->m_BindingInfo.m_XML.m_rgbContentKey, 1, rgbKey, 0, *f_pcbSymmKey );
    PUT_BYTE( f_pbindinfo->m_BindingInfo.m_XML.m_rgbContentKey, 0, ( DRM_BYTE )*f_pcbSymmKey );

    *f_pcbSymmKey += 1;

    ChkDR( DRM_BBX_SymmetricCipher( TRUE,
                                    TRUE,
                                    ( DRM_BYTE * )&privkey,
                                    SIZEOF( PRIVKEY ),
                                    f_pbindinfo->m_BindingInfo.m_XML.m_rgbContentKey,
                                    NULL,
                                    *f_pcbSymmKey ) );    
              
ErrorExit:
    OEM_SECURE_ZERO_MEMORY( rgbKey, SIZEOF( rgbKey ) );
    OEM_SECURE_ZERO_MEMORY( &privkey, SIZEOF( privkey ) );
    return dr;
}



#define DRM_XMR_SYMMETRIC_CONTENT_KEY_AES_SIZE   ( XMR_BASE_OBJECT_LENGTH + SIZEOF( DRM_WORD ) * 2 + DRM_AES_BLOCKLEN * 2 )

/*********************************************************************
**
**  Function:  DRM_BBX_AsymmetricToSymmetricKeyXMR
**
**  Synopsis:  Takes an asymmetrically encrypted license and symmetrically
**             rebinds it to the current blackbox. Adds the optimized content key object
**             if it doesn't already exist, then updates the signature object in-place. 
**
**  Arguments:  
**     [f_pcontextBBX]      : Pointer to an initialized blackbox context
**     [f_pbindinfoEx]      : Pointer to the binding info of the license that is being optmized
**     [f_pbLicense]        : Pointer to the license bytes
**     [f_cbLicense]        : Length of the entire license buffer
**     [f_pcbLicenseUsed]   : Pointer to the length of the license buffer used.
**     [f_pStack]           : Pointer to stack allocator context used to unpack license
**     [f_pcbSymmKey]       : Length of the resultant symmetric content key 
**
**  Notes:  The content key will be reencrypted and returned in the same buffer.  
**          The new length of the symmetric key is returned in f_pcbSymmKey.          
**
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_BBX_AsymmetricToSymmetricKeyXMR(
    __inout_ecount( 1 )               DRM_BB_CONTEXT                *f_pcontextBBX,    
    __inout_ecount_opt( 1 )           DRM_BINDING_INFO              *f_pbindinfo,
    __inout_bcount( f_cbLicense )     DRM_BYTE                      *f_pbLicense,
    __in                              DRM_DWORD                      f_cbLicense,
    __inout_ecount( 1 )               DRM_DWORD                     *f_pcbLicenseUsed,
    __inout_ecount( 1 )               DRM_STACK_ALLOCATOR_CONTEXT   *f_pStack,
    __out_ecount( 1 )                 DRM_DWORD                     *f_pcbSymmKey )  
{
    DRM_RESULT   dr      = DRM_SUCCESS;
    PRIVKEY_P256 privkey = { 0 };        
    DRM_BYTE     rgbKey[__CB_DECL( ECC_P256_PLAINTEXT_SIZE_IN_BYTES )] = { 0 };
    DRM_BYTE     rgbCIKey[__CB_DECL( DRM_AES_KEYSIZE_128 )] = { 0 }; /* Save the clear CI key */  
    DRM_XMR_BINDING_INFO *pXmrBindInfo = NULL;

    ChkArg( f_pcontextBBX    != NULL )
    ChkArg( f_pcbSymmKey     != NULL );
    ChkArg( f_pcbLicenseUsed != NULL );
    ChkArg( f_pbindinfo      != NULL );
    ChkArg( f_pStack         != NULL );

    pXmrBindInfo = &f_pbindinfo->m_BindingInfo.m_XMR;

    ChkArg( f_pbindinfo->m_BindingInfo.m_XMR.m_pxmrContentKey != NULL );
    ChkArg( f_pcontextBBX->fInited );         
    ChkArg( pXmrBindInfo->m_pxmrContentKey->wKeyEncryptionCipherType 
         == XMR_ASYMMETRIC_ENCRYPTION_TYPE_ECC_256 ); /* Must be an asymmetric encryption */            

    ChkDR( _DecryptContentKeyXMR( f_pbindinfo,
                                  1, 
                                  f_pcontextBBX, 
                                  TRUE,
                                  TRUE,
                                  SIZEOF( rgbKey ), 
                                  rgbKey, 
                                  f_pcbSymmKey, 
                                  &privkey ) );
    MEMCPY( rgbCIKey, rgbKey, DRM_AES_KEYSIZE_128 );
    *f_pcbSymmKey = DRM_AES_BLOCKLEN * 2;
    ChkDR( DRM_BBX_SymmetricCipher( TRUE,
                                    FALSE,
                                    ( DRM_BYTE * )&privkey,
                                    SIZEOF( PRIVKEY_P256 ),
                                    rgbKey,
                                    NULL,
                                    *f_pcbSymmKey ) );

    if( pXmrBindInfo->m_pxmrOptimizedContentKey == NULL 
     || !pXmrBindInfo->m_pxmrOptimizedContentKey->fValid )
    {
        DRM_DWORD cbObject        = 0;
        /*
        ** Insert Optimized content key directly after regular content key 
        */
        DRM_DWORD iInsertionPoint = pXmrBindInfo->m_pxmrLicense->containerOuter.containerKeys.ContentKey.iguidKeyID 
                                  - XMR_BASE_OBJECT_LENGTH; 
        ChkOverflow( pXmrBindInfo->m_pxmrLicense->containerOuter.containerKeys.ContentKey.iguidKeyID, iInsertionPoint );

        ChkBOOL( *f_pcbLicenseUsed + DRM_XMR_SYMMETRIC_CONTENT_KEY_AES_SIZE <= f_cbLicense,
                 DRM_E_BUFFERTOOSMALL );     
        ChkOverflow( *f_pcbLicenseUsed, *f_pcbLicenseUsed - iInsertionPoint );
        DRM_BYT_MoveBytes( f_pbLicense, 
                           iInsertionPoint + DRM_XMR_SYMMETRIC_CONTENT_KEY_AES_SIZE,                           
                           f_pbLicense, 
                           iInsertionPoint, 
                           *f_pcbLicenseUsed - iInsertionPoint ); /* Move everything down to make room */

        *f_pcbLicenseUsed += DRM_XMR_SYMMETRIC_CONTENT_KEY_AES_SIZE;

        /*
        ** Add Optimized Content Key object constant data
        */
        WORD_TO_NETWORKBYTES( f_pbLicense, iInsertionPoint, 0 ); 
        iInsertionPoint += SIZEOF( DRM_WORD );
        WORD_TO_NETWORKBYTES( f_pbLicense, iInsertionPoint, XMR_OBJECT_TYPE_OPTIMIZED_CONTENT_KEY_OBJECT );
        iInsertionPoint += SIZEOF( DRM_WORD );
        DWORD_TO_NETWORKBYTES( f_pbLicense, iInsertionPoint, DRM_XMR_SYMMETRIC_CONTENT_KEY_AES_SIZE ); 
        iInsertionPoint += SIZEOF( DRM_DWORD );
        WORD_TO_NETWORKBYTES( f_pbLicense, iInsertionPoint, XMR_SYMMETRIC_KEY_ENCRYPTION_TYPE_AES_128_ECB );
        iInsertionPoint += SIZEOF( DRM_WORD );
        WORD_TO_NETWORKBYTES ( f_pbLicense, iInsertionPoint, DRM_AES_BLOCKLEN * 2 );
        iInsertionPoint += SIZEOF( DRM_WORD );
        DRM_BYT_SetBytes( f_pbLicense, 
                          iInsertionPoint, 
                          DRM_AES_BLOCKLEN * 2,
                          0x00 );

        /*
        ** Adjust sizes of key material container, outer container
        */
        ChkDR( DRM_XMR_FindObject( XMR_OBJECT_TYPE_OUTER_CONTAINER,
                                   f_pbLicense,
                                   *f_pcbLicenseUsed,
                                   &iInsertionPoint,
                                   &cbObject ) );
        iInsertionPoint += 2 * SIZEOF( DRM_WORD ); /* Insert size after flags, object type */
        ChkBOOL( iInsertionPoint <= f_cbLicense, DRM_E_BUFFERTOOSMALL );  
        NETWORKBYTES_TO_DWORD( cbObject, f_pbLicense, iInsertionPoint );
        cbObject += DRM_XMR_SYMMETRIC_CONTENT_KEY_AES_SIZE;
        DWORD_TO_NETWORKBYTES( f_pbLicense, iInsertionPoint, cbObject );

        ChkDR( DRM_XMR_FindObject( XMR_OBJECT_TYPE_KEY_MATERIAL_CONTAINER,
                                   f_pbLicense,
                                   *f_pcbLicenseUsed,
                                   &iInsertionPoint,
                                   &cbObject ) );
        iInsertionPoint += 2 * SIZEOF( DRM_WORD ); /* Insert size after flags, object type */
        ChkBOOL( iInsertionPoint <= f_cbLicense, DRM_E_BUFFERTOOSMALL );  
        NETWORKBYTES_TO_DWORD( cbObject, f_pbLicense, iInsertionPoint );
        cbObject += DRM_XMR_SYMMETRIC_CONTENT_KEY_AES_SIZE;
        DWORD_TO_NETWORKBYTES( f_pbLicense, iInsertionPoint, cbObject );


        /*
        ** Unpack license structure again in order to readjust pointers which have changed
        */
        f_pStack->nStackTop = 0; /* Reset top of stack */
        ZEROMEM( pXmrBindInfo->m_pxmrLicense, SIZEOF( *pXmrBindInfo->m_pxmrLicense ) );
        ChkDR( DRM_XMR_UnpackLicense( f_pbLicense,
                                     *f_pcbLicenseUsed,
                                      f_pStack,
                                      pXmrBindInfo->m_pxmrLicense ) );
        /*
        ** Reset pointers in binding info structure
        */
        pXmrBindInfo->m_pxmrContentKey          = &pXmrBindInfo->m_pxmrLicense->containerOuter.containerKeys.ContentKey;    
        pXmrBindInfo->m_pxmrOptimizedContentKey = &pXmrBindInfo->m_pxmrLicense->containerOuter.containerKeys.OptimizedContentKey;   
        pXmrBindInfo->m_pxmrSignature           = &pXmrBindInfo->m_pxmrLicense->containerOuter.signature;   
        pXmrBindInfo->m_pxmrDomainID            = &pXmrBindInfo->m_pxmrLicense->containerOuter.containerGlobalPolicies.DomainID;   
    }

    ChkDR( _UpdateXMRWithSymmKey( rgbCIKey, rgbKey, pXmrBindInfo->m_pxmrLicense ) );
              
ErrorExit:
    OEM_SECURE_ZERO_MEMORY( rgbKey, SIZEOF( rgbKey ) );
    OEM_SECURE_ZERO_MEMORY( &privkey, SIZEOF( privkey ) );
    return dr;
}


/*********************************************************************
**
**  Function:  DRM_BBX_RebindSymmetricKey
**
**  Synopsis:  Takes an license which is symmetrically optimized to an SLK
**             and re-encrypts it to the device (or domain) symmetric key.
**             Legacy or current crypto is inferred from SLK size.
**             If no XMR license is specified, will re-encrypt in-place
**             to f_pbSymmKey
**
**  Arguments:  
**     [f_pcontextBBX] : Pointer to an initialized blackbox context
**     [f_pslk]        : Pointer to current SLK data
**     [f_pbSymmKey]   : Pointer to the symmetrically encrypted key data. 
**                       Will be updated in place
**     [f_ibSymmKey]   : Index into f_pbSymmKey (for in-place in-license rebinding)
**     [f_cbSymmKey]   : Length of the symmetrically encrypted key data. Will not change.
**     [f_pXmrLicense] : Pointer to an XMR license object to update with the new key and signature (optional)
**
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_BBX_RebindSymmetricKey(
    __inout_ecount( 1 )                         DRM_BB_CONTEXT  *f_pcontextBBX,
    __in_ecount( 1 )                      const DRM_SLK         *f_pslk,
    __inout_bcount( f_cbSymmKey + f_ibSymmKey ) DRM_BYTE        *f_pbSymmKey,
    __in                                        DRM_DWORD        f_ibSymmKey,
    __in                                        DRM_DWORD        f_cbSymmKey,
    __in_opt                                    DRM_XMR_LICENSE *f_pXmrLicense )
{
    DRM_RESULT   dr               = DRM_SUCCESS;
    PRIVKEY_P256 privkey          = { 0 };
    DRM_DWORD    cbPrivkey        = SIZEOF( privkey );
    DRM_SLK      slkClear         = { 0 };    
    DRM_BOOL     fUseLegacyCrypto = FALSE;
    DRM_BYTE     rgbSymmKey[__CB_DECL( DRM_AES_BLOCKLEN * 2 )] = { 0 };

    ChkArg( f_pcontextBBX  != NULL );
    ChkArg( f_pslk         != NULL );
    ChkArg( f_pbSymmKey    != NULL );
    ChkArg( f_cbSymmKey    != 0 );
    ChkArg( f_pcontextBBX->fInited );

    if ( f_pslk->cbKey == DRM_AES_KEYSIZE_128 )
    {        
        ChkDR( _GetDeviceECC256KeyPair( f_pcontextBBX, NULL, &privkey, DRM_BINARY_DEVICE_CERT_KEY_ENCRYPT ) );
    }
    else
    {
        ChkArg( f_pslk->cbKey == DES_KEYSIZE );        
        ChkDR( _GetDevicePrivkey( f_pcontextBBX, ( PRIVKEY * )&privkey ) );

        fUseLegacyCrypto = TRUE;
        cbPrivkey        = SIZEOF( PRIVKEY );
    }    

    /*
    ** First get the SLK key in the clear 
    */
    ChkDR( DRM_BBX_SymmetricCipher( FALSE,
                                    fUseLegacyCrypto,
                                    ( DRM_BYTE * )&privkey,
                                    cbPrivkey,                                                                     
                                    ( DRM_BYTE * )f_pslk,                            
                                    ( DRM_BYTE * )&slkClear,
                                    f_pslk->cbKey ) );   


    /*
    ** Use the clear SLK key to decrypt the content key 
    */
    ChkBOOL( f_cbSymmKey <= SIZEOF( rgbSymmKey ), DRM_E_BUFFERTOOSMALL );
    DRM_BYT_CopyBytes( rgbSymmKey, 0, f_pbSymmKey, f_ibSymmKey, f_cbSymmKey );

    if ( fUseLegacyCrypto )
    {
        ChkDR( DRM_BBX_SymmetricCipher( FALSE,
                                        TRUE,
                                        ( DRM_BYTE * )&slkClear,
                                        DES_KEYSIZE,                                  
                                        rgbSymmKey,
                                        NULL,
                                        f_cbSymmKey ) );        
    }
    else
    {
        ChkDR( Oem_Aes_SetKey( ( DRM_BYTE * )&slkClear, ( DRM_AES_KEY * )( f_pcontextBBX->CryptoContext.rgbCryptoContext ) ) );
        ChkDR( DRM_Aes_EcbDecryptData( ( DRM_AES_KEY * )( f_pcontextBBX->CryptoContext.rgbCryptoContext ), rgbSymmKey, f_cbSymmKey ) );    
    }

    /*
    ** Use the device private key to symmetrically encrypt the clear content key 
    */
    if ( f_pXmrLicense != NULL )
    {
        /*
        ** Decrypt and update license
        */
        DRM_BYTE rgbCIKey[__CB_DECL( DRM_AES_BLOCKLEN )] = { 0 };
        MEMCPY( rgbCIKey, rgbSymmKey, DRM_AES_BLOCKLEN );

        ChkDR( DRM_BBX_SymmetricCipher( TRUE,
                                        fUseLegacyCrypto,
                                        ( DRM_BYTE * )&privkey,
                                        cbPrivkey,                                                                     
                                        rgbSymmKey,
                                        NULL,                                    
                                        f_cbSymmKey ) );

        ChkDR( _UpdateXMRWithSymmKey( rgbCIKey, rgbSymmKey, f_pXmrLicense ) );
    }    
    else
    {
        /*
        ** Decrypt back into the key buffer
        */
        ChkDR( DRM_BBX_SymmetricCipher( TRUE,
                                        fUseLegacyCrypto,
                                        ( DRM_BYTE * )&privkey,
                                        cbPrivkey,                                                                     
                                        rgbSymmKey,
                                        NULL,                                    
                                        f_cbSymmKey ) );

        DRM_BYT_CopyBytes( f_pbSymmKey, f_ibSymmKey, rgbSymmKey, 0, f_cbSymmKey );
    }

ErrorExit:
    OEM_SECURE_ZERO_MEMORY( f_pcontextBBX->CryptoContext.rgbCryptoContext,  SIZEOF( DRM_AES_KEY ) );
    OEM_SECURE_ZERO_MEMORY( &privkey,  SIZEOF( privkey ) );
    OEM_SECURE_ZERO_MEMORY( &slkClear, SIZEOF( slkClear) );
    return dr;
}

/*********************************************************************
**
**  Function:  DRM_BBX_RebindSLK
**
**  Synopsis:  Takes an SLK (ILA Session Key) encrypted with the device
**             private key and re-encrypts it to the corresponding symmetric key,
**             updating the appropriate members of the SLK structure.
**             Legacy or current crypto is inferred from encrypted key size.
**
**  Arguments:  
**     [f_pcontextBBX] : Pointer to an initialized blackbox context
**     [f_pbEncSLK]    : Pointer to the encrypted SLK data
**     [f_cbEncSLK]    : Length of f_pbEncSLK
**     [f_pslk]        : Returns the re-encrypted SLK and it's length
**
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_BBX_RebindSLK(
    __inout_ecount( 1 )             DRM_BB_CONTEXT *f_pcontextBBX,
    __in_bcount( f_cbEncSLK ) const DRM_BYTE       *f_pbEncSLK,
    __in                            DRM_DWORD       f_cbEncSLK,
    __out_ecount( 1 )               DRM_SLK        *f_pslk )
{
    DRM_RESULT   dr        = DRM_SUCCESS;
    PRIVKEY_P256 privkey   = { 0 };
    DRM_DWORD    cbslk     = ECC_P256_PLAINTEXT_SIZE_IN_BYTES;
    DRM_BYTE     rgbslk[ECC_P256_PLAINTEXT_SIZE_IN_BYTES] = { 0 }; /* Maximum size */ 

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_BLACKBOX, PERF_FUNC_DRM_BBX_RebindSLK);

    ChkArg( f_pcontextBBX  != NULL );
    ChkArg( f_pbEncSLK     != NULL );
    ChkArg( f_pslk         != NULL );
    ChkArg( f_pcontextBBX->fInited );

    if ( f_cbEncSLK == ECC_P256_CIPHERTEXT_SIZE_IN_BYTES )
    {
        ChkDR( _GetDeviceECC256KeyPair( f_pcontextBBX, NULL, &privkey, DRM_BINARY_DEVICE_CERT_KEY_ENCRYPT ) );

        ChkDR( DRM_PK_Decrypt( f_pcontextBBX->CryptoContext.rgbCryptoContext,
                               eDRM_ECC_P256,
                               SIZEOF( privkey ), 
                               ( const DRM_BYTE * )&privkey, 
                               f_cbEncSLK,
                               f_pbEncSLK, 
                               &cbslk,
                               ( DRM_BYTE * )rgbslk ) );
        ChkDR( DRM_BBX_SymmetricCipher( TRUE,
                                        FALSE,
                                        ( DRM_BYTE * )&privkey,
                                        SIZEOF( privkey ),                                                                      
                                        &rgbslk[DRM_AES_KEYSIZE_128],  /* First half is just padding */
                                        ( DRM_BYTE * )&f_pslk->rgbKey,
                                        DRM_AES_KEYSIZE_128 ) );  
        f_pslk->cbKey = DRM_AES_KEYSIZE_128;
    }
    else
    {
        DRMCASSERT( DRM_ECC160_PLAINTEXT_LEN / 2 == DES_KEYSIZE );
        ChkArg( f_cbEncSLK == DRM_ECC160_CIPHERTEXT_LEN );
                
        ChkDR( _GetDevicePrivkey( f_pcontextBBX, ( PRIVKEY * )&privkey ) );

        ChkDR( DRM_PK_Decrypt( f_pcontextBBX->CryptoContext.rgbCryptoContext,
                               eDRM_ECC_P160,
                               SIZEOF( PRIVKEY ), 
                               ( const DRM_BYTE * )&privkey, 
                               f_cbEncSLK,
                               f_pbEncSLK, 
                               &cbslk,
                               ( DRM_BYTE * )rgbslk ) );
        ChkDR( DRM_BBX_SymmetricCipher( TRUE,
                                        TRUE,
                                        ( DRM_BYTE * )&privkey,
                                        SIZEOF( PRIVKEY ),                                                                      
                                        rgbslk,                          
                                        ( DRM_BYTE * )&f_pslk->rgbKey,
                                        DES_KEYSIZE ) );  
        f_pslk->cbKey = DES_KEYSIZE;
    }       

ErrorExit:    
    OEM_SECURE_ZERO_MEMORY( &privkey, SIZEOF( privkey ) );   
    OEM_SECURE_ZERO_MEMORY( rgbslk, SIZEOF( rgbslk ) );   

    DRM_PROFILING_LEAVE_SCOPE;
    
    return dr;
}

/******************************************************************************
** 
** Function :   _DecryptContentKeyXMR
** 
** Synopsis :   Decrypt a content key and place it in the given key buffer (XMR)           
** 
** Arguments :  
**          [f_pBindingInfo]    : XMR Binding information
**          [f_dwChainLen]      : Chain length
**          [f_pcontextBBX]     : Blackbox content
**          [f_fIgnoreChecksum] : Specifies to ignore the checksum over the content key
**          [f_fIncludeCIKey]   : Specifies to include the content integrity key in the returned
**                                key data. If TRUE, the buffer must be large enough to accomodate
**                                all of the key data.
**          [f_cbKeyBuff]       : length of the key buffer
**          [f_pbKeyBuff]       : Pointer to the key buffer
**          [f_pcbKey]          : Returns the length of the key
**          [f_pPrivKey]        : Returns the private key used to decrypt the content key (optional)
** 
** Returns :    
**          DRM_SUCCESS
**              Success
**          DRM_E_INVALIDARG
**              A required parameter was NULL or improperly initialized
**          DRM_E_LIC_KEY_DECODE_FAILURE
**              Unable to decode the content key
**          DRM_E_INVALID_SIGNATURE
**              Failed to verify the signature in the license
**          DRM_E_UNSUPPORTEDALGORITHM
**              An unsupported crypto algorithm was specified in the license
**          DRM_E_BUFFERTOOSMALL
**              The content key was too large for the buffer space
**          DRM_E_DOMAIN_BIND_LICENSE
**              No matching domain private key can be located (domain license only).
**
******************************************************************************/
static DRM_RESULT _DecryptContentKeyXMR( 
    __in_ecount( f_dwChainLen ) const DRM_BINDING_INFO    *f_pBindingInfo,
    __in                              DRM_DWORD            f_dwChainLen,
    __inout_ecount( 1 )               DRM_BB_CONTEXT      *f_pContextBBX,   
    __in                              DRM_BOOL             f_fIgnoreChecksum,
    __in                              DRM_BOOL             f_fIncludeCIKey,   /* Specifies to include content key in the returned key data */
    __in                              DRM_DWORD            f_cbKeyBuff,       /* the size of the key buffer */
    __out_bcount( f_cbKeyBuff )       DRM_BYTE            *f_pbKeyBuff,       /* the key buffer */
    __out_ecount( 1 )                 DRM_DWORD           *f_pcbKey,          /* the size of the key */
    __out_ecount_opt( 1 )             PRIVKEY_P256        *f_pPrivKey )       /* returns the privkey used to decrypt */     
{
    DRM_RESULT   dr           = DRM_SUCCESS;
    PRIVKEY_P256 privKey      = { 0 };
    DRM_DWORD    cbDecKeys    = ECC_P256_PLAINTEXT_SIZE_IN_BYTES;
    DRM_DWORD    cbTemp       = SHA256_DIGEST_SIZE_IN_BYTES;
    DRM_BOOL     fSymmBound   = FALSE;
    const DRM_XMR_BINDING_INFO *pXmrBindInfo = NULL;

    /*
    ** Temp buffer is SHA256_DIGEST_SIZE_IN_BYTES (32 bytes), but may be used for SHA256 HMAC or to 
    ** copy the DRM_AES_KEYSIZE_128 signature buffer (16 bytes) for OMAC verification, or
    ** to copy the Domain Account ID (128 bits) to get the domain key
    */
    DRM_BYTE     rgbTemp[__CB_DECL( SHA256_DIGEST_SIZE_IN_BYTES )]          = { 0 };
    DRM_BYTE     rgbDecKeys[__CB_DECL( ECC_P256_PLAINTEXT_SIZE_IN_BYTES )]  = { 0 };
    DRM_BYTE     rgbEncKeys[__CB_DECL( ECC_P256_CIPHERTEXT_SIZE_IN_BYTES )] = { 0 };      

    ChkArg( f_pcbKey       != NULL );  
    ChkArg( f_pContextBBX  != NULL );
    ChkArg( f_pBindingInfo != NULL );
    ChkArg( f_pbKeyBuff    != NULL );
    ChkArg( f_dwChainLen   >  0 );
    ChkArg( f_pContextBBX->fInited );
    ChkArg( f_pBindingInfo[f_dwChainLen-1].m_fXMRLicense );

    pXmrBindInfo = &f_pBindingInfo[f_dwChainLen-1].m_BindingInfo.m_XMR;

    ChkArg( pXmrBindInfo->m_pxmrContentKey != NULL );

    *f_pcbKey = 0; 

    ChkBOOL( pXmrBindInfo->m_pxmrContentKey->wKeyEncryptionCipherType 
          == XMR_ASYMMETRIC_ENCRYPTION_TYPE_ECC_256,
             DRM_E_UNSUPPORTEDALGORITHM );
    /* 
    **  Find the private key that corresponds to
    **  the public key used to encrypt the content key.
    **  If it is a domain-bound license, use appropriate domain key
    **  Otherwise use the device private key
    */
    if ( pXmrBindInfo->m_pxmrDomainID->fValid )
    {
#if DRM_SUPPORT_DOMAINS    
        ChkArg( f_pContextBBX->pDomainStoreContext != NULL );
        
        /*
        ** Using DecKeys temporarily to hold the Account ID for the domain
        */
        ChkBOOL( pXmrBindInfo->m_pxmrDomainID->cbAccountID <= ECC_P256_PLAINTEXT_SIZE_IN_BYTES,
                 DRM_E_BUFFERTOOSMALL );
        DRM_BYT_CopyBytes( rgbDecKeys, 
                           0, 
                           pXmrBindInfo->m_pxmrDomainID->pbAccountID,
                           pXmrBindInfo->m_pxmrDomainID->ibAccountID,
                           pXmrBindInfo->m_pxmrDomainID->cbAccountID );

        if ( DRM_FAILED( DRM_DOMST_GetKey( f_pContextBBX->pDomainStoreContext,
                                           ( DRM_GUID * )rgbDecKeys,
                                           pXmrBindInfo->m_pxmrDomainID->dwRevision,  
                                           rgbTemp,
                                           &cbTemp ) ) )
        {
            ChkDR( DRM_E_DOMAIN_BIND_LICENSE );
        }

        ChkBOOL( cbTemp <= SIZEOF( PRIVKEY_P256 ), DRM_E_BUFFERTOOSMALL );
        ChkDR( DRM_BBX_SymmetricBind( f_pContextBBX, 
                                      FALSE,
                                      FALSE, 
                                      rgbTemp,
                                      ( DRM_BYTE * )&privKey,
                                      cbTemp ) );    
#else
        ChkDR( DRM_E_LIC_KEY_DECODE_FAILURE );
#endif /* DRM_SUPPORT_DOMAINS */
    }
    else
    {
        ChkDR( _GetDeviceECC256KeyPair( f_pContextBBX, NULL, &privKey, DRM_BINARY_DEVICE_CERT_KEY_ENCRYPT ) );
    }             
    
    /*
    **  Get the encrypted content key & integrity key 
    */                    
    if ( pXmrBindInfo->m_pxmrOptimizedContentKey != NULL 
      && pXmrBindInfo->m_pxmrOptimizedContentKey->fValid 
      && pXmrBindInfo->m_pxmrOptimizedContentKey->wKeyEncryptionCipherType 
      == XMR_SYMMETRIC_KEY_ENCRYPTION_TYPE_AES_128_ECB
      && pXmrBindInfo->m_pxmrOptimizedContentKey->cbEncryptedKey <= SIZEOF( rgbEncKeys ) )
    {
        DRM_BYT_CopyBytes( rgbEncKeys, 
                           0, 
                           pXmrBindInfo->m_pxmrOptimizedContentKey->pbEncryptedKeyBuffer, 
                           pXmrBindInfo->m_pxmrOptimizedContentKey->iEncryptedKey,
                           pXmrBindInfo->m_pxmrOptimizedContentKey->cbEncryptedKey );

        cbDecKeys = pXmrBindInfo->m_pxmrOptimizedContentKey->cbEncryptedKey;

        if ( DRM_SUCCEEDED( DRM_BBX_SymmetricCipher( FALSE,
                                                     FALSE,
                                                     ( DRM_BYTE * )&privKey,
                                                     SIZEOF( privKey ),
                                                     rgbEncKeys,
                                                     rgbDecKeys,
                                                     cbDecKeys ) ) )
        {
            fSymmBound = TRUE;
        }        
    }

    if ( !fSymmBound ) /* Fall back to asymmetric binding if failed */
    {
        ChkBOOL( pXmrBindInfo->m_pxmrContentKey->cbEncryptedKey <= SIZEOF( rgbEncKeys ),
                 DRM_E_BUFFERTOOSMALL );
        DRM_BYT_CopyBytes( rgbEncKeys, 
                           0, 
                           pXmrBindInfo->m_pxmrContentKey->pbEncryptedKeyBuffer, 
                           pXmrBindInfo->m_pxmrContentKey->iEncryptedKey,
                           pXmrBindInfo->m_pxmrContentKey->cbEncryptedKey );

        /*
        ** Decrypt the content key with that private key
        */                       
        ChkDR( DRM_PK_Decrypt( f_pContextBBX, 
                               eDRM_ECC_P256,
                               SIZEOF( PRIVKEY_P256 ),
                               ( const DRM_BYTE * )&privKey,
                               ECC_P256_CIPHERTEXT_SIZE_IN_BYTES,
                               rgbEncKeys,
                               &cbDecKeys,
                               rgbDecKeys ) );    
    }
                    
    /*
    ** Verify the signature of the license buffer       
    */
    if( pXmrBindInfo->m_pxmrSignature->wType == XMR_SIGNATURE_TYPE_AES_128_OMAC )
    {
        DRM_AES_KEY aesKey = {0};
        
        ChkBOOL( pXmrBindInfo->m_pxmrSignature->cbSignature == DRM_AES_BLOCKLEN,
                 DRM_E_INVALID_SIGNATURE );

        ChkDR( Oem_Aes_SetKey(rgbDecKeys, &aesKey) );
        dr = DRM_Omac1_Verify(&aesKey, 
                                 pXmrBindInfo->m_pxmrLicense->pbSignedDataBuffer,
                                 pXmrBindInfo->m_pxmrLicense->iSignedData,
                                 pXmrBindInfo->m_pxmrLicense->cbSignedData,
                                 pXmrBindInfo->m_pxmrSignature->pbSignatureBuffer,
                                 pXmrBindInfo->m_pxmrSignature->iSignature );
        Oem_Aes_ZeroKey(&aesKey);
        ChkDR( dr );
    }
    else if( pXmrBindInfo->m_pxmrSignature->wType == XMR_SIGNATURE_TYPE_SHA_256_HMAC )
    {
        /* Post 2/2008 PlayReady licenses should never have this MAC */
        ChkBOOL( pXmrBindInfo->m_pxmrSignature->cbSignature == SHA256_DIGEST_SIZE_IN_BYTES,
                 DRM_E_INVALID_SIGNATURE );                    

        ChkDR( DRM_HMAC_VerifyMAC( eDRM_SHA_256, 
                                   rgbDecKeys,
                                   DRM_AES_KEYSIZE_128,
                                   pXmrBindInfo->m_pxmrLicense->pbSignedDataBuffer,
                                   pXmrBindInfo->m_pxmrLicense->iSignedData, 
                                   pXmrBindInfo->m_pxmrLicense->cbSignedData,                                                             
                                   pXmrBindInfo->m_pxmrSignature->pbSignatureBuffer,
                                   pXmrBindInfo->m_pxmrSignature->iSignature,
                                   pXmrBindInfo->m_pxmrSignature->cbSignature ) );
    }
    else
    {
        ChkDR( DRM_E_UNSUPPORTEDALGORITHM );
    }
    
    /*
    ** Get the size of the key
    */    
    if ( pXmrBindInfo->m_pxmrContentKey->wSymmetricCipherType
      == XMR_SYMMETRIC_ENCRYPTION_TYPE_AES_128_CTR
      || pXmrBindInfo->m_pxmrContentKey->wSymmetricCipherType
      == XMR_SYMMETRIC_ENCRYPTION_TYPE_AES_128_ECB )
    {
        *f_pcbKey = DRM_AES_KEYSIZE_128;
    }
    else if ( pXmrBindInfo->m_pxmrContentKey->wSymmetricCipherType
           == XMR_SYMMETRIC_ENCRYPTION_TYPE_RC4_CIPHER )
    {
        *f_pcbKey = GET_BYTE( rgbDecKeys, DRM_AES_KEYSIZE_128 ); 
        ChkBOOL( *f_pcbKey == DRMCIPHERKEYLEN_RC4
              || *f_pcbKey == DRMCIPHERKEYLEN_RC4_PDRM, DRM_E_LIC_KEY_DECODE_FAILURE );  
        /*
        ** Remove the size byte
        */
        DRM_BYT_MoveBytes( rgbDecKeys, DRM_AES_KEYSIZE_128, rgbDecKeys, DRM_AES_KEYSIZE_128 + 1, *f_pcbKey ); 
    }
    else if ( pXmrBindInfo->m_pxmrContentKey->wSymmetricCipherType
           == XMR_SYMMETRIC_ENCRYPTION_TYPE_COCKTAIL )
    {
        *f_pcbKey = DRMCIPHERKEYLEN_RC4; 
    }
    else
    {
        ChkDR( DRM_E_UNSUPPORTEDALGORITHM );
    }    

    /*
    ** Verify the checksum (over content/root key only)
    */
    if ( !f_fIgnoreChecksum )
    {
        ChkDR( _VerifyChecksum( &rgbDecKeys[DRM_AES_KEYSIZE_128], 
                                *f_pcbKey, 
                                &f_pBindingInfo[f_dwChainLen-1].m_oChecksum, 
                                f_pContextBBX ) );
    }

    /*
    ** Work back through the chain and decrypt key
    */
    for ( f_dwChainLen--; f_dwChainLen > 0; f_dwChainLen-- )
    {    
        ZEROMEM( rgbTemp, SIZEOF( rgbTemp ) );
        pXmrBindInfo = &f_pBindingInfo[f_dwChainLen-1].m_BindingInfo.m_XMR;

        /*
        ** We are now in chained licenses enabling bits.  The algorithm *must* be chained 
        ** And the decrypted root key *must* be an AES-128 key
        */       
        ChkBOOL( pXmrBindInfo->m_pxmrContentKey->wKeyEncryptionCipherType
              == XMR_ASYMMETRIC_ENCRYPTION_TYPE_CHAINED_LICENSE
              && *f_pcbKey == DRM_AES_KEYSIZE_128,
                 DRM_E_UNSUPPORTEDALGORITHM );        

        /*
        ** Use the current content key we extracted as an AES key in ECB mode
        ** to decrypt the next section 
        */
        ChkDR( Oem_Aes_SetKey( &rgbDecKeys[DRM_AES_KEYSIZE_128],
                               ( DRM_AES_KEY * )( f_pContextBBX->CryptoContext.rgbCryptoContext ) ) );
        DRM_BYT_CopyBytes( rgbDecKeys, 
                           0, 
                           pXmrBindInfo->m_pxmrContentKey->pbEncryptedKeyBuffer, 
                           pXmrBindInfo->m_pxmrContentKey->iEncryptedKey,
                           DRM_AES_KEYSIZE_128 * 2 );      
        ChkDR( DRM_Aes_EcbDecryptData( ( DRM_AES_KEY * )( f_pContextBBX->CryptoContext.rgbCryptoContext ),
                                       rgbDecKeys,
                                       DRM_AES_KEYSIZE_128 * 2 ) );

        
        /*
        ** Get the size of the key
        */
        if ( pXmrBindInfo->m_pxmrContentKey->wSymmetricCipherType
          == XMR_SYMMETRIC_ENCRYPTION_TYPE_AES_128_CTR )
        {
            *f_pcbKey = DRM_AES_KEYSIZE_128;
        }
        else if ( pXmrBindInfo->m_pxmrContentKey->wSymmetricCipherType
               == XMR_SYMMETRIC_ENCRYPTION_TYPE_RC4_CIPHER )
        {
            *f_pcbKey = GET_BYTE( rgbDecKeys, DRM_AES_KEYSIZE_128 ); 
            ChkBOOL( *f_pcbKey == DRMCIPHERKEYLEN_RC4
                  || *f_pcbKey == DRMCIPHERKEYLEN_RC4_PDRM, DRM_E_LIC_KEY_DECODE_FAILURE );       
            /*
            ** Remove the size byte
            */
            DRM_BYT_MoveBytes( rgbDecKeys, DRM_AES_KEYSIZE_128, rgbDecKeys, DRM_AES_KEYSIZE_128 + 1, *f_pcbKey ); 
        }
        else if ( pXmrBindInfo->m_pxmrContentKey->wSymmetricCipherType
               == XMR_SYMMETRIC_ENCRYPTION_TYPE_COCKTAIL )
        {
            *f_pcbKey = DRMCIPHERKEYLEN_RC4; 
        }
        else
        {
            ChkDR( DRM_E_UNSUPPORTEDALGORITHM );
        }

        /*
        ** Verify the checksum (over content key only)
        */
        if ( !f_fIgnoreChecksum )
        {
            ChkDR( _VerifyChecksum( &rgbDecKeys[DRM_AES_KEYSIZE_128], 
                                    *f_pcbKey, 
                                    &f_pBindingInfo[f_dwChainLen-1].m_oChecksum, 
                                    f_pContextBBX ) );    
        }
        
        /*
        ** Verify the signature of the license buffer       
        */
        if( pXmrBindInfo->m_pxmrSignature->wType == XMR_SIGNATURE_TYPE_AES_128_OMAC )
        {
            DRM_AES_KEY aesKey = {0};
            
            ChkBOOL( pXmrBindInfo->m_pxmrSignature->cbSignature == DRM_AES_BLOCKLEN,
                     DRM_E_INVALID_SIGNATURE );
        
            ChkDR( Oem_Aes_SetKey(rgbDecKeys, &aesKey) );
            dr = DRM_Omac1_Verify(&aesKey, 
                                     pXmrBindInfo->m_pxmrLicense->pbSignedDataBuffer,
                                     pXmrBindInfo->m_pxmrLicense->iSignedData,
                                     pXmrBindInfo->m_pxmrLicense->cbSignedData,
                                     pXmrBindInfo->m_pxmrSignature->pbSignatureBuffer,
                                     pXmrBindInfo->m_pxmrSignature->iSignature );
            Oem_Aes_ZeroKey(&aesKey);
            ChkDR( dr );
        }
        else if( pXmrBindInfo->m_pxmrSignature->wType == XMR_SIGNATURE_TYPE_SHA_256_HMAC )
        {
            /* Post 2/2008 PlayReady licenses should never have this MAC */
            ChkBOOL( pXmrBindInfo->m_pxmrSignature->cbSignature == SHA256_DIGEST_SIZE_IN_BYTES,
                     DRM_E_INVALID_SIGNATURE );                    
        
            ChkDR( DRM_HMAC_VerifyMAC( eDRM_SHA_256, 
                                       rgbDecKeys,
                                       DRM_AES_KEYSIZE_128,
                                       pXmrBindInfo->m_pxmrLicense->pbSignedDataBuffer,
                                       pXmrBindInfo->m_pxmrLicense->iSignedData, 
                                       pXmrBindInfo->m_pxmrLicense->cbSignedData,                                                             
                                       pXmrBindInfo->m_pxmrSignature->pbSignatureBuffer,
                                       pXmrBindInfo->m_pxmrSignature->iSignature,
                                       pXmrBindInfo->m_pxmrSignature->cbSignature ) );
        }
        else
        {
            ChkDR( DRM_E_UNSUPPORTEDALGORITHM );
        }
   } /* end-for chainlen */

    /*
    ** Everything looks good, copy the decrypted content key
    */ 
    if ( f_fIncludeCIKey )
    {        
        if ( f_pBindingInfo[0].m_BindingInfo.m_XMR.m_pxmrContentKey->wSymmetricCipherType
          == XMR_SYMMETRIC_ENCRYPTION_TYPE_RC4_CIPHER )
        {
            /*
            ** Replace the size byte if we are returning the entire key buffer
            */  
            ChkBOOL( *f_pcbKey <= DRMCIPHERKEYLEN_RC4, DRM_E_LIC_KEY_DECODE_FAILURE );
            DRM_BYT_MoveBytes( rgbDecKeys, DRM_AES_KEYSIZE_128 + 1, rgbDecKeys, DRM_AES_KEYSIZE_128, *f_pcbKey );

//
// Xbox LIVE specific: disabling conversion warning (C4242) after review.
//
            #pragma warning( disable:4242 )
            PUT_BYTE( rgbDecKeys, DRM_AES_KEYSIZE_128, *f_pcbKey );
            #pragma warning( default:4242 )
//
// End Xbox LIVE specific
//
            *f_pcbKey += 1;            
        }
        *f_pcbKey += DRM_AES_KEYSIZE_128;
        ChkBOOL( *f_pcbKey <= f_cbKeyBuff, DRM_E_BUFFERTOOSMALL );              
        DRM_BYT_CopyBytes( f_pbKeyBuff,
                           0,
                           rgbDecKeys,
                           0,
                           *f_pcbKey ); 
    }
    else 
    {
        ChkBOOL( *f_pcbKey <= f_cbKeyBuff, DRM_E_BUFFERTOOSMALL );
        
        DRM_BYT_CopyBytes( f_pbKeyBuff,
                           0,
                           rgbDecKeys,
                           DRM_AES_KEYSIZE_128,
                           *f_pcbKey );
    }

    if ( f_pPrivKey != NULL )
    {
        MEMCPY( f_pPrivKey, &privKey, SIZEOF( PRIVKEY_P256 ) );
    }
    
ErrorExit:   
    OEM_SECURE_ZERO_MEMORY( &privKey, SIZEOF( PRIVKEY_P256 ) );
    OEM_SECURE_ZERO_MEMORY( rgbDecKeys, ECC_P256_PLAINTEXT_SIZE_IN_BYTES );    

    return dr;
}

/*********************************************************************
**
** Function: _GetDeviceECC256KeyPair
**
** Synopsis: Function that retrieves a device's ECC-256 key pair. One of
**           the output parameters may be NULL.
**
** Arguments:
**
** [f_poBBXContext]         -- Pointer to a DRM_BB_CONTEXT context.
** [f_poDevPubKey]          -- Pointer to a PUBKEY_P256 that is used to
**                             receive the device's ECC-256 public key.
**                             This parameter is optional.
** [f_poDevPrivKey]         -- Pointer to a PRIVKEY_P256 that is used to
**                             receive the device's ECC-256 private key.
**                             This parameter is optional.
** [f_eDevKeyUsage]         -- Key usage that defines which key pair to return.
**                             Device cert has two keys with Sign and Encrypt key usages
**                             (don't confuse this enum with key usages defined in drmbcert.h)
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
** Notes:                   None.
**
**********************************************************************/
static DRM_RESULT _GetDeviceECC256KeyPair(
    __in      DRM_BB_CONTEXT  *f_poBBXContext,
    __out_opt PUBKEY_P256     *f_poDevPubKey,
    __out_opt PRIVKEY_P256    *f_poDevPrivKey,
    __in      eDRM_BINARY_DEVICE_CERT_KEYUSAGE f_eDevKeyUsage 
)
{
    DRM_RESULT    dr          = DRM_SUCCESS;
    PRIVKEY_P256  GCPrivKey   = {0};
    DRM_DWORD     cbGCPrivKey = SIZEOF( PRIVKEY_P256 );

                        
    ChkArg( f_poBBXContext != NULL ); 
    ChkArg( f_poDevPubKey != NULL || f_poDevPrivKey != NULL );

    if ( f_poDevPubKey != NULL )
    {
        switch ( f_eDevKeyUsage )
        {
            case DRM_BINARY_DEVICE_CERT_KEY_SIGN:
                MEMCPY( f_poDevPubKey, 
                        &(f_poBBXContext->cachedBCertValues.DeviceKeySign.PublicKey), 
                        SIZEOF( PUBKEY_P256 ) );
                break;
            case DRM_BINARY_DEVICE_CERT_KEY_ENCRYPT:
                MEMCPY( f_poDevPubKey, 
                        &(f_poBBXContext->cachedBCertValues.DeviceKeyEncrypt.PublicKey), 
                        SIZEOF( PUBKEY_P256 ) );
                break;
            default:
                ChkDR( DRM_E_INVALIDARG );
                break;
        }
    }

    if ( f_poDevPrivKey != NULL )
    {
        ChkDR( Oem_Device_GetKey( f_poBBXContext->pOEMContext, 
                                   DRM_DKT_PLAYREADY_MODEL, 
                                   (DRM_BYTE *)&GCPrivKey, 
                                   &cbGCPrivKey ) );
        switch ( f_eDevKeyUsage )
        {
            case DRM_BINARY_DEVICE_CERT_KEY_SIGN:
                ChkDR( DRM_BBX_SymmetricCipher( FALSE,
                                                FALSE, 
                                                (DRM_BYTE *)&GCPrivKey, 
                                                SIZEOF( PRIVKEY_P256 ), 
                                                f_poBBXContext->cachedBCertValues.DeviceKeySign.rgbPrivateKey, 
                                                ( DRM_BYTE * )f_poDevPrivKey,
                                                SIZEOF( PRIVKEY_P256 ) ) );
                break;
            case DRM_BINARY_DEVICE_CERT_KEY_ENCRYPT:
                ChkDR( DRM_BBX_SymmetricCipher( FALSE,
                                                FALSE, 
                                                (DRM_BYTE *)&GCPrivKey, 
                                                SIZEOF( PRIVKEY_P256 ), 
                                                f_poBBXContext->cachedBCertValues.DeviceKeyEncrypt.rgbPrivateKey, 
                                                ( DRM_BYTE * )f_poDevPrivKey,
                                                SIZEOF( PRIVKEY_P256 ) ) );
                break;
            default:
                ChkDR( DRM_E_INVALIDARG );
                break;
        }
    }
    
ErrorExit:
    OEM_SECURE_ZERO_MEMORY( &GCPrivKey, SIZEOF( PRIVKEY_P256 ) );
    return dr;
}

/*********************************************************************
**
** Function: DRM_BBX_ECC256_AESCBC_Decrypt
**
** Synopsis: Function that does ECC-256 decryption on passed in session key,
**           then uses the session key to AES CBC decrypt the encrypted data
**           the first 16 bytes of the passed in data are used as IV. 
**
** Arguments:
**
** [f_poBBXContext]         -- Pointer to a DRM_BB_CONTEXT context.
** [f_pbEncryptedKey]       -- Pointer to a buffer that contains the
**                             encrypted key.
** [f_pcbENcryptedKey]      -- Resp. size of key. 
** [f_poECC256PubKey]       -- Pointer to a device ECC-256 public key whose
**                             matching device ECC-256 private key should be
**                             used to decrypt the passed in data.
**                             If its content is all 0, caller assumes to
**                             use the current device private key to decrypt
**                             the data without checking whether
**                             *f_poECC256PubKey is the same as the current
**                             device public key.
** [f_pbIV]                 -- Initialization Vector for AES CBC
** [f_pbData]               -- encrypted data. 
** [f_cbData]               -- Resp size.
**
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_CRYPTO_PUBLIC_KEY_NOT_MATCH if the
**                          passed in ECC-256 public key does not match any
**                          device public key.
**
** Note:                    The caller ensures the passed in buffer is big
**                          enough to receive the decrypted data.
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_BBX_ECC256_AESCBC_Decrypt(
    __inout_ecount( 1 )          DRM_BB_CONTEXT *f_poBBXContext,
    __in_bcount( f_cbEncryptedKey ) DRM_BYTE       *f_pbEncryptedKey, 
    __in                         DRM_DWORD       f_cbEncryptedKey, 
    __inout_ecount( 1 )          PUBKEY_P256    *f_poECC256PubKey, 
    __inout_bcount( DRM_AES_KEYSIZE_128 ) DRM_BYTE * f_pbIV, 
    __inout_bcount( f_cbData )   DRM_BYTE       *f_pbData,
    __in                         DRM_DWORD       f_cbData )
{
    DRM_RESULT dr = DRM_SUCCESS; 
    DRM_AES_KEY oAESKey = { 0 };
    DRM_DWORD cbKey = f_cbEncryptedKey; 
   
    ChkArg( f_pbData != NULL ); 
    ChkArg( f_cbData > 0 ); 
    ChkArg( f_pbIV != NULL ); 
    ChkArg( f_pbEncryptedKey != NULL ); 
    ChkArg( f_poBBXContext != NULL ); 

    ChkBOOL( f_cbEncryptedKey == ECC_P256_CIPHERTEXT_SIZE_IN_BYTES, DRM_E_XMLSIG_FORMAT );

    /*
    ** ECC-256 decrypt the AES key in place using the matching private key of
    ** the public key. 
    ** It assumes the size of the ECC-256 decrypted AES key can be contained in
    ** the original buffer, and the size of the ECC-256 decrypted AES key is
    ** equal or smaller than the size of the ECC-256 encrypted AES key.
    */
    ChkDR( DRM_BBX_ECC256_Decrypt( f_poBBXContext,
                                   f_pbEncryptedKey, 
                                   &cbKey,
                                   f_poECC256PubKey ) );

    ChkBOOL( cbKey == DRM_XML_AES_KEY_SIZE, DRM_E_XMLSIG_FORMAT );
    /*
    ** Use the decrypted result as a key. 
    */
    ChkDR( Oem_Aes_SetKey( &f_pbEncryptedKey[ DRM_AES_KEYSIZE_128 ], 
                           &oAESKey ) );

    /* 
    ** AES decrypt the cipher data.
    ** The first DRM_AES_KEYSIZE_128 bytes of pbCipherData is the IV.
    */
    ChkDR( DRM_Aes_CbcDecryptData( &oAESKey,
                                   f_pbData,
                                   f_cbData,
                                   f_pbIV ) );
ErrorExit:
    OEM_SECURE_ZERO_MEMORY( &oAESKey, SIZEOF(oAESKey) ); 

    return dr; 
}


/*********************************************************************
**
** Function: DRM_BBX_ECC256_Decrypt
**
** Synopsis: Function that does ECC-256 decryption of the passed in data
**           in place using the device's ECC-256 private key, whose matching
**           ECC-256 public key is the passed in ECC-256 public key.
**
** Arguments:
**
** [f_poBBXContext]         -- Pointer to a DRM_BB_CONTEXT context.
** [f_pbData]               -- Pointer to a buffer that contains the
**                             data to be decrypted. After the decryption,
**                             it contains the decrypted data.
** [f_pcbData]              -- Pointer to a variable that contains the size
**                             (number of bytes) of the buffer to be 
**                             decrypted. After the decryption, it receives
**                             the size (number of bytes) of the decrypted
**                             data.
** [f_poECC256PubKey]       -- Pointer to a device ECC-256 public key whose
**                             matching device ECC-256 private key should be
**                             used to decrypt the passed in data.
**                             If its content is all 0, caller assumes to
**                             use the current device private key to decrypt
**                             the data without checking whether
**                             *f_poECC256PubKey is the same as the current
**                             device public key.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_CRYPTO_PUBLIC_KEY_NOT_MATCH if the
**                          passed in ECC-256 public key does not match any
**                          device public key.
**
** Note:                    The caller ensures the passed in buffer is big
**                          enough to receive the decrypted data.
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_BBX_ECC256_Decrypt(
    __inout_ecount( 1 )          DRM_BB_CONTEXT *f_poBBXContext,
    __inout_bcount( *f_pcbData ) DRM_BYTE       *f_pbData,
    __inout_ecount( 1 )          DRM_DWORD      *f_pcbData,
    __inout_ecount( 1 )          PUBKEY_P256    *f_poECC256PubKey )
{
    DRM_RESULT      dr              = DRM_SUCCESS;
    PUBKEY_P256     oECC256PubKey   = { 0 };
    PRIVKEY_P256    oECC256PrivKey  = { 0 };
    PLAINTEXT_P256  oPlainText      = { 0 };
    CIPHERTEXT_P256 oCipherText     = { 0 };

    ChkArg( f_poBBXContext   != NULL );
    ChkArg( f_pbData         != NULL );
    ChkArg( f_pcbData        != NULL );
    ChkArg( *f_pcbData       == ECC_P256_CIPHERTEXT_SIZE_IN_BYTES );
    ChkArg( f_poECC256PubKey != NULL );  

    ChkDR( _GetDeviceECC256KeyPair( f_poBBXContext,
                                    &oECC256PubKey,
                                    &oECC256PrivKey,
                                    DRM_BINARY_DEVICE_CERT_KEY_ENCRYPT ) );

    if ( MEMCMP( f_poECC256PubKey,
                 &oECC256PubKey,
                 SIZEOF( PUBKEY_P256 ) ) != 0 )
    {
        ZEROMEM( &oECC256PubKey, SIZEOF( PUBKEY_P256 ) );
        
        /* Check whether the input public key contains all 0. */
        if ( MEMCMP( f_poECC256PubKey,
             &oECC256PubKey,
             sizeof( PUBKEY_P256 ) ) != 0 )
        {
            /*
            ** The public key associated with an encrypted domain private key from
            ** the server does not match any public key on the device.
            */
            ChkDR( DRM_E_CRYPTO_PUBLIC_KEY_NOT_MATCH );
        }
    }

    ZEROMEM( &oPlainText, SIZEOF( PLAINTEXT_P256 ) );
    ZEROMEM( &oCipherText, SIZEOF( CIPHERTEXT_P256 ) );

    MEMCPY( oCipherText.m_rgbCiphertext, f_pbData, *f_pcbData );

    ChkDR( DRM_ECC_Decrypt_P256( &oECC256PrivKey,
                                 &oCipherText,
                                 &oPlainText,
                                 (struct bigctx_t *)f_poBBXContext->CryptoContext.rgbCryptoContext ) );

    MEMCPY( f_pbData, oPlainText.m_rgbPlaintext, ECC_P256_PLAINTEXT_SIZE_IN_BYTES );

    *f_pcbData = ECC_P256_PLAINTEXT_SIZE_IN_BYTES;
    
    /* Zero the temoprary decoded buffer to avoid leaking secrets in the heap. */
    OEM_SECURE_ZERO_MEMORY( &oPlainText, SIZEOF( PLAINTEXT_P256 ) );
             
ErrorExit:
    
    OEM_SECURE_ZERO_MEMORY( &oECC256PrivKey, SIZEOF( PRIVKEY_P256 ) );

    OEM_SECURE_ZERO_MEMORY( &oECC256PubKey, SIZEOF( PUBKEY_P256 ) );
     
    return dr;
}

/*********************************************************************
**
** Function: DRM_BBX_ECC256_Sign
**
** Synopsis: Function that generates an ECC-256 signature of the passed in
**           data. It also returns an ECC-256 public key used to verify
**           the generated ECC-256 signature.
**
** Arguments:
**
** [f_poBBXContext]         -- Pointer to a DRM_BB_CONTEXT context.
** [f_pbData]               -- Pointer to a data buffer for which
**                             ECC-256 signature is generated.
** [f_cbData]               -- Size (number of bytes) of a data buffer 
**                             for which ECC-256 signature is generated.
** [f_poECC256PubKey]       -- Pointer to receive an ECC-256 public key
**                             whose matching ECC-256 private key is used
**                             to create the signature. The public key
**                             can be used to verify the signature
**                             generated in this function.
** [f_rgbECC256Signature]   -- Pointer to a buffer that receives a generated
**                             ECC-256 signature.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_BBX_ECC256_Sign(
    __inout_ecount( 1 )                                DRM_BB_CONTEXT *f_poBBXContext,
    __inout_bcount( f_cbData )                         DRM_BYTE       *f_pbData,
    __in                                               DRM_DWORD       f_cbData,
    __inout_ecount( 1 )                                PUBKEY_P256    *f_poECC256PubKey,
    __out_bcount( ECDSA_P256_SIGNATURE_SIZE_IN_BYTES ) DRM_BYTE        f_rgbECC256Signature[ __CB_DECL( ECDSA_P256_SIGNATURE_SIZE_IN_BYTES ) ] )
{
    DRM_RESULT     dr               = DRM_SUCCESS;
    PRIVKEY_P256   oECC256PrivKey   = { 0 };
    SIGNATURE_P256 oECC256Signature = { 0 };

    ChkArg( f_poBBXContext != NULL );
    ChkArg( f_poBBXContext->fInited );
    ChkArg( f_pbData != NULL );
    ChkArg( f_cbData > 0 );
    ChkArg( f_poECC256PubKey != NULL );
    ChkArg( f_rgbECC256Signature != NULL );
           
    ZEROMEM( f_poECC256PubKey, SIZEOF( PUBKEY_P256 ) );
    
    ZEROMEM( f_rgbECC256Signature, ECDSA_P256_SIGNATURE_SIZE_IN_BYTES );
    
    ChkDR( _GetDeviceECC256KeyPair( f_poBBXContext,
                                    f_poECC256PubKey,
                                    &oECC256PrivKey,
                                    DRM_BINARY_DEVICE_CERT_KEY_SIGN ) );

    ChkDR( DRM_ECDSA_Sign_P256( f_pbData,
                                f_cbData,
                                &oECC256PrivKey,
                                &oECC256Signature,
                                (struct bigctx_t *)f_poBBXContext->CryptoContext.rgbCryptoContext ) );

    MEMCPY( f_rgbECC256Signature,
            oECC256Signature.m_rgbSignature,
            ECDSA_P256_SIGNATURE_SIZE_IN_BYTES );

ErrorExit:

    OEM_SECURE_ZERO_MEMORY( &oECC256PrivKey, SIZEOF( PRIVKEY_P256 ) );

    return dr;
}


/*********************************************************************
 *
** Function: DRM_BBX_StoreDomainPrivateKeys
**
** Synopsis: 
**           Parse the domain key XMR data and store domain private 
**           keys in the store
**
** Arguments:
**  [f_poBBXContext]            -- Pointer to a DRM_BB_CONTEXT context.
**  [f_poDomainStoreContext]    -- Pointer to a DRM_DOMAINSTORE_CONTEXT
**                                 context.
**  [f_pbData]                  -- Pointer to a DRM_BYTE buffer that 
**                                 contains the domain key XMR data
**  [f_cbData]                  -- The size of the XMR data
**  [f_poDomainID]              -- Pointer to a DRM_DOMAIN_ID struct
**  [f_poECC256PubKey]          -- Pointer to the ECC256 Public Key that 
**                                 is used to encrypt the AES session 
**                                 key
**  [f_pdastrCertificate]       -- Pointer a DRM_ANSI_STRING that holds 
**                                 the domain certificate
** 
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
** 
**********************************************************************/

DRM_API DRM_RESULT DRM_CALL DRM_BBX_StoreDomainPrivateKeys(
    __inout_ecount( 1 )                 DRM_BB_CONTEXT *f_poBBXContext,
    __inout_ecount( 1 )                 DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    __inout_bcount( f_cbData )          DRM_BYTE *f_pbData,
    __in                                DRM_DWORD f_cbData,
    __inout_ecount( 1 )                 DRM_DOMAIN_ID *f_poDomainID,
    __in_ecount( 1 )                    PUBKEY_P256 *f_poECC256PubKey,
    __in_ecount( 1 )                    DRM_ANSI_STRING *f_pdastrCertificate )
{
    DRM_RESULT                          dr                      = DRM_SUCCESS;
    DRM_DOMKEYXMR_HEADER                oXMRHeader              = {0};
    DRM_DOMKEYXMR_SESSIONKEY            oXMRSessionKey          = {0};
    DRM_DOMKEYXMR_PRIVKEYCONTAINER      oXMRPrivKeyContainer    = {0};
    DRM_DOMKEYXMR_PRIVKEY               oXMRDomainPrivKey       = {0}; 
    PRIVKEY_P256                        oDomainPrivKeyDecrypted = {0};
    PRIVKEY_P256                        oDomainPrivKeyEncrypted = {0};
    DRM_BYTE                            rgbAESSessionKeys[ECC_P256_CIPHERTEXT_SIZE_IN_BYTES]  = {0};
    DRM_AES_KEY                         oAESKeyCI               = {0};
    DRM_AES_KEY                         oAESKeyCK               = {0};
    DRM_DWORD                           bCurrOffset             = 0;
    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BLACKBOX, PERF_FUNC_DRM_BBX_StoreDomainPrivateKeys );

    ChkArg( f_poBBXContext != NULL );
    ChkArg( f_poDomainStoreContext != NULL );
    ChkArg( f_pbData != NULL );
    ChkArg( f_cbData > 0 );  // should this be the minumu data length
    ChkArg( f_poDomainID != NULL );
    ChkArg( f_poECC256PubKey != NULL );
    ChkDRMANSIString( f_pdastrCertificate );

    /* get domain key xmr header */
    ChkDR( DRM_DOMKEYXMR_GetHeader(f_pbData, f_cbData, &bCurrOffset, &oXMRHeader) );
    ChkBOOL( oXMRHeader.dwConstant == DRM_DOMKEYXMR_HEADER_CONSTANT, DRM_E_DOMAIN_INVALID_DOMKEYXMR_DATA );
    ChkBOOL( oXMRHeader.dwVersion  == DRM_DOMKEYXMR_HEADER_VERSION,  DRM_E_DOMAIN_INVALID_DOMKEYXMR_DATA );
    ChkBOOL( bCurrOffset <= f_cbData, DRM_E_DOMAIN_INVALID_DOMKEYXMR_DATA );

    /* get domain key xmr session key */
    ChkDR( DRM_DOMKEYXMR_GetSessionKey( f_pbData, f_cbData, &bCurrOffset, &oXMRSessionKey ) );
    ChkBOOL( oXMRSessionKey.wType           == DRM_DOMKEYXMR_OBJTYPE_SESSIOINKEY,   DRM_E_DOMAIN_INVALID_DOMKEYXMR_DATA );
    ChkBOOL( oXMRSessionKey.wEncryptionType == DRM_DOMKEYXMR_SESSIONKEY_ENCTYPE_ECCP256, DRM_E_DOMAIN_INVALID_DOMKEYXMR_DATA );
    ChkBOOL( oXMRSessionKey.dwKeyLength     == ECC_P256_CIPHERTEXT_SIZE_IN_BYTES, DRM_E_DOMAIN_INVALID_DOMKEYXMR_DATA );
    ChkBOOL( bCurrOffset <= f_cbData, DRM_E_DOMAIN_INVALID_DOMKEYXMR_DATA );
    

    /* get domain key xmr privkey container */
    ChkDR( DRM_DOMKEYXMR_GetPrivKeyContainer(f_pbData, f_cbData, &bCurrOffset, &oXMRPrivKeyContainer ) );
    ChkBOOL( oXMRPrivKeyContainer.wType     == DRM_DOMKEYXMR_OBJTYPE_PRIVKEYCONTAINER, DRM_E_DOMAIN_INVALID_DOMKEYXMR_DATA );
    ChkBOOL( bCurrOffset <= f_cbData, DRM_E_DOMAIN_INVALID_DOMKEYXMR_DATA );

    MEMCPY(rgbAESSessionKeys, oXMRSessionKey.pbData, ECC_P256_CIPHERTEXT_SIZE_IN_BYTES ); 

    /* Decrypt AES session keys to get 2 AES session keys { CI|CK } */
    ChkDR(DRM_BBX_ECC256_Decrypt( f_poBBXContext,
                                 (DRM_BYTE*) rgbAESSessionKeys,
                                  &oXMRSessionKey.dwKeyLength,  
                                  f_poECC256PubKey ) );

    ChkDR( Oem_Aes_SetKey((DRM_BYTE*) rgbAESSessionKeys, &oAESKeyCI) ); 
    ChkDR( Oem_Aes_SetKey((DRM_BYTE*) rgbAESSessionKeys+DRM_AES_KEYSIZE_128, &oAESKeyCK) ); 

    dr = DRM_DOMST_DeleteCert( f_poDomainStoreContext, &f_poDomainID->m_oAccountID );
    if (DRM_E_DOMAIN_STORE_DELETE_DATA == dr)
    {
        /* It is okay if we couldn't find the cert to delete, this may be the first time we
           have joined this domain.
           */
        dr = DRM_SUCCESS;
    }
    ChkDR( dr );

    ChkDR( DRM_DOMST_AddCert( f_poDomainStoreContext,
                             &f_poDomainID->m_oAccountID,
                             &f_poDomainID->m_oServiceID,
                              PB_DASTR( f_pdastrCertificate ),
                              CB_DASTR( f_pdastrCertificate ) ) );

    while( bCurrOffset + DRM_DOMKEYXMR_PRIVKEYOBJ_MIN_LENGTH < f_cbData )
    {
        ChkDR( DRM_DOMKEYXMR_GetPrivkey( f_pbData, f_cbData, &bCurrOffset, &oXMRDomainPrivKey ) );
        ChkBOOL( oXMRDomainPrivKey.wType == DRM_DOMKEYXMR_OBJTYPE_PRIVKEY,  DRM_E_DOMAIN_INVALID_DOMKEYXMR_DATA );
        ChkBOOL( oXMRDomainPrivKey.wKeyType == DRM_DOMKEYXMR_PRIVKEY_TYPE_ECCP256, DRM_E_DOMAIN_INVALID_DOMKEYXMR_DATA );
        ChkBOOL( oXMRDomainPrivKey.dwKeyLength == ECC_P256_PRIVKEY_SIZE_IN_BYTES , DRM_E_DOMAIN_INVALID_DOMKEYXMR_DATA );
        ChkBOOL( oXMRDomainPrivKey.wEncryptionType == DRM_DOMKEYXMR_PRIVKEY_ENCTYPE_MIXED_AESECB, DRM_E_DOMAIN_INVALID_DOMKEYXMR_DATA );
        ChkBOOL( oXMRDomainPrivKey.dwKeyLength == ECC_P256_PRIVKEY_SIZE_IN_BYTES, DRM_E_DOMAIN_INVALID_DOMKEYXMR_DATA );
        ChkBOOL( bCurrOffset <= f_cbData, DRM_E_DOMAIN_INVALID_DOMKEYXMR_DATA );

        MEMCPY(&oDomainPrivKeyDecrypted, oXMRDomainPrivKey.pbData, ECC_P256_PRIVKEY_SIZE_IN_BYTES);

        f_poDomainID->m_dwRevision = oXMRDomainPrivKey.dwRevision;

        ChkDR(DRM_Aes_EcbDecryptData(&oAESKeyCI,
                                     (DRM_BYTE*) &oDomainPrivKeyDecrypted,
                                     DRM_AES_KEYSIZE_128) );
        
        ChkDR(DRM_Aes_EcbDecryptData(&oAESKeyCK,
                                     (DRM_BYTE*)&oDomainPrivKeyDecrypted + __CB_DECL(DRM_AES_KEYSIZE_128),
                                     DRM_AES_KEYSIZE_128) );

        ChkDR( DRM_BBX_SymmetricBind( f_poBBXContext,
                                      TRUE,
                                      FALSE,
                                     (DRM_BYTE*) &oDomainPrivKeyDecrypted,
                                     (DRM_BYTE*) &oDomainPrivKeyEncrypted,
                                     SIZEOF( PRIVKEY_P256 ) ) );

        dr =   DRM_DOMST_DeleteKey( f_poDomainStoreContext, 
                                   &f_poDomainID->m_oAccountID,
                                   f_poDomainID->m_dwRevision );
        if (DRM_E_DOMAIN_STORE_DELETE_DATA == dr)
        {
            /* It is okay if we couldn't find the key to delete, this may be the first time we
               have seen this revision value.
               */
            dr = DRM_SUCCESS;
        }
        ChkDR( dr );

        ChkDR( DRM_DOMST_AddKey( f_poDomainStoreContext,
                                &f_poDomainID->m_oAccountID,
                                 f_poDomainID->m_dwRevision,
                                 (DRM_BYTE *) &oDomainPrivKeyEncrypted,
                                 SIZEOF( PRIVKEY_P256 ) ) );

    }

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    OEM_SECURE_ZERO_MEMORY( &oDomainPrivKeyDecrypted, SIZEOF( PRIVKEY_P256 ) );
    OEM_SECURE_ZERO_MEMORY( &oDomainPrivKeyEncrypted, SIZEOF( PRIVKEY_P256 ) );
    OEM_SECURE_ZERO_MEMORY( rgbAESSessionKeys, SIZEOF( rgbAESSessionKeys ) ) ;
    OEM_SECURE_ZERO_MEMORY( &oAESKeyCI, SIZEOF( DRM_AES_KEY ) ) ;
    OEM_SECURE_ZERO_MEMORY( &oAESKeyCK, SIZEOF( DRM_AES_KEY ) ) ;
    return dr;

}
EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\deskey.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmdes.h>
#include <byteorder.h>
#include "sel.h"
#include "spb.h"

ENTER_PK_NAMESPACE_CODE;

/* Compress bit flags into a WORD as there are 16 of them
   {0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0} = 0x3F7E */
static const DRM_WORD double_shift = 0x3F7E;

#define PERM_OP(a,b,t,n,m) ((t)=((((a)>>(n))^(b))&(m)),\
    (b)^=(t),\
    (a)^=((t)<<(n)))

#define HPERM_OP(a,t,n,m) ((t)=((((a)<<(16-(n)))^(a))&(m)),\
    (a)=(a)^(t)^(t>>(16-(n))))


/******************************************************************************/
DRM_API DRM_VOID DRM_CALL DRM_DES_KeySetup(
    OUT       DESTable *pTable,
    __in_bcount( DES_KEYSIZE ) const DRM_BYTE  rgbKey[__CB_DECL(DES_KEYSIZE)] )
{
    DRM_DWORD csel,
              dsel,
              t,
              s,
              i;
    
    DRM_DWORD *kp = (DRM_DWORD *)pTable;

    BYTES_TO_DWORD(csel, rgbKey);
    BYTES_TO_DWORD(dsel, rgbKey + __CB_DECL(SIZEOF(DRM_DWORD)) );

    PERM_OP (dsel,csel,t,4,0x0f0f0f0f);
    dsel = dsel & 0xFFFFFFFF;
    csel = csel & 0xFFFFFFFF;
    t    = t    & 0xFFFFFFFF;
    HPERM_OP(csel,t,-2,0xcccc0000);
    csel = csel & 0xFFFFFFFF;
    t    = t    & 0xFFFFFFFF;
    HPERM_OP(dsel,t,-2,0xcccc0000);
    csel = csel & 0xFFFFFFFF;
    t    = t    & 0xFFFFFFFF;
    PERM_OP (dsel,csel,t,1,0x55555555);
    dsel = dsel & 0xFFFFFFFF;
    csel = csel & 0xFFFFFFFF;
    t    = t    & 0xFFFFFFFF;
    PERM_OP (csel,dsel,t,8,0x00ff00ff);
    dsel = dsel & 0xFFFFFFFF;
    csel = csel & 0xFFFFFFFF;
    t    = t    & 0xFFFFFFFF;
    PERM_OP (dsel,csel,t,1,0x55555555);
    dsel = dsel & 0xFFFFFFFF;
    csel = csel & 0xFFFFFFFF;
    t    = t    & 0xFFFFFFFF;

    dsel=  (((dsel & 0x000000ff) << 16) | (dsel & 0x0000ff00)    |
            ((dsel & 0x00ff0000) >> 16) | ((csel & 0xf0000000)>>4));
    csel &= 0x0fffffff;

    for(i = 0; i < 16; i++)
    {
        DRM_DWORD temp;

        if(double_shift & (1 << (15 - i)))
        {
            csel = ((csel >> 2) | (csel << 26));
            dsel = ((dsel >> 2) | (dsel << 26));
        }
        else
        {
            csel = ((csel >> 1) | (csel << 27));
            dsel = ((dsel >> 1) | (dsel << 27));
        }

        csel &= 0x0fffffff;
        dsel &= 0x0fffffff;

        s =  _DRM_Sel[0][ (csel      )&0x3f                ];
        s |= _DRM_Sel[1][((csel >>  6)&0x03) | ((csel >>  7)&0x3c)];
        s |= _DRM_Sel[2][((csel >> 13)&0x0f) | ((csel >> 14)&0x30)];
        s |= _DRM_Sel[3][((csel >> 20)&0x01) | ((csel >> 21)&0x06)|((csel >> 22)&0x38)];
        t =  _DRM_Sel[4][ (dsel      )&0x3f                ];
        t |= _DRM_Sel[5][((dsel >>  7)&0x03) | ((dsel >>  8)&0x3c)];
        t |= _DRM_Sel[6][ (dsel >> 15)&0x3f                ];
        t |= _DRM_Sel[7][((dsel >> 21)&0x0f) | ((dsel >> 22)&0x30)];

        temp = ((t << 16) | (s & 0x0000ffff)) ;
        temp = temp & 0xFFFFFFFF;
        *(kp++) = ROTATE_LEFT(temp, 2) &0xFFFFFFFF;

        temp = ((s >> 16) | (t & 0xffff0000));
        temp = temp & 0xFFFFFFFF;
        *(kp++) = ROTATE_LEFT(temp, 6) & 0xFFFFFFFF;
    }
}


/******************************************************************************/

/* Primitive function F.
 * Input is r, subkey array in keys, output is XORed into l.
 * Each round consumes eight 6-bit subkeys, one for
 * each of the 8 S-boxes, 2 longs for each round.
 * Each long contains four 6-bit subkeys, each taking up a byte.
 * The first long contains, from high to low end, the subkeys for
 * S-boxes 1, 3, 5 & 7; the second contains the subkeys for S-boxes
 * 2, 4, 6 & 8 (using the origin-1 S-box numbering in the standard,
 * not the origin-0 numbering used elsewhere in this code)
 * See comments elsewhere about the pre-rotated values of r and Spbox.
 */


#define F(l,r,S) { \
    work = ((DRM_DWORD *)pTable)[S  ]; \
    zork = ((DRM_DWORD *)pTable)[S+1];  \
    work ^= r; \
    zork ^= r; \
    zork = ROTATE_RIGHT(zork, 4); \
    l ^= *(DRM_DWORD *)((DRM_BYTE*)_DRM_Spbox[0] + __CB_DECL((work      & 0xfc))); \
    l ^= *(DRM_DWORD *)((DRM_BYTE*)_DRM_Spbox[1] + __CB_DECL((zork      & 0xfc))); \
    l ^= *(DRM_DWORD *)((DRM_BYTE*)_DRM_Spbox[2] + __CB_DECL(((work>> 8)& 0xfc))); \
    l ^= *(DRM_DWORD *)((DRM_BYTE*)_DRM_Spbox[3] + __CB_DECL(((zork>> 8)& 0xfc))); \
    l ^= *(DRM_DWORD *)((DRM_BYTE*)_DRM_Spbox[4] + __CB_DECL(((work>>16)& 0xfc))); \
    l ^= *(DRM_DWORD *)((DRM_BYTE*)_DRM_Spbox[5] + __CB_DECL(((zork>>16)& 0xfc))); \
    l ^= *(DRM_DWORD *)((DRM_BYTE*)_DRM_Spbox[6] + __CB_DECL(((work>>24)& 0xfc))); \
    l ^= *(DRM_DWORD *)((DRM_BYTE*)_DRM_Spbox[7] + __CB_DECL(((zork>>24)& 0xfc))); }


/******************************************************************************/
/* Encrypt or decrypt a block of data in ECB mode */
DRM_API DRM_VOID DRM_CALL DRM_DES_Cipher(
    __in_bcount( DES_BLOCKLEN ) const DRM_BYTE  rgbIn [__CB_DECL(DES_BLOCKLEN)],
    __out_bcount( DES_BLOCKLEN ) DRM_BYTE  rgbOut[__CB_DECL(DES_BLOCKLEN)],
          DESTable *pTable,
          DRM_INT   op)
{
    DRM_DWORD left, 
              work, 
              right, 
              zork;

    /* Read input block and place in left, right */
    BYTES_TO_DWORD( right, rgbIn);
    BYTES_TO_DWORD( left,  rgbIn + __CB_DECL(SIZEOF(DRM_DWORD)) );

    /* Hoey's clever initial permutation algorithm, from Outerbridge
     * (see Schneier p 478)
     *
     * The convention here is the same as Outerbridge: rotate each
     * register left by 1 bit, i.e., so that "left" contains permuted
     * input bits 2, 3, 4, ... 1 and "right" contains 33, 34, 35, ... 32
     * (using origin-1 numbering as in the FIPS). This allows us to avoid
     * one of the two rotates that would otherwise be required in each of
     * the 16 rounds.
     */

    right = ROTATE_LEFT(right, 4) & 0xFFFFFFFF;
    work = right;
    right ^= left;
    right &= 0xf0f0f0f0;
    work ^= right;
    left ^= right;

    left = ROTATE_LEFT(left, 20) & 0xFFFFFFFF;
    right = work;
    work ^= left;
    work &= 0xfff0000f;
    right ^= work;
    left ^= work;

    left = ROTATE_LEFT(left,14) &0xFFFFFFFF;
    work = right;
    right ^= left;
    right &= 0x33333333;
    work ^= right;
    left ^= right;

    work = ROTATE_LEFT(work, 22) & 0xFFFFFFFF;
    right = work;
    work ^= left;
    work &= 0x03fc03fc;
    right ^= work;
    left ^= work;

    right = ROTATE_LEFT(right, 9) & 0xFFFFFFFF;
    work = right;
    right ^= left;
    right &= 0xaaaaaaaa;
    work ^= right;
    left ^= right;

    left = ROTATE_LEFT(left, 1) & 0xFFFFFFFF;
    right = work;


    /* Now do the 16 rounds */
    if(op == DES_DECRYPT)
    {
        F(left, right, 30);
        F(right, left, 28);
        F(left, right, 26);
        F(right, left, 24);
        F(left, right, 22);
        F(right, left, 20);
        F(left, right, 18);
        F(right, left, 16);
        F(left, right, 14);
        F(right, left, 12);
        F(left, right, 10);
        F(right, left, 8);
        F(left, right, 6);
        F(right, left, 4);
        F(left, right, 2);
        F(right, left, 0);

    }
    else
    {
        F(left, right, 0);
        F(right, left, 2);
        F(left, right, 4);
        F(right, left, 6);
        F(left, right, 8);
        F(right, left, 10);
        F(left, right, 12);
        F(right, left, 14);
        F(left, right, 16);
        F(right, left, 18);
        F(left, right, 20);
        F(right, left, 22);
        F(left, right, 24);
        F(right, left, 26);
        F(left, right, 28);
        F(right, left, 30);
    }


    /* Inverse permutation, also from Hoey via Outerbridge and Schneier */

    right = ROTATE_RIGHT(right, 1)& 0xFFFFFFFF;
    work = left;
    work ^= right;
    work &= 0xaaaaaaaa;
    right ^= work;
    left ^= work;

    left = ROTATE_RIGHT(left, 9)& 0xFFFFFFFF;
    work = right;
    right ^= left;
    right &= 0x03fc03fc;
    work ^= right;
    left ^= right;

    left = ROTATE_RIGHT(left, 22)& 0xFFFFFFFF;
    right = work;
    work ^= left;
    work &= 0x33333333;
    right ^= work;
    left ^= work;

    right = ROTATE_RIGHT(right, 14) & 0xFFFFFFFF;
    work = right;
    right ^= left;
    right &= 0xfff0000f;
    work ^= right;
    left ^= right;

    work = ROTATE_RIGHT(work, 20) &0xFFFFFFFF;
    right = work;
    work ^= left;
    work &= 0xf0f0f0f0;
    right ^= work;
    left ^= work;

    left = ROTATE_RIGHT(left, 4)& 0xFFFFFFFF;

    /* Put the block back into the user's buffer with final swap */
    DWORD_TO_BYTES(rgbOut, left);
    DWORD_TO_BYTES(rgbOut+__CB_DECL(SIZEOF(DRM_DWORD)), right);
}

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\digitogcd.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include "bignum.h"

ENTER_PK_NAMESPACE_CODE;

/*
      File digit_ogcd.c.   Version 06 October 2002.
*/
/***************************************************************************/
DRM_BOOL DRM_CALL digit_ogcd(const digit_t d1, const digit_t d2, digit_t *pgcd)
/*
        Return *pgcd = GCD(d1, d2), where at least one of d1, d2 is odd.
*/
{
    static const DRM_BYTE trailing_zeros[16]
            = {4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0};
#define extract_odd_part(n) do {n >>= trailing_zeros[n & 15];} while ((n&1)==0)

    digit_t n1 = d1, n2 = d2;
    DRM_BOOL OK = TRUE;

    if (IS_EVEN(n1|n2)) {  // Both even
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "digit_ogcd");
    } else if  (n1 == 0 || n2 == 0) {
        n1 = n1 + n2;    // Return GCD(n1, n2) = n1 + n2
    } else {
        extract_odd_part(n1);  extract_odd_part(n2);

        while (n1 != n2) {
            const DRM_INT sh1 = 1 + trailing_zeros[((n1 ^ n2) >> 1) & 15];
                                                      // Lower bound
            const digit_t n12max = MAX(n1, n2);  // Hope compiler avoids
                                            // branch misprediction
            n1 = (n1 ^ n2) ^ n12max;        // MIN(old n1, old n2)
            n2 = (n12max - n1) >> sh1;      // Remove some zeros from
                                            //    abs((old n1) - (old n2))
            extract_odd_part(n2);
            //assert (n1 & n2 & 1);           // Both odd
        }
    }
    if (OK) *pgcd = n1;
    return OK;
} /* digit_ogcd */

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\divide.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "bignum.h"

ENTER_PK_NAMESPACE_CODE;


/*
        File divide.c  Version 02 November 2002.


        This file has five routines:

        DRM_BOOL div21(db, d, &q, &r) --
                                        Divide DRM_UINT64 db by d,
                                        where db < d*RADIX (so that
                                        0 <= quotient < RADIX).
                                        The quotient is stored in q,
                                        and the remainder in r.

        DRM_BOOL div21_fast(db, d, &recip, &q, &r)--
                                        Similar to div21,
                                        but useful when dividing by
                                        the same denominator
                                        repeatedly.  The recip
                                        argument (of type reciprocal_1_t)
                                        must have been initialized
                                        by divide_precondition_1.
                                        The algorithm uses two
                                        multiplications
                                        (top and bottom halves of each)
                                        and several additions/subtractions.

        DRM_BOOL divide(numer, lnum, denom, lden, &recip,
                    quot, rem, plrem, struct bigctx_t *f_pBigCtx) --
                                        Divide numer (of length lnum)
                                        by denom (of length lden).
                                        Quotient
                                        (of length MAX(lnum - lden + 1 ,0))
                                        goes to quot and
                                        remainder (length lden) to rem.
                                        recip can be a reciprocal_1_t
                                        struct for the denominator,
                                        or NULL.

        DRM_BOOL divide_immediate(numer, den, &recip,
                              quot, lng, prem) --
                                        Divide numer (of length lng)
                                        by den (of length 1);
                                        quotient goes to quot
                                        and remainder to *prem.
                                        recip can be the reciprocal_1_t
                                        struct for the denominator,
                                        or NULL.

        DRM_BOOL divide_precondition_1(denom, lng, &reciprocal)
                                        Initialize a reciprocal_1_t
                                        struct for div21_fast or
                                        divide or divide_immediate.        

        The div21 code is slow but assumes only ANSI C.


                Some architectures (e.g., Intel 386, Power PC,
        Motorola 68020, 32-bit SPARC version 8)
        have a hardware instruction to divide a double-length integer
        by a single-length integer.  On such machines,
        the translation of div21 into assembly code
        is straightforward (although we may need to compute
        the remainder via a multiplication and subtraction).
        Other architectures (e.g., MIPS, 64-bit SPARC version 9)
        have an integer division instruction but allow only
        single-length numerator and denominator.
        Still other architectures (e.g., Alpha, IA-64)
        lack an integer divide instruction.
        On the latter architectures, the div21_fast algorithm is attractive.
        Even when there is a hardware instruction which functions
        like div21, the alternative code is attractive if
        division is much slower than multiplication.

                The div21_fast algorithm resembles that on p. 68 of

                        Torjborn Granlund and Peter L. Montgomery,
                        Division by Invariant Integers using Multiplication,
                        pp. 61-72 of Proceedings of SIGPLAN '94 Conference on
                        Programming Language Design and Implementation (PLDI),
                        ACM Press, 1994.

                Let DBOUND = RADIX be a strict upper bound on the divisor.
        and QBOUND = RADIX be a strict upper bound on the quotient.
        These should be powers of 2, with QBOUND dividing DBOUND.
        (The multiple-precision modular reduction
        analogue of this algorithm uses DBOUND = QBOUND^2.)
        Suppose we want to divide repeatedly by d, where 0 < d < DBOUND.
        Start by computing three constants dependent only on d:

                shiftamt = LOG2(DBOUND) - 1 - FLOOR(LOG2(d))
                dnorm = d * 2^shiftamt      // Normalized divisor
                multiplier = FLOOR((DBOUND*QBOUND - 1)/dnorm) - QBOUND

        Also define k = QBOUND*DBOUND - (multiplier + QBOUND)*dnorm.
        These satisfy

                DBOUND/2 <= dnorm < DBOUND
                0 <= multiplier < QBOUND
                0 < k <= dnorm

                Later, given n with 0 <= n <= d*QBOUND - 1,
        do the following computations:

                qprod, nshifted hold values in [0, QBOUND*DBOUND - 1]
                remest holds values in [1-DBOUND, DBOUND-1]
                qest, nshiftedhi hold values in [0, QBOUND - 1]

                nshifted   = n * 2^shiftamt;
                nshiftedhi = FLOOR(nshifted/DBOUND);
                nshiftedlo = (nshifted mod DBOUND);

                adjust = (top bit of nshiftedlo)*FLOOR(multiplier/2);
                qprod =   nshifted
                        + (multiplier*nshiftedhi + adjust)*DBOUND/QBOUND;
                qest = FLOOR(qprod/DBOUND);
                remest = n - qest*d - d;
                if (remest < 0) then
                    quotient is qest, remainder is remest + d
                else
                    quotient is qest+1, remainder is remest
                end if

        We claim that the correct quotient is either qest or qest + 1.
        We achieve this by proving

(*)            0 <= nshifted/dnorm - qprod/DBOUND < 1.

        Add this to qest <= qprod/DBOUND < qest + 1
        and use nshifted/dnorm = n/d to prove

                qest <= n/d < qest + 2.

        Therefore FLOOR(n/d) is either qest or qest + 1.

                Inequality (a) will be useful later:

  (a)     0 <= multiplier*nshiftedlo/DBOUND - adjust
            <  (multiplier + 1)/2
             = (QBOUND*DBOUND - k - QBOUND*dnorm + dnorm)/(2*dnorm)

        The proof of (a) has two cases:

                Case 1:  0 <= nshiftedlo < DBOUND/2 and adjust = 0;

                Case 2:  DBOUND/2 <= nshiftedlo < DBOUND
                         and adjust = FLOOR(multiplier/2).

        Each case is straightforward.

                Next check that

               qprod*QBOUND
             = nshifted*QBOUND + (multiplier*nshiftedhi + adjust)*DBOUND
             =   nshifted*QBOUND
               + multiplier*(nshifted - nshiftedlo) + adjust*DBOUND
             =   nshifted * (multiplier + QBOUND)
               - (multiplier*nshiftedlo - adjust*DBOUND)
             =   nshifted * (QBOUND * DBOUND - k)/dnorm
               - (multiplier*nshiftedlo - adjust*DBOUND)   .

        Multiply this by dnorm/DBOUND to get

                 QBOUND*(nshifted - qprod*dnorm/DBOUND)
             =   QBOUND*nshifted
               - nshifted*(QBOUND*DBOUND - k)/DBOUND
               + dnorm*(multiplier*nshiftedlo - adjust*DBOUND)/DBOUND
             =   nshifted*k/DBOUND
               + dnorm*(multiplier*nshiftedlo/DBOUND - adjust) .

        By (a), the right side above is nonnegative,
        which proves the left inequality in (*).
        Using nshifted < QBOUND*dnorm and (a),
        we can bound the right side above by

        QBOUND*(nshifted - qprod*dnorm/DBOUND)
      = nshifted*k/DBOUND + dnorm*(multiplier*nshiftedlo/DBOUND - adjust)
     <  QBOUND*dnorm*k/DBOUND + (QBOUND*DBOUND - k - QBOUND*dnorm + dnorm)/2
      = k*(QBOUND*dnorm/DBOUND - 1/2) + dnorm/2 + QBOUND*(DBOUND - dnorm)/2
     <=   dnorm*(QBOUND*dnorm/DBOUND - 1/2)
        + dnorm/2 + QBOUND*(DBOUND - dnorm)/2
      = QBOUND*dnorm - QBOUND*(DBOUND - dnorm)*(dnorm/DBOUND - 1/2)
     <= QBOUND*dnorm.

        (we used QBOUND*dnorm/DBOUND >= QBOUND/2 >= 1/2 above).
        This proves the right inequality in (*).
*/

/****************************************************************************/
DRM_NO_INLINE digit_t DRM_CALL estimated_quotient_1
        (const digit_t         n2,
         const digit_t         n1,
         const digit_t         n0,
         const reciprocal_1_t *recip)
/*
        This routine estimates a quotient digit given
        the three most significant digits of the unshifted
        numerator and given the multiplier from
        divide_precondition_1.

        The quotient returned will be in the interval
        [0, RADIX - 1] and will be correct or one too low.
*/
{
    DRM_UINT64 qprod;
    const digit_t nshiftedhi = DOUBLE_SHIFT_LEFT(n2, n1, recip->shiftamt);
    const digit_t nshiftedlo = DOUBLE_SHIFT_LEFT(n1, n0, recip->shiftamt);
    
    qprod = DRM_UI64Add(DRM_UI64HL(nshiftedhi, nshiftedlo),
                       DPRODUU(nshiftedhi, recip->multiplier));

    if (nshiftedlo & RADIX_HALF) {
        qprod = DRM_UI64Add(qprod, DRM_UI64(recip->multiplier >> 1));
    }
    return DRM_UI64High32(qprod);
} /* estimated_quotient_1 */
/****************************************************************************/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL div21(
        const DRM_UINT64    db,        /* Dividend */
        const digit_t       d,          /* Divisor */
        digit_t            *quot,       /* Quotient (output) */
        digit_t            *rem )       /* Remainder (output) */
/*
                This routine divides a double-length
        dividend (db = nhigh * RADIX + nlow) by a single-length divisor (d).
        All arguments are unsigned.
        We require db < d*RADIX, to ensure the quotient will be <= RADIX - 1.
        The quotient *quot and the remainder *rem satisfy the usual rules:

                0 <= *rem < d
                db = d * (*quot) + (*rem)
*/
{
    DRM_BOOL OK = TRUE;
    const digit_t nhigh = DRM_UI64High32(db), nlow = DRM_UI64Low32(db);
    if (!OK) {
    } else if (nhigh >= d) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA, "div21");
    } else {   /* nhigh < d */

#if DBLINT_BUILTIN
/*
                Use the 2-digit / 1-digit division built into the language.
*/
        const digit_t q = (digit_t)(db/DRM_UI64(d));
        *quot = q;
        *rem = nlow - d*q;
#else /* DBLINT_BUILTIN */
/*
                Construct quotient one bit at a time.
*/
        digit_t rhigh = nhigh, rlow = nlow, q = 0, ipow2;

        for (ipow2 = RADIX_HALF; ipow2 != 0; ipow2 >>= 1) {
/*
                At this point,

                nhigh * RADIX + nlow
              = q*d + rhigh*(2*ipow2) + rlow*(2*ipow2/RADIX)

                0 <= rhigh < d

                If 2*rhigh + 2*rlow/RADIX >= d, increase q by ipow2.
                Avoid integer overflow during the test.
*/
            digit_t rlow_hibit = rlow >> (RADIX_BITS - 1);

            if (rhigh + rlow_hibit >= d - rhigh) {
                q += ipow2;
                rlow_hibit -= d;
            }
            rhigh = 2*rhigh + rlow_hibit;
            rlow <<= 1;
        } /* for ipow2 */
/*
        Store quotient and remainder.  rlow is zero now.
*/
        *quot = q;
        *rem = rhigh;
#endif /* DBLINT_BUILTIN */
    } /* if nhigh */
    return OK;
} /* div21 */
/****************************************************************************/
DRM_EXPORTED_INLINE DRM_BOOL DRM_CALL div21_fast(
         const DRM_UINT64       db,
         const digit_t          d,
         const reciprocal_1_t  *recip,
         digit_t               *quot,
         digit_t               *rem )
{
/*
        See start of file for explanation of algorithm.
*/
    const digit_t n1 = DRM_UI64High32(db);
    const digit_t n0 = DRM_UI64Low32(db);
    const digit_t qestcomp
        = RADIXM1 - estimated_quotient_1(n1, n0, 0, recip);
                                             /* RADIX - 1 - qest */

    const DRM_UINT64 remest = DRM_UI64Add(DRM_UI64HL(n1 - d, n0),
                                  DPRODUU(qestcomp, d) );

/*
        remest = (n1 - d)*RADIX + n0 + (RADIX - 1 - qest)*d
               = n1*RADIX + n0 - (qest + 1)*d
        is the remainder using qest+1 as estimated quotient.
        Be careful since qest+1 may equal RADIX.
        remest is in [-d, d - 1]

        If DRM_UI64High32(remest) = 0, then remest is nonnegative;
        set the quotient to qest + 1 = RADIX - qestcomp
        and the remainder to DRM_UI64Low32(remest).
        Otherwise DRM_UI64High32(remest) = RADIXM1;
        set the quotient to qest = RADIXM1 - qestcomp
        and the remainder to DRM_UI64Low32(remest) + d - RADIX.
*/
    *quot = DRM_UI64High32(remest) - qestcomp;
    *rem  = DRM_UI64Low32(remest) + (d & DRM_UI64High32(remest));
    return TRUE;
} /* div21_fast */
/****************************************************************************/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL divide(
         const digit_t          numer[],
         const DRM_DWORD        lnum,
         const digit_t          denom[],
         const DRM_DWORD        lden,
         const reciprocal_1_t  *supplied_reciprocal,
                                   /* reciprocal_t struct for this denominator,
                                      or NULL
                                      if not previously precomputed */
         digit_t   quot[],     /* Quotient -- length MAX(lnum - lden + 1, 0) */
         digit_t   rem[])      /* Remainder -- length lden  */         
/*
        Divide numer (of length lnum) by denom (of length lden).
        Fifth argument can be the reciprocal_1_t struct
        from divide_precondition_1 if same denominator is used
        repeatedly, or can be NULL if
        this denominator is new.

        Quotient (of length MAX(lnum - lden + 1, 0)) is put in quot.
        However, if quot == NULL, no quotient is returned.

        Remainder (of length lden) is put in rem.
        There is no option to suppress the remainder.

        Function value is the number of significant digits
        in the remainder.  The function value is zero precisely
        when the remainder is zero.

        Quotient and remainder should not overlap other arguments.
        The leading digit of the denominator should be nonzero.
*/
{
    DRM_BOOL OK = TRUE;
    digit_t dlead;

    if (lden == 0) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_DIVIDE_ZERO, "divide");
    } else if (numer == NULL || denom == NULL || rem == NULL){
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_NULL_POINTER, "divide");
    } else if (numer == quot || numer == rem || denom == quot || denom == rem) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_OVERLAPPING_ARGS, "divide");
    }
    if (OK) {
        dlead = denom[lden - 1];
        if (dlead == 0) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                            "divide -- leading zero");
        } else if (lnum < lden) {
            mp_extend(numer, lnum, rem, lden);
                             // Quotient length zero
        } else if (lden == 1) {
            OK = OK && divide_immediate(numer, dlead, supplied_reciprocal,
                                        quot, lnum, &rem[0]);
        } else {
            DRM_DWORD iq, i;
            reciprocal_1_t computed_reciprocal;
            const reciprocal_1_t *used_reciprocal;

            used_reciprocal = supplied_reciprocal;
            if (used_reciprocal == NULL) {
                divide_precondition_1(denom, lden,
                                      &computed_reciprocal);
                used_reciprocal = &computed_reciprocal;
            }
/*
                Copy top lden-1 words of numerator to remainder.
                Zero most significant word of remainder.
*/
            rem[lden-1] = 0;
            MEMCPY( rem,&numer[lnum-lden+1],( lden-1)*SIZEOF( digit_t ));

            for (iq = lnum-lden+1; OK && (iq--) != 0; /*null*/) {
                const digit_t remtop = rem[lden-1];
                digit_t qest;
/*
                    Multiply old remainder by RADIX.  Add numer[iq].
*/
                for (i = lden-1; i != 0; i--) {
                    rem[i] = rem[i-1];
                }
                rem[0] = numer[iq];
/*
                    Check for zero digit in quotient.
                    This is especially likely to happen on the
                    first iteration of the iq loop.
*/
                if (remtop == 0 && compare_same(rem, denom, lden) < 0) {
                    qest = 0;
                } else {
                    digit_t borrow;
                    qest = estimated_quotient_1(remtop, rem[lden-1],
                                                rem[lden-2],
                                                used_reciprocal);
                       /* qest is correct or one too low */
                    qest += (qest < RADIXM1);
                       /* Now qest is correct or one too high */
                    borrow = decumulate(denom, qest, rem, lden);
                       /* Subtract qest*denom from rem */
                    if (borrow > remtop) { // If estimated quotient is too high
                        qest--;
                        borrow -= add_same(rem, denom, rem, lden);
                    }

                    if (borrow != remtop) {
                        OK = FALSE;
                        SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                                        "divide - Quotient estimation error.\n");
                    }
                } /* qest == 0 */

                if (quot != NULL) quot[iq] = qest;
            }  /* for iq */
        }
    }
    return OK;
}  /* divide */
/****************************************************************************/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL divide_immediate(
         const digit_t          numer[],
         const digit_t          den,
         const reciprocal_1_t  *supplied_reciprocal,
         digit_t                quot[],
         const DRM_DWORD        lng,
         digit_t               *prem )      // OUT (remainder)         
/*
        Divide numer (length lng) by den (length 1).
        Quotient (length lng) is written to quot (or can be suppressed
        if quot = NULL).
        Remainder is returned as function value.

        supplied_reciprocal is the output of
        divide_precondition_1 for this denominator,
        or can be NULL if reciprocal was not
        previously computed.
*/
{
    DRM_BOOL OK = TRUE;
    digit_t carry = 0;
    DRM_DWORD i, lngleft = lng;

    if (lngleft > 0 && numer[lngleft-1] < den) {
        lngleft--;
        carry = numer[lngleft];
        if (quot != NULL) quot[lngleft] = 0;
    }

    if (supplied_reciprocal == NULL && lngleft < 2) {
        for (i = lngleft; (i--) != 0; /*null*/) {
            digit_t qest = 0;
            OK = OK && div21(DRM_UI64HL(carry, numer[i]),
                             den, &qest, &carry);
            if (quot != NULL) quot[i] = qest;
        }
    } else {
        reciprocal_1_t computed_reciprocal;
        const reciprocal_1_t *used_reciprocal = supplied_reciprocal;

        if (used_reciprocal == NULL) {
            OK = OK && divide_precondition_1(&den, 1,
                              &computed_reciprocal);
            used_reciprocal = &computed_reciprocal;
        }

        for (i = lngleft; OK && (i--) != 0; /*null*/) {
            digit_t qest = 0;
            OK = OK && div21_fast(DRM_UI64HL(carry, numer[i]),
                                   den,used_reciprocal, &qest,
                                   &carry);
            if (quot != NULL) quot[i] = qest;
        }
    }
    if (OK) *prem = carry;
    return OK;
} /* divide_immediate */
/****************************************************************************/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL divide_precondition_1(
         const digit_t         denom[],
         const DRM_DWORD       lden,
         reciprocal_1_t       *recip )
/*
        This routine computes the reciprocal_1_t structure
        for the denominator denom, of length lden.
        The leading digit denom[lden-1] must be nonzero.
        It computes a multiplier accurate enough for estimated_quotient_1
        to predict one digit of a quotient (with an error at most 1).
        This is the case QBOUND = RADIX, DBOUND = RADIX^lden
        of the theory atop this file.
*/
{
    DRM_BOOL OK = TRUE;

    if (denom == NULL || recip == NULL) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_NULL_POINTER,
                        "divide_precondition_1");
    } else if (lden == 0 || denom[lden-1] == 0) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "divide_precondition_1");
    } else {
        DRM_DWORD iden, recip_shift;
        digit_t recip_multiplier = 0, dlead[3], dshiftedhi, dshiftedlo, rem = 0;

        recip_shift = RADIX_BITS - significant_bit_count(denom[lden-1]);
        dlead[2] = denom[lden-1];
        dlead[1] = (lden >= 2 ? denom[lden-2] : 0);
        dlead[0] = (lden >= 3 ? denom[lden-3] : 0);

        dshiftedhi = DOUBLE_SHIFT_LEFT(dlead[2], dlead[1], recip_shift);
        dshiftedlo = DOUBLE_SHIFT_LEFT(dlead[1], dlead[0], recip_shift);
/*
             We want our RADIX + multiplier to be the integer part of

                               RADIX^lden - 1
             ---------------------------------------------------------
             dshiftedhi*RADIX^(lden-2) + dshiftedlo*RADIX^(lden-3) + ...


        The leading digit of this quotient is 1*RADIX^1
        since dshiftedhi >= RADIX/2.
        After subtracting RADIX*denominator from the numerator,
        we get the next digit of the quotient by approximating
        the denominator by dshiftedhi*RADIX^(lden-1). Standard theory
        (see, e.g., Knuth, Seminumerical Algorithms, 1981,
        Theorem B, p. 257) says the so-estimated quotient
        differs from the real quotient by at most 2,
        and the so-estimated quotient is never smaller than the real
        quotient.  When we use the two leading digits from the
        divisor, the error in the estimate can be at most one.
        We allow one correction while looking at
        the dshiftedlo term and one more later on.
*/

        OK = OK && div21(DRM_UI64HL(RADIXM1 - dshiftedhi,
                                     RADIXM1 - dshiftedlo),
                         dshiftedhi, &recip_multiplier, &rem);

/*
                Quick adjustment.  Check the sign of

//        RADIX^3 - 1 - (RADIX + multiplier)*(dshiftedhi*RADIX + dshiftedlo)
//       =    RADIX*(RADIX^2 - 1 - dshiftedhi*RADIX - dshliftedlo)
//         - multiplier*(dshiftedhi*RADIX + dshiftedlo)
//         + RADIX - 1
//      = RADIX*(rem + multiplier*dshiftedhi) + RADIX - 1
//         - multiplier*(dshiftedhi*RADIX + dshiftedlo)
//      = rem*RADIX + RADIX - 1 - multiplier*dshiftedlo
*/
        if ( OK ) 
        {   
            DRM_UINT64 tempRem = DPRODUU( recip_multiplier, dshiftedlo );
            
            if ( DRM_UI64High32(tempRem) > rem ) 
            {
                recip_multiplier--;
            }

/*
                Fine adjustment.  Check the sign of

                      RADIX^(lden+1)/2^shiftamt - 1
                    - (RADIX+multiplier)*denom[lden-1:0].

                If this is negative, then the multiplier is too large.
                If this is nonnegative, then the multiplier is correct.
*/
            rem = (RADIXM1 >> recip_shift) - denom[lden-1];
                             /* RADIX/2^shiftamt - 1 - den[lden-1] */
/*
                Repeatedly replace rem by

            rem*RADIX + RADIX - 1 - denom[iden-1] - multiplier*denom[iden]

        until it is known whether rem >= multiplier or rem < 0.
        Once one of these happens, the sign of rem won't change.
*/
            for (iden = lden; (iden--) != 0 && rem < recip_multiplier;/*null*/){
                        /* CAUTION -- loop may exit early */

                DRM_UINT64  test1 = DRM_UI64HL(rem,
                                      RADIXM1 - (iden > 0 ? denom[iden-1] : 0));
                const DRM_UINT64 test2 = DPRODUU(recip_multiplier, denom[iden]);
                if (!DRM_UI64Les(test2, test1)) {
                    recip_multiplier--;
                    break;
                }
                test1 = DRM_UI64Sub(test1, test2);
                rem = DRM_UI64Low32(test1);
                if (DRM_UI64High32(test1) != 0) break;
            } // for iden
            recip->shiftamt   = recip_shift;
            recip->multiplier = recip_multiplier;
        } // if OK
    } // else
    return OK;
} /* divide_precondition_1 */
/****************************************************************************/

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\divisibility.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

/*
        File divisibility.c.    Version 06 December 2002


        digit_t *low_prime_prod_construction(struct bigctx_t *f_pBigCtx)
               -- Returns pointer
                  to a table used by low_prime_divisibility, to
                  check for divisibility by low odd primes.
                  The pointer returned will be NULL
                  if an error is detected.

        DRM_VOID low_prime_prod_destruction(lowprods, struct bigctx_t *f_pBigCtx) --
                  Free memory allocated during low_prime_prod_construction.

        DRM_BOOL low_prime_divisibility(array, lng, lowprods,
                  &pdivisor, struct bigctx_t *f_pBigCtx) --
                  Check our tables for a (not necessarily prime)
                  divisor of array (length lng).  lowprods must come
                  from low_prime_prod_construction.
                  If we succeed, then *pdivisor > 1 will be a product
                  of primes from the tables.  If no divisor is found,
                  then output with *pdivisor = 1.
*/
#include "bigpriv.h"

ENTER_PK_NAMESPACE_CODE;

//    The LOW_PROD table has 22 32-bit products or 11 64-bit products.
//    Every odd prime below JPFIRST divides one table entry.

#if RADIX_BITS == 32                             // Two products < 2^32
    #define TWO_PRODS(p1, p2) (digit_t)(p1), (digit_t)(p2)
#elif RADIX_BITS == 64                           // One product  < 2^64
    #define TWO_PRODS(p1, p2) (digit_t)(p1) * (digit_t)(p2)
#else
    #error -- "Unexpected RADIX_BITS"
#endif

#define JPFIRST 521
static const DRM_DWORD LOW_PROD_MAGIC = 0x50574F4C;  //  "LOWP"

static const digit_t LOW_PROD[] = {
    TWO_PRODS(4240068105, 3842999413), // 3*5*7*13*29*43*47*53
                                       //              & 11*17*19*23*31*37*41
    TWO_PRODS(3059475739, 4294251953), // 59*67*79*97*101    & 61*367*433*443
    TWO_PRODS(4294770617, 4294737533), // 71*349*353*491     & 73*283*449*463
    TWO_PRODS(4293835597, 4294901213), // 83*293*383*461     & 89*197*487*503
    TWO_PRODS(4294933861, 1353041857), // 103*263*331*479    & 107*157*239*337
    TWO_PRODS(4148193053, 4286755457), // 109*257*373*397    & 113*251*359*421
    TWO_PRODS(4291682933, 4294875479), // 127*241*281*499    & 131*271*311*389
    TWO_PRODS(4294914791, 4294097393), // 137*181*379*457    & 139*229*313*431
    TWO_PRODS(4289642801, 4280410741), // 149*163*347*509    & 151*223*317*401
    TWO_PRODS(4294824337, 4294927237), // 167*227*277*409    & 173*193*307*419
    TWO_PRODS(4294924747, 4294928843)};// 179*191*269*467    & 199*211*233*439
#undef TWO_PRODS

static const DRM_DWORD NUM_LOW_PROD =(DRM_DWORD)(sizeof(LOW_PROD)/sizeof(LOW_PROD[0]));

#ifndef HPRODUU
    #define HPRODUU(u1, u2) DRM_UI64High32(DRM_UI64Mul(DRM_UI64((u1)), DRM_UI64((u2))))
#endif

digit_t* DRM_CALL low_prime_prod_construction(struct bigctx_t *f_pBigCtx, DRM_DWORD *pclowprods)
/*
     Construct table with (products of) low primes.
*/
{
    // On 32-bit hosts, 3200 products of two primes cover
    // all odd primes < 65500.  It goes higher on 64-bit hosts
    // (where many products have 3 or 4 primes).
    const DRM_DWORD NUM_PRODUCT = NUM_LOW_PROD + 3200;

    digit_t *lowprods = NULL;        
    DRM_BOOL OK = TRUE;

    if ( pclowprods == NULL )
    {
        OK = FALSE;
    }
    else
    {
        *pclowprods = 0;
    }

    if ( OK )
    {
        lowprods = digit_allocate( NUM_PRODUCT + 2,
                                   "low_prime_prod_construction",
                                   f_pBigCtx);

        if (lowprods == NULL)
        {
            OK = FALSE;
        }
        else
        {
            *pclowprods = NUM_PRODUCT + 2;
        }
    }

    if (OK) {
        DRM_DWORD ilp, nprod;
        digit_t jp, jpinc, partial_product;

// Loop over integers jp >= 5 with GCD(jp, 6) = 1.
// Store (products of) primes, until prods table fills.

        lowprods[0] = (digit_t)NUM_PRODUCT;   // First entry has length
        lowprods[1] = (digit_t)LOW_PROD_MAGIC;  // Second entry has magic value
        for (nprod = 0, partial_product = 1, jp = 5, jpinc = 2;
             nprod != NUM_PRODUCT && OK;
            jp += jpinc, jpinc = 6 - jpinc) {  // GCD(jp, 6) = 1
            DRM_BOOL jp_factor_found = FALSE;

                // Check for divisors from LOW_PROD table.

            for (ilp = 0; ilp != NUM_LOW_PROD && !jp_factor_found; ilp++) {
                digit_t gcdtest = 0;
                OK = OK && digit_ogcd(jp, LOW_PROD[ilp],&gcdtest);
                if (OK && gcdtest > 1) jp_factor_found = TRUE;
            }
            if (!OK) {
            } else if (jp_factor_found) {
            } else if (jp < JPFIRST) {
                OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                                "low_prime_prod_construction");
            } else if (HPRODUU(partial_product, jp) == 0) {
                // If jp has no factor below JPFIRST, treat it as a prime.
                // We combine multiple primes into one word.
                // On 64-bit machines, three 21-bit primes can be combined.

                partial_product *= jp;    // Merge with old product
            } else {    // partial_product * jp would give integer overflow
                lowprods[nprod+2] = partial_product;
                nprod++;
                partial_product = jp; // Start new product
            }
        } // for jp, nprod
    }
    if (!OK && lowprods != NULL) {
        Free_Temporaries(lowprods, f_pBigCtx);
        lowprods = NULL;
    }
    return lowprods;
} // end low_prime_prod_construction
/******************************************************************************/
DRM_VOID DRM_CALL low_prime_prod_destruction
        (digit_t *lowprods,          // IN (freed)
        struct bigctx_t *f_pBigCtx)
{
    Free_Temporaries(lowprods, f_pBigCtx);
}  // end low_prime_prod_destruction
/******************************************************************************/
DRM_BOOL DRM_CALL low_prime_divisibility
        (const digit_t    array[],        // IN
         const DRM_DWORD   lng,            // IN
         __in_ecount( clowprods ) const digit_t *lowprods,
         __in const DRM_DWORD clowprods,
         digit_t    *pdivisor,       // OUT
         struct bigctx_t *f_pBigCtx)
{
    DRM_BOOL OK = TRUE;
    DRM_DWORD itab, ilp, i, ntab = 2;

    if (lng == 0 || IS_EVEN(array[0])) {
        *pdivisor = 2;  // Even
        return OK;
    } else if (lowprods == NULL || clowprods != ( NUM_LOW_PROD + 3200 + 2 ) ) {
        // NUM_LOW_PROD + 3200 + 2 is the size of the prime table constructed
        // in low_prime_prod_construction() at the beginning of the same file.
        ntab = 1;    // Search only the fixed LOW_PROD table
    } else if (lowprods[1] != LOW_PROD_MAGIC) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "low_prime_divisibility");
    }

    for (itab = 0; OK && itab != ntab; itab++) {
        const digit_t *table  = (itab == 0 ? LOW_PROD : lowprods + 2);
        const DRM_DWORD tablng = (itab == 0 ? NUM_LOW_PROD : (DRM_DWORD)lowprods[0]);

        for (ilp = 0; ilp != tablng; ilp++) {
            const digit_t prodnow = table[ilp];
            digit_t prodinv = 0, rem = 0, mulby;
            OK = OK && two_adic_inverse(prodnow, &prodinv);
            if (OK) {
                for (i = 0; i != lng; i++) {
                     // array[0:i-1] == rem*RADIX^i (mod prodnow)
                     // 0 <= rem <= prodnow
                    rem += array[i];
                    if (rem < array[i]) rem -= prodnow;   // Unsigned compare

                     // Find mulby so
                     // (new rem) = (rem - mulby*prodnow)/RADIX + prodnow
                     // is an positive integer.
                     // Solution is mulby == rem*prodinv (mod RADIX)

                    mulby = prodinv*rem;      // mod RADIX
                    //assert((digit_t)(mulby*prodnow) == rem);
                    rem = prodnow - HPRODUU(mulby, prodnow);
                }
                OK = OK && digit_ogcd(rem, prodnow, pdivisor);
                if (OK && *pdivisor != 1) return OK;
            }
        } // for ilp
    } // for itab
    if (OK) *pdivisor = 1;
    return OK;
} // low_prime_divisibility

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmaes.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

/*
** drmaes.c
**
** Summary:
**  This file implements AES signing and encryption of variable length data.
**  It assumes the existence of routines to encrypt a block sized buffer
*/

#include <drmaes.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmtypes.h>
#include <byteorder.h>
#include <oem.h>

ENTER_PK_NAMESPACE_CODE;

/*********************************************************************************************
** Function:  _XOR 
**
** Synopsis:  Byte-by-byte XOR of two buffers using two indices.
**
** Arguments: [f_pbLHS]  : Pointer to the left-hand side
**            [f_ibLHS]  : Index into the LHS to start XOR at
**            [f_pbRHS]  : Pointer to the right-hand side
**            [f_ibRHS]  : Index into the RHS to start XOR at
**            [f_cb]     : Byte count to XOR
**
** Returns:   DRM_VOID
**********************************************************************************************/
static DRM_VOID _XOR(
    __inout_bcount( f_ibLHS + f_cb )    DRM_BYTE   *f_pbLHS,
    __in                                DRM_DWORD   f_ibLHS,
    __in_bcount( f_ibRHS + f_cb ) const DRM_BYTE   *f_pbRHS,
    __in                                DRM_DWORD   f_ibRHS,
    __in                                DRM_DWORD   f_cb )
{
    DRM_DWORD i = 0;

    for(  ; i < f_cb; i++ )
    {
        PUT_BYTE( f_pbLHS, 
                  i + f_ibLHS, 
                  GET_BYTE( f_pbLHS, i + f_ibLHS ) ^ GET_BYTE( f_pbRHS, i + f_ibRHS ) );
    }
}


/*********************************************************************************************
** Function:  DRM_Aes_CtrProcessData 
**
** Synopsis:  Does AES Counter-Mode encryption or decryption on a buffer of data
**
** Arguments: [f_pKey]      : The AES secret key used to encrypt or decrypt buffer
**            [f_pbData]    : The buffer to encrypt or decrypt ( in place )
**            [f_cbData]    : The number of bytes to encrypt or decrypt
**            [f_pCtrContext] : Contains the initialization vector and offset data. Will be updated
**
** Returns:   DRM_SUCCESS
**              Success
**            DRM_E_INVALIDARG
**              One of the pointers was NULL, or the byte count is 0, or neither the
**              block ID or offset are 0 ( one must == 0 ).
**            DRM_E_CRYPTO_FAILED
**              The encrypt/decrypt operation failed
**********************************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_Aes_CtrProcessData(
    __in_ecount( 1 )            const DRM_AES_KEY                  *f_pKey,
    __inout_bcount( f_cbData )        DRM_BYTE                     *f_pbData,
    __in                              DRM_DWORD                     f_cbData,
    __inout_ecount( 1 )               DRM_AES_COUNTER_MODE_CONTEXT *f_pCtrContext )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BYTE   rgbDataIn [__CB_DECL( DRM_AES_BLOCKLEN )] = { 0 };
    DRM_BYTE   rgbDataOut[__CB_DECL( DRM_AES_BLOCKLEN )] = { 0 };    
    DRM_DWORD  cbDataLeft   = f_cbData;
    DRM_DWORD  ibDataOutCur = 0;
    DRM_DWORD  cbDataToUse  = 0; 
    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMAES, PERF_FUNC_DRM_Aes_CtrProcessData );

    ChkArg( f_pbData      != NULL );
    ChkArg( f_cbData      >  0 );
    ChkArg( f_pCtrContext != NULL );
    ChkArg( f_pKey        != NULL );
    ChkArg( f_pCtrContext->bByteOffset <= DRM_AES_BLOCKLEN );

    QWORD_TO_NETWORKBYTES( rgbDataIn, 0, f_pCtrContext->qwInitializationVector );

    if( f_pCtrContext->bByteOffset > 0 )
    {
        /*
        ** The data is in the middle of a block.  Handle the special case first 
        */
        cbDataToUse = DRM_AES_BLOCKLEN - f_pCtrContext->bByteOffset;
        cbDataToUse = min( cbDataLeft, cbDataToUse );

        QWORD_TO_NETWORKBYTES( &( rgbDataIn[SIZEOF( DRM_UINT64 )] ), 0, f_pCtrContext->qwBlockOffset );

        MEMCPY( rgbDataOut, rgbDataIn, DRM_AES_BLOCKLEN );
        dr = Oem_Aes_EncryptOne( f_pKey, rgbDataOut );
        ChkBOOL( DRM_SUCCEEDED( dr ), DRM_E_CRYPTO_FAILED );
        
        _XOR( f_pbData, ibDataOutCur, rgbDataOut, f_pCtrContext->bByteOffset, cbDataToUse );

        ibDataOutCur += cbDataToUse;

        ChkOverflow( cbDataLeft, cbDataLeft - cbDataToUse );
        cbDataLeft -= cbDataToUse;

        f_pCtrContext->qwBlockOffset = DRM_UI64Add( f_pCtrContext->qwBlockOffset, DRM_UI64( 1 ) );
    }

    while( cbDataLeft > 0 )
    {
        cbDataToUse = min( cbDataLeft, DRM_AES_BLOCKLEN );
        QWORD_TO_NETWORKBYTES( &( rgbDataIn[SIZEOF( DRM_UINT64 )] ), 0, f_pCtrContext->qwBlockOffset );

        MEMCPY( rgbDataOut, rgbDataIn, DRM_AES_BLOCKLEN );            
        dr = Oem_Aes_EncryptOne( f_pKey, rgbDataOut );
        ChkBOOL( DRM_SUCCEEDED( dr ), DRM_E_CRYPTO_FAILED );

        _XOR( f_pbData, ibDataOutCur, rgbDataOut, 0, cbDataToUse );

        ibDataOutCur += cbDataToUse;
        cbDataLeft   -= cbDataToUse;

        f_pCtrContext->qwBlockOffset = DRM_UI64Add( f_pCtrContext->qwBlockOffset, DRM_UI64( 1 ) );
    }

    f_pCtrContext->bByteOffset = ( f_pCtrContext->bByteOffset + f_cbData ) % DRM_AES_BLOCKLEN;
ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

/*********************************************************************************************
** Function:  DRM_Aes_CbcEncryptData 
**
** Synopsis:  Does AES CBC-Mode encryption on a buffer of data
**
** Arguments: [f_pKey]      : The AES secret key used to encrypt the buffer
**            [f_pbData]    : The buffer to encrypt ( in place )
**            [f_cbData]    : The number of bytes to encrypt 
**            [f_rgbIV]     : The initialization vector to use for encryption
**
** Returns:   DRM_SUCCESS
**              Success
**            DRM_E_INVALIDARG
**               One of the pointers was NULL, or the byte count is 0 
**               or not a multiple of DRM_AES_BLOCKLEN
**            DRM_E_CRYPTO_FAILED
**              The encrypt operation failed
**********************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_Aes_CbcEncryptData(
    __in_ecount( 1 )                const DRM_AES_KEY *f_pKey,
    __inout_bcount( f_cbData )            DRM_BYTE    *f_pbData,
    __in                                  DRM_DWORD    f_cbData,
    __in_bcount( DRM_AES_BLOCKLEN ) const DRM_BYTE     f_rgbIV[__CB_DECL( DRM_AES_BLOCKLEN )] )
{
    DRM_RESULT dr           =  DRM_SUCCESS;
    DRM_DWORD  cbDataLeft   = f_cbData;
    DRM_DWORD  ibDataOutCur = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMAES, PERF_FUNC_DRM_Aes_CbcEncryptData );

    ChkArg( f_pbData != NULL );
    ChkArg( f_cbData >= DRM_AES_BLOCKLEN );
    ChkArg( f_cbData % DRM_AES_BLOCKLEN ==  0 );

    /*
    ** The first block is a special case: Use the IV to XOR
    */    
    _XOR( f_pbData, 0, f_rgbIV, 0, DRM_AES_BLOCKLEN );
    dr = Oem_Aes_EncryptOne( f_pKey, f_pbData );
    ChkBOOL( DRM_SUCCEEDED( dr ), DRM_E_CRYPTO_FAILED );
    cbDataLeft -= DRM_AES_BLOCKLEN;

    while( cbDataLeft > 0 )
    {        
        _XOR( f_pbData, ibDataOutCur + DRM_AES_BLOCKLEN, f_pbData, ibDataOutCur, DRM_AES_BLOCKLEN );
        ibDataOutCur += DRM_AES_BLOCKLEN;   
        dr = Oem_Aes_EncryptOne( f_pKey, &f_pbData[ibDataOutCur] );
        ChkBOOL( DRM_SUCCEEDED( dr ), DRM_E_CRYPTO_FAILED );
        cbDataLeft -= DRM_AES_BLOCKLEN;
    }

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

/*********************************************************************************************
** Function:  DRM_Aes_CbcDecryptData 
**
** Synopsis:  Does AES CBC-Mode decryption on a buffer of data
**
** Arguments: [f_pKey]      : The AES secret key used to decrypt the buffer
**            [f_pbData]    : The buffer to decrypt ( in place )
**            [f_cbData]    : The number of bytes to decrypt 
**            [f_rgbIV]     : The initialization vector to use for decryption
**
** Returns:   DRM_SUCCESS
**              Success
**            DRM_E_INVALIDARG
**               One of the pointers was NULL, or the byte count is 0 
**               or not a multiple of DRM_AES_BLOCKLEN
**            DRM_E_CRYPTO_FAILED
**              The decrypt operation failed
**********************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_Aes_CbcDecryptData(
    __in_ecount( 1 )                const DRM_AES_KEY *f_pKey,
    __inout_bcount( f_cbData )            DRM_BYTE    *f_pbData,
    __in                                  DRM_DWORD    f_cbData,
    __in_bcount( DRM_AES_BLOCKLEN ) const DRM_BYTE     f_rgbIV[__CB_DECL( DRM_AES_BLOCKLEN )] )
{
    DRM_RESULT dr           =  DRM_SUCCESS;
    DRM_DWORD  ibDataOutCur = 0;
    DRM_DWORD  i            = 0;
    DRM_BYTE   rgbTemp1[__CB_DECL( DRM_AES_BLOCKLEN )] = { 0 };    
    DRM_BYTE   rgbTemp2[__CB_DECL( DRM_AES_BLOCKLEN )] = { 0 };    

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMAES, PERF_FUNC_DRM_Aes_CbcDecryptData );

    ChkArg( f_pbData != NULL );
    ChkArg( f_cbData >= DRM_AES_BLOCKLEN );    
    ChkArg( f_cbData % DRM_AES_BLOCKLEN ==  0 );

    /*
    ** The first block is a special case: Use the IV to XOR
    */    
    MEMCPY( rgbTemp1, f_pbData, DRM_AES_BLOCKLEN );
    dr = Oem_Aes_DecryptOne( f_pKey, f_pbData );
    _XOR( f_pbData, 0, f_rgbIV, 0, DRM_AES_BLOCKLEN );
    ChkBOOL( DRM_SUCCEEDED( dr ), DRM_E_CRYPTO_FAILED );
    ibDataOutCur += DRM_AES_BLOCKLEN;

    for( ; ibDataOutCur < f_cbData; i++, ibDataOutCur += DRM_AES_BLOCKLEN )
    {             
        DRM_BYT_CopyBytes( ( i % 2 == 0? rgbTemp2 : rgbTemp1 ), 0, f_pbData, ibDataOutCur, DRM_AES_BLOCKLEN );
        dr = Oem_Aes_DecryptOne( f_pKey, &f_pbData[ibDataOutCur] );
        ChkBOOL( DRM_SUCCEEDED( dr ), DRM_E_CRYPTO_FAILED );
        _XOR( f_pbData, ibDataOutCur, ( i % 2 == 0? rgbTemp1 : rgbTemp2 ), 0, DRM_AES_BLOCKLEN );
    }

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

/*********************************************************************************************
** 
** Function:  DRM_Aes_EcbEncryptData 
**
** Synopsis:  Does AES ECB-Mode encryption on a buffer of data
**
** Arguments: [f_pKey]      : The AES secret key used to encrypt  buffer
**            [f_pbData]    : The buffer to encrypt ( in place )
**            [f_cbData]    : The number of bytes to encrypt 
**
** Returns:   DRM_SUCCESS
**               Success
**            DRM_E_INVALIDARG
**               One of the pointers was NULL, or the byte count is 0 
**               or not a multiple of DRM_AES_BLOCKLEN
**********************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_Aes_EcbEncryptData(
    __in_ecount( 1 )                const DRM_AES_KEY *f_pKey,
    __inout_bcount( f_cbData )            DRM_BYTE    *f_pbData,
    __in                                  DRM_DWORD    f_cbData )
{
    DRM_RESULT dr     = DRM_SUCCESS;
    DRM_DWORD  ibData = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMAES, PERF_FUNC_DRM_Aes_EcbEncryptData );

    ChkArg( f_pbData != NULL );
    ChkArg( f_cbData != 0 );
    ChkArg( f_pKey   != NULL );

    ChkArg( f_cbData % DRM_AES_BLOCKLEN == 0 );

    for ( ; ibData < f_cbData; ibData += DRM_AES_BLOCKLEN )
    {
        ChkDR( Oem_Aes_EncryptOne( f_pKey, &( f_pbData[ibData] ) ) );        
    }

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

/*********************************************************************************************
** 
** Function:  DRM_Aes_EcbDecryptData 
**
** Synopsis:  Does AES ECB-Mode decryption on a buffer of data
**
** Arguments: [f_pKey]      : The AES secret key used to decrypt buffer
**            [f_pbData]    : The buffer to decrypt ( in place )
**            [f_cbData]    : The number of bytes to decrypt 
**
** Returns:   DRM_SUCCESS
**               Success
**            DRM_E_INVALIDARG
**               One of the pointers was NULL, or the byte count is 0 
**               or not a multiple of DRM_AES_BLOCKLEN
**********************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_Aes_EcbDecryptData(
    __in_ecount( 1 )                const DRM_AES_KEY *f_pKey,
    __inout_bcount( f_cbData )            DRM_BYTE    *f_pbData,
    __in                                  DRM_DWORD    f_cbData )
{
    DRM_RESULT dr     = DRM_SUCCESS;
    DRM_DWORD  ibData = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMAES, PERF_FUNC_DRM_Aes_EcbDecryptData );

    ChkArg( f_pbData != NULL );
    ChkArg( f_cbData != 0 );
    ChkArg( f_pKey   != NULL );

    ChkArg( f_cbData % DRM_AES_BLOCKLEN == 0 );

    for ( ; ibData < f_cbData; ibData += DRM_AES_BLOCKLEN )
    {
        ChkDR( Oem_Aes_DecryptOne( f_pKey, &( f_pbData[ibData] ) ) );        
    }

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

/*********************************************************************************************
** 
** Function:  _Omac1_GenerateSignTag 
**
** Synopsis:  Computes the OMAC1 sign tag
**
** Arguments: [f_pKey]      : The AES secret key
**            [f_pbData]    : The data to sign
**            [f_cbData]    : The number of bytes to sign 
**            [f_rgbLU]     : Computed by _Omac1_GenerateSignInfo
**            [f_rgbLU_1]   : Computed by _Omac1_GenerateSignInfo
**            [f_rgbTag]    : The generated OMAC1 tag
**
** Returns:   DRM_SUCCESS
**              Success
**            DRM_E_INVALIDARG
**              One of the pointers was NULL, or the byte count is 0
**********************************************************************************************/
static DRM_NO_INLINE DRM_RESULT DRM_CALL _Omac1_GenerateSignTag(  
    __in_ecount( 1 )                 const DRM_AES_KEY *f_pKey,
    __in_bcount( f_ibData+f_cbData ) const DRM_BYTE    *f_pbData,
    __in                                   DRM_DWORD    f_ibData,
    __in                                   DRM_DWORD    f_cbData,
    __in_bcount( DRM_AES_BLOCKLEN )  const DRM_BYTE     f_rgbLU  [__CB_DECL( DRM_AES_BLOCKLEN )],
    __in_bcount( DRM_AES_BLOCKLEN )  const DRM_BYTE     f_rgbLU_1[__CB_DECL( DRM_AES_BLOCKLEN )],
    __out_bcount( DRM_AES_BLOCKLEN )       DRM_BYTE     f_rgbTag [__CB_DECL( DRM_AES_BLOCKLEN )] )
{
    DRM_RESULT dr           = DRM_SUCCESS;
    DRM_DWORD  ibDataInCur  = 0;
    DRM_BYTE   rgbDataBlock    [__CB_DECL( DRM_AES_BLOCKLEN )] = { 0 }; 
    DRM_BYTE   rgbLastDataBlock[__CB_DECL( DRM_AES_BLOCKLEN )] = { 0 };

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMAES, PERF_FUNC_Omac1_GenerateSignTag );

    ChkArg( f_pKey   != NULL );
    ChkArg( f_pbData != NULL );
    ChkArg( f_cbData  > 0 );

    do
    {
        if( f_cbData > DRM_AES_BLOCKLEN )
        {
            DRM_BYT_CopyBytes(rgbDataBlock, 0, f_pbData, f_ibData + ibDataInCur, DRM_AES_BLOCKLEN);
            DRM_XOR( rgbDataBlock, rgbLastDataBlock, DRM_AES_BLOCKLEN );
            MEMCPY( rgbLastDataBlock, rgbDataBlock, DRM_AES_BLOCKLEN );

            Oem_Aes_EncryptOne( f_pKey, rgbLastDataBlock );

            f_cbData -= DRM_AES_BLOCKLEN;
            ibDataInCur += DRM_AES_BLOCKLEN;
        }
        else
        {
            if( f_cbData == DRM_AES_BLOCKLEN )
            {
                DRM_BYT_CopyBytes(rgbDataBlock, 0, f_pbData, f_ibData + ibDataInCur, DRM_AES_BLOCKLEN);
                DRM_XOR( rgbDataBlock, rgbLastDataBlock, DRM_AES_BLOCKLEN );
                DRM_XOR( rgbDataBlock, f_rgbLU, DRM_AES_BLOCKLEN );
            }
            else
            {
                MEMSET( rgbDataBlock, 0, DRM_AES_BLOCKLEN );

                DRM_BYT_CopyBytes(rgbDataBlock, 0, f_pbData, f_ibData + ibDataInCur, f_cbData);
                PUT_BYTE( rgbDataBlock, f_cbData, 0x80 );

                DRM_XOR( rgbDataBlock, rgbLastDataBlock, DRM_AES_BLOCKLEN );
                DRM_XOR( rgbDataBlock, f_rgbLU_1, DRM_AES_BLOCKLEN );
            }

            ChkDR( Oem_Aes_EncryptOne( f_pKey, rgbDataBlock ) );

            f_cbData = 0;
        }
        
    } while( f_cbData > 0 );

    MEMCPY( f_rgbTag, rgbDataBlock, DRM_AES_BLOCKLEN );

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}



/*********************************************************************************************
** 
** Function:  _Omac1_GenerateSignInfo 
**
** Synopsis:  Computes the OMAC1 sign info
**
** Arguments: [f_pKey]      : The AES secret key
**            [f_rgbLU]     : Computed L.u from the OMAC algorithm
**            [f_rgbLU_1]   : Computed L.u2 from the OMAC algorithm
**
** Returns:   DRM_SUCCESS
**              Success
**            DRM_E_INVALIDARG
**              The key pointer was NULL
**********************************************************************************************/
static DRM_NO_INLINE DRM_RESULT DRM_CALL _Omac1_GenerateSignInfo(
    __in_ecount( 1 )                 const DRM_AES_KEY *f_pKey,
    __out_bcount( DRM_AES_BLOCKLEN )       DRM_BYTE     f_rgbLU  [__CB_DECL( DRM_AES_BLOCKLEN )],
    __out_bcount( DRM_AES_BLOCKLEN )       DRM_BYTE     f_rgbLU_1[__CB_DECL( DRM_AES_BLOCKLEN )] )
{
    DRM_RESULT dr                                       = DRM_SUCCESS;
    DRM_BYTE   rgbBuffer[__CB_DECL( DRM_AES_BLOCKLEN )] = { 0 };
    const DRM_BYTE bLU_ComputationConstant              = 0x87;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMAES, PERF_FUNC_Omac1_GenerateSignInfo );

    ChkArg( f_pKey != NULL );

    ChkDR( Oem_Aes_EncryptOne( f_pKey, rgbBuffer ) );

    /*
    ** Compute L.u from the OMAC algorithm
    */
    ChkDR( DRM_UTL_LShift( rgbBuffer, f_rgbLU, DRM_AES_BLOCKLEN ) );

    if( GET_BYTE( rgbBuffer, 0 ) & 0x80 )
    {
        PUT_BYTE( f_rgbLU, DRM_AES_BLOCKLEN - 1, 
                  GET_BYTE( f_rgbLU, DRM_AES_BLOCKLEN - 1 ) ^ bLU_ComputationConstant );
    }

    /*
    ** Compute L.u2 from the OMAC algorithm ( OMAC1 veriant )
    */
    ChkDR( DRM_UTL_LShift( f_rgbLU, f_rgbLU_1, DRM_AES_BLOCKLEN ) );

    if( GET_BYTE( f_rgbLU, 0 ) & 0x80 )
    {
        PUT_BYTE( f_rgbLU_1, DRM_AES_BLOCKLEN - 1, 
                  GET_BYTE( f_rgbLU_1, DRM_AES_BLOCKLEN - 1 ) ^ bLU_ComputationConstant );
    }

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/*********************************************************************************************
** 
** Function:  DRM_Omac1_Sign 
**
** Synopsis:  Generates a signature using an OMAC of the data and an AES key
**
** Arguments: [f_pKey]      : The AES secret key
**            [f_pbData]    : The data to sign
**            [f_ibData]    : The starting byte offset of the data to sign
**            [f_cbData]    : The number of bytes to sign 
**            [f_rgbTag]    : The generated OMAC1 tag
**
** Returns:   DRM_SUCCESS
**              Success
**            DRM_E_INVALIDARG
**              The plain text is too long or one of the pointers is NULL
**********************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_Omac1_Sign(
    __in_ecount( 1 )                       const DRM_AES_KEY *f_pKey,
    __in_bcount( f_ibData + f_cbData )     const DRM_BYTE    *f_pbData,
    __in                                   DRM_DWORD    f_ibData,
    __in                                   DRM_DWORD    f_cbData,
    __out_bcount( DRM_AES_BLOCKLEN )       DRM_BYTE     f_rgbTag[__CB_DECL( DRM_AES_BLOCKLEN )] )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BYTE   rgbLU  [__CB_DECL( DRM_AES_BLOCKLEN )] = { 0 };
    DRM_BYTE   rgbLU_1[__CB_DECL( DRM_AES_BLOCKLEN )] = { 0 };

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMAES, PERF_FUNC_DRM_Omac1_Sign );

    ChkArg( f_pbData != NULL && f_cbData > 0 );
    ChkArg( f_rgbTag != NULL );
    ChkArg( f_pKey   != NULL );

    ChkDR( _Omac1_GenerateSignInfo( f_pKey, 
                                    rgbLU, 
                                    rgbLU_1 ) );

    ChkDR( _Omac1_GenerateSignTag( f_pKey, 
                                   f_pbData,
                                   f_ibData,
                                   f_cbData, 
                                   rgbLU, 
                                   rgbLU_1, 
                                   f_rgbTag ) );

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/*********************************************************************************************
** 
** Function:  DRM_Omac1_Verify 
**
** Synopsis:  Verifies a signature using an OMAC of the data and an AES key
**
** Arguments: [f_pKey]      : The AES secret key
**            [f_pbData]    : The signed data 
**            [f_ibData]    : The starting byte offset of the data to verify
**            [f_cbData]    : The number of bytes signed 
**            [f_rgbTag]    : The OMAC1 tag to verify
**
** Returns:   DRM_SUCCESS
**                The specified signature matches the computed signature
**            DRM_E_INVALID_SIGNATURE
**                The specified signature does not match the computed signature
**            DRM_E_INVALIDARG
**              One of the pointers is NULL 
**********************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_Omac1_Verify(
    __in_ecount( 1 )                const DRM_AES_KEY *f_pKey,
    __in_bcount(f_ibData+f_cbData)  const DRM_BYTE    *f_pbData,
    __in                                  DRM_DWORD    f_ibData,
    __in                                  DRM_DWORD    f_cbData,
    __in_bcount(f_ibSignature+DRM_AES_BLOCKLEN) const DRM_BYTE *f_pbSignature,
    __in                                  DRM_DWORD    f_ibSignature )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BYTE   rgbComputedSignature[__CB_DECL( DRM_AES_BLOCKLEN )] = { 0 };

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMAES, PERF_FUNC_DRM_Omac1_Verify );

    ChkArg( f_pKey   != NULL );
    ChkArg( f_pbData != NULL && f_cbData > 0 );

    /*
    ** Compute the signature
    */
    ChkDR( DRM_Omac1_Sign( f_pKey, f_pbData, f_ibData, f_cbData, rgbComputedSignature ) );

    /*
    ** Compare the computed signature to the passed in signature
    */
    ChkBOOL( DRM_BYT_CompareBytes( rgbComputedSignature, 0, f_pbSignature, f_ibSignature, DRM_AES_BLOCKLEN ) == 0, DRM_E_INVALID_SIGNATURE );
    
ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmbcertbuilder.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmtypes.h>
#include <byteorder.h>
#include <drmerr.h>
#include <drmprofile.h>
#include <drmprofileconstants.h>
#include <drmsha256.h>
#include <drmeccp256.h>
#include <drmbcertbuilder.h>
#include <oem.h>

ENTER_PK_NAMESPACE_CODE;

#define SIZEOF_CHAIN_HEADER     SIZEOF( DRM_BCERT_CHAIN_HEADER )
#define SIZEOF_OBJ_HEADER       SIZEOF( DRM_BCERT_OBJECT_HEADER )
#define SIZEOF_BASIC_INFO       SIZEOF( DRM_BCERT_BASIC_INFO )
#define SIZEOF_PC_INFO          SIZEOF( DRM_BCERT_PC_INFO )
#define SIZEOF_SILVERLIGHT_INFO SIZEOF( DRM_BCERT_SILVERLIGHT_INFO )
#define SIZEOF_DEVICE_INFO      SIZEOF( DRM_BCERT_DEVICE_INFO )
#define SIZEOF_SERVER_INFO      SIZEOF( DRM_BCERT_SERVER_INFO )

/*****************************************************************************
** Function:    _calcManufacturerInfoSize
**
** Synopsis:    Calculates the size of the optional Manufacturer Information element.
**
** Arguments:   [f_pManufacturerStrings] : A pointer to the manufacturing strings; may be NULL
**              [f_pcbSize]              : A pointer to a size variable to be updated
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_INVALIDARG - if the output parm is NULL
**
** Notes:       None.
**
******************************************************************************/
static DRM_RESULT _calcManufacturerInfoSize(
   __in_ecount_opt(1)  DRM_BCERT_MANUFACTURER_STRINGS  *f_pManufacturerStrings,
   __inout             DRM_DWORD                       *f_pcbSize
)
{
    DRM_RESULT  dr = DRM_SUCCESS;

    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_calcManufacturerInfoSize );
    
    ChkArg( f_pcbSize != NULL );

    if ( f_pManufacturerStrings != NULL )
    {
        *f_pcbSize = SIZEOF_OBJ_HEADER
                     + SIZEOF( DRM_DWORD )                                          /* flags */
                     + SIZEOF( DRM_DWORD )                       /* manufacturer name length */
                     + f_pManufacturerStrings->ManufacturerName.cb      /* manufacturer name */
                     + PAD_AMOUNT( f_pManufacturerStrings->ManufacturerName.cb )  /* padding */
                     + SIZEOF( DRM_DWORD )                              /* model name length */
                     + f_pManufacturerStrings->ModelName.cb                    /* model name */
                     + PAD_AMOUNT( f_pManufacturerStrings->ModelName.cb )         /* padding */
                     + SIZEOF( DRM_DWORD )                            /* model number length */
                     + f_pManufacturerStrings->ModelNumber.cb                /* model number */
                     + PAD_AMOUNT( f_pManufacturerStrings->ModelNumber.cb );      /* padding */
    }
    else
    {
        *f_pcbSize = 0;
    }
    
 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}



/*****************************************************************************
** Function:    _calcKeyInfoSize
**
** Synopsis:    Calculates the size of the Public Key Information element.
**
** Arguments:   [f_dwNumCertificateKeys] : The number of entries in the keys array
**              [f_rgoCertificateKeys]   : Array of cert public key structures
**              [f_pcbSize]              : A pointer to a size variable to be updated
**
** Returns:     DRM_SUCCESS                    - on success
**              DRM_E_INVALIDARG               - if the output param is NULL, 
**                                               or num of cert keys is zero
**              DRM_E_BCERT_INVALID_KEY_LENGTH - if the key length is zero
**
** Notes:       For future usability, this routine does not check for a specific
**              public key length, just that it is non-zero.
**
******************************************************************************/
static DRM_RESULT _calcKeyInfoSize(
  __in     const DRM_DWORD                  f_dwNumCertificateKeys,
  __in           DRM_BCERT_BUILDER_CERTKEY *f_rgoCertificateKeys,
  __inout        DRM_DWORD                 *f_pcbSize )
{
    DRM_RESULT  dr     = DRM_SUCCESS;
    DRM_DWORD   iCount = 0;
    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_calcKeyInfoSize );
    
    ChkArg( f_dwNumCertificateKeys != 0 );
    ChkArg( f_rgoCertificateKeys   != NULL );
    ChkArg( f_pcbSize              != NULL );

    *f_pcbSize = SIZEOF_OBJ_HEADER
               + SIZEOF( DRM_DWORD );    /* number of keys */

    for ( iCount = 0; iCount < f_dwNumCertificateKeys; iCount++ )
    {
        ChkBOOL( f_rgoCertificateKeys[iCount].wKeyLength != 0, DRM_E_BCERT_INVALID_KEY_LENGTH );

        *f_pcbSize += SIZEOF( DRM_WORD )                                                /* type                    */
                    + SIZEOF( DRM_WORD )                                                /* length                  */
                    + SIZEOF( DRM_DWORD )                                               /* flags                   */
                    + ( f_rgoCertificateKeys[iCount].wKeyLength / CHAR_BIT )            /* key value               */
                    + PAD_AMOUNT( f_rgoCertificateKeys[iCount].wKeyLength / CHAR_BIT )  /* key value padding       */
                    + SIZEOF( DRM_DWORD )                                               /* number of usage entries */
                    + f_rgoCertificateKeys[iCount].dwNumKeyUsages * SIZEOF(DRM_DWORD);  /* usage set               */
    }
    
 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}



/*****************************************************************************
** Function:    _calcFeatureInfoSize
**
** Synopsis:    Calculates the size of the Feature Information element.
**
** Arguments:   [f_dwNumFeatureEntries] : The number of entries in the features array; may be zero
**              [f_pcbSize]             : A pointer to a size variable to be updated
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_INVALIDARG - if the output parm is NULL
**
** Notes:       None.
**
******************************************************************************/
static DRM_RESULT _calcFeatureInfoSize(
  __in     const DRM_DWORD     f_dwNumFeatureEntries,
  __inout        DRM_DWORD    *f_pcbSize
)
{
    DRM_RESULT  dr = DRM_SUCCESS;

    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_calcFeatureInfoSize );
    
    ChkArg( f_pcbSize != NULL );
    
    *f_pcbSize = SIZEOF_OBJ_HEADER
                 + SIZEOF( DRM_DWORD )                               /* number of entries */
                 + ( f_dwNumFeatureEntries * SIZEOF( DRM_DWORD ) );  /* the entries */
    
 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/*****************************************************************************
** Function:    _calcExtDataSignKeyInfoSize
**
** Synopsis:    Calculates the size of extended data signature key info
**
** Arguments:   [f_pExtData]            : A pointer to all extended data input
**              [f_pcbSize]             : A pointer to a size variable to be updated
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_INVALIDARG - if the output parm is NULL
**
** Notes:       None.
**
******************************************************************************/
static DRM_RESULT _calcExtDataSignKeyInfoSize( 
  __in     DRM_BCERT_EXT_BUILDER_DATA  *f_pExtData,
  __inout  DRM_DWORD                   *f_pcbSize
)
{
    DRM_RESULT  dr = DRM_SUCCESS;
    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_calcExtDataSignKeyInfoSize );
    
    ChkArg( f_pExtData != NULL );
    ChkArg( f_pcbSize != NULL );

    if ( f_pExtData->fValid )
    {
        *f_pcbSize = SIZEOF_OBJ_HEADER
            + SIZEOF( DRM_WORD )                                      /* type              */
            + SIZEOF( DRM_WORD )                                      /* length            */
            + SIZEOF( DRM_DWORD )                                     /* flags             */
            + ( f_pExtData->wExtDataKeyLength / CHAR_BIT )            /* key value         */
            + PAD_AMOUNT( f_pExtData->wExtDataKeyLength / CHAR_BIT ); /* key value padding */
    }
    else
    {
        *f_pcbSize = 0;
    }
    
 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/*****************************************************************************
** Function:    _calcExtDataContainerSize
**
** Synopsis:    Calculates the size of extended data container object
**              including everything in it.
**
** Arguments:   [f_pExtData]            : A pointer to all extended data input
**              [f_pcbSize]             : A pointer to a container size to be updated
**              [f_pcbRecordSize]       : A pointer to a record size to be updated
**              [f_pcbSignatureSize]    : A pointer to a signature size to be updated
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_INVALIDARG - if the output parm is NULL
**
** Notes:       None.
**
******************************************************************************/
static DRM_RESULT _calcExtDataContainerSize( 
  __in        DRM_BCERT_EXT_BUILDER_DATA *f_pExtData,
  __inout     DRM_DWORD                  *f_pcbContainerSize,
  __inout_opt DRM_DWORD                  *f_pcbRecordSize,
  __inout_opt DRM_DWORD                  *f_pcbSignatureSize
)
{
    DRM_RESULT  dr                = DRM_SUCCESS;
    DRM_DWORD   dwBlobLength      = 0;
    DRM_DWORD   dwRecordSize      = 0;
    DRM_DWORD   dwSignatureSize   = 0;
    DRM_WORD    wSignatureLength  = 0;
    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_calcExtDataContainerSize );

    ChkArg( f_pExtData != NULL );    
    ChkArg( f_pcbContainerSize != NULL );

    if ( f_pExtData->fValid )
    {
        /*
        ** Even we add extended data record to the cert later 
        ** its length and type should be known now.
        */
        ChkBOOL( f_pExtData->dwNumExtDataRecords == 1, DRM_E_BCERT_INVALID_NUMBER_EXTDATARECORDS );
        ChkBOOL( f_pExtData->pExtDataRecords != NULL, DRM_E_BCERT_INVALID_NUMBER_EXTDATARECORDS );
        
        ChkBOOL( f_pExtData->pExtDataRecords[0].dwDataLength > 0, DRM_E_BCERT_INVALID_EXTDATARECORD );
        
        dwBlobLength = f_pExtData->pExtDataRecords[0].dwDataLength;
        
        if ( f_pExtData->wExtDataSignatureType == DRM_BCERT_SIGNATURE_TYPE_P256 )
        {
            wSignatureLength = SIZEOF( SIGNATURE_P256 );
        }
        else
        {
            ChkDR( DRM_E_BCERT_INVALID_SIGNATURE_TYPE );
        }

        dwRecordSize = SIZEOF_OBJ_HEADER                             /* extended data record header */ 
                     + SIZEOF( DRM_DWORD )                           /* data length */
                     + dwBlobLength                                  /* data blob */
                     + PAD_AMOUNT( dwBlobLength );                   /* padding */

        dwSignatureSize = SIZEOF_OBJ_HEADER                          /* signature obj header */ 
                        + SIZEOF( DRM_WORD )                         /* signature type */
                        + SIZEOF( DRM_WORD )                         /* signature length */
                        + wSignatureLength                           /* signature data */
                        + PAD_AMOUNT( wSignatureLength );            /* padding */

        *f_pcbContainerSize = SIZEOF_OBJ_HEADER                      /* container obj header */
                            + dwRecordSize
                            + dwSignatureSize;

        DRMASSERT( PAD_AMOUNT(*f_pcbContainerSize) == 0 );  /* calculated size is always 32 bit aligned */
    }
    else
    {
        dwRecordSize = 0;
        dwSignatureSize = 0;
        *f_pcbContainerSize = 0;
    }
    if ( f_pcbRecordSize != NULL )
    {
        *f_pcbRecordSize = dwRecordSize;
    }
    if ( f_pcbSignatureSize != NULL )
    {
        *f_pcbSignatureSize = dwSignatureSize;
    }
    
 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/*****************************************************************************
** Function:    _calcSignatureInfoSize
**
** Synopsis:    Calculates the size of the Signature Information element.
**
** Arguments:   [f_wSignatureType]    : The type of signature signing the certificate
**              [f_dwIssuerKeyLength] : The issuer key length (in bits)
**              [f_pcbSize]           : A pointer to a size variable to be updated
**
** Returns:     DRM_SUCCESS                        - on success
**              DRM_E_INVALIDARG                   - if the output parm is NULL
**              DRM_E_BCERT_INVALID_SIGNATURE_TYPE - if the signature type is unsupported
**
** Notes:       This routine will need to be modified if/when new signature types are supported.
**
******************************************************************************/
static DRM_RESULT _calcSignatureInfoSize(
  __in     const DRM_WORD      f_wSignatureType,  
  __in     const DRM_DWORD     f_dwIssuerKeyLength,
  __inout        DRM_DWORD    *f_pcbSize
)
{
    DRM_RESULT  dr               = DRM_SUCCESS;
    DRM_WORD    wSignatureLength = 0;

    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_calcSignatureInfoSize );
    
    ChkArg( f_pcbSize != NULL );
    
    /*
    ** The signature length (in bytes) is determined from the signature type
    */
    if ( f_wSignatureType == DRM_BCERT_SIGNATURE_TYPE_P256 )
    {
        wSignatureLength = SIZEOF( SIGNATURE_P256 );
    }
    else
    {
        ChkDR( DRM_E_BCERT_INVALID_SIGNATURE_TYPE );
    }
    
    *f_pcbSize = SIZEOF_OBJ_HEADER
                + SIZEOF( DRM_WORD )                             /* signature type    */
                + SIZEOF( DRM_WORD )                             /* signature length  */
                + wSignatureLength                               /* signature data    */
                + PAD_AMOUNT( wSignatureLength )                 /* padding           */
                + SIZEOF( DRM_DWORD )                            /* issuer key length */
                + ( f_dwIssuerKeyLength / CHAR_BIT )             /* issuer key value  */
                + PAD_AMOUNT( f_dwIssuerKeyLength / CHAR_BIT );  /* padding           */
    
 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}



/*****************************************************************************
** Function:    _calcDomainInfoSize
**
** Synopsis:    Calculates the size of the Domain Information element.
**
** Arguments:   [f_dwDomainURLLength] : The domain URL length in bytes, including NULL terminator
**              [f_pcbSize]           : A pointer to a size variable to be updated
**
** Returns:     DRM_SUCCESS                     - on success
**              DRM_E_INVALIDARG                - if the output parm is NULL
**              DRM_E_BCERT_DOMAIN_URL_TOO_LONG - if the length is greater than the max supported
**
** Notes:       None.
**
******************************************************************************/
static DRM_RESULT _calcDomainInfoSize(
  __in     const  DRM_DWORD     f_dwDomainURLLength,
  __inout         DRM_DWORD    *f_pcbSize
)
{
    DRM_RESULT  dr = DRM_SUCCESS;


    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_calcDomainInfoSize );
    
    ChkArg( f_pcbSize != NULL );
    
    /*
    ** Check supported Domain URL Length
    */
    ChkBOOL( f_dwDomainURLLength <= DRM_BCERT_MAX_DOMAIN_URL_LENGTH, DRM_E_BCERT_DOMAIN_URL_TOO_LONG );

    *f_pcbSize = SIZEOF_OBJ_HEADER
                 + DRM_BCERT_SERVICE_ID_LENGTH
                 + DRM_BCERT_ACCOUNT_ID_LENGTH
                 + SIZEOF( DRM_DWORD )                 /* Revision          */
                 + SIZEOF( DRM_DWORD )                 /* Domain URL length */
                 + f_dwDomainURLLength                 /* Domain URL        */
                 + PAD_AMOUNT( f_dwDomainURLLength );  /* padding           */
    
 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/*****************************************************************************
** Function:    _calcMeteringInfoSize
**
** Synopsis:    Calculates the size of the Metering Information element.
**
** Arguments:   [f_dwMeteringURLLength] : The metering URL length in bytes, including NULL terminator
**              [f_pcbSize]             : A pointer to a size variable to be updated
**
** Returns:     DRM_SUCCESS                       - on success
**              DRM_E_INVALIDARG                  - if the output parm is NULL
**              DRM_E_BCERT_METERING_URL_TOO_LONG - if the length is greater than the max supported
**
** Notes:       None.
**
******************************************************************************/
static DRM_RESULT _calcMeteringInfoSize(
  __in     const  DRM_DWORD     f_dwMeteringURLLength,
  __inout         DRM_DWORD    *f_pcbSize
)
{
    DRM_RESULT  dr = DRM_SUCCESS;


    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_calcMeteringInfoSize );
    
    ChkArg( f_pcbSize != NULL );
    
    /*
    ** Check supported Metering URL Length
    */
    ChkBOOL( f_dwMeteringURLLength <= DRM_BCERT_MAX_METERING_URL_LENGTH, DRM_E_BCERT_METERING_URL_TOO_LONG );

    *f_pcbSize = SIZEOF_OBJ_HEADER
                 + DRM_BCERT_METERING_ID_LENGTH
                 + SIZEOF( DRM_DWORD )                   /* Metering URL length */                 
                 + f_dwMeteringURLLength                 /* Metering URL        */
                 + PAD_AMOUNT( f_dwMeteringURLLength );  /* padding           */
    
 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/*****************************************************************************
** Function:    _calcCertSize
**
** Synopsis:    Calculates two values:
**              - the size of the whole certificate being added, and
**              - the size of the certificate up to the Signature Info object.
**
** Arguments:   [f_pData]              : Pointer to all the input data
**              [f_pcbSize]            : Pointer to a variable to update w/ cert size (in bytes)
**              [f_pcbSignatureInfo]   : Pointer to a variable to update w/ signing size (in bytes)
**
** Returns:     DRM_SUCCESS                   - on success
**              DRM_E_INVALIDARG              - if any parameter is NULL
**              DRM_E_BCERT_INVALID_CERT_TYPE - if the specified certificate type is unknown
**              or other return code from a function called within
**
** Notes:       None.
**
******************************************************************************/
static DRM_RESULT _calcCertSize(
  __in     DRM_BCERT_BUILDER_DATA  *f_pData,
  __inout  DRM_DWORD               *f_pcbSize,
  __inout  DRM_DWORD               *f_pcbSignatureInfo,
  __inout  DRM_DWORD               *f_pcbExtendedData
)
{
    DRM_RESULT  dr                   = DRM_SUCCESS;
    DRM_DWORD   cbFeatureInfo        = 0;
    DRM_DWORD   cbKeyInfo            = 0;
    DRM_DWORD   cbManufacturerInfo   = 0;
    DRM_DWORD   cbExtDataSignKeyInfo = 0;
    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_calcCertSize );
    
    ChkArg( f_pData            != NULL );
    ChkArg( f_pcbSize          != NULL );
    ChkArg( f_pcbSignatureInfo != NULL );

    /*
    ** Calculate the sizes of the variable-length common elements
    */
    ChkDR( _calcFeatureInfoSize( f_pData->dwNumFeatureEntries, &cbFeatureInfo ) );    
    ChkDR( _calcKeyInfoSize( f_pData->dwNumCertificateKeys, f_pData->pCertificateKeys, &cbKeyInfo ) );   
    ChkDR( _calcSignatureInfoSize( f_pData->wSignatureType, f_pData->dwIssuerKeyLength, f_pcbSignatureInfo ) );
    ChkDR( _calcManufacturerInfoSize( f_pData->pManufacturerStrings, &cbManufacturerInfo ) );
    ChkDR( _calcExtDataSignKeyInfoSize( &f_pData->ExtendedData, &cbExtDataSignKeyInfo ) );
    ChkDR( _calcExtDataContainerSize( &f_pData->ExtendedData, f_pcbExtendedData, NULL, NULL ) );

    /*
    ** Add-up the sizes of all the common elements
    */
    *f_pcbSize = SIZEOF( DRM_BCERT_HEADER )
                 + SIZEOF_BASIC_INFO
                 + cbFeatureInfo
                 + cbKeyInfo
                 + cbManufacturerInfo
                 + cbExtDataSignKeyInfo
                 + *f_pcbSignatureInfo
                 + *f_pcbExtendedData;     /* Always add ext data to the certificate size */

    /*
    ** Add-on the size of any cert-specific element
    */
    switch ( f_pData->dwType )
    {
        case DRM_BCERT_CERTTYPE_ISSUER:
        case DRM_BCERT_CERTTYPE_CRL_SIGNER:
        case DRM_BCERT_CERTTYPE_SERVICE:
        case DRM_BCERT_CERTTYPE_APPLICATION:
        case DRM_BCERT_CERTTYPE_KEYFILESIGNER:
        {
            break;  /* accurate size already calculated above */
        }

        case DRM_BCERT_CERTTYPE_PC:
        {
            *f_pcbSize += SIZEOF_PC_INFO;
            break;
        }

        case DRM_BCERT_CERTTYPE_SILVERLIGHT:
        {
            *f_pcbSize += SIZEOF_SILVERLIGHT_INFO;
            break;
        }

        case DRM_BCERT_CERTTYPE_DEVICE:
        {
            *f_pcbSize += SIZEOF_DEVICE_INFO;
            break;
        }

        case DRM_BCERT_CERTTYPE_DOMAIN:
        {
            DRM_DWORD   cbDomainInfo = 0;
            ChkBOOL( f_pData->Type.DomainData.pDomainURL     != NULL, DRM_E_BCERT_DOMAIN_URL_NOT_SPECIFIED );
            ChkBOOL( f_pData->Type.DomainData.pDomainURL->cb >  0,    DRM_E_BCERT_DOMAIN_URL_NOT_SPECIFIED );
            _calcDomainInfoSize( f_pData->Type.DomainData.pDomainURL->cb, &cbDomainInfo );
            *f_pcbSize += cbDomainInfo;
            break;
        }

        case DRM_BCERT_CERTTYPE_METERING:
        {
            DRM_DWORD   cbMeteringInfo = 0;
            ChkBOOL( f_pData->Type.MeteringData.pMeteringURL     != NULL, DRM_E_BCERT_METERING_URL_NOT_SPECIFIED );
            ChkBOOL( f_pData->Type.MeteringData.pMeteringURL->cb >  0,    DRM_E_BCERT_METERING_URL_NOT_SPECIFIED );
            _calcMeteringInfoSize( f_pData->Type.MeteringData.pMeteringURL->cb, &cbMeteringInfo );
            *f_pcbSize += cbMeteringInfo;        
            break;
        }

        case DRM_BCERT_CERTTYPE_SERVER:
        {
            *f_pcbSize += SIZEOF_SERVER_INFO;
            break;
        }

        default:
        {
            ChkDR( DRM_E_BCERT_INVALID_CERT_TYPE );
            break;
        }     
    }
 
 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}



/*****************************************************************************
** Function:    _checkBuffer
**
** Synopsis:    Determines if the buffer provided by the user to contain the
**              new certificate chain is large enough.
**
** Arguments:   [f_pbParentChain] : A buffer pointer to an existing certificate chain; may be NULL
**              [f_pbNewChain]    : A buffer pointer for the new certificate chain; may be NULL
**              [f_pcbNewChain]   : A pointer to new chain buffer size (in bytes)
**              [f_dwCertSize]    : The size of the new certificate being added to chain
**
** Returns:     DRM_SUCCESS          - on success
**              DRM_E_INVALIDARG     - if the size parm is NULL, or if the new cert size is zero
**              DRM_E_BUFFERTOOSMALL - if provided new chain buffer is missing or too small
**
** Notes:       None.
**
******************************************************************************/
static DRM_RESULT _checkBuffer ( 
                  DRM_BYTE  *f_pbParentChain,
                  DRM_BYTE  *f_pbNewChain,
  __inout         DRM_DWORD *f_pcbNewChain,
  __in     const  DRM_DWORD  f_dwCertSize
)
{
    DRM_RESULT  dr             = DRM_SUCCESS;
    DRM_DWORD   dwMemoryNeeded = 0;


    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_checkBuffer );
    
    ChkArg( f_pcbNewChain != NULL );
    ChkArg( f_dwCertSize  != 0    );
    
    /*
    ** If this is the first certificate in the chain, start with the size of the chain header.
    ** Otherwise, we are adding an additional certificate, so start with the memory needed
    ** for the existing/parent chain.
    */
    if ( f_pbParentChain == NULL )
    {
        dwMemoryNeeded = SIZEOF_CHAIN_HEADER;
    }
    else
    {
        NETWORKBYTES_TO_DWORD( dwMemoryNeeded, f_pbParentChain, DRM_BCERT_CHAIN_SIZE_OFFSET );
    }

    /*
    ** Add the size of the new certificate being added
    */
    dwMemoryNeeded += f_dwCertSize;
            
    /*
    ** Inform caller of memory requirement if the provided buffer is missing or insufficient
    */
    if ( ( f_pbNewChain == NULL ) || ( *f_pcbNewChain < dwMemoryNeeded ) )
    {
        *f_pcbNewChain = dwMemoryNeeded;
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }
    
    /*
    ** Buffer is big enough, update the parameter with the exact size of the new chain
    */
    *f_pcbNewChain = dwMemoryNeeded;
    
 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}



/*****************************************************************************
** Function:    _addAlignedData
**
** Synopsis:    Adds a sequence of bytes to a binary certificate, with padding
**              characters inserted at the end to ensure alignment on a 32-bit boundary.
**
** Arguments:   [f_pbDestination] : A pointer to a buffer to receive the bytes
**              [f_pdwDestOffset] : A pointer to the offset within the destination buffer; updated
**              [f_pbSource]      : Address of where to get the bytes from
**              [f_cbAmount]      : How many bytes to copy
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_INVALIDARG - if any parameter is invalid
**
** Notes:       None.
**
******************************************************************************/
static DRM_RESULT _addAlignedData(
  __out_bcount(f_cbAmount + *f_pdwDestOffset + 3) DRM_BYTE   *f_pbDestination,
  __inout                                         DRM_DWORD  *f_pdwDestOffset,
  __in_bcount(f_cbAmount)                         DRM_BYTE   *f_pbSource,
  __in                                     const  DRM_DWORD   f_cbAmount
)
{
    DRM_RESULT  dr         = DRM_SUCCESS;
    DRM_DWORD   dwPadCount = 0;
    DRM_BYTE    bPadValue  = '\0';


    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_addAlignedData );

    ChkArg( f_pbDestination != NULL );
    ChkArg( f_pdwDestOffset != NULL );
    ChkArg( f_pbSource      != NULL );
    ChkArg( f_cbAmount       > 0    );
    
    DRM_BYT_CopyBytes( f_pbDestination, *f_pdwDestOffset, f_pbSource, 0, f_cbAmount );
    *f_pdwDestOffset += f_cbAmount;

    /* Padding, if needed to align on 32-bit boundary */
    for ( dwPadCount = PAD_AMOUNT( f_cbAmount ); dwPadCount > 0; dwPadCount-- )
    {
        PUT_BYTE( f_pbDestination, (*f_pdwDestOffset)++, bPadValue );
    }  
    
 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}



/*****************************************************************************
** Function:    _updateCertChainHeader
**
** Synopsis:    Increases the following two values in the certificate chain header:
**              - the total number of bytes in the certificate chain
**              - the count of the number of certificates in the certificate chain
**
** Arguments:   [f_pbBuffer] : A buffer pointer containing a certificate chain
**              [f_cbCert]   : How many bytes were in the new certifcate just added
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_INVALIDARG - if either parameter is invalid
**
** Notes:       None.
**
******************************************************************************/
static DRM_RESULT _updateCertChainHeader (
              DRM_BYTE  *f_pbBuffer, 
  __in  const DRM_DWORD  f_cbCert
)
{
    DRM_RESULT         dr      = DRM_SUCCESS;
    DRM_DWORD          cbChain = 0;
    DRM_DWORD          cCerts  = 0;


    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_updateCertChainHeader );
    
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_cbCert    > 0 );

    /* 
    ** Update the length in bytes of binary certificate chain structure, including this structure.
    ** Get the current value, increment it, then set the new value.
    */
    NETWORKBYTES_TO_DWORD( cbChain, f_pbBuffer, DRM_BCERT_CHAIN_SIZE_OFFSET);
    cbChain += f_cbCert;
    DWORD_TO_NETWORKBYTES( f_pbBuffer, DRM_BCERT_CHAIN_SIZE_OFFSET, cbChain);
    
    /* 
    ** Update the number of entries in this certificate chain.
    ** Get the current value, increment it, then set the new value.
    */
    NETWORKBYTES_TO_DWORD( cCerts, f_pbBuffer, DRM_BCERT_CHAIN_COUNT_OFFSET);
    cCerts += 1;
    DWORD_TO_NETWORKBYTES( f_pbBuffer, DRM_BCERT_CHAIN_COUNT_OFFSET, cCerts );

 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}



/*****************************************************************************
** Function:    _addCertChainHeader
**
** Synopsis:    Adds the certificate chain header to the certificate chain.
**
** Arguments:   [f_pbBuffer] : A pointer to an empty bufffer to contain the new certificate chain
**              [f_dwFlags]  : The flags (a bit-field) to set in the certificate chain header
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_INVALIDARG - if the buffer pointer is NULL
**
** Notes:       None.
**
******************************************************************************/
static DRM_RESULT _addCertChainHeader (
               DRM_BYTE   *f_pbBuffer,
  __in  const  DRM_DWORD   f_dwFlags  
)
{
    DRM_RESULT dr                = DRM_SUCCESS;
    DRM_DWORD  iBuffer           = 0;

    /*
    ** The following variables are necessary because the big-endian version of
    ** the DWORD_TO_NETWORKBYTES macro cannot take a constant as the last parameter.
    */
    DRM_DWORD  dwChainHeaderTag  = DRM_BCERT_CHAIN_HEADER_TAG;
    DRM_DWORD  dwChainVersion    = DRM_BCERT_CHAIN_VERSION;
    DRM_DWORD  dwChainHeaderSize = SIZEOF_CHAIN_HEADER;
    DRM_DWORD  dwZero            = 0;


    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_addCertChainHeader );
    
    ChkArg( f_pbBuffer != NULL );

    /* 
    ** Add the Chain Header Tag & Chain Version
    */
    DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, dwChainHeaderTag );
    iBuffer += SIZEOF( DRM_DWORD );

    DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, dwChainVersion );
    iBuffer += SIZEOF( DRM_DWORD );

    /* 
    ** Add the length in bytes of binary certificate chain structure, including this structure.
    ** This will be updated after each certificate is added.
    */
    DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, dwChainHeaderSize );
    iBuffer += SIZEOF( DRM_DWORD );

    /* 
    ** Add any flags 
    */
    DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_dwFlags );
    iBuffer += SIZEOF( DRM_DWORD );

    /*
    ** Number of entries in this certificate chain. 
    ** This will be updated after each certificate is added.
    */
    DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, dwZero );
    
 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}



/*****************************************************************************
** Function:    _addCertHeader
**
** Synopsis:    Adds a certificate header.
**
** Arguments:   [f_pbBuffer]     : The address at which to start writing these data
**              [f_dwCertSize]   : The full size of the certificate being added (in bytes)
**              [f_dwSignedSize] : The signed-size of the certificate being added (in bytes)
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_INVALIDARG - if the buffer pointer is NULL or the sizes are not correct
**
** Notes:       None.
**
******************************************************************************/
static DRM_RESULT _addCertHeader (
              DRM_BYTE   *f_pbBuffer, 
  __in  const DRM_DWORD   f_dwCertSize,
  __in  const DRM_DWORD   f_dwSignedSize
)
{
    DRM_RESULT  dr            = DRM_SUCCESS;
    DRM_DWORD   iBuffer       = 0;

    /*
    ** The following variables are necessary because the big-endian version of
    ** the DWORD_TO_NETWORKBYTES macro cannot take a constant as the last parameter.
    */
    DRM_DWORD   dwHeaderTag   = DRM_BCERT_HEADER_TAG;
    DRM_DWORD   dwCertVersion = DRM_BCERT_VERSION;
    

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_addCertHeader );
    
    ChkArg( f_pbBuffer   != NULL );
    ChkArg( f_dwCertSize  > f_dwSignedSize );
        
    DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, dwHeaderTag );
    iBuffer += SIZEOF( DRM_DWORD );

    DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, dwCertVersion );
    iBuffer += SIZEOF( DRM_DWORD );

    DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_dwCertSize );
    iBuffer += SIZEOF( DRM_DWORD );
    
    DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_dwSignedSize );
    
 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}



/*****************************************************************************
** Function:    _addCertObjectHeader
**
** Synopsis:    Adds the header of a certificate object.
**
** Arguments:   [f_pbBuffer] : The address at which to start writing these data
**              [f_dwFlags]  : The flags (a bit-field) for this object header
**              [f_dwType]   : The type of certificate object that this is for
**              [f_cbLength] : The length of this certificate object
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_INVALIDARG - if any parameter is invalid
**
** Notes:       For future usability, this routine does not check the validity
**              of the certificate object type, just that it is non-zero.
**
******************************************************************************/
static DRM_RESULT _addCertObjectHeader (
                 DRM_BYTE    *f_pbBuffer,
  __in     const DRM_WORD     f_dwFlags,
  __in     const DRM_WORD     f_dwType,
  __in     const DRM_DWORD    f_cbLength)
{
    DRM_RESULT  dr      = DRM_SUCCESS;
    DRM_DWORD   iBuffer = 0;


    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_addCertObjectHeader );
    
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_dwType   != 0 );
    ChkArg( f_cbLength != 0 );

    /* 
    ** Add the Flags, Object Type, then Object Length.
    */
    WORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_dwFlags );
    iBuffer += SIZEOF( DRM_WORD );

    WORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_dwType );
    iBuffer += SIZEOF( DRM_WORD );

    DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_cbLength );
    
 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}



/*****************************************************************************
** Function:    _addCertBasicInfo
**
** Synopsis:    Adds the Basic Information object to a certificate.
**
** Arguments:   [f_pbBuffer] : The address at which to start writing these data
**              [f_pData]    : A pointer to all the input data
**
** Returns:     DRM_SUCCESS                          - on success
**              DRM_E_INVALIDARG                     - if either parameter is invalid
**              DRM_E_BCERT_CERT_ID_NOT_SPECIFIED    - if the certificate ID is NULL
**              DRM_E_BCERT_PUBLIC_KEY_NOT_SPECIFIED - if the certificate's public key is NULL
**              DRM_E_BCERT_INVALID_SECURITY_LEVEL   - if the security level is not correct
**              or other return code from a function called within
**
** Notes:       This object is a fixed length in size.
**              For future usability, this routine does not check for specific security
**              level values, just that it is non-zero.
**
******************************************************************************/
static DRM_RESULT _addCertBasicInfo (
          DRM_BYTE                  *f_pbBuffer,
  __in    DRM_BCERT_BUILDER_DATA    *f_pData
)
{
    DRM_RESULT            dr          = DRM_SUCCESS;
    DRM_DWORD             iBuffer     = SIZEOF_OBJ_HEADER;
    DRM_SHA256_Context    SHAContext  = {0};
    DRM_SHA256_Digest     DigestValue = {0};
    const DRM_BYTE        rgbZeroClientID[DRM_BCERT_CLIENT_ID_LENGTH] = {0};


    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_addCertBasicInfo );
    
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_pData    != NULL );

    /*
    ** Ensure that the Client ID is zero for Issuer, CRL Signer, and Service certificates
    */
    if ( ( f_pData->dwType == DRM_BCERT_CERTTYPE_ISSUER
         || f_pData->dwType == DRM_BCERT_CERTTYPE_CRL_SIGNER
         || f_pData->dwType == DRM_BCERT_CERTTYPE_SERVICE )
      && ( MEMCMP( f_pData->ClientID.rgb, rgbZeroClientID, DRM_BCERT_CLIENT_ID_LENGTH ) != 0 ) )
    {
        ChkDR( DRM_E_INVALIDARG );
    }
  
    /*
    ** Check data pointers & security level
    */
    ChkBOOL( f_pData->pCertificateID  != NULL, DRM_E_BCERT_CERT_ID_NOT_SPECIFIED    );
    ChkBOOL( f_pData->dwNumCertificateKeys != 0 && f_pData->pCertificateKeys != NULL, 
                DRM_E_BCERT_PUBLIC_KEY_NOT_SPECIFIED );

    /* 
    ** Add the Object Header 
    */
    ChkDR( _addCertObjectHeader( f_pbBuffer, 
                                 DRM_BCERT_OBJFLAG_MUST_UNDERSTAND, 
                                 DRM_BCERT_OBJTYPE_BASIC, 
                                 SIZEOF_BASIC_INFO ) );

    /* 
    ** Add the Certificate ID, Security Level, then the Flags 
    */
    DRM_BYT_CopyBytes( f_pbBuffer, iBuffer, f_pData->pCertificateID->rgb, 0, DRM_BCERT_CERT_ID_LENGTH );
    iBuffer += DRM_BCERT_CERT_ID_LENGTH;

    DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_pData->dwSecurityLevel );
    iBuffer += SIZEOF( DRM_DWORD );

    DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_pData->dwBasicFlags );
    iBuffer += SIZEOF( DRM_DWORD );

    /* 
    ** Add the Type (validity was determined previously when the cert size was calculated 
    */
    DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_pData->dwType );
    iBuffer += SIZEOF( DRM_DWORD );

    /* 
    ** Calculate the Digest Value by SHA256 hashing the public key of this certificate
    */
    ChkDR( DRM_SHA256_Init( &SHAContext ) );
    ChkDR( DRM_SHA256_Update( &SHAContext, 
                              f_pData->pCertificateKeys[0].KeyValue.rgb, 
                              f_pData->pCertificateKeys[0].wKeyLength / CHAR_BIT ) );
    ChkDR( DRM_SHA256_Finalize( &SHAContext, &DigestValue ) );

    /* 
    ** Add the Digest Value (calculated immediately above)
    */
    DRM_BYT_CopyBytes( f_pbBuffer, iBuffer, DigestValue.m_rgbDigest, 0, SHA256_DIGEST_SIZE_IN_BYTES );
    iBuffer += SHA256_DIGEST_SIZE_IN_BYTES;

    /* 
    ** Add the Expiration Date 
    */
    if ( f_pData->dwExpirationDate == 0 )
    {
        f_pData->dwExpirationDate = DRM_BCERT_DEFAULT_EXPIRATION_DATE;
    }
    DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_pData->dwExpirationDate );
    iBuffer += SIZEOF( DRM_DWORD );
    
    /* 
    ** Add the Client ID
    */
    DRM_BYT_CopyBytes( f_pbBuffer, iBuffer, f_pData->ClientID.rgb, 0, DRM_BCERT_CLIENT_ID_LENGTH );
    
 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}



/*****************************************************************************
** Function:    _addCertFeatureInfo
**
** Synopsis:    Adds the Feature Information object to a certificate.
**
** Arguments:   [f_pbBuffer]            : The address at which to start writing these data
**              [f_dwNumFeatureEntries] : The number of features in the features array; may be zero
**              [f_prgdwFeatureSet]     : A pointer to the features array; may be NULL
**              [f_pcbSize]             : Variable pointer to update w/ size of this object (in bytes)
**
** Returns:     DRM_SUCCESS                 - on success
**              DRM_E_INVALIDARG            - if any parameter is invalid
**              DRM_E_BCERT_INVALID_FEATURE - if any feature ID is not a supported value
**              or other return code from a function called within
**
** Notes:       For future usability, this routine does not check for appropriate certificate
**              type to feature mapping; that verification is part of the certificate parser.
**
******************************************************************************/
static DRM_RESULT _addCertFeatureInfo(
                                               DRM_BYTE   *f_pbBuffer,
  __in                                   const DRM_DWORD   f_dwNumFeatureEntries,
  __in_ecount_opt(f_dwNumFeatureEntries)       DRM_DWORD  *f_prgdwFeatureSet,
  __inout                                      DRM_DWORD  *f_pcbSize
)
{
    DRM_RESULT  dr       = DRM_SUCCESS;
    DRM_DWORD   iBuffer  = SIZEOF_OBJ_HEADER;
    DRM_DWORD   iFeature = 0;


    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_addCertFeatureInfo );
    
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_pcbSize  != NULL );

    ChkDR( _calcFeatureInfoSize( f_dwNumFeatureEntries, f_pcbSize ) );

    /* 
    ** Add the Object Header 
    */
    ChkDR( _addCertObjectHeader( f_pbBuffer, 
                                 DRM_BCERT_OBJFLAG_MUST_UNDERSTAND, 
                                 DRM_BCERT_OBJTYPE_FEATURE, 
                                 *f_pcbSize ) );
    
    /* 
    ** Add the Number of Feature Entries 
    */
    DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_dwNumFeatureEntries );
    iBuffer += SIZEOF( DRM_DWORD );
   
    /* 
    ** Add the Feature Set 
    */
    for ( iFeature = 0; iFeature < f_dwNumFeatureEntries; iFeature++ )
    {
        ChkArg( f_prgdwFeatureSet != NULL );
    
        if ( f_prgdwFeatureSet[ iFeature ] == 0
          || f_prgdwFeatureSet[ iFeature ] > DRM_BCERT_FEATURE_MAX_VALUE )
        {
            ChkDR( DRM_E_BCERT_INVALID_FEATURE );
        }
    
        DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_prgdwFeatureSet[ iFeature ] );
        iBuffer += SIZEOF( DRM_DWORD );
    }
    
 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}



/*****************************************************************************
** Function:    _addCertKeyInfo
**
** Synopsis:    Adds the Key Information object to a certificate.
**
** Arguments:   [f_pbBuffer] : The address at which to start writing these data
**              [f_pData]    : A pointer to all the input data
**              [f_pcbSize]  : Variable pointer to update w/ the size of this object (in bytes)
**
** Returns:     DRM_SUCCESS                          - on success
**              DRM_E_INVALIDARG                     - if any parameter is invalid
**              DRM_E_BCERT_PUBLIC_KEY_NOT_SPECIFIED - if the certificate's public key is NULL
**              DRM_E_BCERT_KEY_USAGES_NOT_SPECIFIED - if the key usage set is empty
**              DRM_E_BCERT_INVALID_KEY_TYPE         - if the specified key type is unsupported
**              DRM_E_BCERT_INVALID_KEY_LENGTH       - if the specified key length is unsupported
**              DRM_E_BCERT_INVALID_KEY_USAGE        - if any key usage ID is not a supported value
**              or other return code from a function called within
**
** Notes:       For future usability, this routine does not check for appropriate certificate
**              type to key-usage mapping; that verification is part of the certificate parser.
**
******************************************************************************/
static DRM_RESULT _addCertKeyInfo(
          DRM_BYTE                *f_pbBuffer,
  __in    DRM_BCERT_BUILDER_DATA  *f_pData,
  __inout DRM_DWORD               *f_pcbSize
)
{
    DRM_RESULT  dr       = DRM_SUCCESS;
    DRM_DWORD   iBuffer  = SIZEOF_OBJ_HEADER;
    DRM_DWORD   iUsage   = 0;
    DRM_DWORD   iCount   = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_addCertKeyInfo );
    
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_pData    != NULL );
    ChkArg( f_pcbSize  != NULL );
    
    ChkDR( _calcKeyInfoSize( f_pData->dwNumCertificateKeys, f_pData->pCertificateKeys, f_pcbSize ) );

    /* 
    ** Add the Object Header 
    */
    ChkDR( _addCertObjectHeader( f_pbBuffer, 
                                 DRM_BCERT_OBJFLAG_MUST_UNDERSTAND, 
                                 DRM_BCERT_OBJTYPE_KEY, 
                                 *f_pcbSize ) );

    /*
    ** Add number of cert keys
    */
    ChkBOOL( f_pData->dwNumCertificateKeys != 0 && f_pData->pCertificateKeys != NULL, 
                DRM_E_BCERT_PUBLIC_KEY_NOT_SPECIFIED );

    DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_pData->dwNumCertificateKeys );
    iBuffer += SIZEOF( DRM_DWORD );
    
    for ( iCount = 0; iCount < f_pData->dwNumCertificateKeys; iCount++ )
    {
        /*
        ** Check supported key types and key lengths
        */
        ChkBOOL( f_pData->pCertificateKeys[iCount].wKeyLength == ECC_P256_PUBKEY_SIZE_IN_BITS,
                DRM_E_BCERT_INVALID_KEY_LENGTH );        
        ChkBOOL( f_pData->pCertificateKeys[iCount].wKeyType == DRM_BCERT_KEYTYPE_ECC256,
                DRM_E_BCERT_INVALID_KEY_TYPE );
        /*
        ** Ensure that the key's usage set is provided
        */
        ChkBOOL( f_pData->pCertificateKeys[iCount].dwNumKeyUsages != 0
              && f_pData->pCertificateKeys[iCount].pKeyUsageSet != NULL,
                DRM_E_BCERT_KEY_USAGES_NOT_SPECIFIED );

        /* 
        ** Add the Key Type, Key Length, Key Flags, Key Value, Number of Usages 
        */
        WORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_pData->pCertificateKeys[iCount].wKeyType );
        iBuffer += SIZEOF( DRM_WORD );
    
        WORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_pData->pCertificateKeys[iCount].wKeyLength );
        iBuffer += SIZEOF( DRM_WORD );
    
        DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_pData->pCertificateKeys[iCount].dwKeyFlags );
        iBuffer += SIZEOF( DRM_DWORD );
    
        ChkDR( _addAlignedData( f_pbBuffer, 
                                &iBuffer, 
                                f_pData->pCertificateKeys[iCount].KeyValue.rgb, 
                                (f_pData->pCertificateKeys[iCount].wKeyLength / CHAR_BIT ) ) );
    
        DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_pData->pCertificateKeys[iCount].dwNumKeyUsages );
        iBuffer += SIZEOF( DRM_DWORD );
    
        /* 
        ** Add the Key Usage Set 
        */
        for ( iUsage = 0; iUsage < f_pData->pCertificateKeys[iCount].dwNumKeyUsages; iUsage++ )
        {
            if ( f_pData->pCertificateKeys[iCount].pKeyUsageSet[iUsage] == 0
              || f_pData->pCertificateKeys[iCount].pKeyUsageSet[iUsage] > DRM_BCERT_KEYUSAGE_MAX_VALUE )
            {
                ChkDR( DRM_E_BCERT_INVALID_KEY_USAGE );
            }
            DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_pData->pCertificateKeys[iCount].pKeyUsageSet[iUsage] );
            iBuffer += SIZEOF( DRM_DWORD );
        }
    }
        
 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}



/*****************************************************************************
** Function:    _addCertManufacturerString
**
** Synopsis:    Adds a single manufacturer information string to a certificate.
**
** Arguments:   [f_pbBuffer]              : The buffer in which to write these data
**              [f_pszManufacturerString] : Pointer to the string to add
**              [f_cbManufacturerString]  : The number of bytes in the string to add
**              [f_piBuffer]              : Index within the buffer for these data; updated
**
** Returns:     DRM_SUCCESS                            - on success
**              DRM_E_INVALIDARG                       - if any parameter is invalid
**              DRM_E_BCERT_STRING_NOT_NULL_TERMINATED - if the string is not null terminated
**
** Notes:       None.
**
******************************************************************************/
static DRM_RESULT _addCertManufacturerString(
                                             DRM_BYTE   *f_pbBuffer,
  __in_bcount_z(f_cbManufacturerString)      DRM_BYTE   *f_pszManufacturerString,
  __in                                const  DRM_DWORD   f_cbManufacturerString,
  __inout                                    DRM_DWORD  *f_piBuffer
)
{
    DRM_RESULT  dr = DRM_SUCCESS;
    
    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_addCertManufacturerString );
    
    ChkArg( f_pbBuffer              != NULL );
    ChkArg( f_pszManufacturerString != NULL );
    ChkArg( f_piBuffer              != NULL );

    /* 
    ** Add the string length and then the string itself 
    */
    DWORD_TO_NETWORKBYTES( f_pbBuffer, *f_piBuffer, f_cbManufacturerString );
    *f_piBuffer += SIZEOF( DRM_DWORD );

    if ( f_cbManufacturerString > 0 )
    {
        /* 
        ** Ensure that: 1) the string is NULL terminated and 2) the count includes the NULL 
        */
        ChkBOOL( f_pszManufacturerString[ f_cbManufacturerString - 1 ] == '\0', DRM_E_BCERT_STRING_NOT_NULL_TERMINATED );
    
        ChkDR( _addAlignedData( f_pbBuffer, f_piBuffer, f_pszManufacturerString, f_cbManufacturerString ) );
    }

 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}



/*****************************************************************************
** Function:    _addCertManufacturerInfo
**
** Synopsis:    Adds the optional Manufacturer Information object to a certificate.
**
** Arguments:   [f_pbBuffer]             : The address at which to start writing these data
**              [f_dwManufacturerFlags]  : The flags (a bit-field) for this object
**              [f_pManufacturerStrings] : Pointer to the manufacturer strings; may be NULL
**              [f_pcbSize]              : Variable pointer to update w/ size of this object (in bytes)
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_INVALIDARG - if any parameter is invalid
**
** Notes:       None.
**
******************************************************************************/
static DRM_RESULT _addCertManufacturerInfo(
                           DRM_BYTE                        *f_pbBuffer,
  __in               const DRM_DWORD                        f_dwManufacturerFlags,
  __in_ecount_opt(1)       DRM_BCERT_MANUFACTURER_STRINGS  *f_pManufacturerStrings,
  __inout                  DRM_DWORD                       *f_pcbSize
)
{
    DRM_RESULT  dr      = DRM_SUCCESS;
    DRM_DWORD   iBuffer = SIZEOF_OBJ_HEADER;


    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_addCertManufacturerInfo );
    
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_pcbSize  != NULL );
                
    ChkDR( _calcManufacturerInfoSize( f_pManufacturerStrings, f_pcbSize ) );

    if ( f_pManufacturerStrings != NULL )
    {
        /* 
        ** Add the Object Header 
        */
        ChkDR( _addCertObjectHeader( f_pbBuffer, 
                                     DRM_BCERT_OBJFLAG_EMPTY, 
                                     DRM_BCERT_OBJTYPE_MANUFACTURER, 
                                     *f_pcbSize ) );
        
        /* 
        ** Add the Manufacturer Flags 
        */
        DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_dwManufacturerFlags);
        iBuffer += SIZEOF( DRM_DWORD );
        
        /* 
        ** Add the Manufacturer Name, Model Name, then Model Number
        */
        ChkDR( _addCertManufacturerString(f_pbBuffer, 
                                          f_pManufacturerStrings->ManufacturerName.rgb, 
                                          f_pManufacturerStrings->ManufacturerName.cb, 
                                          &iBuffer) );

        ChkDR( _addCertManufacturerString(f_pbBuffer, 
                                          f_pManufacturerStrings->ModelName.rgb, 
                                          f_pManufacturerStrings->ModelName.cb, 
                                          &iBuffer) );
        
        ChkDR( _addCertManufacturerString(f_pbBuffer, 
                                          f_pManufacturerStrings->ModelNumber.rgb, 
                                          f_pManufacturerStrings->ModelNumber.cb, 
                                          &iBuffer) );
    }
    
 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}




/*****************************************************************************
** Function:    _addExtDataSignKeyInfo
**
** Synopsis:    Adds extended data signature key info
**
** Arguments:   [f_pbBuffer]                : The address at which to start writing these data
**              [f_pExtData]                : Pointer to all extended data input
**              [f_pcbSize]                 : Variable pointer to update w/ size of this object (in bytes)
**
** Returns:     DRM_SUCCESS                           - on success
**              DRM_E_INVALIDARG                      - if any parameter is invalid
**              DRM_BCERT_EXTDATA_LENGTH_MUST_PRESENT - if extended data record length is not present
**
** Notes:       None.
**
******************************************************************************/
static DRM_RESULT _addExtDataSignKeyInfo(
           DRM_BYTE                   *f_pbBuffer,
  __in     DRM_BCERT_EXT_BUILDER_DATA *f_pExtData,
  __inout  DRM_DWORD                  *f_pcbSize
)
{
    DRM_RESULT  dr      = DRM_SUCCESS;
    DRM_DWORD   iBuffer = SIZEOF_OBJ_HEADER;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_addExtDataSignKeyInfo );
    
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_pExtData != NULL );
    ChkArg( f_pcbSize  != NULL );
                
    ChkDR( _calcExtDataSignKeyInfoSize( f_pExtData, f_pcbSize ) );

    if ( f_pExtData->fValid )
    {
        /* 
        ** Add the Object Header 
        */
        ChkDR( _addCertObjectHeader( f_pbBuffer, 
                                     DRM_BCERT_OBJFLAG_EMPTY, 
                                     DRM_BCERT_OBJTYPE_EXTDATASIGNKEY,
                                     *f_pcbSize ) );        
        /* 
        ** Add the Key Type, Key Length, Key Flags, Key Value
        */
        WORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_pExtData->wExtDataKeyType );
        iBuffer += SIZEOF( DRM_WORD );
        
        WORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_pExtData->wExtDataKeyLength );
        iBuffer += SIZEOF( DRM_WORD );
        
        DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_pExtData->dwExtDataKeyFlags );
        iBuffer += SIZEOF( DRM_DWORD );
        
        ChkDR( _addAlignedData( f_pbBuffer, 
                                &iBuffer, 
                                f_pExtData->oPubKey.rgb, 
                                (f_pExtData->wExtDataKeyLength / CHAR_BIT ) ) );
    }
    
 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/*****************************************************************************
** Function:    _addExtDataContainer
**
** Synopsis:    Adds extended data container object including everything it contains
**
** Arguments:   [f_pbBuffer]                : The address at which to start writing these data
**              [f_pExtData]                : Pointer to all extended data input
**              [f_pcbSize]                 : Variable pointer to update w/ size of this object (in bytes)
**              [f_pCryptoCtx]              : Pointer to DRM_CRYPTO_CONTEXT used for temporary data in crypto code.
**
** Returns:     DRM_SUCCESS                           - on success
**              DRM_E_INVALIDARG                      - if any parameter is invalid
**              DRM_E_BCERT_PRIVATE_KEY_NOT_SPECIFIED - if the private key is NULL
**              DRM_E_BCERT_INVALID_KEY_LENGTH        - if the issuer key length is unsupported
**              DRM_E_BCERT_INVALID_SIGNATURE_TYPE    - if the signature type is unsupported
**              or other return code from a function called within
**
** Notes:       If actual record is not available yet the function does nothing.
**              But if we plan to add the record later total cert length should account for that.
**              
******************************************************************************/
static DRM_RESULT _addExtDataContainer(
            DRM_BYTE                   *f_pbBuffer,
  __in      DRM_BCERT_EXT_BUILDER_DATA *f_pExtData,
  __inout   DRM_DWORD                  *f_pcbSize,
  __inout   DRM_CRYPTO_CONTEXT         *f_pCryptoCtx
)
{
    DRM_RESULT     dr                 = DRM_SUCCESS;
    DRM_DWORD      iBuffer            = 0;
    DRM_BYTE       *pbSignedData      = NULL;
    DRM_DWORD      dwSignedDataLength = 0;
    DRM_DWORD      dwRecordSize       = 0;
    DRM_DWORD      dwSignatureSize    = 0;
    PRIVKEY_P256   oPrivKey           = {0};
    SIGNATURE_P256 Signature          = {0};

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_addExtDataContainer );
    
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_pExtData != NULL );
    ChkArg( f_pcbSize  != NULL );                

    ChkDR( _calcExtDataContainerSize( f_pExtData, f_pcbSize, &dwRecordSize, &dwSignatureSize ) );

    if ( f_pExtData->fValid )
    {
        /*
        ** Even we add extended data record to the cert later 
        ** its length and type should be known.
        */
        ChkBOOL( f_pExtData->dwNumExtDataRecords == 1, DRM_E_BCERT_INVALID_NUMBER_EXTDATARECORDS );
        ChkBOOL( f_pExtData->pExtDataRecords != NULL, DRM_E_BCERT_INVALID_NUMBER_EXTDATARECORDS );

        ChkBOOL( f_pExtData->pExtDataRecords[0].dwDataLength > 0, DRM_E_BCERT_INVALID_EXTDATARECORD );

        if ( f_pExtData->pExtDataRecords[0].pbData != NULL )
        {
            /* 
            ** Container object header 
            */
            ChkDR( _addCertObjectHeader( f_pbBuffer, 
                                         DRM_BCERT_OBJFLAG_CONTAINER_OBJ | DRM_BCERT_OBJFLAG_MUST_UNDERSTAND, 
                                         DRM_BCERT_OBJTYPE_EXTDATACONTAINER, 
                                         *f_pcbSize ) );
            iBuffer += SIZEOF_OBJ_HEADER;

            pbSignedData = f_pbBuffer + iBuffer; /* remember where signed data begins */
            
            /* 
            ** Ext data record object header - HWID only
            */
            ChkDR( _addCertObjectHeader( f_pbBuffer + iBuffer, 
                                         f_pExtData->pExtDataRecords[0].Header.wFlags, 
                                         f_pExtData->pExtDataRecords[0].Header.wType,
                                         dwRecordSize ) );
            iBuffer += SIZEOF_OBJ_HEADER;
            
            /*
            ** Data length
            */
            DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_pExtData->pExtDataRecords[0].dwDataLength );
            iBuffer += SIZEOF( DRM_DWORD );
            
            /*
            ** Data Blob, padded
            */
            ChkDR( _addAlignedData( f_pbBuffer, 
                                    &iBuffer, 
                                    f_pExtData->pExtDataRecords[0].pbData, 
                                    f_pExtData->pExtDataRecords[0].dwDataLength ) );

            if ( f_pExtData->wExtDataSignatureType == DRM_BCERT_SIGNATURE_TYPE_P256 )
            {
                /*
                ** Signature object header
                */
                ChkDR( _addCertObjectHeader( f_pbBuffer + iBuffer, 
                                             DRM_BCERT_OBJFLAG_MUST_UNDERSTAND, 
                                             DRM_BCERT_OBJTYPE_EXTDATASIGNATURE,
                                             dwSignatureSize ) );
                iBuffer += SIZEOF_OBJ_HEADER;

                /*
                ** Signature type
                */
                WORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_pExtData->wExtDataSignatureType );
                iBuffer += SIZEOF( DRM_WORD );
                
                /*
                ** Signature length
                */
                WORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, SIZEOF( SIGNATURE_P256 ) );
                iBuffer += SIZEOF( DRM_WORD );
    
                /*
                ** Signature blob
                */
                DRM_BYT_CopyBytes( oPrivKey.m_rgbPrivkey, 
                                   0, 
                                   f_pExtData->oPrivKey.rgb, 
                                   0, 
                                   SIZEOF( PRIVKEY_P256 ) );
                
                dwSignedDataLength = SIZEOF_OBJ_HEADER                                   /* ext data record header */
                            + SIZEOF( DRM_DWORD )                                        /* record length */
                            + f_pExtData->pExtDataRecords[0].dwDataLength                /* record data */
                            + PAD_AMOUNT( f_pExtData->pExtDataRecords[0].dwDataLength ); /* padding */

                ChkDR( DRM_ECDSA_Sign_P256( pbSignedData,
                                            dwSignedDataLength, 
                                            &oPrivKey, 
                                            &Signature,
                                            (struct bigctx_t *)f_pCryptoCtx->rgbCryptoContext ) );
                
                ChkDR( _addAlignedData(f_pbBuffer, &iBuffer, Signature.m_rgbSignature, SIZEOF( SIGNATURE_P256 ) ) );
            }
            else
            {
                ChkDR( DRM_E_BCERT_INVALID_SIGNATURE_TYPE );
            }

             ChkBOOL( iBuffer == *f_pcbSize, DRM_E_BCERT_INVALID_EXTDATA_LENGTH );
        }
        else
        {
            /*
            ** leave empty space of f_pcbSize length
            */
            DRM_BYT_SetBytes(f_pbBuffer, 0, *f_pcbSize, 'a');
        }
    }
    else
    {
        *f_pcbSize = 0;
    }
    
 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

/*****************************************************************************
** Function:    _addCertSignatureInfo
**
** Synopsis:    Adds the Signature Information object to a certificate.
**
** Arguments:   [f_pbBuffer]       : The address at which to start writing these data
**              [f_pData]          : A pointer to all the input data
**              [f_cbAmountToSign] : The portion of this certificate to be signed (in bytes)
**              [f_cbSize]         : The previously calculated size of this object (in bytes)
**              [f_pCryptoCtx]     : Pointer to DRM_CRYPTO_CONTEXT used for temporary data in crypto code.
**
** Returns:     DRM_SUCCESS                           - on success
**              DRM_E_INVALIDARG                      - if any parameter is invalid
**              DRM_E_BCERT_PRIVATE_KEY_NOT_SPECIFIED - if the private key is NULL
**              DRM_E_BCERT_ISSUER_KEY_NOT_SPECIFIED  - if the issuer key is NULL
**              DRM_E_BCERT_INVALID_KEY_LENGTH        - if the issuer key length is unsupported
**              DRM_E_BCERT_INVALID_SIGNATURE_TYPE    - if the signature type is unsupported
**              or other return code from a function called within
**
** Notes:       None.
**
******************************************************************************/
static DRM_RESULT _addCertSignatureInfo(
               DRM_BYTE                *f_pbBuffer,
  __in         DRM_BCERT_BUILDER_DATA  *f_pData,
  __in  const  DRM_DWORD                f_cbAmountToSign,
  __in  const  DRM_DWORD                f_cbSize,
  __inout      DRM_CRYPTO_CONTEXT      *f_pCryptoCtx
)
{
    DRM_RESULT       dr               = DRM_SUCCESS;
    DRM_DWORD        iBuffer          = SIZEOF_OBJ_HEADER;
    SIGNATURE_P256   Signature        = {0};
    DRM_WORD         wSignatureLength = 0;

    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_addCertSignatureInfo );

    ChkArg( f_pbBuffer       != NULL );
    ChkArg( f_pData          != NULL );
    ChkArg( f_cbAmountToSign  > 0    );
    ChkArg( f_cbSize          > 0    );
    ChkArg( f_pCryptoCtx     != NULL );
    /*
    ** Check existance of required keys
    */
    ChkBOOL( f_pData->pPrivateKey       != NULL, DRM_E_BCERT_PRIVATE_KEY_NOT_SPECIFIED );
    ChkBOOL( f_pData->dwIssuerKeyLength != 0,    DRM_E_BCERT_ISSUER_KEY_NOT_SPECIFIED  );
    
    /*
    ** Check supported key lengths
    */
    ChkBOOL( f_pData->dwIssuerKeyLength == ECC_P256_PUBKEY_SIZE_IN_BITS, DRM_E_BCERT_INVALID_KEY_LENGTH );
       
    /* 
    ** Add the Object Header 
    */
    ChkDR( _addCertObjectHeader( f_pbBuffer, 
                                 DRM_BCERT_OBJFLAG_MUST_UNDERSTAND, 
                                 DRM_BCERT_OBJTYPE_SIGNATURE, 
                                 f_cbSize ) );
    
    if ( f_pData->wSignatureType == DRM_BCERT_SIGNATURE_TYPE_P256 )
    {
        /* 
        ** Add the Signature Type 
        */
        WORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_pData->wSignatureType );
        iBuffer += SIZEOF( DRM_WORD );
        
        /* 
        ** Sign the data in this certificate 
        */
        ChkDR( DRM_ECDSA_Sign_P256( (f_pbBuffer - f_cbAmountToSign),
                                     f_cbAmountToSign, 
                                     f_pData->pPrivateKey, 
                                     &Signature,
                                     (struct bigctx_t *)f_pCryptoCtx->rgbCryptoContext ) );
        wSignatureLength = SIZEOF( SIGNATURE_P256 );
    }
    else
    {
        ChkDR( DRM_E_BCERT_INVALID_SIGNATURE_TYPE );
    }
    
    /* 
    ** Add the signature length and signature data 
    */
    WORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, wSignatureLength );
    iBuffer += SIZEOF( DRM_WORD );
    
    ChkDR( _addAlignedData(f_pbBuffer, &iBuffer, Signature.m_rgbSignature, wSignatureLength ) );
 
    /* 
    ** Add the Issuer Key Length (in bits) 
    */
    DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_pData->dwIssuerKeyLength );
    iBuffer += SIZEOF( DRM_DWORD );
    
    /* 
    ** Add the Issuer Key (should be the public key from the next certificate in this chain) 
    */
    ChkDR( _addAlignedData( f_pbBuffer, 
                             &iBuffer, 
                             f_pData->IssuerKey.rgb, 
                             ( f_pData->dwIssuerKeyLength / CHAR_BIT ) ) );
       
 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}




/*****************************************************************************
** Function:    _addCertDomainInfo
**
** Synopsis:    Adds the optional Domain Information object to a certificate.
**
** Arguments:   [f_pbBuffer]   : The address at which to start writing these data
**              [f_DomainData] : The domain data
**              [f_pcbSize]    : Variable pointer to update w/ size of this object (in bytes)
**
** Returns:     DRM_SUCCESS                            - on success
**              DRM_E_INVALIDARG                       - if any parameter is invalid
**              DRM_E_BCERT_ACCOUNT_ID_NOT_SPECIFIED   - if pointer to account ID is NULL
**              DRM_E_BCERT_SERVICE_ID_NOT_SPECIFIED   - if pointer to service ID is NULL
**              DRM_E_BCERT_DOMAIN_URL_NOT_SPECIFIED   - if pointer to domain URL is NULL, or 0 length
**              DRM_E_BCERT_STRING_NOT_NULL_TERMINATED - if the domain URL is not null terminated
**              or other return code from a function called within
**
** Notes:       None.
**
******************************************************************************/
static DRM_RESULT _addCertDomainInfo(
            DRM_BYTE                *f_pbBuffer,
   __in     DRM_BCERT_DOMAIN_DATA    f_DomainData,
   __inout  DRM_DWORD               *f_pcbSize
)
{
    DRM_RESULT  dr       = DRM_SUCCESS;
    DRM_DWORD   iBuffer  = SIZEOF_OBJ_HEADER;

    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_addCertDomainInfo );

    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_pcbSize  != NULL );
    
    ChkBOOL( f_DomainData.pAccountID != NULL, DRM_E_BCERT_ACCOUNT_ID_NOT_SPECIFIED );
    ChkBOOL( f_DomainData.pServiceID != NULL, DRM_E_BCERT_SERVICE_ID_NOT_SPECIFIED );
    
    ChkBOOL( f_DomainData.pDomainURL     != NULL, DRM_E_BCERT_DOMAIN_URL_NOT_SPECIFIED );
    ChkBOOL( f_DomainData.pDomainURL->cb >  0,    DRM_E_BCERT_DOMAIN_URL_NOT_SPECIFIED );

    /* 
    ** Ensure that: 1) the URL string is NULL terminated and 2) the count includes the NULL 
    */
    ChkBOOL( f_DomainData.pDomainURL->rgb[ f_DomainData.pDomainURL->cb - 1 ] == '\0', DRM_E_BCERT_STRING_NOT_NULL_TERMINATED );
    
    ChkDR( _calcDomainInfoSize( f_DomainData.pDomainURL->cb, f_pcbSize ) );
    
    /* 
    ** Add the Object Header 
    */
    ChkDR( _addCertObjectHeader( f_pbBuffer, 
                                 DRM_BCERT_OBJFLAG_MUST_UNDERSTAND, 
                                 DRM_BCERT_OBJTYPE_DOMAIN, 
                                 *f_pcbSize ) );
    
    /* 
    ** Add the Service ID, Domain ID, and Revision
    */
    DRM_BYT_CopyBytes( f_pbBuffer, iBuffer, f_DomainData.pServiceID->rgb, 0, DRM_BCERT_SERVICE_ID_LENGTH );
    iBuffer += DRM_BCERT_SERVICE_ID_LENGTH;

    DRM_BYT_CopyBytes( f_pbBuffer, iBuffer, f_DomainData.pAccountID->rgb, 0, DRM_BCERT_ACCOUNT_ID_LENGTH );
    iBuffer += DRM_BCERT_ACCOUNT_ID_LENGTH;

    DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_DomainData.dwRevision );
    iBuffer += SIZEOF( DRM_DWORD );
    
    /* 
    ** Add the Domain URL Length, then the Domain URL 
    */
    DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_DomainData.pDomainURL->cb );
    iBuffer += SIZEOF( DRM_DWORD );
    
    ChkDR( _addAlignedData(f_pbBuffer, &iBuffer, f_DomainData.pDomainURL->rgb, f_DomainData.pDomainURL->cb ) );
        
 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}



/*****************************************************************************
** Function:    _addCertPCInfo
**
** Synopsis:    Adds the optional PC Information object to a certificate.
**
** Arguments:   [f_pbBuffer] : The address at which to start writing these data
**              [f_PCData]   : The PC data
**
** Returns:     DRM_SUCCESS                           - on success
**              DRM_E_INVALIDARG                      - if any parameter is invalid
**              DRM_E_BCERT_INVALID_SECURITY_VERSION  - if the security version is zero
**              or other return code from a function called within
**
** Notes:       This object is a fixed length in size.
**
******************************************************************************/
static DRM_RESULT _addCertPCInfo(
            DRM_BYTE            *f_pbBuffer,
   __in     DRM_BCERT_PC_DATA    f_PCData
)
{
    DRM_RESULT  dr      = DRM_SUCCESS;
    DRM_DWORD   iBuffer = SIZEOF_OBJ_HEADER;

    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_addCertPCInfo );

    ChkArg( f_pbBuffer != NULL );
    
    ChkBOOL( f_PCData.dwSecurityVersion != 0, DRM_E_BCERT_INVALID_SECURITY_VERSION );
    
    /* 
    ** Add the Object Header 
    */
    ChkDR( _addCertObjectHeader( f_pbBuffer, 
                                 DRM_BCERT_OBJFLAG_MUST_UNDERSTAND, 
                                 DRM_BCERT_OBJTYPE_PC, 
                                 SIZEOF_PC_INFO ) );
    
    /* 
    ** Add the Security Version 
    */
    DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_PCData.dwSecurityVersion );

 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

/*****************************************************************************
** Function:    _addCertSilverLightInfo
**
** Synopsis:    Adds the optional SilverLight Information object to a certificate.
**
** Arguments:   [f_pbBuffer]        : The address at which to start writing these data
**              [f_SilverLightData] : The SilverLight data
**
** Returns:     DRM_SUCCESS                           - on success
**              DRM_E_INVALIDARG                      - if any parameter is invalid
**              DRM_E_BCERT_INVALID_SECURITY_VERSION  - if the security version is zero
**              or other return code from a function called within
**
** Notes:       This object is a fixed length in size.
**
******************************************************************************/
static DRM_RESULT _addCertSilverLightInfo(
            DRM_BYTE                   *f_pbBuffer,
   __in     DRM_BCERT_SILVERLIGHT_DATA  f_SilverLightData
)
{
    DRM_RESULT  dr      = DRM_SUCCESS;
    DRM_DWORD   iBuffer = SIZEOF_OBJ_HEADER;

    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_addCertSilverLightInfo );

    ChkArg( f_pbBuffer != NULL );
    
    ChkBOOL( f_SilverLightData.dwSecurityVersion != 0, DRM_E_BCERT_INVALID_SECURITY_VERSION );
    ChkBOOL( f_SilverLightData.dwPlatformIdentifier <= DRM_BCERT_SILVERLIGHT_PLATFORM_MAX, DRM_E_BCERT_INVALID_PLATFORM_IDENTIFIER);
    
    /* 
    ** Add the Object Header 
    */
    ChkDR( _addCertObjectHeader( f_pbBuffer, 
                                 DRM_BCERT_OBJFLAG_MUST_UNDERSTAND, 
                                 DRM_BCERT_OBJTYPE_SILVERLIGHT, 
                                 SIZEOF_SILVERLIGHT_INFO ) );
    
    /* 
    ** Add the Security Version 
    */
    DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_SilverLightData.dwSecurityVersion );
    iBuffer += SIZEOF( DRM_DWORD );

    /* 
    ** Add the Platform Identifier
    */
    DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_SilverLightData.dwPlatformIdentifier );

 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}



/*****************************************************************************
** Function:    _addCertDeviceInfo
**
** Synopsis:    Adds the optional Device Information object to a certificate.
**
** Arguments:   [f_pbBuffer]   : The address at which to start writing these data
**              [f_DeviceData] : The Device data
**
** Returns:     DRM_SUCCESS                                 - on success
**              DRM_E_INVALIDARG                            - if any parameter is invalid
**              DRM_E_BCERT_INVALID_MAX_LICENSE_SIZE        - if the max license size is unsupported
**              DRM_E_BCERT_INVALID_MAX_HEADER_SIZE         - if the max header size is unsupported
**              DRM_E_BCERT_INVALID_MAX_LICENSE_CHAIN_DEPTH - if the max license chain depth is unsupported
**              or other return code from a function called within
**
** Notes:       This object is a fixed length in size.
**
******************************************************************************/
static DRM_RESULT _addCertDeviceInfo(
           DRM_BYTE                *f_pbBuffer,
   __in    DRM_BCERT_DEVICE_DATA    f_DeviceData
)
{
    DRM_RESULT  dr       = DRM_SUCCESS;
    DRM_DWORD   iBuffer  = SIZEOF_OBJ_HEADER;

    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_addCertDeviceInfo );

    ChkArg( f_pbBuffer   != NULL );
    
    /*
    ** Check the supported maximum sizes
    */ 
    ChkBOOL( f_DeviceData.cbMaxLicense    == DRM_BCERT_MAX_LICENSE_SIZE,        DRM_E_BCERT_INVALID_MAX_LICENSE_SIZE );
    ChkBOOL( f_DeviceData.cbMaxHeader     == DRM_BCERT_MAX_HEADER_SIZE,         DRM_E_BCERT_INVALID_MAX_HEADER_SIZE );
    ChkBOOL( f_DeviceData.dwMaxChainDepth == DRM_BCERT_MAX_LICENSE_CHAIN_DEPTH, DRM_E_BCERT_INVALID_MAX_LICENSE_CHAIN_DEPTH );

    /* 
    ** Add the Object Header 
    */
    ChkDR( _addCertObjectHeader( f_pbBuffer, 
                                  DRM_BCERT_OBJFLAG_MUST_UNDERSTAND, 
                                  DRM_BCERT_OBJTYPE_DEVICE, 
                                  SIZEOF_DEVICE_INFO ) );

    /* 
    ** Add the max license size, max header size, and max license chain depth 
    */
    DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_DeviceData.cbMaxLicense );
    iBuffer += SIZEOF( DRM_DWORD );

    DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_DeviceData.cbMaxHeader );
    iBuffer += SIZEOF( DRM_DWORD );
                                 
    DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_DeviceData.dwMaxChainDepth );
                                 
 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/*****************************************************************************
** Function:    _addCertMeteringInfo
**
** Synopsis:    Adds the optional Metering Information object to a certificate.
**
** Arguments:   [f_pbBuffer]     : The address at which to start writing these data
**              [f_MeteringData] : The metering data
**              [f_pcbSize]      : Variable pointer to update w/ size of this object (in bytes)
**
** Returns:     DRM_SUCCESS                            - on success
**              DRM_E_INVALIDARG                       - if any parameter is invalid
**              DRM_E_BCERT_METERING_ID_NOT_SPECIFIED  - if pointer to metering ID is NULL
**              DRM_E_BCERT_METERING_URL_NOT_SPECIFIED - if pointer to metering URL is NULL, or 0 length
**              DRM_E_BCERT_STRING_NOT_NULL_TERMINATED - if the metering URL is not null terminated
**              or other return code from a function called within
**
** Notes:       None.
**
******************************************************************************/
static DRM_RESULT _addCertMeteringInfo(
            DRM_BYTE                *f_pbBuffer,
   __in     DRM_BCERT_METERING_DATA  f_MeteringData,
   __inout  DRM_DWORD               *f_pcbSize
)
{
    DRM_RESULT  dr       = DRM_SUCCESS;
    DRM_DWORD   iBuffer  = SIZEOF_OBJ_HEADER;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_addCertMeteringInfo );

    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_pcbSize  != NULL );
    
    ChkBOOL( f_MeteringData.pMeteringID != NULL, DRM_E_BCERT_METERING_ID_NOT_SPECIFIED );
    
    ChkBOOL( f_MeteringData.pMeteringURL     != NULL, DRM_E_BCERT_METERING_URL_NOT_SPECIFIED );
    ChkBOOL( f_MeteringData.pMeteringURL->cb >  0,    DRM_E_BCERT_METERING_URL_NOT_SPECIFIED );

    /* 
    ** Ensure that: 1) the URL string is NULL terminated and 2) the count includes the NULL 
    */
    ChkBOOL( f_MeteringData.pMeteringURL->rgb[ f_MeteringData.pMeteringURL->cb - 1 ] == '\0', DRM_E_BCERT_STRING_NOT_NULL_TERMINATED );
    
    ChkDR( _calcMeteringInfoSize( f_MeteringData.pMeteringURL->cb, f_pcbSize ) );
    
    /* 
    ** Add the Object Header 
    */
    ChkDR( _addCertObjectHeader( f_pbBuffer, 
                                 DRM_BCERT_OBJFLAG_MUST_UNDERSTAND, 
                                 DRM_BCERT_OBJTYPE_METERING, 
                                 *f_pcbSize ) );
    
    /* 
    ** Add the Metering ID
    */
    DRM_BYT_CopyBytes( f_pbBuffer, iBuffer, f_MeteringData.pMeteringID->rgb, 0, DRM_BCERT_METERING_ID_LENGTH );
    iBuffer += DRM_BCERT_METERING_ID_LENGTH;

    
    /* 
    ** Add the Metering URL Length, then the Metering URL 
    */
    DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_MeteringData.pMeteringURL->cb );
    iBuffer += SIZEOF( DRM_DWORD );
    
    ChkDR( _addAlignedData(f_pbBuffer, &iBuffer, f_MeteringData.pMeteringURL->rgb, f_MeteringData.pMeteringURL->cb ) );
        
 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/*****************************************************************************
** Function:    _addCertServerInfo
**
** Synopsis:    Adds the optional Server Information object to a certificate.
**
** Arguments:   [f_pbBuffer]     : The address at which to start writing these data
**              [f_ServerData]   : The Server data
**
** Returns:     DRM_SUCCESS                           - on success
**              DRM_E_INVALIDARG                      - if any parameter is invalid
**              DRM_E_BCERT_INVALID_SECURITY_VERSION  - if the security version is zero
**              or other return code from a function called within
**
** Notes:       This object is a fixed length in size.
**
******************************************************************************/
static DRM_RESULT _addCertServerInfo(
            DRM_BYTE              *f_pbBuffer,
   __in     DRM_BCERT_SERVER_DATA  f_ServerData
)
{
    DRM_RESULT  dr      = DRM_SUCCESS;
    DRM_DWORD   iBuffer = SIZEOF_OBJ_HEADER;

    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_addCertServerInfo );

    ChkArg( f_pbBuffer != NULL );
    
    ChkBOOL( f_ServerData.dwWarningDays != 0, DRM_E_BCERT_INVALID_WARNING_DAYS );
    
    /* 
    ** Add the Object Header 
    */
    ChkDR( _addCertObjectHeader( f_pbBuffer, 
                                 DRM_BCERT_OBJFLAG_MUST_UNDERSTAND, 
                                 DRM_BCERT_OBJTYPE_SERVER, 
                                 SIZEOF_SERVER_INFO ) );
    
    /* 
    ** Add the Security Version 
    */
    DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, f_ServerData.dwWarningDays );

 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/*****************************************************************************
** Function:    BCert_SetDefaultBuilderData
**
** Synopsis:    Fills in all the data that are common to all certificate types with default values.
**              Those data that do not have default values are parameters to this function.
**              It is completely optional to call this function, it is provided as a convenience.
**              As such, it does not duplicate any input data validity checking; input data
**              validity checks are in the code that builds the certificate chain.
**
** Arguments:   [f_pCertificateID]      : Pointer to the certificate ID
**              [f_dwType]              : The certificate type
**              [f_pPrivateKey]         : Pointer to the private key to use for signing
**              [f_pIssuerKey]          : Pointer to the issuer key
**              [f_pData]               : Pointer to the builder data stucture to fill in
**
** Returns:     void
**
** Notes:       None.
**
******************************************************************************/
DRM_API DRM_VOID DRM_CALL BCert_SetDefaultBuilderData(
   __in         DRM_BCERT_CERT_ID         *f_pCertificateID,
   __in  const  DRM_DWORD                 f_dwType,
   __in         PRIVKEY_P256              *f_pPrivateKey,
   __in         PUBKEY_P256               *f_pIssuerKey,
   __out        DRM_BCERT_BUILDER_DATA    *f_pData
)
{
    f_pData->dwChainHeaderFlags   = DRM_BCERT_OBJFLAG_EMPTY;
    f_pData->pCertificateID       = f_pCertificateID;
    f_pData->dwSecurityLevel      = DRM_BCERT_SECURITYLEVEL_2000;
    f_pData->dwBasicFlags         = DRM_BCERT_FLAGS_EMPTY;
    f_pData->dwType               = f_dwType;
    f_pData->dwExpirationDate     = DRM_BCERT_DEFAULT_EXPIRATION_DATE;
    
    MEMSET( f_pData->ClientID.rgb, DRM_BCERT_CLIENT_ID_LENGTH, '\0' );
    
    f_pData->dwNumFeatureEntries  = 0;
    f_pData->prgdwFeatureSet      = NULL;
    
    f_pData->dwManufacturerFlags  = DRM_BCERT_OBJFLAG_EMPTY;
    f_pData->pManufacturerStrings = NULL;
    f_pData->pPrivateKey          = f_pPrivateKey;
    f_pData->dwIssuerKeyLength    = ECC_P256_PUBKEY_SIZE_IN_BITS;
    
    MEMCPY( f_pData->IssuerKey.rgb, f_pIssuerKey->m_rgbPubkey, SIZEOF( PUBKEY_P256 ) );
    
    f_pData->wSignatureType       = DRM_BCERT_SIGNATURE_TYPE_P256;

    f_pData->ExtendedData.fValid                  = FALSE;
    f_pData->ExtendedData.wExtDataKeyType         = DRM_BCERT_KEYTYPE_ECC256;
    f_pData->ExtendedData.wExtDataKeyLength       = ECC_P256_PUBKEY_SIZE_IN_BITS;
    f_pData->ExtendedData.dwExtDataKeyFlags       = DRM_BCERT_OBJFLAG_EMPTY;
    f_pData->ExtendedData.dwNumExtDataRecords     = 0;
    f_pData->ExtendedData.pExtDataRecords         = NULL;
    f_pData->ExtendedData.wExtDataSignatureType   = DRM_BCERT_SIGNATURE_TYPE_P256;
}



/*****************************************************************************
** Function:    BCert_SetKeyInfoBuilderData
**
** Synopsis:    Fills in all the data specific to the key info object with default values.
**              Those data that do not have default values are parameters to this function.
**              It is completely optional to call this function, it is provided as a convenience.
**              As such, it does not duplicate any input data validity checking; input data
**              validity checks are in the code that builds the certificate chain.
**
** Arguments:   [f_pKeys]     : Pointer to the array of certificate keys
**              [f_dwNumKeys] : Number of elements in f_pKeys array.
**              [f_pData]     : Pointer to the builder data stucture to fill in
**
** Returns:     void
**
** Notes:       None.
**
******************************************************************************/
DRM_API DRM_VOID DRM_CALL BCert_SetKeyInfoBuilderData(
    __in_ecount(f_dwNumKeys) DRM_BCERT_BUILDER_CERTKEY  *f_pKeys,
    __in                     const DRM_DWORD             f_dwNumKeys,
    __out                    DRM_BCERT_BUILDER_DATA     *f_pData
)
{
    DRM_DWORD iCount = 0;    
    if ( f_pKeys != NULL )
    {
        for (; iCount < f_dwNumKeys; iCount++ )
        {
            f_pKeys[iCount].wKeyType = DRM_BCERT_KEYTYPE_ECC256;
            f_pKeys[iCount].wKeyLength = ECC_P256_PUBKEY_SIZE_IN_BITS;
            f_pKeys[iCount].dwKeyFlags = 0;
        }
        
        f_pData->dwNumCertificateKeys = f_dwNumKeys;
        f_pData->pCertificateKeys = f_pKeys;
    }
}


/*****************************************************************************
** Function:    BCert_SetDomainBuilderData
**
** Synopsis:    Fills in all the data specific to the Domain certificate type with default values.
**              Those data that do not have default values are parameters to this function.
**              It is completely optional to call this function, it is provided as a convenience.
**              As such, it does not duplicate any input data validity checking; input data
**              validity checks are in the code that builds the certificate chain.
**
** Arguments:   [f_pServiceID] : Pointer to the service ID
**              [f_pAccountID] : Pointer to the account ID
**              [f_dwRevision] : Timestamp marking the generation of the domain key pair
**              [f_pClientID]  : Pointer to the client ID
**              [f_pDomainURL] : Pointer to the domain URL
**              [f_pData]      : Pointer to the builder data stucture to fill in
**
** Returns:     void
**
** Notes:       None.
**
******************************************************************************/
DRM_API DRM_VOID DRM_CALL BCert_SetDomainBuilderData(
   __in         DRM_BCERT_SERVICE_ID    *f_pServiceID,
   __in         DRM_BCERT_ACCOUNT_ID    *f_pAccountID,
   __in  const  DRM_DWORD                f_dwRevision,
   __in         DRM_BCERT_CLIENT_ID     *f_pClientID,
   __in         DRM_BCERT_DOMAIN_URL    *f_pDomainURL,
   __out        DRM_BCERT_BUILDER_DATA  *f_pData
)
{
    f_pData->Type.DomainData.pServiceID = f_pServiceID;
    f_pData->Type.DomainData.pAccountID = f_pAccountID;
    f_pData->Type.DomainData.dwRevision = f_dwRevision;
    f_pData->Type.DomainData.pDomainURL = f_pDomainURL;

    MEMCPY( f_pData->ClientID.rgb, f_pClientID->rgb, DRM_BCERT_CLIENT_ID_LENGTH );
}



/*****************************************************************************
** Function:    BCert_SetPCBuilderData
**
** Synopsis:    Fills in all the data specific to the PC certificate type with default values.
**              Those data that do not have default values are parameters to this function.
**              It is completely optional to call this function, it is provided as a convenience.
**              As such, it does not duplicate any input data validity checking; input data
**              validity checks are in the code that builds the certificate chain.
**
** Arguments:   [f_pHardwareID]       : Pointer to the hardware ID
**              [f_dwSecurityVersion] : The security version
**              [f_pPrivateKey]       : Pointer to a private key used to sign extended data
**              [f_pPublicKey]        : Pointer to a corresponding public key to verify signature
**                                      over extended data
**              [f_oRecord]           : Pointer to extended data structure, may be NULL
**              [f_pData            ] : Pointer to the builder data stucture to fill in
**
** Returns:     void
**
** Notes:       None.
**
******************************************************************************/
DRM_API DRM_VOID DRM_CALL BCert_SetPCBuilderData(
   __in           DRM_BCERT_CLIENT_ID      *f_pHardwareID,
   __in    const  DRM_DWORD                 f_dwSecurityVersion,  /* A.B.C.D */
   __in           PRIVKEY_P256             *f_pPrivateKey,
   __in           PUBKEY_P256              *f_pPublicKey,
   __in_opt       DRM_BCERT_EXTDATA_RECORD *f_oRecord,
   __out          DRM_BCERT_BUILDER_DATA   *f_pData
)
{
    f_pData->Type.PCData.dwSecurityVersion = f_dwSecurityVersion;

    MEMCPY( f_pData->ClientID.rgb, f_pHardwareID->rgb, DRM_BCERT_CLIENT_ID_LENGTH );

    f_pData->ExtendedData.fValid = TRUE;
    f_pData->dwBasicFlags = DRM_BCERT_FLAGS_EXTDATA_PRESENT;
    
    MEMCPY( f_pData->ExtendedData.oPubKey.rgb, f_pPublicKey->m_rgbPubkey, SIZEOF( PUBKEY_P256 ) );

    MEMCPY( f_pData->ExtendedData.oPrivKey.rgb, f_pPrivateKey->m_rgbPrivkey, SIZEOF( PRIVKEY_P256 ) );

    f_pData->ExtendedData.dwNumExtDataRecords = 1;

    f_pData->ExtendedData.pExtDataRecords = f_oRecord;   
}


/*****************************************************************************
** Function:    BCert_SetSilverLightBuilderData
**
** Synopsis:    Fills in all the data specific to the SilverLight certificate type with default values.
**              Those data that do not have default values are parameters to this function.
**              It is completely optional to call this function, it is provided as a convenience.
**              As such, it does not duplicate any input data validity checking; input data
**              validity checks are in the code that builds the certificate chain.
**
** Arguments:   [f_pHardwareID]       : Pointer to the hardware ID
**              [f_dwSecurityVersion] : The security version
**              [f_pData            ] : Pointer to the builder data stucture to fill in
**
** Returns:     void
**
** Notes:       None.
**
******************************************************************************/
DRM_API DRM_VOID DRM_CALL BCert_SetSilverLightBuilderData(
   __in           DRM_BCERT_CLIENT_ID     *f_pHardwareID,
   __in    const  DRM_DWORD                f_dwSecurityVersion,  /* A.B.C.D */  
   __in    const  DRM_DWORD                f_dwPlatformIdentifier,
   __out          DRM_BCERT_BUILDER_DATA  *f_pData
)
{
    f_pData->Type.SilverLightData.dwSecurityVersion    = f_dwSecurityVersion;
    f_pData->Type.SilverLightData.dwPlatformIdentifier = f_dwPlatformIdentifier;

    MEMCPY( f_pData->ClientID.rgb, f_pHardwareID->rgb, DRM_BCERT_CLIENT_ID_LENGTH );
}


/*****************************************************************************
** Function:    BCert_SetDeviceBuilderData
**
** Synopsis:    Fills in all the data specific to the Device certificate type with default values.
**              Those data that do not have default values are parameters to this function.
**              It is completely optional to call this function, it is provided as a convenience.
**              As such, it does not duplicate any input data validity checking; input data
**              validity checks are in the code that builds the certificate chain.
**
** Arguments:   [f_pSerialNum] : Pointer to the device's serial number
**              [f_pData]      : Pointer to the builder data stucture to fill in
**
** Returns:     void
**
** Notes:       None.
**
******************************************************************************/
DRM_API DRM_VOID DRM_CALL BCert_SetDeviceBuilderData(
   __in           DRM_BCERT_CLIENT_ID     *f_pSerialNum,
   __out          DRM_BCERT_BUILDER_DATA  *f_pData
)
{
    f_pData->Type.DeviceData.cbMaxLicense    = DRM_BCERT_MAX_LICENSE_SIZE;
    f_pData->Type.DeviceData.cbMaxHeader     = DRM_BCERT_MAX_HEADER_SIZE;
    f_pData->Type.DeviceData.dwMaxChainDepth = DRM_BCERT_MAX_LICENSE_CHAIN_DEPTH;

    MEMCPY( f_pData->ClientID.rgb, f_pSerialNum->rgb, DRM_BCERT_CLIENT_ID_LENGTH );
}

/*****************************************************************************
** Function:    BCert_SetMeteringBuilderData
**
** Synopsis:    Fills in all the data specific to the Metering certificate type with default values.
**              Those data that do not have default values are parameters to this function.
**              It is completely optional to call this function, it is provided as a convenience.
**              As such, it does not duplicate any input data validity checking; input data
**              validity checks are in the code that builds the certificate chain.
**
** Arguments:   [f_pMeteringID] : Pointer to the metering ID
**              [f_pMeteringURL] : Pointer to the metering URL
**              [f_pData]      : Pointer to the builder data stucture to fill in
**
** Returns:     void
**
** Notes:       None.
**
******************************************************************************/
DRM_API DRM_VOID DRM_CALL BCert_SetMeteringBuilderData(
   __in         DRM_BCERT_METERING_ID    *f_pMeteringID,
   __in         DRM_BCERT_METERING_URL   *f_pMeteringURL,
   __out        DRM_BCERT_BUILDER_DATA   *f_pData
)
{
    f_pData->Type.MeteringData.pMeteringID = f_pMeteringID;
    f_pData->Type.MeteringData.pMeteringURL = f_pMeteringURL;
}


/*****************************************************************************
** Function:    BCert_SetServerBuilderData
**
** Synopsis:    Fills in all the data specific to the Server certificate type with default values.
**              Those data that do not have default values are parameters to this function.
**              It is completely optional to call this function, it is provided as a convenience.
**              As such, it does not duplicate any input data validity checking; input data
**              validity checks are in the code that builds the certificate chain.
**
** Arguments:   [f_dwWarningDays] : When to start Server cert expiration warning (in seconds since Jan 1, 1970, UTC)
**              [f_pData             ] : Pointer to the builder data stucture to fill in
**
** Returns:     void
**
** Notes:       None.
**
******************************************************************************/
DRM_API DRM_VOID DRM_CALL BCert_SetServerBuilderData(
   __in    const  DRM_DWORD                 f_dwWarningDays,  /* in seconds since Jan 1, 1970, UTC */
   __out          DRM_BCERT_BUILDER_DATA   *f_pData
)
{
    f_pData->Type.ServerData.dwWarningDays = f_dwWarningDays;
}


/*****************************************************************************
** Function:    BCert_AddCert
**
** Synopsis:    Adds a certificate to a certificate chain.  
**              If this function is called with a NULL new chain buffer pointer, 
**              then the buffer size parm is updated with the required size (in bytes).
**
** Arguments:   [f_pbParentChain] : A buffer pointer to an existing certificate chain; may be NULL
**              [f_pbNewChain]    : A buffer pointer for the new certificate chain; may be NULL
**              [f_pcbNewChain]   : A pointer to new chain buffer size (in bytes); may be updated
**              [f_pData]         : A pointer to all the input data
**              [f_pCryptoCtx]     : Pointer to DRM_CRYPTO_CONTEXT used for temporary data in crypto code.
**
** Returns:     DRM_SUCCESS                - on success
**              DRM_E_INVALIDARG           - if any parameter is invalid
**              DRM_E_BCERT_CHAIN_TOO_DEEP - if the existing chain is already at maximum capacity
**              or other return code from a function called within
**
** Notes:       None.
**
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL BCert_AddCert
(
            DRM_BYTE                *f_pbParentChain,
            DRM_BYTE                *f_pbNewChain,
   __inout  DRM_DWORD               *f_pcbNewChain,
   __in     DRM_BCERT_BUILDER_DATA  *f_pData,
   __inout  DRM_CRYPTO_CONTEXT      *f_pCryptoCtx
)
{
    DRM_RESULT  dr              = DRM_SUCCESS;
    DRM_DWORD   iOffset         = 0;
    DRM_DWORD   cbCert          = 0;
    DRM_DWORD   cbElement       = 0;
    DRM_DWORD   cbSignatureInfo = 0;
    DRM_DWORD   cbExtendedData  = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_DRM_BCert_Add_Cert );

    ChkArg( f_pcbNewChain != NULL );
    ChkArg( f_pData       != NULL );
    ChkArg( f_pCryptoCtx  != NULL );

    /*
    ** Ensure that we are not adding more than the maximum certificates per chain
    */
    if ( f_pbParentChain != NULL )
    {
        DRM_DWORD   cCerts = 0;
        NETWORKBYTES_TO_DWORD( cCerts, f_pbParentChain, DRM_BCERT_CHAIN_COUNT_OFFSET );
        ChkBOOL( cCerts < DRM_BCERT_MAX_CERTS_PER_CHAIN, DRM_E_BCERT_CHAIN_TOO_DEEP );
    }

    /*
    ** Calculate the exact size of this certificate and its signature info portion.
    ** This function also validates the certificate type.
    */
    ChkDR( _calcCertSize( f_pData, &cbCert, &cbSignatureInfo, &cbExtendedData ) );
                          
    /*
    ** Ensure that enough memory for the new certificate chain has been allocated by the caller
    */
    ChkDR( _checkBuffer( f_pbParentChain, f_pbNewChain, f_pcbNewChain, cbCert ) );

    /*
    ** If this is the first certificate in the chain, add a chain header,
    ** otherwise, copy the existing chain header.
    */
    if ( f_pbParentChain == NULL )
    {
        ChkDR( _addCertChainHeader( f_pbNewChain, f_pData->dwChainHeaderFlags ) );
    }
    else
    {
        DRM_BYT_CopyBytes( f_pbNewChain, 0, f_pbParentChain, 0, SIZEOF_CHAIN_HEADER );
    }
    iOffset += SIZEOF_CHAIN_HEADER;

    /*
    ** Add the Certificate Header
    */
    ChkDR( _addCertHeader( f_pbNewChain + iOffset, cbCert, cbCert - cbSignatureInfo - cbExtendedData ) );
    iOffset += SIZEOF( DRM_BCERT_HEADER );

    /* 
    ** Add the Basic Information 
    */
    ChkDR( _addCertBasicInfo( f_pbNewChain + iOffset, f_pData ) );
    iOffset += SIZEOF_BASIC_INFO;

    switch ( f_pData->dwType )
    {
        case DRM_BCERT_CERTTYPE_PC:
        {
            ChkDR( _addCertPCInfo( f_pbNewChain + iOffset, f_pData->Type.PCData ) );
            iOffset += SIZEOF_PC_INFO;
            break;
        }

        case DRM_BCERT_CERTTYPE_SILVERLIGHT:
        {
            ChkDR( _addCertSilverLightInfo( f_pbNewChain + iOffset, f_pData->Type.SilverLightData ) );
            iOffset += SIZEOF_SILVERLIGHT_INFO;
            break;
        }

        case DRM_BCERT_CERTTYPE_DEVICE:
        {
            ChkDR( _addCertDeviceInfo( f_pbNewChain + iOffset, f_pData->Type.DeviceData ) );
            iOffset += SIZEOF_DEVICE_INFO;
            break;
        }

        case DRM_BCERT_CERTTYPE_DOMAIN:
        {
            ChkDR( _addCertDomainInfo( f_pbNewChain + iOffset, f_pData->Type.DomainData, &cbElement ) );
            iOffset += cbElement;
            break;
        }

        case DRM_BCERT_CERTTYPE_METERING:
        {
            ChkDR( _addCertMeteringInfo( f_pbNewChain + iOffset, f_pData->Type.MeteringData, &cbElement ) );
            iOffset += cbElement;
            break;
        }

        case DRM_BCERT_CERTTYPE_SERVER:
        {
            ChkDR( _addCertServerInfo( f_pbNewChain + iOffset, f_pData->Type.ServerData ) );
            iOffset += SIZEOF_SERVER_INFO;
            break;
        }

        default:
        {
            break;
        }
    }

    /* 
    ** Add the Feature Information 
    */
    ChkDR( _addCertFeatureInfo( f_pbNewChain + iOffset, 
                                f_pData->dwNumFeatureEntries,
                                f_pData->prgdwFeatureSet,
                                &cbElement ) );
    iOffset += cbElement;

    /* 
    ** Add the Public Key Information 
    */
    ChkDR( _addCertKeyInfo( f_pbNewChain + iOffset, f_pData, &cbElement ) );
    iOffset += cbElement;

    /* 
    ** Add the Manufacturer Information 
    */
    ChkDR( _addCertManufacturerInfo( f_pbNewChain + iOffset, 
                                     f_pData->dwManufacturerFlags, 
                                     f_pData->pManufacturerStrings,
                                     &cbElement) );
    iOffset += cbElement;


    /*
    ** Add the Extended Data Signature Information
    */
    ChkDR( _addExtDataSignKeyInfo( f_pbNewChain + iOffset, 
                                   &f_pData->ExtendedData,
                                   &cbElement) );
    iOffset += cbElement;
    
    /* 
    ** Future elements are added here 
    */

    /* 
    ** Add the Signature Information
    */
    ChkDR( _addCertSignatureInfo( f_pbNewChain + iOffset, 
                                  f_pData, 
                                  ( cbCert - cbSignatureInfo - cbExtendedData ),  /* # of bytes to sign */
                                  cbSignatureInfo,
                                  f_pCryptoCtx ) );
    iOffset += cbSignatureInfo;
        
    /*
    ** Add the Extended Data
    */
    ChkDR( _addExtDataContainer( f_pbNewChain + iOffset, 
                                 &f_pData->ExtendedData,
                                 &cbElement,
                                 f_pCryptoCtx ) );

    iOffset += cbElement;

    /*
    ** If this is not the first certificate in the chain, then we need to copy the parent chain
    ** after the certificate that we just added
    */
    if ( f_pbParentChain != NULL )
    {
        DRM_DWORD    cbParentChain = 0;
        
        NETWORKBYTES_TO_DWORD( cbParentChain, f_pbParentChain, DRM_BCERT_CHAIN_SIZE_OFFSET );
        cbParentChain -= SIZEOF_CHAIN_HEADER;
        DRM_BYT_CopyBytes( f_pbNewChain, iOffset, f_pbParentChain, SIZEOF_CHAIN_HEADER, cbParentChain );
    }

    /*
    ** Finally, we need to update the certificate chain header with the new byte size and count
    */
    ChkDR( _updateCertChainHeader( f_pbNewChain, cbCert ) );

 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/**************************************************************************************************************
** Function:    BCert_AddExtendedDataToCert
**
** Synopsis:    Adds extended data into a leaf certificate in the provided certificate chain. 
**              Since empty space is already reserved we only need to fill it with data in place.
**
** Arguments:   [f_pbCertChain]         : A buffer pointer to an existing certificate chain; cannot be NULL
**              [f_cbCertData]          : size of the cert chain buffer
**              [f_pExtData]            : A pointer to all extended data input
**              [f_pCryptoCtx]          : Pointer to DRM_CRYPTO_CONTEXT used for temporary data in crypto code.
**
** Returns:     DRM_SUCCESS                - on success
**              DRM_E_INVALIDARG           - if any parameter is invalid
**              DRM_E_BCERT_CHAIN_TOO_DEEP - if the existing chain is already at maximum capacity
**              or other return code from a function called within
**
** Notes:       Just like BCert_AddCert this function does not verify the cert chain.
**              The leaf cert's and cert chain's lengths do not change - they are already set into correct values.
**************************************************************************************************************/
DRM_API DRM_RESULT DRM_CALL BCert_AddExtendedDataToCert(
   __inout_bcount(f_cbCertData) DRM_BYTE *f_pbCertChain,
   __in     const DRM_DWORD              f_cbCertData,
   __in     DRM_BCERT_EXT_BUILDER_DATA   *f_pExtData,
   __inout  DRM_CRYPTO_CONTEXT           *f_pCryptoCtx
)
{
    DRM_RESULT dr                     = DRM_SUCCESS;
    DRM_DWORD  iOffset                = 0;
    DRM_DWORD  cbExtDataInfoLength    = 0;
    DRM_DWORD  cbLeafCertTotalLength  = 0;
    DRM_DWORD  cbLeafCertSignedLength = 0;
    DRM_DWORD  cbSignatureObjLength   = 0;
    DRM_DWORD  cbElement              = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_DRM_BCert_AddExtDataToCert );

    ChkArg( f_pbCertChain != NULL );
    ChkArg( f_pExtData != NULL );
    ChkArg( f_pCryptoCtx != NULL );

    /*
    ** Calculate size of extended data object to be added.
    */
    ChkDR( _calcExtDataContainerSize( f_pExtData, &cbExtDataInfoLength, NULL, NULL ) );
    ChkBOOL( cbExtDataInfoLength > 0, DRM_E_BCERT_EXTDATA_IS_NOT_PROVIDED );

    /*
    ** Now find an offset to write extended data.
    ** Total cert length = signed length 
    **                   + signature obj length 
    **                   + reserved space for extended data
    */

    /*
    ** Jump over cert chain header
    */
    iOffset = SIZEOF_CHAIN_HEADER   /* cert chain header     */
            + SIZEOF(DRM_DWORD)     /* cert header - tag     */
            + SIZEOF(DRM_DWORD);    /* cert header - version */
    ChkBOOL( iOffset + SIZEOF(DRM_DWORD) <= f_cbCertData, DRM_E_BUFFERTOOSMALL );

    /*
    ** Read the length of the first cert in the chain.
    */
    NETWORKBYTES_TO_DWORD( cbLeafCertTotalLength, f_pbCertChain, iOffset );
    ChkBOOL( SIZEOF_CHAIN_HEADER + cbLeafCertTotalLength <= f_cbCertData, DRM_E_BUFFERTOOSMALL );
    ChkOverflow( cbLeafCertTotalLength, cbExtDataInfoLength );

    /*
    ** Read length of a signed portion of the cert.
    */
    iOffset += SIZEOF(DRM_DWORD);
    ChkBOOL( iOffset + SIZEOF(DRM_DWORD) <= f_cbCertData, DRM_E_BUFFERTOOSMALL );
    NETWORKBYTES_TO_DWORD( cbLeafCertSignedLength, f_pbCertChain, iOffset );
    ChkOverflow( cbLeafCertTotalLength, cbLeafCertSignedLength );

    /*
    ** Read length of a signature object
    */
    iOffset = SIZEOF_CHAIN_HEADER     /* cert chain header  */
            + cbLeafCertSignedLength  /* signed length      */
            + SIZEOF(DRM_WORD)        /* obj header - flags */
            + SIZEOF(DRM_WORD);       /* obj header - type  */
    ChkBOOL( iOffset + SIZEOF(DRM_DWORD) <= f_cbCertData, DRM_E_BUFFERTOOSMALL );
    NETWORKBYTES_TO_DWORD( cbSignatureObjLength, f_pbCertChain, iOffset );

    /*
    ** Write extended data container obj
    */
    iOffset = SIZEOF_CHAIN_HEADER     /* cert chain header    */
            + cbLeafCertSignedLength  /* signed length        */
            + cbSignatureObjLength;   /* signature obj length */
    ChkBOOL( iOffset + cbExtDataInfoLength <= f_cbCertData, DRM_E_BUFFERTOOSMALL );

    ChkDR( _addExtDataContainer( f_pbCertChain + iOffset,
                                 f_pExtData,
                                 &cbElement,
                                 f_pCryptoCtx ) );

    /*
    ** No need to update cert length or cert chain length - it's already correct.
    */

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


EXIT_PK_NAMESPACE_CODE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmbcertparser.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include <drmcommon.h>
#include <drmutilities.h>
#include <drmtypes.h>
#include <byteorder.h>
#include <drmerr.h>
#include <drmprofile.h>
#include <drmprofileconstants.h>
#include <drmeccp256.h>
#include <drmsha256.h>
#include <drmbcert.h>
#include <drmutf.h>
#include <drmbcertparser.h>
#include <oem.h>

ENTER_PK_NAMESPACE_CODE;

#define DoExpirationCheck(ft) ( ( (ft).dwLowDateTime != 0 ) && ( (ft).dwHighDateTime != 0 ) )

#define ChkVerificationErr( pVerificationCtx, fCondition, dwErr )                                             \
{                                                                                           \
    if ( !(fCondition) )                                                                    \
    {                                                                                       \
        if ( pVerificationCtx->fCollectErrorsInArrayAndContinue == FALSE                    \
            || pVerificationCtx->cResults >= DRM_MAX_VERIFICATIONRESULTS )                  \
        {                                                                                   \
            ChkDR(dwErr);                                                                   \
        }                                                                                   \
        else                                                                                \
        {                                                                                   \
            pVerificationCtx->rgoResults[pVerificationCtx->cResults].cCertNumber = pVerificationCtx->cCurrentCert; \
            pVerificationCtx->rgoResults[pVerificationCtx->cResults++].dwResult = (dwErr);                         \
        }                                                                                   \
    }                                                                                       \
};                                                                                          \



const DRM_BOOL rgfKeyUsageMapping[ DRM_BCERT_CERTTYPE_MAX_VALUE + 1 ][ DRM_BCERT_KEYUSAGE_MAX_VALUE + 1 ] = 
{
                  /*               Encr   Sign Issuer Issuer Issuer Issuer Issuer Issuer Issuer  Issuer  Issuer  Issuer  Sign     Issuer */
                  /* n/a    Sign    Key    CRL    All  Indiv Device   Link Domain   SL    App   CRLSign Metering KF Sign KeyFile  Server */
 /* n/a         */  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,  FALSE,  FALSE,  FALSE,   FALSE,
 /* PC          */  FALSE, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,  FALSE,  FALSE,  FALSE,   FALSE,
 /* Device      */  FALSE, TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,  FALSE,  FALSE,  FALSE,   FALSE,
 /* Domain      */  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,  FALSE,  FALSE,  FALSE,   FALSE,
 /* Issuer      */  FALSE, TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,   TRUE,   TRUE,   FALSE,   TRUE,
 /* CRLSigner   */  FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,  FALSE,  FALSE,  FALSE,   FALSE,
 /* Service     */  FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,  FALSE,  FALSE,  FALSE,   FALSE,
 /* SilverLight */  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,  FALSE,  FALSE,  FALSE,   FALSE,
 /* Application */  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,  FALSE,  FALSE,  FALSE,   FALSE,
 /* Metering    */  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,  FALSE,  FALSE,  FALSE,   FALSE,
 /* KeyFile Sign*/  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,  FALSE,  FALSE,  TRUE,    FALSE,
 /* Server*/        FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,  FALSE,  FALSE,  FALSE,   FALSE
};


/* Note: Issuer cert can have any feature because sometimes (device certs) this is where we look for them instead of leaf cert */

const DRM_BOOL rgfFeatureMapping[ DRM_BCERT_CERTTYPE_MAX_VALUE + 1 ][ DRM_BCERT_FEATURE_MAX_VALUE + 1 ] = 
{
                  /*                    Shared  Secure AntiRB        Lic    Sym          */
                  /* n/a    Tx     Rx     Cert  Clock  Clock  Meter  Sync   Opts   CRLs  */
 /* n/a         */  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
 /* PC          */  FALSE, TRUE,  TRUE,  FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, TRUE,
 /* Device      */  FALSE, TRUE,  TRUE,  FALSE, TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,
 /* Domain      */  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
 /* Issuer      */  FALSE, TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,
 /* CRLSigner   */  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
 /* Service     */  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
 /* SilverLight */  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
 /* Application */  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
 /* Metering    */  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
 /* KeyFile Sign*/  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
 /* Server*/        FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
};

#define BCERT_KEYUSAGE_PARENT_ISSUERS_MASK                          \
    ( BCERT_KEYUSAGE_BIT( DRM_BCERT_KEYUSAGE_ISSUER_INDIV )         \
    | BCERT_KEYUSAGE_BIT( DRM_BCERT_KEYUSAGE_ISSUER_DEVICE )        \
    | BCERT_KEYUSAGE_BIT( DRM_BCERT_KEYUSAGE_ISSUER_LINK )          \
    | BCERT_KEYUSAGE_BIT( DRM_BCERT_KEYUSAGE_ISSUER_DOMAIN )        \
    | BCERT_KEYUSAGE_BIT( DRM_BCERT_KEYUSAGE_ISSUER_SILVERLIGHT )   \
    | BCERT_KEYUSAGE_BIT( DRM_BCERT_KEYUSAGE_ISSUER_APPLICATION )   \
    | BCERT_KEYUSAGE_BIT( DRM_BCERT_KEYUSAGE_ISSUER_CRL )           \
    | BCERT_KEYUSAGE_BIT( DRM_BCERT_KEYUSAGE_ISSUER_SIGN_KEYFILE )  \
    | BCERT_KEYUSAGE_BIT( DRM_BCERT_KEYUSAGE_ISSUER_METERING ) )


/*****************************************************************************
** Function:    _isUTF8NullTerminatedData
**
** Synopsis:    Verify that byte buffer contains a null-terminated UTF-8 string.
**
** Arguments:   [f_pbData]   : pointer to byte data buffer
**              [f_cbData]   : size in bytes of f_pbData
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_BCERT_STRING_NOT_NULL_TERMINATED
**              DRM_E_UTF8_xxxx - if a string is not UTF-8
**
** Notes:       Strings of length 1 that contain no data and one null are okay.
******************************************************************************/
static DRM_NO_INLINE DRM_RESULT _isUTF8NullTerminatedData(
    __in_bcount(f_cbData) const DRM_BYTE  *f_pbData,
    __in                  DRM_DWORD       f_cbData )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pbData != NULL );
    ChkArg( f_cbData > 0 );

    ChkBOOL( GET_BYTE( f_pbData, f_cbData - 1 ) == 0x0, DRM_E_BCERT_STRING_NOT_NULL_TERMINATED );

    if ( f_cbData > 1 )
    {
        ChkDR( DRM_UTF8_VerifyBytes( f_pbData,
                                     f_cbData - 1,
                                     0,
                                     f_cbData - 2 ) );
    }

ErrorExit:
    return dr;
}

/*****************************************************************************
** Function:    _verifyKeyUsage
**
** Synopsis:    Verify that key usage information matches certificate type.
**
** Arguments:   [f_dwKeyUsage]   : key usage data
**              [f_dwCertType]   : certificate type
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_BCERT_INVALID_CERT_TYPE - if cert type is invalid
**              DRM_E_BCERT_INVALID_KEY_USAGE - if key usage is invalid 
**                                              or does not match cert type
**
** Notes:       None
******************************************************************************/
static DRM_NO_INLINE DRM_RESULT _verifyKeyUsage(
    __in DRM_DWORD f_dwKeyUsage, 
    __in DRM_DWORD f_dwCertType )
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_verifyKeyUsage );
    
    if ( f_dwCertType != DRM_BCERT_CERTTYPE_UNKNOWN )
    {
        ChkBOOL( f_dwCertType <= DRM_BCERT_CERTTYPE_MAX_VALUE, 
            DRM_E_BCERT_INVALID_CERT_TYPE );
        ChkBOOL( f_dwKeyUsage != DRM_BCERT_KEYUSAGE_UNKNOWN 
              && f_dwKeyUsage <= DRM_BCERT_KEYUSAGE_MAX_VALUE, 
            DRM_E_BCERT_INVALID_KEY_USAGE );

        ChkBOOL( rgfKeyUsageMapping[ f_dwCertType ][ f_dwKeyUsage ], 
                 DRM_E_BCERT_INVALID_KEY_USAGE );
    }
ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/*****************************************************************************
** Function:    _verifyFeature
**
** Synopsis:    Verify that feature information matches certificate type.
**
** Arguments:   [f_dwFeature]   : feature data
**              [f_dwCertType]  : certificate type
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_BCERT_INVALID_CERT_TYPE - if cert type is invalid
**              DRM_E_BCERT_INVALID_FEATURE   - if feature is invalid 
**                                              or does not match cert type
**
** Notes:       None
******************************************************************************/
static DRM_NO_INLINE DRM_RESULT _verifyFeature( 
    __in DRM_DWORD f_dwFeature, 
    __in DRM_DWORD f_dwCertType )
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_verifyFeature );
    
    if ( f_dwCertType == 0
        || f_dwCertType > DRM_BCERT_CERTTYPE_MAX_VALUE )
    {
        ChkDR( DRM_E_BCERT_INVALID_CERT_TYPE );
    }

    if ( f_dwFeature == 0
        || f_dwFeature > DRM_BCERT_FEATURE_MAX_VALUE )
    {
        ChkDR( DRM_E_BCERT_INVALID_FEATURE );
    }

    ChkBOOL( rgfFeatureMapping[ f_dwCertType ][ f_dwFeature ], 
             DRM_E_BCERT_INVALID_FEATURE );

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}



/*****************************************************************************
** Function:    _verifyAdjacentCerts
**
** Synopsis:    Verifies that certificates in a chain are correctly linked:
**              1. Issuer key value is the same as a key entry in the next certificate
**                 that issued previous one.
**              2. Security level of the next cert is not lower 
**                 then that of the current cert.
**              3. The parent certificate has the appropriate issuer rights to issue
**                 the child certificate of a particular type with particular key usages and features.
**
** Arguments: [f_poChildCert]  : pointer to structure that contains information
**                               from the child certificate, cannot be NULL
**            [f_poParentCert] : pointer to structure with similar information 
**                               from the parent certificate, cannot be NULL
**                               so this function will never be called for a chain with one cert.
**    [f_pVerificationContext] : pointer to verification context structure
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_INVALIDARG
**              DRM_E_BCERT_ISSUERKEY_KEYINFO_MISMATCH
**              DRM_E_BCERT_INVALID_SECURITY_LEVEL
**              DRM_E_BCERT_INVALID_KEY_USAGE
**
******************************************************************************/
static DRM_NO_INLINE DRM_RESULT _verifyAdjacentCerts(
    __in_ecount(1)  const DRM_BCERT_MINIMALDATA     *f_poChildCert,
    __in_ecount(1)  const DRM_BCERT_MINIMALDATA     *f_poParentCert,
    __inout_ecount(1) DRM_BCERT_VERIFICATIONCONTEXT *f_pVerificationContext )
{
    DRM_RESULT dr                        = DRM_SUCCESS;
    DRM_DWORD  iKey                      = 0;
    DRM_DWORD  iCount                    = 0;
    DRM_DWORD  dwParentKeyUsageMask      = 0;
    DRM_DWORD  dwChildKeyUsageMask       = 0;
    DRM_BOOL   fSupportSecureClock       = FALSE;
    DRM_BOOL   fSupportAntiRollbackClock = FALSE;
    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_verifyAdjacentCerts );
    
    ChkArg( f_poChildCert != NULL );
    ChkArg( f_poParentCert != NULL );

    /*
    ** Parent cert type should be issuer because it has child certificate
    */
    ChkVerificationErr( f_pVerificationContext, 
                        f_poParentCert->oBasicInfo.dwType == DRM_BCERT_CERTTYPE_ISSUER, 
                        DRM_E_BCERT_INVALID_CERT_TYPE );

    /*
    ** Security level of the parent cert is higher or equal to its child cert's.
    */
    ChkVerificationErr( f_pVerificationContext,
                        f_poChildCert->oBasicInfo.dwSecurityLevel <= f_poParentCert->oBasicInfo.dwSecurityLevel,
                        DRM_E_BCERT_INVALID_SECURITY_LEVEL );

    /* 
    ** Issuer key for the current cert is the same as one of the key values in the child cert
    */
    dr = DRM_E_BCERT_ISSUERKEY_KEYINFO_MISMATCH;
    
    for ( iKey = 0; iKey < f_poParentCert->oKeyInfo.dwNumKeys; iKey++ )
    {
        if ( DRM_BYT_CompareBytes( f_poChildCert->oSignatureInfo.IssuerKey.rgb, 
                                   0, 
                                   f_poParentCert->oKeyInfo.rgoKeys[iKey].Value.rgb,
                                   0,
                                   DRM_BCERT_MAX_PUBKEY_VALUE_LENGTH ) == 0 )
        {
            dr = DRM_SUCCESS;
            break;
        }
    }
    if ( DRM_FAILED(dr) ) 
    {
        ChkVerificationErr( f_pVerificationContext, FALSE, dr);
    }

    /*
    ** Collect the key usages of the parent certificate for all keys in the certificate
    */
    for ( iKey = 0; iKey < f_poParentCert->oKeyInfo.dwNumKeys; iKey++ )
    {
        for ( iCount = 0; iCount < f_poParentCert->oKeyInfo.rgoKeys[iKey].dwNumUsageEntries; iCount++ )
        {
            dwParentKeyUsageMask |= BCERT_KEYUSAGE_BIT( f_poParentCert->oKeyInfo.rgoKeys[iKey].dwUsageSet[ iCount ] );
        }    
    }
    
    /*
    ** Check that the current certificate has appropriate Issuer rights
    ** to issue a child certificate of particular type.
    */
    if ( !(dwParentKeyUsageMask & BCERT_KEYUSAGE_BIT( DRM_BCERT_KEYUSAGE_ISSUER_ALL ) ) ) /* Issuer-All can issue anything */
    {
        if ( f_poChildCert->oBasicInfo.dwType == DRM_BCERT_CERTTYPE_DOMAIN )
        {
            /*
            ** Issuer-Domain can issue certificates of Type Domain.
            */
            ChkVerificationErr( f_pVerificationContext,
                                dwParentKeyUsageMask & BCERT_KEYUSAGE_BIT(DRM_BCERT_KEYUSAGE_ISSUER_DOMAIN), 
                                DRM_E_BCERT_INVALID_KEY_USAGE );
        } 
        else if ( f_poChildCert->oBasicInfo.dwType == DRM_BCERT_CERTTYPE_DEVICE )
        {
            /*
            ** Issuer-Device can issue certificate of Type Device.
            */
            ChkVerificationErr( f_pVerificationContext,
                                dwParentKeyUsageMask & BCERT_KEYUSAGE_BIT(DRM_BCERT_KEYUSAGE_ISSUER_DEVICE), 
                                DRM_E_BCERT_INVALID_KEY_USAGE );
        }
        else if ( f_poChildCert->oBasicInfo.dwType == DRM_BCERT_CERTTYPE_PC )
        {
            /*
            ** Issuer-Indiv can issue certificate of Type PC.
            */
            ChkVerificationErr( f_pVerificationContext,
                                dwParentKeyUsageMask & BCERT_KEYUSAGE_BIT(DRM_BCERT_KEYUSAGE_ISSUER_INDIV), 
                                DRM_E_BCERT_INVALID_KEY_USAGE );
        }
        else if ( f_poChildCert->oBasicInfo.dwType == DRM_BCERT_CERTTYPE_SILVERLIGHT )
        {
            /*
            ** Issuer-SilverLight can issue certificate of Type SilverLight.
            */
            ChkVerificationErr( f_pVerificationContext,
                                dwParentKeyUsageMask & BCERT_KEYUSAGE_BIT(DRM_BCERT_KEYUSAGE_ISSUER_SILVERLIGHT), 
                                DRM_E_BCERT_INVALID_KEY_USAGE );
        }    
        else if ( f_poChildCert->oBasicInfo.dwType == DRM_BCERT_CERTTYPE_APPLICATION )
        {
            /*
            ** Issuer-Application can issue certificate of Type Application.
            */
            ChkVerificationErr( f_pVerificationContext,
                                dwParentKeyUsageMask & BCERT_KEYUSAGE_BIT(DRM_BCERT_KEYUSAGE_ISSUER_APPLICATION), 
                                DRM_E_BCERT_INVALID_KEY_USAGE );
        }    
        else if ( f_poChildCert->oBasicInfo.dwType == DRM_BCERT_CERTTYPE_METERING)
        {
            /*
            ** Issuer-Metering can issue certificate of Type Metering.
            */
            ChkVerificationErr( f_pVerificationContext,
                                dwParentKeyUsageMask & BCERT_KEYUSAGE_BIT(DRM_BCERT_KEYUSAGE_ISSUER_METERING), 
                                DRM_E_BCERT_INVALID_KEY_USAGE );
        }
        else if ( f_poChildCert->oBasicInfo.dwType == DRM_BCERT_CERTTYPE_KEYFILESIGNER )
        {
            /*
            ** Issuer-SignKeyFile can issue certificate of Type KeyFileSigner
            */
            ChkVerificationErr( f_pVerificationContext,
                                dwParentKeyUsageMask & BCERT_KEYUSAGE_BIT(DRM_BCERT_KEYUSAGE_ISSUER_SIGN_KEYFILE), 
                                DRM_E_BCERT_INVALID_KEY_USAGE );
        }
        else if ( f_poChildCert->oBasicInfo.dwType == DRM_BCERT_CERTTYPE_SERVER )
        {
            /*
            ** Issuer-Server can issue certificate of Type Server
            */
            ChkVerificationErr( f_pVerificationContext,
                                dwParentKeyUsageMask & BCERT_KEYUSAGE_BIT(DRM_BCERT_KEYUSAGE_ISSUER_SERVER), 
                                DRM_E_BCERT_INVALID_KEY_USAGE );
        }        else if ( f_poChildCert->oBasicInfo.dwType == DRM_BCERT_CERTTYPE_CRL_SIGNER )
        {
            /*
            ** Issuer-CLR can issue certificate of Type CRL Signer
            */
            ChkBOOL( dwParentKeyUsageMask & BCERT_KEYUSAGE_BIT(DRM_BCERT_KEYUSAGE_ISSUER_CRL), DRM_E_BCERT_INVALID_KEY_USAGE );
        }
        else if ( f_poChildCert->oBasicInfo.dwType == DRM_BCERT_CERTTYPE_ISSUER )
        {
            /*
            ** Issuer cert is issued by another issuer cert, and Issuer-related key usages should match.
            */
            for ( iKey = 0; iKey < f_poChildCert->oKeyInfo.dwNumKeys; iKey++ )
            {
                for ( iCount = 0; iCount < f_poChildCert->oKeyInfo.rgoKeys[iKey].dwNumUsageEntries; iCount++ )
                {
                    dwChildKeyUsageMask |= BCERT_KEYUSAGE_BIT( f_poChildCert->oKeyInfo.rgoKeys[iKey].dwUsageSet[ iCount ] );
                }    
            }
            
            /* 
            ** Cannot have Issuer-All child cert 
            */
            ChkVerificationErr( f_pVerificationContext,
                !( dwChildKeyUsageMask & BCERT_KEYUSAGE_BIT( DRM_BCERT_KEYUSAGE_ISSUER_ALL ) ),
                DRM_E_BCERT_INVALID_KEY_USAGE ); 
            /*
            ** Check key usages in a child cert: 
            ** the parent cert is not Issuer-All and must have all issuer-... key usages that child cert has
            */
            ChkVerificationErr( f_pVerificationContext,
                    ( dwChildKeyUsageMask & BCERT_KEYUSAGE_PARENT_ISSUERS_MASK ) 
                        <= ( dwParentKeyUsageMask & BCERT_KEYUSAGE_PARENT_ISSUERS_MASK ),
                    DRM_E_BCERT_INVALID_KEY_USAGE );
        }
        else
        {
            /*
            ** Service cert type. If it has a parent cert it can only be Issuer_All cert, so fail
            */
            ChkVerificationErr( f_pVerificationContext,
                                f_poChildCert->oBasicInfo.dwType == DRM_BCERT_CERTTYPE_SERVICE,
                                DRM_E_BCERT_INVALID_CERT_TYPE );

            ChkVerificationErr( f_pVerificationContext, FALSE, DRM_E_BCERT_INVALID_KEY_USAGE );
        } 
    }

    /*
    ** Some features in a child cert can only be issued by a parent cert with specific key usages.
    */
    for ( iCount = 0; iCount < f_poChildCert->oFeatureInfo.dwNumFeatureEntries; iCount++ )
    {
        if (  f_poChildCert->oFeatureInfo.rgdwFeatureSet[ iCount ] == DRM_BCERT_FEATURE_TRANSMITTER
           || f_poChildCert->oFeatureInfo.rgdwFeatureSet[ iCount ] == DRM_BCERT_FEATURE_RECEIVER
           || f_poChildCert->oFeatureInfo.rgdwFeatureSet[ iCount ] == DRM_BCERT_FEATURE_SHARED_CERTIFICATE )
        {
            /*
            ** Transmitter, Receiver, SharedCertificate can be issued by Issuer-Link.
            */
            ChkVerificationErr( f_pVerificationContext,
                                dwParentKeyUsageMask & BCERT_KEYUSAGE_BIT(DRM_BCERT_KEYUSAGE_ISSUER_LINK), 
                                DRM_E_BCERT_INVALID_KEY_USAGE );
        }
        else if ( f_poChildCert->oFeatureInfo.rgdwFeatureSet[ iCount ] == DRM_BCERT_FEATURE_SECURE_CLOCK )
        {
            /*
            ** SecureClock can be issued by Issuer-Device.
            */
            ChkVerificationErr( f_pVerificationContext,
                                dwParentKeyUsageMask & BCERT_KEYUSAGE_BIT(DRM_BCERT_KEYUSAGE_ISSUER_DEVICE), 
                                DRM_E_BCERT_INVALID_KEY_USAGE );
            fSupportSecureClock = TRUE;
        }
        else if ( f_poChildCert->oFeatureInfo.rgdwFeatureSet[ iCount ] == DRM_BCERT_FEATURE_ANTIROLLBACK_CLOCK )
        {
            /*
            ** Anti-Rollback Clock can be issued by Issuer-Device.
            */
            ChkVerificationErr( f_pVerificationContext,
                                dwParentKeyUsageMask & BCERT_KEYUSAGE_BIT(DRM_BCERT_KEYUSAGE_ISSUER_DEVICE), 
                                DRM_E_BCERT_INVALID_KEY_USAGE );
            fSupportAntiRollbackClock = TRUE;
        }
    }

    /*
    ** Either SecureClock or Anti-Rollback Clock can be issued in one certificate, never both.
    */
    ChkVerificationErr( f_pVerificationContext,
                        !( fSupportSecureClock && fSupportAntiRollbackClock ), 
                        DRM_E_BCERT_INVALID_KEY_USAGE );

ErrorExit:    
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/*****************************************************************************
** Function:    _getObjectHeader
**
** Synopsis:    Parses an object header. If object type is unknown and not 
**              "must understand" function locates the next object header it can read.
**
** Arguments:   [f_pbCertData] : data buffer that is parsed
**              [f_cbCertData] : size of the data buffer (in bytes)
**              [f_pbOffset]   : position to start parsing from
**              [f_poHeader]   : pointer to an object header structure, cannot be NULL
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_INVALIDARG
**              DRM_E_ARITHMETIC_OVERFLOW - if either f_pbOffset or an object length is too big
**              DRM_E_BCERT_OBJECTHEADER_LEN_TOO_BIG - object length value is too big
**
******************************************************************************/
static DRM_NO_INLINE DRM_RESULT _getObjectHeader( 
    __in_bcount(f_cbCertData) const DRM_BYTE          *f_pbCertData,
    __in                      const DRM_DWORD         f_cbCertData,
    __inout_ecount(1)         DRM_DWORD               *f_pbOffset,
    __inout_ecount(1)         DRM_BCERT_OBJECT_HEADER *f_poHeader )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  dwOffset = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_getObjectHeader );
    
    ChkArg( f_pbCertData != NULL );
    ChkArg( f_pbOffset != NULL );
    ChkArg( *f_pbOffset < f_cbCertData );
    ChkArg( f_poHeader != NULL );
    ChkOverflow( f_cbCertData, *f_pbOffset );

    dwOffset = *f_pbOffset;

    /*
    ** Read all object header attributes
    */
    NETWORKBYTES_FROMBUFFER_TO_WORD( f_poHeader->wFlags, 
                                     f_pbCertData, 
                                     dwOffset,
                                     f_cbCertData );

    NETWORKBYTES_FROMBUFFER_TO_WORD( f_poHeader->wType, 
                                     f_pbCertData, 
                                     dwOffset,
                                     f_cbCertData );

    NETWORKBYTES_FROMBUFFER_TO_DWORD( f_poHeader->cbLength, 
                                      f_pbCertData, 
                                      dwOffset,
                                      f_cbCertData );
    /*
    ** Object length should be small enough and inside data buffer.
    ** Note that object header is included into object length.
    */
    ChkOverflow( *f_pbOffset + f_poHeader->cbLength, *f_pbOffset );
    ChkBOOL( *f_pbOffset + f_poHeader->cbLength <= f_cbCertData,
             DRM_E_BCERT_OBJECTHEADER_LEN_TOO_BIG );    

    if ( f_poHeader->wType > DRM_BCERT_OBJTYPE_MAX_VALUE )
    {
        /*
        ** If object's type is unknown but flag is not "must understand"
        ** try to skip it and read the next one
        */
        ChkBOOL( f_poHeader->wFlags != DRM_BCERT_OBJFLAG_MUST_UNDERSTAND, 
                 DRM_E_BCERT_UNEXPECTED_OBJECT_HEADER );

        *f_pbOffset += f_poHeader->cbLength;

        ChkDR( _getObjectHeader( f_pbCertData,
                                 f_cbCertData,
                                 f_pbOffset,
                                 f_poHeader ) );
    }
    else
    {
        /* 
        ** move current offset past object header and stop reading
        */
        ChkBoundsLT( dwOffset, f_cbCertData );
        *f_pbOffset = dwOffset;
    }

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

/*****************************************************************************
** Function:    _parseCertHeader
**
** Synopsis:    Parses a certificate's header.
**
** Arguments:   [f_pbCertData]   : data buffer that is being parsed
**              [f_cbCertData]   : size of the data buffer (in bytes)
**              [f_pbOffset]     : position to start parsing from
**              [f_poCertHeader] : pointer to a certificate header structure, cannot be NULL
**      [f_pVerificationContext] : pointer to verification context structure
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_INVALIDARG
**              DRM_E_ARITHMETIC_OVERFLOW - if offset is too big
**              DRM_E_BUFFERTOOSMALL - buffer is shorter than expected
**              DRM_E_BCERT_INVALID_CERT_HEADER_TAG
**              DRM_E_BCERT_INVALID_CERT_VERSION
**              DRM_E_BCERT_INVALID_CERT_LENGTH
**              DRM_E_BCERT_INVALID_SIGNEDCERT_LENGTH
**              
** Notes:       None.
**
******************************************************************************/
static DRM_NO_INLINE DRM_RESULT _parseCertHeader(
    __in_bcount(f_cbCertData) const DRM_BYTE   *f_pbCertData,
    __in                      const DRM_DWORD   f_cbCertData,
    __inout_ecount(1)         DRM_DWORD        *f_pbOffset,
    __inout_ecount(1)         DRM_BCERT_HEADER *f_poCertHeader,
    __inout_ecount(1)         DRM_BCERT_VERIFICATIONCONTEXT *f_pVerificationContext )
{
    DRM_RESULT dr       = DRM_SUCCESS;
    DRM_DWORD  dwOffset = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_parseCertHeader );

    ChkArg( f_pbCertData != NULL );
    ChkArg( f_cbCertData > 0 );
    ChkArg( f_pbOffset != NULL );
    ChkArg( f_poCertHeader != NULL );
    ChkOverflow( f_cbCertData, *f_pbOffset );

    dwOffset = *f_pbOffset;

    NETWORKBYTES_FROMBUFFER_TO_DWORD( f_poCertHeader->dwHeaderTag, 
                                      f_pbCertData, 
                                      dwOffset,
                                      f_cbCertData );
    
    NETWORKBYTES_FROMBUFFER_TO_DWORD( f_poCertHeader->dwVersion, 
                                      f_pbCertData, 
                                      dwOffset,
                                      f_cbCertData );
    
    NETWORKBYTES_FROMBUFFER_TO_DWORD( f_poCertHeader->cbCertificate, 
                                      f_pbCertData, 
                                      dwOffset,
                                      f_cbCertData );

    NETWORKBYTES_FROMBUFFER_TO_DWORD( f_poCertHeader->cbCertificateSigned, 
                                      f_pbCertData, 
                                      dwOffset,
                                      f_cbCertData );

    
    /*
    ** Header constant tag is correct
    */
    ChkVerificationErr( f_pVerificationContext,
                        f_poCertHeader->dwHeaderTag == DRM_BCERT_HEADER_TAG, 
                        DRM_E_BCERT_INVALID_CERT_HEADER_TAG );
    /*
    ** Version is 1
    */
    ChkVerificationErr( f_pVerificationContext,
                        f_poCertHeader->dwVersion == DRM_BCERT_VERSION, 
                        DRM_E_BCERT_INVALID_CERT_VERSION );
    /* 
    ** length is at least DRM_MIN_CERTIFICATE_LEN and no bigger then
    ** the byte array we are parsing
    */
    ChkBOOL( f_poCertHeader->cbCertificate >= DRM_MIN_CERTIFICATE_LEN, 
             DRM_E_BCERT_INVALID_CERT_LENGTH );
    ChkBOOL( f_poCertHeader->cbCertificate <= f_cbCertData, 
             DRM_E_BCERT_INVALID_CERT_LENGTH );
    /*
    ** length to signature object is <= length
    */
    ChkBOOL( f_poCertHeader->cbCertificateSigned <= f_poCertHeader->cbCertificate, 
             DRM_E_BCERT_INVALID_SIGNEDCERT_LENGTH );
    /*
    ** length up to Signature Object should be larger 
    ** than minimal certificate length - signature length
    */
    ChkBOOL( f_poCertHeader->cbCertificateSigned 
            >=  DRM_MIN_CERTIFICATE_LEN - DRM_BCERT_SIGNATURE_OBJECT_LEN,
            DRM_E_BCERT_INVALID_SIGNEDCERT_LENGTH );

    *f_pbOffset = dwOffset;

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/*****************************************************************************
** Function:    _parseCertBasicInfo
**
** Synopsis:    Parses a certificate's basic info.
**
** Arguments:   [f_pbCertData]  : data buffer that is being parsed
**              [f_cbCertData]  : size of the data buffer (in bytes)
**              [f_pbOffset]    : position to start parsing from
**              [f_poBasicInfo] : pointer to a basic info structure, cannot be NULL
**     [f_pVerificationContext] : pointer to verification context structure
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_INVALIDARG
**              DRM_E_ARITHMETIC_OVERFLOW - if offset is too big
**              DRM_E_BUFFERTOOSMALL - buffer is shorter than expected
**              DRM_E_BCERT_INVALID_SECURITY_LEVEL
**              DRM_E_BCERT_INVALID_CERT_TYPE
**              DRM_E_BCERT_BASICINFO_CERT_EXPIRED
**              DRM_E_BCERT_EXTDATAFLAG_CERT_TYPE_MISMATCH
**
** Notes:       f_pbOffset points to basic info data not including object header.
******************************************************************************/
static DRM_NO_INLINE DRM_RESULT _parseCertBasicInfo(
    __in_bcount(f_cbCertData) const DRM_BYTE       *f_pbCertData,
    __in                      const DRM_DWORD      f_cbCertData,
    __inout_ecount(1)         DRM_DWORD            *f_pbOffset,
    __inout_ecount(1)         DRM_BCERT_BASIC_INFO *f_poBasicInfo,
    __inout_ecount(1)         DRM_BCERT_VERIFICATIONCONTEXT *f_pVerificationContext )
{
    DRM_RESULT  dr           = DRM_SUCCESS;
    DRM_DWORD   dwOffset     = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_parseCertBasicInfo );

    ChkArg( f_pbCertData != NULL );
    ChkArg( f_cbCertData > 0 );
    ChkArg( f_pbOffset != NULL );
    ChkArg( f_poBasicInfo != NULL );
    ChkOverflow( f_cbCertData, *f_pbOffset );

    dwOffset = *f_pbOffset;
        
    /*
    ** read certificate ID
    */
    COPY_FROMBUFFER( f_poBasicInfo->CertificateID.rgb, 
                     f_pbCertData, 
                     dwOffset, 
                     DRM_BCERT_CERT_ID_LENGTH, 
                     f_cbCertData );

    /*
    ** read security level data
    */
    NETWORKBYTES_FROMBUFFER_TO_DWORD( 
            f_poBasicInfo->dwSecurityLevel, 
            f_pbCertData, 
            dwOffset,
            f_cbCertData );

    /*
    ** read flags
    */
    NETWORKBYTES_FROMBUFFER_TO_DWORD( 
            f_poBasicInfo->dwFlags, 
            f_pbCertData, 
            dwOffset,      
            f_cbCertData );

    /*
    ** read and verify cert type
    */
    NETWORKBYTES_FROMBUFFER_TO_DWORD( 
            f_poBasicInfo->dwType, 
            f_pbCertData, 
            dwOffset,
            f_cbCertData );

    ChkVerificationErr( f_pVerificationContext, 
                        f_poBasicInfo->dwType <= DRM_BCERT_CERTTYPE_MAX_VALUE, 
                        DRM_E_BCERT_INVALID_CERT_TYPE );

    if ( (f_poBasicInfo->dwFlags & DRM_BCERT_FLAGS_EXTDATA_PRESENT) == DRM_BCERT_FLAGS_EXTDATA_PRESENT )
    {
        ChkVerificationErr( f_pVerificationContext,
                            f_poBasicInfo->dwType == DRM_BCERT_CERTTYPE_PC, 
                            DRM_E_BCERT_EXTDATAFLAG_CERT_TYPE_MISMATCH );
    }
       
    /*
    ** read digest value, no verification is needed
    */
    COPY_FROMBUFFER( 
            f_poBasicInfo->DigestValue.m_rgbDigest, 
            f_pbCertData, 
            dwOffset,
            SHA256_DIGEST_SIZE_IN_BYTES, 
            f_cbCertData );
    
    /*
    ** read expiration date and verify it is post current time.
    */
    NETWORKBYTES_FROMBUFFER_TO_DWORD( 
            f_poBasicInfo->dwExpirationDate, 
            f_pbCertData, 
            dwOffset,
            f_cbCertData );
    /*
    ** read client ID
    */
    COPY_FROMBUFFER( 
            f_poBasicInfo->ClientID.rgb, 
            f_pbCertData, 
            dwOffset,
            DRM_BCERT_CLIENT_ID_LENGTH, 
            f_cbCertData );
    
    *f_pbOffset = dwOffset;
    
ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/*****************************************************************************
** Function:    _parseDomainInfo
**
** Synopsis:    Parses a certificate's domain info. The data will not be copied
**              if we only verify it.
**
** Arguments:   [f_pbCertData]   : data buffer that is being parsed
**              [f_cbCertData]   : size of the data buffer (in bytes)
**              [f_pbOffset]     : position to start parsing from
**              [f_poDomainInfo] : pointer to a domain info structure, can be NULL
**                                 in which case we only do verification.
**      [f_pVerificationContext] : pointer to verification context structure
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_INVALIDARG
**              DRM_E_ARITHMETIC_OVERFLOW - if offset is too big
**              DRM_E_BUFFERTOOSMALL - buffer is shorter than expected
**              DRM_E_BCERT_DOMAIN_URL_TOO_LONG
**
** Notes:       f_pbOffset points to domain info data not including object header.
******************************************************************************/
static DRM_NO_INLINE DRM_RESULT _parseDomainInfo(
    __in_bcount(f_cbCertData) const DRM_BYTE        *f_pbCertData,
    __in                      const DRM_DWORD       f_cbCertData,
    __inout_ecount(1)         DRM_DWORD             *f_pbOffset,
    __inout_ecount_opt(1)     DRM_BCERT_DOMAIN_INFO *f_poDomainInfo,
    __inout_ecount(1)         DRM_BCERT_VERIFICATIONCONTEXT *f_pVerificationContext )
{
    DRM_RESULT dr       = DRM_SUCCESS;
    DRM_DWORD  dwOffset = 0;
    DRM_DWORD  dwUrlLength = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_parseDomainInfo );

    ChkArg( f_pbCertData != NULL );
    ChkArg( f_cbCertData > 0 );
    ChkArg( f_pbOffset != NULL );
    ChkOverflow( f_cbCertData, *f_pbOffset );

    dwOffset = *f_pbOffset;

    if ( f_poDomainInfo != NULL )
    {
        /*
        ** read service ID
        */
        COPY_FROMBUFFER( f_poDomainInfo->ServiceID.rgb, 
                         f_pbCertData, 
                         dwOffset, 
                         DRM_BCERT_SERVICE_ID_LENGTH, 
                         f_cbCertData );
            
        /*
        ** read account ID
        */
        COPY_FROMBUFFER( f_poDomainInfo->AccountID.rgb, 
                         f_pbCertData, 
                         dwOffset,
                         DRM_BCERT_ACCOUNT_ID_LENGTH, 
                         f_cbCertData );
       
        /*
        ** read revision timestamp
        */
        NETWORKBYTES_FROMBUFFER_TO_DWORD( 
                f_poDomainInfo->dwRevision, 
                f_pbCertData, 
                dwOffset,
                f_cbCertData );
    }
    else
    {
        dwOffset += DRM_BCERT_SERVICE_ID_LENGTH + DRM_BCERT_ACCOUNT_ID_LENGTH + SIZEOF( DRM_DWORD );
    }
    /*
    ** Read length of domain URL.  Note that it is length without padding.
    */
    NETWORKBYTES_FROMBUFFER_TO_DWORD( dwUrlLength,
                                      f_pbCertData, 
                                      dwOffset,
                                      f_cbCertData );    
    /*
    ** Domain URL cannot be empty or too big
    */
    ChkBOOL( dwUrlLength > 0, DRM_E_NO_URL );
    ChkBOOL( dwUrlLength <= DRM_BCERT_MAX_DOMAIN_URL_LENGTH, DRM_E_BCERT_DOMAIN_URL_TOO_LONG );
    /*
    ** No overflow or reading outside buffer boundaries
    */
    ChkOverflow( dwOffset + dwUrlLength, dwOffset );
    ChkOverflow( dwOffset + dwUrlLength + PAD_AMOUNT(dwUrlLength), dwOffset + dwUrlLength );
    ChkOverflow( f_cbCertData, dwOffset + dwUrlLength + PAD_AMOUNT(dwUrlLength) );
    /*
    ** Domain URL is a null-terminated UTF-8 string
    */
    dr = _isUTF8NullTerminatedData( f_pbCertData + dwOffset, dwUrlLength );
    ChkVerificationErr( f_pVerificationContext, DRM_SUCCEEDED(dr), dr );
    dr = DRM_SUCCESS;

    if ( f_poDomainInfo != NULL )
    {
        COPY_FROMBUFFER( 
                f_poDomainInfo->DomainURL.rgb, 
                f_pbCertData, 
                dwOffset,
                dwUrlLength + PAD_AMOUNT( dwUrlLength ), 
                f_cbCertData );
        
        f_poDomainInfo->DomainURL.cb = dwUrlLength;
    }
    else
    {
        dwOffset += dwUrlLength + PAD_AMOUNT( dwUrlLength );
    }
    
    *f_pbOffset = dwOffset;
    
ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/*****************************************************************************
** Function:    _parsePCInfo
**
** Synopsis:    Parses a certificate's PC info.
**
** Arguments:   [f_pbCertData] : data buffer that is being parsed
**              [f_cbCertData] : size of the data buffer (in bytes)
**              [f_pbOffset]   : position to start parsing from
**              [f_poPCInfo]   : pointer to a PC info structure, can be NULL
**
**              DRM_E_INVALIDARG
**              DRM_E_ARITHMETIC_OVERFLOW - if offset is too big
**              DRM_E_BUFFERTOOSMALL - buffer is shorter than expected
**              DRM_E_BCERT_HARDWARE_ID_TOO_LONG
**
** Notes:       f_pbOffset points to PC info data not including object header.
******************************************************************************/
static DRM_NO_INLINE DRM_RESULT _parsePCInfo(
    __in_bcount(f_cbCertData) const DRM_BYTE    *f_pbCertData,
    __in                      const DRM_DWORD   f_cbCertData,
    __inout_ecount(1)         DRM_DWORD         *f_pbOffset,
    __inout_ecount_opt(1)     DRM_BCERT_PC_INFO *f_poPCInfo )
{
    DRM_RESULT dr     = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_parsePCInfo );

    ChkArg( f_pbCertData != NULL );
    ChkArg( f_cbCertData > 0 );
    ChkArg( f_pbOffset != NULL );

    ChkOverflow( f_cbCertData, *f_pbOffset );
    
    /*
    ** Read security version
    */
    if ( f_poPCInfo != NULL )
    {
        NETWORKBYTES_FROMBUFFER_TO_DWORD( 
                f_poPCInfo->dwSecurityVersion,
                f_pbCertData, 
                *f_pbOffset,
                f_cbCertData );
    }
    else
    {
        ChkOverflow( *f_pbOffset + SIZEOF( DRM_DWORD ), *f_pbOffset );
        ChkBoundsLT( *f_pbOffset + SIZEOF( DRM_DWORD ), f_cbCertData );
        *f_pbOffset += SIZEOF( DRM_DWORD );
    }

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/*****************************************************************************
** Function:    _parseServerInfo
**
** Synopsis:    Parses a certificate's Server info.
**
** Arguments:   [f_pbCertData]   : data buffer that is being parsed
**              [f_cbCertData]   : size of the data buffer (in bytes)
**              [f_pbOffset]     : position to start parsing from
**              [f_poServerInfo] : pointer to a Server info structure, can be NULL
**              [f_pVerificationContext] : pointer to verification context structure
**
**              DRM_E_INVALIDARG
**              DRM_E_ARITHMETIC_OVERFLOW - if offset is too big
**              DRM_E_BUFFERTOOSMALL - buffer is shorter than expected
**
** Notes:       f_pbOffset points to Server info data not including object header.
******************************************************************************/
static DRM_RESULT _parseServerInfo(
    __in_bcount(f_cbCertData) const DRM_BYTE    *f_pbCertData,
    __in                      const DRM_DWORD   f_cbCertData,
    __inout_ecount(1)         DRM_DWORD         *f_pbOffset,
    __inout_ecount_opt(1)     DRM_BCERT_SERVER_INFO *f_poServerInfo,
    __inout_ecount(1)         DRM_BCERT_VERIFICATIONCONTEXT *f_pVerificationContext )
{
    DRM_RESULT dr               = DRM_SUCCESS;
    DRM_DWORD  dwWarningDays    = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_parseServerInfo );

    ChkArg( f_pbCertData != NULL );
    ChkArg( f_cbCertData > 0 );
    ChkArg( f_pbOffset != NULL );

    ChkOverflow( f_cbCertData, *f_pbOffset );
    
    /*
    ** Read warning days
    */
    NETWORKBYTES_FROMBUFFER_TO_DWORD( 
            dwWarningDays,
            f_pbCertData, 
            *f_pbOffset,
            f_cbCertData );
    ChkVerificationErr( f_pVerificationContext, dwWarningDays > 0, DRM_E_BCERT_INVALID_WARNING_DAYS );
    
    if ( f_poServerInfo != NULL )
    {
        f_poServerInfo->dwWarningDays = dwWarningDays;
    }

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/*****************************************************************************
** Function:    _parseSilverLightInfo
**
** Synopsis:    Parses a certificate's SilverLight info.
**
** Arguments:   [f_pbCertData]        : data buffer that is being parsed
**              [f_cbCertData]        : size of the data buffer (in bytes)
**              [f_pbOffset]          : position to start parsing from
**              [f_poSilverLightInfo] : pointer to a SilverLight info structure, can be NULL
**           [f_pVerificationContext] : pointer to verification context structure
**
**              DRM_E_INVALIDARG
**              DRM_E_ARITHMETIC_OVERFLOW - if offset is too big
**              DRM_E_BUFFERTOOSMALL - buffer is shorter than expected
**              DRM_E_BCERT_HARDWARE_ID_TOO_LONG
**
** Notes:       f_pbOffset points to Silverlight info data not including object header.
******************************************************************************/
static DRM_NO_INLINE DRM_RESULT _parseSilverLightInfo(
    __in_bcount(f_cbCertData) const DRM_BYTE             *f_pbCertData,
    __in                      const DRM_DWORD             f_cbCertData,
    __inout_ecount(1)         DRM_DWORD                  *f_pbOffset,
    __inout_ecount_opt(1)     DRM_BCERT_SILVERLIGHT_INFO *f_poSilverLightInfo,
    __inout_ecount(1)         DRM_BCERT_VERIFICATIONCONTEXT *f_pVerificationContext )
{
    DRM_RESULT dr     = DRM_SUCCESS;
    DRM_DWORD  dwData = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_parseSilverLightInfo );

    ChkArg( f_pbCertData != NULL );
    ChkArg( f_cbCertData > 0 );
    ChkArg( f_pbOffset != NULL );
    ChkOverflow( f_cbCertData, *f_pbOffset );
    
    /*
    ** Read security version
    */
    NETWORKBYTES_FROMBUFFER_TO_DWORD( dwData, 
                                      f_pbCertData, 
                                      *f_pbOffset,
                                      f_cbCertData );

    ChkVerificationErr( f_pVerificationContext, dwData != 0, DRM_E_BCERT_INVALID_SECURITY_VERSION );
    if ( f_poSilverLightInfo != NULL )
    {
        f_poSilverLightInfo->dwSecurityVersion = dwData;
    }

    /*
    ** Read platform identifier
    */
    NETWORKBYTES_FROMBUFFER_TO_DWORD( dwData, 
                                      f_pbCertData, 
                                      *f_pbOffset,
                                      f_cbCertData );

    ChkVerificationErr( f_pVerificationContext,
                        dwData <= DRM_BCERT_SILVERLIGHT_PLATFORM_MAX, 
                        DRM_E_BCERT_INVALID_PLATFORM_IDENTIFIER);
    if ( f_poSilverLightInfo != NULL )
    {
        f_poSilverLightInfo->dwPlatformIdentifier = dwData;
    }

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/*****************************************************************************
** Function:    _parseDeviceInfo
**
** Synopsis:    Parses a certificate's Device info.
**
** Arguments:   [f_pbCertData]   : data buffer that is being parsed
**              [f_cbCertData]   : size of the data buffer (in bytes)
**              [f_pbOffset]     : position to start parsing from
**              [f_poDeviceInfo] : pointer to a device info structure, can be NULL
**      [f_pVerificationContext] : pointer to verification context structure
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_INVALIDARG
**              DRM_E_BCERT_INVALID_MAX_LICENSE_SIZE
**              DRM_E_BCERT_INVALID_MAX_HEADER_SIZE
**              DRM_E_BCERT_INVALID_MAX_LICENSE_CHAIN_DEPTH
**
** Notes:       f_pbOffset points to device info data not including object header.
******************************************************************************/
static DRM_NO_INLINE DRM_RESULT _parseDeviceInfo(
    __in_bcount(f_cbCertData) const DRM_BYTE        *f_pbCertData,
    __in                      const DRM_DWORD       f_cbCertData,
    __inout_ecount(1)         DRM_DWORD             *f_pbOffset,
    __inout_ecount_opt(1)     DRM_BCERT_DEVICE_INFO *f_poDeviceInfo,
    __inout_ecount(1)         DRM_BCERT_VERIFICATIONCONTEXT *f_pVerificationContext )

{
    DRM_RESULT dr       = DRM_SUCCESS;
    DRM_DWORD  dwData   = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_parseDeviceInfo );

    ChkArg( f_pbCertData != NULL );
    ChkArg( f_cbCertData > 0 );
    ChkArg( f_pbOffset != NULL );

    ChkOverflow( f_cbCertData, *f_pbOffset );

    /*
    ** Read and verify max license size
    */
    NETWORKBYTES_FROMBUFFER_TO_DWORD( dwData, 
                                      f_pbCertData, 
                                      *f_pbOffset,
                                      f_cbCertData );

    ChkVerificationErr( f_pVerificationContext,
                        dwData == DRM_BCERT_MAX_LICENSE_SIZE, 
                        DRM_E_BCERT_INVALID_MAX_LICENSE_SIZE );
    if ( f_poDeviceInfo != NULL )
    {
        f_poDeviceInfo->cbMaxLicense = dwData;
    }

    /*
    ** Read and verify max header size
    */
    NETWORKBYTES_FROMBUFFER_TO_DWORD( dwData, 
                                      f_pbCertData, 
                                      *f_pbOffset,
                                      f_cbCertData );

    ChkVerificationErr( f_pVerificationContext,
                        dwData == DRM_BCERT_MAX_HEADER_SIZE, 
                        DRM_E_BCERT_INVALID_MAX_HEADER_SIZE );
    if ( f_poDeviceInfo != NULL )
    {
        f_poDeviceInfo->cbMaxHeader = dwData;
    }
    /*
    ** Read and verify max chain depth
    */
    NETWORKBYTES_FROMBUFFER_TO_DWORD( dwData, 
                                      f_pbCertData, 
                                      *f_pbOffset,
                                      f_cbCertData );

    ChkVerificationErr( f_pVerificationContext,
                        dwData == DRM_BCERT_MAX_LICENSE_CHAIN_DEPTH, 
                        DRM_E_BCERT_INVALID_MAX_LICENSE_CHAIN_DEPTH );
    if ( f_poDeviceInfo != NULL )
    {
        f_poDeviceInfo->dwMaxChainDepth = dwData;
    }

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/*****************************************************************************
** Function:    _parseMeteringInfo
**
** Synopsis:    Parses a certificate's metering info. The data will not be copied
**              if we only verify it.
**
** Arguments:   [f_pbCertData]   : data buffer that is being parsed
**              [f_cbCertData]   : size of the data buffer (in bytes)
**              [f_pbOffset]     : position to start parsing from
**            [f_poMeteringInfo] : pointer to a metering info structure, can be NULL
**                                 in which case we only do verification.
**      [f_pVerificationContext] : pointer to verification context structure
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_INVALIDARG
**              DRM_E_ARITHMETIC_OVERFLOW - if offset is too big
**              DRM_E_BUFFERTOOSMALL - buffer is shorter than expected
**              DRM_E_BCERT_METERING_URL_TOO_LONG
**
** Notes:       f_pbOffset points to metering info data not including object header.
******************************************************************************/
static DRM_NO_INLINE DRM_RESULT _parseMeteringInfo(
    __in_bcount(f_cbCertData) const DRM_BYTE          *f_pbCertData,
    __in                      const DRM_DWORD          f_cbCertData,
    __inout_ecount(1)         DRM_DWORD               *f_pbOffset,
    __inout_ecount_opt(1)     DRM_BCERT_METERING_INFO *f_poMeteringInfo,
    __inout_ecount(1)         DRM_BCERT_VERIFICATIONCONTEXT *f_pVerificationContext )
{
    DRM_RESULT dr       = DRM_SUCCESS;
    DRM_DWORD  dwOffset = 0;
    DRM_DWORD  dwUrlLength = 0;

    ChkArg( f_pbCertData != NULL );
    ChkArg( f_cbCertData > 0 );
    ChkArg( f_pbOffset != NULL );
    ChkOverflow( f_cbCertData, *f_pbOffset );

    dwOffset = *f_pbOffset;

    if ( f_poMeteringInfo != NULL )
    {
        /*
        ** read metering ID
        */
        COPY_FROMBUFFER( f_poMeteringInfo->MeteringID.rgb, 
                         f_pbCertData, 
                         dwOffset, 
                         DRM_BCERT_METERING_ID_LENGTH, 
                         f_cbCertData );            
    }
    else
    {
        ChkOverflow( dwOffset + DRM_BCERT_METERING_ID_LENGTH, dwOffset );
        dwOffset += DRM_BCERT_METERING_ID_LENGTH;
    }
    
    /*
    ** Read length of metering URL.  Note that it is length without padding.
    */
    NETWORKBYTES_FROMBUFFER_TO_DWORD( dwUrlLength,
                                      f_pbCertData, 
                                      dwOffset,
                                      f_cbCertData );    
    /*
    ** Metering URL cannot be empty or too big
    */
    ChkBOOL( dwUrlLength > 0, DRM_E_NO_URL );
    ChkBOOL( dwUrlLength <= DRM_BCERT_MAX_METERING_URL_LENGTH, DRM_E_BCERT_METERING_URL_TOO_LONG );
    /*
    ** No overflow or reading outside buffer boundaries
    */
    ChkOverflow( dwOffset + dwUrlLength, dwOffset );
    ChkOverflow( dwOffset + dwUrlLength + PAD_AMOUNT(dwUrlLength), dwOffset + dwUrlLength );
    ChkOverflow( f_cbCertData, dwOffset + dwUrlLength + PAD_AMOUNT(dwUrlLength) );
    /*
    ** Metering URL is a null-terminated UTF-8 string
    */
    dr = _isUTF8NullTerminatedData( f_pbCertData + dwOffset, dwUrlLength );
    ChkVerificationErr( f_pVerificationContext, DRM_SUCCEEDED(dr), dr );
    dr = DRM_SUCCESS;

    if ( f_poMeteringInfo != NULL )
    {
        COPY_FROMBUFFER( 
                f_poMeteringInfo->MeteringURL.rgb, 
                f_pbCertData, 
                dwOffset,
                dwUrlLength + PAD_AMOUNT( dwUrlLength ), 
                f_cbCertData );
        
        f_poMeteringInfo->MeteringURL.cb = dwUrlLength;
    }
    else
    {
        dwOffset += dwUrlLength + PAD_AMOUNT( dwUrlLength );
    }

    *f_pbOffset = dwOffset;
    
ErrorExit:

    return dr;
}


/*****************************************************************************
** Function:    _parseFeatureInfo
**
** Synopsis:    Parses feature info object. Feature info structure is always filled-in
**              because it is needed for adjacent cert verification.
**
** Arguments:   [f_pbCertData]    : data buffer that is being parsed
**              [f_cbCertData]    : size of the data buffer (in bytes)
**              [f_dwCertType]    : type of a certificate being parsed
**              [f_pbOffset]      : position to start parsing from
**              [f_poFeatureInfo] : pointer to a feature info structure, cannot be NULL
**       [f_pVerificationContext] : pointer to verification context structure
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_ARITHMETIC_OVERFLOW - if offset is too big
**              DRM_E_BUFFERTOOSMALL - buffer is shorter than expected
**              DRM_E_BCERT_INVALID_MAX_FEATURES
**
** Notes:       f_pbOffset points to feature info data not including object header.
******************************************************************************/
static DRM_NO_INLINE DRM_RESULT _parseFeatureInfo(
    __in_bcount(f_cbCertData) const DRM_BYTE         *f_pbCertData,
    __in                      const DRM_DWORD        f_cbCertData,
    __inout_ecount(1)         DRM_DWORD              *f_pbOffset,
    __in const                DRM_DWORD              f_dwCertType,
    __inout_ecount(1)         DRM_BCERT_FEATURE_INFO *f_poFeatureInfo,
    __inout_ecount(1)         DRM_BCERT_VERIFICATIONCONTEXT *f_pVerificationContext )
{
    DRM_RESULT dr       = DRM_SUCCESS;
    DRM_DWORD  dwOffset = 0;
    DRM_DWORD  iCount   = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_parseFeatureInfo );

    ChkArg( f_pbCertData != NULL );
    ChkArg( f_cbCertData > 0 );
    ChkArg( f_pbOffset != NULL );
    ChkArg( f_poFeatureInfo != NULL );
    ChkOverflow( f_cbCertData, *f_pbOffset );

    dwOffset = *f_pbOffset;

    NETWORKBYTES_FROMBUFFER_TO_DWORD(
            f_poFeatureInfo->dwNumFeatureEntries, 
            f_pbCertData, 
            dwOffset,
            f_cbCertData );

    if ( f_poFeatureInfo->dwNumFeatureEntries == 0 )
    {
        *f_pbOffset = dwOffset;
        goto ErrorExit; /* no features in the list */
    }

    /*
    ** Verify that list of features is not too long
    */
    ChkBOOL( f_poFeatureInfo->dwNumFeatureEntries <= DRM_BCERT_MAX_FEATURES, 
             DRM_E_BCERT_INVALID_MAX_FEATURES );

    /*
    ** read each feature and verify
    */
    for ( iCount = 0; iCount < f_poFeatureInfo->dwNumFeatureEntries; iCount++ )
    {
        NETWORKBYTES_FROMBUFFER_TO_DWORD( 
                f_poFeatureInfo->rgdwFeatureSet[ iCount ],
                f_pbCertData, 
                dwOffset,
                f_cbCertData );

        dr = _verifyFeature( f_poFeatureInfo->rgdwFeatureSet[ iCount ], f_dwCertType );        
        ChkVerificationErr( f_pVerificationContext, DRM_SUCCEEDED(dr), dr );
        dr = DRM_SUCCESS;
    }

    DRMASSERT( dwOffset == *f_pbOffset 
                         + SIZEOF( DRM_DWORD )
                         + f_poFeatureInfo->dwNumFeatureEntries * SIZEOF( DRM_DWORD ) );

    *f_pbOffset = dwOffset;                                           
    
ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/*****************************************************************************
** Function:    _parseManufacturerString
**
** Synopsis:    Reads and verifies one manufacturer string structure.
**
** Arguments:   [f_pbCertData]           : data buffer that is being parsed
**              [f_cbCertData]           : size of the data buffer (in bytes)
**              [f_pbOffset]             : position to start parsing from
**              [f_poManufacturerString] : pointer to a manufacturer string structure, 
**                                         cannot be NULL
**              [f_pVerificationContext] : pointer to verification context structure
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_ARITHMETIC_OVERFLOW - if offset is too big
******************************************************************************/
static DRM_NO_INLINE DRM_RESULT _parseManufacturerString(
    __in_bcount(f_cbCertData) const DRM_BYTE                *f_pbCertData,
    __in                      const DRM_DWORD               f_cbCertData,
    __inout_ecount(1)         DRM_DWORD                     *f_pbOffset,
    __inout_ecount(1)         DRM_BCERT_MANUFACTURER_STRING *f_poManufacturerString,
    __inout_ecount(1)         DRM_BCERT_VERIFICATIONCONTEXT *f_pVerificationContext )    
{
    DRM_RESULT dr       = DRM_SUCCESS;
    DRM_DWORD  dwOffset = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_parseManufacturerString );

    ChkArg( f_pbCertData != NULL );
    ChkArg( f_cbCertData > 0 );
    ChkArg( f_pbOffset != NULL );
    ChkArg( f_poManufacturerString != NULL );
    ChkOverflow( f_cbCertData, *f_pbOffset );

    dwOffset = *f_pbOffset;    

    /*
    ** String length
    */
    NETWORKBYTES_FROMBUFFER_TO_DWORD( 
            f_poManufacturerString->cb, 
            f_pbCertData, 
            dwOffset,
            f_cbCertData );

    if ( f_poManufacturerString->cb > 0 )
    {
        ChkBOOL( f_poManufacturerString->cb <= DRM_BCERT_MAX_MANUFACTURER_STRING_LENGTH, DRM_E_BCERT_MANUFACTURER_STRING_TOO_LONG );
        
        /*
        ** Read string
        */    
        ChkOverflow( f_poManufacturerString->cb + PAD_AMOUNT( f_poManufacturerString->cb ), f_poManufacturerString->cb );
        COPY_FROMBUFFER( 
                f_poManufacturerString->rgb, 
                f_pbCertData, 
                dwOffset,
                f_poManufacturerString->cb
                    + PAD_AMOUNT( f_poManufacturerString->cb ),
                f_cbCertData );
        
        dr = _isUTF8NullTerminatedData( f_poManufacturerString->rgb, 
                                          f_poManufacturerString->cb );
        ChkVerificationErr( f_pVerificationContext, DRM_SUCCEEDED(dr), dr );
        dr = DRM_SUCCESS;
    }

    DRMASSERT( dwOffset == *f_pbOffset
                         + SIZEOF( DRM_DWORD )                         /* string length */
                         + f_poManufacturerString->cb                  /* string data */
                         + PAD_AMOUNT( f_poManufacturerString->cb ) ); /* padding */

    *f_pbOffset = dwOffset;                                           
    
ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

/************************************************************************************
** Function:    _parseManufacturerInfo
**
** Synopsis:    Parses manufacturer info object.
**
** Arguments:   [f_pbCertData]         : data buffer that is being parsed
**              [f_cbCertData]         : size of the data buffer (in bytes)
**              [f_pbOffset]           : position to start parsing from
**              [f_poManufacturerInfo] : pointer to a manufacturer info structure, 
**                                       can be NULL in which case we just validate data
**                                       and do not copy it.
**            [f_pVerificationContext] : pointer to verification context structure
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_ARITHMETIC_OVERFLOW - if offset is too big
**              DRM_E_BUFFERTOOSMALL - buffer is shorter than expected
**              
** Notes:       f_pbOffset points to manufacturer info data not including object header.
**************************************************************************************/
static DRM_NO_INLINE DRM_RESULT _parseManufacturerInfo( 
    __in_bcount(f_cbCertData) const DRM_BYTE                *f_pbCertData,
    __in                      const DRM_DWORD               f_cbCertData,
    __inout_ecount(1)         DRM_DWORD                     *f_pbOffset,
    __inout_ecount_opt(1)     DRM_BCERT_MANUFACTURER_INFO   *f_poManufacturerInfo,
    __inout_ecount(1)         DRM_BCERT_VERIFICATIONCONTEXT *f_pVerificationContext )    
{
    DRM_RESULT dr       = DRM_SUCCESS;
    DRM_DWORD  dwOffset = 0;
    DRM_BCERT_MANUFACTURER_STRING manuStr = { 0 };
        
    ChkArg( f_pbCertData != NULL );
    ChkArg( f_cbCertData > 0 );
    ChkArg( f_pbOffset != NULL );
    ChkOverflow( f_cbCertData, *f_pbOffset );

    dwOffset = *f_pbOffset;    

    /*
    ** Flags - read and ignore
    */
    ChkOverflow( dwOffset + SIZEOF( DRM_DWORD ), dwOffset );
    dwOffset += SIZEOF( DRM_DWORD );    

    /*
    ** Manufacturer name
    */
    ChkDR( _parseManufacturerString( 
        f_pbCertData,
        f_cbCertData,
        &dwOffset,
        f_poManufacturerInfo != NULL ? &f_poManufacturerInfo->ManufacturerStrings.ManufacturerName : &manuStr,
        f_pVerificationContext ) );
    /*
    ** Model name
    */
    ChkDR( _parseManufacturerString( 
        f_pbCertData,
        f_cbCertData,
        &dwOffset,
        f_poManufacturerInfo != NULL ? &f_poManufacturerInfo->ManufacturerStrings.ModelName : &manuStr,
        f_pVerificationContext ) );
    /*
    ** Model number
    */
    ChkDR( _parseManufacturerString( 
        f_pbCertData,
        f_cbCertData,
        &dwOffset,
        f_poManufacturerInfo != NULL ? &f_poManufacturerInfo->ManufacturerStrings.ModelNumber : &manuStr,
        f_pVerificationContext ) );
    
    *f_pbOffset = dwOffset;

ErrorExit:
    return dr;
}

/**********************************************************************************************************
** Function:    _parseExtDataSignKeyInfo
**
** Synopsis:    Parse extended data signature key object. 
**
** Arguments:   [f_pbCertData]           : data buffer that is being parsed
**              [f_cbCertData]           : size of the data buffer (in bytes)
**              [f_pbOffset]             : position to start parsing from
**              [f_poExtDataSignKeyInfo] : pointer to a signature info structure, cannot be NULL
**              [f_pVerificationContext] : pointer to verification context structure
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_ARITHMETIC_OVERFLOW - if offset is too big
**              DRM_E_BUFFERTOOSMALL - buffer is shorter than expected
**
** Notes:       f_pbOffset points to extended data signature key info data not including object header.
**********************************************************************************************************/
static DRM_NO_INLINE DRM_RESULT _parseExtDataSignKeyInfo(
    __in_bcount(f_cbCertData) const DRM_BYTE                 *f_pbCertData,
    __in                      const DRM_DWORD                f_cbCertData,
    __inout_ecount(1)         DRM_DWORD                      *f_pbOffset,
    __inout_ecount(1)         DRM_BCERT_EXTDATA_SIGNKEY_INFO *f_poExtDataSignKeyInfo,
    __inout_ecount(1)         DRM_BCERT_VERIFICATIONCONTEXT  *f_pVerificationContext )    
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  dwOffset = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_parseExtDataSignKeyInfo );

    ChkArg( f_pbCertData != NULL );
    ChkArg( f_cbCertData > 0 );
    ChkArg( f_poExtDataSignKeyInfo != NULL );
    ChkOverflow( f_cbCertData, *f_pbOffset );

    dwOffset = *f_pbOffset;    

    /*
    ** Read key type
    */
    NETWORKBYTES_FROMBUFFER_TO_WORD( 
            f_poExtDataSignKeyInfo->wType, 
            f_pbCertData, 
            dwOffset,
            f_cbCertData );

    ChkVerificationErr( f_pVerificationContext,
                        f_poExtDataSignKeyInfo->wType == DRM_BCERT_KEYTYPE_ECC256, 
                        DRM_E_BCERT_INVALID_KEY_TYPE );
   
    /*
    ** Read key length
    */
    NETWORKBYTES_FROMBUFFER_TO_WORD( 
            f_poExtDataSignKeyInfo->wLength, 
            f_pbCertData, 
            dwOffset,
            f_cbCertData );
   
    ChkVerificationErr( f_pVerificationContext,
                        f_poExtDataSignKeyInfo->wLength == SIZEOF( PUBKEY_P256 ) * CHAR_BIT, 
                        DRM_E_BCERT_INVALID_KEY_LENGTH );

    /*
    ** Read flags
    */
    NETWORKBYTES_FROMBUFFER_TO_DWORD( 
            f_poExtDataSignKeyInfo->dwFlags, 
            f_pbCertData, 
            dwOffset,
            f_cbCertData );

    /*
    ** Read key value - don't reverse bytes, just copy
    */
    COPY_FROMBUFFER(
            f_poExtDataSignKeyInfo->Value.rgb, 
            f_pbCertData, 
            dwOffset,
            SIZEOF( PUBKEY_P256 ),
            f_cbCertData );

    *f_pbOffset = dwOffset;

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

/**********************************************************************************************************
** Function:    _parseSignatureInfo
**
** Synopsis:    Parse signature info object. This function does not validate signature data,
**              it only checks data for correct size and values.
**
** Arguments:   [f_pbCertData]       : data buffer that is being parsed
**              [f_cbCertData]       : size of the data buffer (in bytes)
**              [f_pbOffset]           : position to start parsing from
**              [f_poSignatureInfo]  : pointer to a signature info structure, cannot be NULL
**          [f_pVerificationContext] : pointer to verification context structure
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_ARITHMETIC_OVERFLOW - if offset is too big
**              DRM_E_BUFFERTOOSMALL - buffer is shorter than expected
**              DRM_E_BCERT_INVALID_SIGNATURE_TYPE
**              DRM_E_BCERT_INVALID_ISSUERKEY_LENGTH
**
** Notes:       f_pbOffset points to signature info data not including object header.
**********************************************************************************************************/
static DRM_NO_INLINE DRM_RESULT _parseSignatureInfo(
    __in_bcount(f_cbCertData) const DRM_BYTE                 *f_pbCertData,
    __in                      const DRM_DWORD                f_cbCertData,
    __inout_ecount(1)         DRM_DWORD                      *f_pbOffset,
    __inout_ecount(1)         DRM_BCERT_SIGNATURE_INFO       *f_poSignatureInfo,
    __inout_ecount(1)         DRM_BCERT_VERIFICATIONCONTEXT  *f_pVerificationContext )    
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  dwOffset = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_parseSignatureInfo );

    ChkArg( f_pbCertData != NULL );
    ChkArg( f_cbCertData > 0 );
    ChkArg( f_poSignatureInfo != NULL );
    ChkOverflow( f_cbCertData, *f_pbOffset );

    dwOffset = *f_pbOffset;    

    /*
    ** Read and verify signature type
    */
    NETWORKBYTES_FROMBUFFER_TO_WORD( 
            f_poSignatureInfo->wSignatureType, 
            f_pbCertData, 
            dwOffset,
            f_cbCertData );
    
    ChkVerificationErr( f_pVerificationContext,
                        f_poSignatureInfo->wSignatureType == DRM_BCERT_SIGNATURE_TYPE_P256, 
                        DRM_E_BCERT_INVALID_SIGNATURE_TYPE );

    /*
    ** Read and verify signature data length
    */
    NETWORKBYTES_FROMBUFFER_TO_WORD( 
            f_poSignatureInfo->SignatureData.cb, 
            f_pbCertData, 
            dwOffset,
            f_cbCertData );
    
    ChkVerificationErr( f_pVerificationContext,
                        f_poSignatureInfo->SignatureData.cb == SIZEOF( SIGNATURE_P256 ),
                        DRM_E_BCERT_INVALID_SIGNATURE_TYPE );

    /*
    ** Read signature
    */
    COPY_FROMBUFFER(
            f_poSignatureInfo->SignatureData.rgb, 
            f_pbCertData,
            dwOffset,
            f_poSignatureInfo->SignatureData.cb
                + PAD_AMOUNT( f_poSignatureInfo->SignatureData.cb ),
            f_cbCertData );
    
    /*
    ** Read issuer key length which should be SIZEOF( PUBKEY_P256 ) * CHAR_BIT == 0x200
    */
    NETWORKBYTES_FROMBUFFER_TO_DWORD( 
            f_poSignatureInfo->dwIssuerKeyLength, 
            f_pbCertData, 
            dwOffset,
            f_cbCertData );

    ChkVerificationErr( f_pVerificationContext,
                        f_poSignatureInfo->dwIssuerKeyLength == SIZEOF( PUBKEY_P256 ) * CHAR_BIT,
                        DRM_E_BCERT_INVALID_ISSUERKEY_LENGTH );

    /*
    ** Read Issuer key - don't reverse bytes, just copy
    */
    COPY_FROMBUFFER(
            f_poSignatureInfo->IssuerKey.rgb,
            f_pbCertData, 
            dwOffset,
            SIZEOF( PUBKEY_P256 ), 
            f_cbCertData );

    *f_pbOffset = dwOffset;
    
ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/**********************************************************************************************************
** Function:    _parseExtDataContainer
**
** Synopsis:    Parse extended data info object. This function does not validate signature data,
**              it only checks data for correct size and values.
**
** Arguments:   [f_pbCertData]         : data buffer that is being parsed
**              [f_cbCertData]         : size of the data buffer (in bytes)
**              [f_pbOffset]           : position to start parsing from
**              [f_poExtDataContainer] : pointer to a extended data info structure, cannot be NULL
**            [f_pVerificationContext] : pointer to verification context structure
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_ARITHMETIC_OVERFLOW - if offset is too big
**              DRM_E_BUFFERTOOSMALL - buffer is shorter than expected
**
** Notes:       f_pbOffset points to ext data info object not including object header.
**********************************************************************************************************/
static DRM_NO_INLINE DRM_RESULT _parseExtDataContainer(
    __in_bcount(f_cbCertData) const DRM_BYTE                 *f_pbCertData,
    __in                      const DRM_DWORD                f_cbCertData,
    __inout_ecount(1)         DRM_DWORD                      *f_pbOffset,
    __inout_ecount(1)         DRM_BCERT_EXTDATA_CONTAINER    *f_poExtDataContainer,
    __inout_ecount(1)         DRM_BCERT_VERIFICATIONCONTEXT  *f_pVerificationContext )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  dwOffset = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_parseExtDataContainer );

    ChkArg( f_pbCertData != NULL );
    ChkArg( f_cbCertData > 0 );
    ChkArg( f_poExtDataContainer != NULL );
    ChkOverflow( f_cbCertData, *f_pbOffset );

    dwOffset = *f_pbOffset;

    /*
    ** Read ext data object header
    */
    ChkDR( _getObjectHeader( f_pbCertData, f_cbCertData, &dwOffset, &f_poExtDataContainer->Records[0].Header ) );
    ChkVerificationErr( f_pVerificationContext,
                        f_poExtDataContainer->Records[0].Header.wType == DRM_BCERT_OBJTYPE_EXTDATA_HWID
                            && f_poExtDataContainer->Records[0].Header.wFlags == DRM_BCERT_OBJFLAG_EMPTY,
                        DRM_E_BCERT_UNEXPECTED_OBJECT_HEADER );

    /*
    ** Number of records is always 1
    */
    f_poExtDataContainer->cbRecordsCount = 1;
    
    /* 
    ** Read record length
    */
    NETWORKBYTES_FROMBUFFER_TO_DWORD( 
            f_poExtDataContainer->Records[0].dwDataLength,
            f_pbCertData, 
            dwOffset,
            f_cbCertData );
    
    /*
    ** Read record data: do not copy data record into any buffer, 
    ** only need to set a pointer to where it starts.
    */
    ChkOverflow( dwOffset + f_poExtDataContainer->Records[0].dwDataLength, dwOffset );
    ChkBOOL( dwOffset + f_poExtDataContainer->Records[0].dwDataLength <= f_cbCertData, DRM_E_BUFFERTOOSMALL );
    f_poExtDataContainer->Records[0].pbData = (DRM_BYTE*) (f_pbCertData + dwOffset);

    /*
    ** Skip down to the signature.
    */
    ChkOverflow( dwOffset + f_poExtDataContainer->Records[0].dwDataLength, dwOffset );
    ChkOverflow( dwOffset + f_poExtDataContainer->Records[0].dwDataLength + PAD_AMOUNT( f_poExtDataContainer->Records[0].dwDataLength ), dwOffset + f_poExtDataContainer->Records[0].dwDataLength );
    dwOffset += f_poExtDataContainer->Records[0].dwDataLength + PAD_AMOUNT( f_poExtDataContainer->Records[0].dwDataLength );
    
    /*
    ** Read ext data signature object header
    */
    ChkDR( _getObjectHeader( f_pbCertData, f_cbCertData, &dwOffset, &f_poExtDataContainer->Signature.Header ) );
    ChkVerificationErr( f_pVerificationContext,
                        f_poExtDataContainer->Signature.Header.wType == DRM_BCERT_OBJTYPE_EXTDATASIGNATURE
                           && f_poExtDataContainer->Signature.Header.wFlags == DRM_BCERT_OBJFLAG_MUST_UNDERSTAND,
                        DRM_E_BCERT_UNEXPECTED_OBJECT_HEADER );

    /*
    ** Read and verify signature type
    */
    NETWORKBYTES_FROMBUFFER_TO_WORD( 
            f_poExtDataContainer->Signature.wSignatureType, 
            f_pbCertData, 
            dwOffset,
            f_cbCertData );
    
    ChkVerificationErr( f_pVerificationContext,
                        f_poExtDataContainer->Signature.wSignatureType == DRM_BCERT_SIGNATURE_TYPE_P256, 
                        DRM_E_BCERT_INVALID_SIGNATURE_TYPE );

    /*
    ** Read and verify signature data length
    */
    NETWORKBYTES_FROMBUFFER_TO_WORD( 
            f_poExtDataContainer->Signature.SignatureData.cb, 
            f_pbCertData, 
            dwOffset,
            f_cbCertData );
    
    ChkVerificationErr( f_pVerificationContext,
                        f_poExtDataContainer->Signature.SignatureData.cb == SIZEOF( SIGNATURE_P256 ),
                        DRM_E_BCERT_INVALID_SIGNATURE_TYPE );

    /*
    ** Read signature
    */
    ChkOverflow( f_poExtDataContainer->Signature.SignatureData.cb + PAD_AMOUNT( f_poExtDataContainer->Signature.SignatureData.cb ), f_poExtDataContainer->Signature.SignatureData.cb );
    COPY_FROMBUFFER(
            f_poExtDataContainer->Signature.SignatureData.rgb, 
            f_pbCertData,
            dwOffset,
            f_poExtDataContainer->Signature.SignatureData.cb
                + PAD_AMOUNT( f_poExtDataContainer->Signature.SignatureData.cb ),
            f_cbCertData );

    *f_pbOffset = dwOffset;
    
ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

/**********************************************************************************************************
** Function:    DRM_BCert_VerifySignature
**
** Synopsis:    Check that the Signature Data matches the ECDSA algorithm over the data
**              up to and not including signature element using IssuerKey in Signature Data.
**
** Arguments:   [f_pbCertificateBegin] : pointer to a place in a data buffer where signed data begins.
**              [f_dwSignedDataLength] : length in bytes of a signed data.
**              [f_poSignatureInfo]    : pointer to a signature info structure, cannot be NULL.
**              [f_pCryptoCtx]         : Pointer to DRM_CRYPTO_CONTEXT used for temporary data in crypto code.
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_ARITHMETIC_OVERFLOW - if offset is too big
**              DRM_E_BUFFERTOOSMALL - buffer is shorter than expected
**              DRM_E_BCERT_INVALID_SIGNATURE_TYPE
**              DRM_E_BCERT_INVALID_ISSUERKEY_LENGTH
**
**********************************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_BCert_VerifySignature(
    __in_ecount(__CB_DECL( f_dwSignedDataLength)) const DRM_BYTE *f_pbCertificateBegin,
    __in              DRM_DWORD                f_dwSignedDataLength,
    __inout_ecount(1) DRM_BCERT_SIGNATURE_INFO *f_poSignatureInfo,
    __inout_ecount(1) DRM_CRYPTO_CONTEXT       *f_pCryptoCtx,
    __in_opt          DRM_BB_CONTEXT           *f_pcontextBBX,
    __in_opt          DRM_SECSTORE_CONTEXT     *f_pcontextSST,
    __in_opt          DRM_DST                  *f_pDatastore )
{
    DRM_RESULT     dr         = DRM_SUCCESS;
    SIGNATURE_P256 oSignature = { 0 };
    PUBKEY_P256    oPubKey    = { 0 };

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_verifySignatureInfo );

    ChkArg( f_pbCertificateBegin != NULL );
    ChkArg( f_dwSignedDataLength > 0 );
    ChkArg( f_poSignatureInfo != NULL );
    ChkArg( f_pCryptoCtx != NULL );

#if DRM_SUPPORT_CERTIFICATE_CACHING
    if( f_pcontextBBX != NULL && f_pcontextSST != NULL && f_pDatastore != NULL )
    {
        if( DRM_UTL_VerifyCachedCertificate(    f_pcontextBBX, 
                                                f_pcontextSST,
                                                f_pDatastore, 
                                                f_pbCertificateBegin, 
                                                f_dwSignedDataLength ) )
        {
            /* Signature was found in the cache */
            dr = DRM_SUCCESS;
            goto ErrorExit;
        }
        /* Signature not found, we'll have to validate asymmetrically */
    }
#endif

    /*
    ** Verify signature
    */    
    DRM_BYT_CopyBytes( oSignature.m_rgbSignature, 
                       0, 
                       f_poSignatureInfo->SignatureData.rgb, 
                       0, 
                       SIZEOF( SIGNATURE_P256 ) );

    DRM_BYT_CopyBytes( oPubKey.m_rgbPubkey, 
                       0, 
                       f_poSignatureInfo->IssuerKey.rgb, 
                       0, 
                       SIZEOF( PUBKEY_P256 ) );
    
    ChkDR( DRM_ECDSA_Verify_P256(
            f_pbCertificateBegin, 
            f_dwSignedDataLength,
            &oPubKey,
            &oSignature,
            (struct bigctx_t *)f_pCryptoCtx->rgbCryptoContext ) );

#if DRM_SUPPORT_CERTIFICATE_CACHING
    if( f_pcontextBBX != NULL && f_pcontextSST != NULL && f_pDatastore != NULL )
    {
        /* Signature checked out, add it to the cache */
        ChkDR( DRM_UTL_AddCachedCertificate(f_pcontextBBX, 
                                            f_pcontextSST,
                                            f_pDatastore, 
                                            f_pbCertificateBegin, 
                                            f_dwSignedDataLength ) );
    }
#endif

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/**********************************************************************************************************
** Function:    _verifyExtDataSignature
**
** Synopsis:    Verifies signature over extended data record.
**
** Arguments:   [f_pbCertData]           : data buffer that is being parsed
**              [f_cbCertData]           : size of the data buffer (in bytes)
**              [f_pbSignedDataLength]   : Offset to where extended data record begins.
**              [f_poExtDataSignKeyInfo] : pointer to extended data signing key structure, cannot be NULL.
**              [f_poExtDataContainer]   : pointer to extended data container object, cannot be NULL.
**              [f_pVerificationContext] : pointer to DRM_BCERT_VERIFICATIONCONTEXT structure.
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_ARITHMETIC_OVERFLOW - if offset is too big
**              DRM_E_BUFFERTOOSMALL - buffer is shorter than expected
**              DRM_E_BCERT_INVALID_SIGNATURE_TYPE
**              DRM_E_BCERT_INVALID_ISSUERKEY_LENGTH
**
**********************************************************************************************************/
static DRM_NO_INLINE DRM_RESULT _verifyExtDataSignature(
    __in_bcount(f_cbCertData) const DRM_BYTE         *f_pbCertData,
    __in                      const DRM_DWORD        f_cbCertData,
    __in DRM_DWORD                                   f_pbSignedDataOffset,
    __inout_ecount(1) DRM_BCERT_EXTDATA_SIGNKEY_INFO *f_poExtDataSignKeyInfo,
    __inout_ecount(1) DRM_BCERT_EXTDATA_CONTAINER    *f_poExtDataContainer,
    __inout_ecount(1) DRM_BCERT_VERIFICATIONCONTEXT  *f_pVerificationContext )
{
    DRM_RESULT     dr                 = DRM_SUCCESS;
    SIGNATURE_P256 oSignature         = { 0 };
    PUBKEY_P256    oPubKey            = { 0 };
    DRM_DWORD      dwSignedDataLength = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_verifyExtDataSignature );

    ChkArg( f_pbCertData != NULL );
    ChkArg( f_cbCertData > 0 );
    ChkOverflow( f_cbCertData, f_pbSignedDataOffset );
    ChkArg( f_poExtDataSignKeyInfo != NULL );
    ChkArg( f_poExtDataContainer != NULL );
    ChkArg( f_pVerificationContext != NULL );

    DRMASSERT( f_pVerificationContext->fDontFailOnMissingExtData == FALSE );

    DRM_BYT_CopyBytes( oSignature.m_rgbSignature, 
                       0, 
                       f_poExtDataContainer->Signature.SignatureData.rgb,
                       0, 
                       SIZEOF( SIGNATURE_P256 ) );

    DRM_BYT_CopyBytes( oPubKey.m_rgbPubkey, 
                       0,
                       f_poExtDataSignKeyInfo->Value.rgb,
                       0, 
                       SIZEOF( PUBKEY_P256 ) );

    dwSignedDataLength = SIZEOF( DRM_BCERT_OBJECT_HEADER ) + SIZEOF( DRM_DWORD ); /* ext data record header & record length */

    ChkOverflow(dwSignedDataLength + f_poExtDataContainer->Records[0].dwDataLength, dwSignedDataLength );
    dwSignedDataLength += f_poExtDataContainer->Records[0].dwDataLength; /* record data */

    ChkOverflow( dwSignedDataLength + PAD_AMOUNT( f_poExtDataContainer->Records[0].dwDataLength ), dwSignedDataLength );
    dwSignedDataLength += PAD_AMOUNT( f_poExtDataContainer->Records[0].dwDataLength ); /* padding */

    ChkOverflow( f_cbCertData, f_pbSignedDataOffset + dwSignedDataLength );
    
    /*
    ** verify signature over extended data
    */
    ChkArg( f_pVerificationContext->pCryptoCtx != NULL );

    ChkDR( DRM_ECDSA_Verify_P256( f_pbCertData + f_pbSignedDataOffset, 
                                  dwSignedDataLength,
                                  &oPubKey,
                                  &oSignature,
                                  (struct bigctx_t *)f_pVerificationContext->pCryptoCtx->rgbCryptoContext ) );

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/*****************************************************************************
** Function:    _parseKeyInfo
**
** Synopsis:    Parses key info object and fills-in key info structure.
**
** Arguments:   [f_pbCertData] : data buffer that is being parsed
**              [f_cbCertData] : size of the data buffer (in bytes)
**              [f_pbOffset]   : position to start parsing from
**              [f_dwCertType] : type of a certificate being parsed
**              [f_poKeyInfo]  : pointer to a signature info structure, cannot be NULL
**    [f_pVerificationContext] : pointer to verification context structure
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_ARITHMETIC_OVERFLOW - if offset is too big
**              DRM_E_BUFFERTOOSMALL - buffer is shorter than expected
**              DRM_E_BCERT_INVALID_KEY_TYPE
**              DRM_E_BCERT_INVALID_KEY_LENGTH
**              DRM_E_BCERT_INVALID_MAX_KEY_USAGES
**
** Notes:       f_pbOffset points to key info data not including object header.
**
******************************************************************************/

static DRM_NO_INLINE DRM_RESULT  _parseKeyInfo( 
    __in_bcount(f_cbCertData) const DRM_BYTE                *f_pbCertData,
    __in                      const DRM_DWORD               f_cbCertData,
    __inout_ecount(1)         DRM_DWORD                     *f_pbOffset,
    __in const                DRM_DWORD                     f_dwCertType,
    __inout_ecount(1)         DRM_BCERT_KEY_INFO            *f_poKeyInfo,
    __inout_ecount(1)         DRM_BCERT_VERIFICATIONCONTEXT *f_pVerificationContext )
{
    DRM_RESULT dr                      = DRM_SUCCESS;
    DRM_DWORD  iCount                  = 0;
    DRM_DWORD  iKey                    = 0;
    DRM_DWORD  dwOffset                = 0;
    DRM_BOOL   fCheckRequiredKeyUsages = FALSE;
    DRM_DWORD  dwKeyUsageMask          = 0;
    DRM_DWORD  dwRequiredKeyUsageMask  = 0;
    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_parseKeyInfo );

    ChkArg( f_pbCertData != NULL );
    ChkArg( f_cbCertData > 0 );
    ChkArg( f_pbOffset != NULL );
    ChkArg( f_poKeyInfo != NULL );
    ChkOverflow( f_cbCertData, *f_pbOffset );

    dwOffset = *f_pbOffset;

    /*
    ** Read number of certificate keys
    */
    NETWORKBYTES_FROMBUFFER_TO_DWORD( 
            f_poKeyInfo->dwNumKeys,
            f_pbCertData, 
            dwOffset,
            f_cbCertData );

    ChkBOOL( f_poKeyInfo->dwNumKeys > 0, DRM_E_BCERT_PUBLIC_KEY_NOT_SPECIFIED );

    ChkBOOL(f_poKeyInfo->dwNumKeys <= DRM_BCERT_MAX_KEY_USAGES, DRM_E_BCERT_TOO_MANY_PUBLIC_KEYS );

    for ( iKey = 0; iKey < f_poKeyInfo->dwNumKeys; iKey++ )
    {
        /*
        ** Read key type
        */
        NETWORKBYTES_FROMBUFFER_TO_WORD( 
                f_poKeyInfo->rgoKeys[iKey].wType, 
                f_pbCertData, 
                dwOffset,
                f_cbCertData );

        ChkVerificationErr( f_pVerificationContext, 
                            f_poKeyInfo->rgoKeys[iKey].wType == DRM_BCERT_KEYTYPE_ECC256, 
                            DRM_E_BCERT_INVALID_KEY_TYPE );

        /*
        ** Read key length
        */
        NETWORKBYTES_FROMBUFFER_TO_WORD( 
                f_poKeyInfo->rgoKeys[iKey].wLength, 
                f_pbCertData, 
                dwOffset,
                f_cbCertData );
       
        ChkVerificationErr( f_pVerificationContext, f_poKeyInfo->rgoKeys[iKey].wLength == SIZEOF( PUBKEY_P256 ) * CHAR_BIT, 
                 DRM_E_BCERT_INVALID_KEY_LENGTH );

        /*
        ** Read flags
        */
        NETWORKBYTES_FROMBUFFER_TO_DWORD( 
                f_poKeyInfo->rgoKeys[iKey].dwFlags, 
                f_pbCertData, 
                dwOffset,
                f_cbCertData );

        /*
        ** Read key value - don't reverse bytes, just copy
        */
        COPY_FROMBUFFER(
                f_poKeyInfo->rgoKeys[iKey].Value.rgb, 
                f_pbCertData, 
                dwOffset,
                SIZEOF( PUBKEY_P256 ),
                f_cbCertData );
        /*
        ** Read and validate number of key usage entries
        */
        NETWORKBYTES_FROMBUFFER_TO_DWORD( 
                f_poKeyInfo->rgoKeys[iKey].dwNumUsageEntries, 
                f_pbCertData, 
                dwOffset,
                f_cbCertData );
        
        ChkBOOL( f_poKeyInfo->rgoKeys[iKey].dwNumUsageEntries > 0
                     && f_poKeyInfo->rgoKeys[iKey].dwNumUsageEntries <= DRM_BCERT_MAX_KEY_USAGES, 
                 DRM_E_BCERT_INVALID_MAX_KEY_USAGES );
    
        /*
        ** Read and verify key usage entries
        */
        for ( iCount = 0; iCount < f_poKeyInfo->rgoKeys[iKey].dwNumUsageEntries; iCount++ )
        {
            NETWORKBYTES_FROMBUFFER_TO_DWORD( 
                    f_poKeyInfo->rgoKeys[iKey].dwUsageSet[iCount],
                    f_pbCertData, 
                    dwOffset,
                    f_cbCertData );
                                      
            dr = _verifyKeyUsage( f_poKeyInfo->rgoKeys[iKey].dwUsageSet[iCount], f_dwCertType );
            ChkVerificationErr( f_pVerificationContext, DRM_SUCCEEDED(dr), dr );
            dr = DRM_SUCCESS;

            if ( fCheckRequiredKeyUsages )
            {
                dwKeyUsageMask |= BCERT_KEYUSAGE_BIT( f_poKeyInfo->rgoKeys[iKey].dwUsageSet[ iCount ] ); /* collect cert key usages */
            }
        }
    }

    if ( fCheckRequiredKeyUsages )
    {
        for ( iCount = 0; iCount < f_pVerificationContext->cRequiredKeyUsages; iCount++ )
        {
            dwRequiredKeyUsageMask |= BCERT_KEYUSAGE_BIT( f_pVerificationContext->rgdwRequiredKeyUsages[iCount] );/* collect required key usages */
        }
        /*
        ** See that all required key usages are present
        */
        ChkBOOL( ( dwKeyUsageMask & dwRequiredKeyUsageMask ) == dwRequiredKeyUsageMask, DRM_E_BCERT_REQUIRED_KEYUSAGE_MISSING );
    }

    *f_pbOffset = dwOffset;

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/*****************************************************************************
** Function:    _parseCertificate
**
** Synopsis:    Internal function that parses one certificate in a chain. 
**              For performance reasons it does not verify certificate signature.
**              Function may be called in two modes:
**              - If called by DRM_BCert_GetCertificate() it will fill in the whole 
**                DRM_BCERT_CERTIFICATE structure. 
**              - If called by DRM_BCert_ParseCertificateChain() it will remember 
**                only minimal info from a cert needed for further verification.
**
** Arguments:   [f_pbCertData]    : data buffer that is being parsed
**              [f_cbCertData]    : size of the data buffer (in bytes)
**              [f_pbOffset]      : position to start parsing from
**              [f_poCertificate] : output parameter, pointer to a full certificate structure.
**                                  Cannot be NULL if f_poMinCertData == NULL.
**                                  Should be NULL if f_poMinCertData != NULL.
**              [f_poMinCertData] : output parameter, pointer to a structure to store minimal cert info.
**                                  Cannot be NULL if f_poCertificate == NULL.
**                                  Should be NULL if f_poCertificate != NULL.
**              [f_pVerificationContext] : Pointer to DRM_BCERT_VERIFICATIONCONTEXT structure. Cannot be NULL.
**
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_INVALIDARG
**              DRM_E_BCERT_UNEXPECTED_OBJECT_HEADER
**              DRM_E_BCERT_HWIDINFO_IS_MISSING
******************************************************************************/
static DRM_NO_INLINE DRM_RESULT _parseCertificate(
    __in_bcount(f_cbCertData) const DRM_BYTE                *f_pbCertData,
    __in                      const DRM_DWORD               f_cbCertData,
    __inout_ecount(1)         DRM_DWORD                     *f_pbOffset,
    __inout_ecount_opt(1)     DRM_BCERT_CERTIFICATE         *f_poCertificate,
    __inout_ecount_opt(1)     DRM_BCERT_MINIMALDATA         *f_poMinCertData,
    __inout_ecount(1)         DRM_BCERT_VERIFICATIONCONTEXT *f_pVerificationContext )
{
    DRM_RESULT               dr                = DRM_SUCCESS;
    DRM_DWORD                dwCertificateType = 0;    
    DRM_DWORD                dwCertFlags       = DRM_BCERT_FLAGS_EMPTY;
    DRM_BCERT_OBJECT_HEADER  oObjHeader        = { 0 };
    DRM_VOID                 *pHelperPtr       = NULL;
    DRM_BCERT_EXTDATA_SIGNKEY_INFO oExtDataSignKeyInfo = { 0 }; /* if present this data is needed to verify ext data signature */
    DRM_DWORD                dwCertBegin       = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_parseCertificate );

    ChkArg( f_pbCertData != NULL );
    ChkArg( f_cbCertData > 0 );
    ChkArg( f_pbOffset != NULL );
    ChkArg( f_poCertificate != NULL || f_poMinCertData != NULL );
    ChkArg( f_poCertificate == NULL || f_poMinCertData == NULL );
    ChkArg( f_pVerificationContext != NULL );
    
    ChkOverflow( f_cbCertData, *f_pbOffset );

    dwCertBegin = *f_pbOffset; /* Remember where the cert begins */

    /* 
    ** Certificate header.
    */
    pHelperPtr = f_poCertificate != NULL ? &f_poCertificate->Header : &f_poMinCertData->oCertHeader;
    ChkDR( _parseCertHeader( f_pbCertData,
                             f_cbCertData,
                             f_pbOffset,
                             ( DRM_BCERT_HEADER* ) pHelperPtr,
                             f_pVerificationContext ) );    
    /* 
    ** Basic info always follows certificate header.
    */
    pHelperPtr = ( f_poCertificate != NULL ) ? &f_poCertificate->BasicInfo : &f_poMinCertData->oBasicInfo;
    ChkDR( _getObjectHeader( f_pbCertData, f_cbCertData, f_pbOffset, &(( DRM_BCERT_BASIC_INFO* ) pHelperPtr)->Header ) );

    ChkVerificationErr( f_pVerificationContext,
                        (( DRM_BCERT_BASIC_INFO* ) pHelperPtr)->Header.wFlags   == DRM_BCERT_OBJFLAG_MUST_UNDERSTAND
                           && (( DRM_BCERT_BASIC_INFO* ) pHelperPtr)->Header.wType    == DRM_BCERT_OBJTYPE_BASIC
                           && (( DRM_BCERT_BASIC_INFO* ) pHelperPtr)->Header.cbLength == DRM_BCERT_BASIC_INFO_OBJECT_LEN,
                        DRM_E_BCERT_UNEXPECTED_OBJECT_HEADER );

    ChkDR( _parseCertBasicInfo( f_pbCertData,
                                f_cbCertData,
                                f_pbOffset,
                                ( DRM_BCERT_BASIC_INFO* )pHelperPtr,
                                f_pVerificationContext ) );

    /* 
    ** Remember certificate type and flags
    */
    dwCertificateType = (( DRM_BCERT_BASIC_INFO* ) pHelperPtr)->dwType; 
    dwCertFlags = (( DRM_BCERT_BASIC_INFO* ) pHelperPtr)->dwFlags;      
        
    /* 
    ** Get optional type-specific data object.
    ** Object type should match certificate type in basic info
    ** for device, PC, SilverLight, Metering, Server and Domain certificates.
    ** This code assumes that if a certificate type is Domain, PC, SilverLight, Metering, Server
    ** or Device then type-specific information must be present.
    ** Certificates of other types should not have a type-specific data object.
    */
    ChkDR( _getObjectHeader( f_pbCertData, f_cbCertData, f_pbOffset, &oObjHeader ) );

    switch ( dwCertificateType )
    {
    case DRM_BCERT_CERTTYPE_DOMAIN:
        ChkVerificationErr( f_pVerificationContext,
                            oObjHeader.wFlags == DRM_BCERT_OBJFLAG_MUST_UNDERSTAND
                                && oObjHeader.wType  == DRM_BCERT_OBJTYPE_DOMAIN, 
                            DRM_E_BCERT_UNEXPECTED_OBJECT_HEADER );

        if ( f_poCertificate != NULL )
        {
            DRM_BYT_CopyBytes( &( ( DRM_BCERT_DOMAIN_INFO* )&f_poCertificate->Type )->Header, 
                               0, 
                               &oObjHeader, 
                               0, 
                               SIZEOF( DRM_BCERT_OBJECT_HEADER ) );
        }
        ChkDR( _parseDomainInfo( f_pbCertData,
                                 f_cbCertData,
                                 f_pbOffset,
                                 f_poCertificate != NULL ? ( DRM_BCERT_DOMAIN_INFO* )&f_poCertificate->Type : NULL,
                                 f_pVerificationContext ) );
        
        ChkDR( _getObjectHeader( f_pbCertData, f_cbCertData, f_pbOffset, &oObjHeader ) );
        break;
        
    case DRM_BCERT_CERTTYPE_PC:
        ChkVerificationErr( f_pVerificationContext,
                            oObjHeader.wFlags == DRM_BCERT_OBJFLAG_MUST_UNDERSTAND
                                && oObjHeader.wType  == DRM_BCERT_OBJTYPE_PC, 
                            DRM_E_BCERT_UNEXPECTED_OBJECT_HEADER );

        if ( f_poCertificate != NULL )
        {
            DRM_BYT_CopyBytes( &( ( DRM_BCERT_PC_INFO* )&f_poCertificate->Type )->Header, 
                               0, 
                               &oObjHeader, 
                               0, 
                               SIZEOF( DRM_BCERT_OBJECT_HEADER ) );
        }
        ChkDR( _parsePCInfo( f_pbCertData,
                             f_cbCertData,
                             f_pbOffset,
                             f_poCertificate != NULL ? ( DRM_BCERT_PC_INFO* )&f_poCertificate->Type : NULL ) );

        ChkDR( _getObjectHeader( f_pbCertData, f_cbCertData, f_pbOffset, &oObjHeader ) );
        break;

    case DRM_BCERT_CERTTYPE_SILVERLIGHT:
        ChkVerificationErr( f_pVerificationContext,
                            oObjHeader.wFlags == DRM_BCERT_OBJFLAG_MUST_UNDERSTAND
                                && oObjHeader.wType  == DRM_BCERT_OBJTYPE_SILVERLIGHT, 
                            DRM_E_BCERT_UNEXPECTED_OBJECT_HEADER );

        if ( f_poCertificate != NULL )
        {
            DRM_BYT_CopyBytes( &( ( DRM_BCERT_SILVERLIGHT_INFO* )&f_poCertificate->Type )->Header, 
                               0, 
                               &oObjHeader, 
                               0, 
                               SIZEOF( DRM_BCERT_OBJECT_HEADER ) );
        }
        ChkDR( _parseSilverLightInfo( f_pbCertData,
                                      f_cbCertData,
                                      f_pbOffset,
                                      f_poCertificate != NULL ? ( DRM_BCERT_SILVERLIGHT_INFO* )&f_poCertificate->Type : NULL,
                                      f_pVerificationContext ) );

        ChkDR( _getObjectHeader( f_pbCertData, f_cbCertData, f_pbOffset, &oObjHeader ) );
        break;

    case DRM_BCERT_CERTTYPE_DEVICE:
        ChkVerificationErr( f_pVerificationContext,
                            oObjHeader.wFlags   == DRM_BCERT_OBJFLAG_MUST_UNDERSTAND
                               && oObjHeader.wType    == DRM_BCERT_OBJTYPE_DEVICE
                               && oObjHeader.cbLength == DRM_BCERT_DEVICE_INFO_OBJECT_LEN, 
                            DRM_E_BCERT_UNEXPECTED_OBJECT_HEADER );
                                
        if ( f_poCertificate != NULL )
        {
            DRM_BYT_CopyBytes( &( ( DRM_BCERT_DEVICE_INFO* )&f_poCertificate->Type )->Header, 
                               0, 
                               &oObjHeader, 
                               0, 
                               SIZEOF( DRM_BCERT_OBJECT_HEADER ) );
        }
        ChkDR( _parseDeviceInfo( f_pbCertData,
                                 f_cbCertData,
                                 f_pbOffset,
                                 f_poCertificate != NULL ? ( DRM_BCERT_DEVICE_INFO* )&f_poCertificate->Type : NULL,
                                 f_pVerificationContext ) );
        
        ChkDR( _getObjectHeader( f_pbCertData, f_cbCertData, f_pbOffset, &oObjHeader ) );
        break;

    case DRM_BCERT_CERTTYPE_METERING:
        ChkVerificationErr( f_pVerificationContext,
                            oObjHeader.wFlags == DRM_BCERT_OBJFLAG_MUST_UNDERSTAND
                               && oObjHeader.wType  == DRM_BCERT_OBJTYPE_METERING, 
                            DRM_E_BCERT_UNEXPECTED_OBJECT_HEADER );

        if ( f_poCertificate != NULL )
        {
            DRM_BYT_CopyBytes( &( ( DRM_BCERT_METERING_INFO* )&f_poCertificate->Type )->Header, 
                               0, 
                               &oObjHeader, 
                               0, 
                               SIZEOF( DRM_BCERT_OBJECT_HEADER ) );
        }
        ChkDR( _parseMeteringInfo( f_pbCertData,
                                   f_cbCertData,
                                   f_pbOffset,
                                   f_poCertificate != NULL ? ( DRM_BCERT_METERING_INFO* )&f_poCertificate->Type : NULL,
                                   f_pVerificationContext ) );
        
        ChkDR( _getObjectHeader( f_pbCertData, f_cbCertData, f_pbOffset, &oObjHeader ) );    
        break;
        
    case DRM_BCERT_CERTTYPE_SERVER:
        ChkVerificationErr( f_pVerificationContext,
                            oObjHeader.wFlags == DRM_BCERT_OBJFLAG_MUST_UNDERSTAND
                                && oObjHeader.wType  == DRM_BCERT_OBJTYPE_SERVER, 
                            DRM_E_BCERT_UNEXPECTED_OBJECT_HEADER );

        if ( f_poCertificate != NULL )
        {
            DRM_BYT_CopyBytes( &( ( DRM_BCERT_SERVER_INFO* )&f_poCertificate->Type )->Header, 
                               0, 
                               &oObjHeader, 
                               0, 
                               SIZEOF( DRM_BCERT_OBJECT_HEADER ) );
        }
        ChkDR( _parseServerInfo( f_pbCertData,
                             f_cbCertData,
                             f_pbOffset,
                             f_poCertificate != NULL ? ( DRM_BCERT_SERVER_INFO* )&f_poCertificate->Type : NULL,
                             f_pVerificationContext ) );

        ChkDR( _getObjectHeader( f_pbCertData, f_cbCertData, f_pbOffset, &oObjHeader ) );
        break;
        
    case DRM_BCERT_CERTTYPE_ISSUER:    
    case DRM_BCERT_CERTTYPE_CRL_SIGNER:
    case DRM_BCERT_CERTTYPE_SERVICE:
    case DRM_BCERT_CERTTYPE_APPLICATION:
    case DRM_BCERT_CERTTYPE_KEYFILESIGNER:
        break; /* there is no type-specific info object for these cert types */
        
    default:
        ChkVerificationErr( f_pVerificationContext, FALSE, DRM_E_BCERT_UNEXPECTED_OBJECT_HEADER ); /* wrong object type */
        break;
    }

    /* 
    ** Feature info must be present
    */
    ChkVerificationErr( f_pVerificationContext,
                        oObjHeader.wType    == DRM_BCERT_OBJTYPE_FEATURE
                             && oObjHeader.wFlags   == DRM_BCERT_OBJFLAG_MUST_UNDERSTAND
                             && oObjHeader.cbLength >= DRM_BCERT_FEATURES_OBJECT_MIN_LEN,
                        DRM_E_BCERT_UNEXPECTED_OBJECT_HEADER );

    if ( f_poCertificate != NULL )
    {
        DRM_BYT_CopyBytes( &f_poCertificate->FeatureInfo.Header, 
                           0, 
                           &oObjHeader, 
                           0, 
                           SIZEOF( DRM_BCERT_OBJECT_HEADER ) );
    }
    if ( f_poMinCertData != NULL )
    {
        DRM_BYT_CopyBytes( &f_poMinCertData->oFeatureInfo.Header,
                           0, 
                           &oObjHeader, 
                           0, 
                           SIZEOF( DRM_BCERT_OBJECT_HEADER ) );
    }    
    pHelperPtr = ( f_poCertificate != NULL ) ? &f_poCertificate->FeatureInfo : &f_poMinCertData->oFeatureInfo;
    ChkDR( _parseFeatureInfo( f_pbCertData,
                              f_cbCertData,
                              f_pbOffset,
                              dwCertificateType,
                              ( DRM_BCERT_FEATURE_INFO* ) pHelperPtr,
                              f_pVerificationContext ) );

    /* 
    ** Key info - object must be present
    */
    pHelperPtr = ( f_poCertificate != NULL ) ? &f_poCertificate->KeyInfo : &f_poMinCertData->oKeyInfo;

    ChkDR( _getObjectHeader( f_pbCertData, f_cbCertData, f_pbOffset, &(( DRM_BCERT_KEY_INFO* )pHelperPtr)->Header ) );

    ChkVerificationErr( f_pVerificationContext,
                        (( DRM_BCERT_KEY_INFO* )pHelperPtr)->Header.wFlags == DRM_BCERT_OBJFLAG_MUST_UNDERSTAND
                             && (( DRM_BCERT_KEY_INFO* )pHelperPtr)->Header.wType  == DRM_BCERT_OBJTYPE_KEY, 
                        DRM_E_BCERT_UNEXPECTED_OBJECT_HEADER );
    
    ChkDR( _parseKeyInfo( f_pbCertData,
                          f_cbCertData,
                          f_pbOffset,
                          dwCertificateType,
                          ( DRM_BCERT_KEY_INFO* ) pHelperPtr,
                          f_pVerificationContext ) );

    /* 
    ** Manufacturer info - optional 
    */
    ChkDR( _getObjectHeader( f_pbCertData, f_cbCertData, f_pbOffset, &oObjHeader ) );

    if ( oObjHeader.wType == DRM_BCERT_OBJTYPE_MANUFACTURER )
    {
        ChkVerificationErr( f_pVerificationContext,
                            oObjHeader.wFlags == DRM_BCERT_OBJFLAG_EMPTY, 
                            DRM_E_BCERT_UNEXPECTED_OBJECT_HEADER ); 
    
        if ( f_poCertificate != NULL )
        {
            DRM_BYT_CopyBytes( &f_poCertificate->ManufacturerInfo.Header, 
                               0, 
                               &oObjHeader, 
                               0, 
                               SIZEOF( DRM_BCERT_OBJECT_HEADER ) );
        }
        ChkDR( _parseManufacturerInfo( f_pbCertData,
                                       f_cbCertData,
                                       f_pbOffset,
                                       ( f_poCertificate != NULL ) ? &f_poCertificate->ManufacturerInfo : NULL,
                                       f_pVerificationContext ) );

        ChkDR( _getObjectHeader( f_pbCertData, f_cbCertData, f_pbOffset, &oObjHeader ) );
    }

    /*
    ** Check for presence of a public key object to verify extended data
    ** also indicated by a flag in a basic info.
    ** For now only PC certs can have it, all other types do not (already verified this condition)
    */
    if ( (dwCertFlags & DRM_BCERT_FLAGS_EXTDATA_PRESENT) == DRM_BCERT_FLAGS_EXTDATA_PRESENT )
    {
        ChkVerificationErr( f_pVerificationContext,
                            oObjHeader.wFlags == DRM_BCERT_OBJFLAG_EMPTY
                               && oObjHeader.wType  == DRM_BCERT_OBJTYPE_EXTDATASIGNKEY,
                            DRM_E_BCERT_EXTDATA_IS_NOT_PROVIDED );

        if ( f_poCertificate != NULL )
        {
            DRM_BYT_CopyBytes( &f_poCertificate->ExtDataSignatureInfo.Header, 
                               0, 
                               &oObjHeader, 
                               0, 
                               SIZEOF( DRM_BCERT_OBJECT_HEADER ) );
        }
        ChkDR( _parseExtDataSignKeyInfo( f_pbCertData,
                                         f_cbCertData,
                                         f_pbOffset,
                                         ( f_poCertificate != NULL ) ? &f_poCertificate->ExtDataSignatureInfo : &oExtDataSignKeyInfo,
                                         f_pVerificationContext ) );

        ChkDR( _getObjectHeader( f_pbCertData, f_cbCertData, f_pbOffset, &oObjHeader ) );
    }
    else
    {
        ChkVerificationErr( f_pVerificationContext,
                            oObjHeader.wFlags == DRM_BCERT_OBJFLAG_MUST_UNDERSTAND
                                && oObjHeader.wType  == DRM_BCERT_OBJTYPE_SIGNATURE,
                            DRM_E_BCERT_UNEXPECTED_OBJECT_HEADER );
    }
    
    /* 
    ** The last object (with exception of PC cert) is signature
    ** which must be present. Header is already read.
    */
    ChkVerificationErr( f_pVerificationContext,
                        oObjHeader.wFlags == DRM_BCERT_OBJFLAG_MUST_UNDERSTAND
                           && oObjHeader.wType  == DRM_BCERT_OBJTYPE_SIGNATURE,
                        DRM_E_BCERT_UNEXPECTED_OBJECT_HEADER );

    if ( f_poCertificate != NULL )
    {
        DRM_BYT_CopyBytes( &f_poCertificate->SignatureInfo.Header, 
                           0, 
                           &oObjHeader, 
                           0, 
                           SIZEOF( DRM_BCERT_OBJECT_HEADER ) );
    }
    if ( f_poMinCertData != NULL )
    {
        DRM_BYT_CopyBytes( &f_poMinCertData->oSignatureInfo.Header,
                           0, 
                           &oObjHeader, 
                           0, 
                           SIZEOF( DRM_BCERT_OBJECT_HEADER ) );
    }    
    ChkDR( _parseSignatureInfo( f_pbCertData,
                                f_cbCertData,
                                f_pbOffset,
                                ( f_poCertificate != NULL ) ? &f_poCertificate->SignatureInfo : &f_poMinCertData->oSignatureInfo,
                                f_pVerificationContext ) );

    /*
    ** PC certificate should have signed extended data information.
    ** It follows certificate signature object.
    ** Sometimes the caller of the cert parser allows or expects partially built certificates
    ** and sets f_pVerificationContext->fDontFailOnMissingExtData into TRUE. In this case
    ** if extended data object is present we verify the basics (obj header and structure), 
    ** but do not verify its signature. If extended data is missing do not fail.
    */
    if ( (dwCertFlags & DRM_BCERT_FLAGS_EXTDATA_PRESENT) == DRM_BCERT_FLAGS_EXTDATA_PRESENT )
    {
        DRM_BCERT_EXTDATA_CONTAINER oExtDataContainer    = { 0 };
        DRM_DWORD                   dwExtDataObjectStart = 0;

        if ( DRM_SUCCEEDED(_getObjectHeader( f_pbCertData, f_cbCertData, f_pbOffset, &oExtDataContainer.Header ))
                && oExtDataContainer.Header.wType == DRM_BCERT_OBJTYPE_EXTDATACONTAINER
                && oExtDataContainer.Header.wFlags == (DRM_BCERT_OBJFLAG_MUST_UNDERSTAND | DRM_BCERT_OBJFLAG_CONTAINER_OBJ) )
        {        

            if ( f_poCertificate != NULL )
            {
                DRM_BYT_CopyBytes( &f_poCertificate->ExtDataContainer.Header, 
                                   0, 
                                   &oExtDataContainer.Header, 
                                   0, 
                                   SIZEOF( DRM_BCERT_OBJECT_HEADER ) );
            }

            /* 
            ** Remember where extended data record object starts for signature verification.
            ** Container header has just been read, so this is the right place.
            */
            dwExtDataObjectStart = *f_pbOffset;
          
            ChkDR( _parseExtDataContainer( f_pbCertData,
                                           f_cbCertData,
                                           f_pbOffset,
                                           ( f_poCertificate != NULL ) ? &f_poCertificate->ExtDataContainer : &oExtDataContainer,
                                           f_pVerificationContext ) );
            /*
            ** Verify extended data signature
            */
            if ( !f_pVerificationContext->fDontFailOnMissingExtData )
            {
                ChkDR( _verifyExtDataSignature( f_pbCertData, 
                                                f_cbCertData,
                                                dwExtDataObjectStart,
                                                ( f_poCertificate != NULL ) ? &f_poCertificate->ExtDataSignatureInfo : &oExtDataSignKeyInfo,
                                                ( f_poCertificate != NULL ) ? &f_poCertificate->ExtDataContainer : &oExtDataContainer,
                                                f_pVerificationContext ) );
            }
            
            /*
            ** Reserved space for extended data can be larger than the actual extended data objects.
            ** Need to update offset correctly to point to the beginning of the next cert.
            */
            ChkOverflow( dwCertBegin + ( ( f_poCertificate != NULL ) ? f_poCertificate->Header.cbCertificate : f_poMinCertData->oCertHeader.cbCertificate ), dwCertBegin );
            ChkBoundsLT( dwCertBegin + ( ( f_poCertificate != NULL ) ? f_poCertificate->Header.cbCertificate : f_poMinCertData->oCertHeader.cbCertificate ), f_cbCertData );
            *f_pbOffset = dwCertBegin + ( ( f_poCertificate != NULL ) ? f_poCertificate->Header.cbCertificate : f_poMinCertData->oCertHeader.cbCertificate );
        }
        else
        {
            /*
            ** This is a "partially built" certificate,
            ** Record DRM_E_BCERT_HWIDINFO_IS_MISSING code.
            ** The caller will calculate where the next cert begins.
            */
            if ( !f_pVerificationContext->fDontFailOnMissingExtData )
            {
                ChkVerificationErr( f_pVerificationContext, FALSE, DRM_E_BCERT_HWIDINFO_IS_MISSING );
            }
        }
    }

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/********************************************************************************************
** Function:    DRM_BCert_FindObjectInCertByType
**
** Synopsis:    The function enumerates all objects in a cert until it finds the one
**              with a matching type, or reaches end of data buffer, or the last object
**              in certificate which a signature object.
**
** Arguments:   [f_pbCertData]   : data buffer to parse
**              [f_cbCertData]   : size of the data buffer (in bytes)
**              [f_pbOffset]     : position to start parsing from, should point
**                                 to the beginning of some object's header
**                                 or the beginning of the certificate header 
**                                 (a special case since cert header is not an object).
**                                 On exit if succeeded this offset should point to the beginning
**                                 of an object (including its header!)
**              [f_dwObjectType] : object type
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_INVALIDARG
**              DRM_E_NOMORE
**              DRM_E_ARITHMETIC_OVERFLOW - comes from _getObjectHeader
**              DRM_E_BCERT_OBJECTHEADER_LEN_TOO_BIG - comes from _getObjectHeader
********************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_BCert_FindObjectInCertByType(
    __in_bcount(f_cbCertData) const DRM_BYTE    *f_pbCertData,
    __in                      const DRM_DWORD   f_cbCertData,
    __inout_ecount(1)         DRM_DWORD         *f_pbOffset,
    __in                      const DRM_DWORD   f_dwObjectType )
{
    DRM_RESULT              dr          = DRM_SUCCESS;
    DRM_DWORD               dwOffset    = 0;
    DRM_DWORD               dwHeaderTag = 0;
    DRM_BCERT_OBJECT_HEADER oObjHeader  = { 0 };

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_FindObjectInCertByType );
    
    ChkArg( f_pbCertData != NULL );
    ChkArg( f_cbCertData > 0 );
    ChkArg( f_pbOffset != NULL );
    ChkOverflow( f_cbCertData, *f_pbOffset );
    ChkArg( f_dwObjectType <= DRM_BCERT_OBJTYPE_MAX_VALUE );

    /*
    ** Check for special case:
    ** offset could point to the beginning of the cert which is not an object.
    ** If header is found skip over it.
    */
    dwOffset = *f_pbOffset;
    NETWORKBYTES_FROMBUFFER_TO_DWORD( dwHeaderTag, 
                                      f_pbCertData, 
                                      dwOffset,
                                      f_cbCertData );    
    if( dwHeaderTag == DRM_BCERT_HEADER_TAG )
    {
        ChkOverflow( *f_pbOffset + SIZEOF( DRM_BCERT_HEADER ), *f_pbOffset );
       *f_pbOffset += SIZEOF( DRM_BCERT_HEADER );    
    }
    
    /*
    ** loop thru the objects until we reach
    ** end of data, the last object in cert,
    ** or object of sought type
    */
    dr = DRM_E_NOMORE;
    
    while ( *f_pbOffset < f_cbCertData )
    {
        ChkDR( _getObjectHeader( f_pbCertData,
                                 f_cbCertData,
                                 f_pbOffset,
                                 &oObjHeader ) );
        
        if ( oObjHeader.wType == f_dwObjectType )
        {
            dr = DRM_SUCCESS;
            break;
        }
        /*
        ** This is the last object in a cert and we are not looking for signature object.
        */    
        if ( oObjHeader.wType == DRM_BCERT_OBJTYPE_SIGNATURE )
        {
            dr = DRM_E_NOMORE;
            break;
        }
        /*
        ** go to the next object
        */
        ChkBOOL( SIZEOF( DRM_BCERT_OBJECT_HEADER ) <= oObjHeader.cbLength, 
                 DRM_E_BCERT_OBJECTHEADER_LEN_TOO_SMALL );
        ChkOverflow( *f_pbOffset + oObjHeader.cbLength - SIZEOF( DRM_BCERT_OBJECT_HEADER ), *f_pbOffset );
        *f_pbOffset += oObjHeader.cbLength - SIZEOF( DRM_BCERT_OBJECT_HEADER );
    }
    
ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/*****************************************************************************
** Function:    DRM_BCert_GetChainHeader
**
** Synopsis:    Parses a certificate chain header.
**
** Arguments:   [f_pbCertData] : data buffer that is being parsed
**              [f_cbCertData] : size of the data buffer (in bytes)
**              [f_pbOffset]   : position to start parsing from
**              [f_poChain]    : pointer to a chain header structure, 
**                               output parameter, cannot be NULL
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_ARITHMETIC_OVERFLOW - if offset is too big
**              DRM_E_BUFFERTOOSMALL - buffer is shorter than expected
**              DRM_E_BCERT_INVALID_CHAIN_HEADER_TAG
**              DRM_E_BCERT_INVALID_MAX_LICENSE_CHAIN_DEPTH
**              DRM_E_BCERT_INVALID_CHAIN_VERSION
**              DRM_E_BCERT_INVALID_CHAIN_LENGTH
**
** Notes:  If you need to enumerate all certificates in a chain and read
**         their content into DRM_BCERT_CERTIFICATE structure call this API first
**         1) to ensure the data looks like a cert chain, 2) find out total number 
**         of certs in it, 3) move an offset to the beginning of the first certificate.
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_BCert_GetChainHeader(
    __in_bcount(f_cbCertData) const DRM_BYTE                *f_pbCertData,
    __in                      const DRM_DWORD               f_cbCertData,
    __inout_ecount(1)         DRM_DWORD                     *f_pbOffset,
    __inout_ecount(1)         DRM_BCERT_CHAIN_HEADER        *f_poChain )
{
    DRM_RESULT dr       = DRM_SUCCESS;
    DRM_DWORD  dwOffset = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_GetChainHeader );

    ChkArg( f_pbCertData != NULL );
    ChkArg( f_pbOffset != NULL );
    ChkArg( *f_pbOffset < f_cbCertData );
    ChkArg( f_poChain != NULL );
    ChkOverflow( f_cbCertData, *f_pbOffset );

    dwOffset = *f_pbOffset;

    /*
    ** Fill in a chain header structure
    */
    NETWORKBYTES_FROMBUFFER_TO_DWORD( 
            f_poChain->dwHeaderTag,                 /* tag */
            f_pbCertData, 
            dwOffset,
            f_cbCertData );
    NETWORKBYTES_FROMBUFFER_TO_DWORD( 
            f_poChain->dwVersion,                   /* version */
            f_pbCertData, 
            dwOffset,
            f_cbCertData );
    NETWORKBYTES_FROMBUFFER_TO_DWORD( 
            f_poChain->cbChain,                     /* chain length */
            f_pbCertData, 
            dwOffset,
            f_cbCertData );
    NETWORKBYTES_FROMBUFFER_TO_DWORD( 
            f_poChain->dwFlags,                     /* flags*/
            f_pbCertData, 
            dwOffset,
            f_cbCertData );
    NETWORKBYTES_FROMBUFFER_TO_DWORD( 
            f_poChain->cCerts,                      /* number of certs in chain */
            f_pbCertData, 
            dwOffset,
            f_cbCertData );

    /*
    ** Verify that header constant tag is correct
    */
    ChkBOOL( f_poChain->dwHeaderTag == DRM_BCERT_CHAIN_HEADER_TAG, 
             DRM_E_BCERT_INVALID_CHAIN_HEADER_TAG );
    
    /*
    ** There should be 1-6 certificates in a chain
    */
    ChkBOOL( f_poChain->cCerts > 0, 
             DRM_E_BCERT_INVALID_MAX_LICENSE_CHAIN_DEPTH );
    ChkBOOL( f_poChain->cCerts <= DRM_BCERT_MAX_CERTS_PER_CHAIN, 
             DRM_E_BCERT_INVALID_MAX_LICENSE_CHAIN_DEPTH );
    /*
    ** Version is always 1
    */
    ChkBOOL( f_poChain->dwVersion == DRM_BCERT_CHAIN_VERSION, 
             DRM_E_BCERT_INVALID_CHAIN_VERSION );
    /*
    ** Chain length in bytes cannot be too small
    */
    ChkBOOL( f_poChain->cbChain >= DRM_MIN_CERT_CHAIN_LEN 
                                   + f_poChain->cCerts * DRM_MIN_CERTIFICATE_LEN, 
             DRM_E_BCERT_INVALID_CHAIN_LENGTH );
    /*
    ** There is enough data in a buffer to accomodate a chain length value
    */
    ChkOverflow( *f_pbOffset + f_poChain->cbChain, f_poChain->cbChain );
    ChkBOOL( f_cbCertData >= *f_pbOffset + f_poChain->cbChain, 
             DRM_E_BUFFERTOOSMALL );

    *f_pbOffset = dwOffset;

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/*****************************************************************************
** Function:    _setVerificationContext
**
** Synopsis:    Checks consistency of verification context structure and zeroes
**              the array of return results.
**
** Arguments:   [f_pVerificationContext] : pointer to verification context
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_INVALIDARG
******************************************************************************/
static DRM_RESULT _setVerificationContext(
    __inout_ecount(1) DRM_BCERT_VERIFICATIONCONTEXT *f_pVerificationContext )
{
    DRM_RESULT dr = DRM_SUCCESS;
    
    ChkArg( f_pVerificationContext != NULL );
    
    ChkArg( f_pVerificationContext->dwType <= DRM_BCERT_CERTTYPE_MAX_VALUE );

    /*
    ** Crypto context cannot be NULL if the parser may be doing signature verification
    */
    ChkArg( f_pVerificationContext->pCryptoCtx != NULL
        || ( f_pVerificationContext->fVerifyCertSignatures == FALSE 
            && f_pVerificationContext->fDontFailOnMissingExtData ) );

    f_pVerificationContext->cResults = 0;
    
    f_pVerificationContext->cCurrentCert = 0;
    
ErrorExit:
    return dr;
}


/*****************************************************************************
** Function:    DRM_BCert_InitVerificationContext
**
** Synopsis:    Initializes parser verification context.
**
** Arguments:   
**      [f_pftExpirationTime]           : these parameters correspond to the 
**      [f_pRootPubKey]                   data fields in verification context
**      [f_dwCertType]                    structure. All pointer params are optional.
**      [f_pCryptoCtx]                    For default values and meanings see
**      [f_fVerifyCertSignatures]         DRM_BCERT_VERIFICATIONCONTEXT structure
**      [f_fDontFailOnMissingExtData]     in drmbcertparser.h
**      [f_pKeyUsages]
**      [f_NumKeyUsages]
**      [f_fCollectErrs]                
**      [f_pVerificationContext]        : pointer to verification context
**                                        to be initialized. Cannot be NULL.
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_INVALIDARG
******************************************************************************/

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_BCert_InitVerificationContext(
    __in_opt DRMFILETIME                      *f_pftExpirationTime,
    __in_opt const PUBKEY_P256                *f_pRootPubKey,
    __in     const DRM_DWORD                  f_dwCertType,
    __in_opt DRM_CRYPTO_CONTEXT               *f_pCryptoCtx,
    __in     DRM_BOOL                         f_fVerifyCertSignatures,
    __in     DRM_BOOL                         f_fDontFailOnMissingExtData,
    __in_ecount_opt(f_NumKeyUsages) DRM_DWORD *f_pKeyUsages,
    __in     DRM_DWORD                        f_NumKeyUsages,
    __in     DRM_BOOL                         f_fCollectErrs,
    __in_opt DRM_BB_CONTEXT                  *f_pcontextBBX,
    __in_opt DRM_SECSTORE_CONTEXT            *f_pcontextSST,
    __in_opt DRM_DST                         *f_pDatastore,
    __inout  DRM_BCERT_VERIFICATIONCONTEXT    *f_pVerificationContext

)
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pVerificationContext != NULL );
    
    ChkArg( f_pCryptoCtx != NULL || ( f_fVerifyCertSignatures == FALSE && f_fDontFailOnMissingExtData == TRUE ) );
    ChkArg( f_pKeyUsages == NULL || ( f_NumKeyUsages > 0 && f_NumKeyUsages <= DRM_BCERT_MAX_KEY_USAGES ) );

    ZEROMEM( f_pVerificationContext, SIZEOF( DRM_BCERT_VERIFICATIONCONTEXT ) );
    
    if ( f_pftExpirationTime != NULL )
    {
        DRM_BYT_CopyBytes(&f_pVerificationContext->ftExpirationTime, 0, f_pftExpirationTime, 0, SIZEOF(DRMFILETIME) );
    }

    f_pVerificationContext->pRootPubKey = f_pRootPubKey;
    f_pVerificationContext->dwType = f_dwCertType;
    f_pVerificationContext->pCryptoCtx = f_pCryptoCtx;
    f_pVerificationContext->fVerifyCertSignatures = f_fVerifyCertSignatures;
    f_pVerificationContext->fDontFailOnMissingExtData = f_fDontFailOnMissingExtData;
    f_pVerificationContext->pBlackboxCtx = f_pcontextBBX;
    f_pVerificationContext->pSecStoreCtx = f_pcontextSST;
    f_pVerificationContext->pDSTCtx = f_pDatastore;

    if ( f_pKeyUsages != NULL && f_NumKeyUsages > 0 )
    {
        DRM_BYT_CopyBytes( f_pVerificationContext->rgdwRequiredKeyUsages, 0, f_pKeyUsages, 0, SIZEOF(DRM_DWORD) * f_NumKeyUsages );
    }

    f_pVerificationContext->fCollectErrorsInArrayAndContinue = f_fCollectErrs;

ErrorExit:
    return dr;
}


/*****************************************************************************
** Function:    DRM_BCert_ParseCertificateChain
**
** Synopsis:    The function parses binary data that represents device certificate chain
**              and verifies its validity. Optionally it can verify that all certs
**              are not expired, and the issuer key for of top certificate in a chain
**              matches specified value.
**
** Arguments:   [f_pbCertData]           : data buffer to parse
**              [f_cbCertData]           : size of the data buffer (in bytes)
**              [f_pVerificationContext] : pointer to verification context structure that defines
**                                         optional verification conditions on the cert and may collect list of
**                                         verification errors not fatal for cert parser (i.e. parsing can continue).
**                                         Note that if on exit errors list is not empty this function will return
**                                         specific error code DRM_E_BCERT_VERIFICATION_ERRORS.
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_INVALIDARG
**              DRM_E_BCERT_ISSUERKEY_KEYINFO_MISMATCH
**              DRM_E_BCERT_VERIFICATION_ERRORS
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_BCert_ParseCertificateChain(
    __in_bcount(f_cbCertData)             const DRM_BYTE          *f_pbCertData,
    __in                                  const DRM_DWORD         f_cbCertData,
    __inout                         DRM_BCERT_VERIFICATIONCONTEXT *f_pVerificationContext )
{
    DRM_RESULT             dr               = DRM_SUCCESS;
    DRM_DWORD              bCurrOffset      = 0;
    DRM_BCERT_CHAIN_HEADER oChainHeader     = { 0 };
    DRM_BCERT_MINIMALDATA  roCertData[2]    = { 0, 0 };
    DRMFILETIME            ftCertTime       = { 0 };
    DRM_UINT64             ui64CurrentTime  = DRM_UI64LITERAL( 0, 0 );
    DRM_UINT64             uiCertTime       = DRM_UI64LITERAL( 0, 0 );

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_ParseCertificateChain );

    ChkArg( f_pbCertData != NULL );
    ChkArg( f_cbCertData > 0 );    
    ChkDR( _setVerificationContext( f_pVerificationContext ) );
    
    /*
    ** Parse a cert chain header
    */
    ChkDR( DRM_BCert_GetChainHeader( f_pbCertData, f_cbCertData, &bCurrOffset, &oChainHeader ) );

    /*
    ** Parse certificates in a chain
    */
    for ( f_pVerificationContext->cCurrentCert = 0; 
          f_pVerificationContext->cCurrentCert < oChainHeader.cCerts; 
          f_pVerificationContext->cCurrentCert++ )
    {        
        DRM_DWORD dwCertificateBegin = bCurrOffset;

        /*
        ** Parse certificate and remember only data needed for verification purpose
        */
        ChkDR( _parseCertificate( f_pbCertData, 
                                  f_cbCertData, 
                                  &bCurrOffset, 
                                  NULL, 
                                  &roCertData[ f_pVerificationContext->cCurrentCert % 2 ], 
                                  f_pVerificationContext ) );
        /*
        ** Calculate where certificate ends
        */
        ChkOverflow( dwCertificateBegin + roCertData[ f_pVerificationContext->cCurrentCert % 2 ].oCertHeader.cbCertificate, dwCertificateBegin );
        bCurrOffset = dwCertificateBegin + roCertData[ f_pVerificationContext->cCurrentCert % 2 ].oCertHeader.cbCertificate;
        
        /*
        ** Match leaf certificate type if it is provided
        */
        if ( 0 == f_pVerificationContext->cCurrentCert
            && f_pVerificationContext->dwType > 0 )
        {
            ChkBOOL( roCertData[ f_pVerificationContext->cCurrentCert % 2 ].oBasicInfo.dwType == f_pVerificationContext->dwType, 
                    DRM_E_BCERT_INVALID_CERT_TYPE );
        }
        /*
        ** Verify signature 
        */
        if( f_pVerificationContext->fVerifyCertSignatures )
        {
            ChkBoundsLT( dwCertificateBegin, f_cbCertData );
            ChkBoundsLT( roCertData[ f_pVerificationContext->cCurrentCert % 2 ].oCertHeader.cbCertificateSigned, f_cbCertData - dwCertificateBegin );
            ChkDR( DRM_BCert_VerifySignature( f_pbCertData + dwCertificateBegin,
                                     roCertData[ f_pVerificationContext->cCurrentCert % 2 ].oCertHeader.cbCertificateSigned,
                                     &roCertData[ f_pVerificationContext->cCurrentCert % 2 ].oSignatureInfo,
                                     f_pVerificationContext->pCryptoCtx,
                                     f_pVerificationContext->pBlackboxCtx,
                                     f_pVerificationContext->pSecStoreCtx,
                                     f_pVerificationContext->pDSTCtx ) );
        }
        /*
        ** Check if the certificate is expired - optional
        */
        if ( DoExpirationCheck( f_pVerificationContext->ftExpirationTime ) )
        {
            FILETIME_TO_UI64( f_pVerificationContext->ftExpirationTime, ui64CurrentTime );
            CREATE_FILE_TIME( roCertData[ f_pVerificationContext->cCurrentCert % 2 ].oBasicInfo.dwExpirationDate, ftCertTime );
            FILETIME_TO_UI64( ftCertTime, uiCertTime );    
            ChkBOOL( !DRM_UI64Les( uiCertTime, ui64CurrentTime ), 
                    DRM_E_BCERT_BASICINFO_CERT_EXPIRED );
        }
        /*
        ** Additional verification between the certs
        */
        if ( f_pVerificationContext->cCurrentCert > 0 )
        {
            ChkDR( _verifyAdjacentCerts( &roCertData[(f_pVerificationContext->cCurrentCert + 1) % 2],
                                         &roCertData[f_pVerificationContext->cCurrentCert % 2],
                                         f_pVerificationContext ) );
        }
        /*
        ** Check that Issuer key of the last cert is f_pRootPubkey.
        */
        if ( f_pVerificationContext->pRootPubKey != NULL
            && f_pVerificationContext->cCurrentCert == oChainHeader.cCerts - 1 )
        {
            ChkBOOL( DRM_BYT_CompareBytes(
                        roCertData[ f_pVerificationContext->cCurrentCert % 2 ].oSignatureInfo.IssuerKey.rgb,
                        0, 
                        f_pVerificationContext->pRootPubKey->m_rgbPubkey,
                        0,
                        SIZEOF( PUBKEY_P256 ) ) == 0,
                     DRM_E_BCERT_ISSUERKEY_KEYINFO_MISMATCH );            
        }
    }
    
ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    if ( f_pVerificationContext != NULL )
    {
        if ( f_pVerificationContext->cResults > 0 )
        {
            dr = DRM_E_BCERT_VERIFICATION_ERRORS;
        }
    }
    return dr;
}


/********************************************************************************************
** Function:    DRM_BCert_GetCertificate
**
** Synopsis:    Given the beginning of a certificate in a chain the function skips over it
**              and moves the offset to the next one. If DRM_BCERT_CERTIFICATE is not NULL
**              the certificate's content will be parsed and stored in it.
**
** Arguments:   [f_pbCertData]         : data buffer to parse
**              [f_cbCertData]         : size of the data buffer (in bytes)
**              [f_pbOffset]           : position to start parsing from, should point
**                                       to the beginning of some certificate. On return
**                                       this value will be updated with the next cert's beginning.
**              [f_poCertificate]      : pointer to a certificate structure, optional.
**              [f_dwRequiredCertType] : expected type of certificate, set into DRM_BCERT_CERTTYPE_UNKNOWN
**                                       if it is not important. Otherwise the function will return
**                                       DRM_BCERT_CERTTYPE_UNKNOWN if type does not match.
**                                       Also this parameter is ignored if f_poCertificate == NULL.
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_S_FALSE      - if it was the last certificate in chain.
**              DRM_E_INVALIDARG
**              DRM_E_ARITHMETIC_OVERFLOW
**              DRM_E_BCERT_INVALID_CERT_LENGTH
**              DRM_E_BCERT_INVALID_CERT_TYPE
**
** Note:  1. The function will not validate the certificate if f_poCertificate == NULL,
**           only skip over it. 
**
**        2. If f_poCertificate != NULL then cert data will be checked for compliance with
**           format only! Cert signature, expiration date and public key will NOT be verified.
**           Call DRM_BCert_ParseCertificateChain() API for full validation!
**
**        3. If DRM_S_FALSE is returned it means that there are no more certs in a chain.
**           The f_pbOffset will still be updated so that an attempt to use this value
**           somewhere else would fail.
**
**        4. To enumerate all certs in a chain first call DRM_BCert_GetChainHeader(),
**           then DRM_BCert_GetCertificate. See notes for DRM_BCert_GetChainHeader.
********************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_BCert_GetCertificate(
    __in_bcount(f_cbCertData) const DRM_BYTE         *f_pbCertData,
    __in                      const DRM_DWORD        f_cbCertData,
    __inout_ecount(1)         DRM_DWORD              *f_pbOffset,
    __inout_ecount_opt(1)     DRM_BCERT_CERTIFICATE  *f_poCertificate,
    __in                      const DRM_DWORD        f_dwRequiredCertType )
{
    DRM_RESULT dr                  = DRM_SUCCESS;
    DRM_DWORD  dwOffset            = 0;
    DRM_DWORD  dwCertificateLength = 0;
    DRM_BCERT_VERIFICATIONCONTEXT oVerificationContext = {0};
    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_GetCertificate );

    ChkArg( f_pbCertData != NULL );
    ChkArg( f_cbCertData > 0 );
    ChkArg( f_pbOffset != NULL );

    ChkOverflow( f_cbCertData, *f_pbOffset );
    dwOffset = *f_pbOffset;

    if ( f_poCertificate != NULL )  /* parse current certificate */
    {
        ChkDR( DRM_BCert_InitVerificationContext( NULL,
                                                  NULL,
                                                  f_dwRequiredCertType,
                                                  NULL,
                                                  FALSE,
                                                  TRUE,
                                                  NULL,
                                                  0,
                                                  FALSE,
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  &oVerificationContext ) );

        ChkDR( _parseCertificate( f_pbCertData, 
                                  f_cbCertData, 
                                  &dwOffset,
                                  f_poCertificate,
                                  NULL,
                                  &oVerificationContext ) );

        dwCertificateLength = f_poCertificate->Header.cbCertificate;
    }
    else  /* only read the header */
    {
        DRM_BCERT_HEADER oCertHeader = { 0 };
        ChkDR( _parseCertHeader( f_pbCertData, f_cbCertData, &dwOffset, &oCertHeader, &oVerificationContext ) );

        dwCertificateLength = oCertHeader.cbCertificate;
    }
    ChkOverflow( *f_pbOffset + dwCertificateLength, *f_pbOffset );  /* cert length is not too big */
    ChkOverflow( f_cbCertData, *f_pbOffset + dwCertificateLength ); /* new offset is not too big */
    
    *f_pbOffset  += dwCertificateLength;  /* move the offset to the beginning of the next certificate */

    ChkBOOL( *f_pbOffset < f_cbCertData, DRM_S_FALSE ); /* otherwise we were at the last certificate in a chain */

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/***********************************************************************************************************
** Function:    DRM_BCert_GetPublicKeyByUsage
**
** Synopsis:    The function retrieves the public key of the cert with specified 
**              key usage and index in a certificate chain. 
**              On success returns a key value and an array of all key usages for the found key.
**              If key usage is set into DRM_BCERT_KEYUSAGE_UNKNOWN then the first public key will be returned.
**
** Arguments:   [f_pbCertData]      : data buffer to parse
**              [f_cbCertData]      : size of the data buffer (in bytes)
**              [f_dwCertIndex]     : index of certificate in the chain. Leaf cert is 0.
**              [f_dwKeyUsage]      : requested key usage of public key.
**              [f_pPubkey]         : pointer to a public key structure
**              [f_pdwKeyUsages]    : array of key usages of the returned key. The caller is responsible
**                                    for allocating an array of size of DRM_BCERT_MAX_KEY_USAGES or less
**                                    (it's usually safe to allocate size of DRM_BCERT_KEYUSAGE_MAX_VALUE ).
**                                    This parameter is optional and can be NULL.
**              [f_pcbKeyUsages]    : if f_pdwKeyUsages != NULL then it's a pointer to the size of f_pdwKeyUsages array
**                                    which on success is equal to the actual number of key usage entries of the returned public key.
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_INVALIDARG
**              DRM_E_BUFFERTOOSMALL - if there is not enough room in f_pdwKeyUsages to save all key usages
**
** Note: We assume that this data is valid so that we don't have to parse it again.
**       Some basic validation still occurs.
************************************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_BCert_GetPublicKeyByUsage(
    __in_bcount(f_cbCertData)           const DRM_BYTE    *f_pbCertData,
    __in                                const DRM_DWORD    f_cbCertData,
    __in                                const DRM_DWORD    f_dwCertIndex,
    __in                                const DRM_DWORD    f_dwKeyUsage,
    __inout_ecount(1)                   PUBKEY_P256       *f_pPubkey,
    __inout_ecount_opt(*f_pcbKeyUsages) DRM_DWORD         *f_pdwKeyUsages,
    __inout_opt                         DRM_DWORD         *f_pcbKeyUsages )
{
    DRM_RESULT              dr             = DRM_SUCCESS;
    DRM_DWORD               bCurrOffset    = 0;
    DRM_BCERT_CHAIN_HEADER  oChainHeader   = {0};
    DRM_DWORD               iCertCounter   = 0;
    DRM_DWORD               iKeyCounter    = 0;
    DRM_DWORD               iUsageCounter  = 0;
    DRM_BOOL                fFoundKey      = FALSE;
    DRM_DWORD               iFoundKey      = 0;
    DRM_BCERT_KEY_INFO      oKeyInfo       = {0};
    DRM_BCERT_VERIFICATIONCONTEXT oVerificationContext = {0};

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_GetPublicKeyByUsage );
    
    ChkArg( f_pbCertData != NULL );
    ChkArg( f_cbCertData > 0 );
    ChkArg( f_pPubkey != NULL );

    /*
    ** Parse a cert chain header and make sure
    ** that there are enough certs in the chain.
    */
    ChkDR( DRM_BCert_GetChainHeader( f_pbCertData, 
                                     f_cbCertData, 
                                     &bCurrOffset,
                                     &oChainHeader ) );

    ChkBOOL( oChainHeader.cCerts > f_dwCertIndex, DRM_E_BCERT_INVALID_CHAIN_LENGTH );

    /*
    ** bCurrOffset currently points to the 0-th leaf cert.
    ** Loop thru certificates if needed. 
    ** Do not parse, only look for the start position.
    */
    for ( iCertCounter = 1; iCertCounter <= f_dwCertIndex; iCertCounter++ )
    {
        ChkDR( DRM_BCert_GetCertificate( f_pbCertData,
                                         f_cbCertData,
                                         &bCurrOffset,
                                         NULL,
                                         DRM_BCERT_CERTTYPE_UNKNOWN ) );
    }

    ZEROMEM( f_pPubkey->m_rgbPubkey, ECC_P256_POINT_SIZE_IN_BYTES );

    /*
    ** Loop thru the objects until we find
    ** a key information or reach the end
    */
    ChkDR( DRM_BCert_FindObjectInCertByType( f_pbCertData,
                                             f_cbCertData,
                                             &bCurrOffset,
                                             DRM_BCERT_OBJTYPE_KEY ) );

    ChkDR( DRM_BCert_InitVerificationContext( NULL,
                                              NULL,
                                              DRM_BCERT_CERTTYPE_UNKNOWN ,
                                              NULL,
                                              FALSE,
                                              TRUE,
                                              NULL,
                                              0,
                                              FALSE,
                                              NULL,
                                              NULL,
                                              NULL,
                                              &oVerificationContext ) );

    ChkDR( _parseKeyInfo( f_pbCertData,
                          f_cbCertData,
                          &bCurrOffset,
                          DRM_BCERT_CERTTYPE_UNKNOWN,
                          &oKeyInfo,
                          &oVerificationContext ) );

    if ( f_dwKeyUsage != DRM_BCERT_KEYUSAGE_UNKNOWN )
    {
        /*
        ** Find the first key with requested key usage
        */
        for ( iKeyCounter = 0; iKeyCounter < oKeyInfo.dwNumKeys; iKeyCounter++ )
        {
            for ( iUsageCounter = 0; iUsageCounter < oKeyInfo.rgoKeys[iKeyCounter].dwNumUsageEntries; iUsageCounter++ )
            {
                if ( !fFoundKey 
                    && f_dwKeyUsage == oKeyInfo.rgoKeys[iKeyCounter].dwUsageSet[iUsageCounter] )
                {
                    iFoundKey = iKeyCounter;
                    fFoundKey = TRUE;
                }
            }
        }
    }
    else
    {
        iFoundKey = 0; /* if any keyusage is requested just get the first public key */
        fFoundKey = TRUE;
    }
    
    /*
    ** If the loop is finished then the key with requested usage was not found
    */
    ChkBOOL( fFoundKey, DRM_E_BCERT_NO_PUBKEY_WITH_REQUESTED_KEYUSAGE );

    /*
    ** Copy key usages and the key value
    */
    if ( f_pdwKeyUsages != NULL )
    {
        ChkBOOL( *f_pcbKeyUsages >= oKeyInfo.rgoKeys[iFoundKey].dwNumUsageEntries, DRM_E_BUFFERTOOSMALL );

        DRM_BYT_CopyBytes( f_pdwKeyUsages,
                           0,
                           oKeyInfo.rgoKeys[iFoundKey].dwUsageSet,
                           0,
                           SIZEOF(DRM_DWORD) * oKeyInfo.rgoKeys[iFoundKey].dwNumUsageEntries );
        *f_pcbKeyUsages = oKeyInfo.rgoKeys[iFoundKey].dwNumUsageEntries;
    }
    DRM_BYT_CopyBytes( f_pPubkey->m_rgbPubkey,
                       0, 
                       oKeyInfo.rgoKeys[iFoundKey].Value.rgb, 
                       0, 
                       ECC_P256_POINT_SIZE_IN_BYTES );
    
ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

/********************************************************************************************
** Function:    DRM_BCert_GetPublicKey
**
** Synopsis:    The function retrieves the public key of the specified cert
**              in a certificate chain. If there are several public keys in the cert
**              the first one will be returned.
**
** Arguments:   [f_pbCertData]      : data buffer to parse
**              [f_cbCertData]      : size of the data buffer (in bytes)
**              [f_dwCertIndex]     : index of certificate in the chain. Leaf cert is 0.
**              [f_pPubkey]         : pointer to a public key structure
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_INVALIDARG
**
** Note: We assume that this data is valid so that we don't have to parse it again.
**       Some basic validation still occurs.
********************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_BCert_GetPublicKey(
    __in_bcount(f_cbCertData) const DRM_BYTE    *f_pbCertData,
    __in                      const DRM_DWORD    f_cbCertData,
    __in                      const DRM_DWORD    f_dwCertIndex,
    __inout_ecount(1)         PUBKEY_P256       *f_pPubkey )
{
    DRM_RESULT              dr             = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_BCERT, PERF_FUNC_GetPublicKey );
    
    ChkArg( f_pbCertData != NULL );
    ChkArg( f_cbCertData > 0 );
    ChkArg( f_pPubkey != NULL );

    ChkDR( DRM_BCert_GetPublicKeyByUsage( f_pbCertData,
                                          f_cbCertData,
                                          f_dwCertIndex,
                                          DRM_BCERT_KEYUSAGE_UNKNOWN,
                                          f_pPubkey,
                                          NULL,
                                          NULL ) );
    
ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmbcrlparser.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <byteorder.h>
#include <drmlicense.h>
#include <drmbcert.h>
#include <drmbcertparser.h>
#include <drmbcrl.h>

ENTER_PK_NAMESPACE_CODE;

/**********************************************************************
**
** Function:    DRM_BCrl_VerifySignature
**
** Synopsis:    Verifies the PlayReady revinfov2 or binary crl signature.
**
** Arguments:    
**              [f_pbSignedBytes]        - Specifies the bytes that are signed
**              [f_cbSignedBytes]        - Specifies the size of the signed bytes
**              [f_pbSignature]          - Specifies the signature
**              [f_cbSignature]          - Specifies the size signature
**              [f_pbCertificate]        - Specifies the certificate chain used to find signing key
**              [f_cbCertificate]        - Specifies the size certificate chain used to find signing key
**              [f_pRootPubkey]          - A pointer to public key to verify root certificate.
**              [f_pCryptoCtx]           - Pointer to DRM_CRYPTO_CONTEXT used for temporary data in crypto code.
**
** Returns:     DRM_SUCCESS if the signature is valid
**              DRM_E_INVALIDARG if the data in the passed arguments is invalid
**              passes return codes from other failures up to caller
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_BCrl_VerifySignature (
                 __in_bcount(f_cbSignedBytes) const DRM_BYTE               *f_pbSignedBytes,
                 __in                               DRM_DWORD               f_cbSignedBytes,
                 __in_bcount(f_cbSignature)         DRM_BYTE               *f_pbSignature,
                 __in                               DRM_DWORD               f_cbSignature,
                 __in_bcount(f_cbCertificateChain)  DRM_BYTE               *f_pbCertificateChain,
                 __in                               DRM_DWORD               f_cbCertificateChain,
                 __in_ecount(1)               const PUBKEY_P256            *f_pRootPubkey,
                 __in                               DRM_CRYPTO_CONTEXT     *f_pCryptoCtx,
                 __in_opt                           DRM_BB_CONTEXT         *f_pcontextBBX,
                 __in_opt                           DRM_SECSTORE_CONTEXT   *f_pcontextSST,
                 __in_opt                           DRM_DST                *f_pDatastore )
{
    DRM_RESULT dr = DRM_SUCCESS;
    PUBKEY_P256 pub_key = { 0 };
    DRM_BCERT_CHAIN_HEADER chain_header = { 0 };
    DRM_DWORD offset_for_header = 0;
    DRM_DWORD cert_index = 0; /* Cert[0] is the leaf certificate. */
    DRM_BCERT_VERIFICATIONCONTEXT oVerificationContext = {0};
    DRM_DWORD rgdwKeyUsageSet[] = { DRM_BCERT_KEYUSAGE_SIGN_CRL }; /* verify that this certificate has the Sign Crl key usage value */
    DRMFILETIME ftTime = {0};

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_REVOCATION, PERF_FUNC_DRM_BCrl_VerifySignature );
    
    /* verifying length of chain */
    ChkDR( DRM_BCert_GetChainHeader( f_pbCertificateChain, f_cbCertificateChain, &offset_for_header, &chain_header ) );
    ChkArg( f_cbCertificateChain == chain_header.cbChain );

    /* verifying certificate chain if it's trusted */
    Oem_Clock_GetSystemTimeAsFileTime( NULL, &ftTime );

    ChkDR( DRM_BCert_InitVerificationContext( &ftTime,
                                              f_pRootPubkey,
                                              DRM_BCERT_CERTTYPE_CRL_SIGNER,
                                              f_pCryptoCtx,
                                              TRUE,
                                              FALSE,
                                              rgdwKeyUsageSet,
                                              NO_OF(rgdwKeyUsageSet),
                                              FALSE,
                                              f_pcontextBBX,
                                              f_pcontextSST,
                                              f_pDatastore,
                                              &oVerificationContext ) );

    ChkDR( DRM_BCert_ParseCertificateChain( f_pbCertificateChain, f_cbCertificateChain, &oVerificationContext ) );

    /* retrieving key from certificate chain */    
    ChkDR( DRM_BCert_GetPublicKey( f_pbCertificateChain, f_cbCertificateChain, cert_index, &pub_key ) );

    /* verifying signature */
    ChkArg(sizeof(SIGNATURE_P256) == f_cbSignature);
    ChkDR( DRM_ECDSA_Verify_P256( f_pbSignedBytes, 
                                  f_cbSignedBytes, 
                                  &pub_key, 
                                  (SIGNATURE_P256*)f_pbSignature, 
                                  (struct bigctx_t *)f_pCryptoCtx ) );

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/*****************************************************************************
** Function:    DRM_BCrl_ParseCrl
**
** Synopsis:    Parses Playready CRL from binary to data structure.
**              Verifies the CRL signature and associated certificate chain.
**
** Arguments:   [f_pbCrlData]  : A pointer to the raw binary CRL data
**              [f_cbCrlData]  : Number of bytes in the raw binary CRL data
**              [f_poCrl]      : A pointer to the structure to hold the parsed CRL data
**              [f_pRootPubkey]: A pointer to public key to verify root certificate.
**              [f_pCryptoCtx] : Pointer to DRM_CRYPTO_CONTEXT used for temporary data in crypto code.
**              
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_INVALIDARG - if the output parm or the CRL data is NULL
**
** Notes:       The parser does not make copies of the DRM_RevocationEntry
**              data, it just points to them in the f_pbCrlData buffer.  Thus
**              the caller cannot free the f_pbCrlData buffer and still have a 
**              valid f_poCrl data structure.
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_BCrl_ParseCrl(
 __in_bcount(f_cbCrlData) const DRM_BYTE       *f_pbCrlData,
 __in                     const DRM_DWORD      f_cbCrlData,
 __out                    DRM_BCRL_Signed      *f_poCrl,
 __in_ecount(1)           const PUBKEY_P256    *f_pRootPubkey,
 __inout                  DRM_CRYPTO_CONTEXT   *f_pCryptoCtx,
 __in_opt                 DRM_BB_CONTEXT       *f_pcontextBBX,
 __in_opt                 DRM_SECSTORE_CONTEXT *f_pcontextSST,
 __in_opt                 DRM_DST              *f_pDatastore
)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD dwOffset = 0;
    DRM_DWORD dwSignedMessageLength = 0;

    ChkArg( f_poCrl != NULL );
    ChkArg( f_pbCrlData != NULL);
 
    /* 
    ** Retrieving crl header 
    */
    COPY_FROMBUFFER( f_poCrl->Crl.Identifier, 
                     f_pbCrlData, 
                     dwOffset, 
                     SIZEOF(f_poCrl->Crl.Identifier), 
                     f_cbCrlData );

    NETWORKBYTES_FROMBUFFER_TO_DWORD( f_poCrl->Crl.dwVersion, 
                                      f_pbCrlData, 
                                      dwOffset, 
                                      f_cbCrlData );

    NETWORKBYTES_FROMBUFFER_TO_DWORD( f_poCrl->Crl.cRevocationEntries, 
                                      f_pbCrlData, 
                                      dwOffset, 
                                      f_cbCrlData );    
    /* 
    ** Retrieving revocation entries 
    */    
    if ( f_poCrl->Crl.cRevocationEntries > 0 ) 
    {
        ChkBoundsLT( dwOffset, f_cbCrlData );
        f_poCrl->Crl.Entries = (DRM_RevocationEntry*) ( f_pbCrlData + dwOffset );
    }
    else
    {
        f_poCrl->Crl.Entries = NULL;
    }
    ChkOverflow( f_poCrl->Crl.cRevocationEntries * SIZEOF( DRM_RevocationEntry ), 
                 f_poCrl->Crl.cRevocationEntries );
    ChkOverflow( dwOffset + f_poCrl->Crl.cRevocationEntries * SIZEOF( DRM_RevocationEntry ), 
                 f_poCrl->Crl.cRevocationEntries * SIZEOF( DRM_RevocationEntry ) );
    dwOffset += f_poCrl->Crl.cRevocationEntries * SIZEOF( DRM_RevocationEntry );        

    ChkBoundsLT( dwOffset, f_cbCrlData );
    dwSignedMessageLength = dwOffset; /* remember signed message length */

    /* 
    ** Retrieving signature 
    */
    COPY_FROMBUFFER( f_poCrl->Signature.type,
                     f_pbCrlData,
                     dwOffset,
                     SIZEOF( f_poCrl->Signature.type ),
                     f_cbCrlData );

    ChkArg( PLAYREADY_DRM_BCRL_SIGNATURE_TYPE == f_poCrl->Signature.type ); 
    
    NETWORKBYTES_FROMBUFFER_TO_WORD( f_poCrl->Signature.cb, 
                                     f_pbCrlData, 
                                     dwOffset, 
                                     f_cbCrlData );

    ChkArg( SIZEOF( SIGNATURE_P256 ) == f_poCrl->Signature.cb );

    COPY_FROMBUFFER( f_poCrl->Signature.rgb,
                     f_pbCrlData, 
                     dwOffset, 
                     f_poCrl->Signature.cb, 
                     f_cbCrlData ); 

    /* 
    ** Retrieving certificate chain 
    */    
    ChkBoundsLT( dwOffset, f_cbCrlData );
    f_poCrl->pbCertificateChain = (DRM_BYTE*)( f_pbCrlData + dwOffset );
    f_poCrl->cbCertificateChain = f_cbCrlData - dwOffset; /*this is verified below */
   
    /* verifying signature */
    ChkDR( DRM_BCrl_VerifySignature( f_pbCrlData, 
                                     dwSignedMessageLength, 
                                     &(f_poCrl->Signature.rgb[0]), 
                                     f_poCrl->Signature.cb, 
                                     f_poCrl->pbCertificateChain, 
                                     f_poCrl->cbCertificateChain, 
                                     f_pRootPubkey, 
                                     f_pCryptoCtx, 
                                     f_pcontextBBX, 
                                     f_pcontextSST, 
                                     f_pDatastore ) );
    
ErrorExit: 
    return dr;
}

/*****************************************************************************
** Function:    DRM_BCrl_CheckIfPlayReadyCertRevoked
**
** Synopsis:    Checks if PlayReady certificate is revoked by the CRL.
**              Iterates over hashes in the device CRL, check if it matches hashes of public keys in 
**              certificate chain
**
** Arguments:   [f_pbPlayReadyCert]     : A pointer to the raw PlayReady certificate data.
**              [f_cbPlayReadyCert]     : A Number of bytes in the raw PlayReady certificate data.
**              [f_pbCrlData]           : A pointer to the raw binary CRL data
**              [f_cbCrlData]           : Number of bytes in the raw binary CRL data
**              [f_pRevokedCertDigest]  : Optional pointer to receive the digest of the specific cert within the chain that was revoked.
**              [f_pdwPlayReadyCRLVer]  : Optional pointer to DRM_DWORD. Filled with version of PlayReady CRL. 
**              [f_pCryptoCtx]          : Pointer to DRM_CRYPTO_CONTEXT used for temporary data in crypto code.
**
** Returns:     DRM_SUCCESS                 - on success
**              DRM_E_INVALIDARG            - if the output parm or the CRL data is NULL
**              DRM_E_CERTIFICATE_REVOKED   - if the certificate is revoked by the CRL
**
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_BCrl_CheckIfPlayReadyCertRevoked
(
    __in_bcount(f_cbPlayReadyCert)const DRM_BYTE            *f_pbPlayReadyCert,
    __in                                DRM_DWORD           f_cbPlayReadyCert,
    __in_bcount(f_cbPlayReadyCRL) const DRM_BYTE           *f_pbPlayReadyCRL,
    __in                                DRM_DWORD           f_cbPlayReadyCRL,
    __out_opt                           DRM_SHA256_Digest  *f_pRevokedCertDigest,
    __out_opt                           DRM_DWORD          *f_pdwPlayReadyCRLVer,
    __inout                             DRM_CRYPTO_CONTEXT *f_pCryptoCtx,
    __in_opt                            DRM_BB_CONTEXT     *f_pcontextBBX,
    __in_opt                            DRM_SECSTORE_CONTEXT   *f_pcontextSST,
    __in_opt                            DRM_DST            *f_pDatastore
)

{   DRM_RESULT dr                       = DRM_SUCCESS;
    DRM_BCRL_Signed obCRLDevice         = {0};
    DRM_BCERT_CHAIN_HEADER oChainHeader = {0};
    DRM_BCERT_CERTIFICATE  oDeviceCert  = {0};
    DRM_DWORD              dwCertIndex  = 0;
    DRM_DWORD              bCurrOffset  = 0;
    DRM_DWORD              dwHashIndex  = 0;


    ChkArg( f_pbPlayReadyCert != NULL );
    ChkArg( f_cbPlayReadyCert > 0 );
    ChkArg( f_pbPlayReadyCRL != NULL );
    ChkArg( f_cbPlayReadyCRL > 0 );
    ChkArg( f_pCryptoCtx != NULL );

    if ( NULL != f_pRevokedCertDigest )
    {
        MEMSET( f_pRevokedCertDigest, 0, SIZEOF( *f_pRevokedCertDigest ) );
    }

    /*
    **  Parse PlayReady CRL. This operation brings list of hashes of public keys.
    **  Uses production public key to test signature on CRL files.
    */
    ChkDR( DRM_BCrl_ParseCrl( f_pbPlayReadyCRL, f_cbPlayReadyCRL, &obCRLDevice, (const PUBKEY_P256*)g_rgbMSPlayReadyRootIssuerPubKey, f_pCryptoCtx, f_pcontextBBX, f_pcontextSST, f_pDatastore ) );
    
    /* Optionally ouputs the version of the CRL. On PC they check that CRL has minimal version */
    if ( f_pdwPlayReadyCRLVer != NULL )
    {
        *f_pdwPlayReadyCRLVer = obCRLDevice.Crl.dwVersion;
    }

    /*
    ** Loop over all certificates in the chain of f_pbPlayReadyCert and compare hash of the public key in each
    ** certificate with hashes in the binary CRL.
    */
    
    /* 
    ** Skip the chain header to get to device certificate 
    */
    ChkDR( DRM_BCert_GetChainHeader( f_pbPlayReadyCert, 
                                     f_cbPlayReadyCert, 
                                     &bCurrOffset,
                                     &oChainHeader ) );

    /* Itearation over all certificates in the chain */
    for ( dwCertIndex = 0; dwCertIndex < oChainHeader.cCerts ; dwCertIndex++ )
    {
        /*
        ** Load device certificate. bCurrOffset is updated on each call and thus we iterate over certificates.
        */
        ChkDRMap( DRM_BCert_GetCertificate( f_pbPlayReadyCert, 
                                            f_cbPlayReadyCert, 
                                            &bCurrOffset,
                                            &oDeviceCert,
                                            DRM_BCERT_CERTTYPE_UNKNOWN ), DRM_S_FALSE, DRM_SUCCESS );
        
        /* Iteration over all hashes in binary CRL. */
        for ( dwHashIndex = 0; dwHashIndex < obCRLDevice.Crl.cRevocationEntries; dwHashIndex++ )        
        {   
            /* Compare hashes in the device cert. and in the CRL list. */
            
            if ( 0 == MEMCMP( obCRLDevice.Crl.Entries + dwHashIndex, &oDeviceCert.BasicInfo.DigestValue, SIZEOF( obCRLDevice.Crl.Entries ) ) )
            {
                /* 
                ** OOPs, we found that one of hashes in CRL correspond to hash in device cert. 
                ** So it is revoked!
                */
                if ( NULL != f_pRevokedCertDigest )
                {
                    MEMCPY( f_pRevokedCertDigest, &oDeviceCert.BasicInfo.DigestValue, SIZEOF( *f_pRevokedCertDigest ) );
                }
                ChkDR( DRM_E_CERTIFICATE_REVOKED );
            }
        }
    }

ErrorExit :

    /*
    **  DRM_BCert_GetCertificate return DRM_S_FALSE on last certificate.
    **  Thus if we do not change return code, it would be DRM_S_FALSE in case of not revoked certificate.
    **  While it is acceptable, it is strange return code for DRM_BCrl_CheckIfPlayReadyCertRevoked, so I change it to DRM_SUCCESS
    */
    if ( DRM_S_FALSE == dr  )
    {
        dr = DRM_SUCCESS;
    }
    return dr;
}


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmbase64.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>

ENTER_PK_NAMESPACE_CODE;

#define CCH_B64_IN_QUARTET  4
#define CB_B64_OUT_TRIO     3

static const DRM_BYTE   g_rgbBase64Decode [] = 
{ 
    /* Note we also accept ! and + interchangably. */
    /* Note we also accept * and / interchangably. */
    TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), /*   0 -   7 */
    TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), /*   8 -  15 */
    TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), /*  16 -  23 */
    TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), /*  24 -  31 */
    TWO_BYTES(0x00, 0x3E), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), /*  32 -  39 */
    TWO_BYTES(0x00, 0x00), TWO_BYTES(0x3f, 0x3e), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x3f), /*  40 -  47 */
    TWO_BYTES(0x34, 0x35), TWO_BYTES(0x36, 0x37), TWO_BYTES(0x38, 0x39), TWO_BYTES(0x3a, 0x3b), /*  48 -  55 */
    TWO_BYTES(0x3c, 0x3d), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), /*  56 -  63 */
    TWO_BYTES(0x00, 0x00), TWO_BYTES(0x01, 0x02), TWO_BYTES(0x03, 0x04), TWO_BYTES(0x05, 0x06), /*  64 -  71 */
    TWO_BYTES(0x07, 0x08), TWO_BYTES(0x09, 0x0a), TWO_BYTES(0x0b, 0x0c), TWO_BYTES(0x0d, 0x0e), /*  72 -  79 */
    TWO_BYTES(0x0f, 0x10), TWO_BYTES(0x11, 0x12), TWO_BYTES(0x13, 0x14), TWO_BYTES(0x15, 0x16), /*  80 -  87 */
    TWO_BYTES(0x17, 0x18), TWO_BYTES(0x19, 0x00), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), /*  88 -  95 */
    TWO_BYTES(0x00, 0x1a), TWO_BYTES(0x1b, 0x1c), TWO_BYTES(0x1d, 0x1e), TWO_BYTES(0x1f, 0x20), /*  96 - 103 */
    TWO_BYTES(0x21, 0x22), TWO_BYTES(0x23, 0x24), TWO_BYTES(0x25, 0x26), TWO_BYTES(0x27, 0x28), /* 104 - 111 */
    TWO_BYTES(0x29, 0x2a), TWO_BYTES(0x2b, 0x2c), TWO_BYTES(0x2d, 0x2e), TWO_BYTES(0x2f, 0x30), /* 112 - 119 */
    TWO_BYTES(0x31, 0x32), TWO_BYTES(0x33, 0x00), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00)  /* 120 - 127 */
};

static const DRM_DWORD g_cbBase64Decode = SIZEOF( g_rgbBase64Decode );

/* when decode in-place, the decoded string will be the start of the input buffer */

const DRM_DWORD g_fDecodeAllowed = DRM_BASE64_DECODE_IN_PLACE; /* OR in any new supported flags */

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_B64_DecodeW(
    IN const DRM_CONST_STRING *f_pdstrSource,
    IN OUT   DRM_DWORD        *f_pcbDestination, 
    __out_bcount_opt( *f_pcbDestination ) DRM_BYTE *f_pbDestination,
    IN       DRM_DWORD         f_fFlags)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  cchDecode = 0;    
    DRM_DWORD  ichSource = 0;
    DRM_DWORD  ibInsert  = 0;
    DRM_DWORD  ibDest    = 0;
    
    ChkDRMString(f_pdstrSource);
    ChkArg     ((f_pdstrSource->cchString  % CCH_B64_IN_QUARTET) == 0);
    ChkArg      (f_pcbDestination != NULL);
    ChkArg     ((f_fFlags & ~g_fDecodeAllowed) == 0);

    /* Maximum buffer size needed.     */

    cchDecode = (DRM_DWORD) (((f_pdstrSource->cchString + (CCH_B64_IN_QUARTET - 1)) / CCH_B64_IN_QUARTET) * CB_B64_OUT_TRIO); 

    if (f_pdstrSource->pwszString [f_pdstrSource->cchString  - 1] == g_wchEqual)
    {
        cchDecode--;
        if (f_pdstrSource->pwszString [f_pdstrSource->cchString  - 2] == g_wchEqual)
        {
            cchDecode--;
        }
    }

    if (((cchDecode > *f_pcbDestination) 
       || f_pbDestination == NULL) 
    && (f_fFlags & DRM_BASE64_DECODE_IN_PLACE) == 0)
    {
        *f_pcbDestination = cchDecode;
        ChkDR(DRM_E_BUFFERTOOSMALL);
    }    

    if (f_fFlags & DRM_BASE64_DECODE_IN_PLACE )
    {
        f_pbDestination = (DRM_BYTE *) f_pdstrSource->pwszString;
        ibInsert        = (f_pdstrSource->cchString * SIZEOF(DRM_WCHAR)) - cchDecode;
    }

    *f_pcbDestination = cchDecode;

    for (ichSource  = f_pdstrSource->cchString; 
         ichSource  > 0; 
         ichSource -= CCH_B64_IN_QUARTET)
    {   
        DRM_BYTE  rgbOutput [__CB_DECL(CB_B64_OUT_TRIO + 1)] = { 0 };
        DRM_DWORD iBase64Decode                              = 0;

        for (ibDest = 0; 
             ibDest < CB_B64_OUT_TRIO + 1; 
             ibDest++ )
        {
            if (f_pdstrSource->pwszString [ichSource + ibDest - CCH_B64_IN_QUARTET] == g_wchEqual)
            {
                if (ibDest     < 2 
                 || ichSource != f_pdstrSource->cchString)
                {
                    ChkDR (DRM_E_INVALIDARG);
                }
                break;
            }

            iBase64Decode = (DRM_DWORD) NATIVE_WCHAR(f_pdstrSource->pwszString [((ichSource - CCH_B64_IN_QUARTET) + ibDest)]);

            if ( iBase64Decode >= g_cbBase64Decode )
            {
                /*
                ** The index is larger than the size of g_rgbBase64Decode and
                ** should not be used as an index into g_rgbBase64Decode.  The 
                ** string may have been base64Encoded incorrectly.
                */
                ChkDR (DRM_E_INVALIDARG);
            }

            PUT_BYTE( rgbOutput, 
                      ibDest,  
                      GET_BYTE(g_rgbBase64Decode, iBase64Decode ) );
        }

        switch (ibDest)
        {
        default: 
            PUT_BYTE(f_pbDestination, 
                     ibInsert  + --cchDecode, 
                     ((GET_BYTE(rgbOutput, 2) & 0x03) << 6) |   GET_BYTE(rgbOutput, 3));
            
            /*fall through*/
            
        case 3:  
            PUT_BYTE(f_pbDestination, 
                     ibInsert  + --cchDecode, 
                     ((GET_BYTE(rgbOutput, 1) & 0x0F) << 4) | ((GET_BYTE(rgbOutput, 2) & 0x3C) >> 2));
            
            /*fall through*/
            
        case 2:  
            PUT_BYTE(f_pbDestination, 
                     ibInsert  + --cchDecode, 
                      (GET_BYTE(rgbOutput, 0)         << 2) | ((GET_BYTE(rgbOutput, 1) & 0x30) >> 4));
        }
    }

    /* move the buffer to start of input buffer */
    if (f_fFlags & DRM_BASE64_DECODE_IN_PLACE)
    {
        DRM_BYT_MoveBytes((DRM_BYTE *) f_pdstrSource->pwszString, 
                           0,
                           f_pbDestination,
                           ibInsert,
                          *f_pcbDestination);
    }

    dr = DRM_SUCCESS;
    
ErrorExit:
    return dr;
}  

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_B64_DecodeA(
    __in_ecount( f_pdasstrSource->m_ich + f_pdasstrSource->m_cch ) const DRM_CHAR *f_pszBase,
    IN const DRM_SUBSTRING         *f_pdasstrSource,
    IN OUT DRM_DWORD *f_pcbDestination, 
    __out_bcount_opt( ( f_fFlags & DRM_BASE64_DECODE_IN_PLACE ) == 0 ? *f_pcbDestination : f_pdasstrSource->m_ich + *f_pcbDestination ) DRM_BYTE *f_pbDestination,
    IN       DRM_DWORD              f_fFlags)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  cchDecode = 0;    
    DRM_DWORD  ichSource = 0; 
    DRM_DWORD  ichDest   = 0;
    DRM_DWORD  ibDest    = 0;
    
    ChkArg(f_pdasstrSource  != NULL);    
    ChkArg(f_pcbDestination != NULL);
    ChkArg((f_pdasstrSource->m_cch % CCH_B64_IN_QUARTET) == 0);
    ChkArg((f_fFlags & ~g_fDecodeAllowed) == 0);
    ChkArg( f_pdasstrSource->m_cch > 0 );

    cchDecode = (DRM_DWORD) (((f_pdasstrSource->m_cch + (CCH_B64_IN_QUARTET - 1)) / CCH_B64_IN_QUARTET) * CB_B64_OUT_TRIO); /* Maximum buffer size needed.     */

    if (GET_CHAR(f_pszBase,     f_pdasstrSource->m_ich + f_pdasstrSource->m_cch  - 1) == '=')
    {
        cchDecode--;
        if (GET_CHAR(f_pszBase, f_pdasstrSource->m_ich + f_pdasstrSource->m_cch  - 2) == '=')
        {
            cchDecode--;
        }
    }

    if (((cchDecode > *f_pcbDestination) 
       || f_pbDestination == NULL) 
    && (f_fFlags & DRM_BASE64_DECODE_IN_PLACE) == 0)
    {
        *f_pcbDestination = cchDecode;
        ChkDR (DRM_E_BUFFERTOOSMALL);
    }    

    if (f_fFlags & DRM_BASE64_DECODE_IN_PLACE )
    {
        ichDest = f_pdasstrSource->m_ich
                + f_pdasstrSource->m_cch
                - cchDecode;
        
        f_pbDestination = (DRM_BYTE *) f_pszBase;
    }

    *f_pcbDestination = cchDecode;

    for (ichSource  = f_pdasstrSource->m_cch; 
         ichSource  > 0; 
         ichSource -= CCH_B64_IN_QUARTET)
    {   
        DRM_BYTE  rgbOutput [__CB_DECL(CB_B64_OUT_TRIO + 1)] = { 0 };
        DRM_DWORD iBase64Decode                              = 0;

        for (ibDest = 0; 
             ibDest < CB_B64_OUT_TRIO + 1; 
             ibDest++ )
        {
            DRM_DWORD ichGet = f_pdasstrSource->m_ich + ichSource + ibDest - CCH_B64_IN_QUARTET;
            if (GET_CHAR(f_pszBase, ichGet) == '=')
            {
                if (ibDest     < 2 
                ||  ichSource != f_pdasstrSource->m_cch)
                {
                    ChkDR (DRM_E_INVALIDARG);
                }
                break;
            }

            iBase64Decode = (DRM_DWORD) GET_CHAR(f_pszBase, ichGet);
            if ( iBase64Decode >= g_cbBase64Decode )
            {
                /*
                ** The index is larger than the size of g_rgbBase64Decode and
                ** should not be used as an index into g_rgbBase64Decode.  The
                ** string may have been base64Encoded incorrectly.
                */
                ChkDR (DRM_E_INVALIDARG);
            }

            PUT_BYTE( rgbOutput, 
                      ibDest,  
                      GET_BYTE(g_rgbBase64Decode, iBase64Decode ) );
        }

        switch (ibDest)
        {
        default: 
            PUT_BYTE(f_pbDestination, 
                     ichDest + --cchDecode, 
                     ((GET_BYTE(rgbOutput, 2) & 0x03) << 6) | GET_BYTE(rgbOutput, 3));
            
            /*fall through*/
            
        case 3:  
            PUT_BYTE(f_pbDestination, 
                     ichDest + --cchDecode, 
                     ((GET_BYTE(rgbOutput, 1) & 0x0F) << 4) | ((GET_BYTE(rgbOutput, 2) &0x3C) >> 2));
            
            /*fall through*/
            
        case 2:  
            PUT_BYTE(f_pbDestination, 
                     ichDest + --cchDecode, 
                     (GET_BYTE(rgbOutput, 0) << 2) | ((GET_BYTE(rgbOutput, 1) & 0x30) >> 4));
        }
    }

    /* move the buffer to start of input buffer */
    if( f_fFlags & DRM_BASE64_DECODE_IN_PLACE )
    {
        ChkBOOL( f_pdasstrSource->m_cch >= *f_pcbDestination, DRM_E_INVALIDARG );
        
        DRM_BYT_MoveBytes(f_pbDestination, f_pdasstrSource->m_ich, f_pbDestination, ichDest, *f_pcbDestination);
    }

    dr = DRM_SUCCESS;
    
ErrorExit:
    return dr;
}  


static const DRM_CHAR g_rgchBase64Encoding[] = {
    TWO_BYTES('A', 'B'), TWO_BYTES('C', 'D'), TWO_BYTES('E', 'F'), TWO_BYTES('G', 'H'), TWO_BYTES('I', 'J'), TWO_BYTES('K', 'L'), /* 12 */
    TWO_BYTES('M', 'N'), TWO_BYTES('O', 'P'), TWO_BYTES('Q', 'R'), TWO_BYTES('S', 'T'), TWO_BYTES('U', 'V'), TWO_BYTES('W', 'X'), /* 24 */
    TWO_BYTES('Y', 'Z'), TWO_BYTES('a', 'b'), TWO_BYTES('c', 'd'), TWO_BYTES('e', 'f'), TWO_BYTES('g', 'h'), TWO_BYTES('i', 'j'), /* 36 */
    TWO_BYTES('k', 'l'), TWO_BYTES('m', 'n'), TWO_BYTES('o', 'p'), TWO_BYTES('q', 'r'), TWO_BYTES('s', 't'), TWO_BYTES('u', 'v'), /* 48 */
    TWO_BYTES('w', 'x'), TWO_BYTES('y', 'z'), TWO_BYTES('0', '1'), TWO_BYTES('2', '3'), TWO_BYTES('4', '5'), TWO_BYTES('6', '7'), /* 60 */
    TWO_BYTES('8', '9'), TWO_BYTES('!', '*')            /* 64 */
};

static const DRM_CHAR g_rgchBase64EncodingStandard[] = {
    TWO_BYTES('A', 'B'), TWO_BYTES('C', 'D'), TWO_BYTES('E', 'F'), TWO_BYTES('G', 'H'), TWO_BYTES('I', 'J'), TWO_BYTES('K', 'L'), /* 12 */
    TWO_BYTES('M', 'N'), TWO_BYTES('O', 'P'), TWO_BYTES('Q', 'R'), TWO_BYTES('S', 'T'), TWO_BYTES('U', 'V'), TWO_BYTES('W', 'X'), /* 24 */
    TWO_BYTES('Y', 'Z'), TWO_BYTES('a', 'b'), TWO_BYTES('c', 'd'), TWO_BYTES('e', 'f'), TWO_BYTES('g', 'h'), TWO_BYTES('i', 'j'), /* 36 */
    TWO_BYTES('k', 'l'), TWO_BYTES('m', 'n'), TWO_BYTES('o', 'p'), TWO_BYTES('q', 'r'), TWO_BYTES('s', 't'), TWO_BYTES('u', 'v'), /* 48 */
    TWO_BYTES('w', 'x'), TWO_BYTES('y', 'z'), TWO_BYTES('0', '1'), TWO_BYTES('2', '3'), TWO_BYTES('4', '5'), TWO_BYTES('6', '7'), /* 60 */
    TWO_BYTES('8', '9'), TWO_BYTES('+', '/')            /* 64 */
};

/*
**
*/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_B64_EncodeA( 
    __in_bcount( f_cbSource ) const DRM_BYTE  *f_pbSource,  /* input buffer */
    IN       DRM_DWORD  f_cbSource,  /* input len */
    __out_ecount_opt( *f_pcchEncoded ) DRM_CHAR *f_pszB64,    /* output char */
    IN OUT   DRM_DWORD *f_pcchEncoded, /* output ch len */
    IN       DRM_DWORD  f_fFlags )
{
    DRM_DWORD cchRequired = 0;
    DRM_DWORD iInput      = 0;
    DRM_DWORD iOutput     = 0;
    DRM_RESULT dr         = DRM_SUCCESS;
    const DRM_CHAR *pszMapping = NULL;

    /*
    ** Null input buffer, null output size pointer, and a nonzero
    ** encoded size with a null output buffer are all invalid
    ** parameters.
    **
    ** Check the size first so that caller can allocate enough output buffer before generating 
    ** the input buffer.
    */

    ChkArg(f_cbSource     > 0
        && f_pbSource    != NULL
        && f_pcchEncoded != NULL);

    if (f_fFlags == 0)
    {
        pszMapping = g_rgchBase64EncodingStandard;
    }
    else if (f_fFlags & DRM_BASE64_ENCODE_WMDRM)
    {
        pszMapping = g_rgchBase64Encoding;
    }
    else
    {
        ChkDR(DRM_E_INVALIDARG);
    }

    cchRequired = CCH_BASE64_EQUIV(f_cbSource);
    
    /* if the buffer is too small or both buffers are NULL, we return the required buffer size */
    
    if ((*f_pcchEncoded < cchRequired) 
    ||    f_pszB64     == NULL)
    {
        *f_pcchEncoded = cchRequired;
        ChkDR(DRM_E_BUFFERTOOSMALL);
    }

    *f_pcchEncoded = cchRequired;

    /* encoding starts from end of string */

    /*
    ** Convert the input buffer bytes through the encoding table and
    ** out into the output buffer.
    */
    iInput  = (cchRequired / CCH_B64_IN_QUARTET) * CB_B64_OUT_TRIO - CB_B64_OUT_TRIO;
    iOutput =  cchRequired - CCH_B64_IN_QUARTET;

    while (TRUE) 
    {
        const DRM_BYTE uc0 =                               GET_BYTE(f_pbSource, iInput);
        const DRM_BYTE uc1 = ((iInput + 1) < f_cbSource) ? GET_BYTE(f_pbSource, iInput + 1) : 0;
        const DRM_BYTE uc2 = ((iInput + 2) < f_cbSource) ? GET_BYTE(f_pbSource, iInput + 2) : 0;

        PUT_BYTE(f_pszB64, iOutput,     GET_BYTE(pszMapping,   uc0 >> 2));
        PUT_BYTE(f_pszB64, iOutput + 1, GET_BYTE(pszMapping, ((uc0 << 4) & 0x30) | ((uc1 >> 4) & 0xf)));
        PUT_BYTE(f_pszB64, iOutput + 2, GET_BYTE(pszMapping, ((uc1 << 2) & 0x3c) | ((uc2 >> 6) & 0x3)));
        PUT_BYTE(f_pszB64, iOutput + 3, GET_BYTE(pszMapping,                               uc2 & 0x3f));
        
        if (iInput ==0)
        {
            break;
        }

        iOutput -= CCH_B64_IN_QUARTET;
        iInput  -= CB_B64_OUT_TRIO;
    }

    /*
    ** Fill in leftover bytes at the end
    */
    switch (f_cbSource % CB_B64_OUT_TRIO) 
    {
        /*
        ** One byte out of three, add padding and fall through
        */
        case 1:
            PUT_CHAR(f_pszB64, cchRequired - 2,  '=');
        /*
        ** Two bytes out of three, add padding.
        */
        case 2:
            PUT_CHAR(f_pszB64, cchRequired - 1,  '=');
            
            break;
        case 0:
        default:
            break;
    }

    dr = DRM_SUCCESS;
    
ErrorExit:
    return dr;
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_B64_EncodeW( 
    __in_bcount( f_cbSource ) const DRM_BYTE *f_pbSource,    /* input buffer */
    IN                                   DRM_DWORD        f_cbSource,    /* input len */
    __out_ecount_opt( *f_pcchEncoded ) DRM_WCHAR *f_pwszEncoded, /* output WCHAR */
    IN OUT                               DRM_DWORD       *f_pcchEncoded, /* output ch len */
    IN                                   DRM_DWORD        f_dwFlags )
{
    DRM_DWORD cchRequired = 0;
    DRM_DWORD iInput      = 0;
    DRM_DWORD iOutput     = 0;
    DRM_RESULT dr         = DRM_SUCCESS;
    const DRM_CHAR *pszMapping = NULL;

    /*
    ** Null input buffer, null output size pointer, and a nonzero
    ** encoded size with a null output buffer are all invalid
    ** parameters.
    **
    ** Check the size first so that caller can allocate enough output buffer before generating 
    ** the input buffer.
    */

    ChkArg(f_cbSource     > 0
        && f_pbSource    != NULL
        && f_pcchEncoded != NULL);

    if (f_dwFlags == 0)
    {
        pszMapping = g_rgchBase64EncodingStandard;
    }
    else if (f_dwFlags & DRM_BASE64_ENCODE_WMDRM)
    {
        pszMapping = g_rgchBase64Encoding;
    }
    else
    {
        ChkDR(DRM_E_INVALIDARG);
    }

    cchRequired = CCH_BASE64_EQUIV(f_cbSource);
    
    /* if the buffer is too small or both buffers are NULL, we return the required buffer size */
    
    if ((*f_pcchEncoded < cchRequired) 
    ||    f_pwszEncoded == NULL)
    {
        *f_pcchEncoded = cchRequired;
        ChkDR(DRM_E_BUFFERTOOSMALL);
    }

    *f_pcchEncoded = cchRequired;

    /* encoding starts from end of string */

    /*
    ** Convert the input buffer bytes through the encoding table and
    ** out into the output buffer.
    */
    iInput  = (cchRequired / CCH_B64_IN_QUARTET) * CB_B64_OUT_TRIO - CB_B64_OUT_TRIO;
    iOutput =  cchRequired - CCH_B64_IN_QUARTET;

    while (TRUE) 
    {
        const DRM_BYTE uc0 =                               GET_BYTE(f_pbSource, iInput);
        const DRM_BYTE uc1 = ((iInput + 1) < f_cbSource) ? GET_BYTE(f_pbSource, iInput + 1) : 0;
        const DRM_BYTE uc2 = ((iInput + 2) < f_cbSource) ? GET_BYTE(f_pbSource, iInput + 2) : 0;

        f_pwszEncoded[iOutput]     = WCHAR_CAST(GET_BYTE(pszMapping,   uc0 >> 2));
        f_pwszEncoded[iOutput + 1] = WCHAR_CAST(GET_BYTE(pszMapping, ((uc0 << 4) & 0x30) | ((uc1 >> 4) & 0xf)));
        f_pwszEncoded[iOutput + 2] = WCHAR_CAST(GET_BYTE(pszMapping, ((uc1 << 2) & 0x3c) | ((uc2 >> 6) & 0x3)));
        f_pwszEncoded[iOutput + 3] = WCHAR_CAST(GET_BYTE(pszMapping,                               uc2 & 0x3f));

        if (iInput ==0)
        {
            break;
        }

        iOutput -= CCH_B64_IN_QUARTET;
        iInput  -= CB_B64_OUT_TRIO;
    }

    /*
    ** Fill in leftover bytes at the end
    */
    switch (f_cbSource % CB_B64_OUT_TRIO) 
    {
        /*
        ** One byte out of three, add padding and fall through
        */
        case 1:
            f_pwszEncoded[cchRequired - 2] = g_wchEqual;
            
        /*
        ** Two bytes out of three, add padding.
        */
        case 2:
            f_pwszEncoded[cchRequired - 1] = g_wchEqual;
            
            break;
        case 0:
        default:
            break;
    }

    dr = DRM_SUCCESS;
    
ErrorExit:
    return dr;
}


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmbytemanip.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmtypes.h>
#include <drmbytemanip.h>
#include <drmcrt.h>

ENTER_PK_NAMESPACE_CODE;


DRM_API DRM_NO_INLINE DRM_VOID DRM_CALL DRM_BYT_ReverseBytes(
    __inout_bcount(cbData)  DRM_BYTE  *pbData,
    IN                      DRM_DWORD  cbData )
{
    DRM_BYTE bTemp;
    DRM_DWORD i;
    
    if( cbData < 2 )
    {
        return;
    }
    
    cbData--;
    for( i=0; i<cbData; i++,cbData-- )
    {
        bTemp = GET_BYTE(pbData, i);
        PUT_BYTE(pbData, i, GET_BYTE(pbData, cbData));
        PUT_BYTE(pbData, cbData, bTemp);
    }
}

#if SIXTEEN_BIT_ADDRESSING

DRM_API DRM_VOID DRM_CALL DRM_BYT_CopyBytes( 
     __out_ecount( f_ibTo + f_cb ) DRM_VOID *f_pbTo, 
    IN       DRM_DWORD f_ibTo, 
    __in_ecount( f_ibFrom + f_cb ) const DRM_VOID *f_pbFrom,
    IN       DRM_DWORD f_ibFrom,
    IN       DRM_DWORD f_cb )
{
    DRM_BYTE *pbTo   = (DRM_BYTE*) f_pbTo;
    DRM_BYTE *pbFrom = (DRM_BYTE*) f_pbFrom;

    if( !ISODD(f_ibTo)
     && !ISODD(f_ibFrom) )
    {
        /*
        ** Offsets are both even just use memcpy
        */
        memcpy( pbTo   + (f_ibTo   / CB_NATIVE_BYTE), 
                pbFrom + (f_ibFrom / CB_NATIVE_BYTE), 
                f_cb / CB_NATIVE_BYTE );
        if( ISODD(f_cb) )
        {
            /*
            ** Copy the last odd byte
            */
            PUT_BYTE(pbTo, f_ibTo+(f_cb-1), GET_BYTE( pbFrom, f_ibFrom+(f_cb-1) ) );
        }
    }
    else if( ISODD(f_ibTo)
          && ISODD(f_ibFrom) )
    {
        /*
        ** Offsets are both odd.  
        ** 1. Put the first byte in the right place
        ** 2. Use memcpy for all bytes 1 to f_cb/2
        ** 3. If there is a dangling byte write that at the end
        */
        PUT_BYTE(pbTo, f_ibTo, GET_BYTE( pbFrom, f_ibFrom) );
        f_cb--;
        if( f_cb >= CB_NATIVE_BYTE )
        {
            memcpy( pbTo   + ((f_ibTo+1)   / CB_NATIVE_BYTE), 
                    pbFrom + ((f_ibFrom+1) / CB_NATIVE_BYTE), 
                    f_cb / CB_NATIVE_BYTE );
        }
        if( ISODD(f_cb) )
        {
            /*
            ** Copy the last odd byte (note that f_cp has previously been decremented)
            */
            PUT_BYTE(pbTo, f_ibTo+f_cb, GET_BYTE( pbFrom, f_ibFrom+f_cb ) );
        }
    }
    else
    {
        /*
        ** The input offset and output offset are unfortuantly not both even or both odd.
        ** This means that each byte must be independantly shifted from one to another
        */
        for( ; f_cb > 0; f_cb--, f_ibTo++, f_ibFrom++ )
        {
            PUT_BYTE(pbTo, f_ibTo, GET_BYTE( pbFrom, f_ibFrom ) );
        }
    }
}

DRM_API DRM_VOID DRM_CALL DRM_BYT_MoveBytes( 
     __out_ecount( f_ibTo + f_cb ) DRM_VOID *f_pbTo, 
    IN       DRM_DWORD f_ibTo, 
    __in_ecount( f_ibFrom + f_cb ) const DRM_VOID *f_pbFrom,
    IN       DRM_DWORD f_ibFrom,
    IN       DRM_DWORD f_cb )
{
    DRM_BYTE *pbTo   = (DRM_BYTE*) f_pbTo;
    DRM_BYTE *pbFrom = (DRM_BYTE*) f_pbFrom;

    if( ( ((DRM_DWORD)f_pbTo * CB_NATIVE_BYTE) + f_ibTo )
        - ( ((DRM_DWORD)f_pbFrom * CB_NATIVE_BYTE) + f_ibFrom ) < f_cb )
    {
        /* The source and destination overlap, */
        /* and the destination is later in memory than the source */

        f_ibTo += f_cb - 1;
        f_ibFrom += f_cb - 1;

        for( ; f_cb > 0; f_cb--, f_ibTo--, f_ibFrom-- )
        {
            PUT_BYTE(pbTo, f_ibTo, GET_BYTE( pbFrom, f_ibFrom ) );
        }
    }
    else if( ( ((DRM_DWORD)f_pbFrom * CB_NATIVE_BYTE) + f_ibFrom )
        - ( ((DRM_DWORD)f_pbTo * CB_NATIVE_BYTE) + f_ibTo ) < f_cb )
    {
        /* The source and destination overlap, */
        /* and the source is later in memory than the destination */
        
        for( ; f_cb > 0; f_cb--, f_ibTo++, f_ibFrom++ )
        {
            PUT_BYTE(pbTo, f_ibTo, GET_BYTE( pbFrom, f_ibFrom ) );
        }
    }
    else if( !ISODD(f_ibTo)
     && !ISODD(f_ibFrom) )
    {
        /*
        ** Offsets are both even just use memcpy
        */
        memmove(pbTo   + (f_ibTo   / CB_NATIVE_BYTE), 
                pbFrom + (f_ibFrom / CB_NATIVE_BYTE), 
                f_cb / CB_NATIVE_BYTE );
        if( ISODD(f_cb) )
        {
            /*
            ** Copy the last odd byte
            */
            PUT_BYTE(pbTo, f_ibTo+(f_cb-1), GET_BYTE( pbFrom, f_ibFrom+(f_cb-1) ) );
        }
    }
    else if( ISODD(f_ibTo)
          && ISODD(f_ibFrom) )
    {
        /*
        ** Offsets are both odd.  
        ** 1. Put the first byte in the right place
        ** 2. Use memcpy for all bytes 1 to f_cb/2
        ** 3. If there is a dangling byte write that at the end
        */
        PUT_BYTE(pbTo, f_ibTo, GET_BYTE( pbFrom, f_ibFrom) );
        f_cb--;
        if( f_cb >= CB_NATIVE_BYTE )
        {
            memmove( pbTo   + ((f_ibTo+1)   / CB_NATIVE_BYTE), 
                     pbFrom + ((f_ibFrom+1) / CB_NATIVE_BYTE), 
                     f_cb / CB_NATIVE_BYTE  );
        }
        if( ISODD(f_cb) )
        {
            /*
            ** Copy the last odd byte (note that f_cp has previously been decremented)
            */
            PUT_BYTE(pbTo, f_ibTo+f_cb, GET_BYTE( pbFrom, f_ibFrom+f_cb ) );
        }
    }
    else
    {
        /*
        ** The input offset and output offset are unfortuantly not both even or both odd.
        ** This means that each byte must be independantly shifted from one to another
        */
        for( ; f_cb > 0; f_cb--, f_ibTo++, f_ibFrom++ )
        {
            PUT_BYTE(pbTo, f_ibTo, GET_BYTE( pbFrom, f_ibFrom ) );
        }
    }
}

DRM_API DRM_VOID DRM_CALL DRM_BYT_SetBytes(
    __out_ecount( f_ib + f_cb ) DRM_VOID *f_pb,
    IN     DRM_DWORD f_ib,
    IN     DRM_DWORD f_cb,
    IN     DRM_BYTE  f_b )
{
    DRM_BYTE *pb = (DRM_BYTE*) f_pb;
    DRM_DWORD cb = 0;
    if( ISODD(f_ib) )
    {
        /*
        ** Offset is odd.  Set the first bit before calling memset
        */
        PUT_BYTE( pb, f_ib, f_b );
        f_cb--;
        f_ib++;
    }
    
    cb = f_cb / CB_NATIVE_BYTE;
    
    DRMCRT_memset( pb + (f_ib / CB_NATIVE_BYTE), MAKE_MACHINE_BYTE(f_b,f_b), cb );
    
    f_ib += cb * CB_NATIVE_BYTE;
    if( ISODD(f_cb) )
    {
        /*
        ** Copy the last odd byte
        */
        PUT_BYTE(pb, f_ib, f_b );
    }
}

DRM_API DRM_INT DRM_CALL DRM_BYT_CompareBytes(
    __in_ecount( f_ibA + f_cb ) const DRM_VOID *f_pbA,
    IN       DRM_DWORD f_ibA,
    __in_ecount( f_ibB + f_cb ) const DRM_VOID *f_pbB,
    IN       DRM_DWORD f_ibB,
    IN       DRM_DWORD f_cb )
{
    DRM_INT iResult = 0;
    DRM_NATIVE_BYTE bA     = 0;
    DRM_NATIVE_BYTE bB     = 0;
    DRM_BYTE *pbA = (DRM_BYTE*) f_pbA;
    DRM_BYTE *pbB = (DRM_BYTE*) f_pbB;

    if( !ISODD(f_ibA)
     && !ISODD(f_ibB) )
    {
        /*
        ** Offsets are both even just use memcmp
        */
        iResult = memcmp( pbA + (f_ibA / CB_NATIVE_BYTE), 
                          pbB + (f_ibB / CB_NATIVE_BYTE), 
                          f_cb / CB_NATIVE_BYTE );
        if( iResult == 0 
         && ISODD(f_cb) )
        {
            /*
            ** Compare the last odd bytes if needed
            */
            bA = GET_BYTE( pbA, f_ibA+(f_cb-1) );
            bB = GET_BYTE( pbB, f_ibB+(f_cb-1) );
            if( bA == bB )
            {
                iResult = 0;
            }
            else if( bA > bB )
            {
                iResult = 1;
            }
            else
            {
                iResult = -1;
            }
        }
    }
    else if( ISODD(f_ibA)
          && ISODD(f_ibB) )
    {
        /*
        ** Offsets are both odd.  
        ** 1. Compare the first byte
        ** 2. Use memcmp for all bytes 1 to f_cb/2
        ** 3. If there is a dangling byte at the end compare that one
        */
        bA = GET_BYTE( pbA, f_ibA);
        bB = GET_BYTE( pbB, f_ibB);

        if( bA == bB )
        {
            iResult = 0;
        }
        else if( bA > bB )
        {
            iResult = 1;
        }
        else
        {
            iResult = -1;
        }

        if( iResult == 0 )
        {
            f_cb--;
            if( f_cb >= CB_NATIVE_BYTE )
            {
                iResult = memcmp( pbA + ((f_ibA+1) / CB_NATIVE_BYTE),
                                  pbB + ((f_ibB+1) / CB_NATIVE_BYTE),
                                  f_cb / CB_NATIVE_BYTE );
            }
            if( iResult == 0
             && ISODD(f_cb) )
            {
                /*
                ** Compare the last odd byte (note that f_cp has previously been decremented)
                */
                bA = GET_BYTE( pbA, f_ibA+f_cb );
                bB = GET_BYTE( pbB, f_ibB+f_cb );
                if( bA == bB )
                {
                    iResult = 0;
                }
                else if( bA > bB )
                {
                    iResult = 1;
                }
                else
                {
                    iResult = -1;
                }
            }
        }
    }
    else
    {
        /*
        ** The input offset and output offset are unfortuantly not both even or both odd.
        ** This means that each byte must be independantly compared
        */
        for( ; f_cb > 0; f_cb--, f_ibA++, f_ibB++ )
        {
            bA = GET_BYTE( pbA, f_ibA );
            bB = GET_BYTE( pbB, f_ibB );
            if( bA == bB )
            {
                iResult = 0;
            }
            else if( bA > bB )
            {
                iResult = 1;
                break;
            }
            else
            {
                iResult = -1;
                break;
            }
        }
    }

    return iResult;
}



/*********************************************************************
**  Function: DRM_16B_Read8BitByte
**              
**  Synopsis:  allow one-byte quantities to by read on
**             architectures that cannot address them.  
**
**  Arguments:  
**     [f_pv]  -- buffer to read with 8-bit bytes
**     [f_ib]  -- index of the 8-bit byte to read
*********************************************************************/

DRM_API DRM_NATIVE_BYTE DRM_CALL DRM_16B_Read8BitByte(
    __in_ecount( f_ib / CB_NATIVE_BYTE ) const DRM_VOID  *f_pv,
    IN        DRM_DWORD  f_ib)
{
    DRM_NATIVE_BYTE bNative = 0;
    
    DRMCASSERT(CB_NATIVE_BYTE == 2);

    /* read the MB-sized word containing the sought byte */

    bNative = ((DRM_NATIVE_BYTE *) f_pv) [f_ib / CB_NATIVE_BYTE];

    /* shift the sought byte into the LSB */

    bNative >>= (8 * ( (f_ib+1) % CB_NATIVE_BYTE));
    
    /* mask off the other bytes */
    
    bNative &= ((DRM_NATIVE_BYTE) 0xFF);

    return bNative;
}

/*********************************************************************
**  Function: DRM_16B_Write8BitByte
**              
**  Synopsis:  allow one-byte quantities to by written on
**             architectures that cannot address them.  
**
**  Arguments:  
**     [f_pv]  -- buffer to write with 8-bit bytes
**     [f_ib]  -- index of the byte to write
**     [f_mb]  -- machine byte to write into the address
**
** Note: the other 8-bit byte in the 16-bit byte being written is
**       preserved
*********************************************************************/

DRM_API DRM_VOID DRM_CALL DRM_16B_Write8BitByte(
    __out_ecount( f_ib / CB_NATIVE_BYTE ) DRM_VOID *f_pv,
    IN  DRM_DWORD        f_ib,
    IN  DRM_NATIVE_BYTE  f_mb)
{
    DRM_NATIVE_BYTE bNative = 0;
    DRM_NATIVE_BYTE bMask   = 0xFF;

    DRMCASSERT((CB_NATIVE_BYTE == 2));

    /* shift the LSB into the target position in the machine word: |0|C| --> |C|0| */

    f_mb  <<= (8 * ((f_ib+1) % CB_NATIVE_BYTE));
    bMask <<= (8 * ((f_ib+1) % CB_NATIVE_BYTE));
    
    /* read to the MB-sized word containing the sought byte: |A|B| */

    bNative = ((DRM_NATIVE_BYTE *) f_pv) [f_ib / CB_NATIVE_BYTE];

    /* mask off the position where the new byte will be written: |A|0| */
    /* compose the two MBs to the new one: |A|0| | |0|C| --> |A|C| */

    bNative &= ~bMask;
    bNative |= f_mb;

    /* write the composed MB */

    ((DRM_NATIVE_BYTE *) f_pv) [f_ib / CB_NATIVE_BYTE] = bNative;
}

/*********************************************************************
**  Functions:  DRM_16B_Read8BitChar
**              DRM_16B_Write8BitChar
**              
**  Synopsis:  signed-char versions of the above
*********************************************************************/

DRM_API DRM_NATIVE_CHAR DRM_CALL DRM_16B_Read8BitChar(
    __in_ecount( f_cb / CB_NATIVE_BYTE ) DRM_VOID *f_pch,
    IN  DRM_DWORD f_ich)
{
    return (DRM_NATIVE_CHAR) DRM_16B_Read8BitByte(f_pch, f_ich);
}

DRM_API DRM_VOID DRM_CALL DRM_16B_Write8BitChar(
    OUT DRM_VOID        *f_pch,
    IN  DRM_DWORD        f_ich,
    IN  DRM_NATIVE_CHAR  f_mch)
{
    DRM_16B_Write8BitByte(f_pch, f_ich, (DRM_NATIVE_BYTE) f_mch);
}

/*********************************************************************
**  Functions:  DRM_16B_Read8BitBytes
**              DRM_16B_Write8BitBytes
**              
**  Synopsis:  allow one-byte streams to by read and written on
**             architectures that cannot read and write them.  
**
**  Arguments:  
**     [f_pv]  -- buffer to read/write with 8-bit bytes
**     [f_cb]  -- number of the bytes to read/write
**     [f_pb]  -- buffer of native machine bytes to read to/write from
*********************************************************************/

DRM_API DRM_VOID DRM_CALL DRM_16B_Read8BitBytes(
    __in_ecount( f_cb / CB_NATIVE_BYTE ) DRM_VOID *f_pv,
    IN  DRM_DWORD        f_cb,
    __out_ecount( f_cb ) DRM_NATIVE_BYTE *f_pb)
{
    DRM_DWORD ib8In       = 0;
    DRM_DWORD ibNativeOut = 0;

    /* read a machine-byte chunk from the 8-bit input stream */

    for (ib8In  = 0; 
         ib8In  < f_cb; 
         ib8In += CB_NATIVE_BYTE)
    {
        DRM_NATIVE_BYTE bNative = ((DRM_NATIVE_BYTE *) f_pv) [ib8In / CB_NATIVE_BYTE];
        
        f_pb [ibNativeOut++] = (bNative & 0x00FF);        

        if (ibNativeOut >= f_cb)
        {
            break;
        }

        f_pb [ibNativeOut++] = (bNative >> 8);        
    }
}

DRM_API DRM_VOID DRM_CALL DRM_16B_Write8BitBytes(
    __out_ecount( f_cb / CB_NATIVE_BYTE ) DRM_VOID *f_pv,
    IN  DRM_DWORD f_cb,
    __in_ecount( f_cb ) DRM_NATIVE_BYTE *f_pb)
{
    DRM_DWORD ibNativeIn = 0;

    for (ibNativeIn  = 0; 
         ibNativeIn  < f_cb; 
         ibNativeIn += CB_NATIVE_BYTE)
    {
        DRM_NATIVE_BYTE bOut = 0;
        
        bOut  = f_pb [ibNativeIn] & 0xFF;
        bOut |= f_pb [ibNativeIn  + 1] << 8;

        ((DRM_NATIVE_BYTE *) f_pv) [ibNativeIn / 2] = bOut;
    }
}

DRM_API DRM_VOID DRM_CALL DRM_16B_Read8BitString(
    __in_ecount( f_cch / CB_NATIVE_BYTE ) DRM_VOID *f_pv,
    IN  DRM_DWORD f_cch,
    __out_ecount( f_cch ) DRM_NATIVE_CHAR *f_pch)
{
    DRM_16B_Read8BitBytes(f_pv, f_cch, (DRM_NATIVE_BYTE *) f_pch);
}    

DRM_API DRM_VOID DRM_CALL DRM_16B_Write8BitString(
    __out_ecount( f_cch / CB_NATIVE_BYTE ) DRM_VOID *f_pv,
    IN  DRM_DWORD f_cch,
    __in_ecount( f_cch ) DRM_NATIVE_CHAR *f_pch)
{
    DRM_16B_Write8BitBytes(f_pv, f_cch, (DRM_NATIVE_BYTE *) f_pch);
}

/*****************************************************************************
** Function: DRM_16B_Pack8BitBytes
**
** Synopsis: Convert an array of 16-bit bytes into an array of 8-bit bytes 
**           packed into the nibbles of a 16-bit array
**
** Arguments:
**           [f_pbNative] -- buffer of 16-bit bytes
**           [f_cbNative] -- size of f_pbNative
**           [f_pvPacked]  -- recipient buffer for packed bytes, NULL to
**                            pack in place
**           [f_fOptions]  -- flags.  The following are supported:
**
**                            DRM_PACK_BYTES_IN_PLACE - use f_pbNative as   
**                                                      the output buffer
*****************************************************************************/

DRM_API DRM_VOID *DRM_CALL DRM_16B_Pack8BitBytes(
    __inout_ecount( f_cbMachine ) DRM_NATIVE_BYTE *f_pbNative,
    DRM_DWORD        f_cbNative,
    __out_ecount_opt( f_cbMachine / CB_NATIVE_BYTE ) DRM_VOID *f_pvPacked,
    DRM_DWORD        f_fOptions)
{
    DRM_DWORD ib     = 0;
    DRM_NATIVE_BYTE *pbOut = NULL;
    
    if (f_pvPacked != NULL)
    {
        DRMASSERT((f_fOptions & DRM_PACK_BYTES_IN_PLACE) == 0);
        
        pbOut = (DRM_NATIVE_BYTE *) f_pvPacked;
    }
    else
    {
        DRMASSERT((f_fOptions & DRM_PACK_BYTES_IN_PLACE) != 0);
        
        pbOut = f_pbNative;
    }
        
    for (ib = 0; ib < f_cbNative; ib += CB_NATIVE_BYTE)
    {
        pbOut [ib / 2] = ((f_pbNative [ib + 1] << 8) | (f_pbNative [ib] & 0xFF));
    }
    
    return (DRM_VOID *) pbOut;
}                                        

/*****************************************************************************
** Function: DRM_16B_IncrementPackedPointer
**
** Synopsis: moves an array of 16-bit byte one nibble to the left, effectively
**           executing a psz++
**
**  |a'b|c'd|e'f| --> |b'c|d'e|f'0| with 'a' returned in f_pbHead
**
** Arguments:
**           [f_pbNative] -- buffer of 16-bit bytes
**           [f_cbNative] -- size of f_pbNative
**           [f_pbHead]    -- optional pointer to BYTE to receive value 
**                            overwritten by the left-shift
**
** Notes: this function changes data and should be reversed with 
**        DRM_16B_DecrementPackedPointer 
*****************************************************************************/

DRM_API DRM_VOID *DRM_CALL DRM_16B_IncrementPackedPointer(
    __inout_ecount( f_cbNative / / CB_NATIVE_BYTE ) DRM_NATIVE_BYTE *f_pbNative,
    IN     DRM_DWORD        f_cbNative,
       OUT DRM_NATIVE_BYTE *f_pbHead)
{
    DRM_DWORD ib = 0;
    
    DRMASSERT(f_pbNative != NULL
           && f_cbNative != 0);
    
    if (f_pbHead != NULL)
    {
        *f_pbHead = GET_BYTE(f_pbNative, 0);
    }
    
    /* repack the remaining string to align with the pointer */
    
    for (ib  = 0; 
         ib  < f_cbNative; 
         ib += CB_NATIVE_BYTE)
    {
        f_pbNative [ib / CB_NATIVE_BYTE] = MAKE_MACHINE_BYTE(GET_BYTE(f_pbNative, ib + 1), 
                                                             GET_BYTE(f_pbNative, ib + 2));
    }
    
    f_pbNative [f_cbNative / CB_NATIVE_BYTE] = MAKE_MACHINE_BYTE(GET_BYTE(f_pbNative, ib + 1), 0);

    return f_pbNative;
}       

/*****************************************************************************
** Function: DRM_16B_DecrementPackedPointer
**
** Synopsis: moves an array of 16-bit byte one nibble to the right, effectively
**           executing a psz--
**
**  |a'b|c'd|e'f| --> |X'a|b'c|d'e| where X is passed in as f_bHead
**
** Arguments:
**           [f_pbNative] -- buffer of 16-bit bytes
**           [f_cbNative] -- size of f_pbNative
**           [f_bHead]     -- BYTE to place at the new first nibble
**
** Notes: this function reverses DRM_16B_IncrementPackedPointer 
*****************************************************************************/

DRM_API DRM_VOID *DRM_CALL DRM_16B_DecrementPackedPointer(
    __inout_ecount( f_cbNative / / CB_NATIVE_BYTE ) DRM_NATIVE_BYTE *f_pbNative,
    IN     DRM_DWORD        f_cbNative,
    IN     DRM_NATIVE_BYTE  f_bHead)
{
    DRM_DWORD        ibNative = 0;
    DRM_NATIVE_BYTE  bCarry   = f_bHead;
    
    DRMASSERT(f_pbNative != NULL
           && f_cbNative != 0);

    /*  |b'c|d'e| and a ---> |a'b|c'd|e'0| */
    
    /* repack the remaining string to align with the pointer */
    
    for (ibNative  = 0; 
         ibNative  < f_cbNative; 
         ibNative += CB_NATIVE_BYTE)
    {
        DRM_NATIVE_BYTE b1 = GET_BYTE(f_pbNative, ibNative + 1);

        f_pbNative [ibNative / CB_NATIVE_BYTE] = MAKE_MACHINE_BYTE(bCarry, 
                                                                   GET_BYTE(f_pbNative, ibNative));
        
        bCarry = b1;
    }
    
    f_pbNative [f_cbNative / CB_NATIVE_BYTE] = MAKE_MACHINE_BYTE(bCarry, 0);

    return f_pbNative;
}       


#endif /* SIXTEEN_BIT_ADDRESSING */ 

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmchkdebug.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include <drmcommon.h>

#if DBG

#pragma prefast(suppress:22110,"g_pfDebugAnalyzeDR is only built in DBG builds and is intended to be a global function pointer.")
void (*g_pfDebugAnalyzeDR)(unsigned long) = NULL;

#endif //DBG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmchain.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmlicenseparser.h>
#if DRM_SUPPORT_APP_REVOCATION || DRM_SUPPORT_DEVICE_REVOCATION || DRM_SUPPORT_REVOCATION
#include <drmrevocation.h>
#endif
#include <drmchain.h>
#include <drmsecureclock.h>
#include <drmxmlparser.h>
#include <drmlicreason.h>
#include <drmdatastore.h>

ENTER_PK_NAMESPACE_CODE;

/******************************************************************************
**
** Function :   _ParseLicenseAttributes
**
** Synopsis :   Parse the license for frequently used attributes
**
** Arguments :  f_pdstrLicense  - License string
**              f_rgpdstrEvents - Array of events to parse
**              f_cEvents       - Count of events to parse
**              f_rgdstrCachedAttribs - Cached attribs
**              f_rgCachedEvents- Cached events
**
** Returns :
**
** Notes :      We can parse the license more optimally if needed.
**
******************************************************************************/
static DRM_RESULT _ParseLicenseAttributes(
    IN          DRM_CONST_STRING    *f_pdstrLicense,
    IN  const   DRM_CONST_STRING    *f_rgpdstrEvents[],
    IN          DRM_DWORD            f_cEvents,
        OUT     DRM_CONST_STRING     f_rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_LAST],
        OUT     DRM_CACHED_EVENT     f_rgCachedEvents[DRM_MAX_ACTIONS] )
{
    DRM_RESULT          dr          = DRM_SUCCESS;
    DRM_CONST_STRING    dstrLIData  = EMPTY_DRM_STRING;
    DRM_DWORD           iEvents     = 0;

    /*
    **  If need be we can try to do better here by doing a single scan of the XML
    */
    ChkDR( DRM_LIC_GetAttribute( f_pdstrLicense,
                                 NULL,
                                 DRM_LICENSE_ATTRIB_KID,
                                 &dstrLIData,
                                 &f_rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_KID],
                                 0 ) );

    ChkDR( DRM_LIC_GetAttribute( f_pdstrLicense,
                                 NULL,
                                 DRM_LICENSE_ATTRIB_LID,
                                 &dstrLIData,
                                 &f_rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_LID],
                                 0 ) );

    dr = DRM_LIC_GetAttribute( f_pdstrLicense,
                               NULL,
                               DRM_LICENSE_ATTRIB_CONTENTPUBKEY,
                               &dstrLIData,
                               &f_rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_CONTENTPUBKEY],
                               0 );
    if ( DRM_FAILED( dr ) )
    {
        INIT_DRM_STRING( f_rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_CONTENTPUBKEY] );
        ChkDR( DRM_SUCCESS );  /* This sets 'dr' and keeps the PREfast tool happy. */
    }

    dr = DRM_LIC_GetAttribute( f_pdstrLicense,
                               NULL,
                               DRM_LICENSE_ATTRIB_METERING_ID,
                               &dstrLIData,
                               &f_rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_METERING_ID],
                               0 );
    if ( DRM_FAILED( dr ) )
    {
        INIT_DRM_STRING( f_rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_METERING_ID] );
        ChkDR( DRM_SUCCESS );  /* This sets 'dr' and keeps the PREfast tool happy. */
    }

    dr = DRM_LIC_GetAttribute( f_pdstrLicense,
                               NULL,
                               DRM_LICENSE_ATTRIB_CHAINEDKID,
                               &dstrLIData,
                               &f_rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_CHAINEDKID],
                               0 );
    if ( DRM_FAILED( dr ) )
    {
        INIT_DRM_STRING( f_rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_CHAINEDKID] );
        dr = DRM_SUCCESS;
    }

    for ( iEvents = 0; ( iEvents < f_cEvents ) && ( iEvents < DRM_MAX_ACTIONS ); iEvents++ )
    {
        ASSIGN_DRM_STRING( f_rgCachedEvents[iEvents].dstrType, *( f_rgpdstrEvents[iEvents] ) );
        dr = DRM_LIC_GetEvent( f_pdstrLicense,
                               &g_dstrLicEvalOnAction,
                               f_rgpdstrEvents[iEvents],
                               &dstrLIData,
                               &f_rgCachedEvents[iEvents].dstrCondition,
                               &f_rgCachedEvents[iEvents].dstrAction,
                               &f_rgCachedEvents[iEvents].dstrRestriction );
        if ( DRM_FAILED( dr ) )
        {
            INIT_DRM_STRING( f_rgCachedEvents[iEvents].dstrCondition );
            INIT_DRM_STRING( f_rgCachedEvents[iEvents].dstrAction );
            INIT_DRM_STRING( f_rgCachedEvents[iEvents].dstrRestriction );
            dr = DRM_SUCCESS;
        }
    }


ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   _LoadLicenseAttributes
**
** Synopsis :   Load some of those attributes from a license which are
**              frequently used.
**
** Arguments :  rgpdstrRights : Array of pointers to rights requested
**              f_pLicEval    : License eval context
**
** Returns :
**
** Notes :
**
******************************************************************************/
static DRM_RESULT _LoadLicenseAttributes(
    IN  const   DRM_CONST_STRING    *f_rgpdstrEvents[],
    IN          DRM_DWORD            f_cRights,
    IN  OUT     DRM_LICEVAL_CONTEXT *f_pLicEval )
{
    DRM_RESULT          dr          = DRM_SUCCESS;


    ChkDR( _ParseLicenseAttributes( &f_pLicEval->dstrContentLicense,
                                    f_rgpdstrEvents,
                                    f_cRights,
                                    f_pLicEval->rgdstrCachedAttribs,
                                    f_pLicEval->rgCachedEvents ) );
    f_pLicEval->cCachedEvents = f_cRights;

    /*
    **  Cache the binary LID
    */
    ChkDR( DRM_UTL_StringToGuid( &f_pLicEval->rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_LID],
                                 ( DRM_GUID* ) &( f_pLicEval->LID ) ) );

    /*
    **  Cache the binary KID
    */
    ChkDR( DRM_UTL_DecodeKID( &f_pLicEval->rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_KID],
                              &f_pLicEval->KID ) );

    f_pLicEval->fUseCachedAttribs = TRUE;

ErrorExit:
    return dr;
}



/******************************************************************************
**
** Function :   _PerformActions
**
** Synopsis :   The license is selectable -- Can I perform the actions on it?
**              Loop through all the request actions and ask if we can do them
**              If we can do them all the report them all
**
** Arguments :
**          [f_pFFLicense]              : Find first license structure
**          [f_pstack]                  : Stack allocator for temporary allocations
**          [f_rgpdstrRights]           : Array of rights strings to query for
**          [f_cRights]                 : Count of rights in f_rgpdstrRights
**          [f_pDatastore]              : Specifies the DST
**          [f_pfnPolicyCallback]       : Callback function for output restrictions
**          [f_pv]                      : Void pass-through parameter for callback
**
** Returns :
**          DRM_SUCCESS
**              Success
**          DRM_E_INVALIDARG
**              A required parameter was NULL or improperly initialized
**          DRM_E_RIGHTSNOTAVAILABLE
**              A selected right was not found
**
******************************************************************************/
static DRM_RESULT _PerformActions(
    IN OUT   DRM_FFLICENSE               *f_pFFLicense,
    IN OUT   DRM_STACK_ALLOCATOR_CONTEXT *f_pstack,
    IN const DRM_CONST_STRING            *f_rgpdstrRights[], /* Array of DRM_CONST_STRING pointers */
    IN       DRM_DWORD                    f_cRights,
    IN       DRM_DST                     *f_pDatastore,
    IN       DRMPFNPOLICYCALLBACK         f_pfnPolicyCallback,
    IN const DRM_VOID                    *f_pv )
{
    DRM_RESULT       dr          = DRM_SUCCESS;
    DRM_DWORD        iRight      = f_cRights;
    DRM_BOOL         fExisted    = FALSE;
    DRM_BOOL         fEvalResult = FALSE;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMCHAIN, PERF_FUNC__PerformActions );

    ChkArg( f_pFFLicense != NULL );
    ChkArg( f_pDatastore != NULL );
    f_pFFLicense->fDomainBoundRootRequired = FALSE;

    for( ; iRight > 0; )
    {
        fExisted    = FALSE;
        fEvalResult = FALSE;

        iRight--;
        ChkDR( DRM_LEVL_PerformOperations( f_pFFLicense->pLicEval,
                                           DRM_LICENSE_EVAL_ACTION,
                                           DRM_LICENSE_EVAL_CAN_DO_OPERATION,
                                           f_rgpdstrRights[iRight],
                                          &fEvalResult,
                                          &fExisted,
                                           f_pDatastore,
                                           f_pfnPolicyCallback,
                                           f_pv ) );

        ChkBOOL( fEvalResult, DRM_E_RIGHTSNOTAVAILABLE );

        f_pFFLicense->fDomainBoundRootRequired =
            f_pFFLicense->fDomainBoundRootRequired
         || f_pFFLicense->pLicEval->fDomainBoundRootRequired;

        /*
        ** Check if there are any output levels on this right
        */
        if ( fExisted )
        {
            /*
            ** XMR License
            */
            if ( f_pFFLicense->pLicEval->fLicenseIsXMR )
            {
                /*
                ** Play right
                */
                if ( DRM_UTL_DSTRStringsEqual( f_rgpdstrRights[iRight],
                                             &g_dstrWMDRM_RIGHT_PLAYBACK )
                 && XMR_IS_PLAY_VALID( f_pFFLicense->pLicEval->plicenseXMR ) )
                {
                    /*
                    ** No need to obtain default OPL data if no callback function was supplied
                    */
                    if ( f_pfnPolicyCallback == NULL )
                    {
                        /*
                        ** There were output restrictions and no callback function was supplied
                        */
                        ChkBOOL( !XMR_IS_OPL_VALID( f_pFFLicense->pLicEval->plicenseXMR )
                              && !XMR_IS_EXPLICITANALOGVIDEOPROTECTION_VALID( f_pFFLicense->pLicEval->plicenseXMR ),
                                 DRM_E_NO_OPL_CALLBACK );
                    }
                    /*
                    ** Obtain OPL data - will obtain default data if license has no OPLs
                    */
                    else if ( XMR_IS_OPL_VALID(f_pFFLicense->pLicEval->plicenseXMR)
                           || XMR_IS_EXPLICITANALOGVIDEOPROTECTION_VALID(f_pFFLicense->pLicEval->plicenseXMR)
                           || XMR_IS_EXPLICITDIGITALAUDIOPROTECTION_VALID(f_pFFLicense->pLicEval->plicenseXMR) )
                    {
                        f_pstack->pbStack = f_pFFLicense->rgPlayOpl[f_pFFLicense->dwChainDepth].rgbPlayOPLBuffer;
                        f_pstack->cbStack = SIZEOF( f_pFFLicense->rgPlayOpl[f_pFFLicense->dwChainDepth].rgbPlayOPLBuffer );

                        ChkDR( DRM_OPL_ProcessPlayOutputLevelDataXMR( &f_pFFLicense->pLicEval->plicenseXMR->containerOuter.containerPlaybackPolicies,
                                                                      &f_pFFLicense->rgPlayOpl[f_pFFLicense->dwChainDepth].oplPlay,
                                                                       f_pstack ) );
                        f_pFFLicense->rgfPlayOplValid[f_pFFLicense->dwChainDepth] = TRUE;
                    }
                }
                /*
                ** Copy right
                */
                else if ( DRM_UTL_DSTRStringsEqual( f_rgpdstrRights[iRight], &g_dstrWMDRM_RIGHT_COPY )
                      && XMR_IS_COPY_VALID( f_pFFLicense->pLicEval->plicenseXMR ) )
                {
                    /*
                    ** No need to obtain default OPL data if no callback function was supplied
                    */
                    if ( f_pfnPolicyCallback == NULL )
                    {
                        /*
                        ** There were output restrictions and no callback function was supplied
                        */
                        ChkBOOL( !XMR_IS_COPYPROTECTIONLEVEL_VALID( f_pFFLicense->pLicEval->plicenseXMR ),
                                 DRM_E_NO_OPL_CALLBACK );
                    }
                    /*
                    ** Obtain OPL data - will obtain default data if license has no OPLs
                    */
                    else if( XMR_IS_COPYPROTECTIONLEVEL_VALID(f_pFFLicense->pLicEval->plicenseXMR) )
                    {
#if DRM_SUPPORT_COPY_OPL
                        f_pstack->pbStack = f_pFFLicense->rgCopyOpl[f_pFFLicense->dwChainDepth].rgbCopyOPLBuffer;
                        f_pstack->cbStack = SIZEOF( f_pFFLicense->rgCopyOpl[f_pFFLicense->dwChainDepth].rgbCopyOPLBuffer );

                        ChkDR( DRM_OPL_ProcessCopyOutputLevelDataXMR( &f_pFFLicense->pLicEval->plicenseXMR->containerOuter.containerCopyPolicies,
                                                                      &f_pFFLicense->rgCopyOpl[f_pFFLicense->dwChainDepth].oplCopy,
                                                                       f_pstack ) );
                        f_pFFLicense->rgfCopyOplValid[f_pFFLicense->dwChainDepth] = TRUE;
#else
                        /*
                        ** We don't support COPY OPLs but the license has COPY OPLs
                        */
                        ChkDR( DRM_E_RIGHTSNOTAVAILABLE );
#endif
                    }
                }
            }
            /*
            ** If we got this far, then this is an XML license with OPLs
            */
            else if ( f_pFFLicense->pLicEval->rgCachedEvents[iRight].dstrRestriction.cchString != 0 )
            {
                /*
                ** There were output restrictions and no callback function was supplied
                */
                ChkBOOL( f_pfnPolicyCallback != NULL, DRM_E_NO_OPL_CALLBACK );

                /*
                ** Reset the stack context
                */
                ZEROMEM( f_pstack, SIZEOF( DRM_STACK_ALLOCATOR_CONTEXT ) );

                if ( DRM_UTL_DSTRStringsEqual( f_rgpdstrRights[iRight], &g_dstrWMDRM_RIGHT_PLAYBACK ) )
                {
                    f_pstack->pbStack = f_pFFLicense->rgPlayOpl[f_pFFLicense->dwChainDepth].rgbPlayOPLBuffer;
                    f_pstack->cbStack = SIZEOF( f_pFFLicense->rgPlayOpl[f_pFFLicense->dwChainDepth].rgbPlayOPLBuffer );

                    ChkDR( DRM_OPL_ProcessPlayOutputLevelData( &f_pFFLicense->pLicEval->rgCachedEvents[iRight].dstrRestriction,
                                                               &f_pFFLicense->rgPlayOpl[f_pFFLicense->dwChainDepth].oplPlay,
                                                                f_pstack ) );
                    f_pFFLicense->rgfPlayOplValid[f_pFFLicense->dwChainDepth] = TRUE;
                }

                else if ( DRM_UTL_DSTRStringsEqual( f_rgpdstrRights[iRight], &g_dstrWMDRM_RIGHT_COPY ) )
                {
#if DRM_SUPPORT_COPY_OPL
                    f_pstack->pbStack = f_pFFLicense->rgCopyOpl[f_pFFLicense->dwChainDepth].rgbCopyOPLBuffer;
                    f_pstack->cbStack = SIZEOF( f_pFFLicense->rgCopyOpl[f_pFFLicense->dwChainDepth].rgbCopyOPLBuffer );

                    ChkDR( DRM_OPL_ProcessCopyOutputLevelData( &f_pFFLicense->pLicEval->rgCachedEvents[iRight].dstrRestriction,
                                                               &f_pFFLicense->rgCopyOpl[f_pFFLicense->dwChainDepth].oplCopy,
                                                                f_pstack ) );
                    f_pFFLicense->rgfCopyOplValid[f_pFFLicense->dwChainDepth] = TRUE;
#else
                    ChkDR( DRM_E_RIGHTSNOTAVAILABLE );
#endif
                }

            }

        }
    } /* end for rights */

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


#if DRM_SUPPORT_REVOCATION

/******************************************************************************
**
** Function :   _ValidateRevocationVersions
**
** Synopsis :   This will check the revocation list versions in the license versus the current
**              list versions to ensure they are adequate.  The current version numbers should
**              be pre-cached for this check
**
** Parameters:
**      [f_pFFLicense] : Specifies the find first license structure to use
**      [f_pDatastore] : Specifies the data store.
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          A required argument was NULL or invalid
**      DRM_E_LICEVAL_REQUIRED_REVOCATION_LIST_NOT_AVAILABLE
**          Unable to retrieve the revocation list
**      DRM_E_RIV_TOO_SMALL
**          The Riv was retrieved but was too small
**
******************************************************************************/
static DRM_RESULT _ValidateRevocationVersions(
    IN OUT DRM_FFLICENSE    *f_pFFLicense,
    IN     DRM_DST          *f_pDatastore )
{
    DRM_RESULT       dr                    = DRM_SUCCESS;
    DRM_DWORD        idCRLWMDRMAppRequired = 0;
    DRM_DWORD        idCRLDeviceRequired   = 0;
    DRM_DWORD        idCRLWMDRMNETRequired = 0;
    DRM_CONST_STRING dstrRevInfo           = EMPTY_DRM_STRING;
    DRM_DWORD        dwRevInfo             = 0;
    DRM_DWORD        dwXMRVersion          = XMR_VERSION_INVALID;
    DRM_BOOL         fUseV2RIV             = FALSE;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMCHAIN, PERF_FUNC__ValidateRevocationVersions );

    ChkArg( f_pFFLicense           != NULL );
    ChkArg( f_pFFLicense->pLicEval != NULL );
    ChkArg( f_pDatastore           != NULL );

    /*
    ** Extract required versions from an XML license
    */
    if ( !f_pFFLicense->pLicEval->fLicenseIsXMR )
    {
#if DRM_SUPPORT_APP_REVOCATION
        idCRLWMDRMAppRequired = f_pFFLicense->pLicEval->idCRLsCurrent.wmdrmapp;

        ChkDR( DRM_RVK_PerformAppRevocationCheck( &f_pFFLicense->pLicEval->pcontextBBX->CryptoContext,
                                                   f_pFFLicense->pLicEval->pContextRev,
                                                  &f_pFFLicense->pLicEval->dstrContentLicense,
                                                  &f_pFFLicense->pLicEval->appcert,
                                                   f_pFFLicense->pLicEval->pbRevocationBuffer,
                                                   f_pFFLicense->pLicEval->cbRevocationBuffer,
                                                  &f_pFFLicense->pLicEval->idCRLsCurrent ) );
#endif

#if DRM_SUPPORT_DEVICE_REVOCATION
        dr = DRM_LIC_GetAttribute( &f_pFFLicense->pLicEval->dstrContentLicense,
                                   &g_dstrDeviceRevocationLicenseTag,
                                    DRM_LICENSE_ATTRIB_REVOCATION,
                                    NULL,
                                   &dstrRevInfo,
                                    0 );
        if ( DRM_SUCCEEDED( dr ) )
        {
            ChkDR( DRMCRT_wcsntol( dstrRevInfo.pwszString, dstrRevInfo.cchString, ( DRM_LONG * )&dwRevInfo ) );
            idCRLDeviceRequired = dwRevInfo;
        }
#endif

#if DRM_SUPPORT_WMDRMNET
        dr = DRM_LIC_GetAttribute( &f_pFFLicense->pLicEval->dstrContentLicense,
                                   &g_dstrWMDRMNETRevocationLicenseTag,
                                    DRM_LICENSE_ATTRIB_REVOCATION,
                                    NULL,
                                   &dstrRevInfo,
                                    0 );
        if ( DRM_SUCCEEDED( dr ) )
        {
            ChkDR( DRMCRT_wcsntol( dstrRevInfo.pwszString, dstrRevInfo.cchString, ( DRM_LONG * )&dwRevInfo ) );
            idCRLWMDRMNETRequired = dwRevInfo;
        }
#endif

        dwRevInfo = 0;
        dr = DRM_LIC_GetAttribute( &f_pFFLicense->pLicEval->dstrContentLicense,
                                    NULL,
                                    DRM_LICENSE_ATTRIB_REVINFO,
                                    NULL,
                                   &dstrRevInfo,
                                    0 );

        if( dr != DRM_E_XMLNOTFOUND )
        {
            ChkDR( dr );
            ChkDR( DRMCRT_wcsntol( dstrRevInfo.pwszString, dstrRevInfo.cchString, ( DRM_LONG * ) &dwRevInfo ) );
        }
    }

    /*
    ** Extract required versions from an XMR license
    */
    else
    {
        ChkArg( f_pFFLicense->pLicEval->plicenseXMR != NULL );

        dwXMRVersion = f_pFFLicense->pLicEval->plicenseXMR->dwVersion;

        ChkBOOL(
            dwXMRVersion == XMR_VERSION_1
         || dwXMRVersion == XMR_VERSION_3, DRM_E_INVALIDLICENSE);

        if ( XMR_IS_MINIMUM_ENVIRONMENT_VALID( f_pFFLicense->pLicEval->plicenseXMR ) )
        {
                if (dwXMRVersion == XMR_VERSION_1)
                {
                    idCRLWMDRMAppRequired  = f_pFFLicense->pLicEval->plicenseXMR->containerOuter.containerGlobalPolicies.MinimumEnvironment.dwMinimumAppRevocationListVersion;
                    idCRLDeviceRequired = f_pFFLicense->pLicEval->plicenseXMR->containerOuter.containerGlobalPolicies.MinimumEnvironment.dwMinimumDeviceRevocationListVersion;
                }
                else
                {
                    /*
                     * For V2+ XMR, we do not support the minimum environment objects, so validate
                     * that the versions in this object are zero if the object is valid.
                     * Note that it can be valid since the minimum security level is still
                     * honored.
                    */
                    ChkBOOL( f_pFFLicense->pLicEval->plicenseXMR->containerOuter.containerGlobalPolicies.MinimumEnvironment.dwMinimumAppRevocationListVersion == 0,
                        DRM_E_INVALIDLICENSE);
                    
                    ChkBOOL( f_pFFLicense->pLicEval->plicenseXMR->containerOuter.containerGlobalPolicies.MinimumEnvironment.dwMinimumDeviceRevocationListVersion == 0,
                        DRM_E_INVALIDLICENSE);
    
                    /* Use the V2 revinfo */
                    fUseV2RIV = TRUE;
                }
        }

        if ( XMR_IS_REVOCATION_INFORMATION_VERSION_VALID( f_pFFLicense->pLicEval->plicenseXMR ) )
        {
            dwRevInfo = f_pFFLicense->pLicEval->plicenseXMR->containerOuter.containerGlobalPolicies.RevocationInformationVersion.dwValue;
        }
    }

    /*
    ** Compare the required values to the cached values
    */

    /*
    ** Although we're failing here, the caller should update
    ** the revocation version cache and try again. This is in
    ** case there have been any updates to the revocation lists.
    */
    ChkBOOL( idCRLWMDRMAppRequired <= f_pFFLicense->pLicEval->idCRLsCurrent.wmdrmapp
          && idCRLDeviceRequired   <= f_pFFLicense->pLicEval->idCRLsCurrent.device
          && idCRLWMDRMNETRequired <= f_pFFLicense->pLicEval->idCRLsCurrent.wmdrmnet,
             DRM_E_LICEVAL_REQUIRED_REVOCATION_LIST_NOT_AVAILABLE );

    /* 
    ** Ensure the dwLicRevInfoVer field has the highest RIV needed so far. This
    ** value is returned to callers asking which RIV is required.
    */
    if ( dwRevInfo > f_pFFLicense->dwLicRevInfoVer )
    {
        f_pFFLicense->dwLicRevInfoVer = dwRevInfo;
    }

    /*
    ** Test the license RIV against the currently stored RIV. If the best CRL
    ** set we have is too old, return DRM_E_RIV_TOO_SMALL.
    */
    if ( fUseV2RIV ) 
    {
        ChkBOOL( dwRevInfo <= f_pFFLicense->pLicEval->idCRLsCurrent.riv2,
                 DRM_E_RIV_TOO_SMALL );
    }
    else
    {
        ChkBOOL( dwRevInfo <= f_pFFLicense->pLicEval->idCRLsCurrent.riv,
                 DRM_E_RIV_TOO_SMALL );
    }

    dr = DRM_SUCCESS;

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

#endif /* DRM_SUPPORT_REVOCATION */


/******************************************************************************
**
** Function :   _GetLicenseInfoAndSetup
**
** Synopsis :   Load the license in memory and setup
**
** Parameters:
**      [f_pFFLicense]    : Specifies the find first license structure to use
**      [f_rgpdstrRights] : Specifies the list of rights
**      [f_cRights]       : Number of elements in f_rgpdstrRights
**      [f_pDatastore]    : Specifies the DST
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          A required argument was NULL or invalid
**      DRM_E_XMR_REQUIRED_OBJECT_MISSING
**          A required object was missing for an XMR license
**      DRM_E_INVALIDLICENSE
**          An error occurred while parsing the license
**      DRM_E_POLICY_METERING_DISABLED
**          There is a MID but metering is disabled
**
******************************************************************************/
static DRM_RESULT _GetLicenseInfoAndSetup(
    IN OUT   DRM_FFLICENSE    *f_pFFLicense,
    IN const DRM_CONST_STRING *f_rgpdstrRights[], /* Array of DRM_CONST_STRING pointers */
    IN       DRM_DWORD         f_cRights,
    IN       DRM_DST          *f_pDatastore )
{
    DRM_RESULT dr         = DRM_SUCCESS;
    DRM_DWORD  cbLicSize  = 0;
    DRM_BYTE  *pbChecksum = NULL;
    DRM_BYTE  *pbLicense  = NULL;
    DRM_BYTE  *pbTemp     = NULL;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMCHAIN, PERF_FUNC__GetLicenseInfoAndSetup );

    ChkArg( f_pFFLicense != NULL );
    ChkArg( f_pDatastore != NULL );
    ChkArg( f_pFFLicense->pBindingInfo != NULL );

    ChkDR( DRM_STK_PreAlloc( f_pFFLicense->pstack, &cbLicSize, (DRM_VOID**)&pbLicense ) );
    ChkDR( DRM_LST_GetLicense( f_pFFLicense->rgpLicStoreCurrent[f_pFFLicense->dwChainDepth],
                              &f_pFFLicense->rgkid[f_pFFLicense->dwChainDepth],
                              &f_pFFLicense->rglid[f_pFFLicense->dwChainDepth],
                              &( f_pFFLicense->rgslotHint[f_pFFLicense->dwChainDepth] ),
                               pbLicense,
                              &cbLicSize ) );
    ChkDR( DRM_STK_Alloc( f_pFFLicense->pstack, cbLicSize, (DRM_VOID**)&pbTemp ) );
    DRMASSERT( pbTemp == pbLicense );

    /*
    ** XMR License
    */
    if ( f_pFFLicense->pBindingInfo[0].m_fXMRLicense )
    {
        f_pFFLicense->pLicenseXMR[f_pFFLicense->dwChainDepth].pbXMRLic = pbLicense;
        f_pFFLicense->pLicenseXMR[f_pFFLicense->dwChainDepth].cbXMRLic = cbLicSize;
        /*
        ** Unpack the license into the correct chained license slot
        */

        f_pFFLicense->pLicEval->plicenseXMR = &f_pFFLicense->pLicenseXMR[f_pFFLicense->dwChainDepth];

        ChkDR( DRM_XMR_UnpackLicense( pbLicense,
                                      cbLicSize,
                                      f_pFFLicense->pstack,
                                      f_pFFLicense->pLicEval->plicenseXMR ) );

        /*
        ** Ensure the minimum objects are in the license
        */
        ChkBOOL( XMR_IS_RID_VALID( f_pFFLicense->pLicEval->plicenseXMR )
              && XMR_IS_SIGNATURE_VALID  ( f_pFFLicense->pLicEval->plicenseXMR )
              && XMR_IS_CONTENT_KEY_VALID( f_pFFLicense->pLicEval->plicenseXMR ),
                 DRM_E_XMR_REQUIRED_OBJECT_MISSING );

        f_pFFLicense->pLicEval->fLicenseIsXMR = TRUE;

        if ( f_pFFLicense->fSkipAESContent
          && f_pFFLicense->pLicEval->plicenseXMR->containerOuter.containerKeys.ContentKey.wSymmetricCipherType == XMR_SYMMETRIC_ENCRYPTION_TYPE_AES_128_CTR )
        {
            ChkDR( DRM_E_LICENSEMISMATCH );   /* we are told to ignore this type of license. */
        }

        /*
        ** Parse the KID and LID from the license
        */
        DRM_BYT_CopyBytes( f_pFFLicense->pLicEval->LID.rgb,
                           0,
                           f_pFFLicense->pLicEval->plicenseXMR->pbRightsIdBuffer,
                           f_pFFLicense->pLicEval->plicenseXMR->iRightsId,
                           SIZEOF( f_pFFLicense->pLicEval->LID.rgb ) );
        DRM_BYT_CopyBytes( f_pFFLicense->pLicEval->KID.rgb,
                           0,
                           f_pFFLicense->pLicEval->plicenseXMR->containerOuter.containerKeys.ContentKey.pbguidKeyID,
                           f_pFFLicense->pLicEval->plicenseXMR->containerOuter.containerKeys.ContentKey.iguidKeyID,
                           SIZEOF( f_pFFLicense->pLicEval->KID.rgb ) );

        /*
        ** If we didn't get the RID and LID before, get it now
        */
        if ( f_pFFLicense->dwChainDepth == 0 )
        {
            DRM_BYT_CopyBytes( &f_pFFLicense->rglid[f_pFFLicense->dwChainDepth],
                               0,
                               f_pFFLicense->pLicEval->LID.rgb,
                               0,
                               SIZEOF( f_pFFLicense->pLicEval->LID.rgb ) );
            DRM_BYT_CopyBytes( &f_pFFLicense->rgkid[f_pFFLicense->dwChainDepth],
                               0,
                               f_pFFLicense->pLicEval->KID.rgb,
                               0,
                               SIZEOF( f_pFFLicense->pLicEval->KID.rgb ) );
            ZEROMEM( &f_pFFLicense->rgslotHint[f_pFFLicense->dwChainDepth], SIZEOF( DRM_DST_SLOT_HINT ) );
        }

        if ( XMR_IS_METERING_VALID( f_pFFLicense->pLicEval->plicenseXMR ) )
        {
            ChkBOOL( ( f_pFFLicense->dwPolicyFlags & DRM_POLICY_FLAG_METERING_DISABLED_ENTERPRISE ) == 0,
                     DRM_E_POLICY_METERING_DISABLED );

#if DRM_SUPPORT_METERING
            f_pFFLicense->rgfHasMetering[f_pFFLicense->dwChainDepth] = TRUE;
            DRM_BYT_CopyBytes( &f_pFFLicense->rgmid[f_pFFLicense->dwChainDepth],
                                0,
                                f_pFFLicense->pLicEval->plicenseXMR->containerOuter.containerGlobalPolicies.Metering.pguidBuffer,
                                f_pFFLicense->pLicEval->plicenseXMR->containerOuter.containerGlobalPolicies.Metering.iGuid,
                                SIZEOF( DRM_GUID ) );
#endif
        }

        /*
        ** Set up XMR binding context
        */
        f_pFFLicense->pBindingInfo[f_pFFLicense->dwChainDepth].m_fXMRLicense                                 = TRUE;
        f_pFFLicense->pBindingInfo[f_pFFLicense->dwChainDepth].m_BindingInfo.m_XMR.m_pxmrContentKey          = &f_pFFLicense->pLicEval->plicenseXMR->containerOuter.containerKeys.ContentKey;
        f_pFFLicense->pBindingInfo[f_pFFLicense->dwChainDepth].m_BindingInfo.m_XMR.m_pxmrOptimizedContentKey = &f_pFFLicense->pLicEval->plicenseXMR->containerOuter.containerKeys.OptimizedContentKey;
        f_pFFLicense->pBindingInfo[f_pFFLicense->dwChainDepth].m_BindingInfo.m_XMR.m_pxmrDeviceKey           = &f_pFFLicense->pLicEval->plicenseXMR->containerOuter.containerKeys.DeviceKey;
        f_pFFLicense->pBindingInfo[f_pFFLicense->dwChainDepth].m_BindingInfo.m_XMR.m_pxmrDomainID            = &f_pFFLicense->pLicEval->plicenseXMR->containerOuter.containerGlobalPolicies.DomainID;
        f_pFFLicense->pBindingInfo[f_pFFLicense->dwChainDepth].m_BindingInfo.m_XMR.m_pxmrSignature           = &f_pFFLicense->pLicEval->plicenseXMR->containerOuter.signature;
        f_pFFLicense->pBindingInfo[f_pFFLicense->dwChainDepth].m_BindingInfo.m_XMR.m_pxmrLicense             =  f_pFFLicense->pLicEval->plicenseXMR;

        /*
        ** assign checksum from license to bindinginfo buffer
        */
        if ( f_pFFLicense->dwChainDepth != DRM_MAX_LICENSE_CHAIN_DEPTH - 1 &&
             XMR_IS_UPLINK_KID_VALID( f_pFFLicense->pLicEval->plicenseXMR ) )
        {
            ChkBOOL( f_pFFLicense->pLicEval->plicenseXMR->containerOuter.containerKeys.UplinkKid.cbChainedCheckSum <= DRM_MAX_CHECKSUM,
                     DRM_E_BUFFERTOOSMALL );
            DRM_BYT_CopyBytes( f_pFFLicense->pBindingInfo[f_pFFLicense->dwChainDepth + 1].m_oChecksum.m_rgbChecksumData,
                               0,
                               f_pFFLicense->pLicEval->plicenseXMR->containerOuter.containerKeys.UplinkKid.pbChainedCheckSumBuffer,
                               f_pFFLicense->pLicEval->plicenseXMR->containerOuter.containerKeys.UplinkKid.iChainedCheckSum,
                               f_pFFLicense->pLicEval->plicenseXMR->containerOuter.containerKeys.UplinkKid.cbChainedCheckSum );
            f_pFFLicense->pBindingInfo[f_pFFLicense->dwChainDepth + 1].m_oChecksum.m_cbChecksum
                = f_pFFLicense->pLicEval->plicenseXMR->containerOuter.containerKeys.UplinkKid.cbChainedCheckSum;
            f_pFFLicense->pBindingInfo[f_pFFLicense->dwChainDepth + 1].m_oChecksum.m_fIgnoreChecksum = FALSE;
            f_pFFLicense->pBindingInfo[f_pFFLicense->dwChainDepth + 1].m_oChecksum.m_pbV1KID = NULL;
            DRM_BYT_CopyBytes( f_pFFLicense->pBindingInfo[f_pFFLicense->dwChainDepth + 1].m_oChecksum.m_KID.rgb, 
                               0, 
                               f_pFFLicense->pLicEval->plicenseXMR->containerOuter.containerKeys.UplinkKid.pbguidUplinkKID,
                               f_pFFLicense->pLicEval->plicenseXMR->containerOuter.containerKeys.UplinkKid.iguidUplinkKID,
                               SIZEOF( DRM_KID ) );
        }
    }
    /*
    ** XML License
    */
    else
    {
        DSTR_FROM_PB( &( f_pFFLicense->pLicEval->dstrContentLicense ), pbLicense, cbLicSize );
        f_pFFLicense->pLicEval->fUseCachedAttribs = FALSE;
        f_pFFLicense->pLicEval->fLicenseIsXMR = FALSE;
        f_pFFLicense->pBindingInfo[f_pFFLicense->dwChainDepth].m_fXMRLicense = FALSE;

        /*
        **  Load the necessary License Attribs
        */
        ChkDR( _LoadLicenseAttributes( f_rgpdstrRights, f_cRights, f_pFFLicense->pLicEval ) );

        /*
        ** see if we have a global policy forbidding metering
        */
        if ( ( f_pFFLicense->dwPolicyFlags & DRM_POLICY_FLAG_METERING_DISABLED_ENTERPRISE ) != 0 )
        {
            ChkBOOL( f_pFFLicense->pLicEval->rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_METERING_ID].cchString == 0,
                     DRM_E_POLICY_METERING_DISABLED );
        }
    #if DRM_SUPPORT_METERING
        else
        {
            if ( f_pFFLicense->pLicEval->rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_METERING_ID].cchString != 0 )
            {
                DRM_DWORD cbMID = SIZEOF( DRM_MID );

                f_pFFLicense->rgfHasMetering [f_pFFLicense->dwChainDepth] = TRUE;

                ChkDR( DRM_B64_DecodeW( &f_pFFLicense->pLicEval->rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_METERING_ID],
                                        &cbMID,
                                        ( DRM_BYTE * ) &f_pFFLicense->rgmid[f_pFFLicense->dwChainDepth],
                                        0 ) );
            }
        }
#endif
        cbLicSize = SIZEOF( f_pFFLicense->pBindingInfo[f_pFFLicense->dwChainDepth].m_BindingInfo.m_XML.m_rgbContentKey );
        if ( f_pFFLicense->dwChainDepth == DRM_MAX_LICENSE_CHAIN_DEPTH-1 )
        {
            /*
            ** If we are on the last level that a chain could be pass in NULL
            */
            pbChecksum = NULL;
        }
        else
        {
            /*
            ** Otherwise get the checksum for the next license up the chain
            */
            pbChecksum = f_pFFLicense->pBindingInfo[f_pFFLicense->dwChainDepth + 1].m_oChecksum.m_rgbChecksumData;
        }

        ChkDR( DRM_LIC_GetEnablingBits( &( f_pFFLicense->pLicEval->dstrContentLicense ),
                                         0, /* Get the first enabling bit */
                                        &f_pFFLicense->pBindingInfo[f_pFFLicense->dwChainDepth].m_BindingInfo.m_XML.m_dwAlgorithm,
                                        &f_pFFLicense->pBindingInfo[f_pFFLicense->dwChainDepth].m_BindingInfo.m_XML.m_oPublKey,
                                         f_pFFLicense->pBindingInfo[f_pFFLicense->dwChainDepth].m_BindingInfo.m_XML.m_rgbContentKey,
                                        &cbLicSize,
                                        &f_pFFLicense->pBindingInfo[f_pFFLicense->dwChainDepth].m_BindingInfo.m_XML.m_oLsPublKey,
                                         f_pFFLicense->pBindingInfo[f_pFFLicense->dwChainDepth].m_BindingInfo.m_XML.m_rgbSignature,
                                         pbChecksum,
                                        &f_pFFLicense->pLicEval->pcontextBBX->CryptoContext ) );
    }

    if ( f_pFFLicense->fSecStoreOpen[f_pFFLicense->dwChainDepth] )
    {
        f_pFFLicense->fSecStoreOpen[f_pFFLicense->dwChainDepth] = FALSE;
        ZEROMEM( &( f_pFFLicense->pSecStoreLicense[f_pFFLicense->dwChainDepth] ),
                  SIZEOF( DRM_SECSTORE_CONTEXT ) );
    }

#if DRM_SUPPORT_SECURE_CLOCK
    if( !f_pFFLicense->pLicEval->fSSecureTimeDataLoaded )
    {
        f_pFFLicense->pLicEval->fSSecureTimeDataLoaded = TRUE;

        /*
        ** Never fail here for secure clock stuff
        */
        dr = DRM_SST_CreateGlobalStorePassword( f_pFFLicense->rgbLicensePassword,
                                  ( DRM_BYTE * )f_pFFLicense->pLicEval->pcontextBBX );
        if ( dr == DRM_SUCCESS )
        {
            DRM_DWORD               dwSecureData  = 0;
            DRM_SECSTORE_CLOCK_DATA oClkData      = { 0 };

            ZEROMEM( &oClkData, SIZEOF( oClkData ) );
            dwSecureData = SIZEOF( oClkData );

            dr = DRM_SST_GetData( &( f_pFFLicense->pSecStoreLicense[f_pFFLicense->dwChainDepth] ),
                                  &g_idSData,
                                  &g_idSDataPrev,
                                   f_pFFLicense->rgbLicensePassword,
                                   SECURE_STORE_GLOBAL_DATA,
                                   f_pDatastore,
                                  ( DRM_BYTE * ) &oClkData,
                                  &dwSecureData );

            if ( DRM_SUCCESS == dr )
            {
                _PrepareSecureClockDataForReading( &oClkData );

                /*
                ** Now Test the Values
                */
                if ( ( oClkData.flag&CLK_LK_GP_VALID ) && ( oClkData.flag&CLK_IN_GP_VALID ) )
                {
                    f_pFFLicense->pLicEval->fSecureTimeDataValid = TRUE;
                    if ( oClkData.fInGracePeriod )
                    {
                        f_pFFLicense->pLicEval->fInGracePeriod = TRUE;
                    }
                    f_pFFLicense->pLicEval->u64GPStartTime = oClkData.LastKnownGracePeriodStartTime;
                }
            }
        }
    }
    dr = DRM_SUCCESS;
#endif

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}



/******************************************************************************
**
** Function :   _ProcessEndOfChain
**
** Synopsis :   Process end of the license chain and return
**
** Parameters:
**      [f_pFFLicense]        : Specifies the find first license structure to use
**      [f_pfnPolicyCallback] : Specifies the OPL callback
**      [f_pv]                : Opaque data to pass to f_pfnPolicyCallback
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          A required argument was NULL or invalid
**      DRM_E_LIC_KEY_DECODE_FAILURE
**          Unable to decode key data from the license
**      DRM_E_BUFFERTOOSMALL
**          The internal license buffer is too small
**
******************************************************************************/
static DRM_RESULT _ProcessEndOfChain(
    IN OUT   DRM_FFLICENSE               *f_pFFLicense,
    IN       DRMPFNPOLICYCALLBACK         f_pfnPolicyCallback,
    IN const DRM_VOID                    *f_pv )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  i  = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMCHAIN, PERF_FUNC__ProcessEndOfChain );

    ChkArg( f_pFFLicense != NULL );

    if ( !DRM_BBX_CanBind( f_pFFLicense->pBindingInfo,
                           f_pFFLicense->dwChainDepth + 1,
                           f_pFFLicense->pLicEval->pcontextBBX,
                           &dr ) )
    {
        /*
        ** If the error code is DRM_E_DOMAIN_BIND_LICENSE, let it be
        ** explicitly returned.
        */
        if ( dr != DRM_E_DOMAIN_BIND_LICENSE )
        {
            dr = DRM_E_LIC_KEY_DECODE_FAILURE;
        }

        ChkDR( dr );
    }

    if ( f_pfnPolicyCallback != NULL )
    {
        /*
        **  Perform an inclusion list callback
        */
        f_pFFLicense->inclusionListCallback.dwChainDepth = f_pFFLicense->dwChainDepth;
        ChkDR( f_pfnPolicyCallback( &f_pFFLicense->inclusionListCallback, DRM_INCLUSION_LIST_CALLBACK, f_pv ) );

        for( i = f_pFFLicense->dwChainDepth + 1; i > 0; )
        {
            /*
            ** Find and return the root most OPL for the license chain.
            */
            i--;

            if ( f_pFFLicense->rgfPlayOplValid[i] )
            {
                ChkDR( f_pfnPolicyCallback( &f_pFFLicense->rgPlayOpl[i].oplPlay, DRM_PLAY_OPL_CALLBACK, f_pv ) );
                break;
            }
        }

#if DRM_SUPPORT_COPY_OPL
        for( i = f_pFFLicense->dwChainDepth + 1; i > 0; )
        {
            i--;
            /*
            ** Find and return the root most OPL for the license chain.
            */
            if ( f_pFFLicense->rgfCopyOplValid[i] )
            {
                ChkDR( f_pfnPolicyCallback( &f_pFFLicense->rgCopyOpl[i].oplCopy, DRM_COPY_OPL_CALLBACK, f_pv ) );
                break;
            }
        }
#endif
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


/*****************************************************************************
** Function: _GetSourceIDFromLicense
**
** Synopsis: Checks of the <SOURCEID> tag in the XML license and updates the
**           the dwSourceid in DRM_FFLICENSE if found.
**           Source ID should be specified only in leaf license. We will ignore
**           the sourceID if specified in the root license.
** Arguments:
**           IN f_pFFLicense   -- DRM_FFLICENSE the license
** Returns:
**           DRM_SUCCESS           -- On success
*****************************************************************************/
DRM_RESULT _GetSourceIDFromLicense (
    IN DRM_FFLICENSE *f_pFFLicense )
{
    DRM_RESULT       dr        = DRM_SUCCESS;
    DRM_CONST_STRING dstrValue = EMPTY_DRM_STRING;


    ChkArg( f_pFFLicense != NULL );
    ChkArg( f_pFFLicense->pLicEval != NULL );
    ChkArg( f_pFFLicense->pLicEval->dstrContentLicense.pwszString != NULL
         || ( f_pFFLicense->pLicEval->fLicenseIsXMR
           && f_pFFLicense->pLicEval->plicenseXMR != NULL ) );

    f_pFFLicense->dwSourceid = 0;

    if ( f_pFFLicense->pLicEval->fLicenseIsXMR )
    {
        if ( f_pFFLicense->pLicEval->plicenseXMR->containerOuter.containerGlobalPolicies.SourceID.fValid )
        {
            f_pFFLicense->dwSourceid = f_pFFLicense->pLicEval->plicenseXMR->containerOuter.containerGlobalPolicies.SourceID.dwValue;
        }
    }
    else
    {
        dr = DRM_LIC_GetAttribute( &f_pFFLicense->pLicEval->dstrContentLicense,
                                    NULL,
                                    DRM_LICENSE_ATTRIB_SOURCEID,
                                    NULL,
                                   &dstrValue,
                                    0 );
        if ( DRM_SUCCEEDED( dr ) )
        {
            ChkDR( DRMCRT_WtoDWORD( dstrValue.pwszString,
                                    dstrValue.cchString,
                                    10,                      // base 10
                                    &f_pFFLicense->dwSourceid ) );
        }
    }

    dr = DRM_SUCCESS;
ErrorExit:

    return dr;
}

/*****************************************************************************
** Function : DRM_LIC_CompleteLicenseChain
**
** Synopsis : Complete a license chain and return
**
** Parameters:
**      [f_pFFLicense]              : Specifies the find first license structure to use
**      [f_rgpdstrRights]           : Specifies the set of rights strings
**      [f_cRights]                 : Specifies the number of elements in f_rgpdstrRights
**      [f_pdwChainDepth]           : Returns the current chain depth
**      [f_pDatastore]              : Specifies the primary Data Store (used for metering, Secure Store, etc.)
**      [f_pfnPolicyCallback]       : Specifies the OPL callback
**      [f_pv]                      : Opaque data to pass to f_pfnPolicyCallback
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          A required argument was NULL or invalid
**      DRM_E_RIGHTSNOTAVAILABLE
**          Unable to parse a right from the license
**      DRM_E_LICENSEEXPIRED
**          License is expired
**      DRM_E_V1_LICENSE_CHAIN_NOT_SUPPORTED
**          V1 content containing chained licenses is not supported
**      DRM_E_LICENSENOTFOUND
**          License not found at maximum chain depth
**
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_LIC_CompleteLicenseChain(
    IN OUT   DRM_FFLICENSE               *f_pFFLicense,
    IN const DRM_CONST_STRING            *f_rgpdstrRights[], /* Array of DRM_CONST_STRING pointers */
    IN       DRM_DWORD                    f_cRights,
       OUT   DRM_DWORD                   *f_pdwChainDepth,
    IN       DRM_DST                     *f_pDatastore,
    IN       DRMPFNPOLICYCALLBACK         f_pfnPolicyCallback,
    IN const DRM_VOID                    *f_pv )
{
    DRM_RESULT       dr               = DRM_SUCCESS;
    DRM_BOOL         fEvalResult      = FALSE;
    DRM_DWORD        i                = 0;
    DRM_KID          oChainKID        = { 0 };
    DRM_BOOL         fChained         = FALSE;
    DRM_STACK_ALLOCATOR_CONTEXT stack = { 0, 0, NULL };
    DRM_DWORD        nStackTop        = ULONG_MAX;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMCHAIN, PERF_FUNC_DRM_LIC_CompleteLicenseChain );

    DRMCASSERT( DRM_MAX_LICENSE_CHAIN_DEPTH > 0 );

    ChkArg( f_pFFLicense                           != NULL );
    ChkArg( f_pFFLicense->rgpLicStoreCurrent       != NULL );
    ChkArg( f_pFFLicense->rgpLicStores             != NULL );
    ChkArg( f_pFFLicense->cLicStores                > 0 );
    ChkArg( f_pFFLicense->cLicStores               <= DRM_LICSTORE_MAX_STORES );
    ChkArg( f_pFFLicense->pbBuffer                 != NULL );
    ChkArg( f_pFFLicense->cbBuffer                  > 0 );
    ChkArg( f_pFFLicense->pBindingInfo             != NULL )
    ChkArg( f_pFFLicense->pLicStoreEnum            != NULL );
    ChkArg( f_pdwChainDepth                        != NULL );
    ChkArg( f_pDatastore                           != NULL );
    ChkArg( f_cRights                              <= DRM_MAX_ACTIONS );
    ChkArg( f_pFFLicense->pLicEval                 != NULL );
    ChkArg( f_pFFLicense->pLicEval->pcontextBBX    != NULL );

    f_pFFLicense->pLicEval->fDeleteLicense = FALSE;
    *f_pdwChainDepth = 0;

    ChkBOOL( f_pFFLicense->dwChainDepth < DRM_MAX_LICENSE_CHAIN_DEPTH, DRM_E_LIC_CHAIN_TOO_DEEP );
    if ( f_pFFLicense->dwChainDepth == 0 )
    {
        /*
        ** Only Re-init the stack on the first iteration
        */
        ZEROMEM( f_pFFLicense->pstack, SIZEOF( DRM_STACK_ALLOCATOR_CONTEXT ) );
        ChkDR( DRM_STK_Init( f_pFFLicense->pstack, f_pFFLicense->pbBuffer, f_pFFLicense->cbBuffer ) );

        for( i = 0; i < DRM_MAX_LICENSE_CHAIN_DEPTH; i++ )
        {
#if DRM_SUPPORT_COPY_OPL
            f_pFFLicense->rgfCopyOplValid[i] = FALSE;
#endif
            f_pFFLicense->rgfPlayOplValid[i] = FALSE;
        }
#if DRM_SUPPORT_WMDRMNET
        f_pFFLicense->dwMinimumRequiredAppSec = 0;
#endif
    }

    /* Cache the current stack top in case it needs to be explicitly restored. */
    nStackTop = f_pFFLicense->pstack->nStackTop;

#if DRM_SUPPORT_METERING
    f_pFFLicense->rgfHasMetering [f_pFFLicense->dwChainDepth] = FALSE;
#endif

    ChkDR( _GetLicenseInfoAndSetup( f_pFFLicense, f_rgpdstrRights, f_cRights, f_pDatastore ) );

#if DRM_SUPPORT_REVOCATION
    /*
    ** Compare license RIV and CRL versions,
    ** then return DRM_E_RIV_TOO_SMALL
    ** or DRM_E_LICEVAL_REQUIRED_REVOCATION_LIST_NOT_AVAILABLE error
    */
    ChkDR( _ValidateRevocationVersions( f_pFFLicense, f_pDatastore ) );
#endif /* DRM_SUPPORT_REVOCATION */

    /*
    ** Check if the license has source id >0 and update the dwSourceid in
    ** DRM_FFLICENSE. The source ID should be specified only in leaf license.
    */
    if ( f_pFFLicense->dwChainDepth == 0 )
    {
        ChkDR( _GetSourceIDFromLicense( f_pFFLicense ) );
    }

    f_pFFLicense->pLicEval->dwFlags              = LICEVAL_OPEN_CHECK_SETTINGS;

    /*
    ** The PC is currently using this function to handle temp XMR licenses
    ** which can not be persisted.  Once that is no longer the case, we can remove
    ** all the code #if'd in by this #if.  PS #2762.
    */
    if( f_pFFLicense->pSecStoreLicense != NULL )
    {
        /*
        ** Talk to blackbox to get the secure store password for this license
        */
        ChkDR( DRM_SST_CreateLicenseStatePassword( &f_pFFLicense->pLicEval->LID,
                                                    f_pFFLicense->rgbLicensePassword,
                                                    f_pFFLicense->pLicEval->pcontextBBX ) );

        ChkDR( DRM_SST_OpenKeyTokens( &( f_pFFLicense->pSecStoreLicense[f_pFFLicense->dwChainDepth] ),
                                      &f_pFFLicense->pLicEval->LID,
                                       NULL,
                                       f_pFFLicense->rgbLicensePassword,
                                       0,
                                       SECURE_STORE_LICENSE_DATA,
                                       f_pDatastore ) );

        f_pFFLicense->fSecStoreOpen[f_pFFLicense->dwChainDepth] = TRUE;

        f_pFFLicense->pLicEval->pcontextSSTLicense      = &( f_pFFLicense->pSecStoreLicense[f_pFFLicense->dwChainDepth] );
    }
    else
    {
        f_pFFLicense->pLicEval->pcontextSSTLicense = NULL;
        f_pFFLicense->pLicEval->dwFlags |= LICEVAL_IGNORE_SECURESTORE_ENTRY;
    }

    f_pFFLicense->pLicEval->fGlobalSecStoreWritable = FALSE;

    f_pFFLicense->pLicEval->fReserved            = 0;
#if DRM_SUPPORT_CONTENT_REVOCATION
    f_pFFLicense->pLicEval->dwChainDepth         = f_pFFLicense->dwChainDepth;
#endif
    f_pFFLicense->pLicEval->pDatastore           = f_pDatastore;
    f_pFFLicense->pLicEval->eTimeBasedState      = LICEVAL_NOREFERENECE;
    f_pFFLicense->pLicEval->fDeleteLicense       = FALSE;

    ChkDR( DRM_LEVL_PerformOperations( f_pFFLicense->pLicEval,
                                       DRM_LICENSE_EVAL_SELECT,
                                       DRM_LICENSE_EVAL_CAN_DO_OPERATION,
                                       NULL,
                                      &fEvalResult,
                                       NULL,
                                       f_pDatastore,
                                       f_pfnPolicyCallback,
                                       f_pv ) );
    if ( !fEvalResult )
    {
        /*
        **  We need to make sure that the reason for failure is set correctly.
        **  This is a workaround to compensate for the fact that v9
        **  licenses do not set the reason correctly sometimes.
        */
        if ( f_pFFLicense->pLicEval->lReasonForFail == 0 )
        {
            /*
            ** No reason given by license. Try parsing to get the reason, if we can.
            */
            ( void ) DRM_LEVL_GetLicenseReasonForUnusable( f_pFFLicense->pLicEval,
                                                          &f_pFFLicense->pLicEval->lReasonForFail );
        }
        dr = DRM_E_RIGHTSNOTAVAILABLE;
        /*
        ** If the reason for license not usable is because license expired
        ** OR if the license is "deleting" itself, then delete the license
        */
        if ( f_pFFLicense->pLicEval->lReasonForFail == LR_LICENSE_EXPIRED
          || f_pFFLicense->pLicEval->fDeleteLicense )
        {
            /*
            ** License has expired, delete it
            */
#if DRM_SUPPORT_DELETEDSTORE
            ( void )DRM_LST_DeleteLicenseAndSaveDate( f_pFFLicense->rgpLicStoreCurrent[f_pFFLicense->dwChainDepth],
                                                     &f_pFFLicense->pLicEval->KID,
                                                     &f_pFFLicense->pLicEval->LID,
                                                      NULL,
                                                      TRUE);
#else
            ( void )DRM_LST_DeleteLicense( f_pFFLicense->rgpLicStoreCurrent[f_pFFLicense->dwChainDepth],
                                          &f_pFFLicense->pLicEval->KID,
                                          &f_pFFLicense->pLicEval->LID,
                                           NULL);
#endif

#if DRM_SUPPORT_LICENSE_SYNC
            ( void )DRM_SNC_UpdateKID( f_pFFLicense->pLicEval->pcontextSync,
                                       NULL,
                                      &f_pFFLicense->pLicEval->KID,
                                       NULL,
                                       TRUE );
#endif

            /*
            ** If we're deleting the license, it more or less indicates that the license expired. Some
            ** licenses don't properly set the "reason for fail", so if they never set any reason code
            ** we should just message that it expired.
            */
            if ( f_pFFLicense->pLicEval->lReasonForFail == LR_LICENSE_EXPIRED
             || f_pFFLicense->pLicEval->lReasonForFail == 0 )
            {
                dr = DRM_E_LICENSEEXPIRED;
            }
        }
        goto ErrorExit;
    }

#if DRM_SUPPORT_SECURE_CLOCK
    if ( f_pFFLicense->pLicEval->eTimeBasedState == LICEVAL_MACHINEDATETIMEREFERENCED
     && f_pFFLicense->pLicEval->fInGracePeriod )
    {
        f_pFFLicense->pLicEval->lReasonForFail = LR_LICENSE_CLOCK_NOT_SET;

        ChkDR( DRM_E_RIGHTSNOTAVAILABLE );
    }

#endif

    /*
    **  Get the inclusion list for this license
    */
    if ( f_pFFLicense->pLicEval->fLicenseIsXMR )
    {
        if ( f_pFFLicense->pLicEval->plicenseXMR->containerOuter.containerGlobalPolicies.InclusionList.fValid )
        {
            ChkDR( DRM_XMR_PopulateInclusionList( &f_pFFLicense->pLicEval->plicenseXMR->containerOuter.containerGlobalPolicies.InclusionList,
                                                   f_pFFLicense->inclusionListCallback.rgInclusionList,
                                                   f_pFFLicense->inclusionListCallback.rgfInclusionListValid,
                                                   f_pFFLicense->dwChainDepth ) );
        }
    }
    else
    {
        ChkDR( DRM_LIC_GetInclusionList( &f_pFFLicense->pLicEval->dstrContentLicense,
                                          f_pFFLicense->inclusionListCallback.rgInclusionList,
                                          f_pFFLicense->inclusionListCallback.rgfInclusionListValid,
                                          f_pFFLicense->dwChainDepth ) );
    }

    dr = _PerformActions( f_pFFLicense,
                         &stack,
                          f_rgpdstrRights,
                          f_cRights,
                          f_pDatastore,
                          f_pfnPolicyCallback,
                          f_pv );
#if DRM_SUPPORT_LICENSE_SYNC
    if( dr == DRM_E_LICENSEEXPIRED )
    {
        /* An extensible restriction callback may have given this error code to indicate
        ** that the right has expired and needs to be refreshed.
        */
        ( void )DRM_SNC_UpdateKID( f_pFFLicense->pLicEval->pcontextSync,
                                   NULL,
                                  &f_pFFLicense->pLicEval->KID,
                                   NULL,
                                   TRUE );
    }
#endif
    ChkDR( dr );

#if DRM_SUPPORT_WMDRMNET
    {
        DRM_DWORD dwMinimumRequiredAppSec = 0;

        if ( f_pFFLicense->pLicEval->fLicenseIsXMR )
        {
            dwMinimumRequiredAppSec = f_pFFLicense->pLicEval->plicenseXMR->containerOuter.containerGlobalPolicies.MinimumEnvironment.wMinimumSecurityLevel;
        }
        else
        {
            ChkDR( DRM_ASD_ParseV2License( &f_pFFLicense->pLicEval->dstrContentLicense,
                                           &g_dstrDRM_LS_APPSEC_ATTR,
                                           &dwMinimumRequiredAppSec,
                                            NULL ) );
        }

        if ( dwMinimumRequiredAppSec > f_pFFLicense->dwMinimumRequiredAppSec )
        {
            f_pFFLicense->dwMinimumRequiredAppSec = dwMinimumRequiredAppSec;
        }
    }
#endif

    /*
    ** Get the KID for the chained license
    */
    if ( f_pFFLicense->pLicEval->plicenseXMR != NULL
     && XMR_IS_UPLINK_KID_VALID( f_pFFLicense->pLicEval->plicenseXMR ) )
    {
        DRM_BYT_CopyBytes( oChainKID.rgb,
                           0,
                           f_pFFLicense->pLicEval->plicenseXMR->containerOuter.containerKeys.UplinkKid.pbguidUplinkKID,
                           f_pFFLicense->pLicEval->plicenseXMR->containerOuter.containerKeys.UplinkKid.iguidUplinkKID,
                           SIZEOF( oChainKID.rgb ) );
        fChained = TRUE;
    }
    else if ( f_pFFLicense->pLicEval->rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_CHAINEDKID].cchString != 0 )
    {
        fChained = TRUE;
        ChkDR( DRM_UTL_DecodeKID( &( f_pFFLicense->pLicEval->rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_CHAINEDKID] ),
                                  &oChainKID ) );
    }

    /*
    ** We don't support chained licenses from V1 content
    */
    ChkBOOL( !fChained || f_pFFLicense->pV1Header == NULL, DRM_E_V1_LICENSE_CHAIN_NOT_SUPPORTED );

    if ( fChained )
    {
        DRM_DWORD drCached = DRM_E_LICENSENOTFOUND;

        /*
        ** We're at the maximum chain depth that we support
        */
        ChkBOOL( f_pFFLicense->dwChainDepth + 1 < DRM_MAX_LICENSE_CHAIN_DEPTH, DRM_E_LICENSENOTFOUND );

        /*
        ** Open an enumerator for the KID, increment the chain depth and recurse
        ** Don't recurse if the dependent kid is a kid already in the chain
        */
        if ( f_pFFLicense->rgpLicStores[0]->pDatastore->eImplementationType == eDRM_DST_EMBEDDED )
        {
            /*
            ** Since we never have embedded root licenses, we can avoid looking in the embedded store
            ** for anything above chain depth 0
            */
            ChkDR( f_pFFLicense->cLicStores > 1 );

            ChkDR( DRM_LST_InitEnumMultiple( &f_pFFLicense->rgpLicStores[1],
                                             f_pFFLicense->cLicStores - 1,
                                            &oChainKID,
                                             TRUE,
                                            &( f_pFFLicense->pLicStoreEnum[f_pFFLicense->dwChainDepth+1] ) ) );
        }
        else
        {
            ChkDR( DRM_LST_InitEnumMultiple( f_pFFLicense->rgpLicStores,
                                             f_pFFLicense->cLicStores,
                                            &oChainKID,
                                             TRUE,
                                            &( f_pFFLicense->pLicStoreEnum[f_pFFLicense->dwChainDepth+1] ) ) );
        }

        while( TRUE )
        {
            ChkBOOL( f_pFFLicense->dwChainDepth + 1 < DRM_MAX_LICENSE_CHAIN_DEPTH, DRM_E_LICENSENOTFOUND );

            dr = DRM_LST_EnumNextMultiple( &( f_pFFLicense->pLicStoreEnum[f_pFFLicense->dwChainDepth + 1] ),
                                           &f_pFFLicense->rgkid[f_pFFLicense->dwChainDepth + 1],
                                           &f_pFFLicense->rglid[f_pFFLicense->dwChainDepth + 1],
                                           &f_pFFLicense->rgpLicStoreCurrent[f_pFFLicense->dwChainDepth + 1],
                                           &( f_pFFLicense->rgslotHint[f_pFFLicense->dwChainDepth + 1] ),
                                            NULL );
            if ( dr == DRM_E_NOMORE )
            {
                /*
                ** If uplink KID was not found in the license store, make sure to set 
                ** the proper chain depth and uplink KID anyway
                */
                if ( f_pFFLicense->pLicStoreEnum[f_pFFLicense->dwChainDepth + 1].eMode == eDRM_LICENSE_STORE_MODE_NONE )
                {
                    f_pFFLicense->dwChainDepth++;
                    DRM_BYT_CopyBytes( f_pFFLicense->rgkid[f_pFFLicense->dwChainDepth].rgb,
                                       0,
                                       oChainKID.rgb,
                                       0,
                                       SIZEOF( f_pFFLicense->rgkid[f_pFFLicense->dwChainDepth].rgb ) );
                }
                ChkDR( drCached );
            }

            ChkDR( dr );
            f_pFFLicense->dwChainDepth++;
            dr = DRM_LIC_CompleteLicenseChain( f_pFFLicense,
                                               f_rgpdstrRights,
                                               f_cRights,
                                               f_pdwChainDepth,
                                               f_pDatastore,
                                               f_pfnPolicyCallback,
                                               f_pv );
            f_pFFLicense->dwChainDepth--;
            if ( DRM_SUCCEEDED( dr ) )
            {
                goto ErrorExit;
            }
            drCached = dr;
        }
    }
    else
    {
        if( f_pFFLicense->fDomainBoundRootRequired )
        {
            /*
            ** The license evaluator for some license in the chain indicated
            **  that the root license MUST be domain-bound in order for
            **  chain evaluation to succeed.  Verify this here.
            */
            ChkBOOL(
                ( f_pFFLicense->pLicEval->plicenseXMR != NULL )
             && XMR_IS_DOMAIN_ID_VALID( f_pFFLicense->pLicEval->plicenseXMR ),
                DRM_E_RIGHTSNOTAVAILABLE );
        }

        /*
        ** We can use this license.  Now try to set up a decryptor.
        ** Only setup a decryptor if this is either a simple license ( no chain ),
        ** or the last link in the chain
        */
        if ( !f_pFFLicense->fCanBind )
        {
            ChkDR( _ProcessEndOfChain( f_pFFLicense, f_pfnPolicyCallback, f_pv ) );
        }
    }
    *f_pdwChainDepth = f_pFFLicense->dwChainDepth + 1;

ErrorExit:

    if ( DRM_FAILED( dr )
     && f_pdwChainDepth != NULL )
    {
        *f_pdwChainDepth = max( *f_pdwChainDepth, f_pFFLicense->dwChainDepth + 1 );
    }

    /*
    ** If the function fails and a stack buffer has been allocated for the license(
    ** allocated in _GetLicenseInfoAndSetup() at the beginning of the function),
    ** the stack buffer has to be released. Otherwise future stack allocation for the
    ** next candidate license may fail with DRM_E_BUFFERTOOSMALL.
    */
    if ( DRM_FAILED( dr )
     && f_pFFLicense != NULL
     && f_pFFLicense->pstack != NULL
     && nStackTop != ULONG_MAX )
    {
        f_pFFLicense->pstack->nStackTop = nStackTop;
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}



/*****************************************************************************
** Function : DRM_LIC_ReportActions
**
** Synopsis : Report actions and update metering info
**
** Parameters:
**      [f_pFFLicense]    : Specifies the find first license structure to use
**      [f_rgpdstrRights] : Specifies the set of rights strings
**      [f_cRights]       : Specifies the number of elements in f_rgpdstrRights
**      [f_dwChainDepth]  : Specifies the current chain depth
**      [f_pDatastore]    : Specifies the DST
**      [f_pfnPolicyCallback] : Callback function for output restrictions
**      [f_pv]                      : Void pass-through parameter for callback
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          A required argument was NULL or invalid
**      DRM_E_RIGHTSNOTAVAILABLE
**          Unable to parse a right from the license
**      DRM_E_LICENSENOTFOUND
**          License not found
**
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_LIC_ReportActions(
    IN OUT   DRM_FFLICENSE                *f_pFFLicense,
    IN const DRM_CONST_STRING             *f_rgpdstrRights[], /* Array of DRM_CONST_STRING pointers */
    IN       DRM_DWORD                     f_cRights,
    IN       DRM_DWORD                     f_dwChainDepth,
    IN       DRM_DST                      *f_pDatastore,
    IN       DRMPFNPOLICYCALLBACK          f_pfnPolicyCallback,
    IN const DRM_VOID                     *f_pv )
{
    DRM_RESULT dr          = DRM_SUCCESS;
    DRM_DWORD  cbLicSize   = 0;
    DRM_DWORD  iCount      = 0;
    DRM_DWORD  iRights     = 0;
    DRM_BOOL   fEvalResult = FALSE;
    DRM_BOOL   fExisted    = FALSE;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMCHAIN, PERF_FUNC_DRM_LIC_ReportActions );

    ChkArg( f_pFFLicense != NULL );

    /*
    ** Report actions and update metering info
    */
    for( ; iCount < f_dwChainDepth ; iCount++ )
    {
        f_pFFLicense->rgfDeleteLicense[iCount] = FALSE;

        /*
        ** Read the licenses from the license store again.  It will need
        **  refreshing if it was a chained license
        */
        if ( f_pFFLicense->pLicenseXMR == NULL )
        {
            cbLicSize = f_pFFLicense->cbBuffer;
            ChkDR( DRM_LST_GetLicense( f_pFFLicense->rgpLicStoreCurrent[iCount],
                                      &f_pFFLicense->rgkid[iCount],
                                      &f_pFFLicense->rglid[iCount],
                                      &( f_pFFLicense->rgslotHint[iCount] ),
                                       f_pFFLicense->pbBuffer, 
                                      &cbLicSize ) );

            DSTR_FROM_PB( &( f_pFFLicense->pLicEval->dstrContentLicense ),
                            f_pFFLicense->pbBuffer,
                            cbLicSize );
            f_pFFLicense->pLicEval->fUseCachedAttribs = FALSE;

            /*
            **  Load the necessary License Attribs
            */
            ChkDR( _LoadLicenseAttributes( f_rgpdstrRights, f_cRights, f_pFFLicense->pLicEval ) );

        }

        if ( NULL == f_pFFLicense->pSecStoreLicense )
        {
            f_pFFLicense->pLicEval->pcontextSSTLicense  = NULL;
        }
        else
        {
            f_pFFLicense->pLicEval->pcontextSSTLicense  = &( f_pFFLicense->pSecStoreLicense[iCount] );
        }
        
        f_pFFLicense->pLicEval->fGlobalSecStoreWritable = FALSE;
        f_pFFLicense->pLicEval->fReserved               = 0;
#if DRM_SUPPORT_CONTENT_REVOCATION
        f_pFFLicense->pLicEval->dwChainDepth            = iCount;
#endif
        if ( f_pFFLicense->pLicenseXMR != NULL )
        {
            f_pFFLicense->pLicEval->plicenseXMR   = &f_pFFLicense->pLicenseXMR[iCount];
            f_pFFLicense->pLicEval->fLicenseIsXMR =  TRUE;
        }
        else
        {
            f_pFFLicense->pLicEval->fLicenseIsXMR = FALSE;
        }

        f_pFFLicense->pLicEval->fDeleteLicense = FALSE;
        iRights = f_cRights;
        for( ; iRights > 0; )
        {
            fEvalResult = FALSE;
            fExisted    = FALSE;

            iRights--;
            ChkDR( DRM_LEVL_PerformOperations( f_pFFLicense->pLicEval,
                                               DRM_LICENSE_EVAL_ACTION,
                                               DRM_LICENSE_EVAL_DONE_WITH_OPERATION,
                                               f_rgpdstrRights[iRights],
                                              &fEvalResult,
                                              &fExisted,
                                               f_pDatastore,
                                               f_pfnPolicyCallback,
                                               f_pv ) );

            ChkBOOL( !fExisted || fEvalResult, DRM_E_RIGHTSNOTAVAILABLE );
        }
        f_pFFLicense->rgfDeleteLicense[iCount] = f_pFFLicense->pLicEval->fDeleteLicense;
    }
ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


DRM_API DRM_RESULT DRM_CALL DRM_LIC_GetInclusionList(
    IN const DRM_CONST_STRING  *pdstrLicense,
    IN OUT   DRM_GUID           rgInclusionList[DRM_MAX_INCLUSION_GUIDS],
    IN OUT   DRM_BOOL           rgfGuidValid[DRM_MAX_INCLUSION_GUIDS][DRM_MAX_LICENSE_CHAIN_DEPTH],
    IN       DRM_DWORD          dwChainDepth )
{
    DRM_RESULT       dr       = DRM_SUCCESS;
    DRM_CONST_STRING dstrList = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrGuid = EMPTY_DRM_STRING;
    DRM_DWORD        dwGuid    = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMCHAIN, PERF_FUNC_DRM_LIC_GetInclusionList );

    /*
    ** Set all the valid flags at this chain depth to FALSE for all GUIDs
    */
    for( ; dwGuid < DRM_MAX_INCLUSION_GUIDS; dwGuid++ )
    {
        rgfGuidValid[dwGuid][dwChainDepth] = FALSE;
    }

    dwGuid = 0;

    ChkDR( DRM_XML_GetSubNodeByPath( pdstrLicense, &g_dstrTagDataInclusionList, NULL, NULL, &dstrList, NULL, g_wchForwardSlash ) );

    while( DRM_SUCCEEDED( DRM_XML_GetSubNode( &dstrList, &g_dstrGUID, NULL, NULL, dwGuid, NULL, &dstrGuid, 1 ) ) )
    {
        DRM_GUID guid;

        if ( dwChainDepth == 0
         && dwGuid        >= DRM_MAX_INCLUSION_GUIDS )
        {
            /*
            **  If this is a leaf license we have to stop at the Maximum number of guids
            */
            ChkDR( DRM_E_TOO_MANY_INCLUSION_GUIDS );
        }

        /*
        **  Convert the value to a GUID
        */

        if ( DRM_SUCCEEDED( DRM_UTL_StringToGuid(  &dstrGuid, &guid ) ) )
        {

            if ( dwChainDepth == 0 )
            {
                /*
                **  For the leaf license we need to populate the output array of GUIDs
                **  and valid list as appropriate
                */
                MEMCPY( &rgInclusionList[dwGuid], &guid, SIZEOF( guid ) );
                rgfGuidValid[dwGuid][0] = TRUE;
            }
            else
            {
                DRM_DWORD i;

                /*
                **  For non-leaf licenses we should check to see if this guid is in the list and if so is it valid
                **  at the previous chain level.  If it is then it is still valid at the current level.
                */
                for( i = 0; i < DRM_MAX_INCLUSION_GUIDS; i++ )
                {
                    if ( MEMCMP( &rgInclusionList[i], &guid, SIZEOF( guid ) ) == 0
                     && rgfGuidValid[i][dwChainDepth - 1] )
                    {
                        rgfGuidValid[i][dwChainDepth] = TRUE;
                    }
                }
            }
        }
        dwGuid++;
    }


ErrorExit:

    if ( dr != DRM_E_TOO_MANY_INCLUSION_GUIDS )
    {
        /* Don't fail for any reason other than too many GUIDs */
        dr = DRM_SUCCESS;
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


#if DRM_SUPPORT_ANTIROLLBACK_CLOCK

/******************************************************************************
**
** Function: DRM_LIC_CheckClockRollback
**
** Synopsis: Check for clock rollback
**
** Arguments:
**      [f_pLicEval]        : Specifies the liceval context to use
**      [f_pLicStoreXML]    : Pointer to the XML license store (optional, may be NULL)
**      [f_pLicStoreXMR]    : Pointer to the XMR license store (optional, may be NULL)
**      [f_pLicEnum]        : Pointer to the license store enum context
**      [f_pbBuffer]        : Buffer used internally to store licenses
**      [f_cbBuffer]        : Specifies the size in bytes of f_pbBuffer
**      [f_pDatastore]      : Specifies the DST context
**      [f_poStack]         : Pointer to a stack allocator context
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the required pointer parameters is NULL
**      DRM_E_OUTOFMEMORY
**          The buffer provided is too small
**
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_LIC_CheckClockRollback(
    IN DRM_LICEVAL_CONTEXT         *f_pLicEval,
    IN DRM_LICSTORE_CONTEXT        *f_pLicStoreXML,
    IN DRM_LICSTORE_CONTEXT        *f_pLicStoreXMR,
    IN DRM_LICSTOREENUM_CONTEXT    *f_pLicEnum,
    IN DRM_BYTE                    *f_pbBuffer,
    IN DRM_DWORD                    f_cbBuffer,
    IN DRM_DST                     *f_pDatastore,
    IN DRM_STACK_ALLOCATOR_CONTEXT *f_poStack )
{
    DRM_RESULT dr          = DRM_SUCCESS;
    DRM_BOOL   fEvalResult = TRUE;
    DRM_BOOL   fEvalTmp    = FALSE;
    DRM_KID    oKID        = { 0 };
    DRM_LID    oLID        = { 0 };
    DRM_DWORD  i           = 0;
    DRM_BYTE   rgbPassword [__CB_DECL( DRM_SHA1_DIGEST_LEN )] = { 0 };
    DRM_LICSTORE_CONTEXT   *pLicStore           = NULL;
    const DRM_CONST_STRING *pdstrSetClockString = &g_dstrSetSavedDateTime;
    DRM_XMR_LICENSE oLicXMR= { 0 };

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMCHAIN, PERF_FUNC_DRM_LIC_CheckClockRollback );

    ChkArg( f_pLicEval    != NULL );
    ChkArg( f_pLicEnum    != NULL );
    ChkArg( f_pDatastore  != NULL );
    ChkArg( f_pbBuffer    != NULL );
    ChkArg( f_poStack     != NULL );

    dr = DRM_LEVL_EvaluateExpression( f_pLicEval,
                                     &g_dstrCheckClockRollback,
                                     &fEvalResult );

    if ( dr == CPRMEXP_RETRIEVAL_FAILURE )
    {
        /*
        ** This error code indicates the the global clock rollback value in the secure store
        ** doesn't exist, which would be the case if this is a fresh DST file. Let's rollback
        ** anyway, because there shouldn't be any licenses if it's fresh and if there are then
        ** someone is tampering.
        */
        dr = DRM_SUCCESS;
    }
    else
    {
        ChkDR( dr );
    }

    for ( i = 0; i < 2; i++ )
    {
        pLicStore = ( i == 0 )? f_pLicStoreXML : f_pLicStoreXMR;

        if ( pLicStore != NULL && fEvalResult )
        {
            /*
            ** The clock set string in this case will set the saved date time to the current time
            ** If this code path isn't executed the expression logic will only set the clock to a time
            ** forward from what the current saved date time is
            */
            pdstrSetClockString = &g_dstrResetRollbackedClock;

            /*
            ** There was a failure or the clock was roll back.  In either case we report that as
            ** clock rollback
            */
            ChkDR( DRM_LST_InitEnum( pLicStore, NULL, FALSE, f_pLicEnum ) );

            while( TRUE ) /* Loop will break when DRM_E_NOMORE is hit */
            {
                DRM_DWORD cbLicSize        = 0;
                DRM_DST_SLOT_HINT slotHint = { 0 };

                cbLicSize = f_cbBuffer;
                dr = DRM_LST_EnumNext( f_pLicEnum, &oKID, &oLID, &slotHint, &cbLicSize );

                if ( dr == DRM_E_NOMORE )
                {
                    dr = DRM_SUCCESS;
                    break;
                }
                ChkDR( dr );

                /*
                ** We could fail because the buffer isn't big enough.
                */
                ChkBOOL( cbLicSize <= f_cbBuffer, DRM_E_OUTOFMEMORY );

                ChkDR( DRM_LST_GetLicense( pLicStore,
                                          &oKID,
                                          &oLID,
                                          &slotHint,
                                           f_pbBuffer,
                                          &cbLicSize ) );

                DSTR_FROM_PB( &( f_pLicEval->dstrContentLicense ), f_pbBuffer, cbLicSize );
                f_pLicEval->fUseCachedAttribs = FALSE;

                MEMCPY( &f_pLicEval->LID, &oLID, SIZEOF( DRM_LID ) );

                ChkDRContinue( DRM_BBX_HashValue( f_pLicEval->LID.rgb,
                                                  SIZEOF( f_pLicEval->LID.rgb ),
                                                  rgbPassword,
                                                  f_pLicEval->pcontextBBX ) );

                ChkDRContinue( DRM_SST_OpenKeyTokens( f_pLicEval->pcontextSSTLicense,
                                                     &f_pLicEval->LID,
                                                      NULL,
                                                      rgbPassword,
                                                      0,
                                                      SECURE_STORE_LICENSE_DATA,
                                                      f_pDatastore ) );

                f_pLicEval->fGlobalSecStoreWritable = FALSE;
                f_pLicEval->dwFlags                 = LICEVAL_OPEN_CHECK_SETTINGS;
                f_pLicEval->fReserved               = 0;
                f_pLicEval->fLicenseIsXMR           = ( pLicStore == f_pLicStoreXMR );
                f_pLicEval->fDeleteLicense          = FALSE;

                if ( f_pLicEval->fLicenseIsXMR )
                {
                    f_pLicEval->plicenseXMR = &oLicXMR;

                    ChkDR( DRM_XMR_UnpackLicense( f_pbBuffer,
                                                  cbLicSize,
                                                  f_poStack,
                                                  f_pLicEval->plicenseXMR ) );
                }

                dr = DRM_LEVL_PerformOperations( f_pLicEval,
                                                 DRM_LICENSE_EVAL_REPORTCLOCK_ROLLBACK,
                                                 DRM_LICENSE_EVAL_DONE_WITH_OPERATION,
                                                 NULL,
                                                &fEvalTmp,
                                                 NULL,
                                                 f_pDatastore,
                                                 NULL,
                                                 NULL );

                if ( f_pLicEval->fDeleteLicense )
                {
                    ( void ) DRM_LST_EnumDelete( f_pLicEnum );
                }

                DRM_SST_CloseKey( f_pLicEval->pcontextSSTLicense, f_pDatastore, NULL, NULL );
            }
        }
    }
    /*
    ** update the saveddatetime -- ignore errors here
    */
    f_pLicEval->fGlobalSecStoreWritable = TRUE;
    DRM_LEVL_EvaluateExpression( f_pLicEval, pdstrSetClockString, &fEvalTmp );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


#endif  /* DRM_SUPPORT_ANTIROLLBACK_CLOCK  */


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmcleanstore.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcontextsizes.h>
#include <drmsyncstore.h>
#include <drmlicstore.h>
#include <drmdatastore.h>

ENTER_PK_NAMESPACE_CODE;

#if DRM_SUPPORT_CLEANUP 

static const DRM_DWORD g_dwPercentageTimeForDefrag = 10;

#define _REPORT_STATUS                                                 \
{                                                                      \
    ++iLicense;                                                        \
    if ( f_pfnCallback                       != NULL                   \
     && ( iLicense % cLicBetweenCBInterval ) == 0 )                    \
    {                                                                  \
        ChkDR( f_pfnCallback( f_pvCallerData, iLicense, cLicenses ) ); \
    }                                                                  \
}

#endif /* DRM_SUPPORT_CLEANUP */

/**********************************************************************
** 
** Function :   DRM_LST_Clean
** 
** Synopsis :   Cleanup the XML and XMR license stores specified in
**              f_pContextLSTXML and f_pContextLSTXMR. For PC 
**              ( if DRM_SUPPORT_CLEANUP is defined ), it will remove 
**              unusable licenses from the License store, and then "defrag"
**              the store. For devices, it will only defrag the store
** 
** Arguments :  
**      [f_pContextLEVL]       : Preinitialized License eval context
**      [f_pContextLSTXML]     : Preinitialized LicStore context ( XML store )
**      [f_pContextLSTXMR]     : Preinitialized LicStore context ( XMR store )
**                               May be NULL
**      [f_pbBuffer]           : Buffer supplied by user
**      [f_cbBuffer]           : Size of f_pbBuffer
**      [f_pvCallerData]       : Opaque context data to be funnelled
**                               back to caller during callback. Could be NULL.
**      [f_dwCallbackInterval] : % completion after which callback ( if any ) 
**                               should be invoked. e.g. if dwCallbackInterval = 5, 
**                               callback will be invoked after 5%, 10%, 15%, etc. 
**                               completion
**      [f_pfnCallback]        : Optional caller supplied callback function
**      [f_pDatastore]         : Preinitialized DST context
**
** Returns :    
**      DRM_SUCCESS
**          Success  
**      DRM_E_INVALIDARG
**          One of the required pointer arguments was NULL   
** 
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_LST_Clean (
    IN DRM_BYTE *f_pContextLEVL,
    __in_bcount( SIZEOF( DRM_LICSTORE_CONTEXT ) ) DRM_BYTE *f_pContextLSTXML,
    __in_bcount( SIZEOF( DRM_LICSTORE_CONTEXT ) ) DRM_BYTE  *f_pContextLSTXMR,
    __in DRM_LICSTOREENUM_CONTEXT *f_pLicStoreEnumContext,
    __in_bcount(f_cbBuffer ) DRM_BYTE *f_pbBuffer,
    IN       DRM_DWORD                f_cbBuffer,
    IN const DRM_VOID                *f_pvCallerData,
    IN       DRM_DWORD                f_dwCallbackInterval,
    IN       pfnStoreCleanupProgress  f_pfnCallback,
    IN       DRM_DST                 *f_pDatastore )
{
    DRM_RESULT           dr                    = DRM_SUCCESS;    
#if DRM_SUPPORT_CLEANUP    
    DRM_KID              KID                   = { 0 };
    DRM_LID              LID                   = { 0 };
    DRM_BOOL             fDelete               = FALSE;
    DRM_DWORD            cLicenses             = 0;  
    DRM_DWORD            iLicense              = 0;
    DRM_DWORD            cLicBetweenCBInterval = 0;
    DRM_DWORD            cbLicense             = 0;
    DRM_DWORD            dwTemp                = 0;
    DRM_LICEVAL_CONTEXT *pContextLEVL          = ( DRM_LICEVAL_CONTEXT * )f_pContextLEVL;
    DRM_BYTE            *pContextLSTCurrent    = f_pContextLSTXML;
    DRM_DST_SLOT_HINT    slotHint              = { 0 };
#endif /* DRM_SUPPORT_CLEANUP */

    ChkArg( f_pContextLEVL         != NULL );
    ChkArg( f_pContextLSTXML       != NULL );
    ChkArg( f_pbBuffer             != NULL );
    ChkArg( f_pDatastore           != NULL );
    ChkArg( f_pLicStoreEnumContext != NULL );

#if DRM_SUPPORT_CLEANUP 

    if ( f_pfnCallback )
    {
        /*
        ** Query for all XML licenses  
        */
        ChkDR( DRM_LST_InitEnum( ( DRM_LICSTORE_CONTEXT * )f_pContextLSTXML, 
                                 NULL, 
                                 FALSE, 
                                 f_pLicStoreEnumContext ) );
        
        /*
        **  Count the number of licenses in XML store
        */
        ChkDR( DRM_LST_LicCount( f_pLicStoreEnumContext, &cLicenses ) );
        
        /*
        ** Query for all XMR licenses  
        ** Note that until LEVL supports XMR licenses, the XMR store cannot be fully
        ** cleaned up 
        */
        if ( f_pContextLSTXMR != NULL )
        {
            ChkDR( DRM_LST_InitEnum( ( DRM_LICSTORE_CONTEXT * )f_pContextLSTXMR, 
                                     NULL, 
                                     FALSE, 
                                     f_pLicStoreEnumContext ) );
                                     
            /*
            **  Count the number of licenses in XMR store
            */
            ChkDR( DRM_LST_LicCount( f_pLicStoreEnumContext, &dwTemp ) );
            
            cLicenses += dwTemp;
        }                                    

        /*
        **  Callback to confirm whether cleanup should be started 
        **  Caller returns an error to indicate that cleanup should be aborted  
        */
        ChkDR( f_pfnCallback( f_pvCallerData, 0, cLicenses ) );
        
        cLicBetweenCBInterval = ( ( f_dwCallbackInterval * cLicenses ) 
                                * ( 100 + g_dwPercentageTimeForDefrag ) ) / ( 100 * 100 );

        /*
        **  For certain values of callbackinterval and size of the  
        **  store, this value might become zero                     
        **  Make sure that this value is reset to 1                 
        */
        if ( cLicBetweenCBInterval == 0 )
        {
            cLicBetweenCBInterval = 1;  
        }           
    }
    
    /*
    **  Query for all XML licenses  
    */
    ChkDR( DRM_LST_InitEnum( ( DRM_LICSTORE_CONTEXT * )pContextLSTCurrent, 
                             NULL,
                             FALSE, 
                             f_pLicStoreEnumContext ) );   
    
    /*
    ** Loop will continue until DRM_E_NOMORE, which is remapped at ErrorExit,
    ** or a real failure occurs
    */
    while( TRUE ) 
    {
        cbLicense = 0;        
               
        dr = DRM_LST_EnumNext( f_pLicStoreEnumContext,
                              &KID, 
                              &LID, 
                              &slotHint,
                              &cbLicense ); 

        if ( dr == DRM_E_NOMORE )
        {
            /*
            ** If we run out of licenses in the XML store, switch to the XMR store
            */
            if( pContextLSTCurrent == f_pContextLSTXML
             && f_pContextLSTXMR   != NULL )
            {
                pContextLSTCurrent = f_pContextLSTXMR;
                
                ChkDR( DRM_LST_InitEnum( ( DRM_LICSTORE_CONTEXT * )pContextLSTCurrent, 
                                          NULL,
                                          FALSE, 
                                          f_pLicStoreEnumContext ) );
                                          
                dr = DRM_LST_EnumNext( f_pLicStoreEnumContext,
                                         &KID, 
                                         &LID, 
                                         &slotHint,
                                         &cbLicense );
                if( dr == DRM_E_NOMORE )
                {
                    /* We're done with the loop */
                    ChkDR( DRM_SUCCESS );
                    break;
                }
                ChkDR( dr );
            }
            else
            {
                /* We're done with the loop */
                ChkDR( DRM_SUCCESS );
                break;
            }
        }
        ChkDR( dr );     

        /*
        **  Ignore licenses whose size is greater than size of buffer available        
        */
        if ( cbLicense <= f_cbBuffer )
        {
            /*
            **  Use buffer provided by user 
            */ 
            dr =  DRM_LST_GetLicense( ( DRM_LICSTORE_CONTEXT * )pContextLSTCurrent,
                                      &KID, 
                                      &LID, 
                                      &slotHint,
                                       f_pbBuffer, 
                                      &cbLicense );  
            /*
            **  Ignore failure and continue deleting other licenses  
            */                                                  
            if ( DRM_SUCCEEDED ( dr ) )
            {
                DRM_STACK_ALLOCATOR_CONTEXT oStack = {0};
                DRM_BYTE rgbPassword[DRM_SHA1_DIGEST_LEN];
                
                if( pContextLSTCurrent == f_pContextLSTXMR )
                {
                    DRM_BYTE *pbStack = NULL;
                    DRM_DWORD cbStack = 0;
                    
                    pContextLEVL->fLicenseIsXMR = TRUE;

                    ChkDR( DRM_UTL_EnsureDataAlignment( f_pbBuffer + cbLicense, f_cbBuffer - cbLicense, &pbStack, &cbStack, SIZEOF( DRM_DWORD ), NULL ) );
                    ChkDR( DRM_STK_Init( &oStack, pbStack, cbStack ) );
                    ChkDR( DRM_STK_Alloc( &oStack, SIZEOF( DRM_XMR_LICENSE ), (DRM_VOID**)&pContextLEVL->plicenseXMR ) );
                    ZEROMEM( pContextLEVL->plicenseXMR, SIZEOF( DRM_XMR_LICENSE ) );
                    ChkDR( DRM_XMR_UnpackLicense( f_pbBuffer,
                                                  cbLicense,
                                                 &oStack,
                                                  pContextLEVL->plicenseXMR ) );
                }
                else
                {
                    pContextLEVL->fLicenseIsXMR = FALSE;
                    /*
                    ** Add info about this license to the license evaluator obj 
                    */
                    DSTR_FROM_PB( &pContextLEVL->dstrContentLicense, f_pbBuffer, cbLicense );
                    pContextLEVL->fUseCachedAttribs = FALSE;
                }

                /*
                ** Talk to BB to get the secstore password for this license 
                */
                ChkDR( DRM_SST_CreateLicenseStatePassword( &LID, 
                                                            rgbPassword, 
                                                            pContextLEVL->pcontextBBX ) );

                dr = DRM_SST_OpenKeyTokens( pContextLEVL->pcontextSSTLicense,
                                           &LID,
                                            NULL,
                                            rgbPassword,
                                            0,
                                            SECURE_STORE_LICENSE_DATA,
                                            f_pDatastore );     
                /*  
                **  Note there is no need to close this store.  
                **  We don't care to report actions we just peek inside 
                */
                if ( dr == DRM_E_FILENOTFOUND )
                {
                    /*
                    ** Data corruption - delete this license    
                    */
                    ( void )DRM_LST_EnumDelete( f_pLicStoreEnumContext );
                } 
                else if ( DRM_SUCCEEDED( dr ) )
                {
                    /*
                    ** Save the store context  
                    */
                    pContextLEVL->pDatastore = f_pDatastore;

                    MEMCPY( pContextLEVL->KID.rgb, KID.rgb, SIZEOF( DRM_KID ) );
                    MEMCPY( pContextLEVL->LID.rgb, LID.rgb, SIZEOF( DRM_LID ) );
                           
                    fDelete = FALSE;
                    if ( DRM_SUCCEEDED( DRM_LEVL_IsLicenseReadyForDeletion( pContextLEVL, 
                                                                           &fDelete ) ) 
                      && fDelete )
                    {               
#if DRM_SUPPORT_DELETEDSTORE
                        ( void )DRM_LST_EnumDeleteAndSaveDate( f_pLicStoreEnumContext, TRUE );
#else
                        ( void )DRM_LST_EnumDelete( f_pLicStoreEnumContext );
#endif
                    }
                }                    
            }
            _REPORT_STATUS;             
         }                            
    }    

#endif /* DRM_SUPPORT_CLEANUP */

    /*
    **  Defrag the license store    
    */
    ChkDR( DRM_DST_CleanupStore( f_pDatastore, TRUE ) );    
                 
ErrorExit:
    /*
    ** Remap DRM_E_NOMORE to DRM_SUCCESS
    */
    if( dr == DRM_E_NOMORE )
    {
        dr = DRM_SUCCESS;
    }

    return dr;
}


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmcontract.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include "drmcontract.h"

ENTER_PK_NAMESPACE_CODE;

#if DRM_ERROR_CONTRACT_TEST_MODE

/*
** Set of error codes listed for each API. DRM_SUCCESS is used as the terminator of each API list.
**
** IF YOU MODIFY/ADD ANY OF THESE DATA STRUCTURES, YOU MUST ALSO ENSURE THAT THE CHM FILE IS ACCURATE.
*/

DRM_RESULT g_rgdrGenericErrorList[] =
{
    DRM_E_INVALIDARG,
    DRM_E_BUFFERTOOSMALL,
    DRM_E_DSTBLOCKMISMATCH,
    DRM_E_DSTCORRUPTED,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_Reinitialize[] =
{
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_Content_UpdateEmbeddedStore[] =
{
    DRM_E_CH_INCOMPATIBLE_HEADER_TYPE,
    DRM_E_HEADER_NOT_SET,
    DRM_S_FALSE,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_Content_UpdateEmbeddedStore_Commit[] =
{
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_Content_SetProperty[] =
{
    DRM_E_CH_INVALID_HEADER,
    DRM_E_CH_INCOMPATIBLE_HEADER_TYPE,
    DRM_E_HEADER_ALREADY_SET,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_Content_GetProperty[] =
{
    DRM_E_CH_INVALID_HEADER,
    DRM_E_HEADER_NOT_SET,
    DRM_E_CH_INCOMPATIBLE_HEADER_TYPE,
    DRM_E_CH_KID_MISSING,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_LicenseAcq_GenerateChallenge[] =
{
    DRM_E_V1_NOT_SUPPORTED,
    DRM_E_HEADER_NOT_SET,
    DRM_E_SYNC_ENTRYNOTFOUND,
    DRM_E_NO_URL,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_Device_GetProperty[] =
{
    DRM_E_INVALIDDEVICECERTIFICATETEMPLATE,
    DRM_E_DEVCERTREADERROR,
    DRM_E_UNKNOWN_DEVICE_PROPERTY,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_SyncListItem_InitEnum[] =
{
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_SyncListItem_EnumNext[] =
{
    DRM_E_SYNC_ENTRYNOTFOUND,
    DRM_E_NOMORE,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_LicenseAcq_ProcessResponse[] =
{
    DRM_E_FAILED_TO_STORE_LICENSE,
    DRM_E_NOT_ALL_STORED,
    DRM_E_DRMNOTINIT,
    DRM_E_REVOCATION_BUFFERTOOSMALL,
    DRM_E_CERTIFICATE_REVOKED,
    DRM_E_PRIVKEYREADERROR,
    DRM_E_INVALID_REVOCATION_LIST,
    DRM_E_XMLNOTFOUND,
    DRM_E_SOAPXML_XML_FORMAT,
    DRM_E_XMLSIG_ECDSA_VERIFY_FAILURE,
    DRM_E_INVALIDLICENSE,
    DRM_E_UNKNOWN_BINDING_KEY,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_License_GetProperty[] =
{
    DRM_E_LICENSENOTBOUND,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_Reader_Commit[] =
{
    DRM_E_DRMNOTINIT,
    DRM_E_LICENSENOTBOUND,
    DRM_E_PRIVKEYREADERROR,
    DRM_E_METERING_STORE_CORRUPT,
    DRM_E_METERCERTNOTFOUND,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_Reader_InitDecrypt[] =
{
    DRM_E_CIPHER_NOTINITIALIZED,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_Reader_Decrypt[] =
{
    DRM_E_CIPHER_NOTINITIALIZED,
    DRM_E_DECRYPT_NOTINITIALIZED,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_LicenseQuery_GetState[] =
{
    DRM_E_HEADER_NOT_SET,
    DRM_E_DRMNOTINIT,
    DRM_E_LIC_CHAIN_TOO_DEEP,
    DRM_E_CH_KID_MISSING,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_MeterCert_InitEnum[] =
{
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_MeterCert_EnumNext[] =
{
    DRM_E_METERCERTNOTFOUND,
    DRM_E_NOMORE,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_MeterCert_Update[] =
{
    DRM_E_METERCERTNOTFOUND,
    DRM_E_INVALID_METERCERT_SIGNATURE,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_MeterCert_Delete[] =
{
    DRM_E_METERCERTNOTFOUND,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_Metering_GenerateChallenge[] =
{
    DRM_E_DRMNOTINIT,
    DRM_E_INVALID_METERCERT_SIGNATURE,
    DRM_E_METERING_NOT_SUPPORTED,
    DRMUTIL_UNSUPPORTED_VERSION,
    DRM_E_DEVCERTEXCEEDSIZELIMIT,
    DRM_E_BUFFERTOOSMALL,
    DRM_E_NOMORE,
    DRM_S_FALSE,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_LicenseAcq_GetContentHeader[] =
{
    DRM_E_DRMNOTINIT,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_Sync_GenerateChallenge[] =
{
    DRM_E_DRMNOTINIT,
    DRM_E_NOMORE,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_Metering_ProcessResponse[] =
{
    DRM_E_DRMNOTINIT,
    DRM_E_METERING_NOT_SUPPORTED,
    DRM_E_METERSTORE_DATA_NOT_FOUND,
    DRM_E_METERING_MID_MISMATCH,
    DRM_E_METERING_INVALID_COMMAND,
    DRM_E_INVALID_METERRESPONSE_SIGNATURE,
    DRM_E_METERCERTNOTFOUND,
    DRM_E_CERTIFICATE_REVOKED,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_SecureClock_ProcessResponse[] =
{
    DRM_E_CLK_NOT_SUPPORTED,
    DRM_E_PRIVKEYREADERROR,
    DRM_E_CLK_INVALID_RESPONSE,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_SecureClock_GenerateChallenge[] =
{
    DRM_E_CLK_NOT_SUPPORTED,
    DRM_E_PRIVKEYREADERROR,
    DRM_E_DEVCERTREADERROR,
    DRM_E_INVALIDDEVICECERTIFICATETEMPLATE,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_SecureClock_GetValue[] =
{
    DRM_E_CLK_NOT_SUPPORTED,
    DRM_E_PRIVKEYREADERROR,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_Reader_Bind[] =
{
    DRM_E_HEADER_NOT_SET,
    DRM_E_LICENSENOTFOUND,
    DRM_E_CLK_NOT_SET,
    DRM_E_NO_CLK_SUPPORTED,
    DRM_E_CONDITIONNOTSUPPORTED,
    DRM_E_INVALIDLICENSE,
    DRM_E_LICENSEEXPIRED,
    DRM_E_RIGHTSNOTAVAILABLE,
    DRM_E_NO_OPL_CALLBACK,
    DRM_E_LICEVAL_REQUIRED_REVOCATION_LIST_NOT_AVAILABLE,
    DRM_E_RIV_TOO_SMALL,
    DRM_E_INVALID_REVOCATION_LIST,
    DRM_E_EXTENDED_RESTRICTION_NOT_UNDERSTOOD,
    DRM_E_DOMAIN_BIND_LICENSE,
    DRM_E_V1_LICENSE_CHAIN_NOT_SUPPORTED,
    DRM_E_CH_BAD_KEY,
    DRM_E_LIC_KEY_DECODE_FAILURE,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_StoreMgmt_DeleteLicenses[] =
{
    DRM_E_LICENSENOTFOUND,
    DRM_E_LOGICERR,
    DRM_E_CH_KID_MISSING,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_ProcessRequest[] =
{
    DRM_E_NOTIMPL,
    DRM_SUCCESS
};
DRM_RESULT g_rgdrDrm_ProcessCommand[] =
{
    DRM_E_INVALID_LICENSE_REVOCATION_LIST_SIGNATURE,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_MeterCert_Invalidate[] =
{
    DRM_E_METERCERTNOTFOUND,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_StoreMgmt_CleanupStore[] =
{
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_LicenseQuery_IsAllowed[] =
{
    DRM_E_INVALIDRIGHT,
    DRM_E_HEADER_NOT_SET,
    DRM_E_LICENSENOTFOUND,
    DRM_E_CLK_NOT_SET,
    DRM_E_NO_CLK_SUPPORTED,
    DRM_E_CONDITIONNOTSUPPORTED,
    DRM_E_INVALIDLICENSE,
    DRM_E_LICENSEEXPIRED,
    DRM_E_RIGHTSNOTAVAILABLE,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_Uninitialize[] =
{
    DRM_E_INVALIDLICENSESTORE,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_Initialize[] =
{
    DRM_E_DEVCERTREADERROR,
    DRM_E_INVALIDDEVICECERTIFICATETEMPLATE,
    DRM_E_INVALIDDEVICECERTIFICATE,
    DRM_E_INVALIDLICENSESTORE,
    DRM_E_CLK_INVALID_DATE,
    DRM_E_BCERT_ISSUERKEY_KEYINFO_MISMATCH,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_MeterCert_GenerateChallenge[] =
{
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_MeterCert_ProcessResponse[] =
{
    DRM_E_XMLNOTFOUND,
    DRM_E_SOAPXML_XML_FORMAT,
    DRM_E_METERCERTNOTFOUND,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_JoinDomain_GenerateChallenge[] =
{
    DRM_E_DEVCERTEXCEEDSIZELIMIT,
    DRM_E_DOMAIN_INVALID_CUSTOM_DATA_TYPE,
    DRM_E_DOMAIN_INVALID_CUSTOM_DATA,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_JoinDomain_ProcessResponse[] =
{
    DRM_E_SOAPXML_XML_FORMAT,
    DRM_E_XMLNOTFOUND,
    DRM_S_MORE_DATA,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_LeaveDomain_GenerateChallenge[] =
{
    DRM_E_DEVCERTEXCEEDSIZELIMIT,
    DRM_E_DOMAIN_INVALID_CUSTOM_DATA_TYPE,
    DRM_E_DOMAIN_INVALID_CUSTOM_DATA,
    DRM_E_DOMAIN_NOT_FOUND,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_LeaveDomain_ProcessResponse[] =
{
    DRM_E_SOAPXML_XML_FORMAT,
    DRM_E_XMLNOTFOUND,
    DRM_S_MORE_DATA,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_DomainCert_Find[] =
{
    DRM_E_DOMAIN_STORE_GET_DATA,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_DomainCert_InitEnum[] =
{
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_DomainCert_EnumNext[] =
{
    DRM_E_NOMORE,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_GetAdditionalResponseData[] =
{
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_LicenseAcq_GenerateAck[] =
{
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_LicenseAcq_ProcessAckResponse[] =
{
    DRM_E_SOAPXML_XML_FORMAT,
    DRM_E_XMLNOTFOUND,
    DRM_S_MORE_DATA,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_SecureStore_GetExtendedTokenValue[] =
{
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_SecureStore_SetExtendedTokenValue[] =
{
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_Envelope_Close[] =
{
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_Envelope_DuplicateFileContext[] =
{
    DRM_E_FILEOPEN,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_Envelope_GetSize[] =
{
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_Envelope_GetOriginalFileName[] =
{
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_Envelope_InitializeRead[] =
{
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_Envelope_Open[] =
{
    DRM_E_FILEOPEN,
    DRM_E_ENVELOPE_CORRUPT,
    DRM_E_CH_INVALID_HEADER,
    DRM_E_ENVELOPE_FILE_NOT_COMPATIBLE,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_Envelope_Read[] =
{
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_Envelope_Seek[] =
{
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_Envelope_WritePlayReadyObject[] =
{
    DRM_E_HEADER_NOT_SET,
    DRM_E_CH_INCOMPATIBLE_HEADER_TYPE,
    DRM_E_FILEOPEN,
    DRM_E_ENVELOPE_CORRUPT,
    DRM_E_FILESEEKERROR,
    DRM_E_FILEWRITEERROR,
    DRM_SUCCESS
};

DRM_RESULT g_rgdrDrm_PlayReadyObject_ConvertFromWmdrmHeader[] =
{
    DRM_E_CH_INCOMPATIBLE_HEADER_TYPE,
    DRM_SUCCESS
};

/*
** The order of this list must exactly match that of the ECC_DRM_API_List enum in 'drmcontract.h'
*/
DRM_RESULT * const g_prgdrErrorCodelist[] =
{
    g_rgdrGenericErrorList,

    g_rgdrDrm_Content_UpdateEmbeddedStore,
    g_rgdrDrm_Content_SetProperty,
    g_rgdrDrm_Device_GetProperty,
    g_rgdrDrm_DomainCert_EnumNext,
    g_rgdrDrm_DomainCert_Find,
    g_rgdrDrm_DomainCert_InitEnum,
    g_rgdrDrm_Envelope_Close,
    g_rgdrDrm_Envelope_DuplicateFileContext,
    g_rgdrDrm_Envelope_GetSize,
    g_rgdrDrm_Envelope_GetOriginalFileName,
    g_rgdrDrm_Envelope_InitializeRead,
    g_rgdrDrm_Envelope_Open,
    g_rgdrDrm_Envelope_Read,
    g_rgdrDrm_Envelope_Seek,
    g_rgdrDrm_GetAdditionalResponseData,
    g_rgdrDrm_Initialize,
    g_rgdrDrm_JoinDomain_GenerateChallenge,
    g_rgdrDrm_JoinDomain_ProcessResponse,
    g_rgdrDrm_LeaveDomain_GenerateChallenge,
    g_rgdrDrm_LeaveDomain_ProcessResponse,
    g_rgdrDrm_License_GetProperty,
    g_rgdrDrm_LicenseAcq_GenerateChallenge,
    g_rgdrDrm_LicenseAcq_GenerateAck,
    g_rgdrDrm_LicenseAcq_GetContentHeader,
    g_rgdrDrm_LicenseAcq_ProcessAckResponse,
    g_rgdrDrm_LicenseAcq_ProcessResponse,
    g_rgdrDrm_LicenseQuery_GetState,
    g_rgdrDrm_LicenseQuery_IsAllowed,
    g_rgdrDrm_MeterCert_Delete,
    g_rgdrDrm_MeterCert_EnumNext,
    g_rgdrDrm_MeterCert_GenerateChallenge,
    g_rgdrDrm_MeterCert_InitEnum,
    g_rgdrDrm_MeterCert_Invalidate,
    g_rgdrDrm_MeterCert_ProcessResponse,
    g_rgdrDrm_MeterCert_Update,
    g_rgdrDrm_Metering_GenerateChallenge,
    g_rgdrDrm_Metering_ProcessResponse,
    g_rgdrDrm_ProcessCommand,
    g_rgdrDrm_ProcessRequest,
    g_rgdrDrm_Reader_Bind,
    g_rgdrDrm_Reader_Commit,
    g_rgdrDrm_Reader_Decrypt,
    g_rgdrDrm_Reader_InitDecrypt,
    g_rgdrDrm_Reinitialize,
    g_rgdrDrm_SecureClock_GenerateChallenge,
    g_rgdrDrm_SecureClock_GetValue,
    g_rgdrDrm_SecureClock_ProcessResponse,
    g_rgdrDrm_SecureStore_GetExtendedTokenValue,
    g_rgdrDrm_SecureStore_SetExtendedTokenValue,
    g_rgdrDrm_StoreMgmt_CleanupStore,
    g_rgdrDrm_StoreMgmt_DeleteLicenses,
    g_rgdrDrm_Sync_GenerateChallenge,
    g_rgdrDrm_SyncListItem_EnumNext,
    g_rgdrDrm_SyncListItem_InitEnum,
    g_rgdrDrm_Uninitialize,
    g_rgdrDrm_Content_GetProperty,
    g_rgdrDrm_Envelope_WritePlayReadyObject,
    g_rgdrDrm_Content_UpdateEmbeddedStore_Commit,
    g_rgdrDrm_PlayReadyObject_ConvertFromWmdrmHeader
};

/******************************************************************************
** Function         :   _ECC_TableLookUp
**
** Synopsis         :   The function which does the actual look up and determines
**                      if the error code is present in the contract or not.
**
** ARGUMENTS        :   [f_uiAPIid] - # defined value of the API.
**                      [f_dr]      - dr value returned by the respective function.
**
** RETURN           :   TRUE   if the error code is present in the contract.
**                      FALSE  if the error code is not present in the contract.
**
******************************************************************************/
static DRM_BOOL DRM_CALL _ECC_TableLookUp(
    __in const DRM_UINT   f_uiAPIid,
    __in const DRM_RESULT f_dr )
{
    DRM_BOOL fValue  = FALSE;
    DRM_UINT  uiVar  = 0;
    while( g_prgdrErrorCodelist[f_uiAPIid][uiVar] != DRM_SUCCESS )
    {
        if( g_prgdrErrorCodelist[f_uiAPIid][uiVar] == f_dr )
        {
            fValue = TRUE;
            break;
        }
    uiVar++;
    }
    return fValue;
}



/******************************************************************************
** Function         :   DRM_ECC_ExpectedErrorCode
**
** Synopsis         :   Check the dr returned by the function against the corresponding
**                      API's expected error code list and the generic error code list.
**
** ARGUMENTS        :   [f_uiAPIid]  - # defined value of the API.
**                      [f_dr]       - dr value returned by the respective function.
**
** RETURN           :   TRUE   if the error code is present in the contract.
**                      FALSE  if the error code is not present in the contract.
**
******************************************************************************/
DRM_API DRM_BOOL DRM_CALL DRM_ECC_ExpectedErrorCode(
    __in const  DRM_UINT    f_uiAPIid,
    __in const  DRM_RESULT  f_dr )
{
    DRM_BOOL fExist = FALSE;

    /*
    ** Check the generic error list
    */
    fExist = _ECC_TableLookUp( ECC_DRM_GENERIC_ERROR_LIST, f_dr );

    /*
    ** If the entry is not there in the generic error list, Check the API errorcode list
    */
    if( !fExist )
    {
        fExist = _ECC_TableLookUp( f_uiAPIid, f_dr );
    }
    return fExist;
}

#endif /* DRM_ERROR_CONTRACT_TEST_MODE */


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmcbc.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

/*
chain-sum MAC scheme 4.5: multiply-&-swap rounds plus sum (reversible -- reversal code included)
*/
#include <drmcommon.h>
#include <byteorder.h>
#include <drmcrt.h>
#include <drmcbc.h>

ENTER_PK_NAMESPACE_CODE;

/* pairwise independent function and summing step */
#define MP_C_STEP_P(pbData,L1, L2, L3, L4, L5, L6, t, sum) \
{\
    DRM_DWORD   dwTemp = 0;\
    BYTES_TO_DWORD( dwTemp, pbData );\
    pbData += __CB_DECL(SIZEOF(DRM_DWORD));\
    t += dwTemp; \
    t *= L1; \
    t = WORDSWAP(t); \
    t *= L2; \
    t = WORDSWAP(t); \
    t *= L3; \
    t = WORDSWAP(t); \
    t *= L4; \
    t = WORDSWAP(t); \
    t *= L5; \
    t += L6; \
    sum += t; \
}


#define MP_C_STEP(Data,L1, L2, L3, L4, L5, L6, t, sum) \
    t += Data; \
    t *= L1; \
    t = WORDSWAP(t); \
    t *= L2; \
    t = WORDSWAP(t); \
    t *= L3; \
    t = WORDSWAP(t); \
    t *= L4; \
    t = WORDSWAP(t); \
    t *= L5; \
    t += L6; \
    sum += t;

DRM_API DRM_VOID DRM_CALL DRM_CBC_Mac(
    IN        DRM_BYTE      *pbData,
    IN        DRM_DWORD      cBlocks,
    OUT       DRM_DWORD      rgdwKeys[2],
    IN  const DRM_CBCKey    *pCBCkey )
{    
    rgdwKeys[0] = rgdwKeys[1] = 0;
    while ( cBlocks > 0)
    {
        DRM_DWORD dw = 0;
        BYTES_TO_DWORD( dw, pbData );
        pbData += __CB_DECL(SIZEOF( DRM_DWORD ));
        MP_C_STEP(dw, pCBCkey->a1, pCBCkey->b1, pCBCkey->c1, pCBCkey->d1, pCBCkey->e1, pCBCkey->f1, rgdwKeys[1], rgdwKeys[0]);
        BYTES_TO_DWORD( dw, pbData );
        pbData += __CB_DECL(SIZEOF( DRM_DWORD ));
        MP_C_STEP(dw, pCBCkey->a2, pCBCkey->b2, pCBCkey->c2, pCBCkey->d2, pCBCkey->e2, pCBCkey->f2, rgdwKeys[1], rgdwKeys[0]);
        cBlocks -= 2;
    }
    return;
}

/*******************************************************************/
DRM_API DRM_UINT DRM_CALL DRM_MAC_inv32( DRM_UINT n )
{
    DRM_INT x = n;
    DRM_INT i = 0;

    for (i = 0; i < 30; i++)
    {
        x *= x * n;
    }

    return (DRM_UINT)x;
}


/* step to reverse action of multiply-&-swap rounds */
#define INV_STEP_C(iL1, iL2, iL3, iL4, iL5) \
    tmp *= iL5; \
    tmp = WORDSWAP(tmp); \
    tmp *= iL4; \
    tmp = WORDSWAP(tmp); \
    tmp *= iL3; \
    tmp = WORDSWAP(tmp); \
    tmp *= iL2; \
    tmp = WORDSWAP(tmp); \
    tmp *= iL1;

DRM_API DRM_VOID DRM_CALL DRM_CBC_InverseMac(
    IN OUT   DRM_BYTE   *pbData,
    IN       DRM_DWORD   cBlocks,
    IN const DRM_CBCKey *key,
    IN const DRM_CBCKey *ikey )
{
    DRM_UINT tmp = 0,tmp2 = 0;
    DRM_DWORD sum64[2];


    /* 
        Invert last two blocks (sum and 32-bit MAC).  This requires the encrypted last two
        blocks and the (dwNumBlocks-2) plaintext blocks. 
    */
    DRM_CBC_Mac(pbData, cBlocks - 2, sum64, key);
    BYTES_TO_DWORD( tmp, pbData + ((SIZEOF( DRM_UINT)*(cBlocks - 1))/CB_NATIVE_BYTE));
    sum64[0] += tmp;

    /* last word */    
    tmp -= key->f2;
    INV_STEP_C(ikey->a2, ikey->b2, ikey->c2, ikey->d2, ikey->e2);
    BYTES_TO_DWORD( tmp2, pbData + ((SIZEOF( DRM_UINT)*(cBlocks - 2))/CB_NATIVE_BYTE));
    tmp -= ( tmp2 - sum64[0] );
    DWORD_TO_BYTES( pbData + ((SIZEOF( DRM_UINT)*(cBlocks - 1)/CB_NATIVE_BYTE)), tmp );

    /* next-to-last word */
    tmp = (tmp2 - sum64[0]) - key->f1;
    INV_STEP_C(ikey->a1, ikey->b1, ikey->c1, ikey->d1, ikey->e1);
    tmp -= sum64[1];
    DWORD_TO_BYTES( pbData + ((SIZEOF( DRM_UINT)*(cBlocks - 2)/CB_NATIVE_BYTE)), tmp );
        
    return;
}

DRM_API DRM_VOID DRM_CALL DRM_CBC64InitState( DRM_CBCState *cbcstate ) {
  cbcstate->sum = 0; cbcstate->t = 0; cbcstate->dwBufLen = 0;
}


DRM_API DRM_VOID DRM_CALL DRM_CBC64Init(
    DRM_CBCKey *cbckey,
    DRM_CBCState *cbcstate,
    __in_bcount( SIZEOF( DRM_UINT ) * 12 ) DRM_BYTE *pKey ) 
{
  DRM_UINT *p = NULL;

  cbcstate->sum = 0; cbcstate->t = 0; cbcstate->dwBufLen = 0;
  p = (DRM_UINT *)pKey;
  cbckey->a1 = *p++ | 0x00000001;
  cbckey->b1 = *p++ | 0x00000001;
  cbckey->c1 = *p++ | 0x00000001;
  cbckey->d1 = *p++ | 0x00000001;
  cbckey->e1 = *p++ | 0x00000001;
  cbckey->f1 = *p++ | 0x00000001;
  cbckey->a2 = *p++ | 0x00000001;
  cbckey->b2 = *p++ | 0x00000001;
  cbckey->c2 = *p++ | 0x00000001;
  cbckey->d2 = *p++ | 0x00000001;
  cbckey->e2 = *p++ | 0x00000001;
  cbckey->f2 = *p++ | 0x00000001;
}

DRM_API DRM_VOID DRM_CALL DRM_CBC64InvKey( DRM_CBCKey *cbckey, DRM_CBCKey *cbcInvKey ) {

  cbcInvKey->a1 = DRM_MAC_inv32( cbckey->a1 );
  cbcInvKey->a2 = DRM_MAC_inv32( cbckey->a2 );
  cbcInvKey->b1 = DRM_MAC_inv32( cbckey->b1 );
  cbcInvKey->b2 = DRM_MAC_inv32( cbckey->b2 );
  cbcInvKey->c1 = DRM_MAC_inv32( cbckey->c1 );
  cbcInvKey->c2 = DRM_MAC_inv32( cbckey->c2 );
  cbcInvKey->d1 = DRM_MAC_inv32( cbckey->d1 );
  cbcInvKey->d2 = DRM_MAC_inv32( cbckey->d2 );
  cbcInvKey->e1 = DRM_MAC_inv32( cbckey->e1 );
  cbcInvKey->e2 = DRM_MAC_inv32( cbckey->e2 );
  cbcInvKey->f1 = DRM_MAC_inv32( cbckey->f1 );
  cbcInvKey->f2 = DRM_MAC_inv32( cbckey->f2 );

}

DRM_API DRM_VOID DRM_CALL DRM_CBC64Update( 
    IN      DRM_CBCKey  *key, 
    IN  OUT DRM_CBCState    *cbcstate,
    IN      DRM_DWORD    cbData, 
    __in_bcount( cbData ) DRM_BYTE *pbData )
{
    DRM_DWORD    iData  = 0;
    DRM_DWORD    cbCopy = 0;
    DRM_DWORD    cbTemp  = 0;
    DRM_BYTE    *pbTemp = NULL;
    
    if ( cbcstate->dwBufLen > 0 ) 
    {
        cbCopy = min( cbData, 8 - cbcstate->dwBufLen );
        
        for ( iData=0; iData < cbCopy; iData++ )
        {
            PUT_BYTE( cbcstate->buf, 
                      cbcstate->dwBufLen + iData, 
                      GET_BYTE(pbData, iData) );
        }
        
        cbcstate->dwBufLen += cbCopy;
        if ( cbcstate->dwBufLen == 8 ) 
        {
            pbTemp = cbcstate->buf;
            MP_C_STEP_P( pbTemp, key->a1, key->b1, key->c1, key->d1, key->e1, key->f1, cbcstate->t, cbcstate->sum );
            MP_C_STEP_P( pbTemp, key->a2, key->b2, key->c2, key->d2, key->e2, key->f2, cbcstate->t, cbcstate->sum );
            cbcstate->dwBufLen = 0;
        }
    }

    cbTemp = (cbData - cbCopy) / 8;
    pbTemp = pbData + __CB_DECL(cbCopy);

    while (cbTemp > 0) 
    {
        MP_C_STEP_P( pbTemp, key->a1, key->b1, key->c1, key->d1, key->e1, key->f1, cbcstate->t, cbcstate->sum );
        MP_C_STEP_P( pbTemp, key->a2, key->b2, key->c2, key->d2, key->e2, key->f2, cbcstate->t, cbcstate->sum );
        cbTemp--;
    }

    cbTemp = cbCopy + ((cbData-cbCopy) / 8) * 8;
    if ( cbTemp < cbData ) 
    {
        for ( iData=cbTemp; iData<cbData; iData++ )
        {
            PUT_BYTE( cbcstate->buf, iData - cbTemp, GET_BYTE( pbData, iData ) );
        }
        cbcstate->dwBufLen = cbData - cbTemp;
    }
}

DRM_API DRM_UINT DRM_CALL DRM_CBC64Finalize( DRM_CBCKey *key, DRM_CBCState *cbcstate, DRM_UINT *pKey2 ) {
    DRM_DWORD   i = 0;
    DRM_BYTE    *p = NULL;

    if ( cbcstate->dwBufLen > 0 ) 
    {
        for ( i=cbcstate->dwBufLen; i<8; i++ )
        {
            PUT_BYTE( cbcstate->buf, i, 0);
        }
        p = cbcstate->buf;
        MP_C_STEP_P( p, key->a1, key->b1, key->c1, key->d1, key->e1, key->f1, cbcstate->t, cbcstate->sum );
        MP_C_STEP_P( p, key->a2, key->b2, key->c2, key->d2, key->e2, key->f2, cbcstate->t, cbcstate->sum );
        cbcstate->dwBufLen = 0;
    }

    *pKey2 = cbcstate->t;
    return cbcstate->sum;
}



DRM_API DRM_UINT DRM_CALL DRM_CBC64Invert( DRM_CBCKey *key, DRM_CBCKey *ikey, DRM_UINT MacA1, DRM_UINT MacA2,
        DRM_UINT MacB1, DRM_UINT MacB2, DRM_UINT *pInvKey2 )
{
    DRM_UINT tmp = 0;
    DRM_UINT yn = 0, yn1 = 0, xn = 0, xn1 = 0;

    MacA1 += MacB2;
    yn = MacB2;
    yn1 = MacB1 - MacA1;

    /* last word */
    tmp = yn - key->f2;
    INV_STEP_C(ikey->a2, ikey->b2, ikey->c2, ikey->d2, ikey->e2);
    xn = tmp - yn1;

    /* next-to-last word */
    tmp = yn1 - key->f1;
    INV_STEP_C(ikey->a1, ikey->b1, ikey->c1, ikey->d1, ikey->e1);
    xn1 = tmp - MacA2;

    *pInvKey2 = (DRM_UINT) xn1;
    return (DRM_UINT) xn;
}


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmconstants.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include <drmcommon.h>
#include <drmlicense.h>

ENTER_PK_NAMESPACE_CODE;

/* Define all constants here.  If we put it in an include file we will have multiple defines when linking */

const PUBKEY g_pubkeyLicenseServer = 
{
    {
         TWO_BYTES(0x52, 0xF5), TWO_BYTES(0x5A, 0x8A), TWO_BYTES(0x8A, 0x7F), TWO_BYTES(0xEA, 0x57), 
         TWO_BYTES(0x55, 0x24), TWO_BYTES(0x93, 0xA9), TWO_BYTES(0x8C, 0x11), TWO_BYTES(0x06, 0x58), 
         TWO_BYTES(0x37, 0xAD), TWO_BYTES(0x9F, 0x66), TWO_BYTES(0x68, 0xC1), TWO_BYTES(0x1C, 0x16), 
         TWO_BYTES(0x2D, 0x4A), TWO_BYTES(0x57, 0xBA), TWO_BYTES(0x7B, 0x6C), TWO_BYTES(0xA4, 0x24), 
         TWO_BYTES(0x14, 0x2B), TWO_BYTES(0x4E, 0x2E), TWO_BYTES(0x89, 0xF1), TWO_BYTES(0x39, 0x4E) 
    }
};

/* Some of these must be kept in sync with what is in license.h */
const DRM_LID g_rgbSecStoreGlobalName =
{
    TWO_BYTES('g', 'l'),  TWO_BYTES('o', 'b'),  TWO_BYTES('a', 'l'),  
    TWO_BYTES('.', 's'),  TWO_BYTES('e', 'c'),  TWO_BYTES('s', 't'),  
    TWO_BYTES('a', 't'),  TWO_BYTES('e', '\0')
};

#if DRM_SUPPORT_REVOCATION
const DRM_LID g_lidPCRevInfoRevocation =
{
    TWO_BYTES('R', 'e'),  TWO_BYTES('v', '_'),  TWO_BYTES('I', 'n'),
    TWO_BYTES('f', 'o'),  TWO_BYTES('_', 'D'),  TWO_BYTES('a', 't'),
    TWO_BYTES('a', '\0'), TWO_BYTES('\0', '\0')
};

const DRM_LID g_lidRevocationInfo =
{
    TWO_BYTES('R', 'E'),  TWO_BYTES('V', 'O'),  TWO_BYTES('C', 'A'),
    TWO_BYTES('T', 'I'),  TWO_BYTES('O', 'N'),  TWO_BYTES('I', 'N'),
    TWO_BYTES('F', 'O'),  TWO_BYTES('\0', '\0')
};

const DRM_LID g_lidRevocationInfo2 =
{
    TWO_BYTES('R', 'E'),  TWO_BYTES('V', 'O'),  TWO_BYTES('C', 'A'),
    TWO_BYTES('T', 'I'),  TWO_BYTES('O', 'N'),  TWO_BYTES('I', 'N'),
    TWO_BYTES('F', 'O'),  TWO_BYTES('2', '\0')
};

#if DRM_SUPPORT_DEVICE_REVOCATION
/* DeviceRevocation */
const DRM_LID g_lidDeviceRevocation =
{
    TWO_BYTES('D', 'e'),  TWO_BYTES('v', 'i'),  TWO_BYTES('c', 'e'),
    TWO_BYTES('R', 'e'),  TWO_BYTES('v', 'o'),  TWO_BYTES('c', 'a'),
    TWO_BYTES('t', 'i'),  TWO_BYTES('o', 'n')
};
#endif               

#if DRM_SUPPORT_WMDRMNET
/* WMDRMNET_RVK */
const DRM_LID g_lidWMDRMNET_Revocation =
{
    TWO_BYTES('W', 'M'),   TWO_BYTES('D', 'R'),  TWO_BYTES('M', 'N'),
    TWO_BYTES('E', 'T'),   TWO_BYTES('_', 'R'),  TWO_BYTES('V', 'K'),
    TWO_BYTES('\0', '\0'), TWO_BYTES('\0', '\0')
};
#endif

#if DRM_SUPPORT_APP_REVOCATION
/* RevocationList */
const DRM_LID g_lidAppRevocation =
{
    TWO_BYTES('R', 'e'),  TWO_BYTES('v', 'o'),  TWO_BYTES('c', 'a'),
    TWO_BYTES('t', 'i'),  TWO_BYTES('o', 'n'),  TWO_BYTES('L', 'i'),
    TWO_BYTES('s', 't'),  TWO_BYTES('\0', '\0')
};
#endif /* DRM_SUPPORT_APP_REVOCATION */

/* PRRTRevocList */
const DRM_LID g_lidPRRTRevocation =
{
    TWO_BYTES('P', 'R'), TWO_BYTES('R', 'T'),  TWO_BYTES('R', 'e'),
    TWO_BYTES('v', 'o'), TWO_BYTES('c', 'L'),  TWO_BYTES('i', 's'),
    TWO_BYTES('t', '\0'), TWO_BYTES('\0', '\0')
};

/* PRAppRevocList */
const DRM_LID g_lidPRAppRevocation =
{
    TWO_BYTES('P', 'R'), TWO_BYTES('A', 'p'),  TWO_BYTES('p', 'R'),
    TWO_BYTES('e', 'v'), TWO_BYTES('o', 'c'),  TWO_BYTES('L', 'i'),
    TWO_BYTES('s', 't'), TWO_BYTES('\0', '\0')
};

#endif /* DRM_SUPPORT_REVOCATION */


/* Symmetric Session Key SST entry */
const DRM_ID g_idSLKSST = 
{ 
    TWO_BYTES( 'I', '\0'), TWO_BYTES( 'D', '\0'), TWO_BYTES( 'F', '\0'), 
    TWO_BYTES( 'O', '\0'), TWO_BYTES( 'R', '\0'), TWO_BYTES( 'S', '\0'), 
    TWO_BYTES( 'L', '\0'), TWO_BYTES( 'K', '\0') 
};

/* DRM Version. Keep this in sync with DRM_VERSION_STRING above. */
const DRM_WCHAR             g_rgwchDRM_VERSION_STRING                  []= { ONE_WCHAR('2', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_CONST_STRING      g_dstrDRM_VERSION_STRING                     = CREATE_DRM_STRING( g_rgwchDRM_VERSION_STRING );

const DRM_BYTE              DRM_VERSION [__CB_DECL(VERSION_LEN)]         =
{
    TWO_BYTES(2, 0), TWO_BYTES(0, 0)
}; 

/* Indicates the version of the pubkey to be used for verification of PK CERT. */
const DRM_BYTE              PK_VER [__CB_DECL(VERSION_LEN)]              =
{
    TWO_BYTES(2, 0), TWO_BYTES(0, 0)
}; 

/* Version of the key file. */
const DRM_BYTE              KEYFILE_VER [__CB_DECL(VERSION_LEN)]         =
{
    TWO_BYTES(2, 0), TWO_BYTES(0, 0)
}; 


const DRM_BYTE              LICREQUEST_VER [__CB_DECL(VERSION_LEN)]    =
{
    TWO_BYTES(2, 0), TWO_BYTES(0, 0)
};

/* Indicates the public root key needed to verify the license server certificates. */
const DRM_BYTE              CERT_VER [__CB_DECL(VERSION_LEN)]          =
{
    TWO_BYTES(0, 1), TWO_BYTES(0, 0)
};

/* Indicates the license version delivered. */
const DRM_BYTE              LICENSE_VER [__CB_DECL(VERSION_LEN)]       =
{
    TWO_BYTES(2, 0), TWO_BYTES(0, 0)
}; 

/* The version for client id. */
const DRM_BYTE              CLIENT_ID_VER [__CB_DECL(VERSION_LEN)]      =
{
    TWO_BYTES(2, 0), TWO_BYTES(0, 0)
}; 

/* Content Version. Keep this in sync with CONTENT_VERSION_STRING above. */
const DRM_BYTE              CONTENT_VERSION [__CB_DECL(VERSION_LEN)]    =
{
    TWO_BYTES(2, 0), TWO_BYTES(0, 0)
}; 



/* v1 rights bits */
const DRM_BYTE              RIGHT_PLAY_ON_PC [__CB_DECL(RIGHTS_LEN)]     =
{
    TWO_BYTES(1, 0), TWO_BYTES(0, 0)
};
const DRM_BYTE              RIGHT_COPY_TO_NONSDMI_DEVICE [__CB_DECL(RIGHTS_LEN)]    =
{
    TWO_BYTES(2, 0), TWO_BYTES(0, 0)
};
const DRM_BYTE              RIGHT_NO_RESTORE [__CB_DECL(RIGHTS_LEN)]                =
{
    TWO_BYTES(4, 0), TWO_BYTES(0, 0)
};
const DRM_BYTE              RIGHT_BURN_TO_CD [__CB_DECL(RIGHTS_LEN)]                =
{
    TWO_BYTES(8, 0), TWO_BYTES(0, 0)
};
const DRM_BYTE              RIGHT_COPY_TO_SDMI_DEVICE [__CB_DECL(RIGHTS_LEN)]       =
{
    TWO_BYTES(0x10, 0), TWO_BYTES(0, 0)
};
const DRM_BYTE              RIGHT_ONE_TIME [__CB_DECL(RIGHTS_LEN)]                  =
{
    TWO_BYTES(0x20, 0), TWO_BYTES(0, 0)
};
const DRM_BYTE              RIGHT_COPY [__CB_DECL(RIGHTS_LEN)] =
{
    TWO_BYTES(0x80, 0), TWO_BYTES(0, 0)
};
const DRM_BYTE              RIGHT_COLLABORATIVE_PLAY [__CB_DECL(RIGHTS_LEN)] =
{
    TWO_BYTES(0x00, 1), TWO_BYTES(0, 0)
};

/* Character constants */
const DRM_WCHAR             g_wchPathSeperator                          = WCHAR_CAST('\\');
const DRM_WCHAR             g_wchNull                                   = WCHAR_CAST('\0');
const DRM_WCHAR             g_wchMinus                                  = WCHAR_CAST('-');
const DRM_WCHAR             g_wchPlus                                   = WCHAR_CAST('+');
const DRM_WCHAR             g_wchForwardSlash                           = WCHAR_CAST('/');
const DRM_WCHAR             g_wchColon                                  = WCHAR_CAST(':');
const DRM_WCHAR             g_wchComma                                  = WCHAR_CAST(',');
const DRM_WCHAR             g_wchQuote                                  = WCHAR_CAST('\"');
const DRM_WCHAR             g_wchSingleQuote                            = WCHAR_CAST('\'');
const DRM_WCHAR             g_wchNewLine                                = WCHAR_CAST('\n');
const DRM_WCHAR             g_wchBackSlash                              = WCHAR_CAST('\\');
const DRM_WCHAR             g_wch0                                      = WCHAR_CAST('0');
const DRM_WCHAR             g_wch1                                      = WCHAR_CAST('1');
const DRM_WCHAR             g_wch2                                      = WCHAR_CAST('2');
const DRM_WCHAR             g_wch9                                      = WCHAR_CAST('9');
const DRM_WCHAR             g_wcha                                      = WCHAR_CAST('a');
const DRM_WCHAR             g_wchd                                      = WCHAR_CAST('d');
const DRM_WCHAR             g_wchf                                      = WCHAR_CAST('f');
const DRM_WCHAR             g_wchh                                      = WCHAR_CAST('h');
const DRM_WCHAR             g_wchm                                      = WCHAR_CAST('m');
const DRM_WCHAR             g_wchn                                      = WCHAR_CAST('n');
const DRM_WCHAR             g_wchs                                      = WCHAR_CAST('s');
const DRM_WCHAR             g_wchy                                      = WCHAR_CAST('y');
const DRM_WCHAR             g_wchA                                      = WCHAR_CAST('A');
const DRM_WCHAR             g_wchF                                      = WCHAR_CAST('F');
const DRM_WCHAR             g_wchx                                      = WCHAR_CAST('x');
const DRM_WCHAR             g_wchX                                      = WCHAR_CAST('X');
const DRM_WCHAR             g_wchUnderscore                             = WCHAR_CAST('_');
const DRM_WCHAR             g_wchz                                      = WCHAR_CAST('z');
const DRM_WCHAR             g_wchZ                                      = WCHAR_CAST('Z');
const DRM_WCHAR             g_wchPeriod                                 = WCHAR_CAST('.');
const DRM_WCHAR             g_wchQuestionMark                           = WCHAR_CAST('?');
const DRM_WCHAR             g_wchExclamationMark                        = WCHAR_CAST('!');
const DRM_WCHAR             g_wchOpenParen                              = WCHAR_CAST('(');
const DRM_WCHAR             g_wchCloseParen                             = WCHAR_CAST(')');
const DRM_WCHAR             g_wchPound                                  = WCHAR_CAST('#');
const DRM_WCHAR             g_wchSpace                                  = WCHAR_CAST(' ');
const DRM_WCHAR             g_wchTab                                    = WCHAR_CAST('\x9');
const DRM_WCHAR             g_wchLineFeed                               = WCHAR_CAST('\xA');
const DRM_WCHAR             g_wchVerticalTab                            = WCHAR_CAST('\xB');
const DRM_WCHAR             g_wchFormFeed                               = WCHAR_CAST('\xC');
const DRM_WCHAR             g_wchCarriageReturn                         = WCHAR_CAST('\xD');
const DRM_WCHAR             g_wchEqual                                  = WCHAR_CAST('=');
const DRM_WCHAR             g_wchOpenCurly                              = WCHAR_CAST('{');
const DRM_WCHAR             g_wchCloseCurly                             = WCHAR_CAST('}');
const DRM_WCHAR             g_wchLessThan                               = WCHAR_CAST('<');
const DRM_WCHAR             g_wchGreaterThan                            = WCHAR_CAST('>');
const DRM_WCHAR             g_wchLeftBracket                            = WCHAR_CAST('[');
const DRM_WCHAR             g_wchRightBracket                           = WCHAR_CAST(']');
const DRM_WCHAR             g_wchAsterisk                               = WCHAR_CAST('*');
const DRM_WCHAR             g_wchPercent                                = WCHAR_CAST('%');
const DRM_WCHAR             g_wchSemiColon                              = WCHAR_CAST(';');
const DRM_WCHAR             g_wchAmpersand                              = WCHAR_CAST('&');
const DRM_WCHAR             g_wchPipe                                   = WCHAR_CAST('|');

/* Character constants - ANSI */
const DRM_CHAR             g_chForwardSlash                             = '/';

const DRM_WCHAR      g_rgwchWMDRM_RIGHT_NONE                      [] =  { ONE_WCHAR('N', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchWMDRM_RIGHT_PLAYBACK                  [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchWMDRM_RIGHT_COLLABORATIVE_PLAY        [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('b', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchWMDRM_RIGHT_COPY_TO_CD                [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('b', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('k', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchWMDRM_RIGHT_COPY                      [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchWMDRM_RIGHT_CREATE_THUMBNAIL_IMAGE    [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('h', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('b', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('g', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0') };  /* L"CreateThumbnailImage"; */

#if DRM_SUPPORT_PMLICENSE
const DRM_WCHAR      g_rgwchWMDRM_RIGHT_COPY_TO_SDMI_DEVICE       [] =  { ONE_WCHAR('T', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('f', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchWMDRM_RIGHT_COPY_TO_NON_SDMI_DEVICE   [] =  { ONE_WCHAR('T', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('f', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('\0', '\0')};
#endif

#if DRM_BACKUP_RESTORE_SUPPORT
const DRM_WCHAR      g_rgwchWMDRM_RIGHT_BACKUP                    [] =  { ONE_WCHAR('B', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('k', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('\0', '\0')};
#endif

#if DRM_SUPPORT_PLAYLIST_BURN
const DRM_WCHAR      g_rgwchPlaylistBurnCount                     [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchWMDRM_RIGHT_PLAYLIST_BURN             [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('\0', '\0')};
#endif


/* String constants */
const DRM_CHAR       g_rgchAttributeVersion                       [] =  { TWO_BYTES('v', 'e'),  TWO_BYTES('r', 's'),  TWO_BYTES('i', 'o'),  TWO_BYTES('n', '\0'),  TWO_BYTES('\0', '\0')};         /* ODD count */
const DRM_CHAR       g_rgchAttributeEncrypted                     [] =  { TWO_BYTES('e', 'n'),  TWO_BYTES('c', 'r'),  TWO_BYTES('y', 'p'),  TWO_BYTES('t', 'e'),  TWO_BYTES('d', '\0'),  TWO_BYTES('\0', '\0')};       /* ODD count */
const DRM_CHAR       g_rgchLicVerAttrValue                        [] =  { TWO_BYTES('2', '.'),  TWO_BYTES('0', '.'),  TWO_BYTES('0', '.'),  TWO_BYTES('0', '\0'),  TWO_BYTES('\0', '\0')};         /* ODD count */
const DRM_CHAR       g_rgchLicenseTag                             [] =  { TWO_BYTES('L', 'I'),  TWO_BYTES('C', 'E'),  TWO_BYTES('N', 'S'),  TWO_BYTES('E', '\0'),  TWO_BYTES('\0', '\0')};         /* ODD count */
const DRM_CHAR       g_rgchLicenseRespTag                         [] =  { TWO_BYTES('L', 'I'),  TWO_BYTES('C', 'E'),  TWO_BYTES('N', 'S'),  TWO_BYTES('E', 'R'),  TWO_BYTES('E', 'S'),  TWO_BYTES('P', 'O'),  TWO_BYTES('N', 'S'),  TWO_BYTES('E', '\0'),  TWO_BYTES('\0', '\0')}; /* ODD count */
const DRM_CHAR       g_rgchAttributeFALSE                         [] =  { TWO_BYTES('F', 'A'),  TWO_BYTES('L', 'S'),  TWO_BYTES('E', '\0'),  TWO_BYTES('\0', '\0')};           /* ODD count */

const DRM_WCHAR      g_rgwchAttributeVersion                      [] =  { ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchAttributeEncrypted                    [] =  { ONE_WCHAR('e', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchLicVerAttrValue                       [] =  { ONE_WCHAR('2', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchLicenseRespTag                        [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchLicenseTag                            [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchAttributeFALSE                        [] =  { ONE_WCHAR('F', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};

/* Script varibles used for license properties. */
const DRM_WCHAR      g_rgwchDRM_LS_BEGIN_ATTR                     [] =  { ONE_WCHAR('B', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('g', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRM_LS_COUNT_ATTR                     [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_WCHAR      g_rgwchDRM_LS_BEGDATE_ATTR                   [] =  { ONE_WCHAR('B', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('g', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRM_LS_ENDDATE_ATTR                   [] =  { ONE_WCHAR('E', '\0'),  ONE_WCHAR('x', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRM_LS_FIRSTUSE_ATTR                  [] =  { ONE_WCHAR('F', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRM_LS_FIRSTSTORE_ATTR                [] =  { ONE_WCHAR('F', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRM_LS_EXPIRATION_AFTER_FIRSTUSE_ATTR [] =  { ONE_WCHAR('H', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRM_LS_MINAPPSECLEVEL_ATTR            [] =  { ONE_WCHAR('M', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRM_LS_APPSEC_ATTR                    [] =  { ONE_WCHAR('A', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRM_LS_SAP_ATTR                       [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRM_LS_BURNTOCDCOUNT_ATTR             [] =  { ONE_WCHAR('B', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRM_LS_TRANSFERCOUNT_ATTR             [] =  { ONE_WCHAR('T', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('f', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRM_LS_PLAYCOUNT_ATTR                 [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRM_LS_COPYCOUNT_ATTR                 [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRM_LS_BEGINBURNTOCDCOUNT_ATTR        [] =  { ONE_WCHAR('B', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('g', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRM_LS_BEGINTRANSFERCOUNT_ATTR        [] =  { ONE_WCHAR('B', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('g', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('f', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRM_LS_BEGINPLAYCOUNT_ATTR            [] =  { ONE_WCHAR('B', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('g', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_WCHAR      g_rgwchDRM_LS_DELETED_ATTR                   [] =  { ONE_WCHAR('d', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('\0', '\0') };  /*L"deleted";*/

#if DRM_SUPPORT_ANTIROLLBACK_CLOCK
const DRM_WCHAR      g_rgwchDRM_LS_OLDSAVETIME_ATTR               [] =  { ONE_WCHAR('O', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0') };  /* L"OldSaveTime"; */
const DRM_WCHAR      g_rgwchDRM_LS_MACHINE_DATETIME               [] =  { ONE_WCHAR('m', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('h', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0') }; /* L"machine.datetime"; */
#endif

const DRM_WCHAR      g_rgwchDRM_LS_MACHINE_DATETIME_GE            [] =  { ONE_WCHAR('m', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('h', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('>', '\0'),  ONE_WCHAR('=', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('#', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRM_LS_MACHINE_DATETIME_LE            [] =  { ONE_WCHAR('m', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('h', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('<', '\0'),  ONE_WCHAR('=', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('#', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRM_LS_APP_MINSECLEVEL_GE             [] =  { ONE_WCHAR('a', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('>', '\0'),  ONE_WCHAR('=', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchEqual                                 [] =  { ONE_WCHAR('=', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_WCHAR      g_rgwchDrmRestoreInfo                        [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagData                               [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagLID                                [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_WCHAR      g_rgwchTagIndex                              [] =  { ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('X', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagEnablingbits                       [] =  { ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagSymValue                           [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagSymSig                             [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_WCHAR      g_rgwchTagHashAlgorithm                      [] =  { ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagPubkey                             [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagValue                              [] =  { ONE_WCHAR('V', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagSignature                          [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagHashAlg                            [] =  { ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagSignAlg                            [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchSHA                                   [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchMSDRM                                 [] =  { ONE_WCHAR('M', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchMSDRM_CK                              [] =  { ONE_WCHAR('M', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_CHAR       g_rgchAttributeType                          [] =  { TWO_BYTES('t', 'y'),   TWO_BYTES('p', 'e'),   TWO_BYTES('\0', '\0')};
const DRM_WCHAR      g_rgwchAttributeType                         [] =  { ONE_WCHAR('t', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchSavedDateTime                         [] =  { ONE_WCHAR('g', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('b', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_WCHAR      g_rgwchTagOEMPrivateKeys                     [] =  { ONE_WCHAR('O', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagKeyValue                           [] =  { ONE_WCHAR('K', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0') };
const DRM_WCHAR      g_rgwchTagRSAKeyValue                        [] =  { ONE_WCHAR('R', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('e', '\0'), ONE_WCHAR('\0', '\0') };
const DRM_WCHAR      g_rgwchTagModulus                            [] =  { ONE_WCHAR('M', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('\0', '\0') };
const DRM_WCHAR      g_rgwchTagExponent                           [] =  { ONE_WCHAR('E', '\0'),  ONE_WCHAR('x', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'), ONE_WCHAR('\0', '\0') };
const DRM_WCHAR      g_rgwchTagPrime0                             [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('\0', '\0') };
const DRM_WCHAR      g_rgwchTagPrime1                             [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('1', '\0'),  ONE_WCHAR('\0', '\0') };
const DRM_WCHAR      g_rgwchTagCRTExponent0                       [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('x', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('\0', '\0') };
const DRM_WCHAR      g_rgwchTagCRTExponent1                       [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('x', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('1', '\0'),  ONE_WCHAR('\0', '\0') };
const DRM_WCHAR      g_rgwchTagIQMP                               [] =  { ONE_WCHAR('I', '\0'),  ONE_WCHAR('Q', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('\0', '\0') };
const DRM_WCHAR      g_rgwchTagPRIVKEY                            [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),   ONE_WCHAR('Y', '\0'), ONE_WCHAR('\0', '\0') };
const DRM_WCHAR      g_rgwchXPathPrime0                           [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('/', '\0'),
                                                                          ONE_WCHAR('P', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('\0', '\0') };
const DRM_WCHAR      g_rgwchXPathPrime1                           [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('/', '\0'),
                                                                          ONE_WCHAR('P', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('1', '\0'),  ONE_WCHAR('\0', '\0') };
const DRM_WCHAR      g_rgwchXPathCRTExponent0                     [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('/', '\0'),
                                                                          ONE_WCHAR('C', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('x', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('\0', '\0') };
const DRM_WCHAR      g_rgwchXPathCRTExponent1                     [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('/', '\0'),
                                                                          ONE_WCHAR('C', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('x', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('1', '\0'),  ONE_WCHAR('\0', '\0') };
const DRM_WCHAR      g_rgwchXPathIQMP                             [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('/', '\0'),
                                                                          ONE_WCHAR('I', '\0'),  ONE_WCHAR('Q', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('\0', '\0') };
const DRM_WCHAR      g_rgwchWMDRMCertExponent                     [] =  { ONE_WCHAR('A', '\0'),  ONE_WCHAR('Q', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('\0', '\0') };

#if DRM_SUPPORT_ANTIROLLBACK_CLOCK
const DRM_WCHAR      g_rgwchCheckClockRollback                    [] =  { ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('g', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('b', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('>', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('h', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchResetRollbackedClock                  [] =  { ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('g', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('b', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('=', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('h', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
#endif

const DRM_WCHAR      g_rgwchSetSavedDateTime                      [] =  { ONE_WCHAR('(', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('h', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('>', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('g', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('b', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR(')', '\0'),  ONE_WCHAR('?', '\0'),  ONE_WCHAR('(', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('g', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('b', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('=', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('h', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR(')', '\0'),  ONE_WCHAR(':', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR(';', '\0'),  ONE_WCHAR('1', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchCreatePMLicense                       [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchVersion_1_0                           [] =  { ONE_WCHAR('1', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagDevinfo                            [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagFallback                           [] =  { ONE_WCHAR('F', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_WCHAR      g_rgwchTagError                              [] =  { ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathSigValue                         [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagDataInclusionList                  [] =  { ONE_WCHAR('L', '\0'), ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),   ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),   ONE_WCHAR('O', '\0'), ONE_WCHAR('R', '\0'),   ONE_WCHAR('I', '\0'), ONE_WCHAR('N', '\0'),   ONE_WCHAR('F', '\0'), ONE_WCHAR('O', '\0'),  ONE_WCHAR('/', '\0'), ONE_WCHAR('D', '\0'),   ONE_WCHAR('A', '\0'), ONE_WCHAR('T', '\0'),   ONE_WCHAR('A', '\0'), ONE_WCHAR('/', '\0'),   ONE_WCHAR('I', '\0'), ONE_WCHAR('N', '\0'),   ONE_WCHAR('C', '\0'), ONE_WCHAR('L', '\0'),   ONE_WCHAR('U', '\0'), ONE_WCHAR('S', '\0'),   ONE_WCHAR('I', '\0'), ONE_WCHAR('O', '\0'),   ONE_WCHAR('N', '\0'), ONE_WCHAR('L', '\0'),   ONE_WCHAR('I', '\0'), ONE_WCHAR('S', '\0'),   ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0') };
const DRM_WCHAR      g_rgwchFeatureIndivURL                       [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchCompatCert                            [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchCompatSecVersion                      [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchSubjectId                             [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchMaxSecLevel                           [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchAuthSecVer                            [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchAuthPubKey                            [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathTagSignature                     [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagSignatureVal                       [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathTagCertificateChain              [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchAuthData                              [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchAuthHashAlg                           [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchAuthSignAlg                           [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchFallback                              [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('\0', '\0')};


const DRM_WCHAR      g_rgwchXPathTagSecurityLevel                 [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_WCHAR      g_rgwchXPathTagCertificate                   [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathDataUniqueID                     [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Q', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_WCHAR      g_rgwchXPathManufacturer                     [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathMake                             [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathModel                            [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathDistributor                      [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathHardwareMajor                    [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('W', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('J', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathHardwareMinor                    [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('W', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathFirmwareMajor                    [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('W', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('J', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathFirmwareMinor                    [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('W', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathFeatureTemplate                  [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathClientOldKeys                    [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathClientEscrowKeys                 [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('W', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathClientEscrowKey                  [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('W', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathIndivServerEscrowKey             [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('W', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathDevicePublicKey                  [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathOldKeysData                      [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathIndivSvrPubKey                   [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathSecureClock                      [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathIndivType                        [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathSecureStore                      [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathMetering                         [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathLicenseChain                     [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_WCHAR      g_rgwchTagDevCert                            [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagWrmHeader                          [] =  { ONE_WCHAR('W', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchAttributeHeaderXmlnsName              [] =  { ONE_WCHAR('x', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('\0', '\0') };
/* "http://schemas.microsoft.com/DRM/2007/03/PlayReadyHeader" */
const DRM_WCHAR      g_rgwchAttributeHeaderXmlnsValue             [] =  { ONE_WCHAR('h', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR(':', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('h', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('f', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('2', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('7', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('3', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('\0', '\0')  };
const DRM_WCHAR      g_rgwchAttributeVersion2Value                [] =  { ONE_WCHAR('2', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchAttributeVersion4Value                [] =  { ONE_WCHAR('4', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagLAINFO                             [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagV4DATA                             [] =  { ONE_WCHAR('V', '\0'),  ONE_WCHAR('4', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagLAURL                              [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagLUIURL                             [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagDSID                               [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagKID                                [] =  { ONE_WCHAR('K', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagOEMData                            [] =  { ONE_WCHAR('O', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagContentID                          [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagChecksum                           [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathHeaderUplinks                    [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagUplink                             [] =  { ONE_WCHAR('U', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagUplinks                            [] =  { ONE_WCHAR('U', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_WCHAR      g_rgwchTagLicenseRequest                     [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Q', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagAction                             [] =  { ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_WCHAR      g_rgwchTagV1Challenge                        [] =  { ONE_WCHAR('V', '\0'),  ONE_WCHAR('1', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDefaultV1Data                         [] =  { ONE_WCHAR('N', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagActionList                         [] =  { ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagSecurityVersion                    [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};

/*
**  Devcert Non-indiv Tags
*/
const DRM_WCHAR      g_rgwchTagDNIUniqueID        [] =  { ONE_WCHAR('U', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Q', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagMSDRMSignature     [] =  { ONE_WCHAR('M', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchPrivateKeys           [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchCertTypeDevice        [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchCerttypeGroup         [] =  { ONE_WCHAR('G', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchCerttypeAuth          [] =  { ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchCerttypeAuthRoot      [] =  { ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0')};

/*
**  Devcert Non-indiv XPaths
*/
const DRM_WCHAR      g_rgwchXPathGCSupportCRL     [] =  { ONE_WCHAR('D', '\0'), ONE_WCHAR('A', '\0'), ONE_WCHAR('T', '\0'), ONE_WCHAR('A', '\0'), ONE_WCHAR('/', '\0'), ONE_WCHAR('F', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('A', '\0'), ONE_WCHAR('T', '\0'), ONE_WCHAR('U', '\0'), ONE_WCHAR('R', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('S', '\0'), ONE_WCHAR('/', '\0'), ONE_WCHAR('S', '\0'), ONE_WCHAR('U', '\0'), ONE_WCHAR('P', '\0'), ONE_WCHAR('P', '\0'), ONE_WCHAR('O', '\0'), ONE_WCHAR('R', '\0'), ONE_WCHAR('T', '\0'), ONE_WCHAR('_', '\0'), ONE_WCHAR('R', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('V', '\0'), ONE_WCHAR('O', '\0'), ONE_WCHAR('C', '\0'), ONE_WCHAR('A', '\0'), ONE_WCHAR('T', '\0'), ONE_WCHAR('I', '\0'), ONE_WCHAR('O', '\0'), ONE_WCHAR('N', '\0'), ONE_WCHAR('\0', '\0') };






const DRM_WCHAR      g_rgwchXPathPubkeyData         [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathGCSecureClock      [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathGCSecureClockURL   [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathGCSecureClockPubKey[] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathGCMetering         [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathGCLicenseAcquisitionMode[] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('Q', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathGCLicenseSyncMode  [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathGCSymmOpts         [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathGCEncryption       [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathGCSupportRevocation[] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('C', '\0'), ONE_WCHAR('A', '\0'), ONE_WCHAR('T', '\0'), ONE_WCHAR('I', '\0'), ONE_WCHAR('O', '\0'), ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathGCMaxChainDepth    [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('X', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathGCMaxLicenseSize   [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('X', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathGCMaxHeaderSize    [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('X', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathDeviceKeydata      [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathDACAuthID          [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};



const DRM_WCHAR      g_rgwchReqTagClientInfo                      [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchReqTagClientID                        [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchReqTagClientVersion                   [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchReqTagAppSecurity                     [] =  { ONE_WCHAR('A', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchReqTagSubjectID1                      [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('J', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('1', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchReqTagSubjectID2                      [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('J', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('2', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchReqTagDrmkVersion                     [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchReqTagSubjectID2Data                  [] =  { ONE_WCHAR(' ', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchReqTagDrmkData                        [] =  { ONE_WCHAR(' ', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchReqTagRevInfo                         [] =  { ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'), ONE_WCHAR('V', '\0'), ONE_WCHAR('I', '\0'), ONE_WCHAR('N', '\0'), ONE_WCHAR('F', '\0'), ONE_WCHAR('O', '\0'),  ONE_WCHAR('\0', '\0')};
/* Xml tags used in parsing licenses */
const DRM_WCHAR      g_rgwchLicense                               [] =  { ONE_WCHAR('L', '\0'), ONE_WCHAR('I', '\0'), ONE_WCHAR('C', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('N', '\0'), ONE_WCHAR('S', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchGUID                                  [] =  { ONE_WCHAR('G', '\0'), ONE_WCHAR('U', '\0'), ONE_WCHAR('I', '\0'), ONE_WCHAR('D', '\0'), ONE_WCHAR('\0', '\0') };
const DRM_WCHAR      g_rgwchLicensorInfoNode                      [] =  { ONE_WCHAR('L', '\0'), ONE_WCHAR('I', '\0'), ONE_WCHAR('C', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('N', '\0'), ONE_WCHAR('S', '\0'), ONE_WCHAR('O', '\0'), ONE_WCHAR('R', '\0'), ONE_WCHAR('I', '\0'), ONE_WCHAR('N', '\0'), ONE_WCHAR('F', '\0'), ONE_WCHAR('O', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchLIData                                [] =  { ONE_WCHAR('L', '\0'), ONE_WCHAR('I', '\0'), ONE_WCHAR('C', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('N', '\0'), ONE_WCHAR('S', '\0'), ONE_WCHAR('O', '\0'), ONE_WCHAR('R', '\0'), ONE_WCHAR('I', '\0'), ONE_WCHAR('N', '\0'), ONE_WCHAR('F', '\0'), ONE_WCHAR('O', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchMeta                                  [] =  { ONE_WCHAR('M', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('T', '\0'), ONE_WCHAR('A', '\0'), ONE_WCHAR('\0', '\0')};

const DRM_CHAR       g_rgchTagRevocation                          [] =  { TWO_BYTES('R', 'E'),  TWO_BYTES('V', 'O'),  TWO_BYTES('C', 'A'),  TWO_BYTES('T', 'I'),  TWO_BYTES('O', 'N'),  TWO_BYTES('\0', '\0')};
const DRM_WCHAR      g_rgwchTagRevocation                         [] =  { ONE_WCHAR('R', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('V', '\0'), ONE_WCHAR('O', '\0'), ONE_WCHAR('C', '\0'), ONE_WCHAR('A', '\0'), ONE_WCHAR('T', '\0'), ONE_WCHAR('I', '\0'), ONE_WCHAR('O', '\0'), ONE_WCHAR('N', '\0'), ONE_WCHAR('\0', '\0')};
const DRM_CHAR       g_rgchTagRevocationInfo                      [] =  { TWO_BYTES('R', 'E'),  TWO_BYTES('V', 'O'),  TWO_BYTES('C', 'A'),  TWO_BYTES('T', 'I'),  TWO_BYTES('O', 'N'),  TWO_BYTES('I', 'N'),  TWO_BYTES('F', 'O'),  TWO_BYTES('\0', '\0')};
const DRM_WCHAR      g_rgwchTagRevocationInfo                     [] =  { ONE_WCHAR('R', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('V', '\0'), ONE_WCHAR('O', '\0'), ONE_WCHAR('C', '\0'), ONE_WCHAR('A', '\0'), ONE_WCHAR('T', '\0'), ONE_WCHAR('I', '\0'), ONE_WCHAR('O', '\0'), ONE_WCHAR('N', '\0'), ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchAppRevocation                         [] =  { ONE_WCHAR('R', '\0'), ONE_WCHAR('e', '\0'), ONE_WCHAR('v', '\0'), ONE_WCHAR('o', '\0'), ONE_WCHAR('c', '\0'), ONE_WCHAR('a', '\0'), ONE_WCHAR('t', '\0'), ONE_WCHAR('i', '\0'), ONE_WCHAR('o', '\0'), ONE_WCHAR('n', '\0'), ONE_WCHAR('L', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_CHAR       g_rgchAppRevocation                          [] =  { TWO_BYTES('A', 'p'),  TWO_BYTES('p', 'R'),  TWO_BYTES('e', 'v'),  TWO_BYTES('o', 'c'),  TWO_BYTES('a', 't'),  TWO_BYTES('i', 'o'),  TWO_BYTES('n', 'L'),  TWO_BYTES('i', 's'),  TWO_BYTES('t', '\0') };
const DRM_WCHAR      g_rgwchDeviceRevocation                      [] =  { ONE_WCHAR('D', '\0'), ONE_WCHAR('e', '\0'), ONE_WCHAR('v', '\0'), ONE_WCHAR('i', '\0'), ONE_WCHAR('c', '\0'), ONE_WCHAR('e', '\0'), ONE_WCHAR('R', '\0'), ONE_WCHAR('e', '\0'), ONE_WCHAR('v', '\0'), ONE_WCHAR('o', '\0'), ONE_WCHAR('c', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_CHAR       g_rgchDeviceRevocation                       [] =  { TWO_BYTES('D', 'e'),  TWO_BYTES('v', 'i'),  TWO_BYTES('c', 'e'),  TWO_BYTES('R', 'e'),  TWO_BYTES('v', 'o'),  TWO_BYTES('c', 'a'),  TWO_BYTES('t', 'i'),  TWO_BYTES('o', 'n'),  TWO_BYTES('L', 'i'),  TWO_BYTES('s', 't'),  TWO_BYTES('\0', '\0')}; /* ODD count */
const DRM_WCHAR      g_rgwchDeviceRevocationList                  [] =  { ONE_WCHAR('D', '\0'), ONE_WCHAR('e', '\0'), ONE_WCHAR('v', '\0'), ONE_WCHAR('i', '\0'), ONE_WCHAR('c', '\0'), ONE_WCHAR('e', '\0'), ONE_WCHAR('R', '\0'), ONE_WCHAR('e', '\0'), ONE_WCHAR('v', '\0'), ONE_WCHAR('o', '\0'), ONE_WCHAR('c', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchWMDRMNET_Revocation                   [] =  { ONE_WCHAR('W', '\0'), ONE_WCHAR('M', '\0'), ONE_WCHAR('D', '\0'), ONE_WCHAR('R', '\0'), ONE_WCHAR('M', '\0'), ONE_WCHAR('N', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('T', '\0'), ONE_WCHAR('\0', '\0')};
const DRM_CHAR       g_rgchWMDRMNET_Revocation                    [] =  { TWO_BYTES('W', 'M'),  TWO_BYTES('D', 'R'),  TWO_BYTES('M', 'N'),  TWO_BYTES('E', 'T'),  TWO_BYTES('\0', '\0')};
const DRM_CHAR       g_rgchTagSLK                                 [] =  { TWO_BYTES('S', 'L'),  TWO_BYTES('K', '\0'), TWO_BYTES('\0', '\0')};
const DRM_CHAR       g_rgchTagSLKID                               [] =  { TWO_BYTES('S', 'L'),  TWO_BYTES('K', 'I'),  TWO_BYTES('D', '\0'), TWO_BYTES('\0', '\0')};
const DRM_CHAR       g_rgchTagSLKDATA                             [] =  { TWO_BYTES('S', 'L'),  TWO_BYTES('K', 'D'),  TWO_BYTES('A', 'T'),  TWO_BYTES('A', '\0'), TWO_BYTES('\0', '\0')};
const DRM_WCHAR      g_rgwchTagRevInfoVersion                     [] =  { ONE_WCHAR('R', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('V', '\0'), ONE_WCHAR('I', '\0'), ONE_WCHAR('N', '\0'), ONE_WCHAR('F', '\0'), ONE_WCHAR('O', '\0'), ONE_WCHAR('V', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('R', '\0'), ONE_WCHAR('S', '\0'), ONE_WCHAR('I', '\0'), ONE_WCHAR('O', '\0'), ONE_WCHAR('N', '\0'), ONE_WCHAR('\0', '\0')};
const DRM_CHAR       g_rgchTagRevInfoVersion                      [] =  { TWO_BYTES('R', 'E'),  TWO_BYTES('V', 'I'),  TWO_BYTES('N', 'F'),  TWO_BYTES('O', 'V'),  TWO_BYTES('E', 'R'),  TWO_BYTES('S', 'I'),  TWO_BYTES('O', 'N'),  TWO_BYTES('\0', '\0')};
const DRM_WCHAR      g_rgwchTagSourceID                           [] =  { ONE_WCHAR('S', '\0'), ONE_WCHAR('O', '\0'), ONE_WCHAR('U', '\0'), ONE_WCHAR('R', '\0'), ONE_WCHAR('C', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('I', '\0'), ONE_WCHAR('D', '\0'), ONE_WCHAR('\0', '\0')};
const DRM_CHAR       g_rgchTagSourceID                            [] =  { TWO_BYTES('S', 'O'),  TWO_BYTES('U', 'R'),  TWO_BYTES('C', 'E'),  TWO_BYTES('I', 'D'),  TWO_BYTES('\0', '\0')};

#if DRM_SUPPORT_REVOCATION
    
#if DRM_SUPPORT_WMDRMNET
/* {CD75E604-543D-4A9C-9F09-FE6D24E8BF90} */
const DRM_WCHAR      g_rgwchRevocationGuidWMDRMNET                [] = { ONE_WCHAR('{', '\0'), ONE_WCHAR('C', '\0'), ONE_WCHAR('D', '\0'), ONE_WCHAR('7', '\0'), ONE_WCHAR('5', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('6', '\0'), ONE_WCHAR('0', '\0'), ONE_WCHAR('4', '\0'), ONE_WCHAR('-', '\0'), ONE_WCHAR('5', '\0'), ONE_WCHAR('4', '\0'), ONE_WCHAR('3', '\0'), ONE_WCHAR('D', '\0'), ONE_WCHAR('-', '\0'), ONE_WCHAR('4', '\0'), ONE_WCHAR('A', '\0'), ONE_WCHAR('9', '\0'), ONE_WCHAR('C', '\0'), ONE_WCHAR('-', '\0'), ONE_WCHAR('9', '\0'), ONE_WCHAR('F', '\0'), ONE_WCHAR('0', '\0'), ONE_WCHAR('9', '\0'), ONE_WCHAR('-', '\0'), ONE_WCHAR('F', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('6', '\0'), ONE_WCHAR('D', '\0'), ONE_WCHAR('2', '\0'), ONE_WCHAR('4', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('8', '\0'), ONE_WCHAR('B', '\0'), ONE_WCHAR('F', '\0'), ONE_WCHAR('9', '\0'), ONE_WCHAR('0', '\0'), ONE_WCHAR('}', '\0'), };

/* {CD75E604-543D-4A9C-9F09-FE6D24E8BF90} */
const DRM_CHAR       g_rgchRevocationGuidWMDRMNET                 [] = { TWO_BYTES('{', 'C'), TWO_BYTES('D', '7'), TWO_BYTES('5', 'E'), TWO_BYTES('6', '0'), TWO_BYTES('4', '-'), TWO_BYTES('5', '4'), TWO_BYTES('3', 'D'), TWO_BYTES('-', '4'), TWO_BYTES('A', '9'), TWO_BYTES('C', '-'), TWO_BYTES('9', 'F'), TWO_BYTES('0', '9'), TWO_BYTES('-', 'F'), TWO_BYTES('E', '6'), TWO_BYTES('D', '2'), TWO_BYTES('4', 'E'), TWO_BYTES('8', 'B'), TWO_BYTES('F', '9'), TWO_BYTES('0', '}'), };
#endif /* DRM_SUPPORT_WMDRMNET */

#if DRM_SUPPORT_DEVICE_REVOCATION
/* {3129E375-CEB0-47D5-9CCA-9DB74CFD4332} */
const DRM_WCHAR      g_rgwchRevocationGuidDevice                  [] = { ONE_WCHAR('{', '\0'), ONE_WCHAR('3', '\0'), ONE_WCHAR('1', '\0'), ONE_WCHAR('2', '\0'), ONE_WCHAR('9', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('3', '\0'), ONE_WCHAR('7', '\0'), ONE_WCHAR('5', '\0'), ONE_WCHAR('-', '\0'), ONE_WCHAR('C', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('B', '\0'), ONE_WCHAR('0', '\0'), ONE_WCHAR('-', '\0'), ONE_WCHAR('4', '\0'), ONE_WCHAR('7', '\0'), ONE_WCHAR('D', '\0'), ONE_WCHAR('5', '\0'), ONE_WCHAR('-', '\0'), ONE_WCHAR('9', '\0'), ONE_WCHAR('C', '\0'), ONE_WCHAR('C', '\0'), ONE_WCHAR('A', '\0'), ONE_WCHAR('-', '\0'), ONE_WCHAR('9', '\0'), ONE_WCHAR('D', '\0'), ONE_WCHAR('B', '\0'), ONE_WCHAR('7', '\0'), ONE_WCHAR('4', '\0'), ONE_WCHAR('C', '\0'), ONE_WCHAR('F', '\0'), ONE_WCHAR('D', '\0'), ONE_WCHAR('4', '\0'), ONE_WCHAR('3', '\0'), ONE_WCHAR('3', '\0'), ONE_WCHAR('2', '\0'), ONE_WCHAR('}', '\0'), };

/* {3129E375-CEB0-47D5-9CCA-9DB74CFD4332} */
const DRM_CHAR       g_rgchRevocationGuidDevice                   [] = { TWO_BYTES('{', '3'), TWO_BYTES('1', '2'), TWO_BYTES('9', 'E'), TWO_BYTES('3', '7'), TWO_BYTES('5', '-'), TWO_BYTES('C', 'E'), TWO_BYTES('B', '0'), TWO_BYTES('-', '4'), TWO_BYTES('7', 'D'), TWO_BYTES('5', '-'), TWO_BYTES('9', 'C'), TWO_BYTES('C', 'A'), TWO_BYTES('-', '9'), TWO_BYTES('D', 'B'), TWO_BYTES('7', '4'), TWO_BYTES('C', 'F'), TWO_BYTES('D', '4'), TWO_BYTES('3', '3'), TWO_BYTES('2', '}'), };
#endif /* DRM_SUPPORT_DEVICE_REVOCATION */

#if DRM_SUPPORT_APP_REVOCATION
/* {90A37313-0ECF-4CAA-A906-B188F6129300} */
const DRM_WCHAR      g_rgwchRevocationGuidApp                     [] = { ONE_WCHAR('{', '\0'), ONE_WCHAR('9', '\0'), ONE_WCHAR('0', '\0'), ONE_WCHAR('A', '\0'), ONE_WCHAR('3', '\0'), ONE_WCHAR('7', '\0'), ONE_WCHAR('3', '\0'), ONE_WCHAR('1', '\0'), ONE_WCHAR('3', '\0'), ONE_WCHAR('-', '\0'), ONE_WCHAR('0', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('C', '\0'), ONE_WCHAR('F', '\0'), ONE_WCHAR('-', '\0'), ONE_WCHAR('4', '\0'), ONE_WCHAR('C', '\0'), ONE_WCHAR('A', '\0'), ONE_WCHAR('A', '\0'), ONE_WCHAR('-', '\0'), ONE_WCHAR('A', '\0'), ONE_WCHAR('9', '\0'), ONE_WCHAR('0', '\0'), ONE_WCHAR('6', '\0'), ONE_WCHAR('-', '\0'), ONE_WCHAR('B', '\0'), ONE_WCHAR('1', '\0'), ONE_WCHAR('8', '\0'), ONE_WCHAR('8', '\0'), ONE_WCHAR('F', '\0'), ONE_WCHAR('6', '\0'), ONE_WCHAR('1', '\0'), ONE_WCHAR('2', '\0'), ONE_WCHAR('9', '\0'), ONE_WCHAR('3', '\0'), ONE_WCHAR('0', '\0'), ONE_WCHAR('0', '\0'), ONE_WCHAR('}', '\0'), };

/* {90A37313-0ECF-4CAA-A906-B188F6129300} */
const DRM_CHAR       g_rgchRevocationGuidApp                      [] = { TWO_BYTES('{', '9'), TWO_BYTES('0', 'A'), TWO_BYTES('3', '7'), TWO_BYTES('3', '1'), TWO_BYTES('3', '-'), TWO_BYTES('0', 'E'), TWO_BYTES('C', 'F'), TWO_BYTES('-', '4'), TWO_BYTES('C', 'A'), TWO_BYTES('A', '-'), TWO_BYTES('A', '9'), TWO_BYTES('0', '6'), TWO_BYTES('-', 'B'), TWO_BYTES('1', '8'), TWO_BYTES('8', 'F'), TWO_BYTES('6', '1'), TWO_BYTES('2', '9'), TWO_BYTES('3', '0'), TWO_BYTES('0', '}'), };
#endif /* DRM_SUPPORT APP_REVOCATION */

#endif /* DRM_SUPPORT_REVOCATION */

const DRM_WCHAR       g_rgwchTagSLK                               [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR       g_rgwchTagSLKID                             [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR       g_rgwchTagSLKDATA                           [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_WCHAR      g_rgwchDeviceRevocationLicenseTag            [] =  { ONE_WCHAR('d', '\0'), ONE_WCHAR('e', '\0'), ONE_WCHAR('v', '\0'), ONE_WCHAR('i', '\0'), ONE_WCHAR('c', '\0'), ONE_WCHAR('e', '\0'), ONE_WCHAR('\0', '\0') };
const DRM_WCHAR      g_rgwchWMDRMNETRevocationLicenseTag          [] =  { ONE_WCHAR('w', '\0'), ONE_WCHAR('m', '\0'), ONE_WCHAR('d', '\0'), ONE_WCHAR('r', '\0'), ONE_WCHAR('m', '\0'), ONE_WCHAR('n', '\0'), ONE_WCHAR('e', '\0'), ONE_WCHAR('t', '\0'), ONE_WCHAR('\0', '\0') };

const DRM_WCHAR      g_rgwchMeteringId                            [] =  { ONE_WCHAR('M', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchPriority                              [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchIssueDate                             [] =  { ONE_WCHAR('I', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchContentPubKey                         [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchContentRevocation                     [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchCondition                             [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchAction                                [] =  { ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchRestrictions                          [] =  { ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchChainedEnablingBits                   [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDrmRestoreInfoEnablingBits            [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchCertChain                             [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagCertificate                        [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchLISigHashAlgo                         [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchLISigAlgo                             [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchLISigValue                            [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchOnActionPath                          [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathSymSig                           [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathSymValue                         [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_WCHAR      g_rgwchSequenceNumber                        [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Q', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchLSPubKey                              [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchUplinkKid                             [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchChainedCheckSum                       [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchPMLicenseVersionString                [] =  { ONE_WCHAR('0', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('1', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_CHAR       g_rgchPMLicenseVersionString                 [] =   { TWO_BYTES('0', '.'),  TWO_BYTES('1', '.'),   TWO_BYTES('0', '.'),   TWO_BYTES('0', '\0'),  TWO_BYTES('\0', '\0')}; /* ODD count */
const DRM_CHAR       g_rgchXMRLicenseVersionString                [] =  { TWO_BYTES('3', '.') ,  TWO_BYTES('0', '.'),   TWO_BYTES('0', '.'),   TWO_BYTES('0', '\0'),  TWO_BYTES('\0', '\0')}; /* ODD count */
const DRM_WCHAR      g_rgwchRevAttribute                          [] =  { ONE_WCHAR('r', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDerivedLicTemplate                    [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchLicDataDerivedTmpl                    [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchSourceID                              [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0') };
const DRM_WCHAR      g_rgwchInclusionList                         [] =  { ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0')};

/* XML tags used in writing Challenge and parsing Response for metering */
const DRM_WCHAR      g_rgwchTagMetering                           [] =  { ONE_WCHAR('M', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagHash                               [] =  { ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathMID                              [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};                      
const DRM_WCHAR      g_rgwchTagMID                                [] =  { ONE_WCHAR('M', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};                      
const DRM_WCHAR      g_rgwchTagTID                                [] =  { ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagCmd                                [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagPassword                           [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('W', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagRecords                            [] =  { ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagURL                                [] =  { ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagPartialData                        [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchLabelValue                            [] =  { ONE_WCHAR('v', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchHMAC                                  [] =  { ONE_WCHAR('H', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchChallenge                             [] =  { ONE_WCHAR('c', '\0'),  ONE_WCHAR('h', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('g', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwch1                                     [] =  { ONE_WCHAR('1', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchReset                                 [] =  { ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_CHAR       g_rgchTagMeterCert                           [] =  { TWO_BYTES('M', 'E'),  TWO_BYTES('T', 'E'),  TWO_BYTES('R', 'C'),  TWO_BYTES('E', 'R'),  TWO_BYTES('T', '\0')}; /* ODD count */

const DRM_WCHAR      g_rgwchTagMeterCert                          [] =  { ONE_WCHAR('M', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_WCHAR      g_rgwchTagCertificateChain                   [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};

/* tags used for sync lists */
const DRM_WCHAR      g_rgwchTagPrivateKey                         [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagDevice                             [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchKeyDataTag                            [] =  { ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchGroupTag                              [] =  { ONE_WCHAR('G', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_WCHAR      g_rgwchTagSyncList                           [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0')};
                                                                                                          
const DRM_WCHAR      g_rgwchBackup                                [] =  { ONE_WCHAR('B', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('k', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchRestore                               [] =  { ONE_WCHAR('R', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchRootSigValueVersionTag                [] =  { ONE_WCHAR('p', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchRootSigValueVersionVal                [] =  { ONE_WCHAR('1', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchPFRootTag                             [] =  { ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDACPubKeyTag                          [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchAuthRoot                              [] =  { ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagNameValue                          [] =  { ONE_WCHAR('W', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('f', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('2', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('3', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('1', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('1', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagSecurityLevel                      [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagDataId                             [] =  { ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagDataPubKey                         [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchFallBack                              [] =  { ONE_WCHAR('F', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagName                               [] =  { ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchManufacturer                          [] =  { ONE_WCHAR('M', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchModel                                 [] =  { ONE_WCHAR('M', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchHwMajor                               [] =  { ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('W', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('J', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchHwMinor                               [] =  { ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('W', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchFwMajor                               [] =  { ONE_WCHAR('F', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('W', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('J', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchFwMinor                               [] =  { ONE_WCHAR('F', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('W', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchFeatures                              [] =  { ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchSecClockNotSet                        [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchSecClockSet                           [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchSecClockNeedsRefresh                  [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTemplate                              [] =  { ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchIndivPubKey                           [] =  { ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchUniqueId                              [] =  { ONE_WCHAR('U', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Q', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchUnsignedtemplate                      [] =  { ONE_WCHAR('U', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};

/* This data is used explicitly in the gen tools */
const DRM_WCHAR      g_rgwchTagDataSecVer                         [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};

/* Strings for the expression evaluator functions */
const DRM_WCHAR      g_rgwchExprFuncDateAdd                       [] =  { ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprFuncDateDiff                      [] =  { ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('f', '\0'),  ONE_WCHAR('f', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprFuncMin                           [] =  { ONE_WCHAR('m', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprFuncMax                           [] =  { ONE_WCHAR('m', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('x', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprFuncDatePart                      [] =  { ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprFuncVersionCompare                [] =  { ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprFuncDeleteLicense                 [] =  { ONE_WCHAR('d', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprFuncExists                        [] =  { ONE_WCHAR('e', '\0'),  ONE_WCHAR('x', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('\0', '\0')};

/* Strings for license evaluator well known actions */
const DRM_WCHAR      g_rgwchLicEvalOnSelect                       [] =  { ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchLicEvalOnDelete                       [] =  { ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchLicEvalOnStore                        [] =  { ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchLicEvalOnAction                       [] =  { ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};
#if DRM_SUPPORT_ANTIROLLBACK_CLOCK 
const DRM_WCHAR      g_rgwchLicEvalOnClockRollback                [] =  { ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('\0', '\0')};
#endif

/* Strings for expression evaluator variable evaluation */
const DRM_WCHAR      g_rgwchDRM_PREFIX                            [] =  { ONE_WCHAR('d', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRMK_PREFIX                           [] =  { ONE_WCHAR('d', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('k', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchMACHINE_PREFIX                        [] =  { ONE_WCHAR('m', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('h', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchAPP_PREFIX                            [] =  { ONE_WCHAR('a', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchSECSTATE_PREFIX                       [] =  { ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchLICENSE_PREFIX                        [] =  { ONE_WCHAR('l', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchCONTENT_PREFIX                        [] =  { ONE_WCHAR('c', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDEVICE_PREFIX                         [] =  { ONE_WCHAR('d', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchPMLICENSE_PREFIX                      [] =  { ONE_WCHAR('p', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchSECURETIME_PREFIX                     [] =  { ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchPLAYLISTBURN_PREFIX                   [] =  { ONE_WCHAR('p', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('\0', '\0')};

#if DRM_SUPPORT_SST_REDUNANCY
const DRM_WCHAR      g_rgwchSSTREDUNDANCY_PREFIX                  [] =  { ONE_WCHAR('s', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('\0', '\0')};
#endif

const DRM_WCHAR      g_rgwchExprVarVersion                        [] =  { ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarParameter                      [] =  { ONE_WCHAR('p', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarReason                         [] =  { ONE_WCHAR('r', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarBBMSDRMVersion                 [] =  { ONE_WCHAR('b', '\0'),  ONE_WCHAR('b', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarDateTime                       [] =  { ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarCount                          [] =  { ONE_WCHAR('c', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarMinSecLevel                    [] =  { ONE_WCHAR('m', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarSecLevel                       [] =  { ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarAppSecLevel                    [] =  { ONE_WCHAR('a', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarSubjID                         [] =  { ONE_WCHAR('s', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('b', '\0'),  ONE_WCHAR('j', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarAppSubjID                      [] =  { ONE_WCHAR('a', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('b', '\0'),  ONE_WCHAR('j', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarGlobal                         [] =  { ONE_WCHAR('g', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('b', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarSaveDateTime                   [] =  { ONE_WCHAR('s', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarSavedDateTime                  [] =  { ONE_WCHAR('s', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarDRMReason                      [] =  { ONE_WCHAR('d', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarRights                         [] =  { ONE_WCHAR('r', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('g', '\0'),  ONE_WCHAR('h', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarExpiryDate                     [] =  { ONE_WCHAR('e', '\0'),  ONE_WCHAR('x', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarInGracePeriod                  [] =  { ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('g', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarGpStartTime                    [] =  { ONE_WCHAR('g', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarIncrementCount                 [] =  { ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarDevReg                         [] =  { ONE_WCHAR('r', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('g', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('\0', '\0')};

/* XML tags */
const DRM_WCHAR      g_rgwchTagCDATA                              [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagCDATAOpenBracket                   [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('[', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchOpenTag                               [] =  { ONE_WCHAR('<', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchSpace                                 [] =  { ONE_WCHAR(' ', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchOpenEndTag                            [] =  { ONE_WCHAR('<', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchCloseTag                              [] =  { ONE_WCHAR('>', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchEqualQuote                            [] =  { ONE_WCHAR('=', '\0'),  ONE_WCHAR('\"', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchQuote                                 [] =  { ONE_WCHAR('\"', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchOpenCDATATag                          [] =  { ONE_WCHAR('<', '\0'),  ONE_WCHAR('!', '\0'),  ONE_WCHAR('[', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('[', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchCloseCDATATag                         [] =  { ONE_WCHAR(']', '\0'),  ONE_WCHAR(']', '\0'),  ONE_WCHAR('>', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_CHAR       g_rgchTagCDATA                               [] =  { TWO_BYTES('C', 'D'),  TWO_BYTES('A', 'T'),  TWO_BYTES('A', '\0'),  TWO_BYTES('\0', '\0') };
#define g_rgchTagCDATA_LEN 5
const DRM_CHAR       g_rgchTagCDATAOpenBracket                    [] =  { TWO_BYTES('C', 'D'),  TWO_BYTES('A', 'T'),  TWO_BYTES('A', '['),  TWO_BYTES('\0', '\0')};
#define g_rgchTagCDATAOpenBracket_LEN 6


const DRM_CHAR  g_rgchAttributeAlgorithm        [] = { TWO_BYTES('A', 'l'), TWO_BYTES('g', 'o'), TWO_BYTES('r', 'i'), TWO_BYTES('t', 'h'), TWO_BYTES('m', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchAttributeAlgorithm_LEN 9
const DRM_CHAR  g_rgchAttributeVersionWMDRM     [] = { TWO_BYTES('c', ':'), TWO_BYTES('V', 'e'), TWO_BYTES('r', 's'), TWO_BYTES('i', 'o'), TWO_BYTES('n', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchAttributeVersionWMDRM_LEN 9
const DRM_CHAR  g_rgchTagEscrowedKeys           [] = { TWO_BYTES('E', 's'), TWO_BYTES('c', 'r'), TWO_BYTES('o', 'w'), TWO_BYTES('e', 'd'), TWO_BYTES('K', 'e'), TWO_BYTES('y', 's'), TWO_BYTES('\0', '\0') };
#define g_rgchTagEscrowedKeys_LEN 12
const DRM_CHAR  g_rgchKeyUsageSignCert          [] = { TWO_BYTES('c', ':'), TWO_BYTES('S', 'i'), TWO_BYTES('g', 'n'), TWO_BYTES('C', 'e'), TWO_BYTES('r', 't'), TWO_BYTES('i', 'f'), TWO_BYTES('i', 'c'), TWO_BYTES('a', 't'), TWO_BYTES('e', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchKeyUsageSignCert_LEN 17
const DRM_CHAR  g_rgchKeyUsageSignCRL           [] = { TWO_BYTES('c', ':'), TWO_BYTES('S', 'i'), TWO_BYTES('g', 'n'), TWO_BYTES('C', 'R'), TWO_BYTES('L', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchKeyUsageSignCRL_LEN 9
const DRM_CHAR  g_rgchKeyUsageEncryptKey        [] = { TWO_BYTES('c', ':'), TWO_BYTES('E', 'n'), TWO_BYTES('c', 'r'), TWO_BYTES('y', 'p'), TWO_BYTES('t', 'K'), TWO_BYTES('e', 'y'), TWO_BYTES('\0', '\0') };
#define g_rgchKeyUsageEncryptKey_LEN 12
const DRM_CHAR  g_rgchOne                       [] = { TWO_BYTES('1', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchOne_LEN 1
const DRM_CHAR  g_rgchPrefixManufacturer        [] = { TWO_BYTES('x', 'm'), TWO_BYTES('l', 'n'), TWO_BYTES('s', ':'), TWO_BYTES('f', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchPrefixManufacturer_LEN 7
const DRM_CHAR  g_rgchTagCanonicalization       [] = { TWO_BYTES('C', 'a'), TWO_BYTES('n', 'o'), TWO_BYTES('n', 'i'), TWO_BYTES('c', 'a'), TWO_BYTES('l', 'i'), TWO_BYTES('z', 'a'), TWO_BYTES('t', 'i'), TWO_BYTES('o', 'n'), TWO_BYTES('M', 'e'), TWO_BYTES('t', 'h'), TWO_BYTES('o', 'd'), TWO_BYTES('\0', '\0') };
#define g_rgchTagCanonicalization_LEN 22
const DRM_CHAR  g_rgchTagCertificateCollection  [] = { TWO_BYTES('c', ':'), TWO_BYTES('C', 'e'), TWO_BYTES('r', 't'), TWO_BYTES('i', 'f'), TWO_BYTES('i', 'c'), TWO_BYTES('a', 't'), TWO_BYTES('e', 'C'), TWO_BYTES('o', 'l'), TWO_BYTES('l', 'e'), TWO_BYTES('c', 't'), TWO_BYTES('i', 'o'), TWO_BYTES('n', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagCertificateCollection_LEN 23
const DRM_CHAR  g_rgchTagDigestMethod           [] = { TWO_BYTES('D', 'i'), TWO_BYTES('g', 'e'), TWO_BYTES('s', 't'), TWO_BYTES('M', 'e'), TWO_BYTES('t', 'h'), TWO_BYTES('o', 'd'), TWO_BYTES('\0', '\0') };
#define g_rgchTagDigestMethod_LEN 12
const DRM_CHAR  g_rgchURIDSigSHA1               [] = { TWO_BYTES('h', 't'), TWO_BYTES('t', 'p'), TWO_BYTES(':', '/'), TWO_BYTES('/', 'w'), TWO_BYTES('w', 'w'), TWO_BYTES('.', 'w'), TWO_BYTES('3', '.'), TWO_BYTES('o', 'r'), TWO_BYTES('g', '/'), TWO_BYTES('2', '0'), TWO_BYTES('0', '0'), TWO_BYTES('/', '0'), TWO_BYTES('9', '/'), TWO_BYTES('x', 'm'), TWO_BYTES('l', 'd'), TWO_BYTES('s', 'i'), TWO_BYTES('g', '#'), TWO_BYTES('s', 'h'), TWO_BYTES('a', '1'), TWO_BYTES('\0', '\0') };
#define g_rgchURIDSigSHA1_LEN 38
const DRM_CHAR  g_rgchTagDigestValue            [] = { TWO_BYTES('D', 'i'), TWO_BYTES('g', 'e'), TWO_BYTES('s', 't'), TWO_BYTES('V', 'a'), TWO_BYTES('l', 'u'), TWO_BYTES('e', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagDigestValue_LEN 11
const DRM_CHAR  g_rgchTagSignatureValue         [] = { TWO_BYTES('S', 'i'), TWO_BYTES('g', 'n'), TWO_BYTES('a', 't'), TWO_BYTES('u', 'r'), TWO_BYTES('e', 'V'), TWO_BYTES('a', 'l'), TWO_BYTES('u', 'e'), TWO_BYTES('\0', '\0') };
#define g_rgchTagSignatureValue_LEN 14
const DRM_CHAR  g_rgchTagKeyInfo                [] = { TWO_BYTES('K', 'e'), TWO_BYTES('y', 'I'), TWO_BYTES('n', 'f'), TWO_BYTES('o', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagKeyInfo_LEN 7
const DRM_CHAR  g_rgchTagSymmetricKey           [] = { TWO_BYTES('S', 'y'), TWO_BYTES('m', 'm'), TWO_BYTES('K', 'e'), TWO_BYTES('y', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagSymmetricKey_LEN 7
const DRM_CHAR  g_rgchTagPublicKey              [] = { TWO_BYTES('P', 'u'), TWO_BYTES('b', 'l'), TWO_BYTES('i', 'c'), TWO_BYTES('K', 'e'), TWO_BYTES('y', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagPublicKey_LEN 9
const DRM_CHAR  g_rgchTagPrivateKey             [] = { TWO_BYTES('P', 'r'), TWO_BYTES('i', 'v'), TWO_BYTES('a', 't'), TWO_BYTES('e', 'K'), TWO_BYTES('e', 'y'), TWO_BYTES('\0', '\0') };
#define g_rgchTagPrivateKey_LEN 10
const DRM_CHAR  g_rgchTagKeyValue               [] = { TWO_BYTES('K', 'e'), TWO_BYTES('y', 'V'), TWO_BYTES('a', 'l'), TWO_BYTES('u', 'e'), TWO_BYTES('\0', '\0') };
#define g_rgchTagKeyValue_LEN 8
const DRM_CHAR  g_rgchTagRSAKeyValue            [] = { TWO_BYTES('R', 'S'), TWO_BYTES('A', 'K'), TWO_BYTES('e', 'y'), TWO_BYTES('V', 'a'), TWO_BYTES('l', 'u'), TWO_BYTES('e', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagRSAKeyValue_LEN 11
const DRM_CHAR  g_rgchTagModulus                [] = { TWO_BYTES('M', 'o'), TWO_BYTES('d', 'u'), TWO_BYTES('l', 'u'), TWO_BYTES('s', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagModulus_LEN 7
const DRM_CHAR  g_rgchTagExponent               [] = { TWO_BYTES('E', 'x'), TWO_BYTES('p', 'o'), TWO_BYTES('n', 'e'), TWO_BYTES('n', 't'), TWO_BYTES('\0', '\0') };
#define g_rgchTagExponent_LEN 8
const DRM_CHAR  g_rgchOpenEndTag                [] = { TWO_BYTES('<', '/'), TWO_BYTES('\0', '\0') };
#define g_rgchOpenEndTag_LEN 2
const DRM_CHAR  g_rgchOpenCDATATag              [] = { TWO_BYTES('<', '!'), TWO_BYTES('[', 'C'), TWO_BYTES('D', 'A'), TWO_BYTES('T', 'A'), TWO_BYTES('[', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchOpenCDATATag_LEN 9
const DRM_CHAR  g_rgchCloseCDATATag             [] = { TWO_BYTES(']', ']'), TWO_BYTES('>', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchCloseCDATATag_LEN 3

const DRM_CHAR  g_rgchTagManufacturerName       [] = { TWO_BYTES('c', ':'), TWO_BYTES('M', 'a'), TWO_BYTES('n', 'u'), TWO_BYTES('f', 'a'), TWO_BYTES('c', 't'), TWO_BYTES('u', 'r'), TWO_BYTES('e', 'r'), TWO_BYTES('N', 'a'), TWO_BYTES('m', 'e'), TWO_BYTES('\0', '\0') };
#define g_rgchTagManufacturerName_LEN 18
const DRM_CHAR  g_rgchTagManufacturerData       [] = { TWO_BYTES('c', ':'), TWO_BYTES('M', 'a'), TWO_BYTES('n', 'u'), TWO_BYTES('f', 'a'), TWO_BYTES('c', 't'), TWO_BYTES('u', 'r'), TWO_BYTES('e', 'r'), TWO_BYTES('D', 'a'), TWO_BYTES('t', 'a'), TWO_BYTES('\0', '\0') }; 
#define g_rgchTagManufacturerData_LEN 18
const DRM_CHAR  g_rgchTagModelName              [] = { TWO_BYTES('c', ':'), TWO_BYTES('M', 'o'), TWO_BYTES('d', 'e'), TWO_BYTES('l', 'N'), TWO_BYTES('a', 'm'), TWO_BYTES('e', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagModelName_LEN 11
const DRM_CHAR  g_rgchTagModelNumber            [] = { TWO_BYTES('c', ':'), TWO_BYTES('M', 'o'), TWO_BYTES('d', 'e'), TWO_BYTES('l', 'N'), TWO_BYTES('u', 'm'), TWO_BYTES('b', 'e'), TWO_BYTES('r', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagModelNumber_LEN 13
const DRM_CHAR  g_rgchTagHardwareID               [] = { TWO_BYTES('c', ':'), TWO_BYTES('H', 'a'), TWO_BYTES('r', 'd'), TWO_BYTES('w', 'a'), TWO_BYTES('r', 'e'), TWO_BYTES('I', 'D'), TWO_BYTES('\0', '\0') };
#define g_rgchTagHardwareID_LEN 12
const DRM_CHAR  g_rgchURIRSASHA1                [] = { TWO_BYTES('h', 't'), TWO_BYTES('t', 'p'), TWO_BYTES(':', '/'), TWO_BYTES('/', 'w'), TWO_BYTES('w', 'w'), TWO_BYTES('.', 'w'), TWO_BYTES('3', '.'), TWO_BYTES('o', 'r'), TWO_BYTES('g', '/'), TWO_BYTES('2', '0'), TWO_BYTES('0', '0'), TWO_BYTES('/', '0'), TWO_BYTES('9', '/'), TWO_BYTES('x', 'm'), TWO_BYTES('l', 'd'), TWO_BYTES('s', 'i'), TWO_BYTES('g', '#'), TWO_BYTES('r', 's'), TWO_BYTES('a', '-'), TWO_BYTES('s', 'h'), TWO_BYTES('a', '1'), TWO_BYTES('\0', '\0') };
#define g_rgchURIRSASHA1_LEN 42
const DRM_CHAR  g_rgchURIRSASHA1_Old            [] = { TWO_BYTES('h', 't'), TWO_BYTES('t', 'p'), TWO_BYTES(':', '/'), TWO_BYTES('/', 's'), TWO_BYTES('c', 'h'), TWO_BYTES('e', 'm'), TWO_BYTES('a', 's'), TWO_BYTES('.', 'm'), TWO_BYTES('i', 'c'), TWO_BYTES('r', 'o'), TWO_BYTES('s', 'o'), TWO_BYTES('f', 't'), TWO_BYTES('.', 'c'), TWO_BYTES('o', 'm'), TWO_BYTES('/', 'D'), TWO_BYTES('R', 'M'), TWO_BYTES('/', '2'), TWO_BYTES('0', '0'), TWO_BYTES('4', '/'), TWO_BYTES('0', '2'), TWO_BYTES('/', 'C'), TWO_BYTES('E', 'R'), TWO_BYTES('T', '/'), TWO_BYTES('R', 's'), TWO_BYTES('a', '-'), TWO_BYTES('s', 'h'), TWO_BYTES('a', '1'), TWO_BYTES('\0', '\0') };
#define g_rgchURIRSASHA1_Old_LEN 54
const DRM_CHAR  g_rgchTagReference              [] = { TWO_BYTES('R', 'e'), TWO_BYTES('f', 'e'), TWO_BYTES('r', 'e'), TWO_BYTES('n', 'c'), TWO_BYTES('e', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagReference_LEN 9
const DRM_CHAR  g_rgchTagTransforms             [] = { TWO_BYTES('T', 'r'), TWO_BYTES('a', 'n'), TWO_BYTES('s', 'f'), TWO_BYTES('o', 'r'), TWO_BYTES('m', 's'), TWO_BYTES('\0', '\0') };
#define g_rgchTagTransforms_LEN 10
const DRM_CHAR  g_rgchTagTransform              [] = { TWO_BYTES('T', 'r'), TWO_BYTES('a', 'n'), TWO_BYTES('s', 'f'), TWO_BYTES('o', 'r'), TWO_BYTES('m', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagTransform_LEN 9
const DRM_CHAR  g_rgchURITransformMSCert        [] = { TWO_BYTES('h', 't'), TWO_BYTES('t', 'p'), TWO_BYTES(':', '/'), TWO_BYTES('/', 'w'), TWO_BYTES('w', 'w'), TWO_BYTES('.', 'm'), TWO_BYTES('i', 'c'), TWO_BYTES('r', 'o'), TWO_BYTES('s', 'o'), TWO_BYTES('f', 't'), TWO_BYTES('.', 'c'), TWO_BYTES('o', 'm'), TWO_BYTES('/', 'D'), TWO_BYTES('R', 'M'), TWO_BYTES('/', 'C'), TWO_BYTES('E', 'R'), TWO_BYTES('T', '/'), TWO_BYTES('v', '2'), TWO_BYTES('/', 'D'), TWO_BYTES('a', 't'), TWO_BYTES('a', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchURITransformMSCert_LEN 41
const DRM_CHAR  g_rgchURITransformMSCertColl    [] = { TWO_BYTES('h', 't'), TWO_BYTES('t', 'p'), TWO_BYTES(':', '/'), TWO_BYTES('/', 's'), TWO_BYTES('c', 'h'), TWO_BYTES('e', 'm'), TWO_BYTES('a', 's'), TWO_BYTES('.', 'm'), TWO_BYTES('i', 'c'), TWO_BYTES('r', 'o'), TWO_BYTES('s', 'o'), TWO_BYTES('f', 't'), TWO_BYTES('.', 'c'), TWO_BYTES('o', 'm'), TWO_BYTES('/', 'D'), TWO_BYTES('R', 'M'), TWO_BYTES('/', '2'), TWO_BYTES('0', '0'), TWO_BYTES('4', '/'), TWO_BYTES('0', '2'), TWO_BYTES('/', 'c'), TWO_BYTES('e', 'r'), TWO_BYTES('t', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchURITransformMSCertColl_LEN 45
const DRM_CHAR  g_rgchURITransformMSCert_Old    [] = { TWO_BYTES('h', 't'), TWO_BYTES('t', 'p'), TWO_BYTES(':', '/'), TWO_BYTES('/', 's'), TWO_BYTES('c', 'h'), TWO_BYTES('e', 'm'), TWO_BYTES('a', 's'), TWO_BYTES('.', 'm'), TWO_BYTES('i', 'c'), TWO_BYTES('r', 'o'), TWO_BYTES('s', 'o'), TWO_BYTES('f', 't'), TWO_BYTES('.', 'c'), TWO_BYTES('o', 'm'), TWO_BYTES('/', 'D'), TWO_BYTES('R', 'M'), TWO_BYTES('/', '2'), TWO_BYTES('0', '0'), TWO_BYTES('4', '/'), TWO_BYTES('0', '2'), TWO_BYTES('/', 'C'), TWO_BYTES('E', 'R'), TWO_BYTES('T', '/'), TWO_BYTES('D', 'a'), TWO_BYTES('t', 'a'), TWO_BYTES('\0', '\0') };
#define g_rgchURITransformMSCert_Old_LEN 50
const DRM_CHAR  g_rgchURITransformC14N          [] = { TWO_BYTES('h', 't'), TWO_BYTES('t', 'p'), TWO_BYTES(':', '/'), TWO_BYTES('/', 'w'), TWO_BYTES('w', 'w'), TWO_BYTES('.', 'w'), TWO_BYTES('3', '.'), TWO_BYTES('o', 'r'), TWO_BYTES('g', '/'), TWO_BYTES('T', 'R'), TWO_BYTES('/', '2'), TWO_BYTES('0', '0'), TWO_BYTES('1', '/'), TWO_BYTES('R', 'E'), TWO_BYTES('C', '-'), TWO_BYTES('x', 'm'), TWO_BYTES('l', '-'), TWO_BYTES('c', '1'), TWO_BYTES('4', 'n'), TWO_BYTES('-', '2'), TWO_BYTES('0', '0'), TWO_BYTES('1', '0'), TWO_BYTES('3', '1'), TWO_BYTES('5', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchURITransformC14N_LEN 47
const DRM_CHAR  g_rgchTagWMDRMCertificate       [] = { TWO_BYTES('c', ':'), TWO_BYTES('C', 'e'), TWO_BYTES('r', 't'), TWO_BYTES('i', 'f'), TWO_BYTES('i', 'c'), TWO_BYTES('a', 't'), TWO_BYTES('e', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagWMDRMCertificate_LEN 13
const DRM_CHAR  g_rgchTagWMDRMCertSecurityVersion[]= { TWO_BYTES('c', ':'), TWO_BYTES('S', 'e'), TWO_BYTES('c', 'u'), TWO_BYTES('r', 'i'), TWO_BYTES('t', 'y'), TWO_BYTES('V', 'e'), TWO_BYTES('r', 's'), TWO_BYTES('i', 'o'), TWO_BYTES('n', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagWMDRMCertSecurityVersion_LEN 17
const DRM_CHAR  g_rgchSecurityVersion           [] = { TWO_BYTES('3', '.'), TWO_BYTES('0', '.'), TWO_BYTES('0', '.'), TWO_BYTES('1', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchSecurityVersion_LEN 7
const DRM_CHAR  g_rgchTagWMDRMCertSecurityLevel [] = { TWO_BYTES('c', ':'), TWO_BYTES('S', 'e'), TWO_BYTES('c', 'u'), TWO_BYTES('r', 'i'), TWO_BYTES('t', 'y'), TWO_BYTES('L', 'e'), TWO_BYTES('v', 'e'), TWO_BYTES('l', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagWMDRMCertSecurityLevel_LEN 15
const DRM_CHAR  g_rgchTagWMDRMCertSerialNumber  [] = { TWO_BYTES('c', ':'), TWO_BYTES('S', 'e'), TWO_BYTES('r', 'i'), TWO_BYTES('a', 'l'), TWO_BYTES('N', 'u'), TWO_BYTES('m', 'b'), TWO_BYTES('e', 'r'), TWO_BYTES('\0', '\0') };
#define g_rgchTagWMDRMCertSerialNumber_LEN 14
const DRM_CHAR  g_rgchTagWMDRMCertFeatures      [] = { TWO_BYTES('c', ':'), TWO_BYTES('F', 'e'), TWO_BYTES('a', 't'), TWO_BYTES('u', 'r'), TWO_BYTES('e', 's'), TWO_BYTES('\0', '\0') };
#define g_rgchTagWMDRMCertFeatures_LEN 10

const DRM_CHAR  g_rgchFeaturesWMDRMTransmitter  [] = { TWO_BYTES('c',':'), TWO_BYTES('W','M'), TWO_BYTES('D','R'), TWO_BYTES('M','T'), TWO_BYTES('r','a'), TWO_BYTES('n','s'), TWO_BYTES('m','i'), TWO_BYTES('t','t'), TWO_BYTES('e','r'), TWO_BYTES('\0', '\0') };
#define g_rgchFeaturesWMDRMTransmitter_LEN 18
const DRM_CHAR  g_rgchFeaturesWMDRMReceiver     [] = { TWO_BYTES('c',':'), TWO_BYTES('W','M'), TWO_BYTES('D','R'), TWO_BYTES('M','R'), TWO_BYTES('e','c'), TWO_BYTES('e','i'), TWO_BYTES('v','e'), TWO_BYTES('r', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchFeaturesWMDRMReceiver_LEN 15
const DRM_CHAR  g_rgchTagWMDRMCertKeyUsage      [] = { TWO_BYTES('c', ':'), TWO_BYTES('K', 'e'), TWO_BYTES('y', 'U'), TWO_BYTES('s', 'a'), TWO_BYTES('g', 'e'), TWO_BYTES('\0', '\0') };
#define g_rgchTagWMDRMCertKeyUsage_LEN 10
const DRM_CHAR  g_rgchTagWMDRMCertPublicKey     [] = { TWO_BYTES('c', ':'), TWO_BYTES('P', 'u'), TWO_BYTES('b', 'l'), TWO_BYTES('i', 'c'), TWO_BYTES('K', 'e'), TWO_BYTES('y', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagWMDRMCertPublicKey_LEN 11
const DRM_CHAR  g_rgchTagDataWMDRM              [] = { TWO_BYTES('c', ':'), TWO_BYTES('D', 'a'), TWO_BYTES('t', 'a'), TWO_BYTES('\0', '\0') };
#define g_rgchTagDataWMDRM_LEN 6
const DRM_CHAR  g_rgchTagSignature              [] = { TWO_BYTES('S', 'i'), TWO_BYTES('g', 'n'), TWO_BYTES('a', 't'), TWO_BYTES('u', 'r'), TWO_BYTES('e', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagSignature_LEN 9
const DRM_CHAR  g_rgchTagSignatureMethod        [] = { TWO_BYTES('S', 'i'), TWO_BYTES('g', 'n'), TWO_BYTES('a', 't'), TWO_BYTES('u', 'r'), TWO_BYTES('e', 'M'), TWO_BYTES('e', 't'), TWO_BYTES('h', 'o'), TWO_BYTES('d', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagSignatureMethod_LEN 15
const DRM_CHAR  g_rgchTagSignedInfo             [] = { TWO_BYTES('S', 'i'), TWO_BYTES('g', 'n'), TWO_BYTES('e', 'd'), TWO_BYTES('I', 'n'), TWO_BYTES('f', 'o'), TWO_BYTES('\0', '\0') };
#define g_rgchTagSignedInfo_LEN 10
const DRM_CHAR  g_rgchURIC14N                   [] = { TWO_BYTES('h', 't'), TWO_BYTES('t', 'p'), TWO_BYTES(':', '/'), TWO_BYTES('/', 'w'), TWO_BYTES('w', 'w'), TWO_BYTES('.', 'w'), TWO_BYTES('3', '.'), TWO_BYTES('o', 'r'), TWO_BYTES('g', '/'), TWO_BYTES('T', 'R'), TWO_BYTES('/', '2'), TWO_BYTES('0', '0'), TWO_BYTES('1', '/'), TWO_BYTES('R', 'E'), TWO_BYTES('C', '-'), TWO_BYTES('x', 'm'), TWO_BYTES('l', '-'), TWO_BYTES('c', '1'), TWO_BYTES('4', 'n'), TWO_BYTES('-', '2'), TWO_BYTES('0', '0'), TWO_BYTES('1', '0'), TWO_BYTES('3', '1'), TWO_BYTES('5', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchURIC14N_LEN 47
const DRM_CHAR  g_rgchVersionWMDRM              [] = { TWO_BYTES('2', '.'), TWO_BYTES('0', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchVersionWMDRM_LEN 3
const DRM_CHAR  g_rgchWMDRMCertExponent         [] = { TWO_BYTES('A', 'Q'), TWO_BYTES('A', 'B'), TWO_BYTES('\0', '\0') };
#define g_rgchWMDRMCertExponent_LEN 4


const DRM_CHAR  g_rgchFeatureSampleProtection   [] = { TWO_BYTES('m', ':'), TWO_BYTES('W', 'M'), TWO_BYTES('D', 'R'), TWO_BYTES('M', 'S'), TWO_BYTES('a', 'm'), TWO_BYTES('p', 'l'), TWO_BYTES('e', 'P'), TWO_BYTES('r', 'o'), TWO_BYTES('t', 'e'), TWO_BYTES('c', 't'), TWO_BYTES('i', 'o'), TWO_BYTES('n', '\0') };
#define g_rgchFeatureSampleProtection_LEN 23
const DRM_CHAR  g_rgchFeatureExport             [] = { TWO_BYTES('m', ':'), TWO_BYTES('W', 'M'), TWO_BYTES('D', 'R'), TWO_BYTES('M', 'E'), TWO_BYTES('x', 'p'), TWO_BYTES('o', 'r'), TWO_BYTES('t', '\0') };
#define g_rgchFeatureExport_LEN 13
const DRM_CHAR  g_rgchFeatureExportIncl         [] = { TWO_BYTES('m', ':'), TWO_BYTES('W', 'M'), TWO_BYTES('D', 'R'), TWO_BYTES('M', 'E'), TWO_BYTES('x', 'p'), TWO_BYTES('o', 'r'), TWO_BYTES('t', 'I'), TWO_BYTES('n', 'c'), TWO_BYTES('l', '\0') };
#define g_rgchFeatureExportIncl_LEN 17

const DRM_CHAR  g_rgchPrefixMicrosoftCert       [] = { TWO_BYTES('x', 'm'), TWO_BYTES('l', 'n'), TWO_BYTES('s', ':'), TWO_BYTES('c', '\0') };
#define g_rgchPrefixMicrosoftCert_LEN 7

const DRM_CHAR  g_rgchTagUnsignedTemplate       [] = { TWO_BYTES('U', 'N'), TWO_BYTES('S', 'I'), TWO_BYTES('G', 'N'), TWO_BYTES('E', 'D'), TWO_BYTES('T', 'E'), TWO_BYTES('M', 'P'), TWO_BYTES('L', 'A'), TWO_BYTES('T', 'E'), TWO_BYTES('\0', '\0') };
#define g_rgchTagUnsignedTemplate_LEN 16

const DRM_CHAR  g_rgchMSNDRootPubKeyB64         [] = { TWO_BYTES('p', 'j'), TWO_BYTES('o', 'e'), TWO_BYTES('W', 'L'), TWO_BYTES('S', 'T'), TWO_BYTES('L', 'D'), TWO_BYTES('o', 'n'), TWO_BYTES('Q', 'G'), TWO_BYTES('8', 'S'), 
                                                       TWO_BYTES('h', 'e'), TWO_BYTES('6', 'Q'), TWO_BYTES('h', 'k'), TWO_BYTES('Y', 'b'), TWO_BYTES('Y', 'o'), TWO_BYTES('t', 't'), TWO_BYTES('9', 'f'), TWO_BYTES('P', 'Z'), 
                                                       TWO_BYTES('8', 't'), TWO_BYTES('H', 'd'), TWO_BYTES('B', '1'), TWO_BYTES('2', '8'), TWO_BYTES('Z', 'E'), TWO_BYTES('T', 'c'), TWO_BYTES('g', 'h'), TWO_BYTES('n', '5'), 
                                                       TWO_BYTES('K', 'H'), TWO_BYTES('o', 'y'), TWO_BYTES('i', 'n'), TWO_BYTES('7', 'H'), TWO_BYTES('k', 'J'), TWO_BYTES('E', 'c'), TWO_BYTES('P', 'J'), TWO_BYTES('0', 'E'), 
                                                       TWO_BYTES('g', '4'), TWO_BYTES('U', 'd'), TWO_BYTES('S', 'v'), TWO_BYTES('a', '0'), TWO_BYTES('K', 'D'), TWO_BYTES('I', 'Y'), TWO_BYTES('D', 'j'), TWO_BYTES('A', '3'), 
                                                       TWO_BYTES('E', 'X'), TWO_BYTES('d', '6'), TWO_BYTES('9', 'R'), TWO_BYTES('3', 'C'), TWO_BYTES('N', '2'), TWO_BYTES('W', 'p'), TWO_BYTES('/', 'Q'), TWO_BYTES('y', 'O'), 
                                                       TWO_BYTES('o', '0'), TWO_BYTES('Z', 'P'), TWO_BYTES('Y', 'W'), TWO_BYTES('Y', 'p'), TWO_BYTES('3', 'N'), TWO_BYTES('X', 'p'), TWO_BYTES('J', '7'), TWO_BYTES('0', '0'), 
                                                       TWO_BYTES('t', 'K'), TWO_BYTES('P', 'g'), TWO_BYTES('I', 'p'), TWO_BYTES('l', 'z'), TWO_BYTES('o', '5'), TWO_BYTES('w', 'V'), TWO_BYTES('d', '/'), TWO_BYTES('6', '9'), 
                                                       TWO_BYTES('g', '7'), TWO_BYTES('j', '+'), TWO_BYTES('j', '8'), TWO_BYTES('M', '6'), TWO_BYTES('6', 'W'), TWO_BYTES('7', 'V'), TWO_BYTES('N', 'm'), TWO_BYTES('D', 'w'), 
                                                       TWO_BYTES('a', 'N'), TWO_BYTES('s', '9'), TWO_BYTES('m', 'D'), TWO_BYTES('c', '1'), TWO_BYTES('p', '2'), TWO_BYTES('+', 'V'), TWO_BYTES('V', 'M'), TWO_BYTES('s', 'D'), 
                                                       TWO_BYTES('h', 'O'), TWO_BYTES('s', 'V'), TWO_BYTES('/', 'A'), TWO_BYTES('u', '6'), TWO_BYTES('E', '+'), TWO_BYTES('E', '='), TWO_BYTES('\0', '\0') };
#define g_rgchMSNDRootPubKeyB64_LEN 172


/* Secure clock Challenge\response XML tags */
const DRM_WCHAR      g_rgwchTagDRMReqRoot                         [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchResponse                              [] =  { ONE_WCHAR('r', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchStatus                                [] =  { ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchFlag                                  [] =  { ONE_WCHAR('F', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagGmtTime                            [] =  { ONE_WCHAR('G', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagRefreshDate                        [] =  { ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};

/* Output Level strings */
const DRM_WCHAR      g_rgwchLabelGuid                             [] =  { ONE_WCHAR('g', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchLabelLevel                            [] =  { ONE_WCHAR('l', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagUncompressedDigitalVideo           [] =  { ONE_WCHAR('U', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagCompressedDigitalVideo             [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagUncompressedDigitalAudio           [] =  { ONE_WCHAR('U', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagCompressedDigitalAudio             [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagAnalogVideo                        [] =  { ONE_WCHAR('A', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagCopy                               [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagExtensionList                      [] =  { ONE_WCHAR('E', '\0'),  ONE_WCHAR('X', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagExtension                          [] =  { ONE_WCHAR('E', '\0'),  ONE_WCHAR('X', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagIncludeList                        [] =  { ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagInclude                            [] =  { ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagExcludeList                        [] =  { ONE_WCHAR('E', '\0'),  ONE_WCHAR('X', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagExclude                            [] =  { ONE_WCHAR('E', '\0'),  ONE_WCHAR('X', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchMSRootPubKey                          [] =  { ONE_WCHAR('0', '\0'),  ONE_WCHAR('X', '\0'),  ONE_WCHAR('W', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('w', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('C', '\0'),  
                                                                          ONE_WCHAR('H', '\0'),  ONE_WCHAR('W', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('w', '\0'),  ONE_WCHAR('3', '\0'),  ONE_WCHAR('w', '\0'),  ONE_WCHAR('T', '\0'),  
                                                                          ONE_WCHAR('1', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('q', '\0'),  ONE_WCHAR('j', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('4', '\0'),  
                                                                          ONE_WCHAR('6', '\0'),  ONE_WCHAR('Q', '\0'),  ONE_WCHAR('k', '\0'),  ONE_WCHAR('W', '\0'),  ONE_WCHAR('q', '\0'),  ONE_WCHAR('5', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('g', '\0'),  
                                                                          ONE_WCHAR('Z', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('q', '\0'),  ONE_WCHAR('w', '\0'),  ONE_WCHAR('*', '\0'),  ONE_WCHAR('J', '\0'),  ONE_WCHAR('N', '\0'),  
                                                                          ONE_WCHAR('Z', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('!', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('y', '\0'),  
                                                                          ONE_WCHAR('N', '\0'),  ONE_WCHAR('3', '\0'),  ONE_WCHAR('6', '\0'),  ONE_WCHAR('h', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('w', '\0'),  ONE_WCHAR('=', '\0'),  ONE_WCHAR('=', '\0'),  
                                                                          ONE_WCHAR('\0', '\0') };

/* License State strings */
const DRM_WCHAR      g_rgwchTagLicenseStateRequestRoot            [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagCanBind                            [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};

/*Device License Revocation Blob Strings*/

const DRM_WCHAR      g_rgwchTagDeviceLicenseRevocationRoot        [] =  { ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagRevocationPubKey                   [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_WCHAR      g_rgwchInitialExtensibleStateAttributeName   [] =  { ONE_WCHAR('I', '\0'), ONE_WCHAR('n', '\0'), ONE_WCHAR('i', '\0'), ONE_WCHAR('t', '\0'), ONE_WCHAR('i', '\0'), ONE_WCHAR('a', '\0'), ONE_WCHAR('l', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('x', '\0'), ONE_WCHAR('t', '\0'), ONE_WCHAR('R', '\0'), ONE_WCHAR('e', '\0'), ONE_WCHAR('s', '\0'), ONE_WCHAR('t', '\0'), ONE_WCHAR('S', '\0'), ONE_WCHAR('t', '\0'), ONE_WCHAR('a', '\0'), ONE_WCHAR('t', '\0'), ONE_WCHAR('e', '\0'), ONE_WCHAR('\0', '\0') };

/* Strings to be used from DRMManager */
const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_NONE                       = CREATE_DRM_STRING( g_rgwchWMDRM_RIGHT_NONE );
const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_PLAYBACK                   = CREATE_DRM_STRING( g_rgwchWMDRM_RIGHT_PLAYBACK );
const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_COLLABORATIVE_PLAY         = CREATE_DRM_STRING( g_rgwchWMDRM_RIGHT_COLLABORATIVE_PLAY );
const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_COPY_TO_CD                 = CREATE_DRM_STRING( g_rgwchWMDRM_RIGHT_COPY_TO_CD );
const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_COPY                       = CREATE_DRM_STRING( g_rgwchWMDRM_RIGHT_COPY );
const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_CREATE_THUMBNAIL_IMAGE     = CREATE_DRM_STRING( g_rgwchWMDRM_RIGHT_CREATE_THUMBNAIL_IMAGE );

#if DRM_SUPPORT_PMLICENSE
const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_COPY_TO_SDMI_DEVICE        = CREATE_DRM_STRING( g_rgwchWMDRM_RIGHT_COPY_TO_SDMI_DEVICE );
const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_COPY_TO_NON_SDMI_DEVICE    = CREATE_DRM_STRING( g_rgwchWMDRM_RIGHT_COPY_TO_NON_SDMI_DEVICE );
#endif

#if DRM_BACKUP_RESTORE_SUPPORT
const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_BACKUP                     = CREATE_DRM_STRING( g_rgwchWMDRM_RIGHT_BACKUP );
#endif

#if DRM_SUPPORT_PLAYLIST_BURN
const DRM_CONST_STRING      g_dstrPlaylistBurnCount                     = CREATE_DRM_STRING( g_rgwchPlaylistBurnCount );
const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_PLAYLIST_BURN             = CREATE_DRM_STRING( g_rgwchWMDRM_RIGHT_PLAYLIST_BURN );
#endif


/* String constants */
const DRM_ANSI_CONST_STRING g_adstrAttributeVersion                     = { g_rgchAttributeVersion,   7 }; /* Special case these odd length ANSI strings */
const DRM_ANSI_CONST_STRING g_dastrTagLicense                           = { g_rgchLicenseTag,         7 };
const DRM_ANSI_CONST_STRING g_adstrLicenseRespTag                       = { g_rgchLicenseRespTag,    15 };
const DRM_ANSI_CONST_STRING g_adstrAttributeEncrypted                   = { g_rgchAttributeEncrypted, 9 };
const DRM_ANSI_CONST_STRING g_dastrAttributeFALSE                       = { g_rgchAttributeFALSE,     5 };

const DRM_ANSI_CONST_STRING g_dastrTagSLK                               = { g_rgchTagSLK,     3 };
const DRM_ANSI_CONST_STRING g_dastrTagSLKID                             = { g_rgchTagSLKID,   5 };
const DRM_ANSI_CONST_STRING g_dastrTagSLKDATA                           = { g_rgchTagSLKDATA, 7 };

const DRM_CONST_STRING      g_dstrTagSLK                                = CREATE_DRM_STRING( g_rgwchTagSLK    );
const DRM_CONST_STRING      g_dstrTagSLKID                              = CREATE_DRM_STRING( g_rgwchTagSLKID  );
const DRM_CONST_STRING      g_dstrTagSLKDATA                            = CREATE_DRM_STRING( g_rgwchTagSLKDATA);

const DRM_CONST_STRING      g_dstrAttributeVersion                      = CREATE_DRM_STRING( g_rgwchAttributeVersion );
const DRM_CONST_STRING      g_dstrAttributeEncrypted                    = CREATE_DRM_STRING( g_rgwchAttributeEncrypted );
const DRM_CONST_STRING      g_dstrAttributeFALSE                        = CREATE_DRM_STRING( g_rgwchAttributeFALSE );
const DRM_CONST_STRING      g_dstrLicVerAttrValue                       = CREATE_DRM_STRING( g_rgwchLicVerAttrValue );
const DRM_CONST_STRING      g_dstrLicenseRespTag                        = CREATE_DRM_STRING( g_rgwchLicenseRespTag );
const DRM_CONST_STRING      g_dstrTagLicense                            = CREATE_DRM_STRING( g_rgwchLicenseTag );

/* Script varibles used for license properties. */
const DRM_CONST_STRING      g_dstrDRM_LS_BEGIN_ATTR                     = CREATE_DRM_STRING( g_rgwchDRM_LS_BEGIN_ATTR );
const DRM_CONST_STRING      g_dstrDRM_LS_COUNT_ATTR                     = CREATE_DRM_STRING( g_rgwchDRM_LS_COUNT_ATTR );

const DRM_CONST_STRING      g_dstrDRM_LS_BEGDATE_ATTR                   = CREATE_DRM_STRING( g_rgwchDRM_LS_BEGDATE_ATTR );
const DRM_CONST_STRING      g_dstrDRM_LS_ENDDATE_ATTR                   = CREATE_DRM_STRING( g_rgwchDRM_LS_ENDDATE_ATTR );
const DRM_CONST_STRING      g_dstrDRM_LS_FIRSTUSE_ATTR                  = CREATE_DRM_STRING( g_rgwchDRM_LS_FIRSTUSE_ATTR );
const DRM_CONST_STRING      g_dstrDRM_LS_FIRSTSTORE_ATTR                = CREATE_DRM_STRING( g_rgwchDRM_LS_FIRSTSTORE_ATTR );
const DRM_CONST_STRING      g_dstrDRM_LS_EXPIRATION_AFTER_FIRSTUSE_ATTR = CREATE_DRM_STRING( g_rgwchDRM_LS_EXPIRATION_AFTER_FIRSTUSE_ATTR );
const DRM_CONST_STRING      g_dstrDRM_LS_MINAPPSECLEVEL_ATTR            = CREATE_DRM_STRING( g_rgwchDRM_LS_MINAPPSECLEVEL_ATTR );
const DRM_CONST_STRING      g_dstrDRM_LS_APPSEC_ATTR                    = CREATE_DRM_STRING( g_rgwchDRM_LS_APPSEC_ATTR );
const DRM_CONST_STRING      g_dstrDRM_LS_SAP_ATTR                       = CREATE_DRM_STRING( g_rgwchDRM_LS_SAP_ATTR );
const DRM_CONST_STRING      g_dstrDRM_LS_BURNTOCDCOUNT_ATTR             = CREATE_DRM_STRING( g_rgwchDRM_LS_BURNTOCDCOUNT_ATTR );
const DRM_CONST_STRING      g_dstrDRM_LS_TRANSFERCOUNT_ATTR             = CREATE_DRM_STRING( g_rgwchDRM_LS_TRANSFERCOUNT_ATTR );
const DRM_CONST_STRING      g_dstrDRM_LS_PLAYCOUNT_ATTR                 = CREATE_DRM_STRING( g_rgwchDRM_LS_PLAYCOUNT_ATTR );
const DRM_CONST_STRING      g_dstrDRM_LS_COPYCOUNT_ATTR                 = CREATE_DRM_STRING( g_rgwchDRM_LS_COPYCOUNT_ATTR );
const DRM_CONST_STRING      g_dstrDRM_LS_BEGINBURNTOCDCOUNT_ATTR        = CREATE_DRM_STRING( g_rgwchDRM_LS_BEGINBURNTOCDCOUNT_ATTR );
const DRM_CONST_STRING      g_dstrDRM_LS_BEGINTRANSFERCOUNT_ATTR        = CREATE_DRM_STRING( g_rgwchDRM_LS_BEGINTRANSFERCOUNT_ATTR );
const DRM_CONST_STRING      g_dstrDRM_LS_BEGINPLAYCOUNT_ATTR            = CREATE_DRM_STRING( g_rgwchDRM_LS_BEGINPLAYCOUNT_ATTR );

const DRM_CONST_STRING      g_dstrDRM_LS_DELETED_ATTR                   = CREATE_DRM_STRING( g_rgwchDRM_LS_DELETED_ATTR );

#if DRM_SUPPORT_ANTIROLLBACK_CLOCK
const DRM_CONST_STRING      g_dstrDRM_LS_OLDSAVETIME_ATTR               = CREATE_DRM_STRING( g_rgwchDRM_LS_OLDSAVETIME_ATTR );
const DRM_CONST_STRING      g_dstrDRM_LS_MACHINE_DATETIME               = CREATE_DRM_STRING( g_rgwchDRM_LS_MACHINE_DATETIME );
#endif

const DRM_CONST_STRING      g_dstrDRM_LS_MACHINE_DATETIME_GE            = CREATE_DRM_STRING( g_rgwchDRM_LS_MACHINE_DATETIME_GE );
const DRM_CONST_STRING      g_dstrDRM_LS_MACHINE_DATETIME_LE            = CREATE_DRM_STRING( g_rgwchDRM_LS_MACHINE_DATETIME_LE );
const DRM_CONST_STRING      g_dstrDRM_LS_APP_MINSECLEVEL_GE             = CREATE_DRM_STRING( g_rgwchDRM_LS_APP_MINSECLEVEL_GE );
const DRM_CONST_STRING      g_dstrEqual                                 = CREATE_DRM_STRING( g_rgwchEqual );

const DRM_CONST_STRING      g_dstrDrmRestoreInfo                        = CREATE_DRM_STRING( g_rgwchDrmRestoreInfo );
const DRM_CONST_STRING      g_dstrTagData                               = CREATE_DRM_STRING( g_rgwchTagData );
const DRM_CONST_STRING      g_dstrTagDataInclusionList                  = CREATE_DRM_STRING( g_rgwchTagDataInclusionList );
const DRM_CONST_STRING      g_dstrTagLID                                = CREATE_DRM_STRING( g_rgwchTagLID );

const DRM_CONST_STRING      g_dstrTagIndex                              = CREATE_DRM_STRING( g_rgwchTagIndex );
const DRM_CONST_STRING      g_dstrTagEnablingbits                       = CREATE_DRM_STRING( g_rgwchTagEnablingbits );
const DRM_CONST_STRING      g_dstrTagSymValue                           = CREATE_DRM_STRING( g_rgwchTagSymValue );
const DRM_CONST_STRING      g_dstrTagSymSig                             = CREATE_DRM_STRING( g_rgwchTagSymSig );
const DRM_CONST_STRING      g_dstrTagHashAlgorithm                      = CREATE_DRM_STRING( g_rgwchTagHashAlgorithm );
const DRM_CONST_STRING      g_dstrTagPubkey                             = CREATE_DRM_STRING( g_rgwchTagPubkey );
const DRM_CONST_STRING      g_dstrTagValue                              = CREATE_DRM_STRING( g_rgwchTagValue );
const DRM_CONST_STRING      g_dstrTagSignature                          = CREATE_DRM_STRING( g_rgwchTagSignature );
const DRM_CONST_STRING      g_dstrTagHashAlg                            = CREATE_DRM_STRING( g_rgwchTagHashAlg );
const DRM_CONST_STRING      g_dstrTagSignAlg                            = CREATE_DRM_STRING( g_rgwchTagSignAlg );
const DRM_CONST_STRING      g_dstrSHA                                   = CREATE_DRM_STRING( g_rgwchSHA );
const DRM_CONST_STRING      g_dstrMSDRM                                 = CREATE_DRM_STRING( g_rgwchMSDRM );
const DRM_CONST_STRING      g_dstrMSDRM_CK                              = CREATE_DRM_STRING( g_rgwchMSDRM_CK );
const DRM_ANSI_CONST_STRING g_dastrAttributeType                        = { g_rgchAttributeType, 4 };
const DRM_CONST_STRING      g_dstrAttributeType                         = CREATE_DRM_STRING( g_rgwchAttributeType );
const DRM_CONST_STRING      g_dstrSavedDateTime                         = CREATE_DRM_STRING( g_rgwchSavedDateTime );

const DRM_CONST_STRING      g_dstrTagOEMPrivateKeys                     = CREATE_DRM_STRING( g_rgwchTagOEMPrivateKeys );
const DRM_CONST_STRING      g_dstrTagKeyValue                           = CREATE_DRM_STRING( g_rgwchTagKeyValue );
const DRM_CONST_STRING      g_dstrTagRSAKeyValue                        = CREATE_DRM_STRING( g_rgwchTagRSAKeyValue );
const DRM_CONST_STRING      g_dstrTagModulus                            = CREATE_DRM_STRING( g_rgwchTagModulus );
const DRM_CONST_STRING      g_dstrTagExponent                           = CREATE_DRM_STRING( g_rgwchTagExponent );
const DRM_CONST_STRING      g_dstrTagPrime0                             = CREATE_DRM_STRING( g_rgwchTagPrime0 );
const DRM_CONST_STRING      g_dstrTagPrime1                             = CREATE_DRM_STRING( g_rgwchTagPrime1 );
const DRM_CONST_STRING      g_dstrTagCRTExponent0                       = CREATE_DRM_STRING( g_rgwchTagCRTExponent0 );
const DRM_CONST_STRING      g_dstrTagCRTExponent1                       = CREATE_DRM_STRING( g_rgwchTagCRTExponent1 );
const DRM_CONST_STRING      g_dstrTagIQMP                               = CREATE_DRM_STRING( g_rgwchTagIQMP );
const DRM_CONST_STRING      g_dstrTagPRIVKEY                            = CREATE_DRM_STRING( g_rgwchTagPRIVKEY );
const DRM_CONST_STRING      g_dstrXPathPrime0                           = CREATE_DRM_STRING( g_rgwchXPathPrime0 );
const DRM_CONST_STRING      g_dstrXPathPrime1                           = CREATE_DRM_STRING( g_rgwchXPathPrime1 );
const DRM_CONST_STRING      g_dstrXPathCRTExponent0                     = CREATE_DRM_STRING( g_rgwchXPathCRTExponent0 );
const DRM_CONST_STRING      g_dstrXPathCRTExponent1                     = CREATE_DRM_STRING( g_rgwchXPathCRTExponent1 );
const DRM_CONST_STRING      g_dstrXPathIQMP                             = CREATE_DRM_STRING( g_rgwchXPathIQMP );
const DRM_CONST_STRING      g_dstrWMDRMCertExponent                     = CREATE_DRM_STRING( g_rgwchWMDRMCertExponent );

#if DRM_SUPPORT_ANTIROLLBACK_CLOCK
const DRM_CONST_STRING      g_dstrCheckClockRollback                    = CREATE_DRM_STRING( g_rgwchCheckClockRollback );
const DRM_CONST_STRING      g_dstrResetRollbackedClock                  = CREATE_DRM_STRING( g_rgwchResetRollbackedClock );
#endif

const DRM_CONST_STRING      g_dstrSetSavedDateTime                      = CREATE_DRM_STRING( g_rgwchSetSavedDateTime );
const DRM_CONST_STRING      g_dstrCreatePMLicense                       = CREATE_DRM_STRING( g_rgwchCreatePMLicense );
const DRM_CONST_STRING      g_dstrVersion_1_0                           = CREATE_DRM_STRING( g_rgwchVersion_1_0 );
const DRM_CONST_STRING      g_dstrTagDevinfo                            = CREATE_DRM_STRING( g_rgwchTagDevinfo );
const DRM_CONST_STRING      g_dstrTagFallback                           = CREATE_DRM_STRING( g_rgwchTagFallback );
const DRM_CONST_STRING      g_dstrTagError                              = CREATE_DRM_STRING( g_rgwchTagError );
const DRM_CONST_STRING      g_dstrXPathSigValue                         = CREATE_DRM_STRING( g_rgwchXPathSigValue );
const DRM_CONST_STRING      g_dstrCompatCert                            = CREATE_DRM_STRING( g_rgwchCompatCert );
const DRM_CONST_STRING      g_dstrCompatSecVersion                      = CREATE_DRM_STRING( g_rgwchCompatSecVersion );
const DRM_CONST_STRING      g_dstrSubjectId                             = CREATE_DRM_STRING( g_rgwchSubjectId );
const DRM_CONST_STRING      g_dstrMaxSecLevel                           = CREATE_DRM_STRING( g_rgwchMaxSecLevel );
const DRM_CONST_STRING      g_dstrAuthSecVer                            = CREATE_DRM_STRING( g_rgwchAuthSecVer );
const DRM_CONST_STRING      g_dstrAuthPubKey                            = CREATE_DRM_STRING( g_rgwchAuthPubKey );
const DRM_CONST_STRING      g_dstrXPathTagSignature                     = CREATE_DRM_STRING( g_rgwchXPathTagSignature );
const DRM_CONST_STRING      g_dstrTagSignatureVal                       = CREATE_DRM_STRING( g_rgwchTagSignatureVal );
const DRM_CONST_STRING      g_dstrXPathTagCertificateChain              = CREATE_DRM_STRING( g_rgwchXPathTagCertificateChain );
const DRM_CONST_STRING      g_dstrAuthData                              = CREATE_DRM_STRING( g_rgwchAuthData );
const DRM_CONST_STRING      g_dstrAuthHashAlg                           = CREATE_DRM_STRING( g_rgwchAuthHashAlg );
const DRM_CONST_STRING      g_dstrAuthSignAlg                           = CREATE_DRM_STRING( g_rgwchAuthSignAlg );
const DRM_CONST_STRING      g_dstrFallback                              = CREATE_DRM_STRING( g_rgwchFallback );


const DRM_CONST_STRING      g_dstrXPathTagSecurityLevel                 = CREATE_DRM_STRING( g_rgwchXPathTagSecurityLevel );

const DRM_CONST_STRING      g_dstrXPathTagCertificate                   = CREATE_DRM_STRING( g_rgwchXPathTagCertificate );
const DRM_CONST_STRING      g_dstrXPathDataUniqueID                     = CREATE_DRM_STRING( g_rgwchXPathDataUniqueID );

const DRM_CONST_STRING      g_dstrXPathManufacturer                     = CREATE_DRM_STRING( g_rgwchXPathManufacturer );
const DRM_CONST_STRING      g_dstrXPathMake                             = CREATE_DRM_STRING( g_rgwchXPathMake );
const DRM_CONST_STRING      g_dstrXPathModel                            = CREATE_DRM_STRING( g_rgwchXPathModel );
const DRM_CONST_STRING      g_dstrXPathDistributor                      = CREATE_DRM_STRING( g_rgwchXPathDistributor );
const DRM_CONST_STRING      g_dstrXPathHardwareMajor                    = CREATE_DRM_STRING( g_rgwchXPathHardwareMajor );
const DRM_CONST_STRING      g_dstrXPathHardwareMinor                    = CREATE_DRM_STRING( g_rgwchXPathHardwareMinor );
const DRM_CONST_STRING      g_dstrXPathFirmwareMajor                    = CREATE_DRM_STRING( g_rgwchXPathFirmwareMajor );
const DRM_CONST_STRING      g_dstrXPathFirmwareMinor                    = CREATE_DRM_STRING( g_rgwchXPathFirmwareMinor );
const DRM_CONST_STRING      g_dstrXPathFeatureTemplate                  = CREATE_DRM_STRING( g_rgwchXPathFeatureTemplate );
const DRM_CONST_STRING      g_dstrXPathClientOldKeys                    = CREATE_DRM_STRING( g_rgwchXPathClientOldKeys );
const DRM_CONST_STRING      g_dstrXPathClientEscrowKeys                 = CREATE_DRM_STRING( g_rgwchXPathClientEscrowKeys );
const DRM_CONST_STRING      g_dstrXPathClientEscrowKey                  = CREATE_DRM_STRING( g_rgwchXPathClientEscrowKey );
const DRM_CONST_STRING      g_dstrXPathIndivServerEscrowKey             = CREATE_DRM_STRING( g_rgwchXPathIndivServerEscrowKey );
const DRM_CONST_STRING      g_dstrXPathDevicePublicKey                  = CREATE_DRM_STRING( g_rgwchXPathDevicePublicKey );
const DRM_CONST_STRING      g_dstrXPathOldKeysData                      = CREATE_DRM_STRING( g_rgwchXPathOldKeysData );
const DRM_CONST_STRING      g_dstrXPathIndivSvrPubKey                   = CREATE_DRM_STRING( g_rgwchXPathIndivSvrPubKey );
const DRM_CONST_STRING      g_dstrXPathSecureClock                      = CREATE_DRM_STRING( g_rgwchXPathSecureClock );
const DRM_CONST_STRING      g_dstrXPathIndivType                        = CREATE_DRM_STRING( g_rgwchXPathIndivType );
const DRM_CONST_STRING      g_dstrXPathSecureStore                      = CREATE_DRM_STRING( g_rgwchXPathSecureStore );
const DRM_CONST_STRING      g_dstrXPathMetering                         = CREATE_DRM_STRING( g_rgwchXPathMetering );
const DRM_CONST_STRING      g_dstrXPathLicenseChain                     = CREATE_DRM_STRING( g_rgwchXPathLicenseChain );


const DRM_CONST_STRING      g_dstrTagDevCert                            = CREATE_DRM_STRING( g_rgwchTagDevCert );
const DRM_CONST_STRING      g_dstrTagWrmHeader                          = CREATE_DRM_STRING( g_rgwchTagWrmHeader );
const DRM_CONST_STRING      g_dstrAttributeHeaderXmlnsName              = CREATE_DRM_STRING( g_rgwchAttributeHeaderXmlnsName );
const DRM_CONST_STRING      g_dstrAttributeHeaderXmlnsValue             = CREATE_DRM_STRING( g_rgwchAttributeHeaderXmlnsValue );
const DRM_CONST_STRING      g_dstrAttributeVersion2Value                = CREATE_DRM_STRING( g_rgwchAttributeVersion2Value );
const DRM_CONST_STRING      g_dstrAttributeVersion4Value                = CREATE_DRM_STRING( g_rgwchAttributeVersion4Value );
const DRM_CONST_STRING      g_dstrTagLAINFO                             = CREATE_DRM_STRING( g_rgwchTagLAINFO );
const DRM_CONST_STRING      g_dstrTagV4DATA                             = CREATE_DRM_STRING( g_rgwchTagV4DATA );
const DRM_CONST_STRING      g_dstrTagLAURL                              = CREATE_DRM_STRING( g_rgwchTagLAURL );
const DRM_CONST_STRING      g_dstrTagLUIURL                             = CREATE_DRM_STRING( g_rgwchTagLUIURL );
const DRM_CONST_STRING      g_dstrTagDSID                               = CREATE_DRM_STRING( g_rgwchTagDSID );
const DRM_CONST_STRING      g_dstrTagKID                                = CREATE_DRM_STRING( g_rgwchTagKID );
const DRM_CONST_STRING      g_dstrTagOEMData                            = CREATE_DRM_STRING( g_rgwchTagOEMData );
const DRM_CONST_STRING      g_dstrTagContentID                          = CREATE_DRM_STRING( g_rgwchTagContentID );
const DRM_CONST_STRING      g_dstrTagChecksum                           = CREATE_DRM_STRING( g_rgwchTagChecksum );
const DRM_CONST_STRING      g_dstrXPathHeaderUplinks                    = CREATE_DRM_STRING( g_rgwchXPathHeaderUplinks );
const DRM_CONST_STRING      g_dstrTagUplink                             = CREATE_DRM_STRING( g_rgwchTagUplink );
const DRM_CONST_STRING      g_dstrTagUplinks                            = CREATE_DRM_STRING( g_rgwchTagUplinks );

const DRM_CONST_STRING      g_dstrTagLicenseRequest                     = CREATE_DRM_STRING( g_rgwchTagLicenseRequest );
const DRM_CONST_STRING      g_dstrTagAction                             = CREATE_DRM_STRING( g_rgwchTagAction );

const DRM_CONST_STRING      g_dstrTagV1Challenge                        = CREATE_DRM_STRING( g_rgwchTagV1Challenge );
const DRM_CONST_STRING      g_dstrDefaultV1Data                         = CREATE_DRM_STRING( g_rgwchDefaultV1Data );
const DRM_CONST_STRING      g_dstrTagActionList                         = CREATE_DRM_STRING( g_rgwchTagActionList );
const DRM_CONST_STRING      g_dstrTagSecurityVersion                    = CREATE_DRM_STRING( g_rgwchTagSecurityVersion );


/*
**  Devcert Non-indiv Tags
*/
const DRM_CONST_STRING      g_dstrTagDNIUniqueID                        = CREATE_DRM_STRING( g_rgwchTagDNIUniqueID );
const DRM_CONST_STRING      g_dstrTagMSDRMSignature                     = CREATE_DRM_STRING( g_rgwchTagMSDRMSignature );
const DRM_CONST_STRING      g_dstrPrivateKeys                           = CREATE_DRM_STRING( g_rgwchPrivateKeys );
const DRM_CONST_STRING      g_dstrCertTypeDevice                        = CREATE_DRM_STRING( g_rgwchCertTypeDevice );
const DRM_CONST_STRING      g_dstrCerttypeGroup                         = CREATE_DRM_STRING( g_rgwchCerttypeGroup );
const DRM_CONST_STRING      g_dstrCerttypeAuth                          = CREATE_DRM_STRING( g_rgwchCerttypeAuth );
const DRM_CONST_STRING      g_dstrCerttypeAuthRoot                      = CREATE_DRM_STRING( g_rgwchCerttypeAuthRoot );

/*
**  Devcert Non-indiv XPaths
*/
const DRM_CONST_STRING      g_dstrXPathPubkeyData                       = CREATE_DRM_STRING( g_rgwchXPathPubkeyData );
const DRM_CONST_STRING      g_dstrXPathGCSecureClock                    = CREATE_DRM_STRING( g_rgwchXPathGCSecureClock );
const DRM_CONST_STRING      g_dstrXPathGCSecureClockURL                 = CREATE_DRM_STRING( g_rgwchXPathGCSecureClockURL );
const DRM_CONST_STRING      g_dstrXPathGCSecureClockPubKey              = CREATE_DRM_STRING( g_rgwchXPathGCSecureClockPubKey );
const DRM_CONST_STRING      g_dstrXPathGCMetering                       = CREATE_DRM_STRING( g_rgwchXPathGCMetering );
const DRM_CONST_STRING      g_dstrXPathGCLicenseAcquisitionMode         = CREATE_DRM_STRING( g_rgwchXPathGCLicenseAcquisitionMode );
const DRM_CONST_STRING      g_dstrXPathGCLicenseSyncMode                = CREATE_DRM_STRING( g_rgwchXPathGCLicenseSyncMode );
const DRM_CONST_STRING      g_dstrXPathGCSymmOptsMode                   = CREATE_DRM_STRING( g_rgwchXPathGCSymmOpts );
const DRM_CONST_STRING      g_dstrXPathGCEncryption                     = CREATE_DRM_STRING( g_rgwchXPathGCEncryption );
const DRM_CONST_STRING      g_dstrXPathGCSupportRevocation              = CREATE_DRM_STRING( g_rgwchXPathGCSupportRevocation );
const DRM_CONST_STRING      g_dstrXPathGCMaxChainDepth                  = CREATE_DRM_STRING( g_rgwchXPathGCMaxChainDepth );
const DRM_CONST_STRING      g_dstrXPathGCMaxLicenseSize                 = CREATE_DRM_STRING( g_rgwchXPathGCMaxLicenseSize );
const DRM_CONST_STRING      g_dstrXPathGCMaxHeaderSize                  = CREATE_DRM_STRING( g_rgwchXPathGCMaxHeaderSize );
const DRM_CONST_STRING      g_dstrXPathDeviceKeydata                    = CREATE_DRM_STRING( g_rgwchXPathDeviceKeydata );
const DRM_CONST_STRING      g_dstrXPathDACAuthID                        = CREATE_DRM_STRING( g_rgwchXPathDACAuthID );
const DRM_CONST_STRING      g_dstrXPathGCSupportCRL                     = CREATE_DRM_STRING( g_rgwchXPathGCSupportCRL );

const DRM_CONST_STRING      g_dstrReqTagClientInfo                      = CREATE_DRM_STRING( g_rgwchReqTagClientInfo );
const DRM_CONST_STRING      g_dstrReqTagClientID                        = CREATE_DRM_STRING( g_rgwchReqTagClientID );
const DRM_CONST_STRING      g_dstrReqTagClientVersion                   = CREATE_DRM_STRING( g_rgwchReqTagClientVersion );
const DRM_CONST_STRING      g_dstrReqTagAppSecurity                     = CREATE_DRM_STRING( g_rgwchReqTagAppSecurity );
const DRM_CONST_STRING      g_dstrReqTagSubjectID1                      = CREATE_DRM_STRING( g_rgwchReqTagSubjectID1 );
const DRM_CONST_STRING      g_dstrReqTagSubjectID2                      = CREATE_DRM_STRING( g_rgwchReqTagSubjectID2 );
const DRM_CONST_STRING      g_dstrReqTagDrmkVersion                     = CREATE_DRM_STRING( g_rgwchReqTagDrmkVersion );
const DRM_CONST_STRING      g_dstrReqTagSubjectID2Data                  = CREATE_DRM_STRING( g_rgwchReqTagSubjectID2Data );
const DRM_CONST_STRING      g_dstrReqTagDrmkData                        = CREATE_DRM_STRING( g_rgwchReqTagDrmkData );
const DRM_CONST_STRING      g_dstrReqTagRevInfo                         = CREATE_DRM_STRING( g_rgwchReqTagRevInfo );

/* Xml tags used in parsing licenses */
const DRM_CONST_STRING      g_dstrLicense                               = CREATE_DRM_STRING( g_rgwchLicense );
const DRM_CONST_STRING      g_dstrGUID                                  = CREATE_DRM_STRING( g_rgwchGUID );
const DRM_CONST_STRING      g_dstrLicensorInfoNode                      = CREATE_DRM_STRING( g_rgwchLicensorInfoNode );
const DRM_CONST_STRING      g_dstrLIData                                = CREATE_DRM_STRING( g_rgwchLIData );
const DRM_CONST_STRING      g_dstrMeta                                  = CREATE_DRM_STRING( g_rgwchMeta );

const DRM_ANSI_CONST_STRING g_dastrTagRevocation                        = { g_rgchTagRevocation, 10 };
const DRM_CONST_STRING      g_dstrTagRevocation                         = CREATE_DRM_STRING( g_rgwchTagRevocation );
const DRM_ANSI_CONST_STRING g_dastrAppRevocation                        = { g_rgchAppRevocation, 17 };
const DRM_CONST_STRING      g_dstrAppRevocation                         = CREATE_DRM_STRING( g_rgwchAppRevocation );
const DRM_CONST_STRING      g_dstrDeviceRevocation                      = CREATE_DRM_STRING( g_rgwchDeviceRevocation );
const DRM_ANSI_CONST_STRING g_dastrTagRevocationInfo                    = { g_rgchTagRevocationInfo, 14 };
const DRM_CONST_STRING      g_dstrTagRevocationInfo                     = CREATE_DRM_STRING( g_rgwchTagRevocationInfo );
const DRM_ANSI_CONST_STRING g_dastrDeviceRevocation                     = { g_rgchDeviceRevocation, 20 };
const DRM_CONST_STRING      g_dstrDeviceRevocationList                  = CREATE_DRM_STRING( g_rgwchDeviceRevocationList );
const DRM_CONST_STRING      g_dstrWMDRMNET_Revocation                   = CREATE_DRM_STRING( g_rgwchWMDRMNET_Revocation );
const DRM_ANSI_CONST_STRING g_dastrWMDRMNET_Revocation                  = { g_rgchWMDRMNET_Revocation, 8};
const DRM_CONST_STRING      g_dstrTagRevInfoVersion                     = CREATE_DRM_STRING( g_rgwchTagRevInfoVersion );
const DRM_ANSI_CONST_STRING g_dastrTagRevInfoVersion                    = { g_rgchTagRevInfoVersion, 14 };
const DRM_CONST_STRING      g_dstrTagSourceID                           = CREATE_DRM_STRING( g_rgwchTagSourceID );
const DRM_ANSI_CONST_STRING g_dastrTagSourceID                          = { g_rgchTagSourceID, 8 };

const DRM_CONST_STRING      g_dstrDeviceRevocationLicenseTag            = CREATE_DRM_STRING( g_rgwchDeviceRevocationLicenseTag );
const DRM_CONST_STRING      g_dstrWMDRMNETRevocationLicenseTag          = CREATE_DRM_STRING( g_rgwchWMDRMNETRevocationLicenseTag );

#if DRM_SUPPORT_REVOCATION

#if DRM_SUPPORT_WMDRMNET
const DRM_CONST_STRING      g_dstrRevocationGuidWMDRMNET                = CREATE_DRM_STRING( g_rgwchRevocationGuidWMDRMNET );
const DRM_ANSI_CONST_STRING g_dastrRevocationGuidWMDRMNET               = { g_rgchRevocationGuidWMDRMNET, 38 };
#endif /* DRM_SUPPORT_WMDRMNET */

#if DRM_SUPPORT_DEVICE_REVOCATION
const DRM_CONST_STRING      g_dstrRevocationGuidDevice                  = CREATE_DRM_STRING( g_rgwchRevocationGuidDevice   );
const DRM_ANSI_CONST_STRING g_dastrRevocationGuidDevice                 = { g_rgchRevocationGuidDevice  , 38 };
#endif /* DRM_SUPPORT_DEVICE_REVOCATION */

#if DRM_SUPPORT_APP_REVOCATION
const DRM_CONST_STRING      g_dstrRevocationGuidApp                     = CREATE_DRM_STRING( g_rgwchRevocationGuidApp      );
const DRM_ANSI_CONST_STRING g_dastrRevocationGuidApp                    = { g_rgchRevocationGuidApp     , 38 };
#endif /* DRM_SUPPORT_APP_REVOCATION */

#endif /*DRM_SUPPORT_REVOCATION */

const DRM_CONST_STRING      g_dstrPriority                              = CREATE_DRM_STRING( g_rgwchPriority );
const DRM_CONST_STRING      g_dstrIssueDate                             = CREATE_DRM_STRING( g_rgwchIssueDate );
const DRM_CONST_STRING      g_dstrContentPubKey                         = CREATE_DRM_STRING( g_rgwchContentPubKey );
const DRM_CONST_STRING      g_dstrContentRevocation                     = CREATE_DRM_STRING( g_rgwchContentRevocation );
const DRM_CONST_STRING      g_dstrCondition                             = CREATE_DRM_STRING( g_rgwchCondition );
const DRM_CONST_STRING      g_dstrAction                                = CREATE_DRM_STRING( g_rgwchAction );
const DRM_CONST_STRING      g_dstrRestrictions                          = CREATE_DRM_STRING( g_rgwchRestrictions );
const DRM_CONST_STRING      g_dstrChainedEnablingBits                   = CREATE_DRM_STRING( g_rgwchChainedEnablingBits );
const DRM_CONST_STRING      g_dstrDrmRestoreInfoEnablingBits            = CREATE_DRM_STRING( g_rgwchDrmRestoreInfoEnablingBits );
const DRM_CONST_STRING      g_dstrCertChain                             = CREATE_DRM_STRING( g_rgwchCertChain );
const DRM_CONST_STRING      g_dstrTagCertificate                        = CREATE_DRM_STRING( g_rgwchTagCertificate );
const DRM_CONST_STRING      g_dstrLISigHashAlgo                         = CREATE_DRM_STRING( g_rgwchLISigHashAlgo );
const DRM_CONST_STRING      g_dstrLISigAlgo                             = CREATE_DRM_STRING( g_rgwchLISigAlgo );
const DRM_CONST_STRING      g_dstrLISigValue                            = CREATE_DRM_STRING( g_rgwchLISigValue );
const DRM_CONST_STRING      g_dstrOnActionPath                          = CREATE_DRM_STRING( g_rgwchOnActionPath );
const DRM_CONST_STRING      g_dstrXPathSymSig                           = CREATE_DRM_STRING( g_rgwchXPathSymSig );
const DRM_CONST_STRING      g_dstrXPathSymValue                         = CREATE_DRM_STRING( g_rgwchXPathSymValue );

const DRM_CONST_STRING      g_dstrSequenceNumber                        = CREATE_DRM_STRING( g_rgwchSequenceNumber );
const DRM_CONST_STRING      g_dstrLSPubKey                              = CREATE_DRM_STRING( g_rgwchLSPubKey );
const DRM_CONST_STRING      g_dstrUplinkKid                             = CREATE_DRM_STRING( g_rgwchUplinkKid );
const DRM_CONST_STRING      g_dstrChainedCheckSum                       = CREATE_DRM_STRING( g_rgwchChainedCheckSum );
const DRM_CONST_STRING      g_dstrPMLicenseVersionString                = CREATE_DRM_STRING( g_rgwchPMLicenseVersionString );
const DRM_ANSI_CONST_STRING g_dastrPMLicenseVersionString               = { g_rgchPMLicenseVersionString, 7 }; /* Special case this odd length ANSI string */
const DRM_ANSI_CONST_STRING g_dastrXMRLicenseVersionString              = { g_rgchXMRLicenseVersionString, 7 }; /* Special case this odd length ANSI string */
const DRM_CONST_STRING      g_dstrRevAttribute                          = CREATE_DRM_STRING( g_rgwchRevAttribute );
const DRM_CONST_STRING      g_dstrDerivedLicTemplate                    = CREATE_DRM_STRING( g_rgwchDerivedLicTemplate );
const DRM_CONST_STRING      g_dstrLicDataDerivedTmpl                    = CREATE_DRM_STRING( g_rgwchLicDataDerivedTmpl );
const DRM_CONST_STRING      g_dstrSourceID                              = CREATE_DRM_STRING( g_rgwchSourceID );
const DRM_CONST_STRING      g_dstrInclusionList                         = CREATE_DRM_STRING( g_rgwchInclusionList );

/* XML tags used in writing Challenge and parsing Response for metering */
const DRM_CONST_STRING      g_dstrTagMetering                           = CREATE_DRM_STRING( g_rgwchTagMetering );
const DRM_CONST_STRING      g_dstrTagHash                               = CREATE_DRM_STRING( g_rgwchTagHash );
const DRM_CONST_STRING      g_dstrXPathMID                              = CREATE_DRM_STRING( g_rgwchXPathMID );                      
const DRM_CONST_STRING      g_dstrTagMID                                = CREATE_DRM_STRING( g_rgwchTagMID );                      
const DRM_CONST_STRING      g_dstrTagTID                                = CREATE_DRM_STRING( g_rgwchTagTID );
const DRM_CONST_STRING      g_dstrTagCmd                                = CREATE_DRM_STRING( g_rgwchTagCmd );
const DRM_CONST_STRING      g_dstrTagPassword                           = CREATE_DRM_STRING( g_rgwchTagPassword );
const DRM_CONST_STRING      g_dstrTagRecords                            = CREATE_DRM_STRING( g_rgwchTagRecords );
const DRM_CONST_STRING      g_dstrTagURL                                = CREATE_DRM_STRING( g_rgwchTagURL );
const DRM_CONST_STRING      g_dstrTagPartialData                        = CREATE_DRM_STRING( g_rgwchTagPartialData );
const DRM_CONST_STRING      g_dstrLabelValue                            = CREATE_DRM_STRING( g_rgwchLabelValue );
const DRM_CONST_STRING      g_dstrHMAC                                  = CREATE_DRM_STRING( g_rgwchHMAC );
const DRM_CONST_STRING      g_dstrChallenge                             = CREATE_DRM_STRING( g_rgwchChallenge );
const DRM_CONST_STRING      g_dstr1                                     = CREATE_DRM_STRING( g_rgwch1 );
const DRM_CONST_STRING      g_dstrReset                                 = CREATE_DRM_STRING( g_rgwchReset );

const DRM_ANSI_CONST_STRING g_dastrTagMeterCert                         = { g_rgchTagMeterCert, 9 };

const DRM_CONST_STRING      g_dstrTagMeterCert                          = CREATE_DRM_STRING( g_rgwchTagMeterCert );

const DRM_CONST_STRING      g_dstrTagCertificateChain                   = CREATE_DRM_STRING( g_rgwchTagCertificateChain );

/* tags used for sync lists */
const DRM_CONST_STRING      g_dstrTagPrivateKey                         = CREATE_DRM_STRING( g_rgwchTagPrivateKey );
const DRM_CONST_STRING      g_dstrTagDevice                             = CREATE_DRM_STRING( g_rgwchTagDevice );
const DRM_CONST_STRING      g_dstrKeyDataTag                            = CREATE_DRM_STRING( g_rgwchKeyDataTag );
const DRM_CONST_STRING      g_dstrGroupTag                              = CREATE_DRM_STRING( g_rgwchGroupTag );

const DRM_CONST_STRING      g_dstrTagSyncList                           = CREATE_DRM_STRING( g_rgwchTagSyncList );
                                                                                                          
const DRM_CONST_STRING      g_dstrBackup                                = CREATE_DRM_STRING( g_rgwchBackup );
const DRM_CONST_STRING      g_dstrRestore                               = CREATE_DRM_STRING( g_rgwchRestore );
const DRM_CONST_STRING      g_dstrRootSigValueVersionTag                = CREATE_DRM_STRING( g_rgwchRootSigValueVersionTag );
const DRM_CONST_STRING      g_dstrRootSigValueVersionVal                = CREATE_DRM_STRING( g_rgwchRootSigValueVersionVal );
const DRM_CONST_STRING      g_dstrPFRootTag                             = CREATE_DRM_STRING( g_rgwchPFRootTag );
const DRM_CONST_STRING      g_dstrDACPubKeyTag                          = CREATE_DRM_STRING( g_rgwchDACPubKeyTag );
const DRM_CONST_STRING      g_dstrAuthRoot                              = CREATE_DRM_STRING( g_rgwchAuthRoot );
const DRM_CONST_STRING      g_dstrTagNameValue                          = CREATE_DRM_STRING( g_rgwchTagSecurityLevel );
const DRM_CONST_STRING      g_dstrTagSecurityLevel                      = CREATE_DRM_STRING( g_rgwchTagSecurityLevel );
const DRM_CONST_STRING      g_dstrTagDataId                             = CREATE_DRM_STRING( g_rgwchTagDataId );
const DRM_CONST_STRING      g_dstrTagDataPubKey                         = CREATE_DRM_STRING( g_rgwchTagDataPubKey );
const DRM_CONST_STRING      g_dstrFallBack                              = CREATE_DRM_STRING( g_rgwchFallBack );
const DRM_CONST_STRING      g_dstrTagName                               = CREATE_DRM_STRING( g_rgwchTagName );
const DRM_CONST_STRING      g_dstrManufacturer                          = CREATE_DRM_STRING( g_rgwchManufacturer );
const DRM_CONST_STRING      g_dstrModel                                 = CREATE_DRM_STRING( g_rgwchModel );
const DRM_CONST_STRING      g_dstrHwMajor                               = CREATE_DRM_STRING( g_rgwchHwMajor );
const DRM_CONST_STRING      g_dstrHwMinor                               = CREATE_DRM_STRING( g_rgwchHwMinor );
const DRM_CONST_STRING      g_dstrFwMajor                               = CREATE_DRM_STRING( g_rgwchFwMajor );
const DRM_CONST_STRING      g_dstrFwMinor                               = CREATE_DRM_STRING( g_rgwchFwMinor );
const DRM_CONST_STRING      g_dstrFeatures                              = CREATE_DRM_STRING( g_rgwchFeatures );
const DRM_CONST_STRING      g_dstrSecureClockNotSet                     = CREATE_DRM_STRING( g_rgwchSecClockNotSet );
const DRM_CONST_STRING      g_dstrSecureClockSet                        = CREATE_DRM_STRING( g_rgwchSecClockSet );
const DRM_CONST_STRING      g_dstrSecureClockNeedsRefresh               = CREATE_DRM_STRING( g_rgwchSecClockNeedsRefresh );
const DRM_CONST_STRING      g_dstrTemplate                              = CREATE_DRM_STRING( g_rgwchTemplate );
const DRM_CONST_STRING      g_dstrIndivPubKey                           = CREATE_DRM_STRING( g_rgwchIndivPubKey );
const DRM_CONST_STRING      g_dstrUniqueId                              = CREATE_DRM_STRING( g_rgwchUniqueId );
const DRM_CONST_STRING      g_dstrUnsignedtemplate                      = CREATE_DRM_STRING( g_rgwchUnsignedtemplate );

/* This data is used explicitly in the gen tools */
const DRM_CONST_STRING      g_dstrTagDataSecVer                         = CREATE_DRM_STRING( g_rgwchTagDataSecVer );

/* Strings for the expression evaluator functions */
const DRM_CONST_STRING      g_dstrExprFuncDateAdd                       = CREATE_DRM_STRING( g_rgwchExprFuncDateAdd );
const DRM_CONST_STRING      g_dstrExprFuncDateDiff                      = CREATE_DRM_STRING( g_rgwchExprFuncDateDiff );
const DRM_CONST_STRING      g_dstrExprFuncMin                           = CREATE_DRM_STRING( g_rgwchExprFuncMin );
const DRM_CONST_STRING      g_dstrExprFuncMax                           = CREATE_DRM_STRING( g_rgwchExprFuncMax );
const DRM_CONST_STRING      g_dstrExprFuncDatePart                      = CREATE_DRM_STRING( g_rgwchExprFuncDatePart );
const DRM_CONST_STRING      g_dstrExprFuncVersionCompare                = CREATE_DRM_STRING( g_rgwchExprFuncVersionCompare );
const DRM_CONST_STRING      g_dstrExprFuncDeleteLicense                 = CREATE_DRM_STRING( g_rgwchExprFuncDeleteLicense );
const DRM_CONST_STRING      g_dstrExprFuncExists                        = CREATE_DRM_STRING( g_rgwchExprFuncExists );

/* Strings for license evaluator well known actions */
const DRM_CONST_STRING      g_dstrLicEvalOnSelect                       = CREATE_DRM_STRING( g_rgwchLicEvalOnSelect );
const DRM_CONST_STRING      g_dstrLicEvalOnDelete                       = CREATE_DRM_STRING( g_rgwchLicEvalOnDelete );
const DRM_CONST_STRING      g_dstrLicEvalOnStore                        = CREATE_DRM_STRING( g_rgwchLicEvalOnStore );
const DRM_CONST_STRING      g_dstrLicEvalOnAction                       = CREATE_DRM_STRING( g_rgwchLicEvalOnAction );
#if DRM_SUPPORT_ANTIROLLBACK_CLOCK 
const DRM_CONST_STRING      g_dstrLicEvalOnClockRollback                = CREATE_DRM_STRING( g_rgwchLicEvalOnClockRollback );
#endif

/* Strings for expression evaluator variable evaluation */
const DRM_CONST_STRING      g_dstrDRM_PREFIX                            = CREATE_DRM_STRING( g_rgwchDRM_PREFIX );
const DRM_CONST_STRING      g_dstrDRMK_PREFIX                           = CREATE_DRM_STRING( g_rgwchDRMK_PREFIX );
const DRM_CONST_STRING      g_dstrMACHINE_PREFIX                        = CREATE_DRM_STRING( g_rgwchMACHINE_PREFIX );
const DRM_CONST_STRING      g_dstrAPP_PREFIX                            = CREATE_DRM_STRING( g_rgwchAPP_PREFIX );
const DRM_CONST_STRING      g_dstrSECSTATE_PREFIX                       = CREATE_DRM_STRING( g_rgwchSECSTATE_PREFIX );
const DRM_CONST_STRING      g_dstrLICENSE_PREFIX                        = CREATE_DRM_STRING( g_rgwchLICENSE_PREFIX );
const DRM_CONST_STRING      g_dstrCONTENT_PREFIX                        = CREATE_DRM_STRING( g_rgwchCONTENT_PREFIX );
const DRM_CONST_STRING      g_dstrDEVICE_PREFIX                         = CREATE_DRM_STRING( g_rgwchDEVICE_PREFIX );
const DRM_CONST_STRING      g_dstrPMLICENSE_PREFIX                      = CREATE_DRM_STRING( g_rgwchPMLICENSE_PREFIX );
const DRM_CONST_STRING      g_dstrSECURETIME_PREFIX                     = CREATE_DRM_STRING( g_rgwchSECURETIME_PREFIX );
const DRM_CONST_STRING      g_dstrPLAYLISTBURN_PREFIX                   = CREATE_DRM_STRING( g_rgwchPLAYLISTBURN_PREFIX );

#if DRM_SUPPORT_SST_REDUNANCY
const DRM_CONST_STRING      g_dstrSSTREDUNDANCY_PREFIX                  = CREATE_DRM_STRING( g_rgwchSSTREDUNDANCY_PREFIX );
#endif

const DRM_CONST_STRING      g_dstrExprVarVersion                        = CREATE_DRM_STRING( g_rgwchExprVarVersion );
const DRM_CONST_STRING      g_dstrExprVarParameter                      = CREATE_DRM_STRING( g_rgwchExprVarParameter );
const DRM_CONST_STRING      g_dstrExprVarReason                         = CREATE_DRM_STRING( g_rgwchExprVarReason );
const DRM_CONST_STRING      g_dstrExprVarBBMSDRMVersion                 = CREATE_DRM_STRING( g_rgwchExprVarBBMSDRMVersion );
const DRM_CONST_STRING      g_dstrExprVarDateTime                       = CREATE_DRM_STRING( g_rgwchExprVarDateTime );
const DRM_CONST_STRING      g_dstrExprVarCount                          = CREATE_DRM_STRING( g_rgwchExprVarCount );
const DRM_CONST_STRING      g_dstrExprVarMinSecLevel                    = CREATE_DRM_STRING( g_rgwchExprVarMinSecLevel );
const DRM_CONST_STRING      g_dstrExprVarSecLevel                       = CREATE_DRM_STRING( g_rgwchExprVarSecLevel );
const DRM_CONST_STRING      g_dstrExprVarAppSecLevel                    = CREATE_DRM_STRING( g_rgwchExprVarAppSecLevel );
const DRM_CONST_STRING      g_dstrExprVarSubjID                         = CREATE_DRM_STRING( g_rgwchExprVarSubjID );
const DRM_CONST_STRING      g_dstrExprVarAppSubjID                      = CREATE_DRM_STRING( g_rgwchExprVarAppSubjID );
const DRM_CONST_STRING      g_dstrExprVarGlobal                         = CREATE_DRM_STRING( g_rgwchExprVarGlobal );
const DRM_CONST_STRING      g_dstrExprVarSaveDateTime                   = CREATE_DRM_STRING( g_rgwchExprVarSaveDateTime );
const DRM_CONST_STRING      g_dstrExprVarSavedDateTime                  = CREATE_DRM_STRING( g_rgwchExprVarSavedDateTime );
const DRM_CONST_STRING      g_dstrExprVarDRMReason                      = CREATE_DRM_STRING( g_rgwchExprVarDRMReason );
const DRM_CONST_STRING      g_dstrExprVarRights                         = CREATE_DRM_STRING( g_rgwchExprVarRights );
const DRM_CONST_STRING      g_dstrExprVarExpiryDate                     = CREATE_DRM_STRING( g_rgwchExprVarExpiryDate );
const DRM_CONST_STRING      g_dstrExprVarInGracePeriod                  = CREATE_DRM_STRING( g_rgwchExprVarInGracePeriod );
const DRM_CONST_STRING      g_dstrExprVarGpStartTime                    = CREATE_DRM_STRING( g_rgwchExprVarGpStartTime );
const DRM_CONST_STRING      g_dstrExprVarIncrementCount                 = CREATE_DRM_STRING( g_rgwchExprVarIncrementCount );
const DRM_CONST_STRING      g_dstrExprVarDevReg                         = CREATE_DRM_STRING( g_rgwchExprVarDevReg );

/* XML tags */
const DRM_ANSI_CONST_STRING g_dastrTagCDATA                             = { g_rgchTagCDATA, g_rgchTagCDATA_LEN };
const DRM_CONST_STRING      g_dstrTagCDATA                              = CREATE_DRM_STRING( g_rgwchTagCDATA );
const DRM_ANSI_CONST_STRING g_dastrTagCDATAOpenBracket                  = { g_rgchTagCDATAOpenBracket, g_rgchTagCDATAOpenBracket_LEN };
const DRM_CONST_STRING      g_dstrTagCDATAOpenBracket                   = CREATE_DRM_STRING( g_rgwchTagCDATAOpenBracket );
const DRM_CONST_STRING      g_dstrOpenTag                               = CREATE_DRM_STRING( g_rgwchOpenTag );
const DRM_CONST_STRING      g_dstrSpace                                 = CREATE_DRM_STRING( g_rgwchSpace );
const DRM_CONST_STRING      g_dstrOpenEndTag                            = CREATE_DRM_STRING( g_rgwchOpenEndTag );
const DRM_ANSI_CONST_STRING g_dastrOpenEndTag                           = { g_rgchOpenEndTag, g_rgchOpenEndTag_LEN };
const DRM_CONST_STRING      g_dstrCloseTag                              = CREATE_DRM_STRING( g_rgwchCloseTag );
const DRM_CONST_STRING      g_dstrEqualQuote                            = CREATE_DRM_STRING( g_rgwchEqualQuote );
const DRM_CONST_STRING      g_dstrQuote                                 = CREATE_DRM_STRING( g_rgwchQuote );
const DRM_ANSI_CONST_STRING g_dastrOpenCDATATag                         = { g_rgchOpenCDATATag, g_rgchOpenCDATATag_LEN };
const DRM_CONST_STRING      g_dstrOpenCDATATag                          = CREATE_DRM_STRING( g_rgwchOpenCDATATag );
const DRM_ANSI_CONST_STRING g_dastrCloseCDATATag                        = { g_rgchCloseCDATATag, g_rgchCloseCDATATag_LEN };
const DRM_CONST_STRING      g_dstrCloseCDATATag                         = CREATE_DRM_STRING( g_rgwchCloseCDATATag );


const DRM_ANSI_CONST_STRING  g_dastrAttributeAlgorithm                  = { g_rgchAttributeAlgorithm, g_rgchAttributeAlgorithm_LEN };
const DRM_ANSI_CONST_STRING  g_dastrAttributeVersionWMDRM               = { g_rgchAttributeVersionWMDRM, g_rgchAttributeVersionWMDRM_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagEscrowedKeys                     = { g_rgchTagEscrowedKeys, g_rgchTagEscrowedKeys_LEN };
const DRM_ANSI_CONST_STRING  g_dastrKeyUsageSignCert                    = { g_rgchKeyUsageSignCert, g_rgchKeyUsageSignCert_LEN };
const DRM_ANSI_CONST_STRING  g_dastrKeyUsageSignCRL                     = { g_rgchKeyUsageSignCRL, g_rgchKeyUsageSignCRL_LEN };
const DRM_ANSI_CONST_STRING  g_dastrKeyUsageEncryptKey                  = { g_rgchKeyUsageEncryptKey, g_rgchKeyUsageEncryptKey_LEN };
const DRM_ANSI_CONST_STRING  g_dastrOne                                 = { g_rgchOne, g_rgchOne_LEN };
const DRM_ANSI_CONST_STRING  g_dastrPrefixManufacturer                  = { g_rgchPrefixManufacturer, g_rgchPrefixManufacturer_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagCanonicalization                 = { g_rgchTagCanonicalization, g_rgchTagCanonicalization_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagCertificateCollection            = { g_rgchTagCertificateCollection, g_rgchTagCertificateCollection_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagDigestMethod                     = { g_rgchTagDigestMethod, g_rgchTagDigestMethod_LEN };
const DRM_ANSI_CONST_STRING  g_dastrURIDSigSHA1                         = { g_rgchURIDSigSHA1, g_rgchURIDSigSHA1_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagDigestValue                      = { g_rgchTagDigestValue, g_rgchTagDigestValue_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagSignatureValue                   = { g_rgchTagSignatureValue, g_rgchTagSignatureValue_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagKeyInfo                          = { g_rgchTagKeyInfo, g_rgchTagKeyInfo_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagSymmetricKey                     = { g_rgchTagSymmetricKey, g_rgchTagSymmetricKey_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagPublicKey                        = { g_rgchTagPublicKey, g_rgchTagPublicKey_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagPrivateKey                       = { g_rgchTagPrivateKey, g_rgchTagPrivateKey_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagKeyValue                         = { g_rgchTagKeyValue, g_rgchTagKeyValue_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagRSAKeyValue                      = { g_rgchTagRSAKeyValue, g_rgchTagRSAKeyValue_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagModulus                          = { g_rgchTagModulus, g_rgchTagModulus_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagExponent                         = { g_rgchTagExponent, g_rgchTagExponent_LEN };

const DRM_ANSI_CONST_STRING  g_dastrTagManufacturerName                 = { g_rgchTagManufacturerName, g_rgchTagManufacturerName_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagManufacturerData                 = { g_rgchTagManufacturerData, g_rgchTagManufacturerData_LEN }; 
const DRM_ANSI_CONST_STRING  g_dastrTagModelName                        = { g_rgchTagModelName, g_rgchTagModelName_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagModelNumber                      = { g_rgchTagModelNumber, g_rgchTagModelNumber_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagHardwareID                         = { g_rgchTagHardwareID, g_rgchTagHardwareID_LEN };
const DRM_ANSI_CONST_STRING  g_dastrURIRSASHA1                          = { g_rgchURIRSASHA1, g_rgchURIRSASHA1_LEN };
const DRM_ANSI_CONST_STRING  g_dastrURIRSASHA1_Old                      = { g_rgchURIRSASHA1_Old, g_rgchURIRSASHA1_Old_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagReference                        = { g_rgchTagReference, g_rgchTagReference_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagTransforms                       = { g_rgchTagTransforms, g_rgchTagTransforms_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagTransform                        = { g_rgchTagTransform, g_rgchTagTransform_LEN };
const DRM_ANSI_CONST_STRING  g_dastrURITransformMSCert                  = { g_rgchURITransformMSCert, g_rgchURITransformMSCert_LEN };
const DRM_ANSI_CONST_STRING  g_dastrURITransformMSCertColl              = { g_rgchURITransformMSCertColl, g_rgchURITransformMSCertColl_LEN };
const DRM_ANSI_CONST_STRING  g_dastrURITransformMSCert_Old              = { g_rgchURITransformMSCert_Old, g_rgchURITransformMSCert_Old_LEN };
const DRM_ANSI_CONST_STRING  g_dastrURITransformC14N                    = { g_rgchURITransformC14N, g_rgchURITransformC14N_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMCertificate                 = { g_rgchTagWMDRMCertificate, g_rgchTagWMDRMCertificate_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMData                        = { g_rgchTagDataWMDRM, g_rgchTagDataWMDRM_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMCertPublicKey               = { g_rgchTagWMDRMCertPublicKey, g_rgchTagWMDRMCertPublicKey_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMCertSecurityVersion         = { g_rgchTagWMDRMCertSecurityVersion, g_rgchTagWMDRMCertSecurityVersion_LEN };
const DRM_ANSI_CONST_STRING  g_dastrSecurityVersion                     = { g_rgchSecurityVersion, g_rgchSecurityVersion_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMCertSecurityLevel           = { g_rgchTagWMDRMCertSecurityLevel, g_rgchTagWMDRMCertSecurityLevel_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMCertSerialNumber            = { g_rgchTagWMDRMCertSerialNumber, g_rgchTagWMDRMCertSerialNumber_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMCertFeatures                = { g_rgchTagWMDRMCertFeatures, g_rgchTagWMDRMCertFeatures_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMCertKeyUsage                = { g_rgchTagWMDRMCertKeyUsage, g_rgchTagWMDRMCertKeyUsage_LEN };
const DRM_ANSI_CONST_STRING  g_dastrFeaturesWMDRMTransmitter            = { g_rgchFeaturesWMDRMTransmitter, g_rgchFeaturesWMDRMTransmitter_LEN};
const DRM_ANSI_CONST_STRING  g_dastrFeaturesWMDRMReceiver               = { g_rgchFeaturesWMDRMReceiver, g_rgchFeaturesWMDRMReceiver_LEN};

const DRM_ANSI_CONST_STRING  g_dastrTagSignature                        = { g_rgchTagSignature, g_rgchTagSignature_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagSignatureMethod                  = { g_rgchTagSignatureMethod, g_rgchTagSignatureMethod_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagSignedInfo                       = { g_rgchTagSignedInfo, g_rgchTagSignedInfo_LEN };
const DRM_ANSI_CONST_STRING  g_dastrURIC14N                             = { g_rgchURIC14N, g_rgchURIC14N_LEN };
const DRM_ANSI_CONST_STRING  g_dastrVersionWMDRM                        = { g_rgchVersionWMDRM, g_rgchVersionWMDRM_LEN };
const DRM_ANSI_CONST_STRING  g_dastrWMDRMCertExponent                   = { g_rgchWMDRMCertExponent, g_rgchWMDRMCertExponent_LEN };


const DRM_ANSI_CONST_STRING  g_dastrFeatureSampleProtection             = { g_rgchFeatureSampleProtection, g_rgchFeatureSampleProtection_LEN };
const DRM_ANSI_CONST_STRING  g_dastrFeatureExport                       = { g_rgchFeatureExport, g_rgchFeatureExport_LEN };
const DRM_ANSI_CONST_STRING  g_dastrFeatureExportIncl                   = { g_rgchFeatureExportIncl, g_rgchFeatureExportIncl_LEN};

const DRM_ANSI_CONST_STRING  g_dastrPrefixMicrosoftCert                 = { g_rgchPrefixMicrosoftCert, g_rgchPrefixMicrosoftCert_LEN };

const DRM_ANSI_CONST_STRING  g_dastrTagUnsignedTemplate                 = { g_rgchTagUnsignedTemplate, g_rgchTagUnsignedTemplate_LEN };

const DRM_ANSI_CONST_STRING  g_dastrMSNDRootPubKeyB64                   = { g_rgchMSNDRootPubKeyB64, g_rgchMSNDRootPubKeyB64_LEN };

/* Secure clock Challenge\response XML tags */
const DRM_CONST_STRING      g_dstrTagDRMReqRoot                         = CREATE_DRM_STRING( g_rgwchTagDRMReqRoot );
const DRM_CONST_STRING      g_dstrResponse                              = CREATE_DRM_STRING( g_rgwchResponse );
const DRM_CONST_STRING      g_dstrStatus                                = CREATE_DRM_STRING( g_rgwchStatus );
const DRM_CONST_STRING      g_dstrFlag                                  = CREATE_DRM_STRING( g_rgwchFlag );
const DRM_CONST_STRING      g_dstrTagGmtTime                            = CREATE_DRM_STRING( g_rgwchTagGmtTime );
const DRM_CONST_STRING      g_dstrTagRefreshDate                        = CREATE_DRM_STRING( g_rgwchTagRefreshDate );

/* Output Level strings */
const DRM_CONST_STRING      g_dstrLabelGuid                             = CREATE_DRM_STRING( g_rgwchLabelGuid );
const DRM_CONST_STRING      g_dstrLabelLevel                            = CREATE_DRM_STRING( g_rgwchLabelLevel );
const DRM_CONST_STRING      g_dstrTagUncompressedDigitalVideo           = CREATE_DRM_STRING( g_rgwchTagUncompressedDigitalVideo );
const DRM_CONST_STRING      g_dstrTagCompressedDigitalVideo             = CREATE_DRM_STRING( g_rgwchTagCompressedDigitalVideo );
const DRM_CONST_STRING      g_dstrTagUncompressedDigitalAudio           = CREATE_DRM_STRING( g_rgwchTagUncompressedDigitalAudio );
const DRM_CONST_STRING      g_dstrTagCompressedDigitalAudio             = CREATE_DRM_STRING( g_rgwchTagCompressedDigitalAudio );
const DRM_CONST_STRING      g_dstrTagAnalogVideo                        = CREATE_DRM_STRING( g_rgwchTagAnalogVideo );
const DRM_CONST_STRING      g_dstrTagCopy                               = CREATE_DRM_STRING( g_rgwchTagCopy );
const DRM_CONST_STRING      g_dstrTagExtensionList                      = CREATE_DRM_STRING( g_rgwchTagExtensionList );
const DRM_CONST_STRING      g_dstrTagExtension                          = CREATE_DRM_STRING( g_rgwchTagExtension );
const DRM_CONST_STRING      g_dstrTagIncludeList                        = CREATE_DRM_STRING( g_rgwchTagIncludeList );
const DRM_CONST_STRING      g_dstrTagInclude                            = CREATE_DRM_STRING( g_rgwchTagInclude );
const DRM_CONST_STRING      g_dstrTagExcludeList                        = CREATE_DRM_STRING( g_rgwchTagExcludeList );
const DRM_CONST_STRING      g_dstrTagExclude                            = CREATE_DRM_STRING( g_rgwchTagExclude );

const DRM_CONST_STRING      g_dstrMSRootPubKey                          = CREATE_DRM_STRING( g_rgwchMSRootPubKey );

const DRM_BYTE              g_rgbMSPlayReadyRootIssuerPubKey[] = {
         TWO_BYTES(0x86, 0x4D), TWO_BYTES(0x61, 0xCF), TWO_BYTES(0xF2, 0x25), TWO_BYTES(0x6E, 0x42), TWO_BYTES(0x2C, 0x56), TWO_BYTES(0x8B, 0x3C), TWO_BYTES(0x28, 0x00), TWO_BYTES(0x1C, 0xFB), 
         TWO_BYTES(0x3E, 0x15), TWO_BYTES(0x27, 0x65), TWO_BYTES(0x85, 0x84), TWO_BYTES(0xBA, 0x05), TWO_BYTES(0x21, 0xB7), TWO_BYTES(0x9B, 0x18), TWO_BYTES(0x28, 0xD9), TWO_BYTES(0x36, 0xDE), 
         TWO_BYTES(0x1D, 0x82), TWO_BYTES(0x6A, 0x8F), TWO_BYTES(0xC3, 0xE6), TWO_BYTES(0xE7, 0xFA), TWO_BYTES(0x7A, 0x90), TWO_BYTES(0xD5, 0xCA), TWO_BYTES(0x29, 0x46), TWO_BYTES(0xF1, 0xF6), 
         TWO_BYTES(0x4A, 0x2E), TWO_BYTES(0xFB, 0x9F), TWO_BYTES(0x5D, 0xCF), TWO_BYTES(0xFE, 0x7E), TWO_BYTES(0x43, 0x4E), TWO_BYTES(0xB4, 0x42), TWO_BYTES(0x93, 0xFA), TWO_BYTES(0xC5, 0xAB)
     };

/* License State strings */
const DRM_CONST_STRING      g_dstrTagLicenseStateRequestRoot            = CREATE_DRM_STRING( g_rgwchTagLicenseStateRequestRoot );
const DRM_CONST_STRING      g_dstrTagCanBind                            = CREATE_DRM_STRING( g_rgwchTagCanBind );


/*Device License Revocation Blob Strings*/

const DRM_CONST_STRING      g_dstrTagDeviceLicenseRevocationRoot        = CREATE_DRM_STRING( g_rgwchTagDeviceLicenseRevocationRoot );
const DRM_CONST_STRING      g_dstrTagRevocationPubKey                   = CREATE_DRM_STRING( g_rgwchTagRevocationPubKey );


#if DRM_SUPPORT_REVOCATION
/* Revocation GUIDs */

const DRM_GUID g_guidRevocationTypeRevInfo = {
    0xCCDE5A55, 
    0xA688, 
    0x4405, 
    { 
        TWO_BYTES( 0xA8, 0x8B ), TWO_BYTES( 0xD1, 0x3F ),
        TWO_BYTES( 0x90, 0xD5 ), TWO_BYTES( 0xBA, 0x3E )
    }
};

/* 
** This GUID is for the PlayReady REVINFO2
** {52D1FF11-D388-4edd-82B7-68EA4C20A16C} 
Note that this GUID will also be present in the WMDRM rev-info, in order to
identify the minimum PlayReady Revinfo(V2) version in the WMDRM Revinfo (V1).
This is required to export from WMDRM to PlayReady
*/
const DRM_GUID g_guidRevocationTypeRevInfo2 = {
    0x52D1FF11, 
    0xD388, 
    0x4EDD, 
    { 
        TWO_BYTES( 0x82, 0xB7 ), TWO_BYTES( 0x68, 0xEA ),
        TWO_BYTES( 0x4C, 0x20 ), TWO_BYTES( 0xA1, 0x6C )
    }
};

#if DRM_SUPPORT_WMDRMNET
const DRM_GUID g_guidRevocationTypeWMDRMNET = {
    0xCD75E604, 
    0x543D, 
    0x4A9C, 
    { 
        TWO_BYTES( 0x9F, 0x09 ), TWO_BYTES( 0xFE, 0x6D ),
        TWO_BYTES( 0x24, 0xE8 ), TWO_BYTES( 0xBF, 0x90 )
    }
};
#endif /* DRM_SUPPORT_WMDRMNET */ 

#if DRM_SUPPORT_DEVICE_REVOCATION
const DRM_GUID g_guidRevocationTypeDevice = {
    0x3129E375, 
    0xCEB0, 
    0x47D5, 
    { 
        TWO_BYTES( 0x9C, 0xCA ), TWO_BYTES( 0x9D, 0xB7 ),
        TWO_BYTES( 0x4C, 0xFD ), TWO_BYTES( 0x43, 0x32 )
    }
};
#endif /* DRM_SUPPORT_DEVICE_REVOCATION */


#if DRM_SUPPORT_APP_REVOCATION
const DRM_GUID g_guidRevocationTypeApp = {
    0x90A37313, 
    0x0ECF, 0x4CAA, 
    {
        TWO_BYTES( 0xA9, 0x06 ), TWO_BYTES( 0xB1, 0x88 ),
        TWO_BYTES( 0xF6, 0x12 ), TWO_BYTES( 0x93, 0x00 )
    }
};
#endif /* DRM_SUPPORT_APP_REVOCATION */

const DRM_GUID g_guidRevocationTypePlayReadySilverLightRuntime =
{
    0x4E9D8C8A,
    0xB652, 0x45A7,
    { 
        TWO_BYTES( 0x97, 0x91 ), TWO_BYTES( 0x69, 0x25 ),
        TWO_BYTES( 0xA6, 0xB4 ), TWO_BYTES( 0x79, 0x1F )
    }
};

const DRM_GUID g_guidRevocationTypePlayReadySilverLightApplication =
{
    0x28082E80,
    0xC7A3, 0x40b1,
    { 
        TWO_BYTES( 0x82, 0x56 ), TWO_BYTES( 0x19, 0xE5 ),
        TWO_BYTES( 0xB6, 0xD8 ), TWO_BYTES( 0x9B, 0x27 )
    }
};

#endif /* DRM_SUPPORT_REVOCATION */

const DRM_CONST_STRING      g_dstrInitialExtensibleStateAttributeName = CREATE_DRM_STRING( g_rgwchInitialExtensibleStateAttributeName );



/******************************************************************************
**
** Action GUIDs for DRM_LICENSE_EVAL_ACTION operation
**
******************************************************************************/

DRM_DEFINE_GUID( DRM_ACTION_PLAY,
                 0x4C3FC9B3, 0x31C2, 0x4FD4, 0x82, 0x4A, 0x04, 0xD4, 0x23, 0x41, 0xA9, 0xD3 );

DRM_DEFINE_GUID( DRM_ACTION_COPY,
                 0xD8C5502C, 0x41B1, 0x4681, 0x8B, 0x61, 0x8A, 0x16, 0x18, 0xA3, 0x1D, 0xA7 );

DRM_DEFINE_GUID( DRM_ACTION_CREATE_THUMBNAIL,
                 0x8CC2C885, 0xBB0D, 0x4AA2, 0xA3, 0x58, 0x96, 0x37, 0xBB, 0x35, 0x59, 0xA9 );

DRM_DEFINE_GUID( DRM_ACTION_COLLABORATIVE_PLAY,
                 0x6B6B0837, 0x46A4, 0x4015, 0x84, 0xE3, 0x8C, 0x20, 0xB5, 0xA7, 0xCD, 0x3A );

DRM_DEFINE_GUID( DRM_ACTION_PLAYLIST_BURN,
                 0x0B75E302, 0x2EFF, 0x4153, 0xAD, 0x26, 0xFB, 0xD8, 0xB0, 0xD8, 0x7B, 0xCD );

DRM_DEFINE_GUID( DRM_ACTION_COPY_TO_CD,
                 0xEC930B7D, 0x1F2D, 0x4682, 0xA3, 0x8B, 0x8A, 0xB9, 0x77, 0x72, 0x1D, 0x0D );

DRM_DEFINE_GUID( DRM_ACTION_CREATE_PM_LICENSE,
                 0x6A2C98F0, 0xB4DD, 0x4960, 0x80, 0xA0, 0xC7, 0x23, 0x8C, 0x92, 0x1D, 0xAE );

DRM_DEFINE_GUID( DRM_ACTION_BACKUP_RESTORE,
                 0x5BE1DB73, 0xD15C, 0x497B, 0xAE, 0xB1, 0xD8, 0xE1, 0x63, 0x27, 0x45, 0xD7 );

DRM_DEFINE_GUID( DRM_ACTION_COPY_TO_PC,
                 0xCE480EDE, 0x516B, 0x40B3, 0x90, 0xE1, 0xD6, 0xCF, 0xC4, 0x76, 0x30, 0xC5 );

DRM_DEFINE_GUID( DRM_ACTION_COPY_TO_DEVICE,
                 0x6848955D, 0x516B, 0x4EB0, 0x90, 0xE8, 0x8F, 0x6D, 0x5A, 0x77, 0xB8, 0x5F );

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmcipher.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmcipher.h>
#include <drmaes.h>
#include <oemaes.h>
#include <byteorder.h>
#include <oem.h>

ENTER_PK_NAMESPACE_CODE;

/*********************************************************************
**
**  Function:  DRM_CPHR_Init
**
**  Synopsis:  Initializes a content cipher context.  This must be done prior to using 
**             DRM_CPHR_Encrypt or DRM_CHPR_Decrypt.
**
**  Arguments:  
**     f_pContext     :  The cipher context to be initialized
**     f_eCipherType  :  The type of cipher to be used
**     f_cbContKey    :  The length of f_pbContKey in bytes
**     f_pbContKey    :  The content key
**
**  Returns:
**      DRM_SUCCESS
**          success
**      DRM_E_INVALIDARG
**          one of the arguments was NULL or out of range
**
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_CPHR_Init(
    __out_ecount( 1 )                 DRM_CIPHER_CONTEXT     *f_pContext,
    __in                              DRM_SUPPORTED_CIPHERS   f_eCipherType,
    __in                              DRM_DWORD               f_cbContKey,
    __in_bcount( f_cbContKey )  const DRM_BYTE               *f_pbContKey )
{
    DRM_RESULT  dr             = DRM_SUCCESS;
    DRM_UINT    rnd_bytes[16]  = { 0 };    
    DRM_UINT    rnd_bytes2[16] = { 0 };
    DRM_INT     i              = 0;
    
    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMCIPHER, PERF_FUNC_DRM_CPHR_Init);

    DRMCASSERT( SIZEOF( DRM_SHA_CONTEXT ) < SIZEOF( RC4_KEYSTRUCT ) );

    ChkArg( f_pbContKey  != NULL );
    ChkArg( f_cbContKey   > 0 );
    ChkArg( f_pContext   != NULL );

    ZEROMEM( f_pContext, SIZEOF( DRM_CIPHER_CONTEXT ) );

    /*
    ** copy the content key to the context 
    */
    ChkArg( f_cbContKey <= SIZEOF( f_pContext->rgbContentKey ) );
    f_pContext->cbContentKey = f_cbContKey;
    MEMCPY( f_pContext->rgbContentKey, f_pbContKey, f_cbContKey );

    /*
    ** Initialize an RC4 cipher
    */
    if( f_eCipherType == eDRM_RC4_CIPHER )
    {      
        /*
        ** hash to song key to 20 bytes length. first 12 bytes used as a MAC key, the following
        ** 8 ( 7 ) bytes as a DES key 
        */
        ChkDR( DRM_SHA_Init( ( DRM_SHA_CONTEXT * )&f_pContext->cipher.cipherRC4.rc4ks, eDRM_SHA_1 ) );
        ChkDR( DRM_SHA_Update( f_pbContKey, 
                               f_cbContKey, 
                              ( DRM_SHA_CONTEXT* )&f_pContext->cipher.cipherRC4.rc4ks ) );
        ChkDR( DRM_SHA_Finalize( ( DRM_SHA_CONTEXT* )&f_pContext->cipher.cipherRC4.rc4ks, 
                                 DRM_SHA1_DIGEST_LEN,
                                 f_pContext->cipher.cipherRC4.shaOut ) );

        ZEROMEM( rnd_bytes2, SIZEOF( rnd_bytes ) );

        DRM_RC4_KeySetup( &f_pContext->cipher.cipherRC4.rc4ks, 
                           12, 
                           f_pContext->cipher.cipherRC4.shaOut );
        DRM_RC4_Cipher( &f_pContext->cipher.cipherRC4.rc4ks, 
                         SIZEOF( rnd_bytes2 ), 
                         ( DRM_BYTE * )rnd_bytes2 );

        for( i = 0; i < NO_OF( rnd_bytes2 ); i++ )
        {
            BYTES_TO_DWORD( rnd_bytes[i], ( ( DRM_BYTE* )( rnd_bytes2 + i ) ) );
        }
        
        f_pContext->cipher.cipherRC4.mackey.a1 = rnd_bytes[0]  | 0x00000001;
        f_pContext->cipher.cipherRC4.mackey.b1 = rnd_bytes[1]  | 0x00000001;
        f_pContext->cipher.cipherRC4.mackey.c1 = rnd_bytes[2]  | 0x00000001;
        f_pContext->cipher.cipherRC4.mackey.d1 = rnd_bytes[3]  | 0x00000001;
        f_pContext->cipher.cipherRC4.mackey.e1 = rnd_bytes[4]  | 0x00000001;
        f_pContext->cipher.cipherRC4.mackey.f1 = rnd_bytes[5]  | 0x00000001;
        f_pContext->cipher.cipherRC4.mackey.a2 = rnd_bytes[6]  | 0x00000001;
        f_pContext->cipher.cipherRC4.mackey.b2 = rnd_bytes[7]  | 0x00000001;
        f_pContext->cipher.cipherRC4.mackey.c2 = rnd_bytes[8]  | 0x00000001;
        f_pContext->cipher.cipherRC4.mackey.d2 = rnd_bytes[9]  | 0x00000001;
        f_pContext->cipher.cipherRC4.mackey.e2 = rnd_bytes[10] | 0x00000001;
        f_pContext->cipher.cipherRC4.mackey.f2 = rnd_bytes[11] | 0x00000001;

        f_pContext->cipher.cipherRC4.invmackey.a1 = 
            DRM_MAC_inv32( f_pContext->cipher.cipherRC4.mackey.a1 );
        f_pContext->cipher.cipherRC4.invmackey.a2 = 
            DRM_MAC_inv32( f_pContext->cipher.cipherRC4.mackey.a2 );
        f_pContext->cipher.cipherRC4.invmackey.b1 = 
            DRM_MAC_inv32( f_pContext->cipher.cipherRC4.mackey.b1 );
        f_pContext->cipher.cipherRC4.invmackey.b2 = 
            DRM_MAC_inv32( f_pContext->cipher.cipherRC4.mackey.b2 );
        f_pContext->cipher.cipherRC4.invmackey.c1 = 
            DRM_MAC_inv32( f_pContext->cipher.cipherRC4.mackey.c1 );
        f_pContext->cipher.cipherRC4.invmackey.c2 = 
            DRM_MAC_inv32( f_pContext->cipher.cipherRC4.mackey.c2 );
        f_pContext->cipher.cipherRC4.invmackey.d1 = 
            DRM_MAC_inv32( f_pContext->cipher.cipherRC4.mackey.d1 );
        f_pContext->cipher.cipherRC4.invmackey.d2 = 
            DRM_MAC_inv32( f_pContext->cipher.cipherRC4.mackey.d2 );
        f_pContext->cipher.cipherRC4.invmackey.e1 = 
            DRM_MAC_inv32( f_pContext->cipher.cipherRC4.mackey.e1 );
        f_pContext->cipher.cipherRC4.invmackey.e2 = 
            DRM_MAC_inv32( f_pContext->cipher.cipherRC4.mackey.e2 );

        f_pContext->cipher.cipherRC4.desS1[0] = rnd_bytes[12]; 
        f_pContext->cipher.cipherRC4.desS1[1] = rnd_bytes[13];
        f_pContext->cipher.cipherRC4.desS2[0] = rnd_bytes[14]; 
        f_pContext->cipher.cipherRC4.desS2[1] = rnd_bytes[15];

        DRM_DES_KeySetup( &f_pContext->cipher.cipherRC4.destable, 
                           f_pContext->cipher.cipherRC4.shaOut + __CB_DECL( 12 ) );  
    }
    /*
    ** Initialize an AES CTR-mode cipher
    */
    else
    {    
        ChkArg( f_eCipherType == eDRM_AES_COUNTER_CIPHER );
        ChkArg( f_cbContKey   == DRM_AES_KEYSIZE_128 );  

        ChkDR( Oem_Aes_SetKey( f_pContext->rgbContentKey, &f_pContext->cipher.cipherAES.aesKey ) );
    }
    f_pContext->eCipherType = f_eCipherType;
    f_pContext->fInited     = TRUE;

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/******************************************************************************
** 
** Function :   DRM_CPHR_InitDecrypt
** 
** Synopsis :   Initializes state for phased decryption
** 
** Arguments :  
**      f_pContext : Cipher context initialized with DRM_CPHR_Init
**      f_pbLast15 : Pointer to the last 15 bytes of the ciphertext. If the 
**                   ciphertext is less than 15 bytes, it is a pointer to the
**                   beginning of the ciphertext.
**      f_cbData   : # of bytes in ENTIRE ciphertext              
** 
** Returns :    
**      DRM_E_INVALIDARG
**          f_pContext is null, or f_pbLast15 is null when cipher type is RC4
**      DRM_E_CIPHER_NOTINITIALIZED
**          f_pContext was not appropriately initialized    
** 
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_CPHR_InitDecrypt(
    __inout_ecount( 1 )                                DRM_CIPHER_CONTEXT *f_pContext,
    __in_bcount_opt( min(DRM_CPHR_CB_FOR_INITDECRYPT,f_cbData) ) DRM_BYTE *f_pbLast15,
    __in                                                        DRM_DWORD  f_cbData )
{
    DRM_DWORD  cbClear = 0;
    DRM_RESULT dr      = DRM_SUCCESS;    
        
    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMCIPHER, PERF_FUNC_DRM_CPHR_InitDecrypt);

    ChkArg( f_pContext != NULL );
    ChkArg( f_cbData   >  0 );

    ChkBOOL( f_pContext->fInited, DRM_E_CIPHER_NOTINITIALIZED );        
    
    /*
    ** Only RC4 cipher requires this extra initialization
    */
    if ( f_pContext->eCipherType == eDRM_RC4_CIPHER )
    {    
        f_pContext->cipher.cipherRC4.fDecryptInited = FALSE;

        ChkArg( f_pbLast15 != NULL );

        /*
        **  Initialize data required for phased decryption
        */
        f_pContext->cipher.cipherRC4.cbPacket = f_cbData;
        f_pContext->cipher.cipherRC4.iPacket  = 0;
            
        if ( f_cbData >= 16 )
        {                            
            /*
            **  Find Number of clear bytes
            */
            cbClear = f_cbData % 8;

            /*
            **  Extract the last 8 bytes before the clear content
            ** ( To find these bytes start at the end of the last 15 bytes,
            **  subtract the number of clear bytes, then move 8 more bytes back,
            **  i.e. 15 - ( cbClear + 8 ) ).
            */
            DRM_BYT_CopyBytes( ( DRM_BYTE* )f_pContext->cipher.cipherRC4.rguiLast8, 
                               0, 
                               f_pbLast15,
                               15 - ( cbClear + 8 ),
                               2 * SIZEOF( DRM_UINT ) );    
            
            FIX_ENDIAN_DWORD( f_pContext->cipher.cipherRC4.rguiLast8[0] );
            FIX_ENDIAN_DWORD( f_pContext->cipher.cipherRC4.rguiLast8[1] );   

            /*    
            **  XOR the last 8 bytes( right before the clear content ) with the DES key
            */    
            f_pContext->cipher.cipherRC4.rguiLast8[0] ^= f_pContext->cipher.cipherRC4.desS2[0];
            f_pContext->cipher.cipherRC4.rguiLast8[1] ^= f_pContext->cipher.cipherRC4.desS2[1];
            
            FIX_ENDIAN_DWORD( f_pContext->cipher.cipherRC4.rguiLast8[0] );
            FIX_ENDIAN_DWORD( f_pContext->cipher.cipherRC4.rguiLast8[1] );   
            
            /*
            **  Use the DES key to decrypt the 8 bytes. The result is the XOR'd RC4 
            **  content encryption key for the payload.
            */                
            DRM_DES_Decrypt( ( DRM_BYTE * )f_pContext->cipher.cipherRC4.rguiLast8, 
                             ( DRM_BYTE * )f_pContext->cipher.cipherRC4.rc4key, 
                             &f_pContext->cipher.cipherRC4.destable );
            
            FIX_ENDIAN_DWORD( f_pContext->cipher.cipherRC4.rguiLast8[0] );
            FIX_ENDIAN_DWORD( f_pContext->cipher.cipherRC4.rguiLast8[1] );
            FIX_ENDIAN_DWORD( f_pContext->cipher.cipherRC4.rc4key[0] );
            FIX_ENDIAN_DWORD( f_pContext->cipher.cipherRC4.rc4key[1] );

            /*
            **  XOR the 8 bytes resulting from the DES decryption with the DES key. 
            **  The result is the RC4 content key for the packet
            */
            f_pContext->cipher.cipherRC4.rc4key[0] ^= f_pContext->cipher.cipherRC4.desS1[0];
            f_pContext->cipher.cipherRC4.rc4key[1] ^= f_pContext->cipher.cipherRC4.desS1[1];

            FIX_ENDIAN_DWORD( f_pContext->cipher.cipherRC4.rc4key[0] );
            FIX_ENDIAN_DWORD( f_pContext->cipher.cipherRC4.rc4key[1] );
            
            /*
            **  Setup the RC4 key to decrypt content
            */
            DRM_RC4_KeySetup( &f_pContext->cipher.cipherRC4.rc4ks, 
                              8, 
                              ( DRM_BYTE * )f_pContext->cipher.cipherRC4.rc4key ); 
            
            FIX_ENDIAN_DWORD( f_pContext->cipher.cipherRC4.rc4key[0] );
            FIX_ENDIAN_DWORD( f_pContext->cipher.cipherRC4.rc4key[1] );

            /*
            **  Initialize cbc state
            */
            DRM_CBC64InitState( &( f_pContext->cipher.cipherRC4.cbcstate ) );            
        }
        f_pContext->cipher.cipherRC4.fDecryptInited = TRUE;
    }
    else
    {
        ChkArg( f_pContext->eCipherType == eDRM_AES_COUNTER_CIPHER );               
    }     

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}
    
/******************************************************************************
** 
** Function :   DRM_CPHR_Decrypt
** 
** Synopsis :   Decrypts part of the ciphertext. This function must be called 
**              after DRM_CPHR_InitDecrypt has been successful
** 
** Arguments :  
**     f_pContext     : Cipher context initialized with DRM_CPHR_Init
**                      followed by DRM_CPHR_InitDecrypt
**     f_pCtrContext  : Sets and maintains the 
**                      initialization vector and counter 
**                      for AES CTR mode. Must be 
**                      specified for AES decryption, and
**                      ignored for Cocktail.
**     f_cbData       :  Length of pbData in bytes
**     f_pbData       :  Array of bytes to decrypt
**
**  Returns:
**      DRM_SUCCESS
**          success
**      DRM_E_INVALIDARG
**          pbData or pContextCipher is null
**      DRM_E_CIPHER_NOTINITIALIZED
**          pContextCipher was not appropriately initialized
**      DRM_E_DECRYPT_NOTINITIALIZED
**          pContextCipher was not appropriately initialized for decryption (Cocktail only)
**      DRM_E_CRYPTO_FAILED
**          The encrypt/decrypt operation failed
**      DRM_E_ARITHMETIC_OVERFLOW
**          An overflow/underflow occurred while processing the data
** 
** Notes :      IMPORTANT: (COCKTAIL ONLY)
**              Phased decrypt should be called on segments of 
**              encrypted data sequentially, i.e. if encrypted data is divided 
**              four segments, the order of decryption should be segment 1,
**              followed by 2, 3, 4.
**              To remove complexity we do not handle the case where
**              a packet is split somewhere in the middle of the last 15 bytes.
**              The caller is responsible to ensure that the last 15 bytes never
**              straddle multiple calls to Decrypt.
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_CPHR_Decrypt(
    __inout_ecount( 1 )          DRM_CIPHER_CONTEXT           *f_pContext,
    __inout_opt                  DRM_AES_COUNTER_MODE_CONTEXT *f_pCtrContext,
    __in                         DRM_DWORD                     f_cbData, 
    __inout_bcount( f_cbData )   DRM_BYTE                     *f_pbData )
{
    DRM_RESULT  dr                = DRM_SUCCESS;
    DRM_DWORD   imac_start        = 0; 
    DRM_DWORD   imac_end          = 0; 
    DRM_DWORD   segment_end       = 0; 
    DRM_DWORD   imac_in_seg_start = 0; 
    DRM_DWORD   imac_in_seg_end   = 0;
    
    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMCIPHER, PERF_FUNC_DRM_CPHR_Decrypt);
    
    ChkArg( f_pbData   != NULL );
    ChkArg( f_pContext != NULL );
    ChkArg( f_cbData   >  0 );

    ChkBOOL( f_pContext->fInited, DRM_E_CIPHER_NOTINITIALIZED );    

    /*
    ** RC4 Decryption:
    */
    if ( f_pContext->eCipherType == eDRM_RC4_CIPHER ) 
    {        
        ChkBOOL( f_pContext->cipher.cipherRC4.fDecryptInited, DRM_E_DECRYPT_NOTINITIALIZED );

        ChkArg( ( f_pContext->cipher.cipherRC4.iPacket + f_cbData ) 
             <= f_pContext->cipher.cipherRC4.cbPacket );
        ChkOverflow ( ( f_pContext->cipher.cipherRC4.iPacket + f_cbData ), 
                      f_pContext->cipher.cipherRC4.iPacket );        

        if ( f_cbData == 0 )
        {
            goto ErrorExit;
        }
        
        /*
        **  small packet case: MAC does not handle it
        */
        if ( f_pContext->cipher.cipherRC4.cbPacket < 16 )
        {
            DRM_DWORD iData = 0;
            for ( iData = 0; iData < f_cbData; iData++ )
            {
                DRM_BYTE bSHA = GET_BYTE( f_pContext->cipher.cipherRC4.shaOut,
                                          iData + f_pContext->cipher.cipherRC4.iPacket );
                DRM_BYTE bData = GET_BYTE( f_pbData, iData );

                PUT_BYTE( f_pbData, iData, bData ^ bSHA );
            }
            
            f_pContext->cipher.cipherRC4.iPacket += f_cbData;
            goto ErrorExit;
        }   

        imac_end    = ( f_pContext->cipher.cipherRC4.cbPacket / 8 ) * 8;
        imac_start  = imac_end - 8;
        segment_end = f_pContext->cipher.cipherRC4.iPacket + f_cbData;

        if ( segment_end > imac_start ) 
        {
            /* 
            ** NOTE:  To remove complexity we do not handle the case where
            ** a packet is split somewhere in the middle of the last 15 bytes 
            */
            DRMASSERT( segment_end == f_pContext->cipher.cipherRC4.cbPacket );

            /*
            ** Set the last 8 bytes correctly 
            */
            DRM_BYT_CopyBytes( f_pbData,
                               imac_start - f_pContext->cipher.cipherRC4.iPacket,
                               ( DRM_BYTE* )f_pContext->cipher.cipherRC4.rguiLast8, 
                               0, 
                               2 * SIZEOF( DRM_UINT ) );
        }

        /*
        **  RC4 decrypt the content
        */
        DRM_RC4_Cipher( &f_pContext->cipher.cipherRC4.rc4ks, f_cbData, f_pbData );
        
        if ( f_pContext->cipher.cipherRC4.iPacket < imac_start ) 
        {
            ChkOverflow( f_pContext->cipher.cipherRC4.iPacket + f_cbData,
                         f_pContext->cipher.cipherRC4.iPacket );
            
            if ( f_pContext->cipher.cipherRC4.iPacket + f_cbData >= imac_start ) 
            {
                DRM_UINT mac1 = 0;
                DRM_UINT mac2 = 0;
                DRM_UINT macInverse1 = 0;
                DRM_UINT macInverse2 = 0;

                /* Try to make Prefix happy. */
                ChkOverflow( ( imac_start - f_pContext->cipher.cipherRC4.iPacket ) * 8,
                             imac_start - f_pContext->cipher.cipherRC4.iPacket );

                /*
                **  First update MAC with data from this segment
                */            
                DRM_CBC64Update( &f_pContext->cipher.cipherRC4.mackey, 
                             &f_pContext->cipher.cipherRC4.cbcstate, 
                             imac_start - f_pContext->cipher.cipherRC4.iPacket, 
                             f_pbData );
                
                /*
                **  Finalize MAC to decipher last 8 bytes of encrypted data 
                */
                mac1 = DRM_CBC64Finalize( &f_pContext->cipher.cipherRC4.mackey, 
                                      &f_pContext->cipher.cipherRC4.cbcstate, 
                                      &mac2 );
                macInverse2 = DRM_CBC64Invert( &f_pContext->cipher.cipherRC4.mackey, 
                                           &f_pContext->cipher.cipherRC4.invmackey, 
                                           mac1, 
                                           mac2, 
                                           f_pContext->cipher.cipherRC4.rc4key[0], 
                                           f_pContext->cipher.cipherRC4.rc4key[1], 
                                           &macInverse1 );
                f_pContext->cipher.cipherRC4.rc4key[0] = macInverse1; 
                f_pContext->cipher.cipherRC4.rc4key[1] = macInverse2;
            }
            else 
            {
                /*
                **  Update MAC with data from this segment
                */             
                DRM_CBC64Update( &f_pContext->cipher.cipherRC4.mackey, 
                             &f_pContext->cipher.cipherRC4.cbcstate, 
                             f_cbData, 
                             f_pbData );
            }
        }
             
        if ( f_pContext->cipher.cipherRC4.iPacket < imac_end 
          && segment_end > imac_start ) 
        {
            /*
            **  Insert last 8 bytes of data deciphered
            */        
            DRM_BYTE  rgbMac[__CB_DECL( 8 )];
            DRM_DWORD iData = 0;
            
            DWORD_TO_BYTES( rgbMac,                f_pContext->cipher.cipherRC4.rc4key[0] );
            DWORD_TO_BYTES( rgbMac + __CB_DECL( 4 ), f_pContext->cipher.cipherRC4.rc4key[1] );

            imac_in_seg_start = ( imac_start >= f_pContext->cipher.cipherRC4.iPacket ) ? 
                                                imac_start : f_pContext->cipher.cipherRC4.iPacket;
            imac_in_seg_end = ( imac_end <= segment_end ) ? imac_end:segment_end;
            
            for ( iData = imac_in_seg_start; iData < imac_in_seg_end; iData++ ) 
            {
                PUT_BYTE( f_pbData, 
                          iData - f_pContext->cipher.cipherRC4.iPacket, 
                          GET_BYTE( rgbMac, iData - imac_start ) );
            }
        }    

        f_pContext->cipher.cipherRC4.iPacket += f_cbData;
        if ( f_pContext->cipher.cipherRC4.iPacket >= f_pContext->cipher.cipherRC4.cbPacket )
        {
            f_pContext->cipher.cipherRC4.fDecryptInited = FALSE;
        }
    }    
    /*
    ** AES Counter-mode decryption:
    */
    else
    {
        ChkArg( f_pContext->eCipherType == eDRM_AES_COUNTER_CIPHER );
        ChkArg( f_pCtrContext           != NULL );

        ChkDR( DRM_Aes_CtrProcessData( &f_pContext->cipher.cipherAES.aesKey,
                                       f_pbData,
                                       f_cbData,
                                       f_pCtrContext ) );        
    }

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/*********************************************************************
**
**  Function:  DRM_CPHR_Encrypt
**
**  Synopsis:  Encrypts an array of bytes using a DRM content cipher algorithm
**
**  Arguments:  
**     f_pContext     : Cipher context initialized with DRM_CPHR_Init
**     f_pCtrContext  : Sets and maintains the 
**                      initialization vector and counter 
**                      for AES CTR mode. Must be 
**                      specified for AES decryption, and
**                      ignored for Cocktail.
**     f_cbData       : Length of f_pbData in bytes
**     f_pbData       : Array of bytes to encrypt
**
**  Returns:
**      DRM_SUCCESS
**          success
**      DRM_E_INVALIDARG
**          f_pbData or f_pContext is null or the data has an invalid byte count
**          for AES ECB-mode cipher
**      DRM_E_CIPHER_NOTINITIALIZED
**          f_pContext was not appropriately initialized
**      DRM_E_CRYPTO_FAILED
**          The encrypt/decrypt operation failed
**      DRM_E_ARITHMETIC_OVERFLOW
**          An overflow/underflow occurred while processing the data
**
**  Notes:  Encryption is done in place.
**
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_CPHR_Encrypt(
    __inout_ecount( 1 )         DRM_CIPHER_CONTEXT           *f_pContext,
    __inout_opt                 DRM_AES_COUNTER_MODE_CONTEXT *f_pCtrContext,
    __in                        DRM_DWORD                     f_cbData, 
    __inout_bcount( f_cbData )  DRM_BYTE                     *f_pbData )
{
    DRM_RESULT dr            = DRM_SUCCESS;
    DRM_UINT   macLength4    = 0;       /* mac length in four byte blocks */
    DRM_DWORD  rc4key    [2] = { 0 };
    DRM_DWORD  rguiLast8 [2] = { 0 };    

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMCIPHER, PERF_FUNC_DRM_CPHR_Encrypt);

    ChkArg( f_pbData   != NULL );
    ChkArg( f_pContext != NULL );   

    ChkBOOL( f_pContext->fInited, DRM_E_CIPHER_NOTINITIALIZED );

    /*
    ** RC4/Cocktail Encrypt:
    */
    if ( f_pContext->eCipherType == eDRM_RC4_CIPHER )
    {
        /*
        ** small packet case: MAC does not handle it 
        */
        if ( f_cbData < 16 )
        {        
            for ( rc4key[0] = 0; rc4key[0] < f_cbData; rc4key[0]++ )
            {
                DRM_BYTE bTemp = GET_BYTE( f_pbData, rc4key[0] );
                bTemp ^= GET_BYTE( f_pContext->cipher.cipherRC4.shaOut, rc4key[0] );
                PUT_BYTE( f_pbData, rc4key[0], bTemp );
            }        
        }
        else
        {
            /*
            ** making sure block number is even 
            */
            macLength4 = ( f_cbData / 8 ) * 2; 
            MEMCPY( rguiLast8, 
                   ( f_pbData + __CB_DECL( 4 * macLength4 - 8 )), 
                   NO_OF( rguiLast8 ) * SIZEOF( DRM_UINT ) );
            
            /*
            ** run MAC over data 
            */
            DRM_CBC_Mac( f_pbData, macLength4, rc4key, &( f_pContext->cipher.cipherRC4.mackey ) );

            /*
            ** RC4 encrypt content 
            */
            FIX_ENDIAN_DWORD( rc4key[0] );
            FIX_ENDIAN_DWORD( rc4key[1] );

            DRM_RC4_KeySetup( &f_pContext->cipher.cipherRC4.rc4ks, 8, ( DRM_BYTE * )rc4key );                
            DRM_RC4_Cipher(   &f_pContext->cipher.cipherRC4.rc4ks, f_cbData, f_pbData );
            FIX_ENDIAN_DWORD( rc4key[0] );
            FIX_ENDIAN_DWORD( rc4key[1] );
            
            /*
            ** DES encrypt MAC and put it in the right place 
            */
            rc4key[0] ^= f_pContext->cipher.cipherRC4.desS1[0];
            rc4key[1] ^= f_pContext->cipher.cipherRC4.desS1[1];
            
            FIX_ENDIAN_DWORD( rc4key[0] );
            FIX_ENDIAN_DWORD( rc4key[1] );
            DRM_DES_Encrypt( ( DRM_BYTE * )rc4key, 
                             ( DRM_BYTE* )rguiLast8, 
                              &f_pContext->cipher.cipherRC4.destable );
            
            FIX_ENDIAN_DWORD( rguiLast8[0] );
            FIX_ENDIAN_DWORD( rguiLast8[1] );
            rguiLast8[0] ^= f_pContext->cipher.cipherRC4.desS2[0];
            rguiLast8[1] ^= f_pContext->cipher.cipherRC4.desS2[1];
            DWORD_TO_BYTES( ( f_pbData + __CB_DECL( 4 * macLength4 - 8 ) ), rguiLast8[0] );
            DWORD_TO_BYTES( ( f_pbData + __CB_DECL( 4 * macLength4 - 4 ) ), rguiLast8[1] );
        }
    }    
    /*
    ** Counter-Mode AES Encrypt:
    */
    else
    {
        ChkArg( f_pContext->eCipherType == eDRM_AES_COUNTER_CIPHER );
        ChkArg( f_pCtrContext          != NULL );
        
        ChkDR( DRM_Aes_CtrProcessData( &f_pContext->cipher.cipherAES.aesKey,
                                       f_pbData,
                                       f_cbData,
                                       f_pCtrContext ) );
    }

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmdebug.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>

ENTER_PK_NAMESPACE_CODE;

DRM_VOID drmtype_asserts(void)
{
    DRMSIZEASSERT(sizeof(DRM_BYTE), 1);
    DRMSIZEASSERT(sizeof(DRM_CHAR), 1);
#if SIXTEEN_BIT_ADDRESSING
    DRMSIZEASSERT(sizeof (DRM_SHORT), 1);
    DRMSIZEASSERT(sizeof (DRM_WORD),  1);
    DRMSIZEASSERT(sizeof (DRM_UINT),  2);
    DRMSIZEASSERT(sizeof (DRM_INT),   2);
    DRMSIZEASSERT(sizeof (DRM_LONG),  2);
    DRMSIZEASSERT(sizeof (DRM_DWORD), 2);
    DRMSIZEASSERT(sizeof (DRM_INT64), 4);
#else
    DRMSIZEASSERT(sizeof (DRM_SHORT), 2);
    DRMSIZEASSERT(sizeof (DRM_WORD),  2);
    DRMSIZEASSERT(sizeof (DRM_UINT),  4);
    DRMSIZEASSERT(sizeof (DRM_INT),   4);
    DRMSIZEASSERT(sizeof (DRM_LONG),  4);
    DRMSIZEASSERT(sizeof (DRM_DWORD), 4);
    DRMSIZEASSERT(sizeof (DRM_INT64), 8);
#endif    
}





EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmcrt.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmcrt.h>
#include <byteorder.h>

ENTER_PK_NAMESPACE_CODE;

/* String CRT functions */

#if !NO_DRM_CRT

DRM_API DRM_INT DRM_CALL DRMCRT_wcsncmp(
    __in_ecount( count ) const DRM_WCHAR *first,
    __in_ecount( count ) const DRM_WCHAR *last,
    IN       DRM_SIZE_T  count )
{
    if (!count)
    {
        return(0);
    }

    while (--count && *first && *first == *last)
    {
        first++;
        last++;
    }

    return((DRM_INT)(*first - *last));
}

DRM_API DRM_SIZE_T DRM_CALL DRMCRT_wcslen(
    __in_z const DRM_WCHAR *wsz )
{
    const DRM_WCHAR *eos = wsz;
    while( *eos )
    {
        eos++;
    }
    return( (DRM_SIZE_T)(eos - wsz) );
}

DRM_API DRM_INT DRM_CALL DRMCRT_strncmp (
    __in_ecount( count ) const DRM_CHAR  *first,
    __in_ecount( count ) const DRM_CHAR  *last,
    IN       DRM_SIZE_T  count)
{
    if (!count)
    {
        return(0);
    }

    while (--count && *first && *first == *last)
    {
        first++;
        last++;
    }

    return((DRM_INT)(*first - *last));
}


DRM_API DRM_BOOL DRM_CALL DRMCRT_iswxdigit (DRM_WCHAR f_wch)
{
    DRM_WCHAR wch = NATIVE_WCHAR( f_wch );
    return ((wch >= NATIVE_WCHAR(g_wch0) && wch <= NATIVE_WCHAR(g_wch9))   /* A digit */ 
        ||  (wch >= NATIVE_WCHAR(g_wchA) && wch <= NATIVE_WCHAR(g_wchF))   /* Upper case hex char */ 
        ||  (wch >= NATIVE_WCHAR(g_wcha) && wch <= NATIVE_WCHAR(g_wchf))); /* lower case hex char */
}

DRM_API DRM_BOOL DRM_CALL DRMCRT_iswdigit( DRM_WCHAR wch )
{
    return ( NATIVE_WCHAR(wch) >= NATIVE_WCHAR(g_wch0) 
          && NATIVE_WCHAR(wch) <= NATIVE_WCHAR(g_wch9) ); /* A digit */
}
DRM_API DRM_BOOL DRM_CALL DRMCRT_iswalpha (DRM_WCHAR wch)
{
    return ((NATIVE_WCHAR(wch) >= NATIVE_WCHAR(g_wchA) && NATIVE_WCHAR(wch) <= NATIVE_WCHAR(g_wchZ))   /* Upper case char */
         || (NATIVE_WCHAR(wch) >= NATIVE_WCHAR(g_wcha) && NATIVE_WCHAR(wch) <= NATIVE_WCHAR(g_wchz))); /* lower case char */
}

DRM_API DRM_WCHAR DRM_CALL DRMCRT_towlower (DRM_WCHAR wch)
{
    if (DRMCRT_iswalpha (wch)
    &&   NATIVE_WCHAR(wch) < NATIVE_WCHAR(g_wcha))
    {
        DRM_WCHAR wchTemp = NATIVE_WCHAR(g_wcha) - NATIVE_WCHAR(g_wchA);
        wch = NATIVE_WCHAR(wch) + wchTemp;
        wch = WCHAR_CAST( wch );
    }

    return wch;
}

DRM_API DRM_BOOL DRM_CALL DRMCRT_iswspace (DRM_WCHAR wch)
{
    return (NATIVE_WCHAR(wch) == NATIVE_WCHAR(g_wchTab)
         || NATIVE_WCHAR(wch) == NATIVE_WCHAR(g_wchLineFeed)
         || NATIVE_WCHAR(wch) == NATIVE_WCHAR(g_wchVerticalTab)
         || NATIVE_WCHAR(wch) == NATIVE_WCHAR(g_wchFormFeed)
         || NATIVE_WCHAR(wch) == NATIVE_WCHAR(g_wchCarriageReturn)
         || NATIVE_WCHAR(wch) == NATIVE_WCHAR(g_wchSpace));
}

DRM_API DRM_SIZE_T DRM_CALL DRMCRT_strlen(
    __in_z const DRM_CHAR *sz )
{
    const DRM_CHAR *eos = sz;
    while( *eos )
    {
        eos++;
    }
    return( (DRM_SIZE_T)(eos - sz) );
}

/*******************************************************************************
*memmove - Copy source buffer to destination buffer
*
*Purpose:
*       memmove() copies a source memory buffer to a destination memory buffer.
*       This routine recognize overlapping buffers to avoid propogation.
*       For cases where propogation is not a problem, memcpy() can be used.
*
*Entry:
*       void *dst = pointer to destination buffer
*       const void *src = pointer to source buffer
*       size_t count = number of bytes to copy
*
*Exit:
*       Returns a pointer to the destination buffer
*
*Exceptions:
*******************************************************************************/

DRM_API DRM_VOID * DRM_CALL DRMCRT_memmove (
    __out_bcount( count ) DRM_VOID  *dst,
    __in_bcount( count ) const DRM_VOID  *src,
    IN       DRM_SIZE_T count )
{
        DRM_VOID * ret = dst;

        if (dst <= src || (DRM_CHAR *)dst >= ((DRM_CHAR *)src + count)) {
                /*
                 * Buffers don't overlap in a way that would cause problems
                 * copy from lower addresses to higher addresses
                 */
                while (count--) {
                        *(DRM_CHAR *)dst = *(DRM_CHAR *)src;
                        dst = (DRM_CHAR *)dst + 1;
                        src = (DRM_CHAR *)src + 1;
                }
        }
        else {
                /*
                 * Overlapping Buffers
                 * copy from higher addresses to lower addresses
                 */
                dst = (DRM_CHAR *)dst + count - 1;
                src = (DRM_CHAR *)src + count - 1;

                while (count--) {
                        *(DRM_CHAR *)dst = *(DRM_CHAR *)src;
                        dst = (DRM_CHAR *)dst - 1;
                        src = (DRM_CHAR *)src - 1;
                }
        }

        return(ret);
}

DRM_API DRM_VOID DRM_CALL DRMCRT_memcpy(
    __out_bcount( count ) DRM_VOID  *dst,
    __in_bcount( count ) const DRM_VOID  *src,
    IN       DRM_SIZE_T  count )
{
    while( count > 0 )
    {
        *(DRM_BYTE*)dst = *(DRM_BYTE*)src;
        dst = (DRM_CHAR *)dst + 1;
        src = (DRM_CHAR *)src + 1;
        count--;
    }
}

DRM_API DRM_VOID DRM_CALL DRMCRT_memset(
    __out_bcount( count ) DRM_VOID  *dst,
    IN       DRM_DWORD   b,
    IN       DRM_SIZE_T  count )
{
    /*
    ** b is a DRM_DWORD to be consistent with standard memset
    ** but we only use the low order byte
    */
    DRM_BYTE by = b & 0xFF;

    //
    // Xbox LIVE specific: disabling conversion warning (C4296) after review.
    //
    #pragma warning( disable:4296 )
    DRMASSERT( b >= 0x00 && b <= 0xFF );
    #pragma warning( default:4296 )
    //
    // End Xbox LIVE specific
    //

    while( count > 0 )
    {
        *(DRM_BYTE*)dst = by;
        dst = (DRM_CHAR *)dst + 1;
        count--;
    }
}

DRM_API DRM_INT DRM_CALL DRMCRT_memcmp(
    __in_bcount( count ) const DRM_VOID  *src1,
    __in_bcount( count ) const DRM_VOID  *src2,
    IN       DRM_SIZE_T  count )
{
    while( count > 0 )
    {
        if( *(DRM_BYTE*)src1 > *(DRM_BYTE*)src2 )
        {
            return 1;
        }
        else if( *(DRM_BYTE*)src1 < *(DRM_BYTE*)src2 )
        {
            return -1;
        }
        src1 = (DRM_CHAR *)src1 + 1;
        src2 = (DRM_CHAR *)src2 + 1;
        count--;
    }
    return 0;
}

DRM_API DRM_INT DRM_CALL DRMCRT_abs( DRM_INT number )
{
    return (number>=0 ? number : -number);
}

#endif /* #ifndef NO_DRM_CRT */

/*****************************************************************************
** Function:    _DRMCRT_ASCIIToByteValue
**
** Synopsis:    Converts ASCII character to numeric value.
**
** Arguments:   [f_chAscii]   : ASCII character. 
**              [f_pdwVal]    : Address of byte variable for the value.

** Returns:     TRUE    - on success
**              FALSE   - if character is not numeric or hex digit.
******************************************************************************/

static DRM_BOOL _DRMCRT_ASCIIToByteValue( IN DRM_CHAR f_chAscii, OUT DRM_BYTE *f_pdwVal )
{
    DRM_BOOL bVal = TRUE;
    
    if ( f_pdwVal == NULL )
    {
        bVal = FALSE;
        goto ErrorExit;
    }

    /* Base 10 digit */
    if ( '0' <= f_chAscii  &&  f_chAscii <= '9' )
    {  
        *f_pdwVal = f_chAscii - '0';
        goto ErrorExit;
    }

    /* Capital HEX digit - A,B,C,D,E,F */
    if ( 'A' <= f_chAscii  &&  f_chAscii <= 'F' )
    {   
        *f_pdwVal = f_chAscii - 'A' + 10;
        goto ErrorExit;
    }
    /* lower case hex digit - a,b,c,d,e,f */
    if ( 'a' <= f_chAscii  &&  f_chAscii <= 'f' )
    {   
        *f_pdwVal = f_chAscii - 'a' + 10;
        goto ErrorExit;
    }
    
    /* Unknown character, return FALSE */
    bVal = FALSE;

ErrorExit :
    return bVal;
}


/*****************************************************************************
** Function:    _DRMCRT_WCHARToByteValue
**
** Synopsis:    Converts WCHAR character to numeric value.
**
** Arguments:   [f_wch]       : WCHAR character. 
**              [f_dwBase]    : base for conversion. Should be 10 or 16
**              [f_pdwVal]    : Address of byte variable for the value.

** Returns:     TRUE    - on success
**              FALSE   - if character is not numeric or hex digit.
******************************************************************************/

static DRM_BOOL _DRMCRT_WCHARToByteValue( 
   __in const         DRM_WCHAR f_wch, 
   __in const         DRM_DWORD f_dwBase, 
   __out_bcount( 1 )  DRM_BYTE *f_pdwVal )
{
    /*
     * assume a non-numeric/hex value
     */
    DRM_BOOL bVal = FALSE;
    
    if ( f_pdwVal == NULL || ( f_dwBase != 10 && f_dwBase != 16 ) )
    {
        /*
         * Invalid argument.
        */
        goto ErrorExit;
    }

    /* Base 10 digit */
    if ( DRMCRT_iswdigit( f_wch ) )
    {  
        *f_pdwVal = NATIVE_WCHAR( f_wch ) - NATIVE_WCHAR( g_wch0 );
        bVal = TRUE;
        goto ErrorExit;
    }

    if ( f_dwBase == 16 )
    {
        /* Capital HEX digit - A,B,C,D,E,F */
        if (    NATIVE_WCHAR( f_wch ) >= NATIVE_WCHAR(g_wchA) 
             && NATIVE_WCHAR( f_wch ) <= NATIVE_WCHAR(g_wchF) )
        {   
            *f_pdwVal = NATIVE_WCHAR( f_wch ) - NATIVE_WCHAR( g_wchA ) + 10;
            bVal = TRUE;
            goto ErrorExit;
        }
        /* lower case hex digit - a,b,c,d,e,f */
        if (    NATIVE_WCHAR( f_wch ) >= NATIVE_WCHAR(g_wcha) 
             && NATIVE_WCHAR( f_wch ) <= NATIVE_WCHAR(g_wchf)  )
        {   
            *f_pdwVal = NATIVE_WCHAR( f_wch ) - NATIVE_WCHAR( g_wcha ) + 10;
            bVal = TRUE;
            goto ErrorExit;
        }
    }

ErrorExit :
    return bVal;
}


static DRM_RESULT DRMCRT_wcsrev( __inout_ecount( cchString )  DRM_WCHAR *pwszStr, IN DRM_DWORD cchString ) 

{    
    DRM_RESULT  dr          = DRM_SUCCESS;
    DRM_DWORD   SmallIndex  = 0;
    /* BigIndex is offset of last character */
    DRM_DWORD BigIndex   = cchString - 1;
    
    ChkArg( pwszStr != NULL 
        && cchString > 0 );

    /* SSmallIndex goes up, BigIndex down. Exchange characters until they meet */
    while ( SmallIndex < BigIndex ) 
    {   
        /* Exchange characters */  
        DRM_WCHAR Temp = pwszStr[SmallIndex];
        pwszStr[SmallIndex] = pwszStr[BigIndex];
        pwszStr[BigIndex] = Temp;
        /* Small index up, big index down */
        SmallIndex++;
        BigIndex--;
    }
ErrorExit:
    
    return dr;
}

/*****************************************************************************
** Function:    DRMCRT_AtoDWORD
**
** Synopsis:    Consverts ASCII string with numeric value to DWORD.
**
** Arguments:   [f_pszStringInput]   : pointer to string with data
**              [f_cchStringInput]   : count of characters in string
**              [f_base]             : base for conversion. Should be 10 or 16
                [f_pdwValue]         : address of DWORD for converted value

** Returns:     DRM_SUCCESS                 - on success
**              DRM_E_ARITHMETIC_OVERFLOW   - if converted value does not fit into DWORD.
******************************************************************************/

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRMCRT_AtoDWORD( 
    __in_ecount( f_cchStringInput ) const DRM_CHAR  *f_pszStringInput,  
    IN       DRM_DWORD  f_cchStringInput,
    IN       DRM_DWORD  f_base,
    OUT      DRM_DWORD *f_pdwValue )

{   DRM_RESULT dr           = DRM_SUCCESS;
    DRM_BYTE   bNextDigit   = 0;
    DRM_DWORD  dwIndex      = 0;

    ChkArg( f_pszStringInput != NULL );         /* String must be present */
    ChkArg( f_cchStringInput >  0 );            /* At least one character */
    ChkArg( f_base == 10 || f_base == 16 );     /* Convert only decimal or hex numbers */
    ChkArg( f_pdwValue != NULL );               /* Address for output varible must be present */

    /*
    ** If base is 16, then the string may start with 0x or 0X. Skip it.
    */
    if (        f_base == 16 
            &&  f_cchStringInput > 2                                            
            &&  f_pszStringInput[0] == '0' 
            &&  ( f_pszStringInput[1] == 'x' || f_pszStringInput[1] == 'X' )    )
    {
        f_pszStringInput += 2;
        f_cchStringInput -= 2;
    }
    
    *f_pdwValue = 0;
    for( dwIndex = 0; dwIndex < f_cchStringInput && _DRMCRT_ASCIIToByteValue( f_pszStringInput[dwIndex], &bNextDigit ); dwIndex++ )
    {   
        DRM_DWORD dwNewValue = *f_pdwValue * f_base  +  bNextDigit;
        
        if ( ( dwNewValue - bNextDigit ) / f_base != *f_pdwValue )
        {
            ChkDR( DRM_E_ARITHMETIC_OVERFLOW )
        }

        /* Continue with next digit */
        *f_pdwValue = dwNewValue;
    }

ErrorExit :
    return dr;
}

/*****************************************************************************
** Function:    DRMCRT_WtoDWORD
**
** Synopsis:    Consverts WCHAR string with numeric value to DWORD.
**
** Arguments:   [f_pwszStringInput]  : pointer to string with data
**              [f_cchStringInput]   : count of characters in string
**              [f_dwBase]           : base for conversion. Should be 10 or 16
**              [f_pdwValue]         : address of DWORD for converted value
**
** Returns:     DRM_SUCCESS                 - on success
**              DRM_E_ARITHMETIC_OVERFLOW   - if converted value does not fit into DWORD.
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRMCRT_WtoDWORD( 
    __in_ecount( f_cchStringInput ) const DRM_WCHAR *f_pwszStringInput,
    __in                                  DRM_DWORD  f_cchStringInput,
    __in                                  DRM_DWORD  f_dwBase,
    __out                                 DRM_DWORD *f_pdwValue )
{
    DRM_RESULT dr           = DRM_SUCCESS;
    DRM_BYTE   bNextDigit   = 0;
    DRM_DWORD  dwIndex      = 0;
    DRM_DWORD  dwNewValue   = 0;

    ChkArg( f_pwszStringInput != NULL );         /* String must be present */
    ChkArg( f_cchStringInput >  0 );             /* At least one character */
    ChkArg( f_dwBase == 10 || f_dwBase == 16 );  /* Convert only decimal or hex numbers */
    ChkArg( f_pdwValue != NULL );                /* Address for output varible must be present */

    /*
    ** If base is 16, then the string may start with 0x or 0X. Skip it.
    */
    if (        f_dwBase == 16 
            &&  f_cchStringInput > 2                                            
            &&  f_pwszStringInput[0] == g_wch0 
            &&  ( f_pwszStringInput[1] == g_wchx || f_pwszStringInput[1] == g_wchX )    )
    {
        f_pwszStringInput += 2;
        f_cchStringInput -= 2;
    }

    *f_pdwValue = 0;
    for( dwIndex = 0; 
         dwIndex < f_cchStringInput && _DRMCRT_WCHARToByteValue( f_pwszStringInput[dwIndex], f_dwBase, &bNextDigit );
         dwIndex++ )
    {
        dwNewValue = *f_pdwValue * f_dwBase  +  bNextDigit;
        
        if ( ( dwNewValue - bNextDigit ) / f_dwBase != *f_pdwValue )
        {
            ChkDR( DRM_E_ARITHMETIC_OVERFLOW )
        }

        /* 
        ** Continue with next digit 
        */
        *f_pdwValue = dwNewValue;
    }

ErrorExit :
    return dr;
}


DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRMCRT_wcsntol( 
    __in_ecount( cchStringInput ) const DRM_WCHAR *pwszStringInput,
    IN       DRM_DWORD  cchStringInput,
    OUT      DRM_LONG  *plValue )
{    
    DRM_CONST_STRING wszString;
    DRM_DWORD lMaxVal    = ULONG_MAX / 10;
    DRM_DWORD lNextDigit = 0;
    DRM_DWORD lValue     = 0;
    DRM_BOOL fPositive   = TRUE;

    if( NULL == plValue || 
        NULL == pwszStringInput ||
        0 == cchStringInput )
    {
        return DRM_E_INVALIDARG;
    }

    if( pwszStringInput[0] == g_wchMinus || pwszStringInput[0] == g_wchPlus )
    {
        if( pwszStringInput[0] == g_wchMinus )
        {
            fPositive = FALSE;
        }
        pwszStringInput++;
        cchStringInput--;
    }

    wszString.pwszString = pwszStringInput;
    wszString.cchString = cchStringInput;    
    *plValue = 0;

    while( wszString.cchString > 0 && DRMCRT_iswdigit( *( wszString.pwszString ) ) )
    {

        lNextDigit = (NATIVE_WCHAR(*(wszString.pwszString)) - NATIVE_WCHAR(g_wch0));
        if( lValue < lMaxVal || 
            ( lValue == lMaxVal && lNextDigit <= ULONG_MAX % 10 ) )
        {
            lValue = lValue * 10 + lNextDigit;            
        }
        else
        {            
            return DRM_E_ARITHMETIC_OVERFLOW;
        }
        wszString.pwszString++;
        wszString.cchString--;
    }

    if( lValue & 0x80000000 )
    {
        /* The high bit is set.  */
        if( lValue == 0x80000000 && !fPositive )
        {
            /* Special case */
            *plValue = lValue;
        }
        else
        {
            /* This is fine for an unsigned long, but means we really have overflowed to return a signed long */
            return DRM_E_ARITHMETIC_OVERFLOW;
        }       
    }
    else    
    {
        *plValue = lValue;
        if( !fPositive )
        {
           *plValue *= -1;
        }
    }

    return DRM_SUCCESS;
}

DRM_API DRM_WCHAR* DRM_CALL DRMCRT_wcsnstr
(
   __in_ecount( cchMaxStr ) const DRM_WCHAR *pwszStr,
   IN       DRM_DWORD  cchMaxStr,
   __in_ecount( cchMaxStrSearch ) const DRM_WCHAR *pwszStrSearch, 
   IN       DRM_DWORD  cchMaxStrSearch
)
{  
    DRM_WCHAR *pwszRetVal    = NULL;
    DRM_DWORD i              = 0;

    /* Check Arguments */
    if ( pwszStr == NULL  ||
         pwszStrSearch == NULL || 
         cchMaxStr == 0 ||
         cchMaxStrSearch == 0 )
    { 
        goto ErrorExit;
    }

    /* Get the length of the string to search for */
    while( i < cchMaxStrSearch )
    {
        if( pwszStrSearch[i] == NULL )
            break;
        i++;
    }
    cchMaxStrSearch = i;

    
    /* Now search */
    for ( ; cchMaxStrSearch <= cchMaxStr; pwszStr++, cchMaxStr-- )
    {   
       if ( 0 == DRMCRT_wcsncmp( pwszStrSearch, pwszStr, cchMaxStrSearch ) )
       { 
           pwszRetVal = (DRM_WCHAR*)pwszStr; 
            break;
       }
    }

ErrorExit :   
    return pwszRetVal;
}



EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmdatastore.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmdatastore.h>
#include <drmhds.h>
#include <drmembeddedstore.h>

ENTER_PK_NAMESPACE_CODE;


/**********************************************************************
** Function:    DRM_DST_Init
**
** Synopsis:    Initializes a Data Store Context for a given implementation type.
**
** Arguments:   
**      [f_eImplementationType] - Specifies a supported implementation type.
**      [f_pDSTContext]         - Specifies the DST Context.
**      [f_cbDSTContext]        - Specifies the actual size of f_pDSTContext in bytes.
**                                The actual context may be smaller than DRM_DST_CONTEXT_LEN,
**                                depending on the implementation.
**      [f_pDST]                - Returns the initialized data store.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
** Notes:       The function MUST be called in the main thread BEFORE
**              any of the child thread(s) starting sharing the same 
**              context. If this function is called after the child
**              thread(s) started, the result is undefined.
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DST_Init ( 
    __in                          DRM_DST_IMPLEMENTATION_TYPE       f_eImplementationType, 
    __in_bcount( f_cbDSTContext ) DRM_DST_CONTEXT                  *f_pDSTContext,
    __in                          DRM_DWORD                         f_cbDSTContext,
    __out                         DRM_DST                          *f_pDST )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pDST != NULL );
    ChkArg( f_pDSTContext != NULL );

    f_pDST->poContextDST = f_pDSTContext;
        
    switch ( f_eImplementationType )
    {
    case eDRM_DST_HDS:
        ChkArg( f_cbDSTContext >= DRM_HDS_CONTEXT_LEN );
        ChkDR( DRM_HDS_InitializeDST( f_pDST ) );
        break;
    case eDRM_DST_EMBEDDED:
        ChkArg( f_cbDSTContext >= DRM_EST_CONTEXT_LEN );
        ChkDR( DRM_EST_InitializeDST( f_pDST ) );
        break;
    case eDRM_DST_NONE:
    default:
        return DRM_E_NOTIMPL;
    }

    ChkBOOL( f_pDST->oDataStoreInterface.pfnInit != NULL, DRM_E_INVALIDARG );
    ChkDR( f_pDST->oDataStoreInterface.pfnInit( f_pDST->poContextDST ) );
ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_DST_Uninit
**
** Synopsis:    Uninitializes a Data Store.
**
** Arguments:   
**      [f_pDST] - Specifies the data store to uninitialize.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.

**
** Notes:       This function MUST be called in the main thread AFTER
**              any of the child thread(s) sharing the same context 
**              stopped. If this function is called before the child
**              thread(s) stopped, the result is undefined.
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DST_Uninit ( __inout DRM_DST *f_pDST )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pDST != NULL );
    ChkBOOL( f_pDST->oDataStoreInterface.pfnUninit != NULL, DRM_E_INVALIDARG );
    ChkDR( f_pDST->oDataStoreInterface.pfnUninit( f_pDST->poContextDST ) );

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_DST_CreateStore
**
** Synopsis:    Creates a data store.
**
** Arguments:   
**      [f_pvOEMContext]   - Optional pointer to OEM-specific context.
**      [f_pbStoreData]    - Specifies store initialization data.
**      [f_cbStoreData]    - Specifies the length of f_pbStoreData.
**      [f_dwBlockSize]    - Specifies the block size for the store.
**      [f_eBlkNumType]    - Specifies a block numbering type for the store.
**      [f_fTruncateExist] - Specifies whether to truncate an existing store at this location.
**      [f_dwInitSizeInKB] - Specifies the initial size of the data store in KB.
**      [f_pDST]           - Returns the updated data store.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DST_CreateStore ( 
    __in_opt                           DRM_VOID          *f_pbOEMContext,
    __in_bcount( f_cbStoreData ) const DRM_BYTE          *f_pbStoreData,
    __in                               DRM_DWORD          f_cbStoreData,
    __in                         const DRM_DWORD          f_dwBlockSize,
    __in                               DRM_DST_BLKNUMTYPE f_eBlNumType,
    __in                               DRM_BOOL           f_fTruncateExist,
    __in                         const DRM_DWORD          f_dwInitSizeInKB,
    __inout                            DRM_DST            *f_pDST )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pDST != NULL );
    ChkBOOL( f_pDST->oDataStoreInterface.pfnCreateStore != NULL, DRM_E_INVALIDARG );
    ChkDR( f_pDST->oDataStoreInterface.pfnCreateStore( f_pbOEMContext,
                                                       f_pbStoreData,
                                                       f_cbStoreData,
                                                       f_dwBlockSize,
                                                       f_eBlNumType,
                                                       f_fTruncateExist,
                                                       f_dwInitSizeInKB,
                                                       f_pDST->poContextDST ) );

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_DST_OpenStore
**
** Synopsis:    Opens a previously created data store.
**
** Arguments:  
**      [f_pOEMContext]      - Pointer to OEM-specific context data.
**      [f_pbStoreData]      - Specifies store initialization data.
**      [f_cbStoreData]      - Specifies the length of f_pbStoreData.
**      [f_dwGrowBySizeinKB] - Specifies the number of bytes to grow the store
**                             during resizing.
**      [f_pDST]             - Returns the updated data store.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DST_OpenStore ( 
    __in_opt                     DRM_VOID   *f_pOEMContext,
    __in_bcount( f_cbStoreData ) DRM_BYTE   *f_pbStoreData,
    __in                         DRM_DWORD   f_cbStoreData,
    __in                         DRM_DWORD   f_dwGrowBySizeinKB,
    __inout                      DRM_DST    *f_pDST )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pDST != NULL );
    ChkBOOL( f_pDST->oDataStoreInterface.pfnOpenStore != NULL, DRM_E_INVALIDARG );
    ChkDR( f_pDST->oDataStoreInterface.pfnOpenStore( f_pOEMContext,
                                                     f_pbStoreData,
                                                     f_cbStoreData,
                                                     f_dwGrowBySizeinKB,
                                                     f_pDST->poContextDST ) );

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_DST_CloseStore
**
** Synopsis:    Close the data store.  This will also Commit before close.
**
** Arguments:   
**      [f_pDST] - Specifies the data store to close.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DST_CloseStore ( __inout DRM_DST *f_pDST )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pDST != NULL );
    ChkBOOL( f_pDST->oDataStoreInterface.pfnCloseStore != NULL, DRM_E_INVALIDARG );
    ChkDR( f_pDST->oDataStoreInterface.pfnCloseStore( f_pDST->poContextDST ) );

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_DST_CommitStore
**
** Synopsis:    Flushes unwritten data to the store.
**
** Arguments:   
**      [f_pDST] - Specifies the data store to flush.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_DST_CommitStore ( __inout DRM_DST *f_pDST )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pDST != NULL );
    ChkBOOL( f_pDST->oDataStoreInterface.pfnCommitStore != NULL, DRM_E_INVALIDARG );
    ChkDR( f_pDST->oDataStoreInterface.pfnCommitStore( f_pDST->poContextDST ) );

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_DST_CleanupStore
**
** Synopsis:    Performs cleanup on a data store.
**
** Arguments:   
**      [f_pDST]    - Specifies the data store to clean.
**      [f_fWait]   - Specifies whether to wait for locked slots to unlock.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_DST_CleanupStore ( 
    __inout DRM_DST   *f_pDST,
    __in    DRM_BOOL   f_fWait )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pDST != NULL );
    ChkBOOL( f_pDST->oDataStoreInterface.pfnCleanupStore != NULL, DRM_E_INVALIDARG );
    ChkDR( f_pDST->oDataStoreInterface.pfnCleanupStore( f_pDST->poContextDST, f_fWait ) );

ErrorExit:
    return dr;
}


/*
** ----------------------------------------------------------------------------
** Methods applied to namespaces within the data store. 
** ----------------------------------------------------------------------------
*/

/**********************************************************************
** Function:    DRM_DST_OpenNamespace
**
** Synopsis:    Opens a specified namespace within a data store.
**
** Arguments:   
**      [f_pDST]               - Specifies the data store.
**      [f_pbNamespace]        - Namespace identifier to open.
**      [f_cbNamespace]        - Specifies the length in bytes of f_pbNamespace.
**      [f_eOpenMode]          - Specifies the open mode.
**      [f_wMaxNumChildren]    - Specifies the number of children to create if a new
**                               namespace is to be created.
**      [f_dwExpectedSlotSize] - Expected size of bytes in slots for this namespace.
**      [f_pContextNS]         - Returns the context for the opened namespace.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DST_OpenNamespace ( 
    __inout        DRM_DST                   *f_pDST,
    __in    const  DRM_DST_NAMESPACE         *f_pNamespace,
    __in           DRM_DST_OPENMODE           f_eOpenMode,
    __in           DRM_WORD                   f_wMaxNumChildren,
    __in           DRM_DWORD                  f_dwExpectedSlotSize,
    __out          DRM_DST_NAMESPACE_CONTEXT *f_pContextNS )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pDST != NULL );
    ChkBOOL( f_pDST->oDataStoreInterface.pfnOpenNamespace != NULL, DRM_E_INVALIDARG );
    ChkDR( f_pDST->oDataStoreInterface.pfnOpenNamespace( f_pDST->poContextDST,
                                                         f_pNamespace,
                                                         f_eOpenMode,
                                                         f_wMaxNumChildren,
                                                         f_dwExpectedSlotSize,
                                                         f_pContextNS ) );

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_DST_DeleteNamespace
**
** Synopsis:    Deletes a specified namespace and all sub-nodes from a data store.
**
** Arguments:   
**      [f_pDST]   - Specifies the data store.
**      [f_pNS]    - Identifies the namespace to delete.
**      [f_fWait]  - Specifies whether to wait for locks before deletion.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_DST_DeleteNamespace ( 
    __inout    DRM_DST           *f_pDST,
    __inout    DRM_DST_NAMESPACE *f_pNS,
    __in       DRM_BOOL           f_fWait )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pDST != NULL );
    ChkBOOL( f_pDST->oDataStoreInterface.pfnDeleteNamespace != NULL, DRM_E_INVALIDARG );
    ChkDR( f_pDST->oDataStoreInterface.pfnDeleteNamespace( f_pDST->poContextDST,
                                                           f_pNS,
                                                           f_fWait ) );

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_DST_CloseNamespace
**
** Synopsis:    Closes the specified namespace.
**
** Arguments:   
**      [f_pDST]        - Specifies the data store.
**      [f_pContextNS]  - Specifies the context of the namespace to close.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DST_CloseNamespace ( 
    __inout    DRM_DST                    *f_pDST,
    __inout    DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pDST != NULL );
    ChkBOOL( f_pDST->oDataStoreInterface.pfnCloseNamespace != NULL, DRM_E_INVALIDARG );
    ChkDR( f_pDST->oDataStoreInterface.pfnCloseNamespace( f_pContextNS ) );

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_DST_CommitNamespace
**
** Synopsis:    Flushes open data to the specified namespace.
**
** Arguments:   
**      [f_pDST]        - Specifies the data store.
**      [f_pContextNS]  - Specifies the context of the namespace to flush.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_DST_CommitNamespace ( 
    __inout    DRM_DST                    *f_pDST,
    __inout    DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pDST != NULL );
    ChkBOOL( f_pDST->oDataStoreInterface.pfnCommitNamespace != NULL, DRM_E_INVALIDARG );
    ChkDR( f_pDST->oDataStoreInterface.pfnCommitNamespace( f_pContextNS ) );

ErrorExit:
    return dr;
} 


/*
** ----------------------------------------------------------------------------
** Methods to navigate, create, delete, open and close DST dataslots  
** ----------------------------------------------------------------------------
*/

/**********************************************************************
** Function:    DRM_DST_MakeSlotHint
**
** Synopsis:    Initialize a slot hint based on the slot context passed.
**
** Arguments:   
**      [f_pDST]          - Specifies the data store.
**      [f_pContextSlot]  - Specifies the slot context.
**      [f_pSlotHint]     - Returns the initialized slot hint.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DST_MakeSlotHint ( 
    __inout DRM_DST               *f_pDST,
    __in    DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __out   DRM_DST_SLOT_HINT     *f_pSlotHint )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pDST != NULL );
    ChkBOOL( f_pDST->oDataStoreInterface.pfnMakeSlotHint != NULL, DRM_E_INVALIDARG );
    ChkDR( f_pDST->oDataStoreInterface.pfnMakeSlotHint( f_pContextSlot, f_pSlotHint ) );

ErrorExit:
    return dr;
} 

/**********************************************************************
** Function:    DRM_DST_OpenSlot
**
** Synopsis:    Create or open a dataslot using given key1 and key2.
**
** Arguments:   
**      [f_pDST]          - Specifies the data store.
**      [f_pContextNS]    - Specifies the namespace to search for a slot.
**      [f_dwMode]        - Combo of DRM_DST_OPENMODE and DRM_DSTSLOT_LOCKMODE.
**      [f_pKey1]         - Specifies the first key of the slot to open.
**      [f_pKey2]         - Specifies the second (unique) key of the slot to open.
**      [f_pSlotHint]     - Optional. Specifies a slot hint for the slot to open.
**      [f_pcbSlotSize]   - Specifies the slot context size. Returns the size of the data slot in bytes.
**      [f_pContextSlot]  - Returns the context for the opened slot.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DST_OpenSlot ( 
    __inout    DRM_DST                   *f_pDST,
    __in       DRM_DST_NAMESPACE_CONTEXT *f_pContextNS,
    __in       DRM_DWORD                  f_dwMode,
    __in const DRM_DST_KEY               *f_pKey1,
    __in const DRM_DST_KEY               *f_pKey2,
    __in_opt   DRM_DST_SLOT_HINT         *f_pSlotHint,
    __inout    DRM_DWORD                 *f_pcbSlotSize,
    __out      DRM_DST_SLOT_CONTEXT      *f_pContextSlot )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pDST != NULL );
    ChkBOOL( f_pDST->oDataStoreInterface.pfnOpenSlot != NULL, DRM_E_INVALIDARG );
    ChkDR( f_pDST->oDataStoreInterface.pfnOpenSlot( f_pContextNS,
                                                    f_dwMode,
                                                    f_pKey1,
                                                    f_pKey2,
                                                    f_pSlotHint,
                                                    f_pcbSlotSize,
                                                    f_pContextSlot ) );

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_DST_CloseSlot
**
** Synopsis:    Closes an open data slot.
**
** Arguments:   
**      [f_pDST]         - Specifies the data store.
**      [f_pContextSlot] - Specifies the slot context.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DST_CloseSlot ( 
    __inout  DRM_DST               *f_pDST,
    __inout  DRM_DST_SLOT_CONTEXT  *f_pContextSlot )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pDST != NULL );
    ChkBOOL( f_pDST->oDataStoreInterface.pfnCloseSlot != NULL, DRM_E_INVALIDARG );
    ChkDR( f_pDST->oDataStoreInterface.pfnCloseSlot( f_pContextSlot ) );

ErrorExit:
    return dr;
} 

/**********************************************************************
** Function:    DRM_DST_DeleteSlot
**
** Synopsis:    Deletes a dataslot with given key1 and key2.
**
** Arguments:   
**      [f_pDST]       - Specifies the data store.
**      [f_pContextNS] - Specifies the namespace to search for the slot.
**      [f_dwMode]     - Combo of DRM_DST_OPENMODE and DRM_DSTSLOT_LOCKMODE.
**      [f_pKey1]      - Specifies the first key of the slot to delete.
**      [f_pKey2]      - Specifies the second (unique) key of the slot to delete.
**      [f_pSlotHint]  - Optional. Specifies a slot hint for the slot to delete.
**      [f_fWait]      - Specifies whether to wait for open locks before deletion.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DST_DeleteSlot ( 
    __inout    DRM_DST                   *f_pDST,
    __in       DRM_DST_NAMESPACE_CONTEXT *f_pContextNS,
    __in const DRM_DST_KEY               *f_pKey1,
    __in const DRM_DST_KEY               *f_pKey2,
    __in_opt   DRM_DST_SLOT_HINT         *f_pSlotHint,
    __in       DRM_BOOL                   f_fWait )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pDST != NULL );
    ChkBOOL( f_pDST->oDataStoreInterface.pfnDeleteSlot != NULL, DRM_E_INVALIDARG );
    ChkDR( f_pDST->oDataStoreInterface.pfnDeleteSlot( f_pContextNS,
                                                      f_pKey1,
                                                      f_pKey2,
                                                      f_pSlotHint,
                                                      f_fWait ) );

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_DST_InitSlotEnum
**
** Synopsis:    Initialized an enumeration of slots within a namespace.
**
** Arguments:   
**      [f_pDST]         - Specifies the data store.
**      [f_pContextNS]   - Specifies the namespace to enumerate in.
**      [f_pKey1]        - Optional. Specifies the key to enumerate. If NULL, enumerates
**                         over all keys in the namespace.
**      [f_eLockMode]    - Specifies the lock mode to use for enumerated slots.
**      [f_pContextEnum] - Returns the initialized enumeration context.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DST_InitSlotEnum ( 
    __inout        DRM_DST                   *f_pDST,
    __in           DRM_DST_NAMESPACE_CONTEXT *f_pContextNS,
    __in_opt const DRM_DST_KEY               *f_pKey1,
    __in           DRM_DST_LOCKMODE           f_eLockMode,
    __out          DRM_DST_ENUM_CONTEXT      *f_pContextEnum )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pDST != NULL );
    ChkBOOL( f_pDST->oDataStoreInterface.pfnInitSlotEnum != NULL, DRM_E_INVALIDARG );
    ChkDR( f_pDST->oDataStoreInterface.pfnInitSlotEnum( f_pContextNS,
                                                        f_pKey1,
                                                        f_eLockMode,
                                                        f_pContextEnum ) );

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_DST_SlotEnumNext
**
** Synopsis:    Retrieves the next slot from an enumeration.
**
** Arguments:   
**      [f_pDST]         - Specifies the data store.
**      [f_pContextEnum] - Specifies the initialized enumeration context.
**      [f_pContextSlot] - Returns the slot data for the next slot in the enumeration.
**      [f_pKey1]        - Optional. Returns the first key value for the next slot.
**      [f_pKey2]        - Optional. Returns the second (unique) key value for the next slot.
**      [f_pcbSize]      - Optional. Returns the data slot size in bytes.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DST_SlotEnumNext ( 
    __inout    DRM_DST               *f_pDST,
    __inout    DRM_DST_ENUM_CONTEXT  *f_pContextEnum,
    __out      DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __out_opt  DRM_DST_KEY           *f_pKey1,
    __out_opt  DRM_DST_KEY           *f_pKey2,
    __out_opt  DRM_DWORD             *f_pcbSize )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pDST != NULL );
    ChkBOOL( f_pDST->oDataStoreInterface.pfnSlotEnumNext != NULL, DRM_E_INVALIDARG );
    ChkDR( f_pDST->oDataStoreInterface.pfnSlotEnumNext( f_pContextEnum,
                                                        f_pContextSlot,
                                                        f_pKey1,
                                                        f_pKey2,
                                                        f_pcbSize ) );

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_DST_SlotEnumReloadCurrent
**
** Synopsis:    Reload the current slot in the enumeration.
**
** Arguments:   
**      [f_pDST]         - Specifies the data store.
**      [f_pContextEnum] - Specifies the initialized enumeration context.
**      [f_pContextSlot] - Returns the slot data for the current slot in the enumeration.
**      [f_pKey1]        - Optional. Returns the first key value for the slot.
**      [f_pKey2]        - Optional. Returns the second (unique) key value for the slot.
**      [f_pcbSize]      - Optional. Returns the data slot size in bytes.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DST_SlotEnumReloadCurrent ( 
    __inout    DRM_DST               *f_pDST,
    __inout    DRM_DST_ENUM_CONTEXT  *f_pContextEnum,
    __out      DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __out_opt  DRM_DST_KEY           *f_pKey1,
    __out_opt  DRM_DST_KEY           *f_pKey2,
    __out_opt  DRM_DWORD             *f_pcbSize )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pDST != NULL );
    ChkBOOL( f_pDST->oDataStoreInterface.pfnSlotEnumReloadCurrent != NULL, DRM_E_INVALIDARG );
    ChkDR( f_pDST->oDataStoreInterface.pfnSlotEnumReloadCurrent( f_pContextEnum,
                                                                 f_pContextSlot,
                                                                 f_pKey1,
                                                                 f_pKey2,
                                                                 f_pcbSize ) );

ErrorExit:
    return dr;   
}

/**********************************************************************
** Function:    DRM_DST_SlotEnumDeleteCurrent
**
** Synopsis:    Deletes the currently enumerated slot.
**
** Arguments:   
**      [f_pDST]         - Specifies the data store.
**      [f_pContextEnum] - Specifies the initialized enumeration context.
**      [f_pContextSlot] - Specifies the slot context of the current slot.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
** Notes: The enumeration must be initialized with exclusive access.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DST_SlotEnumDeleteCurrent ( 
    __inout   DRM_DST               *f_pDST,
    __inout   DRM_DST_ENUM_CONTEXT  *f_pContextEnum,
    __inout   DRM_DST_SLOT_CONTEXT  *f_pContextSlot )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pDST != NULL );
    ChkBOOL( f_pDST->oDataStoreInterface.pfnSlotEnumDeleteCurrent != NULL, DRM_E_INVALIDARG );
    ChkDR( f_pDST->oDataStoreInterface.pfnSlotEnumDeleteCurrent( f_pContextEnum,
                                                                 f_pContextSlot ) );

ErrorExit:
    return dr;   
}

/**********************************************************************
** Function:    DRM_DST_BlockScanDelete
**
** Synopsis:    Rapid deletion of multiple slots.
**
** Arguments:   
**      [f_pDST]       - Specifies the data store.
**      [f_pContextNS] - Specifies the namespace context to delete from.
**      [f_rgKey1]     - Specifies a list of keys (first key) to delete.
**      [f_cKey1]      - Specifies the number of elements in f_rgKey1.
**      [f_pKey2]      - Specifies a unique key
**      [f_fWait]      - Specifies whether to wait for locks before deletion.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DST_BlockScanDelete ( 
    __inout                DRM_DST                    *f_pDST,
    __inout                DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS,
    __in_ecount( f_cKey1 ) DRM_DST_KEY                *f_rgKey1,
    __in                   DRM_DWORD                   f_cKey1,
    __in                   DRM_DST_KEY                *f_pKey2,
    __in                   DRM_BOOL                    f_fWait )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pDST != NULL );
    ChkBOOL( f_pDST->oDataStoreInterface.pfnBlockScanDelete != NULL, DRM_E_INVALIDARG );
    ChkDR( f_pDST->oDataStoreInterface.pfnBlockScanDelete( f_pContextNS,
                                                           f_rgKey1,
                                                           f_cKey1,
                                                           f_pKey2,
                                                           f_fWait ) );

ErrorExit:
    return dr; 
}


/*
** ----------------------------------------------------------------------------
** Methods to read, write and seek within a dataslot
** ----------------------------------------------------------------------------
*/

/**********************************************************************
** Function:    DRM_DST_SlotResize
**
** Synopsis:    Resizes an open data slot.
**
** Arguments:   
**      [f_pDST]         - Specifies the data store.
**      [f_pContextSlot] - Specifies the slot context to resize.
**      [f_cbSize]       - Specifies the new size for the slot.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DST_SlotResize ( 
    __inout  DRM_DST               *f_pDST,
    __inout  DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __in     DRM_DWORD              f_cbSize )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pDST != NULL );
    ChkBOOL( f_pDST->oDataStoreInterface.pfnSlotResize != NULL, DRM_E_INVALIDARG );
    ChkDR( f_pDST->oDataStoreInterface.pfnSlotResize( f_pContextSlot, f_cbSize ) );

ErrorExit:
    return dr; 
}

/**********************************************************************
** Function:    DRM_DST_SlotSeek
**
** Synopsis:    Set the seek pointer within an open data slot.
**
** Arguments:   
**      [f_pDST]          - Specifies the data store.
**      [f_pContextSlot]  - Specifies the slot context.
**      [f_lOffset]       - Specifies the seek offset
**      [f_eSeekMode]     - Specifies the seek mode to use.
**      [f_pdwSeekPointer]- Optional. Returns the new seek pointer value.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DST_SlotSeek ( 
    __inout   DRM_DST               *f_pDST,
    __inout   DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __in      DRM_LONG               f_lOffset,
    __in      DRM_DST_SEEKMODE       f_eSeekMode,
    __out_opt DRM_DWORD             *f_pdwSeekPointer )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pDST != NULL );
    ChkBOOL( f_pDST->oDataStoreInterface.pfnSlotSeek != NULL, DRM_E_INVALIDARG );
    ChkDR( f_pDST->oDataStoreInterface.pfnSlotSeek( f_pContextSlot, 
                                                    f_lOffset,
                                                    f_eSeekMode,
                                                    f_pdwSeekPointer ) );

ErrorExit:
    return dr; 
}

/**********************************************************************
** Function:    DRM_DST_SlotRead
**
** Synopsis:    Read data from an open data slot.
**
** Arguments:   
**      [f_pDST]         - Specifies the data store.
**      [f_pContextSlot] - Specifies the slot context.
**      [f_cbData]       - Specifies the size in bytes to read.
**      [f_pbData]       - The data buffer to read into.
**      [f_pcbRead]      - Returns the number of bytes read.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DST_SlotRead ( 
    __inout                  DRM_DST               *f_pDST,
    __inout                  DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __in                     DRM_DWORD              f_cbData,
    __out_bcount( f_cbData ) DRM_BYTE              *f_pbData,
    __out_opt                DRM_DWORD             *f_pcbRead )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pDST != NULL );
    ChkBOOL( f_pDST->oDataStoreInterface.pfnSlotRead != NULL, DRM_E_INVALIDARG );
    ChkDR( f_pDST->oDataStoreInterface.pfnSlotRead( f_pContextSlot, 
                                                    f_cbData,
                                                    f_pbData,
                                                    f_pcbRead ) );

ErrorExit:
    return dr; 
}

/**********************************************************************
** Function:    DRM_DST_SlotWrite
**
** Synopsis:    Write data from an open and locked data slot.
**
** Arguments:   
**      [f_pDST]         - Specifies the data store.
**      [f_pContextSlot] - Specifies the slot context.
**      [f_cbData]       - Specifies the size in bytes to write.
**      [f_pbData]       - The data buffer to write from.
**      [f_pcbWritten]   - Returns the number of bytes written.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DST_SlotWrite ( 
    __inout                       DRM_DST               *f_pDST,
    __inout                       DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __in                          DRM_DWORD              f_cbData,
    __in_bcount( f_cbData ) const DRM_BYTE              *f_pbData,
    __out_opt                     DRM_DWORD             *f_pcbWritten )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pDST != NULL );
    ChkBOOL( f_pDST->oDataStoreInterface.pfnSlotWrite != NULL, DRM_E_INVALIDARG );
    ChkDR( f_pDST->oDataStoreInterface.pfnSlotWrite( f_pContextSlot, 
                                                     f_cbData,
                                                     f_pbData,
                                                     f_pcbWritten ) );

ErrorExit:
    return dr; 
}
EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmdomainapi.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmtypes.h>
#include <drmhds.h>
#include <drmutilities.h>
#include <drmdomainstore.h>
#include <drmmanager.h>
#include <drmdomainapi.h>
#include <drmcontract.h>

ENTER_PK_NAMESPACE_CODE;

#if DRM_SUPPORT_DOMAINS

/*********************************************************************
**
** Function: Drm_JoinDomain_GenerateChallenge
**
** Synopsis: API that generates a domain join challenge to be sent to the
**           domain server to register a device to a domain. The challenge
**           includes the  identity of the device to be registered and
**           optionally the domain ID to which the device wants to be
**           registered.
**
** Arguments:
**
** [f_poAppContext]         -- Pointer to a DRM App context initialized via
**                             Drm_Initialize().
** [f_dwFlags]              -- Flag that indicates the type of custom data.
** [f_poDomainID]           -- Pointer to a domain ID to be registered with
**                             the server. Some of its fields (service ID,
**                             account ID or revision) may be blank.
** [f_pchFriendlyName]      -- Pointer to a character buffer that contains
**                             the friendly name. It can be NULL.
** [f_cchFriendlyName]      -- Size (number of characters) of the friendly
**                             name string.
** [f_pchData]              -- Pointer to a buffer that contains the custom data
**                             sent to the server. The format of the custom data
**                             is based on the value of f_dwFlags. It may be NULL. 
**                             If the Query data is passed in with f_dwFlags == DRM_REGISTER_INDIRECT_QUERY_DATA
**                             then it should have the following XML Format:
**                             <JoinDomain type = \"challenge\">
**                              <Data>
**                               <ServiceID>Optional Base 64 encoded Service Account ID string in ANSI</ServiceID>
**                               <AccountID>Optional Base 64 encoded Domain Account ID string in ANSI</AccountID>
**                               <Revision>Optional Domain Revision</Revision>
**                               <FriendlyName>Optional Friendly Name in ANSI </FriendlyName>
**                               <CustomData>Optional Custom Data in ANSI</CustomData>
**                              </Data>
**                             </JoinDomain>
** [f_cchData]              -- Size (in characters) of the custom data buffer.
**                             It must be 0 if f_pchCustomData is NULL.
** [f_pbChallenge]          -- Pointer to a buffer to receive a generated challenge
**                             byte stream. If it is NULL, the function returns
**                             an error and the size of the required buffer is
**                             stored in *f_pcbChallenge.
** [f_pcbChallenge]         -- Pointer to a variable that contains the size (in bytes
**                             of the challenge buffer during input and receives the
**                             size (in bytes) of the challenge buffer during output.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_BUFFERTOOSMALL if the buffer to retrieve
**                          the data is not big enough.
**                          DRM_E_DEVCERTEXCEEDSIZELIMIT if the device certificate
**                          is too big.
**                          DRM_E_DOMAIN_INVALID_CUSTOM_DATA_TYPE if the custom data
**                          type is incorrect.
**                          DRM_E_DOMAIN_INVALID_CUSTOM_DATA if the custom data cannot
**                          be parsed.
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL Drm_JoinDomain_GenerateChallenge(
    IN DRM_APP_CONTEXT *f_poAppContext,
    IN DRM_DWORD f_dwFlags,
    IN DRM_DOMAIN_ID *f_poDomainID,
    __in_ecount_opt( f_cchFriendlyName ) DRM_CHAR *f_pchFriendlyName,
    IN DRM_DWORD f_cchFriendlyName,
    __in_ecount_opt( f_cchData ) DRM_CHAR *f_pchData,
    IN DRM_DWORD f_cchData,
    __out_bcount_opt( *f_pcbChallenge ) DRM_BYTE *f_pbChallenge,
    IN OUT DRM_DWORD *f_pcbChallenge )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_APP_CONTEXT_INTERNAL *poAppContextInternal =
        ( DRM_APP_CONTEXT_INTERNAL * )f_poAppContext;
    DRM_DWORD cbDeviceCert = 0;

    ChkArg( f_poAppContext != NULL );
    ChkArg( poAppContextInternal->fStoreOpened );

    /*
    ** Clear the previous response fields in the app context.
    */
    poAppContextInternal->fResponseSignatureChecked = FALSE;
    poAppContextInternal->dwLastResponseProtocol    = DRM_SOAPXML_PROTOCOL_UNKNOWN;

    /*
    ** Get the size (number of characters) of the device certificate. 
    */
    ChkDR( DRM_SOAPXML_GetDeviceCert( poAppContextInternal->pOEMContext, FALSE, NULL, &cbDeviceCert ) );

    /*
    ** Use license buffer to store the device certificate.
    */
    if ( cbDeviceCert > SIZEOF( poAppContextInternal->oDRMBuffer.oBuffers.rgbDRMLicense ) )
    {
        /*
        ** If size of the license buffer is smaller than the size of the
        ** device certificate, return with error.
        */
        ChkDR( DRM_E_DEVCERTEXCEEDSIZELIMIT );
    }

    if( f_pbChallenge != NULL )
    {
        /* Don't bother if we're not actually generating the challenge */
        ChkDR( DRM_SOAPXML_GetDeviceCert( poAppContextInternal->pOEMContext,
                                          FALSE,
                                          ( DRM_CHAR * )poAppContextInternal->oDRMBuffer.oBuffers.rgbDRMLicense,
                                          &cbDeviceCert ) );
    }

    ChkDR( DRM_DOM_GenerateJoinChallenge( poAppContextInternal->pOEMContext,
                                          &poAppContextInternal->oBlackBoxContext,
                                          &poAppContextInternal->oDomainStoreContext,
                                          f_dwFlags,
                                          f_poDomainID,
                                          f_pchFriendlyName,
                                          f_cchFriendlyName,
                                          f_pbChallenge == NULL ? NULL : poAppContextInternal->oDRMBuffer.oBuffers.rgbDRMLicense,
                                          cbDeviceCert,
                                          f_pchData,
                                          f_cchData,
                                          f_pbChallenge,
                                          f_pcbChallenge ) );

ErrorExit:

    ChkECC( ECC_Drm_JoinDomain_GenerateChallenge, dr );

    return dr;
}

/*********************************************************************
**
** Function: Drm_JoinDomain_ProcessResponse
**
** Synopsis: API that processes a domain join response sent by the domain
**           registration server. The domain response contains a domain
**           certificate and one or more domain private key that will be
**           added to the domain store by the device that calls the API.
**
** Arguments:
**
** [f_poAppContext]         -- Pointer to a DRM App context initialized via
**                             Drm_Initialize().
** [f_pbResponse]           -- Pointer to a buffer that contains the domain
**                             join response from the domain registration
**                             server.
** [f_cbResponse]           -- Size of the domain join response from the domain
**                             registration server. It must be bigger than 0.
** [f_pResult]              -- Optional pointer to a variable that receives the
**                             status code.
** [f_poDomainID]           -- Optional pointer to a variable that receives the
**                             domain id contained in the domain join response.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_S_MORE_DATA if custom data is available from
**                          the server.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_SOAPXML_XML_FORMAT if SOAP format error happens.
**                          DRM_E_XMLNOTFOUND if expected XML node is not found.
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL Drm_JoinDomain_ProcessResponse(
    IN DRM_APP_CONTEXT *f_poAppContext,
    __in_bcount( f_cbResponse ) DRM_BYTE *f_pbResponse,
    IN DRM_DWORD f_cbResponse,
    OUT DRM_RESULT *f_pResult,
    OUT DRM_DOMAIN_ID *f_poDomainID )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_APP_CONTEXT_INTERNAL *poAppContextInternal =
        ( DRM_APP_CONTEXT_INTERNAL * )f_poAppContext;

    ChkArg( f_poAppContext != NULL );
    ChkArg( poAppContextInternal->fStoreOpened );

    ChkDR( DRM_DOM_ProcessJoinResponse( &poAppContextInternal->oBlackBoxContext,
                                        &poAppContextInternal->oDomainStoreContext,
                                        f_pbResponse,
                                        f_cbResponse,
                                        f_pResult,
                                        f_poDomainID ) );

ErrorExit:

    ChkECC( ECC_Drm_JoinDomain_ProcessResponse, dr );

    return dr;
}

/*********************************************************************
**
** Function: Drm_LeaveDomain_GenerateChallenge
**
** Synopsis: API that generates a domain leave challenge to be sent to the
**           domain registration server to unregister a device from a domain. The
**           challenge includes the identity of the device to be unregistered and
**           the domain ID to which the device wants to be unregistered.
**           The device will remove the domain certificate and the domain
**           private keys from its domain store.
**
** Arguments:
**
** [f_poAppContext]         -- Pointer to a DRM App context initialized via
**                             Drm_Initialize().
** [f_dwFlags]              -- Flag that indicates the type of custom data.
** [f_poDomainID]           -- Domain ID to be unregistered with the server. Some of
**                             its fields (service ID, account ID or revision)
**                             may be blank.
** [f_pchData]              -- Pointer to a buffer that contains the custom data
**                             sent to the server. The format of the custom data
**                             is based on the value of f_dwFlags. It may be NULL.
**                             If the Query data is passed in with f_dwFlags == DRM_REGISTER_INDIRECT_QUERY_DATA
**                             then it should have the following XML Format:
**                             <LeaveDomain type = \"challenge\">
**                              <Data>
**                               <ServiceID>Optional Base 64 encoded Service Account ID string in ANSI</ServiceID>
**                               <AccountID>Mandatory Base 64 encoded Domain Account ID string in ANSI</AccountID>
**                               <Revision>Optional Domain Revision</Revision>
**                               <CustomData>Optional Custom Data in ANSI</CustomData>
**                              </Data>
**                             </LeaveDomain> 
** [f_cchData]              -- Size (in characters) of the custom data buffer.
**                             It must be 0 if f_pchCustomData is NULL.
** [f_pbChallenge]          -- Pointer to a buffer to receive a generated challenge
**                             byte stream. If it is NULL, the function returns an
**                             error and the size of the required buffer is stored
**                             in *f_pcbChallenge.
** [f_pcbChallenge]         -- Pointer to a variable that contains the size (in bytes
**                             of the challenge buffer during input and receives the
**                             size (in bytes) of the challenge buffer during output.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_BUFFERTOOSMALL if the buffer to retrieve
**                          the data is not big enough.
**                          DRM_E_DEVCERTEXCEEDSIZELIMIT if the device certificate
**                          is too big.
**                          DRM_E_DOMAIN_INVALID_CUSTOM_DATA_TYPE if the custom data
**                          type is incorrect.
**                          DRM_E_DOMAIN_INVALID_CUSTOM_DATA if the custom data cannot
**                          be parsed.
**                          DRM_E_DOMAIN_STORE_DELETE_DATA if domain data cannot be
**                          deleted.
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL Drm_LeaveDomain_GenerateChallenge(
    IN DRM_APP_CONTEXT *f_poAppContext,
    IN DRM_DWORD f_dwFlags,
    IN DRM_DOMAIN_ID *f_poDomainID,
    __in_ecount_opt( f_cchData ) DRM_CHAR *f_pchData,
    IN DRM_DWORD f_cchData,
    __out_bcount_opt( *f_pcbChallenge ) DRM_BYTE *f_pbChallenge,
    IN OUT DRM_DWORD *f_pcbChallenge )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_APP_CONTEXT_INTERNAL *poAppContextInternal =
        ( DRM_APP_CONTEXT_INTERNAL * )f_poAppContext;
    DRM_DWORD cbDeviceCert = 0;

    ChkArg( f_poAppContext != NULL );
    ChkArg( poAppContextInternal->fStoreOpened );

    /*
    ** Clear the previous response fields in the app context.
    */
    poAppContextInternal->fResponseSignatureChecked = FALSE;
    poAppContextInternal->dwLastResponseProtocol    = DRM_SOAPXML_PROTOCOL_UNKNOWN;

    /*
    ** Get the size (number of characters) of the device certificate.
    */
    ChkDR( DRM_SOAPXML_GetDeviceCert( poAppContextInternal->pOEMContext, FALSE, NULL, &cbDeviceCert ) );

    /*
    ** Use license buffer to store the device certificate. 
    */
    if ( cbDeviceCert > SIZEOF( poAppContextInternal->oDRMBuffer.oBuffers.rgbDRMLicense ) )
    {
        /*
        ** If size of the license buffer is smaller than the size of the
        ** device certificate, return with error.
        */
        ChkDR( DRM_E_DEVCERTEXCEEDSIZELIMIT );
    }

    
    if( f_pbChallenge != NULL )
    {
        /* Don't bother if we're not actually generating the challenge */
        ChkDR( DRM_SOAPXML_GetDeviceCert( poAppContextInternal->pOEMContext,
                                          FALSE,
                                          ( DRM_CHAR * )poAppContextInternal->oDRMBuffer.oBuffers.rgbDRMLicense,
                                          &cbDeviceCert ) );
    }

    ChkDR( DRM_DOM_GenerateLeaveChallenge( poAppContextInternal->pOEMContext,
                                           &poAppContextInternal->oBlackBoxContext,
                                           &poAppContextInternal->oDomainStoreContext,
                                           f_dwFlags,
                                           f_poDomainID,
                                           f_pbChallenge == NULL ? NULL : poAppContextInternal->oDRMBuffer.oBuffers.rgbDRMLicense,
                                           cbDeviceCert,
                                           f_pchData,
                                           f_cchData,
                                           f_pbChallenge,
                                           f_pcbChallenge ) );

ErrorExit:

    ChkECC( ECC_Drm_LeaveDomain_GenerateChallenge, dr );

    return dr;
}

/*********************************************************************
**
** Function: Drm_LeaveDomain_ProcessResponse
**
** Synopsis: API that processes a domain leave response received from
**           the domain server.
**
** Arguments:
**
** [f_poAppContext]         -- Pointer to a DRM App context initialized via
**                             Drm_Initialize().
** [f_pbResponse]           -- Pointer to a buffer that contains the domain
**                             leave response from the domain registration
**                             server.
** [f_cbResponse]           -- Size of the domain leave response from the domain
**                             registration server. It must be bigger than 0.
** [f_pResult]              -- Optional pointer to a variable that receives the
**                             status code.
**
** Returns:                 DRM_SUCCESS on success.
                            DRM_S_MORE_DATA if custom data is available from
**                          the server.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_SOAPXML_XML_FORMAT if SOAP format error happens.
**                          DRM_E_XMLNOTFOUND if expected XML node is not found.
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL Drm_LeaveDomain_ProcessResponse(
    IN DRM_APP_CONTEXT *f_poAppContext,
    __in_bcount( f_cbResponse ) DRM_BYTE *f_pbResponse,
    IN DRM_DWORD f_cbResponse,
    OUT DRM_RESULT *f_pResult )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_APP_CONTEXT_INTERNAL *poAppContextInternal =
        ( DRM_APP_CONTEXT_INTERNAL * )f_poAppContext;

    ChkArg( f_poAppContext != NULL );
    ChkArg( poAppContextInternal->fStoreOpened );
    
    ChkDR( DRM_DOM_ProcessLeaveResponse( f_pbResponse,
                                         f_cbResponse,
                                         f_pResult,
                                         &poAppContextInternal->oBlackBoxContext) );

ErrorExit:

    ChkECC( ECC_Drm_LeaveDomain_ProcessResponse, dr );

    return dr;
}

/*********************************************************************
**
** Function: Drm_DomainCert_Find
**
** Synopsis: API that retrieves a domain certificate from the domain
**           store for a specific domain.
**
** Arguments:
**
** [f_poAppContext]         -- Pointer to a DRM App context initialized via
**                             Drm_Initialize().
** [f_pDomainID]            -- Domain ID of the domain whose domain certificate will
**                             be retrieved. Only the account ID field is used.
** [f_pbDomainCert]         -- Pointer to a buffer to receive a domain certificate
**                             byte stream. If it is NULL, the function returns an
**                             error and the size of the required buffer is stored
**                             in *f_pcbDomainCert.
** [f_pcbDomainCert]        -- Pointer to a variable that contains the size (in bytes)
**                             of the domain certificate buffer during input and
**                             receives the size (in bytes) of the domain certificate
**                             buffer during output.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_BUFFERTOOSMALL if the buffer to retrieve
**                          the data is not big enough.
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL Drm_DomainCert_Find(
    IN DRM_APP_CONTEXT *f_poAppContext,
    IN DRM_DOMAIN_ID *f_poDomainID,
    __out_bcount_opt( *f_pcbDomainCert ) DRM_BYTE *f_pbDomainCert,
    IN OUT DRM_DWORD *f_pcbDomainCert )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_APP_CONTEXT_INTERNAL *poAppContextInternal =
        ( DRM_APP_CONTEXT_INTERNAL * )f_poAppContext;

    ChkArg( f_poAppContext != NULL );
    ChkArg( poAppContextInternal->fStoreOpened );

    /*
    ** DRM App context should have an already opened domain store during
    ** its initialization.
    */
    ChkDR( DRM_DOM_FindCert( &poAppContextInternal->oDomainStoreContext,
                             f_poDomainID,
                             f_pbDomainCert,
                             f_pcbDomainCert ) );

ErrorExit:

    ChkECC( ECC_Drm_DomainCert_Find, dr );

    return dr;
}

/*********************************************************************
**
** Function: Drm_DomainCert_InitEnum
**
** Synopsis: API that initializes an domain store enumerator context
**           for all the domain certificates.
**
** Arguments:
**
** [f_poAppContext]         -- Pointer to a DRM App context initialized via
**                             Drm_Initialize().
** [f_poDomainCertEnumContext]           
**                          -- Pointer to a domain cert enumerator context
**                             for all the domain certificates. This API
**                             initialized the domain cert context.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL Drm_DomainCert_InitEnum(
    IN DRM_APP_CONTEXT *f_poAppContext,
    OUT DRM_DOMAIN_CERT_ENUM_CONTEXT *f_poDomainCertEnumContext )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_APP_CONTEXT_INTERNAL *poAppContextInternal =
        ( DRM_APP_CONTEXT_INTERNAL * )f_poAppContext;

    ChkArg( f_poAppContext != NULL );
    ChkArg( poAppContextInternal->fStoreOpened );

    ChkDR( DRM_DOM_InitCertEnum( &poAppContextInternal->oDomainStoreContext,
                                 f_poDomainCertEnumContext ) );

ErrorExit:

    ChkECC( ECC_Drm_DomainCert_InitEnum, dr );

    return dr;
}

/*********************************************************************
**
** Function: Drm_DomainCert_EnumNext
**
** Synopsis: API that enumerates the next domain certificate using an
**           initialized domain cert enumerator context.
**
** Arguments:
**
** [f_poDomainCertEnumContext]           
**                          -- Pointer to an initialized domain cert 
**                             enumerator context.
** [f_pcchDomainCert]       -- Pointer to a variable that receives the size
**                             (in characters) of the domain cert being
**                             enumerated. Caller should allocate buffer using
**                             the returned size and then call Drm_DomainCert_Find()
**                             to actually read the domain certificate.
** [f_poDomainCertInfo]     -- Pointer to a structure that receives additional
**                             information of the domain certificates retrieved.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_NOMORE when there is no more element to be
**                          enumerated next.
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL Drm_DomainCert_EnumNext(
    IN DRM_DOMAIN_CERT_ENUM_CONTEXT *f_poDomainCertEnumContext,
    OUT DRM_DWORD *f_pcchDomainCert,
    OUT DRM_DOMAINCERT_INFO *f_poDomainCertInfo )
{
    DRM_RESULT dr = DRM_SUCCESS;
    
    ChkDR( DRM_DOM_EnumNextCert( f_poDomainCertEnumContext,
                                 f_pcchDomainCert,
                                 f_poDomainCertInfo ) );

ErrorExit:

    ChkECC( ECC_Drm_DomainCert_EnumNext, dr );

    return dr;
}

#endif /* DRM_SUPPORT_DOMAINS */

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmdevstore.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <ndtconstants.h>
#include <oemdevstore.h>
#include <drmdevstore.h>

ENTER_PK_NAMESPACE_CODE;

static DRM_RESULT _GenerateDeviceID(
    __out      DRM_BYTEBLOB * const f_pDeviceID, 
    __in const DRM_BYTEBLOB         f_DeviceCertificate,
    __in const DRM_ID               f_DeviceSerialNumber
)
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DEVICESTORE, PERF_FUNC__GenerateDeviceID );

    ChkArg(f_pDeviceID
           && f_DeviceCertificate.pbBlob);

    /* DeviceID is the serial number concatenated with the certificate */
    ChkOverflow( SIZEOF(DRM_ID) + f_DeviceCertificate.cbBlob, SIZEOF(DRM_ID) );
    f_pDeviceID->cbBlob = SIZEOF(DRM_ID) + f_DeviceCertificate.cbBlob;
    f_pDeviceID->pbBlob = (DRM_BYTE *) Oem_MemAlloc(f_pDeviceID->cbBlob);
    ChkMem(f_pDeviceID->pbBlob);
    DRM_BYT_CopyBytes(f_pDeviceID->pbBlob, 0, &f_DeviceSerialNumber, 0, SIZEOF(DRM_ID));
    DRM_BYT_CopyBytes(f_pDeviceID->pbBlob, SIZEOF(DRM_ID), f_DeviceCertificate.pbBlob, 0, f_DeviceCertificate.cbBlob);

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


static DRM_RESULT _ExtractDeviceInfo(
    __in const                            DRM_BYTEBLOB         f_DeviceID, 
    __out_bcount(*f_pcbDeviceCertificate) DRM_BYTE     * const f_pbDeviceCertificate, 
    __out                                 DRM_DWORD    * const f_pcbDeviceCertificate, 
    __out                                 DRM_ID       * const f_pDeviceSerialNumber
)
{
    DRM_RESULT dr = DRM_SUCCESS;
    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DEVICESTORE, PERF_FUNC__ExtractDeviceInfo );

    ChkArg( f_DeviceID.pbBlob
            && f_pcbDeviceCertificate
            && (0 == *f_pcbDeviceCertificate || NULL != f_pbDeviceCertificate)
            && f_pDeviceSerialNumber );

    if ( *f_pcbDeviceCertificate < f_DeviceID.cbBlob - SIZEOF(DRM_ID) )
    {
        dr = DRM_E_BUFFERTOOSMALL;
    }
    *f_pcbDeviceCertificate = f_DeviceID.cbBlob - SIZEOF(DRM_ID);
    ChkDR(dr);

    DRM_BYT_CopyBytes(f_pDeviceSerialNumber, 0, f_DeviceID.pbBlob, 0, SIZEOF(DRM_ID));
    DRM_BYT_CopyBytes(f_pbDeviceCertificate, 0, f_DeviceID.pbBlob, SIZEOF(DRM_ID), *f_pcbDeviceCertificate);
    
 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/**********************************************************************
**
** Function:    DRM_DeviceStore_HasTimedOut
**
** Synopsis:    Compares the current time against a previous time and an timeout period
**              to see if the timeout has expired.
**
** Arguments:   [f_pOEMContext]      -- Pointer to the OEM context; may be NULL
**              [f_pftStartTime]     -- Starting time of measurement
**              [f_dwTimeoutSeconds] -- Timeout period in seconds
**
** Returns:     TRUE if the timeout has expired,
**              FALSE otherwise
**
**********************************************************************/
DRM_API DRM_BOOL DRM_CALL DRM_DeviceStore_HasTimedOut(
    __in_opt    DRM_VOID    *f_pOEMContext,
    __in        DRMFILETIME *f_pftStartTime,
    __in const  DRM_DWORD    f_dwTimeoutSeconds
)
{
    DRMFILETIME ft;
    DRM_UINT64  ui64Start;
    DRM_UINT64  ui64Now;


    DRMASSERT( f_pftStartTime != NULL );

    Oem_Clock_GetSystemTimeAsFileTime( f_pOEMContext, &ft );

    /*
    ** Convert start time to quadword seconds
    */
    FILETIME_TO_UI64( *f_pftStartTime, ui64Start );
    ui64Start = DRM_UI64Div( ui64Start, DRM_UI64( C_TICS_PER_SECOND ) );
    
    /*
    ** Convert current time to quadword seconds
    */
    FILETIME_TO_UI64( ft, ui64Now );
    ui64Now = DRM_UI64Div( ui64Now, DRM_UI64( C_TICS_PER_SECOND ) );
    
    /*
    ** Return TRUE if the timeout value is less than the elapsed time (now - start)
    */
    if ( DRM_UI64Les( DRM_UI64( f_dwTimeoutSeconds ), DRM_UI64Sub( ui64Now, ui64Start ) ) )
    {
        return TRUE;
    }

    return FALSE;
}


/**********************************************************************
**
** Function:    DRM_DeviceStore_MarkDeviceAsValid
**
** Synopsis:    Marks the given device as valid.  Sets a device property
**              with the current time, which is queried by
**              DRM_DeviceStore_IsDeviceValid
**
** Arguments:   [f_pOEMContext]    -- Pointer to the OEM context; may be NULL
**              [f_hDeviceHandle]  -- The device handle
**
** Returns:     DRM_SUCCESS on success or
**              DRM_E_INVALIDARG if any of the arguments are invalid
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_DeviceStore_MarkDeviceAsValid(
    __in_opt    DRM_VOID            *f_pOEMContext,
    __in const  OEM_DEVICE_HANDLE    f_hDeviceHandle
)
{
    DRM_RESULT   dr = DRM_SUCCESS;
    DRM_BYTEBLOB attrName;
    DRM_BYTEBLOB attrValue;
    DRMFILETIME  ftNow;
    DRM_BYTE     rgbValue[__CB_DECL(SIZEOF(DRM_DWORD) * 2)];


    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DEVICESTORE, PERF_FUNC_DRM_DeviceStore_MarkDeviceAsValid );

    ChkArg( f_hDeviceHandle != NULL );

    attrName.pbBlob = (DRM_BYTE *) g_dstrDeviceAttrLastValidationTime.pwszString;
    attrName.cbBlob = g_dstrDeviceAttrLastValidationTime.cchString * SIZEOF(DRM_WCHAR);

    Oem_Clock_GetSystemTimeAsFileTime(f_pOEMContext, &ftNow);
    DWORD_TO_NETWORKBYTES(rgbValue, 0, ftNow.dwHighDateTime);
    DWORD_TO_NETWORKBYTES(rgbValue, SIZEOF(DRM_DWORD), ftNow.dwLowDateTime);
    attrValue.pbBlob = rgbValue;
    attrValue.cbBlob = SIZEOF(DRM_DWORD) * 2;

    ChkDR( Oem_DeviceStore_SetDeviceAttr( f_hDeviceHandle, attrName, attrValue ) );
    ChkDR( Oem_DeviceStore_CommitDevice( f_hDeviceHandle ) );

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}



/**********************************************************************
**
** Function:    DRM_DeviceStore_IsDeviceValid
**
** Synopsis:    Determines if the given device is valid.  This uses
**              the time set at the time of DRM_DeviceStore_MarkDeviceAsValid
**              and ensures the validation timeout has not occured.
**
** Arguments:   [f_pOEMContext]    -- Pointer to the OEM context; may be NULL
**              [f_hDeviceHandle]  -- The device handle
**
** Returns:     TRUE if the device is valid; FALSE otherwise
**
**********************************************************************/
DRM_API DRM_BOOL DRM_CALL DRM_DeviceStore_IsDeviceValid(
    __in_opt   DRM_VOID           *f_pOEMContext,
    __in const OEM_DEVICE_HANDLE   f_hDeviceHandle
)
{
    DRM_RESULT   dr          = DRM_SUCCESS;
    DRMFILETIME  ftValidated = { 0 };
    DRM_BYTE     rgbValidated[ __CB_DECL( SIZEOF(DRM_DWORD) * 2 )] = { 0 };
    DRM_BYTEBLOB attrName    = { NULL, 0 };
    DRM_DWORD    cbValue     = SIZEOF( rgbValidated );
    DRM_BOOL     fResult     = FALSE;

    /* Refresh attributes */
    ChkDR( Oem_DeviceStore_CommitDevice( f_hDeviceHandle ) );

    attrName.pbBlob = (DRM_BYTE *) g_dstrDeviceAttrLastValidationTime.pwszString;
    attrName.cbBlob = g_dstrDeviceAttrLastValidationTime.cchString * SIZEOF(DRM_WCHAR);

    ChkDR( Oem_DeviceStore_GetDeviceAttr( f_hDeviceHandle, attrName, rgbValidated, &cbValue ) );
    ChkBOOL( cbValue == SIZEOF( rgbValidated), DRM_E_FAIL );
    
    NETWORKBYTES_TO_DWORD( ftValidated.dwHighDateTime, rgbValidated, 0 );
    NETWORKBYTES_TO_DWORD( ftValidated.dwLowDateTime, rgbValidated, SIZEOF(DRM_DWORD) );

    fResult = !DRM_DeviceStore_HasTimedOut( f_pOEMContext, 
                                            &ftValidated, 
                                            DRM_DEVICESTORE_VALIDATION_TIMEOUT );
    
ErrorExit:
    TRACE_IF_FAILED(( "DRM_DeviceStore_IsDeviceValid failed; dr = 0x%x", dr ));
    return fResult;
}



/**********************************************************************
**
** Function:    DRM_DeviceStore_FreeDevice
**
** Synopsis:    A wrapper for Oem_DeviceStore_FreeDevice.
**
** Arguments:   [f_hDeviceHandle]     -- The device handle
**
** Returns:     N/A
**
**********************************************************************/
DRM_API DRM_VOID DRM_CALL DRM_DeviceStore_FreeDevice(
    __in const   OEM_DEVICE_HANDLE            f_hDeviceHandle
)
{
    Oem_DeviceStore_FreeDevice((OEM_DEVICE_HANDLE) f_hDeviceHandle);
}


/**********************************************************************
**
** Function:    DRM_DeviceStore_UnRegisterDevice
**
** Synopsis:    A wrapper for Oem_DeviceStore_UnRegisterDevice
**
** Arguments:   [f_pOemDevStoreContext] -- OEM device store context 
**              [f_DeviceCertificate]   -- Certificate
**              [f_DeviceSerialNumber]  -- Serial Number
**
** Returns:     return from underlying call is bubbled up
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_DeviceStore_UnRegisterDevice(
    __inout       OEM_DEVICESTORE_CONTEXT *f_pOemDevStoreContext,
    __in const    DRM_BYTEBLOB             f_DeviceCertificate,
    __in const    DRM_ID                   f_DeviceSerialNumber
)
{
    DRM_RESULT               dr = DRM_SUCCESS;
    DRM_BYTEBLOB             Tmp = {NULL, 0};

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DEVICESTORE, PERF_FUNC_DRM_DeviceStore_UnRegisterDevice );

    ChkArg( f_pOemDevStoreContext != NULL );
    ChkArg( f_DeviceCertificate.pbBlob != NULL );

    ChkDR( _GenerateDeviceID(&Tmp, f_DeviceCertificate, f_DeviceSerialNumber) );
    ChkDR( Oem_DeviceStore_UnRegisterDevice( f_pOemDevStoreContext, Tmp) );

 ErrorExit:
    SAFE_OEM_FREE(Tmp.pbBlob);

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


/**********************************************************************
**
** Function:    DRM_DeviceStore_GetFirstDevice
**
** Synopsis:    A wrapper for Oem_DeviceStore_GetFirstDevice
**
** Arguments:   [f_pOemDevStoreContext] -- OEM device store context 
**              [f_phDeviceHandle]      -- Device Handle
**
** Returns:     return from underlying call is bubbled up
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_DeviceStore_GetFirstDevice(
    __inout OEM_DEVICESTORE_CONTEXT *       f_pOemDevStoreContext,
    __out   OEM_DEVICE_HANDLE       * const f_phDeviceHandle
)
{
    DRM_RESULT               dr = DRM_SUCCESS;

    ChkArg( f_pOemDevStoreContext != NULL ); 
    ChkArg( f_phDeviceHandle != NULL );

    ChkDR( Oem_DeviceStore_GetFirstDevice( f_pOemDevStoreContext, 
                                           (OEM_DEVICE_HANDLE *) f_phDeviceHandle ) );

 ErrorExit:
    return dr;
}


/**********************************************************************
**
** Function:    DRM_DeviceStore_GetNextDevice
**
** Synopsis:    A wrapper for Oem_DeviceStore_GetNextDevice
**
** Arguments:   [f_pOemDevStoreContext] -- OEM device store context 
**              [f_phDeviceHandle]      -- Device Handle
**
** Returns:     return from underlying call is bubbled up
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_DeviceStore_GetNextDevice(
    __inout OEM_DEVICESTORE_CONTEXT *       f_pOemDevStoreContext,
    __out   OEM_DEVICE_HANDLE       * const f_phDeviceHandle
)
{
    DRM_RESULT               dr = DRM_SUCCESS;

    ChkArg( f_pOemDevStoreContext != NULL ); 
    ChkArg( f_phDeviceHandle != NULL );

    ChkDR( Oem_DeviceStore_GetNextDevice( f_pOemDevStoreContext,
                                          (OEM_DEVICE_HANDLE *) f_phDeviceHandle ) );

 ErrorExit:
    return dr;
}


/**********************************************************************
**
** Function:    DRM_DeviceStore_GetDeviceByID
**
** Synopsis:    A wrapper for Oem_DeviceStore_GetDeviceByID
**
** Arguments:   [f_pOemDevStoreContext] -- OEM device store context 
**              [f_DeviceCertificate]   -- Device Certificate
**              [f_DeviceSerialNumber]  -- Device Serial Number
**              [f_phDeviceHandle]      -- Device Handle
**
** Returns:     return from underlying call is bubbled up
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_DeviceStore_GetDeviceByID(
    __inout       OEM_DEVICESTORE_CONTEXT *       f_pOemDevStoreContext,
    __in const    DRM_BYTEBLOB                    f_DeviceCertificate,
    __in const    DRM_ID                          f_DeviceSerialNumber,
    __out         OEM_DEVICE_HANDLE       * const f_phDeviceHandle
)
{
    DRM_RESULT               dr = DRM_SUCCESS;
    DRM_BYTEBLOB             Tmp = {NULL, 0};

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DEVICESTORE, PERF_FUNC_DRM_DeviceStore_GetDeviceByID );

    ChkArg( f_pOemDevStoreContext != NULL ); 
    ChkArg( f_DeviceCertificate.pbBlob!= NULL );
    ChkArg( f_phDeviceHandle != NULL );

    ChkDR( _GenerateDeviceID(&Tmp, f_DeviceCertificate, f_DeviceSerialNumber) );
    ChkDR( Oem_DeviceStore_GetDeviceByID( f_pOemDevStoreContext,
                                          Tmp, 
                                          (OEM_DEVICE_HANDLE *) f_phDeviceHandle ) );

 ErrorExit:  
    SAFE_OEM_FREE(Tmp.pbBlob);

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


/**********************************************************************
**
** Function:    DRM_DeviceStore_GetDeviceInfo
**
** Synopsis:    The function extracts device certificate and serial number
**
** Arguments:   [f_hDeviceHandle]        -- Device Handle
**              [f_pbDeviceCertificate]  -- Pointer to Device Certificate; may be NULL
**              [f_pcbDeviceCertificate] -- Device Certificate Size
**              [f_pDeviceSerialNumber]  -- Device Serial Number
**
** Returns:     return from underlying call is bubbled up
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_DeviceStore_GetDeviceInfo(
    __in const                                OEM_DEVICE_HANDLE         f_hDeviceHandle,
    __out_bcount_opt(*f_pcbDeviceCertificate) DRM_BYTE          * const f_pbDeviceCertificate,
    __inout                                   DRM_DWORD         * const f_pcbDeviceCertificate,
    __out                                     DRM_ID            * const f_pDeviceSerialNumber
)
{
    DRM_RESULT   dr = DRM_SUCCESS;
    DRM_BYTEBLOB Tmp = {NULL, 0};

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DEVICESTORE, PERF_FUNC_DRM_DeviceStore_GetDeviceInfo );

    ChkArg( f_pcbDeviceCertificate 
            && (0 == *f_pcbDeviceCertificate || NULL != f_pbDeviceCertificate)
            && f_pDeviceSerialNumber );

    dr = Oem_DeviceStore_GetDeviceID((OEM_DEVICE_HANDLE) f_hDeviceHandle,
                                     Tmp.pbBlob,
                                     &Tmp.cbBlob);
    if ( DRM_E_BUFFERTOOSMALL == dr )
    {
        Tmp.pbBlob = (DRM_BYTE*)Oem_MemAlloc(Tmp.cbBlob);
        ChkMem(Tmp.pbBlob);
        dr = Oem_DeviceStore_GetDeviceID((OEM_DEVICE_HANDLE) f_hDeviceHandle,
                                         Tmp.pbBlob,
                                         &Tmp.cbBlob);
    }
    ChkDR(dr);

    ChkDR(_ExtractDeviceInfo(Tmp, f_pbDeviceCertificate, f_pcbDeviceCertificate, f_pDeviceSerialNumber));

 ErrorExit:
    SAFE_OEM_FREE(Tmp.pbBlob);

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


/**********************************************************************
**
** Function:    DRM_DeviceStore_GetDeviceAttr
**
** Synopsis:    A wrapper for Oem_DeviceStore_GetDeviceAttr
**
** Arguments:   [f_hDeviceHandle] -- Device Handle
**              [f_AttrName]      -- Attribute Name
**              [f_pbAttrValue]   -- Pointer to Attribute Value; may be NULL
**              [f_pcbAttrValue]  -- Attribute Value Size
**
** Returns:     return from underlying call is bubbled up
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_DeviceStore_GetDeviceAttr(
    __in const                        OEM_DEVICE_HANDLE         f_hDeviceHandle,
    __in const                        DRM_BYTEBLOB              f_AttrName,
    __out_bcount_opt(*f_pcbAttrValue) DRM_BYTE          * const f_pbAttrValue,
    __inout                           DRM_DWORD         * const f_pcbAttrValue
)
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkDR( Oem_DeviceStore_GetDeviceAttr((OEM_DEVICE_HANDLE) f_hDeviceHandle, 
                                          f_AttrName, 
                                          f_pbAttrValue,
                                          f_pcbAttrValue) );

 ErrorExit:
    return dr;
}


/**********************************************************************
**
** Function:    DRM_DeviceStore_GetDeviceAttrCount
**
** Synopsis:    A wrapper for Oem_DeviceStore_GetDeviceAttrCount
**
** Arguments:   [f_hDeviceHandle] -- Device Handle
**              [f_pdwAttrCount]  -- Number of Attributes
**
** Returns:     return from underlying call is bubbled up
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_DeviceStore_GetDeviceAttrCount(
    __in const  OEM_DEVICE_HANDLE            f_hDeviceHandle,
    __out       DRM_DWORD            * const f_pdwAttrCount
)
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkDR( Oem_DeviceStore_GetDeviceAttrCount((OEM_DEVICE_HANDLE) f_hDeviceHandle, 
                                               f_pdwAttrCount) );
           
 ErrorExit:
    return dr;
}


/**********************************************************************
**
** Function:    DRM_DeviceStore_GetDeviceAttrByIndex
**
** Synopsis:    A wrapper for Oem_DeviceStore_GetDeviceAttrByIndex
**
** Arguments:   [f_hDeviceHandle] -- Device Handle
**              [f_dwAttrIndex]   -- Attribute Index
**              [f_pbAttrName]    -- Pointer to Attribute Name; may be NULL
**              [f_pcbAttrName]   -- Attribute Name Size
**              [f_pbAttrValue]   -- Pointer to Attribute Value; may be NULL
**              [f_pcbAttrValue]  -- Attribute Value Size
**
** Returns:     return from underlying call is bubbled up
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_DeviceStore_GetDeviceAttrByIndex(
    __in const                        OEM_DEVICE_HANDLE         f_hDeviceHandle,
    __in const                        DRM_DWORD                 f_dwAttrIndex,
    __out_bcount_opt(*f_pcbAttrName)  DRM_BYTE          * const f_pbAttrName,
    __inout                           DRM_DWORD         * const f_pcbAttrName,
    __out_bcount_opt(*f_pcbAttrValue) DRM_BYTE          * const f_pbAttrValue,
    __inout                           DRM_DWORD         * const f_pcbAttrValue
)
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkDR( Oem_DeviceStore_GetDeviceAttrByIndex((OEM_DEVICE_HANDLE) f_hDeviceHandle, 
                                                f_dwAttrIndex,
                                                f_pbAttrName,
                                                f_pcbAttrName,
                                                f_pbAttrValue,
                                                f_pcbAttrValue) );
           
 ErrorExit:
    return dr;
}


/**********************************************************************
**
** Function:    DRM_DeviceStore_SetDeviceAttr
**
** Synopsis:    A wrapper for Oem_DeviceStore_SetDeviceAttr
**
** Arguments:   [f_hDeviceHandle] -- Device Handle
**              [f_dwAttrIndex]   -- Attribute Index
**              [f_AttrName]      -- Attribute Name
**              [f_AttrValue]     -- Attribute Value
**
** Returns:     return from underlying call is bubbled up
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_DeviceStore_SetDeviceAttr(
    __in const   OEM_DEVICE_HANDLE f_hDeviceHandle,
    __in const   DRM_BYTEBLOB      f_AttrName,
    __in const   DRM_BYTEBLOB      f_AttrValue
)
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkDR( Oem_DeviceStore_SetDeviceAttr((OEM_DEVICE_HANDLE) f_hDeviceHandle, 
                                         f_AttrName,
                                         f_AttrValue) );
           
 ErrorExit:
    return dr;
}


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmdomainconstants.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmtypes.h>
#include <drmdomainconstants.h>

ENTER_PK_NAMESPACE_CODE;

#if DRM_SUPPORT_DOMAINS

/* 
** -------------------------------------------------------------
** XML strings used in the construction of domain join challenge
** -------------------------------------------------------------
*/
/* "JoinDomain" */
const DRM_CHAR g_rgchDomJoinRootTag [] =
{
    TWO_BYTES( 'J', 'o' ), TWO_BYTES( 'i', 'n' ), TWO_BYTES( 'D', 'o' ), TWO_BYTES( 'm', 'a' ), 
    TWO_BYTES( 'i', 'n' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinRootTag = { g_rgchDomJoinRootTag, 10 };


/* "Version" */
const DRM_CHAR g_rgchDomJoinVersionTag [] =
{
    TWO_BYTES( 'V', 'e' ), TWO_BYTES( 'r', 's' ), TWO_BYTES( 'i', 'o' ), TWO_BYTES( 'n', '\0' ), 
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinVersionTag = { g_rgchDomJoinVersionTag, 7 };


/* "challenge" */
const DRM_CHAR g_rgchDomJoinChallenge1Tag [] =
{
    TWO_BYTES( 'c', 'h' ), TWO_BYTES( 'a', 'l' ), TWO_BYTES( 'l', 'e' ), TWO_BYTES( 'n', 'g' ), 
    TWO_BYTES( 'e', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinChallenge1Tag = { g_rgchDomJoinChallenge1Tag, 9 };


/* "Challenge" */
const DRM_CHAR g_rgchDomJoinChallenge2Tag [] =
{
    TWO_BYTES( 'C', 'h' ), TWO_BYTES( 'a', 'l' ), TWO_BYTES( 'l', 'e' ), TWO_BYTES( 'n', 'g' ), 
    TWO_BYTES( 'e', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinChallenge2Tag = { g_rgchDomJoinChallenge2Tag, 9 };


/* "Domain" */
const DRM_CHAR g_rgchDomJoinDomainTag [] =
{
    TWO_BYTES( 'D', 'o' ), TWO_BYTES( 'm', 'a' ), TWO_BYTES( 'i', 'n' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinDomainTag = { g_rgchDomJoinDomainTag, 6 };


/* "Data" */
const DRM_CHAR g_rgchDomJoinDataTag [] =
{
    TWO_BYTES( 'D', 'a' ), TWO_BYTES( 't', 'a' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinDataTag = { g_rgchDomJoinDataTag, 4 };


/* "ServiceID" */
const DRM_CHAR g_rgchDomJoinServiceIDTag [] =
{
    TWO_BYTES( 'S', 'e' ), TWO_BYTES( 'r', 'v' ), TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'e', 'I' ), 
    TWO_BYTES( 'D', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinServiceIDTag = { g_rgchDomJoinServiceIDTag, 9 };


/* "AccountID" */
const DRM_CHAR g_rgchDomJoinAccountIDTag [] =
{
    TWO_BYTES( 'A', 'c' ), TWO_BYTES( 'c', 'o' ), TWO_BYTES( 'u', 'n' ), TWO_BYTES( 't', 'I' ), 
    TWO_BYTES( 'D', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinAccountIDTag = { g_rgchDomJoinAccountIDTag, 9 };


/* "Revision" */
const DRM_CHAR g_rgchDomJoinRevisionTag [] =
{
    TWO_BYTES( 'R', 'e' ), TWO_BYTES( 'v', 'i' ), TWO_BYTES( 's', 'i' ), TWO_BYTES( 'o', 'n' ), 
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinRevisionTag = { g_rgchDomJoinRevisionTag, 8 };


/* "FriendlyName" */
const DRM_CHAR g_rgchDomJoinFriendlyNameTag [] =
{
    TWO_BYTES( 'F', 'r' ), TWO_BYTES( 'i', 'e' ), TWO_BYTES( 'n', 'd' ), TWO_BYTES( 'l', 'y' ), 
    TWO_BYTES( 'N', 'a' ), TWO_BYTES( 'm', 'e' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinFriendlyNameTag = { g_rgchDomJoinFriendlyNameTag, 12 };


/* "CustomData" */
const DRM_CHAR g_rgchDomJoinCustomDataTag [] =
{
    TWO_BYTES( 'C', 'u' ), TWO_BYTES( 's', 't' ), TWO_BYTES( 'o', 'm' ), TWO_BYTES( 'D', 'a' ), 
    TWO_BYTES( 't', 'a' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinCustomDataTag = { g_rgchDomJoinCustomDataTag, 10 };


/* "CertificateChain" */
const DRM_CHAR g_rgchDomJoinCertificateChainTag [] =
{
    TWO_BYTES( 'C', 'e' ), TWO_BYTES( 'r', 't' ), TWO_BYTES( 'i', 'f' ), TWO_BYTES( 'i', 'c' ), 
    TWO_BYTES( 'a', 't' ), TWO_BYTES( 'e', 'C' ), TWO_BYTES( 'h', 'a' ), TWO_BYTES( 'i', 'n' ), 
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinCertificateChainTag = { g_rgchDomJoinCertificateChainTag, 16 };



/* "xmlns" */
const DRM_CHAR g_rgchDomJoinRootAttribName [] =
{
    TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', 'n' ), TWO_BYTES( 's', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinRootAttribName = { g_rgchDomJoinRootAttribName, 5 };

/* "http://schemas.microsoft.com/DRM/2007/03/protocols" */
const DRM_CHAR g_rgchDomJoinRootAttribValue [] =
{
    TWO_BYTES( 'h', 't' ), TWO_BYTES( 't', 'p' ), TWO_BYTES( ':', '/' ), TWO_BYTES( '/', 's' ), 
    TWO_BYTES( 'c', 'h' ), TWO_BYTES( 'e', 'm' ), TWO_BYTES( 'a', 's' ), TWO_BYTES( '.', 'm' ), 
    TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'r', 'o' ), TWO_BYTES( 's', 'o' ), TWO_BYTES( 'f', 't' ), 
    TWO_BYTES( '.', 'c' ), TWO_BYTES( 'o', 'm' ), TWO_BYTES( '/', 'D' ), TWO_BYTES( 'R', 'M' ), 
    TWO_BYTES( '/', '2' ), TWO_BYTES( '0', '0' ), TWO_BYTES( '7', '/' ), TWO_BYTES( '0', '3' ), 
    TWO_BYTES( '/', 'p' ), TWO_BYTES( 'r', 'o' ), TWO_BYTES( 't', 'o' ), TWO_BYTES( 'c', 'o' ), 
    TWO_BYTES( 'l', 's' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinRootAttribValue = { g_rgchDomJoinRootAttribValue, 50 };


/* "xmlns" */
const DRM_CHAR g_rgchDomJoinChallenge2AttribName [] =
{
    TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', 'n' ), TWO_BYTES( 's', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinChallenge2AttribName = { g_rgchDomJoinChallenge2AttribName, 5 };

/* "http://schemas.microsoft.com/DRM/2007/03/protocols/messages" */
const DRM_CHAR g_rgchDomJoinChallenge2AttribValue [] =
{
    TWO_BYTES( 'h', 't' ), TWO_BYTES( 't', 'p' ), TWO_BYTES( ':', '/' ), TWO_BYTES( '/', 's' ), 
    TWO_BYTES( 'c', 'h' ), TWO_BYTES( 'e', 'm' ), TWO_BYTES( 'a', 's' ), TWO_BYTES( '.', 'm' ), 
    TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'r', 'o' ), TWO_BYTES( 's', 'o' ), TWO_BYTES( 'f', 't' ), 
    TWO_BYTES( '.', 'c' ), TWO_BYTES( 'o', 'm' ), TWO_BYTES( '/', 'D' ), TWO_BYTES( 'R', 'M' ), 
    TWO_BYTES( '/', '2' ), TWO_BYTES( '0', '0' ), TWO_BYTES( '7', '/' ), TWO_BYTES( '0', '3' ), 
    TWO_BYTES( '/', 'p' ), TWO_BYTES( 'r', 'o' ), TWO_BYTES( 't', 'o' ), TWO_BYTES( 'c', 'o' ), 
    TWO_BYTES( 'l', 's' ), TWO_BYTES( '/', 'm' ), TWO_BYTES( 'e', 's' ), TWO_BYTES( 's', 'a' ), 
    TWO_BYTES( 'g', 'e' ), TWO_BYTES( 's', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinChallenge2AttribValue = { g_rgchDomJoinChallenge2AttribValue, 59 };


/* "xmlns" */
const DRM_CHAR g_rgchDomJoinDomainAttrib1Name [] =
{
    TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', 'n' ), TWO_BYTES( 's', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinDomainAttrib1Name = { g_rgchDomJoinDomainAttrib1Name, 5 };

/* "http://schemas.microsoft.com/DRM/2007/03/protocols" */
const DRM_CHAR g_rgchDomJoinDomainAttrib1Value [] =
{
    TWO_BYTES( 'h', 't' ), TWO_BYTES( 't', 'p' ), TWO_BYTES( ':', '/' ), TWO_BYTES( '/', 's' ), 
    TWO_BYTES( 'c', 'h' ), TWO_BYTES( 'e', 'm' ), TWO_BYTES( 'a', 's' ), TWO_BYTES( '.', 'm' ), 
    TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'r', 'o' ), TWO_BYTES( 's', 'o' ), TWO_BYTES( 'f', 't' ), 
    TWO_BYTES( '.', 'c' ), TWO_BYTES( 'o', 'm' ), TWO_BYTES( '/', 'D' ), TWO_BYTES( 'R', 'M' ), 
    TWO_BYTES( '/', '2' ), TWO_BYTES( '0', '0' ), TWO_BYTES( '7', '/' ), TWO_BYTES( '0', '3' ), 
    TWO_BYTES( '/', 'p' ), TWO_BYTES( 'r', 'o' ), TWO_BYTES( 't', 'o' ), TWO_BYTES( 'c', 'o' ), 
    TWO_BYTES( 'l', 's' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinDomainAttrib1Value = { g_rgchDomJoinDomainAttrib1Value, 50 };


/* "Id" */
const DRM_CHAR g_rgchDomJoinDomainAttrib2Name [] =
{
    TWO_BYTES( 'I', 'd' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinDomainAttrib2Name = { g_rgchDomJoinDomainAttrib2Name, 2 };

/* "SignedData" */
const DRM_CHAR g_rgchDomJoinDomainAttrib2Value [] =
{
    TWO_BYTES( 'S', 'i' ), TWO_BYTES( 'g', 'n' ), TWO_BYTES( 'e', 'd' ), TWO_BYTES( 'D', 'a' ), 
    TWO_BYTES( 't', 'a' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinDomainAttrib2Value = { g_rgchDomJoinDomainAttrib2Value, 10 };


/* "Type" */
const DRM_CHAR g_rgchDomJoinCertificateChainAttribName [] =
{
    TWO_BYTES( 'T', 'y' ), TWO_BYTES( 'p', 'e' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinCertificateChainAttribName = { g_rgchDomJoinCertificateChainAttribName, 4 };

/* "device" */
const DRM_CHAR g_rgchDomJoinCertificateChainAttribValue [] =
{
    TWO_BYTES( 'd', 'e' ), TWO_BYTES( 'v', 'i' ), TWO_BYTES( 'c', 'e' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinCertificateChainAttribValue = { g_rgchDomJoinCertificateChainAttribValue, 6 };



/* "1" */
const DRM_CHAR g_rgchDomainJoinVersion [] =
{
    TWO_BYTES( '1', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomainJoinVersion = { g_rgchDomainJoinVersion, 1 };




/*
** --------------------------------------------------------------
** XML strings used in the construction of domain leave challenge
** --------------------------------------------------------------
*/
/* "LeaveDomain" */
const DRM_CHAR g_rgchDomLeaveRootTag [] =
{
    TWO_BYTES( 'L', 'e' ), TWO_BYTES( 'a', 'v' ), TWO_BYTES( 'e', 'D' ), TWO_BYTES( 'o', 'm' ), 
    TWO_BYTES( 'a', 'i' ), TWO_BYTES( 'n', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomLeaveRootTag = { g_rgchDomLeaveRootTag, 11 };


/* "Version" */
const DRM_CHAR g_rgchDomLeaveVersionTag [] =
{
    TWO_BYTES( 'V', 'e' ), TWO_BYTES( 'r', 's' ), TWO_BYTES( 'i', 'o' ), TWO_BYTES( 'n', '\0' ), 
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomLeaveVersionTag = { g_rgchDomLeaveVersionTag, 7 };


/* "challenge" */
const DRM_CHAR g_rgchDomLeaveChallenge1Tag [] =
{
    TWO_BYTES( 'c', 'h' ), TWO_BYTES( 'a', 'l' ), TWO_BYTES( 'l', 'e' ), TWO_BYTES( 'n', 'g' ), 
    TWO_BYTES( 'e', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomLeaveChallenge1Tag = { g_rgchDomLeaveChallenge1Tag, 9 };


/* "Challenge" */
const DRM_CHAR g_rgchDomLeaveChallenge2Tag [] =
{
    TWO_BYTES( 'C', 'h' ), TWO_BYTES( 'a', 'l' ), TWO_BYTES( 'l', 'e' ), TWO_BYTES( 'n', 'g' ), 
    TWO_BYTES( 'e', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomLeaveChallenge2Tag = { g_rgchDomLeaveChallenge2Tag, 9 };


/* "Domain" */
const DRM_CHAR g_rgchDomLeaveDomainTag [] =
{
    TWO_BYTES( 'D', 'o' ), TWO_BYTES( 'm', 'a' ), TWO_BYTES( 'i', 'n' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomLeaveDomainTag = { g_rgchDomLeaveDomainTag, 6 };


/* "Data" */
const DRM_CHAR g_rgchDomLeaveDataTag [] =
{
    TWO_BYTES( 'D', 'a' ), TWO_BYTES( 't', 'a' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomLeaveDataTag = { g_rgchDomLeaveDataTag, 4 };


/* "AccountID" */
const DRM_CHAR g_rgchDomLeaveAccountIDTag [] =
{
    TWO_BYTES( 'A', 'c' ), TWO_BYTES( 'c', 'o' ), TWO_BYTES( 'u', 'n' ), TWO_BYTES( 't', 'I' ), 
    TWO_BYTES( 'D', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomLeaveAccountIDTag = { g_rgchDomLeaveAccountIDTag, 9 };


/* "CustomData" */
const DRM_CHAR g_rgchDomLeaveCustomDataTag [] =
{
    TWO_BYTES( 'C', 'u' ), TWO_BYTES( 's', 't' ), TWO_BYTES( 'o', 'm' ), TWO_BYTES( 'D', 'a' ), 
    TWO_BYTES( 't', 'a' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomLeaveCustomDataTag = { g_rgchDomLeaveCustomDataTag, 10 };


/* "CertificateChain" */
const DRM_CHAR g_rgchDomLeaveCertificateChainTag [] =
{
    TWO_BYTES( 'C', 'e' ), TWO_BYTES( 'r', 't' ), TWO_BYTES( 'i', 'f' ), TWO_BYTES( 'i', 'c' ), 
    TWO_BYTES( 'a', 't' ), TWO_BYTES( 'e', 'C' ), TWO_BYTES( 'h', 'a' ), TWO_BYTES( 'i', 'n' ), 
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomLeaveCertificateChainTag = { g_rgchDomLeaveCertificateChainTag, 16 };



/* "xmlns" */
const DRM_CHAR g_rgchDomLeaveRootAttribName [] =
{
    TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', 'n' ), TWO_BYTES( 's', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomLeaveRootAttribName = { g_rgchDomLeaveRootAttribName, 5 };

/* "http://schemas.microsoft.com/DRM/2007/03/protocols" */
const DRM_CHAR g_rgchDomLeaveRootAttribValue [] =
{
    TWO_BYTES( 'h', 't' ), TWO_BYTES( 't', 'p' ), TWO_BYTES( ':', '/' ), TWO_BYTES( '/', 's' ), 
    TWO_BYTES( 'c', 'h' ), TWO_BYTES( 'e', 'm' ), TWO_BYTES( 'a', 's' ), TWO_BYTES( '.', 'm' ), 
    TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'r', 'o' ), TWO_BYTES( 's', 'o' ), TWO_BYTES( 'f', 't' ), 
    TWO_BYTES( '.', 'c' ), TWO_BYTES( 'o', 'm' ), TWO_BYTES( '/', 'D' ), TWO_BYTES( 'R', 'M' ), 
    TWO_BYTES( '/', '2' ), TWO_BYTES( '0', '0' ), TWO_BYTES( '7', '/' ), TWO_BYTES( '0', '3' ), 
    TWO_BYTES( '/', 'p' ), TWO_BYTES( 'r', 'o' ), TWO_BYTES( 't', 'o' ), TWO_BYTES( 'c', 'o' ), 
    TWO_BYTES( 'l', 's' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomLeaveRootAttribValue = { g_rgchDomLeaveRootAttribValue, 50 };


/* "xmlns" */
const DRM_CHAR g_rgchDomLeaveChallenge2AttribName [] =
{
    TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', 'n' ), TWO_BYTES( 's', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomLeaveChallenge2AttribName = { g_rgchDomLeaveChallenge2AttribName, 5 };

/* "http://schemas.microsoft.com/DRM/2007/03/protocols/messages" */
const DRM_CHAR g_rgchDomLeaveChallenge2AttribValue [] =
{
    TWO_BYTES( 'h', 't' ), TWO_BYTES( 't', 'p' ), TWO_BYTES( ':', '/' ), TWO_BYTES( '/', 's' ), 
    TWO_BYTES( 'c', 'h' ), TWO_BYTES( 'e', 'm' ), TWO_BYTES( 'a', 's' ), TWO_BYTES( '.', 'm' ), 
    TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'r', 'o' ), TWO_BYTES( 's', 'o' ), TWO_BYTES( 'f', 't' ), 
    TWO_BYTES( '.', 'c' ), TWO_BYTES( 'o', 'm' ), TWO_BYTES( '/', 'D' ), TWO_BYTES( 'R', 'M' ), 
    TWO_BYTES( '/', '2' ), TWO_BYTES( '0', '0' ), TWO_BYTES( '7', '/' ), TWO_BYTES( '0', '3' ), 
    TWO_BYTES( '/', 'p' ), TWO_BYTES( 'r', 'o' ), TWO_BYTES( 't', 'o' ), TWO_BYTES( 'c', 'o' ), 
    TWO_BYTES( 'l', 's' ), TWO_BYTES( '/', 'm' ), TWO_BYTES( 'e', 's' ), TWO_BYTES( 's', 'a' ), 
    TWO_BYTES( 'g', 'e' ), TWO_BYTES( 's', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomLeaveChallenge2AttribValue = { g_rgchDomLeaveChallenge2AttribValue, 59 };


/* "xmlns" */
const DRM_CHAR g_rgchDomLeaveDomainAttrib1Name [] =
{
    TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', 'n' ), TWO_BYTES( 's', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomLeaveDomainAttrib1Name = { g_rgchDomLeaveDomainAttrib1Name, 5 };

/* "http://schemas.microsoft.com/DRM/2007/03/protocols" */
const DRM_CHAR g_rgchDomLeaveDomainAttrib1Value [] =
{
    TWO_BYTES( 'h', 't' ), TWO_BYTES( 't', 'p' ), TWO_BYTES( ':', '/' ), TWO_BYTES( '/', 's' ), 
    TWO_BYTES( 'c', 'h' ), TWO_BYTES( 'e', 'm' ), TWO_BYTES( 'a', 's' ), TWO_BYTES( '.', 'm' ), 
    TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'r', 'o' ), TWO_BYTES( 's', 'o' ), TWO_BYTES( 'f', 't' ), 
    TWO_BYTES( '.', 'c' ), TWO_BYTES( 'o', 'm' ), TWO_BYTES( '/', 'D' ), TWO_BYTES( 'R', 'M' ), 
    TWO_BYTES( '/', '2' ), TWO_BYTES( '0', '0' ), TWO_BYTES( '7', '/' ), TWO_BYTES( '0', '3' ), 
    TWO_BYTES( '/', 'p' ), TWO_BYTES( 'r', 'o' ), TWO_BYTES( 't', 'o' ), TWO_BYTES( 'c', 'o' ), 
    TWO_BYTES( 'l', 's' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomLeaveDomainAttrib1Value = { g_rgchDomLeaveDomainAttrib1Value, 50 };


/* "Id" */
const DRM_CHAR g_rgchDomLeaveDomainAttrib2Name [] =
{
    TWO_BYTES( 'I', 'd' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomLeaveDomainAttrib2Name = { g_rgchDomLeaveDomainAttrib2Name, 2 };

/* "SignedData" */
const DRM_CHAR g_rgchDomLeaveDomainAttrib2Value [] =
{
    TWO_BYTES( 'S', 'i' ), TWO_BYTES( 'g', 'n' ), TWO_BYTES( 'e', 'd' ), TWO_BYTES( 'D', 'a' ), 
    TWO_BYTES( 't', 'a' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomLeaveDomainAttrib2Value = { g_rgchDomLeaveDomainAttrib2Value, 10 };


/* "Type" */
const DRM_CHAR g_rgchDomLeaveCertificateChainAttribName [] =
{
    TWO_BYTES( 'T', 'y' ), TWO_BYTES( 'p', 'e' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomLeaveCertificateChainAttribName = { g_rgchDomLeaveCertificateChainAttribName, 4 };

/* "device" */
const DRM_CHAR g_rgchDomLeaveCertificateChainAttribValue [] =
{
    TWO_BYTES( 'd', 'e' ), TWO_BYTES( 'v', 'i' ), TWO_BYTES( 'c', 'e' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomLeaveCertificateChainAttribValue = { g_rgchDomLeaveCertificateChainAttribValue, 6 };


/* "1" */
const DRM_CHAR g_rgchDomainLeaveVersion [] =
{
    TWO_BYTES( '1', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomainLeaveVersion = { g_rgchDomainLeaveVersion, 1 };




/* 
** -------------------------------------------------------
** XML strings used in the parsing of domain join response
** -------------------------------------------------------
*/
/* "JoinDomainResponse" */
const DRM_CHAR g_rgchDomJoinResponsePath [] =
{
    TWO_BYTES( 'J', 'o' ), TWO_BYTES( 'i', 'n' ), TWO_BYTES( 'D', 'o' ), TWO_BYTES( 'm', 'a' ), 
    TWO_BYTES( 'i', 'n' ), TWO_BYTES( 'R', 'e' ), TWO_BYTES( 's', 'p' ), TWO_BYTES( 'o', 'n' ), 
    TWO_BYTES( 's', 'e' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinResponsePath = { g_rgchDomJoinResponsePath, 18 };


/* "JoinDomainResult/Response/Signature" */
const DRM_CHAR g_rgchDomJoinSignaturePath [] =
{
    TWO_BYTES( 'J', 'o' ), TWO_BYTES( 'i', 'n' ), TWO_BYTES( 'D', 'o' ), TWO_BYTES( 'm', 'a' ), 
    TWO_BYTES( 'i', 'n' ), TWO_BYTES( 'R', 'e' ), TWO_BYTES( 's', 'u' ), TWO_BYTES( 'l', 't' ), 
    TWO_BYTES( '/', 'R' ), TWO_BYTES( 'e', 's' ), TWO_BYTES( 'p', 'o' ), TWO_BYTES( 'n', 's' ), 
    TWO_BYTES( 'e', '/' ), TWO_BYTES( 'S', 'i' ), TWO_BYTES( 'g', 'n' ), TWO_BYTES( 'a', 't' ), 
    TWO_BYTES( 'u', 'r' ), TWO_BYTES( 'e', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinSignaturePath = { g_rgchDomJoinSignaturePath, 35 };


/* "JoinDomainResult/Response/Domain" */
const DRM_CHAR g_rgchDomJoinDomainPath [] =
{
    TWO_BYTES( 'J', 'o' ), TWO_BYTES( 'i', 'n' ), TWO_BYTES( 'D', 'o' ), TWO_BYTES( 'm', 'a' ), 
    TWO_BYTES( 'i', 'n' ), TWO_BYTES( 'R', 'e' ), TWO_BYTES( 's', 'u' ), TWO_BYTES( 'l', 't' ), 
    TWO_BYTES( '/', 'R' ), TWO_BYTES( 'e', 's' ), TWO_BYTES( 'p', 'o' ), TWO_BYTES( 'n', 's' ), 
    TWO_BYTES( 'e', '/' ), TWO_BYTES( 'D', 'o' ), TWO_BYTES( 'm', 'a' ), TWO_BYTES( 'i', 'n' ), 
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinDomainPath = { g_rgchDomJoinDomainPath, 32 };


/* "JoinDomainResult/Response/Domain/EncryptedData" */
const DRM_CHAR g_rgchDomJoinEncryptedDataPath [] =
{
    TWO_BYTES( 'J', 'o' ), TWO_BYTES( 'i', 'n' ), TWO_BYTES( 'D', 'o' ), TWO_BYTES( 'm', 'a' ), 
    TWO_BYTES( 'i', 'n' ), TWO_BYTES( 'R', 'e' ), TWO_BYTES( 's', 'u' ), TWO_BYTES( 'l', 't' ), 
    TWO_BYTES( '/', 'R' ), TWO_BYTES( 'e', 's' ), TWO_BYTES( 'p', 'o' ), TWO_BYTES( 'n', 's' ), 
    TWO_BYTES( 'e', '/' ), TWO_BYTES( 'D', 'o' ), TWO_BYTES( 'm', 'a' ), TWO_BYTES( 'i', 'n' ), 
    TWO_BYTES( '/', 'E' ), TWO_BYTES( 'n', 'c' ), TWO_BYTES( 'r', 'y' ), TWO_BYTES( 'p', 't' ), 
    TWO_BYTES( 'e', 'd' ), TWO_BYTES( 'D', 'a' ), TWO_BYTES( 't', 'a' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinEncryptedDataPath = { g_rgchDomJoinEncryptedDataPath, 46 };


/* "JoinDomainResult/Response/Domain/EncryptedData/KeyInfo/EncryptedKey/KeyInfo" */
const DRM_CHAR g_rgchDomJoinKeyInfoPath [] =
{
    TWO_BYTES( 'J', 'o' ), TWO_BYTES( 'i', 'n' ), TWO_BYTES( 'D', 'o' ), TWO_BYTES( 'm', 'a' ), 
    TWO_BYTES( 'i', 'n' ), TWO_BYTES( 'R', 'e' ), TWO_BYTES( 's', 'u' ), TWO_BYTES( 'l', 't' ), 
    TWO_BYTES( '/', 'R' ), TWO_BYTES( 'e', 's' ), TWO_BYTES( 'p', 'o' ), TWO_BYTES( 'n', 's' ), 
    TWO_BYTES( 'e', '/' ), TWO_BYTES( 'D', 'o' ), TWO_BYTES( 'm', 'a' ), TWO_BYTES( 'i', 'n' ), 
    TWO_BYTES( '/', 'E' ), TWO_BYTES( 'n', 'c' ), TWO_BYTES( 'r', 'y' ), TWO_BYTES( 'p', 't' ), 
    TWO_BYTES( 'e', 'd' ), TWO_BYTES( 'D', 'a' ), TWO_BYTES( 't', 'a' ), TWO_BYTES( '/', 'K' ), 
    TWO_BYTES( 'e', 'y' ), TWO_BYTES( 'I', 'n' ), TWO_BYTES( 'f', 'o' ), TWO_BYTES( '/', 'E' ), 
    TWO_BYTES( 'n', 'c' ), TWO_BYTES( 'r', 'y' ), TWO_BYTES( 'p', 't' ), TWO_BYTES( 'e', 'd' ), 
    TWO_BYTES( 'K', 'e' ), TWO_BYTES( 'y', '/' ), TWO_BYTES( 'K', 'e' ), TWO_BYTES( 'y', 'I' ), 
    TWO_BYTES( 'n', 'f' ), TWO_BYTES( 'o', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinKeyInfoPath = { g_rgchDomJoinKeyInfoPath, 75 };


/* "ServiceID" */
const DRM_CHAR g_rgchDomJoinServiceIDPath [] =
{
    TWO_BYTES( 'S', 'e' ), TWO_BYTES( 'r', 'v' ), TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'e', 'I' ), 
    TWO_BYTES( 'D', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinServiceIDPath = { g_rgchDomJoinServiceIDPath, 9 };


/* "AccountID" */
const DRM_CHAR g_rgchDomJoinAccountIDPath [] =
{
    TWO_BYTES( 'A', 'c' ), TWO_BYTES( 'c', 'o' ), TWO_BYTES( 'u', 'n' ), TWO_BYTES( 't', 'I' ), 
    TWO_BYTES( 'D', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinAccountIDPath = { g_rgchDomJoinAccountIDPath, 9 };


/* "CertificateChain" */
const DRM_CHAR g_rgchDomJoinCertificateChainPath [] =
{
    TWO_BYTES( 'C', 'e' ), TWO_BYTES( 'r', 't' ), TWO_BYTES( 'i', 'f' ), TWO_BYTES( 'i', 'c' ), 
    TWO_BYTES( 'a', 't' ), TWO_BYTES( 'e', 'C' ), TWO_BYTES( 'h', 'a' ), TWO_BYTES( 'i', 'n' ), 
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinCertificateChainPath = { g_rgchDomJoinCertificateChainPath, 16 };


/* "JoinDomainResult/Response/Domain/DomainKeys" */
const DRM_CHAR g_rgchDomJoinDomainKeysPath [] =
{
    TWO_BYTES( 'J', 'o' ), TWO_BYTES( 'i', 'n' ), TWO_BYTES( 'D', 'o' ), TWO_BYTES( 'm', 'a' ), 
    TWO_BYTES( 'i', 'n' ), TWO_BYTES( 'R', 'e' ), TWO_BYTES( 's', 'u' ), TWO_BYTES( 'l', 't' ), 
    TWO_BYTES( '/', 'R' ), TWO_BYTES( 'e', 's' ), TWO_BYTES( 'p', 'o' ), TWO_BYTES( 'n', 's' ), 
    TWO_BYTES( 'e', '/' ), TWO_BYTES( 'D', 'o' ), TWO_BYTES( 'm', 'a' ), TWO_BYTES( 'i', 'n' ), 
    TWO_BYTES( '/', 'D' ), TWO_BYTES( 'o', 'm' ), TWO_BYTES( 'a', 'i' ), TWO_BYTES( 'n', 'K' ), 
    TWO_BYTES( 'e', 'y' ), TWO_BYTES( 's', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinDomainKeysPath = { g_rgchDomJoinDomainKeysPath, 43 };


/*
** --------------------------------------------------------
** XML strings used in the parsing of domain leave response
** --------------------------------------------------------
*/
/* "LeaveDomainResult/Response/Domain" */
const DRM_CHAR g_rgchDomLeaveDomainPath [] =
{
    TWO_BYTES( 'L', 'e' ), TWO_BYTES( 'a', 'v' ), TWO_BYTES( 'e', 'D' ), TWO_BYTES( 'o', 'm' ), 
    TWO_BYTES( 'a', 'i' ), TWO_BYTES( 'n', 'R' ), TWO_BYTES( 'e', 's' ), TWO_BYTES( 'u', 'l' ), 
    TWO_BYTES( 't', '/' ), TWO_BYTES( 'R', 'e' ), TWO_BYTES( 's', 'p' ), TWO_BYTES( 'o', 'n' ), 
    TWO_BYTES( 's', 'e' ), TWO_BYTES( '/', 'D' ), TWO_BYTES( 'o', 'm' ), TWO_BYTES( 'a', 'i' ), 
    TWO_BYTES( 'n', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomLeaveDomainPath = { g_rgchDomLeaveDomainPath, 33 };


/* "LeaveDomainResult/Response/Domain/AccountID" */
const DRM_CHAR g_rgchDomLeaveAccountIDPath [] =
{
    TWO_BYTES( 'L', 'e' ), TWO_BYTES( 'a', 'v' ), TWO_BYTES( 'e', 'D' ), TWO_BYTES( 'o', 'm' ), 
    TWO_BYTES( 'a', 'i' ), TWO_BYTES( 'n', 'R' ), TWO_BYTES( 'e', 's' ), TWO_BYTES( 'u', 'l' ), 
    TWO_BYTES( 't', '/' ), TWO_BYTES( 'R', 'e' ), TWO_BYTES( 's', 'p' ), TWO_BYTES( 'o', 'n' ), 
    TWO_BYTES( 's', 'e' ), TWO_BYTES( '/', 'D' ), TWO_BYTES( 'o', 'm' ), TWO_BYTES( 'a', 'i' ), 
    TWO_BYTES( 'n', '/' ), TWO_BYTES( 'A', 'c' ), TWO_BYTES( 'c', 'o' ), TWO_BYTES( 'u', 'n' ), 
    TWO_BYTES( 't', 'I' ), TWO_BYTES( 'D', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomLeaveAccountIDPath = { g_rgchDomLeaveAccountIDPath, 43 };


/* "LeaveDomainResult/Response/Signature" */
const DRM_CHAR g_rgchDomLeaveSignaturePath [] =
{
    TWO_BYTES( 'L', 'e' ), TWO_BYTES( 'a', 'v' ), TWO_BYTES( 'e', 'D' ), TWO_BYTES( 'o', 'm' ), 
    TWO_BYTES( 'a', 'i' ), TWO_BYTES( 'n', 'R' ), TWO_BYTES( 'e', 's' ), TWO_BYTES( 'u', 'l' ), 
    TWO_BYTES( 't', '/' ), TWO_BYTES( 'R', 'e' ), TWO_BYTES( 's', 'p' ), TWO_BYTES( 'o', 'n' ), 
    TWO_BYTES( 's', 'e' ), TWO_BYTES( '/', 'S' ), TWO_BYTES( 'i', 'g' ), TWO_BYTES( 'n', 'a' ), 
    TWO_BYTES( 't', 'u' ), TWO_BYTES( 'r', 'e' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomLeaveSignaturePath = { g_rgchDomLeaveSignaturePath, 36 };




/* 
** ----------------------------------------------
** XML strings used in the parsing of custom data
** ----------------------------------------------
*/
/* "JoinDomainResult/Response/Domain/CustomData" */
const DRM_CHAR g_rgchDomJoinCustomDataPath [] =
{
    TWO_BYTES( 'J', 'o' ), TWO_BYTES( 'i', 'n' ), TWO_BYTES( 'D', 'o' ), TWO_BYTES( 'm', 'a' ), 
    TWO_BYTES( 'i', 'n' ), TWO_BYTES( 'R', 'e' ), TWO_BYTES( 's', 'u' ), TWO_BYTES( 'l', 't' ), 
    TWO_BYTES( '/', 'R' ), TWO_BYTES( 'e', 's' ), TWO_BYTES( 'p', 'o' ), TWO_BYTES( 'n', 's' ), 
    TWO_BYTES( 'e', '/' ), TWO_BYTES( 'D', 'o' ), TWO_BYTES( 'm', 'a' ), TWO_BYTES( 'i', 'n' ), 
    TWO_BYTES( '/', 'C' ), TWO_BYTES( 'u', 's' ), TWO_BYTES( 't', 'o' ), TWO_BYTES( 'm', 'D' ), 
    TWO_BYTES( 'a', 't' ), TWO_BYTES( 'a', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomJoinCustomDataPath = { g_rgchDomJoinCustomDataPath, 43 };


/* "LeaveDomainResult/Response/Domain/CustomData" */
const DRM_CHAR g_rgchDomLeaveCustomDataPath [] =
{
    TWO_BYTES( 'L', 'e' ), TWO_BYTES( 'a', 'v' ), TWO_BYTES( 'e', 'D' ), TWO_BYTES( 'o', 'm' ), 
    TWO_BYTES( 'a', 'i' ), TWO_BYTES( 'n', 'R' ), TWO_BYTES( 'e', 's' ), TWO_BYTES( 'u', 'l' ), 
    TWO_BYTES( 't', '/' ), TWO_BYTES( 'R', 'e' ), TWO_BYTES( 's', 'p' ), TWO_BYTES( 'o', 'n' ), 
    TWO_BYTES( 's', 'e' ), TWO_BYTES( '/', 'D' ), TWO_BYTES( 'o', 'm' ), TWO_BYTES( 'a', 'i' ), 
    TWO_BYTES( 'n', '/' ), TWO_BYTES( 'C', 'u' ), TWO_BYTES( 's', 't' ), TWO_BYTES( 'o', 'm' ), 
    TWO_BYTES( 'D', 'a' ), TWO_BYTES( 't', 'a' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrDomLeaveCustomDataPath = { g_rgchDomLeaveCustomDataPath, 44 };



#endif /* DRM_SUPPORT_DOMAINS */


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmdevicestore.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmdevicestore.h>
#include <drmdatastore.h>
#include <byteorder.h>

ENTER_PK_NAMESPACE_CODE;

#if DRM_SUPPORT_DEVICESTORE

/* DEVICEID */
const DRM_WCHAR g_wszDeviceID[]            = { ONE_WCHAR('D', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('V', '\0'), ONE_WCHAR('I', '\0'), ONE_WCHAR('C', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('I', '\0'), ONE_WCHAR('D', '\0') };

/* We store the size of the attribute name and attribute value as a DWORD */
#define DEVICESTORE_ENTRY_SIZE( namelen, contentlen ) ( SIZEOF( DRM_DWORD ) + namelen + SIZEOF( DRM_DWORD ) + contentlen )


static DRM_RESULT _CalculateStoreID( const DRM_BYTE *pbData, DRM_DWORD cbData, DRM_ID *pID )
{
    DRM_RESULT      dr  = DRM_SUCCESS;
    DRM_SHA_CONTEXT sha = DRM_SHA_CONTEXT_DEFAULT;
    DRM_BYTE        rgb[__CB_DECL( DRM_SHA1_DIGEST_LEN )] = { 0 };

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DEVICESTORE, PERF_FUNC__CalculateStoreID );

    ChkArg( pbData != NULL
        && cbData != 0
        && pID != NULL );

    ChkDR( DRM_SHA_Init( &sha, eDRM_SHA_1 ) );
    ChkDR( DRM_SHA_Update( pbData, cbData, &sha ) );
    ChkDR( DRM_SHA_Finalize( &sha, DRM_SHA1_DIGEST_LEN, rgb ) );
    MEMCPY( pID, rgb, SIZEOF( DRM_ID ) );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


static DRM_RESULT _CalculateKeyPassword(
    DRM_BB_CONTEXT *f_pcontextBBX,
    const DRM_ID *f_pid,
    DRM_BYTE f_rgbPassword[DRM_SHA1_DIGEST_LEN] )
{
    /* Assuming DRM_BBX_HashValue checks arguments */
    return DRM_BBX_HashValue( (DRM_BYTE*)f_pid, SIZEOF ( DRM_ID ), f_rgbPassword, f_pcontextBBX);
}

static DRM_RESULT _WriteDeviceStoreEntryItem( 
    IN      const DRM_BYTE *f_pbName, 
    IN      const DRM_DWORD f_cbName, 
    IN      const DRM_BYTE *f_pbContent, 
    IN      const DRM_DWORD f_cbContent, 
    IN OUT        DRM_BYTE *f_pbBase, 
    IN            DRM_DWORD f_ibOffset )
{
    DRM_DWORD dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DEVICESTORE, PERF_FUNC__WriteDeviceStoreEntryItem );

    ChkArg( f_pbName != NULL
        &&   f_cbName != 0
        &&   f_pbContent != NULL
        &&   f_pbBase != NULL );
    
    /* The caller must use the DEVICESTORE_ENTRY_SIZE macro to compute the required buffer size */

    DWORD_TO_NETWORKBYTES( f_pbBase, f_ibOffset, f_cbName );
    f_ibOffset += SIZEOF( DRM_DWORD );

    DRM_BYT_CopyBytes( f_pbBase, f_ibOffset, f_pbName, 0, f_cbName );
    f_ibOffset += f_cbName;

    DWORD_TO_NETWORKBYTES( f_pbBase, f_ibOffset, f_cbContent );
    f_ibOffset += SIZEOF( DRM_DWORD );

    DRM_BYT_CopyBytes( f_pbBase, f_ibOffset, f_pbContent, 0, f_cbContent );
    f_ibOffset += f_cbContent;

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

static DRM_RESULT _ReadDeviceStoreEntryItem( 
    OUT     DRM_DWORD *f_pibName, 
    OUT     DRM_DWORD *f_pcbName, 
    OUT     DRM_DWORD *f_pibContent, 
    OUT     DRM_DWORD *f_pcbContent, 
    IN      DRM_BYTE  *f_pbBase, 
    IN OUT  DRM_DWORD *f_pibOffset, 
    IN      DRM_DWORD  f_cbSize )
{
    DRM_DWORD dr = DRM_SUCCESS;
    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DEVICESTORE, PERF_FUNC__ReadDeviceStoreEntryItem );

    ChkArg( f_pibName != NULL
        &&   f_pcbName != NULL
        &&   f_pibContent != NULL
        &&   f_pcbContent != NULL
        &&   f_pbBase != NULL
        &&   f_pibOffset != NULL );

    /* The device data should terminate only at the exact end of the buffer */
    if( f_cbSize == *f_pibOffset )
    {
        ChkDR( DRM_E_NOMORE );
    }

    /* If the entry has extra bytes, but not enough for a DWORD, the entry is corrupt */
    ChkBOOL( f_cbSize >= ( *f_pibOffset + SIZEOF( DRM_DWORD ) ), DRM_E_INVALID_DEVSTORE_ENTRY );
    
    NETWORKBYTES_TO_DWORD( *f_pcbName, f_pbBase, *f_pibOffset );
    *f_pibOffset += SIZEOF( DRM_DWORD );

    ChkBOOL( f_cbSize >= ( *f_pibOffset + *f_pcbName + SIZEOF( DRM_DWORD ) ), DRM_E_INVALID_DEVSTORE_ENTRY );
    *f_pibName = *f_pibOffset;
    *f_pibOffset+= *f_pcbName;

    NETWORKBYTES_TO_DWORD( *f_pcbContent, f_pbBase, *f_pibOffset );
    *f_pibOffset += SIZEOF( DRM_DWORD );

    ChkBOOL( f_cbSize >= ( *f_pibOffset + *f_pcbContent ), DRM_E_INVALID_DEVSTORE_ENTRY );
    *f_pibContent = *f_pibOffset;
    *f_pibOffset += *f_pcbContent;

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

DRM_RESULT _SetDirtyFlag( _DeviceHandle *pDeviceHandle, DRM_DWORD dwIndex )
{
    DRM_DWORD   i = 0;
    DRM_RESULT  dr = DRM_SUCCESS;
    DRM_DWORD  *pdwNewList = NULL;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DEVICESTORE, PERF_FUNC__SetDirtyFlag );

    ChkArg( pDeviceHandle != NULL );

    for( i = 0; i < pDeviceHandle->dwNumDirtyAttributes; i++ )
    {
        if( pDeviceHandle->pdwDirtyAttributes[i] == dwIndex )
        {
            /* The dirty flag has already been set, so we're done */
            goto ErrorExit;
        }
    }

    if( pDeviceHandle->dwNumDirtyAttributes == pDeviceHandle->dwDirtyAttributesSize )
    {
        /* Our dirty attribute list buffer is full, so let's double it's size */
        ChkOverflow((pDeviceHandle->dwDirtyAttributesSize+1), pDeviceHandle->dwDirtyAttributesSize);
        ChkOverflow((2*(pDeviceHandle->dwDirtyAttributesSize+1)), (pDeviceHandle->dwDirtyAttributesSize+1));
        ChkOverflow((2*(pDeviceHandle->dwDirtyAttributesSize+1)*SIZEOF(DRM_DWORD)), (2*(pDeviceHandle->dwDirtyAttributesSize+1)));
        ChkMem( pdwNewList = (DRM_DWORD *)Oem_MemAlloc( 2 * (pDeviceHandle->dwDirtyAttributesSize + 1) * SIZEOF( DRM_DWORD ) ) );

        if( pDeviceHandle->dwNumDirtyAttributes > 0 )
        {
            DRM_BYT_CopyBytes( pdwNewList, 0, pDeviceHandle->pdwDirtyAttributes, 0, pDeviceHandle->dwDirtyAttributesSize * SIZEOF( DRM_DWORD ) );
        }
        
        SAFE_OEM_FREE( pDeviceHandle->pdwDirtyAttributes );
        pDeviceHandle->pdwDirtyAttributes = pdwNewList;
        pDeviceHandle->dwDirtyAttributesSize = (pDeviceHandle->dwDirtyAttributesSize + 1) * 2;

        pdwNewList = NULL;
    }

    pDeviceHandle->pdwDirtyAttributes[pDeviceHandle->dwNumDirtyAttributes++] = dwIndex;

ErrorExit:
    SAFE_OEM_FREE( pdwNewList );

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

DRM_RESULT _GetDirtyFlag( _DeviceHandle *pDeviceHandle, DRM_DWORD dwIndex, DRM_BOOL *pfDirty )
{
    DRM_DWORD   i = 0;
    DRM_RESULT  dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DEVICESTORE, PERF_FUNC__GetDirtyFlag );

    ChkArg( pDeviceHandle != NULL
            && pfDirty != NULL
            && pDeviceHandle->pdwDirtyAttributes != NULL );

    *pfDirty = FALSE;
    for( i = 0;i < pDeviceHandle->dwNumDirtyAttributes; i++ )
    {
        if( pDeviceHandle->pdwDirtyAttributes[i] == dwIndex )
        {
            /* The dirty flag had been set */
            *pfDirty = TRUE;
            break;
        }
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

DRM_RESULT _InitDeviceHandle( _DeviceHandle **ppDeviceHandle, _DeviceStoreContext *pDeviceStore, DRM_BYTE *pbDeviceID, DRM_DWORD cbDeviceID, DRM_BYTE *pbEntry, DRM_DWORD cbEntry)
{
    DRM_DWORD dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DEVICESTORE, PERF_FUNC__InitDeviceHandle );

    ChkArg( ppDeviceHandle );

    ChkMem( *ppDeviceHandle = (_DeviceHandle *)Oem_MemAlloc( SIZEOF( _DeviceHandle ) ) );
    ZEROMEM( *ppDeviceHandle, SIZEOF( _DeviceHandle ) );

    (*ppDeviceHandle)->oDeviceID.pbBlob = pbDeviceID;
    (*ppDeviceHandle)->oDeviceID.cbBlob = cbDeviceID;

    (*ppDeviceHandle)->pbEntry = pbEntry;
    (*ppDeviceHandle)->cbEntry = cbEntry;

    (*ppDeviceHandle)->pDeviceStoreContext = pDeviceStore;

    (*ppDeviceHandle)->dwDirtyAttributesSize = DEVICESTORE_NUMDIRTYATTRIBUTES_INTIAL;
    ChkMem( (*ppDeviceHandle)->pdwDirtyAttributes = (DRM_DWORD *)Oem_MemAlloc( DEVICESTORE_NUMDIRTYATTRIBUTES_INTIAL * SIZEOF( DRM_DWORD ) ) );

    /* We don't know how many attributes there are yet */
    (*ppDeviceHandle)->dwNumAttributes = DEVICESTORE_NUMATTRIBUTES_UNKNOWN;

ErrorExit:

    if( DRM_FAILED( dr ) )
    {
        if( ppDeviceHandle != NULL )
        {
            if( (*ppDeviceHandle)->pdwDirtyAttributes != NULL )
            {
                SAFE_OEM_FREE( (*ppDeviceHandle)->pdwDirtyAttributes );
            }
            
            SAFE_OEM_FREE( *ppDeviceHandle );
        }
    }
    
    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

DRM_API DRM_RESULT DRM_CALL DRM_DVS_Initialize(
    IN     DRM_DEVICESTORE_CONTEXT   *f_pDeviceStoreContext,
    IN     DRM_APP_CONTEXT       *f_pDeviceStoreInitData )
{
    DRM_RESULT                dr            = DRM_SUCCESS;
    DRM_APP_CONTEXT_INTERNAL *pContext     = (DRM_APP_CONTEXT_INTERNAL*)f_pDeviceStoreInitData;
    _DeviceStoreContext      *pDeviceStore = (_DeviceStoreContext*)f_pDeviceStoreContext;
    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DEVICESTORE, PERF_FUNC_DRM_DVS_Initialize );

    ChkArg(f_pDeviceStoreContext != NULL
        && f_pDeviceStoreInitData != NULL );

    /* Make sure that the size of the context matches the size of our _DeviceStoreContext */
    DRMSIZEASSERT( SIZEOF( DRM_DEVICESTORE_CONTEXT ), SIZEOF( _DeviceStoreContext ) );


    ZEROMEM( f_pDeviceStoreContext, SIZEOF( _DeviceStoreContext ) );

    /* Copy out pointers to the necessary contexts from DRM_APP_CONTEXT */
    pDeviceStore->pDatastore  = &pContext->oDatastoreHDS;
    pDeviceStore->pBBXContext = &pContext->oBlackBoxContext;
    pDeviceStore->pSecureStoreContext = &pContext->oSecStoreGlobalContext;

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}



DRM_API DRM_VOID DRM_CALL DRM_DVS_Uninitialize(
    IN OUT DRM_DEVICESTORE_CONTEXT      *f_pDeviceStoreContext )
{
    return;
}




DRM_API DRM_RESULT DRM_CALL DRM_DVS_RegisterDevice(
    IN OUT DRM_DEVICESTORE_CONTEXT      *f_pDeviceStoreContext,
    IN     DRM_BYTEBLOB                  f_DeviceID,
       OUT DRM_DEVICESTORE_HANDLE       *f_pDeviceHandle )
{
    DRM_RESULT                    dr            = DRM_SUCCESS;
    _DeviceStoreContext          *pDeviceStore = (_DeviceStoreContext*)f_pDeviceStoreContext;
    DRM_DWORD                     dwSize = 0,
                                  cbData = 0;
    DRM_BYTE                      rgbPassword[DRM_SHA1_DIGEST_LEN];
    DRM_ID                        key = {0};
    DRM_BYTE                     *pbData = NULL;
    _DeviceHandle                *pDeviceHandle = NULL;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DEVICESTORE, PERF_FUNC_DRM_DVS_RegisterDevice );

    ChkArg( f_pDeviceHandle             != NULL 
         && f_DeviceID.pbBlob           != NULL
         && f_DeviceID.cbBlob           > 0
         && f_pDeviceStoreContext       != NULL );
    
    *f_pDeviceHandle = NULL;


    ChkDR( _CalculateStoreID( f_DeviceID.pbBlob, f_DeviceID.cbBlob, &key ) );
    ChkDR( _CalculateKeyPassword( pDeviceStore->pBBXContext, &key, rgbPassword ) );


    /* Check for already registered...
    */
    dr = DRM_SST_GetData(   pDeviceStore->pSecureStoreContext,
                                 &key,
                                 &key,
                                 rgbPassword,
                                 SECURE_STORE_DEVICE_REGISTRATION_DATA,
                                 pDeviceStore->pDatastore,
                                 NULL,
                                 &dwSize );
    if( DRM_SUCCEEDED( dr )
        || dr == DRM_E_BUFFERTOOSMALL )
    {
       ChkDR( DRM_E_DEVICE_ALREADY_REGISTERED );
    }
    else if( dr != DRM_E_DSTSLOTNOTFOUND )
    {
        ChkDR( dr );
    }
    /* dr should be DRM_E_DSTSLOTNOTFOUND */
    

    /* Make a device handle 
    */
    ChkDR( _InitDeviceHandle( &pDeviceHandle, pDeviceStore, NULL, f_DeviceID.cbBlob, NULL, 0 ) );
    
    ChkMem( pDeviceHandle->oDeviceID.pbBlob = (DRM_BYTE *)Oem_MemAlloc( f_DeviceID.cbBlob ) );
    MEMCPY( pDeviceHandle->oDeviceID.pbBlob, f_DeviceID.pbBlob, f_DeviceID.cbBlob );


    /* Write the device ID as the first attribute
    */
    cbData = DEVICESTORE_ENTRY_SIZE( SIZEOF( g_wszDeviceID ), f_DeviceID.cbBlob );
    ChkMem( pbData = (DRM_BYTE *)Oem_MemAlloc( cbData ) );

    pDeviceHandle->pbEntry = pbData;
    pDeviceHandle->cbEntry = cbData;

    ChkDR( _WriteDeviceStoreEntryItem( (DRM_BYTE *)g_wszDeviceID, 
                                                        SIZEOF( g_wszDeviceID ), 
                                                        f_DeviceID.pbBlob, 
                                                        f_DeviceID.cbBlob, 
                                                        pbData,
                                                        0 ) );

    /* There is now just 1 attribute, the DEVICEID attribute */
    pDeviceHandle->dwNumAttributes = 1;

    /* We've created the device, so now let's commit it to the store */
    dr = DRM_SST_SetData( pDeviceStore->pSecureStoreContext,
                            &key,
                            &key,
                            rgbPassword,
                            SECURE_STORE_DEVICE_REGISTRATION_DATA,
                            pDeviceStore->pDatastore,
                            pDeviceHandle->pbEntry,
                            pDeviceHandle->cbEntry );


    *f_pDeviceHandle = pDeviceHandle;

ErrorExit:
    if( DRM_FAILED( dr )
        && pDeviceHandle != NULL )
    {
        /* We only want to free the handle, not commit it */
        pDeviceHandle->fDontCommitOnFree = TRUE;
        DRM_DVS_FreeDevice( pDeviceHandle );
    }
    
    DRM_PROFILING_LEAVE_SCOPE;

    return dr;

}



DRM_API DRM_RESULT DRM_CALL DRM_DVS_UnRegisterDevice(
    IN OUT DRM_DEVICESTORE_CONTEXT      *f_pDeviceStoreContext,
    IN     DRM_BYTEBLOB                  f_DeviceID )
{
    DRM_RESULT                    dr            = DRM_SUCCESS;
    _DeviceStoreContext          *pDeviceStore = (_DeviceStoreContext*)f_pDeviceStoreContext;
    DRM_ID                        key = {0};

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DEVICESTORE, PERF_FUNC_DRM_DVS_UnRegisterDevice );

    ChkArg(f_pDeviceStoreContext != NULL
         && f_DeviceID.pbBlob      != NULL );

    ChkDR( _CalculateStoreID( f_DeviceID.pbBlob, f_DeviceID.cbBlob, &key ) );
    
    ChkDR( DRM_SST_DeleteKey( pDeviceStore->pSecureStoreContext, 
                SECURE_STORE_DEVICE_REGISTRATION_DATA, 
                &key, 
                &key, 
                pDeviceStore->pDatastore ) );
    
ErrorExit:    

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


DRM_API DRM_VOID DRM_CALL DRM_DVS_FreeDevice(
    IN    DRM_DEVICESTORE_HANDLE            f_hDeviceHandle )
{
    _DeviceHandle                *pDeviceHandle = NULL;

    if( f_hDeviceHandle != NULL )
    {
        pDeviceHandle = (_DeviceHandle *)f_hDeviceHandle;

        if( !pDeviceHandle->fDontCommitOnFree )
        {
            DRM_DVS_CommitDevice( f_hDeviceHandle );
        }

        SAFE_OEM_FREE( pDeviceHandle->pbEntry );
        SAFE_OEM_FREE( pDeviceHandle->oDeviceID.pbBlob );
        SAFE_OEM_FREE( pDeviceHandle->pdwDirtyAttributes );
        SAFE_OEM_FREE( pDeviceHandle );
    }
    
    return;
}


DRM_API DRM_RESULT DRM_CALL DRM_DVS_GetFirstDevice(
    IN OUT DRM_DEVICESTORE_CONTEXT      *f_pDeviceStoreContext,
       OUT DRM_DEVICESTORE_HANDLE       *f_pDeviceHandle )
{
    DRM_RESULT                    dr            = DRM_SUCCESS;
    _DeviceStoreContext          *pDeviceStore = (_DeviceStoreContext*)f_pDeviceStoreContext;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DEVICESTORE, PERF_FUNC_DRM_DVS_GetFirstDevice );

    ChkArg( f_pDeviceStoreContext != NULL
        &&   f_pDeviceHandle        != NULL
        &&   !pDeviceStore->fEnumInited );

    ChkDR( DRM_SST_OpenEnumerator( SECURE_STORE_DEVICE_REGISTRATION_DATA,
                                    NULL,
                                    &pDeviceStore->oSecStoreEnum,
                                    pDeviceStore->pDatastore,
                                    FALSE) );

    pDeviceStore->fEnumInited = TRUE;
    ChkDR( DRM_DVS_GetNextDevice( f_pDeviceStoreContext, f_pDeviceHandle ) );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}



DRM_API DRM_RESULT DRM_CALL DRM_DVS_GetNextDevice(
    IN OUT DRM_DEVICESTORE_CONTEXT      *f_pDeviceStoreContext,
       OUT DRM_DEVICESTORE_HANDLE       *f_pDeviceHandle )
{
    DRM_RESULT                    dr            = DRM_SUCCESS;
    _DeviceStoreContext          *pDeviceStore = (_DeviceStoreContext*)f_pDeviceStoreContext;
    DRM_DWORD                     dwSize = 0,
                                  cbData = 0;
    DRM_BYTE                      rgbPassword[DRM_SHA1_DIGEST_LEN];
    DRM_ID                        key = {0};
    DRM_BYTE                     *pbData = NULL;
    _DeviceHandle                *pDeviceHandle = NULL;
    DRM_BYTEBLOB                  DeviceID = {NULL, 0};

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DEVICESTORE, PERF_FUNC_DRM_DVS_GetNextDevice );

    ChkArg( f_pDeviceStoreContext != NULL
        &&  f_pDeviceHandle        != NULL
        &&  pDeviceStore->fEnumInited );


    *f_pDeviceHandle = NULL;

    dr = DRM_SST_EnumNext(  &pDeviceStore->oSecStoreEnum,
                                  NULL,
                                 &key,
                                 &cbData );
    if ( DRM_E_NOMORE == dr )
    {
        pDeviceStore->fEnumInited = FALSE;
    }
    ChkDR(dr);

    /* Create the device handle */
    ChkDR( _InitDeviceHandle( &pDeviceHandle, pDeviceStore, NULL, 0, NULL, 0 ) );
    
    ChkMem( pbData = (DRM_BYTE *)Oem_MemAlloc( cbData ) );
    pDeviceHandle->pbEntry = pbData;
    pDeviceHandle->cbEntry = cbData;

    ChkDR( _CalculateKeyPassword( pDeviceStore->pBBXContext, &key, rgbPassword ) );

    dr = DRM_SST_GetData(   pDeviceStore->pSecureStoreContext,
                            &key,
                            &key,
                            rgbPassword,
                            SECURE_STORE_DEVICE_REGISTRATION_DATA,
                            pDeviceStore->pDatastore,
                            pbData,
                            &cbData );
    if( DRM_E_FILENOTFOUND == dr || DRM_E_DSTSLOTNOTFOUND == dr )
    {
        ChkDR( DRM_E_DEVICE_NOT_REGISTERED );
    }
    ChkDR( dr );

    *f_pDeviceHandle = pDeviceHandle;


    /* Load the device ID attribute into the handle */
    DeviceID.pbBlob = (DRM_BYTE*)g_wszDeviceID;
    DeviceID.cbBlob = SIZEOF( g_wszDeviceID );
    dwSize = 0;
    dr = DRM_DVS_GetDeviceAttr( *f_pDeviceHandle, DeviceID, NULL, &dwSize );
    if( dr != DRM_E_BUFFERTOOSMALL )
    {
        ChkDR( dr );
    }
    pDeviceHandle->oDeviceID.cbBlob = dwSize;

    if( dr == DRM_E_BUFFERTOOSMALL)
    {
        ChkMem( pDeviceHandle->oDeviceID.pbBlob = (DRM_BYTE *)Oem_MemAlloc( dwSize ) );
        ChkDR( DRM_DVS_GetDeviceAttr( *f_pDeviceHandle, DeviceID, pDeviceHandle->oDeviceID.pbBlob, &dwSize ) );
    }
    
ErrorExit:
    if( DRM_FAILED( dr )
        && pDeviceHandle != NULL )
    {
        /* We only want to free the handle, not commit it */
        pDeviceHandle->fDontCommitOnFree = TRUE;
        DRM_DVS_FreeDevice( pDeviceHandle );
    }
    
    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


DRM_API DRM_RESULT DRM_CALL DRM_DVS_GetDeviceByID(
    IN OUT DRM_DEVICESTORE_CONTEXT      *f_pDeviceStoreContext,
    IN     DRM_BYTEBLOB                     f_DeviceID,
       OUT DRM_DEVICESTORE_HANDLE            *f_pDeviceHandle )
{
    DRM_RESULT                    dr            = DRM_SUCCESS;
    _DeviceStoreContext          *pDeviceStore = (_DeviceStoreContext*)f_pDeviceStoreContext;
    DRM_DWORD                     cbData = 0;
    DRM_BYTE                      rgbPassword[DRM_SHA1_DIGEST_LEN];
    DRM_ID                        key = {0};
    DRM_BYTE                     *pbData = NULL;
    _DeviceHandle                *pDeviceHandle = NULL;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DEVICESTORE, PERF_FUNC_DRM_DVS_GetDeviceByID );

    ChkArg( f_pDeviceStoreContext != NULL
        &&   f_pDeviceHandle        != NULL );


    *f_pDeviceHandle = NULL;


    /* Create the device handle */
    ChkDR( _InitDeviceHandle( &pDeviceHandle, pDeviceStore, NULL, f_DeviceID.cbBlob, NULL, 0 ) );

    ChkMem( pDeviceHandle->oDeviceID.pbBlob = (DRM_BYTE *)Oem_MemAlloc( f_DeviceID.cbBlob ) );
    MEMCPY( pDeviceHandle->oDeviceID.pbBlob, f_DeviceID.pbBlob, f_DeviceID.cbBlob );

    ChkDR( _CalculateStoreID( f_DeviceID.pbBlob, f_DeviceID.cbBlob, &key ) );
    ChkDR( _CalculateKeyPassword( pDeviceStore->pBBXContext, &key, rgbPassword ) );

    dr = DRM_SST_GetData( pDeviceStore->pSecureStoreContext,
                                 &key,
                                 &key,
                                 rgbPassword,
                                 SECURE_STORE_DEVICE_REGISTRATION_DATA,
                                 pDeviceStore->pDatastore,
                                 NULL,
                                 &cbData );
    if( DRM_E_FILENOTFOUND == dr || DRM_E_DSTSLOTNOTFOUND == dr )
    {
        ChkDR( DRM_E_DEVICE_NOT_REGISTERED );
    }
    else if( dr == DRM_E_BUFFERTOOSMALL )
    {
        ChkMem( pbData = (DRM_BYTE *)Oem_MemAlloc( cbData ) );

        dr = DRM_SST_GetData( pDeviceStore->pSecureStoreContext,
                                &key,
                                &key,
                                rgbPassword,
                                SECURE_STORE_DEVICE_REGISTRATION_DATA,
                                pDeviceStore->pDatastore,
                                pbData,
                                &cbData );

        pDeviceHandle->pbEntry = pbData;
        pDeviceHandle->cbEntry = cbData;

        pDeviceHandle->pDeviceStoreContext = pDeviceStore;
    }
    ChkDR( dr );

    *f_pDeviceHandle = pDeviceHandle;
    
ErrorExit:
    if( DRM_FAILED( dr )
        && pDeviceHandle != NULL )
    {
        /* We only want to free the handle, not commit it */
        pDeviceHandle->fDontCommitOnFree = TRUE;
        DRM_DVS_FreeDevice( pDeviceHandle );
    }
    
    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

DRM_API DRM_RESULT DRM_CALL DRM_DVS_GetDeviceID(
    IN     DRM_DEVICESTORE_HANDLE             f_hDeviceHandle,
       OUT DRM_BYTE                        *f_pbDeviceID,
    IN OUT DRM_DWORD                       *f_pcbDeviceID )
{
    DRM_DWORD                     dr = DRM_SUCCESS;
    _DeviceHandle                *pDeviceHandle = (_DeviceHandle *)f_hDeviceHandle;
    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DEVICESTORE, PERF_FUNC_DRM_DVS_GetDeviceID );

    ChkArg( f_pcbDeviceID != NULL 
        && f_hDeviceHandle != NULL );


    if( *f_pcbDeviceID < pDeviceHandle->oDeviceID.cbBlob )
    {
        *f_pcbDeviceID = pDeviceHandle->oDeviceID.cbBlob;
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

    ChkArg( f_pbDeviceID != NULL );

    MEMCPY( f_pbDeviceID, pDeviceHandle->oDeviceID.pbBlob, pDeviceHandle->oDeviceID.cbBlob );
    *f_pcbDeviceID = pDeviceHandle->oDeviceID.cbBlob;


ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}



DRM_API DRM_RESULT DRM_CALL DRM_DVS_GetDeviceAttr(
    IN     DRM_DEVICESTORE_HANDLE             f_hDeviceHandle,
    IN     DRM_BYTEBLOB                     f_AttrName,
       OUT DRM_BYTE                        *f_pbAttrValue,
    IN OUT DRM_DWORD                       *f_pcbAttrValue )
{
    DRM_DWORD                     dr = DRM_SUCCESS;
    _DeviceHandle                *pDeviceHandle = (_DeviceHandle*)f_hDeviceHandle;
    DRM_DWORD                     ibOffset = 0;
    DRM_DWORD                     ibName = 0;
    DRM_DWORD                     cbName = 0;
    DRM_DWORD                     ibContent = 0;
    DRM_DWORD                     cbContent = 0;
    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DEVICESTORE, PERF_FUNC_DRM_DVS_GetDeviceAttr );

    ChkArg( f_hDeviceHandle != NULL
        && f_pcbAttrValue != NULL 
        && f_hDeviceHandle != NULL
        && f_AttrName.pbBlob != NULL 
        && f_AttrName.cbBlob != 0 
        && pDeviceHandle->pbEntry != NULL );

    do {
        ChkDR( _ReadDeviceStoreEntryItem(&ibName, 
                    &cbName, 
                    &ibContent, 
                    &cbContent, 
                    pDeviceHandle->pbEntry, 
                    &ibOffset, 
                    pDeviceHandle->cbEntry) );

        if( ( cbName == f_AttrName.cbBlob )
            && ( DRM_BYT_CompareBytes( pDeviceHandle->pbEntry, 
                    ibName, 
                    f_AttrName.pbBlob, 
                    0, 
                    f_AttrName.cbBlob ) == 0 ) )
        {

            if( *f_pcbAttrValue < cbContent )
            {
                *f_pcbAttrValue = cbContent;
                ChkDR( DRM_E_BUFFERTOOSMALL );
            }

            *f_pcbAttrValue = cbContent;

            ChkArg( f_pbAttrValue != NULL );

            DRM_BYT_CopyBytes( f_pbAttrValue, 0, pDeviceHandle->pbEntry, ibContent, cbContent );

            break;
        }
        
    } while( dr == DRM_SUCCESS );
    
ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}



DRM_API DRM_RESULT DRM_CALL DRM_DVS_GetDeviceAttrCount(
    IN     DRM_DEVICESTORE_HANDLE               f_hDeviceHandle,
       OUT DRM_DWORD                           *f_pdwAttrCount )
{
    DRM_DWORD                     dr = DRM_SUCCESS;
    _DeviceHandle                *pDeviceHandle = (_DeviceHandle*)f_hDeviceHandle;
    DRM_DWORD                     ibOffset = 0;
    DRM_DWORD                     ibName = 0;
    DRM_DWORD                     cbName = 0;
    DRM_DWORD                     ibContent = 0;
    DRM_DWORD                     cbContent = 0;
    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DEVICESTORE, PERF_FUNC_DRM_DVS_GetDeviceAttrCount );

    ChkArg( f_hDeviceHandle != NULL
        && f_pdwAttrCount != NULL
        && pDeviceHandle->pbEntry != NULL );

    if( DEVICESTORE_NUMATTRIBUTES_UNKNOWN == pDeviceHandle->dwNumAttributes )
    {
        *f_pdwAttrCount = 0;
        do {
            ChkDR( _ReadDeviceStoreEntryItem(&ibName, 
                        &cbName, 
                        &ibContent, 
                        &cbContent, 
                        pDeviceHandle->pbEntry, 
                        &ibOffset, 
                        pDeviceHandle->cbEntry) );


            (*f_pdwAttrCount)++;
        } while( dr == DRM_SUCCESS );

        /* Update our cache */
        pDeviceHandle->dwNumAttributes = (*f_pdwAttrCount);
    }
    else
    {
        *f_pdwAttrCount = pDeviceHandle->dwNumAttributes;
    }
    
ErrorExit:
    
    if( dr == DRM_E_NOMORE )
    {
        dr = DRM_SUCCESS;
    }
    
    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}



DRM_API DRM_RESULT DRM_CALL DRM_DVS_GetDeviceAttrByIndex(
    IN     DRM_DEVICESTORE_HANDLE             f_hDeviceHandle,
    IN     DRM_DWORD                        f_dwAttrIndex,
       OUT DRM_BYTE                        *f_pbAttrName,
    IN OUT DRM_DWORD                       *f_pcbAttrName,
       OUT DRM_BYTE                        *f_pbAttrValue,
    IN OUT DRM_DWORD                       *f_pcbAttrValue )
{
    DRM_DWORD                     dr = DRM_SUCCESS;
    _DeviceHandle                *pDeviceHandle = (_DeviceHandle*)f_hDeviceHandle;
    DRM_DWORD                     ibOffset = 0;
    DRM_DWORD                     ibName = 0;
    DRM_DWORD                     cbName = 0;
    DRM_DWORD                     ibContent = 0;
    DRM_DWORD                     cbContent = 0;
    DRM_DWORD                     dwIndex = 0;
    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DEVICESTORE, PERF_FUNC_DRM_DVS_GetDeviceAttrByIndex );

    ChkArg( f_hDeviceHandle != NULL );
    ChkArg( f_pcbAttrValue != NULL );
    ChkArg( f_pcbAttrName != NULL );
    ChkArg( f_dwAttrIndex >= 1 );
    ChkArg( pDeviceHandle->pbEntry != NULL );

    do {
        ChkDR( _ReadDeviceStoreEntryItem(&ibName, 
                    &cbName, 
                    &ibContent, 
                    &cbContent, 
                    pDeviceHandle->pbEntry, 
                    &ibOffset, 
                    pDeviceHandle->cbEntry) );

        if( dwIndex++ == f_dwAttrIndex )
        {

            if( *f_pcbAttrValue < cbContent )
            {
                *f_pcbAttrValue = cbContent;
                dr = DRM_E_BUFFERTOOSMALL;
            }

            if( *f_pcbAttrName < cbName )
            {
                *f_pcbAttrName = cbName;
                dr = DRM_E_BUFFERTOOSMALL;
            }
            ChkDR( dr );

            *f_pcbAttrValue = cbContent;
            *f_pcbAttrName = cbName;

            ChkArg( f_pbAttrValue != NULL
                && f_pbAttrName != NULL );

            DRM_BYT_CopyBytes( f_pbAttrValue, 0, pDeviceHandle->pbEntry, ibContent, cbContent );
            DRM_BYT_CopyBytes( f_pbAttrName, 0, pDeviceHandle->pbEntry, ibName, cbName );

            break;
        }
        
    } while( dr == DRM_SUCCESS );
    
ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


DRM_API DRM_RESULT DRM_CALL DRM_DVS_SetDeviceAttr(
    IN     DRM_DEVICESTORE_HANDLE           f_hDeviceHandle,
    IN     DRM_BYTEBLOB                     f_AttrName,
    IN     DRM_BYTEBLOB                     f_AttrValue )
{
    DRM_DWORD                     dr = DRM_SUCCESS;
    _DeviceHandle                *pDeviceHandle = (_DeviceHandle*)f_hDeviceHandle;
    DRM_DWORD                     ibOffset = 0;
    DRM_DWORD                     ibName = 0;
    DRM_DWORD                     cbName = 0;
    DRM_DWORD                     ibContent = 0;
    DRM_DWORD                     cbContent = 0;
    DRM_DWORD                     cbNewEntry = 0;
    DRM_BYTE                     *pbNew = NULL;
    DRM_DWORD                     dwIndex = 0;
    DRM_BOOL                      fFoundExisting = FALSE;

    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DEVICESTORE, PERF_FUNC_DRM_DVS_SetDeviceAttr );

    ChkArg( f_hDeviceHandle        != NULL );
    ChkArg( f_AttrValue.pbBlob     != NULL );
    ChkArg( f_hDeviceHandle        != NULL );
    ChkArg( f_AttrName.pbBlob      != NULL );
    ChkArg( f_AttrName.cbBlob      != 0    );
    ChkArg( pDeviceHandle->pbEntry != NULL );

    /* They can't change the device ID */
    ChkBOOL( f_AttrName.cbBlob != SIZEOF( g_wszDeviceID )
        || MEMCMP( f_AttrName.pbBlob, g_wszDeviceID, SIZEOF( g_wszDeviceID ) ) != 0, DRM_E_INVALID_DEVSTORE_ATTRIBUTE );


    /* Check to see if there's already an attribute with this name */
    do {
        dr = _ReadDeviceStoreEntryItem(&ibName, 
                    &cbName, 
                    &ibContent, 
                    &cbContent, 
                    pDeviceHandle->pbEntry, 
                    &ibOffset, 
                    pDeviceHandle->cbEntry);

        if(    DRM_SUCCEEDED( dr )
            && ( cbName == f_AttrName.cbBlob )
            && ( DRM_BYT_CompareBytes( pDeviceHandle->pbEntry, 
                    ibName, 
                    f_AttrName.pbBlob, 
                    0, 
                    f_AttrName.cbBlob ) == 0 ) )
        {
            /* We found an existing entry for this attribute name */
            fFoundExisting = TRUE;
            break;
        }

        dwIndex++;
    } while( dr == DRM_SUCCESS );

    if( dr != DRM_E_NOMORE )
    {
        ChkDR( dr );
    }


    if( fFoundExisting )
    {
        /* Found an existing attribute with this name, so need to overwrite it 
        */

        /* If the size of the attribute value has changed, we need to deal with it */
        if( cbContent != f_AttrValue.cbBlob )
        {
            ChkOverflow( pDeviceHandle->cbEntry, cbContent );
            ChkOverflow( pDeviceHandle->cbEntry - cbContent + f_AttrValue.cbBlob, pDeviceHandle->cbEntry - cbContent );            
            cbNewEntry = pDeviceHandle->cbEntry - cbContent + f_AttrValue.cbBlob;
            
            if( cbContent < f_AttrValue.cbBlob )
            {
                /* We need to allocate a new buffer to hold the larger sized value */
                ChkMem( pbNew = (DRM_BYTE *)Oem_MemAlloc( cbNewEntry ) );

                /* Copy the old data into the new buffer */
                DRM_BYT_CopyBytes( pbNew, 0, pDeviceHandle->pbEntry, 0, ibContent );
                DRM_BYT_CopyBytes( pbNew, ibContent + f_AttrValue.cbBlob, pDeviceHandle->pbEntry, ibContent + cbContent,  pDeviceHandle->cbEntry - ibContent - cbContent );

                /* Free the old buffer and replace it with the new one */
                SAFE_OEM_FREE( pDeviceHandle->pbEntry );
                pDeviceHandle->pbEntry = pbNew;
                pbNew = NULL;
            }
            else
            {
                /* The new attribute is shorter than the old one, so we can use the same buffer.
                   However, we have to shift the entry back by however much the difference in size is*/
                DRM_BYT_MoveBytes( pDeviceHandle->pbEntry, ibContent + f_AttrValue.cbBlob, pDeviceHandle->pbEntry, ibContent + cbContent,  pDeviceHandle->cbEntry - ibContent - cbContent );
            }
            pDeviceHandle->cbEntry = cbNewEntry;


            /* Store the new value size */
            DWORD_TO_NETWORKBYTES( pDeviceHandle->pbEntry, ibContent - SIZEOF( DRM_DWORD ), f_AttrValue.cbBlob );
        }


        /* Store the value */
        DRM_BYT_CopyBytes( pDeviceHandle->pbEntry, ibContent, f_AttrValue.pbBlob, 0, f_AttrValue.cbBlob );
    }
    else
    {
        /* The attribute name doesn't exist yet, so let's create it
        */

        dwIndex--;
        /* Allocate a new buffer to hold the additional entry */
        cbNewEntry = pDeviceHandle->cbEntry + DEVICESTORE_ENTRY_SIZE( f_AttrName.cbBlob, f_AttrValue.cbBlob);
        ChkOverflow(cbNewEntry, pDeviceHandle->cbEntry);

        ChkMem( pbNew = (DRM_BYTE *)Oem_MemAlloc( cbNewEntry ) );
        DRM_BYT_CopyBytes( pbNew, 0, pDeviceHandle->pbEntry, 0, pDeviceHandle->cbEntry );

        /* Write out the new entry */
        ChkDR( _WriteDeviceStoreEntryItem( f_AttrName.pbBlob, f_AttrName.cbBlob, f_AttrValue.pbBlob, f_AttrValue.cbBlob, pbNew, pDeviceHandle->cbEntry ) );

        /* Free the old buffer and replace it with the new one */
        SAFE_OEM_FREE( pDeviceHandle->pbEntry );
        pDeviceHandle->pbEntry = pbNew;
        pDeviceHandle->cbEntry = cbNewEntry;

        /* Keep our attribute count up to date */
        if( DEVICESTORE_NUMATTRIBUTES_UNKNOWN != pDeviceHandle->dwNumAttributes )
        {
            pDeviceHandle->dwNumAttributes++;
        }

        pbNew = NULL;
    }

    /* Set the dirty flag */
    ChkDR( _SetDirtyFlag( pDeviceHandle, dwIndex ) );
    
ErrorExit:

    SAFE_OEM_FREE( pbNew );

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;

}


DRM_API DRM_RESULT DRM_CALL DRM_DVS_CommitDevice(
    IN     DRM_DEVICESTORE_HANDLE             f_hDeviceHandle )
{
    DRM_RESULT                    dr            = DRM_SUCCESS;
    _DeviceStoreContext          *pDeviceStore = NULL;
    DRM_BYTE                      rgbPassword[DRM_SHA1_DIGEST_LEN];
    DRM_ID                        key = {0};
    _DeviceHandle                *pDeviceHandle = (_DeviceHandle *)f_hDeviceHandle;
    DRM_DWORD                     cbDataInStore = 0;
    _DeviceHandle                *pDeviceInStore = NULL;
    DRM_BYTEBLOB                  attrName = {NULL, 0};
    DRM_BYTEBLOB                  attrValue = {NULL, 0};

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DEVICESTORE, PERF_FUNC_DRM_DVS_CommitDevice );

    ChkArg( f_hDeviceHandle != NULL );
    ChkArg( pDeviceHandle->pbEntry != NULL
            && pDeviceHandle->cbEntry != 0
            && pDeviceHandle->oDeviceID.pbBlob != NULL
            && pDeviceHandle->oDeviceID.cbBlob != 0
            && pDeviceHandle->pDeviceStoreContext != NULL );

    pDeviceStore = pDeviceHandle->pDeviceStoreContext;

    ChkArg( pDeviceStore );
    
    ChkDR( _CalculateStoreID( pDeviceHandle->oDeviceID.pbBlob, pDeviceHandle->oDeviceID.cbBlob, &key ) );
    ChkDR( _CalculateKeyPassword( pDeviceStore->pBBXContext, &key, rgbPassword ) );



    ChkDR( DRM_SST_OpenAndLockSlot( pDeviceStore->pDatastore,
                                        SECURE_STORE_DEVICE_REGISTRATION_DATA,
                                        &key,
                                        &key,
                                        rgbPassword,
                                        DRM_SECURE_STORE_OPEN_ALWAYS,
                                        pDeviceStore->pSecureStoreContext,
                                        &cbDataInStore ) );

    

    /* Check if there is already data in the store */
    if( cbDataInStore != 0 )
    {
        DRM_DWORD i = 0;
        DRM_DWORD dwCount = 0;
        DRM_BOOL fDirty = FALSE;

        ChkMem( pDeviceInStore = (_DeviceHandle *)Oem_MemAlloc( SIZEOF( _DeviceHandle ) ) );
        ZEROMEM( pDeviceInStore, SIZEOF( _DeviceHandle ) );

        pDeviceInStore->cbEntry = cbDataInStore;
        ChkMem( pDeviceInStore->pbEntry = (DRM_BYTE *)Oem_MemAlloc( cbDataInStore ) );
        ChkDR( DRM_SST_GetLockedData( pDeviceStore->pSecureStoreContext, pDeviceInStore->pbEntry, &(pDeviceInStore->cbEntry) ) );

        if( pDeviceHandle->dwNumDirtyAttributes > 0 )
        {
            /* Since there are some dirty attributes, */
            /* we need to update the store with only the attributes that were changed */
            DRM_DVS_GetDeviceAttrCount( f_hDeviceHandle, &dwCount );
            for( i = 0; i < dwCount; i++ )
            {
                ChkDR( _GetDirtyFlag( pDeviceHandle, i, &fDirty ) );

                if( fDirty )
                {
                    attrName.cbBlob = 0;
                    attrValue.cbBlob = 0;
                    dr = DRM_DVS_GetDeviceAttrByIndex( f_hDeviceHandle, i, NULL, &(attrName.cbBlob), NULL, &(attrValue.cbBlob) );
                    
                    if( dr != DRM_E_BUFFERTOOSMALL )
                    {
                        ChkDR( dr );
                    }

                    ChkMem( attrName.pbBlob = (DRM_BYTE *)Oem_MemAlloc( attrName.cbBlob ) );
                    ChkMem( attrValue.pbBlob = (DRM_BYTE *)Oem_MemAlloc( attrValue.cbBlob ) );

                    ChkDR( DRM_DVS_GetDeviceAttrByIndex( f_hDeviceHandle, i, attrName.pbBlob, &(attrName.cbBlob), attrValue.pbBlob, &(attrValue.cbBlob) ) );

                    ChkDR( DRM_DVS_SetDeviceAttr( (DRM_DEVICESTORE_HANDLE)pDeviceInStore, attrName, attrValue ) );
                
                    SAFE_OEM_FREE( attrName.pbBlob );
                    SAFE_OEM_FREE( attrValue.pbBlob );
                }
            }
        }

        /* We now update our cache with the latest merged data */
        SAFE_OEM_FREE( pDeviceHandle->pbEntry );
        pDeviceHandle->pbEntry = pDeviceInStore->pbEntry;
        pDeviceHandle->cbEntry = pDeviceInStore->cbEntry;

        pDeviceInStore->pbEntry = NULL;
        pDeviceInStore->cbEntry = 0;

        /* We don't know how many attributes there are now since we merged */
        pDeviceHandle->dwNumAttributes = DEVICESTORE_NUMATTRIBUTES_UNKNOWN;
    }

    /* If we changed anything, we need to save it into the store */
    if( pDeviceHandle->dwNumDirtyAttributes > 0 )
    {
        ChkDR( DRM_SST_SetLockedData( pDeviceStore->pSecureStoreContext, pDeviceHandle->cbEntry, pDeviceHandle->pbEntry ) );
    }

    /* We just committed to the store, so nothing's dirty anymore. All clean. */
    pDeviceHandle->dwNumDirtyAttributes = 0;

ErrorExit:
    if( pDeviceStore != NULL )
    {
        DRM_SST_CloseLockedSlot( pDeviceStore->pSecureStoreContext );
    }

    if( pDeviceInStore != NULL)
    {
        /* We only want to free the handle, not commit it */
        pDeviceInStore->fDontCommitOnFree = TRUE;
        DRM_DVS_FreeDevice( (DRM_DEVICESTORE_HANDLE) pDeviceInStore );
    }

    SAFE_OEM_FREE( attrName.pbBlob );
    SAFE_OEM_FREE( attrValue.pbBlob );

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

#endif


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmdomainstore.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmtypes.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmdatastore.h>
#include <drmdomainstore.h>
#include <oem.h>
#include <drmbcertparser.h>

ENTER_PK_NAMESPACE_CODE;

#if DRM_SUPPORT_DOMAINS

#define DRM_DOMAIN_STORE_MAX_NUMBER_OF_CHILD_NODES   16
#define DRM_DOMAIN_STORE_EXPECTED_SLOT_SIZE          1000

/* "domainstore\0\0\0" */
static const DRM_DST_NAMESPACE g_rgbDomainStoreNameSpace =
{
    TWO_BYTES( 'd', 'o' ), TWO_BYTES( 'm', 'a' ), TWO_BYTES( 'i', 'n' ),
    TWO_BYTES( 's', 't' ), TWO_BYTES( 'o', 'r' ), TWO_BYTES( 'e', '\0' ),
    TWO_BYTES( '\0', '\0' )
};

/* Type ID of the domain certificate */
static const DRM_ID g_oCertTypeID = 
{
    TWO_BYTES( '\0', '\0' ), TWO_BYTES( '\0', '\0' ), TWO_BYTES( '\0', '\0' ), 
    TWO_BYTES( '\0', '\0' ), TWO_BYTES( '\0', '\0' ), TWO_BYTES( '\0', '\0' ),
    TWO_BYTES( '\0', '\0' ), TWO_BYTES( '\0', '\0' )
};

/*********************************************************************
**
** Function: _DomainStore_AddData
**
** Synopsis: Function that adds a piece of data into the domain store
**           using the passed in primary key and secondary key.
**
** Arguments:
**
** [f_poDomainStoreContext] -- Pointer to an initialized domain store
**                             context.
** [f_poAccountID]          -- Pointer to a primary key (account ID)
**                             that is used to add the data.
** [f_poTypeID]             -- Pointer to a secondary key (type ID) that
**                             is used to add the data.
** [f_poServiceID]          -- Pointer to service ID (GUID). It can be NULL
**                             if *f_poTypeID is NOT the same as g_oCertTypeID.
** [f_pbData]               -- Pointer to a buffer that contains the data
**                             to be added.
** [f_cbData]               -- Size (number of bytes) of the data to be added.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_DOMAIN_STORE_ADD_DATA for all other errors.
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT _DomainStore_AddData(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    IN const DRM_GUID *f_poAccountID,
    IN const DRM_GUID *f_poTypeID,
    IN const DRM_GUID *f_poServiceID,
    IN DRM_BYTE *f_pbData,
    IN DRM_DWORD f_cbData )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DOMAINSTORE_CONTEXT_PRIVATE *poDomainStoreContextPrivate =
        ( DRM_DOMAINSTORE_CONTEXT_PRIVATE * )f_poDomainStoreContext;
    DRM_DWORD cbWritten = 0;
    DRM_DWORD cbSlotSize1 = 0;
    DRM_DWORD cbSlotSize2 = 0;
    DRM_BOOL fOpened = FALSE;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DOMAINSTORE, PERF_FUNC__DomainStore_AddData );

    ChkArg( f_poDomainStoreContext != NULL );
    ChkArg( poDomainStoreContextPrivate->m_fInited );
    ChkArg( f_poAccountID != NULL );
    ChkArg( f_poTypeID != NULL );
    ChkArg( MEMCMP( f_poTypeID, &g_oCertTypeID, SIZEOF( DRM_GUID ) ) != 0 ||
            f_poServiceID != NULL );
    ChkArg( f_pbData != NULL );
    ChkArg( f_cbData > 0 );

    cbSlotSize1 = f_cbData;

    if ( MEMCMP( f_poTypeID, &g_oCertTypeID, SIZEOF( DRM_GUID ) ) == 0 )
    {
        /*
        ** If a domain certificate is going to be stored in the slot, its service ID
        ** is stored together at the beginning of the slot. This saves parsing of the
        ** domain certificate when the domain certificate is enumerated.
        ** The size of the slot to be allocated should take into account the size of
        ** the service ID.
        */
        cbSlotSize1 += SIZEOF( DRM_GUID );
    }

    cbSlotSize2 = cbSlotSize1;

    ChkDR( DRM_DST_OpenSlot( poDomainStoreContextPrivate->m_poDST,
                             &poDomainStoreContextPrivate->m_oDSTNameSpaceContext,
                             eDRM_DST_OPEN_ALWAYS | eDRM_DST_LOCKEXCLUSIVE | eDRM_DST_LOCKWAIT,
                             ( DRM_ID * )f_poAccountID,
                             ( DRM_ID * )f_poTypeID,
                             NULL,
                             &cbSlotSize2,
                             &poDomainStoreContextPrivate->m_oDSTSlotContext ) );

    fOpened = TRUE;

    if ( cbSlotSize1 != cbSlotSize2 )
    {
        ChkDR( DRM_DST_SlotResize( poDomainStoreContextPrivate->m_poDST,
                                   &poDomainStoreContextPrivate->m_oDSTSlotContext,
                                   cbSlotSize1 ) );
    }

    if ( MEMCMP( f_poTypeID, &g_oCertTypeID, SIZEOF( DRM_GUID ) ) == 0 )
    {
        /* Write the service ID first. */
        ChkDR( DRM_DST_SlotWrite( poDomainStoreContextPrivate->m_poDST,
                                  &poDomainStoreContextPrivate->m_oDSTSlotContext,
                                  SIZEOF( DRM_GUID ),
                                  ( DRM_BYTE * )f_poServiceID,
                                  &cbWritten ) );

        ChkBOOL( cbWritten == SIZEOF( DRM_GUID ), DRM_E_DOMAIN_STORE_ADD_DATA );

        ChkDR( DRM_DST_SlotSeek( poDomainStoreContextPrivate->m_poDST, 
                                 &poDomainStoreContextPrivate->m_oDSTSlotContext,
                                 SIZEOF( DRM_GUID ),
                                 eDRM_DST_SEEKSET,
                                 NULL ) );
    }

    /* Write the data (domain certificate or domain private key). */
    ChkDR( DRM_DST_SlotWrite( poDomainStoreContextPrivate->m_poDST,
                              &poDomainStoreContextPrivate->m_oDSTSlotContext,
                              f_cbData,
                              f_pbData,
                              &cbWritten ) );

    ChkBOOL( cbWritten == f_cbData, DRM_E_DOMAIN_STORE_ADD_DATA );

#if !_DATASTORE_WRITE_THRU
    ChkDR( DRM_DST_CommitNamespace( poDomainStoreContextPrivate->m_poDST,
                                    &poDomainStoreContextPrivate->m_oDSTNameSpaceContext ) );
#endif

ErrorExit:
    if ( fOpened )
    {
        DRM_DST_CloseSlot( poDomainStoreContextPrivate->m_poDST, 
                           &poDomainStoreContextPrivate->m_oDSTSlotContext );
    }

    if ( DRM_FAILED( dr ) && 
         dr != DRM_E_INVALIDARG )
    {
        dr = DRM_E_DOMAIN_STORE_ADD_DATA;
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: _DomainStore_GetData
**
** Synopsis: Function that gets a piece of data from the domain store using
**           the passed in primary key and secondary key.
**
** Arguments:
**
** [f_poDomainStoreContext] -- Pointer to an initialized domain store
**                             context.
** [f_poAccountID]          -- Pointer to a primary key (account ID)
**                             that is used to retrieve the data.
** [f_poTypeID]             -- Pointer to a secondary key (type ID) that
**                             is used to retrieve the data.
** [f_poServiceID]          -- Pointer to a buffer to receive the service
**                             ID. It can be NULL if *f_poTypeID is NOT
**                             the same as g_oCertTypeID.
** [f_pbData]               -- Pointer to a buffer is used to receive the
**                             data retrieved.
** [f_cbData]               -- Size (number of bytes) of the data retrieved.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_BUFFERTOOSMALL if the buffer is not big enough.
**                          DRM_E_DOMAIN_STORE_GET_DATA for all other errors.
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT _DomainStore_GetData(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    IN const DRM_GUID *f_poAccountID,
    IN const DRM_GUID *f_poTypeID,
    OUT DRM_GUID *f_poServiceID,
    OUT DRM_BYTE *f_pbData,
    IN OUT DRM_DWORD *f_pcbData )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DOMAINSTORE_CONTEXT_PRIVATE *poDomainStoreContextPrivate =
        ( DRM_DOMAINSTORE_CONTEXT_PRIVATE * )f_poDomainStoreContext;
    DRM_DWORD cbSlotSize = 0;
    DRM_BOOL fOpened = FALSE;
    DRM_DWORD cbRead = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DOMAINSTORE, PERF_FUNC__DomainStore_GetData );

    ChkArg( f_poDomainStoreContext != NULL );
    ChkArg( poDomainStoreContextPrivate->m_fInited );
    ChkArg( f_poAccountID != NULL );
    ChkArg( f_poTypeID != NULL );
    ChkArg( MEMCMP( f_poTypeID, &g_oCertTypeID, SIZEOF( DRM_GUID ) ) != 0 ||
            f_poServiceID != NULL );
    ChkArg( f_pcbData != NULL );
    ChkArg( f_pbData == NULL ||
            *f_pcbData > 0 );

    ChkDR( DRM_DST_OpenSlot( poDomainStoreContextPrivate->m_poDST,
                             &poDomainStoreContextPrivate->m_oDSTNameSpaceContext,
                             eDRM_DST_OPEN_EXISTING | eDRM_DST_LOCKWAIT,
                             ( DRM_ID * )f_poAccountID,
                             ( DRM_ID * )f_poTypeID,
                             NULL,
                             &cbSlotSize,
                             &poDomainStoreContextPrivate->m_oDSTSlotContext ) );

    fOpened = TRUE;

    if ( MEMCMP( f_poTypeID, &g_oCertTypeID, SIZEOF( DRM_GUID ) ) == 0 )
    {
        /* Make sure the size of the slot is at least big enough to fit a service ID. */
        ChkBOOL( cbSlotSize >= SIZEOF( DRM_GUID ), DRM_E_DOMAIN_STORE_GET_DATA );

        ChkDR( DRM_DST_SlotRead( poDomainStoreContextPrivate->m_poDST,
                                 &poDomainStoreContextPrivate->m_oDSTSlotContext,
                                 SIZEOF( DRM_GUID ),
                                 ( DRM_BYTE * )f_poServiceID,
                                 &cbRead ) );

        ChkBOOL( cbRead == SIZEOF( DRM_GUID ), DRM_E_DOMAIN_STORE_GET_DATA );

        ChkDR( DRM_DST_SlotSeek( poDomainStoreContextPrivate->m_poDST,
                                 &poDomainStoreContextPrivate->m_oDSTSlotContext,
                                 SIZEOF( DRM_GUID ),
                                 eDRM_DST_SEEKSET,
                                 NULL ) );

        /*
        ** The size of buffer provided by user is only used to store the domain
        ** certificate and not the service ID.
        **/
        cbSlotSize -= SIZEOF( DRM_GUID );
    }

    if ( *f_pcbData < cbSlotSize )
    {
        *f_pcbData = cbSlotSize;

        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

    ChkArg( f_pbData != NULL );

    ChkDR( DRM_DST_SlotRead( poDomainStoreContextPrivate->m_poDST,
                             &poDomainStoreContextPrivate->m_oDSTSlotContext,
                             cbSlotSize,
                             f_pbData,
                             f_pcbData ) );

ErrorExit:

    if ( fOpened )
    {
        DRM_DST_CloseSlot( poDomainStoreContextPrivate->m_poDST, 
                          &poDomainStoreContextPrivate->m_oDSTSlotContext );
    }

    if ( DRM_FAILED( dr ) && 
         dr != DRM_E_INVALIDARG &&
         dr != DRM_E_BUFFERTOOSMALL )
    {
        dr = DRM_E_DOMAIN_STORE_GET_DATA;
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: _DomainStore_DeleteData
**
** Synopsis: Function that deletes a piece of data from the domain store 
**           using the passed in primary key and secondary key.
**
** Arguments:
**
** [f_poDomainStoreContext] -- Pointer to an initialized domain store
**                             context.
** [f_poAccountID]          -- Pointer to a primary key (account ID) that
**                             is used to delete the data.
** [f_poTypeID]             -- Pointer to a secondary key (type ID) that
**                             is used to delete the data.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_DOMAIN_STORE_DELETE_DATA for all other errors.
**
**********************************************************************/
static DRM_RESULT _DomainStore_DeleteData(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    IN const DRM_GUID *f_poAccountID,
    IN const DRM_GUID *f_poTypeID )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DOMAINSTORE_CONTEXT_PRIVATE *poDomainStoreContextPrivate =
        ( DRM_DOMAINSTORE_CONTEXT_PRIVATE * )f_poDomainStoreContext;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DOMAINSTORE, PERF_FUNC__DomainStore_DeleteData );

    ChkArg( f_poDomainStoreContext != NULL );
    ChkArg( poDomainStoreContextPrivate->m_fInited );
    ChkArg( f_poAccountID != NULL );
    ChkArg( f_poTypeID != NULL );    

    ChkDR( DRM_DST_DeleteSlot( poDomainStoreContextPrivate->m_poDST,
                               &poDomainStoreContextPrivate->m_oDSTNameSpaceContext,
                               ( DRM_ID * )f_poAccountID,
                               ( DRM_ID * )f_poTypeID,
                               NULL,
                               TRUE ) );

ErrorExit:

    if ( DRM_FAILED( dr ) &&
         dr != DRM_E_INVALIDARG )
    {
        dr = DRM_E_DOMAIN_STORE_DELETE_DATA;
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: _DomainStore_InitEnumData
**
** Synopsis: Function that initializes an enumerator of a particular type
**           of data in an opened domain store.
**
** Arguments:
**
** [f_poDomainStoreContext] -- Pointer to a domain store context initialized
**                             via DRM_DOMST_OpenStore().
** [f_fCert]                -- Flag indicating whether domain certificates
**                             or domain private keys should be enumerated.
** [f_fExclusive]           -- Flag indicating whether the domain store
**                             enumerator context should be opened exclusively.
** [f_poDomainStoreEnumContext]               
**                          -- Pointer to a domain store enumerator context
**                             to be initialized by the API.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_DOMAIN_STORE_GET_DATA for all other errors.
**
**********************************************************************/
static DRM_RESULT _DomainStore_InitEnumData(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    IN const DRM_BOOL f_fCert,
    IN DRM_BOOL f_fExclusive,
    OUT DRM_DOMAINSTORE_ENUM_CONTEXT *f_poDomainStoreEnumContext )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DOMAINSTORE_CONTEXT_PRIVATE *poDomainStoreContextPrivate =
        ( DRM_DOMAINSTORE_CONTEXT_PRIVATE * )f_poDomainStoreContext;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DOMAINSTORE, PERF_FUNC__DomainStore_InitEnumData );

    ChkArg( f_poDomainStoreContext != NULL );
    ChkArg( poDomainStoreContextPrivate->m_fInited );
    ChkArg( f_poDomainStoreEnumContext != NULL );
    
    ZEROMEM( f_poDomainStoreEnumContext, SIZEOF( DRM_DOMAINSTORE_ENUM_CONTEXT ) );

    dr = DRM_DST_InitSlotEnum( poDomainStoreContextPrivate->m_poDST,
                               &poDomainStoreContextPrivate->m_oDSTNameSpaceContext, 
                               NULL,
                               ( DRM_DST_LOCKMODE )( ( f_fExclusive ? eDRM_DST_LOCKEXCLUSIVE : eDRM_DST_LOCKSHARED ) | eDRM_DST_LOCKWAIT ), 
                               &f_poDomainStoreEnumContext->m_oDSTEnumContext );

    if ( dr == DRM_E_DSTSLOTNOTFOUND )
    {
        dr = DRM_SUCCESS;
    }
    else if ( DRM_FAILED( dr ) )
    {
        ChkDR( DRM_E_DOMAIN_STORE_GET_DATA );
    }

    f_poDomainStoreEnumContext->m_poDomainStore = poDomainStoreContextPrivate->m_poDST;

    f_poDomainStoreEnumContext->m_fCert = f_fCert;

    f_poDomainStoreEnumContext->m_fInited = TRUE;

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: _DomainStore_EnumNextData
**
** Synopsis: Function that enumerates the next data of a particular type in
**           an opened domain store.
**
** Arguments:
**
** [f_poDomainStoreEnumContext]               
**                          -- Pointer to an initialized domain store enumerator
**                             context by DRM_DOMST_InitEnumData().
** [f_poAccountID]          -- Pointer to a variable that receives the account ID
**                             of the currently enumerated domain store slot.
**                             This parameter is optional.
** [f_poTypeID]             -- Pointer to a variable that receives the type ID
**                             of the currently enumerated domain store slot.
**                             This parameter is optional.
** [f_poServiceID]          -- Pointer to a buffer to receive the service ID.
**                             This parameter is optional and is only used
**                             when the value of the secondary key is the same
**                             as g_oCertTypeID, which means the slot contains
**                             a domain certificate.
** [f_poSlotHint]           -- Pointer to a variable that receives the DST
**                             slot hint of the currently enumerated domain
**                             store slot. This parameter is optional.
** [f_pcbData]              -- Pointer to a variable that receives the size
**                             (number of bytes) of the currently enumerated
**                             domain store slot. This parameter is optional.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_NOMORE if there is no more data to be enumerated.
**                          DRM_E_DOMAIN_STORE_GET_DATA for all other errors.
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT _DomainStore_EnumNextData(
    IN DRM_DOMAINSTORE_ENUM_CONTEXT *f_poDomainStoreEnumContext,
    OUT DRM_GUID *f_poAccountID,
    OUT DRM_GUID *f_poTypeID,
    OUT DRM_GUID *f_poServiceID,
    OUT DRM_DST_SLOT_HINT *f_poSlotHint,
    OUT DRM_DWORD *f_pcbData )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_GUID oCurrAccountID = EMPTY_DRM_GUID;
    DRM_GUID oCurrTypeID = EMPTY_DRM_GUID;
    DRM_DWORD cbSlotSize = 0;
    DRM_DWORD cbRead = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DOMAINSTORE, PERF_FUNC__DomainStore_EnumNextData );

    ChkArg( f_poDomainStoreEnumContext != NULL );
    ChkArg( f_poDomainStoreEnumContext->m_fInited );

    for ( ; ; )
    {
        dr = DRM_DST_SlotEnumNext( f_poDomainStoreEnumContext->m_poDomainStore,
                                   &f_poDomainStoreEnumContext->m_oDSTEnumContext,
                                   &f_poDomainStoreEnumContext->m_oDSTSlotContext, 
                                   ( DRM_ID * )&oCurrAccountID, 
                                   ( DRM_ID * )&oCurrTypeID, 
                                   &cbSlotSize );

        if ( dr == DRM_E_NOMORE )
        {
            break;
        }
        else if ( dr == DRM_E_DSTBLOCKMISMATCH ||
                  dr == DRM_E_DSTSLOTNOTFOUND )
        {
            ChkDR( DRM_E_DOMAIN_STORE_GET_DATA );
        }

        if ( f_poSlotHint != NULL )
        {
            DRM_DST_MakeSlotHint( f_poDomainStoreEnumContext->m_poDomainStore,
                                  &f_poDomainStoreEnumContext->m_oDSTSlotContext,
                                  f_poSlotHint );
        }

        if ( ( f_poDomainStoreEnumContext->m_fCert &&
               MEMCMP( &oCurrTypeID,
                       ( DRM_GUID * )&g_oCertTypeID,
                       SIZEOF( DRM_GUID ) ) != 0 ) ||
             ( !f_poDomainStoreEnumContext->m_fCert &&
               MEMCMP( &oCurrTypeID,
                       ( DRM_GUID * )&g_oCertTypeID,
                       SIZEOF( DRM_GUID ) ) == 0 ) )
        {
            ChkDR( DRM_DST_CloseSlot( f_poDomainStoreEnumContext->m_poDomainStore,
                                      &f_poDomainStoreEnumContext->m_oDSTSlotContext ) );

            continue;
        }
        
        if ( f_poDomainStoreEnumContext->m_fCert &&
             MEMCMP( &oCurrTypeID,
                     ( DRM_GUID * )&g_oCertTypeID,
                     SIZEOF( DRM_GUID ) ) == 0 )
        {
            /* Make sure the size of the current slot is at least big enough to fit a service ID. */
            ChkBOOL( cbSlotSize >= SIZEOF( DRM_GUID ), DRM_E_DOMAIN_STORE_GET_DATA );
            
            /*
            ** The size of buffer provided by user is only used to store the domain
            ** certificate and not the service ID.
            **/
            cbSlotSize -= SIZEOF( DRM_GUID );
            
            if ( f_poServiceID != NULL )
            {
                ChkDR( DRM_DST_SlotRead( f_poDomainStoreEnumContext->m_poDomainStore,
                                         &f_poDomainStoreEnumContext->m_oDSTSlotContext, 
                                         SIZEOF( DRM_GUID ),
                                         ( DRM_BYTE * )f_poServiceID,
                                         &cbRead ) );

                ChkBOOL( cbRead == SIZEOF( DRM_GUID ), DRM_E_DOMAIN_STORE_GET_DATA );
            }
        }

        if ( f_poAccountID != NULL )
        {
            MEMCPY( f_poAccountID, &oCurrAccountID, SIZEOF( DRM_GUID ) );
        }

        if ( f_poTypeID != NULL )
        {
            MEMCPY( f_poTypeID, &oCurrTypeID, SIZEOF( DRM_GUID ) );
        }

        if ( f_pcbData != NULL )
        {
            *f_pcbData = cbSlotSize;
        }

        ChkDR( DRM_DST_CloseSlot( f_poDomainStoreEnumContext->m_poDomainStore,
                                  &f_poDomainStoreEnumContext->m_oDSTSlotContext ) );

        break;
    }

ErrorExit:
    
    if ( DRM_FAILED( dr ) && 
         dr != DRM_E_INVALIDARG &&
         dr != DRM_E_NOMORE )
    {
        dr = DRM_E_DOMAIN_STORE_GET_DATA;
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: _InitEnumKeyExclusive
**
** Synopsis: Function that initializes an enumerator of all domain private
**           keys in an opened domain store. The enumerator is opened
**           in the exclusive mode.
**
** Arguments:
**
** [f_poDomainStoreContext] -- Pointer to a domain store context initialized
**                             via DRM_DOMST_OpenStore().
** [f_poDomainStoreEnumContext]               
**                          -- Pointer to a domain store enumerator context
**                             to be initialized by the API.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_DOMAIN_STORE_GET_DATA for all other 
**                          errors.
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT _InitEnumKeyExclusive(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    OUT DRM_DOMAINSTORE_ENUM_CONTEXT *f_poDomainStoreEnumContext )
{
    return _DomainStore_InitEnumData( f_poDomainStoreContext,
                                      FALSE,
                                      TRUE,
                                      f_poDomainStoreEnumContext );
}

/*********************************************************************
**
** Function: DRM_DOMST_OpenStore
**
** Synopsis: API that opens a domain store and returns an initialized
**           domain store context.
**
** Arguments:
**
** [f_pDatastore]           -- Pointer to an initialized data store.
** [f_poDomainStoreContext] -- Pointer to a domain store context to be
**                             initialized by the API.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_DOMAIN_STORE_OPEN_STORE for all other 
**                          errors.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DOMST_OpenStore(
    IN  DRM_DST                 *f_pDatastore,
    OUT DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DOMAINSTORE_CONTEXT_PRIVATE *poDomainStoreContextPrivate =
        ( DRM_DOMAINSTORE_CONTEXT_PRIVATE * )f_poDomainStoreContext;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DOMAINSTORE, PERF_FUNC_DRM_DOMST_OpenStore );

    ChkArg( f_pDatastore != NULL );
    ChkArg( f_poDomainStoreContext != NULL );
    ChkArg( !poDomainStoreContextPrivate->m_fInited );   

    DRMSIZEASSERT( SIZEOF( DRM_DOMAINSTORE_CONTEXT_PRIVATE ), SIZEOF ( DRM_DOMAINSTORE_CONTEXT ) );

    /* Open the namespace of the Domain Store */
    ChkDR( DRM_DST_OpenNamespace( f_pDatastore,
                                  &g_rgbDomainStoreNameSpace,
                                  (DRM_DST_OPENMODE)(eDRM_DST_OPEN_ALWAYS | eDRM_DST_LOCKWAIT),
                                  DRM_DOMAIN_STORE_MAX_NUMBER_OF_CHILD_NODES,
                                  DRM_DOMAIN_STORE_EXPECTED_SLOT_SIZE,
                                  &poDomainStoreContextPrivate->m_oDSTNameSpaceContext ) );

    poDomainStoreContextPrivate->m_fInited = TRUE;

    poDomainStoreContextPrivate->m_poDST = f_pDatastore;

ErrorExit:

    if ( DRM_FAILED( dr ) &&
         dr != DRM_E_INVALIDARG )
    {
        dr = DRM_E_DOMAIN_STORE_OPEN_STORE;
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: DRM_DOMST_CloseStore
**
** Synopsis: API that closes an opened domain store.
**
** Arguments:
**
** [f_poDomainStoreContext] -- Pointer to a domain store context initialized
**                             via DRM_DOMST_OpenStore(). If the passed
**                             in domain store context is not initialized,
**                             the function just exit without returning any
**                             error code.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_DOMAIN_STORE_CLOSE_STORE for all other 
**                          errors.
**
** Note:                    If caller passes in an uninitialized domain store
**                          context. It must be zeroed by the caller before
**                            being passed in.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DOMST_CloseStore(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DOMAINSTORE_CONTEXT_PRIVATE *poDomainStoreContextPrivate =
        ( DRM_DOMAINSTORE_CONTEXT_PRIVATE * )f_poDomainStoreContext;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DOMAINSTORE, PERF_FUNC_DRM_DOMST_CloseStore );

    ChkArg( f_poDomainStoreContext != NULL );
    
    /*
    ** If a domain store context has not yet been initialized,
    ** just exit the function without returning any error code.
    */
    if ( !poDomainStoreContextPrivate->m_fInited )
    {
        goto ErrorExit;
    }

    /*
    ** If the domain store context has been initialized, then these are errors
    */
    ChkDR( DRM_DST_CloseNamespace( poDomainStoreContextPrivate->m_poDST,
                                   &poDomainStoreContextPrivate->m_oDSTNameSpaceContext ) );

    /* Implicitly set poDomainStoreContextPrivate->m_fInited to FALSE. */
    ZEROMEM( f_poDomainStoreContext, SIZEOF( DRM_DOMAINSTORE_CONTEXT ) );

ErrorExit:

    if ( DRM_FAILED( dr ) &&
         dr != DRM_E_INVALIDARG )
    {
        dr = DRM_E_DOMAIN_STORE_CLOSE_STORE;
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: DRM_DOMST_AddCert
**
** Synopsis: API that adds a domain certificate into an opened domain store.
**
** Arguments:
**
** [f_poDomainStoreContext] -- Pointer to a domain store context initialized
**                             via DRM_DOMST_OpenStore().
** [f_poAccountID]          -- Pointer to an account ID of the domain 
**                             certificate to be added into the domain store.
**                             It cannot be NULL.
** [f_poServiceID]          -- Pointer to a service ID of the domain 
**                             certificate to be added into the domain store.
**                             It cannot be NULL.
** [f_pbCert]               -- Pointer to a buffer that contains the domain
**                             certificate to be added into the domain store.
** [f_cbCert]               -- Size (in bytes) of the buffer that contains
**                             the domain certificate to be added into the
**                             domain store.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_DOMAIN_STORE_ADD_DATA for all other 
**                          errors.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DOMST_AddCert(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    IN DRM_GUID *f_poAccountID,
    IN DRM_GUID *f_poServiceID,
    __in_bcount( f_cbCert ) DRM_BYTE *f_pbCert,
    IN DRM_DWORD f_cbCert )
{
    DRM_BCERT_VERIFICATIONCONTEXT oVerificationContext = {0};
    DRM_RESULT dr = DRM_SUCCESS;

    ChkDR( DRM_BCert_InitVerificationContext( NULL, /* expiration time */
                                              NULL, /* root key */
                                              DRM_BCERT_CERTTYPE_DOMAIN,
                                              NULL, /* crypto ctx */
                                              FALSE,
                                              TRUE,
                                              NULL, /* required key usages */
                                              0,
                                              FALSE, 
                                              NULL, /* BBX ctx */
                                              NULL, /* SST ctx */
                                              NULL, /* data store */
                                              &oVerificationContext ) );

    ChkDR( DRM_BCert_ParseCertificateChain( f_pbCert, f_cbCert, &oVerificationContext ) );

    ChkDR( _DomainStore_AddData( f_poDomainStoreContext,
                                 f_poAccountID,
                                 ( DRM_GUID * )&g_oCertTypeID,
                                 f_poServiceID,
                                 f_pbCert,
                                 f_cbCert ) );
ErrorExit:
    return dr;
    
}

/*********************************************************************
**
** Function: DRM_DOMST_GetCert
**
** Synopsis: API that retrieves a domain certificate from an opened domain
**           store.
**
** Arguments:
**
** [f_poDomainStoreContext] -- Pointer to a domain store context initialized
**                             via DRM_DOMST_OpenStore().
** [f_poAccountID]          -- Pointer to an account ID of the domain 
**                             certificate to be retrieved from the domain store.
**                             It cannot be NULL.
** [f_poServiceID]          -- Pointer to buffer to receive the server ID of the
**                             domain  certificate retrieved from the domain store.
**                             It cannot be NULL.
** [f_pbCert]               -- Pointer to a buffer to receive the domain certificate
**                             retrieved  from the domain store. If it is NULL,
**                             the function returns an error and the size of the
**                             required buffer is stored in *pcbCert.
** [f_pcbCert]              -- Pointer to a variable that contains the size
**                             (in bytes) of the domain certificate buffer
**                             during input and receives the size (in bytes) of
**                             the domain certificate buffer during output.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_BUFFERTOOSMALL if the buffer to retrieve
**                          the data is not big enough.
**                          DRM_E_DOMAIN_STORE_GET_DATA for all other 
**                          errors.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DOMST_GetCert(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    IN DRM_GUID *f_poAccountID,
    IN DRM_GUID *f_poServiceID,
    __out_bcount_opt( *f_pcbCert ) DRM_BYTE *f_pbCert,
    IN OUT DRM_DWORD *f_pcbCert )
{
    return _DomainStore_GetData( f_poDomainStoreContext,
                                 f_poAccountID,
                                 ( DRM_GUID * )&g_oCertTypeID,
                                 f_poServiceID,
                                 f_pbCert,
                                 f_pcbCert );
}

/*********************************************************************
**
** Function: DRM_DOMST_DeleteCert
**
** Synopsis: API that deletes a domain certificate from an opened domain
**           store.
**
** Arguments:
**
** [f_poDomainStoreContext] -- Pointer to a domain store context initialized
**                             via DRM_DOMST_OpenStore().
** [f_poAccountID]          -- Pointer to an accountID of the domain 
**                             certificate to be deleted from the domain store.
**                             It cannot be NULL.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_DOMAIN_STORE_DELETE_DATA for all other 
**                          errors.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DOMST_DeleteCert(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    IN DRM_GUID *f_poAccountID )
{
    return _DomainStore_DeleteData( f_poDomainStoreContext,
                                    f_poAccountID,
                                    ( DRM_GUID * )&g_oCertTypeID );
}

/*********************************************************************
**
** Function: DRM_DOMST_InitEnumCert
**
** Synopsis: API that initializes an enumerator of all domain certificates
**           in an opened domain store.
**
** Arguments:
**
** [f_poDomainStoreContext] -- Pointer to a domain store context initialized
**                             via DRM_DOMST_OpenStore().
** [f_poDomainStoreEnumContext]               
**                          -- Pointer to a domain store enumerator context
**                             to be initialized by the API.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_DOMAIN_STORE_GET_DATA for all other 
**                          errors.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DOMST_InitEnumCert(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    OUT DRM_DOMAINSTORE_ENUM_CONTEXT *f_poDomainStoreEnumContext )
{
    return _DomainStore_InitEnumData( f_poDomainStoreContext,
                                      TRUE,
                                      FALSE,
                                      f_poDomainStoreEnumContext );
}

/*********************************************************************
**
** Function: DRM_DOMST_EnumNextCert
**
** Synopsis: API that enumerates the next domain certificate in an opened
**           domain store.
**
** Arguments:
**
** [f_poDomainStoreEnumContext]               
**                          -- Pointer to an initialized domain store enumerator
**                             context by DRM_DOMST_InitEnumCert().
** [f_poAccountID]          -- Pointer to a variable that receives the account ID
**                             of the currently enumerated domain certificate.
**                             This parameter is optional.
** [f_poServiceID]          -- Pointer to a variable that receives the service ID
**                             of the currently enumerated domain certificate.
**                             This parameter is optional.
** [f_poSlotHint]           -- Pointer to a variable that receives the DST
**                             slot hint of the currently enumerated domain
**                             certificate. This parameter is optional.
** [f_pcbData]              -- Pointer to a variable that receives the size
**                             (number of bytes) of the currently enumerated
**                             domain certificate. This parameter is optional.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_NOMORE if there is no more data to be enumerated.
**                          DRM_E_DOMAIN_STORE_GET_DATA for all other 
**                          errors.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DOMST_EnumNextCert(
    IN DRM_DOMAINSTORE_ENUM_CONTEXT *f_poDomainStoreEnumContext,
    OUT DRM_GUID *f_poAccountID,
    OUT DRM_GUID *f_poServiceID,
    OUT DRM_DST_SLOT_HINT *f_poSlotHint,
    OUT DRM_DWORD *f_pcbData )
{
    return _DomainStore_EnumNextData( f_poDomainStoreEnumContext,
                                      f_poAccountID,
                                      NULL,
                                      f_poServiceID,
                                      f_poSlotHint,
                                      f_pcbData );
}

/*********************************************************************
**
** Function: DRM_DOMST_AddKey
**
** Synopsis: API that adds a domain private key into an opened domain store.
**
** Arguments:
**
** [f_poDomainStoreContext] -- Pointer to a domain store context initialized
**                             via DRM_DOMST_OpenStore().
** [f_poAccountID]          -- Pointer to a account ID of the domain 
**                             private key to be added into the domain store.
**                             It cannot be NULL.
** [f_dwRevision]           -- Revision of the domain private key to be added
**                             into the domain store.
** [f_pbKey]                -- Pointer to a buffer that contains the domain
**                             private key to be added into the domain store.
** [f_cbKey]                -- Size (in bytes) of the buffer that contains
**                             the domain private key to be added into the
**                             domain store.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_DOMAIN_STORE_ADD_DATA for all other 
**                          errors.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DOMST_AddKey(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    IN DRM_GUID *f_poAccountID,
    IN DRM_DWORD f_dwRevision,
    __in_bcount( f_cbKey ) DRM_BYTE *f_pbKey,
    IN DRM_DWORD f_cbKey )
{
    DRM_GUID oTypeID = EMPTY_DRM_GUID;

    DWORD_TO_NETWORKBYTES( &oTypeID, 0, f_dwRevision );

    return _DomainStore_AddData( f_poDomainStoreContext,
                                 f_poAccountID,
                                 &oTypeID,
                                 NULL,
                                 f_pbKey,
                                 f_cbKey );
}

/*********************************************************************
**
** Function: DRM_DOMST_GetKey
**
** Synopsis: API that retrieves a domain private key from an opened domain
**           store.
**
** Arguments:
**
** [f_poDomainStoreContext] -- Pointer to a domain store context initialized
**                             via DRM_DOMST_OpenStore().
** [f_poAccountID]          -- Pointer to an account ID of the domain 
**                             private key to be retrieved from the domain store.
**                             It cannot be NULL.
** [f_dwRevision]           -- Revision of the domain private key to be retrieved
**                             from the domain store. It cannot be NULL.
** [f_pbKey]                -- Pointer to a buffer to receive the domain private 
**                             key retrieved from the domain store. If it is
**                             NULL, the function returns an error and the size
**                             of the required buffer is stored in *pcbCert.
** [f_pcbKey]               -- Pointer to a variable that contains the size
**                             (in bytes) of the domain private key buffer
**                             during input and receives the size (in bytes) of
**                             the domain private key buffer during output.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_BUFFERTOOSMALL if the buffer to retrieve
**                          the data is not big enough.
**                          DRM_E_DOMAIN_STORE_GET_DATA for all other 
**                          errors.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DOMST_GetKey(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    IN DRM_GUID *f_poAccountID,
    IN DRM_DWORD f_dwRevision,
    __out_bcount_opt( *f_pcbKey ) DRM_BYTE *f_pbKey,
    IN OUT DRM_DWORD *f_pcbKey )
{
    DRM_GUID oTypeID = EMPTY_DRM_GUID;

    DWORD_TO_NETWORKBYTES( &oTypeID, 0, f_dwRevision );

    return _DomainStore_GetData( f_poDomainStoreContext,
                                 f_poAccountID,
                                 &oTypeID,
                                 NULL,
                                 f_pbKey,
                                 f_pcbKey );
}

/*********************************************************************
**
** Function: DRM_DOMST_DeleteKey
**
** Synopsis: API that deletes a domain private key from an opened domain
**           store.
**
** Arguments:
**
** [f_poDomainStoreContext] -- Pointer to a domain store context initialized
**                             via DRM_DOMST_OpenStore().
** [f_poAccountID]          -- Pointer to an account ID of the domain 
**                             private key to be deleted from the domain store.
**                             It cannot be NULL.
** [f_dwRevision]           -- Revision of the domain private key to be deleted
**                             from the domain store. It cannot be NULL.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_DOMAIN_STORE_DELETE_DATA for all other 
**                          errors.
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_DOMST_DeleteKey(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    IN DRM_GUID *f_poAccountID,
    IN DRM_DWORD f_dwRevision )
{
    DRM_GUID oTypeID = EMPTY_DRM_GUID;

    DWORD_TO_NETWORKBYTES( ( DRM_BYTE * )&oTypeID, 0, f_dwRevision );

    return _DomainStore_DeleteData( f_poDomainStoreContext,
                                    f_poAccountID,
                                    &oTypeID );
}

/*********************************************************************
**
** Function: DRM_DOMST_DeleteKeys
**
** Synopsis: API that deletes all domain private keys that have the same
**           account ID from an opened domain store.
**
** Arguments:
**
** [f_poDomainStoreContext] -- Pointer to a domain store context initialized
**                             via DRM_DOMST_OpenStore().
** [f_poAccountID]          -- Pointer to an account ID of the domain 
**                             private keys to be deleted from the domain store.
**                             It cannot be NULL.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_DOMAIN_STORE_DELETE_DATA for all other 
**                          errors.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DOMST_DeleteKeys(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    IN DRM_GUID *f_poAccountID )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DOMAINSTORE_ENUM_CONTEXT oDomainStoreEnumContext = { 0 };
    DRM_GUID oAccountID = EMPTY_DRM_GUID;
    DRM_DOMAINSTORE_CONTEXT_PRIVATE *poDomainStoreContextPrivate =
        ( DRM_DOMAINSTORE_CONTEXT_PRIVATE * )f_poDomainStoreContext;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DOMAINSTORE, PERF_FUNC_DRM_DOMST_DeleteKeys );

    ChkArg( f_poDomainStoreContext != NULL );
    ChkArg( f_poAccountID != NULL );
    
    ChkDR( _InitEnumKeyExclusive( f_poDomainStoreContext,
                                  &oDomainStoreEnumContext ) );

    for ( ; ; )
    {
        dr = DRM_DOMST_EnumNextKey( &oDomainStoreEnumContext,
                                    &oAccountID,
                                    NULL,
                                    NULL,
                                    NULL );

        if ( dr == DRM_E_NOMORE )
        {
            dr = DRM_SUCCESS;

            break;
        }
        else
        {
            ChkDR( dr );
        }

        if ( MEMCMP( &oAccountID, f_poAccountID, SIZEOF( DRM_GUID ) ) != 0 )
        {
            continue;
        }

        ChkDR( DRM_DST_SlotEnumReloadCurrent( poDomainStoreContextPrivate->m_poDST,
                                              &oDomainStoreEnumContext.m_oDSTEnumContext,
                                              &oDomainStoreEnumContext.m_oDSTSlotContext,
                                              NULL,
                                              NULL,
                                              NULL ) );

        ChkDR( DRM_DST_SlotEnumDeleteCurrent( poDomainStoreContextPrivate->m_poDST,
                                              &oDomainStoreEnumContext.m_oDSTEnumContext,
                                              &oDomainStoreEnumContext.m_oDSTSlotContext ) );
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: DRM_DOMST_InitEnumKey
**
** Synopsis: API that initializes an enumerator of all domain private
**           keys in an opened domain store.
**
** Arguments:
**
** [f_poDomainStoreContext] -- Pointer to a domain store context initialized
**                             via DRM_DOMST_OpenStore().
** [f_poDomainStoreEnumContext]               
**                          -- Pointer to a domain store enumerator context
**                             to be initialized by the API.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_DOMAIN_STORE_GET_DATA for all other 
**                          errors.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DOMST_InitEnumKey(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    OUT DRM_DOMAINSTORE_ENUM_CONTEXT *f_poDomainStoreEnumContext )
{
    return _DomainStore_InitEnumData( f_poDomainStoreContext,
                                      FALSE,
                                      FALSE,
                                      f_poDomainStoreEnumContext );
}

/*********************************************************************
**
** Function: DRM_DOMST_EnumNextKey
**
** Synopsis: API that enumerates the next domain private key in an opened
**           domain store.
**
** Arguments:
**
** [f_poDomainStoreEnumContext]               
**                          -- Pointer to an initialized domain store enumerator
**                             context by DRM_DOMST_InitEnumKey().
** [f_poAccountID]          -- Pointer to a variable that receives the account ID
**                             of the currently enumerated domain private key.
**                             This parameter is optional.
** [f_pdwRevision]          -- Pointer to a variable that receives the revision
**                             of the currently enumerated domain private key.
**                             This parameter is optional.
** [f_poSlotHint]           -- Pointer to a variable that receives the DST
**                             slot hint of the currently enumerated domain
**                             private key. This parameter is optional.
** [f_pcbData]              -- Pointer to a variable that receives the size
**                             (number of bytes) of the currently enumerated
**                             domain private key. This parameter is optional.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_NOMORE if there is no more data to be enumerated.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_DOMAIN_STORE_GET_DATA for all other 
**                          errors.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DOMST_EnumNextKey(
    IN DRM_DOMAINSTORE_ENUM_CONTEXT *f_poDomainStoreEnumContext,
    OUT DRM_GUID *f_poAccountID,
    OUT DRM_DWORD *f_pdwRevision,
    OUT DRM_DST_SLOT_HINT *f_poSlotHint,
    OUT DRM_DWORD *f_pcbData )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_GUID oTypeID = EMPTY_DRM_GUID;

    ChkDR( _DomainStore_EnumNextData( f_poDomainStoreEnumContext,
                                      f_poAccountID,
                                      &oTypeID,
                                      NULL,
                                      f_poSlotHint,
                                      f_pcbData ) );

    if ( f_pdwRevision != NULL )
    {
        NETWORKBYTES_TO_DWORD( *f_pdwRevision, ( DRM_BYTE * )&oTypeID, 0 );
    }

ErrorExit:

    return dr;
}

#endif /* DRM_SUPPORT_DOMAINS */

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmdomainimp.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmtypes.h>
#include <drmhds.h>
#include <drmutilities.h>
#include <drmxmlparser.h>
#include <drmxmlbuildera.h>
#include <drmcrt.h>
#include <drmxmlsigconstants.h>
#include <drmxmlsig.h>
#include <drmdomainstore.h>
#include <drmsoapxmlconstants.h>
#include <drmsoapxmlutility.h>
#include <drmdomainconstants.h>
#include <drmdomainimp.h>
#include <drmdomainkeyxmrparser.h>
#include <oem.h>

ENTER_PK_NAMESPACE_CODE;

#if DRM_SUPPORT_DOMAINS

/*********************************************************************
**
** Function: _CalcJoinChallengeDataCharCount
**
** Synopsis: Function that calculates the character count of the portion
**           of data to be encrypted in the domain join challenge, based
**           on the device certificate.
**
** Arguments:
**
** [f_cchDeviceCert]        -- Size (number of characters) of a device
**                             certificate.
**
** Returns:                 A long integer value that is the character
**                          count of the calculated portion of data to
**                          be encrypted in the domain join challenge
**                          XML segment. 0 if the device certificate
**                          string is not valid.
**
**********************************************************************/
static DRM_NO_INLINE DRM_DWORD _CalcJoinChallengeDataCharCount(
    IN DRM_DWORD f_cchDeviceCert )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cchCount = 0;

    ChkArg( f_cchDeviceCert > 0 );

    /* <Data> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrDomJoinDataTag.cchString,
                                              0,
                                              0,
                                              0 );

    /* <CertificateChain> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrDomJoinCertificateChainTag.cchString,
                                              f_cchDeviceCert,
                                              0,
                                              0 );

    /* Add space used by XML builder context. */
    cchCount += g_cbXMLBuilderMinimumA;

    /*
    ** Add one more DRM_DWORD to ensure the size of buffer is
    ** big enough even after realighnment.
    */
    cchCount += SIZEOF( DRM_DWORD );

    /*
    ** Reserve space in order to pad the result XML string to
    ** the length of multiples of DRM_AES_BLOCKLEN (16).
    */
    cchCount += DRM_AES_BLOCKLEN;

ErrorExit:

    return cchCount;
}

/*********************************************************************
**
** Function: _CalcLeaveChallengeDataCharCount
**
** Synopsis: Function that calculates the character count of the portion
**           of data to be encrypted in the domain leave challenge, based
**           on the device certificate.
**
** Arguments:
**
** [f_cchDeviceCert]        -- Size (number of characters) of a device
**                             certificate.
**
** Returns:                 A long integer value that is the character
**                          count of the calculated portion of data to
**                          be encrypted in the domain leave challenge
**                          XML segment. 0 if the device certificate
**                          string is not valid.
**
**********************************************************************/
static DRM_NO_INLINE DRM_DWORD _CalcLeaveChallengeDataCharCount(
    IN DRM_DWORD f_cchDeviceCert )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cchCount = 0;

    ChkArg( f_cchDeviceCert > 0 );

    /* <Data> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrDomLeaveDataTag.cchString,
                                              0,
                                              0,
                                              0 );

    /* <CertificateChain> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrDomLeaveCertificateChainTag.cchString,
                                              f_cchDeviceCert,
                                              0,
                                              0 );

    /* Add space used by XML builder context. */
    cchCount += g_cbXMLBuilderMinimumA;

    /*
    ** Add one more DRM_DWORD to ensure the size of buffer is
    ** big enough even after realighnment.
    */
    cchCount += SIZEOF( DRM_DWORD );

    /*
    ** Reserve space in order to pad the result XML string to
    ** the length of multiples of DRM_AES_BLOCKLEN (16).
    */
    cchCount += DRM_AES_BLOCKLEN;

ErrorExit:

    return cchCount;
}

/*********************************************************************
**
** Function: _CalcJoinChallengeCharCount
**
** Synopsis: Function that calculates the character count of the domain
**           join challenge, based on the domain ID, the device certificate,
**           the friendly name, the custom data and the key information
**           used to encrypt portion of the challenge data.
**
** Arguments:
**
** [f_poDomainID]           -- Pointer to a domain ID.
** [f_cchDeviceCert]        -- Size (number of characters) of a device
**                             certificate.
** [f_poXMLKey]             -- Pointer to a DRM_XML_KEY structure that
**                             contains the key information to encrypt
**                             portion of the challenge data.
** [f_cchFriendlyName]      -- Size (number of characters) of a friendly
**                             name string.
** [f_cchCustomData]        -- Size (number of characters) of a custom
**                             data buffer.
**
** Returns:                 A long integer value that is the character
**                          count of the calculated domain join challenge
**                          XML segment. 0 if the device certificate string
**                          or the service ID is not valid.
**
**********************************************************************/
static DRM_NO_INLINE DRM_DWORD _CalcJoinChallengeCharCount(
    IN DRM_DOMAIN_ID *f_poDomainID,
    IN DRM_DWORD f_cchDeviceCert,
    IN DRM_XML_KEY *f_poXMLKey,
    IN DRM_DWORD f_cchFriendlyName,
    IN DRM_DWORD f_cchCustomData )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cchCount = 0;
    DRM_DWORD cchSignatureXMLCount = 0;
    DRM_DWORD cchEncryptedCount = 0;
    DRM_DWORD cbEncryptedSize = 0;

    ChkArg( f_poDomainID != NULL );
    ChkArg( f_cchDeviceCert > 0 );

#if DRM_USE_SOAP
    
    cchCount += g_dastrXMLRootTag.cchString;

    cchCount += DRM_SOAPXML_CalcSOAPHeaderCharCount();

#endif

    /* <JoinDomain xmlns="..."> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrDomJoinRootTag.cchString,
                                              0,
                                              g_dastrDomJoinRootAttribName.cchString,
                                              g_dastrDomJoinRootAttribValue.cchString );

    /* <challenge> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrDomJoinChallenge1Tag.cchString,
                                              0,
                                              0,
                                              0 );

    /* <Challenge> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrDomJoinChallenge2Tag.cchString,
                                              0,
                                              0,
                                              0 );

    cchCount += DRM_XMB_RequiredCharsForAttributeA( g_dastrDomJoinChallenge2AttribName.cchString,
                                                    g_dastrDomJoinChallenge2AttribValue.cchString );

    /* <Domain> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrDomJoinDomainTag.cchString,
                                              0,
                                              g_dastrDomJoinDomainAttrib1Name.cchString,
                                              g_dastrDomJoinDomainAttrib1Value.cchString );

    cchCount += DRM_XMB_RequiredCharsForTagA( 0,
                                              0,
                                              g_dastrDomJoinDomainAttrib2Name.cchString,
                                              g_dastrDomJoinDomainAttrib2Value.cchString );

    cchCount += DRM_XMB_RequiredCharsForAttributeA( g_dastrSOAPPreserveSpaceAttribName.cchString,
                                                    g_dastrSOAPPreserveSpaceAttribValue.cchString );

    /* <Version> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrDomJoinVersionTag.cchString,
                                              g_dastrDomainJoinVersion.cchString,
                                              0,
                                              0 );

    if ( !DRM_SOAPXML_IsBlankGUID( &f_poDomainID->m_oServiceID ) )
    {
        /* <ServiceID> */
        cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrDomJoinServiceIDTag.cchString,
                                                  CCH_BASE64_EQUIV( SIZEOF( DRM_GUID ) ),
                                                  0,
                                                  0 );
    }

    if ( !DRM_SOAPXML_IsBlankGUID( &f_poDomainID->m_oAccountID ) )
    {
        /* <AccountID> */
        cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrDomJoinAccountIDTag.cchString,
                                                  CCH_BASE64_EQUIV( SIZEOF( DRM_GUID ) ),
                                                  0,
                                                  0 );
    }

    if ( f_poDomainID->m_dwRevision != 0 )
    {
        /* <Revision> */
        cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrDomJoinRevisionTag.cchString,
                                                  DRM_SOAPXML_CalcDWORDCharCount( f_poDomainID->m_dwRevision ),
                                                  0,
                                                  0 );
    }

    if ( f_cchFriendlyName > 0 )
    {
        /* <FriendlyName> */
        cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrDomJoinFriendlyNameTag.cchString,
                                                  f_cchFriendlyName,
                                                  0,
                                                  0 );

        /* Possible alignment cost. */
        cchCount += SIZEOF( DRM_WORD );
    }

    if ( f_cchCustomData > 0 )
    {
        /* <CustomData> */
        cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrDomJoinCustomDataTag.cchString,
                                                  f_cchCustomData,
                                                  0,
                                                  0 );

        /* Possible alignment cost. */
        cchCount += SIZEOF( DRM_WORD );
    }

    /* Calculate the character count of the data to be encrypted. */
    cchEncryptedCount = _CalcJoinChallengeDataCharCount( f_cchDeviceCert );

    cbEncryptedSize = cchEncryptedCount * SIZEOF( DRM_CHAR );

    /* Add the character count of the encrypted data. */
    ChkDR( DRM_XMLSIG_GetEncryptedDataNodeCharCount( f_poXMLKey,
                                                     cbEncryptedSize,
                                                     &cchEncryptedCount ) );
    
    cchCount += cchEncryptedCount;

    /* Add the character count of the signature. */
    ChkDR( DRM_XMLSIG_GetSignatureNodeCharCount( &cchSignatureXMLCount ) );

    cchCount += cchSignatureXMLCount;

ErrorExit:

    return cchCount;
}

/*********************************************************************
**
** Function: _CalcLeaveChallengeCharCount
**
** Synopsis: Function that calculates the character count of the domain
**           leave challenge, based on the domain ID, the device certificate
**           and the key information used to encrypt portion of the
**           challenge data.
**
** Arguments:
**
** [f_poDomainID]           -- Pointer to a domain ID.
** [f_cchDeviceCert]        -- Size (number of characters) of a device
**                             certificate.
** [f_poXMLKey]             -- Pointer to a DRM_XML_KEY structure that
**                             contains the key information to encrypt
**                             portion of the challenge data.
** [f_cchCustomData]        -- Size (number of characters) of a custom
**                             data buffer.
**
** Returns:                 A long integer value that is the character
**                          count of the calculated domain leave challenge
**                          XML segment. 0 if the device certificate string
**                          is not valid or the domain ID is NULL.
**
**********************************************************************/
static DRM_NO_INLINE DRM_DWORD _CalcLeaveChallengeCharCount(
    IN DRM_DOMAIN_ID *f_poDomainID,
    IN DRM_DWORD f_cchDeviceCert,
    IN DRM_XML_KEY *f_poXMLKey,
    IN DRM_DWORD f_cchCustomData )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cchCount = 0;
    DRM_DWORD cchSignatureXMLCount = 0;
    DRM_DWORD cchEncryptedCount = 0;
    DRM_DWORD cbEncryptedSize = 0;

    ChkArg( f_poDomainID != NULL );
    ChkArg( !DRM_SOAPXML_IsBlankGUID( &f_poDomainID->m_oAccountID ) );
    ChkArg( f_cchDeviceCert > 0 );

#if DRM_USE_SOAP
    
    cchCount += g_dastrXMLRootTag.cchString;

    cchCount += DRM_SOAPXML_CalcSOAPHeaderCharCount();

#endif

    /* <LeaveDomain xmlns="..."> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrDomLeaveRootTag.cchString,
                                              0,
                                              g_dastrDomLeaveRootAttribName.cchString,
                                              g_dastrDomLeaveRootAttribValue.cchString );

    /* <challenge> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrDomLeaveChallenge1Tag.cchString,
                                              0,
                                              0,
                                              0 );

    /* <Challenge> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrDomLeaveChallenge2Tag.cchString,
                                              0,
                                              0,
                                              0 );

    cchCount += DRM_XMB_RequiredCharsForAttributeA( g_dastrDomLeaveChallenge2AttribName.cchString,
                                                    g_dastrDomLeaveChallenge2AttribValue.cchString );

    /* <Domain> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrDomLeaveDomainTag.cchString,
                                              0,
                                              g_dastrDomLeaveDomainAttrib1Name.cchString,
                                              g_dastrDomLeaveDomainAttrib1Value.cchString );

    cchCount += DRM_XMB_RequiredCharsForTagA( 0,
                                              0,
                                              g_dastrDomLeaveDomainAttrib2Name.cchString,
                                              g_dastrDomLeaveDomainAttrib2Value.cchString );

    cchCount += DRM_XMB_RequiredCharsForAttributeA( g_dastrSOAPPreserveSpaceAttribName.cchString,
                                                    g_dastrSOAPPreserveSpaceAttribValue.cchString );

    /* <Version> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrDomLeaveVersionTag.cchString,
                                              g_dastrDomainLeaveVersion.cchString,
                                              0,
                                              0 );

    /* <AccountID> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrDomLeaveAccountIDTag.cchString,
                                              0,
                                              0,
                                              0 );

    /* Add the B64-ed character count of account ID. */
    cchCount += CCH_BASE64_EQUIV( SIZEOF( DRM_GUID ) );

    if ( f_cchCustomData > 0 )
    {
        /* <CustomData> */
        cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrDomLeaveCustomDataTag.cchString,
                                                  f_cchCustomData,
                                                  0,
                                                  0 );

        /* Possible alignment cost. */
        cchCount += SIZEOF( DRM_WORD );
    }

    /* Calculate the character count of the data to be encrypted. */
    cchEncryptedCount = _CalcLeaveChallengeDataCharCount( f_cchDeviceCert );

    cbEncryptedSize = cchEncryptedCount * SIZEOF( DRM_CHAR );

    /* Add the character count of the encrypted data. */
    ChkDR( DRM_XMLSIG_GetEncryptedDataNodeCharCount( f_poXMLKey,
                                                     cbEncryptedSize,
                                                     &cchEncryptedCount ) );

    cchCount += cchEncryptedCount;

    /* Add the character count of the signature. */
    ChkDR( DRM_XMLSIG_GetSignatureNodeCharCount( &cchSignatureXMLCount ) );

    cchCount += cchSignatureXMLCount;

ErrorExit:

    return cchCount;
}

/*********************************************************************
**
** Function: _BuildJoinChallengeDataXML
**
** Synopsis: Function that constructs a sub XML segment to be encrypted in
**           the domain join challenge XML string using the XML builder.
**
** Arguments:
**
** [f_pbDeviceCert]         -- Pointer to a buffer that contains the passed in device
**                             certificate.
** [f_cbDeviceCert]         -- Size (number of bytes) of the passed in device certificate.
** [f_pdastrXML]            -- Pointer to a DRM UTF8/ANSI string that is used
**                             to receive a constructed XML segment string.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT _BuildJoinChallengeDataXML(
    __in_opt DRM_VOID *f_pOEMContext,
    IN const DRM_BYTE *f_pbDeviceCert,
    IN DRM_DWORD f_cbDeviceCert,
    OUT DRM_ANSI_STRING *f_pdastrXML )
{
    DRM_RESULT dr = DRM_SUCCESS;
    _XMBContextA *poXMLContext = NULL;
    DRM_BYTE *pbXMLContext = NULL;
    DRM_DWORD cbXMLContext = 0;
    DRM_SUBSTRING dasstrDeviceCert = EMPTY_DRM_SUBSTRING;
    DRM_CHAR *pchXML = NULL;
    DRM_SUBSTRING dasstrXML = EMPTY_DRM_SUBSTRING;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DOMAINAPI, PERF_FUNC__BuildJoinChallengeDataXML );

    ChkDRMANSIString( f_pdastrXML );
    ChkArg( f_pbDeviceCert != NULL && f_cbDeviceCert > 0 );

    pbXMLContext = PB_DASTR( f_pdastrXML );
    cbXMLContext = CB_DASTR( f_pdastrXML );

    ChkDR( DRM_UTL_EnsureDataAlignment( pbXMLContext,
                                        cbXMLContext,
                                        ( DRM_BYTE ** )&poXMLContext,
                                        &cbXMLContext,
                                        SIZEOF( DRM_DWORD ),
                                        NULL ) );

    /*
    ** Add and open <Data> node.
    **
    ** Output:
    ** <Data>
    */
    ChkDR( DRM_XMB_CreateDocumentA( cbXMLContext,
                                    ( DRM_BYTE * )poXMLContext,
                                    &g_dastrDomJoinDataTag ) );

    ChkDR( DRM_XMB_GetXMLBaseA( poXMLContext, &pchXML ) );

    /*
    ** Add and open <CertificateChain> node.
    **
    ** Output:
    ** <Data>
    **      <CertificateChain>
    */
    ChkDR( DRM_XMB_WriteTagA( poXMLContext,
                              &g_dastrDomJoinCertificateChainTag,
                              NULL,
                              NULL,
                              NULL,
                              wttOpen ) );

    /*
    ** Add the device certificate.
    **
    ** Output:
    ** <Data>
    **      <CertificateChain>
    **          device certificate
    */

    /* Reserve a buffer starting at a DRM_WORD aligned address. */
    ChkDR( DRM_XMB_ReserveSpaceA( poXMLContext,
                                  SIZEOF( DRM_WORD ),
                                  CCH_BASE64_EQUIV( f_cbDeviceCert ),
                                  &dasstrDeviceCert ) );
 
    DRM_BYT_MoveBytes( pchXML,
                       dasstrDeviceCert.m_ich,
                       f_pbDeviceCert,
                       0,
                       f_cbDeviceCert );

    /*
    ** Since the space reserved is guaranteed to start at a DRM_WORD aligned address,
    ** using pointer arithmatic is OK.
    */
    ChkDR( DRM_B64_EncodeA( (DRM_BYTE *)pchXML + __CB_DECL( dasstrDeviceCert.m_ich ),
                            f_cbDeviceCert, 
                            pchXML + __CB_DECL( dasstrDeviceCert.m_ich ), 
                            &dasstrDeviceCert.m_cch, 
                            0 ) );

    /*
    ** Close <CertificateChain> node.
    **
    ** Output:
    ** <Data>
    **      <CertificateChain>
    **          ...
    **      </CertificateChain>
    */
    ChkDR( DRM_XMB_CloseCurrNodeA( poXMLContext, NULL ) );

    /*
    ** Close <Data> node.
    **
    ** Output:
    ** <Data>
    **  ...
    ** </Data>
    */
    ChkDR( DRM_XMB_CloseDocumentA( poXMLContext, &dasstrXML ) );

    f_pdastrXML->pszString = pchXML;
    f_pdastrXML->cchString = dasstrXML.m_cch;

    ChkDR( DRM_SOAPXML_PadANSIString( f_pdastrXML, DRM_AES_BLOCKLEN ) );

    DRM_BYT_MoveBytes( pbXMLContext, 0, pchXML, 0, f_pdastrXML->cchString );

    f_pdastrXML->pszString = ( DRM_CHAR * )pbXMLContext;

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: _BuildLeaveChallengeDataXML
**
** Synopsis: Function that constructs a sub XML segment to be encrypted in
**           the domain leave challenge XML string using the XML builder.
**
** Arguments:
**
** [f_pbDeviceCert]         -- Pointer to a buffer that contains the passed in device
**                             certificate.
** [f_cbDeviceCert]         -- Size (number of bytes) of the passed in device certificate.
** [f_pdastrXML]            -- Pointer to a DRM UTF8/ANSI string that is used
**                             to receive a constructed XML segment string.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT _BuildLeaveChallengeDataXML(
    __in_opt DRM_VOID *f_pOEMContext,
    IN const DRM_BYTE *f_pbDeviceCert,
    IN DRM_DWORD f_cbDeviceCert,
    OUT DRM_ANSI_STRING *f_pdastrXML )
{
    DRM_RESULT dr = DRM_SUCCESS;
    _XMBContextA *poXMLContext = NULL;
    DRM_BYTE *pbXMLContext = NULL;
    DRM_DWORD cbXMLContext = 0;
    DRM_SUBSTRING dasstrDeviceCert = EMPTY_DRM_SUBSTRING;
    DRM_CHAR *pchXML = NULL;
    DRM_SUBSTRING dasstrXML = EMPTY_DRM_SUBSTRING;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DOMAINAPI, PERF_FUNC__BuildLeaveChallengeDataXML );

    ChkDRMANSIString( f_pdastrXML );
    ChkArg( f_pbDeviceCert != NULL && f_cbDeviceCert > 0 );

    pbXMLContext = PB_DASTR( f_pdastrXML );
    cbXMLContext = CB_DASTR( f_pdastrXML );

    ChkDR( DRM_UTL_EnsureDataAlignment( pbXMLContext,
                                        cbXMLContext,
                                        ( DRM_BYTE ** )&poXMLContext,
                                        &cbXMLContext,
                                        SIZEOF( DRM_DWORD ),
                                        NULL ) );

    /*
    ** Add and open <Data> node.
    **
    ** Output:
    ** <Data>
    */
    ChkDR( DRM_XMB_CreateDocumentA( cbXMLContext,
                                    ( DRM_BYTE * )poXMLContext,
                                    &g_dastrDomLeaveDataTag ) );

    ChkDR( DRM_XMB_GetXMLBaseA( poXMLContext, &pchXML ) );

    /*
    ** Add and open <CertificateChain> node.
    **
    ** Output:
    ** <Data>
    **  ...
    **      <CertificateChain>
    */
    ChkDR( DRM_XMB_WriteTagA( poXMLContext,
                              &g_dastrDomLeaveCertificateChainTag,
                              NULL,
                              NULL,
                              NULL,
                              wttOpen ) );

    /*
    ** Add the device certificate.
    **
    ** Output:
    ** <Data>
    **  ...
    **      <CertificateChain>
    **          device certificate
    */

    /* Reserve a buffer starting at a DRM_WORD aligned address. */
    ChkDR( DRM_XMB_ReserveSpaceA( poXMLContext,
                                  SIZEOF( DRM_WORD ),
                                  CCH_BASE64_EQUIV( f_cbDeviceCert ),
                                  &dasstrDeviceCert ) );
 
    DRM_BYT_MoveBytes( pchXML,
                       dasstrDeviceCert.m_ich,
                       f_pbDeviceCert,
                       0,
                       f_cbDeviceCert );

    /*
    ** Since the space reserved is guaranteed to start at a DRM_WORD aligned address,
    ** using pointer arithmatic is OK.
    */
    ChkDR( DRM_B64_EncodeA( (DRM_BYTE *)pchXML + __CB_DECL( dasstrDeviceCert.m_ich ),
                            f_cbDeviceCert, 
                            pchXML + __CB_DECL( dasstrDeviceCert.m_ich ), 
                            &dasstrDeviceCert.m_cch, 
                            0 ) );

    /*
    ** Close <CertificateChain> node.
    **
    ** Output:
    ** <Data>
    **  ...
    **      <CertificateChain>
    **          ...
    **      </CertificateChain>
    */
    ChkDR( DRM_XMB_CloseCurrNodeA( poXMLContext, NULL ) );

    /*
    ** Close <Data> node.
    **
    ** Output:
    ** <Data>
    **  ...
    ** </Data>
    */
    ChkDR( DRM_XMB_CloseDocumentA( poXMLContext, &dasstrXML ) );

    f_pdastrXML->pszString = pchXML;
    f_pdastrXML->cchString = dasstrXML.m_cch;

    ChkDR( DRM_SOAPXML_PadANSIString( f_pdastrXML, DRM_AES_BLOCKLEN ) );

    DRM_BYT_MoveBytes( pbXMLContext, 0, pchXML, 0, f_pdastrXML->cchString );

    f_pdastrXML->pszString = ( DRM_CHAR * )pbXMLContext;

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: _BuildJoinChallengeXML
**
** Synopsis: Function that constructs a domain join challenge XML
**           string using the XML builder.
**
** Arguments:
**
** [f_poXMLContext]         -- Pointer to a XML builder context.
** [f_cbXMLContext]         -- Size (number of bytes) of internal buffer
**                             of a XML builder context.
**                             into the signature XML segment.
** [f_poBBXContext]         -- Pointer to a DRM_BB_CONTEXT context.
** [f_poDomainID]           -- Pointer to a domain ID.
** [f_cchDeviceCert]        -- Size (number of characters) of a device
**                             certificate.
** [f_poXMLKey]             -- Pointer to a DRM_XML_KEY structure that
**                             contains the key information to encrypt
**                             the device certificate.
** [f_pchFriendlyName]      -- Pointer to a character buffer that contains
**                             the friendly name. It can be NULL.
** [f_cchFriendlyName]      -- Size (number of characters) of the friendly
**                             name string.
** [f_pbDeviceCert]         -- Pointer to a buffer that contains the passed in device
**                             certificate.
** [f_cbDeviceCert]         -- Size (number of bytes) of the passed in device certificate.
** [f_pchCustomData]        -- Pointer to a character buffer that contains
**                             the custom data. It can be NULL.
** [f_cchCustomData]        -- Size (number of characters) of the custom
**                             data string.
** [f_pdastrXML]            -- Pointer to a DRM UTF8/ANSI string that is used
**                             to receive a constructed domain join challenge
**                             XML string.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT _BuildJoinChallengeXML(
    IN OUT _XMBContextA *f_poXMLContext,
    IN DRM_DWORD f_cbXMLContext,
    IN DRM_BB_CONTEXT *f_poBBXContext,
    IN DRM_DOMAIN_ID *f_poDomainID,
    IN DRM_XML_KEY *f_poXMLKey,
    IN const DRM_CHAR *f_pchFriendlyName,
    IN DRM_DWORD f_cchFriendlyName,
    IN const DRM_BYTE *f_pbDeviceCert,
    IN DRM_DWORD f_cbDeviceCert,
    IN const DRM_CHAR *f_pchCustomData,
    IN DRM_DWORD f_cchCustomData,
    OUT DRM_ANSI_STRING *f_pdastrXML )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BYTE rgbServiceID[ __CB_DECL( CCH_BASE64_EQUIV( SIZEOF( DRM_GUID ) ) ) ] = { 0 };
    DRM_ANSI_CONST_STRING dastrServiceID = EMPTY_DRM_STRING;
    DRM_BYTE rgbAccountID[ __CB_DECL( CCH_BASE64_EQUIV( SIZEOF( DRM_GUID ) ) ) ] = { 0 };
    DRM_ANSI_CONST_STRING dastrAccountID = EMPTY_DRM_STRING;
    DRM_WCHAR rgwchRevision[ DRM_MAX_CCH_BASE10_DWORD_STRING + 1 ] = { 0 };
    DRM_CHAR rgchRevision[ __CB_DECL( DRM_MAX_CCH_BASE10_DWORD_STRING + 1 ) ] = { 0 };
    DRM_ANSI_CONST_STRING dastrRevision = EMPTY_DRM_STRING;
    DRM_DWORD cchData = 0;
    DRM_SUBSTRING dasstrCustomData = EMPTY_DRM_SUBSTRING;
    DRM_DWORD cchCustomData = 0;
    DRM_SUBSTRING dasstrFriendlyName = EMPTY_DRM_SUBSTRING;
    DRM_DWORD cchFriendlyName = 0;
    DRM_SUBSTRING dasstrSignedNode = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrEncryptedDataNode = EMPTY_DRM_SUBSTRING;
    DRM_ANSI_CONST_STRING dastrEncryptedXML = EMPTY_DRM_STRING;
    DRM_CHAR *pchXML = NULL;
    DRM_SUBSTRING dasstrXML = EMPTY_DRM_SUBSTRING;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DOMAINAPI, PERF_FUNC__BuildJoinChallengeXML );

    ChkArg( f_poXMLContext != NULL );
    ChkArg( f_cbXMLContext > 0 );
    ChkArg( f_poBBXContext != NULL );
    ChkArg( f_poDomainID != NULL );
    ChkArg( f_poXMLKey != NULL );
    ChkArg( ( f_pchFriendlyName == NULL && f_cchFriendlyName == 0 ) ||
            ( f_pchFriendlyName != NULL && f_cchFriendlyName > 0 ) );
    ChkArg( f_pbDeviceCert != NULL && f_cbDeviceCert > 0 );
    ChkArg( ( f_pchCustomData == NULL && f_cchCustomData == 0 ) ||
            ( f_pchCustomData != NULL && f_cchCustomData > 0 ) );
    ChkArg( f_pdastrXML != NULL );

#if DRM_USE_SOAP

    /* Add SOAP headers. */
    ChkDR( DRM_SOAPXML_BuildSOAPHeaderXML( f_poXMLContext, f_cbXMLContext ) );

    /*
    ** Add and open <JoinDomain> node.
    **
    ** Output:
    ** [<SOAP headers>]
    ** <JoinDomain ...>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                              &g_dastrDomJoinRootTag,
                              NULL,
                              &g_dastrDomJoinRootAttribName,
                              &g_dastrDomJoinRootAttribValue,
                              wttOpen ) );

#else
    /*
    ** Add and open <JoinDomain> node.
    **
    ** Output:
    ** <JoinDomain ...>
    */
    ChkDR( DRM_XMB_CreateDocumentA( f_cbXMLContext,
                                    ( DRM_BYTE * )f_poXMLContext,
                                    &g_dastrDomJoinRootTag ) );

    ChkDR( DRM_XMB_AddAttributeA( f_poXMLContext,
                                  &g_dastrDomJoinRootAttribName,
                                  &g_dastrDomJoinRootAttribValue ) );
#endif

    ChkDR( DRM_XMB_GetXMLBaseA( f_poXMLContext, &pchXML ) );

    /*
    ** Add and open <challenge> node.
    **
    ** Output:
    ** [<SOAP headers>] (optional)
    ** <JoinDomain ...>
    **      <challenge>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                              &g_dastrDomJoinChallenge1Tag,
                              NULL,
                              NULL,
                              NULL,
                              wttOpen ) );

    /*
    ** Add and open <Challenge> node.
    **
    ** Output:
    ** [<SOAP headers>] (optional)
    ** <JoinDomain ...>
    **      <challenge>
    **          <Challenge ...>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                              &g_dastrDomJoinChallenge2Tag,
                              NULL,
                              NULL,
                              NULL,
                              wttOpen ) );

    ChkDR( DRM_XMB_AddAttributeA( f_poXMLContext,
                                  &g_dastrDomJoinChallenge2AttribName,
                                  &g_dastrDomJoinChallenge2AttribValue ) );

    /*
    ** Add and open <Domain> node.
    **
    ** Output:
    ** [<SOAP headers>] (optional)
    ** <JoinDomain ...>
    **      ...
    **      <challenge>
    **          <Challenge ...>
    **              <Domain ...>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                              &g_dastrDomJoinDomainTag,
                              NULL,
                              &g_dastrDomJoinDomainAttrib1Name,
                              &g_dastrDomJoinDomainAttrib1Value,
                              wttOpen ) );
    
    ChkDR( DRM_XMB_AddAttributeA( f_poXMLContext,
                                  &g_dastrDomJoinDomainAttrib2Name,
                                  &g_dastrDomJoinDomainAttrib2Value ) );
    

    ChkDR( DRM_XMB_AddAttributeA( f_poXMLContext,
                                  &g_dastrSOAPPreserveSpaceAttribName,
                                  &g_dastrSOAPPreserveSpaceAttribValue ) );

    /*
    ** Add and close <Version> node.
    **
    ** Output:
    ** [<SOAP headers>] (optional)
    ** <JoinDomain ...>
    **      <challenge>
    **          <Challenge ...>
    **              <Domain ...>
    **                  <Version>...</Version>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                              &g_dastrDomJoinVersionTag,
                              &g_dastrDomainJoinVersion,
                              NULL,
                              NULL,
                              wttClosed ) );

    if ( !DRM_SOAPXML_IsBlankGUID( &f_poDomainID->m_oServiceID ) )
    {
        cchData = SIZEOF( rgbServiceID );

        ChkDR( DRM_B64_EncodeA( ( DRM_BYTE * )&f_poDomainID->m_oServiceID,
                                SIZEOF( DRM_GUID ),
                                ( DRM_CHAR * )rgbServiceID,
                                &cchData,
                                0 ) );

        dastrServiceID.pszString = ( DRM_CHAR * )rgbServiceID;
        dastrServiceID.cchString = cchData;

        /*
        ** Add and close <ServiceID> node.
        **
        ** Output:
        ** [<SOAP headers>] (optional)
        ** <JoinDomain ...>
        **      ...
        **      <challenge>
        **          <Challenge ...>
        **              <Domain ...>
        **                  ...
        **                  <ServiceID>...</ServiceID>
        */
        ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                                  &g_dastrDomJoinServiceIDTag,
                                  &dastrServiceID,
                                  NULL,
                                  NULL,
                                  wttClosed ) );
    }

    if ( !DRM_SOAPXML_IsBlankGUID( &f_poDomainID->m_oAccountID ) )
    {
        cchData = SIZEOF( rgbAccountID );

        ChkDR( DRM_B64_EncodeA( ( DRM_BYTE * )&f_poDomainID->m_oAccountID,
                                SIZEOF( DRM_GUID ),
                                ( DRM_CHAR * )rgbAccountID,
                                &cchData,
                                0 ) );

        dastrAccountID.pszString = ( DRM_CHAR * )rgbAccountID;
        dastrAccountID.cchString = cchData;

        /*
        ** Add and close <AccountID> node.
        **
        ** Output:
        ** [<SOAP headers>] (optional)
        ** <JoinDomain ...>
        **      ...
        **      <challenge>
        **          <Challenge ...>
        **              <Domain ...>
        **                  ...
        **                  <AccountID>...</AccountID>
        */
        ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                                  &g_dastrDomJoinAccountIDTag,
                                  &dastrAccountID,
                                  NULL,
                                  NULL,
                                  wttClosed ) );
    }

    if ( f_poDomainID->m_dwRevision != 0 )
    {
        ChkDR( DRM_STR_NumberToString( f_poDomainID->m_dwRevision,
                                       rgwchRevision,
                                       DRM_MAX_CCH_BASE10_DWORD_STRING + 1,
                                       0, 10, &cchData ) );

        DRMASSERT( cchData <= DRM_MAX_CCH_BASE10_DWORD_STRING );

        if ( cchData > DRM_MAX_CCH_BASE10_DWORD_STRING )
        {
            cchData = DRM_MAX_CCH_BASE10_DWORD_STRING;
        }

        /* Safe to use, input parameter is in ASCII */
        DRM_UTL_DemoteUNICODEtoASCII( rgwchRevision, rgchRevision, cchData + 1 );

        dastrRevision.pszString = rgchRevision;
        dastrRevision.cchString = cchData;

        /*
        ** Add and close <Revision> node.
        **
        ** Output:
        ** [<SOAP headers>] (optional)
        ** <JoinDomain ...>
        **      ...
        **      <challenge>
        **          <Challenge ...>
        **              <Domain ...>
        **                  ...
        **                  <Revision>...</Revision>
        */
        ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                                  &g_dastrDomJoinRevisionTag,
                                  &dastrRevision,
                                  NULL,
                                  NULL,
                                  wttClosed ) );
    }

    /* Estimate the size of the XML encoded friendly name. */
    ChkDR( DRM_SOAPXML_EncodeData( f_pchFriendlyName,
                                   f_cchFriendlyName,
                                   NULL,
                                   &cchFriendlyName ) );

    if ( cchFriendlyName > 0 )
    {
        ChkDR( DRM_SOAPXML_EnsureTagValueNativeByteAligned( f_poXMLContext, 
                                                            &g_dastrDomJoinFriendlyNameTag ) );

        /*
        ** Add and open <FriendlyName> node.
        **
        ** Output:
        ** [<SOAP headers>] (optional)
        ** <JoinDomain ...>
        **      ...
        **      <challenge>
        **          <Challenge ...>
        **              <Domain ...>
        **                  ...
        **                  <FriendlyName>
        */
        ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                                  &g_dastrDomJoinFriendlyNameTag,
                                  NULL,
                                  NULL,
                                  NULL,
                                  wttOpen ) );

        ChkDR( DRM_XMB_ReserveSpaceA( f_poXMLContext,
                                      SIZEOF( DRM_BYTE ),
                                      cchFriendlyName,
                                      &dasstrFriendlyName ) );
    
        ChkDR( DRM_SOAPXML_EncodeData( f_pchFriendlyName,
                                       f_cchFriendlyName,
                                       pchXML + __CB_DECL( dasstrFriendlyName.m_ich ),
                                       &cchFriendlyName ) );

        /*
        ** Close <FriendlyName> node.
        **
        ** Output:
        ** [<SOAP headers>] (optional)
        ** <JoinDomain ...>
        **      ...
        **      <challenge>
        **          <Challenge ...>
        **              <Domain ...>
        **                  ...
        **                  <FriendlyName>...</FriendlyNamea>
        */
        ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContext, NULL ) );
    }

    /* Estimate the size of the XML encoded custom data. */
    ChkDR( DRM_SOAPXML_EncodeData( f_pchCustomData,
                                   f_cchCustomData,
                                   NULL,
                                   &cchCustomData ) );

    if ( cchCustomData > 0  )
    {
        ChkDR( DRM_SOAPXML_EnsureTagValueNativeByteAligned( f_poXMLContext, 
                                                            &g_dastrDomJoinCustomDataTag ) );

        /*
        ** Add and open <CustomData> node.
        **
        ** Output:
        ** [<SOAP headers>] (optional)
        ** <JoinDomain ...>
        **      ...
        **      <challenge>
        **          <Challenge ...>
        **              <Domain ...>
        **                  ...
        **                  <CustomData>
        */
        ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                                  &g_dastrDomJoinCustomDataTag,
                                  NULL,
                                  NULL,
                                  NULL,
                                  wttOpen ) );

        ChkDR( DRM_XMB_ReserveSpaceA( f_poXMLContext,
                                      SIZEOF( DRM_BYTE ),
                                      cchCustomData,
                                      &dasstrCustomData ) );
    
        ChkDR( DRM_SOAPXML_EncodeData( f_pchCustomData,
                                       f_cchCustomData,
                                       pchXML + __CB_DECL( dasstrCustomData.m_ich ),
                                       &cchCustomData ) );

        /*
        ** Close <CustomData> node.
        **
        ** Output:
        ** [<SOAP headers>] (optional)
        ** <JoinDomain ...>
        **      ...
        **      <challenge>
        **          <Challenge ...>
        **              <Domain ...>
        **                  ...
        **                  <CustomData>...</CustomData>
        */
        ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContext, NULL ) );
    }

    ChkDR( DRM_XMB_GetCurrentBufferPointerA( f_poXMLContext,
                                             TRUE,
                                             ( DRM_CHAR ** )&dastrEncryptedXML.pszString ) );

    dastrEncryptedXML.cchString = _CalcJoinChallengeDataCharCount( CCH_BASE64_EQUIV( f_cbDeviceCert ) );

    ChkDR( _BuildJoinChallengeDataXML( f_poBBXContext->pOEMContext,
                                       f_pbDeviceCert,
                                       f_cbDeviceCert,
                                       ( DRM_ANSI_STRING * )&dastrEncryptedXML ) );

    /* XML encrypt the data. */
    ChkDR( DRM_SOAPXML_EncryptDataWithXMLKey( f_poBBXContext->pOEMContext,
                                              f_poXMLKey,
                                              &dastrEncryptedXML,
                                              &f_poBBXContext->CryptoContext ) );

    /*
    ** Build <EncryptedData> node.
    **
    ** Output:
    ** [<SOAP headers>] (optional)
    ** <JoinDomain ...>
    **  ...
    **      <challenge>
    **          <Challenge ...>
    **              <Domain ...>
    **                  <EncryptedData>...</<EncryptedData>
    */
    ChkDR( DRM_XMLSIG_BuildEncryptedDataNode( f_poXMLContext,
                                              f_poXMLKey,
                                              dastrEncryptedXML.cchString,
                                              &dasstrEncryptedDataNode ) );

    ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContext, &dasstrSignedNode ) );

    /* The whole <Domain> node (inclusive) is signed. */
    ChkDR( DRM_XMLSIG_BuildSignatureNode( f_poXMLContext,
                                          f_poBBXContext,
                                          pchXML,
                                          &dasstrSignedNode ) );

    ChkDR( DRM_XMB_GetXMLBaseA( f_poXMLContext, &pchXML ) );

    /*
    ** Close all nodes that are still open.
    **
    ** Output:
    ** [<SOAP headers>] (optional)
    ** <JoinDomain ...>
    ** ...
    ** </JoinDomain>
    ** [</SOAP headers>] (optional)
    */
    ChkDR( DRM_XMB_CloseDocumentA( f_poXMLContext, &dasstrXML ) );

    f_pdastrXML->pszString = pchXML;
    f_pdastrXML->cchString = dasstrXML.m_cch;

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: _BuildLeaveChallengeXML
**
** Synopsis: Function that constructs a domain leave challenge XML
**           string using the XML builder.
**
** Arguments:
**
** [f_poXMLContext]         -- Pointer to a XML builder context.
** [f_cbXMLContext]         -- Size (number of bytes) of internal buffer
**                             of a XML builder context.
** [f_poBBXContext]         -- Pointer to a DRM_BB_CONTEXT context.
** [f_poDomainID]           -- Pointer to a domain ID.
** [f_cchDeviceCert]        -- Size (number of characters) of a device
**                             certificate.
** [f_poXMLKey]             -- Pointer to a DRM_XML_KEY structure that
**                             has the key information to encrypt the
**                             device certificate.
** [f_pbDeviceCert]         -- Pointer to a buffer that contains the passed in device
**                             certificate.
** [f_cbDeviceCert]         -- Size (number of bytes) of the passed in device certificate.
** [f_pchCustomData]        -- Pointer to a character buffer that contains
**                             the custom data. It can be NULL.
** [f_cchCustomData]        -- Size (number of characters) of the custom
**                             data string.
** [f_pdastrXML]            -- Pointer to a DRM UTF8/ANSI string that is used
**                             to receive a constructed domain leave challenge
**                             XML string.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT _BuildLeaveChallengeXML(
    IN OUT _XMBContextA *f_poXMLContext,
    IN DRM_DWORD f_cbXMLContext,
    IN DRM_BB_CONTEXT *f_poBBXContext,
    IN DRM_DOMAIN_ID *f_poDomainID,
    IN DRM_XML_KEY *f_poXMLKey,
    IN const DRM_BYTE *f_pbDeviceCert,
    IN DRM_DWORD f_cbDeviceCert,
    IN const DRM_CHAR *f_pchCustomData,
    IN DRM_DWORD f_cchCustomData,
    OUT DRM_ANSI_STRING *f_pdastrXML )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BYTE rgbAccountID[ __CB_DECL( CCH_BASE64_EQUIV( SIZEOF( DRM_GUID ) ) ) ] = { 0 };
    DRM_ANSI_CONST_STRING dastrAccountID = EMPTY_DRM_STRING;
    DRM_DWORD cchData = 0;
    DRM_SUBSTRING dasstrCustomData = EMPTY_DRM_SUBSTRING;
    DRM_DWORD cchCustomData = 0;
    DRM_SUBSTRING dasstrSignedNode = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrEncryptedDataNode = EMPTY_DRM_SUBSTRING;
    DRM_ANSI_CONST_STRING dastrEncryptedXML = EMPTY_DRM_STRING;
    DRM_CHAR *pchXML = NULL;
    DRM_SUBSTRING dasstrXML = EMPTY_DRM_SUBSTRING;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DOMAINAPI, PERF_FUNC__BuildLeaveChallengeXML );

    ChkArg( f_poXMLContext != NULL );
    ChkArg( f_cbXMLContext > 0 );
    ChkArg( f_poBBXContext != NULL );
    ChkArg( f_poDomainID != NULL );
    ChkArg( f_poXMLKey != NULL );
    ChkArg( f_pbDeviceCert != NULL && f_cbDeviceCert > 0 );
    ChkArg( ( f_pchCustomData == NULL && f_cchCustomData == 0 ) ||
            ( f_pchCustomData != NULL && f_cchCustomData > 0 ) );
    ChkArg( f_pdastrXML != NULL );

#if DRM_USE_SOAP

    /* Add SOAP headers. */
    ChkDR( DRM_SOAPXML_BuildSOAPHeaderXML( f_poXMLContext, f_cbXMLContext ) );

    /*
    ** Add and open <LeaveDomain> node.
    **
    ** Output:
    ** [<SOAP headers>]
    ** <LeaveDomain ...>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                              &g_dastrDomLeaveRootTag,
                              NULL,
                              &g_dastrDomLeaveRootAttribName,
                              &g_dastrDomLeaveRootAttribValue,
                              wttOpen ) );

#else

    /*
    ** Add and open <LeaveDomain> node.
    **
    ** Output:
    ** <LeaveDomain ...>
    */
    ChkDR( DRM_XMB_CreateDocumentA( f_cbXMLContext,
                                    ( DRM_BYTE * )f_poXMLContext,
                                    &g_dastrDomLeaveRootTag ) );

    ChkDR( DRM_XMB_AddAttributeA( f_poXMLContext,
                                  &g_dastrDomLeaveRootAttribName,
                                  &g_dastrDomLeaveRootAttribValue ) );

#endif

    ChkDR( DRM_XMB_GetXMLBaseA( f_poXMLContext, &pchXML ) );

    /*
    ** Add and open <challenge> node.
    **
    ** Output:
    ** [<SOAP headers>] (optional)
    ** <LeaveDomain ...>
    **      <challenge>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                              &g_dastrDomLeaveChallenge1Tag,
                              NULL,
                              NULL,
                              NULL,
                              wttOpen ) );

    /*
    ** Add and open <Challenge> node.
    **
    ** Output:
    ** [<SOAP headers>] (optional)
    ** <LeaveDomain ...>
    **      <challenge>
    **          <Challenge ...>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                              &g_dastrDomLeaveChallenge2Tag,
                              NULL,
                              NULL,
                              NULL,
                              wttOpen ) );

    ChkDR( DRM_XMB_AddAttributeA( f_poXMLContext,
                                  &g_dastrDomLeaveChallenge2AttribName,
                                  &g_dastrDomLeaveChallenge2AttribValue ) );

    /*
    ** Add and open <Domain> node.
    **
    ** Output:
    ** [<SOAP headers>] (optional)
    ** <LeaveDomain ...>
    **      ...
    **      <challenge>
    **          <Challenge ...>
    **              <Domain ...>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                              &g_dastrDomLeaveDomainTag,
                              NULL,
                              &g_dastrDomLeaveDomainAttrib1Name,
                              &g_dastrDomLeaveDomainAttrib1Value,
                              wttOpen ) );

    ChkDR( DRM_XMB_AddAttributeA( f_poXMLContext,
                                  &g_dastrDomLeaveDomainAttrib2Name,
                                  &g_dastrDomLeaveDomainAttrib2Value ) );
    
    ChkDR( DRM_XMB_AddAttributeA( f_poXMLContext,
                                  &g_dastrSOAPPreserveSpaceAttribName,
                                  &g_dastrSOAPPreserveSpaceAttribValue ) );

    /*
    ** Add and close <Version> node.
    **
    ** Output:
    ** <LeaveDomain ...>
    **      <challenge>
    **          <Challenge ...>
    **              <Domain ...>
    **                  <Version>...</Version>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                              &g_dastrDomLeaveVersionTag,
                              &g_dastrDomainLeaveVersion,
                              NULL,
                              NULL,
                              wttClosed ) );


    cchData = SIZEOF( rgbAccountID );

    ChkDR( DRM_B64_EncodeA( ( DRM_BYTE * )&f_poDomainID->m_oAccountID,
                            SIZEOF( DRM_GUID ),
                            ( DRM_CHAR * )rgbAccountID,
                            &cchData,
                            0 ) );

    dastrAccountID.pszString = ( DRM_CHAR * )rgbAccountID;
    dastrAccountID.cchString = cchData;

    /*
    ** Add and close <AccountID> node.
    **
    ** Output:
    ** [<SOAP headers>] (optional)
    ** <LeaveDomain ...>
    **      ...
    **      <challenge>
    **          <Challenge ...>
    **              <Domain ...>
    **                  ...
    **                  <AccountID>...</AccountID>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                              &g_dastrDomLeaveAccountIDTag,
                              &dastrAccountID,
                              NULL,
                              NULL,
                              wttClosed ) );

    /* Estimate the size of the XML encoded custom data. */
    ChkDR( DRM_SOAPXML_EncodeData( f_pchCustomData,
                                   f_cchCustomData,
                                   NULL,
                                   &cchCustomData ) );

    if ( cchCustomData > 0  )
    {
        ChkDR( DRM_SOAPXML_EnsureTagValueNativeByteAligned( f_poXMLContext, 
                                                            &g_dastrDomLeaveCustomDataTag ) );

        
        /*
        ** Add and open <CustomData> node.
        **
        ** Output:
        ** [<SOAP headers>] (optional)
        ** <LeaveDomain ...>
        **      ...
        **      <challenge>
        **          <Challenge ...>
        **              <Domain ...>
        **                  ...
        **                  <CustomData>
        */
        ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                                  &g_dastrDomLeaveCustomDataTag,
                                  NULL,
                                  NULL,
                                  NULL,
                                  wttOpen ) );

        ChkDR( DRM_XMB_ReserveSpaceA( f_poXMLContext,
                                      SIZEOF( DRM_BYTE ),
                                      cchCustomData,
                                      &dasstrCustomData ) );
    
        ChkDR( DRM_SOAPXML_EncodeData( f_pchCustomData,
                                       f_cchCustomData,
                                       pchXML + __CB_DECL( dasstrCustomData.m_ich ),
                                       &cchCustomData ) );

        /*
        ** Close <CustomData> node.
        **
        ** Output:
        ** [<SOAP headers>] (optional)
        ** <LeaveDomain ...>
        **      ...
        **      <challenge>
        **          <Challenge ...>
        **              <Domain ...>
        **                  ...
        **                  <CustomData>...</CustomData>
        */
        ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContext, NULL ) );
    }

    ChkDR( DRM_XMB_GetCurrentBufferPointerA( f_poXMLContext,
                                             TRUE,
                                             ( DRM_CHAR ** )&dastrEncryptedXML.pszString ) );

    dastrEncryptedXML.cchString = _CalcJoinChallengeDataCharCount( CCH_BASE64_EQUIV( f_cbDeviceCert ) );

    ChkDR( _BuildLeaveChallengeDataXML( f_poBBXContext->pOEMContext,
                                        f_pbDeviceCert,
                                        f_cbDeviceCert,
                                        ( DRM_ANSI_STRING * )&dastrEncryptedXML ) );

    /* XML encrypt the data. */
    ChkDR( DRM_SOAPXML_EncryptDataWithXMLKey( f_poBBXContext->pOEMContext,
                                              f_poXMLKey,
                                              &dastrEncryptedXML,
                                              &f_poBBXContext->CryptoContext) );

    /*
    ** Build <EncryptedData> node.
    **
    ** Output:
    ** [<SOAP headers>] (optional)
    ** <LeaveDomain ...>
    **  ...
    **      <challenge>
    **          <Challenge ...>
    **              <Domain ...>
    **                  ...
    **                  <EncryptedData>...</<EncryptedData>
    */
    ChkDR( DRM_XMLSIG_BuildEncryptedDataNode( f_poXMLContext,
                                              f_poXMLKey,
                                              dastrEncryptedXML.cchString,
                                              &dasstrEncryptedDataNode ) );

    ChkDR( DRM_XMB_GetXMLBaseA( f_poXMLContext, &pchXML ) );

    ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContext, &dasstrSignedNode ) );

    /* The whole <Domain> node (inclusive) is signed. */
    ChkDR( DRM_XMLSIG_BuildSignatureNode( f_poXMLContext,
                                          f_poBBXContext,
                                          pchXML,
                                          &dasstrSignedNode ) );

    /*
    ** Close all nodes that are still open.
    **
    ** Output:
    ** [<SOAP headers>] (optional)
    ** <LeaveDomain ...>
    ** ...
    ** </LeaveDomain>
    ** [</SOAP headers>] (optional)
    */
    ChkDR( DRM_XMB_CloseDocumentA( f_poXMLContext, &dasstrXML ) );

    f_pdastrXML->pszString = pchXML;
    f_pdastrXML->cchString = dasstrXML.m_cch;

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


#define DRM_CERTS_NEEDED        2
#define DRM_SERVICE_CERT_INDEX  1 



/*********************************************************************
**
** Function: _ProcessJoinDataFromResponse
**
** Synopsis: Function that extracts and processes data from
**           the domain join response. They are: domain ID,
**           domain private key, domain certificate and possibly
**           previous revisions of domain private keys.
**           The extracted data is stored into the domain store.
**
** Arguments:
**
** [f_poDomainStoreContext] -- Pointer to a domain store context.
** [f_poBBXContext]         -- Pointer to a DRM_BB_CONTEXT context.
** [f_pdastrResponse]       -- Pointer to a DRM UTF8/ANSI string that
**                             contains a domain join response XML
**                             received from the server.
** [f_poDomainID]           -- Optional pointer to a variable that is used to
**                             receive the domain id parsed out from the domain
**                             join response.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT _ProcessJoinDataFromResponse(
    IN     DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    IN     DRM_BB_CONTEXT *f_poBBXContext,
    IN OUT DRM_ANSI_STRING *f_pdastrResponse,
    OUT    DRM_DOMAIN_ID *f_poDomainID )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_SUBSTRING dasstrResponse = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrServiceID = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrAccountID = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrEncryptedData = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrDecryptedData = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrEncryptedCertificateData = EMPTY_DRM_SUBSTRING;
    DRM_ANSI_STRING dastrDecryptedCertificateData = EMPTY_DRM_STRING;
    DRM_SUBSTRING dasstrXMLPubKey = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrDomainKeys = EMPTY_DRM_SUBSTRING;
    DRM_DOMAIN_ID oDomainID = EMPTY_DRM_DOMAIN_ID;
    DRM_DWORD cbSize = 0;
    DRM_CHAR *pchDecryptedData = NULL;
    DRM_DWORD cchDecryptedData = 0;
    DRM_BYTE *pbDomainKeysData = NULL;
    DRM_DWORD cbDomainKeysData = 0;
    PUBKEY_P256 oECC256PubKey = {0};

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DOMAINAPI, PERF_FUNC__ProcessJoinDataFromResponse );

    ChkArg( f_poDomainStoreContext != NULL );
    ChkArg( f_poBBXContext != NULL );
    ChkDRMANSIString( f_pdastrResponse );

    dasstrResponse.m_ich = 0;
    dasstrResponse.m_cch = f_pdastrResponse->cchString;

#if DRM_USE_SOAP

    ChkDR( DRM_SOAPXML_SkipSOAPHeaders( ( DRM_CHAR * )f_pdastrResponse->pszString,
                                         &dasstrResponse ) );

#endif

    /* Extract <DomainKeys> node from the response
    ** We receive the node into dasstrDomainKeys first before we decrpt the 
    ** <EncryptedData> node 
    */
    ChkDR( DRM_XML_GetSubNodeByPathA( f_pdastrResponse->pszString,
                                      &dasstrResponse,
                                      &g_dastrDomJoinDomainKeysPath,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &dasstrDomainKeys,
                                      g_chForwardSlash ) );

    /*
    ** Extract <EncryptedKey> node from <EncryptedData>/<KeyInfo> node.
    ** The subnode <KeyInfo> under <EncryptedKey> node contains an ECC-256
    ** public key that is used to decrypt the domain private key.
    */
    ChkDR( DRM_XML_GetSubNodeByPathA( f_pdastrResponse->pszString,
                                      &dasstrResponse,
                                      &g_dastrDomJoinKeyInfoPath,
                                      NULL,
                                      NULL,
                                      &dasstrXMLPubKey,
                                      NULL,
                                      g_chForwardSlash ) );

    /*
    ** Extract <EncryptedData> node from the response.
    */
    ChkDR( DRM_XML_GetSubNodeByPathA( f_pdastrResponse->pszString,
                                      &dasstrResponse,
                                      &g_dastrDomJoinEncryptedDataPath,
                                      NULL,
                                      NULL,
                                      &dasstrEncryptedData,
                                      NULL,
                                      g_chForwardSlash ) );

    /*
    ** Decrypt data contained in the <EncryptedData> XML segment.
    ** The data is decrypted in place so the original response
    ** XML string may not be valid after the decryption is done.
    ** Before exiting this function, the encrypted data portion
    ** will be reset to be all blanks, therefore allowing additional
    ** XML parsing (e.g. parsing of custom data) of the original
    ** response XML string to be possible by other functions.
    */
    ChkDR( DRM_XMLSIG_ExtractEncryptedData( f_poBBXContext,
                                            f_pdastrResponse->pszString,
                                            &dasstrEncryptedData,
                                            ( DRM_BYTE ** )&pchDecryptedData,
                                            &cchDecryptedData ) ); 

    dasstrDecryptedData.m_ich = 0;
    dasstrDecryptedData.m_cch = cchDecryptedData;

    /* Extract <ServiceID> node from the decrypted data. */
    ChkDR( DRM_XML_GetSubNodeByPathA( pchDecryptedData,
                                      &dasstrDecryptedData,
                                      &g_dastrDomJoinServiceIDPath,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &dasstrServiceID,
                                      g_chForwardSlash ) );

    cbSize = SIZEOF( DRM_GUID );

    if ( DRM_FAILED( DRM_B64_DecodeA( pchDecryptedData,
                                      &dasstrServiceID,
                                      &cbSize,
                                      ( DRM_BYTE * )&oDomainID.m_oServiceID,
                                      0 ) ) )
    {
        ChkDR( DRM_E_DOMAIN_INVALID_GUID );
    }

    ChkBOOL( cbSize == SIZEOF( DRM_GUID ), DRM_E_DOMAIN_INVALID_GUID );

    /* Extract <AccountID> node from the decrypted data. */
    ChkDR( DRM_XML_GetSubNodeByPathA( pchDecryptedData,
                                      &dasstrDecryptedData,
                                      &g_dastrDomJoinAccountIDPath,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &dasstrAccountID,
                                      g_chForwardSlash ) );

    cbSize = SIZEOF( DRM_GUID );

    if ( DRM_FAILED( DRM_B64_DecodeA( pchDecryptedData,
                                      &dasstrAccountID,
                                      &cbSize,
                                      ( DRM_BYTE * )&oDomainID.m_oAccountID,
                                      0 ) ) )
    {
        ChkDR( DRM_E_DOMAIN_INVALID_GUID );
    }

    ChkBOOL( cbSize == SIZEOF( DRM_GUID ), DRM_E_DOMAIN_INVALID_GUID );


    /* Extract <CertificateChain> node from the decrypted data. */
    ChkDR( DRM_XML_GetSubNodeByPathA( pchDecryptedData,
                                      &dasstrDecryptedData,
                                      &g_dastrDomJoinCertificateChainPath,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &dasstrEncryptedCertificateData,
                                      g_chForwardSlash ) );

    ChkDR( DRM_B64_DecodeA( pchDecryptedData,
                            &dasstrEncryptedCertificateData,
                            &dastrDecryptedCertificateData.cchString,
                            NULL,
                            DRM_BASE64_DECODE_IN_PLACE ) );

    if ( dasstrEncryptedCertificateData.m_ich % CB_NATIVE_BYTE > 0 )
    {
        /*
        ** The code is running on a 16 bits/byte system and unfortunately
        ** dasstrEncryptedCertificateData starts in the middle of a native
        ** byte. Need to shift the whole substring specified by
        ** dasstrEncryptedCertificateData one DRM_BYTE to the higher address.
        ** It should be OK since in the worst case (assuming the previous B64
        ** decode does not leave any extra byte, which is highly unlikely),
        ** we will overwrite the first byte of the </EncryptedData> tag, which
        ** is OK since the whole <EncryptedData> node (including the enclosing
        ** tags) will be reset to black strings before the function exits.
        */
        DRM_BYT_MoveBytes( pchDecryptedData,
                           dasstrEncryptedCertificateData.m_ich + 1,
                           pchDecryptedData,
                           dasstrEncryptedCertificateData.m_ich,
                           dastrDecryptedCertificateData.cchString );

        dasstrEncryptedCertificateData.m_ich += 1;
    }
    
    dastrDecryptedCertificateData.pszString =
            pchDecryptedData + __CB_DECL( dasstrEncryptedCertificateData.m_ich );

    ChkDR( DRM_B64_DecodeA( f_pdastrResponse->pszString,
                            &dasstrDomainKeys,
                            &cbDomainKeysData,
                            NULL,
                            DRM_BASE64_DECODE_IN_PLACE) );

    pbDomainKeysData = (DRM_BYTE*)f_pdastrResponse->pszString + dasstrDomainKeys.m_ich;

    /* Process and store the domain keys */
    ChkDR( DRM_BBX_StoreDomainPrivateKeys( f_poBBXContext,
                                           f_poDomainStoreContext,
                                           pbDomainKeysData,
                                           cbDomainKeysData,
                                          &oDomainID,
                                          &oECC256PubKey,
                                          &dastrDecryptedCertificateData) );


    /* Return the domain id if f_poDomainID is not NULL.*/
    if ( f_poDomainID != NULL )
    {
        MEMCPY( f_poDomainID, &oDomainID, SIZEOF( DRM_DOMAIN_ID ) );
    }

ErrorExit:

    /*
    ** Set all bytes of the encrypted data portion of the original
    ** response XML string to ' ' to prevent future parsing error
    ** of the original response XML string.    
    */
    if( dasstrEncryptedData.m_ich != 0 )
    {
        DRM_BYT_SetBytes( ( DRM_BYTE * )f_pdastrResponse->pszString,
                          dasstrEncryptedData.m_ich,
                          dasstrEncryptedData.m_cch,
                          ' ' );
    }

    if( dasstrDomainKeys.m_ich != 0 )
    {
        DRM_BYT_SetBytes( ( DRM_BYTE * )f_pdastrResponse->pszString,
                          dasstrDomainKeys.m_ich,
                          dasstrDomainKeys.m_cch,
                          ' ' );
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: _GetLatestRevision
**
** Synopsis: Function that retrieve the latest revision number from
**           the domain store and updated the revision field of the
**           passed in domain ID, if the account ID of the passed in
**           domain ID is not empty.
**
** Arguments:
**
** [f_poDomainStoreContext] -- Pointer to a domain store context that has already
**                             been opened.
** [f_poDomainID]           -- Domain ID whose revision field is to be updated.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL _GetLatestRevision(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    IN OUT DRM_DOMAIN_ID *f_poDomainID )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD dwMaxRevision = 0, dwKeyRevision = 0;
    DRM_DOMAINSTORE_ENUM_CONTEXT oDomainStoreEnumContext = { 0 };
    DRM_GUID oAccountID = EMPTY_DRM_GUID;

    ChkArg( f_poDomainStoreContext != NULL );
    ChkArg( f_poDomainID != NULL );

    if ( DRM_SOAPXML_IsBlankGUID( &f_poDomainID->m_oAccountID ) )
    {
        f_poDomainID->m_dwRevision = 0;

        goto ErrorExit;
    }

    ChkDR( DRM_DOMST_InitEnumKey( f_poDomainStoreContext,
                                  &oDomainStoreEnumContext ) );

    for ( ; ; )
    {
        dr = DRM_DOMST_EnumNextKey( &oDomainStoreEnumContext,
                                    &oAccountID,
                                    &dwKeyRevision,
                                    NULL,
                                    NULL );

        if ( dr == DRM_E_NOMORE )
        {
            dr = DRM_SUCCESS;

            break;
        }
        else
        {
            ChkDR( dr );
        }

        if ( MEMCMP( &oAccountID, &f_poDomainID->m_oAccountID, SIZEOF( DRM_GUID ) ) != 0 )
        {
            /*
            ** Skip those domain private keys that do not match
            ** the passed in account ID.
            */
            continue;
        }

        if ( dwKeyRevision > dwMaxRevision )
        {
            dwMaxRevision = dwKeyRevision;
        }
    }

    f_poDomainID->m_dwRevision = dwMaxRevision;

ErrorExit:

    return dr;
}

/*********************************************************************
**
** Function: _ParseJoinDomainChallengeQueryData
**
** Synopsis: This function Parses the Join Domain Challenge Query Data and populates the
**                the Domain Account ID, Friendly name and Custom data.
**
** Arguments:
** [f_pchQueryData]     -- The XML Join domain Query data in ANSI of the form:
**                         <JoinDomain type = \"challenge\">
**                           <Data>
**                             <ServiceID>Optional Base 64 encoded Service Account ID string in ANSI</ServiceID>
**                             <AccountID>Optional Base 64 encoded Domain Account ID string in ANSI</AccountID>
**                             <Revision>Optional Domain Revision</Revision>
**                             <FriendlyName>Optional Friendly Name in ANSI </FriendlyName>
**                             <CustomData>Optional Custom Data in ANSI</CustomData>
**                           </Data>
**                         </JoinDomain>
**
** [f_cchQueryData]      -- Size (in characters) of the Query Data Buffer.
**
** [f_poDomainID]        -- Domain ID in the sent in the challenge.
**
** [f_ppchFriendlyName]  -- Pointer to pointer which will point to the Friendly name in the XML.
**
** [f_pcchFriendlyName]  -- Size (number of characters) of the friendly name string.
**                            
** [f_ppchCustomData]    -- Pointer pointer which will point to the Custom data in the XML.
**
** [f_pcchCustomData]    -- Size (in characters) of the custom data buffer.
**
** Returns:              DRM_SUCCESS on success.
**                       DRM_E_INVALIDARG if the arguments are invalid.
**                       DRM_E_DOMAIN_INVALID_CUSTOM_DATA if the custom data cannot be parsed.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL _ParseJoinDomainChallengeQueryData( 
    IN     const DRM_CHAR *f_pchQueryData,
    IN     DRM_DWORD       f_cchQueryData,
    IN OUT DRM_DOMAIN_ID  *f_poDomainID,
    IN OUT DRM_CHAR const**f_ppchFriendlyName,
    IN OUT DRM_DWORD      *f_pcchFriendlyName,
    IN OUT DRM_CHAR const**f_ppchCustomData,
    IN OUT DRM_DWORD      *f_pcchCustomData, 
    IN     DRM_BYTE       *f_pbChallenge )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cbServiceId = DRM_ID_SIZE;
    DRM_DWORD cbAccountId = DRM_ID_SIZE;
    DRM_SUBSTRING dsstrData = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dsstrSid = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dsstrAid = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dsstrRev = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dsstrFname = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dsstrCdata = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dsstrJdomain = EMPTY_DRM_SUBSTRING;
    DRM_BYTE *pbFreeBuffer = (DRM_BYTE*) f_pchQueryData;
    DRM_DWORD cbFreeBuffer = f_cchQueryData;
    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DOMAINAPI, PERF_FUNC__ParseJoinDomainChallengeQueryData );
    
    ChkArg( f_poDomainID != NULL );
    ChkArg( f_ppchFriendlyName != NULL );
    ChkArg( f_pcchFriendlyName != NULL );
    ChkArg( f_ppchCustomData != NULL );
    ChkArg( f_pcchCustomData != NULL );
    ChkArg( f_pchQueryData != NULL &&
            f_cchQueryData > 0 );

    dsstrJdomain.m_ich = 0;
    dsstrJdomain.m_cch = f_cchQueryData;
    
    /* Look for <JoinDomain> tag */      
    ChkDR( DRM_XML_GetNodeA( f_pchQueryData,
                             &dsstrJdomain,
                             &g_dastrDomJoinRootTag,
                             NULL,
                             NULL,
                             0,
                             &dsstrJdomain,
                             NULL ) );
    
    /* Get the <Data> node */
    ChkDR( DRM_XML_GetSubNodeA( f_pchQueryData,
                                &dsstrJdomain,
                                &g_dastrDomJoinDataTag,
                                NULL,
                                NULL,
                                0,
                                &dsstrData,
                                NULL,
                                1 ) );

    /*Get the <ServiceID> node from the <Data> node if available since it is optional */
    dr = DRM_XML_GetSubNodeA( f_pchQueryData,
                              &dsstrData,
                              &g_dastrDomJoinServiceIDTag,
                              NULL,
                              NULL,
                              0,
                              NULL,
                              &dsstrSid,
                              1 );
    
    if ( dr != DRM_E_XMLNOTFOUND && dsstrSid.m_cch != 0)
    {
        ChkDR(dr);

        /*Base 64 decode the Service ID and set it in the Domain ID struct */
        ChkDR( DRM_B64_DecodeA( f_pchQueryData,
                                &dsstrSid,
                                &cbServiceId,
                                (DRM_BYTE*)&(f_poDomainID->m_oServiceID),
                                0 ) );
    }

    /*Get the <AccountID> node from the <Data> node if available since it is optional */
    dr = DRM_XML_GetSubNodeA( f_pchQueryData,
                              &dsstrData,
                              &g_dastrDomJoinAccountIDTag,
                              NULL,
                              NULL,
                              0,
                              NULL,
                              &dsstrAid,
                              1 );
    
    if ( dr != DRM_E_XMLNOTFOUND && dsstrAid.m_cch != 0)
    {    
        ChkDR(dr);

        /*Base 64 decode the Account ID and set it in the Domain ID struct */
        ChkDR( DRM_B64_DecodeA( f_pchQueryData,
                                &dsstrAid,
                                &cbAccountId,
                                (DRM_BYTE*)&(f_poDomainID->m_oAccountID),
                                0 ) );
    }

    /*Get the <Revision> node from the <Data> node if available since it is optional */
    dr = DRM_XML_GetSubNodeA( f_pchQueryData,
                              &dsstrData,
                              &g_dastrDomJoinRevisionTag,
                              NULL,
                              NULL,
                              0,
                              NULL,
                              &dsstrRev,
                              1 );

    if ( dr != DRM_E_XMLNOTFOUND && dsstrRev.m_cch != 0)
    {    
        ChkDR(dr);

        ChkDR( DRMCRT_AtoDWORD(
            f_pchQueryData + dsstrRev.m_ich,
            dsstrRev.m_cch,
            10,
            &f_poDomainID->m_dwRevision ) );
    }

    /*Get the <FriendlyName> node from the <Data> node if available since it is optional */
    dr = DRM_XML_GetSubNodeA( f_pchQueryData,
                              &dsstrData,
                              &g_dastrDomJoinFriendlyNameTag,
                              NULL,
                              NULL,
                              0,
                              NULL,
                              &dsstrFname,
                              1 );

    if ( dr != DRM_E_XMLNOTFOUND && dsstrFname.m_cch != 0)
    {
        ChkDR(dr);

        *f_ppchFriendlyName = f_pchQueryData + __CB_DECL( dsstrFname.m_ich );
        *f_pcchFriendlyName = dsstrFname.m_cch;                    
    }              
    else
    {
        *f_ppchFriendlyName = NULL;
        *f_pcchFriendlyName = 0;
    }

    /*Get the <CustomData> node from the <Data> node if available since it is optional */
    dr = DRM_XML_GetSubNodeA( f_pchQueryData,
                              &dsstrData,
                              &g_dastrDomJoinCustomDataTag,
                              NULL,
                              NULL,
                              0,
                              NULL,
                              &dsstrCdata,
                              1 );
    
    if ( dr != DRM_E_XMLNOTFOUND && dsstrCdata.m_cch != 0)
    {
        ChkDR(dr);

        *f_ppchCustomData = f_pchQueryData + __CB_DECL( dsstrCdata.m_ich );
        *f_pcchCustomData = dsstrCdata.m_cch;        
    }              
    else
    {
        dr = DRM_SUCCESS;

        *f_ppchCustomData = NULL;
        *f_pcchCustomData = 0;
    }

    if ( f_pbChallenge != NULL )
    {
        /*
          Since the Challenge Buffer has been allocated, we can reuse the
          Query data memory as free buffer to ensure WORD alignment. 
          Copy the friendly name and customdata to start at a WORD boundary.
          by overwriting into the buffer we got for the Query data. The Query
          data buffer always starts at the WORD boundary.
        */
        
        if ( *f_ppchFriendlyName != NULL )
        {
            DRM_BYT_CopyBytes( pbFreeBuffer, 
                               0, 
                               *f_ppchFriendlyName,
                               0,
                               *f_pcchFriendlyName );

            *f_ppchFriendlyName = ( DRM_CHAR * )pbFreeBuffer;

            pbFreeBuffer = pbFreeBuffer + __CB_DECL( *f_pcchFriendlyName );
            cbFreeBuffer = cbFreeBuffer - *f_pcchFriendlyName;
            
            ChkDR( DRM_UTL_EnsureDataAlignment( pbFreeBuffer, 
                                                cbFreeBuffer, 
                                                &pbFreeBuffer, 
                                                &cbFreeBuffer, 
                                                SIZEOF( DRM_WORD ),
                                                NULL ) );
        }
        
        if ( *f_ppchCustomData != NULL )
        {
            DRM_BYT_CopyBytes( pbFreeBuffer, 
                               0, 
                               *f_ppchCustomData,
                               0,
                               *f_pcchCustomData );
            
            *f_ppchCustomData = ( DRM_CHAR * )pbFreeBuffer;
        }
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    if ( DRM_FAILED( dr ) && dr == DRM_E_XMLNOTFOUND )
    {
        dr = DRM_E_DOMAIN_INVALID_CUSTOM_DATA;
    }

    return dr;
}

/*********************************************************************
**
** Function: _ParseLeaveDomainChallengeQueryData
**
** Synopsis: This function Parses the Leave Domain Challenge Query Data and populates the
**           the Domain Account ID and Custom data.
**
** Arguments:
** [f_pchQueryData]     -- The XML Join domain Query data in ANSI of the form:
**                         <LeaveDomain type = \"challenge\">
**                           <Data>
**                             <ServiceID>Optional Base 64 encoded Service Account ID string in ANSI</ServiceID>
**                             <AccountID>Mandatory Base 64 encoded Domain Account ID string in ANSI</AccountID>
**                             <Revision>Optional Domain Revision</Revision>
**                             <CustomData>Optional Custom Data in ANSI</CustomData>
**                           </Data>
**                         </LeaveDomain>
**
** [f_cchQueryData]      -- Size (in characters) of the Query Data Buffer.
**
** [f_poDomainID]        -- Domain ID in the sent in the challenge.
**
** [f_ppchCustomData]    -- Pointer pointer which will point to the Custom data in the XML.
**
** [f_pcchCustomData]    -- Size (in characters) of the custom data buffer.
**
** Returns:              DRM_SUCCESS on success.
**                       DRM_E_INVALIDARG if the arguments are invalid.
**                       DRM_E_DOMAIN_INVALID_CUSTOM_DATA if the custom data cannot be parsed.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL _ParseLeaveDomainChallengeQueryData( 
    IN     const DRM_CHAR *f_pchQueryData,
    IN     DRM_DWORD       f_cchQueryData,
    IN OUT DRM_DOMAIN_ID  *f_poDomainID,
    IN OUT DRM_CHAR const**f_ppchCustomData,
    IN OUT DRM_DWORD      *f_pcchCustomData,
    IN     DRM_BYTE       *f_pbChallenge )
{

    DRM_RESULT       dr            = DRM_SUCCESS;
    DRM_DWORD        cbServiceId   = DRM_ID_SIZE;
    DRM_DWORD        cbAccountId   = DRM_ID_SIZE;
    DRM_SUBSTRING    dsstrData     = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING    dsstrSid      = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING    dsstrAid      = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING    dsstrRev      = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING    dsstrCdata    = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING    dsstrLdomain  = EMPTY_DRM_SUBSTRING;
    DRM_BYTE        *pbFreeBuffer  = (DRM_BYTE*) f_pchQueryData;
    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DOMAINAPI, PERF_FUNC__ParseLeaveDomainChallengeQueryData );
    
    ChkArg( f_poDomainID       != NULL );
    ChkArg( f_ppchCustomData   != NULL );
    ChkArg( f_pcchCustomData   != NULL );
    ChkArg( f_pchQueryData     != NULL
         && f_cchQueryData     >  0 );            

    dsstrLdomain.m_ich = 0;
    dsstrLdomain.m_cch = f_cchQueryData;
    
    /* Look for <LeaveDomain> tag */      
    ChkDR( DRM_XML_GetNodeA( f_pchQueryData,
                            &dsstrLdomain,
                            &g_dastrDomLeaveRootTag,
                             NULL,
                             NULL,
                             0,
                            &dsstrLdomain,
                             NULL ) );
    
    /* Get the <Data> node */
    ChkDR( DRM_XML_GetSubNodeA( f_pchQueryData,
                               &dsstrLdomain,
                               &g_dastrDomJoinDataTag,
                                NULL,
                                NULL,
                                0,
                               &dsstrData,
                                NULL,
                                1 ) );

    /*Get the <ServiceID> node from the <Data> node which is a mandatory tag.*/
    dr = DRM_XML_GetSubNodeA( f_pchQueryData,
                             &dsstrData,
                             &g_dastrDomJoinServiceIDTag,
                              NULL,
                              NULL,
                              0,
                              NULL,
                             &dsstrSid,
                              1 );
    
    if ( dr != DRM_E_XMLNOTFOUND && dsstrSid.m_cch != 0)
    {
        ChkDR(dr);

        /*Base 64 decode the Service ID and set it in the Domain ID struct */
        ChkDR( DRM_B64_DecodeA( f_pchQueryData,
                               &dsstrSid,
                               &cbServiceId,
                                (DRM_BYTE*)&(f_poDomainID->m_oServiceID),
                                0 ) );
    }   

    /*Get the <AccountID> node from the <Data> node which is a mandatory tag.*/
    ChkDR( DRM_XML_GetSubNodeA( f_pchQueryData,
                             &dsstrData,
                             &g_dastrDomJoinAccountIDTag,
                              NULL,
                              NULL,
                              0,
                              NULL,
                             &dsstrAid,
                              1 ) );
    
    if( dsstrAid.m_cch == 0)
    {
        ChkDR( DRM_E_DOMAIN_INVALID_GUID );                    
    }
    else
    {
        /*Base 64 decode the Account ID and set it in the Domain ID struct */
        ChkDR( DRM_B64_DecodeA( f_pchQueryData,
                               &dsstrAid,
                               &cbAccountId,
                                (DRM_BYTE*)&(f_poDomainID->m_oAccountID),
                                0 ) );
    }   

    /*Get the <Revision> node from the <Data> node if available since it is optional */
    dr = DRM_XML_GetSubNodeA( f_pchQueryData,
                              &dsstrData,
                              &g_dastrDomJoinRevisionTag,
                              NULL,
                              NULL,
                              0,
                              NULL,
                              &dsstrRev,
                              1 );

    if ( dr != DRM_E_XMLNOTFOUND && dsstrRev.m_cch != 0)
    {    
        ChkDR(dr);

        ChkDR( DRMCRT_AtoDWORD(
            f_pchQueryData + dsstrRev.m_ich,
            dsstrRev.m_cch,
            10,
            &f_poDomainID->m_dwRevision ) );
    }

    /*Get the <CustomData> node from the <Data> node if available since it is optional */
    dr = DRM_XML_GetSubNodeA( f_pchQueryData,
                             &dsstrData,
                             &g_dastrDomJoinCustomDataTag,
                              NULL,
                              NULL,
                              0,
                              NULL,
                             &dsstrCdata,
                              1 );
    
    if( dr != DRM_E_XMLNOTFOUND && dsstrCdata.m_cch != 0)
    {

        ChkDR(dr);
        *f_ppchCustomData = f_pchQueryData + __CB_DECL( dsstrCdata.m_ich );
        *f_pcchCustomData = dsstrCdata.m_cch;        
    }              
    else
    {
        dr = DRM_SUCCESS;
        *f_ppchCustomData = NULL;
        *f_pcchCustomData = 0;
    }
    
    if( f_pbChallenge != NULL )
    {
        /*
          Since the Challenge Buffer has been allocated, we can reuse the
          Query data memory as free buffer to ensure WORD alignment. 
          Copy the customdata to start at a WORD boundary by overwriting
          into the buffer we got for the Query data. The QueryData buffer
          always starts at the WORD boundary.
        */
                
        if( *f_ppchCustomData != NULL )
        {
            DRM_BYT_CopyBytes( pbFreeBuffer, 
                               0, 
                               *f_ppchCustomData,
                               0,
                               *f_pcchCustomData );
            
            *f_ppchCustomData = (DRM_CHAR*)pbFreeBuffer;
        }
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    if ( DRM_FAILED( dr ) && dr == DRM_E_XMLNOTFOUND )
    {
        dr = DRM_E_DOMAIN_INVALID_CUSTOM_DATA;
    }

    return dr;
}

/*********************************************************************
**
** Function: DRM_DOM_GenerateJoinChallenge
**
** Synopsis: API that generates a domain join challenge to be sent to the
**           domain server to register a device to a domain. The challenge
**           includes the  identity of the device to be registered and
**           optionally the domain ID to which the device wants to be
**           registered.
**
** Arguments:
**
** [f_poOEMContext]         -- Pointer to an optional OEM context structure.
** [f_poBBXContext]         -- Pointer to a black box context.
** [f_poDomainStoreContext] -- Pointer to a domain store context that has already
**                             been opened.
** [f_dwFlags]              -- Flag that indicates the type of custom data.
** [f_poDomainID]           -- Domain ID to be registered with the server. Some of
**                             its fields (service ID, account ID or revision)
**                             may be blank.
** [f_pchFriendlyName]      -- Pointer to a character buffer that contains
**                             the friendly name. It can be NULL.
** [f_cchFriendlyName]      -- Size (number of characters) of the friendly
**                             name string.
** [f_pbDeviceCert]         -- Pointer to a buffer that contains the passed in device
**                             certificate.
** [f_cbDeviceCert]         -- Size (number of bytes) of the passed in device certificate.
** [f_pchData]              -- Pointer to a buffer that contains the custom data
**                             sent to the server. The format of the custom data
**                             is based on the value of f_dwFlags. It may be NULL.
**                             If the Query data is passed in with f_dwFlags == DRM_REGISTER_INDIRECT_QUERY_DATA
**                             then it should have the following XML Format:
**                             <JoinDomain type = \"challenge\">
**                              <Data>
**                               <ServiceID>Optional Base 64 encoded Service Account ID string in ANSI</ServiceID>
**                               <AccountID>Optional Base 64 encoded Domain Account ID string in ANSI</AccountID>
**                               <Revision>Optional Domain Revision</Revision>
**                               <FriendlyName>Optional Friendly Name in ANSI </FriendlyName>
**                               <CustomData>Optional Custom Data in ANSI</CustomData>
**                              </Data>
**                             </JoinDomain>
** [f_cchData]              -- Size (in characters) of the custom/query data buffer.
**                             It must be 0 if f_pchCustomData is NULL.
** [f_pbChallenge]          -- Pointer to a buffer to receive a generated challenge
**                             byte stream. If it is NULL, the function returns
**                             an error and the size of the required buffer is
**                             stored in *f_pcbChallenge.
** [f_pcbChallenge]         -- Pointer to a variable that contains the size (in bytes
**                             of the challenge buffer during input and receives the
**                             size (in bytes) of the challenge buffer during output.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_BUFFERTOOSMALL if the buffer to retrieve
**                          the data is not big enough.
**                          DRM_E_DOMAIN_INVALID_CUSTOM_DATA_TYPE if the custom data
**                          type is incorrect.
**                          DRM_E_DOMAIN_INVALID_CUSTOM_DATA if the custom data cannot
**                          be parsed.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DOM_GenerateJoinChallenge(
    IN DRM_VOID *f_poOEMContext,
    IN DRM_BB_CONTEXT *f_poBBXContext,
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    IN DRM_DWORD f_dwFlags,
    IN DRM_DOMAIN_ID *f_poDomainID,
    __in_ecount_opt( f_cchFriendlyName ) const DRM_CHAR *f_pchFriendlyName,
    IN DRM_DWORD f_cchFriendlyName,
    __in_bcount_opt( f_cbDeviceCert ) const DRM_BYTE *f_pbDeviceCert,
    IN DRM_DWORD f_cbDeviceCert,
    __in_ecount_opt( f_cchData) const DRM_CHAR *f_pchData,
    IN DRM_DWORD f_cchData,
    __out_bcount_opt( *f_pcbChallenge ) DRM_BYTE *f_pbChallenge,
    IN OUT DRM_DWORD *f_pcbChallenge )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cchXMLContext = 0;
    _XMBContextA *poXMLContext = NULL;
    DRM_DWORD cbXMLContext = 0;
    DRM_ANSI_STRING dastrXML = EMPTY_DRM_STRING;
    DRM_XML_KEY oXMLKey = EMPTY_XML_KEY;
    DRM_DWORD cchEncodedCustomData = 0;
    DRM_DWORD cchEncodedFriendlyName = 0;
    DRM_DOMAIN_ID oDomainID = EMPTY_DRM_GUID;
    const DRM_CHAR *pchCustomData = NULL;
    DRM_DWORD cchCustomData = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DOMAINAPI, PERF_FUNC_DRM_DOM_GenerateJoinChallenge );

    ChkArg( f_poBBXContext != NULL );
    
    ChkArg( f_poDomainStoreContext != NULL );
    ChkBOOL( f_dwFlags == DRM_REGISTER_NULL_DATA ||
             f_dwFlags == DRM_REGISTER_CUSTOM_DATA ||
             f_dwFlags == DRM_REGISTER_INDIRECT_QUERY_DATA,
             DRM_E_DOMAIN_INVALID_CUSTOM_DATA_TYPE );

    ChkArg( f_cbDeviceCert > 0 );

    ChkArg( f_pcbChallenge != NULL );
    ChkArg( f_pbChallenge == NULL ||
            *f_pcbChallenge > 0 );

    if( f_dwFlags == DRM_REGISTER_INDIRECT_QUERY_DATA )
    {
        f_poDomainID  = &oDomainID;
        ChkDR( _ParseJoinDomainChallengeQueryData( f_pchData,
                                                   f_cchData,
                                                   f_poDomainID,
                                                   &f_pchFriendlyName,
                                                   &f_cchFriendlyName,
                                                   &pchCustomData,
                                                   &cchCustomData,
                                                   f_pbChallenge ) );
                                                                                
    }
    else
    {
        ChkArg( f_poDomainID != NULL );

        ChkArg( ( f_pchFriendlyName == NULL && f_cchFriendlyName == 0 ) 
              ||( f_pchFriendlyName != NULL && f_cchFriendlyName > 0 ) );
        
        ChkArg( ( f_pchData == NULL && f_cchData == 0 ) 
              ||( f_pchData != NULL && f_cchData > 0 ) );

        /* The data f_pchData carries custom data */
        pchCustomData = f_pchData;
        cchCustomData = f_cchData;
     }    
    
    ChkDR( DRM_SOAPXML_InitXMLKey( f_poOEMContext, &oXMLKey, &f_poBBXContext->CryptoContext ) );

    /* Get the size (number of characters) of the XML encoded friendly name. */
    ChkDR( DRM_SOAPXML_EncodeData( f_pchFriendlyName,
                                   f_cchFriendlyName,
                                   NULL,
                                   &cchEncodedFriendlyName ) );

    /* Get the size (number of characters) of the XML encoded friendly name. */
    ChkDR( DRM_SOAPXML_EncodeData( f_pchFriendlyName,
                                   f_cchFriendlyName,
                                   NULL,
                                   &cchEncodedFriendlyName ) );

    /* Get the size (number of characters) of the XML encoded custom data. */
    ChkDR( DRM_SOAPXML_EncodeData( pchCustomData,
                                   cchCustomData,
                                   NULL,
                                   &cchEncodedCustomData ) );

    cchXMLContext = _CalcJoinChallengeCharCount( f_poDomainID,
                                                 CCH_BASE64_EQUIV( f_cbDeviceCert ),
                                                 &oXMLKey,
                                                 cchEncodedFriendlyName,
                                                 cchEncodedCustomData );

    /* Add space used by XML builder context. */
    cchXMLContext += g_cbXMLBuilderMinimumA;

    /*
    ** Add one more DRM_DWORD to ensure the size of buffer is
    ** big enough even after realighnment.
    */
    cchXMLContext += SIZEOF( DRM_DWORD );

    if ( f_pbChallenge == NULL || *f_pcbChallenge < cchXMLContext )
    {
        *f_pcbChallenge = cchXMLContext;

        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

    if ( f_poDomainID->m_dwRevision == 0 )
    {
        ChkDR( _GetLatestRevision( f_poDomainStoreContext, f_poDomainID ) );
    }

    ChkDR( DRM_SOAPXML_PrepareXMLContext( f_pbChallenge,
                                          cchXMLContext,
                                          &poXMLContext,
                                          &cbXMLContext ) );

    ChkDR( _BuildJoinChallengeXML( poXMLContext,
                                   cbXMLContext,
                                   f_poBBXContext,
                                   f_poDomainID,
                                   &oXMLKey,
                                   f_pchFriendlyName,
                                   f_cchFriendlyName,
                                   f_pbDeviceCert,
                                   f_cbDeviceCert,
                                   pchCustomData,
                                   cchCustomData,
                                   &dastrXML ) );

#if DRM_USE_SOAP

    ChkDR( DRM_SOAPXML_PrependXMLRoot( &dastrXML ) );

#endif

    ChkBOOL( dastrXML.cchString <= *f_pcbChallenge,
             DRM_E_BUFFERTOOSMALL );

    MEMCPY( f_pbChallenge, dastrXML.pszString, dastrXML.cchString );

    /* Return the actual size (number of bytes) of the generated challenge. */
    *f_pcbChallenge = dastrXML.cchString;

ErrorExit:

    OEM_SECURE_ZERO_MEMORY( &oXMLKey, SIZEOF( DRM_XML_KEY ) );
 
    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: DRM_DOM_ProcessJoinResponse
**
** Synopsis: API that processes a domain join response sent by the domain
**           registration server. The domain response contains a domain
**           certificate and one or more domain private key that will be
**           added to the domain store by the device that calls the API.
**
** Arguments:
**
** [f_poBBXContext]         -- Pointer to a black box context.
** [f_poDomainStoreContext] -- Pointer to a domain store context that has already
**                             been opened.
** [f_pbResponse]           -- Pointer to a buffer that contains the domain
**                             join response from the domain registration
**                             server.
** [f_cbResponse]           -- Size of the domain join response from the domain
**                             registration server. It must be bigger than 0.
** [f_pResult]              -- Optional pointer to a variable that receives the
**                             status code.
** [f_poDomainID]           -- Optional pointer to a variable that is used to
**                             receive the domain id parsed out from the domain
**                             join response.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_S_MORE_DATA if custom data is available from
**                          the server.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_SOAPXML_XML_FORMAT if SOAP format error happens.
**                          DRM_E_XMLNOTFOUND if expected XML node is not found.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DOM_ProcessJoinResponse(
    IN DRM_BB_CONTEXT *f_poBBXContext,
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    __inout_bcount( f_cbResponse ) DRM_BYTE *f_pbResponse,
    IN DRM_DWORD f_cbResponse,
    OUT DRM_RESULT *f_pResult,
    OUT DRM_DOMAIN_ID *f_poDomainID )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_ANSI_STRING dastrResponse = EMPTY_DRM_STRING;
    DRM_BOOL fOverwriteResult = FALSE;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DOMAINAPI, PERF_FUNC_DRM_DOM_ProcessJoinResponse );

    ChkArg( f_poBBXContext != NULL );
    ChkArg( f_poDomainStoreContext != NULL );
    ChkArg( f_pbResponse != NULL );
    ChkArg( f_cbResponse > 0 );

    fOverwriteResult = TRUE;
    
    DASTR_FROM_PB( &dastrResponse, f_pbResponse, f_cbResponse );

    /*
    ** Process the domain join response and extract the domain ID if
    ** the caller provides a non NULL pointer of a domain ID variable.
    */
    ChkDR( _ProcessJoinDataFromResponse( f_poDomainStoreContext,
                                         f_poBBXContext,
                                         &dastrResponse,
                                         f_poDomainID ) );

    /* Try to detect whether there is custom data from the server. */
    dr = DRM_SOAPXML_ParseCustomDataForProtocol( f_pbResponse,
                                                 f_cbResponse,
                                                 DRM_SOAPXML_PROTOCOL_DOMAIN_JOIN_RESPONSE,
                                                 NULL,
                                                 NULL );


    if ( dr == DRM_E_BUFFERTOOSMALL )
    {
        /* Yes there is a custom data string from the server. */
        dr = DRM_S_MORE_DATA;
    }
    else
    {
        dr = DRM_SUCCESS;
    }

ErrorExit:

    dr = DRM_SOAPXML_ParseStatusCodeAndChooseBest(f_pbResponse,
                                                  f_cbResponse,
                                                  dr,
                                                  fOverwriteResult ? f_pResult : NULL );

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


/*********************************************************************
**
** Function: DRM_DOM_GenerateLeaveChallenge
**
** Synopsis: API that generates a domain leave challenge to be sent to the
**           domain server to unregister a device from a domain. The challenge
**           includes the identity of the device to be unregistered and
**           the domain ID to which the device wants to be unregistered.
**           The device will remove the domain certificate and the domain
**           private keys from its domain store.
**
** Arguments:
**
** [f_poOEMContext]         -- Pointer to an optional OEM context structure.
** [f_poBBXContext]         -- Pointer to a black box context.
** [f_poDomainStoreContext] -- Pointer to a domain store context that has
**                             already been opened.
** [f_dwFlags]              -- Flag that indicates the type of custom data.
** [f_poDomainID]           -- Domain ID to be unregistered with the server. Some of
**                             its fields (service ID, account ID or revision)
**                             may be blank.
** [f_pbDeviceCert]         -- Pointer to a buffer that contains the passed in device
**                             certificate.
** [f_cbDeviceCert]         -- Size (number of bytes) of the passed in device certificate.
** [f_pchData]              -- Pointer to a buffer that contains the custom data
**                             sent to the server. The format of the custom data
**                             is based on the value of f_dwFlags. It may be NULL.
**                             If the Query data is passed in with f_dwFlags == DRM_REGISTER_INDIRECT_QUERY_DATA
**                             then it should have the following XML Format:
**                             <LeaveDomain type = \"challenge\">
**                              <Data>
**                               <ServiceID>Optional Base 64 encoded Service Account ID string in ANSI</ServiceID>
**                               <AccountID>Mandatory Base 64 encoded Domain Account ID string in ANSI</AccountID>
**                               <Revision>Optional Domain Revision</Revision>
**                               <CustomData>Optional Custom Data in ANSI</CustomData>
**                              </Data>
**                             </LeaveDomain>                             
** [f_cchData]              -- Size (in characters) of the custom data buffer.
**                             It must be 0 if f_pchCustomData is NULL.
** [f_pbChallenge]          -- Pointer to a buffer to receive a generated challenge
**                             byte stream. If it is NULL, the function returns an
**                             error and the size of the required buffer is stored
**                             in *f_pcbChallenge.
** [f_pcbChallenge]         -- Pointer to a variable that contains the size (in bytes
**                             of the challenge buffer during input and receives the
**                             size (in bytes) of the challenge buffer during output.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_BUFFERTOOSMALL if the buffer to retrieve
**                          the data is not big enough.
**                          DRM_E_DOMAIN_INVALID_CUSTOM_DATA_TYPE if the custom data
**                          type is incorrect.
**                          DRM_E_DOMAIN_INVALID_CUSTOM_DATA if the custom data cannot
**                          be parsed.
**                          DRM_E_DOMAIN_NOT_FOUND if domain to be left is not in the 
**                          current domain store.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DOM_GenerateLeaveChallenge(
    IN DRM_VOID *f_poOEMContext,
    IN DRM_BB_CONTEXT *f_poBBXContext,
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    IN DRM_DWORD f_dwFlags,
    IN DRM_DOMAIN_ID *f_poDomainID,
    __in_bcount_opt( f_cbDeviceCert ) const DRM_BYTE *f_pbDeviceCert,
    IN DRM_DWORD f_cbDeviceCert,
    __in_ecount_opt( f_cchData) const DRM_CHAR *f_pchData,
    IN DRM_DWORD f_cchData,
    __out_bcount_opt( *f_pcbChallenge ) DRM_BYTE *f_pbChallenge,
    IN OUT DRM_DWORD *f_pcbChallenge )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cchXMLContext = 0;
    _XMBContextA *poXMLContext = NULL;
    DRM_DWORD cbXMLContext = 0;
    DRM_ANSI_STRING dastrXML = EMPTY_DRM_STRING;
    DRM_XML_KEY oXMLKey = EMPTY_XML_KEY;
    DRM_DWORD cchEncodedCustomData = 0;
    DRM_DOMAIN_ID oDomainID = EMPTY_DRM_GUID;
    const DRM_CHAR *pchCustomData = NULL;
    DRM_DWORD cchCustomData = 0; 

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DOMAINAPI, PERF_FUNC_DRM_DOM_GenerateLeaveChallenge );

    ChkArg( f_poBBXContext != NULL );
    ChkArg( f_poBBXContext->fInited );
    ChkArg( f_poDomainStoreContext != NULL ); 
    ChkBOOL( f_dwFlags == DRM_REGISTER_NULL_DATA ||
             f_dwFlags == DRM_REGISTER_CUSTOM_DATA ||
             f_dwFlags == DRM_REGISTER_INDIRECT_QUERY_DATA,
             DRM_E_DOMAIN_INVALID_CUSTOM_DATA_TYPE );
    
    ChkArg( f_pcbChallenge != NULL );
    ChkArg( f_pbChallenge == NULL ||
            *f_pcbChallenge > 0 );

    if( f_dwFlags == DRM_REGISTER_INDIRECT_QUERY_DATA )
    {
        f_poDomainID = &oDomainID;

        ChkDR( _ParseLeaveDomainChallengeQueryData( f_pchData,
                                                    f_cchData,
                                                    f_poDomainID,                                                  
                                                    &pchCustomData,
                                                    &cchCustomData,
                                                    f_pbChallenge ) );
                                                                                
    }
    else
    {
        ChkArg( f_poDomainID != NULL );
        ChkArg( !DRM_SOAPXML_IsBlankGUID( &f_poDomainID->m_oAccountID ) );
        ChkArg( ( f_pchData == NULL && f_cchData == 0 ) ||
                ( f_pchData != NULL && f_cchData > 0 ) );

        /* The data f_pchData carries custom data */
        pchCustomData = f_pchData;
        cchCustomData = f_cchData;
    }

    ChkDR( DRM_SOAPXML_InitXMLKey( f_poOEMContext, &oXMLKey, &f_poBBXContext->CryptoContext ) );

    /* Get the size (number of characters) of the XML encoded custom data. */
    ChkDR( DRM_SOAPXML_EncodeData( pchCustomData,
                                   cchCustomData,
                                   NULL,
                                   &cchEncodedCustomData ) );

    cchXMLContext = _CalcLeaveChallengeCharCount( f_poDomainID,
                                                  CCH_BASE64_EQUIV( f_cbDeviceCert ),
                                                  &oXMLKey,
                                                  cchEncodedCustomData );

    /* Add space used by XML builder context. */
    cchXMLContext += g_cbXMLBuilderMinimumA;

    /*
    ** Add one more DRM_DWORD to ensure the size of buffer is
    ** big enough even after realighnment.
    */
    cchXMLContext += SIZEOF( DRM_DWORD );

    if ( f_pbChallenge == NULL || *f_pcbChallenge < cchXMLContext )
    {
        *f_pcbChallenge = cchXMLContext;

        ChkDR( DRM_E_BUFFERTOOSMALL );
    }
    
    ChkDR( DRM_SOAPXML_PrepareXMLContext( f_pbChallenge,
                                          cchXMLContext,
                                          &poXMLContext,
                                          &cbXMLContext ) );

    ChkDR( _BuildLeaveChallengeXML( poXMLContext,
                                    cbXMLContext,
                                    f_poBBXContext,
                                    f_poDomainID,
                                    &oXMLKey,
                                    f_pbDeviceCert,
                                    f_cbDeviceCert,
                                    pchCustomData,
                                    cchCustomData,
                                    &dastrXML ) );

#if DRM_USE_SOAP

    ChkDR( DRM_SOAPXML_PrependXMLRoot( &dastrXML ) );

#endif

    ChkBOOL( dastrXML.cchString <= *f_pcbChallenge,
             DRM_E_BUFFERTOOSMALL );

    MEMCPY( f_pbChallenge, dastrXML.pszString, dastrXML.cchString );

    /* Return the actual size (number of bytes) of the generated challenge. */
    *f_pcbChallenge = dastrXML.cchString;

    /*
    ** DRM App context should have an already opened domain store during
    ** its initialization.
    */
    
    dr = DRM_DOMST_DeleteCert( f_poDomainStoreContext, &f_poDomainID->m_oAccountID );
    
    if ( dr == DRM_E_DOMAIN_STORE_DELETE_DATA )
    {
        /*
        ** If DRM_E_DOMAIN_STORE_DELETE_DATA is returned, it is possible that the device
        ** has not yet joined the domain. In this case, try to delete the keys anyway.
        ** and return a more user friendly error code to the caller.
        */
        DRM_DOMST_DeleteKeys( f_poDomainStoreContext, &f_poDomainID->m_oAccountID );
        
        dr = DRM_E_DOMAIN_NOT_FOUND;
    }
    else
    {
        ChkDR( dr );
        
        ChkDR( DRM_DOMST_DeleteKeys( f_poDomainStoreContext, &f_poDomainID->m_oAccountID ) );
    }

    /*
    ** If there is a failure between the deletion of domain certificate and key(s), it is
    ** possible to have a DID that has a domain private key(s) in the domain store
    ** but its matching domain certificate has already been deleted.
    */

ErrorExit:

    OEM_SECURE_ZERO_MEMORY( &oXMLKey, SIZEOF( DRM_XML_KEY ) );
 
    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: DRM_DOM_ProcessLeaveResponse
**
** Synopsis: API that processes a domain leave response received from
**           the domain server.
**
** Arguments:
**
** [f_pbResponse]           -- Pointer to a buffer that contains the domain
**                             leave response from the domain registration
**                             server.
** [f_cbResponse]           -- Size of the domain leave response from the domain
**                             registration server. It must be bigger than 0.
** [f_pResult]              -- Optional pointer to a variable that receives the
**                             status code.
** [f_pBBXCtx]              -- Pointer to a black box context.
**
** Returns:                 DRM_SUCCESS on success.
                            DRM_S_MORE_DATA if custom data is available from
**                          the server.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_SOAPXML_XML_FORMAT if SOAP format error happens.
**                          DRM_E_XMLNOTFOUND if expected XML node is not found.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DOM_ProcessLeaveResponse(
    __in_bcount( f_cbResponse ) DRM_BYTE *f_pbResponse,
    IN DRM_DWORD f_cbResponse,
    OUT DRM_RESULT *f_pResult,
    IN DRM_BB_CONTEXT *f_pBBXCtx )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_ANSI_CONST_STRING dastrResponse = EMPTY_DRM_STRING;
    DRM_SUBSTRING dasstrResponse = EMPTY_DRM_SUBSTRING;
    DRM_BOOL fOverwriteResult = FALSE;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DOMAINAPI, PERF_FUNC_DRM_DOM_ProcessLeaveResponse );

    ChkArg( f_pbResponse != NULL );
    ChkArg( f_cbResponse > 0 );
    ChkArg( f_pBBXCtx != NULL );

    fOverwriteResult = TRUE;

    DASTR_FROM_PB( &dastrResponse, f_pbResponse, f_cbResponse );

    dasstrResponse.m_ich = 0;
    dasstrResponse.m_cch = dastrResponse.cchString;

#if DRM_USE_SOAP

    // The following line of code does the basic validation of message format.
    ChkDR( DRM_SOAPXML_SkipSOAPHeaders( ( DRM_CHAR * )dastrResponse.pszString,
                                         &dasstrResponse ) );

#endif

    /* Try to detect whether there is custom data from the server. */
    dr = DRM_SOAPXML_ParseCustomDataForProtocol( f_pbResponse,
                                                 f_cbResponse,
                                                 DRM_SOAPXML_PROTOCOL_DOMAIN_LEAVE_RESPONSE,
                                                 NULL,
                                                 NULL );
    if ( dr == DRM_E_BUFFERTOOSMALL )
    {
        /* Yes there is a custom data string from the server. */
        dr = DRM_S_MORE_DATA;
    }
    else
    {
        dr = DRM_SUCCESS;
    }

ErrorExit:

    dr = DRM_SOAPXML_ParseStatusCodeAndChooseBest(f_pbResponse,
                                                  f_cbResponse,
                                                  dr,
                                                  fOverwriteResult ? f_pResult : NULL );

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: DRM_DOM_FindCert
**
** Synopsis: API that retrieves a domain certificate from the domain
**           store for a specific domain.
**
** Arguments:
**
** [f_poDomainStoreContext] -- Pointer to a domain store context that has
**                             already been opened.
** [f_pDomainID]            -- Domain ID of the domain whose domain certificate will
**                             be retrieved. Only the account ID field is used.
** [f_pbDomainCert]         -- Pointer to a buffer to receive a domain certificate
**                             byte stream. If it is NULL, the function returns an
**                             error and the size of the required buffer is stored
**                             in *f_pcbDomainCert.
** [f_pcbDomainCert]        -- Pointer to a variable that contains the size (in bytes)
**                             of the domain certificate buffer during input and
**                             receives the size (in bytes) of the domain certificate
**                             buffer during output.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_BUFFERTOOSMALL if the buffer to retrieve
**                          the data is not big enough.
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_DOM_FindCert(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    IN DRM_DOMAIN_ID *f_poDomainID,
    __out_bcount_opt( *f_pcbDomainCert ) DRM_BYTE *f_pbDomainCert,
    IN OUT DRM_DWORD *f_pcbDomainCert )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_GUID oServiceID = EMPTY_DRM_GUID;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DOMAINAPI, PERF_FUNC_DRM_DOM_FindCert );

    ChkArg( f_poDomainStoreContext != NULL );
    ChkArg( f_poDomainID != NULL );
    ChkArg( f_pcbDomainCert != NULL )
    ChkArg( f_pbDomainCert == NULL ||
            *f_pcbDomainCert > 0 );

    ChkDR( DRM_DOMST_GetCert( f_poDomainStoreContext,
                              &f_poDomainID->m_oAccountID,
                              &oServiceID,
                              f_pbDomainCert,
                              f_pcbDomainCert ) );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: DRM_DOM_InitCertEnum
**
** Synopsis: API that initializes an domain store enumerator context
**           for all the domain certificates.
**
** Arguments:
**
** [f_poDomainStoreContext] -- Pointer to a domain store context that has
**                             already been opened.
** [f_poDomainCertEnumContext]           
**                          -- Pointer to a domain cert enumerator context
**                             for all the domain certificates. This API
**                             initialized the domain cert context.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_DOM_InitCertEnum(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    OUT DRM_DOMAIN_CERT_ENUM_CONTEXT *f_poDomainCertEnumContext )
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DOMAINAPI, PERF_FUNC_DRM_DOM_InitCertEnum );

    ChkArg( f_poDomainStoreContext != NULL );
    ChkArg( f_poDomainCertEnumContext != NULL );

    ChkDR( DRM_DOMST_InitEnumCert( f_poDomainStoreContext,
                                   f_poDomainCertEnumContext ) );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: DRM_DOM_EnumNextCert
**
** Synopsis: API that enumerates the next domain certificate using an
**           initialized domain cert enumerator context.
**
** Arguments:
**
** [f_poDomainCertEnumContext]           
**                          -- Pointer to an initialized domain cert 
**                             enumerator context.
** [f_pcchDomainCert]       -- Pointer to a variable that receives the size
**                             (in characters) of the domain cert being
**                             enumerated. Caller should allocate buffer using
**                             the returned size and then call Drm_DomainCert_Find()
**                             to actually read the domain certificate.
** [f_poDomainCertInfo]     -- Pointer to a structure that receives additional
**                             information of the domain certificates retrieved.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_NOMORE when there is no more element to be
**                          enumerated next.
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_DOM_EnumNextCert(
    IN DRM_DOMAIN_CERT_ENUM_CONTEXT *f_poDomainCertEnumContext,
    OUT DRM_DWORD *f_pcchDomainCert,
    OUT DRM_DOMAINCERT_INFO *f_poDomainCertInfo )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DOMAIN_ID oDomainID = EMPTY_DRM_DOMAIN_ID;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DOMAINAPI, PERF_FUNC_DRM_DOM_EnumNextCert );

    ChkArg( f_poDomainCertEnumContext != NULL );
    ChkArg( f_poDomainCertEnumContext->m_fInited );
    ChkArg( f_pcchDomainCert != NULL );
    ChkArg( f_poDomainCertInfo != NULL );

    ChkDR( DRM_DOMST_EnumNextCert( f_poDomainCertEnumContext,
                                  &oDomainID.m_oAccountID,
                                  &oDomainID.m_oServiceID,
                                   NULL,
                                   f_pcchDomainCert ) );

    MEMCPY( &f_poDomainCertInfo->m_oDomainID, &oDomainID, SIZEOF( DRM_DOMAIN_ID ) );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

#endif /* DRM_SUPPORT_DOMAINS */

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmdomainkeyxmrparser.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include <drmcommon.h>
#include <drmtypes.h>
#include <drmdomainkeyxmrparser.h>

ENTER_PK_NAMESPACE_CODE;

#if DRM_SUPPORT_DOMAINS

/**********************************************************************
** 
** Function: DRM_DOMKEYXMR_GetHeader
** 
** Synopsis: Parses an domain key XMR object header
** 
** Arguments:
** 
** [f_pbData]               -- Pointer to the XMR key data buffer 
** [f_cbData]               -- size of the data buffer
** [f_pbOffset]             -- Pointer to the offset position in the buffer to start
** [f_poHeader]             -- Pointer to an header object structure
** 
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DOMKEYXMR_GetHeader(
   __in_bcount(f_cbData) DRM_BYTE  *f_pbData,
   __in                  DRM_DWORD  f_cbData,
   __inout_ecount(1)     DRM_DWORD *f_pbOffset,
   __inout_ecount(1)     DRM_DOMKEYXMR_HEADER  *f_poHeader)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD dwOffset = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DOMAINAPI, PERF_FUNC_DRM_DOMKEYXMR_HEADER );

    ChkArg( f_pbData   != NULL );
    ChkArg( f_pbOffset != NULL );
    ChkArg( f_poHeader != NULL );
    ChkArg( f_cbData > *f_pbOffset + SIZEOF(DRM_DOMKEYXMR_HEADER) );

    dwOffset = *f_pbOffset;

    /*
    ** Read objects in the header
    */
    NETWORKBYTES_FROMBUFFER_TO_DWORD( f_poHeader->dwConstant, 
                                      f_pbData,
                                      dwOffset,
                                      f_cbData )

    NETWORKBYTES_FROMBUFFER_TO_DWORD( f_poHeader->dwVersion, 
                                      f_pbData,
                                      dwOffset,
                                      f_cbData )

    NETWORKBYTES_FROMBUFFER_TO_DWORD( f_poHeader->dwLength, 
                                      f_pbData,
                                      dwOffset,
                                      f_cbData )

    NETWORKBYTES_FROMBUFFER_TO_DWORD( f_poHeader->dwSignedLength, 
                                      f_pbData,
                                      dwOffset,
                                      f_cbData )

    *f_pbOffset = dwOffset;

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

/**********************************************************************
** 
** Function: DRM_DOMKEYXMR_GetSessionKey
** 
** Synopsis: Parses an domain key XMR session key object 
** 
** Arguments:
** 
** [f_pbData]               -- Pointer to the XMR key data buffer 
** [f_cbData]               -- size of the data buffer
** [f_pbOffset]             -- Pointer to the offset position in the buffer to start
** [f_poKeyObj]             -- Pointer to an session key object structure
** 
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DOMKEYXMR_GetSessionKey(
   __in_bcount(f_cbData) DRM_BYTE  *f_pbData,
   __in                  DRM_DWORD  f_cbData,
   __inout_ecount(1)     DRM_DWORD *f_pbOffset,
   __inout_ecount(1)     DRM_DOMKEYXMR_SESSIONKEY  *f_poKeyObj)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD dwOffset = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DOMAINAPI, PERF_FUNC_DRM_DOMKEYXMR_SESSIONKEY );
    
    ChkArg( f_pbData   != NULL );
    ChkArg( f_pbOffset != NULL );
    ChkArg( f_poKeyObj != NULL );
    ChkArg( f_cbData > *f_pbOffset + SIZEOF(DRM_DOMKEYXMR_SESSIONKEY) );

    dwOffset = *f_pbOffset;

    NETWORKBYTES_FROMBUFFER_TO_WORD( f_poKeyObj->wFlags, 
                                     f_pbData,
                                     dwOffset,
                                     f_cbData )

    NETWORKBYTES_FROMBUFFER_TO_WORD( f_poKeyObj->wType, 
                                     f_pbData,
                                     dwOffset,
                                     f_cbData )

    NETWORKBYTES_FROMBUFFER_TO_DWORD( f_poKeyObj->dwLength, 
                                      f_pbData,
                                      dwOffset,
                                      f_cbData )

    NETWORKBYTES_FROMBUFFER_TO_WORD( f_poKeyObj->wKeyType, 
                                     f_pbData,
                                     dwOffset,
                                     f_cbData )

    NETWORKBYTES_FROMBUFFER_TO_WORD( f_poKeyObj->wEncryptionType, 
                                     f_pbData,
                                     dwOffset,
                                     f_cbData )

    NETWORKBYTES_FROMBUFFER_TO_DWORD( f_poKeyObj->dwKeyLength, 
                                     f_pbData,
                                     dwOffset,
                                     f_cbData )

    f_poKeyObj->pbData = f_pbData + dwOffset;

    dwOffset += f_poKeyObj->dwKeyLength; 

    *f_pbOffset = dwOffset;

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

/**********************************************************************
** 
** Function: DRM_DOMKEYXMR_GetPrivKeyContainer
** 
** Synopsis: Parses an domain key XMR private key container object 
** 
** Arguments:
** 
** [f_pbData]               -- Pointer to the XMR key data buffer 
** [f_cbData]               -- size of the data buffer
** [f_pbOffset]             -- Pointer to the offset position in the buffer to start
** [f_poKeyContainer]       -- Pointer to an dromain private key container 
**                             object structure
** 
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DOMKEYXMR_GetPrivKeyContainer(
   __in_bcount(f_cbData) DRM_BYTE  *f_pbData,
   __in                  DRM_DWORD  f_cbData,
   __inout_ecount(1)     DRM_DWORD *f_pbOffset,
   __inout_ecount(1)     DRM_DOMKEYXMR_PRIVKEYCONTAINER  *f_poKeyContainer)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD dwOffset = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DOMAINAPI, PERF_FUNC_DRM_DOMKEYXMR_GetPrivKeyContainer );
    
    ChkArg( f_pbData   != NULL );
    ChkArg( f_pbOffset != NULL );
    ChkArg( f_poKeyContainer != NULL );
    ChkArg( f_cbData > *f_pbOffset + SIZEOF(DRM_DOMKEYXMR_PRIVKEYCONTAINER ) );

    dwOffset = *f_pbOffset;

    NETWORKBYTES_FROMBUFFER_TO_WORD( f_poKeyContainer->wFlags, 
                                     f_pbData,
                                     dwOffset,
                                     f_cbData )

    NETWORKBYTES_FROMBUFFER_TO_WORD( f_poKeyContainer->wType, 
                                     f_pbData,
                                     dwOffset,
                                     f_cbData )

    NETWORKBYTES_FROMBUFFER_TO_DWORD( f_poKeyContainer->dwLength, 
                                      f_pbData,
                                      dwOffset,
                                      f_cbData )

    *f_pbOffset = dwOffset;

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/**********************************************************************
** 
** Function: DRM_DOMKEYXMR_GetPrivkey
** 
** Synopsis: Parses an domain key XMR private key object 
** 
** Arguments:
** 
** [f_pbData]               -- Pointer to the XMR key data buffer 
** [f_cbData]               -- size of the data buffer
** [f_pbOffset]             -- Pointer to the offset position in the buffer to start
** [f_poKeyObj]             -- Pointer to an domain private key object structure
** 
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_DOMKEYXMR_GetPrivkey(
   __in_bcount(f_cbData) DRM_BYTE  *f_pbData,
   __in                  DRM_DWORD  f_cbData,
   __inout_ecount(1)     DRM_DWORD *f_pbOffset,
   __inout_ecount(1)     DRM_DOMKEYXMR_PRIVKEY *f_poKeyObj)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD dwOffset = 0;


    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DOMAINAPI, PERF_FUNC_DRM_DOMKEYXMR_GetPrivKey );
    
    ChkArg( f_pbData   != NULL );
    ChkArg( f_pbOffset != NULL );
    ChkArg( f_poKeyObj != NULL );
    ChkArg( f_cbData > *f_pbOffset + SIZEOF(DRM_DOMKEYXMR_PRIVKEY) );

    dwOffset = *f_pbOffset;

    NETWORKBYTES_FROMBUFFER_TO_WORD( f_poKeyObj->wFlags, 
                                     f_pbData,
                                     dwOffset,
                                     f_cbData );

    NETWORKBYTES_FROMBUFFER_TO_WORD( f_poKeyObj->wType, 
                                     f_pbData,
                                     dwOffset,
                                     f_cbData );

    NETWORKBYTES_FROMBUFFER_TO_DWORD( f_poKeyObj->dwLength,
                                     f_pbData,
                                     dwOffset,
                                     f_cbData );

    NETWORKBYTES_FROMBUFFER_TO_DWORD( f_poKeyObj->dwRevision,
                                     f_pbData,
                                     dwOffset,
                                     f_cbData );

    NETWORKBYTES_FROMBUFFER_TO_WORD( f_poKeyObj->wKeyType,
                                     f_pbData,
                                     dwOffset,
                                     f_cbData );

    NETWORKBYTES_FROMBUFFER_TO_WORD( f_poKeyObj->wEncryptionType,
                                     f_pbData,
                                     dwOffset,
                                     f_cbData );

    NETWORKBYTES_FROMBUFFER_TO_DWORD( f_poKeyObj->dwKeyLength,
                                     f_pbData,
                                     dwOffset,
                                     f_cbData );

    f_poKeyObj->pbData = f_pbData += dwOffset;

    dwOffset += f_poKeyObj->dwKeyLength;

    *f_pbOffset = dwOffset;

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

#endif /* DRM_SUPPORT_DOMAINS */

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmeccp256.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmerr.h>
#include <drmprofile.h>
#include <bigdefs.h>
#include <bignum.h>
#include <field.h>
#include <fieldpriv.h>
#include <ecurve.h>
#include <mprand.h>
#include "drmeccp256.h"
#include "drmsha256.h"
#include <oem.h>

ENTER_PK_NAMESPACE_CODE;


/*
** Defines
*/

#define P256_KEY_GEN_TRIES ( 1000 )

/*
** Extern Defines
*/

extern const field_arithmetic_t prime_arithmetic;

/*
** Globals
*/

#if DRM_PRECOMPUTE_GTABLE

#define ECC_P256_TABLE_SPACING 5
#define ECC_P256_TABLE_LAST 256


/*
 * Statically generated table using ecaffine_table_construction and table spacing of 5 and table length of 256
 */

static const digit_t TABLE[ ( ECC_P256_TABLE_LAST + 1 ) * ECC_P256_POINT_SIZE_IN_ECAFFINES ] = {

                0x18a9143c, 0x79e730d4, 0x5fedb601, 0x75ba95fc, 0x77622510, 0x79fb732b, 0xa53755c6, 0x18905f76, 0xce95560a, 0xddf25357, 0xba19e45c, 0x8b4ab8e4, 0xdd21f325, 0xd2e88688, 0x25885d85, 0x8571ff18, 0xc5e3a3d8, 0xd8c5fccf, 0x4079dfbf, 0xbefd904c, 0xfead0197, 0xbc6d6a58, 0x695532a4, 0x39227077, 0xdbef42f5, 
                0x09e23e6d, 0x480a9908, 0x7e449b64, 0xad9a2e40, 0x7b969c1a, 0x9591c2a4, 0x6231d792, 0x44cc3add, 0x4f7081e1, 0x87be82cf, 0xd5ffa1d6, 0x0edd6472, 0x89890b6c, 0x3ed17863, 0xada26e1a, 0x63483caa, 0x276f2715, 0x2f6077fd, 0xe6924cd9, 0x0a466e3c, 0x05a7fe98, 0xb1902d1f, 0xf1c794b0, 0x3b36f9fd, 
                0x79b0fe62, 0xfde19fc0, 0x26543b23, 0x958482ef, 0x136e64a0, 0x9b095825, 0x23f63771, 0xb6a1142e, 0x14cfd596, 0x335aac0b, 0x5ea6aac6, 0xf3081dd5, 0x86a0e8bd, 0x003dc12a, 0x5fb89d79, 0x584c5e20, 0xa7a8746a, 0xb9dc7035, 0x267e4ea1, 0xb9548c9b, 0x593a15cf, 0x4bd012f3, 0x5e6e2135, 0x8c8f936e, 
                0xdf31cc6a, 0xb5c241dc, 0x8af84d04, 0x345efb86, 0x63990a6f, 0xb9b962cb, 0x6fef4e61, 0x2c11bb37, 0x540234b2, 0xed4c74a3, 0x2d0366dd, 0xeec5f25d, 0xf9a968da, 0x67b63142, 0x36601068, 0x68d7b6d4, 0x07cd6d2c, 0x0c842942, 0xa8f74f09, 0x7768b1ee, 0xe2751404, 0xfe62aee4, 0x4b5f7e89, 0xa61a76fa, 
                0x55d5c68d, 0xca1554dc, 0x598b441d, 0x773b279c, 0xd39923b9, 0x36bf9efc, 0x33331d3c, 0x298de399, 0x2d4c848e, 0xa1a27f56, 0xcfdb8e77, 0x57b8ab70, 0x94c855ea, 0x6f7879ba, 0xdcdb9dae, 0x22248acc, 0xb2083a12, 0x3264e366, 0x1f6ec0ef, 0x5afdee28, 0x5659b704, 0xe6430bb5, 0x7a823a40, 0xe1900a79, 
                0x24592a04, 0xc9ee6576, 0xcde09d4a, 0x4b5ea54a, 0x52b6463f, 0xd3ca65a7, 0x1efe9ed3, 0x533ef217, 0x889f6d65, 0xc3ca2e87, 0x7158c7e4, 0xdc2b4167, 0xfb670dfb, 0x844c257f, 0x75910a01, 0xcf88577d, 0xf336bf07, 0xe45e2ace, 0x22245250, 0x7ca23d85, 0x2ed92e8d, 0x2b812f58, 0x29f8be4c, 0xea6c3997, 
                0x5ace5035, 0xc2610bef, 0x54259aaa, 0x3c80dd39, 0xef18bb3f, 0x5fc3fa39, 0x6910b95b, 0x43e09aee, 0xfce2f510, 0xa7675665, 0xced56c9f, 0xd872db61, 0x10e265ac, 0xae9fce69, 0x6982812e, 0xa90567e6, 0x97b14f7e, 0xb6ae5cb7, 0x513257b7, 0x9f10903d, 0x85454a3c, 0x69bc3724, 0xd8d2c9ad, 0x6b29cb44, 
                0x38da9324, 0x77c8cbac, 0xb540a21d, 0x01918e42, 0x9bbfe435, 0x56c3614e, 0xfffa707a, 0xc094dbb5, 0x6233ea68, 0xd968d410, 0xb77d062e, 0x58b3002d, 0x3e719bbc, 0x3dc49d58, 0x68e7dd3d, 0x013a5e58, 0x8d825740, 0x3c9e3c1b, 0x21311747, 0x7c99b6ab, 0x0cb0a2a7, 0xc2f888f2, 0x5c48a3b3, 0x6424c49b, 
                0x646f9679, 0x67c241c9, 0xf888dfe8, 0x24f68b49, 0xe12d4b93, 0xa571df20, 0x9a6b62d8, 0x179483cb, 0x81b4b26d, 0x9511fae2, 0x666f9632, 0xd53aa51f, 0xd281b3e4, 0x7f3dbd16, 0x7f96a765, 0xfac61d9a, 0x027cc8b8, 0xe3c6fe8a, 0x7d25e062, 0xe5bff503, 0xe08805bf, 0x6ff632f7, 0x13271e6c, 0x232f76a5, 
                0x55dca6c0, 0x701ef426, 0x8957c32d, 0xa10a5178, 0xee728bcb, 0xb62c5173, 0x5ea60411, 0xa3e6fced, 0x0d53f5c7, 0xf45fbdeb, 0xe8cbbdd5, 0x13339a70, 0xf85c01df, 0x142ceb81, 0x0ff71880, 0xbd70437a, 0x4c4e8774, 0xba0bda6a, 0x5fb32891, 0xf18bd26e, 0x1cdbebd2, 0x03a9d522, 0x2f9526f1, 0x65c7322d, 
                0x439530b6, 0xb3c1b3fb, 0xcf12cc01, 0x0172f685, 0xc70b0186, 0x1b58391d, 0xb915ee22, 0xa317db24, 0x9afdf03b, 0x17b8ffc4, 0x87dec659, 0xe4d3d050, 0x7f46597b, 0x006500e7, 0x80a1c1ed, 0xf1c367ca, 0xe4050f1c, 0xc90fbc7d, 0x9bc85a9b, 0xe1a11032, 0xa373c4a2, 0xad0393a9, 0xb64232b7, 0x167dad29, 
                0xf5577eb0, 0x94b78ab2, 0x1604f301, 0xe829348b, 0x0baa94af, 0x41654342, 0x77fbd8dd, 0x5ca7d866, 0xab58b910, 0x3adb3b34, 0x582967e2, 0xcceac0bc, 0x89ae4447, 0x7bf56af5, 0x919c667c, 0x60f5dcd7, 0x9aec17b1, 0xddcaadbc, 0xec697b9f, 0x463467f5, 0x0b98f341, 0xa967132f, 0xb187f1f7, 0x3a29467a, 
                0x9894344f, 0xc51eba6d, 0xde81e949, 0xa5e5c2f2, 0xdaea066b, 0x08c8c7b3, 0x3fc8a614, 0x06d0de9f, 0x7adff88f, 0x3b75ce0a, 0xbbc11cf5, 0xfbbc87d5, 0x9fbb7acc, 0x7badfde2, 0xa1458e26, 0xc5f95cd8, 0xb06b1244, 0xf4ab95f4, 0xda8c8af0, 0xb9e5836d, 0x1bae59c2, 0x3acffffc, 0x07d51e7e, 0xc2ccbcda, 
                0x01e15e6a, 0x8528c3e0, 0x3bc1923f, 0xa49fead4, 0x43324577, 0x2aa7a711, 0x61a1b884, 0xc8de610b, 0x0f893a5d, 0x67e223ce, 0xe8c515fb, 0x4ead6dc5, 0x7774bfa6, 0x925c728f, 0x89d20f95, 0x098583ce, 0x7a1e0966, 0x93f2a7d7, 0xa2eedb94, 0x4c304d4a, 0x1b282097, 0xc077282d, 0x0842e3da, 0x36f09ab0, 
                0xefb2149e, 0x4a10bb5b, 0x03f163ca, 0x06e20998, 0xd0297045, 0x1b5a3bab, 0x56f0af00, 0x70880e0d, 0x7af4cfec, 0xbe3d913f, 0x7332a66f, 0x7eceb4bd, 0x32e6c84a, 0x9c228f55, 0xedc4a79a, 0x1bf4581c, 0x98857ceb, 0xaca7b166, 0xe635e186, 0x659722ac, 0x278ddd22, 0x1db68007, 0xa0903c4c, 0x48f21402, 
                0x366e4589, 0xb96abda2, 0x31b49c14, 0xe0403190, 0x329c4b09, 0xd29f43fe, 0x97197ca3, 0x80eb24a9, 0x60e28570, 0x488e0cfd, 0x7bedfb4d, 0xc259cdb8, 0x721ebbd7, 0xbc6390a9, 0x0b0da855, 0xde314c70, 0x2b4d04db, 0x6c32e846, 0xcdbf1fbc, 0xb162fc9e, 0x33833eab, 0xb0dd3ab7, 0x9939b48b, 0xd111f8ec, 
                0x3e0e5c9d, 0xb7c4e760, 0xbcc33f8d, 0xbd392a51, 0x702f9a91, 0xc132e92d, 0x7da4a795, 0x0bb1151b, 0x1a0b0ae3, 0x02e32251, 0x54febac8, 0x694e9e78, 0xea3a5082, 0xe4fe40b8, 0xe58ffec1, 0xb733aa5f, 0x3c2f0ba9, 0xf05af235, 0xdece47cb, 0xa2ac82a5, 0xf8e3f715, 0x2203f18a, 0xc97ba641, 0x09c11060, 
                0xc3af5504, 0x46af512d, 0x56ea2c05, 0xf3f28146, 0xfac28daf, 0x959ef494, 0x87fab43a, 0x41c23fa3, 0xb4480f04, 0xc1989a2e, 0xb4712eb0, 0x93a29ca7, 0x3ccbba0f, 0xd619428c, 0x6e205c14, 0xb3641686, 0x90db7957, 0x45ac8b4e, 0x0432691d, 0xf64e0350, 0x07a759ac, 0x9c972517, 0x0514d89c, 0xe2c2bf15, 
                0xfeb09740, 0xa9e99704, 0x627a2205, 0xc2fbc565, 0xec8d73d0, 0xc20c8de8, 0x223eed8f, 0xa8363b49, 0x1ee32583, 0xc9c2b0a6, 0x1a0b6cb9, 0x90dbc85c, 0x49f7c3d2, 0x1ef4c1ac, 0xa8dfbb97, 0xfa181e69, 0xef0a3fec, 0x30d69a98, 0x9ea02f81, 0x66eab95d, 0xb2e9cf8e, 0x24720021, 0x520f2beb, 0x1df84361, 
                0x621c540a, 0x71fa6d5d, 0x12037721, 0x0ff5f6ff, 0x6e3c7b51, 0xabb2bef3, 0x817a069b, 0x700a1acd, 0xb5560fb6, 0xfd999681, 0xe823fd73, 0x6cb4e1ba, 0xda915d1f, 0x6ebe00a3, 0x0d030118, 0x89fca8cd, 0x744fb0c9, 0xf9da0e0b, 0x970d01db, 0x7931d76f, 0x0ad8c564, 0xf659b96a, 0xb15737bf, 0x626332d5, 
                0x994f523a, 0x5561bb44, 0x7bc38833, 0x3d845ea2, 0x005ed4b0, 0xc2a1f08a, 0xd39d3ee1, 0xe7676b0d, 0x6561fdd3, 0xfb706017, 0x620e35ff, 0xf264f9a8, 0x36ce424f, 0xda2681f7, 0xc4c3419f, 0x7cb1282c, 0xb828dd1a, 0xbe46973a, 0xa08d7626, 0xe708d6b2, 0x6baf8d40, 0x4daeb3f3, 0x72571fa1, 0xf22dfd98, 
                0x85b1732f, 0x0087108d, 0x87ab01a7, 0x5988207a, 0xaaaafea8, 0x69f00755, 0xccc832f8, 0x6d3549cf, 0xd433e50f, 0xfacd665e, 0x6f33696f, 0xce11fcb4, 0x695bfdac, 0xaf7c9860, 0x810ee252, 0x7159bb2c, 0x65450fe1, 0x758b357b, 0xf7dfbebe, 0xd69fea72, 0x2b057e74, 0x92731745, 0xd485717a, 0x46ac49d2, 
                0xa6b5c9d6, 0x83137aa9, 0x42c77c0b, 0x68225a38, 0x24d000fc, 0x2fe1e907, 0x0f63cfc8, 0xc6441f95, 0x22d1b01b, 0xec8e448f, 0x7d38f719, 0x787fb1ba, 0x9b33fa5f, 0x190158df, 0x94dcfda1, 0xc4e83d33, 0x43ed81b5, 0x5efd488b, 0xd9f35879, 0x9deb4d0f, 0x164a620f, 0xac6a7394, 0xc6927bdb, 0x9f9e0f03, 
                0x45c28df7, 0xfcd7e1a9, 0x2868661e, 0xffa348f1, 0x7cf4e8d0, 0x398538e0, 0x6bd4c284, 0x52666a58, 0xb0d1ed84, 0xe6a9c3c2, 0x4bcb6e00, 0x26906408, 0x3c57411c, 0x13556400, 0xcfc20755, 0x5294dba3, 0xa08b1c50, 0x8b7dd31e, 0xa30ba286, 0x991eca74, 0xd70ba90e, 0xe762c2b9, 0x094e142c, 0xe1337c26, 
                0x949c9976, 0xd73d68e5, 0x6faadebd, 0xf1b768d9, 0x9e158614, 0x9cc4f069, 0x22dfa557, 0xbe93c6d6, 0xccd6da17, 0xa504f5b9, 0x24866c61, 0x8d694da1, 0x2121353c, 0x0140b8c6, 0x1c6ca580, 0xb0166f7a, 0xae8317f4, 0xceec74e6, 0xfbd3e3f7, 0xe0874bfd, 0xfdb516ac, 0xc681f3a3, 0x3d846019, 0x7c1620b0, 
                0x0b12ee5c, 0x2b63c501, 0xba68b4dd, 0x6668c51e, 0xac03cd32, 0x4e0bcb5b, 0x2a6279f7, 0xc2c6ff70, 0x8735728d, 0xc5dc2235, 0x79d6122f, 0x19e277f9, 0x23f5d003, 0xdded8cc7, 0x7ee84e25, 0x63cd880a, 0x91a8afb0, 0x3574af60, 0x3f3ea7c6, 0x02de7f42, 0x0cfcdc84, 0xb31aa152, 0x62d0792f, 0x4cd8f64c, 
                0xc492ec64, 0x279d7b51, 0x58a2d790, 0x1fc75256, 0x0ced1fc5, 0x8f433017, 0x3e658aed, 0x05da59eb, 0x0b61942e, 0x0ddc3722, 0xba3d60a3, 0x742e7f87, 0x7c311cd1, 0xf6b01b6e, 0x6473ffee, 0x81fdad90, 0x25914f78, 0x0d2cf6ab, 0xcf638f56, 0xcc054de5, 0xb90bc03f, 0x18b06350, 0x932811a7, 0x9bbd11ff, 
                0x2f00b330, 0xb4044974, 0x76108a6f, 0xa851d266, 0x801bb9e0, 0xbf8990c1, 0x0dd099be, 0xcb198ac7, 0x1c894849, 0x0f264665, 0xa884a93d, 0x9b200678, 0x2da964ef, 0x009834e6, 0x3c351b87, 0xe2c4b44b, 0xafb2ef9f, 0x3326790c, 0x580f6c47, 0x0b02264a, 0xb8480521, 0x42a194e2, 0x8ba6f9e2, 0x9d8e68fd, 
                0xe5f649be, 0x1b044320, 0xdb0f0533, 0xe0c33398, 0xf6fde9b3, 0x66c8cfae, 0x92f4209b, 0x1a739d4b, 0xe9d1afcc, 0xa28ab8de, 0x09aea75f, 0xeac6f1d0, 0x14375fb5, 0x708f7aa5, 0x6420b560, 0xe0f222c2, 0x5043dea7, 0x72e65142, 0x309d42ac, 0x9216cd30, 0x94fe9ddd, 0x0f87feec, 0xd6539c7d, 0x432ac7d7, 
                0x03c5a57c, 0x327fda10, 0x72692cf0, 0x280698de, 0xec28c85f, 0x7ec283b1, 0x2331fb46, 0xc42bd6d2, 0xdb567d6a, 0xbb1f96ae, 0x6df86468, 0x4843b28e, 0x0efe5b1a, 0x6379b240, 0x961bbb05, 0x70a6a26b, 0xb6caf5f0, 0x328e6e39, 0x70686c0d, 0x895fc8d3, 0x80da06cf, 0xb363fdc9, 0x804d8810, 0x292a9287, 
                0xa004dcb3, 0x77b092c7, 0xddc15cf6, 0x806c0605, 0x083a8464, 0x3db997b0, 0x4a68df70, 0x05bf7dd0, 0x9c134e45, 0x8ccf7f8c, 0xa4e63d39, 0x41b5f8af, 0xa6e6517f, 0xad7bc1cc, 0xaa8b9342, 0xf23206d5, 0x2bf5db47, 0x1d260152, 0x2f6d3420, 0x3f8ff89a, 0x17b87653, 0x378fa458, 0x5157c30c, 0x2d4fb936, 
                0x7517c5c5, 0xe6518cdc, 0xef22f7ac, 0xbf847a64, 0xdeb483e6, 0x92e0fa89, 0xf5084558, 0xef7d9289, 0x549db2b5, 0x197f015a, 0x2480d4a8, 0xc40493b6, 0x61d5590b, 0x6f780331, 0x3a55b52e, 0x309eadb0, 0x40eb8115, 0x92e5c625, 0xdea7de5a, 0xcc6a3d5a, 0x64d631f0, 0x93e8dd61, 0x9d5e9d7c, 0x1f095615, 
                0x1083e2ea, 0x14e68c33, 0x0a28ad77, 0x3d8818be, 0x6bfc0252, 0xf35850cd, 0xb585113a, 0x30df8aa1, 0x7d935f0b, 0x4ab7e3ac, 0xaddda07c, 0x552f00cb, 0x92c34299, 0x2909df6c, 0xc33ed1de, 0x566c5c43, 0x6e85cb51, 0x3597f046, 0xcff9c919, 0x4994d94a, 0x9354e90c, 0x2147927d, 0xe0a39332, 0x0dc1eb2b, 
                0x8427fac1, 0x2ff319fa, 0x88cfd8c2, 0x01965274, 0xe2d4e684, 0x67aaa746, 0xfa2e067d, 0x23a5d896, 0x9910ba6b, 0x7fe4364e, 0x1fe19e35, 0x9a33c677, 0x6e1da8c3, 0x29fd9fd0, 0x15b4488b, 0x1a1f22bf, 0x1f439254, 0xab8163e8, 0x920a8a70, 0x07e5658e, 0x3fd1b249, 0xb6ec839b, 0xf2c4f79c, 0x95a7b1a2, 
                0x197dd46d, 0x3c6341fb, 0x9c4e7ad6, 0x484c2ece, 0x426eca29, 0xde7f4f8a, 0x9211e489, 0xc78ef1f4, 0x14997f6e, 0x06574586, 0x2b2c0910, 0x1c3eede8, 0x17286a6e, 0x0f60e018, 0x25f92e47, 0x6d55d6a4, 0xc52d8d8b, 0xbe58e8f9, 0xc4130fb3, 0xe1275627, 0x5f55c345, 0x117042d3, 0xb881a03c, 0x3238d301, 
                0x00a970a5, 0x12a2c4f1, 0x40d7cf24, 0xd770ea74, 0xace4a2f5, 0xe96940b2, 0x36a2e587, 0x1ab98df0, 0xee8b49b0, 0xf59a9427, 0xecbdeab5, 0x548c6a63, 0xbb05effa, 0xdb9344ef, 0x7efc4617, 0x357e0678, 0x4f4444f2, 0x72103a20, 0xd4b9f5f7, 0xb9777db0, 0x4f0d7397, 0x8288f5df, 0x7ff6e1d2, 0x5a463486, 
                0x97575f51, 0x306eaa96, 0x3cf990bc, 0xfe851fe2, 0xbbfd37ee, 0x0347d5d8, 0x98075a38, 0x087def74, 0xd799f5a9, 0x1ba1609c, 0x07365f7a, 0x76a88396, 0xe6a39ca6, 0x39fb04ca, 0xab11ed8d, 0x2d6d2261, 0x30dbdb03, 0x0a712d66, 0x9c2cc5ea, 0x91be6c9b, 0x04096f3c, 0x0aab7e15, 0x0410f050, 0xf6831d44, 
                0x6acd71db, 0x732f1b08, 0x6e118cec, 0xa4e928f8, 0x942ef8cc, 0x42577ccb, 0xb9395357, 0x241507a2, 0x6243e9b8, 0x2b237781, 0x68ab873f, 0x5526adf7, 0x0e53b515, 0xdf40fa2e, 0xac542701, 0x686808e7, 0x9ee929c6, 0x176c5288, 0x44977caa, 0x867c9c46, 0x1375fd2b, 0xcdb2e6d2, 0xb1395e94, 0xe323fe2a, 
                0x88dbf571, 0x89081b0f, 0x1fce5d43, 0x6d053b84, 0xf94cf853, 0x00233caf, 0x95c5550d, 0xd39a394f, 0x0afb5c85, 0x465031a5, 0x4badb9fd, 0x974faba7, 0x1ae7afae, 0x53cc5c75, 0xb5281147, 0xd4f4e970, 0x8306ad4b, 0x05a8c25b, 0x3118e937, 0xbdc8c9e3, 0x9cdded3c, 0x7c1a5725, 0x2e1c3a6b, 0x73acf0a1, 
                0x4cd326b4, 0xf21a3175, 0xa6bfda97, 0x1e00da12, 0x4f64bca2, 0xbbd27529, 0x17b50465, 0x08e7d678, 0xac362409, 0x6d29ce9a, 0x98308f24, 0xe5b43e8d, 0x6b6ad08e, 0x07bf8762, 0xf1e60a0f, 0xc6fcb2cf, 0x14a074d1, 0x6fd43c2f, 0x349f7d2f, 0x94ea4778, 0x8e7ac5d7, 0xcb80f618, 0xec106a62, 0xc02afe47, 
                0x2eef718c, 0x3e360468, 0xff8c9db3, 0x50d841a0, 0x446f73e8, 0xc188b6cd, 0x670ef28c, 0x65819f96, 0x205f7808, 0xfc2a6491, 0x130f6317, 0xb288ca97, 0x7c93567b, 0xea4d03bc, 0xf4733fbd, 0x0878dd00, 0x58840ac5, 0x9491e292, 0xcbb2e188, 0x840cbe7b, 0x40b17a07, 0x7255b284, 0x7e90ce7c, 0x5fe2938f, 
                0x28c3a65b, 0x79fe6187, 0x1e85c4ee, 0x1f641ca0, 0x1f85724e, 0x582584c1, 0x261a3c5e, 0xf4798f9f, 0x516b1c42, 0x52ca7b06, 0x2329f7fd, 0x42e70261, 0xda781d5d, 0xd8e5cfb7, 0x34677c35, 0x87a7d45b, 0x7e3828f7, 0x6120dcfd, 0x7f0b1b62, 0x5120867d, 0x099b5f4c, 0xc4b3d7c8, 0x31f1fcc6, 0x39a3132a, 
                0x01e68417, 0x93c06a60, 0xf0c11a60, 0x84651665, 0x1172be49, 0xf54a2da6, 0xd5f63e50, 0xf97d61d2, 0xdbf53fe5, 0x929ffd1a, 0xa91a964b, 0xc504e62d, 0xe0ace6b2, 0x1eb04527, 0x302bd557, 0x8cfc4a6a, 0x0b1c611b, 0x0b0274e0, 0x6c28c8d1, 0x1ee813f5, 0x75fa46e8, 0x41c07cb4, 0x6526fdc0, 0x887d2b2f, 
                0xd7b48235, 0xf3871545, 0x92c684e3, 0xe78e9b70, 0xb5f5f2e3, 0x9b211ade, 0xf90e43ac, 0xb96850ad, 0x2badfe7e, 0x53d0063a, 0x149ee17c, 0xd36592cf, 0xad4c5b0c, 0x602f3797, 0xfbce9ecf, 0x0ed1f3cb, 0x01f796be, 0x9a47299d, 0xaf694d61, 0x6dc824f6, 0x881cda7d, 0xb572af5b, 0xdcfdbe1a, 0x6694a2a8, 
                0x9303b61d, 0xe599688f, 0xe21e7555, 0x35e2a19d, 0x1ab483d8, 0x61e48a0c, 0x8a912bad, 0x6b8b4b42, 0x7f0e193f, 0x1c3966dc, 0xc4f2d16f, 0x1218f4b8, 0x4b915343, 0x5795259a, 0x81858c60, 0xcf62e6d1, 0x1e07f57b, 0x39af1c3e, 0xce99c2df, 0x8e946432, 0x73d9df11, 0xda3ac6af, 0x60f19331, 0x1d8bbe4f, 
                0xbfcdddfa, 0x14477713, 0x5add9d2f, 0xfaefffce, 0xab51c819, 0x53e3958b, 0xbc458fdf, 0xbeb5f5fe, 0xd9fecd9d, 0xcc90a0a8, 0x6e251161, 0x9325239a, 0xbb73932b, 0x1ff66e45, 0x6442dd12, 0xa206c95f, 0x5e1365e2, 0xf1cd1105, 0x6e4bbea6, 0x0599b828, 0x68d8cabe, 0xba4c2251, 0x68fe1cd9, 0xc1320557, 
                0x6792173a, 0x8df69e39, 0xcf96f290, 0x45ec9115, 0x6e14b7fd, 0x437e74b3, 0x34fa98f0, 0x5ff194af, 0x52979f37, 0x7fc1a505, 0xfbfb2ed2, 0xed49d9d7, 0x3c98090d, 0x92c3d76f, 0xbf600559, 0x809ea598, 0xbd0fd85b, 0x24e95867, 0xe48e1df2, 0x6fd29f61, 0x9e205fb7, 0x2c7aa375, 0x7f27e98f, 0x8d3ee115, 
                0xd3959a69, 0x122f6cf8, 0x51e15ad6, 0x43beae52, 0x36f29974, 0xcf43f2b0, 0xf2035e2d, 0x9fb905a1, 0x38f7e3e6, 0x3f07e6cf, 0xef2990d4, 0xe737e343, 0xafed8661, 0xbed161fa, 0xa53b9a9d, 0x8571acdd, 0x556c1ef7, 0x32ec01a6, 0x5e82254b, 0x30d5ab3c, 0x12eb099c, 0x65cf24c4, 0xefbb038a, 0x548f5729, 
                0x545aa7e0, 0xdb8b4e88, 0x0278140f, 0xd250c4ba, 0xdc352716, 0x3276b856, 0x71cf044f, 0xba73e7a0, 0xd423f233, 0xc91bb1b3, 0x95f07b69, 0xf4c5bb24, 0xa831588a, 0x3efd91bb, 0xeb1d4917, 0x475e6388, 0x6b456c97, 0x2688182d, 0x5e67a4e8, 0x0a5867da, 0xdd98b3df, 0x42a48cee, 0x04a876b1, 0x925d6c52, 
                0x166e1c17, 0x4f9f2c89, 0x439774f9, 0x98767e4f, 0x31530a7e, 0x998e5f2b, 0xa6026123, 0xc405e032, 0x8b77bf91, 0xa9dca02d, 0x8f7aa529, 0x4e55c7a4, 0x60232f35, 0x11b8502f, 0xbaed3a9a, 0x0f39645d, 0xdfe8b6b0, 0x11b2d295, 0xcc2c9f8b, 0x7527dda7, 0x4c8d6c07, 0x6c7f757b, 0x0d9a9e01, 0xc70f1134, 
                0x00ed73ff, 0x769d06e7, 0xdf892b4e, 0xb91cd0c3, 0x56a39047, 0xee8241bc, 0x8a17acce, 0x2ad384fe, 0x633adda9, 0xb580a51d, 0x7115cf0b, 0xcacfa799, 0x37732209, 0x4c0e4df9, 0xc2730cf2, 0xe177864f, 0xa37ddf85, 0xae27a244, 0x57a4e0a7, 0xb5a8948d, 0x0dec95fc, 0x0ca6116c, 0xf00d7c64, 0xde338ebc, 
                0xa95ea503, 0x3b30f5ea, 0xc6561a09, 0x98927ae2, 0xa5d936f4, 0xd0fd8e00, 0x76369b1d, 0x0131f641, 0x670e26b5, 0x16120de5, 0x36137c2f, 0x6a4f7877, 0x1ecdcf54, 0xb149f6ca, 0x2e3b382e, 0xa1a4a9bd, 0x1d639b19, 0x6d66fa5d, 0x806d38a4, 0xe7bf9a3d, 0x39c66da5, 0x03865476, 0xf82870f8, 0x861e3fa2, 
                0x0c5a0f20, 0xc12ff342, 0x495a0aec, 0x206840e0, 0x14a885d3, 0x1242f32a, 0xc134ef26, 0x22c372f4, 0x0c6022af, 0x7cf7dcd4, 0x9c6f1d8b, 0x8c0f1f4d, 0x4e5cfd78, 0x93ea817a, 0x50c65ac6, 0x824e3c8b, 0xe65b20bf, 0xa7354090, 0x46f2bc84, 0x6bb68f5c, 0xe4a63f5a, 0x1b8c1a8d, 0x80424b38, 0x9532f44a, 
                0xc899dccf, 0x8d261d93, 0xc017acf8, 0x3d681143, 0x3c156ba7, 0xe0f46929, 0xd5cc52c9, 0xe576b18b, 0xc21aeb08, 0xf746139b, 0x9f31eb94, 0x4794f4d5, 0x997f128b, 0x7846149b, 0x65dbe966, 0x30daccd9, 0xce6a526a, 0x07cbb45d, 0xa64c6572, 0xc0e06263, 0x4262cb4c, 0x27c08f45, 0xb9f01d5a, 0xe9f50c0d, 
                0xd49d62f0, 0x5da9dc83, 0xc8066a1e, 0x73107703, 0xacc8a408, 0x2df1801c, 0x1277ffa1, 0x282d4b83, 0x8779c438, 0xef0828a6, 0x43a5b177, 0xe8baa9b0, 0xb34893ad, 0x49f35f50, 0xcd8a7523, 0x08733e26, 0xa42c6f46, 0x38f0b396, 0x236a5d8f, 0xf6e14d45, 0x846e3a06, 0x6784852e, 0x2d8dc98b, 0x26a9e620, 
                0x14fce5f8, 0x3a0c74b1, 0x6e41a645, 0xc14ddce8, 0x35a7c405, 0xd0700ce3, 0xea8f9915, 0xb0cedc91, 0x74f1a1be, 0xe686f0c5, 0x103c8c05, 0xe3e6e1b1, 0x95f18e15, 0xd239a907, 0x5cb5d4a1, 0xa7854e41, 0xc0e6b131, 0xe78b238e, 0x210232ec, 0xe79ebbb6, 0xd3bef13e, 0xb06e3cdd, 0x06110ff2, 0x5d346e44, 
                0x3a7c897b, 0x9948c2a9, 0x4101dc61, 0x83bc93a7, 0x03c81c58, 0x249e5712, 0x898e5b18, 0x81ad2eba, 0x68465c41, 0x4dc749b5, 0xc9c56c25, 0x733480f9, 0x5898b7e3, 0x9744de1e, 0x5039406a, 0xfe16b2aa, 0x25f8209c, 0x73eb293d, 0xb93d6789, 0x82d26c5e, 0xea9b8c89, 0x2118886b, 0x9c63db50, 0x3b82d2e5, 
                0x3a7c63b0, 0xfdf217e8, 0xb28f738f, 0x66aa63c9, 0x3ec686e0, 0xd271e1e4, 0x41e0f6a3, 0x00e0f2b7, 0x8ecfdf69, 0xf30e53e1, 0xdecdbeb6, 0x59180d5d, 0xc5f1d5e3, 0xe53ed44a, 0x5cb489e4, 0x873da1fc, 0xd8f7ef4e, 0xd45f81c0, 0x208b2335, 0x8ec2802e, 0x036fd4af, 0x8d21241c, 0x50abd05d, 0xa6b84e15, 
                0x69f51d77, 0x2cb21881, 0x5722bd2f, 0xf20c486f, 0x06e28519, 0x752e123b, 0xe439dbc7, 0x8098be00, 0x74d6201a, 0x951b0872, 0xcc72e5a6, 0xf21b6fbb, 0x01f64521, 0xbdd9db86, 0xea2d215f, 0x30168579, 0x990c865b, 0x49c6604d, 0x1bc779bb, 0x8b2c4f1e, 0xba0ed23c, 0x3ef864d6, 0x8647366a, 0x2d9017da, 
                0x63634d25, 0x3ccf877b, 0x9f8983b6, 0x2f020c28, 0xa1df9e84, 0x09d1ce85, 0x278e2874, 0x2d81b8f1, 0x5f397964, 0x1f4374d4, 0x4b220a8f, 0x10b6f2b6, 0x036e5dd9, 0x95080533, 0xadd76c36, 0xcaed6cca, 0x3aa73d11, 0xe00c4d6e, 0x5ebc9b60, 0x77d7d420, 0xe3b5aba0, 0x89d9ee0e, 0x0aaa05f4, 0x3f2258a9, 
                0xac1cd922, 0xbe6753c1, 0x12c22095, 0x456e683a, 0xe5ff32df, 0x47190ca2, 0xc16ca713, 0xd5941915, 0x265078b6, 0x5e0d8f7d, 0x5ff6da74, 0xf4ecf027, 0x993f605e, 0x44470571, 0xdb656d5b, 0x8eba05ae, 0x25e93457, 0xa6121b18, 0x16054e7b, 0x73c7f885, 0x714d715e, 0x5116adc3, 0x9b374968, 0x9d234b75, 
                0x77b91d2e, 0xe7ec4573, 0xd911ac4d, 0x30c67f3a, 0x009cbf61, 0x8bc4b3aa, 0x3628d070, 0xf772f116, 0x0d98f483, 0xec8c33a3, 0x6dbccb8b, 0x9296a7e5, 0x9fb1a435, 0x4817ff3c, 0x6960595b, 0x814a3d8f, 0x989d7ad0, 0xcdb698b8, 0xa05f28d2, 0x717fc758, 0x5699810f, 0x49328b2d, 0xabd71424, 0x392cc048, 
                0xe142ab66, 0x6868d481, 0x2684a6e3, 0x5c822b1d, 0x2794ef9e, 0x4a3e90e4, 0x1548ba86, 0xf1f6df1e, 0x6cceddb6, 0xff3fab70, 0xfa35cccf, 0xfbbb889c, 0xa911fd20, 0x697dc2b7, 0xf355c5e3, 0x84c6ef5c, 0x2ea194c3, 0xf6f121aa, 0xf2bb613a, 0x917e22d2, 0xb1f9376a, 0xf807ca16, 0x8c61a1d2, 0xa1c2fe01, 
                0x1e453cd5, 0xa7c662f2, 0x4a234649, 0x8e624262, 0xf8949993, 0xbc14dbf5, 0x1c6b0da9, 0x441acb44, 0x6b087f17, 0xc8c137ee, 0x8ef3a084, 0x053ee779, 0xf248a32c, 0x3362d801, 0x705dca7b, 0xa51c8e9a, 0xec40b399, 0x4533cc5d, 0x023acea0, 0xeb3935b2, 0xacd85bcf, 0xf0e15002, 0x51f886dc, 0x270ffbba, 
                0x43878fa2, 0x36de06a4, 0xfe593ec2, 0xbc075242, 0x756cd38c, 0xba849f97, 0x6abcb20a, 0x7927b445, 0xce91c966, 0xcac01bce, 0xf0d040dc, 0xa616f1b7, 0x614e39d8, 0x58f35e1c, 0x8ff16ab8, 0x243d9357, 0x8f6a1ff8, 0x477cd153, 0xa0614df6, 0x27c6404c, 0x0a8e99fe, 0xafcc3af5, 0x9136e6e6, 0x2f213a45, 
                0xffbf2dfe, 0x86289bd1, 0x45a9d8f7, 0xf9f7936d, 0xaa45ed94, 0xf9ce5efd, 0xc2d73062, 0x82312eac, 0x6c33f50c, 0x818520a0, 0x860cc642, 0x74d20b05, 0x7057e04f, 0x788158a1, 0xbe1f9e9a, 0x7a594160, 0x1fb347ac, 0x721a5be9, 0x1dd6459f, 0x904a1022, 0x54934a15, 0x427b6d2c, 0xdbc5c3cd, 0x33277945, 
                0xc41f40db, 0x2cb0dc07, 0xfbc8b014, 0x750dc202, 0xc4fbaf79, 0xc48bf3ec, 0x7754582b, 0xade91632, 0x9e138595, 0x37bb180b, 0x9c3f5e48, 0x6f3f03fa, 0x9ea528ec, 0x3c38e838, 0x6ccbd78c, 0x90b5720d, 0xdacff4a6, 0x77e808e3, 0x14f6e4c5, 0xf3cb42f1, 0x3787df0b, 0x846551e2, 0x665603a4, 0x5292ab5e, 
                0xf9bdfcd1, 0x3ca1c920, 0xaae1459c, 0x31430b72, 0x319a6aea, 0x89b5dcb7, 0x504537fe, 0x77fef4ec, 0x9a028dd0, 0x658d180e, 0x7c9c49c7, 0xfaa225aa, 0x7c578fe5, 0xc8ff5c4d, 0x1667da4f, 0xe7c0aa48, 0x3f04e0e6, 0xb256641e, 0x0065e9f9, 0x809e6c02, 0x2e65b917, 0x7a61b8ca, 0xd7353172, 0xb74cc230, 
                0x22034a2a, 0x91f8c490, 0xa87aca64, 0x0118e2fc, 0xd0289c89, 0xa9feaafd, 0x076132ff, 0x75316c5d, 0xd3e2d775, 0x925b3065, 0xbbd987d0, 0xbda36c22, 0x1a2ade14, 0x37f750b8, 0x4d1c58f0, 0xd80a3ddf, 0x9e981d55, 0x2579bfc1, 0x90dfbe17, 0x26664123, 0x2b3690b2, 0xcc6ba057, 0x326f19c3, 0x6b21b959, 
                0x8a32e7cf, 0x757c5397, 0xcec596a2, 0x7cd657d9, 0x1a321482, 0x4d42a5b9, 0x4c37a940, 0xa12fed61, 0x90133797, 0xdb47a485, 0x1c88ff5e, 0x9dbeb2f7, 0x51d68bbd, 0x08bac776, 0x8aa3443b, 0xafb22550, 0x468f779a, 0xbc526acc, 0x4945a9f1, 0x6cdb5073, 0x8d5131a6, 0xf84a4a2f, 0x82373818, 0x74838afd, 
                0x41ab436e, 0xf19e030c, 0xec0d696f, 0x7d31e315, 0xd168e51a, 0x6342eab2, 0xb38d6af3, 0x22ccd3db, 0xa63cffee, 0xdf0e2cca, 0x3ea485e8, 0x969b8543, 0x8045f2f8, 0xe3b444a3, 0xe8483be4, 0x89493942, 0x971c29a6, 0x5c1eecab, 0xed73e23b, 0x5f1dd5c3, 0xf69bad8b, 0x1a52ea60, 0x81215d06, 0x1faf7ea3, 
                0xf187f1aa, 0x5ae54ee4, 0xecdb7ba0, 0xf9662824, 0xe32b466c, 0x607e6ed6, 0xefd58014, 0xcbc68ef8, 0xd281551a, 0xd0ebac90, 0x095500e7, 0x51568112, 0x30cbcbe9, 0x3cc38eae, 0xc339e056, 0xe3c2f676, 0xe35a9b64, 0x9b0d1e76, 0xe65339a6, 0xa105be92, 0xbc203461, 0xaa308d81, 0xe9f73f31, 0x675a3d2e, 
                0x344cabc0, 0xdd80048b, 0xed4a158c, 0xa06b2812, 0xeb10fb59, 0x68582575, 0x51a46dbd, 0x82a6c74a, 0x6276575c, 0x9e33e5f7, 0xace88484, 0xf6b2b6b8, 0x6de2e783, 0x75b119da, 0xc1ea05f7, 0xca95a7b7, 0x830692ad, 0x492a52aa, 0x5c0b0e5d, 0xa0c7cb76, 0xb8a7b9bd, 0xd76b9d50, 0xdb732f00, 0xb72d8c7a, 
                0xfd0eee19, 0x594f2761, 0x2f753b06, 0x02b3b39e, 0x74b112f8, 0x03835b01, 0x51759bf3, 0xfa9694dd, 0xd022a95d, 0xae7b2fd8, 0xdb6dc66a, 0xa36940d9, 0x7f9eed14, 0x7b85c89c, 0x416fc067, 0xaa61f8d0, 0xe96bd046, 0x42c96a5f, 0x1792a8a9, 0x9f43dfc5, 0x1837637f, 0xcfaef982, 0xd7fc826a, 0x278518cd, 
                0x2f9148f9, 0x64b22bb7, 0x97c5ea91, 0x8c7e4b2a, 0x4a341b6b, 0x67f5dafd, 0xfd8d6e17, 0xa61083f9, 0xde66462d, 0x8baff658, 0x1291df73, 0xd349a347, 0x4aefdfdb, 0xb224a31a, 0xb6ee8436, 0xa8e42f66, 0x211b7d7e, 0xd9d021bc, 0xe441a627, 0xb5a23d59, 0x06a47dd4, 0xd1c514c4, 0x87b22893, 0x626a95dd, 
                0x5164bd62, 0x09c7e7d5, 0x0a974211, 0x5992764a, 0xa91316f9, 0xd6c6d2f0, 0x3c5a381c, 0xb33df14e, 0x53808999, 0x60620e08, 0x13a4a8c5, 0xf66118de, 0x4ce48425, 0x1e7f3cd1, 0x59f6391d, 0x62da1827, 0xfeac0a63, 0x7ff90695, 0xadfeb3d3, 0xba63cf4a, 0xfa334854, 0xc9548f68, 0xdd433044, 0xb618f68e, 
                0xec6b0d7c, 0x284fbc7a, 0xb865f25f, 0x3111ee31, 0x682f7952, 0x901755bb, 0x3ad94a77, 0xbf19b917, 0x9192bc84, 0x4346521f, 0xcb41b31f, 0xbb38d6ad, 0xd2cec305, 0xce118cc7, 0xc75fc2a0, 0x521292dc, 0xc96accb5, 0x6bf8e078, 0x6628f004, 0x78a84e63, 0xbbbaf816, 0xba76fe0a, 0x57439e1f, 0xe54a5ac4, 
                0xaac5a06b, 0xbdc57f46, 0x81933085, 0xd0a29d4c, 0x72542397, 0x01fb6ac5, 0x4ebb2292, 0x7be3c194, 0xa4ab2393, 0xf5550da0, 0x50bc234c, 0x3bca7b46, 0x250dd20a, 0xf8b60908, 0x3001722a, 0xf590cdcc, 0xfb2e6342, 0xb07cbb4e, 0x836a852e, 0x1d442b86, 0xcf5339a7, 0xca4ba329, 0x7af2a91a, 0x5a18591d, 
                0x2a67aaeb, 0x2c36acfc, 0x88786292, 0x75970b7c, 0x5cf5a6e2, 0xbdc09eff, 0x0fc24cca, 0x9d1a5b83, 0xa83323a4, 0x323257fe, 0xf1ebcb2d, 0xcb077399, 0xd1af2024, 0xf8defde1, 0xad868941, 0x15fa7495, 0x274209df, 0xbf5a59d0, 0x4b49d61f, 0xd56f6dad, 0xaf1cd526, 0x777a4e2e, 0x116b99f7, 0x12d8bfa5, 
                0xde7f38f3, 0x0d89beab, 0xbbfbf6e0, 0x0cea9506, 0xb6e4db9c, 0x47f28127, 0xaa242939, 0xcd889293, 0x646ec2f7, 0x0cbddae0, 0xa0987ef7, 0x06bf24ac, 0xc7633a51, 0x492c6944, 0xa906829e, 0x50e20207, 0x1f3c95a9, 0x0aa06091, 0xadc32d4a, 0x174794c0, 0xc22ef80b, 0x081d2391, 0x1a647603, 0x3615380a, 
                0x046c9096, 0xf7e1790b, 0x391cef9d, 0xdbe268e2, 0x700b6f4c, 0x580d8683, 0xebb56b58, 0xbb9940f2, 0x6f464009, 0x7c8446c0, 0x8af6e9ff, 0x030acd8f, 0xa4b35bc5, 0x398ed314, 0x9102fdce, 0xdcf5ef6a, 0xd78ee60c, 0xac3e365c, 0x19c36802, 0x7f4d841b, 0x47fad56b, 0x8f0f75c3, 0x6928e447, 0x932bc68e, 
                0xc1f5a0f3, 0x508191f9, 0x63ef5e86, 0x0e255c30, 0x63b54b5c, 0x45c12bdb, 0x0d7fb5ce, 0x177bca63, 0xe3eeb8a4, 0x78f63910, 0x13df0554, 0x06aebbf1, 0xba7072c0, 0x7542e1d9, 0x9b050a93, 0x6af48744, 0x45db6fdb, 0x61175d5f, 0xfa3a48c7, 0x2e6dd1aa, 0xc2c4b2f2, 0xd35b8e0c, 0x16a7cd3e, 0xd28ea294, 
                0x41f97875, 0x34553e22, 0x84a8d982, 0xe04148da, 0x166c771f, 0xb00c305d, 0x581d3e1c, 0xbd5447a9, 0xa1f2fdac, 0x1b96ab66, 0x826f75be, 0x9610485b, 0xc0856564, 0xd5e70914, 0xce66e1c9, 0xcd638c84, 0x1984e7c5, 0x45f6f089, 0xdc025757, 0x5db4006b, 0x81181ca3, 0x50c547e1, 0x013b7e6a, 0x735e48d5, 
                0x5eb66031, 0xa2b9df0f, 0x085db5fc, 0x9f91b7c9, 0x1758d648, 0xb930f619, 0x1d80328a, 0x507c4de0, 0x230c2828, 0x30866e20, 0xa44f4fe7, 0x801c919f, 0x9bd2e279, 0x51a04050, 0x7e13932d, 0xbadb05a6, 0x03981e92, 0x3767ba02, 0x01e8fee2, 0xcbfbe2b7, 0x272d9986, 0xb207adf5, 0x3beed25f, 0x580f58bb, 
                0x33fe8033, 0x6e7918d5, 0x399a7d73, 0xc1be322f, 0x32fb4701, 0xc2f1e540, 0xbe521b70, 0x4c87a16a, 0x37d91ce0, 0x426ac16e, 0x5215bc46, 0x49c8983e, 0x6918e130, 0xe9830dae, 0xa58484e8, 0xab66ef78, 0x5e14fe3f, 0x881a6f64, 0x58e954d4, 0x5f50ad85, 0x542d0801, 0x447dde9f, 0x5474eb0e, 0x682446a7, 
                0xd55167fc, 0xf007ab99, 0x2f5a4730, 0x83544efd, 0x69e688e7, 0x991f764e, 0x67808de0, 0x72575466, 0xaf921f9b, 0x104c469a, 0x9f172263, 0xdeb6966a, 0xe929a886, 0xbd05d75e, 0xde7872fb, 0x4ee51963, 0x3a1b8c9b, 0x5de5b967, 0xdc4e6ff6, 0xfb729a05, 0xc0c7e831, 0xf2cc556f, 0x860b505c, 0xa58554c0, 
                0x66567147, 0xe905aa99, 0x6e2b382f, 0x3711d930, 0x41ba24f9, 0xddf687d9, 0x4e2ccc39, 0xec7eedfe, 0xaa9da44a, 0x9bfe7ddc, 0xef428ae1, 0x08a9d63f, 0xaf042050, 0x27b50e9b, 0x2854f43f, 0x1a1b86b5, 0xd7a49d7a, 0x336a7ef7, 0x02c4f41c, 0xc71d4c9c, 0x02c8446c, 0x39056950, 0x0186aa45, 0x1aa66a6e, 
                0x3e2ad255, 0x6a79c75b, 0x4f163af4, 0xc4f4aef8, 0xe5145dd9, 0x77d5a744, 0x9ae95e09, 0xd4ddeac5, 0xd1643494, 0xe66d93e0, 0x3e1304e7, 0xe77273c6, 0x6058a50a, 0x7d2325df, 0x802683b7, 0xf7c76684, 0x374a1199, 0xe47cbac1, 0x5bd5a30b, 0xf911fb74, 0xe33c152e, 0xfd8c9b95, 0x28400c8a, 0x02c8ecc6, 
                0x01d43404, 0xbaccec12, 0xcc4cc25b, 0x3179120c, 0x8fe9754c, 0x347a48ec, 0x1b55c1f3, 0xbe44af2a, 0xcffbaf03, 0x34ec9888, 0x9d1b95fd, 0x7c34d847, 0x1ebce8c8, 0xf1c4113a, 0x519cbc2d, 0x65850da8, 0xaaff0bc0, 0x800860f3, 0x73701efa, 0x01af3371, 0xa9758873, 0xa3753191, 0x4743be4e, 0x0948a424, 
                0x28a04907, 0x48d2ad3c, 0x0e3f84db, 0x35cf49d2, 0x65d72dd6, 0xae04b103, 0x6437f502, 0xb7cf0d86, 0x4c9315d0, 0x30400dc4, 0x04fe2163, 0xd510b0aa, 0x2ef7d2bb, 0x120f2cfe, 0x716218ee, 0x413e3b93, 0xa88f03b0, 0xd13b7c2d, 0x1aa20e34, 0x5a826883, 0x03c05e72, 0x3e70d6a3, 0x20b9b7e2, 0xa1d141f5, 
                0x57ac4d86, 0xe0384acf, 0x4ef851a1, 0x7d1ff78a, 0x5e1dcb65, 0x98c08ed0, 0x44b0b947, 0xbc51f3c5, 0x82fc1164, 0x2ae5c651, 0x868e7a42, 0x5153a816, 0x4258a9bc, 0x4dd53d7f, 0xd313c753, 0xcdfbfb6a, 0xd03ae7ec, 0x646d9b06, 0xdcab4ceb, 0x900e83c6, 0x6255440a, 0x089247ba, 0xf10e84fb, 0xc885eb6d, 
                0xba9ba0d9, 0xfe802ed5, 0x9ba24966, 0x9f9f0002, 0xe82d36ce, 0xd73e03d1, 0x107f2fca, 0xae6aadef, 0xc26c8c80, 0x920f6579, 0x83d7784f, 0x6b708967, 0xeac6c30e, 0x1a6c515f, 0xfd259493, 0xd5175429, 0x8a29479f, 0xb63223be, 0x5ecf0cf0, 0xc2fffc05, 0x11f539a7, 0x83026174, 0xf5eab3f2, 0x51a9a8bb, 
                0xe7b4d5bb, 0x4fa9f8a5, 0x04cf2743, 0xda9da599, 0x2bc6095a, 0x0d9123f0, 0x2987652b, 0xf78cdada, 0x1e2d50a2, 0x90d8e559, 0xf37f5aff, 0xe719a93a, 0xb8648fc4, 0xecbc27b7, 0xd369927a, 0x8c463c8a, 0xef36a7b3, 0xb67cdaae, 0x639f0672, 0xc60fd5b7, 0xc0a1c0f9, 0x1b55e7dd, 0x3c47a6f3, 0xf262bf48, 
                0x8ece9978, 0x6a142606, 0xa5f26a79, 0xef55dfd0, 0x5084ca00, 0xf573b934, 0x7b1aa6c3, 0x8cb84088, 0xb13f33ee, 0x94669de2, 0xda04e42d, 0x0f4e7810, 0xf06f2f16, 0x3abaaa6d, 0xa9f38353, 0x987cd5b9, 0x89b2b132, 0xb3c45398, 0x31df8785, 0x97b11158, 0x718a1565, 0x3e298674, 0xe85f5f6f, 0x5aa92026, 
                0xb1709b0f, 0xa0ba9f6e, 0x0e52a62b, 0x43bc9634, 0xb4ddeaef, 0x7efbb6ce, 0x3c94defb, 0xc8b71905, 0xbe84a8e0, 0x0afcfe76, 0xb39a7f48, 0x27cb7deb, 0x02cd401c, 0x22abf2c8, 0x815d7557, 0x92226b3f, 0x4abd0378, 0x320e9c2a, 0x0e1373a0, 0xe4b39f48, 0x2a84461b, 0xbdfef3b2, 0xb129b386, 0xa28c0c19, 
                0x78d12db1, 0xbd042f21, 0xd5a43a92, 0x9f865427, 0x492b5684, 0x1d87ab21, 0x72696fd6, 0x31b11a7d, 0x7c9cfd91, 0xd4f32d44, 0x831ab3c2, 0x39cfbf77, 0x31b6c6b9, 0x6b11f091, 0x7027cc25, 0x3a8eb38e, 0x9ffd355a, 0xe7382433, 0x97fdf58c, 0x3bf092f5, 0x87ea79b4, 0x6a65a865, 0x00f9c35e, 0x5926b92c, 
                0x97f76e8d, 0xbac181f9, 0x3251c6ed, 0x5473f742, 0x8cfc2334, 0x13f081f8, 0x0965f5f1, 0x4aba6105, 0x932c8cbc, 0xa90a2b6a, 0x1fc1dcb7, 0x766c8827, 0x86a78a79, 0xfe3272a9, 0x3265b411, 0xc02eee79, 0x0a707976, 0xa0409b4b, 0xba6cced7, 0x3e0e115a, 0x8dac420f, 0x7da9e9ef, 0x8e39d75c, 0xb3772b8f, 
                0x028aa587, 0x7dcbfc06, 0x8e6d4ca0, 0x5471ed74, 0xfb4efa63, 0x3cf54fb2, 0xaae67206, 0x257420c6, 0xbe855acc, 0xba1e5abf, 0x63651c86, 0x73ab4918, 0xef35f249, 0x4e5fa0c9, 0x613a23f0, 0x53dd810a, 0x6b15330c, 0x80c10bd9, 0x13c4b030, 0xb3d20149, 0xfee4087a, 0x14cc0041, 0x716d8792, 0x1d763357, 
                0x49cc8686, 0xa55f45c1, 0xcafd8dac, 0x29d0d808, 0x82accda8, 0x3a8a3936, 0xc6e3ce96, 0xf9035f5f, 0x423d9a27, 0xe1175d58, 0x4615c158, 0x98ab126a, 0x2b004452, 0x13f2f6a9, 0x0b797335, 0x15fc116b, 0xd5c7923b, 0xa81ab2d2, 0x46526e89, 0x30eccd2d, 0x93796b44, 0x7cbce8c1, 0xa653fd75, 0xd72a8efd, 
                0x4640611b, 0x79e536bd, 0x02bffba3, 0x769965ad, 0x3eff7563, 0x03f73af2, 0xbd804cd7, 0x9b3dec93, 0x1e4e0f53, 0x3eaea57b, 0xa1e2ff9f, 0x1dcbb5fa, 0xf62a1a93, 0xf5f73cf8, 0xc0cd7da3, 0x501aa8f4, 0xf101be19, 0x00c2f119, 0xff5e6d86, 0x289ecd5f, 0x9d52daf9, 0x5375ca11, 0x5ab03c37, 0x8e17b35c, 
                0xa05e2d50, 0xe922e17d, 0x65a48d9b, 0x1d79af49, 0x57756064, 0xff491849, 0xe18e4e9f, 0xaec6114f, 0xf9b18566, 0x2453d491, 0x881fdc8e, 0xb3c2b6c8, 0x9d51312a, 0xf4b88adc, 0x3853205a, 0xf10704d1, 0x7747ae2f, 0x26aa1c1e, 0x968a13fa, 0x61842ed6, 0x46123d26, 0x44da9539, 0xb0e9b183, 0xa6a3efca, 
                0xb94482ae, 0x3ead5652, 0xb2a14d1d, 0xffdd6c06, 0x267454f4, 0xe5ae479b, 0xc6a83fa7, 0x8a6bafe5, 0xad956684, 0x11765bb5, 0x8d23bb70, 0x7b3b061d, 0x00aae32d, 0xdcf55e1e, 0xed175b90, 0x02c93d26, 0xb6735ec9, 0x6defaaa3, 0xf70ae493, 0xbfbe8e94, 0xea6d930c, 0x3dd332ca, 0xf57e71f7, 0x5a8ee015, 
                0xa0a71db1, 0xec1a21b9, 0x07b899eb, 0x18db44b3, 0x7cf23c90, 0xc3be3c53, 0xe0695efa, 0xe7851d08, 0x8e749638, 0xdff8d555, 0xfc9f1532, 0x0a3b6fcb, 0x8d3ba8ef, 0x263e65db, 0x29af4753, 0x3021a729, 0x5665c989, 0xf89b937b, 0x2ed4c2b6, 0x80cb4afb, 0xb37b8cc9, 0xbebbdce5, 0x242cd888, 0xcc6ba03e, 
                0x6bce8a24, 0x350a2856, 0xc294fc54, 0xee79e074, 0xe1cf38f2, 0x40ea94f4, 0xa4d459d4, 0x37b6cd8e, 0xd778034e, 0xba08e5c3, 0x7546aceb, 0x9de119fa, 0xb2a4eeaa, 0x324b9f8d, 0x304fc008, 0x5dc5d0e4, 0x51ad7612, 0xb2863663, 0xf011e5da, 0x5cc818c6, 0x7f6472be, 0x2f528299, 0xa8ba46de, 0x1fa0c709, 
                0x48a029e0, 0x231d479e, 0x90e61d27, 0xc6243a79, 0x59f73a7a, 0xcbe7d14a, 0x0ed9fc8b, 0x651ce8a0, 0x677c9879, 0x660bda8b, 0xe571ce10, 0xa41c6d1a, 0x43cfe642, 0x6cea9afb, 0x556c4b45, 0xd6cbc996, 0x77f10da1, 0xb6dbe4cb, 0x41a2c913, 0x5a9e07eb, 0xddda6793, 0x627aacc9, 0x1f2cbc43, 0x2352db58, 
                0x1bcc9aa6, 0xcc88cdac, 0x2770253d, 0x73f24d71, 0x90ae9dea, 0xa6c2526a, 0x38809ae5, 0x2426f37a, 0xb41f63a3, 0xb699efa8, 0x0469d01f, 0x35859f6e, 0x2486ea48, 0xcce50a88, 0x1d6b4209, 0x31ac2573, 0x7070fb26, 0x04d5af4a, 0xd6aca7b0, 0xc767c199, 0xa4b29478, 0x376ca232, 0xbbc59073, 0x0a809757, 
                0xfd50af73, 0x950b8f67, 0x32e8da91, 0x6de52866, 0xb8d6d092, 0x0e1f1fce, 0xa50363bf, 0x6492f6e8, 0x90dc0934, 0x1a5549b0, 0xc4d317ef, 0x1b374700, 0xe112cd9b, 0x490619eb, 0x3de8e77f, 0xffdb7e0d, 0x72278fe1, 0xd09c09c3, 0x1c878fa6, 0x92c88f81, 0xfe0b8ab6, 0xbf7293ec, 0xf960b1cc, 0xc1870bfc, 
                0x0671bc45, 0x0c2596c9, 0x49d2dc4a, 0x8ae395da, 0x74de2a9f, 0x51aa051f, 0xb33efcad, 0xeabbf59b, 0x60663177, 0x4b6a8f2a, 0x6b093d54, 0x44598287, 0x4d6381d8, 0x46a3f99d, 0x311d73c1, 0xf29812d2, 0x39af5e34, 0x781bc26e, 0x50fb4bc4, 0x68d00869, 0x4e52e09d, 0x8247e427, 0x4d59739e, 0x050ac8c4, 
                0x70730ec8, 0x15a809dd, 0xdcc83e54, 0x27d510a1, 0x8a1306e5, 0x4c8f6709, 0x8db7707c, 0xa31f6ac5, 0xf98a4a4f, 0x954334b0, 0x99b08668, 0xa242f3b7, 0xaa20c6d6, 0xcf89255f, 0xade9093e, 0x455390b4, 0x259ca04a, 0x1fd6d93d, 0x4d95aa3a, 0x268d2339, 0x9203c3e1, 0xfa268578, 0x57ccc3ea, 0xa2ca90f2, 
                0xa20f2bab, 0xb3d00473, 0x004fb4aa, 0xf318d885, 0x0a67abfa, 0x800953c1, 0x9ff7a81c, 0xba8d6568, 0x637fba7a, 0x78dc1d60, 0x7a5771dc, 0x8771a757, 0x5eb7bde4, 0x80f98ea3, 0xf2cf0f7c, 0x87d85e7b, 0x13ea707c, 0xfe6a86b3, 0xfa18e699, 0xfc82bc14, 0xa72df4ba, 0x65fe3ce1, 0x25c3c0f1, 0xcbadd018, 
                0x89d2d40c, 0x656a4a57, 0xc7238acd, 0xe24e9a22, 0x9d677ace, 0x32e06681, 0x20c8d504, 0x5ff48206, 0x0834ae15, 0xf1f52712, 0x47c9053e, 0x79addda2, 0x123480d2, 0x945aa54b, 0x14cb391d, 0xbdd88d97, 0x40c9afe6, 0x47a4fd5e, 0x5b386351, 0x3037986d, 0x8f5d7d82, 0x428e93c2, 0x2131ba39, 0x2c822417, 
                0xf6ffde6a, 0xea40d041, 0xa09fc652, 0xc1a43480, 0x4520b792, 0x07178630, 0x798472be, 0xee062342, 0x33fbe09d, 0x4139d014, 0x2bd9d479, 0xac10e741, 0x1112f754, 0xab9b3824, 0x0d3b94f6, 0x059fa8f8, 0x04f71716, 0x62836d6b, 0xb530534a, 0x4d8dcc8a, 0x8d196dab, 0xc95c640b, 0x89c03f98, 0xe306cfe8, 
                0x5c9a8217, 0x8256e00c, 0x674e2f7a, 0xbac51e42, 0xa888c98f, 0x2a0c570e, 0x3c5c1ba6, 0x552c5f69, 0xbd574821, 0x64e34bf2, 0x5cb5d076, 0x32fe2e04, 0x31717151, 0x54272f05, 0xcc63d567, 0xa17b994b, 0xeb1e983f, 0x5519b609, 0xe5d0229a, 0x72c34cac, 0x8d3ec51e, 0xb97931d3, 0xa1603fee, 0x34da80b5, 
                0xce9146a7, 0x77cd8a9b, 0x6f8278b1, 0x14f98490, 0x21bfbeff, 0x1a080d4c, 0x8e1369d2, 0x5d992429, 0x138f6c92, 0x8cfd36c2, 0x461c86da, 0xf8d77d0a, 0xe0b772db, 0xeec2d9a5, 0xeaefde45, 0x0d002c76, 0x3b44538d, 0xb3c0133f, 0xedb0f04b, 0xc17c0b13, 0x48b9464e, 0x01c5dc8d, 0x22171b69, 0x979656a8, 
                0x73ad86ef, 0x200d99f4, 0x4047c80f, 0x0e3ab577, 0xd18ec9b9, 0xc7e8f64e, 0xb702b484, 0x80535b9b, 0x568570fd, 0x4f88474c, 0xcf75ee83, 0xb6c81704, 0xb0dfa758, 0x47f68432, 0xbe524d63, 0x2cdaf625, 0x0ef3ac9d, 0x552592d3, 0xd9f4276e, 0x79965b6d, 0x67f76455, 0xbf791f84, 0xdab2e48b, 0x5e6face2, 
                0x9931dcc7, 0x609c1982, 0x84e83184, 0x49a94139, 0x315ed00e, 0x34c5740f, 0xe7a45340, 0x784f372c, 0x414a9b8e, 0xe77a7ac0, 0x5db4d1b3, 0xaaf83aa1, 0xb8d883f3, 0x787c68d8, 0x1142bfca, 0x299798a2, 0x755d2aa8, 0x924908a7, 0xc1485cbb, 0x660df332, 0x9a4d6b17, 0xd30c2ff5, 0x1d8afc85, 0x0a924ed8, 
                0xeb924315, 0x26eb7497, 0xf10d5df9, 0xd9d7ec53, 0xeab031ce, 0x20716640, 0x149a733d, 0x9074282e, 0x935dc9e9, 0xc683ceb3, 0x3ea36799, 0x73468dbc, 0x415010fe, 0xd63e8b8d, 0xf46658bf, 0xa021aa1a, 0x86aa398b, 0x6106c96c, 0x0b1adb5d, 0x2e41edc4, 0x0616ef47, 0x35f25867, 0x07ecda68, 0x7f9cf849, 
                0x3f55dd43, 0xf452aa7f, 0x505a7a57, 0xf4642853, 0x0ae7ef88, 0xcf7848bb, 0xe504fb90, 0x1292a017, 0xf86e5009, 0x1db7f1b6, 0x7bd07267, 0xa0192204, 0xab126981, 0xb8a66c9c, 0x38b0bc19, 0xd5fc4364, 0xa1c83651, 0xe5669dd8, 0xefa7042c, 0xf9c917d0, 0xa6c941b9, 0x3bee68eb, 0xfa68e052, 0x3f3e3b18, 
                0x8a851c13, 0x731404a6, 0x1f36110f, 0x64e6af8a, 0xb5bd2ff1, 0x3df2eb9c, 0x1f14b86f, 0x5c0b7cbb, 0x6f7c64ca, 0xbc831255, 0xadaddfdd, 0x8525a868, 0x3a816540, 0xed588188, 0xb4cda638, 0xeafbf335, 0x1b5f57b0, 0x32c11276, 0xb9f39c35, 0x22fd2356, 0x016e5d3d, 0x1994d8dd, 0x2a684cae, 0xdad6d5e9, 
                0x2e68799e, 0xa8149228, 0x4788dbad, 0x04000644, 0x87d76c45, 0xbcdbab5a, 0xffadd041, 0xad97b1aa, 0x1d113d1b, 0xca59dbf8, 0xefb70cac, 0x074b989e, 0x29a5d826, 0xf4a45666, 0xfaa779b2, 0xda1f954b, 0xaa57c266, 0xe5f01a1a, 0x0ad9cd92, 0x260edd42, 0x1f7fa336, 0xde261b5b, 0x7aa01378, 0xdce2c3df, 
                0xe9d34ecb, 0x9915c14d, 0x60b0f61e, 0x29b18806, 0x70d73ad5, 0x7868f268, 0x75f17cbf, 0x4cf45826, 0x886ef17a, 0x60ec9774, 0xe4083290, 0xd3025c0b, 0x11e6db22, 0x770ddafe, 0xb9e24e73, 0x49c65718, 0x11f191e7, 0x1beb5e19, 0xd5e1599a, 0x811a564b, 0xbf1ef507, 0xf5172c90, 0x17073f4a, 0xe38f01d4, 
                0x7c2f33c4, 0x4deceed8, 0x046a8ccd, 0x01240286, 0xf7f52fd8, 0xe29f52e0, 0xcc28d185, 0xe15f0cd1, 0xcb9969c1, 0x267e5dca, 0x9cc8c9b3, 0xc420ac5f, 0x78751eb2, 0xba9d4c47, 0x00a5276b, 0x5309aff0, 0x8a6293c0, 0x480d7850, 0x51a1f3ef, 0xcb931bcd, 0xaf0dabde, 0x750fd2e5, 0xb4d78e45, 0xdbf3ca43, 
                0xa1711913, 0x0e66b485, 0x9d7b07a2, 0xccf35e3d, 0x8fcb5da5, 0xe7177856, 0xccfba684, 0x05790723, 0xe9c68173, 0x92c5f001, 0x64dba8cb, 0xca7400c2, 0x17337781, 0x189fd693, 0x532946cb, 0x044138d7, 0x0f25b168, 0x0ea4d611, 0xff4a7508, 0x6988403b, 0xd01a927d, 0x985aedf2, 0xb1c737ac, 0x2e6bd7bd, 
                0x48327287, 0x70bb6360, 0x7b988d1d, 0xbda0f17c, 0x6da4e938, 0x2aaa0619, 0x8feb4a3c, 0x07712eee, 0x7d817ef4, 0x54c1ffd2, 0x8aebb7e1, 0x5986cafa, 0xc93f7f5b, 0x4cd46218, 0xbde8af8e, 0x64e6a77b, 0x2453b918, 0x61715072, 0x21be3afc, 0x1de0163a, 0x3cc2cab0, 0xdd000f07, 0xb5a97001, 0xcbedda04, 
                0x179e5696, 0xafe9b1f2, 0x1ada65ac, 0x7bc9975c, 0x13e2693e, 0x37791fca, 0xff1713fa, 0xa1b3fac1, 0xc338f2bb, 0xdee5b849, 0x8f4a4353, 0x404a273d, 0x5268e384, 0xd83ecf1d, 0x9b458613, 0x0be8542d, 0xfef9ab2d, 0xd4b4e8e2, 0xe5dbacdf, 0xa3898f8d, 0xedae78ab, 0x365fe65e, 0xc582e7bf, 0x92f20282, 
                0xf8de5700, 0x1d9a69cb, 0x26be783b, 0xcba3b133, 0x5d2bc847, 0xaf2f4033, 0x9e0fd306, 0x128840d0, 0xb80c8b2e, 0x80c38d97, 0x534f8949, 0x0cb2977b, 0x68612e53, 0xcaca9c69, 0xef229c64, 0x3adfa56d, 0x1a81520f, 0x954a0904, 0xe2921a25, 0xf02763f9, 0xcb8cfaf5, 0x6d4bfa3e, 0xffeff0f7, 0x544d1ec4, 
                0x9a6a8fd6, 0xf9571444, 0x8d66b617, 0x8700aee0, 0x7b29ea30, 0xb40be434, 0xcfa30c7c, 0xa7ce4395, 0x39d83271, 0xfbdb4905, 0x60e48c41, 0x9d04ac9f, 0xe161acde, 0x4366ce64, 0x10671c0c, 0x2168ae6f, 0x74ab018b, 0x860036ec, 0x54bffd1a, 0x2ba38cb4, 0x8ef7e747, 0x07fa7e15, 0x9ee45657, 0x2e730825, 
                0xcb8a02ca, 0x09c6d3b6, 0x7718dae0, 0x0cfb9de9, 0xd0e2e509, 0xe70eda33, 0x4111461b, 0x409a6f00, 0x274e36dd, 0x30386ce2, 0x5be07c03, 0x548233af, 0x0aa0916c, 0x092b6005, 0xf000ded0, 0x218ac0f7, 0xd11d8184, 0xaa71963d, 0x5aaa7306, 0x1bb1b968, 0xaa4c5e6e, 0x73927f3a, 0x943cae8e, 0xc8f6c853, 
                0x6a54fa6f, 0x6eafcd65, 0x9aa1b972, 0x106d80b4, 0x252106ce, 0x88e93385, 0xc5fc2a20, 0x68577fec, 0x30729cc8, 0x25ba6f3f, 0x12b7e979, 0xcf87c0dd, 0xd13ad6b1, 0x4ed00379, 0x446768b8, 0x8beb4840, 0x5b50a252, 0xc87b1e05, 0xc37de630, 0xe94e635d, 0x1a576a26, 0xae2597ed, 0xcb51b184, 0x23c41af4, 
                0x7f66a345, 0x009d9dcc, 0x7c9085a7, 0xf19b3000, 0x4f16b87a, 0x8acd09ea, 0x36797cf1, 0x64c468b9, 0x94422fc5, 0x534c1f40, 0xc0e448f4, 0x87bb8784, 0x766976e1, 0x411fc196, 0x7dbf19bd, 0xcfb639cb, 0x337c50ae, 0xaafb9ffa, 0x18a1bcae, 0x0ce5a895, 0x1316f546, 0x91d0db72, 0x331b0d66, 0x12bf832b, 
                0xb75579ab, 0x8881a857, 0x2f8c3250, 0xf06fadbb, 0x93867630, 0x5aec4abf, 0x70a2f515, 0xfa0929e8, 0xadd7d8a6, 0xf4f2182d, 0xefdf4cd3, 0x16bd9f58, 0xd7f21be0, 0xea92acbe, 0x82fcbf0f, 0xcfb8a7b0, 0x71890358, 0xd2c4fed5, 0x7bf213d5, 0x075e323f, 0x2906aff7, 0xf3bcc7fa, 0x8b9cc5b6, 0x23742631, 
                0xa250aec9, 0xabb2f43e, 0xc5f24b5c, 0x54182642, 0x68096678, 0xddbeef50, 0x36338a3e, 0x1b72bb30, 0x07d7a168, 0xbdaa03d8, 0xa3b19bfc, 0xc1a27528, 0x3d24304b, 0x18b91c03, 0x2fc70b36, 0x3e183de3, 0x142d429c, 0x9e41f6c6, 0x6b0d8b9d, 0xdff1cd35, 0x14e254d1, 0x0a9cf0b6, 0xdd4690b7, 0xecbea28f, 
                0x9321de7a, 0xc6e737e4, 0x2eeaa9b9, 0x90a834aa, 0x57ef5483, 0xc692d238, 0x4356c755, 0x382719c7, 0x8dabe3bc, 0xfaaa3730, 0x1d30aeb9, 0x31d0402b, 0xdc64bb6f, 0x49a04384, 0xb72ed51e, 0x4489dd5c, 0xccfc4f94, 0x7b40908b, 0xe12a7cd3, 0x29d91536, 0x9f92f5be, 0x859cccd9, 0x6615c4e8, 0xafc0e4db, 
                0x060b07bc, 0xc1a32280, 0xe405c4b1, 0x5f4a05f1, 0xd393e489, 0x3d2b65a9, 0x57d637f6, 0x5b5d450f, 0xb33679fd, 0x32d6c0cc, 0xe51b3d94, 0x656b2a4c, 0xc782108e, 0x54750490, 0x4a13a048, 0x6db1f5af, 0x4f43913b, 0xe1066f75, 0x8e271506, 0x98fcd460, 0xafaeeaf1, 0xd0a1bedf, 0x7070f2e1, 0x669d0487, 
                0x89584f02, 0x035c004b, 0x02c1ecc5, 0x593933d6, 0xa416bdfc, 0xd42c688e, 0x57cf532a, 0xfc73551e, 0xe937c902, 0xdbb86547, 0x61b2f74e, 0xec1f3360, 0x735c393b, 0x217d032b, 0x828fbfe8, 0xf9588ad4, 0x990716dc, 0xac76c0a5, 0x8f92d44b, 0xfa0f3890, 0x609460e1, 0x5d1d9606, 0xa274b117, 0x5d8420cf, 
                0x0e741b50, 0x0330329d, 0xc5eafec2, 0x67b80c35, 0xffc2cac5, 0x61ed2094, 0x6536bbee, 0xfc9edfde, 0xa31a5321, 0x2175daa7, 0xcb3ca0e0, 0x37525576, 0xa454d468, 0xb9a7ab78, 0x65df0d5c, 0x9d875bb5, 0x99af57b6, 0x500e97ea, 0xe81f08d4, 0x69fd47e9, 0xe05487a9, 0x8a97aee1, 0xd70e1395, 0xb64e48b5, 
                0x7d5fa274, 0xc5a483d3, 0xf220a7b2, 0xb6ed8743, 0x23e1f41b, 0xf7b80d78, 0xd9ee3379, 0xb4417691, 0xa5e83143, 0xc02346b5, 0xac252896, 0x8f6f069e, 0x8155f991, 0x1302b8b1, 0xa854964f, 0x55141c38, 0x5fdf4d3d, 0x6b1e2e8f, 0x6de6bbcf, 0x16ae9d3b, 0xbe45bbef, 0x060e948a, 0xaee84b1e, 0x131ccc04, 
                0x505c3551, 0x283bd681, 0xe06a24a3, 0x2a2434f0, 0xe966fa43, 0x5164544f, 0xb2ef9dee, 0xf836253c, 0x215154e8, 0xf4560f9b, 0xcc0644c1, 0x6c6540db, 0x100c7234, 0x5fd9e709, 0xf96b04e8, 0xa6a8dfe4, 0xa2b29f97, 0x3543d667, 0xef6e432e, 0x30f50083, 0x83e5b188, 0xd13d0dd9, 0x0a147c71, 0x607c28da, 
                0x74934706, 0xe0331fb4, 0x5b2d97c3, 0xc2c8b21d, 0x66bac8f8, 0x23f774ff, 0x825d21eb, 0x908c070f, 0xbbb9a412, 0xb1ee301d, 0x168eb863, 0x68da2f5f, 0x36718445, 0x0ef50679, 0x70980f17, 0xd996c16e, 0x142ecbce, 0x57d921b0, 0x47261757, 0x0f4be4e0, 0xc36d9fd9, 0x25e0af2f, 0x7cdb045d, 0x7b9d59b0, 
                0xa2ba8958, 0x7ac38818, 0x70e21303, 0xedde2a96, 0x1565dd4e, 0xb3b21af5, 0x6594ab31, 0x0917f23c, 0x4d97076b, 0xc1d486dd, 0xf89bddf1, 0xa6cae209, 0x1f3098e9, 0x16930e3d, 0xfb83f04d, 0xa21263a5, 0xb2a59138, 0xad91848f, 0x1b7f05b9, 0xe24faa79, 0xd6beb774, 0xade580c2, 0x27c82d61, 0xf619631f, 
                0x35c65ed7, 0x6613e25e, 0x62018f93, 0xf4b3e6d7, 0x92d19c01, 0xb5641c5f, 0xa7657522, 0xe041cabe, 0x98d71d8a, 0x9e0e1152, 0x57426349, 0xef05c7f0, 0x88f5d912, 0x30e0725f, 0x2cea53c3, 0x9b3d5322, 0x6e23c77c, 0x7b018169, 0x43314c3c, 0xedb09236, 0x19ba4022, 0x880a6ceb, 0x793ffe39, 0xa79f3219, 
                0xbd1661a3, 0x2ec22636, 0x5d99fa01, 0xfb1b166b, 0xdac74336, 0x5f6be2cb, 0x6abdcf65, 0x47ca798c, 0xa3214b69, 0xdd46c997, 0xe40d20aa, 0x3501dfa2, 0xd786a225, 0x13bccf28, 0xe5b90086, 0x2ba88ee3, 0x120e7847, 0x963cf0e3, 0x176d8883, 0xe5bc49d8, 0x927bdf83, 0x64b97718, 0xab110bb7, 0xda780824, 
                0xec82f579, 0x9bcd8cbd, 0x663dee46, 0x4ee92aa3, 0x3ec3119d, 0x589d0980, 0xbddd76c0, 0x20a04275, 0xb3f17f22, 0xc899b04b, 0x550ba21f, 0x2c4e6c7f, 0xc1c9d1b1, 0xef859333, 0xf4b17f74, 0x26f2db0e, 0x05b0f453, 0x630804e3, 0x950aeac6, 0x36f62c2f, 0xda3df44e, 0x4821fa65, 0x1d094cb3, 0xf07c571b, 
                0xdd12d8b5, 0xade08619, 0x89763bb3, 0xfede8795, 0x7d703fa8, 0x61db0075, 0x7667e67d, 0xb34e4df5, 0xf9e00f35, 0xceaa324a, 0x899a69a1, 0x681d23f6, 0x814004de, 0xd89741b3, 0x86c8361f, 0xb558735f, 0xf9c62a7a, 0xc0476525, 0xfbcdf278, 0x1d2fd6e5, 0x2db8134f, 0x31dc4d38, 0xb254b992, 0x45cacd0f, 
                0xc7194b38, 0x5fe34073, 0x4fd9795b, 0xaa35086a, 0xc611109e, 0xbcad7e28, 0xdacf271a, 0x8c17e6ed, 0x1143198b, 0x06c85e48, 0xe598bcef, 0xff9821af, 0x8ebe92f4, 0x21537abb, 0xb5706e90, 0x1bc589ea, 0x9600905a, 0xf760a646, 0xafa58470, 0xe6e3d7cf, 0x6abbca88, 0xfee6a45e, 0x4d503b7f, 0x88b229e1, 
                0xd12d6913, 0x84c6708e, 0x1b0d1960, 0x674892a5, 0x282687fc, 0xcccc55fd, 0x9166a9ac, 0x20b3d3e0, 0x7311cb2e, 0xb5da6e7c, 0xa733ab6d, 0xdc4addd9, 0xd6e41695, 0xcc8f6751, 0x78613c7e, 0xd8beebb9, 0x507d4541, 0x173e7000, 0x5508b35a, 0xc5a6bdd6, 0xf73a8e37, 0x33eb1586, 0xacf8d9b4, 0xf9fc2644, 
                0x4a725c2d, 0x37acb7d0, 0xd9ed33a3, 0x8d7f5b71, 0x8d80eca2, 0x44a9173a, 0x6f8a536c, 0xab4320ad, 0x8f6fb20a, 0x424a9476, 0xd9d4162c, 0xc1f61cf2, 0xd5efa74d, 0x01f49071, 0xdf189d10, 0x57a732e9, 0x1973091b, 0x123207f4, 0x5373de64, 0x460aeaa9, 0x7d5456cb, 0xacc56d59, 0xbb8f04eb, 0x031e9e68, 
                0xe9e787cb, 0x123543f8, 0x02c0b72c, 0x63cfaa16, 0x67145d8e, 0x19050068, 0x696d288e, 0x810eed5d, 0x0071e42b, 0x50381d21, 0x37d4a77e, 0xc9aba2df, 0xf9b30055, 0x80a4326b, 0xc813d0f5, 0xad3be34a, 0x4a3d70ff, 0x4169d6ee, 0xab773add, 0x727df822, 0xb8ad8d65, 0xf676f0e7, 0x4b3a886e, 0x8b2ea2bf, 
                0x14ab68f6, 0xff88469b, 0x42aa79fc, 0x33c3b903, 0x122f6a28, 0x2624cc44, 0xcd2d1d53, 0xa5d977f7, 0x4e4ffe41, 0x4b0a2fcc, 0x06c5cbcc, 0x07370fea, 0x82682cd5, 0xfefa3498, 0x5157d86e, 0x7dd006ba, 0x6cfe78b4, 0x764eba3c, 0x3f1d3294, 0x4fda225e, 0x36d02ab8, 0x081051c7, 0x3bf0519c, 0x2ea97d9e, 
                0x74437c56, 0x652c2351, 0x73a34d60, 0x59fe7635, 0x0c74e2b6, 0xa8ff342d, 0x0ccf6e04, 0xe3905c7d, 0x890c7da6, 0xb79e2d08, 0xcc182f35, 0xba6d52b0, 0xfaead005, 0x830025cb, 0x13012e1e, 0xfef153e4, 0xa9926336, 0x1bb65fbf, 0x3632a0fc, 0xf4e279a2, 0xfcefe2ec, 0x3e4e01b8, 0x28139cc0, 0xfe529652, 
                0x7e46e9dd, 0x020c52e4, 0x1e71e382, 0x7c3191e5, 0x3af07aa6, 0x493a208d, 0x4688c5de, 0x72b68a07, 0xcdb3f392, 0xbf41c35b, 0x16e4477d, 0xc64622c6, 0x5ef42bf8, 0x7ea9b48b, 0x36aa1b13, 0xf580f67b, 0xe9720890, 0x524cbc15, 0xbc8a8e73, 0xe74c5a52, 0xf3a2f30d, 0xe1020b7b, 0xb65adbe5, 0x1b83c2fe, 
                0x63bce6de, 0x8ff34a50, 0xbb1b65f1, 0xd711e845, 0x2dc7612e, 0x3fd9173a, 0x1dd6248e, 0x8324753e, 0x5ba44d67, 0x2f517095, 0x697741a3, 0x91074b42, 0x9a886e29, 0x9f0fb50a, 0x89137935, 0x2731d323, 0x65445a55, 0x4f4d2e7c, 0x28eef06d, 0xd27a6a7d, 0xa37d2e41, 0x0f7ae846, 0xf48283ff, 0x3e49aac0, 
                0x7d7a6884, 0xfe714c33, 0x4356d7e0, 0x69053af2, 0x472c8450, 0x0ac90dbf, 0x5d19d718, 0xbd8690d7, 0x718bc7e3, 0xa771666b, 0x7c259fa4, 0x6f020899, 0x16620a41, 0x07516e40, 0xc98d10fa, 0x0ae944f0, 0xc6d86451, 0x88162d37, 0x56b81f92, 0xf482b62d, 0x8d7f00e6, 0x0f8807b2, 0xa41a08c3, 0xe4678a25, 
                0xe8516974, 0xa9e03bf2, 0x99167051, 0x3d0a7d3d, 0xdecb6bd8, 0x3a224abb, 0x3649dbd4, 0x313927a6, 0x297ae216, 0x6abb07f2, 0x78249715, 0x2790c23e, 0x249d5914, 0xfa71f334, 0x4fe26c11, 0x2623156a, 0x017a0efd, 0x5e72f432, 0x281257a4, 0x70206036, 0x7ff4336b, 0xcf674ef7, 0xa01903c6, 0x65adcb80, 
                0xbdc7ac02, 0xf9da5885, 0xa6197e28, 0xfba9bc68, 0x5ad48044, 0xaf9574c3, 0x31e6953c, 0xe00191e8, 0x7f65e287, 0xe447567b, 0x51b7bb1b, 0x7b03ed61, 0x272d00ab, 0xf0901168, 0x08a1e2af, 0xc17890e9, 0xc2bd080f, 0xbb060e53, 0x436d2257, 0x71c67c93, 0x408165e1, 0xf1dd2220, 0x82dfa881, 0x547cfee9, 
                0x0e528bd7, 0xbbf3d980, 0xc6642518, 0x2faebe46, 0x5c4d1c1e, 0x9f6f0207, 0x7aabe213, 0x73d98667, 0xa90aed2d, 0xa81fd7df, 0xb5626621, 0x3245f214, 0x841bf509, 0x87c53018, 0x42fdaad2, 0x779ed41b, 0x8b03695c, 0xefcdf1a3, 0x3a3d9eda, 0xd990a917, 0xda3d7ef0, 0x9da2bd8f, 0x07529df0, 0x34f77bf7, 
                0xaf9e01df, 0x9a0c7311, 0xfd8ac698, 0xfa8b0b6c, 0x1aa52526, 0x0f4738ed, 0x0be708bc, 0x7671057e, 0x7a2e689b, 0x6da9d34a, 0x01dbcf9c, 0x83ee4f95, 0xaed69e3d, 0x064155b7, 0xc72be713, 0x180c3b4b, 0xf1c75ba4, 0x78112b4f, 0x26c714ed, 0xcba4ebac, 0x05321ee9, 0x4aee141b, 0x55d6972e, 0x5ec3d068, 
                0xbf7a7f57, 0xb81247e5, 0x09c669a6, 0x9df2e40c, 0xed7cff58, 0xc7fcbce0, 0x726a0a1c, 0xddeac73e, 0x8e655959, 0x1f25a55b, 0x97eccefe, 0x072d7246, 0x45d7a1a7, 0x9937fccb, 0x3ecdeb26, 0x3c24b861, 0x16966467, 0xb820a31e, 0x9513fbc6, 0x02201f41, 0xbfd27dfe, 0x108442ee, 0xc60d43b5, 0xcfc99d16, 
                0xe4243964, 0xa055b421, 0x78374730, 0xcaf8702f, 0x417c89db, 0xc8daedc2, 0xb5302cc4, 0x2e3eb63a, 0x600a51f3, 0xb72cce52, 0xcf609e75, 0x52cbb937, 0xb61ba2b4, 0x6552fc7b, 0x85afc8ab, 0x2f8c0e98, 0xf130f34f, 0xff1ce55c, 0x2f1c1436, 0xbc456efa, 0xfff8c5c5, 0x075e625e, 0x92a69b20, 0x729f4976, 
                0x3269b307, 0x1f996a57, 0x11e950c8, 0xcd620889, 0x0b7da84c, 0x3d28b817, 0x68531e2c, 0x565f9f69, 0x69d242e1, 0xcdec8d11, 0x79fe6c2e, 0x63a47a45, 0x6063ab15, 0x4c42f0a5, 0xff3dfd3b, 0x0e4be547, 0xa6616596, 0xac812a58, 0x4506bb89, 0x00116d6f, 0x553e9d3b, 0x08055503, 0xda3cc8fa, 0xfdc11a9d, 
                0x99306f22, 0x3da4c1b3, 0x871a845d, 0xe0901a2d, 0xbfc335dc, 0x141c73b9, 0x6894c770, 0x6eb66789, 0x2246ded6, 0xd3c2013e, 0x7cb77a53, 0x5bd08b97, 0xefce5ced, 0xbc1fbd6e, 0x1d7d3ba0, 0x4fde2013, 0xc9bb48b9, 0xade1c31d, 0x1165348d, 0xca948058, 0x8e9107ce, 0xd7aa1417, 0x6dae00b8, 0xbc6658be, 
                0x6f7d77c8, 0xccd20921, 0x971eb9a6, 0x4fe3ad9c, 0xba8e3508, 0x9307dff5, 0xfd0de746, 0xbfde7405, 0x4325acdd, 0xc034124c, 0xe2888bd3, 0xddc7244a, 0x935bef34, 0x99ec4074, 0x7ea26d6e, 0xfe2f90d1, 0x57769127, 0xa619b50e, 0x552ac9ed, 0xd727e06e, 0x2d00a573, 0xf72c8343, 0x43ec3e60, 0xe8533f84, 
                0xf6b3fc01, 0xc3d5a7ff, 0xced6124e, 0x99930d79, 0xc05cfe85, 0xeda677fb, 0x223fa1f3, 0x70116a2f, 0x31431609, 0x107885bb, 0x13780de4, 0x467e3e13, 0xd28dbb32, 0x83e57eb1, 0x6580c66d, 0x79b3e8d9, 0x5dfcfc1c, 0x0b7d1f15, 0x9f182177, 0x85eaeb92, 0x28b8a00a, 0x611c85d0, 0xa8f00d11, 0xbcad606b, 
                0x9869713b, 0xbb4333ec, 0x2a808cc4, 0x7a9d90e2, 0x4b535fc0, 0x4057b6b4, 0xe1f6fc6d, 0x60a8834b, 0xe26150af, 0x3dbcb49d, 0x2fcfc152, 0x5fbb07f8, 0x128a21b2, 0xf0acbcb7, 0x66160ab4, 0xa762a00a, 0xfa668d65, 0xd20a6bc7, 0x4af648a0, 0x17e2493b, 0xc75c5769, 0xad3fb33e, 0x14e4b152, 0xfb710a3c, 
                0xea70697c, 0xd2c5ca37, 0x295e0040, 0xe0307da6, 0x63f26d95, 0x206c40ae, 0xe28e2dab, 0x645579d3, 0x71c30f8a, 0x86f6ac97, 0x08f3fe95, 0x9edaf43f, 0x6cdc9331, 0xcb3b9e88, 0xbebaaacb, 0xbb832327, 0x22cecd5a, 0x2cc4f928, 0x09400d38, 0x1f85e984, 0xa6f3dd00, 0x61ac06ad, 0x2fc59847, 0x63f0208b, 
                0xaebfd0eb, 0xff122ce7, 0x54acf0b1, 0x1ab6ac9c, 0xf5985a38, 0xe27f98a0, 0x3b786202, 0x7fd164a0, 0x259e281a, 0x62ab01bb, 0xa052c273, 0xc5308721, 0xbc5964ea, 0x72bfe62e, 0xa643d1cc, 0xb8918c86, 0xd60a2614, 0x21a49f71, 0xfe1212c4, 0x08bbcc65, 0xd7e91af4, 0x5a3de012, 0x229965bd, 0x320e1251, 
                0x9feb0c1e, 0xc1ecae2d, 0xa608f24a, 0xfe4c768c, 0x6b89f1c5, 0x01b05fda, 0x2bc052bb, 0x0d69668d, 0x76ad4808, 0xa8294e60, 0x30449e36, 0x96c95f1e, 0xdf572841, 0xacbaefc8, 0xec7b8aab, 0x8addbd8c, 0xecc39754, 0x15409175, 0xc31330a1, 0x2f809993, 0xb58cf542, 0x0872dc9b, 0x602cae07, 0xf4715642, 
                0x326dd202, 0x732c385b, 0xc2664d7c, 0xc8af6a0b, 0xbb881ccd, 0x1e925342, 0x45916a11, 0x8a64a77f, 0xd99c90b8, 0x20bfffa4, 0x61cf9c0c, 0x8ffd02fe, 0x092cef65, 0x71647f8d, 0xac5074fc, 0x11742be8, 0x6b88661f, 0x09288a6f, 0x4d4dacfd, 0x796317e6, 0xe923905e, 0xe2573a12, 0x1731891c, 0xe0538bbf, 
                0x785075ac, 0x5006812c, 0x6d6cbbd4, 0x557a08f6, 0x873787e7, 0x3b15985b, 0xef572cfd, 0x4028fa47, 0xc12fb273, 0xb6e8fea6, 0x78f9f762, 0x8a95d33c, 0x0b9d007a, 0x723ccad5, 0xc120d010, 0xd29e62fa, 0x76c3ded3, 0x0e489048, 0x46e1e2dd, 0x5771ec46, 0xda4df2fe, 0xf948c211, 0x6b61a774, 0xafe3edb9, 
                0x32eea8fe, 0x42311054, 0xc3704aaa, 0xc954a41a, 0x5281ea70, 0x8fe6d5e2, 0xbac2c0d5, 0x2cba28fa, 0x16a05b58, 0x08d4fc0f, 0x9f9af098, 0x8605e029, 0x18801f58, 0xb10c4a48, 0x6272cb14, 0x5540f336, 0x4e8f8406, 0x18050a83, 0xbb79eb05, 0xd8d65309, 0x7ba4f188, 0x1bd4aebb, 0xaf982ac5, 0x152c0690, 
                0xa6d3c52c, 0xb7c30dc7, 0x34027788, 0x8b6327c3, 0x8b9816df, 0x3b018f73, 0x6b3bb4a4, 0xceb55d06, 0x8ff0e565, 0xaff91eca, 0xfa182a92, 0xc0a18487, 0x7e16e96e, 0x2a806368, 0xf9559a99, 0x85069bc7, 0xb68bc6c7, 0x4e9a3117, 0xc9a49e64, 0x53ccf2b1, 0x28ab9bfe, 0x20494701, 0x1353ff50, 0x7e016ca8, 
                0x2e00c131, 0x01cecd91, 0xb41cf59a, 0x07853c38, 0x1abe6d34, 0xf521303e, 0xacc95056
}; //TABLE
 
#endif /* DRM_PRECOMPUTE_GTABLE */


#if ( RADIX_BITS == 32 )

static const digit_t g_rgdOrder_P256[ ECC_P256_INTEGER_SIZE_IN_DIGITS ] =
{
    0xfc632551, 0xf3b9cac2, 0xa7179e84, 0xbce6faad,
    0xffffffff, 0xffffffff, 0x00000000, 0xffffffff
};

static const digit_t g_rgdA_P256[ ECC_P256_INTEGER_SIZE_IN_DIGITS ] =
{
    0xfffffffc, 0xffffffff, 0xffffffff, 0x00000003,
    0x00000000, 0x00000000, 0x00000004, 0xfffffffc
};

static const digit_t g_rgdB_P256[ ECC_P256_INTEGER_SIZE_IN_DIGITS ] =
{
    0x29c4bddf, 0xd89cdf62, 0x78843090, 0xacf005cd,
    0xf7212ed6, 0xe5a220ab, 0x04874834, 0xdc30061d
};

static const digit_t g_rgecG_P256[ ECC_P256_POINT_SIZE_IN_ECAFFINES ] =
{
    0x18a9143c, 0x79e730d4, 0x5fedb601, 0x75ba95fc,
    0x77622510, 0x79fb732b, 0xa53755c6, 0x18905f76,
    0xce95560a, 0xddf25357, 0xba19e45c, 0x8b4ab8e4, 
    0xdd21f325, 0xd2e88688, 0x25885d85, 0x8571ff18
};

static const digit_t g_rgdConstModulus_P256[ ECC_P256_INTEGER_SIZE_IN_DIGITS ] =
{
    0xffffffff, 0xffffffff, 0xffffffff, 0x00000000,
    0x00000000, 0x00000000, 0x00000001, 0xffffffff
};

static const digit_t g_rgdConstA_P256[ ECC_P256_INTEGER_SIZE_IN_DIGITS ] =
{
    0xfffffffc, 0xffffffff, 0xffffffff, 0x00000003,
    0x00000000, 0x00000000, 0x00000004, 0xfffffffc
};

static const digit_t g_rgdConstB_P256[ ECC_P256_INTEGER_SIZE_IN_DIGITS ] =
{
    0x29c4bddf, 0xd89cdf62, 0x78843090, 0xacf005cd,
    0xf7212ed6, 0xe5a220ab, 0x04874834, 0xdc30061d
};

static const digit_t g_rgecConstG_P256[ ECC_P256_POINT_SIZE_IN_ECAFFINES ] =
{
    0x18a9143c, 0x79e730d4, 0x5fedb601, 0x75ba95fc,
    0x77622510, 0x79fb732b, 0xa53755c6, 0x18905f76,
    0xce95560a, 0xddf25357, 0xba19e45c, 0x8b4ab8e4, 
    0xdd21f325, 0xd2e88688, 0x25885d85, 0x8571ff18
};

static const digit_t g_rgdMulFirst[ ECC_P256_POINT_SIZE_IN_ECAFFINES ] =
{
    0xffffffff, 0xffffffff, 0x00000001, 0x00000001,
    0xffffffff, 0xfffffffe, 0x00000001, 0xfffffffe
};

static const digit_t g_rgdMulScnd[ ECC_P256_LNGRED2 ] =
{
    0xffffffff, 0xffffffff, 0xffffffff, 0xfffffffe
};

static const digit_t g_rgdOne[ ECC_P256_POINT_SIZE_IN_ECAFFINES ] =
{
    0x00000001, 0x00000000, 0x00000000, 0xffffffff, 
    0xffffffff, 0xffffffff, 0xfffffffe, 0x00000000
};

static const digit_t m_rgdInverseAdjustment[ ECC_P256_INTEGER_SIZE_IN_DIGITS ] = 
{
    0x00000000, 0x00000003, 0xfffffffe, 0x00000001, 
    0x00000002, 0xfffffffd, 0x00000003, 0xfffffffe
};

#else /* #if ( RADIX_BITS == 32 ) */

#error -- "digit_t is defined as an unsupported size"

#endif /* #if ( RADIX_BITS != 32 ) */ 

/*
** A warning is thrown by the following globals that states
** we should not be using a non-obfuscated global constant function pointer. 
** This should be ok on the porting kit, however this code must not go on the PC
** The reason why it exists on the PK is that these globals must be consts b/c
** certain compilers do not support global non-constant data ( and hence we can't
** obfuscate the pointers ).
*/
#if defined( _PREFAST_ )
#pragma warning( disable : 22112 )
#endif

/*
** Pre-inititalized read only curve context for the P256 crypto
*/
static const mp_modulus_t g_Modulus =
{
    ECC_P256_INTEGER_SIZE_IN_DIGITS,        /* length  */
    ECC_P256_LNGRED2,                       /* lngred2 */
    ECC_P256_INTEGER_SIZE_IN_DIGITS * 2,    /* modmul_algorithm_temps */
    ( DRM_INT )( RADIX_BITS * ECC_P256_INTEGER_SIZE_IN_DIGITS ), /* scaling_power2;  */
    FROM_RIGHT,                             /* reddir */
    { 0 },                                  /* left_reciprocal_1 */
    0xffffffff,                             /* right_reciprocal_1 */
    ( digit_t* )g_rgdConstModulus_P256,     /* modulus */
    ( digit_t* )g_rgdMulFirst,              /* multiplier_first */
    ( digit_t* )g_rgdMulScnd,               /* multiplier_second */    
    ( digit_t* )g_rgdOne,                   /* one */     

#if ECC_P256_INTEGER_SIZE_IN_DIGITS == LNGQ_MODULO_8    
    modmul_from_right_default_modulo8,      /* modmul_algorithm for case with one ECC_P256_INTEGER as 8 digits*/
#else 
    modmul_from_right_default,              /* modmul_algorithm */
#endif 
};

static const field_desc_t g_Fdesc =
{
    ECC_P256_INTEGER_SIZE_IN_DIGITS, /* elng */
    1,                               /* degree */
    11 * ECC_P256_INTEGER_SIZE_IN_DIGITS + 6,   /* ndigtemps_arith */
    ECC_P256_INTEGER_SIZE_IN_DIGITS * 2,        /* ndigtemps_mul */
    10 * ECC_P256_INTEGER_SIZE_IN_DIGITS + 6,   /* ndigtemps_invert1 */
    FIELD_Q_MP,             /* ftype */    
    FALSE,                  /* free_modulus */
    ( digit_t* )g_rgdOne,   /* one */
    NULL,                   /* deallocate */
   &prime_arithmetic,       /* arithmetic */
    NULL,                   /* base_field */
    NULL,                   /* minimal_polynomial */
   &g_Modulus,              /* modulo */
    ( digit_t* )m_rgdInverseAdjustment, /* inverse_adjustment */
    0,                      /* T */
    0,                      /* lng_mulshifts */
    NULL,                   /* mulshifts */
    0,                      /* nonzero_trace_power */
    NULL,                   /* leading_inverse */
    NULL,                   /* freduc */
    0,                      /* unused_bits_top */
    RADIXM1,                /* mask_used_bits */
    
};

extern const ecurve_t g_Ecurve = 
{
     &g_Fdesc,                          /* field desc */
    ( digit_t* )g_rgdConstA_P256,       /* A */
    ( digit_t* )g_rgdConstB_P256,       /* B */
    ( digit_t* )g_rgecConstG_P256,      /* G */
    ( digit_t* )g_rgdOrder_P256,        /* order */
      NULL,                   /* Deallocs, should be NULL */
      NULL,                   /* fexpon */
      FALSE,                  /* Free field, should be false - nothing to free */
      FALSE,                  /* is b == zero, obviously this is false */
      ECC_P256_NDIGTEMPS,     /* ndigtemps */
      0,                      /* lnggorder */
    { 0 }                     /* G reciprocal */
};

/*
** Local Function defs
*/

DRM_NO_INLINE DRM_RESULT Convert_P256_BigEndianBytesToModular(
    __in_ecount( __CB_DECL( ECC_P256_INTEGER_SIZE_IN_BYTES ) ) const DRM_BYTE    f_rgbInBytes[], 
    __in_ecount( 1 )                                           const ecurve_t   *f_pEcurve,    
    __out_ecount( ECC_P256_INTEGER_SIZE_IN_ECAFFINES )               digit_t  f_rgecModular[],
    __inout                                                   struct bigctx_t *f_pBigCtx );

DRM_NO_INLINE DRM_RESULT Convert_P256_ModularIntToBigEndianBytesModOrder(
    __in_ecount( ECC_P256_INTEGER_SIZE_IN_ECAFFINES ) const  digit_t    f_rgecInModularInt[],
    __in_ecount( 1 )                                  const  ecurve_t  *f_pEcurve,
    __out_ecount( ECC_P256_INTEGER_SIZE_IN_BYTES )           DRM_BYTE   f_rgbOutBytes[] );

DRM_NO_INLINE DRM_RESULT Convert_P256_PlaintextToPoint( 
    __in_ecount( 1 )                                const  PLAINTEXT_P256  *f_pPlaintext, 
    __in_ecount( 1 )                                const  ecurve_t        *f_pEcurve,
    __inout_opt                                            digit_t          f_rgdSuppliedTemps[],
    __out_ecount( ECC_P256_POINT_SIZE_IN_ECAFFINES )       digit_t          f_rgptOutPoint[],
    __inout                                         struct bigctx_t        *f_pBigCtx );

DRM_NO_INLINE DRM_RESULT Convert_P256_PointToBigEndianBytes(
    __in_ecount( ECC_P256_POINT_SIZE_IN_ECAFFINES )           const  digit_t    f_rgptInPoint[],
    __in_ecount( 1 )                                          const  ecurve_t  *f_pEcurve,
    __out_ecount( __CB_DECL( ECC_P256_POINT_SIZE_IN_BYTES ) )        DRM_BYTE   f_rgbOutBytes[] );

/*
** Function Implementations
*/


/*************************************************************************************************
**
** Function: Convert_BigEndianBytesToDigits
**
** Description: Convert a DRM_BYTE array to a digit_t array. Input should have big-endian form.
**
** Args:
**    [f_rgbInBytes]:   The bytes to convert
**    [f_rgdOutDigits]: The output converted digits
**    [f_cBits]:        Number of bits to convert
**
** Returns: DRM_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes: 
**
*************************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL Convert_BigEndianBytesToDigits(
  __in_ecount( __CB_DECL( ( f_cBits + 7 ) / 8 ) ) const DRM_BYTE  f_rgbInBytes[],
  __out_ecount( BITS_TO_DIGITS( f_cBits ) )             digit_t   f_rgdOutDigits[],
                                             const DRM_DWORD f_cBits )
{
    /*
    ** Decls and inits
    */
    DRM_DWORD   cDigitLen = BITS_TO_DIGITS( f_cBits );
    DRM_DWORD   iByte     = 0;
    DRM_DWORD   iDig      = 0;
    DRM_DWORD   cByteLen  = __CB_DECL( ( f_cBits + 7 ) / 8 );
    DRM_RESULT  dr        = DRM_SUCCESS;

#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRM_ECC_P256, PERF_FUNC_Convert_BigEndianBytesToDigits );
#endif

    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_rgbInBytes );
    ChkArg( NULL != f_rgdOutDigits );
    ChkArg( 0    != f_cBits );
    
    ZEROMEM( f_rgdOutDigits, cDigitLen * SIZEOF( digit_t ) );

    /*
    ** Loop through and set each digit, byte by byte
    */
    for ( iDig = 0; iDig < cDigitLen; ++iDig ) 
    {
        /*
        ** Figure out how many bytes to process for this digit ( it should be
        ** the min between the number of bytes in the digit and number of bytes 
        ** left unprocessed in the byte array )
        */
        DRM_DWORD cbBytesRemaining = cByteLen - RADIX_BYTES * iDig;
        DRM_DWORD cbBytesToProcess = MIN( cbBytesRemaining, RADIX_BYTES );             

        /*
        ** Assign the bytes into the current digit
        */
        for ( iByte = 0; iByte < cbBytesToProcess; ++iByte ) 
        {
            f_rgdOutDigits[ iDig ] ^=    ( digit_t )GET_BYTE( f_rgbInBytes, cbBytesRemaining - 1 - iByte )
                                      << ( 8 * iByte );
        } /* end for iByte */
    } /* end for iDig */

    /*
    ** Pad the end digit in the array if the bytes don't fit perfectly
    ** into the digits. This padding should be all 0x00s
    */
    f_rgdOutDigits[ cDigitLen - 1 ] &= RADIXM1 >> ( RADIX_BITS * cDigitLen - f_cBits );

ErrorExit:

#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_LEAVE_SCOPE;
#endif

    return dr;
} /* end Convert_BigEndianBytesToDigits */

/*************************************************************************************************
**
** Function: Convert_DigitsToBigEndianBytes
**
** Description: Convert digit_t array to bytes. Put most significant byte first.
**
** Args:
**    [f_rgdInDigits]: The input digits to be converted
**    [f_rgbOutBytes]: The output converted bytes
**    [f_cBits]:       Number of bits to convert
**
** Returns: DRM_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes:
**
*************************************************************************************************/
DRM_API DRM_RESULT DRM_CALL Convert_DigitsToBigEndianBytes(
  __in_ecount( BITS_TO_DIGITS( f_cBits ) )          const digit_t   f_rgdInDigits[],
  __out_ecount( __CB_DECL( ( f_cBits + 7 ) / 8 ) )        DRM_BYTE  f_rgbOutBytes[],
  __in                                              const DRM_DWORD f_cBits )
{
    /*
    ** Decls and inits
    */
    DRM_DWORD   cDigitLen = BITS_TO_DIGITS( f_cBits );
    DRM_DWORD   iByte     = 0;
    DRM_DWORD   iDig      = 0;
    DRM_DWORD   cByteLen  = __CB_DECL( ( f_cBits + 7 ) / 8 );
    DRM_RESULT  dr        = DRM_SUCCESS;

#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRM_ECC_P256, PERF_FUNC_Convert_DigitsToBigEndianBytes );
#endif

    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_rgdInDigits );
    ChkArg( NULL != f_rgbOutBytes );
    ChkArg( 0    != f_cBits );

    /*
    ** Pull the bytes out of the digit array an stick them in their correct posn
    */
    for ( iDig = 0; iDig != cDigitLen; ++iDig ) 
    {
        digit_t   dValue = f_rgdInDigits[ iDig ];
        DRM_DWORD cbBytesRemaining = cByteLen - RADIX_BYTES * iDig;
        DRM_DWORD cbBytesToProcess = MIN( cbBytesRemaining, RADIX_BYTES );

        for ( iByte = 0; iByte != cbBytesToProcess; ++iByte ) 
        {
            PUT_BYTE( f_rgbOutBytes,cbBytesRemaining - 1 - iByte, ( DRM_BYTE )( dValue & 0xff ) );
            dValue >>= 8;
        } /* end for iByte */
    } /* end for iDig */

ErrorExit:
    
#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_LEAVE_SCOPE;
#endif

    return dr;
} /* end digits_to_endian_bytes */

/*************************************************************************************************
**
** Function: Convert_P256_BigEndianBytesToDigits
**
** Description: 
**
** Args:
**    [f_rgbInBytes]:   The input bytes to be converted
**    [f_rgdOutDigits]: The output converted digits
**
** Returns: DRM_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes:
**
*************************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL Convert_P256_BigEndianBytesToDigits(
    __in_ecount( __CB_DECL( ECC_P256_INTEGER_SIZE_IN_BYTES ) ) const DRM_BYTE f_rgbInBytes[], 
    __out_ecount( ECC_P256_INTEGER_SIZE_IN_DIGITS )                  digit_t  f_rgdOutDigits[] )
{
    /*
    ** decls
    */
    DRM_RESULT dr = DRM_SUCCESS;

#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRM_ECC_P256, PERF_FUNC_Convert_P256_BigEndianBytesToDigits );
#endif

    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_rgdOutDigits );
    ChkArg( NULL != f_rgbInBytes );

    /*
    ** Now do the conversion
    */
    if ( DRM_FAILED( Convert_BigEndianBytesToDigits( f_rgbInBytes, 
                                                     f_rgdOutDigits, 
                                                     ECC_P256_INTEGER_SIZE_IN_BITS ) ) )
    {
        ChkDR( DRM_E_P256_CONVERSION_FAILURE );
    } /* end if */
    
ErrorExit:
    
#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_LEAVE_SCOPE;
#endif

    return dr;
} /* end Convert_P256_BigEndianBytesToDigits */


/*************************************************************************************************
**
** Function: Convert_P256_BigEndianBytesToDigitsModOrder
**
** Description: 
**
** Args:
**    [f_rgbBytes]:  The input bytes to be converted
**    [f_pEcurve ]:  EC that we are working on
**    [f_rgdDigits]: The output converted digits mod order 
**
** Returns: DRM_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes:
**
*************************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL Convert_P256_BigEndianBytesToDigitsModOrder(
    __in_ecount( ECC_P256_INTEGER_SIZE_IN_BYTES )   const DRM_BYTE  f_rgbBytes[],
    __in_ecount( 1 )                                const ecurve_t *f_pEcurve,
    __out_ecount( ECC_P256_INTEGER_SIZE_IN_DIGITS )       digit_t   f_rgdDigits[] )
{
    /*
    ** decls
    */
    DRM_RESULT dr = DRM_SUCCESS;
    digit_t    rgdTemp[ ECC_P256_INTEGER_SIZE_IN_DIGITS ] = { 0 };

#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRM_ECC_P256, PERF_FUNC_Convert_P256_BigEndianBytesToDigitsModOrder );
#endif

    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_rgbBytes );
    ChkArg( NULL != f_pEcurve );
    ChkArg( NULL != f_rgdDigits );    

    /*
    ** Now do the conversion
    */
    if ( DRM_FAILED( Convert_BigEndianBytesToDigits( f_rgbBytes, 
                                                     rgdTemp, 
                                                     ECC_P256_INTEGER_SIZE_IN_BITS ) ) )
    {
        ChkDR( DRM_E_P256_CONVERSION_FAILURE );
    } /* end if */

    /*
    ** Now do the modding
    */ 
    ChkBOOL( divide( rgdTemp,
                     ECC_P256_INTEGER_SIZE_IN_DIGITS,
                     f_pEcurve->gorder, 
                     ECC_P256_INTEGER_SIZE_IN_DIGITS,
                     NULL, 
                     NULL, 
                     f_rgdDigits ),
             DRM_E_P256_CONVERSION_FAILURE );
ErrorExit:
    
#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_LEAVE_SCOPE;
#endif

    return dr;
} /* end Convert_P256_BigEndianBytesToDigitsModOrder */

/*************************************************************************************************
**
** Function: Convert_P256_BigEndianBytesToModular
**
** Description: Converts big endian bytes into modular formatted 
**
** Args:
**    [f_rgbInBytes]:  The bytes to be converted into modular digits ( ecaffines )
**    [f_pEcurve ]:    EC that we are working on
**    [f_rgecModular]: The converted modular format integer output
**    [f_pBigCtx]:     Bignum context pointer
**
** Returns: DRM_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes:
**
*************************************************************************************************/
DRM_RESULT DRM_NO_INLINE Convert_P256_BigEndianBytesToModular(
    __in_ecount( __CB_DECL( ECC_P256_INTEGER_SIZE_IN_BYTES ) ) const  DRM_BYTE   f_rgbInBytes[], 
    __in_ecount( 1 )                                           const  ecurve_t  *f_pEcurve,    
    __out_ecount( ECC_P256_INTEGER_SIZE_IN_ECAFFINES )                digit_t    f_rgecModular[],
    __inout                                                    struct bigctx_t  *f_pBigCtx )
{
    /*
    ** decls
    */
    DRM_RESULT dr = DRM_SUCCESS;
    digit_t    rgdTemp[ ECC_P256_POINT_SIZE_IN_DIGITS / 2 ] = { 0 };

#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRM_ECC_P256, PERF_FUNC_Convert_P256_BigEndianBytesToModular );
#endif

    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_rgbInBytes );
    ChkArg( NULL != f_pEcurve );
    ChkArg( NULL != f_rgecModular );
    ChkArg( NULL != f_pBigCtx );
    ChkArg( NULL != f_pEcurve->fdesc );
    ChkArg( NULL != f_pEcurve->fdesc->modulo );
    ChkArg( ECC_P256_INTEGER_SIZE_IN_DIGITS == f_pEcurve->fdesc->modulo->length );

    /*
    ** First convert to digits
    */
    ChkDR( Convert_P256_BigEndianBytesToDigits( f_rgbInBytes, rgdTemp ) );

    /*
    ** Now Convert to modular format
    */
    ChkBOOL( to_modular( rgdTemp, 
                         ECC_P256_INTEGER_SIZE_IN_DIGITS, 
                         f_rgecModular,
                         f_pEcurve->fdesc->modulo,
                         f_pBigCtx ),
             DRM_E_P256_CONVERSION_FAILURE );

ErrorExit:
    
#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_LEAVE_SCOPE;
#endif

    return dr;
} /* end Convert_P256_BigEndianBytesToModular */ 

/*************************************************************************************************
**
** Function: Convert_P256_BigEndianBytesToPoint
**
** Description: Converts big endian bytes into a modular EC point ( ecaffines )
**
** Args:
**    [f_rgbInBytes]:   The input bytes to be converted
**    [f_pEcurve ]:     EC that we are working on
**    [f_rgptOutPoint]: The output converted data in modular point format
**    [f_pBigCtx]:      Bignum context pointer
**
** Returns: DRM_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes:
**
*************************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL Convert_P256_BigEndianBytesToPoint(
    __in_ecount( __CB_DECL( ECC_P256_POINT_SIZE_IN_BYTES ) )  const  DRM_BYTE   f_rgbInBytes[], 
    __in_ecount( 1 )                                          const  ecurve_t  *f_pEcurve,    
    __out_ecount( ECC_P256_POINT_SIZE_IN_ECAFFINES )                 digit_t    f_rgptOutPoint[],
    __inout                                                   struct bigctx_t  *f_pBigCtx )
{
    /*
    ** decls
    */
    DRM_RESULT dr = DRM_SUCCESS;
    digit_t    rgdTemp[ ECC_P256_POINT_SIZE_IN_DIGITS / 2 ] = { 0 };

#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRM_ECC_P256, PERF_FUNC_Convert_P256_BigEndianBytesToPoint );
#endif

    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_rgbInBytes );
    ChkArg( NULL != f_pEcurve );
    ChkArg( NULL != f_rgptOutPoint );
    ChkArg( NULL != f_pBigCtx );
	ChkArg( NULL != f_pEcurve->fdesc );
	ChkArg( NULL != f_pEcurve->fdesc->modulo );
	ChkArg( ECC_P256_INTEGER_SIZE_IN_DIGITS == f_pEcurve->fdesc->modulo->length );

    /*
    ** Convert the bytes into digits and then into modular (point ) format for the x coord
    */
    ChkDR( Convert_P256_BigEndianBytesToDigits( f_rgbInBytes, rgdTemp ) );
    ChkBOOL( to_modular( rgdTemp,
                         ECC_P256_POINT_SIZE_IN_ECAFFINES / 2,
                         f_rgptOutPoint,
                         f_pEcurve->fdesc->modulo,
                         f_pBigCtx ),
             DRM_E_P256_CONVERSION_FAILURE );

    /*
    ** Convert the bytes into digits and then into modular (point ) format for the y coord
    */
    ChkDR( Convert_P256_BigEndianBytesToDigits( &f_rgbInBytes[ ECC_P256_POINT_SIZE_IN_BYTES / 2 ],
                                                 rgdTemp ) );
    ChkBOOL( to_modular( rgdTemp,
                         ECC_P256_POINT_SIZE_IN_ECAFFINES / 2,
                        &f_rgptOutPoint[ ECC_P256_POINT_SIZE_IN_ECAFFINES / 2 ],
                         f_pEcurve->fdesc->modulo,
                         f_pBigCtx ),
             DRM_E_P256_CONVERSION_FAILURE );
    
ErrorExit:
    
#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_LEAVE_SCOPE;
#endif

    return dr;
} /* end Convert_P256_BigEndianBytesToPoint */

/*************************************************************************************************
**
** Function: Convert_P256_DigitsToBigEndianBytes
**
** Description: Convert EC integer in digits format into big endian bytes format
**
** Args:
**    [f_rgdInDigits]: The digits to convert into bytes
**    [f_rgbOutBytes]: The converted bytes output buffer
**
** Returns: DRM_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes:
**
*************************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL Convert_P256_DigitsToBigEndianBytes(
    __in_ecount( ECC_P256_INTEGER_SIZE_IN_DIGITS )              const digit_t  f_rgdInDigits[], 
    __out_ecount( __CB_DECL( ECC_P256_INTEGER_SIZE_IN_BYTES ) )       DRM_BYTE f_rgbOutBytes[] )
{
    /*
    ** decls
    */
    DRM_RESULT dr = DRM_SUCCESS;

#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRM_ECC_P256, PERF_FUNC_Convert_P256_DigitsToBigEndianBytes );
#endif

    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_rgdInDigits );
    ChkArg( NULL != f_rgbOutBytes );

    /*
    ** Convert the digits to bytes
    */
    if( DRM_FAILED( Convert_DigitsToBigEndianBytes( f_rgdInDigits, 
                                                    f_rgbOutBytes,
                                                    ECC_P256_INTEGER_SIZE_IN_BITS ) ) )
    {
        ChkDR( DRM_E_P256_CONVERSION_FAILURE );
    } /* end if */
    
ErrorExit:
    
#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_LEAVE_SCOPE;
#endif

    return dr;
} /* end Convert_P256_DigitsToBigEndianBytes */

/*************************************************************************************************
**
** Function: Convert_P256_ModularIntToBigEndianBytesModOrder
**
** Description: Converts modular format EC integer into big endian bytes mod curve's order 
**
** Args:
**    [f_rgecInModularInt]: The modular format integer to be converted into big endian bytes % o
**    [f_pEcurve ]:         EC that we are working on
**    [f_rgbOutBytes]:      The output buffer containing bytes in big endian format ( mod order )
**
** Returns: DRM_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes:
**
*************************************************************************************************/
DRM_NO_INLINE DRM_RESULT Convert_P256_ModularIntToBigEndianBytesModOrder(
    __in_ecount( ECC_P256_INTEGER_SIZE_IN_ECAFFINES ) const  digit_t   f_rgecInModularInt[],
    __in_ecount( 1 )                                  const  ecurve_t *f_pEcurve,
    __out_ecount( ECC_P256_INTEGER_SIZE_IN_BYTES )           DRM_BYTE  f_rgbOutBytes[] )
{
    /*
    ** decls
    */
    DRM_RESULT dr = DRM_SUCCESS;
    digit_t    rgdModNum[ ECC_P256_INTEGER_SIZE_IN_DIGITS ] = { 0 };    

#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRM_ECC_P256, PERF_FUNC_Convert_P256_ModularIntToBigEndianBytesModOrder );
#endif
    
    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_rgecInModularInt );
    ChkArg( NULL != f_pEcurve );
    ChkArg( NULL != f_rgbOutBytes );    

    /*
    ** Convert first from modular to digits ( and do the modding )
    */
    ChkDR( Convert_P256_ModularIntToDigitsModOrder( f_rgecInModularInt,
                                                    f_pEcurve,
                                                    rgdModNum ) );

    /*
    ** Now convert now from digits to bytes
    */
    ChkDR( Convert_P256_DigitsToBigEndianBytes( rgdModNum, f_rgbOutBytes ) );
    
ErrorExit:
    
#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_LEAVE_SCOPE;
#endif

    return dr;
}/* end Convert_P256_ModularIntToBigEndianBytesModOrder */

/*************************************************************************************************
**
** Function: Convert_P256_ModularIntToDigitsModOrder
**
** Description: Converts a modular format EC integer into digits mod the curve's order
**
** Args:
**    [f_rgecInModularInt]: The modular format integer to be converted into big endian bytes % o
**    [f_pEcurve ]:         EC that we are working on
**    [f_rgbOutDigits]:     The output buffer containing digits formatted data ( mod order )
**
** Returns: DRM_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes:
**
*************************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL Convert_P256_ModularIntToDigitsModOrder(
    __in_ecount( ECC_P256_INTEGER_SIZE_IN_ECAFFINES ) const  digit_t   f_rgecInModularInt[],
    __in_ecount( 1 )                                  const  ecurve_t *f_pEcurve,
    __out_ecount( ECC_P256_INTEGER_SIZE_IN_DIGITS )          digit_t   f_rgbOutDigits[] )
{
    /*
    ** decls
    */
    DRM_RESULT dr = DRM_SUCCESS;
    digit_t    rgdTemp[ ECC_P256_INTEGER_SIZE_IN_DIGITS ] = { 0 };

#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRM_ECC_P256, PERF_FUNC_Convert_P256_ModularIntToDigitsModOrder );
#endif    

    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_rgecInModularInt );
    ChkArg( NULL != f_pEcurve );
    ChkArg( NULL != f_rgbOutDigits );    
	ChkArg( NULL != f_pEcurve->fdesc );
	ChkArg( NULL != f_pEcurve->fdesc->modulo );
	ChkArg( ECC_P256_INTEGER_SIZE_IN_DIGITS == f_pEcurve->fdesc->modulo->length );

    /*
    ** Convert first from modular to digits
    */
    ChkBOOL( from_modular( f_rgecInModularInt,
                           rgdTemp,
                           f_pEcurve->fdesc->modulo ),
             DRM_E_P256_CONVERSION_FAILURE );

    /*
    ** We now take the digits and mod by the order
    */
    ChkBOOL( divide( rgdTemp,
                     ECC_P256_INTEGER_SIZE_IN_DIGITS,
                     f_pEcurve->gorder,
                     ECC_P256_INTEGER_SIZE_IN_DIGITS,
                     NULL,
                     NULL,
                     f_rgbOutDigits ),
             DRM_E_P256_CONVERSION_FAILURE );
       
ErrorExit:
    
#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_LEAVE_SCOPE;
#endif

    return dr;
} /* end Convert_P256_ModularIntToDigitsModOrder */

/************************************************************************************************
**
** Function:  DRM_ECC_MapX2PointP256
**
** Synopsis:  Given X coordinate of a point tries to calculate Y coordinate. Such that the 
**            resulting point is on the P256 curve. Fails if it is not possible. 
**
** Arguments:  
**    [f_pX]:               X Coordinate
**    [f_pY]:               Output Y Coordinate
**    [f_rgdSuppliedTemps]: Optional temps Array for math functions
**    [f_pBigCtx]:          Bignum context pointer
**
** Returns: DRM_RESULT indicating success or the corresponding error code, 
**          DRM_E_P256_PLAINTEXT_MAPPING_FAILURE is returned if mapping was not possible.
**          f_pY is filled in case of success. 
**
** Notes:   
**
*************************************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_ECC_MapX2PointP256(
    __in_ecount(ECC_P256_INTEGER_SIZE_IN_DIGITS)  digit_t          *f_pX,
    __out_ecount(ECC_P256_INTEGER_SIZE_IN_DIGITS) digit_t          *f_pY,
    __inout_opt                                   digit_t           f_rgdSuppliedTemps[],
    __inout                                struct bigctx_t         *f_pBigCtx
)
{
    DRM_RESULT dr = DRM_SUCCESS; 
    DRM_BOOL   fSquare = FALSE;
    digit_t    rgdYSqrd[ ECC_P256_INTEGER_SIZE_IN_DIGITS * 2 ] = { 0 }; /* big enough for x^3 + ax + b */


#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRM_ECC_P256, PERF_FUNC_DRM_ECC_MapX2PointP256);
#endif    

    /*
    ** Compute the right-hand size of the EC function in two steps:
    ** rgdYSqrd = x^2 + a
    ** rgdYSqrd = x^3 + ax + b
    **
    ** FYI: EC function is defined as y^2 = x^3 + ax + b
    */
    ChkBOOL( Kmuladd( f_pX, 
                      f_pX,
                      g_Ecurve.a,
                      rgdYSqrd,
                      g_Ecurve.fdesc,
                      f_rgdSuppliedTemps,
                      f_pBigCtx ),
             DRM_E_P256_PKCRYPTO_FAILURE );

    ChkBOOL( Kmuladd( f_pX,
                      rgdYSqrd,
                      g_Ecurve.b,
                      rgdYSqrd,
                      g_Ecurve.fdesc,
                      f_rgdSuppliedTemps,
                      f_pBigCtx ),
             DRM_E_P256_PKCRYPTO_FAILURE );

    /*
    ** Calculate the square root of our x^3 + ax + b, this solves for y,
    ** b/c the equation is: y^2 = x^3 + ax + b, if this function succeeds in
    ** producing a root then we have successfully mapped the array to a point!
    */
    ChkBOOL( Kprime_sqrter( rgdYSqrd, 
                            f_pY,
                            1, 
                            g_Ecurve.fdesc,
                           &fSquare,
                            f_pBigCtx ), DRM_E_P256_PKCRYPTO_FAILURE); 

    /*
    ** if we could not square root the value, then return the mapping error
    */
    ChkBOOL( fSquare, DRM_E_P256_PLAINTEXT_MAPPING_FAILURE ); /* Is x^3 + ax + b  a square? */
     
ErrorExit:

#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_LEAVE_SCOPE;
#endif

    return dr; 
}

/************************************************************************************************
**
** Function:  Convert_P256_PlaintextToPoint
**
** Synopsis:  Maps a plaintext array into an EC point, this can fail if the plaintext
**            is not a valid x coord on the EC curve. Conversion expands the data by 100%
**
** Arguments:  
**    [f_pPlaintext]:       Input Plaintext data array to be converted into a point
**    [f_pEcurve ]:         EC that we are working on 
**    [f_rgdSuppliedTemps]: Optional temps array that the math functions can use.
**    [f_rgptOutPoint]:     Output plaintext in modular point format ( ecaffines )
**    [f_pBigCtx]:          Bignum context pointer
**
** Returns: DRM_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes:   This function is very similar to HMAC calculation function. 
**
*************************************************************************************************/
DRM_NO_INLINE DRM_RESULT Convert_P256_PlaintextToPoint( 
    __in_ecount( 1 )                                 const  PLAINTEXT_P256  *f_pPlaintext, 
    __in_ecount( 1 )                                 const  ecurve_t        *f_pEcurve,
    __inout_opt                                             digit_t          f_rgdSuppliedTemps[],
    __out_ecount( ECC_P256_POINT_SIZE_IN_ECAFFINES )        digit_t          f_rgptOutPoint[],
    __inout                                          struct bigctx_t        *f_pBigCtx )
{
    /*
    ** Decls
    */
    DRM_RESULT dr      = DRM_SUCCESS;

#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRM_ECC_P256, PERF_FUNC_Convert_P256_PlaintextToPoint );
#endif

    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_pPlaintext );
    ChkArg( NULL != f_pEcurve );
    ChkArg( NULL != f_rgptOutPoint );
    ChkArg( NULL != f_pBigCtx );


    /*
    ** Convert to the array to modular format
    */
    ChkDR( Convert_P256_BigEndianBytesToModular( f_pPlaintext->m_rgbPlaintext,
                                                 f_pEcurve,
                                                 f_rgptOutPoint,
                                                 f_pBigCtx ) );
    
    ChkDR( DRM_ECC_MapX2PointP256( f_rgptOutPoint, 
                                  &f_rgptOutPoint[ ECC_P256_POINT_SIZE_IN_ECAFFINES / 2 ] ,
                                   f_rgdSuppliedTemps,
                                   f_pBigCtx ) ); 
                 
ErrorExit:
    
#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_LEAVE_SCOPE;
#endif

    return dr;
} /* end Convert_P256_PlaintextToPoint */

/*************************************************************************************************
**
** Function: Convert_P256_PointToBigEndianBytes
**
** Description: Converts a modular EC point into big endian bytes format
**
** Args:
**    [f_rgptPoint]:  EC point to convert
**    [f_pEcurve ]:   EC that we are working on
**    [f_pPlaintext]: Convert plaintext output
**
** Returns: DRM_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes:
**
*************************************************************************************************/
DRMFORCEINLINE DRM_RESULT Convert_P256_PointToBigEndianBytes(
    __in_ecount( ECC_P256_POINT_SIZE_IN_ECAFFINES )          const  digit_t   f_rgptInPoint[],
    __in_ecount( 1 )                                         const  ecurve_t *f_pEcurve,
    __out_ecount( __CB_D