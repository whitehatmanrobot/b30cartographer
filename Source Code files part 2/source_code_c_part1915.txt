x + 16));\\\n");
            }
            // specular
            if (mtVFormat == FlexVF) {
                fprintf (fHdr,"    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\\\n");
            } else {
                fprintf (fHdr,"    dwTemp = (*(DWORD*)(vertex + 20));\\\n");
            }
            // fog
            if (mtFogMode != None) {
                // wnear and wfar both equal to 1.0 means the projection is affine
                fprintf (fHdr,"    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\\\n");
                fprintf (fHdr,"    frhw = *(float*)&dwrhw;\\\n");
                fprintf (fHdr,"    FP_INV (fw, frhw);\\\n");
                fprintf (fHdr,"    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\\\n");  // select between z and 1/(1/rhw)
                fprintf (fHdr,"    fz = *(float *)&dwz;\\\n");
                if (mtFogMode == LinFog) {
                    fprintf (fHdr,"    ffog = (fz >= pCurrentContext->fFogTableEnd) ? 0.0f :\\\n");
                    fprintf (fHdr,"           (fz <= pCurrentContext->fFogTableStart) ? 1.0f :\\\n");
                    fprintf (fHdr,"           (pCurrentContext->fFogTableEnd - fz) * pCurrentContext->fFogTableLinearScale;\\\n");
                } else {
                    fprintf (fHdr,"    ffog  = fz * pCurrentContext->fFogTableDensity;\\\n");
                    if (mtFogMode == Exp2Fog) {
                        fprintf (fHdr,"    ffog *= ffog;\\\n");
                    }
                    fprintf (fHdr,"    FP_EXP (ffog,ffog);\\\n");
                }
                fprintf (fHdr,"    FP_NORM_TO_BIT24 (ifog,ffog);\\\n");
                fprintf (fHdr,"    dwTemp = (dwTemp & 0x00ffffff) | ifog;\\\n");
            }
            fprintf (fHdr,"    *(DWORD*)(fifo + 24) = dwTemp;\\\n");
            // uv (uv2)
            if (mtVFormat == FlexVF) {
                fprintf (fHdr,"    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\\\n");
                fprintf (fHdr,"    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\\\n");
                fprintf (fHdr,"    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\\\n");
                if (mtClass == DX6) {
                    fprintf (fHdr,"    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\\\n");
                    fprintf (fHdr,"    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\\\n");
                }
            } else {
                fprintf (fHdr,"    *(DWORD*)(fifo + 28) = (*(DWORD*)(vertex + 24));\\\n");
                fprintf (fHdr,"    *(DWORD*)(fifo + 32) = (*(DWORD*)(vertex + 28));\\\n");
                if (mtClass == DX6) {
                    fprintf (fHdr,"    *(DWORD*)(fifo + 36) = 0;\\\n");
                    fprintf (fHdr,"    *(DWORD*)(fifo + 40) = 0;\\\n");
                }
            }
        }
            fprintf (fHdr,"    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\\\n");
            fprintf (fHdr,"                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\\\n");
            fprintf (fHdr,"                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\\\n");
            fprintf (fHdr,"    fifo      += %s * 4;\\\n",size);
            fprintf (fHdr,"    freecount -= %s;\\\n",size);
            fprintf (fHdr,"}\n\n");
    NEXT

    fprintf (fImp,"#endif //!NV_FASTLOOPS\n");

// close files
    fclose (fHdr);
    fclose (fImp);

// done
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\blt1632.c ===
/*==========================================================================;
 *
 *  Copyright (C) 1995, 1998 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       blt1632.c
 *  Content:    Windows95 DirectDraw 32 bit driver
 *
 ***************************************************************************/

#include "windows.h"
#include <conio.h>
#include "nvd3ddrv.h"
#include "nv32.h"
#include "nvddobj.h"
#include "ddrvmem.h"
#include "d3dinc.h"
#include "global.h"
#include "nvheap.h"

extern DWORD ResetNV();

/*
 * Blt16bpp32
 *
 * 32-bit Blt function for 16bpp surfaces.
 */
DWORD __stdcall Blt16bpp32( LPDDHAL_BLTDATA pbd )
{
    FAST Nv10ControlDma *npDev;
    DWORD               dwFlags;
#ifdef  DX7
    DWORD               dwAFlags;
#endif  /* DX7 */
    DWORD               dwDstCaps;
    DWORD               dwSrcCaps;
    DWORD               dwDDFX = 0;
    DWORD               dwRop;
    NVCOORD             wXYext;
    NVCOORD             wDestXY;
    NVCOORD             wSrcXY;
    BYTE                isZBlt = 0;
    BYTE                wStretch = 0;
    BYTE                doMirrorUpDown = 0;
    BYTE                isVideo = 0;

    DWORD               dwFillColor;
    DWORD               dwColorKey;

    DWORD               dwDstOffset;
    DWORD               dwDstPitch;
    DWORD               dwDstWidth;
    DWORD               dwDstHeight;

    DWORD               dwSrcOffset;
    DWORD               dwSrcPitch;
    DWORD               dwSrcWidth;
    DWORD               dwSrcHeight;

    LPDDRAWI_DDRAWSURFACE_LCL  srcx;
    LPDDRAWI_DDRAWSURFACE_LCL  dstx;
    LPDDRAWI_DDRAWSURFACE_GBL  src;
    LPDDRAWI_DDRAWSURFACE_GBL  dst;

    unsigned long       *dmaPusherPutAddress =
                            (unsigned long *)pDriverData->NvDmaPusherPutAddress;
    unsigned long       *dmaPusherBufferBase =
                            (unsigned long *)pDriverData->NvDmaPusherBufferBase;
    long                freeCount;

    dstx = pbd->lpDDDestSurface;
    dst = dstx->lpGbl;

    /*
     * NOTES:
     *
     * Everything you need is in pdb->bltFX .
     * Look at pdb->dwFlags to determine what kind of blt you are doing,
     * DDBLT_xxxx are the flags.
     *
     * Z BUFFER NOTES:
     *
     * ZBuffer ALWAYS comes in BLTFX.   You don't need to go looking for
     * the attached surface. If DDBLT_ZBUFFER is specified, then either a
     * constant z or z buffer surface has been specified for the source and
     * destination. Just look for the DDBLT_ZBUFFERDESTOVERRIDE,
     * DDBLT_ZBUFFERSRCOVERRIDE, DDBLT_ZBUFFERCONSTANTDESTOVERRIDE, or
     * DDBLT_ZBUFFERCONSTANTSRCOVERRIDE.
     *
     * COLORKEY NOTES:
     *
     * ColorKey ALWAY comes in BLTFX.   You don't have to look it up in
     * the surface.
     */

    dwFlags   = pbd->dwFlags;
    dwDstCaps = dstx->ddsCaps.dwCaps;
#ifdef  DX7
    dwAFlags  = pbd->dwAFlags;

    if ((dwFlags & DDBLT_AFLAGS) && (dwAFlags & DDABLT_SRCOVERDEST)) {
        DPF("ALPHA ON 16BPP SURFACE FAILED");
        pbd->ddRVal = DDERR_NOALPHAHW;
        return DDHAL_DRIVER_HANDLED;
    }
#endif  /* DX7 */

#ifndef NVD3D
    if (dwDstCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_TEXTURE | DDSCAPS_NONLOCALVIDMEM))
        return DDHAL_DRIVER_NOTHANDLED;
#else   // NVD3D

#ifndef NV_TEX2
    /*
     * Check for a 16 Bpp texture blit right ways.
     */
    if (dwDstCaps & DDSCAPS_TEXTURE) {
#ifdef WINNT
    /*
     * Some MS apps insist on passing us DX7 AlphaBlts even though we never
     * claim DX7 support. Our texblt code requires a source, so return
     * an error if the src is not present.
     */
        if (!pbd->lpDDSrcSurface) {
            pbd->ddRVal = DDERR_INVALIDPARAMS;
            return DDHAL_DRIVER_HANDLED;
        }
#endif
        /*
         * Call the special D3D Texture blit code to handle this blit.
         */
        nvTextureBlit16Bpp(pbd);

        /*
         * Return successfully.
         */
        pbd->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }
#endif //!NV_TEX2

    /*
     * Check for any non video memory blits and reject them right away.
     */
    if (dwDstCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM))
        return DDHAL_DRIVER_NOTHANDLED;
#endif  // NVD3D

    // check for z buffer blit
    // assume that DD runtime has enough sense to make alpha blits mutually exclusive
    if ((dwDstCaps & DDSCAPS_ZBUFFER) && (dstx->dwFlags & DDRAWISURF_HASPIXELFORMAT)) {
        if (dst->ddpfSurface.dwZBufferBitDepth == 32)
            isZBlt = NV042_SET_COLOR_FORMAT_LE_Y32;
        else if (dst->ddpfSurface.dwZBufferBitDepth == 16)
            isZBlt = NV042_SET_COLOR_FORMAT_LE_Y16;
    }

    if (dwFlags & DDBLT_DDFX)
        dwDDFX = pbd->bltFX.dwDDFX;

    if (dwFlags & (DDBLT_KEYDEST | DDBLT_KEYDESTOVERRIDE)) {
        DPF("Dest color key failed");
        pbd->ddRVal = DDERR_NOCOLORKEYHW;
        return DDHAL_DRIVER_HANDLED;
    }

    /*
     * Let 3D code know we did some 2D rendering
     */
    pDriverData->TwoDRenderingOccurred = 1;

    /*
     * get offset, width, and height for destination
     */
    dwDstOffset = dst->fpVidMem     - pDriverData->BaseAddress;
    dwDstPitch  = dst->lPitch;
    dwDstWidth  = pbd->rDest.right  - pbd->rDest.left;
    dwDstHeight = pbd->rDest.bottom - pbd->rDest.top;
    wXYext.wh16.w = (unsigned short)dwDstWidth;
    wXYext.wh16.h = (unsigned short)dwDstHeight;

    wDestXY.xy16.x = (short)pbd->rDest.left;
    wDestXY.xy16.y = (short)pbd->rDest.top;

    npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

    if (npDev == NULL) {
        if (!ResetNV()) {
            pbd->ddRVal = DDERR_GENERIC;
            return DDHAL_DRIVER_HANDLED;
        }
        pDriverData->fReset = FALSE;
        npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

        if (npDev == NULL) {
            pbd->ddRVal = DDERR_SURFACELOST;
            return DDHAL_DRIVER_HANDLED;
        }
    }

    /*
     * Flag blits to the primary surface.  D3D will use this information
     * at end scene.
     * This is probably not needed and on top of that it has a significant
     * impact on 3D Winbench 98 for some reason.
     */
//    if (dwDstCaps & DDSCAPS_PRIMARYSURFACE)
//        dstx->dwReserved1 |= NV_D3D_HAS_FLIPPED;

    dmaPusherPutAddress = (unsigned long *)pDriverData->NvDmaPusherPutAddress;

#ifdef  CACHE_FREECOUNT
    freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
    freeCount = 0;
#endif  /* CACHE_FREECOUNT */

    if (pDriverData->ddClipUpdate) {

        while (freeCount < 7)
            NvGetDmaBufferFreeCount(npDev, freeCount, 7, dmaPusherPutAddress);
        freeCount -= 7;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
        dmaPusherPutAddress[1] = NV_DD_IMAGE_BLACK_RECTANGLE;
        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
            IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000;
        dmaPusherPutAddress[3] = 0;
        dmaPusherPutAddress[4] = asmMergeCoords(NV_MAX_X_CLIP,
                                                NV_MAX_Y_CLIP);
        dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
        dmaPusherPutAddress[6] = NV_DD_SURFACES_2D;

        dmaPusherPutAddress += 7;

        pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

        /* Force write combine buffer to flush */
        pDriverData->NvDmaPusherBufferEnd[0] = 0;
        /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
        _outp (0x3d0,0);

        pDriverData->dwDmaPusherFreeCount = freeCount;

        npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

        pDriverData->dwSharedClipChangeCount++;

        pDriverData->dwDDMostRecentClipChangeCount = pDriverData->dwSharedClipChangeCount;

        pDriverData->ddClipUpdate = FALSE;
    }

    /*
     * If async, then only work if bltter isn't busy
     * This should probably be a little more specific to each call, but
     * waiting for 32 is pretty close
     */
    if( dwFlags & DDBLT_ASYNC ) {

        NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);

        pDriverData->dwDmaPusherFreeCount = freeCount;

        /* Must save pointer in case it was changed by above macro */
        pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

        if (freeCount < 10) {
            DPF("Asynchronous blit failed");
            pbd->ddRVal = DDERR_WASSTILLDRAWING;
            return DDHAL_DRIVER_HANDLED;
        }
    }

    if (dwFlags & DDBLT_ROP) {
        dwRop = pbd->bltFX.dwROP >> 16;

        // set pixel depth for z buffer blit
        if (isZBlt) {
            while (freeCount < 2)
                NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
            freeCount -= 2;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = isZBlt;

            dmaPusherPutAddress += 2;
        }

        if ((dwRop == BLACKNESSINDEX) || (dwRop == WHITENESSINDEX)) {

            while (freeCount < 10)
                NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
            freeCount -= 10;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                SET_ROP_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = dwRop;

            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_DEST_OFFSET | 0x40000;
            dmaPusherPutAddress[3] = dwDstOffset;
            dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_PITCH_OFFSET | 0x40000;
            dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

            dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_COLOR1A_OFFSET | 0xC0000;
            dmaPusherPutAddress[7] = 0;
            dmaPusherPutAddress[8] = asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);
            dmaPusherPutAddress[9] = asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

            dmaPusherPutAddress += 10;

        } else if ((dwRop == PATCOPYINDEX) || (dwRop == PATINVERTINDEX)) {

            dwFillColor = pbd->bltFX.dwFillColor & pDriverData->physicalColorMask;

            if (dwRop == PATCOPYINDEX)
                dwRop = SRCCOPYINDEX;
            else if (dwRop == PATINVERTINDEX)
                dwRop = SRCINVERTINDEX;

            while (freeCount < 10)
                NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
            freeCount -= 10;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                SET_ROP_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = dwRop;

            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_DEST_OFFSET | 0x40000;
            dmaPusherPutAddress[3] = dwDstOffset;
            dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_PITCH_OFFSET | 0x40000;
            dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

            dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_COLOR1A_OFFSET | 0xC0000;
            dmaPusherPutAddress[7] = dwFillColor;
            dmaPusherPutAddress[8] = asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);
            dmaPusherPutAddress[9] = asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

            dmaPusherPutAddress += 10;

        } else if ((dwRop == SRCCOPYINDEX) || (dwRop == SRCPAINTINDEX) ||
                   (dwRop == SRCANDINDEX) || (dwRop == NOTSRCCOPYINDEX) ||
                   (dwRop == SRCINVERTINDEX) || (dwRop == MERGEPAINTINDEX) ||
                   (dwRop == SRCERASEINDEX) || (dwRop == NOTSRCERASEINDEX)) {

            srcx = pbd->lpDDSrcSurface;
            src = srcx->lpGbl;

            dwSrcCaps = srcx->ddsCaps.dwCaps;

            /* We must treat AGP source memory as system memory */
            if (dwSrcCaps & DDSCAPS_NONLOCALVIDMEM) {
                dwSrcCaps &= ~(DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM);
            }

            dwSrcOffset = VIDMEM_OFFSET(src->fpVidMem);
            dwSrcPitch  = src->lPitch;
            dwSrcWidth  = pbd->rSrc.right  - pbd->rSrc.left;
            dwSrcHeight = pbd->rSrc.bottom - pbd->rSrc.top;
            dwColorKey  = pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;

            wSrcXY.xy16.x = (short)pbd->rSrc.left;
            wSrcXY.xy16.y = (short)pbd->rSrc.top;

            if((srcx->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
               (src->ddpfSurface.dwFlags & DDPF_FOURCC)) {

               if (src->ddpfSurface.dwFourCC == FOURCC_RGB0) {
                   if ((src->ddpfSurface.dwRBitMask == 0x0000F800) &&
                       (src->ddpfSurface.dwGBitMask == 0x000007E0) &&
                       (src->ddpfSurface.dwBBitMask == 0x0000001F)) {
                       if (dwSrcCaps & DDSCAPS_SYSTEMMEMORY)
                           isVideo = 1;
                       goto srcRGB;
                   } else {
                       pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                       return DDHAL_DRIVER_HANDLED;
                   }
               } else if (src->ddpfSurface.dwFourCC == FOURCC_RAW8) {
                   pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                   return DDHAL_DRIVER_HANDLED;
               }

               while (freeCount < 6)
                   NvGetDmaBufferFreeCount(npDev, freeCount, 6, dmaPusherPutAddress);
               freeCount -= 6;

               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                   SET_ROP_OFFSET | 0x40000;
               dmaPusherPutAddress[1] = SRCCOPYINDEX;

               dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                   SURFACES_2D_DEST_OFFSET | 0x40000;
               dmaPusherPutAddress[3] = dwDstOffset;
               dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                   SURFACES_2D_PITCH_OFFSET | 0x40000;
               dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

               dmaPusherPutAddress += 6;

               pDriverData->dwDmaPusherFreeCount = freeCount;

               /* Just in case we return unexpectedly */
               pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

               switch (src->ddpfSurface.dwFourCC) {
                   case FOURCC_UYVY:
                   case FOURCC_UYNV:
                   case FOURCC_YUY2:
                   case FOURCC_YUNV:
//                     if (dwSrcWidth & 1) {  NEC MPEG CODEC DOESN'T RESPOND TO THIS ERROR
//                           pbd->ddRVal = DDERR_INVALIDRECT;
//                           return DDHAL_DRIVER_HANDLED;
//                       }

                       if (wSrcXY.xy16.x & 1) {
                           pbd->ddRVal = DDERR_INVALIDRECT;
                           return DDHAL_DRIVER_HANDLED;
                       }

                       if ((src->ddpfSurface.dwFourCC == FOURCC_UYVY) ||
                           (src->ddpfSurface.dwFourCC == FOURCC_UYNV)) {
                           isVideo = 2;
                           // Is this surface DMAable ?
                           if ((pDriverData->fNvActiveFloatingContexts &
                                NV_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                               (pDriverData->NvFloating0UYVYSurfaceMem == src->fpVidMem))
                                   isVideo = 4;
                           else if ((pDriverData->fNvActiveFloatingContexts &
                                NV_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                               (pDriverData->NvFloating1UYVYSurfaceMem == src->fpVidMem))
                                   isVideo = 5;
                       } else { // YUY2
                           isVideo = 3;
                           // Is this surface DMAable ?
                           if ((pDriverData->fNvActiveFloatingContexts &
                                NV_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                               (pDriverData->NvFloating0YUYVSurfaceMem == src->fpVidMem))
                                   isVideo = 6;
                           else if ((pDriverData->fNvActiveFloatingContexts &
                                NV_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                               (pDriverData->NvFloating1YUYVSurfaceMem == src->fpVidMem))
                                   isVideo = 7;
                       }
                       goto srcRGB;
                   break;

                   case FOURCC_YV12:
                       // Size has to be always * 4, to use VU subsampling
                       if ((dwSrcWidth & 3) || (dwSrcHeight & 3)) {
                           pbd->ddRVal = DDERR_INVALIDRECT;
                           return DDHAL_DRIVER_HANDLED;
                       }
                       return DDHAL_DRIVER_HANDLED;
                   break;
               }
               pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
               return DDHAL_DRIVER_HANDLED;
            }

srcRGB:     if (dwDDFX & DDBLTFX_MIRRORUPDOWN)
                doMirrorUpDown = 1;

            if ((dwSrcWidth != dwDstWidth) || (dwSrcHeight != dwDstHeight))
                wStretch = 1;

            if (isVideo > 1) /* YUV video */
                wStretch = 1;

            if (dwFlags & DDBLT_KEYSRCOVERRIDE) {

               dwColorKey = pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;

               /* Let D3D know that we changed the object in subchannel 6 */
               pDriverData->dDrawSpareSubchannel6Object = NV_DD_CONTEXT_COLOR_KEY;

               while (freeCount < 4)
                   NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
               freeCount -= 4;

               // load and enable chroma key
               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_TRANSCOLOR) | 0x40000;
               dmaPusherPutAddress[1] = NV_DD_CONTEXT_COLOR_KEY;
               dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_TRANSCOLOR) +
                   SET_TRANSCOLOR_OFFSET | 0x40000;
               dmaPusherPutAddress[3] =
                    (dwColorKey & pDriverData->physicalColorMask) | NV_ALPHA_1_016;

               dmaPusherPutAddress += 4;

               pDriverData->dwDmaPusherFreeCount = freeCount;

               /* Just in case we return unexpectedly */
               pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;
            }

            // screen to screen bitblt
            if (wStretch == 0) {

                if ((dwDstCaps & DDSCAPS_VIDEOMEMORY) &&
                    (dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                    ((dwSrcCaps & DDSCAPS_TEXTURE) == 0) &&
                    (doMirrorUpDown == 0) &&
                    (isVideo == 0)) {

                    if (pDriverData->dwSharedClipChangeCount != pDriverData->dwDDMostRecentClipChangeCount) {

                        while (freeCount < 7)
                            NvGetDmaBufferFreeCount(npDev, freeCount, 7, dmaPusherPutAddress);
                        freeCount -= 7;

                        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
                        dmaPusherPutAddress[1] = NV_DD_IMAGE_BLACK_RECTANGLE;
                        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                            IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000;
                        dmaPusherPutAddress[3] = 0;
                        dmaPusherPutAddress[4] = asmMergeCoords(NV_MAX_X_CLIP, NV_MAX_Y_CLIP);
                        dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
                        dmaPusherPutAddress[6] = NV_DD_SURFACES_2D;

                        dmaPusherPutAddress += 7;

                        pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                        /* Force write combine buffer to flush */
                        pDriverData->NvDmaPusherBufferEnd[0] = 0;
                        /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                        _outp (0x3d0,0);

                        pDriverData->dwDmaPusherFreeCount = freeCount;

                        npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                        pDriverData->dwSharedClipChangeCount++;

                        pDriverData->dwDDMostRecentClipChangeCount = pDriverData->dwSharedClipChangeCount;
                    }

                    while (freeCount < 10)
                        NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
                    freeCount -= 10;

                    dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                        SET_ROP_OFFSET | 0x40000;
                    dmaPusherPutAddress[1] = dwRop;

                    dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                        SURFACES_2D_PITCH_OFFSET | 0xC0000;
                    dmaPusherPutAddress[3] = (dwDstPitch << 16) | dwSrcPitch;
                    dmaPusherPutAddress[4] = dwSrcOffset;
                    dmaPusherPutAddress[5] = dwDstOffset;

                    dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_BLIT) +
                        BLIT_POINT_IN_OFFSET | 0xC0000;
                    dmaPusherPutAddress[7] = wSrcXY.xy;
                    dmaPusherPutAddress[8] = wDestXY.xy;
                    dmaPusherPutAddress[9] = wXYext.wh;

                    dmaPusherPutAddress += 10;

                } else {
                    // memory to screen blt (src may be in system memory or in video memory)
                   unsigned long temp;
                   long srcScanLength;
                   long nxtSrcScan;
                   short n = wXYext.wh16.h;
                   FAST short pxlCount;
                   unsigned long srcOffset;
                   unsigned char *pSrcInitBits;

                   pSrcInitBits = (unsigned char *)src->fpVidMem;
                   srcScanLength = src->lPitch;

                   if (doMirrorUpDown)
                       wSrcXY.xy16.y += (n - 1);

                   pSrcInitBits += (wSrcXY.xy16.y * srcScanLength);

                   srcOffset = wSrcXY.xy16.x & 1;

                   temp = ((wXYext.wh16.w + 1 + srcOffset) & 0xFFFE);

                   nxtSrcScan = (srcScanLength >> 1) - temp;

                   if (doMirrorUpDown)
                       nxtSrcScan = -(srcScanLength >> 1) - temp;

                   pSrcInitBits += ((wSrcXY.xy16.x & 0xFFFE) << 1);

                   while (freeCount < 15)
                       NvGetDmaBufferFreeCount(npDev, freeCount, 15, dmaPusherPutAddress);
                   freeCount -= 15;

                   if (pDriverData->dDrawSpareSubchannelObject !=
                       NV_DD_IMAGE_BLACK_RECTANGLE) {

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                       dmaPusherPutAddress[1] = NV_DD_IMAGE_BLACK_RECTANGLE;

                       dmaPusherPutAddress += 2;

                       pDriverData->dDrawSpareSubchannelObject =
                       NV_DD_IMAGE_BLACK_RECTANGLE;
                   }

                   /* Let others know that we changed the clip */
                   pDriverData->dwSharedClipChangeCount++;

                   // changing canvas clip avoids manually aligning 16-bit source /
                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) +
                       IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000;
                   dmaPusherPutAddress[1] = wDestXY.xy;
                   dmaPusherPutAddress[2] = wXYext.wh;

                   dmaPusherPutAddress[3] = dDrawSubchannelOffset(NV_DD_ROP) +
                       SET_ROP_OFFSET | 0x40000;
                   dmaPusherPutAddress[4] = dwRop;

                   dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                       SURFACES_2D_DEST_OFFSET | 0x40000;
                   dmaPusherPutAddress[6] = dwDstOffset;
                   dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                       SURFACES_2D_PITCH_OFFSET | 0x40000;
                   dmaPusherPutAddress[8] = (dwDstPitch << 16) | dwDstPitch;

                   dmaPusherPutAddress[9] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                       IMAGE_FROM_CPU_POINT_OFFSET | 0xC0000;
                   dmaPusherPutAddress[10] =
                       asmMergeCoords((wDestXY.xy16.x - srcOffset), wDestXY.xy16.y);
                   dmaPusherPutAddress[11] =
                       asmMergeCoords(wXYext.wh16.w + srcOffset, wXYext.wh16.h);
                   dmaPusherPutAddress[12] =
                       asmMergeCoords(temp, wXYext.wh16.h);

                   dmaPusherPutAddress += 13;

                   {
                       FAST unsigned short *pSrcBits = (unsigned short *)pSrcInitBits;
                       FAST unsigned long tmpPxls0, tmpPxls1, tmpPxls2;

                       if (temp < (1792 << 1)) {
                           while (--n >= 0) {
                               pxlCount = (short)temp;

                               // Get enough buffer space for this scanline
                               while (freeCount < (long)(1 + (temp >> 1)))
                                   NvGetDmaBufferFreeCount(npDev, freeCount, (long)(1 + (temp >> 1)), dmaPusherPutAddress);
                               freeCount -= (long)(1 + (temp >> 1));

                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                   IMAGE_FROM_CPU_COLOR_OFFSET | (temp << 17);
                               dmaPusherPutAddress += 1;

                               while (pxlCount >= 16) {
                                   pxlCount -= 16;

                                   tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                   tmpPxls1 = *(unsigned long *)&pSrcBits[2];
                                   dmaPusherPutAddress[0] = tmpPxls0;
                                   tmpPxls2 = *(unsigned long *)&pSrcBits[4];
                                   dmaPusherPutAddress[1] = tmpPxls1;
                                   tmpPxls0 = *(unsigned long *)&pSrcBits[6];
                                   tmpPxls1 = *(unsigned long *)&pSrcBits[8];
                                   dmaPusherPutAddress[2] = tmpPxls2;
                                   dmaPusherPutAddress[3] = tmpPxls0;
                                   tmpPxls2 = *(unsigned long *)&pSrcBits[10];
                                   tmpPxls0 = *(unsigned long *)&pSrcBits[12];
                                   dmaPusherPutAddress[4] = tmpPxls1;
                                   dmaPusherPutAddress[5] = tmpPxls2;
                                   tmpPxls1 = *(unsigned long *)&pSrcBits[14];
                                   dmaPusherPutAddress[6] = tmpPxls0;
                                   pSrcBits += 16;
                                   dmaPusherPutAddress[7] = tmpPxls1;

                                   dmaPusherPutAddress += 8;
                               }

                               if (pxlCount > 0) {

                                   while (pxlCount >= 4) {
                                       pxlCount -= 4;
                                       tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                       tmpPxls1 = *(unsigned long *)&pSrcBits[2];
                                       pSrcBits += 4;
                                       dmaPusherPutAddress[0] = tmpPxls0;
                                       dmaPusherPutAddress[1] = tmpPxls1;

                                       dmaPusherPutAddress += 2;
                                   }

                                   if (pxlCount > 0) {
                                       tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                       pSrcBits += 2;
                                       dmaPusherPutAddress[0] = tmpPxls0;

                                       dmaPusherPutAddress++;
                                   }
                               }
                               pSrcBits += nxtSrcScan;
                               /* Force write combine buffer to flush */
                               pDriverData->NvDmaPusherBufferEnd[0] = 0;
                               /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                               _outp (0x3d0,0);

                               pDriverData->dwDmaPusherFreeCount = freeCount;

                               npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                           }
                       } else { /* more than 1792 dwords per scanline */

                           while (--n >= 0) {
                               pxlCount = (short)temp;

                               while (pxlCount >= 16) {
                                   pxlCount -= 16;

                                   while (freeCount < (1 + (16 >> 1)))
                                       NvGetDmaBufferFreeCount(npDev, freeCount, (1 + (16 >> 1)), dmaPusherPutAddress);
                                   freeCount -= (1 + (16 >> 1));

                                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                       IMAGE_FROM_CPU_COLOR_OFFSET | (16 << 17);

                                   tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                   tmpPxls1 = *(unsigned long *)&pSrcBits[2];
                                   dmaPusherPutAddress[1] = tmpPxls0;
                                   tmpPxls2 = *(unsigned long *)&pSrcBits[4];
                                   dmaPusherPutAddress[2] = tmpPxls1;
                                   tmpPxls0 = *(unsigned long *)&pSrcBits[6];
                                   tmpPxls1 = *(unsigned long *)&pSrcBits[8];
                                   dmaPusherPutAddress[3] = tmpPxls2;
                                   dmaPusherPutAddress[4] = tmpPxls0;
                                   tmpPxls2 = *(unsigned long *)&pSrcBits[10];
                                   tmpPxls0 = *(unsigned long *)&pSrcBits[12];
                                   dmaPusherPutAddress[5] = tmpPxls1;
                                   dmaPusherPutAddress[6] = tmpPxls2;
                                   tmpPxls1 = *(unsigned long *)&pSrcBits[14];
                                   dmaPusherPutAddress[7] = tmpPxls0;
                                   pSrcBits += 16;
                                   dmaPusherPutAddress[8] = tmpPxls1;

                                   dmaPusherPutAddress += 9;
                               }

                               if (pxlCount > 0) {

                                   while (freeCount < (1 + (pxlCount >> 1)))
                                       NvGetDmaBufferFreeCount(npDev, freeCount, (1 + (pxlCount >> 1)), dmaPusherPutAddress);
                                   freeCount -= (1 + (pxlCount >> 1));

                                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                       IMAGE_FROM_CPU_COLOR_OFFSET | (pxlCount << 17);
                                   dmaPusherPutAddress += 1;

                                   while (pxlCount >= 4) {
                                       pxlCount -= 4;
                                       tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                       tmpPxls1 = *(unsigned long *)&pSrcBits[2];
                                       pSrcBits += 4;
                                       dmaPusherPutAddress[0] = tmpPxls0;
                                       dmaPusherPutAddress[1] = tmpPxls1;

                                       dmaPusherPutAddress += 2;
                                   }

                                   if (pxlCount > 0) {
                                       tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                       pSrcBits += 2;
                                       dmaPusherPutAddress[0] = tmpPxls0;

                                       dmaPusherPutAddress++;
                                   }
                               }
                               pSrcBits += nxtSrcScan;
                               /* Force write combine buffer to flush */
                               pDriverData->NvDmaPusherBufferEnd[0] = 0;
                               /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                               _outp (0x3d0,0);

                               pDriverData->dwDmaPusherFreeCount = freeCount;

                               npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                           }
                       }
                   }

                   pDriverData->dwSharedClipChangeCount++;

                   pDriverData->dwDDMostRecentClipChangeCount = pDriverData->dwSharedClipChangeCount;

                   while (freeCount < 3)
                       NvGetDmaBufferFreeCount(npDev, freeCount, 3, dmaPusherPutAddress);
                   freeCount -= 3;

                   // restore canvas clip
                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) +
                       IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000;
                   dmaPusherPutAddress[1] = 0;
                   dmaPusherPutAddress[2] = asmMergeCoords(NV_MAX_X_CLIP, NV_MAX_Y_CLIP);
                   dmaPusherPutAddress += 3;
                }
            } else { // stretch
                RECT rDummy;
                BOOL isOverlappingVmem = FALSE;
                FLATPTR lpSurfTemp = 0;
                DWORD dwSrcBitsPP = 16;
                BOOL useStretched = FALSE;

                /*
                 *  Fractional positioning bands of the SCALED IMAGE class when downscaling
                 *  vertically by small amounts is just too hard to get correct so we switch to the
                 *  STRETCHED IMAGE class when that occurs.
                 */

                if ((!(dwSrcCaps & DDSCAPS_VIDEOMEMORY)) && (dwSrcHeight > dwDstHeight))
                    useStretched = TRUE;

                // if the source and destination overlap, then we must do this in 2 passes, first copy the source
                // image somewhere else, and then so the stretch from there.
                if ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) && dwSrcOffset == dwDstOffset && IntersectRect(&rDummy, (LPRECT)(&pbd->rSrc), (LPRECT)(&pbd->rDest))) {
                    NVHEAP_ALLOC(lpSurfTemp, dwSrcHeight * ((dwSrcWidth * dwSrcBitsPP / 8 + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad), TYPE_IMAGE);
                    if (lpSurfTemp) {
                        isOverlappingVmem = TRUE;
                        if (pDriverData->dwSharedClipChangeCount != pDriverData->dwDDMostRecentClipChangeCount) {

                            while (freeCount < 7)
                                NvGetDmaBufferFreeCount(npDev, freeCount, 7, dmaPusherPutAddress);
                            freeCount -= 7;

                            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
                            dmaPusherPutAddress[1] = NV_DD_IMAGE_BLACK_RECTANGLE;
                            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                                IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000;
                            dmaPusherPutAddress[3] = 0;
                            dmaPusherPutAddress[4] = asmMergeCoords(NV_MAX_X_CLIP, NV_MAX_Y_CLIP);
                            dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
                            dmaPusherPutAddress[6] = NV_DD_SURFACES_2D;

                            dmaPusherPutAddress += 7;

                            pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                            /* Force write combine buffer to flush */
                            pDriverData->NvDmaPusherBufferEnd[0] = 0;
                            /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                            _outp (0x3d0,0);

                            pDriverData->dwDmaPusherFreeCount = freeCount;

                            npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                            pDriverData->dwSharedClipChangeCount++;

                            pDriverData->dwDDMostRecentClipChangeCount = pDriverData->dwSharedClipChangeCount;
                        }

                        while (freeCount < 10)
                            NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
                        freeCount -= 10;

                        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                            SET_ROP_OFFSET | 0x40000;
                        dmaPusherPutAddress[1] = dwRop;

                        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                            SURFACES_2D_PITCH_OFFSET | 0xC0000;
                        dmaPusherPutAddress[3] = ((((dwSrcWidth * dwSrcBitsPP / 8 + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad)) << 16) | dwSrcPitch;
                        dmaPusherPutAddress[4] = dwSrcOffset;
                        dmaPusherPutAddress[5] = lpSurfTemp - pDriverData->BaseAddress;

                        dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_BLIT) +
                            BLIT_POINT_IN_OFFSET | 0xC0000;
                        dmaPusherPutAddress[7] = wSrcXY.xy;
                        dmaPusherPutAddress[8] = 0;
                        dmaPusherPutAddress[9] = wXYext.wh;

                        dmaPusherPutAddress += 10;

                        dwSrcOffset = lpSurfTemp - pDriverData->BaseAddress;
                        dwSrcPitch = ((dwSrcWidth * dwSrcBitsPP / 8 + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad);
                        wSrcXY.xy = 0;
                        wSrcXY.xy16.x = 0;
                        wSrcXY.xy16.y = 0;
                    } else {
                        // FIXME: vmem heap alloc failed, must do system mem alloc and copy there
                    }
                }
                // WARNING: carefully consider each use of src->fpVidMem and src->lPitch beyond this point
                //          it could screw up overlapping stretchblits

               if ((dwFlags & DDBLT_KEYSRCOVERRIDE) || (useStretched)) { // If color key then MUST use STRETCHED IMAGE instead of SCALED IMAGE
                   NvNotification *pDmaBufferNotifier;
                   unsigned char *pScanlineBuffer;
                   long srcScanLength;
                   long nxtSrcScan;
                   long n;
                   short m;
                   FAST short pxlCount;
                   unsigned char *pSrcInitBits;
                   unsigned char *pSaveSrcBits;
                   unsigned char *pSrcCurScan;
                   long deltaX;
                   long deltaY;
                   long curDstY;
                   long lastDstY;
                   long skipSrcBytes = 0;
                   NVCOORD wSrcExt;
                   NVCOORD wDstPoint;
                   unsigned long srcStrtX;
                   BYTE srcInVideoMemory = 0;
                   BYTE bufState = 0;
                   short skipV = 0;

//                   pSrcInitBits = (unsigned char *)src->fpVidMem;
//                   srcScanLength = src->lPitch;
                   pSrcInitBits = (unsigned char *)(dwSrcOffset + pDriverData->BaseAddress);
                   srcScanLength = dwSrcPitch;

                   if (dwSrcPitch <= 800)
                       m = 16;
                   else if (dwSrcPitch <= 1600)
                       m = 8;
                   else
                       m = 4;

                   while (freeCount < 8)
                       NvGetDmaBufferFreeCount(npDev, freeCount, 8, dmaPusherPutAddress);
                   freeCount -= 8;

                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                       SET_ROP_OFFSET | 0x40000;
                   dmaPusherPutAddress[1] = dwRop;

                   dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                       SURFACES_2D_DEST_OFFSET | 0x40000;
                   dmaPusherPutAddress[3] = dwDstOffset;
                   dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                       SURFACES_2D_PITCH_OFFSET | 0x40000;
                   dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

                   dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;
                   dmaPusherPutAddress[7] = NV_DD_STRETCHED_IMAGE_FROM_CPU;

                   dmaPusherPutAddress += 8;

                   /* calculate deltas in 12.20 format */

                   deltaX = dwDstWidth << 20;
                   deltaX /= dwSrcWidth;

                   if ((deltaX > 0x100000) && (deltaX & 0xFFFFF)) {
                       long xStretch = deltaX & 0xFFF00000;
                       deltaX = (dwDstWidth << 20) + xStretch;
                       deltaX /= dwSrcWidth;
                   }

                   if ((deltaX < 0x100000) && (deltaX & 0xFFFFF)) {
                       deltaX = (dwDstWidth << 20) + 0x100000;
                       deltaX /= dwSrcWidth;
                   }

                   deltaY = dwDstHeight << 20;
                   deltaY /= dwSrcHeight;

                   if ((deltaY > 0x100000) && (deltaY & 0xFFFFF)) {
                       long yStretch = deltaY & 0xFFF00000;
                       deltaY = (dwDstHeight << 20) + yStretch;
                       deltaY /= dwSrcHeight;
                   }

                   if ((deltaY < 0x100000) && (deltaY & 0xFFFFF)) {
                       deltaY = (dwDstHeight << 20) + 0x100000;
                       deltaY /= dwSrcHeight;
                   }

                   wSrcExt.wh16.w = (unsigned short)((dwSrcWidth + 1) & ~1);
                   wSrcExt.wh16.h = (unsigned short)dwSrcHeight;

                   n = (short)dwSrcHeight;

                   if (wSrcXY.xy16.y + n > src->wHeight)
                       n = src->wHeight - wSrcXY.xy16.y;

                   nxtSrcScan = srcScanLength;

                   if (doMirrorUpDown) {
                       wSrcXY.xy16.y += (n - 1);
                       nxtSrcScan = -nxtSrcScan;
                       skipSrcBytes = -skipSrcBytes;
                   }

                   if ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                       ((dwSrcCaps & DDSCAPS_TEXTURE) == 0) &&
                       ((src->fpVidMem >= pDriverData->BaseAddress) || isOverlappingVmem)) {
                       srcInVideoMemory = 1;
                   } else {
                       pSaveSrcBits = (unsigned char *)(pSrcInitBits +
                                      (wSrcXY.xy16.y * srcScanLength));
                       pSaveSrcBits += (wSrcXY.xy16.x << 1);
                       pSrcCurScan = pSaveSrcBits;
                   }

                   if (srcInVideoMemory) {
                       pDmaBufferNotifier = (NvNotification *)pDriverData->NvDmaBufferNotifierFlat;
                       pDmaBufferNotifier++;
                       pScanlineBuffer = (unsigned char *)pDriverData->NvScanlineBufferFlat;

                       wSrcExt.wh16.w = (unsigned short)((dwSrcWidth + 1) & ~1);
                       wSrcExt.wh16.h = m;

                       srcStrtX = wSrcXY.xy16.x;

                       while (freeCount < 2)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                       freeCount -= 2;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) | 0x40000;
                       dmaPusherPutAddress[1] = NV_DD_VIDEO_MEMORY_TO_SYSTEM_MEMORY_FORMAT;

                       dmaPusherPutAddress += 2;

                       // wait for any pending notification operation to finish
                       while ((volatile)pDmaBufferNotifier->status == NV_IN_PROGRESS);

                       pDmaBufferNotifier->status = NV_IN_PROGRESS;

                       while (freeCount < 9)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 9, dmaPusherPutAddress);
                       freeCount -= 9;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                           MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000;

                       dmaPusherPutAddress[1] = dwSrcOffset +
                           ((dwSrcPitch + skipSrcBytes) * (unsigned long)wSrcXY.xy16.y) +
                           ((unsigned long)wSrcXY.xy16.x << 1);

                       dmaPusherPutAddress[2] = NV_DD_NOTIFIER_BLOCK_SIZE + (srcStrtX << 1);

                       dmaPusherPutAddress[3] = (dwSrcPitch + skipSrcBytes);

                       dmaPusherPutAddress[4] = dwSrcPitch;

                       dmaPusherPutAddress[5] = (unsigned long)(wSrcExt.wh16.w << 1);

                       dmaPusherPutAddress[6] = m;

                       dmaPusherPutAddress[7] = (1 << 8) | 1;

                       dmaPusherPutAddress[8] = 0;

                       dmaPusherPutAddress += 9;

                       /* Force write combine buffer to flush */
                       pDriverData->NvDmaPusherBufferEnd[0] = 0;
                       /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                       _outp (0x3d0,0);

                       pDriverData->dwDmaPusherFreeCount = freeCount;

                       npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                       // wait for Dma operation to finish
                       while ((volatile)pDmaBufferNotifier->status == NV_IN_PROGRESS);

                       if (doMirrorUpDown)
                           wSrcXY.xy16.y -= (m + skipV);
                       else
                           wSrcXY.xy16.y += (m + skipV);
                   }

                   /* Convert to 12.4 format */
                   wDstPoint.xy16.x = (wDestXY.xy16.x << 4);
                   wDstPoint.xy16.y = (wDestXY.xy16.y << 4);

                   /* convert to 16.16 */
                   lastDstY = (long)(wDestXY.xy16.y + wXYext.wh16.h) << 16;

                   /* convert to 16.16 */
                   curDstY = (long)(wDestXY.xy16.y << 16);

                   while (freeCount < 7)
                       NvGetDmaBufferFreeCount(npDev, freeCount, 7, dmaPusherPutAddress);
                   freeCount -= 7;

                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                       STRETCHED_IMAGE_SIZE_IN_OFFSET | 0x180000;
                   dmaPusherPutAddress[1] = wSrcExt.wh;
                   dmaPusherPutAddress[2] = deltaX;
                   dmaPusherPutAddress[3] = deltaY;
                   dmaPusherPutAddress[4] = wDestXY.xy;
                   dmaPusherPutAddress[5] = wXYext.wh;
                   dmaPusherPutAddress[6] = wDstPoint.xy;

                   dmaPusherPutAddress += 7;

                   while ((n > 0) && (curDstY < lastDstY)) {
                       FAST unsigned long *pSrcBits;
                       FAST unsigned long tmpPxls0, tmpPxls1, tmpPxls2;

                       if (srcInVideoMemory) {
                           if (bufState == 0)
                               pSrcBits = (unsigned long *)(pScanlineBuffer +
                                   (srcStrtX << 1));
                           else
                               pSrcBits = (unsigned long *)(pScanlineBuffer +
                                   (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1) +
                                   (srcStrtX << 1));

                           pSrcCurScan = (unsigned char *)pSrcBits;

                           if (m > 0) {
                               pDmaBufferNotifier->status = NV_IN_PROGRESS;

                               while (freeCount < 9)
                                   NvGetDmaBufferFreeCount(npDev, freeCount, 9, dmaPusherPutAddress);
                               freeCount -= 9;

                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                   MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000;

                               dmaPusherPutAddress[1] = dwSrcOffset +
                                   ((dwSrcPitch + skipSrcBytes) * (unsigned long)wSrcXY.xy16.y) +
                                   ((unsigned long)wSrcXY.xy16.x << 1);

                               if (bufState == 0)
                                   dmaPusherPutAddress[2] =
                                       NV_DD_NOTIFIER_BLOCK_SIZE +
                                       (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1) +
                                       (srcStrtX << 1);
                               else
                                   dmaPusherPutAddress[2] =
                                       NV_DD_NOTIFIER_BLOCK_SIZE +
                                       (srcStrtX << 1);

                               dmaPusherPutAddress[3] = (dwSrcPitch + skipSrcBytes);

                               dmaPusherPutAddress[4] = dwSrcPitch;

                               dmaPusherPutAddress[5] = (unsigned long)(wSrcExt.wh16.w << 1);

                               dmaPusherPutAddress[6] = m;

                               dmaPusherPutAddress[7] = (1 << 8) | 1;

                               dmaPusherPutAddress[8] = 0;

                               dmaPusherPutAddress += 9;

                               /* Force write combine buffer to flush */
                               pDriverData->NvDmaPusherBufferEnd[0] = 0;
                               /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                               _outp (0x3d0,0);

                               pDriverData->dwDmaPusherFreeCount = freeCount;

                               npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                               bufState ^= 1;

                               if (doMirrorUpDown)
                                   wSrcXY.xy16.y -= (m + skipV);
                               else
                                   wSrcXY.xy16.y += (m + skipV);

                               while (freeCount < 7)
                                   NvGetDmaBufferFreeCount(npDev, freeCount, 7, dmaPusherPutAddress);
                               freeCount -= 7;

                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                                   STRETCHED_IMAGE_SIZE_IN_OFFSET | 0x180000;

                               dmaPusherPutAddress[1] = wSrcExt.wh;

                               dmaPusherPutAddress[2] = deltaX;

                               dmaPusherPutAddress[3] = deltaY;

                               dmaPusherPutAddress[4] = wDestXY.xy;

                               dmaPusherPutAddress[5] = wXYext.wh;

                               dmaPusherPutAddress[6] = wDstPoint.xy;

                               dmaPusherPutAddress += 7;

                               /* Force write combine buffer to flush */
                               pDriverData->NvDmaPusherBufferEnd[0] = 0;
                               /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                               _outp (0x3d0,0);

                               pDriverData->dwDmaPusherFreeCount = freeCount;

                               npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                           }
                       } else { // source in system memory
                           pSrcBits = (unsigned long *)pSrcCurScan;
                           pSrcCurScan += (nxtSrcScan + skipSrcBytes);
                           n--;
                       }

doNxtSrcScan:          pxlCount = (short)((dwSrcWidth + 1) & ~1);

                       if (pxlCount < (1792 << 1)) {

                           // Get enough room for this scanline
                           while (freeCount < (1 + (pxlCount >> 1)))
                               NvGetDmaBufferFreeCount(npDev, freeCount, (1 + (pxlCount >> 1)), dmaPusherPutAddress);
                           freeCount -= (1 + (pxlCount >> 1));

                           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                               STRETCHED_IMAGE_COLOR_OFFSET | (pxlCount << 17);

                           dmaPusherPutAddress += 1;

                           while (pxlCount >= 32) {

                               pxlCount -= 32;

                               tmpPxls0 = pSrcBits[0];
                               tmpPxls1 = pSrcBits[1];
                               dmaPusherPutAddress[0] = tmpPxls0;
                               tmpPxls2 = pSrcBits[2];
                               dmaPusherPutAddress[1] = tmpPxls1;
                               tmpPxls0 = pSrcBits[3];
                               tmpPxls1 = pSrcBits[4];
                               dmaPusherPutAddress[2] = tmpPxls2;
                               dmaPusherPutAddress[3] = tmpPxls0;
                               tmpPxls2 = pSrcBits[5];
                               tmpPxls0 = pSrcBits[6];
                               dmaPusherPutAddress[4] = tmpPxls1;
                               dmaPusherPutAddress[5] = tmpPxls2;
                               tmpPxls1 = pSrcBits[7];
                               tmpPxls2 = pSrcBits[8];
                               dmaPusherPutAddress[6] = tmpPxls0;
                               dmaPusherPutAddress[7] = tmpPxls1;
                               tmpPxls0 = pSrcBits[9];
                               tmpPxls1 = pSrcBits[10];
                               dmaPusherPutAddress[8] = tmpPxls2;
                               dmaPusherPutAddress[9] = tmpPxls0;
                               tmpPxls2 = pSrcBits[11];
                               tmpPxls0 = pSrcBits[12];
                               dmaPusherPutAddress[10] = tmpPxls1;
                               dmaPusherPutAddress[11] = tmpPxls2;
                               tmpPxls1 = pSrcBits[13];
                               tmpPxls2 = pSrcBits[14];
                               dmaPusherPutAddress[12] = tmpPxls0;
                               dmaPusherPutAddress[13] = tmpPxls1;
                               tmpPxls0 = pSrcBits[15];
                               dmaPusherPutAddress[14] = tmpPxls2;
                               pSrcBits += 16;
                               dmaPusherPutAddress[15] = tmpPxls0;

                               dmaPusherPutAddress += 16;
                           }

                           while (pxlCount >= 16) {

                               pxlCount -= 16;

                               tmpPxls0 = pSrcBits[0];
                               tmpPxls1 = pSrcBits[1];
                               dmaPusherPutAddress[0] = tmpPxls0;
                               tmpPxls2 = pSrcBits[2];
                               dmaPusherPutAddress[1] = tmpPxls1;
                               tmpPxls0 = pSrcBits[3];
                               tmpPxls1 = pSrcBits[4];
                               dmaPusherPutAddress[2] = tmpPxls2;
                               dmaPusherPutAddress[3] = tmpPxls0;
                               tmpPxls2 = pSrcBits[5];
                               tmpPxls0 = pSrcBits[6];
                               dmaPusherPutAddress[4] = tmpPxls1;
                               dmaPusherPutAddress[5] = tmpPxls2;
                               tmpPxls1 = pSrcBits[7];
                               pSrcBits += 8;
                               dmaPusherPutAddress[6] = tmpPxls0;
                               dmaPusherPutAddress[7] = tmpPxls1;

                               dmaPusherPutAddress += 8;
                           }

                           while (pxlCount >= 2) {
                               pxlCount -= 2;
                               tmpPxls0 = pSrcBits[0];
                               pSrcBits += 1;
                               dmaPusherPutAddress[0] = tmpPxls0;

                               dmaPusherPutAddress += 1;
                           }

                       } else { /* more than 1792 dwords per scanline */

                           while (pxlCount >= 32) {

                               pxlCount -= 32;

                               while (freeCount < (1 + (32 >> 1)))
                                   NvGetDmaBufferFreeCount(npDev, freeCount, (1 + (32 >> 1)), dmaPusherPutAddress);
                               freeCount -= (1 + (32 >> 1));

                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                                   STRETCHED_IMAGE_COLOR_OFFSET | (32 << 17);

                               dmaPusherPutAddress += 1;

                               tmpPxls0 = pSrcBits[0];
                               tmpPxls1 = pSrcBits[1];
                               dmaPusherPutAddress[0] = tmpPxls0;
                               tmpPxls2 = pSrcBits[2];
                               dmaPusherPutAddress[1] = tmpPxls1;
                               tmpPxls0 = pSrcBits[3];
                               tmpPxls1 = pSrcBits[4];
                               dmaPusherPutAddress[2] = tmpPxls2;
                               dmaPusherPutAddress[3] = tmpPxls0;
                               tmpPxls2 = pSrcBits[5];
                               tmpPxls0 = pSrcBits[6];
                               dmaPusherPutAddress[4] = tmpPxls1;
                               dmaPusherPutAddress[5] = tmpPxls2;
                               tmpPxls1 = pSrcBits[7];
                               tmpPxls2 = pSrcBits[8];
                               dmaPusherPutAddress[6] = tmpPxls0;
                               dmaPusherPutAddress[7] = tmpPxls1;
                               tmpPxls0 = pSrcBits[9];
                               tmpPxls1 = pSrcBits[10];
                               dmaPusherPutAddress[8] = tmpPxls2;
                               dmaPusherPutAddress[9] = tmpPxls0;
                               tmpPxls2 = pSrcBits[11];
                               tmpPxls0 = pSrcBits[12];
                               dmaPusherPutAddress[10] = tmpPxls1;
                               dmaPusherPutAddress[11] = tmpPxls2;
                               tmpPxls1 = pSrcBits[13];
                               tmpPxls2 = pSrcBits[14];
                               dmaPusherPutAddress[12] = tmpPxls0;
                               dmaPusherPutAddress[13] = tmpPxls1;
                               tmpPxls0 = pSrcBits[15];
                               dmaPusherPutAddress[14] = tmpPxls2;
                               pSrcBits += 16;
                               dmaPusherPutAddress[15] = tmpPxls0;

                               dmaPusherPutAddress += 16;
                           }

                           while (pxlCount >= 16) {

                               pxlCount -= 16;

                               while (freeCount < (1 + (16 >> 1)))
                                   NvGetDmaBufferFreeCount(npDev, freeCount, (1 + (16 >> 1)), dmaPusherPutAddress);
                               freeCount -= (1 + (16 >> 1));

                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                                   STRETCHED_IMAGE_COLOR_OFFSET | (16 << 17);

                               dmaPusherPutAddress += 1;

                               tmpPxls0 = pSrcBits[0];
                               tmpPxls1 = pSrcBits[1];
                               dmaPusherPutAddress[0] = tmpPxls0;
                               tmpPxls2 = pSrcBits[2];
                               dmaPusherPutAddress[1] = tmpPxls1;
                               tmpPxls0 = pSrcBits[3];
                               tmpPxls1 = pSrcBits[4];
                               dmaPusherPutAddress[2] = tmpPxls2;
                               dmaPusherPutAddress[3] = tmpPxls0;
                               tmpPxls2 = pSrcBits[5];
                               tmpPxls0 = pSrcBits[6];
                               dmaPusherPutAddress[4] = tmpPxls1;
                               dmaPusherPutAddress[5] = tmpPxls2;
                               tmpPxls1 = pSrcBits[7];
                               pSrcBits += 8;
                               dmaPusherPutAddress[6] = tmpPxls0;
                               dmaPusherPutAddress[7] = tmpPxls1;

                               dmaPusherPutAddress += 8;
                           }

                           if (pxlCount >= 2) {
                               while (freeCount < (1 + (pxlCount >> 1)))
                                   NvGetDmaBufferFreeCount(npDev, freeCount, (1 + (pxlCount >> 1)), dmaPusherPutAddress);
                               freeCount -= (1 + (pxlCount >> 1));

                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                                   STRETCHED_IMAGE_COLOR_OFFSET | (pxlCount << 17);

                               dmaPusherPutAddress++;
                           }

                           while (pxlCount >= 2) {
                               pxlCount -= 2;
                               tmpPxls0 = pSrcBits[0];
                               pSrcBits += 1;
                               dmaPusherPutAddress[0] = tmpPxls0;

                               dmaPusherPutAddress++;
                           }
                       }

                       /* Force write combine buffer to flush */
                       pDriverData->NvDmaPusherBufferEnd[0] = 0;
                       /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                       _outp (0x3d0,0);

                       pDriverData->dwDmaPusherFreeCount = freeCount;

                       npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                       if (srcInVideoMemory) {
                           if (--m > 0) {
                               pSrcCurScan += dwSrcPitch;

                               pSrcBits = (unsigned long *)pSrcCurScan;

                               goto doNxtSrcScan;
                           } else {
                               if (dwSrcPitch <= 800) {
                                   m = 16;
                                   curDstY += deltaY;
                               } else if (dwSrcPitch <= 1600) {
                                   m = 8;
                                   curDstY += (deltaY >> 1);
                               } else {
                                   m = 4;
                                   curDstY += (deltaY >> 2);
                               }
                                                   /* convert 16.16 to 12.4 */
                               wDstPoint.xy16.y = (short)(curDstY >> 12);

                               // wait for DMA operation to finish
                               while ((volatile)pDmaBufferNotifier->status == NV_IN_PROGRESS);
                           }
                       }
                   }

                   if (srcInVideoMemory) {

                       while (freeCount < 2)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                       freeCount -= 2;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) | 0x40000;
                       dmaPusherPutAddress[1] = NV_DD_IMAGE_FROM_CPU;

                       dmaPusherPutAddress += 2;
                   }

                   /* restore default object */
                   while (freeCount < 2)
                       NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                   freeCount -= 2;

                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;
                   dmaPusherPutAddress[1] = NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;

                   dmaPusherPutAddress += 2;

               } else { // OK to use SCALED IMAGE
                   NvNotification *pDmaDmaFromMemNotifier;
                   unsigned char *pScanlineBuffer;
                   unsigned char *npPixelBuf;
                   long srcScanLength;
                   long nxtSrcScan;
                   unsigned long n;
                   unsigned char *pSrcInitBits;
                   unsigned char *pSaveSrcInitBits;
                   unsigned short *pSaveSrcBits;
                   unsigned short *pSrcCurScan;
                   long srcDeltaX;
                   long srcDeltaY;
                   long skipDeltaY = 0;
                   unsigned long dstDeltaScans;
                   unsigned long dstDeltaX;
                   long dstDeltaY;
                   long srcInitFract;
                   long srcStartFract;
                   long srcStartY;
                   long srcCurFract;
                   long srcCurY;
                   long srcDeltaYPerBand;
                   long srcDeltaScans;
                   long srcCurDeltaScans;
                   long xStretch;
                   long yStretch;
                   long srcBufferPitch;
                   long skipSrcBytes = 0;
                   long dstStartY;
                   long dstCurY;
                   long curV;
                   long skipV = 0;
                   long m;
                   NVCOORD wSrcPoint;
                   NVCOORD wSrcExt;
                   NVCOORD wDstPoint;
                   NVCOORD wDstExt;
                   BYTE srcInVideoMemory = 0;
                   BYTE srcTooWide = 0;
                   short curBuffer;
//// These are for working around NV4 scaled image bug
                   DWORD scaledImageObjectID = NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;
                   DWORD curClipPoint;
                   DWORD curClipExtent;
                   DWORD curDUDX;
                   DWORD curDVDY;
//// End of NV4 workaround variables

//                   pSrcInitBits = (unsigned char *)src->fpVidMem;
//                   srcScanLength = src->lPitch;
                   pSrcInitBits = (unsigned char *)(dwSrcOffset + pDriverData->BaseAddress);
                   srcScanLength = dwSrcPitch;

                   while (freeCount < 6)
                       NvGetDmaBufferFreeCount(npDev, freeCount, 6, dmaPusherPutAddress);
                   freeCount -= 6;

                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                       SET_ROP_OFFSET | 0x40000;
                   dmaPusherPutAddress[1] = dwRop;

                   dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                       SURFACES_2D_DEST_OFFSET | 0x40000;
                   dmaPusherPutAddress[3] = dwDstOffset;
                   dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                       SURFACES_2D_PITCH_OFFSET | 0x40000;
                   dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

                   dmaPusherPutAddress += 6;

                   pDriverData->dwDmaPusherFreeCount = freeCount;

                   /* Just in case we return unexpectedly */
                   pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                   srcBufferPitch = ((dwSrcWidth << 1) + 3) & ~3L;

                   srcDeltaScans = (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1) -   /* allow for 2 extra src scanlines */
                            NV_DD_NOTIFIER_BLOCK_SIZE - (srcBufferPitch << 1); /* buffer contains several separate notifiers */

                   srcDeltaScans /= srcBufferPitch;

                   /* Limiting source scans per DMA increases parallelism */
                   if (srcDeltaScans > 32)
                       srcDeltaScans = 32;
                   else if (srcDeltaScans > 16)
                       srcDeltaScans = 16;
                   else if (srcDeltaScans > 8)
                       srcDeltaScans = 8;
                   else if (srcDeltaScans > 4)
                       srcDeltaScans = 4;
                   else
                       srcDeltaScans = 2;

                   /* Check for divide by 0 */
                   if ((dwDstWidth < 1) || (dwDstHeight < 1)) {
                       pbd->ddRVal = DDERR_INVALIDRECT;
                       return DDHAL_DRIVER_HANDLED;
                   }

                   /* Check if within NV hardware supported range */
                   if ((dwDstWidth > 2047) || (dwDstHeight > 2047)) {
                       return DDHAL_DRIVER_NOTHANDLED;
                   }

                   srcDeltaX = dwSrcWidth << 20;
                   srcDeltaX /= dwDstWidth;

                   /*
                    * This fudge factor prevents us from running out of source pixels
                    * when the source starting position is fractional resulting in
                    * a true final width of dwSrcWidth - fraction. Unfortunately
                    * this fudge factor also causes problems when it is important
                    * to end on exactly the right source pixel.  The uglier of the 2 cases
                    * is to run out of source pixels so I opted to leave the fudge
                    * factor in. It works by enlarging the destination by a factor
                    * equivalent to 1 source pixel resulting in slightly enlarging
                    * the stretch factor on each source pixel.
                    */

                   if (srcDeltaX < 0x100000) {
                       xStretch = 0x40000000 / (srcDeltaX >> 10);
                       xStretch >>= 20;
                       srcDeltaX = dwSrcWidth << 20;
                       srcDeltaX /= (dwDstWidth + xStretch);
                   }

                   srcDeltaY = dwSrcHeight << 20;
                   srcDeltaY /= dwDstHeight;

                   /* Algorithm can't handle a scale factor that is too large */
                   if (srcDeltaY > 0x40000000) {
                       pbd->ddRVal = DDERR_INVALIDRECT;
                       return DDHAL_DRIVER_HANDLED;
                   }

                   /* If shrinking in vertical direction then adjust to skip src scanlines */
                   if (srcDeltaY >= (srcDeltaScans << 20)) { /* limit Y delta range to acceptable range */
                       skipDeltaY = srcDeltaY;
                       skipSrcBytes = srcScanLength;
                       skipV = 1;
                       while (srcDeltaY >= (srcDeltaScans << 20)) {
                           srcDeltaY >>= 1;
                           skipSrcBytes <<= 1;
                           skipV <<= 1;
                           skipDeltaY <<= 1;
                       }
                       skipSrcBytes -= srcScanLength;
                       skipV -= 1;
                       skipDeltaY -= srcDeltaY;
                   }

                   /* Algorithm can't handle scale factor that is too small */
                   if ((srcDeltaY & 0xFFFFFC00) == 0) {
                       pbd->ddRVal = DDERR_INVALIDRECT;
                       return DDHAL_DRIVER_HANDLED;
                   }

                   yStretch = 0x40000000 / ((srcDeltaY + 0x00000200) >> 10);

                   dstDeltaY = srcDeltaScans * yStretch;  // how many dst scanlines will srcDeltaScans scanlines generate

                   dstDeltaScans = dstDeltaY >> 20;

                   if (dstDeltaScans == 0) { /* if shrinking too much then can't handle */
                       return DDHAL_DRIVER_NOTHANDLED;
                   }

                   if (wSrcXY.xy16.y + dwSrcHeight > src->wHeight)
                       dwSrcHeight = src->wHeight - wSrcXY.xy16.y;

                   nxtSrcScan = (srcScanLength >> 1);

                   srcDeltaYPerBand = dstDeltaScans * (srcDeltaY + skipDeltaY);

                   if (doMirrorUpDown) {
                       wSrcXY.xy16.y += (short)(dwSrcHeight - 1);
                       srcDeltaY =- srcDeltaY;
                       srcDeltaYPerBand = -srcDeltaYPerBand;
                       skipDeltaY = -skipDeltaY;
                       nxtSrcScan = -nxtSrcScan;
                       skipSrcBytes = -skipSrcBytes;
                   }

                   pDmaDmaFromMemNotifier = (NvNotification *)pDriverData->NvDmaDmaFromMemNotifierFlat;
                   pScanlineBuffer = (unsigned char *)pDriverData->NvScanlineBufferFlat;

                   if (srcDeltaY > 0)
                       srcCurY = 0;
                   else
                       srcCurY = ((long)dwSrcHeight << 20);

                   wSrcPoint.xy = 0;

                   /* Calculate initial source fractional X */
                   if ((srcDeltaX > 0x40000000) || ((srcDeltaX & 0xFFFFFC00) == 0)) {
                       pbd->ddRVal = DDERR_INVALIDRECT;
                       return DDHAL_DRIVER_HANDLED;
                   }

                   /* Do this math in 16.16 precision to avoid 12. overflow */
                   dstDeltaX = ((long)wSrcXY.xy16.x << 16) / (srcDeltaX >> 4);

                   /* Do this math in 16.16 precision to avoid 12. overflow */
                   srcInitFract = dstDeltaX * (srcDeltaX >> 4);

                   /* Do this math in 16.16 precision to avoid 12. overflow */
                   while (srcInitFract >> 16 < wSrcXY.xy16.x)
                       srcInitFract += (srcDeltaX >> 4);

                   /* Convert to 12.4 format */
                   wSrcPoint.xy16.x = (short)((srcInitFract & 0xFFFF) >> 12);

                        // DMAable ?
                   if ((isVideo > 3) || ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                       ((dwSrcCaps & DDSCAPS_TEXTURE) == 0) &&
                       ((src->fpVidMem >= pDriverData->BaseAddress) || isOverlappingVmem))) {

                       srcInitFract = 0;

                       if (srcDeltaY > 0) {
                           /* Calculate initial source fractional Y */
                           /* Do this math in 16.16 precision to avoid 12. overflow */
                           dstDeltaY = ((long)wSrcXY.xy16.y << 16) / (srcDeltaY  >> 4);

                           /* Do this math in 16.16 precision to avoid 12. overflow */
                           srcInitFract = dstDeltaY * (srcDeltaY >> 4);

                           /* Do this math in 16.16 precision to avoid 12. overflow */
                           while (srcInitFract >> 16 < wSrcXY.xy16.y)
                               srcInitFract += (srcDeltaY >> 4);

                           /* Convert result back to 12.20 precision */
                           srcInitFract <<= 4;

                           srcInitFract &= 0xFFFFF;
                       }

                       srcCurY += srcInitFract;

                       srcCurFract = srcInitFract;

                       if (isVideo < 4) {
                           srcInVideoMemory = 1;

                           if (doMirrorUpDown) {
                               pSaveSrcBits = (unsigned short *)
                                  (pSrcInitBits - pDriverData->BaseAddress);
                               wSrcPoint.xy16.y += ((short)(dwSrcHeight - 1) << 4);
                           } else {
                               wSrcPoint.xy16.y += (short)(srcCurFract >> 16);

                               pSaveSrcBits = (unsigned short *)
                                  ((pSrcInitBits - pDriverData->BaseAddress) +
                                   (wSrcXY.xy16.y * srcScanLength));
                           }

                       } else { // source is in DMAable system memory

                           if (doMirrorUpDown) {
                               pSaveSrcBits = 0;
                               wSrcPoint.xy16.y += ((short)(dwSrcHeight - 1) << 4);
                           } else {
                               wSrcPoint.xy16.y += (short)(srcCurFract >> 16);

                               pSaveSrcBits = (unsigned short *)
                                  (wSrcXY.xy16.y * srcScanLength);
                           }
                       }

                       pSaveSrcBits += wSrcXY.xy16.x;

                       while (freeCount < 2)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                       freeCount -= 2;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;

                       if (isVideo < 2)
                           scaledImageObjectID = NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
                       else if (isVideo == 2)
                           scaledImageObjectID = NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY;
                       else if (isVideo == 3)
                           scaledImageObjectID = NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY;
                       else if (isVideo == 4)
                           scaledImageObjectID = NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                       else if (isVideo == 5)
                           scaledImageObjectID = NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                       else if (isVideo == 6)
                           scaledImageObjectID = NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
                       else if (isVideo == 7)
                           scaledImageObjectID = NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;

                       dmaPusherPutAddress[1] = scaledImageObjectID;

                       dmaPusherPutAddress += 2;

                   } else {
                       pSaveSrcBits = (unsigned short *)(pSrcInitBits +
                           (wSrcXY.xy16.y * srcScanLength));
                       pSaveSrcBits += wSrcXY.xy16.x;
                       pSrcCurScan = pSaveSrcBits;

                       while (freeCount < 2)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                       freeCount -= 2;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;

                       if (isVideo == 2)
                           scaledImageObjectID = NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                       else if (isVideo == 3)
                           scaledImageObjectID = NV_DD_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;

                       /* NOTE: This may load the default scaledImageObjectID */
                       dmaPusherPutAddress[1] = scaledImageObjectID;

                       dmaPusherPutAddress += 2;
                   }

                   pSaveSrcInitBits = (unsigned char *)pSaveSrcBits;

                   curClipPoint = wDestXY.xy;
                   curClipExtent = wXYext.wh;
                   curDUDX = srcDeltaX;
                   if (srcDeltaY > 0)
                       curDVDY = srcDeltaY;
                   else
                       curDVDY = -srcDeltaY;

                   while (freeCount < 6)
                       NvGetDmaBufferFreeCount(npDev, freeCount, 6, dmaPusherPutAddress);
                   freeCount -= 6;

                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                       SCALED_IMAGE_CLIPPOINT_OFFSET | 0x80000;
                   dmaPusherPutAddress[1] = curClipPoint;
                   dmaPusherPutAddress[2] = curClipExtent;
                   dmaPusherPutAddress[3] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                       SCALED_IMAGE_DELTADUDX_OFFSET | 0x80000;
                   dmaPusherPutAddress[4] = curDUDX;
                   dmaPusherPutAddress[5] = curDVDY;

                   dmaPusherPutAddress += 6;

                   wDstExt.wh = wXYext.wh;

                   /* NV4 Scaled Image class requires source width to be even */
                   dwSrcWidth = (dwSrcWidth + 1) & ~1;

                   /* NV3 hardware can only handle a maximum source width of 1024 */
                   if (dwSrcWidth > 1024) {
                       srcTooWide = 1;
                       xStretch = 0x40000000 / (srcDeltaX >> 10);
                       dstDeltaX = (xStretch * 1024) >> 20;
                       wDstExt.wh16.w = (unsigned short)dstDeltaX;
                       srcBufferPitch = 2048;
                   }

                   // Let the world know we are doing DMA operations
//                   pDriverData->NvDmaFromMemSurfaceMem = src->fpVidMem;
                   pDriverData->NvDmaFromMemSurfaceMem = dwSrcOffset + pDriverData->BaseAddress;

oneMorePass:       n = dwDstHeight;

                   srcCurY &= 0xFFF00000;

                   srcInitFract = 0;

                   if (srcDeltaY > 0) {
                       /* Calculate initial source fractional Y */
                       /* Do this math in 16.16 precision to avoid 12. overflow */
                       dstDeltaY = ((long)wSrcXY.xy16.y << 16) / (srcDeltaY  >> 4);

                       /* Do this math in 16.16 precision to avoid 12. overflow */
                       srcInitFract = dstDeltaY * (srcDeltaY >> 4);

                       /* Do this math in 16.16 precision to avoid 12. overflow */
                       while (srcInitFract >> 16 < wSrcXY.xy16.y)
                           srcInitFract += (srcDeltaY >> 4);

                       /* Convert result back to 12.20 precision */
                       srcInitFract <<= 4;

                       srcInitFract &= 0xFFFFF;
                   }

                   srcCurY += srcInitFract;

                   srcCurFract = srcInitFract;

                   curV = srcCurY >> 20;

                   wDstPoint.xy = wDestXY.xy;

                   dstStartY = dstCurY = wDestXY.xy16.y;

                   curBuffer = 0;

                   if ((srcInVideoMemory) || (isVideo > 3)) { // DMAable ?

                       // wait for any pending notification operation to finish
// should not be necessary   while ((volatile)pDmaDmaFromMemNotifier->status == NV_IN_PROGRESS);

                       pDmaDmaFromMemNotifier->status = NV_IN_PROGRESS;

                       while (freeCount < 11)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
                       freeCount -= 11;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_OUT_POINT_OFFSET | 0x80000;
                       dmaPusherPutAddress[1] = wDstPoint.xy;
                       dmaPusherPutAddress[2] = wDstExt.wh;
                       dmaPusherPutAddress[3] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET | 0xC0000;

                       if ((dwSrcWidth < 16) && (isVideo < 4)) { // workaround for NV3 Rev B hardware bug (only happens if source is in video memory)
                           dmaPusherPutAddress[4] =
                               asmMergeCoords(dwSrcPitch, dwSrcHeight);
                       } else {
                           dmaPusherPutAddress[4] =
                               asmMergeCoords(dwSrcWidth, dwSrcHeight);
                       }

                       dmaPusherPutAddress[5] =
                           (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |
                           (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                           dwSrcPitch;

                       dmaPusherPutAddress[6] = (unsigned long)pSaveSrcBits;

                       dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_NOTIFY_OFFSET | 0x40000;
                       dmaPusherPutAddress[8] = 0;
                       dmaPusherPutAddress[9] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_IN_POINT_OFFSET | 0x40000;
                       dmaPusherPutAddress[10] = wSrcPoint.xy;

                       dmaPusherPutAddress += 11;

                       /* Force write combine buffer to flush */
                       pDriverData->NvDmaPusherBufferEnd[0] = 0;
                       /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                       _outp (0x3d0,0);

                       pDriverData->dwDmaPusherFreeCount = freeCount;

                       npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                       n = 0;
                   } else {
                       // wait for any pending notification operation to finish
                       while ((volatile)pDmaDmaFromMemNotifier->status == NV_IN_PROGRESS);
                   }

                   while (n >= dstDeltaScans) {
                       FAST unsigned long *pSrcBits;

                       n -= dstDeltaScans;
                       srcStartY = srcCurY;
                       srcStartFract = srcCurFract;
                       srcCurY += srcDeltaYPerBand;

                       if (doMirrorUpDown) {
                           if (((srcCurY - 0x100000) >> 20) < 0)
                               srcCurY = 0x100000;
                       } else {
                           if (((srcCurY + 0x100000) >> 20) >  ((long)dwSrcHeight - 1))
                               srcCurY = ((long)dwSrcHeight - 2) << 20;
                       }

                       srcCurFract = srcCurY & 0xFFFFF;

                       if (curBuffer == 0)
                           npPixelBuf = (unsigned char *)pScanlineBuffer;
                       else
                           npPixelBuf = (unsigned char *)(pScanlineBuffer +
                               (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1));

                       /* Must recalculate on each pass since src scanlines may be used more than once */
                       pSrcBits = (unsigned long *)(pSaveSrcInitBits +
                                  (curV * (nxtSrcScan << 1)));
                       pSrcCurScan = (unsigned short *)pSrcBits;

                       if (doMirrorUpDown)
                           m = (srcStartY >> 20) - ((srcCurY - 0x100000) >> 20);
                       else
                           m = ((srcCurY + 0x100000) >> 20) - (srcStartY >> 20);

                       srcCurDeltaScans = 0;

                       /* Copy and convert a block of source pixels to transfer buffer */
                       while (--m >= 0) {

                           if (pSrcBits >= (unsigned long *)pSrcInitBits) {
  //                           asmCopyScan(pSrcBits, npPixelBuf, srcBufferPitch);
                               _asm
                               {
#ifdef P6
                                   mov ecx, dword ptr srcBufferPitch
                                   mov esi, dword ptr pSrcBits
                                   shr ecx, 5
                    nxtCacheLine2: mov eax, [esi]
                                   add esi, 32
                                   dec ecx
                                   jg nxtCacheLine2
#endif /* P6 */
                                   mov ecx, dword ptr srcBufferPitch
                                   mov esi, dword ptr pSrcBits
                                   shr ecx, 2
                                   mov edi, dword ptr npPixelBuf
                                   test ecx, 1
                                   jz doQwords2
                                   mov eax, [esi]
                                   add esi, 4
                                   mov [edi], eax
                                   add edi, 4
                        doQwords2: shr ecx, 1
                                   jz copyDone2
#ifdef MMX
                        nxtQword2: movq mm1, qword ptr [esi]
                                   add esi, 8
                                   movq qword ptr [edi], mm1
                                   add edi, 8
                                   dec ecx
#else /* MMX */
                        nxtQword2: mov eax, [esi]
                                   mov edx, [esi+4]
                                   add edi, 8
                                   add esi, 8
                                   dec ecx
                                   mov [edi-8], eax
                                   mov [edi-4], edx
#endif /* MMX */
                        copyDone2: jg nxtQword2
                               }
                           }
                           npPixelBuf += srcBufferPitch;
                           pSrcCurScan += (nxtSrcScan + skipSrcBytes);
                           pSrcBits = (unsigned long *)pSrcCurScan;
                           srcCurDeltaScans++;
                           m -= skipV;
                       }

                       /* wait for Dma operation to finish */
                       while (pDmaDmaFromMemNotifier->status == NV_IN_PROGRESS);

                       pDmaDmaFromMemNotifier->status = NV_IN_PROGRESS;

                       wDstPoint.xy16.y = (short)dstCurY;
                       wDstExt.wh16.h = (unsigned short)dstDeltaScans;
                       wSrcPoint.xy16.y = (short)(srcStartFract >> 16); /* convert V to 12.4 */
                       wSrcExt.wh = srcCurDeltaScans;
                       wSrcExt.wh <<= 16;    /* shift V extent into place */
                       wSrcExt.wh |= dwSrcWidth;

//// BEGIN WORKAROUND FOR NV4 SCALED IMAGE HARDWARE BUG

                       while (freeCount < 8)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 8, dmaPusherPutAddress);
                       freeCount -= 8;

                       /* Reload object */
                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;
                       dmaPusherPutAddress[1] = scaledImageObjectID;
                       /* Reinitialize volatile methods */
                       dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_CLIPPOINT_OFFSET | 0x80000;
                       dmaPusherPutAddress[3] = curClipPoint;
                       dmaPusherPutAddress[4] = curClipExtent;
                       dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_DELTADUDX_OFFSET | 0x80000;
                       dmaPusherPutAddress[6] = curDUDX;
                       dmaPusherPutAddress[7] = curDVDY;

                       dmaPusherPutAddress += 8;

//// END WORKAROUND FOR NV4 SCALED IMAGE HARDWARE BUG

                       while (freeCount < 11)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
                       freeCount -= 11;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_OUT_POINT_OFFSET | 0x80000;
                       dmaPusherPutAddress[1] = wDstPoint.xy;
                       dmaPusherPutAddress[2] = wDstExt.wh;
                       dmaPusherPutAddress[3] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET | 0xC0000;
                       dmaPusherPutAddress[4] = wSrcExt.wh;
                       dmaPusherPutAddress[5] =
                           (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |
                           (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                           srcBufferPitch;

                       if (curBuffer == 0)
                           dmaPusherPutAddress[6] =
                               NV_DD_NOTIFIER_BLOCK_SIZE;  /* There are several notifiers in the buffer */
                       else
                           dmaPusherPutAddress[6] =
                               NV_DD_NOTIFIER_BLOCK_SIZE + (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1);

                       dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_NOTIFY_OFFSET | 0x40000;
                       dmaPusherPutAddress[8] = 0;
                       dmaPusherPutAddress[9] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_IN_POINT_OFFSET | 0x40000;
                       dmaPusherPutAddress[10] = wSrcPoint.xy;

                       dmaPusherPutAddress += 11;

                       /* Force write combine buffer to flush */
                       pDriverData->NvDmaPusherBufferEnd[0] = 0;
                       /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                       _outp (0x3d0,0);

                       pDriverData->dwDmaPusherFreeCount = freeCount;

                       npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                       curBuffer ^= 1;

                       dstCurY += dstDeltaScans;

                       curV = srcCurY >> 20;
                   }

                   if (n > 0) {
                       FAST unsigned long *pSrcBits;

                       srcStartY = srcCurY;
                       srcStartFract = srcCurFract;
                       srcCurY += srcDeltaYPerBand;

                       if (doMirrorUpDown) {
                           if (((srcCurY - 0x100000) >> 20) < 0)
                               srcCurY = 0x100000;
                       } else {
                           if (((srcCurY + 0x100000) >> 20) > ((long)dwSrcHeight - 1))
                               srcCurY = ((long)dwSrcHeight - 2) << 20;
                       }

                       srcCurFract = srcCurY & 0xFFFFF;

                       if (curBuffer == 0)
                           npPixelBuf = (unsigned char *)pScanlineBuffer;
                       else
                           npPixelBuf = (unsigned char *)(pScanlineBuffer +
                               (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1));

                       /* Must recalculate since src scanlines may be used more than once */
                       pSrcBits = (unsigned long *)(pSaveSrcInitBits +
                                  (curV * (nxtSrcScan << 1)));
                       pSrcCurScan = (unsigned short *)pSrcBits;

                       if (doMirrorUpDown)
                           m = (srcStartY >> 20) - ((srcCurY - 0x100000) >> 20);
                       else
                           m = ((srcCurY + 0x100000) >> 20) - (srcStartY >> 20);

                       srcCurDeltaScans = 0;

                       /* Copy and convert a block of source pixels to transfer buffer */
                       while (--m >= 0) {
                           if (pSrcBits >= (unsigned long *)pSrcInitBits) {
  //                           asmCopyScan(pSrcBits, npPixelBuf, srcBufferPitch);
                               _asm
                               {
#ifdef P6
                                   mov ecx, dword ptr srcBufferPitch
                                   mov esi, dword ptr pSrcBits
                                   shr ecx, 5
                     nxtCacheLine: mov eax, [esi]
                                   add esi, 32
                                   dec ecx
                                   jg nxtCacheLine
#endif /* P6 */
                                   mov ecx, dword ptr srcBufferPitch
                                   mov esi, dword ptr pSrcBits
                                   shr ecx, 2
                                   mov edi, dword ptr npPixelBuf
                                   test ecx, 1
                                   jz doQwords
                                   mov eax, [esi]
                                   add esi, 4
                                   mov [edi], eax
                                   add edi, 4
                         doQwords: shr ecx, 1
                                   jz copyDone
#ifdef MMX
                         nxtQword: movq mm1, qword ptr [esi]
                                   add esi, 8
                                   movq qword ptr [edi], mm1
                                   add edi, 8
                                   dec ecx
#else /* MMX */
                         nxtQword: mov eax, [esi]
                                   mov edx, [esi+4]
                                   add edi, 8
                                   add esi, 8
                                   dec ecx
                                   mov [edi-8], eax
                                   mov [edi-4], edx
#endif /* MMX */
                         copyDone: jg nxtQword
                               }
                           }
                           npPixelBuf += srcBufferPitch;
                           pSrcCurScan += (nxtSrcScan + skipSrcBytes);
                           pSrcBits = (unsigned long *)pSrcCurScan;
                           srcCurDeltaScans++;
                           m -= skipV;
                       }

                       /* wait for Dma operation to finish */
                       while (pDmaDmaFromMemNotifier->status == NV_IN_PROGRESS);

                       pDmaDmaFromMemNotifier->status = NV_IN_PROGRESS;

                       wDstPoint.xy16.y = (short)dstCurY;
                       wDstExt.wh16.h = (unsigned short)n;
                       wSrcPoint.xy16.y = (short)(srcStartFract >> 16); /* convert V to 12.4 */
                       wSrcExt.wh = srcCurDeltaScans;
                       wSrcExt.wh <<= 16;    /* shift V extent into place */
                       wSrcExt.wh |= dwSrcWidth;

//// BEGIN WORKAROUND FOR NV4 SCALED IMAGE HARDWARE BUG

                       while (freeCount < 8)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 8, dmaPusherPutAddress);
                       freeCount -= 8;

                       /* Reload object */
                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;
                       dmaPusherPutAddress[1] = scaledImageObjectID;
                       /* Reinitialize volatile methods */
                       dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_CLIPPOINT_OFFSET | 0x80000;
                       dmaPusherPutAddress[3] = curClipPoint;
                       dmaPusherPutAddress[4] = curClipExtent;
                       dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_DELTADUDX_OFFSET | 0x80000;
                       dmaPusherPutAddress[6] = curDUDX;
                       dmaPusherPutAddress[7] = curDVDY;

                       dmaPusherPutAddress += 8;

//// END WORKAROUND FOR NV4 SCALED IMAGE HARDWARE BUG

                       while (freeCount < 11)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
                       freeCount -= 11;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_OUT_POINT_OFFSET | 0x80000;
                       dmaPusherPutAddress[1] = wDstPoint.xy;
                       dmaPusherPutAddress[2] = wDstExt.wh;
                       dmaPusherPutAddress[3] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET | 0xC0000;
                       dmaPusherPutAddress[4] = wSrcExt.wh;
                       dmaPusherPutAddress[5] =
                           (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |
                           (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                           srcBufferPitch;

                       if (curBuffer == 0)
                           dmaPusherPutAddress[6] =
                               NV_DD_NOTIFIER_BLOCK_SIZE;  /* There are several notifiers in the buffer */
                       else
                           dmaPusherPutAddress[6] =
                               NV_DD_NOTIFIER_BLOCK_SIZE + (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1);

                       dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_NOTIFY_OFFSET | 0x40000;
                       dmaPusherPutAddress[8] = 0;
                       dmaPusherPutAddress[9] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_IN_POINT_OFFSET | 0x40000;
                       dmaPusherPutAddress[10] = wSrcPoint.xy;

                       dmaPusherPutAddress += 11;

                       /* Force write combine buffer to flush */
                       pDriverData->NvDmaPusherBufferEnd[0] = 0;
                       /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                       _outp (0x3d0,0);

                       pDriverData->dwDmaPusherFreeCount = freeCount;

                       npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                   }

                   if (srcTooWide) {
                       srcTooWide = 0;
                       wDestXY.xy16.x += (short)dstDeltaX;
                       wDstExt.wh16.w = wXYext.wh16.w - wDstExt.wh16.w;
                       if ((srcInVideoMemory) || (isVideo > 3))
                           wSrcPoint.xy16.x += (1024 << 4);
                       srcBufferPitch = ((dwSrcWidth << 1) + 3) & ~3L;
                       srcBufferPitch -= 2048;
                       pSaveSrcInitBits += 2048;
                       pSaveSrcBits = (unsigned short *)pSaveSrcInitBits;
                       pSrcCurScan = pSaveSrcBits;
                       goto oneMorePass;
                   }
#ifdef  MMX
                   if (curV != 0) {
                      _asm emms;
                   }
#endif /* MMX */
                }   // stretch

                if (isOverlappingVmem && lpSurfTemp) {
                    // FIXME: wait for blt to complete
                    NVHEAP_FREE(lpSurfTemp);
                }
            }

            if (dwFlags & DDBLT_KEYSRCOVERRIDE) {
                // disable chroma key
                while (freeCount < 2)
                    NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                freeCount -= 2;

                dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_TRANSCOLOR) +
                    SET_TRANSCOLOR_OFFSET | 0x40000;
                dmaPusherPutAddress[1] = 0;

                dmaPusherPutAddress += 2;
            }

        } else {
            DPF("BLT     blt not handled by driver");
            return DDHAL_DRIVER_NOTHANDLED;
        }

        // restore pixel depth for z blts
        if (isZBlt) {
            while (freeCount < 2)
                NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
            freeCount -= 2;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;

            dmaPusherPutAddress += 2;
        }

    } else if (dwFlags & DDBLT_COLORFILL) {
        dwFillColor = pbd->bltFX.dwFillColor & pDriverData->physicalColorMask;

        while (freeCount < 10)
            NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
        freeCount -= 10;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
            SET_ROP_OFFSET | 0x40000;
        dmaPusherPutAddress[1] = SRCCOPYINDEX;

        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
            SURFACES_2D_DEST_OFFSET | 0x40000;
        dmaPusherPutAddress[3] = dwDstOffset;
        dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
            SURFACES_2D_PITCH_OFFSET | 0x40000;
        dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

        dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
            RECT_AND_TEXT_COLOR1A_OFFSET | 0xC0000;
        dmaPusherPutAddress[7] = dwFillColor;
        dmaPusherPutAddress[8] = asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);
        dmaPusherPutAddress[9] = asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

        dmaPusherPutAddress += 10;

    } else if (dwFlags & DDBLT_DEPTHFILL) {

        if (!(dwDstCaps & DDSCAPS_ZBUFFER)) {
            pbd->ddRVal = DDERR_INVALIDSURFACETYPE;
            return DDHAL_DRIVER_HANDLED;
        }

        pDriverData->dwDmaPusherFreeCount = freeCount;
        (unsigned long *)pDriverData->NvDmaPusherPutAddress = dmaPusherPutAddress;
        nvD3DClearZBuffer(dstx, pbd->bltFX.dwFillDepth);
        dmaPusherPutAddress = (unsigned long *)pDriverData->NvDmaPusherPutAddress;
#ifdef  CACHE_FREECOUNT
        freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
        freeCount = 0;
#endif  /* CACHE_FREECOUNT */

    } else {
        /* We don't handle any other type of BLT operation */
        return DDHAL_DRIVER_NOTHANDLED;
    }

    pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

    /* Force write combine buffer to flush */
    pDriverData->NvDmaPusherBufferEnd[0] = 0;
    /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
    _outp (0x3d0,0);

    pDriverData->dwDmaPusherFreeCount = freeCount;

    npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

    pbd->ddRVal = DD_OK;

    return DDHAL_DRIVER_HANDLED;

} /* Blt16bpp32 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\UVWRAP.H ===
#define WRAP(uv, wrap)                      \
{                                           \
    if (wrap)                               \
    {                                       \
        float el,er,em;                     \
        el=(float)fabs(uv##2 - uv##0);      \
        er=(float)fabs(uv##1 - uv##2);      \
        em=(float)fabs(uv##0 - uv##1);      \
        if (el > 0.5f && er > 0.5f)         \
        {                                   \
            if (uv##2 < uv##1)              \
            {                               \
                uv##2 += 1.0f;              \
            }                               \
            else                            \
            {                               \
                uv##1 += 1.0f;              \
                uv##0 += 1.0f;              \
            }                               \
        }                                   \
        else if (er > 0.5f && em > 0.5f)    \
        {                                   \
            if (uv##1 < uv##0)              \
            {                               \
                uv##1 += 1.0f;              \
            }                               \
            else                            \
            {                               \
                uv##0 += 1.0f;              \
                uv##2 += 1.0f;              \
            }                               \
        }                                   \
        else if (em > 0.5f && el > 0.5f)    \
        {                                   \
            if (uv##0 < uv##2)              \
            {                               \
                uv##0 += 1.0f;              \
            }                               \
            else                            \
            {                               \
                uv##2 += 1.0f;              \
                uv##1 += 1.0f;              \
            }                               \
        }                                   \
    }                                       \
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\blt3232.c ===
/*==========================================================================;
 *
 *  Copyright (C) 1995, 1998 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       blt3232.c
 *  Content:    Windows95 DirectDraw 32 bit driver
 *
 ***************************************************************************/

#include "windows.h"
#include <conio.h>
#include "nvd3ddrv.h"
#include "nv32.h"
#include "nvddobj.h"
#include "ddrvmem.h"
#include "d3dinc.h"
#include "nvrmapi.h"
#include "nvrmarch.inc"
#include "nvheap.h"

extern DWORD ResetNV();

/*
 * Blt32bpp32
 *
 * 32-bit Blt function for 32bpp surfaces.
 */
DWORD __stdcall Blt32bpp32( LPDDHAL_BLTDATA pbd )
{
    FAST Nv10ControlDma *npDev;
    DWORD               dwFlags;
#ifdef  DX7
    DWORD               dwAFlags;
#endif  /* DX7 */
    DWORD               dwDDFX = 0;
    DWORD               dwDstCaps;
    DWORD               dwSrcCaps;
    DWORD               dwRop;
    NVCOORD             wXYext;
    NVCOORD             wDestXY;
    NVCOORD             wSrcXY;
    BYTE                wStretch = 0;
    BYTE                doMirrorUpDown = 0;
    BYTE                doBilinearFiltering = 0;
    BYTE                isVideo = 0;
    BYTE                isAlphaBlt = 0;
    BYTE                isZBlt = 0;
    BYTE                isNoAlphaSrc = 0;
    BYTE                isKeySrc = 0;
    BYTE                isClipped = 0;

    DWORD               dwFillColor;
    DWORD               dwMultipliers;
    DWORD               dwColorKey;

    DWORD               dwDstOffset;
    DWORD               dwDstPitch;
    DWORD               dwDstWidth;
    DWORD               dwDstHeight;

    DWORD               dwSrcOffset;
    DWORD               dwSrcPitch;
    DWORD               dwSrcWidth;
    DWORD               dwSrcHeight;

    LPDDRAWI_DDRAWSURFACE_LCL  srcx;
    LPDDRAWI_DDRAWSURFACE_LCL  dstx;
    LPDDRAWI_DDRAWSURFACE_GBL  src;
    LPDDRAWI_DDRAWSURFACE_GBL  dst;

    unsigned long       *dmaPusherPutAddress =
                            (unsigned long *)pDriverData->NvDmaPusherPutAddress;
    unsigned long       *dmaPusherBufferBase =
                            (unsigned long *)pDriverData->NvDmaPusherBufferBase;
    long                freeCount;

    dstx = pbd->lpDDDestSurface;
    dst = dstx->lpGbl;

    /*
     * NOTES:
     *
     * Everything you need is in pdb->bltFX .
     * Look at pdb->dwFlags to determine what kind of blt you are doing,
     * DDBLT_xxxx are the flags.
     *
     * Z BUFFER NOTES:
     *
     * ZBuffer ALWAYS comes in BLTFX.   You don't need to go looking for
     * the attached surface. If DDBLT_ZBUFFER is specified, then either a
     * constant z or z buffer surface has been specified for the source and
     * destination. Just look for the DDBLT_ZBUFFERDESTOVERRIDE,
     * DDBLT_ZBUFFERSRCOVERRIDE, DDBLT_ZBUFFERCONSTANTDESTOVERRIDE, or
     * DDBLT_ZBUFFERCONSTANTSRCOVERRIDE.
     *
     * COLORKEY NOTES:
     *
     * ColorKey ALWAY comes in BLTFX.   You don't have to look it up in
     * the surface.
     */

    dwFlags   = pbd->dwFlags;
    dwDstCaps = dstx->ddsCaps.dwCaps;

#ifdef  DX7
    /*
     * Check for AlphaBlt call
     */
    dwAFlags  = pbd->dwAFlags;

    if ((dwFlags & DDBLT_AFLAGS) && (dwAFlags & DDABLT_SRCOVERDEST)) {
        isAlphaBlt = 1;
        if (dwAFlags & DDABLT_KEYDEST) {
            DPF("AlphaBlt Dest color key failed");
            pbd->ddRVal = DDERR_NOCOLORKEYHW;
            return DDHAL_DRIVER_HANDLED;
        }
        if (dwAFlags & DDABLT_MIRRORLEFTRIGHT) {
            DPF("AlphaBlt mirror left/right failed");
            pbd->ddRVal = DDERR_NOMIRRORHW;
            return DDHAL_DRIVER_HANDLED;
        }
        if (pbd->IsClipped)
            isClipped = 1;
    }
#endif  /* DX7 */

    // check for z buffer blit
    // assume that DD runtime has enough sense to make alpha blits mutually exclusive
    if ((dwDstCaps & DDSCAPS_ZBUFFER) && (dstx->dwFlags & DDRAWISURF_HASPIXELFORMAT)) {
        if (dst->ddpfSurface.dwZBufferBitDepth == 32)
            isZBlt = NV042_SET_COLOR_FORMAT_LE_Y32;
        else if (dst->ddpfSurface.dwZBufferBitDepth == 16)
            isZBlt = NV042_SET_COLOR_FORMAT_LE_Y16;
    }

    if (dwFlags & DDBLT_DDFX)
        dwDDFX = pbd->bltFX.dwDDFX;

    if (dwFlags & (DDBLT_KEYDEST | DDBLT_KEYDESTOVERRIDE)) {
        DPF("Dest color key failed");
        pbd->ddRVal = DDERR_NOCOLORKEYHW;
        return DDHAL_DRIVER_HANDLED;
    }

    /*
     * get offset, width, and height for destination
     */
    dwDstOffset = dst->fpVidMem     - pDriverData->BaseAddress;
    dwDstPitch  = dst->lPitch;
    dwDstWidth  = pbd->rDest.right  - pbd->rDest.left;
    dwDstHeight = pbd->rDest.bottom - pbd->rDest.top;
    wXYext.wh16.w = (unsigned short)dwDstWidth;
    wXYext.wh16.h = (unsigned short)dwDstHeight;

    wDestXY.xy16.x = (short)pbd->rDest.left;
    wDestXY.xy16.y = (short)pbd->rDest.top;

#ifndef NV_TEX2
    /*
     * Check for a 32 Bpp texture blit right away.
     */
    if (dwDstCaps & DDSCAPS_TEXTURE) {

#ifdef WINNT
    /*
     * Some MS apps insist on passing us DX7 AlphaBlts even though we never
     * claim DX7 support. Our texblt code requires a source, so return
     * an error if the src is not present.
     */
        if (!pbd->lpDDSrcSurface) {
            pbd->ddRVal = DDERR_INVALIDPARAMS;
            return DDHAL_DRIVER_HANDLED;
        }
#endif
        /*
         * Call the special D3D Texture blit code to handle this blit.
         */
        nvTextureBlit32Bpp(pbd);

        /*
         * Return successfully.
         */
        pbd->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }
#endif //!NV_TEX2

    if (dwDstCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM))
        return DDHAL_DRIVER_NOTHANDLED;

    /*
     * Let 3D code know we did some 2D rendering
     */
    pDriverData->TwoDRenderingOccurred = 1;

    npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

    if (npDev == NULL) {
        if (!ResetNV()) {
            pbd->ddRVal = DDERR_GENERIC;
            return(DDHAL_DRIVER_HANDLED);
        }
        pDriverData->fReset = FALSE;
        npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

        if (npDev == NULL) {
            pbd->ddRVal = DDERR_SURFACELOST;
            return DDHAL_DRIVER_HANDLED;
        }
    }

    dmaPusherPutAddress = (unsigned long *)pDriverData->NvDmaPusherPutAddress;

#ifdef  CACHE_FREECOUNT
    freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
    freeCount = 0;
#endif  /* CACHE_FREECOUNT */

    if (pDriverData->ddClipUpdate) {

        while (freeCount < 7)
            NvGetDmaBufferFreeCount(npDev, freeCount, 7, dmaPusherPutAddress);
        freeCount -= 7;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
        dmaPusherPutAddress[1] = NV_DD_IMAGE_BLACK_RECTANGLE;
        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
            IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000;
        dmaPusherPutAddress[3] = 0;
        dmaPusherPutAddress[4] = asmMergeCoords(NV_MAX_X_CLIP, NV_MAX_Y_CLIP);
        dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
        dmaPusherPutAddress[6] = NV_DD_SURFACES_2D;

        dmaPusherPutAddress += 7;

        pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

        /* Force write combine buffer to flush */
        pDriverData->NvDmaPusherBufferEnd[0] = 0;
        /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
        _outp (0x3d0,0);

        pDriverData->dwDmaPusherFreeCount = freeCount;

        npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

        pDriverData->dwSharedClipChangeCount++;

        pDriverData->dwDDMostRecentClipChangeCount = pDriverData->dwSharedClipChangeCount;

        pDriverData->ddClipUpdate = FALSE;
    }

    /*
     * If async, then only work if bltter isn't busy
     * This should probably be a little more specific to each call, but
     * waiting for 32 is pretty close
     */
    if( dwFlags & DDBLT_ASYNC ) {

        NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);

        pDriverData->dwDmaPusherFreeCount = freeCount;

        /* Must save pointer in case it was changed by above macro */
        pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

        if (freeCount < 10) {
            DPF("ASYNC FAILED");
            pbd->ddRVal = DDERR_WASSTILLDRAWING;
            return DDHAL_DRIVER_HANDLED;
        }
    }

    /* Check for AlphaBlt fill operation */
    if ((isAlphaBlt) && (pbd->lpDDSrcSurface == 0)) {

        while (freeCount < 12)
            NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
        freeCount -= 12;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) +
            SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000;
        dmaPusherPutAddress[1] = NV042_SET_COLOR_FORMAT_LE_A8R8G8B8;

        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
            SURFACES_2D_DEST_OFFSET | 0x40000;
        dmaPusherPutAddress[3] = dwDstOffset;
        dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
            SURFACES_2D_PITCH_OFFSET | 0x40000;
        dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

        dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
        dmaPusherPutAddress[7] = NV_DD_CONTEXT_BETA4;
#ifdef  DX7
        dwMultipliers = pbd->ddrgbaScaleFactors.alpha << 24;
        dwMultipliers |= pbd->ddrgbaScaleFactors.red << 16;
        dwMultipliers |= pbd->ddrgbaScaleFactors.green << 8;
        dwMultipliers |= pbd->ddrgbaScaleFactors.blue;
#endif  /* DX7 */
        dmaPusherPutAddress[8] = dDrawSubchannelOffset(NV_DD_SPARE) +
            BETA4_SET_BETA_FACTOR_OFFSET | 0x40000;
        dmaPusherPutAddress[9] = dwMultipliers;

        dmaPusherPutAddress[10] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) | 0x40000;
        dmaPusherPutAddress[11] = NV_DD_ABLEND_RECT_AND_TEXT;

        dmaPusherPutAddress += 12;

        if (isClipped) {
            DWORD nRects = pbd->dwRectCnt;
            LPRECT pClipRects = pbd->prDestRects;
            NVCOORD clipPoint0;
            NVCOORD clipPoint1;

            wDestXY.xy16.x = (short)pbd->rOrigDest.left;
            wDestXY.xy16.y = (short)pbd->rOrigDest.top;
            wXYext.xy16.x  = (short)pbd->rOrigDest.right;
            wXYext.xy16.y  = (short)pbd->rOrigDest.bottom;

            while (freeCount < 2)
                NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
            freeCount -= 2;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_COLOR1A_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = 0xFFFFFFFF;

            dmaPusherPutAddress += 2;

            while (--nRects >= 0) {

                clipPoint0.xy16.x = (short)pClipRects->left;
                clipPoint0.xy16.y = (short)pClipRects->top;
                clipPoint1.xy16.x = (short)pClipRects->right;
                clipPoint1.xy16.y = (short)pClipRects->bottom;
                pClipRects++;

                while (freeCount < 6)
                    NvGetDmaBufferFreeCount(npDev, freeCount, 6, dmaPusherPutAddress);
                freeCount -= 6;

                dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                    RECT_AND_TEXT_CLIPPOINT0B_OFFSET | 0x80000;
                dmaPusherPutAddress[1] = clipPoint0.xy;
                dmaPusherPutAddress[2] = clipPoint1.xy;
                dmaPusherPutAddress[3] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                    RECT_AND_TEXT_CLIPPEDRECT_POINT0_OFFSET | 0x80000;
                dmaPusherPutAddress[4] = wDestXY.xy;
                dmaPusherPutAddress[5] = wXYext.xy;

                dmaPusherPutAddress += 6;
            }

        } else {

            /* unclipped AlphaBlt MUST clip to destination */
            if (wDestXY.xy16.x < 0)
                wDestXY.xy16.x = 0;
            if (wDestXY.xy16.y < 0)
                wDestXY.xy16.y = 0;
            if (wDestXY.xy16.x + wXYext.wh16.w > dst->wWidth)
                wXYext.wh16.w = dst->wWidth - wDestXY.xy16.x;
            if (wDestXY.xy16.y + wXYext.wh16.h > dst->wHeight)
                wXYext.wh16.h = dst->wHeight - wDestXY.xy16.y;
            /* handle NULL destination rectangle case */
            if ((wDestXY.xy16.x == 0) && (wXYext.wh16.w == 0))
                wXYext.wh16.w = dst->wWidth;
            if ((wDestXY.xy16.y == 0) && (wXYext.wh16.h == 0))
                wXYext.wh16.h = dst->wHeight;

            while (freeCount < 4)
                NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
            freeCount -= 4;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_COLOR1A_OFFSET | 0xC0000;
            dmaPusherPutAddress[1] = 0xFFFFFFFF;
            dmaPusherPutAddress[2] = asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);
            dmaPusherPutAddress[3] = asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

            dmaPusherPutAddress += 4;
        }

        while (freeCount < 4)
            NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
        freeCount -= 4;

        /* Restore default objects */
        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) | 0x40000;
        dmaPusherPutAddress[1] = NV_DD_ROP_GDI_RECT_AND_TEXT;

        /* Restore default destination color format */
        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
            SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000;
        dmaPusherPutAddress[3] = NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;

        dmaPusherPutAddress += 4;

        pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

        /* Force write combine buffer to flush */
        pDriverData->NvDmaPusherBufferEnd[0] = 0;
        /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
        _outp (0x3d0,0);

        pDriverData->dwDmaPusherFreeCount = freeCount;

        npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

        pbd->ddRVal = DD_OK;

        return DDHAL_DRIVER_HANDLED;
    }

    if ((dwFlags & DDBLT_ROP) || ((isAlphaBlt) && (pbd->lpDDSrcSurface != 0))) {

        // set pixel depth for z buffer blit
        if (isZBlt) {
            while (freeCount < 2)
                NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
            freeCount -= 2;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = isZBlt;

            dmaPusherPutAddress += 2;
        }

        if (isAlphaBlt)
            dwRop = SRCCOPYINDEX;
        else
            dwRop = pbd->bltFX.dwROP >> 16;

        if ((dwRop == BLACKNESSINDEX) || (dwRop == WHITENESSINDEX)) {

            while (freeCount < 10)
                NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
            freeCount -= 10;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                SET_ROP_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = dwRop;

            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_DEST_OFFSET | 0x40000;
            dmaPusherPutAddress[3] = dwDstOffset;
            dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_PITCH_OFFSET | 0x40000;
            dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

            dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_COLOR1A_OFFSET | 0xC0000;
            dmaPusherPutAddress[7] = 0;
            dmaPusherPutAddress[8] = asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);
            dmaPusherPutAddress[9] = asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

            dmaPusherPutAddress += 10;

        } else if ((dwRop == PATCOPYINDEX) || (dwRop == PATINVERTINDEX)) {

            dwFillColor = pbd->bltFX.dwFillColor & pDriverData->physicalColorMask;

            if (dwRop == PATCOPYINDEX)
                dwRop = SRCCOPYINDEX;
            else if (dwRop == PATINVERTINDEX)
                dwRop = SRCINVERTINDEX;

            while (freeCount < 10)
                NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
            freeCount -= 10;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                SET_ROP_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = dwRop;

            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_DEST_OFFSET | 0x40000;
            dmaPusherPutAddress[3] = dwDstOffset;
            dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_PITCH_OFFSET | 0x40000;
            dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

            dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_COLOR1A_OFFSET | 0xC0000;
            dmaPusherPutAddress[7] = dwFillColor;
            dmaPusherPutAddress[8] = asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);
            dmaPusherPutAddress[9] = asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

            dmaPusherPutAddress += 10;

        } else if ((dwRop == SRCCOPYINDEX) || (dwRop == SRCPAINTINDEX) ||
                   (dwRop == SRCANDINDEX) || (dwRop == NOTSRCCOPYINDEX) ||
                   (dwRop == SRCINVERTINDEX) || (dwRop == MERGEPAINTINDEX) ||
                   (dwRop == SRCERASEINDEX) || (dwRop == NOTSRCERASEINDEX)) {

            srcx = pbd->lpDDSrcSurface;
            src = srcx->lpGbl;

            dwSrcCaps = srcx->ddsCaps.dwCaps;

            /* We must treat AGP source memory as system memory */
            if (dwSrcCaps & DDSCAPS_NONLOCALVIDMEM)
                dwSrcCaps &= ~(DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM);

            dwSrcOffset = src->fpVidMem    - pDriverData->BaseAddress;
            dwSrcPitch  = src->lPitch;
            dwSrcWidth  = pbd->rSrc.right  - pbd->rSrc.left;
            dwSrcHeight = pbd->rSrc.bottom - pbd->rSrc.top;

            dwColorKey  = pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;

            wSrcXY.xy16.x = (short)pbd->rSrc.left;
            wSrcXY.xy16.y = (short)pbd->rSrc.top;

            if (srcx->dwFlags & DDRAWISURF_HASPIXELFORMAT) {
                if (src->ddpfSurface.dwFlags & DDPF_ALPHAPREMULT) {
                   if ((src->ddpfSurface.dwRGBAlphaBitMask != 0xFF000000) ||
                       (src->ddpfSurface.dwRBitMask != 0x00FF0000) ||
                       (src->ddpfSurface.dwGBitMask != 0x0000FF00) ||
                       (src->ddpfSurface.dwBBitMask != 0x000000FF)) {
                           pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                           return DDHAL_DRIVER_HANDLED;
                       }
                } else if (src->ddpfSurface.dwFlags & DDPF_FOURCC) {

                   if (src->ddpfSurface.dwFourCC == FOURCC_RGB0) {
                       if ((src->ddpfSurface.dwRBitMask == 0x00FF0000) &&
                           (src->ddpfSurface.dwGBitMask == 0x0000FF00) &&
                           (src->ddpfSurface.dwBBitMask == 0x000000FF)) {
                           if (dwSrcCaps & DDSCAPS_SYSTEMMEMORY)
                               isVideo = 1;
                           goto srcRGB;
                       } else {
                           pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                           return DDHAL_DRIVER_HANDLED;
                       }
                   } else if (src->ddpfSurface.dwFourCC == FOURCC_RAW8) {
                       pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                       return DDHAL_DRIVER_HANDLED;
                   }

                   while (freeCount < 6)
                       NvGetDmaBufferFreeCount(npDev, freeCount, 6, dmaPusherPutAddress);
                   freeCount -= 6;

                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                       SET_ROP_OFFSET | 0x40000;
                   dmaPusherPutAddress[1] = SRCCOPYINDEX;

                   dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                       SURFACES_2D_DEST_OFFSET | 0x40000;
                   dmaPusherPutAddress[3] = dwDstOffset;
                   dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                       SURFACES_2D_PITCH_OFFSET | 0x40000;
                   dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

                   dmaPusherPutAddress += 6;

                   /* Just in case we return unexpectedly */
                   pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                   switch (src->ddpfSurface.dwFourCC) {
                       case FOURCC_UYVY:
                       case FOURCC_UYNV:
                       case FOURCC_YUY2:
                       case FOURCC_YUNV:
    //                     if (dwSrcWidth & 1) {  NEC MPEG CODEC DOESN'T RESPOND TO THIS ERROR
    //                           pbd->ddRVal = DDERR_INVALIDRECT;
    //                           return DDHAL_DRIVER_HANDLED;
    //                       }

                           if (wSrcXY.xy16.x & 1) {
                               pbd->ddRVal = DDERR_INVALIDRECT;
                               return DDHAL_DRIVER_HANDLED;
                           }

                           if ((src->ddpfSurface.dwFourCC == FOURCC_UYVY) ||
                               (src->ddpfSurface.dwFourCC == FOURCC_UYNV)) {
                               isVideo = 2;
                               // Is this surface DMAable ?
                               if ((pDriverData->fNvActiveFloatingContexts &
                                    NV_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                   (pDriverData->NvFloating0UYVYSurfaceMem == src->fpVidMem))
                                       isVideo = 4;
                               else if ((pDriverData->fNvActiveFloatingContexts &
                                    NV_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                   (pDriverData->NvFloating1UYVYSurfaceMem == src->fpVidMem))
                                       isVideo = 5;
                           } else { // YUY2
                               isVideo = 3;
                               // Is this surface DMAable ?
                               if ((pDriverData->fNvActiveFloatingContexts &
                                    NV_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                   (pDriverData->NvFloating0YUYVSurfaceMem == src->fpVidMem))
                                       isVideo = 6;
                               else if ((pDriverData->fNvActiveFloatingContexts &
                                    NV_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                   (pDriverData->NvFloating1YUYVSurfaceMem == src->fpVidMem))
                                       isVideo = 7;
                           }
                           goto srcRGB;
                       break;

                       case FOURCC_YV12:
                           // Size has to be always * 4, to use VU subsampling
                           if ((dwSrcWidth & 3) || (dwSrcHeight & 3)) {
                               pbd->ddRVal = DDERR_INVALIDRECT;
                               return DDHAL_DRIVER_HANDLED;
                           }
                           return DDHAL_DRIVER_HANDLED;
                       break;
                   }
                   pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                   return DDHAL_DRIVER_HANDLED;
                }
            }

srcRGB:     if (dwDDFX & DDBLTFX_MIRRORUPDOWN)
                doMirrorUpDown = 1;
#ifdef  DX7
            if ((isAlphaBlt) && (dwAFlags & DDABLT_MIRRORUPDOWN))
                doMirrorUpDown = 1;
#endif  /* DX7 */
            if ((dwSrcWidth != dwDstWidth) || (dwSrcHeight != dwDstHeight)) {
                wStretch = 1;
#ifdef  DX7
                if ((isAlphaBlt) && (dwAFlags & DDABLT_BILINEARFILTER))
                    doBilinearFiltering = 1;
#endif  /* DX7 */
            }

            if (isVideo > 1) { /* YUV video */
                wStretch = 1;
                doBilinearFiltering = 1;
            }

#ifdef  DX7
            if ((dwFlags & DDBLT_KEYSRCOVERRIDE)  || ((isAlphaBlt) && (dwAFlags & DDABLT_KEYSRC))) {
#else   /* DX7 */
            if (dwFlags & DDBLT_KEYSRCOVERRIDE) {
#endif  /* DX7 */
               if (isAlphaBlt) { /* NV4 doesn't support source color key in blended image blit operations */
                   isKeySrc = 1;
                   dwColorKey = srcx->ddckCKSrcBlt.dwColorSpaceLowValue;
               } else
                   dwColorKey = pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;

               /* Let D3D know that we changed the object in subchannel 6 */
               pDriverData->dDrawSpareSubchannel6Object = NV_DD_CONTEXT_COLOR_KEY;

               while (freeCount < 4)
                   NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
               freeCount -= 4;

               // load and enable chroma key
               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_TRANSCOLOR) | 0x40000;
               dmaPusherPutAddress[1] = NV_DD_CONTEXT_COLOR_KEY;
               dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_TRANSCOLOR) +
                   SET_TRANSCOLOR_OFFSET | 0x40000;
               dmaPusherPutAddress[3] =
                    (dwColorKey & pDriverData->physicalColorMask) | NV_ALPHA_1_032;

               dmaPusherPutAddress += 4;

               pDriverData->dwDmaPusherFreeCount = freeCount;

               /* Just in case we return unexpectedly */
               pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

            }

            // screen to screen bitblt
            if (wStretch == 0) {
                if ((dwDstCaps & DDSCAPS_VIDEOMEMORY) &&
                    (dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                    ((dwSrcCaps & DDSCAPS_TEXTURE) == 0) &&
                    (isNoAlphaSrc == 0) &&
                    (isKeySrc == 0) &&
                    (doMirrorUpDown == 0) &&
                    (isVideo == 0)) {

                    if (isAlphaBlt) {

                        while (freeCount < 9)
                            NvGetDmaBufferFreeCount(npDev, freeCount, 9, dmaPusherPutAddress);
                        freeCount -= 9;

                        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                            SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x100000;
                        dmaPusherPutAddress[1] = NV042_SET_COLOR_FORMAT_LE_A8R8G8B8;
                        dmaPusherPutAddress[2] = (dwDstPitch << 16) | dwSrcPitch;
                        dmaPusherPutAddress[3] = dwSrcOffset;
                        dmaPusherPutAddress[4] = dwDstOffset;

                        dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                        dmaPusherPutAddress[6] = NV_DD_CONTEXT_BETA4;
#ifdef  DX7
                        dwMultipliers = pbd->ddrgbaScaleFactors.alpha << 24;
                        dwMultipliers |= pbd->ddrgbaScaleFactors.red << 16;
                        dwMultipliers |= pbd->ddrgbaScaleFactors.green << 8;
                        dwMultipliers |= pbd->ddrgbaScaleFactors.blue;
#endif  /* DX7 */
                        dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_SPARE) +
                            BETA4_SET_BETA_FACTOR_OFFSET | 0x40000;
                        dmaPusherPutAddress[8] = dwMultipliers;

                        dmaPusherPutAddress += 9;

                        if (isClipped) {
                            DWORD nRects = pbd->dwRectCnt;
                            LPRECT pClipRects = pbd->prDestRects;
                            NVCOORD wOrigDestXY;
                            NVCOORD wOrigSrcXY;

                            wOrigDestXY.xy16.x = (short)pbd->rOrigDest.left;
                            wOrigDestXY.xy16.y = (short)pbd->rOrigDest.top;
                            wOrigSrcXY.xy16.x  = (short)pbd->rOrigSrc.left;
                            wOrigSrcXY.xy16.y  = (short)pbd->rOrigSrc.top;
#ifdef  DX7
                            if (dwAFlags & DDABLT_NOBLEND) {

                                while (freeCount < 2)
                                    NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                                freeCount -= 2;

                                dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_BLIT) | 0x40000;
                                dmaPusherPutAddress[1] = NV_DD_SRCCOPY_IMAGE_BLIT;

                                dmaPusherPutAddress += 2;
                            }
#endif  /* DX7 */
                            /* This will need redone to deal with directional copying */
                            while (--nRects >= 0) {
                                wDestXY.xy16.x = (short)pClipRects->left;
                                wDestXY.xy16.y = (short)pClipRects->top;
                                wXYext.wh16.w = (unsigned short)(pClipRects->right - pClipRects->left);
                                wXYext.wh16.h = (unsigned short)(pClipRects->bottom - pClipRects->top);
                                pClipRects++;

                                wSrcXY.xy16.x = wOrigSrcXY.xy16.x +
                                    wDestXY.xy16.x - wOrigDestXY.xy16.x;
                                wSrcXY.xy16.y = wOrigSrcXY.xy16.y +
                                    wDestXY.xy16.y - wOrigDestXY.xy16.y;

                                while (freeCount < 4)
                                    NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
                                freeCount -= 4;

                                dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_BLIT) +
                                    BLIT_POINT_IN_OFFSET | 0xC0000;
                                dmaPusherPutAddress[1] = wSrcXY.xy;
                                dmaPusherPutAddress[2] = wDestXY.xy;
                                dmaPusherPutAddress[3] = wXYext.wh;

                                dmaPusherPutAddress += 4;
                            }
#ifdef  DX7
                            if (dwAFlags & DDABLT_NOBLEND) {

                                while (freeCount < 2)
                                    NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                                freeCount -= 2;

                                dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_BLIT) | 0x40000;
                                dmaPusherPutAddress[1] = NV_DD_IMAGE_BLIT;

                                dmaPusherPutAddress += 2;
                            }
#endif  /* DX7 */
                        } else { /* unclipped */
#ifdef  DX7
                            if (dwAFlags & DDABLT_NOBLEND) {

                                while (freeCount < 2)
                                    NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                                freeCount -= 2;

                                dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_BLIT) | 0x40000;
                                dmaPusherPutAddress[1] = NV_DD_SRCCOPY_IMAGE_BLIT;

                                dmaPusherPutAddress += 2;
                            }
#endif  /* DX7 */
                            /* unclipped AlphaBlt MUST clip to destination */
                            if (wDestXY.xy16.x < 0)
                                wDestXY.xy16.x = 0;
                            if (wDestXY.xy16.y < 0)
                                wDestXY.xy16.y = 0;
                            if (wDestXY.xy16.x + wXYext.wh16.w > dst->wWidth)
                                wXYext.wh16.w = dst->wWidth - wDestXY.xy16.x;
                            if (wDestXY.xy16.y + wXYext.wh16.h > dst->wHeight)
                                wXYext.wh16.h = dst->wHeight - wDestXY.xy16.y;
                            /* handle NULL destination rectangle case */
                            if ((wDestXY.xy16.x == 0) && (wXYext.wh16.w == 0))
                                wXYext.wh16.w = dst->wWidth;
                            if ((wDestXY.xy16.y == 0) && (wXYext.wh16.h == 0))
                                wXYext.wh16.h = dst->wHeight;

                            while (freeCount < 4)
                                NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
                            freeCount -= 4;

                            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_BLIT) +
                                BLIT_POINT_IN_OFFSET | 0xC0000;
                            dmaPusherPutAddress[1] = wSrcXY.xy;
                            dmaPusherPutAddress[2] = wDestXY.xy;
                            dmaPusherPutAddress[3] = wXYext.wh;

                            dmaPusherPutAddress += 4;
#ifdef  DX7
                            if (dwAFlags & DDABLT_NOBLEND) {

                                while (freeCount < 2)
                                    NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                                freeCount -= 2;

                                dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_BLIT) | 0x40000;
                                dmaPusherPutAddress[1] = NV_DD_IMAGE_BLIT;

                                dmaPusherPutAddress += 2;
                            }
#endif  /* DX7 */
                        }

                        while (freeCount < 2)
                            NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                        freeCount -= 2;

                        /* Restore default destination color format */
                        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                            SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x80000;
                        dmaPusherPutAddress[1] = NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;

                        dmaPusherPutAddress += 2;

                    } else { /* regular non-alpha blit */

                        while (freeCount < 10)
                            NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
                        freeCount -= 10;

                        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                            SET_ROP_OFFSET | 0x40000;
                        dmaPusherPutAddress[1] = dwRop;

                        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                            SURFACES_2D_PITCH_OFFSET | 0xC0000;
                        dmaPusherPutAddress[3] = (dwDstPitch << 16) | dwSrcPitch;
                        dmaPusherPutAddress[4] = dwSrcOffset;
                        dmaPusherPutAddress[5] = dwDstOffset;

                        dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_BLIT) +
                            BLIT_POINT_IN_OFFSET | 0xC0000;
                        dmaPusherPutAddress[7] = wSrcXY.xy;
                        dmaPusherPutAddress[8] = wDestXY.xy;
                        dmaPusherPutAddress[9] = wXYext.wh;

                        dmaPusherPutAddress += 10;
                    }

                } else {
                    // memory to screen blt (src may be in system memory or in video memory)
                   unsigned long temp;
                   long srcScanLength;
                   long nxtSrcScan;
                   short n = wXYext.wh16.h;
                   FAST short pxlCount;
                   unsigned long *pSrcInitBits;

                   pSrcInitBits = (unsigned long *)src->fpVidMem;
                   srcScanLength = src->lPitch >> 2;

                   if (doMirrorUpDown)
                       wSrcXY.xy16.y += (n - 1);

                   pSrcInitBits += (wSrcXY.xy16.y * srcScanLength);

                   temp = wXYext.wh16.w;

                   nxtSrcScan = srcScanLength - temp;

                   if (doMirrorUpDown)
                       nxtSrcScan = -srcScanLength - temp;

                   pSrcInitBits += wSrcXY.xy16.x;

                   if (isAlphaBlt) {

                       while (freeCount < 12)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
                       freeCount -= 12;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000;
                       dmaPusherPutAddress[1] = NV042_SET_COLOR_FORMAT_LE_A8R8G8B8;

                       dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_DEST_OFFSET | 0x40000;
                       dmaPusherPutAddress[3] = dwDstOffset;
                       dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_PITCH_OFFSET | 0x40000;
                       dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

                       dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                       dmaPusherPutAddress[7] = NV_DD_CONTEXT_BETA4;
#ifdef  DX7
                       dwMultipliers = pbd->ddrgbaScaleFactors.alpha << 24;
                       dwMultipliers |= pbd->ddrgbaScaleFactors.red << 16;
                       dwMultipliers |= pbd->ddrgbaScaleFactors.green << 8;
                       dwMultipliers |= pbd->ddrgbaScaleFactors.blue;
#endif  /* DX7 */
                       dmaPusherPutAddress[8] = dDrawSubchannelOffset(NV_DD_SPARE) +
                           BETA4_SET_BETA_FACTOR_OFFSET | 0x40000;
                       dmaPusherPutAddress[9] = dwMultipliers;
#ifdef  DX7
                       dmaPusherPutAddress[10] = dDrawSubchannelOffset(NV_DD_IMAGE) | 0x40000;

                       if (dwAFlags & DDABLT_NOBLEND)
                           dmaPusherPutAddress[11] =
                               NV_DD_SRCCOPY_IMAGE_FROM_CPU;
                       else
                           dmaPusherPutAddress[11] =
                               NV_DD_ABLEND_IMAGE_FROM_CPU;

                       dmaPusherPutAddress += 12;
#else   /* DX7 */
                       dmaPusherPutAddress += 10;
#endif  /* DX7 */

                       if (isClipped) {
                           DWORD nRects = pbd->dwRectCnt;
                           LPRECT pClipRects = pbd->prDestRects;
                           NVCOORD wOrigDestXY;
                           NVCOORD wOrigSrcXY;

                           wOrigDestXY.xy16.x = (short)pbd->rOrigDest.left;
                           wOrigDestXY.xy16.y = (short)pbd->rOrigDest.top;
                           wOrigSrcXY.xy16.x  = (short)pbd->rOrigSrc.left;
                           wOrigSrcXY.xy16.y  = (short)pbd->rOrigSrc.top;

                           while (--nRects >= 0) {
                               wDestXY.xy16.x = (short)pClipRects->left;
                               wDestXY.xy16.y = (short)pClipRects->top;
                               wXYext.wh16.w = (unsigned short)(pClipRects->right - pClipRects->left);
                               wXYext.wh16.h = (unsigned short)(pClipRects->bottom - pClipRects->top);
                               pClipRects++;

                               wSrcXY.xy16.x = wOrigSrcXY.xy16.x +
                                   wDestXY.xy16.x - wOrigDestXY.xy16.x;
                               wSrcXY.xy16.y = wOrigSrcXY.xy16.y +
                                   wDestXY.xy16.y - wOrigDestXY.xy16.y;

                               pSrcInitBits = (unsigned long *)src->fpVidMem;

                               n = wXYext.wh16.h;

                               if (doMirrorUpDown)
                                   wSrcXY.xy16.y += (n - 1);

                               pSrcInitBits += (wSrcXY.xy16.y * srcScanLength);

                               temp = wXYext.wh16.w;

                               nxtSrcScan = srcScanLength - temp;

                               if (doMirrorUpDown)
                                   nxtSrcScan = -srcScanLength - temp;

                               pSrcInitBits += wSrcXY.xy16.x;

                               while (freeCount < 4)
                                   NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
                               freeCount -= 4;

                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                   IMAGE_FROM_CPU_POINT_OFFSET | 0xC0000;
                               dmaPusherPutAddress[1] = wDestXY.xy;
                               dmaPusherPutAddress[2] = wXYext.wh;
                               dmaPusherPutAddress[3] = wXYext.wh;

                               dmaPusherPutAddress += 4;

                               {
                                   FAST unsigned long *pSrcBits = (unsigned long *)pSrcInitBits;
                                   FAST unsigned long tmpPxls0, tmpPxls1, tmpPxls2;

                                   if (temp < 1792) {
                                       while (--n >= 0) {
                                           pxlCount = (short)temp;

                                           // Get enough buffer space for this scanline
                                           while (freeCount < (long)(1 + temp))
                                               NvGetDmaBufferFreeCount(npDev, freeCount, (long)(1 + temp), dmaPusherPutAddress);
                                           freeCount -= (long)(1 + temp);

                                           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                               IMAGE_FROM_CPU_COLOR_OFFSET | (temp << 18);

                                           dmaPusherPutAddress += 1;

                                           while (pxlCount >= 16) {
                                               pxlCount -= 16;

                                               tmpPxls0 = pSrcBits[0];
                                               tmpPxls1 = pSrcBits[1];
                                               dmaPusherPutAddress[0] = tmpPxls0;
                                               tmpPxls2 = pSrcBits[2];
                                               dmaPusherPutAddress[1] = tmpPxls1;
                                               tmpPxls0 = pSrcBits[3];
                                               tmpPxls1 = pSrcBits[4];
                                               dmaPusherPutAddress[2] = tmpPxls2;
                                               dmaPusherPutAddress[3] = tmpPxls0;
                                               tmpPxls2 = pSrcBits[5];
                                               tmpPxls0 = pSrcBits[6];
                                               dmaPusherPutAddress[4] = tmpPxls1;
                                               dmaPusherPutAddress[5] = tmpPxls2;
                                               tmpPxls1 = pSrcBits[7];
                                               tmpPxls2 = pSrcBits[8];
                                               dmaPusherPutAddress[6] = tmpPxls0;
                                               dmaPusherPutAddress[7] = tmpPxls1;
                                               tmpPxls0 = pSrcBits[9];
                                               tmpPxls1 = pSrcBits[10];
                                               dmaPusherPutAddress[8] = tmpPxls2;
                                               dmaPusherPutAddress[9] = tmpPxls0;
                                               tmpPxls2 = pSrcBits[11];
                                               tmpPxls0 = pSrcBits[12];
                                               dmaPusherPutAddress[10] = tmpPxls1;
                                               dmaPusherPutAddress[11] = tmpPxls2;
                                               tmpPxls1 = pSrcBits[13];
                                               tmpPxls2 = pSrcBits[14];
                                               dmaPusherPutAddress[12] = tmpPxls0;
                                               dmaPusherPutAddress[13] = tmpPxls1;
                                               tmpPxls0 = pSrcBits[15];
                                               dmaPusherPutAddress[14] = tmpPxls2;
                                               pSrcBits += 16;
                                               dmaPusherPutAddress[15] = tmpPxls0;
                                               dmaPusherPutAddress += 16;
                                           }

                                           if (pxlCount > 0) {
                                               while (--pxlCount >= 0) {
                                                   tmpPxls0 = pSrcBits[0];
                                                   pSrcBits += 1;
                                                   dmaPusherPutAddress[0] = tmpPxls0;
                                                   dmaPusherPutAddress++;
                                               }
                                           }

                                           pSrcBits += nxtSrcScan;

                                           /* Force write combine buffer to flush */
                                           pDriverData->NvDmaPusherBufferEnd[0] = 0;
                                           /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                                           _outp (0x3d0,0);

                                           pDriverData->dwDmaPusherFreeCount = freeCount;

                                           npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                                       }
                                   } else { /* more than 1792 pixels per scanline */
                                       while (--n >= 0) {
                                           pxlCount = (short)temp;

                                           while (pxlCount >= 16) {
                                               pxlCount -= 16;

                                               while (freeCount < (1 + 16))
                                                   NvGetDmaBufferFreeCount(npDev, freeCount, (1 + 16), dmaPusherPutAddress);
                                               freeCount -= (1 + 16);

                                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                                   IMAGE_FROM_CPU_COLOR_OFFSET | (16 << 18);

                                               tmpPxls0 = pSrcBits[0];
                                               tmpPxls1 = pSrcBits[1];
                                               dmaPusherPutAddress[1] = tmpPxls0;
                                               tmpPxls2 = pSrcBits[2];
                                               dmaPusherPutAddress[2] = tmpPxls1;
                                               tmpPxls0 = pSrcBits[3];
                                               tmpPxls1 = pSrcBits[4];
                                               dmaPusherPutAddress[3] = tmpPxls2;
                                               dmaPusherPutAddress[4] = tmpPxls0;
                                               tmpPxls2 = pSrcBits[5];
                                               tmpPxls0 = pSrcBits[6];
                                               dmaPusherPutAddress[5] = tmpPxls1;
                                               dmaPusherPutAddress[6] = tmpPxls2;
                                               tmpPxls1 = pSrcBits[7];
                                               tmpPxls2 = pSrcBits[8];
                                               dmaPusherPutAddress[7] = tmpPxls0;
                                               dmaPusherPutAddress[8] = tmpPxls1;
                                               tmpPxls0 = pSrcBits[9];
                                               tmpPxls1 = pSrcBits[10];
                                               dmaPusherPutAddress[9] = tmpPxls2;
                                               dmaPusherPutAddress[10] = tmpPxls0;
                                               tmpPxls2 = pSrcBits[11];
                                               tmpPxls0 = pSrcBits[12];
                                               dmaPusherPutAddress[11] = tmpPxls1;
                                               dmaPusherPutAddress[12] = tmpPxls2;
                                               tmpPxls1 = pSrcBits[13];
                                               tmpPxls2 = pSrcBits[14];
                                               dmaPusherPutAddress[13] = tmpPxls0;
                                               dmaPusherPutAddress[14] = tmpPxls1;
                                               tmpPxls0 = pSrcBits[15];
                                               dmaPusherPutAddress[15] = tmpPxls2;
                                               pSrcBits += 16;
                                               dmaPusherPutAddress[16] = tmpPxls0;

                                               dmaPusherPutAddress += 17;
                                           }

                                           if (pxlCount > 0) {
                                               while (freeCount < (1 + pxlCount))
                                                   NvGetDmaBufferFreeCount(npDev, freeCount, (1 + pxlCount), dmaPusherPutAddress);
                                               freeCount -= (1 + pxlCount);

                                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                                   IMAGE_FROM_CPU_COLOR_OFFSET | (pxlCount << 18);

                                               dmaPusherPutAddress += 1;

                                               while (--pxlCount >= 0) {
                                                   tmpPxls0 = pSrcBits[0];
                                                   pSrcBits += 1;
                                                   dmaPusherPutAddress[0] = tmpPxls0;
                                                   dmaPusherPutAddress++;
                                               }
                                           }

                                           pSrcBits += nxtSrcScan;

                                           /* Force write combine buffer to flush */
                                           pDriverData->NvDmaPusherBufferEnd[0] = 0;
                                           /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                                           _outp (0x3d0,0);

                                           pDriverData->dwDmaPusherFreeCount = freeCount;

                                           npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                                       }
                                   }
                               }
                           }
                       } else { // unclipped

                           /* unclipped AlphaBlt MUST clip to destination */
                           if (wDestXY.xy16.x < 0)
                               wDestXY.xy16.x = 0;
                           if (wDestXY.xy16.y < 0)
                               wDestXY.xy16.y = 0;
                           if (wDestXY.xy16.x + wXYext.wh16.w > dst->wWidth)
                               wXYext.wh16.w = dst->wWidth - wDestXY.xy16.x;
                           if (wDestXY.xy16.y + wXYext.wh16.h > dst->wHeight)
                               wXYext.wh16.h = dst->wHeight - wDestXY.xy16.y;
                           /* handle NULL destination rectangle case */
                           if ((wDestXY.xy16.x == 0) && (wXYext.wh16.w == 0))
                               wXYext.wh16.w = dst->wWidth;
                           if ((wDestXY.xy16.y == 0) && (wXYext.wh16.h == 0))
                               wXYext.wh16.h = dst->wHeight;

                           while (freeCount < 4)
                               NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
                           freeCount -= 4;

                           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                               IMAGE_FROM_CPU_POINT_OFFSET | 0xC0000;
                           dmaPusherPutAddress[1] = wDestXY.xy;
                           dmaPusherPutAddress[2] = wXYext.wh;
                           dmaPusherPutAddress[3] = wXYext.wh;

                           dmaPusherPutAddress += 4;

                           {
                               FAST unsigned long *pSrcBits = (unsigned long *)pSrcInitBits;
                               FAST unsigned long tmpPxls0, tmpPxls1, tmpPxls2;

                               if (temp < 1792) {

                                   while (--n >= 0) {
                                       pxlCount = (short)temp;

                                       // Get enough buffer space for this scanline
                                       while (freeCount < (long)(1 + temp))
                                           NvGetDmaBufferFreeCount(npDev, freeCount, (long)(1 + temp), dmaPusherPutAddress);
                                       freeCount -= (long)(1 + temp);

                                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                           IMAGE_FROM_CPU_COLOR_OFFSET | (temp << 18);

                                       dmaPusherPutAddress += 1;

                                       while (pxlCount >= 16) {
                                           pxlCount -= 16;

                                           tmpPxls0 = pSrcBits[0];
                                           tmpPxls1 = pSrcBits[1];
                                           dmaPusherPutAddress[0] = tmpPxls0;
                                           tmpPxls2 = pSrcBits[2];
                                           dmaPusherPutAddress[1] = tmpPxls1;
                                           tmpPxls0 = pSrcBits[3];
                                           tmpPxls1 = pSrcBits[4];
                                           dmaPusherPutAddress[2] = tmpPxls2;
                                           dmaPusherPutAddress[3] = tmpPxls0;
                                           tmpPxls2 = pSrcBits[5];
                                           tmpPxls0 = pSrcBits[6];
                                           dmaPusherPutAddress[4] = tmpPxls1;
                                           dmaPusherPutAddress[5] = tmpPxls2;
                                           tmpPxls1 = pSrcBits[7];
                                           tmpPxls2 = pSrcBits[8];
                                           dmaPusherPutAddress[6] = tmpPxls0;
                                           dmaPusherPutAddress[7] = tmpPxls1;
                                           tmpPxls0 = pSrcBits[9];
                                           tmpPxls1 = pSrcBits[10];
                                           dmaPusherPutAddress[8] = tmpPxls2;
                                           dmaPusherPutAddress[9] = tmpPxls0;
                                           tmpPxls2 = pSrcBits[11];
                                           tmpPxls0 = pSrcBits[12];
                                           dmaPusherPutAddress[10] = tmpPxls1;
                                           dmaPusherPutAddress[11] = tmpPxls2;
                                           tmpPxls1 = pSrcBits[13];
                                           tmpPxls2 = pSrcBits[14];
                                           dmaPusherPutAddress[12] = tmpPxls0;
                                           dmaPusherPutAddress[13] = tmpPxls1;
                                           tmpPxls0 = pSrcBits[15];
                                           dmaPusherPutAddress[14] = tmpPxls2;
                                           pSrcBits += 16;
                                           dmaPusherPutAddress[15] = tmpPxls0;
                                           dmaPusherPutAddress += 16;
                                       }

                                       if (pxlCount > 0) {
                                           while (--pxlCount >= 0) {
                                               tmpPxls0 = pSrcBits[0];
                                               pSrcBits += 1;
                                               dmaPusherPutAddress[0] = tmpPxls0;
                                               dmaPusherPutAddress++;
                                           }
                                       }

                                       pSrcBits += nxtSrcScan;

                                       /* Force write combine buffer to flush */
                                       pDriverData->NvDmaPusherBufferEnd[0] = 0;
                                       /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                                       _outp (0x3d0,0);

                                       pDriverData->dwDmaPusherFreeCount = freeCount;

                                       npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                                   }
                               } else { /* more than 1792 pixels per scanline */

                                   while (--n >= 0) {
                                       pxlCount = (short)temp;

                                       while (pxlCount >= 16) {
                                           pxlCount -= 16;

                                           while (freeCount < (1 + 16))
                                               NvGetDmaBufferFreeCount(npDev, freeCount, (1 + 16), dmaPusherPutAddress);
                                           freeCount -= (1 + 16);

                                           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                               IMAGE_FROM_CPU_COLOR_OFFSET | (16 << 18);

                                           tmpPxls0 = pSrcBits[0];
                                           tmpPxls1 = pSrcBits[1];
                                           dmaPusherPutAddress[1] = tmpPxls0;
                                           tmpPxls2 = pSrcBits[2];
                                           dmaPusherPutAddress[2] = tmpPxls1;
                                           tmpPxls0 = pSrcBits[3];
                                           tmpPxls1 = pSrcBits[4];
                                           dmaPusherPutAddress[3] = tmpPxls2;
                                           dmaPusherPutAddress[4] = tmpPxls0;
                                           tmpPxls2 = pSrcBits[5];
                                           tmpPxls0 = pSrcBits[6];
                                           dmaPusherPutAddress[5] = tmpPxls1;
                                           dmaPusherPutAddress[6] = tmpPxls2;
                                           tmpPxls1 = pSrcBits[7];
                                           tmpPxls2 = pSrcBits[8];
                                           dmaPusherPutAddress[7] = tmpPxls0;
                                           dmaPusherPutAddress[8] = tmpPxls1;
                                           tmpPxls0 = pSrcBits[9];
                                           tmpPxls1 = pSrcBits[10];
                                           dmaPusherPutAddress[9] = tmpPxls2;
                                           dmaPusherPutAddress[10] = tmpPxls0;
                                           tmpPxls2 = pSrcBits[11];
                                           tmpPxls0 = pSrcBits[12];
                                           dmaPusherPutAddress[11] = tmpPxls1;
                                           dmaPusherPutAddress[12] = tmpPxls2;
                                           tmpPxls1 = pSrcBits[13];
                                           tmpPxls2 = pSrcBits[14];
                                           dmaPusherPutAddress[13] = tmpPxls0;
                                           dmaPusherPutAddress[14] = tmpPxls1;
                                           tmpPxls0 = pSrcBits[15];
                                           dmaPusherPutAddress[15] = tmpPxls2;
                                           pSrcBits += 16;
                                           dmaPusherPutAddress[16] = tmpPxls0;
                                           dmaPusherPutAddress += 17;
                                       }

                                       if (pxlCount > 0) {
                                           while (freeCount < (1 + pxlCount))
                                               NvGetDmaBufferFreeCount(npDev, freeCount, (1 + pxlCount), dmaPusherPutAddress);
                                           freeCount -= (1 + pxlCount);

                                           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                               IMAGE_FROM_CPU_COLOR_OFFSET | (pxlCount << 18);

                                           dmaPusherPutAddress += 1;

                                           while (--pxlCount >= 0) {
                                               tmpPxls0 = pSrcBits[0];
                                               pSrcBits += 1;
                                               dmaPusherPutAddress[0] = tmpPxls0;
                                               dmaPusherPutAddress++;
                                           }
                                       }

                                       pSrcBits += nxtSrcScan;

                                       /* Force write combine buffer to flush */
                                       pDriverData->NvDmaPusherBufferEnd[0] = 0;
                                       /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                                       _outp (0x3d0,0);

                                       pDriverData->dwDmaPusherFreeCount = freeCount;

                                       npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                                   }
                               }
                           }
                       }

                       while (freeCount < 4)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
                       freeCount -= 4;

                       /* Restore default destination color format */
                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x80000;
                       dmaPusherPutAddress[1] = NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;

                       /* Restore default object */
                       dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_IMAGE) | 0x40000;
                       dmaPusherPutAddress[3] = NV_DD_IMAGE_FROM_CPU;

                       dmaPusherPutAddress += 4;

                   } else { /* non-alpha blit */

                       FAST unsigned long *pSrcBits = (unsigned long *)pSrcInitBits;
                       FAST unsigned long tmpPxls0, tmpPxls1, tmpPxls2;

                       while (freeCount < 10)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
                       freeCount -= 10;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                           SET_ROP_OFFSET | 0x40000;
                       dmaPusherPutAddress[1] = dwRop;

                       dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_DEST_OFFSET | 0x40000;
                       dmaPusherPutAddress[3] = dwDstOffset;
                       dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_PITCH_OFFSET | 0x40000;
                       dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

                       dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                           IMAGE_FROM_CPU_POINT_OFFSET | 0xC0000;
                       dmaPusherPutAddress[7] = wDestXY.xy;
                       dmaPusherPutAddress[8] = wXYext.wh;
                       dmaPusherPutAddress[9] = wXYext.wh;

                       dmaPusherPutAddress += 10;

                       if (temp < 1792) {

                           while (--n >= 0) {
                               pxlCount = (short)temp;

                               // Get enough buffer space for this scanline
                               while (freeCount < (long)(1 + temp))
                                   NvGetDmaBufferFreeCount(npDev, freeCount, (long)(1 + temp), dmaPusherPutAddress);
                               freeCount -= (long)(1 + temp);

                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                   IMAGE_FROM_CPU_COLOR_OFFSET | (temp << 18);

                               dmaPusherPutAddress += 1;

                               while (pxlCount >= 16) {
                                   pxlCount -= 16;

                                   tmpPxls0 = pSrcBits[0];
                                   tmpPxls1 = pSrcBits[1];
                                   dmaPusherPutAddress[0] = tmpPxls0;
                                   tmpPxls2 = pSrcBits[2];
                                   dmaPusherPutAddress[1] = tmpPxls1;
                                   tmpPxls0 = pSrcBits[3];
                                   tmpPxls1 = pSrcBits[4];
                                   dmaPusherPutAddress[2] = tmpPxls2;
                                   dmaPusherPutAddress[3] = tmpPxls0;
                                   tmpPxls2 = pSrcBits[5];
                                   tmpPxls0 = pSrcBits[6];
                                   dmaPusherPutAddress[4] = tmpPxls1;
                                   dmaPusherPutAddress[5] = tmpPxls2;
                                   tmpPxls1 = pSrcBits[7];
                                   tmpPxls2 = pSrcBits[8];
                                   dmaPusherPutAddress[6] = tmpPxls0;
                                   dmaPusherPutAddress[7] = tmpPxls1;
                                   tmpPxls0 = pSrcBits[9];
                                   tmpPxls1 = pSrcBits[10];
                                   dmaPusherPutAddress[8] = tmpPxls2;
                                   dmaPusherPutAddress[9] = tmpPxls0;
                                   tmpPxls2 = pSrcBits[11];
                                   tmpPxls0 = pSrcBits[12];
                                   dmaPusherPutAddress[10] = tmpPxls1;
                                   dmaPusherPutAddress[11] = tmpPxls2;
                                   tmpPxls1 = pSrcBits[13];
                                   tmpPxls2 = pSrcBits[14];
                                   dmaPusherPutAddress[12] = tmpPxls0;
                                   dmaPusherPutAddress[13] = tmpPxls1;
                                   tmpPxls0 = pSrcBits[15];
                                   dmaPusherPutAddress[14] = tmpPxls2;
                                   pSrcBits += 16;
                                   dmaPusherPutAddress[15] = tmpPxls0;
                                   dmaPusherPutAddress += 16;
                               }

                               if (pxlCount > 0) {
                                   while (--pxlCount >= 0) {
                                       tmpPxls0 = pSrcBits[0];
                                       pSrcBits += 1;
                                       dmaPusherPutAddress[0] = tmpPxls0;
                                       dmaPusherPutAddress++;
                                   }
                               }

                               pSrcBits += nxtSrcScan;

                               /* Force write combine buffer to flush */
                               pDriverData->NvDmaPusherBufferEnd[0] = 0;
                               /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                               _outp (0x3d0,0);

                               pDriverData->dwDmaPusherFreeCount = freeCount;

                               npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                           }
                       } else { /* more than 1792 pixels per scanline */

                           while (--n >= 0) {
                               pxlCount = (short)temp;

                               while (pxlCount >= 16) {
                                   pxlCount -= 16;

                                   while (freeCount < (1 + 16))
                                       NvGetDmaBufferFreeCount(npDev, freeCount, (1 + 16), dmaPusherPutAddress);
                                   freeCount -= (1 + 16);

                                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                       IMAGE_FROM_CPU_COLOR_OFFSET | (16 << 18);

                                   tmpPxls0 = pSrcBits[0];
                                   tmpPxls1 = pSrcBits[1];
                                   dmaPusherPutAddress[1] = tmpPxls0;
                                   tmpPxls2 = pSrcBits[2];
                                   dmaPusherPutAddress[2] = tmpPxls1;
                                   tmpPxls0 = pSrcBits[3];
                                   tmpPxls1 = pSrcBits[4];
                                   dmaPusherPutAddress[3] = tmpPxls2;
                                   dmaPusherPutAddress[4] = tmpPxls0;
                                   tmpPxls2 = pSrcBits[5];
                                   tmpPxls0 = pSrcBits[6];
                                   dmaPusherPutAddress[5] = tmpPxls1;
                                   dmaPusherPutAddress[6] = tmpPxls2;
                                   tmpPxls1 = pSrcBits[7];
                                   tmpPxls2 = pSrcBits[8];
                                   dmaPusherPutAddress[7] = tmpPxls0;
                                   dmaPusherPutAddress[8] = tmpPxls1;
                                   tmpPxls0 = pSrcBits[9];
                                   tmpPxls1 = pSrcBits[10];
                                   dmaPusherPutAddress[9] = tmpPxls2;
                                   dmaPusherPutAddress[10] = tmpPxls0;
                                   tmpPxls2 = pSrcBits[11];
                                   tmpPxls0 = pSrcBits[12];
                                   dmaPusherPutAddress[11] = tmpPxls1;
                                   dmaPusherPutAddress[12] = tmpPxls2;
                                   tmpPxls1 = pSrcBits[13];
                                   tmpPxls2 = pSrcBits[14];
                                   dmaPusherPutAddress[13] = tmpPxls0;
                                   dmaPusherPutAddress[14] = tmpPxls1;
                                   tmpPxls0 = pSrcBits[15];
                                   dmaPusherPutAddress[15] = tmpPxls2;
                                   pSrcBits += 16;
                                   dmaPusherPutAddress[16] = tmpPxls0;
                                   dmaPusherPutAddress += 17;
                               }

                               if (pxlCount > 0) {
                                   while (freeCount < (1 + pxlCount))
                                       NvGetDmaBufferFreeCount(npDev, freeCount, (1 + pxlCount), dmaPusherPutAddress);
                                   freeCount -= (1 + pxlCount);

                                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                       IMAGE_FROM_CPU_COLOR_OFFSET | (pxlCount << 18);

                                   dmaPusherPutAddress += 1;

                                   while (--pxlCount >= 0) {
                                       tmpPxls0 = pSrcBits[0];
                                       pSrcBits += 1;
                                       dmaPusherPutAddress[0] = tmpPxls0;
                                       dmaPusherPutAddress++;
                                   }
                               }

                               pSrcBits += nxtSrcScan;

                               /* Force write combine buffer to flush */
                               pDriverData->NvDmaPusherBufferEnd[0] = 0;
                               /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                               _outp (0x3d0,0);

                               pDriverData->dwDmaPusherFreeCount = freeCount;

                               npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                           }
                       }
                   }
               }
            } else { // stretch
                RECT rDummy;
                BOOL isOverlappingVmem = FALSE;
                FLATPTR lpSurfTemp = 0;
                DWORD dwSrcBitsPP = 32;
                BOOL useStretched = FALSE;

                /*
                 *  Fractional positioning bands of the SCALED IMAGE class when downscaling
                 *  vertically by small amounts is just too hard to get correct so we switch to the
                 *  STRETCHED IMAGE class when that occurs.
                 */

                if ((!(dwSrcCaps & DDSCAPS_VIDEOMEMORY)) && (dwSrcHeight > dwDstHeight))
                    useStretched = TRUE;

                // if the source and destination overlap, then we must do this in 2 passes, first copy the source
                // image somewhere else, and then so the stretch from there.
                if ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) && dwSrcOffset == dwDstOffset && IntersectRect(&rDummy, (LPRECT)(&pbd->rSrc), (LPRECT)(&pbd->rDest))) {
                    NVHEAP_ALLOC(lpSurfTemp, dwSrcHeight * ((dwSrcWidth * dwSrcBitsPP / 8 + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad), TYPE_IMAGE);
                    if (lpSurfTemp) {
                        isOverlappingVmem = TRUE;
                        if (pDriverData->dwSharedClipChangeCount != pDriverData->dwDDMostRecentClipChangeCount) {

                            while (freeCount < 7)
                                NvGetDmaBufferFreeCount(npDev, freeCount, 7, dmaPusherPutAddress);
                            freeCount -= 7;

                            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
                            dmaPusherPutAddress[1] = NV_DD_IMAGE_BLACK_RECTANGLE;
                            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                                IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000;
                            dmaPusherPutAddress[3] = 0;
                            dmaPusherPutAddress[4] = asmMergeCoords(NV_MAX_X_CLIP, NV_MAX_Y_CLIP);
                            dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
                            dmaPusherPutAddress[6] = NV_DD_SURFACES_2D;

                            dmaPusherPutAddress += 7;

                            pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                            /* Force write combine buffer to flush */
                            pDriverData->NvDmaPusherBufferEnd[0] = 0;
                            /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                            _outp (0x3d0,0);

                            pDriverData->dwDmaPusherFreeCount = freeCount;

                            npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                            pDriverData->dwSharedClipChangeCount++;

                            pDriverData->dwDDMostRecentClipChangeCount = pDriverData->dwSharedClipChangeCount;
                        }

                        while (freeCount < 10)
                            NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
                        freeCount -= 10;

                        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                            SET_ROP_OFFSET | 0x40000;
                        dmaPusherPutAddress[1] = dwRop;

                        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                            SURFACES_2D_PITCH_OFFSET | 0xC0000;
                        dmaPusherPutAddress[3] = ((((dwSrcWidth * dwSrcBitsPP / 8 + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad)) << 16) | dwSrcPitch;
                        dmaPusherPutAddress[4] = dwSrcOffset;
                        dmaPusherPutAddress[5] = lpSurfTemp - pDriverData->BaseAddress;

                        dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_BLIT) +
                            BLIT_POINT_IN_OFFSET | 0xC0000;
                        dmaPusherPutAddress[7] = wSrcXY.xy;
                        dmaPusherPutAddress[8] = 0;
                        dmaPusherPutAddress[9] = wXYext.wh;

                        dmaPusherPutAddress += 10;

                        dwSrcOffset = lpSurfTemp - pDriverData->BaseAddress;
                        dwSrcPitch = ((dwSrcWidth * dwSrcBitsPP / 8 + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad);
                        wSrcXY.xy = 0;
                        wSrcXY.xy16.x = 0;
                        wSrcXY.xy16.y = 0;
                    } else {
                        // FIXME: vmem heap alloc failed, must do system mem alloc and copy there
                    }
                }
                // WARNING: carefully consider each use of src->fpVidMem and src->lPitch beyond this point
                //          it could screw up overlapping stretchblits

               if ((dwFlags & DDBLT_KEYSRCOVERRIDE) || (isKeySrc) || (useStretched)) { // If color key then MUST use STRETCHED IMAGE instead of SCALED IMAGE
                   NvNotification *pDmaBufferNotifier;
                   unsigned char *pScanlineBuffer;
                   long srcScanLength;
                   long nxtSrcScan;
                   long n;
                   short m;
                   FAST short pxlCount;
                   unsigned char *pSrcInitBits;
                   unsigned char *pSaveSrcBits;
                   unsigned char *pSrcCurScan;
                   long deltaX;
                   long deltaY;
                   long curDstY;
                   long lastDstY;
                   NVCOORD wSrcExt;
                   NVCOORD wDstPoint;
                   unsigned long srcStrtX;
                   BYTE srcInVideoMemory = 0;
                   BYTE bufState = 0;
                   short skipV = 0;
                   DWORD nRects;
                   LPRECT pClipRects;
                   NVCOORD wOrigDestXY;
                   NVCOORD wOrigSrcXY;
                   unsigned long dwSrcXPos;
                   unsigned long dwSrcYPos;

//                   pSrcInitBits = (unsigned char *)src->fpVidMem;
//                   srcScanLength = src->lPitch;
                   pSrcInitBits = (unsigned char *)(dwSrcOffset + pDriverData->BaseAddress);
                   srcScanLength = dwSrcPitch;

                   if (dwSrcPitch <= 1600)
                       m = 8;
                   else if (dwSrcPitch <= 3200)
                       m = 4;
                   else
                       m = 2;

                   if (isAlphaBlt) {

                       while (freeCount < 12)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
                       freeCount -= 12;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000;
                       dmaPusherPutAddress[1] = NV042_SET_COLOR_FORMAT_LE_A8R8G8B8;

                       dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_DEST_OFFSET | 0x40000;
                       dmaPusherPutAddress[3] = dwDstOffset;
                       dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_PITCH_OFFSET | 0x40000;
                       dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

                       dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                       dmaPusherPutAddress[7] = NV_DD_CONTEXT_BETA4;
#ifdef  DX7
                       dwMultipliers = pbd->ddrgbaScaleFactors.alpha << 24;
                       dwMultipliers |= pbd->ddrgbaScaleFactors.red << 16;
                       dwMultipliers |= pbd->ddrgbaScaleFactors.green << 8;
                       dwMultipliers |= pbd->ddrgbaScaleFactors.blue;
#endif  /* DX7 */
                       dmaPusherPutAddress[8] = dDrawSubchannelOffset(NV_DD_SPARE) +
                           BETA4_SET_BETA_FACTOR_OFFSET | 0x40000;
                       dmaPusherPutAddress[9] = dwMultipliers;
#ifdef  DX7
                       dmaPusherPutAddress[10] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;

                       if (dwAFlags & DDABLT_NOBLEND)
                           dmaPusherPutAddress[11] =
                               NV_DD_SRCCOPY_STRETCHED_IMAGE_FROM_CPU;
                       else
                           dmaPusherPutAddress[11] =
                               NV_DD_ABLEND_STRETCHED_IMAGE_FROM_CPU;

                       dmaPusherPutAddress += 12;
#else   DX7
                       dmaPusherPutAddress += 10;
#endif  /* DX7 */
                   } else { // regular blit

                       while (freeCount < 8)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 8, dmaPusherPutAddress);
                       freeCount -= 8;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                           SET_ROP_OFFSET | 0x40000;
                       dmaPusherPutAddress[1] = dwRop;

                       dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_DEST_OFFSET | 0x40000;
                       dmaPusherPutAddress[3] = dwDstOffset;
                       dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_PITCH_OFFSET | 0x40000;
                       dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

                       dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;
                       dmaPusherPutAddress[7] = NV_DD_STRETCHED_IMAGE_FROM_CPU;

                       dmaPusherPutAddress += 8;
                   }

                   if (isClipped) {

                       nRects = pbd->dwRectCnt;
                       pClipRects = pbd->prDestRects;

                       wOrigDestXY.xy16.x = (short)pbd->rOrigDest.left;
                       wOrigDestXY.xy16.y = (short)pbd->rOrigDest.top;
                       wOrigSrcXY.xy16.x  = (short)pbd->rOrigSrc.left;
                       wOrigSrcXY.xy16.y  = (short)pbd->rOrigSrc.top;

                       dwDstWidth = pbd->rOrigDest.right - pbd->rOrigDest.left;
                       dwDstHeight = pbd->rOrigDest.bottom - pbd->rOrigDest.top;
                       dwSrcWidth = pbd->rOrigSrc.right - pbd->rOrigSrc.left;
                       dwSrcHeight = pbd->rOrigSrc.bottom - pbd->rOrigSrc.top;

                       /* calculate deltas in 12.20 format */
                       deltaX = dwDstWidth << 20;
                       deltaX /= dwSrcWidth;

                       if ((deltaX > 0x100000) && (deltaX & 0xFFFFF)) {
                           long xStretch = deltaX & 0xFFF00000;
                           deltaX = (dwDstWidth << 20) + xStretch;
                           deltaX /= dwSrcWidth;
                       }

                       if ((deltaX < 0x100000) && (deltaX & 0xFFFFF)) {
                           deltaX = (dwDstWidth << 20) + 0x100000;
                           deltaX /= dwSrcWidth;
                       }

                       deltaY = dwDstHeight << 20;
                       deltaY /= dwSrcHeight;

                       if ((deltaY > 0x100000) && (deltaY & 0xFFFFF)) {
                           long yStretch = deltaY & 0xFFF00000;
                           deltaY = (dwDstHeight << 20) + yStretch;
                           deltaY /= dwSrcHeight;
                       }

                       if ((deltaY < 0x100000) && (deltaY & 0xFFFFF)) {
                           deltaY = (dwDstHeight << 20) + 0x100000;
                           deltaY /= dwSrcHeight;
                       }
                   } else { // unclipped

                       /* calculate deltas in 12.20 format */
                       deltaX = dwDstWidth << 20;
                       deltaX /= dwSrcWidth;

                       if ((deltaX > 0x100000) && (deltaX & 0xFFFFF)) {
                           long xStretch = deltaX & 0xFFF00000;
                           deltaX = (dwDstWidth << 20) + xStretch;
                           deltaX /= dwSrcWidth;
                       }

                       if ((deltaX < 0x100000) && (deltaX & 0xFFFFF)) {
                           deltaX = (dwDstWidth << 20) + 0x100000;
                           deltaX /= dwSrcWidth;
                       }

                       deltaY = dwDstHeight << 20;
                       deltaY /= dwSrcHeight;

                       if ((deltaY > 0x100000) && (deltaY & 0xFFFFF)) {
                           long yStretch = deltaY & 0xFFF00000;
                           deltaY = (dwDstHeight << 20) + yStretch;
                           deltaY /= dwSrcHeight;
                       }

                       if ((deltaY < 0x100000) && (deltaY & 0xFFFFF)) {
                           deltaY = (dwDstHeight << 20) + 0x100000;
                           deltaY /= dwSrcHeight;
                       }
                   }

nxtStretchedRect:  if (isClipped) {

                       skipV = 0;

                       wDestXY.xy16.x = (short)pClipRects->left;
                       wDestXY.xy16.y = (short)pClipRects->top;
                       wXYext.wh16.w = (unsigned short)(pClipRects->right - pClipRects->left);
                       wXYext.wh16.h = (unsigned short)(pClipRects->bottom - pClipRects->top);
                       pClipRects++;

                       /* calculate starting source X position */
                       dwSrcXPos = (long)(wDestXY.xy16.x - wOrigDestXY.xy16.x) << 20;

                       if (deltaX >= 0x100000)
                           dwSrcXPos /= (deltaX >> 16); /* result is 16:16 */
                       else {
                           dwSrcXPos /= deltaX; /* result is 16:00 */
                           dwSrcXPos <<= 16;
                       }
                                                           /* truncate fraction */
                       wSrcXY.xy16.x = wOrigSrcXY.xy16.x + (short)(dwSrcXPos >> 16);

                       /* calculate starting source Y position */
                       dwSrcYPos = (long)(wDestXY.xy16.y - wOrigDestXY.xy16.y) << 20;

                       if (deltaY >= 0x100000)
                           dwSrcYPos /= (deltaY >> 16); /* result is 16:16 */
                       else {
                           dwSrcYPos /= deltaY; /* result is 16:00 */
                           dwSrcYPos <<= 16;
                       }
                                                           /* truncate fraction */
                       wSrcXY.xy16.y = wOrigSrcXY.xy16.y + (short)(dwSrcYPos >> 16);

//                       pSrcInitBits = (unsigned char *)src->fpVidMem;
                       pSrcInitBits = (unsigned char *)(dwSrcOffset + pDriverData->BaseAddress);

                       /* calculate source X extent */
                       dwSrcWidth = (unsigned long)wXYext.wh16.w << 20;

                       if (deltaX >= 0x100000)
                           dwSrcWidth /= (deltaX >> 16); /* result is 16:16 */
                       else {
                           dwSrcWidth /= deltaX; /* result is 16:00 */
                           dwSrcWidth <<= 16;
                       }

                       /* calculate source Y extent */
                       dwSrcHeight = (unsigned long)wXYext.wh16.h << 20;

                       if (deltaY >= 0x100000)
                           dwSrcHeight /= (deltaY >> 16); /* result is 16:16 */
                       else {
                           dwSrcHeight /= deltaY; /* result is 16:00 */
                           dwSrcHeight <<= 16;
                       }

                       wSrcExt.wh16.w = (unsigned short)(dwSrcXPos + dwSrcWidth) >> 16;
                       wSrcExt.wh16.h = (unsigned short)(dwSrcYPos + dwSrcHeight) >> 16;
                   } else {
                       wSrcExt.wh16.w = (unsigned short)dwSrcWidth;
                       wSrcExt.wh16.h = (unsigned short)dwSrcHeight;
                   }

                   n = (short)wSrcExt.wh16.h;

                   if (wSrcXY.xy16.y + n > src->wHeight)
                       n = src->wHeight - wSrcXY.xy16.y;

                   nxtSrcScan = srcScanLength;

                   if (doMirrorUpDown) {
                       wSrcXY.xy16.y += (n - 1);
                       nxtSrcScan = -nxtSrcScan;
                   }

                   if ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                       ((dwSrcCaps & DDSCAPS_TEXTURE) == 0) &&
                       ((src->fpVidMem >= pDriverData->BaseAddress) || isOverlappingVmem)) {
                       srcInVideoMemory = 1;
                   } else {
                       pSaveSrcBits = (unsigned char *)(pSrcInitBits +
                                      (wSrcXY.xy16.y * srcScanLength));
                       pSaveSrcBits += (wSrcXY.xy16.x << 2);
                       pSrcCurScan = pSaveSrcBits;
                   }

                   if (srcInVideoMemory) {
                       pDmaBufferNotifier = (NvNotification *)pDriverData->NvDmaBufferNotifierFlat;
                       pDmaBufferNotifier++;
                       pScanlineBuffer = (unsigned char *)pDriverData->NvScanlineBufferFlat;

                       if (isClipped)
                           wSrcExt.wh16.w = (unsigned short)(dwSrcXPos + dwSrcWidth) >> 16;
                       else
                           wSrcExt.wh16.w = (unsigned short)dwSrcWidth;

                       wSrcExt.wh16.h = m;

                       srcStrtX = wSrcXY.xy16.x;

                       while (freeCount < 2)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                       freeCount -= 2;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) | 0x40000;
                       dmaPusherPutAddress[1] = NV_DD_VIDEO_MEMORY_TO_SYSTEM_MEMORY_FORMAT;

                       dmaPusherPutAddress += 2;

                       // wait for any pending notification operation to finish
                       while ((volatile)pDmaBufferNotifier->status == NV_IN_PROGRESS);

                       pDmaBufferNotifier->status = NV_IN_PROGRESS;

                       while (freeCount < 9)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 9, dmaPusherPutAddress);
                       freeCount -= 9;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                           MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000;

                       dmaPusherPutAddress[1] = dwSrcOffset +
                           (dwSrcPitch * (unsigned long)wSrcXY.xy16.y) +
                           ((unsigned long)wSrcXY.xy16.x << 2);

                       dmaPusherPutAddress[2] = NV_DD_NOTIFIER_BLOCK_SIZE + (srcStrtX << 2);

                       dmaPusherPutAddress[3] = dwSrcPitch;

                       dmaPusherPutAddress[4] = dwSrcPitch;

                       dmaPusherPutAddress[5] = (unsigned long)(wSrcExt.wh16.w << 2);

                       dmaPusherPutAddress[6] = m;

                       dmaPusherPutAddress[7] = (1 << 8) | 1;

                       dmaPusherPutAddress[8] = 0;

                       dmaPusherPutAddress += 9;

                       /* Force write combine buffer to flush */
                       pDriverData->NvDmaPusherBufferEnd[0] = 0;
                       /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                       _outp (0x3d0,0);

                       pDriverData->dwDmaPusherFreeCount = freeCount;

                       npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                       // wait for Dma operation to finish
                       while ((volatile)pDmaBufferNotifier->status == NV_IN_PROGRESS);

                       if (doMirrorUpDown)
                           wSrcXY.xy16.y -= (m + skipV);
                       else
                           wSrcXY.xy16.y += (m + skipV);
                   }

                   /* Convert to 12.4 format */
                   wDstPoint.xy16.x = (wDestXY.xy16.x << 4);
                   wDstPoint.xy16.y = (wDestXY.xy16.y << 4);

                   /* convert to 16.16 */
                   lastDstY = (long)(wDestXY.xy16.y + wXYext.wh16.h) << 16;

                   /* convert to 16.16 */
                   curDstY = ((long)wDestXY.xy16.y << 16);

                   while (freeCount < 7)
                       NvGetDmaBufferFreeCount(npDev, freeCount, 7, dmaPusherPutAddress);
                   freeCount -= 7;

                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                       STRETCHED_IMAGE_SIZE_IN_OFFSET | 0x180000;
                   dmaPusherPutAddress[1] = wSrcExt.wh;
                   dmaPusherPutAddress[2] = deltaX;
                   dmaPusherPutAddress[3] = deltaY;
                   dmaPusherPutAddress[4] = wDestXY.xy;
                   dmaPusherPutAddress[5] = wXYext.wh;
                   dmaPusherPutAddress[6] = wDstPoint.xy;

                   dmaPusherPutAddress += 7;

                   while ((n > 0) && (curDstY < lastDstY)) {
                       FAST unsigned long *pSrcBits;
                       FAST unsigned long tmpPxls0, tmpPxls1, tmpPxls2;

                       if (srcInVideoMemory) {
                           if (bufState == 0)
                               pSrcBits = (unsigned long *)(pScanlineBuffer +
                                   (srcStrtX << 2));
                           else
                               pSrcBits = (unsigned long *)(pScanlineBuffer +
                                   (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1) +
                                   (srcStrtX << 2));

                           pSrcCurScan = (unsigned char *)pSrcBits;

                           if (m > 0) {
                               pDmaBufferNotifier->status = NV_IN_PROGRESS;

                               while (freeCount < 9)
                                   NvGetDmaBufferFreeCount(npDev, freeCount, 9, dmaPusherPutAddress);
                               freeCount -= 9;

                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                   MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000;

                               dmaPusherPutAddress[1] = dwSrcOffset +
                                   (dwSrcPitch * (unsigned long)wSrcXY.xy16.y) +
                                   ((unsigned long)wSrcXY.xy16.x << 2);

                               if (bufState == 0)
                                   dmaPusherPutAddress[2] =
                                       NV_DD_NOTIFIER_BLOCK_SIZE +
                                       (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1) +
                                       (srcStrtX << 2);
                               else
                                   dmaPusherPutAddress[2] =
                                       NV_DD_NOTIFIER_BLOCK_SIZE +
                                       (srcStrtX << 2);

                               dmaPusherPutAddress[3] = dwSrcPitch;

                               dmaPusherPutAddress[4] = dwSrcPitch;

                               dmaPusherPutAddress[5] = (unsigned long)(wSrcExt.wh16.w << 2);

                               dmaPusherPutAddress[6] = m;

                               dmaPusherPutAddress[7] = (1 << 8) | 1;

                               dmaPusherPutAddress[8] = 0;

                               dmaPusherPutAddress += 9;

                               /* Force write combine buffer to flush */
                               pDriverData->NvDmaPusherBufferEnd[0] = 0;
                               /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                               _outp (0x3d0,0);

                               pDriverData->dwDmaPusherFreeCount = freeCount;

                               npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                               bufState ^= 1;

                               if (doMirrorUpDown)
                                   wSrcXY.xy16.y -= (m + skipV);
                               else
                                   wSrcXY.xy16.y += (m + skipV);

                               while (freeCount < 7)
                                   NvGetDmaBufferFreeCount(npDev, freeCount, 7, dmaPusherPutAddress);
                               freeCount -= 7;

                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                                   STRETCHED_IMAGE_SIZE_IN_OFFSET | 0x180000;

                               dmaPusherPutAddress[1] = wSrcExt.wh;

                               dmaPusherPutAddress[2] = deltaX;

                               dmaPusherPutAddress[3] = deltaY;

                               dmaPusherPutAddress[4] = wDestXY.xy;

                               dmaPusherPutAddress[5] = wXYext.wh;

                               dmaPusherPutAddress[6] = wDstPoint.xy;

                               dmaPusherPutAddress += 7;

                               /* Force write combine buffer to flush */
                               pDriverData->NvDmaPusherBufferEnd[0] = 0;
                               /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                               _outp (0x3d0,0);

                               pDriverData->dwDmaPusherFreeCount = freeCount;

                               npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                           }
                       } else { // source in system memory
                           pSrcBits = (unsigned long *)pSrcCurScan;
                           pSrcCurScan += nxtSrcScan;
                           n--;
                       }

doNxtBltSrcScan:       if (isClipped) {
                           pxlCount = (short)(dwSrcXPos + dwSrcWidth) >> 16; /* Include fractional starting position */

                           pxlCount -= (short)(dwSrcXPos >> 16);
                       } else {
                           pxlCount = (short)dwSrcWidth;
                       }

                       if (pxlCount < 1792) {

                           // Get enough room for this scanline
                           while (freeCount < (1 + pxlCount))
                               NvGetDmaBufferFreeCount(npDev, freeCount, (1 + pxlCount), dmaPusherPutAddress);
                           freeCount -= (1 + pxlCount);

                           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                               STRETCHED_IMAGE_COLOR_OFFSET | (pxlCount << 18);

                           dmaPusherPutAddress += 1;

                           while (pxlCount >= 16) {

                               pxlCount -= 16;

                               tmpPxls0 = pSrcBits[0];
                               tmpPxls1 = pSrcBits[1];
                               dmaPusherPutAddress[0] = tmpPxls0;
                               tmpPxls2 = pSrcBits[2];
                               dmaPusherPutAddress[1] = tmpPxls1;
                               tmpPxls0 = pSrcBits[3];
                               tmpPxls1 = pSrcBits[4];
                               dmaPusherPutAddress[2] = tmpPxls2;
                               dmaPusherPutAddress[3] = tmpPxls0;
                               tmpPxls2 = pSrcBits[5];
                               tmpPxls0 = pSrcBits[6];
                               dmaPusherPutAddress[4] = tmpPxls1;
                               dmaPusherPutAddress[5] = tmpPxls2;
                               tmpPxls1 = pSrcBits[7];
                               tmpPxls2 = pSrcBits[8];
                               dmaPusherPutAddress[6] = tmpPxls0;
                               dmaPusherPutAddress[7] = tmpPxls1;
                               tmpPxls0 = pSrcBits[9];
                               tmpPxls1 = pSrcBits[10];
                               dmaPusherPutAddress[8] = tmpPxls2;
                               dmaPusherPutAddress[9] = tmpPxls0;
                               tmpPxls2 = pSrcBits[11];
                               tmpPxls0 = pSrcBits[12];
                               dmaPusherPutAddress[10] = tmpPxls1;
                               dmaPusherPutAddress[11] = tmpPxls2;
                               tmpPxls1 = pSrcBits[13];
                               tmpPxls2 = pSrcBits[14];
                               dmaPusherPutAddress[12] = tmpPxls0;
                               dmaPusherPutAddress[13] = tmpPxls1;
                               tmpPxls0 = pSrcBits[15];
                               dmaPusherPutAddress[14] = tmpPxls2;
                               pSrcBits += 16;
                               dmaPusherPutAddress[15] = tmpPxls0;

                               dmaPusherPutAddress += 16;
                           }

                           while (pxlCount >= 8) {

                               pxlCount -= 8;

                               tmpPxls0 = pSrcBits[0];
                               tmpPxls1 = pSrcBits[1];
                               dmaPusherPutAddress[0] = tmpPxls0;
                               tmpPxls2 = pSrcBits[2];
                               dmaPusherPutAddress[1] = tmpPxls1;
                               tmpPxls0 = pSrcBits[3];
                               tmpPxls1 = pSrcBits[4];
                               dmaPusherPutAddress[2] = tmpPxls2;
                               dmaPusherPutAddress[3] = tmpPxls0;
                               tmpPxls2 = pSrcBits[5];
                               tmpPxls0 = pSrcBits[6];
                               dmaPusherPutAddress[4] = tmpPxls1;
                               dmaPusherPutAddress[5] = tmpPxls2;
                               tmpPxls1 = pSrcBits[7];
                               pSrcBits += 8;
                               dmaPusherPutAddress[6] = tmpPxls0;
                               dmaPusherPutAddress[7] = tmpPxls1;

                               dmaPusherPutAddress += 8;
                           }

                           while (--pxlCount >= 0) {
                               tmpPxls0 = pSrcBits[0];
                               pSrcBits += 1;
                               dmaPusherPutAddress[0] = tmpPxls0;

                               dmaPusherPutAddress += 1;
                           }

                       } else { /* more than 1792 pixels per scanline */
                           while (pxlCount >= 16) {

                               pxlCount -= 16;

                               while (freeCount < (1 + 16))
                                   NvGetDmaBufferFreeCount(npDev, freeCount, (1 + 16), dmaPusherPutAddress);
                               freeCount -= (1 + 16);

                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                                   STRETCHED_IMAGE_COLOR_OFFSET | (16 << 18);

                               dmaPusherPutAddress += 1;

                               tmpPxls0 = pSrcBits[0];
                               tmpPxls1 = pSrcBits[1];
                               dmaPusherPutAddress[0] = tmpPxls0;
                               tmpPxls2 = pSrcBits[2];
                               dmaPusherPutAddress[1] = tmpPxls1;
                               tmpPxls0 = pSrcBits[3];
                               tmpPxls1 = pSrcBits[4];
                               dmaPusherPutAddress[2] = tmpPxls2;
                               dmaPusherPutAddress[3] = tmpPxls0;
                               tmpPxls2 = pSrcBits[5];
                               tmpPxls0 = pSrcBits[6];
                               dmaPusherPutAddress[4] = tmpPxls1;
                               dmaPusherPutAddress[5] = tmpPxls2;
                               tmpPxls1 = pSrcBits[7];
                               tmpPxls2 = pSrcBits[8];
                               dmaPusherPutAddress[6] = tmpPxls0;
                               dmaPusherPutAddress[7] = tmpPxls1;
                               tmpPxls0 = pSrcBits[9];
                               tmpPxls1 = pSrcBits[10];
                               dmaPusherPutAddress[8] = tmpPxls2;
                               dmaPusherPutAddress[9] = tmpPxls0;
                               tmpPxls2 = pSrcBits[11];
                               tmpPxls0 = pSrcBits[12];
                               dmaPusherPutAddress[10] = tmpPxls1;
                               dmaPusherPutAddress[11] = tmpPxls2;
                               tmpPxls1 = pSrcBits[13];
                               tmpPxls2 = pSrcBits[14];
                               dmaPusherPutAddress[12] = tmpPxls0;
                               dmaPusherPutAddress[13] = tmpPxls1;
                               tmpPxls0 = pSrcBits[15];
                               dmaPusherPutAddress[14] = tmpPxls2;
                               pSrcBits += 16;
                               dmaPusherPutAddress[15] = tmpPxls0;

                               dmaPusherPutAddress += 16;
                           }

                           while (pxlCount >= 8) {

                               pxlCount -= 8;

                               while (freeCount < (1 + 8))
                                   NvGetDmaBufferFreeCount(npDev, freeCount, (1 + 8), dmaPusherPutAddress);
                               freeCount -= (1 + 8);

                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                                   STRETCHED_IMAGE_COLOR_OFFSET | (8 << 18);

                               dmaPusherPutAddress += 1;

                               tmpPxls0 = pSrcBits[0];
                               tmpPxls1 = pSrcBits[1];
                               dmaPusherPutAddress[0] = tmpPxls0;
                               tmpPxls2 = pSrcBits[2];
                               dmaPusherPutAddress[1] = tmpPxls1;
                               tmpPxls0 = pSrcBits[3];
                               tmpPxls1 = pSrcBits[4];
                               dmaPusherPutAddress[2] = tmpPxls2;
                               dmaPusherPutAddress[3] = tmpPxls0;
                               tmpPxls2 = pSrcBits[5];
                               tmpPxls0 = pSrcBits[6];
                               dmaPusherPutAddress[4] = tmpPxls1;
                               dmaPusherPutAddress[5] = tmpPxls2;
                               tmpPxls1 = pSrcBits[7];
                               pSrcBits += 8;
                               dmaPusherPutAddress[6] = tmpPxls0;
                               dmaPusherPutAddress[7] = tmpPxls1;

                               dmaPusherPutAddress += 8;
                           }

                           if (pxlCount > 0) {
                               while (freeCount < (1 + pxlCount))
                                   NvGetDmaBufferFreeCount(npDev, freeCount, (1 + pxlCount), dmaPusherPutAddress);
                               freeCount -= (1 + pxlCount);

                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                                   STRETCHED_IMAGE_COLOR_OFFSET | (pxlCount << 18);

                               dmaPusherPutAddress++;
                           }

                           while (--pxlCount >= 0) {
                               tmpPxls0 = pSrcBits[0];
                               pSrcBits += 1;
                               dmaPusherPutAddress[0] = tmpPxls0;

                               dmaPusherPutAddress++;
                           }
                       }

                       /* Force write combine buffer to flush */
                       pDriverData->NvDmaPusherBufferEnd[0] = 0;
                       /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                       _outp (0x3d0,0);

                       pDriverData->dwDmaPusherFreeCount = freeCount;

                       npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                       if (srcInVideoMemory) {
                           if (--m > 0) {
                               pSrcCurScan += dwSrcPitch;

                               pSrcBits = (unsigned long *)pSrcCurScan;

                               goto doNxtBltSrcScan;
                           } else {
                               if (dwSrcPitch <= 1600) {
                                   m = 8;
                                   curDstY += (deltaY >> 1);
                               } else if (dwSrcPitch <= 3200) {
                                   m = 4;
                                   curDstY += (deltaY >> 2);
                               } else {
                                   m = 2;
                                   curDstY += (deltaY >> 3);
                               }
                                                   /* convert 16.16 to 12.4 */
                               wDstPoint.xy16.y = (short)(curDstY >> 12);

                               // wait for DMA operation to finish
                               while ((volatile)pDmaBufferNotifier->status == NV_IN_PROGRESS);
                           }
                       }
                   }

                   if (isClipped) {
                       if (--nRects > 0)
                           goto nxtStretchedRect;
                   }

                   if (srcInVideoMemory) {
                       while (freeCount < 2)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                       freeCount -= 2;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) | 0x40000;
                       dmaPusherPutAddress[1] = NV_DD_IMAGE_FROM_CPU;

                       dmaPusherPutAddress += 2;
                   }

                   /* restore default object */
                   while (freeCount < 2)
                       NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                   freeCount -= 2;

                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;
                   dmaPusherPutAddress[1] = NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;

                   dmaPusherPutAddress += 2;

                   if (isAlphaBlt) {
                       /* Restore default destination color format */
                       while (freeCount < 2)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                       freeCount -= 2;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000;

                       dmaPusherPutAddress[1] =
                           NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;

                       dmaPusherPutAddress += 2;
                   }

               } else { // OK to use SCALED IMAGE
                   NvNotification *pDmaDmaFromMemNotifier;
                   unsigned char *pScanlineBuffer;
                   unsigned char *npPixelBuf;
                   long srcScanLength;
                   long nxtSrcScan;
                   unsigned long n;
                   unsigned char *pSrcInitBits;
                   unsigned char *pSaveSrcInitBits;
                   unsigned long *pSaveSrcBits;
                   unsigned long *pSrcCurScan;
                   long srcDeltaX;
                   long srcDeltaY;
                   long skipDeltaY = 0;
                   unsigned long dstDeltaScans;
                   unsigned long dstDeltaX;
                   long dstDeltaY;
                   long srcInitFract;
                   long srcStartFract;
                   long srcStartY;
                   long srcCurFract;
                   long srcCurY;
                   long srcDeltaYPerBand;
                   long srcDeltaScans;
                   long srcCurDeltaScans;
                   long xStretch;
                   long yStretch;
                   long srcBufferPitch;
                   long skipSrcBytes = 0;
                   long dstStartY;
                   long dstCurY;
                   long curV;
                   long skipV = 0;
                   long m;
                   NVCOORD wSrcPoint;
                   NVCOORD wSrcExt;
                   NVCOORD wDstPoint;
                   NVCOORD wDstExt;
                   BYTE srcInVideoMemory = 0;
                   BYTE srcTooWide = 0;
                   short curBuffer;
                   DWORD nRects = 0;
                   LPRECT pClipRects;
                   NVCOORD wOrigDestXY;
                   NVCOORD wOrigSrcXY;
                   long origSrcDeltaX;
                   long origSrcDeltaY;
                   long srcClippedInitFract;
//// These are for working around NV4 scaled image bug
                   DWORD scaledImageObjectID = NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;
                   DWORD curClipPoint;
                   DWORD curClipExtent;
                   DWORD curDUDX;
                   DWORD curDVDY;
//// End of NV4 workaround variables

//                   pSrcInitBits = (unsigned char *)src->fpVidMem;
                   pSrcInitBits = (unsigned char *)(dwSrcOffset + pDriverData->BaseAddress);

                   if (isVideo < 2)
//                       srcScanLength = src->lPitch;
                       srcScanLength = dwSrcPitch;
                   else
//                       srcScanLength = src->lPitch >> 1;
                       srcScanLength = dwSrcPitch >> 1;

                   if (isAlphaBlt) {

                       while (freeCount < 12)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
                       freeCount -= 12;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000;
                       dmaPusherPutAddress[1] = NV042_SET_COLOR_FORMAT_LE_A8R8G8B8;

                       dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_DEST_OFFSET | 0x40000;
                       dmaPusherPutAddress[3] = dwDstOffset;
                       dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_PITCH_OFFSET | 0x40000;
                       dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

                       dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                       dmaPusherPutAddress[7] = NV_DD_CONTEXT_BETA4;
#ifdef  DX7
                       dwMultipliers = pbd->ddrgbaScaleFactors.alpha << 24;
                       dwMultipliers |= pbd->ddrgbaScaleFactors.red << 16;
                       dwMultipliers |= pbd->ddrgbaScaleFactors.green << 8;
                       dwMultipliers |= pbd->ddrgbaScaleFactors.blue;
#endif  /* DX7 */
                       dmaPusherPutAddress[8] = dDrawSubchannelOffset(NV_DD_SPARE) +
                           BETA4_SET_BETA_FACTOR_OFFSET | 0x40000;
                       dmaPusherPutAddress[9] = dwMultipliers;
#ifdef  DX7
                       dmaPusherPutAddress[10] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;

                       if (dwAFlags & DDABLT_NOBLEND)
                           scaledImageObjectID =
                               NV_DD_SRCCOPY_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;
                       else
                           scaledImageObjectID =
                               NV_DD_ABLEND_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;

                       dmaPusherPutAddress[11] = scaledImageObjectID;

                       dmaPusherPutAddress += 12;
#else   /* DX7 */
                       dmaPusherPutAddress += 10;
#endif  /* DX7 */
                   } else { // regular blit

                       while (freeCount < 6)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 6, dmaPusherPutAddress);
                       freeCount -= 6;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                           SET_ROP_OFFSET | 0x40000;
                       dmaPusherPutAddress[1] = dwRop;

                       dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_DEST_OFFSET | 0x40000;
                       dmaPusherPutAddress[3] = dwDstOffset;
                       dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_PITCH_OFFSET | 0x40000;
                       dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

                       dmaPusherPutAddress += 6;
                   }

                   pDriverData->dwDmaPusherFreeCount = freeCount;

                   /* Just in case we return unexpectedly */
                   pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                   if (isClipped) {

                       nRects = pbd->dwRectCnt;
                       pClipRects = pbd->prDestRects;

                       wOrigDestXY.xy16.x = (short)pbd->rOrigDest.left;
                       wOrigDestXY.xy16.y = (short)pbd->rOrigDest.top;
                       wOrigSrcXY.xy16.x  = (short)pbd->rOrigSrc.left;
                       wOrigSrcXY.xy16.y  = (short)pbd->rOrigSrc.top;

                       dwDstWidth = pbd->rOrigDest.right - pbd->rOrigDest.left;
                       dwDstHeight = pbd->rOrigDest.bottom - pbd->rOrigDest.top;
                       dwSrcWidth = pbd->rOrigSrc.right - pbd->rOrigSrc.left;
                       dwSrcHeight = pbd->rOrigSrc.bottom - pbd->rOrigSrc.top;

                       /* check for divide by 0 */
                       if ((dwDstWidth < 1) || (dwDstHeight < 1)) {
                           pbd->ddRVal = DDERR_INVALIDRECT;
                           return DDHAL_DRIVER_HANDLED;
                       }

                       /* Check if within NV hardware supported range */
                       if ((dwDstWidth > 2047) || (dwDstHeight > 2047)) {
                           return DDHAL_DRIVER_NOTHANDLED;
                       }

                       origSrcDeltaX = dwSrcWidth << 20;
                       origSrcDeltaX /= dwDstWidth;

                       origSrcDeltaY = dwSrcHeight << 20;
                       origSrcDeltaY /= dwDstHeight;

                       /* Algorithm can't handle a scale factor that is too large */
                       if (origSrcDeltaY > 0x40000000) {
                           pbd->ddRVal = DDERR_INVALIDRECT;
                           return DDHAL_DRIVER_HANDLED;
                       }

                   } else { // unclipped

                       /* check for divide by 0 */
                       if ((dwDstWidth < 1) || (dwDstHeight < 1)) {
                           pbd->ddRVal = DDERR_INVALIDRECT;
                           return DDHAL_DRIVER_HANDLED;
                       }

                       /* Check if within NV hardware supported range */
                       if ((dwDstWidth > 2047) || (dwDstHeight > 2047)) {
                           return DDHAL_DRIVER_NOTHANDLED;
                       }

                       origSrcDeltaX = dwSrcWidth << 20;
                       origSrcDeltaX /= dwDstWidth;

                       /*
                        * This fudge factor prevents us from running out of source pixels
                        * when the source starting position is fractional resulting in
                        * a true final width of dwSrcWidth - fraction. Unfortunately
                        * this fudge factor also causes problems when it is important
                        * to end on exactly the right source pixel.  The uglier of the 2 cases
                        * is to run out of source pixels so I opted to leave the fudge
                        * factor in. It works by enlarging the destination by a factor
                        * equivalent to 1 source pixel resulting in slightly enlarging
                        * the stretch factor on each source pixel.
                        */

                       if (origSrcDeltaX < 0x100000) {
                           xStretch = 0x40000000 / (origSrcDeltaX >> 10);
                           xStretch >>= 20;
                           origSrcDeltaX = dwSrcWidth << 20;
                           origSrcDeltaX /= (dwDstWidth + xStretch);
                       }

                       origSrcDeltaY = dwSrcHeight << 20;
                       origSrcDeltaY /= dwDstHeight;

                       /* Algorithm can't handle a scale factor that is too large */
                       if (origSrcDeltaY > 0x40000000) {
                           pbd->ddRVal = DDERR_INVALIDRECT;
                           return DDHAL_DRIVER_HANDLED;
                       }

                   }

nxtScaledRect:     srcDeltaX = origSrcDeltaX;
                   srcDeltaY = origSrcDeltaY;

                   if (isClipped) {
                       unsigned long dwSrcXPos;
                       unsigned long dwSrcYPos;

                       skipDeltaY = 0;
                       skipSrcBytes = 0;
                       skipV = 0;
                       srcTooWide = 0;

                       wDestXY.xy16.x = (short)pClipRects->left;
                       wDestXY.xy16.y = (short)pClipRects->top;
                       wXYext.wh16.w = (unsigned short)(pClipRects->right - pClipRects->left);
                       wXYext.wh16.h = (unsigned short)(pClipRects->bottom - pClipRects->top);
                       pClipRects++;

                       dwDstWidth = (unsigned long)wXYext.wh16.w;
                       dwDstHeight = (unsigned long)wXYext.wh16.h;

                       /* calculate starting source X position */
                       dwSrcXPos = (long)(wDestXY.xy16.x - wOrigDestXY.xy16.x);

                       dwSrcXPos *= origSrcDeltaX; /* result is 12:20 */

                                                           /* truncate fraction */
                       wSrcXY.xy16.x = wOrigSrcXY.xy16.x + (short)(dwSrcXPos >> 20);

                       wSrcPoint.xy16.x = (short)((dwSrcXPos & 0xFFFFF) >> 16);

                       /* calculate starting source Y position */
                       dwSrcYPos = (long)(wDestXY.xy16.y - wOrigDestXY.xy16.y);

                       dwSrcYPos *= origSrcDeltaY; /* result is 12.20 */

                                                           /* truncate fraction */
                       wSrcXY.xy16.y = wOrigSrcXY.xy16.y + (short)(dwSrcYPos >> 20);

                       srcClippedInitFract = dwSrcYPos & 0xFFFFF;

                       /* calculate source X extent */
                       dwSrcWidth = (unsigned long)wXYext.wh16.w;

                       dwSrcWidth *= origSrcDeltaX; /* result is 12.20 */

                       dwSrcWidth += (dwSrcXPos & 0xFFFFF); /* include starting fraction of source */

                       dwSrcWidth >>= 20; /* we lose precision here, may need changed later */

                       if (wSrcXY.xy16.x + dwSrcWidth > src->wWidth)
                           dwSrcWidth = src->wWidth - wSrcXY.xy16.x;

                       /* calculate source Y extent */
                       dwSrcHeight = (unsigned long)wXYext.wh16.h;

                       dwSrcHeight *= origSrcDeltaY; /* result is 12.20 */

                       dwSrcHeight += (dwSrcYPos & 0xFFFFF); /* include starting fraction of source */

                       dwSrcHeight >>= 20; /* we lose precision here, may need changed later */


                   }

                   if (isVideo < 2)
                       srcBufferPitch = dwSrcWidth << 2;
                   else
                       srcBufferPitch = dwSrcWidth << 1;

                   srcDeltaScans = (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1) -   /* allow for 2 extra src scanlines */
                            NV_DD_NOTIFIER_BLOCK_SIZE - (srcBufferPitch << 1); /* buffer contains several separate notifiers */

                   srcDeltaScans /= srcBufferPitch;

                   /* limiting source scans per DMA increases parallelism */
                   if (srcDeltaScans > 32)
                       srcDeltaScans = 32;
                   else if (srcDeltaScans > 16)
                       srcDeltaScans = 16;
                   else if (srcDeltaScans > 8)
                       srcDeltaScans = 8;
                   else if (srcDeltaScans > 4)
                       srcDeltaScans = 4;
                   else
                       srcDeltaScans = 2;


                   /* If shrinking in vertical direction then adjust to skip src scanlines */
                   if (srcDeltaY >= (srcDeltaScans << 20)) { /* limit Y delta range to acceptable range */
                       skipDeltaY = srcDeltaY;
                       skipSrcBytes = srcScanLength;
                       skipV = 1;
                       while (srcDeltaY >= (srcDeltaScans << 20)) {
                           srcDeltaY >>= 1;
                           skipSrcBytes <<= 1;
                           skipV <<= 1;
                           skipDeltaY <<= 1;
                       }
                       skipSrcBytes -= srcScanLength;
                       skipV -= 1;
                       skipDeltaY -= srcDeltaY;
                   }

                   /* Algorithm can't handle scale factor that is too small */
                   if ((srcDeltaY & 0xFFFFFC00) == 0) {
                       pbd->ddRVal = DDERR_INVALIDRECT;
                       return DDHAL_DRIVER_HANDLED;
                   }

                   yStretch = 0x40000000 / ((srcDeltaY + 0x00000200) >> 10);

                   dstDeltaY = srcDeltaScans * yStretch;  // how many dst scanlines will srcDeltaScans scanlines generate

                   dstDeltaScans = dstDeltaY >> 20;

                   if (dstDeltaScans == 0) { /* if shrinking too much then can't handle */
                       return DDHAL_DRIVER_NOTHANDLED;
                   }

                   if (wSrcXY.xy16.y + dwSrcHeight > src->wHeight)
                       dwSrcHeight = src->wHeight - wSrcXY.xy16.y;

                   if (isVideo < 2)
                       nxtSrcScan = (srcScanLength >> 2);
                   else
                       nxtSrcScan = (srcScanLength >> 1);

                   srcDeltaYPerBand = dstDeltaScans * (srcDeltaY + skipDeltaY);

                   if (doMirrorUpDown) {
                       wSrcXY.xy16.y += (short)(dwSrcHeight - 1);
                       srcDeltaY = -srcDeltaY;
                       srcDeltaYPerBand = -srcDeltaYPerBand;
                       skipDeltaY = -skipDeltaY;
                       nxtSrcScan = -nxtSrcScan;
                       skipSrcBytes = -skipSrcBytes;
                   }

                   pDmaDmaFromMemNotifier = (NvNotification *)pDriverData->NvDmaDmaFromMemNotifierFlat;
                   pScanlineBuffer = (unsigned char *)pDriverData->NvScanlineBufferFlat;

                   if (srcDeltaY > 0)
                       srcCurY = 0;
                   else
                       srcCurY = ((long)dwSrcHeight << 20);

                   /* Calculate initial source fractional X */
                   if ((srcDeltaX > 0x40000000) || ((srcDeltaX & 0xFFFFFC00) == 0)) {
                       pbd->ddRVal = DDERR_INVALIDRECT;
                       return DDHAL_DRIVER_HANDLED;
                   }

                   if (!(isClipped)) {
                       wSrcPoint.xy = 0;

                       /* Do this math in 16.16 precision to avoid 12. overflow */
                       dstDeltaX = ((long)wSrcXY.xy16.x << 16) / (srcDeltaX >> 4);

                       /* Do this math in 16.16 precision to avoid 12. overflow */
                       srcInitFract = dstDeltaX * (srcDeltaX >> 4);

                       /* Do this math in 16.16 precision to avoid 12. overflow */
                       while (srcInitFract >> 16 < wSrcXY.xy16.x)
                           srcInitFract += (srcDeltaX >> 4);

                       /* Convert to 12.4 format */
                       wSrcPoint.xy16.x = (short)(srcInitFract & 0xFFFF) >> 12;
                   }

                       // DMAable ?
                   if ((isVideo > 3) || ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                       ((dwSrcCaps & DDSCAPS_TEXTURE) == 0) &&
                       ((src->fpVidMem >= pDriverData->BaseAddress) || isOverlappingVmem))) {

                       if (isClipped) {
                           srcInitFract = srcClippedInitFract;
                       } else {
                           srcInitFract = 0;

                           if (srcDeltaY > 0) {
                               /* Calculate initial source fractional Y */
                               /* Do this math in 16.16 precision to avoid 12. overflow */
                               dstDeltaY = ((long)wSrcXY.xy16.y << 16) / (srcDeltaY  >> 4);

                               /* Do this math in 16.16 precision to avoid 12. overflow */
                               srcInitFract = dstDeltaY * (srcDeltaY >> 4);

                               /* Do this math in 16.16 precision to avoid 12. overflow */
                               while (srcInitFract >> 16 < wSrcXY.xy16.y)
                                   srcInitFract += (srcDeltaY >> 4);

                               /* Convert result back to 12.20 precision */
                               srcInitFract <<= 4;

                               srcInitFract &= 0xFFFFF;
                           }
                       }

                       srcCurY += srcInitFract;

                       srcCurFract = srcInitFract;

                       if (isVideo < 4) {
                           srcInVideoMemory = 1;

                           if (doMirrorUpDown) {
                               pSaveSrcBits = (unsigned long *)
                                  (pSrcInitBits - pDriverData->BaseAddress);
                               wSrcPoint.xy16.y += ((short)(dwSrcHeight - 1) << 4);
                           } else {
                               wSrcPoint.xy16.y += (short)(srcCurFract >> 16);

                               if (isVideo < 2)
                                   pSaveSrcBits = (unsigned long *)
                                      ((pSrcInitBits - pDriverData->BaseAddress) +
                                       (wSrcXY.xy16.y * srcScanLength));
                               else
                                   pSaveSrcBits = (unsigned long *)
                                      ((pSrcInitBits - pDriverData->BaseAddress) +
                                       (wSrcXY.xy16.y * (srcScanLength << 1)));
                           }
                       } else {

                           if (doMirrorUpDown) {
                               pSaveSrcBits = 0;
                               wSrcPoint.xy16.y += ((short)(dwSrcHeight - 1) << 4);
                           } else {
                               wSrcPoint.xy16.y += (short)(srcCurFract >> 16);

                               pSaveSrcBits = (unsigned long *)
                                   (wSrcXY.xy16.y * (srcScanLength << 1));
                           }
                       }

                       if (isVideo < 2)
                           pSaveSrcBits += wSrcXY.xy16.x;
                       else
                           pSaveSrcBits += (wSrcXY.xy16.x >> 1);

                       while (freeCount < 2)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                       freeCount -= 2;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;

                       if (isAlphaBlt) {
#ifdef  DX7
                           if (dwAFlags & DDABLT_NOBLEND)
                               scaledImageObjectID =
                                   NV_DD_SRCCOPY_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
                           else
                               scaledImageObjectID =
                                   NV_DD_ABLEND_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
#endif  /* DX7 */
                       } else if (isVideo < 2)
                           scaledImageObjectID =
                               NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
                       else if (isVideo == 2)
                           scaledImageObjectID =
                               NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY;
                       else if (isVideo == 3)
                           scaledImageObjectID =
                               NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY;
                       else if (isVideo == 4)
                           scaledImageObjectID =
                               NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                       else if (isVideo == 5)
                           scaledImageObjectID =
                               NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                       else if (isVideo == 6)
                           scaledImageObjectID =
                               NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
                       else if (isVideo == 7)
                           scaledImageObjectID =
                               NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;

                       dmaPusherPutAddress[1] = scaledImageObjectID;

                       dmaPusherPutAddress += 2;

                   } else {
                       if (isVideo < 2) {
                           pSaveSrcBits = (unsigned long *)(pSrcInitBits +
                               (wSrcXY.xy16.y * srcScanLength));
                           pSaveSrcBits += wSrcXY.xy16.x;
                       } else {
                           pSaveSrcBits = (unsigned long *)(pSrcInitBits +
                               (wSrcXY.xy16.y * (srcScanLength << 1)));
                           pSaveSrcBits += (wSrcXY.xy16.x >> 1);
                       }

                       pSrcCurScan = pSaveSrcBits;

                       while (freeCount < 2)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                       freeCount -= 2;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;

                       if (isVideo == 2)
                           scaledImageObjectID = NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                       else if (isVideo == 3)
                           scaledImageObjectID = NV_DD_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;

                       /* NOTE: This may load the default scaledImageObjectID */
                       dmaPusherPutAddress[1] = scaledImageObjectID;

                       dmaPusherPutAddress += 2;
                   }

                   pSaveSrcInitBits = (unsigned char *)pSaveSrcBits;

                   curClipPoint = wDestXY.xy;
                   curClipExtent = wXYext.wh;
                   curDUDX = srcDeltaX;
                   if (srcDeltaY > 0)
                       curDVDY = srcDeltaY;
                   else
                       curDVDY = -srcDeltaY;

                   while (freeCount < 6)
                       NvGetDmaBufferFreeCount(npDev, freeCount, 6, dmaPusherPutAddress);
                   freeCount -= 6;

                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                       SCALED_IMAGE_CLIPPOINT_OFFSET | 0x80000;
                   dmaPusherPutAddress[1] = curClipPoint;
                   dmaPusherPutAddress[2] = curClipExtent;
                   dmaPusherPutAddress[3] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                       SCALED_IMAGE_DELTADUDX_OFFSET | 0x80000;
                   dmaPusherPutAddress[4] = curDUDX;
                   dmaPusherPutAddress[5] = curDVDY;

                   dmaPusherPutAddress += 6;

                   wDstExt.wh = wXYext.wh;

                   /* NV4 Scaled Image class requires source width to be even */
                   dwSrcWidth = (dwSrcWidth + 1) & ~1;

                   /* NV3 hardware can only handle a maximum source width of 1024 */
                   if (dwSrcWidth > 1024) {
                       srcTooWide = 1;
                       xStretch = 0x40000000 / (srcDeltaX >> 10);
                       dstDeltaX = (xStretch * 1024) >> 20;
                       wDstExt.wh16.w = (unsigned short)dstDeltaX;
                       srcBufferPitch = 4096;
                   }

                   // Let the world know we are doing DMA operations
//                   pDriverData->NvDmaFromMemSurfaceMem = src->fpVidMem;
                   pDriverData->NvDmaFromMemSurfaceMem = dwSrcOffset + pDriverData->BaseAddress;

oneMorePass:       n = dwDstHeight;

                   srcCurY &= 0xFFF00000;

                   if (isClipped) {
                       srcInitFract = srcClippedInitFract;
                   } else {
                       srcInitFract = 0;

                       if (srcDeltaY > 0) {
                           /* Calculate initial source fractional Y */
                           /* Do this math in 16.16 precision to avoid 12. overflow */
                           dstDeltaY = ((long)wSrcXY.xy16.y << 16) / (srcDeltaY  >> 4);

                           /* Do this math in 16.16 precision to avoid 12. overflow */
                           srcInitFract = dstDeltaY * (srcDeltaY >> 4);

                           /* Do this math in 16.16 precision to avoid 12. overflow */
                           while (srcInitFract >> 16 < wSrcXY.xy16.y)
                               srcInitFract += (srcDeltaY >> 4);

                           /* Convert result back to 12.20 precision */
                           srcInitFract <<= 4;

                           srcInitFract &= 0xFFFFF;
                       }
                   }

                   srcCurY += srcInitFract;

                   srcCurFract = srcInitFract;

                   curV = srcCurY >> 20;

                   wDstPoint.xy = wDestXY.xy;

                   dstStartY = dstCurY = wDestXY.xy16.y;

                   curBuffer = 0;

                   if ((srcInVideoMemory) || (isVideo > 3)) { // DMAable ?

                       // wait for any pending notification operation to finish
//this shouldn't be necessary  while ((volatile)pDmaDmaFromMemNotifier->status == NV_IN_PROGRESS);

                       pDmaDmaFromMemNotifier->status = NV_IN_PROGRESS;

                       while (freeCount < 11)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
                       freeCount -= 11;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_OUT_POINT_OFFSET | 0x80000;
                       dmaPusherPutAddress[1] = wDstPoint.xy;
                       dmaPusherPutAddress[2] = wDstExt.wh;
                       dmaPusherPutAddress[3] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET | 0xC0000;

                       if ((dwSrcWidth < 16) && (isVideo < 4)) { // workaround for NV3 Rev B hardware bug (only happens if source is in video memory)
                           dmaPusherPutAddress[4] =
                               asmMergeCoords(dwSrcPitch, dwSrcHeight);
                       } else {
                           dmaPusherPutAddress[4] =
                               asmMergeCoords(dwSrcWidth, dwSrcHeight);
                       }

                       if ((isAlphaBlt) && (doBilinearFiltering == 0))
                           dmaPusherPutAddress[5] =
                               (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH << 24) |
                               (NV077_IMAGE_IN_FORMAT_ORIGIN_CORNER << 16) |
                               dwSrcPitch;
                       else // filter
                           dmaPusherPutAddress[5] =
                               (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |
                               (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                               dwSrcPitch;

                       dmaPusherPutAddress[6] = (unsigned long)pSaveSrcBits;

                       dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_NOTIFY_OFFSET | 0x40000;
                       dmaPusherPutAddress[8] = 0;
                       dmaPusherPutAddress[9] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_IN_POINT_OFFSET | 0x40000;
                       dmaPusherPutAddress[10] = wSrcPoint.xy;

                       dmaPusherPutAddress += 11;

                       /* Force write combine buffer to flush */
                       pDriverData->NvDmaPusherBufferEnd[0] = 0;
                       /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                       _outp (0x3d0,0);

                       pDriverData->dwDmaPusherFreeCount = freeCount;

                       npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                       n = 0;
                   } else {
                       // wait for any pending notification operation to finish
                       while ((volatile)pDmaDmaFromMemNotifier->status == NV_IN_PROGRESS);
                   }

                   while (n >= dstDeltaScans) {
                       FAST unsigned long *pSrcBits;

                       n -= dstDeltaScans;
                       srcStartY = srcCurY;
                       srcStartFract = srcCurFract;
                       srcCurY += srcDeltaYPerBand;

                       if (doMirrorUpDown) {
                           if (((srcCurY - 0x100000) >> 20) < 0)
                               srcCurY = 0x100000;
                       } else {
                           if (((srcCurY + 0x100000) >> 20) >  ((long)dwSrcHeight - 1))
                               srcCurY = ((long)dwSrcHeight - 2) << 20;
                       }

                       srcCurFract = srcCurY & 0xFFFFF;

                       if (curBuffer == 0)
                           npPixelBuf = (unsigned char *)pScanlineBuffer;
                       else
                           npPixelBuf = (unsigned char *)(pScanlineBuffer +
                               (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1));

                       /* Must recalculate on each pass since src scanlines may be used more than once */
                       pSrcBits = (unsigned long *)(pSaveSrcInitBits +
                           (curV * (nxtSrcScan << 2)));

                       pSrcCurScan = pSrcBits;

                       if (doMirrorUpDown)
                           m = (srcStartY >> 20) - ((srcCurY - 0x100000) >> 20);
                       else
                           m = ((srcCurY + 0x100000) >> 20) - (srcStartY >> 20);

                       srcCurDeltaScans = 0;

                       /* Copy and convert a block of source pixels to transfer buffer */
                       while (--m >= 0) {
                           if (pSrcBits >= (unsigned long *)pSrcInitBits) {
  //                           asmCopyScan(pSrcBits, npPixelBuf, srcBufferPitch);
                               _asm
                               {
#ifdef P6
                                   mov ecx, dword ptr srcBufferPitch
                                   mov esi, dword ptr pSrcBits
                                   shr ecx, 5
                     nxtCacheLine: mov eax, [esi]
                                   add esi, 32
                                   dec ecx
                                   jg nxtCacheLine
#endif /* P6 */
                                   mov ecx, dword ptr srcBufferPitch
                                   mov esi, dword ptr pSrcBits
                                   shr ecx, 2
                                   mov edi, dword ptr npPixelBuf
                                   test ecx, 1
                                   jz doQwords
                                   mov eax, [esi]
                                   add esi, 4
                                   mov [edi], eax
                                   add edi, 4
                         doQwords: shr ecx, 1
                                   jz copyDone
                         nxtQword: mov eax, [esi]
                                   mov edx, [esi+4]
                                   add edi, 8
                                   add esi, 8
                                   dec ecx
                                   mov [edi-8], eax
                                   mov [edi-4], edx
                         copyDone: jg nxtQword
                               }
                           }
                           npPixelBuf += srcBufferPitch;
                           pSrcCurScan += (nxtSrcScan + skipSrcBytes);
                           pSrcBits = (unsigned long *)pSrcCurScan;
                           srcCurDeltaScans++;
                           m -= skipV;
                       }

                       /* wait for Dma operation to finish */
                       while (pDmaDmaFromMemNotifier->status == NV_IN_PROGRESS);

                       pDmaDmaFromMemNotifier->status = NV_IN_PROGRESS;

                       wDstPoint.xy16.y = (short)dstCurY;
                       wDstExt.wh16.h = (unsigned short)dstDeltaScans;
                       wSrcPoint.xy16.y = (short)(srcStartFract >> 16); /* convert V to 12.4 */
                       wSrcExt.wh = srcCurDeltaScans;
                       wSrcExt.wh <<= 16;    /* shift V extent into place */
                       wSrcExt.wh |= dwSrcWidth;

//// BEGIN WORKAROUND FOR NV4 SCALED IMAGE HARDWARE BUG

                       while (freeCount < 8)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 8, dmaPusherPutAddress);
                       freeCount -= 8;

                       /* Reload object */
                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;
                       dmaPusherPutAddress[1] = scaledImageObjectID;
                       /* Reinitialize volatile methods */
                       dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_CLIPPOINT_OFFSET | 0x80000;
                       dmaPusherPutAddress[3] = curClipPoint;
                       dmaPusherPutAddress[4] = curClipExtent;
                       dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_DELTADUDX_OFFSET | 0x80000;
                       dmaPusherPutAddress[6] = curDUDX;
                       dmaPusherPutAddress[7] = curDVDY;

                       dmaPusherPutAddress += 8;

//// END WORKAROUND FOR NV4 SCALED IMAGE HARDWARE BUG

                       while (freeCount < 11)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
                       freeCount -= 11;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_OUT_POINT_OFFSET | 0x80000;
                       dmaPusherPutAddress[1] = wDstPoint.xy;
                       dmaPusherPutAddress[2] = wDstExt.wh;
                       dmaPusherPutAddress[3] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET | 0xC0000;
                       dmaPusherPutAddress[4] = wSrcExt.wh;

                       if ((isAlphaBlt) && (doBilinearFiltering == 0))
                           dmaPusherPutAddress[5] =
                               (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH << 24) |
                               (NV077_IMAGE_IN_FORMAT_ORIGIN_CORNER << 16) |
                               srcBufferPitch;
                       else // filter
                           dmaPusherPutAddress[5] =
                               (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |
                               (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                               srcBufferPitch;

                       if (curBuffer == 0)
                           dmaPusherPutAddress[6] =
                               NV_DD_NOTIFIER_BLOCK_SIZE; /* There are several notifiers in the buffer */
                       else
                           dmaPusherPutAddress[6] =
                               NV_DD_NOTIFIER_BLOCK_SIZE + (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1);

                       dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_NOTIFY_OFFSET | 0x40000;
                       dmaPusherPutAddress[8] = 0;
                       dmaPusherPutAddress[9] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_IN_POINT_OFFSET | 0x40000;
                       dmaPusherPutAddress[10] = wSrcPoint.xy;

                       dmaPusherPutAddress += 11;

                       /* Force write combine buffer to flush */
                       pDriverData->NvDmaPusherBufferEnd[0] = 0;
                       /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                       _outp (0x3d0,0);

                       pDriverData->dwDmaPusherFreeCount = freeCount;

                       npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                       curBuffer ^= 1;

                       dstCurY += dstDeltaScans;

                       curV = srcCurY >> 20;
                   }

                   if (n > 0) {
                       FAST unsigned long *pSrcBits;

                       srcStartY = srcCurY;
                       srcStartFract = srcCurFract;
                       srcCurY += srcDeltaYPerBand;

                       if (doMirrorUpDown) {
                           if (((srcCurY - 0x100000) >> 20) < 0)
                               srcCurY = 0x100000;
                       } else {
                           if (((srcCurY + 0x100000) >> 20) > ((long)dwSrcHeight - 1))
                               srcCurY = ((long)dwSrcHeight - 2) << 20;
                       }

                       srcCurFract = srcCurY & 0xFFFFF;

                       if (curBuffer == 0)
                           npPixelBuf = (unsigned char *)pScanlineBuffer;
                       else
                           npPixelBuf = (unsigned char *)(pScanlineBuffer +
                               (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1));

                       /* Must recalculate since src scanlines may be used more than once */
                       pSrcBits = (unsigned long *)(pSaveSrcInitBits +
                           (curV * (nxtSrcScan << 2)));

                       pSrcCurScan = pSrcBits;

                       if (doMirrorUpDown)
                           m = (srcStartY >> 20) - ((srcCurY - 0x100000) >> 20);
                       else
                           m = ((srcCurY + 0x100000) >> 20) - (srcStartY >> 20);

                       srcCurDeltaScans = 0;

                       /* Copy and convert a block of source pixels to transfer buffer */
                       while (--m >= 0) {
                           if (pSrcBits >= (unsigned long *)pSrcInitBits) {
  //                           asmCopyScan(pSrcBits, npPixelBuf, srcBufferPitch);
                               _asm
                               {
#ifdef P6
                                   mov ecx, dword ptr srcBufferPitch
                                   mov esi, dword ptr pSrcBits
                                   shr ecx, 5
                    nxtCacheLine2: mov eax, [esi]
                                   add esi, 32
                                   dec ecx
                                   jg nxtCacheLine2
#endif /* P6 */
                                   mov ecx, dword ptr srcBufferPitch
                                   mov esi, dword ptr pSrcBits
                                   shr ecx, 2
                                   mov edi, dword ptr npPixelBuf
                                   test ecx, 1
                                   jz doQwords2
                                   mov eax, [esi]
                                   add esi, 4
                                   mov [edi], eax
                                   add edi, 4
                        doQwords2: shr ecx, 1
                                   jz copyDone2
                        nxtQword2: mov eax, [esi]
                                   mov edx, [esi+4]
                                   add edi, 8
                                   add esi, 8
                                   dec ecx
                                   mov [edi-8], eax
                                   mov [edi-4], edx
                        copyDone2: jg nxtQword2
                               }
                           }
                           npPixelBuf += srcBufferPitch;
                           pSrcCurScan += (nxtSrcScan + skipSrcBytes);
                           pSrcBits = (unsigned long *)pSrcCurScan;
                           srcCurDeltaScans++;
                           m -= skipV;
                       }

                       /* wait for Dma operation to finish */
                       while (pDmaDmaFromMemNotifier->status == NV_IN_PROGRESS);

                       pDmaDmaFromMemNotifier->status = NV_IN_PROGRESS;

                       wDstPoint.xy16.y = (short)dstCurY;
                       wDstExt.wh16.h = (unsigned short)n;
                       wSrcPoint.xy16.y = (short)(srcStartFract >> 16); /* convert V to 12.4 */
                       wSrcExt.wh = srcCurDeltaScans;
                       wSrcExt.wh <<= 16;    /* shift V extent into place */
                       wSrcExt.wh |= dwSrcWidth;

//// BEGIN WORKAROUND FOR NV4 SCALED IMAGE HARDWARE BUG

                       while (freeCount < 8)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 8, dmaPusherPutAddress);
                       freeCount -= 8;

                       /* Reload object */
                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;
                       dmaPusherPutAddress[1] = scaledImageObjectID;
                       /* Reinitialize volatile methods */
                       dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_CLIPPOINT_OFFSET | 0x80000;
                       dmaPusherPutAddress[3] = curClipPoint;
                       dmaPusherPutAddress[4] = curClipExtent;
                       dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_DELTADUDX_OFFSET | 0x80000;
                       dmaPusherPutAddress[6] = curDUDX;
                       dmaPusherPutAddress[7] = curDVDY;

                       dmaPusherPutAddress += 8;

//// END WORKAROUND FOR NV4 SCALED IMAGE HARDWARE BUG

                       while (freeCount < 11)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
                       freeCount -= 11;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_OUT_POINT_OFFSET | 0x80000;
                       dmaPusherPutAddress[1] = wDstPoint.xy;
                       dmaPusherPutAddress[2] = wDstExt.wh;
                       dmaPusherPutAddress[3] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET | 0xC0000;
                       dmaPusherPutAddress[4] = wSrcExt.wh;

                       if ((isAlphaBlt) && (doBilinearFiltering == 0))
                           dmaPusherPutAddress[5] =
                               (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH << 24) |
                               (NV077_IMAGE_IN_FORMAT_ORIGIN_CORNER << 16) |
                               srcBufferPitch;
                       else // filter
                           dmaPusherPutAddress[5] =
                               (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |
                               (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                               srcBufferPitch;

                       if (curBuffer == 0)
                           dmaPusherPutAddress[6] =
                               NV_DD_NOTIFIER_BLOCK_SIZE; /* There are several notifiers in the buffer */
                       else
                           dmaPusherPutAddress[6] =
                               NV_DD_NOTIFIER_BLOCK_SIZE + (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1);

                       dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_NOTIFY_OFFSET | 0x40000;
                       dmaPusherPutAddress[8] = 0;
                       dmaPusherPutAddress[9] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_IN_POINT_OFFSET | 0x40000;
                       dmaPusherPutAddress[10] = wSrcPoint.xy;

                       dmaPusherPutAddress += 11;

                       /* Force write combine buffer to flush */
                       pDriverData->NvDmaPusherBufferEnd[0] = 0;
                       /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                       _outp (0x3d0,0);

                       pDriverData->dwDmaPusherFreeCount = freeCount;

                       npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                   }

                   if (srcTooWide) {
                       srcTooWide = 0;
                       wDestXY.xy16.x += (short)dstDeltaX;
                       wDstExt.wh16.w = wXYext.wh16.w - wDstExt.wh16.w;
                       if ((srcInVideoMemory) || (isVideo > 3))
                           wSrcPoint.xy16.x += (1024 << 4);
                       srcBufferPitch = dwSrcWidth << 2;
                       srcBufferPitch -= 4096;
                       pSaveSrcInitBits += 1024;
                       pSaveSrcBits = (unsigned long *)pSaveSrcInitBits;
                       pSrcCurScan = pSaveSrcBits;
                       srcCurY = ((long)wSrcXY.xy16.y << 20);
                       goto oneMorePass;
                   }

                   if (isClipped) {
                       if (--nRects > 0)
                           goto nxtScaledRect;
                   }
               }    // stretch

               if (isOverlappingVmem && lpSurfTemp) {
                   // FIXME: wait for blt to complete
                   NVHEAP_FREE(lpSurfTemp);
               }
            }

            if (dwFlags & DDBLT_KEYSRCOVERRIDE) {
                /* disable chroma key */
                while (freeCount < 2)
                    NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                freeCount -= 2;

                dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_TRANSCOLOR) +
                    SET_TRANSCOLOR_OFFSET | 0x40000;
                dmaPusherPutAddress[1] = 0;

                dmaPusherPutAddress += 2;
            }

            if (isAlphaBlt) {
                /* Restore default destination color format */
                while (freeCount < 2)
                    NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                freeCount -= 2;

                dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                    SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000;

                dmaPusherPutAddress[1] =
                    NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;

                dmaPusherPutAddress += 2;
            }

        } else {
            DPF("BLT     blt not handled by driver");
            return DDHAL_DRIVER_NOTHANDLED;
        }

        // restore pixel depth for z blts
        if (isZBlt) {
            while (freeCount < 2)
                NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
            freeCount -= 2;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;

            dmaPusherPutAddress += 2;
        }

    } else if (dwFlags & DDBLT_COLORFILL) {
        dwFillColor = pbd->bltFX.dwFillColor & pDriverData->physicalColorMask;

        while (freeCount < 10)
            NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
        freeCount -= 10;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
            SET_ROP_OFFSET | 0x40000;
        dmaPusherPutAddress[1] = SRCCOPYINDEX;

        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
            SURFACES_2D_DEST_OFFSET | 0x40000;
        dmaPusherPutAddress[3] = dwDstOffset;
        dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
            SURFACES_2D_PITCH_OFFSET | 0x40000;
        dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

        dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
            RECT_AND_TEXT_COLOR1A_OFFSET | 0xC0000;
        dmaPusherPutAddress[7] = dwFillColor;
        dmaPusherPutAddress[8] = asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);
        dmaPusherPutAddress[9] = asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

        dmaPusherPutAddress += 10;

    } else if (dwFlags & DDBLT_DEPTHFILL) {

        if (!(dwDstCaps & DDSCAPS_ZBUFFER)) {
            pbd->ddRVal = DDERR_INVALIDSURFACETYPE;
            return DDHAL_DRIVER_HANDLED;
        }

        pDriverData->dwDmaPusherFreeCount = freeCount;
        (unsigned long *)pDriverData->NvDmaPusherPutAddress = dmaPusherPutAddress;

        nvD3DClearZBuffer(dstx, pbd->bltFX.dwFillDepth);

        dmaPusherPutAddress = (unsigned long *)pDriverData->NvDmaPusherPutAddress;
#ifdef  CACHE_FREECOUNT
        freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
        freeCount = 0;
#endif  /* CACHE_FREECOUNT */

    } else {
        /* We don't handle any other type of BLT operation */
        return DDHAL_DRIVER_NOTHANDLED;
    }

    pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

    /* Force write combine buffer to flush */
    pDriverData->NvDmaPusherBufferEnd[0] = 0;
    /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
    _outp (0x3d0,0);

    pDriverData->dwDmaPusherFreeCount = freeCount;

    npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

    pbd->ddRVal = DD_OK;

    return DDHAL_DRIVER_HANDLED;

} /* Blt32bpp32 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\blt832.c ===
/*==========================================================================;
 *
 *  Copyright (C) 1995, 1998 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       blt832.c
 *  Content:    Windows95 DirectDraw 32 bit driver
 *
 ***************************************************************************/

#include "windows.h"
#include <conio.h>
#include "nvd3ddrv.h"
#include "nv32.h"
#include "nvddobj.h"
#include "ddrvmem.h"
#include "d3dinc.h"
#include "nvheap.h"

extern DWORD ResetNV();

/*
 * Blt8bpp32
 *
 * 32-bit Blt function for 8bpp surfaces.
 */
DWORD __stdcall Blt8bpp32( LPDDHAL_BLTDATA pbd )
{
    FAST Nv10ControlDma *npDev;
    DWORD               dwFlags;
#ifdef  DX7
    DWORD               dwAFlags;
#endif  // DX7
    DWORD               dwDDFX = 0;
    DWORD               dwDstCaps;
    DWORD               dwSrcCaps;
    DWORD               dwRop;
    NVCOORD             wXYext;
    NVCOORD             wDestXY;
    NVCOORD             wSrcXY;
    BYTE                wStretch = 0;
    BYTE                doMirrorUpDown = 0;
    BYTE                isVideo = 0;
    BYTE                isZBlt = 0;

    DWORD               dwFillColor;
    DWORD               dwColorKey;

    DWORD               dwDstOffset;
    DWORD               dwDstPitch;
    DWORD               dwDstWidth;
    DWORD               dwDstHeight;

    DWORD               dwSrcOffset;
    DWORD               dwSrcPitch;
    DWORD               dwSrcWidth;
    DWORD               dwSrcHeight;

    LPDDRAWI_DDRAWSURFACE_LCL  srcx;
    LPDDRAWI_DDRAWSURFACE_LCL  dstx;
    LPDDRAWI_DDRAWSURFACE_GBL  src;
    LPDDRAWI_DDRAWSURFACE_GBL  dst;

    unsigned long       *dmaPusherPutAddress =
                            (unsigned long *)pDriverData->NvDmaPusherPutAddress;
    unsigned long       *dmaPusherBufferBase =
                            (unsigned long *)pDriverData->NvDmaPusherBufferBase;
    long                freeCount;

    dstx = pbd->lpDDDestSurface;
    dst = dstx->lpGbl;

    /*
     * NOTES:
     *
     * Everything you need is in pdb->bltFX .
     * Look at pdb->dwFlags to determine what kind of blt you are doing,
     * DDBLT_xxxx are the flags.
     *
     * Z BUFFER NOTES:
     *
     * ZBuffer ALWAYS comes in BLTFX.   You don't need to go looking for
     * the attached surface. If DDBLT_ZBUFFER is specified, then either a
     * constant z or z buffer surface has been specified for the source and
     * destination. Just look for the DDBLT_ZBUFFERDESTOVERRIDE,
     * DDBLT_ZBUFFERSRCOVERRIDE, DDBLT_ZBUFFERCONSTANTDESTOVERRIDE, or
     * DDBLT_ZBUFFERCONSTANTSRCOVERRIDE.
     *
     * COLORKEY NOTES:
     *
     * ColorKey ALWAYS comes in BLTFX.   You don't have to look it up in
     * the surface.
     */

    dwFlags   = pbd->dwFlags;
    dwDstCaps = dstx->ddsCaps.dwCaps;

    if (dwFlags & DDBLT_DDFX)
        dwDDFX = pbd->bltFX.dwDDFX;
#ifdef  DX7
    dwAFlags  = pbd->dwAFlags;

    if ((dwFlags & DDBLT_AFLAGS) && (dwAFlags & DDABLT_SRCOVERDEST)) {
        DPF("ALPHA ON 8BPP SURFACE FAILED");
        pbd->ddRVal = DDERR_NOALPHAHW;
        return DDHAL_DRIVER_HANDLED;
    }
#endif  /* DX7 */

    // check for z buffer blit
    // assume that DD runtime has enough sense to make alpha blits mutually exclusive
    if ((dwDstCaps & DDSCAPS_ZBUFFER) && (dstx->dwFlags & DDRAWISURF_HASPIXELFORMAT)) {
        if (dst->ddpfSurface.dwZBufferBitDepth == 32)
            isZBlt = NV042_SET_COLOR_FORMAT_LE_Y32;
        else if (dst->ddpfSurface.dwZBufferBitDepth == 16)
            isZBlt = NV042_SET_COLOR_FORMAT_LE_Y16;
    }

    if (dwFlags & (DDBLT_KEYDEST | DDBLT_KEYDESTOVERRIDE)) {
        DPF("DEST COLOR KEY FAILED");
        pbd->ddRVal = DDERR_NOCOLORKEYHW;
        return DDHAL_DRIVER_HANDLED;
    }

    /*
     * get offset, width, and height for destination
     */
    dwDstOffset = dst->fpVidMem     - pDriverData->BaseAddress;
    dwDstPitch  = dst->lPitch;
    dwDstWidth  = pbd->rDest.right  - pbd->rDest.left;
    dwDstHeight = pbd->rDest.bottom - pbd->rDest.top;
    wXYext.wh16.w = (unsigned short)dwDstWidth;
    wXYext.wh16.h = (unsigned short)dwDstHeight;

    wDestXY.xy16.x = (short)pbd->rDest.left;
    wDestXY.xy16.y = (short)pbd->rDest.top;

    if (dwDstCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_TEXTURE | DDSCAPS_NONLOCALVIDMEM))
        return DDHAL_DRIVER_NOTHANDLED;

    npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

    if (npDev == NULL) {
        if (!ResetNV()) {
            pbd->ddRVal = DDERR_GENERIC;
            return DDHAL_DRIVER_HANDLED;
        }
        pDriverData->fReset = FALSE;
        npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

        if (npDev == NULL) {
            pbd->ddRVal = DDERR_SURFACELOST;
            return DDHAL_DRIVER_HANDLED;
        }
    }

    dmaPusherPutAddress = (unsigned long *)pDriverData->NvDmaPusherPutAddress;

#ifdef  CACHE_FREECOUNT
    freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
    freeCount = 0;
#endif  /* CACHE_FREECOUNT */

    /*
     * If async, then only work if bltter isn't busy
     * This should probably be a little more specific to each call, but
     * waiting for 32 is pretty close
     */
    if (dwFlags & DDBLT_ASYNC ) {

        NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);

        pDriverData->dwDmaPusherFreeCount = freeCount;

        /* Must save pointer in case it was changed by above macro */
        pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

        if (freeCount < 10) {
            DPF("ASYNC FAILED");
            pbd->ddRVal = DDERR_WASSTILLDRAWING;
            return DDHAL_DRIVER_HANDLED;
        }
    }

    if (dwFlags & DDBLT_ROP) {
        dwRop = pbd->bltFX.dwROP >> 16;

        // set pixel depth for z buffer blit
        if (isZBlt) {
            while (freeCount < 2)
                NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
            freeCount -= 2;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = isZBlt;

            dmaPusherPutAddress += 2;
        }
        if ((dwRop == BLACKNESSINDEX) || (dwRop == WHITENESSINDEX)) {

            while (freeCount < 10)
                NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
            freeCount -= 10;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                SET_ROP_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = dwRop;

            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_DEST_OFFSET | 0x40000;
            dmaPusherPutAddress[3] = dwDstOffset;
            dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_PITCH_OFFSET | 0x40000;
            dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

            dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_COLOR1A_OFFSET | 0xC0000;
            dmaPusherPutAddress[7] = 0;
            dmaPusherPutAddress[8] = asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);
            dmaPusherPutAddress[9] = asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

            dmaPusherPutAddress += 10;

        } else if ((dwRop == PATCOPYINDEX) || (dwRop == PATINVERTINDEX)) {

            dwFillColor = pbd->bltFX.dwFillColor & pDriverData->physicalColorMask;

            if (dwRop == PATCOPYINDEX)
                dwRop = SRCCOPYINDEX;
            else if (dwRop == PATINVERTINDEX)
                dwRop = SRCINVERTINDEX;

            while (freeCount < 10)
                NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
            freeCount -= 10;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                SET_ROP_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = dwRop;

            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_DEST_OFFSET | 0x40000;
            dmaPusherPutAddress[3] = dwDstOffset;
            dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_PITCH_OFFSET | 0x40000;
            dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

            dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_COLOR1A_OFFSET | 0xC0000;
            dmaPusherPutAddress[7] = dwFillColor;
            dmaPusherPutAddress[8] = asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);
            dmaPusherPutAddress[9] = asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

            dmaPusherPutAddress += 10;

        } else if ((dwRop == SRCCOPYINDEX) || (dwRop == SRCPAINTINDEX) ||
                   (dwRop == SRCANDINDEX) || (dwRop == NOTSRCCOPYINDEX) ||
                   (dwRop == SRCINVERTINDEX) || (dwRop == MERGEPAINTINDEX) ||
                   (dwRop == SRCERASEINDEX) || (dwRop == NOTSRCERASEINDEX)) {

            srcx = pbd->lpDDSrcSurface;
            src = srcx->lpGbl;

            dwSrcCaps = srcx->ddsCaps.dwCaps;

            /* We must treat AGP source memory as system memory */
            if (dwSrcCaps & DDSCAPS_NONLOCALVIDMEM) {
                dwSrcCaps &= ~(DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM);
            }

            dwSrcOffset = src->fpVidMem    - pDriverData->BaseAddress;
            dwSrcPitch  = src->lPitch;
            dwSrcWidth  = pbd->rSrc.right  - pbd->rSrc.left;
            dwSrcHeight = pbd->rSrc.bottom - pbd->rSrc.top;
            dwColorKey  = pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;

            wSrcXY.xy16.x = (short)pbd->rSrc.left;
            wSrcXY.xy16.y = (short)pbd->rSrc.top;

            /* We don't handle FOURCC_RGB0 format in 8bpp mode */
            if ((srcx->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
                (src->ddpfSurface.dwFlags & DDPF_FOURCC)) {

               if (src->ddpfSurface.dwFourCC == FOURCC_RGB0) {
                   if ((src->ddpfSurface.dwRBitMask == 0) &&
                       (src->ddpfSurface.dwGBitMask == 0) &&
                       (src->ddpfSurface.dwBBitMask == 0)) {
                       if (dwSrcCaps & DDSCAPS_SYSTEMMEMORY)
                           isVideo = 1;
                       goto srcRGB;
                   } else {
                       pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                       return DDHAL_DRIVER_HANDLED;
                   }
               }
               pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
               return DDHAL_DRIVER_HANDLED;
            }

srcRGB:     if (dwDDFX & DDBLTFX_MIRRORUPDOWN)
                doMirrorUpDown = 1;

            if ((dwSrcWidth != dwDstWidth) || (dwSrcHeight != dwDstHeight)) {
                wStretch = 1;
            }

            if (dwFlags & DDBLT_KEYSRCOVERRIDE) {

                dwColorKey = pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;

                /* Let D3D know that we changed the object in subchannel 6 */
                pDriverData->dDrawSpareSubchannel6Object = NV_DD_CONTEXT_COLOR_KEY;

                while (freeCount < 4)
                    NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
                freeCount -= 4;

                // load and enable chroma key
                dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_TRANSCOLOR) | 0x40000;
                dmaPusherPutAddress[1] = NV_DD_CONTEXT_COLOR_KEY;
                dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_TRANSCOLOR) +
                    SET_TRANSCOLOR_OFFSET | 0x40000;
                dmaPusherPutAddress[3] =
                    (dwColorKey & pDriverData->physicalColorMask) | NV_ALPHA_1_008;

                dmaPusherPutAddress += 4;

                pDriverData->dwDmaPusherFreeCount = freeCount;

                /* Just in case we return unexpectedly */
                pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;
            }

            // screen to screen bitblt
            if (wStretch == 0) {

                if ((dwDstCaps & DDSCAPS_VIDEOMEMORY) &&
                    (dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                    ((dwSrcCaps & DDSCAPS_TEXTURE) == 0) &&
                    (doMirrorUpDown == 0) &&
                    (isVideo == 0)) {

                    if (pDriverData->dwSharedClipChangeCount != pDriverData->dwDDMostRecentClipChangeCount) {

                        while (freeCount < 7)
                            NvGetDmaBufferFreeCount(npDev, freeCount, 7, dmaPusherPutAddress);
                        freeCount -= 7;

                        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
                        dmaPusherPutAddress[1] = NV_DD_IMAGE_BLACK_RECTANGLE;
                        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                            IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000;
                        dmaPusherPutAddress[3] = 0;
                        dmaPusherPutAddress[4] = asmMergeCoords(NV_MAX_X_CLIP, NV_MAX_Y_CLIP);
                        dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
                        dmaPusherPutAddress[6] = NV_DD_SURFACES_2D;

                        dmaPusherPutAddress += 7;

                        pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                        /* Force write combine buffer to flush */
                        pDriverData->NvDmaPusherBufferEnd[0] = 0;
                        /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                        _outp (0x3d0,0);

                        pDriverData->dwDmaPusherFreeCount = freeCount;

                        npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                        pDriverData->dwSharedClipChangeCount++;

                        pDriverData->dwDDMostRecentClipChangeCount = pDriverData->dwSharedClipChangeCount;
                    }

                    while (freeCount < 10)
                        NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
                    freeCount -= 10;

                    dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                        SET_ROP_OFFSET | 0x40000;
                    dmaPusherPutAddress[1] = dwRop;

                    dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                        SURFACES_2D_PITCH_OFFSET | 0xC0000;
                    dmaPusherPutAddress[3] = (dwDstPitch << 16) | dwSrcPitch;
                    dmaPusherPutAddress[4] = dwSrcOffset;
                    dmaPusherPutAddress[5] = dwDstOffset;

                    dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_BLIT) +
                        BLIT_POINT_IN_OFFSET | 0xC0000;
                    dmaPusherPutAddress[7] = wSrcXY.xy;
                    dmaPusherPutAddress[8] = wDestXY.xy;
                    dmaPusherPutAddress[9] = wXYext.wh;

                    dmaPusherPutAddress += 10;

               } else {
                   // memory to screen blt (src may be in system memory or in video memory)
                   unsigned long temp;
                   long srcScanLength;
                   long nxtSrcScan;
                   short n = wXYext.wh16.h;
                   FAST short pxlCount;
                   unsigned short srcOffset;
                   unsigned char *pSrcInitBits;

                   pSrcInitBits = (unsigned char *)src->fpVidMem;

                   srcScanLength = src->lPitch;

                   if (doMirrorUpDown)
                       wSrcXY.xy16.y += (n - 1);

                   pSrcInitBits += (wSrcXY.xy16.y * srcScanLength);

                   srcOffset = wSrcXY.xy16.x & 3;

                   temp = ((wXYext.wh16.w + srcOffset + 3) & 0xFFFC);

                   nxtSrcScan = srcScanLength - temp;

                   if (doMirrorUpDown)
                       nxtSrcScan = -srcScanLength - temp;

                   pSrcInitBits += (wSrcXY.xy16.x & 0xFFFC);

                   while (freeCount < 15)
                       NvGetDmaBufferFreeCount(npDev, freeCount, 15, dmaPusherPutAddress);
                   freeCount -= 15;

                   if (pDriverData->dDrawSpareSubchannelObject !=
                       NV_DD_IMAGE_BLACK_RECTANGLE) {

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                       dmaPusherPutAddress[1] = NV_DD_IMAGE_BLACK_RECTANGLE;

                       dmaPusherPutAddress += 2;

                       pDriverData->dDrawSpareSubchannelObject =
                       NV_DD_IMAGE_BLACK_RECTANGLE;
                   }

                   /* Let others know that we changed the clip */
                   pDriverData->dwSharedClipChangeCount++;

                   // changing canvas clip avoids manually aligning 8-bit source
                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) +
                       IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000;
                   dmaPusherPutAddress[1] = wDestXY.xy;
                   dmaPusherPutAddress[2] = wXYext.wh;

                   dmaPusherPutAddress[3] = dDrawSubchannelOffset(NV_DD_ROP) +
                       SET_ROP_OFFSET | 0x40000;
                   dmaPusherPutAddress[4] = dwRop;

                   dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                       SURFACES_2D_DEST_OFFSET | 0x40000;
                   dmaPusherPutAddress[6] = dwDstOffset;
                   dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                       SURFACES_2D_PITCH_OFFSET | 0x40000;
                   dmaPusherPutAddress[8] = (dwDstPitch << 16) | dwDstPitch;

                   /* compiler screws up this expression when it goes negative in following macro */
                   temp = wDestXY.xy16.x - srcOffset;

                   dmaPusherPutAddress[9] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                       IMAGE_FROM_CPU_POINT_OFFSET | 0xC0000;
                   dmaPusherPutAddress[10] =
                       asmMergeCoords(temp, wDestXY.xy16.y);
                   dmaPusherPutAddress[11] =
                       asmMergeCoords(wXYext.wh16.w + srcOffset, wXYext.wh16.h);

                   temp = ((wXYext.wh16.w + srcOffset + 3) & 0xFFFC);

                   dmaPusherPutAddress[12] =
                       asmMergeCoords(temp, wXYext.wh16.h);

                   dmaPusherPutAddress += 13;

                   {
                       FAST unsigned char *pSrcBits = pSrcInitBits;
                       FAST unsigned long tmpPxls0, tmpPxls1, tmpPxls2;

                       if (temp < (1792 << 2)) {
                           while (--n >= 0) {
                               pxlCount = (short)temp;

                               // Get enough buffer space for this scanline
                               while (freeCount < (long)(1 + (temp >> 2)))
                                   NvGetDmaBufferFreeCount(npDev, freeCount, (long)(1 + (temp >> 2)), dmaPusherPutAddress);
                               freeCount -= (long)(1 + (temp >> 2));

                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                   IMAGE_FROM_CPU_COLOR_OFFSET | (temp << 16);
                               dmaPusherPutAddress += 1;

                               while (pxlCount >= 32) {
                                   pxlCount -= 32;

                                   tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                   tmpPxls1 = *(unsigned long *)&pSrcBits[4];
                                   dmaPusherPutAddress[0] = tmpPxls0;
                                   tmpPxls2 = *(unsigned long *)&pSrcBits[8];
                                   dmaPusherPutAddress[1] = tmpPxls1;
                                   tmpPxls0 = *(unsigned long *)&pSrcBits[12];
                                   tmpPxls1 = *(unsigned long *)&pSrcBits[16];
                                   dmaPusherPutAddress[2] = tmpPxls2;
                                   dmaPusherPutAddress[3] = tmpPxls0;
                                   tmpPxls2 = *(unsigned long *)&pSrcBits[20];
                                   tmpPxls0 = *(unsigned long *)&pSrcBits[24];
                                   dmaPusherPutAddress[4] = tmpPxls1;
                                   dmaPusherPutAddress[5] = tmpPxls2;
                                   tmpPxls1 = *(unsigned long *)&pSrcBits[28];
                                   dmaPusherPutAddress[6] = tmpPxls0;
                                   pSrcBits += 32;
                                   dmaPusherPutAddress[7] = tmpPxls1;

                                   dmaPusherPutAddress += 8;
                               }

                               if (pxlCount > 0) {

                                   while (pxlCount >= 8) {
                                       pxlCount -= 8;
                                       tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                       tmpPxls1 = *(unsigned long *)&pSrcBits[4];
                                       pSrcBits += 8;
                                       dmaPusherPutAddress[0] = tmpPxls0;
                                       dmaPusherPutAddress[1] = tmpPxls1;

                                       dmaPusherPutAddress += 2;
                                   }

                                   if (pxlCount > 0) {
                                       pxlCount -= 4;
                                       tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                       pSrcBits += 4;
                                       dmaPusherPutAddress[0] = tmpPxls0;

                                       dmaPusherPutAddress++;

                                       if (pxlCount > 0) {
                                           tmpPxls1 = *(unsigned long *)&pSrcBits[0];
                                           pSrcBits += 4;
                                           dmaPusherPutAddress[0] = tmpPxls1;

                                           dmaPusherPutAddress++;
                                       }
                                   }
                               }
                               pSrcBits += nxtSrcScan;

                               /* Force write combine buffer to flush */
                               pDriverData->NvDmaPusherBufferEnd[0] = 0;
                               /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                               _outp (0x3d0,0);

                               pDriverData->dwDmaPusherFreeCount = freeCount;

                               npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                            }
                        } else { /* more than 1792 dwords per scanline */

                           while (--n >= 0) {
                               pxlCount = (short)temp;

                               while (pxlCount >= 32) {
                                   pxlCount -= 32;

                                   while (freeCount < (1 + (32 >> 2)))
                                       NvGetDmaBufferFreeCount(npDev, freeCount, (1 + (32 >> 2)), dmaPusherPutAddress);
                                   freeCount -= (1 + (32 >> 2));

                                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                       IMAGE_FROM_CPU_COLOR_OFFSET | (32 << 16);

                                   tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                   tmpPxls1 = *(unsigned long *)&pSrcBits[4];
                                   dmaPusherPutAddress[1] = tmpPxls0;
                                   tmpPxls2 = *(unsigned long *)&pSrcBits[8];
                                   dmaPusherPutAddress[2] = tmpPxls1;
                                   tmpPxls0 = *(unsigned long *)&pSrcBits[12];
                                   tmpPxls1 = *(unsigned long *)&pSrcBits[16];
                                   dmaPusherPutAddress[3] = tmpPxls2;
                                   dmaPusherPutAddress[4] = tmpPxls0;
                                   tmpPxls2 = *(unsigned long *)&pSrcBits[20];
                                   tmpPxls0 = *(unsigned long *)&pSrcBits[24];
                                   dmaPusherPutAddress[5] = tmpPxls1;
                                   dmaPusherPutAddress[6] = tmpPxls2;
                                   tmpPxls1 = *(unsigned long *)&pSrcBits[28];
                                   dmaPusherPutAddress[7] = tmpPxls0;
                                   pSrcBits += 32;
                                   dmaPusherPutAddress[8] = tmpPxls1;

                                   dmaPusherPutAddress += 9;
                               }

                               if (pxlCount > 0) {

                                   while (freeCount < (1 + (pxlCount >> 2)))
                                       NvGetDmaBufferFreeCount(npDev, freeCount, (1 + (pxlCount >> 2)), dmaPusherPutAddress);
                                   freeCount -= (1 + (pxlCount >> 2));

                                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                       IMAGE_FROM_CPU_COLOR_OFFSET | (pxlCount << 16);
                                   dmaPusherPutAddress += 1;

                                   while (pxlCount >= 8) {
                                       pxlCount -= 8;
                                       tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                       tmpPxls1 = *(unsigned long *)&pSrcBits[4];
                                       pSrcBits += 8;
                                       dmaPusherPutAddress[0] = tmpPxls0;
                                       dmaPusherPutAddress[1] = tmpPxls1;

                                       dmaPusherPutAddress += 2;
                                   }

                                   if (pxlCount > 0) {
                                       pxlCount -= 4;
                                       tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                       pSrcBits += 4;
                                       dmaPusherPutAddress[0] = tmpPxls0;

                                       dmaPusherPutAddress++;

                                       if (pxlCount > 0) {
                                           tmpPxls1 = *(unsigned long *)&pSrcBits[0];
                                           pSrcBits += 4;
                                           dmaPusherPutAddress[0] = tmpPxls1;

                                           dmaPusherPutAddress++;
                                       }
                                   }
                               }
                               pSrcBits += nxtSrcScan;

                               /* Force write combine buffer to flush */
                               pDriverData->NvDmaPusherBufferEnd[0] = 0;
                               /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                               _outp (0x3d0,0);

                               pDriverData->dwDmaPusherFreeCount = freeCount;

                               npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                            }
                        }
                    }

                    pDriverData->dwSharedClipChangeCount++;

                    pDriverData->dwDDMostRecentClipChangeCount = pDriverData->dwSharedClipChangeCount;

                    while (freeCount < 3)
                        NvGetDmaBufferFreeCount(npDev, freeCount, 3, dmaPusherPutAddress);
                    freeCount -= 3;

                    // restore canvas clip
                    dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) +
                        IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000;
                    dmaPusherPutAddress[1] = 0;
                    dmaPusherPutAddress[2] = asmMergeCoords(NV_MAX_X_CLIP, NV_MAX_Y_CLIP);

                    dmaPusherPutAddress += 3;
                }
            } else { // stretch
               NvNotification *pDmaBufferNotifier;
               unsigned char *pScanlineBuffer;
               long srcScanLength;
               long nxtSrcScan;
               long n;
               short m;
               FAST short pxlCount;
               unsigned char *pSrcInitBits;
               unsigned char *pSaveSrcBits;
               unsigned char *pSrcCurScan;
               long deltaX;
               long deltaY;
               long curDstY;
               long lastDstY;
               long skipSrcBytes = 0;
               NVCOORD wSrcExt;
               NVCOORD wDstPoint;
               unsigned long srcStrtX;
               BYTE srcInVideoMemory = 0;
               BYTE bufState = 0;
               short skipV = 0;

               RECT rDummy;
               BOOL isOverlappingVmem = FALSE;
               FLATPTR lpSurfTemp = 0;
               DWORD dwSrcBitsPP = 8;
               // if the source and destination overlap, then we must do this in 2 passes, first copy the source
               // image somewhere else, and then so the stretch from there.
               if ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) && dwSrcOffset == dwDstOffset && IntersectRect(&rDummy, (LPRECT)(&pbd->rSrc), (LPRECT)(&pbd->rDest))) {
                    NVHEAP_ALLOC(lpSurfTemp, dwSrcHeight * ((dwSrcWidth * dwSrcBitsPP / 8 + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad), TYPE_IMAGE);
                    if (lpSurfTemp) {
                        isOverlappingVmem = TRUE;
                        if (pDriverData->dwSharedClipChangeCount != pDriverData->dwDDMostRecentClipChangeCount) {

                            while (freeCount < 7)
                                NvGetDmaBufferFreeCount(npDev, freeCount, 7, dmaPusherPutAddress);
                            freeCount -= 7;

                            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
                            dmaPusherPutAddress[1] = NV_DD_IMAGE_BLACK_RECTANGLE;
                            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                                IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000;
                            dmaPusherPutAddress[3] = 0;
                            dmaPusherPutAddress[4] = asmMergeCoords(NV_MAX_X_CLIP, NV_MAX_Y_CLIP);
                            dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
                            dmaPusherPutAddress[6] = NV_DD_SURFACES_2D;

                            dmaPusherPutAddress += 7;

                            pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                            /* Force write combine buffer to flush */
                            pDriverData->NvDmaPusherBufferEnd[0] = 0;
                            /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                            _outp (0x3d0,0);

                            pDriverData->dwDmaPusherFreeCount = freeCount;

                            npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                            pDriverData->dwSharedClipChangeCount++;

                            pDriverData->dwDDMostRecentClipChangeCount = pDriverData->dwSharedClipChangeCount;
                        }

                        while (freeCount < 10)
                            NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
                        freeCount -= 10;

                        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                            SET_ROP_OFFSET | 0x40000;
                        dmaPusherPutAddress[1] = dwRop;

                        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                            SURFACES_2D_PITCH_OFFSET | 0xC0000;
                        dmaPusherPutAddress[3] = ((((dwSrcWidth * dwSrcBitsPP / 8 + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad)) << 16) | dwSrcPitch;
                        dmaPusherPutAddress[4] = dwSrcOffset;
                        dmaPusherPutAddress[5] = lpSurfTemp - pDriverData->BaseAddress;

                        dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_BLIT) +
                            BLIT_POINT_IN_OFFSET | 0xC0000;
                        dmaPusherPutAddress[7] = wSrcXY.xy;
                        dmaPusherPutAddress[8] = 0;
                        dmaPusherPutAddress[9] = wXYext.wh;

                        dmaPusherPutAddress += 10;

                        dwSrcOffset = lpSurfTemp - pDriverData->BaseAddress;
                        dwSrcPitch = ((dwSrcWidth * dwSrcBitsPP / 8 + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad);
                        wSrcXY.xy = 0;
                        wSrcXY.xy16.x = 0;
                        wSrcXY.xy16.y = 0;
                    } else {
                        // FIXME: vmem heap alloc failed, must do system mem alloc and copy there
                    }
               }
               // WARNING: carefully consider each use of src->fpVidMem and src->lPitch beyond this point
               //          it could screw up overlapping stretchblits

//               pSrcInitBits = (unsigned char *)src->fpVidMem;
//               srcScanLength = src->lPitch;
               pSrcInitBits = (unsigned char *)(dwSrcOffset + pDriverData->BaseAddress);
               srcScanLength = dwSrcPitch;

               if (dwSrcPitch <= 800)
                   m = 16;
               else
                   m = 8;

               while (freeCount < 6)
                   NvGetDmaBufferFreeCount(npDev, freeCount, 6, dmaPusherPutAddress);
               freeCount -= 6;

               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                   SET_ROP_OFFSET | 0x40000;
               dmaPusherPutAddress[1] = dwRop;

               dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                   SURFACES_2D_DEST_OFFSET | 0x40000;
               dmaPusherPutAddress[3] = dwDstOffset;
               dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                   SURFACES_2D_PITCH_OFFSET | 0x40000;
               dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

               dmaPusherPutAddress += 6;

               /* calculate deltas in 12.20 format */
               deltaX = dwDstWidth << 20;
               deltaX /= dwSrcWidth;

               if ((deltaX > 0x100000) && (deltaX & 0xFFFFF)) {
                   long xStretch = deltaX & 0xFFF00000;
                   deltaX = (dwDstWidth << 20) + xStretch;
                   deltaX /= dwSrcWidth;
               }

               if ((deltaX < 0x100000) && (deltaX & 0xFFFFF)) {
                   deltaX = (dwDstWidth << 20) + 0x100000;
                   deltaX /= dwSrcWidth;
               }

               deltaY = dwDstHeight << 20;
               deltaY /= dwSrcHeight;

               if ((deltaY > 0x100000) && (deltaY & 0xFFFFF)) {
                   long yStretch = deltaY & 0xFFF00000;
                   deltaY = (dwDstHeight << 20) + yStretch;
                   deltaY /= dwSrcHeight;
               }

               if ((deltaY < 0x100000) && (deltaY & 0xFFFFF)) {
                   deltaY = (dwDstHeight << 20) + 0x100000;
                   deltaY /= dwSrcHeight;
               }

               wSrcExt.wh16.w = (unsigned short)((dwSrcWidth + 3) & ~3L);
               wSrcExt.wh16.h = (unsigned short)dwSrcHeight;

               n = (short)dwSrcHeight;

               if (wSrcXY.xy16.y + n > src->wHeight)
                   n = src->wHeight - wSrcXY.xy16.y;

               nxtSrcScan = srcScanLength;

               if (doMirrorUpDown) {
                   wSrcXY.xy16.y += (n - 1);
                   nxtSrcScan = -nxtSrcScan;
                   skipSrcBytes = -skipSrcBytes;
               }

               if ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                   ((dwSrcCaps & DDSCAPS_TEXTURE) == 0) &&
                   ((src->fpVidMem >= pDriverData->BaseAddress) || isOverlappingVmem)) {
                   srcInVideoMemory = 1;
               } else {
                   pSaveSrcBits = (unsigned char *)(pSrcInitBits +
                                  (wSrcXY.xy16.y * srcScanLength));
                   pSaveSrcBits += wSrcXY.xy16.x;
                   pSrcCurScan = pSaveSrcBits;
               }

               if (srcInVideoMemory) {
                   pDmaBufferNotifier = (NvNotification *)pDriverData->NvDmaBufferNotifierFlat;
                   pDmaBufferNotifier++;
                   pScanlineBuffer = (unsigned char *)pDriverData->NvScanlineBufferFlat;

                   wSrcExt.wh16.w = (unsigned short)((dwSrcWidth + 3) & ~3);
                   wSrcExt.wh16.h = m;

                   srcStrtX = wSrcXY.xy16.x;

                   while (freeCount < 2)
                       NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                   freeCount -= 2;

                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) | 0x40000;
                   dmaPusherPutAddress[1] = NV_DD_VIDEO_MEMORY_TO_SYSTEM_MEMORY_FORMAT;

                   dmaPusherPutAddress += 2;

                   // wait for any pending notification operation to finish
                   while ((volatile)pDmaBufferNotifier->status == NV_IN_PROGRESS);

                   pDmaBufferNotifier->status = NV_IN_PROGRESS;

                   while (freeCount < 9)
                       NvGetDmaBufferFreeCount(npDev, freeCount, 9, dmaPusherPutAddress);
                   freeCount -= 9;

                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                       MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000;

                   dmaPusherPutAddress[1] = dwSrcOffset +
                       ((dwSrcPitch + skipSrcBytes) * (unsigned long)wSrcXY.xy16.y) +
                       ((unsigned long)wSrcXY.xy16.x);

                   dmaPusherPutAddress[2] = NV_DD_NOTIFIER_BLOCK_SIZE + srcStrtX;

                   dmaPusherPutAddress[3] = (dwSrcPitch + skipSrcBytes);

                   dmaPusherPutAddress[4] = dwSrcPitch;

                   dmaPusherPutAddress[5] = (unsigned long)wSrcExt.wh16.w;

                   dmaPusherPutAddress[6] = m;

                   dmaPusherPutAddress[7] = (1 << 8) | 1;

                   dmaPusherPutAddress[8] = 0;

                   dmaPusherPutAddress += 9;

                   /* Force write combine buffer to flush */
                   pDriverData->NvDmaPusherBufferEnd[0] = 0;
                   /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                   _outp (0x3d0,0);

                   pDriverData->dwDmaPusherFreeCount = freeCount;

                   npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                   // wait for Dma operation to finish
                   while ((volatile)pDmaBufferNotifier->status == NV_IN_PROGRESS);

                   if (doMirrorUpDown)
                       wSrcXY.xy16.y -= (m + skipV);
                   else
                       wSrcXY.xy16.y += (m + skipV);
               }

               /* Convert to 12.4 format */
               wDstPoint.xy16.x = (wDestXY.xy16.x << 4);
               wDstPoint.xy16.y = (wDestXY.xy16.y << 4);

               /* convert to 16.16 */
               lastDstY = (long)(wDestXY.xy16.y + wXYext.wh16.h) << 16;

               /* convert to 16.16 */
               curDstY = ((long)wDestXY.xy16.y << 16);

               while (freeCount < 7)
                   NvGetDmaBufferFreeCount(npDev, freeCount, 7, dmaPusherPutAddress);
               freeCount -= 7;

               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                   STRETCHED_IMAGE_SIZE_IN_OFFSET | 0x180000;
               dmaPusherPutAddress[1] = wSrcExt.wh;
               dmaPusherPutAddress[2] = deltaX;
               dmaPusherPutAddress[3] = deltaY;
               dmaPusherPutAddress[4] = wDestXY.xy;
               dmaPusherPutAddress[5] = wXYext.wh;
               dmaPusherPutAddress[6] = wDstPoint.xy;

               dmaPusherPutAddress += 7;

               while ((n > 0) && (curDstY < lastDstY)) {
                   FAST unsigned long *pSrcBits;
                   FAST unsigned long tmpPxls0, tmpPxls1, tmpPxls2;

                   if (srcInVideoMemory) {
                       if (bufState == 0)
                           pSrcBits = (unsigned long *)(pScanlineBuffer + srcStrtX);
                       else
                           pSrcBits = (unsigned long *)(pScanlineBuffer +
                               (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1) + srcStrtX);

                       pSrcCurScan = (unsigned char *)pSrcBits;

                       if (m > 0) {
                           pDmaBufferNotifier->status = NV_IN_PROGRESS;

                           while (freeCount < 9)
                               NvGetDmaBufferFreeCount(npDev, freeCount, 9, dmaPusherPutAddress);
                           freeCount -= 9;

                           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                               MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000;

                           dmaPusherPutAddress[1] = dwSrcOffset +
                               ((dwSrcPitch + skipSrcBytes) * (unsigned long)wSrcXY.xy16.y) +
                               ((unsigned long)wSrcXY.xy16.x);

                           if (bufState == 0)
                               dmaPusherPutAddress[2] =
                                   NV_DD_NOTIFIER_BLOCK_SIZE +
                                   (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1) +
                                   srcStrtX;
                           else
                               dmaPusherPutAddress[2] =
                                   NV_DD_NOTIFIER_BLOCK_SIZE +
                                   srcStrtX;

                           dmaPusherPutAddress[3] = (dwSrcPitch + skipSrcBytes);

                           dmaPusherPutAddress[4] = dwSrcPitch;

                           dmaPusherPutAddress[5] = (unsigned long)wSrcExt.wh16.w;

                           dmaPusherPutAddress[6] = m;

                           dmaPusherPutAddress[7] = (1 << 8) | 1;

                           dmaPusherPutAddress[8] = 0;

                           dmaPusherPutAddress += 9;

                           /* Force write combine buffer to flush */
                           pDriverData->NvDmaPusherBufferEnd[0] = 0;
                           /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                           _outp (0x3d0,0);

                           pDriverData->dwDmaPusherFreeCount = freeCount;

                           npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                           bufState ^= 1;

                           if (doMirrorUpDown)
                               wSrcXY.xy16.y -= (m + skipV);
                           else
                               wSrcXY.xy16.y += (m + skipV);

                           while (freeCount < 7)
                               NvGetDmaBufferFreeCount(npDev, freeCount, 7, dmaPusherPutAddress);
                           freeCount -= 7;

                           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                               STRETCHED_IMAGE_SIZE_IN_OFFSET | 0x180000;

                           dmaPusherPutAddress[1] = wSrcExt.wh;

                           dmaPusherPutAddress[2] = deltaX;

                           dmaPusherPutAddress[3] = deltaY;

                           dmaPusherPutAddress[4] = wDestXY.xy;

                           dmaPusherPutAddress[5] = wXYext.wh;

                           dmaPusherPutAddress[6] = wDstPoint.xy;

                           dmaPusherPutAddress += 7;

                           /* Force write combine buffer to flush */
                           pDriverData->NvDmaPusherBufferEnd[0] = 0;
                           /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                           _outp (0x3d0,0);

                           pDriverData->dwDmaPusherFreeCount = freeCount;

                           npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                       }
                   } else { // source in system memory
                       pSrcBits = (unsigned long *)pSrcCurScan;
                       pSrcCurScan += (nxtSrcScan + skipSrcBytes);
                       n--;
                   }

doNxtSrcScan:      pxlCount = (short)((dwSrcWidth + 3) & ~3);

                   if (pxlCount < (1792 << 2)) {

                       // Get enough room for this scanline
                       while (freeCount < (1 + (pxlCount >> 2)))
                           NvGetDmaBufferFreeCount(npDev, freeCount, (1 + (pxlCount >> 2)), dmaPusherPutAddress);
                       freeCount -= (1 + (pxlCount >> 2));

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           STRETCHED_IMAGE_COLOR_OFFSET | (pxlCount << 16);

                       dmaPusherPutAddress += 1;

                       while (pxlCount >= 64) {

                           pxlCount -= 64;

                           tmpPxls0 = pSrcBits[0];
                           tmpPxls1 = pSrcBits[1];
                           dmaPusherPutAddress[0] = tmpPxls0;
                           tmpPxls2 = pSrcBits[2];
                           dmaPusherPutAddress[1] = tmpPxls1;
                           tmpPxls0 = pSrcBits[3];
                           tmpPxls1 = pSrcBits[4];
                           dmaPusherPutAddress[2] = tmpPxls2;
                           dmaPusherPutAddress[3] = tmpPxls0;
                           tmpPxls2 = pSrcBits[5];
                           tmpPxls0 = pSrcBits[6];
                           dmaPusherPutAddress[4] = tmpPxls1;
                           dmaPusherPutAddress[5] = tmpPxls2;
                           tmpPxls1 = pSrcBits[7];
                           tmpPxls2 = pSrcBits[8];
                           dmaPusherPutAddress[6] = tmpPxls0;
                           dmaPusherPutAddress[7] = tmpPxls1;
                           tmpPxls0 = pSrcBits[9];
                           tmpPxls1 = pSrcBits[10];
                           dmaPusherPutAddress[8] = tmpPxls2;
                           dmaPusherPutAddress[9] = tmpPxls0;
                           tmpPxls2 = pSrcBits[11];
                           tmpPxls0 = pSrcBits[12];
                           dmaPusherPutAddress[10] = tmpPxls1;
                           dmaPusherPutAddress[11] = tmpPxls2;
                           tmpPxls1 = pSrcBits[13];
                           tmpPxls2 = pSrcBits[14];
                           dmaPusherPutAddress[12] = tmpPxls0;
                           dmaPusherPutAddress[13] = tmpPxls1;
                           tmpPxls0 = pSrcBits[15];
                           dmaPusherPutAddress[14] = tmpPxls2;
                           pSrcBits += 16;
                           dmaPusherPutAddress[15] = tmpPxls0;

                           dmaPusherPutAddress += 16;
                       }

                       while (pxlCount >= 32) {

                           pxlCount -= 32;

                           tmpPxls0 = pSrcBits[0];
                           tmpPxls1 = pSrcBits[1];
                           dmaPusherPutAddress[0] = tmpPxls0;
                           tmpPxls2 = pSrcBits[2];
                           dmaPusherPutAddress[1] = tmpPxls1;
                           tmpPxls0 = pSrcBits[3];
                           tmpPxls1 = pSrcBits[4];
                           dmaPusherPutAddress[2] = tmpPxls2;
                           dmaPusherPutAddress[3] = tmpPxls0;
                           tmpPxls2 = pSrcBits[5];
                           tmpPxls0 = pSrcBits[6];
                           dmaPusherPutAddress[4] = tmpPxls1;
                           dmaPusherPutAddress[5] = tmpPxls2;
                           tmpPxls1 = pSrcBits[7];
                           pSrcBits += 8;
                           dmaPusherPutAddress[6] = tmpPxls0;
                           dmaPusherPutAddress[7] = tmpPxls1;

                           dmaPusherPutAddress += 8;
                       }

                       while (pxlCount >= 4) {
                           pxlCount -= 4;
                           tmpPxls0 = pSrcBits[0];
                           pSrcBits += 1;
                           dmaPusherPutAddress[0] = tmpPxls0;

                           dmaPusherPutAddress += 1;
                       }

                   } else { /* more than 1792 dwords per scanline */

                       while (pxlCount >= 64) {

                           pxlCount -= 64;

                           while (freeCount < (1 + (64 >> 2)))
                               NvGetDmaBufferFreeCount(npDev, freeCount, (1 + (64 >> 2)), dmaPusherPutAddress);
                           freeCount -= (1 + (64 >> 2));

                           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                               STRETCHED_IMAGE_COLOR_OFFSET | (64 << 16);

                           dmaPusherPutAddress += 1;

                           tmpPxls0 = pSrcBits[0];
                           tmpPxls1 = pSrcBits[1];
                           dmaPusherPutAddress[0] = tmpPxls0;
                           tmpPxls2 = pSrcBits[2];
                           dmaPusherPutAddress[1] = tmpPxls1;
                           tmpPxls0 = pSrcBits[3];
                           tmpPxls1 = pSrcBits[4];
                           dmaPusherPutAddress[2] = tmpPxls2;
                           dmaPusherPutAddress[3] = tmpPxls0;
                           tmpPxls2 = pSrcBits[5];
                           tmpPxls0 = pSrcBits[6];
                           dmaPusherPutAddress[4] = tmpPxls1;
                           dmaPusherPutAddress[5] = tmpPxls2;
                           tmpPxls1 = pSrcBits[7];
                           tmpPxls2 = pSrcBits[8];
                           dmaPusherPutAddress[6] = tmpPxls0;
                           dmaPusherPutAddress[7] = tmpPxls1;
                           tmpPxls0 = pSrcBits[9];
                           tmpPxls1 = pSrcBits[10];
                           dmaPusherPutAddress[8] = tmpPxls2;
                           dmaPusherPutAddress[9] = tmpPxls0;
                           tmpPxls2 = pSrcBits[11];
                           tmpPxls0 = pSrcBits[12];
                           dmaPusherPutAddress[10] = tmpPxls1;
                           dmaPusherPutAddress[11] = tmpPxls2;
                           tmpPxls1 = pSrcBits[13];
                           tmpPxls2 = pSrcBits[14];
                           dmaPusherPutAddress[12] = tmpPxls0;
                           dmaPusherPutAddress[13] = tmpPxls1;
                           tmpPxls0 = pSrcBits[15];
                           dmaPusherPutAddress[14] = tmpPxls2;
                           pSrcBits += 16;
                           dmaPusherPutAddress[15] = tmpPxls0;

                           dmaPusherPutAddress += 16;
                       }

                       while (pxlCount >= 32) {

                           pxlCount -= 32;

                           while (freeCount < (1 + (32 >> 2)))
                               NvGetDmaBufferFreeCount(npDev, freeCount, (1 + (32 >> 2)), dmaPusherPutAddress);
                           freeCount -= (1 + (32 >> 2));

                           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                               STRETCHED_IMAGE_COLOR_OFFSET | (32 << 16);

                           dmaPusherPutAddress += 1;

                           tmpPxls0 = pSrcBits[0];
                           tmpPxls1 = pSrcBits[1];
                           dmaPusherPutAddress[0] = tmpPxls0;
                           tmpPxls2 = pSrcBits[2];
                           dmaPusherPutAddress[1] = tmpPxls1;
                           tmpPxls0 = pSrcBits[3];
                           tmpPxls1 = pSrcBits[4];
                           dmaPusherPutAddress[2] = tmpPxls2;
                           dmaPusherPutAddress[3] = tmpPxls0;
                           tmpPxls2 = pSrcBits[5];
                           tmpPxls0 = pSrcBits[6];
                           dmaPusherPutAddress[4] = tmpPxls1;
                           dmaPusherPutAddress[5] = tmpPxls2;
                           tmpPxls1 = pSrcBits[7];
                           pSrcBits += 8;
                           dmaPusherPutAddress[6] = tmpPxls0;
                           dmaPusherPutAddress[7] = tmpPxls1;

                           dmaPusherPutAddress += 8;
                       }

                       if (pxlCount >= 4) {
                           while (freeCount < (1 + (pxlCount >> 2)))
                               NvGetDmaBufferFreeCount(npDev, freeCount, (1 + (pxlCount >> 2)), dmaPusherPutAddress);
                           freeCount -= (1 + (pxlCount >> 2));

                           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                               STRETCHED_IMAGE_COLOR_OFFSET | (pxlCount << 16);

                           dmaPusherPutAddress++;
                       }

                       while (pxlCount >= 4) {
                           pxlCount -= 4;
                           tmpPxls0 = pSrcBits[0];
                           pSrcBits += 1;
                           dmaPusherPutAddress[0] = tmpPxls0;

                           dmaPusherPutAddress += 1;
                       }
                   }

                   /* Force write combine buffer to flush */
                   pDriverData->NvDmaPusherBufferEnd[0] = 0;
                   /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                   _outp (0x3d0,0);

                   pDriverData->dwDmaPusherFreeCount = freeCount;

                   npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                   if (srcInVideoMemory) {
                       if (--m > 0) {
                           pSrcCurScan += dwSrcPitch;

                           pSrcBits = (unsigned long *)pSrcCurScan;

                           goto doNxtSrcScan;
                       } else {
                           if (dwSrcPitch <= 800) {
                               m = 16;
                               curDstY += deltaY;
                           } else {
                               m = 8;
                               curDstY += (deltaY >> 1);
                           }
                                               /* convert 16.16 to 12.4 */
                           wDstPoint.xy16.y = (short)(curDstY >> 12);

                           // wait for DMA operation to finish
                           while ((volatile)pDmaBufferNotifier->status == NV_IN_PROGRESS);
                       }
                   }    // stretch
                   if (isOverlappingVmem && lpSurfTemp) {
                       // FIXME: wait for blt to complete
                       NVHEAP_FREE(lpSurfTemp);
                   }
               }

               if (srcInVideoMemory) {

                   while (freeCount < 2)
                       NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                   freeCount -= 2;

                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) | 0x40000;
                   dmaPusherPutAddress[1] = NV_DD_IMAGE_FROM_CPU;

                   dmaPusherPutAddress += 2;
               }
            }

            if (dwFlags & DDBLT_KEYSRCOVERRIDE) {
                // disable chroma key
                while (freeCount < 2)
                    NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                freeCount -= 2;

                dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_TRANSCOLOR) +
                    SET_TRANSCOLOR_OFFSET | 0x40000;
                dmaPusherPutAddress[1] = 0;

                dmaPusherPutAddress += 2;
            }

        } else {
            DPF("BLT     blt not handled by driver");
            return DDHAL_DRIVER_NOTHANDLED;
        }

        // restore pixel depth for z blts
        if (isZBlt) {
            while (freeCount < 2)
                NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
            freeCount -= 2;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;

            dmaPusherPutAddress += 2;
        }

    } else if (dwFlags & DDBLT_COLORFILL) {
        dwFillColor = pbd->bltFX.dwFillColor & pDriverData->physicalColorMask;

        while (freeCount < 10)
            NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
        freeCount -= 10;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
            SET_ROP_OFFSET | 0x40000;
        dmaPusherPutAddress[1] = SRCCOPYINDEX;

        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
            SURFACES_2D_DEST_OFFSET | 0x40000;
        dmaPusherPutAddress[3] = dwDstOffset;
        dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
            SURFACES_2D_PITCH_OFFSET | 0x40000;
        dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

        dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
            RECT_AND_TEXT_COLOR1A_OFFSET | 0xC0000;
        dmaPusherPutAddress[7] = dwFillColor;
        dmaPusherPutAddress[8] = asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);
        dmaPusherPutAddress[9] = asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

        dmaPusherPutAddress += 10;

    } else if (dwFlags & DDBLT_ZBUFFER) {
        /* Hardware Z buffer fills not currently supported when in 8bpp mode */
        DPF("HARDWARE Z BUFFER BLT FAILED");
        return DDHAL_DRIVER_NOTHANDLED;
    } else {
        DPF("BLT     blt not handled by driver");
        /* We don't handle any other type of BLT operation */
        return DDHAL_DRIVER_NOTHANDLED;
    }

    pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

    /* Force write combine buffer to flush */
    pDriverData->NvDmaPusherBufferEnd[0] = 0;
    /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
    _outp (0x3d0,0);

    pDriverData->dwDmaPusherFreeCount = freeCount;

    npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

    pbd->ddRVal = DD_OK;

    return DDHAL_DRIVER_HANDLED;

} /* Blt8bpp32 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\d3ddebug.c ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: D3DDBG.C                                                          *
*   Debug build stuff for D3D.                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       11/18/97 - re-wrote and cleaned up.     *
*                                                                           *
\***************************************************************************/
#include <math.h>
#include <windows.h>
#include "nvd3ddrv.h"

#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nv3ddbg.h"

/*
 * Define global data valid only when DEBUG is defined.
 */
#ifdef  DEBUG
BOOL    dbgShowState    = 0;
BOOL    dbgFlush        = 0x00000000;   // Flush Nothing
DWORD   dbgLevel        = 0x00000000;   // No Debug output.
#endif  // DEBUG

/*
 * Define global data valid only when DBGFRONTRENDER is defined.
 */
#ifdef  DBGFRONTRENDER
BOOL    dbgFrontRender      = 0;
DWORD   dbgFrontRenderPitch = 1024 * 2;
#endif  // DBGFRONTRENDER

/*
 * Define global data valid only when DBGPREVIEWTEX is defined.
 */
#ifdef  DBGPREVIEWTEX
BOOL    dbgPreviewTextureUseBase = 0;
BOOL    dbgPreviewTexture        = 0;
BOOL    dbgPreviewLinearTexture  = 0;
BOOL    dbgMaskAlpha0            = 0;
DWORD   dbgPreviewTexturePitch   = 1024 * 2;
DWORD   dbgSurfaceDepth          = 16;
BOOL    dbgPreviewTextureClearFirst = TRUE;
DWORD   dbgPreviewTextureMagX = 1;
DWORD   dbgPreviewTextureMagY = 1;
#endif  // DBGPREVIEWTEX

/*
 * Define global data valid only when DMAVALIDATE is defined.
 */
#ifdef  DMAVALIDATE
BOOL    dbgValidatePushBuffer       = 0;
DWORD   dbgLastValidatedPushBuffer  = 0;
#endif  // DMAVALIDATE

#ifdef  DEBUG
/*
 *
 */
char szD3DBoolean[][32] =
{
    "FALSE",
    "TRUE",
};
char szD3DShadeMode[][32] =
{
    "NULL",
    "D3DSHADE_FLAT",
    "D3DSHADE_GOURAUD",
    "D3DSHADE_PHONG"
};
char szD3DFillMode[][32] =
{
    "NULL",
    "D3DFILL_POINT",
    "D3DFILL_WIREFRAME",
    "D3DFILL_SOLID"
};
char szD3DTextureFilter[][32] =
{
    "NULL",
    "D3DFILTER_NEAREST",
    "D3DFILTER_LINEAR",
    "D3DFILTER_MIPNEAREST",
    "D3DFILTER_MIPLINEAR",
    "D3DFILTER_LINEARMIPNEAREST",
    "D3DFILTER_LINEARMIPLINEAR"
};
char szD3DBlend[][32] =
{
    "NULL",
    "D3DBLEND_ZERO",
    "D3DBLEND_ONE",
    "D3DBLEND_SRCCOLOR",
    "D3DBLEND_INVSRCCOLOR",
    "D3DBLEND_SRCALPHA",
    "D3DBLEND_INVSRCALPHA",
    "D3DBLEND_DESTALPHA",
    "D3DBLEND_INVDESTALPHA",
    "D3DBLEND_DESTCOLOR",
    "D3DBLEND_INVDESTCOLOR",
    "D3DBLEND_SRCALPHASAT",
    "D3DBLEND_BOTHSRCALPHA",
    "D3DBLEND_BOTHINVSRCALPHA"
};
char szD3DTextureBlend[][32] =
{
    "NULL",
    "D3DTBLEND_DECAL",
    "D3DTBLEND_MODULATE",
    "D3DTBLEND_DECALALPHA",
    "D3DTBLEND_MODULATEALPHA",
    "D3DTBLEND_DECALMASK",
    "D3DTBLEND_MODULATEMASK",
    "D3DTBLEND_COPY",
    "D3DTBLEND_ADD"
};
char szD3DTextureAddress[][32] =
{
    "NULL",
    "D3DTADDRESS_WRAP",
    "D3DTADDRESS_MIRROR",
    "D3DTADDRESS_CLAMP",
    "D3DTADDRESS_BORDER"
};
char szD3DCull[][32] =
{
    "NULL",
    "D3DCULL_NONE",
    "D3DCULL_CW",
    "D3DCULL_CCW"
};
char szD3DCmpFunc[][32] =
{
    "NULL",
    "D3DCMP_NEVER",
    "D3DCMP_LESS",
    "D3DCMP_EQUAL",
    "D3DCMP_LESSEQUAL",
    "D3DCMP_GREATER",
    "D3DCMP_NOTEQUAL",
    "D3DCMP_GREATEREQUAL",
    "D3DCMP_ALWAYS"
};
char szD3DStencilOp[][32] =
{
    "NULL",
    "D3DSTENCILOP_KEEP",
    "D3DSTENCILOP_ZERO",
    "D3DSTENCILOP_REPLACE",
    "D3DSTENCILOP_INCRSAT",
    "D3DSTENCILOP_DECRSAT",
    "D3DSTENCILOP_INVERT",
    "D3DSTENCILOP_INCR",
    "D3DSTENCILOP_DECR"
};
char szD3DFogMode[][32] =
{
    "NULL",
    "D3DFOG_NONE",
    "D3DFOG_EXP",
    "D3DFOG_EXP2",
    "D3DFOG_LINEAR"
};
char szD3DZBufferType[][32] =
{
    "NULL",
    "D3DZB_FALSE",
    "D3DZB_TRUE",
    "D3DZB_USEW"
};
char szD3DAntiAliasMode[][32] =
{
    "NULL",
    "D3DANTIALIAS_NONE",
    "D3DANTIALIAS_SORTDEPENDENT",
    "D3DANTIALIAS_SORTINDEPENDENT"
};
char szD3DTextureOp[][36] =
{
    "NULL",
    "D3DTOP_DISABLE",
    "D3DTOP_SELECTARG1",
    "D3DTOP_SELECTARG2",
    "D3DTOP_MODULATE",
    "D3DTOP_MODULATE2X",
    "D3DTOP_MODULATE4X",
    "D3DTOP_ADD",
    "D3DTOP_ADDSIGNED",
    "D3DTOP_ADDSIGNED2X",
    "D3DTOP_SUBTRACT",
    "D3DTOP_ADDSMOOTH",
    "D3DTOP_BLENDDIFFUSEALPHA",
    "D3DTOP_BLENDTEXTUREALPHA",
    "D3DTOP_BLENDFACTORALPHA",
    "D3DTOP_BLENDTEXTUREALPHAPM",
    "D3DTOP_BLENDCURRENTALPHA",
    "D3DTOP_PREMODULATE",
    "D3DTOP_MODULATEALPHA_ADDCOLOR",
    "D3DTOP_MODULATECOLOR_ADDALPHA",
    "D3DTOP_MODULATEINVALPHA_ADDCOLOR",
    "D3DTOP_MODULATEINVCOLOR_ADDALPHA",
    "D3DTOP_BUMPENVMAP",
    "D3DTOP_BUMPENVMAPLUMINANCE",
    "D3DTOP_DOTPRODUCT3"
};
char szD3DArg[][64] =
{
    "D3DTA_DIFFUSE",
    "D3DTA_CURRENT",
    "D3DTA_TEXTURE",
    "D3DTA_TFACTOR",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "D3DTA_DIFFUSE | D3DTA_COMPLEMENT",
    "D3DTA_CURRENT | D3DTA_COMPLEMENT",
    "D3DTA_TEXTURE | D3DTA_COMPLEMENT",
    "D3DTA_TFACTOR | D3DTA_COMPLEMENT",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "D3DTA_DIFFUSE | D3DTA_ALPHAREPLICATE",
    "D3DTA_CURRENT | D3DTA_ALPHAREPLICATE",
    "D3DTA_TEXTURE | D3DTA_ALPHAREPLICATE",
    "D3DTA_TFACTOR | D3DTA_ALPHAREPLICATE",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "D3DTA_DIFFUSE | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE",
    "D3DTA_CURRENT | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE",
    "D3DTA_TEXTURE | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE",
    "D3DTA_TFACTOR | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID"
};
char szD3DArgModifier[][32] =
{
    "D3DTA_NORMAL",
    "D3DTA_COMPLEMENT",
    "D3DTA_ALPHAREPLICATE"
};
char szD3DTextureMagFilter[][32] =
{
    "NULL",
    "D3DTFG_POINT",
    "D3DTFG_LINEAR",
    "D3DTFG_FLATCUBIC",
    "D3DTFG_GAUSSIANCUBIC",
    "D3DTFG_ANISOTROPIC"
};
char szD3DTextureMinFilter[][32] =
{
    "NULL",
    "D3DTFN_POINT",
    "D3DTFN_LINEAR",
    "D3DTFN_ANISOTROPIC"
};
char szD3DTextureMipFilter[][32] =
{
    "NULL",
    "D3DTFP_POINT",
    "D3DTFP_LINEAR"
};
#endif  // DEBUG


#ifdef  DEBUG
#define START_STR       "NVD3D: "
#define END_STR         "\r\n"
#ifndef WINNT
void __cdecl DPF_LEVEL(DWORD dwLevel, LPSTR szFormat, ...)
{
    char str[256];

    if (dbgLevel & dwLevel)
    {
        lstrcpy(str, START_STR);
        wvsprintf(str+lstrlen(str), szFormat, (LPVOID)(&szFormat+1));
        lstrcat(str, END_STR);
        OutputDebugString(str);
    }
}
#else
void __cdecl DPF_LEVEL(DWORD dwLevel, LPSTR szFormat, ...)
{
    va_list ap;

    if (dbgLevel & dwLevel)
    {
        va_start(ap, szFormat);
        EngDebugPrint(START_STR, szFormat, ap);
        EngDebugPrint("", "\n", ap);
        va_end(ap);
    }
}
#endif // #ifdef WINNT

#endif  // DEBUG


/*
 * Debug routines that are valid only when DEBUG is defined.
 */
#ifdef  DEBUG
void dbgD3DError
(
    void
)
{
    DPF("NV D3D ERROR!!!");
    return;
}

void dbgDisplayContextState
(
    DWORD           dwFlags,
    PNVD3DCONTEXT   pContext
)
{
    if (!dbgShowState)
        return;

    if ((dbgShowState & NVDBG_SHOW_RENDER_STATE)
     && (dwFlags & NVDBG_SHOW_RENDER_STATE))
    {
        DPF("D3D:Context Render State:");
        DPF("    TextureHandle      = %08lx", pContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE]);
        DPF("    AntiAlias          = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_ANTIALIAS]]);
        DPF("    TextureAddress     = %s",    szD3DTextureAddress[pContext->dwRenderState[D3DRENDERSTATE_TEXTUREADDRESS]]);
        DPF("    TexturePerspective = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE]]);
        DPF("    WrapU              = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_WRAPU]]);
        DPF("    WrapV              = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_WRAPV]]);
        DPF("    ZEnable            = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_ZENABLE]]);
        DPF("    FillMode           = %s",    szD3DFillMode[pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]]);
        DPF("    ShadeMode          = %s",    szD3DShadeMode[pContext->dwRenderState[D3DRENDERSTATE_SHADEMODE]]);
        DPF("    LinePattern        = %08lx", pContext->dwRenderState[D3DRENDERSTATE_LINEPATTERN]);
        DPF("    MonoEnable         = %08lx", pContext->dwRenderState[D3DRENDERSTATE_MONOENABLE]);
        DPF("    Rop2               = %08lx", pContext->dwRenderState[D3DRENDERSTATE_ROP2]);
        DPF("    PlaneMask          = %08lx", pContext->dwRenderState[D3DRENDERSTATE_PLANEMASK]);
        DPF("    ZWriteEnable       = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE]]);
        DPF("    AlphaTestEnable    = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_ALPHATESTENABLE]]);
        DPF("    LastPixelEnable    = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_LASTPIXEL]]);
        DPF("    TextureMag         = %s",    szD3DTextureFilter[pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMAG]]);
        DPF("    TextureMin         = %s",    szD3DTextureFilter[pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMIN]]);
        DPF("    SrcBlend           = %s",    szD3DBlend[pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND]]);
        DPF("    DstBlend           = %s",    szD3DBlend[pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND]]);
        DPF("    TextureMapBlend    = %s",    szD3DTextureBlend[pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMAPBLEND]]);
        DPF("    CullMode           = %s",    szD3DCull[pContext->dwRenderState[D3DRENDERSTATE_CULLMODE]]);
        DPF("    ZFunc              = %s",    szD3DCmpFunc[pContext->dwRenderState[D3DRENDERSTATE_ZFUNC]]);
        DPF("    AlphaRef           = %08lx", pContext->dwRenderState[D3DRENDERSTATE_ALPHAREF]);
        DPF("    AlphaFunc          = %s",    szD3DCmpFunc[pContext->dwRenderState[D3DRENDERSTATE_ALPHAFUNC]]);
        DPF("    DitherEnable       = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_DITHERENABLE]]);
        DPF("    AlphaBlendEnable   = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE]]);
        DPF("    FogEnable          = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_FOGENABLE]]);
        DPF("    SpecularEnable     = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE]]);
        DPF("    ZVisible           = %08lx", pContext->dwRenderState[D3DRENDERSTATE_ZVISIBLE]);
        DPF("    SubPixel           = %08lx", pContext->dwRenderState[D3DRENDERSTATE_SUBPIXEL]);
        DPF("    SubPixelX          = %08lx", pContext->dwRenderState[D3DRENDERSTATE_SUBPIXELX]);
        DPF("    StippledAlpha      = %08lx", pContext->dwRenderState[D3DRENDERSTATE_STIPPLEDALPHA]);
        DPF("    FogColor           = %08lx", pContext->dwRenderState[D3DRENDERSTATE_FOGCOLOR]);
        DPF("    FogTableMode       = %s",    szD3DFogMode[pContext->dwRenderState[D3DRENDERSTATE_FOGTABLEMODE]]);
        DPF("    FogTableStart      = %08lx", pContext->dwRenderState[D3DRENDERSTATE_FOGTABLESTART]);
        DPF("    FogTableEnd        = %08lx", pContext->dwRenderState[D3DRENDERSTATE_FOGTABLEEND]);
        DPF("    FogTableDensity    = %08lx", pContext->dwRenderState[D3DRENDERSTATE_FOGTABLEDENSITY]);
        DPF("    StippledEnable     = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_STIPPLEENABLE]]);
        DPF("    EdgeAntiAlias      = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_EDGEANTIALIAS]]);
        DPF("    ColorKeyEnable     = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_COLORKEYENABLE]]);
        DPF("    BorderColor        = %08lx", pContext->dwRenderState[D3DRENDERSTATE_BORDERCOLOR]);
        DPF("    TextureAddressU    = %s",    szD3DTextureAddress[pContext->dwRenderState[D3DRENDERSTATE_TEXTUREADDRESSU]]);
        DPF("    TextureAddressV    = %s",    szD3DTextureAddress[pContext->dwRenderState[D3DRENDERSTATE_TEXTUREADDRESSV]]);
        DPF("    MipMapLODBias      = %08lx", pContext->dwRenderState[D3DRENDERSTATE_MIPMAPLODBIAS]);
        DPF("    ZBias              = %08lx", pContext->dwRenderState[D3DRENDERSTATE_ZBIAS]);
        DPF("    RangeFogEnable     = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_RANGEFOGENABLE]]);
        DPF("    Anisotropy         = %08lx", pContext->dwRenderState[D3DRENDERSTATE_ANISOTROPY]);
        DPF("    FlushBatch         = %08lx", pContext->dwRenderState[D3DRENDERSTATE_FLUSHBATCH]);
#ifdef  NVD3D_DX6
        DPF("    TranslucentSortInd = %08lx", pContext->dwRenderState[D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT]);
        DPF("    StencilEnable      = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE]]);
        DPF("    StencilFail        = %s",    szD3DStencilOp[pContext->dwRenderState[D3DRENDERSTATE_STENCILFAIL]]);
        DPF("    StencilZFail       = %s",    szD3DStencilOp[pContext->dwRenderState[D3DRENDERSTATE_STENCILZFAIL]]);
        DPF("    StencilPass        = %s",    szD3DStencilOp[pContext->dwRenderState[D3DRENDERSTATE_STENCILPASS]]);
        DPF("    StencilFunc        = %s",    szD3DCmpFunc[pContext->dwRenderState[D3DRENDERSTATE_STENCILFUNC]]);
        DPF("    StencilRef         = %08lx", pContext->dwRenderState[D3DRENDERSTATE_STENCILREF]);
        DPF("    StencilMask        = %08lx", pContext->dwRenderState[D3DRENDERSTATE_STENCILMASK]);
        DPF("    StencilWriteMask   = %08lx", pContext->dwRenderState[D3DRENDERSTATE_STENCILWRITEMASK]);
        DPF("    TextureFactor      = %08lx", pContext->dwRenderState[D3DRENDERSTATE_TEXTUREFACTOR]);
        DPF("    Wrap0              = %08lx", pContext->dwRenderState[D3DRENDERSTATE_WRAP0]);
        DPF("    Wrap1              = %08lx", pContext->dwRenderState[D3DRENDERSTATE_WRAP1]);
        DPF("    Wrap2              = %08lx", pContext->dwRenderState[D3DRENDERSTATE_WRAP2]);
        DPF("    Wrap3              = %08lx", pContext->dwRenderState[D3DRENDERSTATE_WRAP3]);
        DPF("    Wrap4              = %08lx", pContext->dwRenderState[D3DRENDERSTATE_WRAP4]);
        DPF("    Wrap5              = %08lx", pContext->dwRenderState[D3DRENDERSTATE_WRAP5]);
        DPF("    Wrap6              = %08lx", pContext->dwRenderState[D3DRENDERSTATE_WRAP6]);
        DPF("    Wrap7              = %08lx", pContext->dwRenderState[D3DRENDERSTATE_WRAP7]);
#endif  // NVD3D_DX6
        DPF("\r\n");
    }
#ifdef  NVD3D_DX6
    if ((dbgShowState & NVDBG_SHOW_MTS_STATE)
     && (dwFlags & NVDBG_SHOW_MTS_STATE))
    {
        DWORD   dwNumStages;
        DWORD   dwStage;

        dwNumStages = (dbgShowState & NVDBG_SHOW_MTS_STATE) >> NVDBG_SHOW_MTS_STATE_SHIFT;
        dwNumStages = (dwNumStages <= NVDBG_SHOW_MTS_STATE_MAX) ? dwNumStages : NVDBG_SHOW_MTS_STATE_MAX;
        for (dwStage = 0; dwStage < dwNumStages; dwStage++)
        {
            DPF("D3D:Texture Stage %d State:", dwStage);
            DPF("    TextureMap     = %08lx", pContext->tssState[dwStage].dwTextureMap);
            DPF("    AddressU       = %s",    szD3DTextureAddress[pContext->tssState[dwStage].dwAddressU]);
            DPF("    AddressV       = %s",    szD3DTextureAddress[pContext->tssState[dwStage].dwAddressV]);
            DPF("    MagFilter      = %s",    szD3DTextureMagFilter[pContext->tssState[dwStage].dwMagFilter]);
            DPF("    MinFilter      = %s",    szD3DTextureMinFilter[pContext->tssState[dwStage].dwMinFilter]);
            DPF("    MipFilter      = %s",    szD3DTextureMipFilter[pContext->tssState[dwStage].dwMipFilter]);
            DPF("    ColorOp        = %s",    szD3DTextureOp[pContext->tssState[dwStage].dwColorOp]);
            DPF("    ColorArg1      = %s",    szD3DArg[pContext->tssState[dwStage].dwColorArg1]);
            DPF("    ColorArg2      = %s",    szD3DArg[pContext->tssState[dwStage].dwColorArg2]);
            DPF("    AlphaOp        = %s",    szD3DTextureOp[pContext->tssState[dwStage].dwAlphaOp]);
            DPF("    AlphaArg1      = %s",    szD3DArg[pContext->tssState[dwStage].dwAlphaArg1]);
            DPF("    AlphaArg2      = %s",    szD3DArg[pContext->tssState[dwStage].dwAlphaArg2]);
            DPF("    BumpEnvMat00   = %08lx", pContext->tssState[dwStage].dwBumpEnvMat00);
            DPF("    BumpEnvMat01   = %08lx", pContext->tssState[dwStage].dwBumpEnvMat01);
            DPF("    BumpEnvMat10   = %08lx", pContext->tssState[dwStage].dwBumpEnvMat10);
            DPF("    BumpEnvMat11   = %08lx", pContext->tssState[dwStage].dwBumpEnvMat11);
            DPF("    TexCoordIndex  = %08lx", pContext->tssState[dwStage].dwTexCoordIndex);
            DPF("    BorderColor    = %08lx", pContext->tssState[dwStage].dwBorderColor);
            DPF("    MipMapLODBias  = %08lx", pContext->tssState[dwStage].dwMipMapLODBias);
            DPF("    MaxMipMapLevel = %08lx", pContext->tssState[dwStage].dwMaxMipLevel);
            DPF("    MaxAnisotropy  = %08lx", pContext->tssState[dwStage].dwMaxAnisotropy);
            DPF("    BumpEnvlScale  = %08lx", pContext->tssState[dwStage].dwBumpEnvlScale);
            DPF("    BumpEnvlOffset = %08lx", pContext->tssState[dwStage].dwBumpEnvlOffset);
            DPF("\r\n");
        }
    }
#endif  // NVD3D_DX6
    if ((dbgShowState & NVDBG_SHOW_DX5_CLASS_STATE)
     && (dwFlags & NVDBG_SHOW_DX5_CLASS_STATE))
    {
        DPF("D3D:NV4 DX5 Class Context State:");
        DPF("    ColorKey           = %08lx", pContext->ctxInnerLoop.dwColorKey);
        DPF("    TextureOffset      = %08lx", pContext->ctxInnerLoop.dwTextureOffset);
        DPF("    Format             = %08lx", pContext->ctxInnerLoop.dwFormat);
        DPF("    Filter             = %08lx", pContext->ctxInnerLoop.dwFilter);
        DPF("    Blend              = %08lx", pContext->ctxInnerLoop.dwBlend);
        DPF("    Control            = %08lx", pContext->ctxInnerLoop.dwControl);
        DPF("    FogColor           = %08lx", pContext->ctxInnerLoop.dwFogColor);
        DPF("\r\n");
    }
#ifdef  NVD3D_DX6
    if ((dbgShowState & NVDBG_SHOW_DX6_CLASS_STATE)
     && (dwFlags & NVDBG_SHOW_DX6_CLASS_STATE))
    {
        DPF("D3D:NV4 DX6 Class Context State:");
        DPF("    TextureOffset[0]   = %08lx", pContext->mtsState.dwTextureOffset[0]);
        DPF("    TextureOffset[1]   = %08lx", pContext->mtsState.dwTextureOffset[1]);
        DPF("    TextureFormat[0]   = %08lx", pContext->mtsState.dwTextureFormat[0]);
        DPF("    TextureFormat[1]   = %08lx", pContext->mtsState.dwTextureFormat[1]);
        DPF("    TextureFilter[0]   = %08lx", pContext->mtsState.dwTextureFilter[0]);
        DPF("    TextureFilter[1]   = %08lx", pContext->mtsState.dwTextureFilter[1]);
        DPF("    Combine0Alpha      = %08lx", pContext->mtsState.dwCombine0Alpha);
        DPF("    Combine0Color      = %08lx", pContext->mtsState.dwCombine0Color);
        DPF("    Combine1Alpha      = %08lx", pContext->mtsState.dwCombine1Alpha);
        DPF("    Combine1Color      = %08lx", pContext->mtsState.dwCombine1Color);
        DPF("    CombineFactor      = %08lx", pContext->mtsState.dwCombineFactor);
        DPF("    Blend              = %08lx", pContext->mtsState.dwBlend);
        DPF("    Control0           = %08lx", pContext->mtsState.dwControl0);
        DPF("    Control1           = %08lx", pContext->mtsState.dwControl1);
        DPF("    Control2           = %08lx", pContext->mtsState.dwControl2);
        DPF("    FogColor           = %08lx", pContext->mtsState.dwFogColor);
        DPF("\r\n");
    }
#endif  // NVD3D_DX6
    if ((dbgShowState & NVDBG_SHOW_SURFACE_STATE)
     && (dwFlags & NVDBG_SHOW_SURFACE_STATE))
    {
        DPF("D3D:NV4 Surface State:");
        DPF("    ClipStart (x, y)   = %04ld, %04ld", pContext->surfaceViewport.clipHorizontal.wX, pContext->surfaceViewport.clipVertical.wY);
        DPF("    ClipSize (w, h)    = %04ld, %04ld", pContext->surfaceViewport.clipHorizontal.wWidth, pContext->surfaceViewport.clipVertical.wHeight);
        DPF("    SurfaceAddr        = %08lx", pContext->dwSurfaceAddr);
        DPF("    SurfaceOffset      = %08lx", pContext->dwSurfaceOffset);
        DPF("    SurfaceOffset      = %04lx", pContext->surfacePitch.wColorPitch);
        DPF("    SurfaceFormat      = %08lx", pContext->dwSurfaceFormat);
        DPF("    Z-BufferAddr       = %08lx", pContext->ZBufferAddr);
        DPF("    Z-BufferOffset     = %08lx", pContext->ZBufferOffset);
        DPF("    Z-BufferPitch      = %04lx", pContext->surfacePitch.wZetaPitch);
        DPF("\r\n");
    }
    return;
}

void dbgDisplayDrawPrimitives2Info
(
    BYTE bCommand,
    WORD wCommandCount
)
{
    if(!(dbgShowState & NVDBG_SHOW_DRAWPRIM2_INFO))
    {
        return;
    }

    switch(bCommand)
    {

    case D3DDP2OP_POINTS:
        DPF("D3D:D3DDP2OP_POINTS : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_INDEXEDLINELIST:
        DPF("D3DDP2OP_INDEXEDLINELIST : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_INDEXEDTRIANGLELIST:
        DPF("D3DDP2OP_INDEXEDTRIANGLELIST : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_RENDERSTATE:
        DPF("D3DDP2OP_RENDERSTATE : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_LINELIST:
        DPF("D3DDP2OP_LINELIST : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_LINESTRIP:
        DPF("D3DDP2OP_LINESTRIP : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_INDEXEDLINESTRIP:
        DPF("D3DDP2OP_INDEXEDLINESTRIP : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_TRIANGLELIST:
        DPF("D3DDP2OP_TRIANGLELIST : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_TRIANGLESTRIP:
        DPF("D3DDP2OP_TRIANGLESTRIP : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_INDEXEDTRIANGLESTRIP:
        DPF("D3DDP2OP_INDEXEDTRIANGLESTRIP : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_TRIANGLEFAN:
        DPF("D3DDP2OP_TRIANGLEFAN : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_INDEXEDTRIANGLEFAN:
        DPF("D3DDP2OP_INDEXEDTRIANGLEFAN : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_TRIANGLEFAN_IMM:
        DPF("D3DDP2OP_TRIANGLEFAN_IMM : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_LINELIST_IMM:
        DPF("D3DDP2OP_LINELIST_IMM : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_TEXTURESTAGESTATE:
        DPF("D3DDP2OP_TEXTURESTAGESTATE : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_INDEXEDTRIANGLELIST2:
        DPF("D3DDP2OP_INDEXEDTRIANGLELIST2 : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_INDEXEDLINELIST2:
        DPF("D3DDP2OP_INDEXEDLINELIST2 : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_VIEWPORTINFO:
        DPF("D3DDP2OP_VIEWPORTINFO : %08lx", (DWORD)wCommandCount);
        break;
    default:
        DPF("D3DDP2OP_UNKNOWN : Command = %08lx", (DWORD)bCommand);
        break;
    }

/*
    switch(bCommand)
    {
        BOOL didIPrintAnything = 0;

    case D3DDP2OP_POINTS:
    case D3DDP2OP_INDEXEDLINELIST:
    case D3DDP2OP_INDEXEDTRIANGLELIST:
    case D3DDP2OP_LINELIST:
    case D3DDP2OP_LINESTRIP:
    case D3DDP2OP_INDEXEDLINESTRIP:
    case D3DDP2OP_TRIANGLELIST:
    case D3DDP2OP_TRIANGLESTRIP:
    case D3DDP2OP_INDEXEDTRIANGLESTRIP:
    case D3DDP2OP_TRIANGLEFAN:
    case D3DDP2OP_INDEXEDTRIANGLEFAN:
    case D3DDP2OP_TRIANGLEFAN_IMM:
    case D3DDP2OP_LINELIST_IMM:
    case D3DDP2OP_INDEXEDTRIANGLELIST2:
    case D3DDP2OP_INDEXEDLINELIST2:

        // profiling -paul
        if(pCurrentContext->dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE] == 1 &&
           pCurrentContext->dwRenderState[D3DRENDERSTATE_FOGENABLE] == 1)
        {
            DPF("*** ALPHA FOG ***");
            didIPrintAnything = 1;
        }
        if(pCurrentContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE] == 1)
        {
            DPF("*** SPECULAR ***");
            didIPrintAnything = 1;
        }
        if(pCurrentContext->tssState[0].dwMipFilter == D3DTFP_LINEAR)
        {
            DPF("*** TRILINEAR MIPMAPPING ***");
            didIPrintAnything = 1;
        }
        if(pCurrentContext->tssState[1].dwColorOp != D3DTOP_DISABLE ||
           pCurrentContext->tssState[1].dwAlphaOp != D3DTOP_DISABLE)
        {

        }
        if(didIPrintAnything)
        {
            DPF(" "); DPF(" ");
        }

        break;
    default:
        break;
    }
*/
}

void dbgDisplayVertexData
(
    DWORD   sx,
    DWORD   sy,
    DWORD   sz,
    DWORD   rhw,
    DWORD   color,
    DWORD   specular,
    DWORD   tu,
    DWORD   tv
)
{
    if (dbgShowState & NVDBG_SHOW_VERTICES)
    {
        float f;
        int i, frac;
        DPF("D3D:NV4 Vertex Data:");
        f = *(float *)&sx;    i = (int)f;      frac = (int)(100.0*(f-i));
        DPF("    X        = %08lx ~= %d.%02d", sx, i, frac);
        f = *(float *)&sy;    i = (int)f;      frac = (int)(100.0*(f-i));
        DPF("    Y        = %08lx ~= %d.%02d", sy, i, frac);
        f = *(float *)&sz;    i = (int)f;      frac = (int)(100.0*(f-i));
        DPF("    Z        = %08lx ~= %d.%02d", sz, i, frac);
        f = *(float *)&rhw;   i = (int)f;      frac = (int)(100.0*(f-i));
        DPF("    RHW      = %08lx ~= %d.%02d", rhw, i, frac);
        DPF("    Color    = %08lx", color);
        DPF("    Specular = %08lx", specular);
        f = *(float *)&tu;    i = (int)f;      frac = (int)(100.0*(f-i));
        DPF("    U        = %08lx ~= %d.%02d", tu, i, frac);
        f = *(float *)&tv;    i = (int)f;      frac = (int)(100.0*(f-i));
        DPF("    V        = %08lx ~= %d.%02d", tv, i, frac);
        DPF("\r\n");
    }
    return;
}

/*
 * Routine to test the push buffers ability to function.
 */
BOOL dbgTestPushBuffer
(
    PNVD3DCONTEXT   pContext
)
{
    return (TRUE);
}
BOOL dbgValidateControlRegisters
(
    PNVD3DCONTEXT   pContext
)
{
    DWORD   drfValue;
    /*
     * Validate the Format register.
     */
    drfValue = DRF_VAL(054, _FORMAT, _CONTEXT_DMA, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_CONTEXT_DMA_A)
     && (drfValue != NV054_FORMAT_CONTEXT_DMA_B))
    {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_CONTEXT_DMA field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _COLORKEYENABLE, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_COLORKEYENABLE_FALSE)
     && (drfValue != NV054_FORMAT_COLORKEYENABLE_TRUE))
    {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_COLORKEYENABLE field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _ORIGIN_ZOH, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_ORIGIN_ZOH_CENTER)
     && (drfValue != NV054_FORMAT_ORIGIN_ZOH_CORNER))
    {
        DPF("dbgValidateControlRegisters: NV054_FORMAT__ORIGIN_ZOH field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _ORIGIN_FOH, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_ORIGIN_FOH_CENTER)
     && (drfValue != NV054_FORMAT_ORIGIN_FOH_CORNER))
    {
        DPF("dbgValidateControlRegisters: NV054_FORMAT__ORIGIN_FOH field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _COLOR, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_COLOR_LE_Y8)
     && (drfValue != NV054_FORMAT_COLOR_LE_A1R5G5B5)
     && (drfValue != NV054_FORMAT_COLOR_LE_X1R5G5B5)
     && (drfValue != NV054_FORMAT_COLOR_LE_A4R4G4B4)
     && (drfValue != NV054_FORMAT_COLOR_LE_R5G6B5)
     && (drfValue != NV054_FORMAT_COLOR_LE_A8R8G8B8)
     && (drfValue != NV054_FORMAT_COLOR_LE_X8R8G8B8))
    {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_COLOR field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
//    drfValue = DRF_VAL(054, _FORMAT, _MIPMAP_LEVELS, pContext->ctxInnerLoop.dwFormat);
//    if (drfValue )
//    {
//        DPF("dbgValidateControlRegisters: NV054_FORMAT_MIPMAP_LEVELS field invalid 0x%08lx", drfValue);
//        dbgD3DError();
//    }
    drfValue = DRF_VAL(054, _FORMAT, _BASE_SIZE_U, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_BASE_SIZE_U_1)
     && (drfValue != NV054_FORMAT_BASE_SIZE_U_2)
     && (drfValue != NV054_FORMAT_BASE_SIZE_U_4)
     && (drfValue != NV054_FORMAT_BASE_SIZE_U_8)
     && (drfValue != NV054_FORMAT_BASE_SIZE_U_16)
     && (drfValue != NV054_FORMAT_BASE_SIZE_U_32)
     && (drfValue != NV054_FORMAT_BASE_SIZE_U_64)
     && (drfValue != NV054_FORMAT_BASE_SIZE_U_128)
     && (drfValue != NV054_FORMAT_BASE_SIZE_U_256)
     && (drfValue != NV054_FORMAT_BASE_SIZE_U_512)
     && (drfValue != NV054_FORMAT_BASE_SIZE_U_1024)
     && (drfValue != NV054_FORMAT_BASE_SIZE_U_2048))
    {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_BASE_SIZE_U field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _BASE_SIZE_V, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_BASE_SIZE_V_1)
     && (drfValue != NV054_FORMAT_BASE_SIZE_V_2)
     && (drfValue != NV054_FORMAT_BASE_SIZE_V_4)
     && (drfValue != NV054_FORMAT_BASE_SIZE_V_8)
     && (drfValue != NV054_FORMAT_BASE_SIZE_V_16)
     && (drfValue != NV054_FORMAT_BASE_SIZE_V_32)
     && (drfValue != NV054_FORMAT_BASE_SIZE_V_64)
     && (drfValue != NV054_FORMAT_BASE_SIZE_V_128)
     && (drfValue != NV054_FORMAT_BASE_SIZE_V_256)
     && (drfValue != NV054_FORMAT_BASE_SIZE_V_512)
     && (drfValue != NV054_FORMAT_BASE_SIZE_V_1024)
     && (drfValue != NV054_FORMAT_BASE_SIZE_V_2048))
    {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_BASE_SIZE_V field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _TEXTUREADDRESSU, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_TEXTUREADDRESSU_WRAP)
     && (drfValue != NV054_FORMAT_TEXTUREADDRESSU_MIRROR)
     && (drfValue != NV054_FORMAT_TEXTUREADDRESSU_CLAMP)
     && (drfValue != NV054_FORMAT_TEXTUREADDRESSU_BORDER))
    {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_TEXTUREADDRESSU field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _WRAPU, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_WRAPU_FALSE)
     && (drfValue != NV054_FORMAT_WRAPU_TRUE))
    {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_WRAPU field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _TEXTUREADDRESSV, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_TEXTUREADDRESSV_WRAP)
     && (drfValue != NV054_FORMAT_TEXTUREADDRESSV_MIRROR)
     && (drfValue != NV054_FORMAT_TEXTUREADDRESSV_CLAMP)
     && (drfValue != NV054_FORMAT_TEXTUREADDRESSV_BORDER))
    {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_TEXTUREADDRESSV field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _WRAPV, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_WRAPV_FALSE)
     && (drfValue != NV054_FORMAT_WRAPV_TRUE))
    {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_WRAPV field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }

    /*
     * Validate the Filter register.
     */
    drfValue = DRF_VAL(054, _FILTER, _MIPMAP_DITHER_ENABLE, pContext->ctxInnerLoop.dwFilter);
    if ((drfValue != NV054_FILTER_MIPMAP_DITHER_ENABLE_FALSE)
     && (drfValue != NV054_FILTER_MIPMAP_DITHER_ENABLE_TRUE))
    {
        DPF("dbgValidateControlRegisters: NV054_FILTER_MIPMAP_DITHER_ENABLE field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FILTER, _TEXTUREMIN, pContext->ctxInnerLoop.dwFilter);
    if ((drfValue != NV054_FILTER_TEXTUREMIN_NEAREST)
     && (drfValue != NV054_FILTER_TEXTUREMIN_LINEAR)
     && (drfValue != NV054_FILTER_TEXTUREMIN_MIPNEAREST)
     && (drfValue != NV054_FILTER_TEXTUREMIN_MIPLINEAR)
     && (drfValue != NV054_FILTER_TEXTUREMIN_LINEARMIPNEAREST)
     && (drfValue != NV054_FILTER_TEXTUREMIN_LINEARMIPLINEAR))
    {
        DPF("dbgValidateControlRegisters: NV054_FILTER_TEXTUREMIN field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FILTER, _ANISOTROPIC_MINIFY_ENABLE, pContext->ctxInnerLoop.dwFilter);
    if ((drfValue != NV054_FILTER_ANISOTROPIC_MINIFY_ENABLE_FALSE)
     && (drfValue != NV054_FILTER_ANISOTROPIC_MINIFY_ENABLE_TRUE))
    {
        DPF("dbgValidateControlRegisters: NV054_FILTER_ANISOTROPIC_MINIFY_ENABLE field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FILTER, _TEXTUREMAG, pContext->ctxInnerLoop.dwFilter);
    if ((drfValue != NV054_FILTER_TEXTUREMAG_NEAREST)
     && (drfValue != NV054_FILTER_TEXTUREMAG_LINEAR)
     && (drfValue != NV054_FILTER_TEXTUREMAG_MIPNEAREST)
     && (drfValue != NV054_FILTER_TEXTUREMAG_MIPLINEAR)
     && (drfValue != NV054_FILTER_TEXTUREMAG_LINEARMIPNEAREST)
     && (drfValue != NV054_FILTER_TEXTUREMAG_LINEARMIPLINEAR))
    {
        DPF("dbgValidateControlRegisters: NV054_FILTER_TEXTUREMAG field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FILTER, _ANISOTROPIC_MAGNIFY_ENABLE, pContext->ctxInnerLoop.dwFilter);
    if ((drfValue != NV054_FILTER_ANISOTROPIC_MAGNIFY_ENABLE_FALSE)
     && (drfValue != NV054_FILTER_ANISOTROPIC_MAGNIFY_ENABLE_TRUE))
    {
        DPF("dbgValidateControlRegisters: NV054_FILTER_ANISOTROPIC_MAGNIFY_ENABLE field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }

    /*
     * Validate the Blend register.
     */
    drfValue = DRF_VAL(054, _BLEND, _TEXTUREMAPBLEND, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_TEXTUREMAPBLEND_DECAL)
     && (drfValue != NV054_BLEND_TEXTUREMAPBLEND_MODULATE)
     && (drfValue != NV054_BLEND_TEXTUREMAPBLEND_DECALALPHA)
     && (drfValue != NV054_BLEND_TEXTUREMAPBLEND_MODULATEALPHA)
     && (drfValue != NV054_BLEND_TEXTUREMAPBLEND_DECALMASK)
     && (drfValue != NV054_BLEND_TEXTUREMAPBLEND_MODULATEMASK)
     && (drfValue != NV054_BLEND_TEXTUREMAPBLEND_COPY)
     && (drfValue != NV054_BLEND_TEXTUREMAPBLEND_ADD))
    {
        DPF("dbgValidateControlRegisters: NV054_BLEND_TEXTUREMAPBLEND field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _MASK_BIT, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_MASK_BIT_LSB)
     && (drfValue != NV054_BLEND_MASK_BIT_MSB))
    {
        DPF("dbgValidateControlRegisters: NV054_BLEND_MASK_BIT field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _SHADEMODE, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_SHADEMODE_FLAT)
     && (drfValue != NV054_BLEND_SHADEMODE_GOURAUD)
     && (drfValue != NV054_BLEND_SHADEMODE_PHONG))
    {
        DPF("dbgValidateControlRegisters: NV054_BLEND_SHADEMODE field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _TEXTUREPERSPECTIVE, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_TEXTUREPERSPECTIVE_FALSE)
     && (drfValue != NV054_BLEND_TEXTUREPERSPECTIVE_TRUE))
    {
        DPF("dbgValidateControlRegisters: NV054_BLEND_TEXTUREPERSPECTIVE field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _SPECULARENABLE, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_SPECULARENABLE_FALSE)
     && (drfValue != NV054_BLEND_SPECULARENABLE_TRUE))
    {
        DPF("dbgValidateControlRegisters: NV054_BLEND_SPECULARENABLE field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _FOGENABLE, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_FOGENABLE_FALSE)
     && (drfValue != NV054_BLEND_FOGENABLE_TRUE))
    {
        DPF("dbgValidateControlRegisters: NV054_BLEND_FOGENABLE field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _ALPHABLENDENABLE, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_ALPHABLENDENABLE_FALSE)
     && (drfValue != NV054_BLEND_ALPHABLENDENABLE_TRUE))
    {
        DPF("dbgValidateControlRegisters: NV054_BLEND_ALPHABLENDENABLE field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _SRCBLEND, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_SRCBLEND_ZERO)
     && (drfValue != NV054_BLEND_SRCBLEND_ONE)
     && (drfValue != NV054_BLEND_SRCBLEND_SRCCOLOR)
     && (drfValue != NV054_BLEND_SRCBLEND_INVSRCCOLOR)
     && (drfValue != NV054_BLEND_SRCBLEND_SRCALPHA)
     && (drfValue != NV054_BLEND_SRCBLEND_INVSRCALPHA)
     && (drfValue != NV054_BLEND_SRCBLEND_DESTALPHA)
     && (drfValue != NV054_BLEND_SRCBLEND_INVDESTALPHA)
     && (drfValue != NV054_BLEND_SRCBLEND_DESTCOLOR)
     && (drfValue != NV054_BLEND_SRCBLEND_INVDESTCOLOR)
     && (drfValue != NV054_BLEND_SRCBLEND_SRCALPHASAT))
    {
        DPF("dbgValidateControlRegisters: NV054_BLEND_SRCBLEND field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _DESTBLEND, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_DESTBLEND_ZERO)
     && (drfValue != NV054_BLEND_DESTBLEND_ONE)
     && (drfValue != NV054_BLEND_DESTBLEND_SRCCOLOR)
     && (drfValue != NV054_BLEND_DESTBLEND_INVSRCCOLOR)
     && (drfValue != NV054_BLEND_DESTBLEND_SRCALPHA)
     && (drfValue != NV054_BLEND_DESTBLEND_INVSRCALPHA)
     && (drfValue != NV054_BLEND_DESTBLEND_DESTALPHA)
     && (drfValue != NV054_BLEND_DESTBLEND_INVDESTALPHA)
     && (drfValue != NV054_BLEND_DESTBLEND_DESTCOLOR)
     && (drfValue != NV054_BLEND_DESTBLEND_INVDESTCOLOR)
     && (drfValue != NV054_BLEND_DESTBLEND_SRCALPHASAT))
    {
        DPF("dbgValidateControlRegisters: NV054_BLEND_DESTBLEND field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }

    /*
     * Validate the Control register.
     */
    drfValue = DRF_VAL(054, _CONTROL, _ALPHAFUNC, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_ALPHAFUNC_NEVER)
     && (drfValue != NV054_CONTROL_ALPHAFUNC_LESS)
     && (drfValue != NV054_CONTROL_ALPHAFUNC_EQUAL)
     && (drfValue != NV054_CONTROL_ALPHAFUNC_LESSEQUAL)
     && (drfValue != NV054_CONTROL_ALPHAFUNC_GREATER)
     && (drfValue != NV054_CONTROL_ALPHAFUNC_NOTEQUAL)
     && (drfValue != NV054_CONTROL_ALPHAFUNC_GREATEREQUAL)
     && (drfValue != NV054_CONTROL_ALPHAFUNC_ALWAYS))
    {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_ALPHAFUNC field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _ALPHATESTENABLE, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_ALPHATESTENABLE_FALSE)
     && (drfValue != NV054_CONTROL_ALPHATESTENABLE_TRUE))
    {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_ALPHATESTENABLE field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _ZENABLE, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_ZENABLE_FALSE)
     && (drfValue != NV054_CONTROL_ZENABLE_TRUE))
    {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_ZENABLE field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _ZFUNC, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_ZFUNC_NEVER)
     && (drfValue != NV054_CONTROL_ZFUNC_LESS)
     && (drfValue != NV054_CONTROL_ZFUNC_EQUAL)
     && (drfValue != NV054_CONTROL_ZFUNC_LESSEQUAL)
     && (drfValue != NV054_CONTROL_ZFUNC_GREATER)
     && (drfValue != NV054_CONTROL_ZFUNC_NOTEQUAL)
     && (drfValue != NV054_CONTROL_ZFUNC_GREATEREQUAL)
     && (drfValue != NV054_CONTROL_ZFUNC_ALWAYS))
    {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_ZFUNC field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _CULLMODE, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_CULLMODE_NONE)
     && (drfValue != NV054_CONTROL_CULLMODE_CW)
     && (drfValue != NV054_CONTROL_CULLMODE_CCW))
    {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_CULLMODE field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _DITHERENABLE, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_DITHERENABLE_FALSE)
     && (drfValue != NV054_CONTROL_DITHERENABLE_TRUE))
    {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_DITHERENABLE field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _Z_PERSPECTIVE_ENABLE, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_Z_PERSPECTIVE_ENABLE_FALSE)
     && (drfValue != NV054_CONTROL_Z_PERSPECTIVE_ENABLE_TRUE))
    {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_Z_PERSPECTIVE_ENABLE field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _ZWRITEENABLE, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_ZWRITEENABLE_FALSE)
     && (drfValue != NV054_CONTROL_ZWRITEENABLE_TRUE))
    {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_ZWRITEENABLE field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _Z_FORMAT, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_Z_FORMAT_FIXED)
     && (drfValue != NV054_CONTROL_Z_FORMAT_FLOAT))
    {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_Z_FORMAT field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    return (TRUE);
}
#endif  // DEBUG

#ifdef  DBGPREVIEWTEX
void dbgDisplayTexture
(
    PNVD3DCONTEXT   pContext,
    PNVD3DTEXTURE   pTexture
)
{
    // txtodo - support this
    if (dbgPreviewTexture && pTexture)
    {
        LPDDRAWI_DDRAWSURFACE_LCL   lclDDS   = pTexture->lpLcl;
        LPDDRAWI_DDRAWSURFACE_GBL   gblDDS   = pTexture->lpLcl->lpGbl;
        long                        u, v, u0, v0, uu, vv;
        long                        texWidth  = gblDDS->wWidth;
        long                        texHeight = gblDDS->wHeight;
        long                        texPitch  = gblDDS->lPitch;
        long                        fbPitch;
        long                        magX, magY;
        DWORD                       dwNonZeroAlphaCount = 0;

        if (pContext)
        {
            switch (pContext->dwSurfaceFormat & 0x0000000F)
            {
                case NV053_SET_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5:
                case NV053_SET_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5:
                case NV053_SET_FORMAT_COLOR_LE_R5G6B5:
                    dbgSurfaceDepth = 16;
                    break;
                case NV053_SET_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8:
                case NV053_SET_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8:
                case NV053_SET_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8:
                case NV053_SET_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8:
                case NV053_SET_FORMAT_COLOR_LE_A8R8G8B8:
                    dbgSurfaceDepth = 32;
                    break;
            }
        }

        NV_D3D_GLOBAL_SAVE();
        nvFlushDmaBuffers();
        NV_D3D_GLOBAL_SETUP();
        if (dbgSurfaceDepth == 16)
        {
            short                       texelSwizzle;
            unsigned short             *texMapSwizzle;
            unsigned short             *fb, *fb0;

#ifdef NV_TEX2
            if (pTexture->dwTextureFlags & NV4_TEXFLAG_USER_MIP_LEVEL)
                texMapSwizzle = (unsigned short *)TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags);
#else
            if (pTexture->dwTextureFlags & NV3_TEXTURE_USER_MIP_LEVEL)
                texMapSwizzle = (unsigned short *)pTexture->dwTexturePointer;
#endif
            else
            {
#ifdef NV_TEX2
                texMapSwizzle = (unsigned short *)TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags);
#else // !NV_TEX2
                if (pTexture->dwTextureFlags & NV3_TEXTURE_VIDEO_MEMORY)
                    texMapSwizzle = (unsigned short *)(VIDMEM_ADDR(pDriverData->BaseAddress + pTexture->dwTextureOffset));
                else
                {
                    if (pDriverData->GARTLinearBase > 0)
                        texMapSwizzle = (unsigned short *)pTexture->dwTexturePointer;
                    else
                        texMapSwizzle = (unsigned short *)GetPointerTextureHeap(pTexture->dwTextureOffset);
                }
#endif // !NV_TEX2
            }
            fb = fb0 = (dbgPreviewTextureUseBase) ? (unsigned short *)VIDMEM_ADDR(pDriverData->BaseAddress)
                                                  : (unsigned short *)VIDMEM_ADDR(pDriverData->CurrentVisibleSurfaceAddress);
            fbPitch = dbgPreviewTexturePitch;

            // if we can fit it in half the screen width or less,
            // then magnify as requested. otherwise don't
            magX = magY = 1;
            if ((int)(dbgPreviewTextureMagX * texWidth) < (fbPitch >> 2))
                magX = dbgPreviewTextureMagX;
            if ((int)(dbgPreviewTextureMagY * texHeight) < (fbPitch >> 2))
                magY = dbgPreviewTextureMagY;
            if ((magX > 1) || (magY > 1))
                DPF("D3D: DbgDisplayTexture: Texture Preview magnified by %d,%d (x,y)", magX, magY);

            if (dbgPreviewTextureClearFirst)
            {
                short clrColor;
                clrColor = (short)(0xffff * ((double)rand() / RAND_MAX));
                for (v = 0; v < texHeight*magY + 32; v++)
                {
                    for (u = 0; u < texWidth*magX + 32; u++) fb[u] = clrColor;
                    fb += (fbPitch >> 1);
                }
                fb = fb0;
            }

            for (v = 0; v < texHeight; v++)
            {
                V_INTERLEAVE(v0, v, texWidth, texHeight);

                for (vv = 0; vv < magY; vv++)
                {
                    for (u = 0; u < texWidth; u++)
                    {
                        U_INTERLEAVE(u0, u, texWidth, texHeight);
                        texelSwizzle = texMapSwizzle[u0|v0];

                        switch (pTexture->dwTextureColorFormat)
                        {

                        case NV054_FORMAT_COLOR_LE_A1R5G5B5:
                        {
                            if (texelSwizzle & 0x8000)
                                dwNonZeroAlphaCount++;
                            if ((!dbgMaskAlpha0)
                             || (texelSwizzle & 0x8000))
                            {
                                short r, g;
                                r = (texelSwizzle & 0x7C00) << 1;
                                g = (texelSwizzle & 0x03E0) << 1;
                                texelSwizzle = r | g | (texelSwizzle & 0x001F);
                                for (uu=0; uu<magX; uu++) fb[magX*u+uu] = texelSwizzle;
                            }
                            break;
                        }

                        case NV054_FORMAT_COLOR_LE_X1R5G5B5:
                        {
                            short r, g;
                            r = (texelSwizzle & 0x7C00) << 1;
                            g = (texelSwizzle & 0x03E0) << 1;
                            texelSwizzle = r | g | (texelSwizzle & 0x001F);
                            for (uu=0; uu<magX; uu++) fb[magX*u+uu] = texelSwizzle;
                            break;
                        }

                        case NV054_FORMAT_COLOR_LE_A4R4G4B4:
                        {
                            short a, r, g;
                            if (a = texelSwizzle & 0xF000)
                                dwNonZeroAlphaCount++;

                            r = (texelSwizzle & 0x0F00) << 3;
                            g = (texelSwizzle & 0x00F0) << 2;
                            texelSwizzle = ((texelSwizzle & 0x000F) << 1) | r | g;

                            if ((!dbgMaskAlpha0) || (a))
                            {
                                for (uu=0; uu<magX; uu++) fb[magX*u+uu] = texelSwizzle;
                            }
                            break;
                        }

                        case NV054_FORMAT_COLOR_LE_R5G6B5:
                        {
                            for (uu=0; uu<magX; uu++) fb[magX*u+uu] = texelSwizzle;
                            break;
                        }

                        case NV054_FORMAT_COLOR_LE_A8R8G8B8:
                        {
                            DWORD   dwTexel;
                            DWORD   a;
                            SHORT   r, g, b;
                            dwTexel = ((DWORD *)texMapSwizzle)[u0|v0];
                            if (a = (dwTexel & 0xFF000000))
                                dwNonZeroAlphaCount++;

                            r = (SHORT)((dwTexel & 0x00FF0000) >> 8) & 0xF800;
                            g = (SHORT)((dwTexel & 0x0000FF00) >> 5) & 0x07E0;
                            b = (SHORT)((dwTexel & 0x000000FF) >> 3) & 0x001F;
                            texelSwizzle = r | g | b;
                            if ((!dbgMaskAlpha0) || (a))
                            {
                                for (uu=0; uu<magX; uu++) fb[magX*u+uu] = texelSwizzle;
                            }
                            break;
                        }

                        case NV054_FORMAT_COLOR_LE_X8R8G8B8:
                        {
                            DWORD   dwTexel;
                            SHORT   r, g, b;
                            dwTexel = ((DWORD *)texMapSwizzle)[u0|v0];
                            r = (SHORT)((dwTexel & 0x00FF0000) >> 8) & 0xF800;
                            g = (SHORT)((dwTexel & 0x0000FF00) >> 5) & 0x07E0;
                            b = (SHORT)((dwTexel & 0x000000FF) >> 3) & 0x001F;
                            texelSwizzle = r | g | b;
                            for (uu=0; uu<magX; uu++) fb[magX*u+uu] = texelSwizzle;
                            break;
                        }

                        default:
                        {
                            for (uu=0; uu<magX; uu++) fb[magX*u+uu] = texelSwizzle;
                            break;
                        }

                        }  // switch

                    }  // loop on u

                    fb += (fbPitch >> 1);

                }  // loop on vv
            }  // loop on v
        }
        else
        {
            DWORD   texelSwizzle;
            DWORD  *texMapSwizzle;
            DWORD  *fb, *fb0;

#ifdef NV_TEX2
            if (pTexture->dwTextureFlags & NV4_TEXFLAG_USER_MIP_LEVEL)
                texMapSwizzle = (unsigned long *)TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags);
#else
            if (pTexture->dwTextureFlags & NV3_TEXTURE_USER_MIP_LEVEL)
                texMapSwizzle = (unsigned long *)pTexture->dwTexturePointer;
#endif
            else
            {
#ifdef NV_TEX2
                texMapSwizzle = (unsigned long *)TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags);
#else // !NV_TEX2
                if (pTexture->dwTextureFlags & NV3_TEXTURE_VIDEO_MEMORY)
                    texMapSwizzle = (unsigned long *)(VIDMEM_ADDR(pDriverData->BaseAddress + pTexture->dwTextureOffset));
                else
                {
                    if (pDriverData->GARTLinearBase > 0)
                        texMapSwizzle = (unsigned long *)pTexture->dwTexturePointer;
                    else
                        texMapSwizzle = (unsigned long *)GetPointerTextureHeap(pTexture->dwTextureOffset);
                }
#endif // !NV_TEX2
            }
            fb = fb0 = (dbgPreviewTextureUseBase) ? (DWORD *)VIDMEM_ADDR(pDriverData->BaseAddress)
                                                  : (DWORD *)VIDMEM_ADDR(pDriverData->CurrentVisibleSurfaceAddress);
            fbPitch = dbgPreviewTexturePitch;

            // if we can fit it in half the screen width or less,
            // then magnify as requested. otherwise don't
            magX = magY = 1;
            if ((int)(dbgPreviewTextureMagX * texWidth) < (fbPitch >> 3))
                magX = dbgPreviewTextureMagX;
            if ((int)(dbgPreviewTextureMagY * texHeight) < (fbPitch >> 3))
                magY = dbgPreviewTextureMagY;
            if ((magX > 1) || (magY > 1))
                DPF("D3D: DbgDisplayTexture: Texture Preview magnified by %d,%d (x,y)", magX, magY);

            if (dbgPreviewTextureClearFirst)
            {
                DWORD clrColor;
                clrColor = (DWORD)(0xffffffff * ((float)rand() / RAND_MAX));
                for (v = 0; v < texHeight*magY + 32; v++)
                {
                    for (u = 0; u < texWidth*magX + 32; u++) fb[u] = clrColor;
                    fb += (fbPitch >> 2);
                }
                fb = fb0;
            }

            for (v = 0; v < texHeight; v++)
            {
                V_INTERLEAVE(v0, v, texWidth, texHeight);

                for (vv = 0; vv < magY; vv++)
                {

                    for (u = 0; u < texWidth; u++)
                    {

                        U_INTERLEAVE(u0, u, texWidth, texHeight);

                        switch (pTexture->dwTextureColorFormat)
                        {

                        case NV054_FORMAT_COLOR_LE_A1R5G5B5:
                        {
                            WORD    wTexel;
                            wTexel = ((WORD *)texMapSwizzle)[u0|v0];

                            if (wTexel & 0x8000)
                                dwNonZeroAlphaCount++;
                            if ((!dbgMaskAlpha0)
                             || (wTexel & 0x8000))
                            {
                                texelSwizzle = ((wTexel & 0x7C00) << 9)
                                             | ((wTexel & 0x03E0) << 6)
                                             | ((wTexel & 0x001F) << 3);
                                for (uu=0; uu<magX; uu++) fb[magX*u+uu] = texelSwizzle;
                            }
                            break;
                        }

                        case NV054_FORMAT_COLOR_LE_X1R5G5B5:
                        {
                            WORD    wTexel;
                            wTexel = ((WORD *)texMapSwizzle)[u0|v0];
                            texelSwizzle = ((wTexel & 0x7C00) << 9)
                                         | ((wTexel & 0x03E0) << 6)
                                         | ((wTexel & 0x001F) << 3);
                            for (uu=0; uu<magX; uu++) fb[magX*u+uu] = texelSwizzle;
                            break;
                        }

                        case NV054_FORMAT_COLOR_LE_A4R4G4B4:
                        {
                            short a;
                            WORD    wTexel;
                            wTexel = ((WORD *)texMapSwizzle)[u0|v0];

                            if (a = wTexel & 0xF000)
                                dwNonZeroAlphaCount++;

                            if ((!dbgMaskAlpha0)
                             || (a))
                            {
                                texelSwizzle = ((wTexel & 0x0F00) << 12)
                                             | ((wTexel & 0x00F0) << 8)
                                             | ((wTexel & 0x000F) << 4);
                                for (uu=0; uu<magX; uu++) fb[magX*u+uu] = texelSwizzle;
                            }
                            break;
                        }

                        case NV054_FORMAT_COLOR_LE_R5G6B5:
                        {
                            WORD    wTexel;
                            wTexel = ((WORD *)texMapSwizzle)[u0|v0];

                            texelSwizzle = ((wTexel & 0xF800) << 8)
                                         | ((wTexel & 0x07E0) << 5)
                                         | ((wTexel & 0x001F) << 3);
                            for (uu=0; uu<magX; uu++) fb[magX*u+uu] = texelSwizzle;
                            break;
                        }

                        case NV054_FORMAT_COLOR_LE_A8R8G8B8:
                        {
                            DWORD   a;
                            texelSwizzle = texMapSwizzle[u0|v0];
                            if (a = (texelSwizzle & 0xFF000000))
                                dwNonZeroAlphaCount++;

                            if ((!dbgMaskAlpha0)
                             || (a))
                            {
                                for (uu=0; uu<magX; uu++) fb[magX*u+uu] = texelSwizzle;
                            }
                            break;
                        }

                        case NV054_FORMAT_COLOR_LE_X8R8G8B8:
                        {
                            texelSwizzle = texMapSwizzle[u0|v0];
                            for (uu=0; uu<magX; uu++) fb[magX*u+uu] = texelSwizzle;
                            break;
                        }

                        }  // switch

                    }  // loop on u

                    fb += (fbPitch >> 2);

                }  // loop on vv
            }  // loop on v

        }  // else (32-bit)

        if ((pTexture->dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A1R5G5B5)
         || (pTexture->dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A4R4G4B4)
         || (pTexture->dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A8R8G8B8))
        {
            if (dwNonZeroAlphaCount)
                DPF("D3D:dbgDisplayTexture - Non Zero Alpha Count = %08lx", dwNonZeroAlphaCount);
            else
                DPF("D3D:dbgDisplayTexture - ALPHA TEXTURE HAS NO ALPHA!!!!");
        }
    }

    return;
}

void dbgDisplayLinearTexture
(
    LPDDRAWI_DDRAWSURFACE_LCL   lpLcl,
    LPDDRAWI_DDRAWSURFACE_LCL   lpLclDst,
    DWORD                       dwTextureFormat
)
{
    if (dbgPreviewLinearTexture && lpLcl)
    {
        LPDDRAWI_DDRAWSURFACE_GBL   lpGbl = lpLcl->lpGbl;
        short                       texelLinear;
        unsigned short             *texMapLinear;
        unsigned short             *fb;
        long                        u, v;
        long                        texWidth  = lpGbl->wWidth;
        long                        texHeight = lpGbl->wHeight;
        long                        texPitch  = lpGbl->lPitch;
        long                        fbPitch;
        DWORD                       dwNonZeroAlphaCount = 0;
        DWORD                       dwSrcBitCount;

        texMapLinear = (unsigned short *)lpGbl->fpVidMem;
        fb           = (dbgPreviewTextureUseBase) ? (unsigned short *)VIDMEM_ADDR(pDriverData->BaseAddress) : (unsigned short *)VIDMEM_ADDR(pDriverData->CurrentVisibleSurfaceAddress);
        fbPitch      = dbgPreviewTexturePitch;
        if (lpGbl->ddpfSurface.dwFlags & DDPF_RGB)
            dwSrcBitCount = lpGbl->ddpfSurface.dwRGBBitCount;
        else
            dwSrcBitCount = pDriverData->bi.biBitCount;
#ifndef WINNT // BUGBUG NT5 doesn't appear to support palettized textures
        if (dwSrcBitCount == 8)
        {
            BYTE            bIndex;
            WORD            wColor;
            LPPALETTEENTRY  pPalette;
            unsigned char  *srcTexture;
            if ((!lpLclDst->lpDDPalette)
             || (!lpLclDst->lpDDPalette->lpLcl)
             || (!lpLclDst->lpDDPalette->lpLcl->lpGbl)
             || (!lpLclDst->lpDDPalette->lpLcl->lpGbl->lpColorTable))
            {
                return;
            }
            pPalette = lpLclDst->lpDDPalette->lpLcl->lpGbl->lpColorTable;
            srcTexture = (unsigned char *)texMapLinear;
            for (v = 0; v < texHeight; v++)
            {
                for (u = 0; u < texWidth; u++)
                {
                    bIndex = srcTexture[u];
                    wColor = ((WORD)(pPalette[bIndex].peRed & 0xF8) << 8)
                           | ((WORD)(pPalette[bIndex].peGreen & 0xFC) << 3)
                           | ((WORD)(pPalette[bIndex].peBlue & 0xF8) >> 3);
                    fb[u+264] = wColor;
                }
                srcTexture += texPitch;
                fb         += (fbPitch >> 1);
            }
            return;
        }
#endif // BUGBUG #ifndef WINNT

        for (v = 0; v < texHeight; v++)
        {
            for (u = 0; u < texWidth; u++)
            {
                texelLinear = texMapLinear[u];
                switch (dwTextureFormat)
                {
                    case NV054_FORMAT_COLOR_LE_A1R5G5B5:
                    {
                        if (texelLinear & 0x8000)
                            dwNonZeroAlphaCount++;
                        if ((!dbgMaskAlpha0)
                         || (texelLinear & 0x8000))
                        {
                            short r, g;
                            r = (texelLinear & 0x7C00) << 1;
                            g = (texelLinear & 0x03D0) << 1;
                            texelLinear = r | g | (texelLinear & 0x001F);
                            fb[u+264] = texelLinear;
                        }
                        break;
                    }
                    case NV054_FORMAT_COLOR_LE_X1R5G5B5:
                    {
                        short r, g;
                        r = (texelLinear & 0x7C00) << 1;
                        g = (texelLinear & 0x03D0) << 1;
                        texelLinear = r | g | (texelLinear & 0x001F);
                        fb[u+264] = texelLinear;
                        break;
                    }
                    case NV054_FORMAT_COLOR_LE_A4R4G4B4:
                    {
                        short a, r, g;
                        if (a = texelLinear & 0xF000)
                            dwNonZeroAlphaCount++;

                        r = (texelLinear & 0x0F00) << 3;
                        g = (texelLinear & 0x00F0) << 2;
                        texelLinear = ((texelLinear & 0x000F) << 1) | r | g;

                        if ((!dbgMaskAlpha0)
                         || (a))
                        {
                            fb[u+264] = texelLinear;
                        }
                        break;
                    }
                    case NV054_FORMAT_COLOR_LE_R5G6B5:
                    {
                        fb[u+264] = texelLinear;
                        break;
                    }
                    case NV054_FORMAT_COLOR_LE_A8R8G8B8:
                    {
                        DWORD   dwTexel;
                        DWORD   a;
                        SHORT   r, g, b;
                        dwTexel = ((DWORD *)texMapLinear)[u];
                        if (a = (dwTexel & 0xFF000000))
                            dwNonZeroAlphaCount++;

                        r = (SHORT)((dwTexel & 0x00FF0000) >> 8) & 0xF800;
                        g = (SHORT)((dwTexel & 0x0000FF00) >> 5) & 0x07E0;
                        b = (SHORT)((dwTexel & 0x000000FF) >> 3) & 0x001F;
                        texelLinear = r | g | b;
                        if ((!dbgMaskAlpha0)
                         || (a))
                        {
                            fb[u+264] = texelLinear;
                        }
                        break;
                    }
                    case NV054_FORMAT_COLOR_LE_X8R8G8B8:
                    {
                        DWORD   dwTexel;
                        SHORT   r, g, b;
                        dwTexel = ((DWORD *)texMapLinear)[u];
                        r = (SHORT)((dwTexel & 0x00FF0000) >> 8) & 0xF800;
                        g = (SHORT)((dwTexel & 0x0000FF00) >> 5) & 0x07E0;
                        b = (SHORT)((dwTexel & 0x000000FF) >> 3) & 0x001F;
                        texelLinear = r | g | b;
                        fb[u+264] = texelLinear;
                        break;
                    }
                    default:
                        fb[u+264] = texelLinear;
                        break;

                }
            }
            texMapLinear += (texPitch >> 1);
            fb           += (fbPitch >> 1);
        }
        if ((dwTextureFormat == NV054_FORMAT_COLOR_LE_A1R5G5B5)
         || (dwTextureFormat == NV054_FORMAT_COLOR_LE_A4R4G4B4)
         || (dwTextureFormat == NV054_FORMAT_COLOR_LE_A8R8G8B8))
        {
            if (dwNonZeroAlphaCount)
                DPF("D3D:dbgDisplayTexture - Non Zero Alpha Count = %08lx", dwNonZeroAlphaCount);
            else
                DPF("D3D:dbgDisplayTexture - ALPHA TEXTURE HAS NO ALPHA!!!!");
        }
    }
    return;
}
#endif  // DBGPREVIEWTEX

/*
 * Routines that are valid when DMAVALIDATE is defined.
 */
#ifdef  DMAVALIDATE
void dbgValidatePushBufferError
(
    void
)
{
    DPF("D3D:dbgValidatePushBufferError - Push Buffer Validation Error!!!");
    return;
}
void dbgValidatePushBufferData
(
    void
)
{
    return;
}
#endif  // DMAVALIDATE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\D3dmini.c ===
/*
 * Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: D3DMINI.C                                                         *
*   The direct 3d HAL driver routines are implemented in this module.       *
*   This file is a hardware independant file.                               *
*   DO NOT PUT HARDWARE SPECIFIC CODE IN THIS FILE                          *
*   Hardware specific code can be found in:                                 *
*   nv3mini.c, nv4mini.c, ...                                               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/02/97 - re-wrote and cleaned up.     *
*       Charles Inman               01/31/98 - Ported for NV4               *
*                                                                           *
\***************************************************************************/
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "d3dinc.h"
#include "nvd3dcap.h"
#include "nvtexfmt.h"
#include "nv3ddbg.h"

/*
 * Miscellaneous Driver Data.
 */
static D3DHAL_GLOBALDRIVERDATA  NvGlobal;

/*
 * Direct3D HAL Callback Table.
 */
static D3DHAL_CALLBACKS NvD3DHALCallbacks =
{
    sizeof(D3DHAL_CALLBACKS),
    /*
     * Device context
     */
    nvContextCreate,            /* Required. */
    nvContextDestroy,           /* Required. */
    nvContextDestroyAll,        /* Required. */
    /*
     * Scene capture
     */
    nvSceneCapture,             /* Optional. */
    /*
     * Execution
     */
    0,                          /* Optional. Not needed if only rasterization */
    0,
#ifndef WINNT
    nvRenderState,              /* Required if no Execute */
    nvRenderPrimitive,          /* Required if no Execute */
#else
    0,
    0,
#endif // #else
    0L,                         /* Reserved, must be zero */
    /*
     * Textures
     */
    nvTextureCreate,            /* If any of these calls are supported, */
    nvTextureDestroy,           /* they must all be. */
    nvTextureSwap,              /* ditto - but can always fail. */
    nvTextureGetSurf,           /* ditto - but can always fail. */
    /*
     * Transform - must be supported if lighting is supported.
     */
    0,                          /* If any of these calls are supported, */
    0,                          /* they must all be. */
    0,                          /* ditto */
    0,                          /* ditto */
    0,                          /* ditto */
    /*
     * Lighting
     */
    0,                          /* If any of these calls are supported, */
    0,                          /* they must all be. */
    0,                          /* ditto */
    0,                          /* ditto */
    0,                          /* ditto */
    /*
     * Pipeline state
     */
#ifndef WINNT
    nvGetState,                 /* Required if implementing Execute. */
#else
    0,
#endif // #else
    /*
     * Reserved
     */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
};

/*
 * Define the NV3 device capabilities structure.
 */
D3DDEVICEDESC_V1 NvCaps =
{
    sizeof(D3DDEVICEDESC_V1),
    NV_DEVDESC_FLAGS,
    NV_COLORMODEL,
    NV_DEVCAPS_FLAGS,
    NV_TRANSFORMCAPS,
    NV_3DCLIPPINGCAPS,
    NV_LIGHTINGCAPS,
    NV_LINECAPS,
    NV_TRICAPS,
    NV_RENDERBITDEPTHCAPS,
    NV_ZBUFFERBITDEPTHCAPS,
    NV_MAXBUFFERSIZE,
    NV_MAXVERTEXCOUNT
};

/*
 * Define supported texture formats.
 */
static DDSURFACEDESC    NvTextureFormats[] =
{
    NV_TEXTURE_FORMATS      /* Texture formats defined in NVTEXFMTS.H */
};

/*
 * Developer Identification String
 * Before sending a pre-release driver to a developer, this data can be modified in the binary to identify
 * the developer it is being sent to.  This will give us an identification mechanism if the driver mysteriously
 * finds it's way on the the net.
 */
BYTE bDeveloperID[32 + 32] =
{
    0x0F, 0xAD, 0xCA, 0xFE, 0xDE, 0xAF, 0xFE, 0xED,
    0xDE, 0xAF, 0xBA, 0xBE, 0xDE, 0xAD, 0xF0, 0x0D,
    0x0B, 0xAD, 0xCA, 0xFE, 0x0D, 0xEA, 0xDF, 0xED,
    0xDE, 0xAD, 0xBA, 0xBE, 0x0B, 0xAD, 0xF0, 0x0D,

    0x61, 0x34, 0x42, 0x34, 0xf6, 0xf4, 0x82, 0xe1,
    0xb7, 0xec, 0x5c, 0x23, 0x82, 0x00, 0x60, 0x84,
    0x67, 0x8c, 0x45, 0x2c, 0x47, 0x31, 0x85, 0x32,
    0x30, 0x05, 0x06, 0x20, 0x93, 0x10, 0x40, 0x92,
};

/*
 * --------------------------------------------------------------------------
 *  Direct 3D HAL driver creation routines.
 *  Functions used to instantiate the 3D portion of the DirectDraw HAL
 *  Will be called (for example) from invokeCreateDriver() from ddsamp.
 *
 *  D3DHALCreateDriver
 *
 *  LPD3DHAL_GLOBALDRIVERDATA* lplpGlobal
 *      - A pointer to a structure containing alot of global information about
 *        our driver.
 *
 *  LPD3DHAL_CALLBACKS* lplpHALCallbacks
 *      - A pointer to a structure we fill in with the callbacks that this
 *        driver supports.
 * --------------------------------------------------------------------------
 */
BOOL __stdcall D3DHALCreateDriver
(
    LPD3DHAL_GLOBALDRIVERDATA  *lplpGlobal,
    LPD3DHAL_CALLBACKS         *lplpHALCallbacks
)
{
    if (!pDriverData->hContexts_gbl)
        if (!CreateItemArrays())
        {
            DPF_LEVEL (NVDBG_LEVEL_ERROR, "Failed to initialize arrays");
            return FALSE;
        }

    /*
     * check if driver is valid
     */
    {
        DWORD i,c;

        for (i = 32,c = 0; i < 64; i++)
        {
            if ((i & 7) == 7)
            {
                c ^= 0x42;
                if ((c ^ bDeveloperID[i]) & 0xfe)
                {
                    DPF_LEVEL (NVDBG_LEVEL_ERROR, "Invalid Driver ID");
                    return FALSE;
                }
                c = 0;
            }
            else
            {
                c ^= bDeveloperID[i];
            }
        }
    }

    /*
     * Get the current registry settings from the hardware specific routine.
     */
    D3DReadRegistry();

    /*
     * Here we fill in the supplied structures.
     */
    memset(&NvGlobal, 0, sizeof(D3DHAL_GLOBALDRIVERDATA));
    NvGlobal.dwSize              = sizeof(D3DHAL_GLOBALDRIVERDATA);
    NvGlobal.hwCaps              = NvCaps;
    NvGlobal.dwNumVertices       = 0;
    NvGlobal.dwNumClipVertices   = 0;
    NvGlobal.dwNumTextureFormats = sizeof(NvTextureFormats)
                                 / sizeof(DDSURFACEDESC);
    NvGlobal.lpTextureFormats    = &NvTextureFormats[0];

    /*
     * Modify the capabilities as neccessary for the registry settings.
     */
    D3DModifyCapabilities(&NvGlobal);

    /*
     * Return the HAL table.
     */
    *lplpGlobal       = &NvGlobal;
    *lplpHALCallbacks = &NvD3DHALCallbacks;
    return (TRUE);
}

/*
 * --------------------------------------------------------------------------
 * Initialization routines.
 * --------------------------------------------------------------------------
 */

/*
 * This routine creates the various dynamic item arrays used by the Direct3D
 * driver for managing contexts and textures. This routine should be called
 * at DLL_PROCESS_ATTACH time from DllMain.
 */
BOOL CreateItemArrays
(
    void
)
{
#ifndef OLDSTUFF
#else
    /*
     * Initialize memory system.
     */
    if (!DDrvItemArrayInit())
    {
        DPF_LEVEL (NVDBG_LEVEL_ERROR, "CreateItemArrays - Failed to initialize memory subsystem");
        return (FALSE);
    }
#endif

    /*
     * Create the D3D context heap.
     */
    if (!nvCreateContextListHeap())
        return (FALSE);

    /*
     * Create the D3D texture heap.
     */
    if (!nvCreateTextureListHeap())
    {
        /*
         * Could not allocate the Texture heap! Cleanup.
         */
        nvDestroyContextListHeap();
#ifndef OLDSTUFF
#else
        DDrvItemArrayFini();
#endif
        return (FALSE);
    }
    return (TRUE);
}

/*
 * --------------------------------------------------------------------------
 * Termination routines.
 * --------------------------------------------------------------------------
 */

/*
 * This routine destroys the various dynamic item arrays used by the
 * Direct3D driver for managing contexts and textures. This routine should
 * be called at DLL_PROCESS_DETACH time from DllMain.
 */
BOOL DestroyItemArrays
(
    void
)
{
    /*
     * Cleanup texture array.
     */
    nvDestroyTextureListHeap();

    /*
     * Cleanup the D3D context heap.
     */
    nvDestroyContextListHeap();

    /*
     * Set all the heap handles back to null.
     */
    pDriverData->hContexts_gbl  = 0;
    pDriverData->hTextures_gbl  = 0;
    pDriverData->hAGPList_gbl   = 0;

#ifndef OLDSTUFF
    return (TRUE);
#else
    /*
     * Cleanup memory.
     */
    return (DDrvItemArrayFini());
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\D3dctxt.c ===
/*
 * Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 * (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: D3DCTXT.C                                                         *
*   The Direct 3d Context Management routines.                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/02/97 - re-wrote and cleaned up.     *
*                                                                           *
\***************************************************************************/
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "d3dinc.h"
#include "nv3ddbg.h"
#include "nvheap.h"

#ifdef NV_DISASM
HANDLE nvPusherFile               = 0;
BOOL   nvPusherDisassemblerEnable = 0;
#endif

//#define NV_TETRIS
#ifdef NV_TETRIS

/*
 * nvTetrisTile
 *
 * reorgs memory to cancel tiling reorg
 */
void nvTetrisTile
(
    DWORD  dwTetrisShift,
    DWORD  dwTetrisMode
)
{
    DWORD dwBase  = pDriverData->BaseAddress;
    DWORD dwSize  = pDriverData->TotalVRAM;

    DWORD dwMask2 = ((1 << dwTetrisMode) - 1) << (10 + dwTetrisShift);
    DWORD dwMask3 = dwMask2 >> dwTetrisMode;
    DWORD dwMask1 = ~(dwMask2 | dwMask3);

    DWORD dwGran  = 1 << (10 + dwTetrisShift - dwTetrisMode);

    BYTE  *p1     = GlobalAlloc(GPTR,dwGran);
    BYTE  *p2     = GlobalAlloc(GPTR,dwGran);

    DWORD dwAddr1;
    DWORD dwAddr2;

    for (dwAddr1 = 0; dwAddr1 < dwSize; dwAddr1 += dwGran)
    {
        dwAddr2 = (dwAddr1 & dwMask1)
                | ((dwAddr1 >> dwTetrisMode) & dwMask3)
                | ((dwAddr1 << dwTetrisMode) & dwMask2);

        if (dwAddr2 > dwAddr1)
        {
            memcpy (p1,(void*)(dwBase + dwAddr1),dwGran);
            memcpy (p2,(void*)(dwBase + dwAddr2),dwGran);
            memcpy ((void*)(dwBase + dwAddr1),p2,dwGran);
            memcpy ((void*)(dwBase + dwAddr2),p1,dwGran);
        }
    }

    GlobalFree (p1);
    GlobalFree (p2);
}

/*
 * nvTetrisTilingEnable
 *
 * safely enables tetris tiling
 */
void nvTetrisTilingEnable
(
    DWORD  dwTetrisShift,
    DWORD  dwTetrisMode
)
{
    DWORD dwCtrl   = ((DWORD)pDriverData->NvBaseFlat) + 0x100200;
    DWORD t;

    /*
     * read/modify register
     */
    t  = *(DWORD*)dwCtrl;
    t &= 0xfff00000;
    t |= 0x2000 | (dwTetrisMode << 15) | (dwTetrisShift << 18);

    /*
     * clear ints
     */
    __asm cli;

    /*
     * restore memory
     */
    nvTetrisTile (dwTetrisShift,dwTetrisMode);

    /*
     * write register
     */
    *(DWORD*)dwCtrl = t;

    /*
     * enable ints
     */
    __asm sti;
}

/*
 * nvTetrisTilingDisable
 *
 * safely enables tetris tiling
 */
void nvTetrisTilingDisable
(
    DWORD  dwTetrisShift,
    DWORD  dwTetrisMode
)
{
    DWORD dwCtrl   = ((DWORD)pDriverData->NvBaseFlat) + 0x100200;
    DWORD t;

    /*
     * read/modify register
     */
    t  = *(DWORD*)dwCtrl;
    t &= 0xfff00000;
    t |= 0x00001114;

    /*
     * clear ints
     */
    __asm cli;

    /*
     * restore memory
     */
    nvTetrisTile (dwTetrisShift,dwTetrisMode);

    /*
     * write register
     */
    *(DWORD*)dwCtrl = t;

    /*
     * enable ints
     */
    __asm sti;
}

#endif //NV_TETRIS

/*
 * Miscellaneous D3D context related routines.
 */
BOOL nvCreateContextListHeap
(
    void
)
{
    /*
     * Create a global heap to allocate internal D3D Context data structures out of.
     * The number of D3D Contexts available can be adjusted by a setting in the registry.
     * It is set reasonably large by default, so hopefully the registry override will never
     * be needed....but just in case.
     */
#ifndef OLDSTUFF
    pDriverData->hContexts_gbl = (DWORD)HEAPCREATE((pDriverData->regD3DContextMax * sizeof(NVD3DCONTEXT)));
#else
    pDriverData->hContexts_gbl = (DWORD)HeapCreate(HEAP_SHARED,
                                                   (pDriverData->regD3DContextMax * sizeof(NVD3DCONTEXT)),
                                                   0);
#endif
    if (!pDriverData->hContexts_gbl)
    {
        DPF_LEVEL (NVDBG_LEVEL_ERROR, "nvCreateContextListHeap - Could not create context list heap!");
        return (FALSE);
    }
    return (TRUE);
}
BOOL nvDestroyContextListHeap
(
    void
)
{
    PNVD3DCONTEXT   pContext;
    PNVD3DCONTEXT   pContextNext;

    /*
     * If there's no heap currently allocated, then there is no heap to destroy.
     */
    if (!pDriverData->hContexts_gbl)
        return (TRUE);

    /*
     * Free any contexts that are still allocated.
     */
    pContext = (PNVD3DCONTEXT)pDriverData->dwContextListHead;
    while (pContext)
    {
        pContextNext = pContext->pContextNext;
#ifndef OLDSTUFF
        HEAPFREE(pDriverData->hContexts_gbl, pContext);
#else
        HeapFree((HANDLE)pDriverData->hContexts_gbl, 0, pContext);
#endif
        pDriverData->dwD3DContextCount--;
        pContext = pContextNext;
    }

    /*
     * Destroy the heap.
     */
#ifndef OLDSTUFF
    HEAPDESTROY(pDriverData->hContexts_gbl);
#else
    HeapDestroy((HANDLE)pDriverData->hContexts_gbl);
#endif
    pDriverData->hContexts_gbl = (DWORD)NULL;
    return (TRUE);
}

/*
 * D3D HAL context callback routines
 */

/*
 * --------------------------------------------------------------------------
 * NvContextCreate
 *
 * LPD3DHAL_CONTEXTCREATEDATA pccd
 *    Pointer to a structure containing things including the current
 *    rendering surface, the current Z surface, and the DirectX object
 *    handle, etc.
 * --------------------------------------------------------------------------
 */
DWORD __stdcall nvContextCreate
(
    LPD3DHAL_CONTEXTCREATEDATA  pccd
)
{
    unsigned char              *pData = 0;
    HDDRVITEM                   hContext;
    LPDDRAWI_DDRAWSURFACE_LCL   lpLcl  = 0;
    LPDDRAWI_DDRAWSURFACE_GBL   lpGbl  = 0;
    LPDDRAWI_DDRAWSURFACE_LCL   lpLclZ = 0;

    /*
     * analyzer markers
     */
#ifdef NV_MARKER
    {
        extern DWORD dwMarkerCount;
        dwMarkerCount = 0;
    }
#endif
#ifdef NV_STATS
    {
        extern DWORD dwSceneCount;
        dwSceneCount = 0;
    }
#endif
    /*
     * push buffer disassembler
     */
#ifdef NV_DISASM
    {
        nvPusherFile = CreateFile("\\PushData.bin",GENERIC_WRITE,0,0,CREATE_ALWAYS,0,0);
        if (nvPusherFile == INVALID_HANDLE_VALUE)
        {
            nvPusherFile = 0;
        }
    }
#endif

    /*
     * Validate the direct draw surface pointers.
     */
    if ((pccd->lpDDS) == NULL)
    {
        pccd->ddrval = DDERR_CURRENTLYNOTAVAIL;
        return (DDHAL_DRIVER_HANDLED);
    }
    if ((lpLcl = DDS_LCL(pccd->lpDDS)) == NULL)
    {
        pccd->ddrval = DDERR_CURRENTLYNOTAVAIL;
        return (DDHAL_DRIVER_HANDLED);
    }
    if (lpLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
    {
        pccd->ddrval = DDERR_CURRENTLYNOTAVAIL;
        return (DDHAL_DRIVER_HANDLED);
    }
    if ((lpGbl = lpLcl->lpGbl) == NULL)
    {
        pccd->ddrval = DDERR_CURRENTLYNOTAVAIL;
        return DDHAL_DRIVER_HANDLED;
    }
    if ((pccd->lpDDSZ != NULL)
     && ((lpLclZ = DDS_LCL(pccd->lpDDSZ)) == NULL))
    {
        pccd->ddrval = DDERR_CURRENTLYNOTAVAIL;
        return (DDHAL_DRIVER_HANDLED);
    }
    if (lpLclZ && (lpLclZ->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY))
    {
        pccd->ddrval = DDERR_CURRENTLYNOTAVAIL;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Get pointer to global driver data structure.
     */
    NvSetDriverDataPtr(pccd->lpDDGbl);

    /*
     * Setup frequently accessed globals.
     */
    NV_D3D_GLOBAL_SETUP();

#ifdef NV_TETRIS
    /*
     * enable tetris tiling
     */
    nvTetrisTilingEnable (1/* dwBPP / 8 - 1 */,4 /* # lines for a 4:1 aspect tile */);
#endif

    /*
     * NOTES:
     *
     * This callback is invoked when a new surface is to be used as a
     * rendering target.
     * The context handled returned will be used whenever rendering
     * to this surface is to be performed.
     *
     * Allocate a new context from the context array.
     */
#ifndef  OLDSTUFF
    hContext = (HDDRVITEM)HEAPALLOC(pDriverData->hContexts_gbl, sizeof(NVD3DCONTEXT));
#else
    hContext = (HDDRVITEM)HeapAlloc((HANDLE)pDriverData->hContexts_gbl,
                                    HEAP_ZERO_MEMORY,
                                    sizeof(NVD3DCONTEXT));
#endif

    /*
     * Get the pointer to the newly allocated context.
     */
    pCurrentContext = (PNVD3DCONTEXT)hContext;
    if (!pCurrentContext)
    {
        DPF_LEVEL (NVDBG_LEVEL_ERROR, "nvContextCreate - Bad Context");
        NV_D3D_GLOBAL_SAVE();
        pccd->ddrval = D3DHAL_OUTOFCONTEXTS;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Start with a clean slate.
     */
    memset(pCurrentContext, 0, sizeof(NVD3DCONTEXT));

    /*
     * Save off the applications DirectX version level.
     */
    pCurrentContext->dwDXVersionLevel = pccd->dwhContext;

    /*
     * Return the handle of the new context.
     */
    pccd->dwhContext = hContext;

    /*
     * Set the process ID for the context.
     */
    pCurrentContext->pid = pccd->dwPID;
#ifdef WINNT
    pCurrentContext->lpDD = pccd->lpDDGbl;
#endif // #ifdef WINNT

    /*
     * Initialize the surface specific context data.
     */
    pCurrentContext->lpLcl  = lpLcl;
    pCurrentContext->lpLclZ = lpLclZ;

    /*
     * Do the hardware specific context setup.
     */
    if (!nvSetupContext(pCurrentContext))
    {
        /*
         * When this call fails, it means there was some sort of problem with the
         * surface format.  Either an unsupported pixel format was specified or
         * an unsupported pixel/zeta format was specified.
         * Free the context memory and return an error.
         */
#ifndef OLDSTUFF
        HEAPFREE(pDriverData->hContexts_gbl, pCurrentContext);
#else
        HeapFree((HANDLE)pDriverData->hContexts_gbl, 0, (PVOID)pCurrentContext);
#endif
        pccd->dwhContext = 0;
        pCurrentContext  = 0;
        NV_D3D_GLOBAL_SAVE();
        pccd->ddrval = DDERR_INVALIDPIXELFORMAT;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Update the open context count.
     */
    pDriverData->dwD3DContextCount++;

    /*
     * Update the context list.
     */
    pCurrentContext->pContextPrev = (PNVD3DCONTEXT)NULL;
    pCurrentContext->pContextNext = (PNVD3DCONTEXT)pDriverData->dwContextListHead;
    if (pCurrentContext->pContextNext)
        pCurrentContext->pContextNext->pContextPrev = pCurrentContext;
    pDriverData->dwContextListHead = (DWORD)pCurrentContext;

    /*
     * Init scene counter
     */
    pCurrentContext->dwSceneCount = 0;


    /*
     * Initiate Anti-Aliasing runtime
     */
    if (!nvAACreate()) {
        DPF_LEVEL (NVDBG_LEVEL_ERROR, "Cannot create AA Context.");
        NV_D3D_GLOBAL_SAVE();
        pccd->ddrval = D3DHAL_OUTOFCONTEXTS;
        return (DDHAL_DRIVER_HANDLED);
    }

#ifdef HW_PAL8
    // allocate some video memory for texture palettes
    //    pCurrentContext->dwTexturePaletteStagingHandle =
    //    nvTMAllocTextureStagingSpace(256*sizeof(DWORD),
    //                                 &(pCurrentContext->dwTexturePaletteAddr),
    //                                 &(pCurrentContext->dwTexturePaletteOffset));
    NVHEAP_ALLOC(pCurrentContext->dwTexturePaletteAddr, 512*sizeof(DWORD), TYPE_IMAGE);
    if (!pCurrentContext->dwTexturePaletteAddr) dbgD3DError();
    pCurrentContext->dwTexturePaletteOffset =
        pCurrentContext->dwTexturePaletteAddr - pDriverData->BaseAddress;
#endif

#ifdef NV_PROFILE
    // Start up profiler
    nvpCreate();
#endif //NV_PROFILE

#ifdef NV_MARKER
    *(DWORD*)(pDriverData->BaseAddress) = 0xcccccccc;
#endif

    /*
     * Context creation complete, return successfully.
     */
    NV_D3D_GLOBAL_SAVE();
    pccd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}

DWORD __stdcall nvContextDestroy
(
    LPD3DHAL_CONTEXTDESTROYDATA pcdd
)
{

    /*
     * NOTES:
     * This callback is invoked when a context is to be destroyed.
     * Perform any cleanup required.
     *
     * Get pointer to context being destroyed.
     */
    pCurrentContext = (PNVD3DCONTEXT)pcdd->dwhContext;
    if (!pCurrentContext)
    {
        DPF_LEVEL (NVDBG_LEVEL_ERROR, "nvContextDestroy - Bad Context");
        pcdd->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Get pointer to global driver data structure.
     */
    NvSetDriverDataPtrFromContext(pCurrentContext);

    if (pDriverData->dwD3DContextCount == 0)
    {
        pcdd->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }

#ifdef NV_MARKER
    *(DWORD*)(pDriverData->BaseAddress) = 0xdddddddd;
#endif

    /*
     * push buffer disassembler
     */
#ifdef NV_DISASM
    {
        if (nvPusherFile)
        {
            CloseHandle (nvPusherFile);
            nvPusherFile = 0;
        }
    }
#endif

#ifdef NV_PROFILE
    /*
     * Shut down profiler
     */
    nvpDestroy();
#endif //NV_PROFILE

    /*
     * Shutdown Anti-Aliasing runtime
     */
    if (pCurrentContext->pAAContext) nvAADestroy();

    /*
     * Setup frequently accessed globals.
     */
    NV_D3D_GLOBAL_SETUP();

#ifdef NV_TETRIS
    /*
     * disable tetris tiling
     */
    nvTetrisTilingDisable (1/* dwBPP / 8 - 1 */,4 /* # lines for a 4:1 aspect tile */);
#endif

    /*
     * Destroy all textures associated with this context. The Win2K D3D runtimes
     * seem to dissociate textures from contexts, and will call nvTextureDestroy
     * for each texture created in the context. Thus under Win2K only we defer
     * destroying the textures created in this context.
     */
    nvDestroyTextureContext(pcdd->dwhContext);

    /*
     * Free any default texture associated with this context.
     */
    nvFreeDefaultTexture(pCurrentContext);

    if (pCurrentContext->pContextPrev)
        pCurrentContext->pContextPrev->pContextNext = pCurrentContext->pContextNext;
    if (pCurrentContext->pContextNext)
        pCurrentContext->pContextNext->pContextPrev = pCurrentContext->pContextPrev;
    if (pDriverData->dwContextListHead == (DWORD)pCurrentContext)
        pDriverData->dwContextListHead = (DWORD)pCurrentContext->pContextNext;
#ifndef OLDSTUFF
    HEAPFREE(pDriverData->hContexts_gbl, pCurrentContext);
#else
    HeapFree((HANDLE)pDriverData->hContexts_gbl, 0, (PVOID)pCurrentContext);
#endif
    pDriverData->dwD3DContextCount--;

    /*
     * If there are no more open D3D contexts.  Do any neccessary cleanup.
     */
    if (!pDriverData->dwD3DContextCount)
        nvFinalContextCleanup();

    /*
     * Reset the global context and texture handles.
     */
    pCurrentContext = NULL;
    pDriverData->dwCurrentContextHandle = 0;

    /*
     * Return successfully.
     */
    NV_D3D_GLOBAL_SAVE();
    pcdd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}
DWORD __stdcall nvContextDestroyAll
(
    LPD3DHAL_CONTEXTDESTROYALLDATA  pcdd
)
{
    PNVD3DCONTEXT   pContext     = 0;
    PNVD3DCONTEXT   pContextNext = 0;

    /*
     * BUGBUG WINNT only - We believe this is an obsolete fct and therefore
     * will never be called, therefore we don't worry about loading
     * pDriverData.
     */

    /*
     * This routine is legacy and will only ever be called in non-mulitmonitor
     * situations, so it's ok to trust what has been previously loaded into
     * pDriverData.
     */
    if (pDriverData->dwD3DContextCount == 0)
    {
        pcdd->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Setup frequently accessed globals.
     */
    NV_D3D_GLOBAL_SETUP();

    /*
     * NOTES:
     *
     * This callback is invoked when a process dies.  All the contexts
     * which were created by this context need to be destroyed.
     *
     * Destroy all valid texture's associated with this process ID.
     */
    nvDestroyTextureProcess(pcdd->dwPID);

    pContext = (PNVD3DCONTEXT)pDriverData->dwContextListHead;
    while (pContext)
    {
        pContextNext = pContext->pContextNext;
        if (pContext->pid == pcdd->dwPID)
        {
            if (pContext->pContextPrev)
                pContext->pContextPrev->pContextNext = pContext->pContextNext;
            if (pContext->pContextNext)
                pContext->pContextNext->pContextPrev = pContext->pContextPrev;
            if (pDriverData->dwContextListHead == (DWORD)pContext)
                pDriverData->dwContextListHead = (DWORD)pContext->pContextNext;

#ifndef OLDSTUFF
            HEAPFREE(pDriverData->hContexts_gbl, pContext);
#else
            HeapFree((HANDLE)pDriverData->hContexts_gbl, 0, pContext);
#endif
            pDriverData->dwD3DContextCount--;
        }
        pContext = pContextNext;
    }

    /*
     * If there are no more open D3D contexts.  Do any neccessary cleanup.
     */
    if (!pDriverData->dwD3DContextCount)
        nvFinalContextCleanup();

    /*
     * Reset the global context and texture handles.
     */
    pDriverData->dwCurrentContextHandle = 0;
    NV_D3D_GLOBAL_SAVE();
    pcdd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\D3drendr.c ===
/*
 * Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 * (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: D3DRENDR.C                                                        *
*   The Direct 3d Rendereing routines.                                      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/02/97 - re-wrote and cleaned up.     *
*       Ben de Waal (bdw)           11/06/97 - Linear MipMap xxx            *
*                                                                           *
\***************************************************************************/
#include <math.h>
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "d3dinc.h"
#include "nv3ddbg.h"

/*
 * Dma Pushing loop stats.
 */
DWORD   statDmaSyncLoop      = 0;
DWORD   statDmaSyncOverflow  = 0;
DWORD   statDmaBusyLoop      = 0;
DWORD   statDmaBusyOverflow  = 0;
DWORD   statDmaFlushLoop     = 0;
DWORD   statDmaFlushOverflow = 0;
#ifndef WINNT
/*
 * --------------------------------------------------------------------------
 * nvRenderState
 *
 * LPD3DHAL_RENDERSTATEDATA
 * - Points to the instruction in the execute buffer.
 *
 * We get the count of states to set and then walk the execute buffer
 * handling each one at a time.
 * --------------------------------------------------------------------------
 */
DWORD __stdcall nvRenderState
(
    LPD3DHAL_RENDERSTATEDATA    prd
)
{
    DWORD           i;
    LPBYTE          lpData;
    LPD3DSTATE      lpState;

    /*
     * NOTES:
     * This callback is invoked when a set of render states are changed.
     *
     * Get the pointer to the context this texture is associated with.
     */
    DPF_LEVEL (NVDBG_LEVEL_DDI_ENTRY, "nvRenderState - hContext = %08lx", prd->dwhContext);
    SET_CURRENT_CONTEXT(prd);

    /*
     * Get pointer to global driver. data structure.
     */
    NvSetDriverDataPtrFromContext(pCurrentContext);
    NV_D3D_GLOBAL_SETUP();

    /*
     *
     */
    lpData = (LPBYTE)(((LPDDRAWI_DDRAWSURFACE_INT)prd->lpExeBuf)->lpLcl->lpGbl->fpVidMem);
    for (i = 0, lpState = (LPD3DSTATE)(lpData + prd->dwOffset);
         i < prd->dwCount; i++, lpState++)
    {
        DWORD type = (DWORD) lpState->drstRenderStateType;

        if (IS_OVERRIDE(type))
        {
            DWORD override = GET_OVERRIDE(type);
            if (lpState->dwArg[0])
            {
                DPF_LEVEL (NVDBG_LEVEL_INFO, "nvRenderState - setting override for state %08lx", override);
                STATESET_SET(pCurrentContext->overrides, override);
            }
            else
            {
                DPF_LEVEL (NVDBG_LEVEL_INFO, "nvRenderState, clearing override for state %08lx", override);
                STATESET_CLEAR(pCurrentContext->overrides, override);
            }
            continue;
        }
        if (STATESET_ISSET(pCurrentContext->overrides, type))
        {
            DPF_LEVEL (NVDBG_LEVEL_INFO, "nvRenderState, state %08lx is overridden, ignoring", type);
            continue;
        }
        nvSetContextState(lpState->drstRenderStateType, lpState->dwArg[0], &prd->ddrval);
        if (prd->ddrval != DD_OK)
        {
            NV_D3D_GLOBAL_SAVE();
            return (DDHAL_DRIVER_HANDLED);
        }

    }
    NV_D3D_GLOBAL_SAVE();
    prd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}
#endif // #ifndef WINNT
DWORD __stdcall nvSetRenderTarget
(
    LPD3DHAL_SETRENDERTARGETDATA    psrtd
)
{
    LPDDRAWI_DDRAWSURFACE_LCL   lpLcl    = 0;
    LPDDRAWI_DDRAWSURFACE_LCL   lpLclZ   = 0;

    /*
     * Get the pointer to the context this texture is associated with.
     */
    DPF_LEVEL (NVDBG_LEVEL_DDI_ENTRY, "nvSetRenderTarget - hContext = %08lx", psrtd->dwhContext);
    SET_CURRENT_CONTEXT(psrtd);

    /*
     * Get pointer to global driver. data structure.
     */
    NvSetDriverDataPtrFromContext(pCurrentContext);

    /*
     * Set the new rendering surface into the D3D context.
     */
    if (!psrtd->lpDDS)
    {
        dbgD3DError();
        psrtd->ddrval = DDERR_CURRENTLYNOTAVAIL;
        return (DDHAL_DRIVER_HANDLED);
    }
    if (!(lpLcl = DDS_LCL(psrtd->lpDDS)))
    {
        dbgD3DError();
        psrtd->ddrval = DDERR_CURRENTLYNOTAVAIL;
        return (DDHAL_DRIVER_HANDLED);
    }
    if (psrtd->lpDDSZ)
        lpLclZ = DDS_LCL(psrtd->lpDDSZ);

    /*
     * Check for an invalid rendering and ZETA sufaces
     * (i.e. system memory surface)
     */
    if (lpLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
    {
        dbgD3DError();
        psrtd->ddrval = DDERR_CURRENTLYNOTAVAIL;
        return (DDHAL_DRIVER_HANDLED);
    }
    if (lpLclZ
     && (lpLclZ->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY))
    {
        dbgD3DError();
        psrtd->ddrval = DDERR_CURRENTLYNOTAVAIL;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Set the Rendering and Zeta surfaces into the D3D context.
     */
    pCurrentContext->lpLcl  = lpLcl;
    pCurrentContext->lpLclZ = lpLclZ;

    /*
     * Call the hardware specific context surface setup.
     */
    if (!nvSetContextSurface(pCurrentContext))
    {
        /*
         * Generally the only way this fails if if a stencil buffer is
         * being used with a 16 bit rendering target.
         */
        dbgD3DError();
        psrtd->ddrval = DDERR_INVALIDPIXELFORMAT;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Return invalid pixel format if the z-buffer depth does not match the render target depth.
     */
    if (pCurrentContext->dwContextFlags & NV_CONTEXT_ZETA_BUFFER_MISMATCH)
    {
        dbgD3DError();
        psrtd->ddrval = DDERR_INVALIDPIXELFORMAT;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Return successfully.
     */
    psrtd->ddrval = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\d3danti.c ===
#ifdef NV4
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: D3DANTI.C                                                         *
*   AntiAliased Triangles                                                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal (bdw)           04/27/97 - NV4 port                     *
*                                                                           *
\***************************************************************************/

#include <math.h>
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "d3dinc.h"
#include "nv3ddbg.h"
#include "nvddobj.h"
#include "nv4vxmac.h"
#include "nvheap.h"

/*****************************************************************************

SuperSampled AA Algorithm:

  * Calls to Clear only logs the color and zbuffer value
  * Calls to render geometry are captured and sorted into buckets. nothing
     is rendered at this point
  * All state are logged as well
  * at EndScene we render the buckets one by one into the super buffer and
     filter it down to screen.
  * ZBuffer will be corrupt at EndScene.

Limitations:
  * Multiple Begin/EndScene apps that rely on z-buffer will not work
  * Texture destroy or blts during the scene will corrupt at playback time
     since the texels are not captured

******************************************************************************

Edge AA Algorithm:

  * Calls to clear are performed normally
  * Calls to render geometry are captured and also rendered. Edges are
     placed in tables for 2nd pass (only for triangles that do not
     alpha blend)
  * All state are logged
  * At EndScene we render the edges as quads
  * ZBuffer will be okay

Limitations:
  * Multiple Begin/EndScene apps with 2d in between will occationally have
     edges appear over 2D.
  * Texture destroy or blts during the scene will corrupt edges at playback
     time since the texels are not captured

*****************************************************************************/

/*
 * constants
 */
#define AA_ALIGNPITCH                       32
#define AA_MIN                              -2047.0f
#define AA_MAX                               2047.0f

#define VF_NEGX                             0x00000001
#define VF_POSX                             0x00000002
#define VF_NEGY                             0x00000004
#define VF_POSY                             0x00000008
#define VF_OUTCODEMASK                      0x0000000f
#define VF_RESTORE                          0x80000000

/*
 * macros
 */
#define AA_ALLOC(x)                         while ((dwIndex + (x)) >= dwSize) { dwSize += 4096; dwAddr=(DWORD)ReallocIPM((void*)dwAddr,dwSize); if (!dwAddr) return FALSE; }
#define AACOMBINE(a,b)                      (((a)<<16)|(b))
#define ISDX6(x)                            ((x) == ((sizeDx6TriangleTLVertex - 1) * 4))

#define IF_NOT_CULLED_BEGIN(v0,v1,v2,cv) {             \
    DWORD _sx0  = v0 + 0;                              \
    DWORD _sy0  = v0 + 4;                              \
    DWORD _sx1  = v1 + 0;                              \
    DWORD _sy1  = v1 + 4;                              \
    DWORD _sx2  = v2 + 0;                              \
    DWORD _sy2  = v2 + 4;                              \
    float _dx10 = *(float*)_sx1 - *(float*)_sx0;       \
    float _dy10 = *(float*)_sy1 - *(float*)_sy0;       \
    float _dx20 = *(float*)_sx2 - *(float*)_sx0;       \
    float _dy20 = *(float*)_sy2 - *(float*)_sy0;       \
           cv   = _dx10*_dy20  - _dx20*_dy10;          \
    if (((*(DWORD*)&cv) ^ dwCullMask1) & dwCullMask2) {
#define IF_NOT_CULLED_END } }

/*
 * externals
 */
#ifndef WINNT
FLATPTR EXTERN_DDAPI DDHAL32_VidMemAlloc  (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, DWORD dwXDim, DWORD dwYDim);
void    EXTERN_DDAPI DDHAL32_VidMemFree   (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, FLATPTR ptr);
#endif
void nvSetClearSurface  (DWORD,DWORD,DWORD,DWORD,DWORD);
void nvClearSurfaceRect (DWORD,DWORD,DWORD,DWORD);
void nvReset2DSurfaceFormat (void);
void nvAASingleChunkRenderPrimitive (DWORD,LPWORD,DWORD,LPBYTE);

/*
 * tables
 */
typedef struct
{
    float fScaleX;
    float fScaleY;
    DWORD dwSrcPass1;
    DWORD dwDXPass1;
    DWORD dwDYPass1;
    DWORD dwSrcPass2;
    DWORD dwDXPass2;
    DWORD dwDYPass2;
    DWORD dwDU;
    DWORD dwDV;
} NVAATABLE;

NVAATABLE nvAATable[] =
{
    //* test */{ 1.0f, 1.0f, 0x00000000,(1<<20),(1<<20), 0,0,0 },
    /*0*/ { 2.0f, 1.0f, 0x00000008,(2<<20),(1<<20), 0,0,0,                      (1<<20)/2,(1<<20)/1}, // 2x1
    /*1*/ { 2.0f, 2.0f, 0x00080008,(2<<20),(2<<20), 0,0,0,                      (1<<20)/2,(1<<20)/2}, // 2x2
    /*2*/ { 3.0f, 2.0f, 0x00000008,(1<<20),(1<<20), 0x00080008,(3<<20),(2<<20), (1<<20)/3,(1<<20)/2}, // 3x2
    /*3*/ { 3.0f, 3.0f, 0x00080008,(1<<20),(1<<20), 0x00080008,(3<<20),(3<<20), (1<<20)/3,(1<<20)/3}, // 3x3
    /*4*/ { 4.0f, 2.0f, 0x00080008,(2<<20),(2<<20), 0x00000008,(2<<20),(1<<20), (1<<20)/4,(1<<20)/2}, // 4x2
    /*5*/ { 4.0f, 3.0f, 0x00000008,(1<<20),(1<<20), 0x00080008,(2<<20),(3<<20), (1<<20)/4,(1<<20)/3}, // 4x3
    /*6*/ { 4.0f, 4.0f, 0x00080008,(2<<20),(2<<20), 0x00080008,(2<<20),(2<<20), (1<<20)/4,(1<<20)/4}  // 4x4
};

/*
 * nvAACreate
 *
 * creates an AA context - called at createContext time
 */
BOOL nvAACreate
(
    void
)
{
    PNVAACONTEXT pCtx;

    DPF_LEVEL (NVDBG_LEVEL_FUNCTION_CALL, "nvAACreate");

    /*
     * assume AA unavailable
     */
    pCurrentContext->pAAContext       = NULL;
    pCurrentContext->dwAntiAliasFlags = 0;

    /*
     * allocate aa context memory
     */
    pCtx = pCurrentContext->pAAContext = (NVAACONTEXT*)AllocIPM(sizeof(NVAACONTEXT));
    if (!pCtx)
    {
        DPF_LEVEL (NVDBG_LEVEL_ERROR,"nvAACreate: failed to allocate AA Context");
        return FALSE;
    }

    /*
     * setup super sampling constants
     */
    pCtx->dwAASuperMode = pDriverData->regAAMethod;
    pCtx->fAAScaleX     = nvAATable[pCtx->dwAASuperMode].fScaleX;
    pCtx->fAAScaleY     = nvAATable[pCtx->dwAASuperMode].fScaleY;

    /*
     * initialize context
     */
    pCtx->dwChunkWidth  = pCurrentContext->lpLcl->lpGbl->wWidth  / (DWORD)pCtx->fAAScaleX;
    pCtx->dwSuperWidth  = pCurrentContext->lpLcl->lpGbl->wWidth;//pCtx->dwChunkWidth  * (DWORD)pCtx->fAAScaleX;
    pCtx->dwChunkHeight = pCurrentContext->lpLcl->lpGbl->wHeight / (DWORD)pCtx->fAAScaleY;
    pCtx->dwSuperHeight = pCurrentContext->lpLcl->lpGbl->wHeight;//pCtx->dwChunkHeight * (DWORD)pCtx->fAAScaleY;
    if (pCurrentContext->lpLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT)
        pCtx->dwBPP     = pCurrentContext->lpLcl->lpGbl->ddpfSurface.dwRGBBitCount / 8;
    else
        pCtx->dwBPP     = pDriverData->bi.biBitCount / 8;
    pCtx->dwCFill       = 0x00000000;
    pCtx->dwZFill       = 0xffffffff;

    /*
     * success
     */
    return TRUE;
}

/*
 * nvAADestroy
 *
 * free up AA context memory
 */
void nvAADestroy
(
    void
)
{
    PNVAACONTEXT pCtx;

    DPF_LEVEL (NVDBG_LEVEL_FUNCTION_CALL, "nvAADestroy");

    /*
     * get context
     */
    pCtx = pCurrentContext->pAAContext;

    /*
     * free surface memory (if any)
     */
    if (pCtx->dwSuperAddr)
    {
        NVHEAP_FREE(pCtx->dwSuperAddr);
    }

    /*
     * free capture memory
     */
    if (pCtx->dwCapAddr)
    {
        FreeIPM ((void*)(pCtx->dwCapAddr));
    }

    /*
     * free context memory
     */
    FreeIPM (pCtx);

    /*
     * tag AA unavailable
     */
    pCurrentContext->pAAContext       = NULL;
    pCurrentContext->dwAntiAliasFlags = 0;
}

/*
 * nvAACreateBuffers
 *
 * create buffers for AA
 */
BOOL nvAACreateBuffers
(
    void
)
{
    PNVAACONTEXT pCtx;

    DPF_LEVEL (NVDBG_LEVEL_FUNCTION_CALL, "nvAACreateBuffers");

    /*
     * get context
     */
    pCtx = pCurrentContext->pAAContext;

    /*
     * assume buffers not allocated
     */
    pCurrentContext->dwAntiAliasFlags &= ~AA_BUFALLOC_MASK;

    switch (pCurrentContext->dwAntiAliasFlags & AA_ENABLED_MASK)
    {
        /*
         * allocate super sampled buffers
         */
        case AA_MODE_SUPER:
        case AA_MODE_SINGLECHUNK: // not selectable from registry - automatic detection
            {
                DWORD dwSize;

                /*
                 * attempt to allocate the whole super buffer for single-chunk super-sampled aa
                 */
                {
                    DWORD dwSCWidth;
                    DWORD dwSCHeight;
                    DWORD dwSCPitch;
                    DWORD dwSCFAddr = 0;
                    DWORD dwSCZAddr = 0;

                    /*
                     * calc width & check if it will fit to HW limits for single chunk
                     */
                    dwSCWidth = pCtx->dwSuperWidth * (DWORD)pCtx->fAAScaleX;
                    if (dwSCWidth <= AA_MAX)
                    {
                        dwSCHeight = pCtx->dwSuperHeight * (DWORD)pCtx->fAAScaleY;
                        dwSCPitch = ((dwSCWidth * pCtx->dwBPP) + AA_ALIGNPITCH - 1) & ~(AA_ALIGNPITCH - 1);
                        dwSize    = dwSCPitch * dwSCHeight;
                        NVHEAP_ALLOC (dwSCFAddr,dwSize,TYPE_IMAGE);
                        if (dwSCFAddr)
                        {
                            NVHEAP_ALLOC (dwSCZAddr,dwSize,TYPE_DEPTH);
                            if (dwSCZAddr)
                            {
                                /*
                                 * enough memory present - select SCSSAA
                                 */
                                pCtx->dwChunkWidth   = pCtx->dwSuperWidth;   // the window width
                                pCtx->dwSuperWidth   = dwSCWidth;            // scaled width
                                pCtx->dwChunkHeight  = pCtx->dwSuperHeight;  // the window height
                                pCtx->dwSuperHeight  = dwSCHeight;           // scaled height

                                pCtx->dwSuperAddr    = dwSCFAddr;
                                pCtx->dwSuperZAddr   = dwSCZAddr;
                                pCtx->dwSuperOffset  = dwSCFAddr - pDriverData->BaseAddress;
                                pCtx->dwSuperZOffset = dwSCZAddr - pDriverData->BaseAddress;
                                pCtx->dwSuperPitch   = dwSCPitch;
                                pCtx->dwSuperZPitch  = dwSCPitch;

                                /*
                                 * tag buffers allocated
                                 */
                                pCurrentContext->dwAntiAliasFlags &= ~AA_ENABLED_MASK;
                                pCurrentContext->dwAntiAliasFlags |=  AA_MODE_SINGLECHUNK
                                                                  |   AA_BUFALLOC_SINGLECHUNK
                                                                  |   AA_CLEAR_SCREEN;

                                /*
                                 * clear the buffers - courtesy to app
                                 */
                                memset ((void*)pCtx->dwSuperAddr,0,dwSize);
                                memset ((void*)pCtx->dwSuperZAddr,0xff,dwSize);

                                /*
                                 * success
                                 */
                                return TRUE;
                            }
                            else
                            {
                                /*
                                 * free frame buffer
                                 */
                                NVHEAP_FREE (dwSCFAddr);
                                dwSCFAddr = 0;
                            }
                        }
                    }
                }

                /*
                 * compute super buffer size for chunking super sampled AA
                 */
                pCtx->dwSuperPitch = ((pCtx->dwSuperWidth * pCtx->dwBPP) + AA_ALIGNPITCH - 1) & ~(AA_ALIGNPITCH - 1);
                dwSize             = pCtx->dwSuperPitch * pCtx->dwSuperHeight;

                /*
                 * allocate the buffer (allow for alignment)
                 */
                NVHEAP_ALLOC (pCtx->dwSuperAddr,dwSize,TYPE_IMAGE);
                if (!pCtx->dwSuperAddr)
                {
                    /*
                     * fail to allocate memory
                     */
                    return FALSE;
                }

                /*
                 * setup super surface
                 */
                pCtx->dwSuperOffset = pCtx->dwSuperAddr - pDriverData->BaseAddress;

                /*
                 * tag buffers allocated
                 */
                pCurrentContext->dwAntiAliasFlags |= AA_BUFALLOC_SUPER
                                                  |  AA_CLEAR_SCREEN;
            }
            break;
        /*
         * allocate edge buffers
         */
        case AA_MODE_EDGE:
            {
            }
            return FALSE;
            // aatodo - implement

            /*
             * tag buffers allocated
             */
            pCurrentContext->dwAntiAliasFlags |= AA_BUFALLOC_EDGE;
            break;
    }

    /*
     * allocate geometry capture area
     */
    pCtx->dwCapIndex = 0;
    pCtx->dwCapSize  = 4096;
    pCtx->dwCapAddr  = (DWORD)AllocIPM(pCtx->dwCapSize);
    if (!pCtx->dwCapAddr)
    {
        /*
         * not enough memory - fail
         */
        pCurrentContext->dwAntiAliasFlags &= ~AA_BUFALLOC_MASK;
        return FALSE;
    }

    /*
     * success
     */
    return TRUE;
}

/*
 * nvAACapturePrimitive
 *
 * capture triangles for 2nd pass. aa mode == edge will pass this batch
 * through to be rendered as well.
 */
BOOL __stdcall nvAACapturePrimitive
(
    DWORD  nPrimCount,
    LPWORD pIndices,        // NULL for non-indexed cases
    DWORD  dwStrides,
    LPBYTE pVertices
)
{
    PNVAACONTEXT pCtx;
    DWORD        dwOldFifo;
    DWORD        dwOldFreeCount;
#ifndef NV_FASTLOOPS
    DWORD        dwFlags;
#endif

    DPF_LEVEL (NVDBG_LEVEL_FUNCTION_CALL, "nvAACapturePrimitive");
    DPF_LEVEL (NVDBG_LEVEL_AA_INFO,"nvAACapturePrimitive: aa = %08x",pCurrentContext->dwAntiAliasFlags);

    /*
     * check for single-chunking
     */
    if (pCurrentContext->dwAntiAliasFlags & AA_MODE_SINGLECHUNK)
    {
        /*
         * render triangles
         */
        nvAASingleChunkRenderPrimitive (nPrimCount,pIndices,dwStrides,pVertices);

        /*
         * success
         */
        return TRUE;
    }

    /*
     * get context
     */
    pCtx = pCurrentContext->pAAContext;

    /*
     * override fifo
     */
    dwOldFifo      = (DWORD)nvFifo;
    dwOldFreeCount = nvFreeCount;
    nvFifo         = pCtx->dwCapAddr + pCtx->dwCapIndex;
    nvFreeCount    = (pCtx->dwCapSize - pCtx->dwCapIndex) >> 2;
#ifndef NV_FASTLOOPS
    dwFlags        = _CALC_FUNCTION_INDEX(pCurrentContext);
#endif

    /*
     * start fifo capture
     */
    pCurrentContext->dwAntiAliasFlags |= AA_CAPTURE_PUSHBUFFER;

    /*
     * render
     */
    pDriverData->dDrawSpareSubchannelObject = 0;

#ifndef NV_FASTLOOPS
    if (pCurrentContext->bUseDX6Class)
    {
        /*
         * force state load
         */
        nvSetDx6MultiTextureState(pCurrentContext);
        /*
         * dispatch triangles
         */
        if (pIndices)
            fnDX6FlexIndexedTable[dwFlags](nPrimCount,pIndices,dwStrides,pVertices);
        else
            fnDX6FlexTable[dwFlags]((WORD)nPrimCount,dwStrides,pVertices);
    }
    else
    {
        /*
         * force state load
         */
        nvSetDx5TriangleState(pCurrentContext);
        /*
         * dispatch triangles
         */
        if (pIndices)
            fnDX5FlexIndexedTable[dwFlags](nPrimCount,pIndices,dwStrides,pVertices);
        else
            fnDX5FlexTable[dwFlags]((WORD)nPrimCount,dwStrides,pVertices);
    }
#else //NV_FASTLOOPS
    /*
     * force state update
     */
    pCurrentContext->dwStateChange    = TRUE;
    pCurrentContext->dwFunctionLookup = NV_SETUP_FUNCTION_INDEX;
    /*
     * draw them
     */
    nvTriangleDispatch(nPrimCount,pIndices,dwStrides,pVertices);
    /*
     * force innerloop reset since the capturing spoofed the index
     */
    pCurrentContext->dwFunctionLookup = NV_SETUP_FUNCTION_INDEX;
#endif //NV_FASTLOOPS

    /*
     * reset fifo
     */
    pCurrentContext->dwAntiAliasFlags &= ~AA_CAPTURE_PUSHBUFFER;
    pCtx->dwCapIndex = nvFifo - pCtx->dwCapAddr;
    nvFifo           = dwOldFifo;
    nvFreeCount      = dwOldFreeCount;

    /*
     * kill subchannel
     */
    pDriverData->dDrawSpareSubchannelObject = 0;

    /*
     * success
     */
    return TRUE;
}

/*
 * nvAABlt
 *
 * Arbitrary filter blt
 */
void __inline nvAABlt
(
    DWORD dwSrcOffset,
    DWORD dwSrcPitch,
    DWORD dwSrcYX,          // 12.4 12.4
    DWORD dwSrcHW,
    DWORD dwDstOffset,
    DWORD dwDstPitch,
    DWORD dwDstYX,
    DWORD dwDstHW,
    DWORD dwClpYX,
    DWORD dwClpHW,
    DWORD dwDUDX,
    DWORD dwDVDY,
    DWORD dwFormat
)
{
    while (nvFreeCount < 21) nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, 21);
    *(DWORD*)(nvFifo+ 0) = dDrawSubchannelOffset(NV_DD_ROP) + SET_ROP_OFFSET | 0x40000;
    *(DWORD*)(nvFifo+ 4) = SRCCOPYINDEX;
    *(DWORD*)(nvFifo+ 8) = dDrawSubchannelOffset(NV_DD_SURFACES) + SURFACES_2D_DEST_OFFSET | 0x40000;
    *(DWORD*)(nvFifo+12) = dwDstOffset;
    *(DWORD*)(nvFifo+16) = dDrawSubchannelOffset(NV_DD_SURFACES) + SURFACES_2D_PITCH_OFFSET | 0x40000;
    *(DWORD*)(nvFifo+20) = (dwDstPitch << 16) | dwSrcPitch;
    *(DWORD*)(nvFifo+24) = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;
    *(DWORD*)(nvFifo+28) = NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
    *(DWORD*)(nvFifo+32) = dDrawSubchannelOffset(NV_DD_STRETCH) + SCALED_IMAGE_CLIPPOINT_OFFSET | 0x80000;
    *(DWORD*)(nvFifo+36) = dwClpYX;                  // clip point
    *(DWORD*)(nvFifo+40) = dwClpHW;                  // clip size
    *(DWORD*)(nvFifo+44) = dDrawSubchannelOffset(NV_DD_STRETCH) + SCALED_IMAGE_IMAGE_OUT_POINT_OFFSET | 0x100000;
    *(DWORD*)(nvFifo+48) = dwDstYX;                  // dst point
    *(DWORD*)(nvFifo+52) = dwDstHW;                  // dst size
    *(DWORD*)(nvFifo+56) = dwDUDX;                   // dudx
    *(DWORD*)(nvFifo+60) = dwDVDY;                   // dvdy
    *(DWORD*)(nvFifo+64) = dDrawSubchannelOffset(NV_DD_STRETCH) + SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET | 0x100000;
    *(DWORD*)(nvFifo+68) = dwSrcHW;                  // src size
    *(DWORD*)(nvFifo+72) = dwSrcPitch | dwFormat; // src format
    *(DWORD*)(nvFifo+76) = dwSrcOffset;              // src offset
    *(DWORD*)(nvFifo+80) = dwSrcYX;                  // src point x.4
    nvFifo      += 84;
    nvFreeCount -= 21;

    pDriverData->dDrawSpareSubchannelObject = 0;
    //pDriverData->TwoDRenderingOccurred   = TRUE;
    pDriverData->ThreeDRenderingOccurred = 0;
}

/*
 * nvAACut
 *
 * subdivides an edge in 2. with t==0 c=a, t==1 c=b.
 */
void __inline nvAACut
(
    float t,
    DWORD len,
    DWORD a,
    DWORD b,
    DWORD c
)
{
    PREFETCH (a);
    PREFETCH (b);

    /*
     * boundary cases
     */
    if (t <= 0.0f)
    {
        memcpy ((void*)c,(void*)a,len);
        return;
    }
    if (t >= 1.0f)
    {
        memcpy ((void*)c,(void*)b,len);
        return;
    }

    /*
     * harder (real-world) case
     */
    if (ISDX6(len))
    {
        PREFETCH (a+32);
        PREFETCH (b+32);
    }
    {
        float nt   = 1.0f - t;
        float w,rhw,rhw0,rhw1;

        /*
         * sx,sy,sz
         */
        *(float*)(c+0) = nt * (*(float*)(a+0)) + t * (*(float*)(b+0));
        *(float*)(c+4) = nt * (*(float*)(a+4)) + t * (*(float*)(b+4));
        *(float*)(c+8) = nt * (*(float*)(a+8)) + t * (*(float*)(b+8));

        /*
         * 1/w aka rhw
         */
        rhw0 = *(float*)(a+12);
        rhw1 = *(float*)(b+12);
        *(float*)(c+12) = rhw = nt * rhw0 + t * rhw1;
        w   = (rhw == 0.0f) ? 1.0f : (1.0f / rhw);
        t  *= w * rhw1;
        nt *= w * rhw0;

        /*
         * color
         */
        {
            DWORD v0 = *(DWORD*)(a+16);
            DWORD v1 = *(DWORD*)(b+16);
            if (v0 == v1)
            {
                *(DWORD*)(c+16) = v0;
            }
            else
            {
                DWORD a = 0xff000000 & (DWORD)(nt * (float)(v0 & 0xff000000) + t * (float)(v1 & 0xff000000));
                DWORD r = 0x00ff0000 & (DWORD)(nt * (float)(v0 & 0x00ff0000) + t * (float)(v1 & 0x00ff0000));
                DWORD g = 0x0000ff00 & (DWORD)(nt * (float)(v0 & 0x0000ff00) + t * (float)(v1 & 0x0000ff00));
                DWORD b = 0x000000ff & (DWORD)(nt * (float)(v0 & 0x000000ff) + t * (float)(v1 & 0x000000ff));
                *(DWORD*)(c+16) = a | r | g | b;
            }
        }

        /*
         * specular
         */
        {
            DWORD v0 = *(DWORD*)(a+20);
            DWORD v1 = *(DWORD*)(b+20);
            if (v0 == v1)
            {
                *(DWORD*)(c+20) = v0;
            }
            else
            {
                DWORD a = 0xff000000 & (DWORD)(nt * (float)(v0 & 0xff000000) + t * (float)(v1 & 0xff000000));
                DWORD r = 0x00ff0000 & (DWORD)(nt * (float)(v0 & 0x00ff0000) + t * (float)(v1 & 0x00ff0000));
                DWORD g = 0x0000ff00 & (DWORD)(nt * (float)(v0 & 0x0000ff00) + t * (float)(v1 & 0x0000ff00));
                DWORD b = 0x000000ff & (DWORD)(nt * (float)(v0 & 0x000000ff) + t * (float)(v1 & 0x000000ff));
                *(DWORD*)(c+20) = a | r | g | b;
            }
        }

        /*
         * uv0
         */
        *(float*)(c+24) = nt * (*(float*)(a+24)) + t * (*(float*)(b+24));
        *(float*)(c+28) = nt * (*(float*)(a+28)) + t * (*(float*)(b+28));

        /*
         * uv1
         */
        if (ISDX6(len))
        {
            *(float*)(c+32) = nt * (*(float*)(a+32)) + t * (*(float*)(b+32));
            *(float*)(c+36) = nt * (*(float*)(a+36)) + t * (*(float*)(b+36));
        }
    }
}

/*
 * nvAAClip
 *
 * clip triangle to AA_MIN - AA_MAX
 */
void __inline nvAAClip
(
    DWORD i0,
    DWORD i1,
    DWORD i2,
    DWORD len,
    float *XYCache,
    DWORD *VCache,
    DWORD *VFlags
)
{
    DWORD vertex[2 * 6 * 16];
    DWORD *vx0,*vx1,vm0,vm1;
    DWORD o,e,i;

    /*
     * trivial reject
     */
    if (VFlags[i0] & VFlags[i1] & VFlags[i2] & VF_OUTCODEMASK) return;

    /*
     * do the evil copy of vertices. Really simplifies coding. Viva Data Cache.
     */
    vertex[0*16 + 0] = *(DWORD*)&XYCache[i0*2+0];
    vertex[0*16 + 1] = *(DWORD*)&XYCache[i0*2+1];
    memcpy (vertex + 0*16 + 2,(void*)(VCache[i0]+8),len-8);
    vertex[1*16 + 0] = *(DWORD*)&XYCache[i1*2+0];
    vertex[1*16 + 1] = *(DWORD*)&XYCache[i1*2+1];
    memcpy (vertex + 1*16 + 2,(void*)(VCache[i1]+8),len-8);
    vertex[2*16 + 0] = *(DWORD*)&XYCache[i2*2+0];
    vertex[2*16 + 1] = *(DWORD*)&XYCache[i2*2+1];
    memcpy (vertex + 2*16 + 2,(void*)(VCache[i2]+8),len-8);

    /*
     * setup
     */
    vx0 = vertex + 0*16;
    vm0 = 3;
    vx1 = vertex + 6*16;
    vm1 = 0;
    o   = (VFlags[i0] | VFlags[i1] | VFlags[i2]) & VF_OUTCODEMASK;

    /*
     * for four edges
     */
    for (e=1; e<16; e<<=1)
    {
        /*
         * quick edge clip reject
         */
        if (!(o & e))
            continue;

        /*
         * traverse triangle
         */
        for (i=0; i<vm0; i++)
        {
            float edge;
            DWORD index;
            DWORD j  = (i+1) % vm0;
            float *vi = ((float*)vx0) + i*16;
            float *vj = ((float*)vx0) + j*16;
            DWORD oi = 0;
            DWORD oj = 0;

            /*
             * determine outcodes
             */
            switch (e)
            {
                case 1: if (vi[0] < AA_MIN) oi=1;
                        if (vj[0] < AA_MIN) oj=1;
                        edge = AA_MIN; index = 0;
                        break;
                case 2: if (vi[0] > AA_MAX) oi=1;
                        if (vj[0] > AA_MAX) oj=1;
                        edge = AA_MAX; index = 0;
                        break;
                case 4: if (vi[1] < AA_MIN) oi=1;
                        if (vj[1] < AA_MIN) oj=1;
                        edge = AA_MIN; index = 1;
                        break;
                case 8: if (vi[1] > AA_MAX) oi=1;
                        if (vj[1] > AA_MAX) oj=1;
                        edge = AA_MAX; index = 1;
                        break;
            }

            /*
             * outside-outside
             */
            if (oi && oj)
            {
                continue;
            }

            /*
             * inside-outside or outside-inside
             */
            if (oi != oj) // (!oi && oj) || (oi && !oj)
            {
                if (vj[index] > vi[index])
                {
                    float t = vj[index] - vi[index];
                          t = (t == 0.0f) ? 0.5f : ((edge - vi[index]) / t);
                    nvAACut (t,len,(DWORD)vi,(DWORD)vj,(DWORD)&vx1[vm1*16]);
                    vm1++;
                }
                else
                {
                    float t = vi[index] - vj[index];
                          t = (t == 0.0f) ? 0.5f : ((edge - vj[index]) / t);
                    nvAACut (t,len,(DWORD)vj,(DWORD)vi,(DWORD)&vx1[vm1*16]);
                    vm1++;
                }
            }

            /*
             * inside-inside or outside-inside
             */
            if (!oj) // (!oi && !oj) || (oi && !oj)
            {
                memcpy (&vx1[vm1*16],vj,len);
                vm1++;
            }
        }

        /*
         * early exit
         */
        if (vm1 < 3) return;

        /*
         * next edge
         */
        {
            DWORD *t = vx0; vx0 = vx1; vx1 = t;
        }
        vm0 = vm1;
        vm1 = 0;
    }

    /*
     * now that we have clipped - emit triangle fan
     */
    {
        DWORD f[16]; // table to make sure we do not punt used vertices
        DWORD m = ISDX6(len) ? 7 : 15;
        DWORD launch;

        /*
         * tag all as unused
         */
        memset (f,0,sizeof(f));

        /*
         * for all vertices in clipped polygon
         */
        for (i=0; i<vm0; i++)
        {
            DWORD j;

            /*
             * displace vertex entry
             */
            for (j=m; j>0; j--)
            {
                /*
                 * find 1) an uninitialized or 2) invalid entry or 3) an entry that needs restoring already
                 */
                if (!f[j] && (!VCache[j] || VFlags[j]))
                {
                    /*
                     * tag as used & no need to restore
                     */
                    f[j] = 1;
                    goto emit;
                }
            }
            for (j=m; j>0; j--)
            {
                /*
                 * find any entry that we haven't used before
                 */
                if (!f[j])
                {
                    /*
                     * tag as used & need restore
                     */
                    f[j] = 1;
                    VFlags[j] |= VF_RESTORE;
                    goto emit;
                }
            }
            /*
             * control cannot go here unless we clip a triangle into more than 15 vertices and
             *  since we only have 4 clip planes you cannot end up with more than 6.
             * j == 0 at this point which will not cause a crash but will cause degenerate
             *  triangles.
             */
#ifdef DEBUG
            __asm int 3;
#endif

            /*
             * emit vertex
             */
        emit:
            if (ISDX6(len))
            {
                while (nvFreeCount < sizeDx6TriangleTLVertex)
                    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeDx6TriangleTLVertex);
                *(DWORD*)(nvFifo + 0) = ((sizeDx6TriangleTLVertex-1)<<18) | ((NV_DD_SPARE)<<13) | NV055_TLMTVERTEX((j));
                memcpy ((void*)(nvFifo+4),vx0+i*16,len);
                nvFifo      += sizeDx6TriangleTLVertex * 4;
                nvFreeCount -= sizeDx6TriangleTLVertex;
            }
            else
            {
                while (nvFreeCount < sizeDx5TriangleTLVertex)
                    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeDx5TriangleTLVertex);
                *(DWORD*)(nvFifo + 0) = ((sizeDx5TriangleTLVertex-1)<<18) | ((NV_DD_SPARE)<<13) | NV054_TLVERTEX((j));
                memcpy ((void*)(nvFifo+4),vx0+i*16,len);
                nvFifo      += sizeDx5TriangleTLVertex * 4;
                nvFreeCount -= sizeDx5TriangleTLVertex;
            }
            /*
             * store launch codes & launch if needed
             */
            if (i==0)
                launch  = j << 8;
            else
            if (i==1)
                launch |= j << 4;
            else
            {
                launch |= j;
                // note: assume sizeDx5TriangleDrawPrimitive == sizeDx6TriangleDrawPrimitive
                while (nvFreeCount < sizeDx5TriangleDrawPrimitive)
                    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeDx5TriangleDrawPrimitive);
                if (ISDX6(len))
                {
                    nvglDx6TriangleDrawPrimitive (nvFifo, nvFreeCount, NV_DD_SPARE, 0, launch);
                }
                else
                {
                    nvglDx5TriangleDrawPrimitive (nvFifo, nvFreeCount, NV_DD_SPARE, 0, launch);
                }
                launch = (launch & 0xf00) | (j << 4);
            }
        }
    }
}

/*
 * nvAARenderPrimitive
 *
 * play back captured data - called at endScene
 */
BOOL nvAARenderPrimitive
(
    void
)
{
    PNVAACONTEXT pCtx;
    DWORD        dwAddr;
    DWORD        dwIndex;
    DWORD        dwScreenOffset;
    DWORD        dwScreenPitch;
    DWORD        dwScreenHW;
    DWORD        dwScreenYX;
    DWORD        dwSuperHW;
    DWORD        dwChunkHW;
    DWORD        dwClipYX;
    DWORD        dwClipHW;
    float        fAAScaleX;
    float        fAAScaleY;
    float        fAAOffsetX;
    float        fAAOffsetY;

    DPF_LEVEL (NVDBG_LEVEL_FUNCTION_CALL, "nvAARenderPrimitive");
    DPF_LEVEL (NVDBG_LEVEL_AA_INFO,"nvAARenderPrimitive: aa = %08x",pCurrentContext->dwAntiAliasFlags);

    /*
     * get context
     */
    pCtx           = pCurrentContext->pAAContext;

    /*
     * get state
     */
    dwAddr         = pCtx->dwCapAddr;
    dwIndex        = pCtx->dwCapIndex;
    dwScreenOffset = pCurrentContext->dwSurfaceOffset;
    dwScreenPitch  = pCurrentContext->surfacePitch.wColorPitch;
    dwScreenHW     = AACOMBINE(pCurrentContext->lpLcl->lpGbl->wHeight,pCurrentContext->lpLcl->lpGbl->wWidth);
    dwSuperHW      = AACOMBINE(pCtx->dwSuperHeight,pCtx->dwSuperWidth);
    dwChunkHW      = AACOMBINE(pCtx->dwChunkHeight,pCtx->dwChunkWidth);
    fAAScaleX      = pCtx->fAAScaleX;
    fAAScaleY      = pCtx->fAAScaleY;
    dwClipYX       = AACOMBINE(pCurrentContext->surfaceViewport.clipVertical.wY,pCurrentContext->surfaceViewport.clipHorizontal.wX);
    dwClipHW       = AACOMBINE(pCurrentContext->surfaceViewport.clipVertical.wHeight,pCurrentContext->surfaceViewport.clipHorizontal.wWidth);

    /*
     * get an accurate freecount reading
     */
/*
    nvFreeCount = nvGetDmaFreeCount(1);
*/

/*
    //early abort
    pCtx->dwCapIndex = 0;
    return 1;
/**/

    /*
     * play back
     */
    switch (pCurrentContext->dwAntiAliasFlags & AA_ENABLED_MASK)
    {
        case AA_MODE_SUPER:
        {
            DWORD VCache[16];
            DWORD VFlags[16];
            float XYCache[32];
            float chunkW = pCtx->fAAScaleX * (float)pCtx->dwChunkWidth;
            float chunkH = pCtx->fAAScaleY * (float)pCtx->dwChunkHeight;
            DWORD scrnX;
            DWORD scrnY;
            DWORD chunkX;
            DWORD chunkY;
            DWORD chunkMaxX = (DWORD)pCtx->fAAScaleX;
            DWORD chunkMaxY = (DWORD)pCtx->fAAScaleY;
            DWORD dwRectColorFormat;
            DWORD dwSurfColorFormat;

            /*
             * early exit if nothing todo
             */
            if (!pCtx->dwCapIndex)
            {
                return TRUE;
            }

            /*
             * setup
             */
            switch (pCtx->dwBPP)
            {
                case 2:
                    dwRectColorFormat = NV05E_SET_COLOR_FORMAT_LE_X16R5G6B5;
                    dwSurfColorFormat = NV042_SET_COLOR_FORMAT_LE_Y16;
                    break;
                case 3:
                case 4:
                    dwRectColorFormat = NV05E_SET_COLOR_FORMAT_LE_X8R8G8B8;
                    dwSurfColorFormat = NV042_SET_COLOR_FORMAT_LE_Y32;
                    break;
            }

            /*
             * set render phase tag
             */
            pCurrentContext->dwAntiAliasFlags |= AA_RENDER;
            pDriverData->lpLast3DSurfaceRendered = 0;
            nvSetD3DSurfaceState (pCurrentContext);

            /*
             * for all chunks
             */
            fAAOffsetY = 0.0f;
            scrnY      = 0;
            for (chunkY=0; chunkY<chunkMaxY; chunkY++)
            {
                fAAOffsetX = 0.0f;
                scrnX      = 0;

                for (chunkX=0; chunkX<chunkMaxX; chunkX++)
                {
                    DWORD ptr,end,cls;

                    /*
                     * setup
                     */
                    dwScreenYX = AACOMBINE(scrnY,scrnX);

                    /*
                     * clear z buffer and frame buffer of scaled chunk
                     */
                    if (pCurrentContext->lpLclZ)
                    {
                        nvSetClearSurface(
                            pCurrentContext->lpLclZ->lpGbl->fpVidMem - pDriverData->BaseAddress,
                            (WORD)pCurrentContext->lpLclZ->lpGbl->lPitch,
                            dwSurfColorFormat,dwRectColorFormat,pCtx->dwZFill);
                        nvClearSurfaceRect(0,0,pCtx->dwSuperWidth,pCtx->dwSuperHeight);
                    }
                    if (pCurrentContext->dwAntiAliasFlags & AA_CLEAR_SCREEN)
                    {
                        nvSetClearSurface(
                            pCtx->dwSuperOffset,pCtx->dwSuperPitch,
                            dwSurfColorFormat,dwRectColorFormat,pCtx->dwCFill);
                        nvClearSurfaceRect(0,0,pCtx->dwSuperWidth,pCtx->dwSuperHeight);
                    }
                    else
                    {
                        nvReset2DSurfaceFormat();
                        nvAABlt (dwScreenOffset,dwScreenPitch,          dwScreenYX<<4,dwScreenHW,
                                 pCtx->dwSuperOffset,pCtx->dwSuperPitch,0x00000000,dwSuperHW,
                                                                        0x00000000,dwSuperHW,
                                 nvAATable[pCtx->dwAASuperMode].dwDU,nvAATable[pCtx->dwAASuperMode].dwDV,
                                 (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH << 24) | (NV077_IMAGE_IN_FORMAT_ORIGIN_CORNER << 16));
                    }
                    nvReset2DSurfaceFormat();

                    /*
                     * blt target chunk to scaled chunk
                     */
                    /* keep for future reference
                    nvAABlt (dwScreenOffset,dwScreenPitch,          dwScreenYX<<4,dwChunkHW,
                             pCtx->dwSuperOffset,pCtx->dwSuperPitch,0,dwSuperHW,
                                                                    0,dwSuperHW,
                             (1<<20)/AA_SCALE,(1<<20)/AA_SCALE,
                             (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH << 24) | (NV077_IMAGE_IN_FORMAT_ORIGIN_CORNER << 16));
                    */

                    /*
                     * play back geometry
                     */
                    ptr = dwAddr;
                    end = dwAddr + dwIndex;
                    cls = 0;
                    memset (VCache,0,sizeof(VCache)); // reset cache for clipper vc displacement algo
                    memset (VFlags,0,sizeof(VFlags));
                    while (ptr < end)
                    {
                        DWORD data = *(DWORD*)ptr;
                        DWORD size = 1 + ((data >> 18) & 0x3f);
                        DWORD skip = size << 2;

                        /*
                        if (nvFreeCount < 128)
                        {
                             nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, 128);
                        }
                        */
                        /*
                        if (data & 0xc0000000)
                        {
                            __asm lea eax,dword ptr [global]
                            __asm int 3;
                        }
                        /**/

                        switch (data)
                        {
                            /*
                             * object
                             */
                            case (0x040000 | (NV_DD_SPARE << 13)):
                            {
                                cls = *(DWORD*)(ptr+4);
                                goto copy;
                            }
                            break;
                            /*
                             * tri launch
                             */
                            case (0x040000 | (NV_DD_SPARE << 13) | NV054_DRAW_PRIMITIVE(0)):
                            case (0x040000 | (NV_DD_SPARE << 13) | NV055_DRAW_PRIMITIVE(0)):
                            {
                                DWORD len    = (data == (0x040000 | (NV_DD_SPARE << 13) | NV055_DRAW_PRIMITIVE(0)))
                                             ? ((sizeDx6TriangleTLVertex - 1) * 4)
                                             : ((sizeDx5TriangleTLVertex - 1) * 4);
                                DWORD launch = *(DWORD*)(ptr+4);

                                /*
                                 * extract vertices of triangle
                                 */
                                DWORD i0     = (launch >> 8)     ;
                                DWORD i1     = (launch >> 4) & 15;
                                DWORD i2     = (launch     ) & 15;

                                /*
                                 * check for clipping
                                 */
                                if ((VFlags[i0] | VFlags[i1] | VFlags[i2]) & VF_OUTCODEMASK)
                                {
                                    /*
                                     * clip
                                     */
                                    nvAAClip (i0,i1,i2,len,XYCache,VCache,VFlags);
                                    /*
                                     * suppress copy
                                     */
                                    break;
                                }

                                /*
                                 * restore punted vertices
                                 */
                                {
                                    DWORD i;
                                    for (i=0; i<3; i++)
                                    {
                                        DWORD x = launch & 15;
                                        launch >>= 4;
                                        if (VFlags[x] & VF_RESTORE)
                                        {
                                            VFlags[x] &= ~VF_RESTORE;
                                            if (ISDX6(len))
                                            {
                                                while (nvFreeCount < sizeDx6TriangleTLVertex)
                                                    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeDx6TriangleTLVertex);
                                                *(DWORD*)(nvFifo + 0) = ((sizeDx6TriangleTLVertex-1)<<18) | ((NV_DD_SPARE)<<13) | NV055_TLMTVERTEX((x));
                                                *(float*)(nvFifo + 4) = XYCache[x*2+0];
                                                *(float*)(nvFifo + 8) = XYCache[x*2+1];
                                                memcpy ((void*)(nvFifo+12),(void*)(VCache[x]+8),len-8);
                                                nvFifo      += sizeDx6TriangleTLVertex * 4;
                                                nvFreeCount -= sizeDx6TriangleTLVertex;
                                            }
                                            else
                                            {
                                                while (nvFreeCount < sizeDx5TriangleTLVertex)
                                                    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeDx5TriangleTLVertex);
                                                *(DWORD*)(nvFifo + 0) = ((sizeDx5TriangleTLVertex-1)<<18) | ((NV_DD_SPARE)<<13) | NV054_TLVERTEX((x));
                                                *(float*)(nvFifo + 4) = XYCache[x*2+0];
                                                *(float*)(nvFifo + 8) = XYCache[x*2+1];
                                                memcpy ((void*)(nvFifo+12),(void*)(VCache[x]+8),len-8);
                                                nvFifo      += sizeDx5TriangleTLVertex * 4;
                                                nvFreeCount -= sizeDx5TriangleTLVertex;
                                            }
                                        }
                                    }
                                }

                                /*
                                 * launch tri
                                 */
                                goto copy;
                            }
                            break;
                            /*
                             * something else
                             */
                            default:
                            {
                                DWORD method = data & 0x7ff;
                                /*
                                 * vertex
                                 */
                                if (((cls == D3D_DX5_TEXTURED_TRIANGLE)      && (method >= 0x400) && (method < 0x600))
                                 || ((cls == D3D_DX6_MULTI_TEXTURE_TRIANGLE) && (method >= 0x400) && (method < 0x540)))
                                {
                                    DWORD idx = (cls == D3D_DX5_TEXTURED_TRIANGLE) ? ((method-0x400)/0x20) : ((method-0x400)/0x28);
                                    float sx,sy;

                                    VCache[idx] = ptr+4;
                                    VFlags[idx] = VF_RESTORE; // load on demand

                                    sx = *(float*)(ptr+4) * fAAScaleX + fAAOffsetX;
                                    if (sx < AA_MIN) VFlags[idx] |= VF_NEGX; else
                                    if (sx > AA_MAX) VFlags[idx] |= VF_POSX;
                                    XYCache[idx*2+0] = sx;

                                    sy = *(float*)(ptr+8) * fAAScaleY + fAAOffsetY;
                                    if (sy < AA_MIN) VFlags[idx] |= VF_NEGY; else
                                    if (sy > AA_MAX) VFlags[idx] |= VF_POSY;
                                    XYCache[idx*2+1] = sy;

                                    break;
                                }
                                /*
                                 * blind copy
                                 */
                            copy:
                                while (nvFreeCount < size)
                                    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, size);
                                memcpy ((void*)nvFifo,(void*)ptr,skip);
                                nvFifo      += skip;
                                nvFreeCount -= size;
                            }
                            break;
                        }
                        ptr += skip;
                    }

                    /*
                     * filter down
                     */
                    if (nvAATable[pCtx->dwAASuperMode].dwDXPass2)
                    {
                        /*
                         * 2-pass filter
                         */
                        nvAABlt (pCtx->dwSuperOffset,pCtx->dwSuperPitch,nvAATable[pCtx->dwAASuperMode].dwSrcPass1,dwSuperHW,
                                 pCtx->dwSuperOffset,pCtx->dwSuperPitch,0x00000000,dwSuperHW,
                                                                        0x00000000,dwSuperHW,
                                 nvAATable[pCtx->dwAASuperMode].dwDXPass1,nvAATable[pCtx->dwAASuperMode].dwDYPass1,
                                 (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) | (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16));
                        nvAABlt (pCtx->dwSuperOffset,pCtx->dwSuperPitch,nvAATable[pCtx->dwAASuperMode].dwSrcPass2,dwSuperHW,
                                 dwScreenOffset,dwScreenPitch,          dwScreenYX,dwChunkHW,
                                                                        dwClipYX,dwClipHW,
                                 nvAATable[pCtx->dwAASuperMode].dwDXPass2,nvAATable[pCtx->dwAASuperMode].dwDYPass2,
                                 (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) | (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16));
                    }
                    else
                    {
                        /*
                         * 1-pass filter
                         */
                        nvAABlt (pCtx->dwSuperOffset,pCtx->dwSuperPitch,nvAATable[pCtx->dwAASuperMode].dwSrcPass1,dwSuperHW,
                                 dwScreenOffset,dwScreenPitch,          dwScreenYX,dwChunkHW,
                                                                        dwClipYX,dwClipHW,
                                 nvAATable[pCtx->dwAASuperMode].dwDXPass1,nvAATable[pCtx->dwAASuperMode].dwDYPass1,
                                 (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) | (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16));
                    }
                    nvReset2DSurfaceFormat();
                    /* unfiltered blt
                    nvAABlt (pCtx->dwSuperOffset,pCtx->dwSuperPitch,0x00000000,dwSuperHW,
                             dwScreenOffset,dwScreenPitch,          0x00000000,dwSuperHW,
                                                                    0x00000000,dwSuperHW,
                             (1<<20),(1<<20),
                             (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH << 24) | (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16));
                    */

                    /*
                     * kick off
                     */
                    nvStartDmaBuffer (FALSE);

                    /*
                     * next
                     */
                    fAAOffsetX -= chunkW;
                    scrnX      += pCtx->dwChunkWidth;
                }

                fAAOffsetY -= chunkH;
                scrnY      += pCtx->dwChunkHeight;
            }

            /*
             * reset render phase tag
             */
            pCurrentContext->dwAntiAliasFlags &= ~(AA_RENDER | AA_CLEAR_SCREEN | AA_COPY_SCREEN);
            pCtx->dwCapIndex = 0;
        }
        break;
        case AA_MODE_SINGLECHUNK:
        {
            if (pCurrentContext->dwAntiAliasFlags & AA_PENDING_DATA)
            {
                /*
                 * force the blitter to operate properly (test on simply3d)
                 */
                nvReset2DSurfaceFormat();

                /*
                 * scale down super buffer
                 */
                if (nvAATable[pCtx->dwAASuperMode].dwDXPass2)
                {
                    /*
                     * 2-pass filter
                     */
                    nvAABlt (pCtx->dwSuperOffset,pCtx->dwSuperPitch,nvAATable[pCtx->dwAASuperMode].dwSrcPass1,dwSuperHW,
                             pCtx->dwSuperOffset,pCtx->dwSuperPitch,0x00000000,dwSuperHW,
                                                                    0x00000000,dwSuperHW,
                             nvAATable[pCtx->dwAASuperMode].dwDXPass1,nvAATable[pCtx->dwAASuperMode].dwDYPass1,
                             (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) | (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16));
                    nvAABlt (pCtx->dwSuperOffset,pCtx->dwSuperPitch,nvAATable[pCtx->dwAASuperMode].dwSrcPass2,dwSuperHW,
                             dwScreenOffset,dwScreenPitch,          0,dwChunkHW,
                                                                    dwClipYX,dwClipHW,
                             nvAATable[pCtx->dwAASuperMode].dwDXPass2,nvAATable[pCtx->dwAASuperMode].dwDYPass2,
                             (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) | (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16));
                }
                else
                {
                    /*
                     * 1-pass filter
                     */
                    nvAABlt (pCtx->dwSuperOffset,pCtx->dwSuperPitch,nvAATable[pCtx->dwAASuperMode].dwSrcPass1,dwSuperHW,
                             dwScreenOffset,dwScreenPitch,          0,dwChunkHW,
                                                                    dwClipYX,dwClipHW,
                             nvAATable[pCtx->dwAASuperMode].dwDXPass1,nvAATable[pCtx->dwAASuperMode].dwDYPass1,
                             (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) | (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16));
                }
                pCurrentContext->dwAntiAliasFlags &= ~AA_PENDING_DATA;
            }
        }
        break;
        case AA_MODE_EDGE:
        {
            /*
             * early exit if nothing todo
             */
            if (!pCtx->dwCapIndex)
            {
                return TRUE;
            }
            //aatodo - implement
            pCtx->dwCapIndex = 0;
        }
        break;
    }

    /*
     * reset counters for next frame
     */
    pDriverData->dDrawSpareSubchannelObject = 0;
    //pDriverData->TwoDRenderingOccurred      = TRUE;
    pDriverData->ThreeDRenderingOccurred    = 0;
    nvReset2DSurfaceFormat();

    /*
     * success
     */
    return TRUE;
}

/*
 * nvAASingleChunkRenderPrimitive
 *
 * renders triangles into super buffer
 */
void nvAASingleChunkRenderPrimitive
(
    DWORD  nPrimCount,
    LPWORD pIndices,        // NULL for non-indexed cases
    DWORD  dwStrides,
    LPBYTE pVertices
)
{
    PNVAACONTEXT pCtx;
    DWORD        a0,a1,a2;
    DWORD        dwVertexStride;
    float        fAAScaleX;
    float        fAAScaleY;
    DWORD        dwCullMask1;
    DWORD        dwCullMask2;
    DWORD        dwFogMode;
    DWORD       *dwUVOffset;

    DPF_LEVEL (NVDBG_LEVEL_FUNCTION_CALL, "nvAASingleChunkRenderPrimitive");

    /*
     * get context
     */
    pCtx = pCurrentContext->pAAContext;
    pCurrentContext->dwAntiAliasFlags |= AA_PENDING_DATA;

    /*
     * clear render target if needed, always clear z buffer
     */
    if (pCurrentContext->dwAntiAliasFlags & (AA_CLEAR_SCREEN | AA_COPY_SCREEN))
    {
        DWORD dwRectColorFormat;
        DWORD dwSurfColorFormat;

        /*
         * setup formats
         */
        switch (pCtx->dwBPP)
        {
            case 2:
                dwRectColorFormat = NV05E_SET_COLOR_FORMAT_LE_X16R5G6B5;
                dwSurfColorFormat = NV042_SET_COLOR_FORMAT_LE_Y16;
                break;
            case 3:
            case 4:
                dwRectColorFormat = NV05E_SET_COLOR_FORMAT_LE_X8R8G8B8;
                dwSurfColorFormat = NV042_SET_COLOR_FORMAT_LE_Y32;
                break;
        }

        /*
         * do clear
         */
        if  (pCurrentContext->lpLclZ)
        {
            nvSetClearSurface(
                pCtx->dwSuperZOffset,pCtx->dwSuperZPitch,
                dwSurfColorFormat,dwRectColorFormat,pCtx->dwZFill);
            nvClearSurfaceRect(0,0,pCtx->dwSuperWidth,pCtx->dwSuperHeight);
            nvReset2DSurfaceFormat();
        }

        if (pCurrentContext->dwAntiAliasFlags & AA_CLEAR_SCREEN)
        {
            nvSetClearSurface(
                pCtx->dwSuperOffset,pCtx->dwSuperPitch,
                dwSurfColorFormat,dwRectColorFormat,pCtx->dwCFill);
            nvClearSurfaceRect(0,0,pCtx->dwSuperWidth,pCtx->dwSuperHeight);
            nvReset2DSurfaceFormat();
            /*
             * tag as clear (clear takes precedence over copy)
             */
            pCurrentContext->dwAntiAliasFlags &= ~(AA_CLEAR_SCREEN | AA_COPY_SCREEN);
        }
        /*
         * do copy
         */
        else
        {
            DWORD dwScreenOffset;
            DWORD dwScreenPitch;
            DWORD dwScreenHW;
            DWORD dwSuperHW;

            /*
             * setup
             */
            dwScreenOffset = pCurrentContext->dwSurfaceOffset;
            dwScreenPitch  = pCurrentContext->surfacePitch.wColorPitch;
            dwScreenHW     = AACOMBINE(pCurrentContext->lpLcl->lpGbl->wHeight,pCurrentContext->lpLcl->lpGbl->wWidth);
            dwSuperHW      = AACOMBINE(pCtx->dwSuperHeight,pCtx->dwSuperWidth);

            /*
             * copy screen
             */
            nvAABlt (dwScreenOffset,dwScreenPitch,          0x00000000,dwScreenHW,
                     pCtx->dwSuperOffset,pCtx->dwSuperPitch,0x00000000,dwSuperHW,
                                                            0x00000000,dwSuperHW,
                     nvAATable[pCtx->dwAASuperMode].dwDU,nvAATable[pCtx->dwAASuperMode].dwDV,
                     (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH << 24) | (NV077_IMAGE_IN_FORMAT_ORIGIN_CORNER << 16));

            /*
             * tag as copied
             */
            pCurrentContext->dwAntiAliasFlags &= ~AA_COPY_SCREEN;
        }

        /*
         * set render target
         */
        pDriverData->lpLast3DSurfaceRendered = 0;
        nvSetD3DSurfaceState (pCurrentContext);

        /*
         * reset triangle object
         */
        if (pCurrentContext->bUseDX6Class)
        {
            nvSetDx6MultiTextureState (pCurrentContext);
        }
        else
        {
            nvSetDx5TriangleState (pCurrentContext);
        }

        /*
         * let it rip while we send some triangles
         */
        nvStartDmaBuffer (FALSE);
    }

    /*
     * setup
     */
    a0 = 0;
    a1 = 1;
    a2 = 2;
    dwVertexStride = fvfData.dwVertexStride;
    fAAScaleX      = pCtx->fAAScaleX;
    fAAScaleY      = pCtx->fAAScaleY;
    dwCullMask1    = (pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
    dwCullMask2    = (pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_NONE) ? 0xffffffff : 0x80000000;
    dwFogMode      = pCurrentContext->dwRenderState[D3DRENDERSTATE_FOGENABLE]
                   ? pCurrentContext->dwRenderState[D3DRENDERSTATE_FOGTABLEMODE]
                   : 0;
    dwUVOffset     = ((PNVD3DMULTITEXTURESTATE)(&pCurrentContext->mtsState))->dwUVOffset;

    /*
     * for all primitives
     */
    while (nPrimCount)
    {
        DWORD v0,v1,v2;
        float cv;

        /*
         * extract vertices
         */
        if (pIndices)
        {
            v0 = (DWORD)pVertices + dwVertexStride * (DWORD)pIndices[a0];
            PREFETCH (v0);
            v1 = (DWORD)pVertices + dwVertexStride * (DWORD)pIndices[a1];
            PREFETCH (v1);
            v2 = (DWORD)pVertices + dwVertexStride * (DWORD)pIndices[a2];
            PREFETCH (v2);
        }
        else
        {
            v0 = (DWORD)pVertices + dwVertexStride * a0;
            PREFETCH (v0);
            v1 = (DWORD)pVertices + dwVertexStride * a1;
            PREFETCH (v1);
            v2 = (DWORD)pVertices + dwVertexStride * a2;
            PREFETCH (v2);
        }

        /*
         * cull check
         */
        IF_NOT_CULLED_BEGIN(v0,v1,v2,cv)
            DWORD o0,o1,o2;
            float x0,x1,x2;
            float y0,y1,y2;
            DWORD s0[11],s1[11],s2[11];

            /*
             * scale vertices & compute outcodes
             */
            o0 = 0;
            x0 = *(float*)(v0 + 0) * fAAScaleX;
            if (x0 < AA_MIN) o0 |= VF_NEGX;
            if (x0 > AA_MAX) o0 |= VF_POSX;
            y0 = *(float*)(v0 + 4) * fAAScaleY;
            if (y0 < AA_MIN) o0 |= VF_NEGY;
            if (y0 > AA_MAX) o0 |= VF_POSY;

            o1 = 0;
            x1 = *(float*)(v1 + 0) * fAAScaleX;
            if (x1 < AA_MIN) o1 |= VF_NEGX;
            if (x1 > AA_MAX) o1 |= VF_POSX;
            y1 = *(float*)(v1 + 4) * fAAScaleY;
            if (y1 < AA_MIN) o1 |= VF_NEGY;
            if (y1 > AA_MAX) o1 |= VF_POSY;

            o2 = 0;
            x2 = *(float*)(v2 + 0) * fAAScaleX;
            if (x2 < AA_MIN) o2 |= VF_NEGX;
            if (x2 > AA_MAX) o2 |= VF_POSX;
            y2 = *(float*)(v2 + 4) * fAAScaleY;
            if (y2 < AA_MIN) o2 |= VF_NEGY;
            if (y2 > AA_MAX) o2 |= VF_POSY;

            /*
             * expand vertices into TL format
             */
            if (pCurrentContext->bUseDX6Class)
            {
                DWORD ptr,fc=0;
                switch (dwFogMode)
                {
                    case 0: ptr = (DWORD)s0;
                            nvglDX6FlexTriangleVertex(ptr,fc,NV_DD_SPARE,0,v0,fvfData,dwUVOffset);
                            ptr = (DWORD)s1;
                            nvglDX6FlexTriangleVertex(ptr,fc,NV_DD_SPARE,1,v1,fvfData,dwUVOffset);
                            ptr = (DWORD)s2;
                            nvglDX6FlexTriangleVertex(ptr,fc,NV_DD_SPARE,2,v2,fvfData,dwUVOffset);
                            break;
                    case 1: ptr = (DWORD)s0;
                            nvglDX6FlexTriangleVertexExpFog(ptr,fc,NV_DD_SPARE,0,v0,fvfData,dwUVOffset);
                            ptr = (DWORD)s1;
                            nvglDX6FlexTriangleVertexExpFog(ptr,fc,NV_DD_SPARE,1,v1,fvfData,dwUVOffset);
                            ptr = (DWORD)s2;
                            nvglDX6FlexTriangleVertexExpFog(ptr,fc,NV_DD_SPARE,2,v2,fvfData,dwUVOffset);
                            break;
                    case 2: ptr = (DWORD)s0;
                            nvglDX6FlexTriangleVertexExp2Fog(ptr,fc,NV_DD_SPARE,0,v0,fvfData,dwUVOffset);
                            ptr = (DWORD)s1;
                            nvglDX6FlexTriangleVertexExp2Fog(ptr,fc,NV_DD_SPARE,1,v1,fvfData,dwUVOffset);
                            ptr = (DWORD)s2;
                            nvglDX6FlexTriangleVertexExp2Fog(ptr,fc,NV_DD_SPARE,2,v2,fvfData,dwUVOffset);
                            break;
                    case 3: ptr = (DWORD)s0;
                            nvglDX6FlexTriangleVertexLinearFog(ptr,fc,NV_DD_SPARE,0,v0,fvfData,dwUVOffset);
                            ptr = (DWORD)s1;
                            nvglDX6FlexTriangleVertexLinearFog(ptr,fc,NV_DD_SPARE,1,v1,fvfData,dwUVOffset);
                            ptr = (DWORD)s2;
                            nvglDX6FlexTriangleVertexLinearFog(ptr,fc,NV_DD_SPARE,2,v2,fvfData,dwUVOffset);
                            break;
                }
            }
            else
            {
                DWORD ptr,fc=0;
                switch (dwFogMode)
                {
                    case 0: ptr = (DWORD)s0;
                            nvglDX5FlexTriangleVertex(ptr,fc,NV_DD_SPARE,0,v0,fvfData,dwUVOffset);
                            ptr = (DWORD)s1;
                            nvglDX5FlexTriangleVertex(ptr,fc,NV_DD_SPARE,1,v1,fvfData,dwUVOffset);
                            ptr = (DWORD)s2;
                            nvglDX5FlexTriangleVertex(ptr,fc,NV_DD_SPARE,2,v2,fvfData,dwUVOffset);
                            break;
                    case 1: ptr = (DWORD)s0;
                            nvglDX5FlexTriangleVertexExpFog(ptr,fc,NV_DD_SPARE,0,v0,fvfData,dwUVOffset);
                            ptr = (DWORD)s1;
                            nvglDX5FlexTriangleVertexExpFog(ptr,fc,NV_DD_SPARE,1,v1,fvfData,dwUVOffset);
                            ptr = (DWORD)s2;
                            nvglDX5FlexTriangleVertexExpFog(ptr,fc,NV_DD_SPARE,2,v2,fvfData,dwUVOffset);
                            break;
                    case 2: ptr = (DWORD)s0;
                            nvglDX5FlexTriangleVertexExp2Fog(ptr,fc,NV_DD_SPARE,0,v0,fvfData,dwUVOffset);
                            ptr = (DWORD)s1;
                            nvglDX5FlexTriangleVertexExp2Fog(ptr,fc,NV_DD_SPARE,1,v1,fvfData,dwUVOffset);
                            ptr = (DWORD)s2;
                            nvglDX5FlexTriangleVertexExp2Fog(ptr,fc,NV_DD_SPARE,2,v2,fvfData,dwUVOffset);
                            break;
                    case 3: ptr = (DWORD)s0;
                            nvglDX5FlexTriangleVertexLinearFog(ptr,fc,NV_DD_SPARE,0,v0,fvfData,dwUVOffset);
                            ptr = (DWORD)s1;
                            nvglDX5FlexTriangleVertexLinearFog(ptr,fc,NV_DD_SPARE,1,v1,fvfData,dwUVOffset);
                            ptr = (DWORD)s2;
                            nvglDX5FlexTriangleVertexLinearFog(ptr,fc,NV_DD_SPARE,2,v2,fvfData,dwUVOffset);
                            break;
                }
            }

            /*
             * clip if needed
             */
            if (o0 | o1 | o2)
            {
                static DWORD VFlags[16] = { VF_RESTORE,VF_RESTORE,VF_RESTORE,VF_RESTORE,
                                            VF_RESTORE,VF_RESTORE,VF_RESTORE,VF_RESTORE,
                                            VF_RESTORE,VF_RESTORE,VF_RESTORE,VF_RESTORE,
                                            VF_RESTORE,VF_RESTORE,VF_RESTORE,VF_RESTORE };
                DWORD  VCache[3] = {(DWORD)&s0[1], (DWORD)&s1[1], (DWORD)&s2[1]};
                float XYCache[6] = {x0,y0,x1,y1,x2,y2};
                DWORD len        = pCurrentContext->bUseDX6Class
                                 ? ((sizeDx6TriangleTLVertex - 1) * 4)
                                 : ((sizeDx5TriangleTLVertex - 1) * 4);

                VFlags[0] = VF_RESTORE | o0;
                VFlags[1] = VF_RESTORE | o1;
                VFlags[2] = VF_RESTORE | o2;

                nvAAClip (2,1,0,len,XYCache,VCache,VFlags);
            }
            else
            {
                /*
                 * assign scaled x & y values
                 */
                *(float*)(&s0[1]) = x0;
                *(float*)(&s0[2]) = y0;
                *(float*)(&s1[1]) = x1;
                *(float*)(&s1[2]) = y1;
                *(float*)(&s2[1]) = x2;
                *(float*)(&s2[2]) = y2;

                /*
                 * send to HW
                 */
                if (pCurrentContext->bUseDX6Class)
                {
                    while (nvFreeCount < (sizeDx6TriangleTLVertex * 3 + sizeDx6TriangleDrawPrimitive))
                        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeDx6TriangleTLVertex * 3 + sizeDx6TriangleDrawPrimitive));
                    memcpy ((DWORD*)(nvFifo +  0),s0,sizeDx6TriangleTLVertex * 4);
                    memcpy ((DWORD*)(nvFifo + 44),s1,sizeDx6TriangleTLVertex * 4);
                    memcpy ((DWORD*)(nvFifo + 88),s2,sizeDx6TriangleTLVertex * 4);
                    *(DWORD*)(nvFifo + 132) = (((sizeDx6TriangleDrawPrimitiveMthdCnt << 2) << 16) | ((NV_DD_SPARE) << 13) | NV055_DRAW_PRIMITIVE((0)));
                    *(DWORD*)(nvFifo + 136) = 0x210;
                    nvFifo      += (sizeDx6TriangleTLVertex * 3 + sizeDx6TriangleDrawPrimitive) * 4;
                    nvFreeCount -=  sizeDx6TriangleTLVertex * 3 + sizeDx6TriangleDrawPrimitive;
                }
                else
                {
                    while (nvFreeCount < (sizeDx5TriangleTLVertex * 3 + sizeDx5TriangleDrawPrimitive))
                        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeDx5TriangleTLVertex * 3 + sizeDx5TriangleDrawPrimitive));
                    memcpy ((DWORD*)(nvFifo +  0),s0,sizeDx5TriangleTLVertex * 4);
                    memcpy ((DWORD*)(nvFifo + 36),s1,sizeDx5TriangleTLVertex * 4);
                    memcpy ((DWORD*)(nvFifo + 72),s2,sizeDx5TriangleTLVertex * 4);
                    *(DWORD*)(nvFifo + 108) = (((sizeDx5TriangleDrawPrimitiveMthdCnt << 2) << 16) | ((NV_DD_SPARE) << 13) | NV054_DRAW_PRIMITIVE((0)));
                    *(DWORD*)(nvFifo + 112) = 0x210;
                    nvFifo      += (sizeDx5TriangleTLVertex * 3 + sizeDx5TriangleDrawPrimitive) * 4;
                    nvFreeCount -=  sizeDx5TriangleTLVertex * 3 + sizeDx5TriangleDrawPrimitive;
                }
            }

        IF_NOT_CULLED_END

        /*
         * next
         */
        a0 += (dwStrides & 0x00ff00) >> 8;
        a1 +=  dwStrides & 0x0000ff;
        a2 +=  dwStrides & 0x0000ff;
        if (dwStrides & 0xff0000) a1 ^= a2 , a2 ^= a1 , a1 ^= a2;
        nPrimCount--;
    }

    /*
     * kick off if needed
     */
    nvStartDmaBuffer (TRUE);

}

#endif  // NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\D3dstate.c ===
/*
 * Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: D3DRENDR.C                                                        *
*   The Direct 3d Rendereing routines.                                      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/02/97 - re-wrote and cleaned up.     *
*                                                                           *
\***************************************************************************/
#include <windows.h>
#include "ddrawi.h"
#include "d3dhal.h"

DWORD __stdcall nvGetState
(
    LPD3DHAL_GETSTATEDATA   pgsd
)
{
    /*
     * NOTES:
     *
     * This callback is called when Direct3D requires information about
     * the state of a particular stage in the pipeline. If you only handle
     * rasterisation then you only need to respond to D3DHALSTATE_GET_RENDER
     * calls.
     * The state wanted is in pgsd->ddState.drstRenderStateType.
     * Return the answer in pgsd->ddState.dwArg[0].
     */
    if (!pgsd->dwhContext)
    {
        pgsd->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }
    if (pgsd->dwWhich != D3DHALSTATE_GET_RENDER)
    {
        pgsd->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }
    pgsd->ddState.dwArg[0] = 1;
    pgsd->ddrval           = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\D3dTex.c ===
/*
 * Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 * (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: D3DTEX.C                                                          *
*   The Direct 3d texture routines.                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/02/97 - re-wrote and cleaned up.     *
*       Ben de Waal (bdw)           08/28/97 - enabled locked tex status    *
*                                   09/19/97 - optimize mipmap creation     *
*                                                                           *
\***************************************************************************/

#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nv3ddbg.h"

#ifndef WINNT
FLATPTR EXTERN_DDAPI DDHAL32_VidMemAlloc (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, DWORD dwXDim, DWORD dwYDim);
void EXTERN_DDAPI DDHAL32_VidMemFree (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, FLATPTR ptr);
#endif // #ifndef WINNT

/*
 * Some statistical data.
 */

// omnitemporal texture counts
DWORD   statTextureOmniCountTotal      = 0;
DWORD   statTextureOmniCountPalette    = 0;

// omnitemporal texture sizes
DWORD   statTextureOmniSizeTotal       = 0;
DWORD   statTextureOmniSizePalette     = 0;

// extant texture counts
DWORD   statTextureCountTotal          = 0;
DWORD   statTextureCountVideo          = 0;
DWORD   statTextureCountAgpHeap        = 0;
DWORD   statTextureCountPciHeap        = 0;
DWORD   statTextureCountCache          = 0;

// extant texture sizes
DWORD   statTextureSizeTotal           = 0;
DWORD   statTextureSizeVideo           = 0;
DWORD   statTextureSizeAgpHeap         = 0;
DWORD   statTextureSizePciHeap         = 0;
DWORD   statTextureSizeCache           = 0;

// texture dimensions
DWORD   statTextureDimensionMinVideo   = 2048;
DWORD   statTextureDimensionMinAgpHeap = 2048;
DWORD   statTextureDimensionMinPciHeap = 2048;
DWORD   statTextureDimensionMinCache   = 2048;
DWORD   statTextureDimensionMaxVideo   = 0;
DWORD   statTextureDimensionMaxAgpHeap = 0;
DWORD   statTextureDimensionMaxPciHeap = 0;
DWORD   statTextureDimensionMaxCache   = 0;

/*
 * --------------------------------------------------------------------------
 * Miscellaneous D3D texture related routines.
 * --------------------------------------------------------------------------
 */
BOOL nvCreateTextureListHeap
(
    void
)
{
    /*
     * Create a global heap to allocate internal D3D Texture data structures out of.
     * The number of D3D Textures available can be adjusted by a setting in the registry.
     * It is set reasonably large by default, so hopefully the registry override will never
     * be needed....but just in case.
     */
#ifndef OLDSTUFF
    pDriverData->hTextures_gbl = (DWORD)HEAPCREATE((pDriverData->regD3DTextureMax * sizeof(NVD3DTEXTURE)));
#else
    pDriverData->hTextures_gbl = (DWORD)HeapCreate(HEAP_SHARED,
                                                   (pDriverData->regD3DTextureMax * sizeof(NVD3DTEXTURE)),
                                                   0);
#endif
    if (!pDriverData->hTextures_gbl)
    {
        dbgD3DError();
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureListHeap - Could not create texture list heap!");
        return (FALSE);
    }
    return (TRUE);
}
BOOL nvDestroyTextureListHeap
(
    void
)
{
    PNVD3DTEXTURE               pTexture;
    PNVD3DTEXTURE               pTextureNext;

    /*
     * If there's no heap currently allocated, then there is no heap to destroy.
     */
    if (!pDriverData->hTextures_gbl)
        return (TRUE);

    /*
     * Free any textures that are still allocated.
     * This will hopefully never happen, because it gets quite complicated if the texture
     * surface that this texture structure is associated with has not been destroyed yet.
     */
    pTexture = (PNVD3DTEXTURE)pDriverData->dwTextureListHead;

    while (pTexture)
    {
        /*
         * Get the pointer to the next texture in the list before actually freeing the
         * memory for this structure.
         */
        pTextureNext = pTexture->pTextureNext;

        /*
         * Before freeing the memory for this texture structure, we will need to get the
         * pointer to the texture surface so that we can zero out the reserved field
         * containing the handle for this structure.  That is, if the texture surface field
         * is still valid.
         */


        /*
         * If the surface is no longer allocated, but the user texture memory is, then
         * free up the memory now.
         */
#ifdef NV_TEX2
        if (pTexture->dwLinearAddr)
        {
            nvTextureFreeLinearSurface (pTexture);
        }
#else // !NV_TEX2
        if ((!(pTexture->dwTextureFlags & NV3_TEXTURE_SURFACE_ALLOCATED))
         && (pTexture->dwTextureFlags & NV3_TEXTURE_USER_ALLOCATED))
        {
            GlobalUnlock(pTexture->hUserTexture);
            GlobalFree(pTexture->hUserTexture);
            pTexture->hUserTexture    = (HANDLE)NULL;
            pTexture->fpUserTexture   = (FLATPTR)NULL;
            pTexture->dwTextureFlags &= ~NV3_TEXTURE_USER_ALLOCATED;
        }
#endif // NV_TEX2

        /*
         * No matter what, if the internal texture memory is still allocated, then
         * free it now.
         */
#ifdef NV_TEX2
        if (TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags))
        {
            nvTextureFreeSwizzleSurface (pTexture);
        }
#else // !NV_TEX2
        if (pTexture->dwTextureFlags & NV3_TEXTURE_INTERNAL_ALLOCATED)
        {
            PNVD3DCONTEXT   pContext;

            /*
             * Free the internal texture memory.
             */
            pContext = (PNVD3DCONTEXT)pTexture->hContext;
            nvDestroyInternalTexture(pContext, pTexture);
        }
#endif // NV_TEX2

        /*
         * Zero out the handle field in the texture surface structure if there is still
         * a valid pointer to the surface (which there should only be if the surface
         * wasn't destroyed yet.
         */
        NV_LOCK_TEXTURE_SURFACE(pTexture);
        if ((pTexture->lpLcl)
#ifndef NV_TEX2
         && (pTexture->dwTextureFlags & NV3_TEXTURE_SURFACE_ALLOCATED)
#endif
         ) pTexture->lpLcl->dwReserved1 = (DWORD)NULL;
        NV_UNLOCK_TEXTURE_SURFACE(pTexture);

        /*
         * Zero out the memory so that there's no question about the contents.
         */
        memset(pTexture, 0, sizeof(PNVD3DTEXTURE));

        /*
         * Alrighty, go ahead and free the memory for this texture structure.
         */
#ifndef OLDSTUFF
        HEAPFREE(pDriverData->hTextures_gbl, pTexture);
#else
        HeapFree((HANDLE)pDriverData->hTextures_gbl, 0, pTexture);
#endif
        pDriverData->dwD3DTextureCount--;
        pTexture = pTextureNext;
    }

    /*
     * Destroy the heap.
     */
#ifndef OLDSTUFF
    HEAPDESTROY(pDriverData->hTextures_gbl);
#else
    HeapDestroy((HANDLE)pDriverData->hTextures_gbl);
#endif
    pDriverData->hTextures_gbl = (DWORD)NULL;
    return (TRUE);
}
BOOL nvDestroyTextureStructure
(
    PNVD3DTEXTURE   pTexture
)
{
    /*
     * NOTE: This routine assumes only valid (non-null) texture pointers will be
     *       passed in!!
     * Is there still a surface allocated?
     * This can vary.  It is possible that a structure has been destroyed already
     * (i.e. this is common in the case of full screen applications being minimized
     * and restored)
     */
#ifdef NV_TEX2
    if (!TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags) && !pTexture->dwLinearAddr)
#else
#ifdef WINNT
    /*
     * Under WINNT, free up user copy of texture since we are now running
     * in the context of the process which created it (we hope).
     */
    if (pTexture->dwTextureFlags & NV3_TEXTURE_USER_ALLOCATED)
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvDestroyTextureSurface - Free User Texture = %08lx", pTexture->fpUserTexture);
        pTexture->dwTextureFlags &= ~NV3_TEXTURE_USER_ALLOCATED;
        GlobalUnlock(pTexture->hUserTexture);
        GlobalFree(pTexture->hUserTexture);
    }
#endif // #ifdef WINNT
    if (!(pTexture->dwTextureFlags & NV3_TEXTURE_SURFACE_ALLOCATED))
#endif
    {
        /*
         * Perform all neccessary context cleanup.
         */
        pTexture->pid             = 0L;
        pTexture->hContext        = 0L;

        /*
         * The internal data structure has been destroyed, make sure to clear the driver
         * reserved field out so that we don't try and access an invalid internal texture
         * structure.
         * REMOVING THIS LINE IS BAD FOR BENCHMARK TEST 10 AND 19.
         */
        NV_LOCK_TEXTURE_SURFACE(pTexture);
        if (pTexture->lpLcl)
            pTexture->lpLcl->dwReserved1 = 0;
        NV_UNLOCK_TEXTURE_SURFACE(pTexture);

        /*
         * Free the context from the array.
         */
        if (pTexture->pTexturePrev)
            pTexture->pTexturePrev->pTextureNext = pTexture->pTextureNext;
        if (pTexture->pTextureNext)
            pTexture->pTextureNext->pTexturePrev = pTexture->pTexturePrev;
        if (pDriverData->dwTextureListHead == (DWORD)pTexture)
            pDriverData->dwTextureListHead = (DWORD)pTexture->pTextureNext;
#ifndef OLDSTUFF
        HEAPFREE(pDriverData->hTextures_gbl, pTexture);
#else
        HeapFree((HANDLE)pDriverData->hTextures_gbl, 0, (PVOID)pTexture);
#endif
        pDriverData->dwD3DTextureCount--;
    }
    else
    {
        /*
         * Return FALSE if the texture structure was not deallocated.
         */
        return (FALSE);
    }

    /*
     * Return TRUE if the texture structure was actually destroyed.
     */
    return (TRUE);
}
BOOL nvDestroyTextureProcess
(
    DWORD   pid
)
{
    PNVD3DTEXTURE   pTexture;
    PNVD3DTEXTURE   pTextureNext;

    /*
     * Start at the head of the texture list.
     */
    pTexture = (PNVD3DTEXTURE)pDriverData->dwTextureListHead;

    /*
     * Search for all textures belonging to this process.
     */
    while (pTexture)
    {
        /*
         * Get the pointer to the next texture in the list before possibly
         * destroying this texture structure.
         */
        pTextureNext = pTexture->pTextureNext;

        /*
         * Destroy this texture if it belongs to this process.
         */
        if (pTexture->pid == pid)
        {
            /*
             * Mark the texture handle as being deallocated.
             */
#ifdef NV_TEX2
            pTexture->dwTextureFlags &= ~NV4_TEXFLAG_HANDLE_ALLOCATED;
            if (!TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags))
#else
            pTexture->dwTextureFlags &= ~NV3_TEXTURE_HANDLE_ALLOCATED;
            if (!(pTexture->dwTextureFlags & NV3_TEXTURE_SURFACE_ALLOCATED))
#endif
                pTexture->lpLcl = 0;

            nvDestroyTextureStructure(pTexture);
        }

        /*
         * Set the current texture to the next texture in the list.
         */
        pTexture = pTextureNext;
    }
    return (TRUE);
}
BOOL nvDestroyTextureContext
(
    DWORD   hContext
)
{
    PNVD3DTEXTURE   pTexture;
    PNVD3DTEXTURE   pTextureNext;

    /*
     * Start at the head of the texture list.
     */
    pTexture = (PNVD3DTEXTURE)pDriverData->dwTextureListHead;

    /*
     * Search for all textures belonging to this context.
     */
    while (pTexture)
    {
        /*
         * Get the pointer to the next texture in the list before possibly
         * destroying this texture structure.
         */
        pTextureNext = pTexture->pTextureNext;

        /*
         * Destroy this texture if it belongs to this process.
         */
        if (pTexture->hContext == hContext)
        {
#ifndef WINNT
            /*
             * Mark the texture handle as being deallocated.
             */
#ifdef NV_TEX2
            pTexture->dwTextureFlags &= ~NV4_TEXFLAG_HANDLE_ALLOCATED;
#else
            pTexture->dwTextureFlags &= ~NV3_TEXTURE_HANDLE_ALLOCATED;
#endif
            nvDestroyTextureStructure(pTexture);
#else
            /*
             * We might not be running in the proper context to
             * free the user mode copy of the texture. Defer
             * destruction of the surface til the texture is
             * explicitly destroyed via DestroySurface. Get rid
             * of the context ptr as the context is about to
             * be destroyed.
             */
            pTexture->hContext = 0;
#endif // #ifndef WINNT
        }

        /*
         * Set the current texture to the next texture in the list.
         */
        pTexture = pTextureNext;
    }
    return (TRUE);
}

/*
 * --------------------------------------------------------------------------
 * D3D HAL texture callback routines
 * --------------------------------------------------------------------------
 */
DWORD __stdcall nvTextureCreate
(
    LPD3DHAL_TEXTURECREATEDATA  ptcd
)
{
    HDDRVITEM                   hTexture;
    PNVD3DTEXTURE               pTexture = 0;
    LPDDRAWI_DDRAWSURFACE_LCL   lpLcl;

    /*
     * NOTES:
     *
     * This callback is invoked when a texture is to be created from a
     * DirectDrawSurface.
     * We must pass back the created handle.
     *
     * Get the pointer to the context this texture is associated with.
     */
    DPF_LEVEL (NVDBG_LEVEL_DDI_ENTRY, "nvTextureCreate - hContext = %08lx", ptcd->dwhContext);
    pCurrentContext = (PNVD3DCONTEXT)ptcd->dwhContext;
    if (!pCurrentContext)
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureCreate - Bad Context");
        dbgD3DError();
        ptcd->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Validate the parameters of the texture being created.
     */
#ifndef WINNT
    lpLcl = ((LPDDRAWI_DDRAWSURFACE_INT)ptcd->lpDDS)->lpLcl;
#else
     lpLcl = EngLockDirectDrawSurface(ptcd->hDDS);
#endif // #ifndef WINNT

    if (!lpLcl)
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, ":nvTextureCreate - Texture Create Failed");
        dbgD3DError();
        ptcd->ddrval = D3DERR_TEXTURE_CREATE_FAILED;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Get pointer to global driver. data structure.
     */
    NvSetDriverDataPtrFromContext(pCurrentContext);

    /*
     * Setup frequently accessed globals.
     */
    NV_D3D_GLOBAL_SETUP();

    /*
     * Try and get a texture pointer based on the value stored in the local surface structure
     * driver reserved field.
     *
     * DUMB APPLICATION ALERT!!!!!
     * This code is going to look really strange, but there is a reason.  Believe it or not,
     * an application actually exists (Nightmare Creatures by Kalisto) that does not work if
     * the handle returned has bit 31 set.  Because of where the memory for our texture structures
     * is located, the high bit is always set, but I don't want to just blindly assume that this
     * is always going to be the case.  So, what I'm going to do is mask off the high bit of the
     * texture structure and return the remaining 31 bits as the handle, then in places where the
     * application passes in a texture handle, I will take the pointer to the head of the texture
     * list, mask off all but the high bit and OR it in with the handle to get the pointer to the
     * texture structure.  This should be safe since the texture structures are all allocated from
     * a linearly contiguous heap.
     *
     * bdw: except if this heap straddles the 2GB point where the texture will live with bit 31 set
     *      and the heap base with bit 31 not set. Windows architecture will of course not do such a
     *      thing since the 2GB point splits app and shared memory.
     */
    hTexture = lpLcl->dwReserved1 & 0x7FFFFFFF;
    pTexture = (PNVD3DTEXTURE)lpLcl->dwReserved1;

    /*
     * Is the internal texture data structure already allocated for this texture?
     */
    if (!pTexture)
    {
        /*
         * The internal texture data structure has not been allocated yet. This can
         * happen if the application allocates it's texture handles before it creates the
         * texture surfaces.  (Ziff Davis 3D Winbench)
         * So we have to handle both cases.  If the data structure has not been allocated
         * yet, allocate it here.
         */
#ifndef OLDSTUFF
        hTexture = (HDDRVITEM)HEAPALLOC(pDriverData->hTextures_gbl, sizeof(NVD3DTEXTURE));
#else
        hTexture = (HDDRVITEM)HeapAlloc((HANDLE)pDriverData->hTextures_gbl,
                                        HEAP_ZERO_MEMORY,
                                        sizeof(NVD3DTEXTURE));
#endif
        pTexture = (PNVD3DTEXTURE)hTexture;
        if (!pTexture)
        {
            /*
             * Bad news.  Could not allocate the internal data structure.  No choice but to
             * return an error.
             */
            dbgD3DError();
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureCreate - Bad Texture");
            ptcd->ddrval = D3DERR_TEXTURE_CREATE_FAILED;
            return (DDHAL_DRIVER_HANDLED);
        }
        pDriverData->dwD3DTextureCount++;

        /*
         * Store the handle of the internal texture structure in the local surface structure
         * driver reserved field.
         */
        lpLcl->dwReserved1 = hTexture;

        /*
         * Make sure a few key fields are intialized to zero.
         */
/* allocated with HEAP_ZERO_MEMORY - waste of time
        pTexture->hMipBaseTexture  = 0;
        pTexture->dwTextureFlags   = 0;
        pTexture->dwTexturePointer = 0;
        pTexture->dwTextureOffset  = 0;
        pTexture->fpTexture        = 0;
        pTexture->hUserTexture     = 0;
        pTexture->fpUserTexture    = 0;
*/
        pTexture->dwDriverData     = (DWORD)pDriverData;

        /*
         * Update the texture list.
         */
        pTexture->pTexturePrev = (PNVD3DTEXTURE)NULL;
        pTexture->pTextureNext = (PNVD3DTEXTURE)pDriverData->dwTextureListHead;
        if (pTexture->pTextureNext)
            pTexture->pTextureNext->pTexturePrev = pTexture;
        pDriverData->dwTextureListHead = (DWORD)pTexture;
    }

    /*
     * Return the new texture handle.
     */
    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvTextureCreate - New texture handle = %08lx", hTexture);
    ptcd->dwHandle = hTexture;

    /*
     * Initialize the new texture header.
     */
    pTexture->pid      = pCurrentContext->pid;
    pTexture->hContext = ptcd->dwhContext;
    pTexture->lpLcl    = lpLcl;
#ifndef WINNT
    pTexture->lpDDS    = ptcd->lpDDS;
#else
    pTexture->hDDS = ptcd->hDDS;
#endif  // #ifndef WINNT

    /*
     * A handle is only ever allocated for the top most level of the mipmap chain.
     * run down the chain and updated the mipmap base texture for each mipmap.
     */
    if ((lpLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP)
     && (!lpLcl->lpAttachListFrom)
     && (lpLcl->lpAttachList))
    {
        LPDDRAWI_DDRAWSURFACE_LCL   lclMip;
        lclMip = lpLcl->lpAttachList->lpAttached;
        while (lclMip)
        {
            PNVD3DTEXTURE   pMipMap;

            pMipMap = (PNVD3DTEXTURE)lclMip->dwReserved1;
            if (pMipMap)
            {
                pMipMap->hMipBaseTexture = (DWORD)pTexture;
#ifdef NV_TEX2
                pMipMap->dwTextureFlags |= NV4_TEXFLAG_USER_MIP_LEVEL;
#else
                pMipMap->dwTextureFlags |= NV3_TEXTURE_USER_MIP_LEVEL;
#endif
            }
            if (lclMip->lpAttachList)
                lclMip = lclMip->lpAttachList->lpAttached;
            else
                lclMip = 0;
        }
    }

    /*
     * If this is not a user mipmap level then see if the internal texture
     * memory needs to be re-allocated.  For user mip maps, only the base
     * level
     */
#ifdef NV_TEX2
    if (!(pTexture->dwTextureFlags & NV4_TEXFLAG_USER_MIP_LEVEL))
#else
    if (!(pTexture->dwTextureFlags & NV3_TEXTURE_USER_MIP_LEVEL))
#endif
    {
        /*
         * We don't normally want to allocate the internal texture memory here, but there are
         * situations where we need to try.
         * First, if the surface is already allocated but there is no internal memory allocated
         * for it.  Then try and allocate it.
         */
#ifdef NV_TEX2
        if (!TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags)
          && pTexture->dwMipMapSizeBytes)
#else
        if ((pTexture->dwTextureFlags & NV3_TEXTURE_SURFACE_ALLOCATED)
         && (!(pTexture->dwTextureFlags & NV3_TEXTURE_INTERNAL_ALLOCATED)))
#endif
        {
#ifdef NV_TEX2
            nvAllocateInternalTexture(pTexture);
            /* txtodo - remove this comment
            nvTextureAllocSwizzleSurface (pTexture,
                                          pTexture->dwMipMapSizeBytes,
                                          pDriverData->GARTLinearBase ? (NV4_TEXLOC_VID | NV4_TEXLOC_AGP)
                                                                      : (NV4_TEXLOC_VID | NV4_TEXLOC_PCI),
                                          pTexture->dwTextureFlags >> NV4_TEXMASK_SWIZZLE_SHIFT);
            pTexture->dwTextureFlags &= ~NV4_TEXFLAG_SWIZZLE_VALID;
            */
#else
            pTexture->dwTexturePointer = 0;
            pTexture->dwTextureOffset  = 0;
            nvAllocateInternalTexture(pTexture);
            pTexture->dwTextureFlags |= NV3_TEXTURE_MODIFIED;
#endif // NV_TEX2
        }

        /*
         * If the texture flags show that the internal texture surface has been allocated and
         * the internal texture is in the PCI system memory texture heap, validate the texture
         * pointer.  If it is invalid, then it must be reallocated.
         */
#ifdef NV_TEX2
        if (TEX_SWIZZLE_FLAGS(pTexture,pTexture->dwTextureFlags) & NV4_TEXLOC_PCI)
#else
        if ((pTexture->dwTextureFlags & NV3_TEXTURE_INTERNAL_ALLOCATED)
         && !(pTexture->dwTextureFlags & NV3_TEXTURE_VIDEO_MEMORY)
         && (pDriverData->GARTLinearBase == 0))
#endif
        {
            /*
             * Validate the PCI system memory texture pointer.
             */
#ifdef NV_TEX2
            if (!GetPointerTextureHeap(TEX_SWIZZLE_OFFSET(pTexture,pTexture->dwTextureFlags)))
#else
            if (!GetPointerTextureHeap(pTexture->dwTextureOffset))
#endif
            {
#ifdef NV_TEX2
                nvTextureAllocSwizzleSurface (pTexture,
                                              pTexture->dwMipMapSizeBytes,
                                              pDriverData->GARTLinearBase ? (NV4_TEXLOC_VID | NV4_TEXLOC_AGP)
                                                                          : (NV4_TEXLOC_VID | NV4_TEXLOC_PCI),
                                              TEX_SWIZZLE_FLAGS(pTexture,pTexture->dwTextureFlags) & NV4_TEXMASK_LOCATION);
                TEX_SWIZZLE_FLAGS(pTexture,pTexture->dwTextureFlags) &= ~NV4_TEXFLAG_VALID;
#else
                pTexture->dwTexturePointer = 0;
                pTexture->dwTextureOffset  = 0;
                nvAllocateInternalTexture(pTexture);
                pTexture->dwTextureFlags |= NV3_TEXTURE_MODIFIED;
#endif // NV_TEX2
            }
        }
    }

    /*
     * Show that the texture has not been loaded yet and that it is not locked.
     */
#ifdef NV_TEX2
    pTexture->dwTextureFlags |= NV4_TEXFLAG_HANDLE_ALLOCATED;
#else
    pTexture->dwTextureFlags |= NV3_TEXTURE_HANDLE_ALLOCATED;
    pTexture->dwTextureFlags &= ~(NV3_TEXTURE_IS_LOCKED | NV3_TEXTURE_MUST_RELOAD);
#endif

    /*
     * Load convert the texture immediately so that hopefully real game speed does not
     * get impacted during actual game play.  This has no effect on the benchmarks, but
     * it can sometimes help out games (like moto racer with the polygon patch).
     */
#ifdef NV_TEX2
    if (!(TEX_SWIZZLE_FLAGS(pTexture,pTexture->dwTextureFlags) & NV4_TEXFLAG_VALID)
      && (pTexture->dwTextureFlags & NV4_TEXFLAG_LINEAR_VALID))
        nvUpdateSwizzleSurface(pTexture);
#else
    if ((pTexture->dwTextureFlags & NV3_TEXTURE_MODIFIED)
     && (pTexture->dwTextureFlags & NV3_TEXTURE_USER_ALLOCATED))
        nvLoadTexture(pTexture);
#endif

    /*
     * Texture creation successful.
     */
    NV_D3D_GLOBAL_SAVE();
    ptcd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}
DWORD __stdcall nvTextureDestroy
(
    LPD3DHAL_TEXTUREDESTROYDATA ptcd
)
{
    HDDRVITEM       hTexture;
    PNVD3DTEXTURE   pTexture = 0;

    /*
     * DUMB APPLICATION ALERT!!!!!
     * This code is going to look really strange, but there is a reason.  Believe it or not,
     * an application actually exists (Nightmare Creatures by Kalisto) that does not work if
     * the handle returned has bit 31 set.  Because of where the memory for our texture structures
     * is located, the high bit is always set, but I don't want to just blindly assume that this
     * is always going to be the case.  So, what I'm going to do is mask off the high bit of the
     * texture structure and return the remaining 31 bits as the handle, then in places where the
     * application passes in a texture handle, I will take the pointer to the head of the texture
     * list, mask off all but the high bit and OR it in with the handle to get the pointer to the
     * texture structure.  This should be safe since the texture structures are all allocated from
     * a linearly contiguous heap.
     */

    DPF_LEVEL(NVDBG_LEVEL_DDI_ENTRY, "nvTextureDestroy - Destroy texture handle = %08lx", ptcd->dwHandle);

    /*
     * This is a little ugly.  I know however that the handle is supposed to have bit 31
     * set all the time in order to reference it as a pointer.  And I need the pointer to the
     * texture so that I can get the pointer to the global driver data structure out of the
     * surface structure before I can access pDriverData which I would normally use to construct
     * the texture structure pointer.
     */
    hTexture = ptcd->dwHandle | 0x80000000;
    pTexture = (PNVD3DTEXTURE)hTexture;

    /*
     * The order in which the texture handle is allocated/deallocated and the texture
     * surface is created/destroyed can vary based on the application (and also a problem
     * between D3D and DDRAW). Check to see if the internal data structure is still allcocated
     * and destroy it if it still is AND the texture surface has already been destroyed.
     * If the texture surface has not been destroyed yet, then we don't want to destroy the
     * internal texture structure yet.
     */
//    hTexture = ptcd->dwHandle | (pDriverData->dwTextureListHead & 0x80000000);
//    pTexture = (PNVD3DTEXTURE)hTexture;

    /*
     * Perform all the neccessary steps for destroying this texture handle.
     * Destruction of the actual texture data structure is actually
     * dependent on the current state of the texture surface structure.
     */
    if (pTexture)
    {
        /*
         * Get pointer to global driver. data structure.
         */
        pDriverData = (GLOBALDATA *)pTexture->dwDriverData;

        /*
         * Mark the texture handle as being deallocated.
         */
#ifdef NV_TEX2
        pTexture->dwTextureFlags &= ~NV4_TEXFLAG_HANDLE_ALLOCATED;
#else
        pTexture->dwTextureFlags &= ~NV3_TEXTURE_HANDLE_ALLOCATED;
#endif

        /*
         * Destroy the internal texture data structure.
         */
        nvDestroyTextureStructure(pTexture);
    }

    /*
     * Texture destroyed successfully.
     */
    ptcd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}
DWORD __stdcall nvTextureSwap
(
    LPD3DHAL_TEXTURESWAPDATA    ptsd
)
{
    PNVD3DCONTEXT   pContext  = 0;
    PNVD3DTEXTURE   pTexture1 = 0;
    PNVD3DTEXTURE   pTexture2 = 0;
    NVD3DTEXTURE    texTemp;

    /*
     * DUMB APPLICATION ALERT!!!!!
     * This code is going to look really strange, but there is a reason.  Believe it or not,
     * an application actually exists (Nightmare Creatures by Kalisto) that does not work if
     * the handle returned has bit 31 set.  Because of where the memory for our texture structures
     * is located, the high bit is always set, but I don't want to just blindly assume that this
     * is always going to be the case.  So, what I'm going to do is mask off the high bit of the
     * texture structure and return the remaining 31 bits as the handle, then in places where the
     * application passes in a texture handle, I will take the pointer to the head of the texture
     * list, mask off all but the high bit and OR it in with the handle to get the pointer to the
     * texture structure.  This should be safe since the texture structures are all allocated from
     * a linearly contiguous heap.
     */

    DPF_LEVEL(NVDBG_LEVEL_DDI_ENTRY, "nvTextureSwap - hContext = %08lx", ptsd->dwhContext);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "Swap texture handle 1 = %08lx", ptsd->dwHandle1);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvTextureSwap - Swap texture handle 2 = %08lx", ptsd->dwHandle2);

    /*
     * NOTES:
     *
     * This callback is invoked when two texture handles are to be swapped.
     * I.e. the data refered to by the two handles is to be swapped.
     *
     * Get the pointer to the specified context.
     */
    pContext = (PNVD3DCONTEXT)ptsd->dwhContext;
    if (!pContext)
    {
        dbgD3DError();
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureSwap - Bad Context");
        ptsd->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Get pointer to global driver. data structure.
     */
    NvSetDriverDataPtrFromContext(pContext);

    /*
     * Get pointer to first texture.
     */
    pTexture1 = (PNVD3DTEXTURE)(ptsd->dwHandle1 | (pDriverData->dwTextureListHead & 0x80000000));
    if (!pTexture1)
    {
        dbgD3DError();
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureSwap - Bad Texture 1");
        ptsd->ddrval = DDERR_INVALIDPARAMS;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Get pointer to second texture.
     */
    pTexture2 = (PNVD3DTEXTURE)(ptsd->dwHandle2 | (pDriverData->dwTextureListHead & 0x80000000));
    if (!pTexture2)
    {
        dbgD3DError();
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureSwap - Bad Texture 2");
        ptsd->ddrval = DDERR_INVALIDPARAMS;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Swap the contents of the internal texture data structures.
     */
    texTemp    = *pTexture1;
    *pTexture1 = *pTexture2;
    *pTexture2 = texTemp;

    /*
     * Restore the original structure list pointers.
     * Even though the contents of the texture structure have been swapped,
     * the positions of the structures in the texture list does not change.
     */
    pTexture2->pTexturePrev = pTexture1->pTexturePrev;
    pTexture2->pTextureNext = pTexture1->pTextureNext;
    pTexture1->pTexturePrev = texTemp.pTexturePrev;
    pTexture1->pTextureNext = texTemp.pTextureNext;
    NV_LOCK_TEXTURE_SURFACE(pTexture1);
#ifdef NV_TEX2
    if ((TEX_SWIZZLE_ADDR(pTexture1,pTexture1->dwTextureFlags))
#else
    if ((pTexture1->dwTextureFlags & NV3_TEXTURE_SURFACE_ALLOCATED)
#endif
     && (pTexture1->lpLcl))
    {
        /*
         * Make sure the handle in the local surface structure is correct
         * after the swap.
         */
        pTexture1->lpLcl->dwReserved1 = ptsd->dwHandle1 | (pDriverData->dwTextureListHead & 0x80000000);

        /*
         * If the texture being swapped is the base of a user mipmap chain,
         * then it is neccessary to traverse the chain and update the mipmap base texture
         * field for each mipmap in the chain.
         */
        if ((pTexture1->lpLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP)
         && (pTexture1->lpLcl->lpAttachList))
        {
            LPDDRAWI_DDRAWSURFACE_LCL   lclMip;

            lclMip = pTexture1->lpLcl->lpAttachList->lpAttached;
            while (lclMip)
            {
                PNVD3DTEXTURE   pMipMap;

                pMipMap = (PNVD3DTEXTURE)lclMip->dwReserved1;
                if (pMipMap)
                    pMipMap->hMipBaseTexture = (DWORD)pTexture1;
                if (lclMip->lpAttachList)
                    lclMip = lclMip->lpAttachList->lpAttached;
                else
                    lclMip = 0;
            }
        }
    }
    NV_LOCK_TEXTURE_SURFACE(pTexture2);
#ifdef NV_TEX2
    if ((TEX_SWIZZLE_ADDR(pTexture2,pTexture2->dwTextureFlags))
#else
    if ((pTexture2->dwTextureFlags & NV3_TEXTURE_SURFACE_ALLOCATED)
#endif
     && (pTexture2->lpLcl))
    {
        /*
         * Make sure the handle in the local surface structure is correct
         * after the swap.
         */
        pTexture2->lpLcl->dwReserved1 = ptsd->dwHandle2 | (pDriverData->dwTextureListHead & 0x80000000);

        /*
         * If the texture being swapped is the base of a user mipmap chain,
         * then it is neccessary to traverse the chain and update the mipmap base texture
         * field for each mipmap in the chain.
         */
        if ((pTexture2->lpLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP)
         && (pTexture2->lpLcl->lpAttachList))
        {
            LPDDRAWI_DDRAWSURFACE_LCL   lclMip;

            lclMip = pTexture2->lpLcl->lpAttachList->lpAttached;
            while (lclMip)
            {
                PNVD3DTEXTURE   pMipMap;

                pMipMap = (PNVD3DTEXTURE)lclMip->dwReserved1;
                if (pMipMap)
                    pMipMap->hMipBaseTexture = (DWORD)pTexture2;
                if (lclMip->lpAttachList)
                    lclMip = lclMip->lpAttachList->lpAttached;
                else
                    lclMip = 0;
            }
        }
    }

    /*
     * Texture swap was successful.
     */
    ptsd->ddrval = DD_OK;
    NV_UNLOCK_TEXTURE_SURFACE(pTexture1);
    NV_UNLOCK_TEXTURE_SURFACE(pTexture2);

    return (DDHAL_DRIVER_HANDLED);
}
DWORD __stdcall nvTextureGetSurf
(
    LPD3DHAL_TEXTUREGETSURFDATA ptgd
)
{
    PNVD3DCONTEXT   pContext = 0;
    PNVD3DTEXTURE   pTexture = 0;

    /*
     * DUMB APPLICATION ALERT!!!!!
     * This code is going to look really strange, but there is a reason.  Believe it or not,
     * an application actually exists (Nightmare Creatures by Kalisto) that does not work if
     * the handle returned has bit 31 set.  Because of where the memory for our texture structures
     * is located, the high bit is always set, but I don't want to just blindly assume that this
     * is always going to be the case.  So, what I'm going to do is mask off the high bit of the
     * texture structure and return the remaining 31 bits as the handle, then in places where the
     * application passes in a texture handle, I will take the pointer to the head of the texture
     * list, mask off all but the high bit and OR it in with the handle to get the pointer to the
     * texture structure.  This should be safe since the texture structures are all allocated from
     * a linearly contiguous heap.
     */

    DPF_LEVEL(NVDBG_LEVEL_DDI_ENTRY, "nvTextureGetSurf - Get texture surface handle = %08lx", ptgd->dwHandle);

    /*
     * NOTES:
     *
     * This callback is invoked when the d3d needs to obtain the surface
     * refered to by a handle.
     *
     * Get the pointer to the specified context.
     */
    pContext = (PNVD3DCONTEXT)ptgd->dwhContext;
    if (!pContext)
    {
        dbgD3DError();
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureGetSurf - Bad Context");
        ptgd->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Get pointer to global driver data structure.
     */
    NvSetDriverDataPtrFromContext(pContext);

    /*
     * Get pointer to the texture.
     */
    pTexture = (PNVD3DTEXTURE)(ptgd->dwHandle | (pDriverData->dwTextureListHead & 0x80000000));

    if (!pTexture)
    {
        dbgD3DError();
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureGetSurf - Bad Texture");
        ptgd->ddrval = DDERR_INVALIDPARAMS;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Return the pointer to the texture surface.
     */
#ifndef WINNT
    ptgd->lpDDS = (DWORD)pTexture->lpDDS;
#else
    ptgd->hDDS = pTexture->hDDS;
#endif // #ifndef WINNT


    /*
     * Texture surface was gotten successfully.
     */
    ptgd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}

/*
 * --------------------------------------------------------------------------
 * Texture heap management routines.
 * --------------------------------------------------------------------------
 */
BOOL CreateTextureHeap
(
    void
)
{
    DWORD   status;
    DWORD   dwBlockStartOffset;

    /*
     * Something is very wrong if we don't have a pointer to NV at this point.
     */
    if ((!pDriverData->NvDevFlatDma) || (!pDriverData->NvBaseFlat))
        return (FALSE);

    /*
     * Only need to create the heap once.
     */
    if (pDriverData->hTextureHeap)
        return (TRUE);

    /*
     * The texture heap always starts out empty.
     */
    pDriverData->dwAllocSize = 0;

    /*
     * On AGP don't allocate a heap just use the GART address.
     */
    if (pDriverData->GARTLinearBase > 0)
    {
        /*
         * Make sure we don't do this more than neccessary.
         */
        CreateAGPListArray();
        pDriverData->hTextureHeap = 1;
        return (TRUE);
    }

    /*
     * Get the maximum size of the texture heap.
     */
    if (!(pDriverData->dwTextureHeapSizeMax = pDriverData->regTexHeap))
        return (TRUE);

    do
    {
        /*
         * Create the texture heap.
         */
#ifndef OLDSTUFF
        pDriverData->hTextureHeap = (DWORD)HEAPCREATE(pDriverData->dwTextureHeapSizeMax);
#else
        pDriverData->hTextureHeap = (DWORD)HeapCreate(HEAP_SHARED, pDriverData->dwTextureHeapSizeMax, 0);
#endif // #ifdef OLDSTUFF
        if (!pDriverData->hTextureHeap)
            return (FALSE);

        /*
         * Allocate the entire heap up front for management.
         */
#ifndef OLDSTUFF
        (PTEXHEAPHEADER)pDriverData->pRealHeapBase = (PTEXHEAPHEADER)HEAPALLOC((HANDLE)pDriverData->hTextureHeap, pDriverData->dwTextureHeapSizeMax);
#else
        (PTEXHEAPHEADER)pDriverData->pRealHeapBase = (PTEXHEAPHEADER)HeapAlloc((HANDLE)pDriverData->hTextureHeap, HEAP_ZERO_MEMORY, pDriverData->dwTextureHeapSizeMax);
#endif
        if (!pDriverData->pRealHeapBase)
        {
#ifndef OLDSTUFF
            HEAPDESTROY((HANDLE)pDriverData->hTextureHeap);
#else
            HeapDestroy((HANDLE)pDriverData->hTextureHeap);
#endif // #ifdef OLDSTUFF
            pDriverData->hTextureHeap = (DWORD)NULL;
            return (FALSE);
        }

        /*
         * Get the size of the allocated heap and set the maximum heap limit.
         * The size shouldn't be different than what we asked for, but do
         * the check anyway, just for fun.
         */
#ifndef OLDSTUFF
#ifndef WINNT
        pDriverData->dwTextureHeapSizeMax  = (DWORD)HEAPSIZE((HANDLE)pDriverData->hTextureHeap, (PTEXHEAPHEADER)pDriverData->pRealHeapBase);
#endif // #ifndef WINNT
#else
        pDriverData->dwTextureHeapSizeMax  = (DWORD)HeapSize((HANDLE)pDriverData->hTextureHeap, 0, (PTEXHEAPHEADER)pDriverData->pRealHeapBase);
#endif // #ifdef OLDSTUFF
        pDriverData->dwTextureHeapLimitMax = pDriverData->dwTextureHeapSizeMax - 1;

        /*
         * Align the heap properly.
         */
        pDriverData->pTextureHeapBase       = ((pDriverData->pRealHeapBase + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN);
        pDriverData->dwTextureHeapSizeMax  -= (pDriverData->pTextureHeapBase - pDriverData->pRealHeapBase);
        pDriverData->dwTextureHeapSizeMax  &= 0xFFFFFF00;
        pDriverData->dwTextureHeapLimitMax  = pDriverData->dwTextureHeapSizeMax - 1;
        pDriverData->dwFreeSize             = pDriverData->dwTextureHeapSizeMax - NV_TEXTURE_PAD;
        pDriverData->dwTextureHeapSize      = pDriverData->dwTextureHeapSizeMax;
        pDriverData->dwTextureHeapLimit     = pDriverData->dwTextureHeapSize - 1;

        /*
         * Try and lock down the entire heap.
         */
#ifdef  CACHE_FREECOUNT
        nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
        UnplugSystemMemoryTextureContext();
        status = AdjustTextureLimit(D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY, pDriverData->pTextureHeapBase, pDriverData->dwTextureHeapLimit, 0);
        UpdateTriangleContexts();
        if (status)
        {
            /*
             * Map the context to the frame buffer because the RM/Hardware doesn't
             * like having limts of 0.
             */
            UnplugSystemMemoryTextureContext();
#ifndef WINNT
            AdjustTextureLimit(D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY, pDriverData->BaseAddress, 0xFF, 0xFF);
#else
            AdjustTextureLimit(D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY, pDriverData->ppdev->pjScreen, 0xFF, 0xFF);
#endif // #ifdef WINNT
            UpdateTriangleContexts();
#ifndef OLDSTUFF
            HEAPFREE(pDriverData->hTextureHeap, (PTEXHEAPHEADER)pDriverData->pRealHeapBase);
            HEAPDESTROY((HANDLE)pDriverData->hTextureHeap);
#else
            HeapFree((HANDLE)pDriverData->hTextureHeap, 0, (PTEXHEAPHEADER)pDriverData->pRealHeapBase);
            HeapDestroy((HANDLE)pDriverData->hTextureHeap);
#endif
            pDriverData->hTextureHeap  = (DWORD)NULL;
            (PTEXHEAPHEADER)pDriverData->pRealHeapBase = (PTEXHEAPHEADER)NULL;
            if (status)
            {
                pDriverData->dwTextureHeapSizeMax -= min(pDriverData->dwTextureHeapSizeMax, HEAP_SIZE_ADJUST);
                if (!pDriverData->dwTextureHeapSizeMax)
                {
                    /*
                     * Can't lock down even a minimal heap.  Disable system memory textures.
                     */
                    pDriverData->regTexHeap             = 0;
                    pDriverData->dwTextureHeapSizeMax  = 0;
                    pDriverData->dwTextureHeapLimitMax = 0;
#ifdef  CACHE_FREECOUNT
                    pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
                    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
                    return (FALSE);
                }
            }
            else
            {
                /*
                 * Something more severe occured.  Disable system memory textures.
                 */
                pDriverData->regTexHeap            = 0;
                pDriverData->dwTextureHeapSizeMax  = 0;
                pDriverData->dwTextureHeapLimitMax = 0;
#ifdef  CACHE_FREECOUNT
                pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
                NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
                return (FALSE);
            }
        }
#ifdef  CACHE_FREECOUNT
        pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
    } while (!pDriverData->hTextureHeap);

    /*
     * Align the start of the texture.
     * 1) Original way was aligning the texture heap base address then aligning each
     *    individual texture start offset off of the texture heap base address.
     */
//    dwBlockStartOffset                       = (sizeof(TEXHEAPHEADER) + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN;
    /*
     * 2) New way is to align the texture heap address and align the start address of each
     *    texture.
     */
    dwBlockStartOffset = (((pDriverData->pTextureHeapBase + sizeof(TEXHEAPHEADER) + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN) - pDriverData->pTextureHeapBase);

    /*
     * Fill in the initial block structure.
     */
    ((PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead)                     = (PTEXHEAPHEADER)(pDriverData->pTextureHeapBase + dwBlockStartOffset - sizeof(TEXHEAPHEADER));
    ((PTEXHEAPHEADER)pDriverData->pTextureHeapFreeTail)                     = (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead;
    ((PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead)->dwTag              = HEAP_TAG_FREE;
    ((PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead)->dwBlockSize        = pDriverData->dwTextureHeapSizeMax - dwBlockStartOffset;
    ((PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead)->dwBlockStartOffset = dwBlockStartOffset;
    ((PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead)->pNextFreeBlock     = (PTEXHEAPHEADER)NULL;
    ((PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead)->pPrevFreeBlock     = (PTEXHEAPHEADER)NULL;
    ((PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead)->pNextAllocBlock    = (PTEXHEAPHEADER)NULL;
    ((PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead)->pPrevAllocBlock    = (PTEXHEAPHEADER)NULL;

    /*
     * Dump some information about the texture heap.
     */
    DPF_LEVEL(NVDBG_LEVEL_INFO, "CreateTextureHeap - pTextureHeapBase      = %08lx", pDriverData->pTextureHeapBase);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "CreateTextureHeap - dwTextureHeapSizeMax  = %08lx", pDriverData->dwTextureHeapSizeMax);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "CreateTextureHeap - dwTextureHeapLimitMax = %08lx", pDriverData->dwTextureHeapLimitMax);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "CreateTextureHeap - dwTextureHeapSize     = %08lx", pDriverData->dwTextureHeapSize);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "CreateTextureHeap - dwTextureHeapLimit    = %08lx", pDriverData->dwTextureHeapLimit);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "CreateTextureHeap - dwFreeSize            = %08lx", pDriverData->dwFreeSize);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "CreateTextureHeap - dwAllocSize           = %08lx", pDriverData->dwAllocSize);

    /*
     * Return successfully.
     */
    return (TRUE);
}
BOOL DestroyTextureHeap
(
    void
)
{
    /*
     * Can't destroy a heap if there isn't one.
     */
    if (!pDriverData->hTextureHeap)
        return (TRUE);

    /*
     * Tear down the Texture DMA context.
     * Note: Need to be careful here, because there are some instances that
     * the channel may already be closed at this point.
     */
    /*
     * Something is very wrong if we don't have a pointer to NV at this point.
     */
    if ((pDriverData->NvDevFlatDma) && (pDriverData->NvBaseFlat))
    {
        /*
         * Map the context to the frame buffer because the RM/Hardware doesn't
         * like having limts of 0.
         */
#ifdef  CACHE_FREECOUNT
        nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
        UnplugSystemMemoryTextureContext();
#ifndef WINNT
        AdjustTextureLimit(D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY, pDriverData->BaseAddress, 0xFF, 0xFF);
#else
        AdjustTextureLimit(D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY, pDriverData->ppdev->pjScreen, 0xFF, 0xFF);
#endif // #ifdef WINNT

        UpdateTriangleContexts();
#ifdef  CACHE_FREECOUNT
        pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
    }

    /*
     * Free and destroy the texture heap.
     */
    if (pDriverData->GARTLinearBase == 0)
    {
        /*
         * Only need to free the heap if it was allocated.  (it won't be
         * allocated on an AGP system)
         */
#ifndef OLDSTUFF
        HEAPFREE(pDriverData->hTextureHeap, (PTEXHEAPHEADER)pDriverData->pRealHeapBase);
        HEAPDESTROY(pDriverData->hTextureHeap);
#else
        HeapFree((HANDLE)pDriverData->hTextureHeap, 0, (PTEXHEAPHEADER)pDriverData->pRealHeapBase);
        HeapDestroy((HANDLE)pDriverData->hTextureHeap);
#endif
    }
    else
        DestroyAGPListArray();

    /*
     * Clean up a little bit.
     */
    pDriverData->hTextureHeap                           = (DWORD)NULL;
    (PTEXHEAPHEADER)pDriverData->pRealHeapBase         = (PTEXHEAPHEADER)NULL;
    (PTEXHEAPHEADER)pDriverData->pTextureHeapBase      = (PTEXHEAPHEADER)NULL;
    (PTEXHEAPHEADER)pDriverData->pTextureHeapAllocHead = (PTEXHEAPHEADER)NULL;
    (PTEXHEAPHEADER)pDriverData->pTextureHeapAllocTail = (PTEXHEAPHEADER)NULL;
    (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead  = (PTEXHEAPHEADER)NULL;
    (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeTail  = (PTEXHEAPHEADER)NULL;
    pDriverData->dwTextureHeapSize                     = 0;
    pDriverData->dwTextureHeapSizeMax                  = 0;
    pDriverData->dwTextureHeapLimit                    = 0;
    pDriverData->dwTextureHeapLimitMax                 = 0;
    pDriverData->dwAllocSize                           = 0;
    pDriverData->dwFreeSize                            = 0;
    return (TRUE);
}
DWORD AllocTextureHeap
(
    DWORD   dwSizeRequest
)
{
    DWORD           dwAllocBlockSize;
    DWORD           dwNewFreeBlockSize;
    DWORD           dwNewFreeBlockOffset;
    DWORD           dwNewFreeBlockStartOffset;
    DWORD           dwAllocLimit;
    PTEXHEAPHEADER  pAllocBlock;
    PTEXHEAPHEADER  pList;
    PTEXHEAPHEADER  pNextFree;
    PTEXHEAPHEADER  pPrevFree;
    PTEXHEAPHEADER  pNewFree;

    DPF_LEVEL(NVDBG_LEVEL_FUNCTION_CALL, "AllocTextureHeap - dwSizeRequest = %08lx", dwSizeRequest);

    /*
     * Create the texture heap if it doesn't exist yet.
     */
    if (!pDriverData->hTextureHeap)
        CreateTextureHeap();

    /*
     * If the free list is null, then there's no memory to be allocated.
     */
    if ((!pDriverData->pTextureHeapFreeHead)
     || (pDriverData->dwFreeSize < dwSizeRequest))
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "AllocTextureHeap - Not enough free memory to fill request!");
        return (0);
    }

    /*
     * Search the free block list for a block large enough to fill this
     * request.
     */
    pAllocBlock      = (PTEXHEAPHEADER)NULL;
    dwAllocBlockSize = 0;
    pList            = (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead;

    /*
     * The search will end when a block has been found that exactly matches
     * the requested size or the end of the free list has been reached. In the
     * event that an exact size match is not found, then the first block that is
     * closest to the requested size will be used.
     *
     * CHASNOTE: Potential problem with this method is that a larger block might
     * be passed up for a smaller block later in the heap and this could mean that
     * the context limit will fail shrink when it may have otherwise if the larger
     * block was used.
     */
    while ((pList)
        && (dwAllocBlockSize != dwSizeRequest))
    {
        if (pList->dwBlockSize >= dwSizeRequest)
        {
            if ((!dwAllocBlockSize)
             || (pList->dwBlockSize < dwAllocBlockSize))
            {
                pAllocBlock      = pList;
                dwAllocBlockSize = pList->dwBlockSize;
            }
        }
        pList = pList->pNextFreeBlock;
    }

    /*
     * If there was no block large enough to fill the request, return unsuccessful.
     */
    if (!pAllocBlock)
        return (0);

    /*
     * Get a few pointers.
     */
    pPrevFree                   = pAllocBlock->pPrevFreeBlock;
    pNextFree                   = pAllocBlock->pNextFreeBlock;
    pAllocBlock->pPrevFreeBlock = (PTEXHEAPHEADER)NULL;
    pAllocBlock->pNextFreeBlock = (PTEXHEAPHEADER)NULL;

    /*
     * Initialize the newly allocated block header and create
     * the new free block as neccessary.
     */
    pAllocBlock->dwTag       = HEAP_TAG_ALLOC;
    pAllocBlock->dwBlockSize = dwSizeRequest;

    /*
     * Allocate any new free block if the block being used for the allocation
     * is larger than the requested block size.
     */
    dwNewFreeBlockSize = dwAllocBlockSize - dwSizeRequest;

    /*
     * Adjust alignment so the next free block starts on the correct boundry for an NV3
     * texture.
     */
    if (dwNewFreeBlockSize >= (sizeof(TEXHEAPHEADER) + NV_MIN_TEXTURE_SIZE))
    {
        DWORD dwNextBlockOffset;
        DWORD dwExcess;

        dwNextBlockOffset         = pAllocBlock->dwBlockStartOffset + dwSizeRequest;
        /*
         * Align the start of the texture.
         * 1) Original way was aligning the texture heap base address then aligning each
         *    individual texture start offset off of the texture heap base address.
         */
//        dwNewFreeBlockStartOffset = (dwNextBlockOffset + sizeof(TEXHEAPHEADER) + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN;
        /*
         * 2) New way is to align the texture heap address and align the start address of each
         *    texture.
         */
        dwNewFreeBlockStartOffset = ((((pDriverData->pTextureHeapBase + dwNextBlockOffset + sizeof(TEXHEAPHEADER)) + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN) - pDriverData->pTextureHeapBase);
        dwNewFreeBlockOffset      = dwNewFreeBlockStartOffset - sizeof(TEXHEAPHEADER);
        dwExcess                  = dwNewFreeBlockOffset - dwNextBlockOffset;
        dwNewFreeBlockSize       -= dwExcess;
        pAllocBlock->dwBlockSize += dwExcess;
    }

    /*
     * Now that the block has been aligned on the correct boundry, check again to make sure
     * that there's still enough room for a minimum sized texture.
     */
    if (dwNewFreeBlockSize >= (sizeof(TEXHEAPHEADER) + NV_MIN_TEXTURE_SIZE))
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "AllocTextureHeap - Create new free block at end of allocation block.");

        /*
         * Create the new free block.
         */
        pNewFree                     = (PTEXHEAPHEADER)(pDriverData->pTextureHeapBase + dwNewFreeBlockOffset);
        pNewFree->dwTag              = HEAP_TAG_FREE;
        pNewFree->dwBlockStartOffset = dwNewFreeBlockStartOffset;
        pNewFree->dwBlockSize        = dwNewFreeBlockSize - sizeof(TEXHEAPHEADER);
        pNewFree->pNextFreeBlock     = pNextFree;
        pNewFree->pPrevFreeBlock     = pPrevFree;
        pNewFree->pNextAllocBlock    = (PTEXHEAPHEADER)NULL;
        pNewFree->pPrevAllocBlock    = (PTEXHEAPHEADER)NULL;

        /*
         * Insert the new free block into the free block list.
         */
        if (pPrevFree)
            pPrevFree->pNextFreeBlock = pNewFree;
        else
            (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead = pNewFree;
        if (pNextFree)
            pNextFree->pPrevFreeBlock = pNewFree;
        else
            (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeTail = pNewFree;
    }
    else
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "AllocTextureHeap - Tack excess free memory  onto end of allocation block.");

        /*
         * Tack the excess memory on to the end of the block.
         */
        pAllocBlock->dwBlockSize += dwNewFreeBlockSize;

        /*
         * Remove the block from the free block list.
         */
        if (pPrevFree)
            pPrevFree->pNextFreeBlock = pNextFree;
        else
            (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead = pNextFree;

        if (pNextFree)
            pNextFree->pPrevFreeBlock = pPrevFree;
        else
            (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeTail = pPrevFree;
    }

    /*
     * Update the allocation sizes.
     */
    pDriverData->dwAllocSize += pAllocBlock->dwBlockSize;
    pDriverData->dwFreeSize  -= pAllocBlock->dwBlockSize;

    /*
     * Insert the newly allocated block into the allocation list.
     * First handle the best case scenarios, the block is either the first block
     * to be allocated, the block comes before the current head of the allocation
     * list, or the block comes after the current tail of the allocation list.
     * In these cases, its simply a case of updating a few pointers.
     */
    if (!pDriverData->pTextureHeapAllocHead)
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "AllocTextureHeap - Insert new allocation block at head of allocation list. First time.");
        pAllocBlock->pPrevAllocBlock                        = (PTEXHEAPHEADER)NULL;
        pAllocBlock->pNextAllocBlock                        = (PTEXHEAPHEADER)NULL;
        (PTEXHEAPHEADER)pDriverData->pTextureHeapAllocHead = pAllocBlock;
        (PTEXHEAPHEADER)pDriverData->pTextureHeapAllocTail = pAllocBlock;

        /*
         * The tail of allocation list has changed. Check to see if the texture context
         * needs to be udpated to reflect the change.
         */
        if (pDriverData->pTextureHeapAllocTail)
            dwAllocLimit = ((PTEXHEAPHEADER)pDriverData->pTextureHeapAllocTail)->dwBlockStartOffset + ((PTEXHEAPHEADER)pDriverData->pTextureHeapAllocTail)->dwBlockSize - 1;
        else
            dwAllocLimit = 0;
    }
    else if (pAllocBlock < (PTEXHEAPHEADER)pDriverData->pTextureHeapAllocHead)
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "AllocTextureHeap - Insert new allocation block at head of allocation list.");
        ((PTEXHEAPHEADER)pDriverData->pTextureHeapAllocHead)->pPrevAllocBlock = pAllocBlock;
        pAllocBlock->pPrevAllocBlock                                           = (PTEXHEAPHEADER)NULL;
        pAllocBlock->pNextAllocBlock                                           = (PTEXHEAPHEADER)pDriverData->pTextureHeapAllocHead;
        (PTEXHEAPHEADER)pDriverData->pTextureHeapAllocHead                    = pAllocBlock;
    }
    else if (pAllocBlock > (PTEXHEAPHEADER)pDriverData->pTextureHeapAllocTail)
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "AllocTextureHeap - Insert new allocation block at tail of allocation list.");
        ((PTEXHEAPHEADER)pDriverData->pTextureHeapAllocTail)->pNextAllocBlock = pAllocBlock;
        pAllocBlock->pPrevAllocBlock                                           = (PTEXHEAPHEADER)pDriverData->pTextureHeapAllocTail;
        pAllocBlock->pNextAllocBlock                                           = (PTEXHEAPHEADER)NULL;
        (PTEXHEAPHEADER)pDriverData->pTextureHeapAllocTail                    = pAllocBlock;

        /*
         * The tail of allocation list has changed. Check to see if the texture context
         * needs to be udpated to reflect the change.
         */
        if (pDriverData->pTextureHeapAllocTail)
            dwAllocLimit = ((PTEXHEAPHEADER)pDriverData->pTextureHeapAllocTail)->dwBlockStartOffset + ((PTEXHEAPHEADER)pDriverData->pTextureHeapAllocTail)->dwBlockSize - 1;
        else
            dwAllocLimit = 0;
    }
    else
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "AllocTextureHeap - Insert new allocation block in middle of allocation list.");

        /* WORST CASE
         * The newly allocated block falls between the head and tail of the allocation
         * list. Search all memory blocks following the new allocation block to find the
         * next allocated block, then just update the pointers.
         */
        pList = (PTEXHEAPHEADER)((DWORD)pAllocBlock + sizeof(TEXHEAPHEADER) + pAllocBlock->dwBlockSize);
        while ((pList)
            && (pList->dwTag != HEAP_TAG_ALLOC))
        {
            pList = (PTEXHEAPHEADER)((DWORD)pList + sizeof(TEXHEAPHEADER) + pList->dwBlockSize);
        }
        /*
         * This should never happen, if it does, then we've got problems.
         */
        if (!pList)
        {
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "AllocTextureHeap - Error inserting new allocation block!!");
            return (pAllocBlock->dwBlockStartOffset);
        }

        /*
         * Update the pointers.
         */
        pAllocBlock->pPrevAllocBlock                  = pList->pPrevAllocBlock;
        pAllocBlock->pNextAllocBlock                  = pList;
        pList->pPrevAllocBlock                        = pAllocBlock;
        pAllocBlock->pPrevAllocBlock->pNextAllocBlock = pAllocBlock;
    }

    /*
     * Dump some information about the texture heap allocation.
     */
    DPF_LEVEL(NVDBG_LEVEL_INFO, "AllocTextureHeap - pAllocBlock->dwBlockStartOffset = %08lx", (DWORD)pAllocBlock->dwBlockStartOffset);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "AllocTextureHeap - dwTextureHeapSize               = %08lx", pDriverData->dwTextureHeapSize);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "AllocTextureHeap - dwTextureHeapLimit              = %08lx", pDriverData->dwTextureHeapLimit);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "AllocTextureHeap - dwFreeSize                      = %08lx", pDriverData->dwFreeSize);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "AllocTextureHeap - dwAllocSize                     = %08lx", pDriverData->dwAllocSize);

    /*
     * Return the offset to the allocated block.
     */
    return (pAllocBlock->dwBlockStartOffset);
}
BOOL FreeTextureHeap
(
    DWORD   dwFreeBlockOffset
)
{
    DWORD           dwAllocLimit;
    PTEXHEAPHEADER  pList;
    PTEXHEAPHEADER  pFreeBlock;
    PTEXHEAPHEADER  pPrevFree;
    PTEXHEAPHEADER  pNextFree;
    PTEXHEAPHEADER  pPrevAlloc;
    PTEXHEAPHEADER  pNextAlloc;

    DPF_LEVEL(NVDBG_LEVEL_FUNCTION_CALL, "FreeTextureHeap - dwFreeBlockOffset       = %08lx", dwFreeBlockOffset);

    /*
     * Make sure there is a valid texture heap to free the memory from.
     */
    if (!pDriverData->pTextureHeapBase)
        return (TRUE);

    /*
     * Make sure there is actually a valid texture block to free.
     */
    if (!dwFreeBlockOffset)
        return (FALSE);

    /*
     * Calculate the pointer to the header of the block being freed.
     */
    pFreeBlock = (PTEXHEAPHEADER)(pDriverData->pTextureHeapBase + (dwFreeBlockOffset - sizeof(TEXHEAPHEADER)));
    DPF_LEVEL(NVDBG_LEVEL_INFO, "FreeTextureHeap - pFreeBlock->dwBlockSize = %08lx", pFreeBlock->dwBlockSize);

    /*
     * Make sure we are pointer to an actual allocated block header.
     */
    if (pFreeBlock->dwTag != HEAP_TAG_ALLOC)
        return (FALSE);

    /*
     * Get a few pointers.
     */
    pPrevAlloc                  = pFreeBlock->pPrevAllocBlock;
    pNextAlloc                  = pFreeBlock->pNextAllocBlock;
    pFreeBlock->pPrevAllocBlock = (PTEXHEAPHEADER)NULL;
    pFreeBlock->pNextAllocBlock = (PTEXHEAPHEADER)NULL;

    /*
     * Remove the block from the allocation list.
     */
    if (pPrevAlloc)
        pPrevAlloc->pNextAllocBlock = pNextAlloc;
    else
        (PTEXHEAPHEADER)pDriverData->pTextureHeapAllocHead = pNextAlloc;
    if (pNextAlloc)
        pNextAlloc->pPrevAllocBlock = pPrevAlloc;
    else
    {
        (PTEXHEAPHEADER)pDriverData->pTextureHeapAllocTail = pPrevAlloc;

        /*
         * The tail of allocation list has changed. Check to see if the texture context
         * needs to be udpated to reflect the change.
         */
        if (pDriverData->pTextureHeapAllocTail)
            dwAllocLimit = ((PTEXHEAPHEADER)pDriverData->pTextureHeapAllocTail)->dwBlockStartOffset + ((PTEXHEAPHEADER)pDriverData->pTextureHeapAllocTail)->dwBlockSize - 1;
        else
            dwAllocLimit = 0;
    }

    /*
     * Mark the block as freed and get the size of the block.
     */
    pFreeBlock->dwTag = HEAP_TAG_FREE;

    /*
     * Update the allocation sizes.
     */
    pDriverData->dwAllocSize -= pFreeBlock->dwBlockSize;
    pDriverData->dwFreeSize  += pFreeBlock->dwBlockSize;

    /*
     * Insert the newly freed block into the free list.
     */
    if (!pDriverData->pTextureHeapFreeHead)
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "FreeTextureHeap - Insert new free block at head of free list. First time.");
        pFreeBlock->pPrevFreeBlock                         = (PTEXHEAPHEADER)NULL;
        pFreeBlock->pNextFreeBlock                         = (PTEXHEAPHEADER)NULL;
        (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead = pFreeBlock;
        (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeTail = pFreeBlock;
    }
    else if (pFreeBlock < (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead)
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "FreeTextureHeap - Insert new free block at head of free list.");
        ((PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead)->pPrevFreeBlock = pFreeBlock;
        pFreeBlock->pPrevFreeBlock                                           = (PTEXHEAPHEADER)NULL;
        pFreeBlock->pNextFreeBlock                                           = (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead;
        (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead                   = pFreeBlock;
    }
    else if (pFreeBlock > (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeTail)
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "FreeTextureHeap - Insert new free block at tail of free list.");
        ((PTEXHEAPHEADER)pDriverData->pTextureHeapFreeTail)->pNextFreeBlock = pFreeBlock;
        pFreeBlock->pPrevFreeBlock                                           = (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeTail;
        pFreeBlock->pNextFreeBlock                                           = (PTEXHEAPHEADER)NULL;
        (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeTail                   = pFreeBlock;
    }
    else
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "FreeTextureHeap - Insert new free block in middle of free list.");

        /* WORST CASE
         * The newly freed block falls between the head and tail of the free
         * list. Search all memory blocks following the new freed block to find the
         * next free block, then just update the pointers.
         */
        pList = (PTEXHEAPHEADER)((DWORD)pFreeBlock + sizeof(TEXHEAPHEADER) + pFreeBlock->dwBlockSize);
        while ((pList)
            && (pList->dwTag != HEAP_TAG_FREE))
        {
            pList = (PTEXHEAPHEADER)((DWORD)pList + sizeof(TEXHEAPHEADER) + pList->dwBlockSize);
        }
        /*
         * This should never happen, if it does, then we've got problems.
         */
        if (!pList)
        {
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "FreeTextureHeap - Error inserting newly freed block!!");
            return (TRUE);
        }

        /*
         * Update the pointers.
         */
        pFreeBlock->pPrevFreeBlock                 = pList->pPrevFreeBlock;
        pFreeBlock->pNextFreeBlock                 = pList;
        pList->pPrevFreeBlock                      = pFreeBlock;
        pFreeBlock->pPrevFreeBlock->pNextFreeBlock = pFreeBlock;
    }

    /*
     * Do some basic garbage collection to try and consolidate contiguous free
     * blocks.
     */
    pPrevFree = pFreeBlock->pPrevFreeBlock;
    pNextFree = pFreeBlock->pNextFreeBlock;
    if ((pPrevFree)
     && (((DWORD)pPrevFree + sizeof(TEXHEAPHEADER) + pPrevFree->dwBlockSize) == (DWORD)pFreeBlock))
    {
        /*
         * Merge the previous free block with the new free block.
         */
        pPrevFree->dwBlockSize += sizeof(TEXHEAPHEADER) + pFreeBlock->dwBlockSize;
        if (pPrevFree->pNextFreeBlock = pNextFree)
            pNextFree->pPrevFreeBlock = pPrevFree;
        else
            (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeTail = pPrevFree;

        /*
         * Clean out the old free block header.
         */
        pFreeBlock->dwTag              = 0;
        pFreeBlock->dwBlockSize        = 0;
        pFreeBlock->dwBlockStartOffset = 0;
        pFreeBlock->pPrevFreeBlock     = (PTEXHEAPHEADER)NULL;
        pFreeBlock->pNextFreeBlock     = (PTEXHEAPHEADER)NULL;
        pFreeBlock->pPrevAllocBlock    = (PTEXHEAPHEADER)NULL;
        pFreeBlock->pNextAllocBlock    = (PTEXHEAPHEADER)NULL;

        /*
         * Update the free block pointer to point to the new consolidated block.
         */
        pFreeBlock = pPrevFree;
    }
    if ((pNextFree)
     && (((DWORD)pFreeBlock + sizeof(TEXHEAPHEADER) + pFreeBlock->dwBlockSize) == (DWORD)pNextFree))
    {
        /*
         * Merge the new free block with the next free block.
         */
        pFreeBlock->dwBlockSize += sizeof(TEXHEAPHEADER) + pNextFree->dwBlockSize;
        if (pFreeBlock->pNextFreeBlock = pNextFree->pNextFreeBlock)
            pNextFree->pNextFreeBlock->pPrevFreeBlock = pFreeBlock;
        else
            (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeTail = pFreeBlock;

        /*
         * Clean out the old free block header.
         */
        pNextFree->dwTag              = 0;
        pNextFree->dwBlockSize        = 0;
        pNextFree->dwBlockStartOffset = 0;
        pNextFree->pPrevFreeBlock     = (PTEXHEAPHEADER)NULL;
        pNextFree->pNextFreeBlock     = (PTEXHEAPHEADER)NULL;
        pNextFree->pPrevAllocBlock    = (PTEXHEAPHEADER)NULL;
        pNextFree->pNextAllocBlock    = (PTEXHEAPHEADER)NULL;
    }

    /*
     * Dump some information about the texture heap allocation.
     */
    DPF_LEVEL(NVDBG_LEVEL_INFO, "FreeTextureHeap - dwTextureHeapSize  = %08lx", pDriverData->dwTextureHeapSize);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "FreeTextureHeap - dwTextureHeapLimit = %08lx", pDriverData->dwTextureHeapLimit);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "FreeTextureHeap - dwFreeSize         = %08lx", pDriverData->dwFreeSize);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "FreeTextureHeap - dwAllocSize        = %08lx", pDriverData->dwAllocSize);

    /*
     * Destroy the texture heap if there's nothing left allocated in it.
     */
    if (!pDriverData->pTextureHeapAllocHead)
        DestroyTextureHeap();

    /*
     * Return successfully.
     */
    return (TRUE);
}
DWORD GetPointerTextureHeap
(
    DWORD   dwBlockOffset
)
{
    DWORD           dwBlockPointer;
    PTEXHEAPHEADER  pBlockHeader;

    dwBlockPointer = pDriverData->pTextureHeapBase + dwBlockOffset;
    pBlockHeader   = (PTEXHEAPHEADER)(dwBlockPointer - sizeof(TEXHEAPHEADER));

    if ((!pBlockHeader)
     || (pBlockHeader->dwTag != HEAP_TAG_ALLOC))
        return (0);

    /*
     * Return the pointer to the start of the memory block.
     */
    return (dwBlockPointer);
}

typedef struct _def_agp_heap_list   AGPHEAPLIST, *PAGPHEAPLIST;
struct _def_agp_heap_list
{
    DWORD           hCurrent;
    DWORD           dwPointer;
    DWORD           dwAlignedPointer;
    DWORD           dwSize;
    DWORD           dwLimit;
    HDDRVITEM       hPrev;
    HDDRVITEM       hNext;
};
HDDRVITEM           hAGPHeapHead = (HDDRVITEM)0;
HDDRVITEM           hAGPHeapTail = (HDDRVITEM)0;
DWORD AllocAGPHeap
(
    LPDDRAWI_DIRECTDRAW_GBL pDrv,
    DWORD                   dwSize
)
{
    DWORD           dwOffset;
    DWORD           dwCurrentLimit;
    DWORD           dwNewBlockLimit;
    DWORD           pAGPMem;
    HDDRVITEM       hAGPListBlock;
    PAGPHEAPLIST    pAGPHeap;
    PAGPHEAPLIST    pAGPListBlock;
    PAGPHEAPLIST    pAGPHeapHead;
    PAGPHEAPLIST    pAGPHeapTail;
    PAGPHEAPLIST    pNext;

    /*
     * Something is very wrong if we don't have a pointer to NV at this point.
     */
    if ((!pDriverData->NvDevFlatDma) || (!pDriverData->NvBaseFlat))
        return (0);

    /*
     * Make sure this is AGP.
     */
    if (pDriverData->GARTLinearBase == 0)
        return (0);

    /*
     * Create the texture heap if it doesn't exist yet.
     */
    if (!pDriverData->hTextureHeap)
        CreateTextureHeap();

    /*
     * Allocate an entry in the texture item array for the new texture.
     */
#ifndef OLDSTUFF
    hAGPListBlock = (HDDRVITEM)HEAPALLOC(pDriverData->hAGPList_gbl, sizeof(AGPHEAPLIST));
    if (!hAGPListBlock)
        return (0);
    pAGPListBlock = (PAGPHEAPLIST)hAGPListBlock;
    pAGPHeapHead  = (PAGPHEAPLIST)hAGPHeapHead; // Needs to be in pDriverData
    pAGPHeapTail  = (PAGPHEAPLIST)hAGPHeapTail; // Needs to be in pDriverData
#else
    DDrvItemArrayAlloc(pDriverData->hAGPList_gbl, &hAGPListBlock);
    if (!hAGPListBlock)
        return (0);
    pAGPListBlock = (PAGPHEAPLIST)DDrvItemArrayGetPtr(pDriverData->hAGPList_gbl, hAGPListBlock);
    if (!pAGPListBlock)
    {
        DDrvItemArrayFree(pDriverData->hAGPList_gbl, hAGPListBlock);
        return (0);
    }
    pAGPHeapHead = (PAGPHEAPLIST)DDrvItemArrayGetPtr(pDriverData->hAGPList_gbl, hAGPHeapHead);
    pAGPHeapTail = (PAGPHEAPLIST)DDrvItemArrayGetPtr(pDriverData->hAGPList_gbl, hAGPHeapTail);
#endif

    /*
     * Allocate the memory from the AGP heap.
     * Add padding to prevent DMA limit errors.
     */
    dwSize += NV_TEXTURE_PAD;
    pAGPMem = (DWORD)DDHAL32_VidMemAlloc(pDrv, AGP_HEAP, dwSize, 1);
    if (pAGPMem)
    {
        dwNewBlockLimit = ((pAGPMem - pDriverData->GARTLinearBase) + dwSize & 0xFFFFFF00) - 1;
        dwCurrentLimit = (pAGPHeapTail) ? pAGPHeapTail->dwLimit : 0;
        if (dwNewBlockLimit > dwCurrentLimit)
        {
            /*
             * Adjust the limit on the AGP context.
             */

#ifdef  CACHE_FREECOUNT
            nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
            NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
            UnplugSystemMemoryTextureContext();
            if (AdjustTextureLimit(D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY, pDriverData->GARTLinearBase, dwNewBlockLimit, dwCurrentLimit))
            {
                /*
                 * Free the memory since the new limit could not be set.
                 */
                DDHAL32_VidMemFree(pDrv, AGP_HEAP, pAGPMem);

#ifndef OLDSTUFF
                HEAPFREE(pDriverData->hAGPList_gbl, (HDDRVITEM)hAGPListBlock);
#else
                DDrvItemArrayFree(pDriverData->hAGPList_gbl, (HDDRVITEM)hAGPListBlock);
#endif

                /*
                 * Could not set the new limit.  Return an error.
                 */
                UpdateTriangleContexts();
#ifdef  CACHE_FREECOUNT
                pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
                NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
                return (0);
            }
            UpdateTriangleContexts();
#ifdef  CACHE_FREECOUNT
            pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
            NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
            pDriverData->dwAllocSize += dwSize;

            /*
             * Store the current texture heap limit.
             */
            pDriverData->dwTextureHeapLimit = dwNewBlockLimit;
        }

        /*
         * Insert the new allocation block into the heap allocation list.
         */
        pAGPListBlock->hCurrent  = hAGPListBlock;
        pAGPListBlock->dwPointer = pAGPMem;

        /*
         * Align the start of the texture.
         * 1) Original way was each individual texture start offset off of the
         *    texture heap base address.
         */
//        dwOffset = ((pAGPMem - pDriverData->GARTLinearBase) + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN;
        /*
         * 2) New way is to align the start address of each texture.
         */
        dwOffset = ((pAGPMem + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN) - pDriverData->GARTLinearBase;
        pAGPMem  = pDriverData->GARTLinearBase + dwOffset;
        pAGPListBlock->dwAlignedPointer = pAGPMem;
        pAGPListBlock->dwSize           = dwSize;
        pAGPListBlock->dwLimit          = dwNewBlockLimit;
        pAGPHeap = pAGPHeapTail;
#ifndef OLDSTUFF
        while ((pAGPHeap) && (dwNewBlockLimit < pAGPHeap->dwLimit))
            pAGPHeap = (PAGPHEAPLIST)pAGPHeap->hPrev;
#else
        while ((pAGPHeap) && (dwNewBlockLimit < pAGPHeap->dwLimit))
            pAGPHeap = (PAGPHEAPLIST)DDrvItemArrayGetPtr(pDriverData->hAGPList_gbl, pAGPHeap->hPrev);
#endif
        if (pAGPHeap)
        {
#ifndef OLDSTUFF
            pNext = (PAGPHEAPLIST)pAGPHeap->hNext;
#else
            pNext = (PAGPHEAPLIST)DDrvItemArrayGetPtr(pDriverData->hAGPList_gbl, pAGPHeap->hNext);
#endif
            pAGPListBlock->hPrev = pAGPHeap->hCurrent;
            pAGPListBlock->hNext = pAGPHeap->hNext;
            pAGPHeap->hNext      = hAGPListBlock;
            if (pNext)
                pNext->hPrev = hAGPListBlock;
            else
                hAGPHeapTail = hAGPListBlock;
        }
        else
        {
            if (hAGPHeapHead)
            {
                pAGPListBlock->hPrev = (HDDRVITEM)NULL;
                pAGPListBlock->hNext = hAGPHeapHead;
            }
            else
            {
                pAGPListBlock->hPrev = (HDDRVITEM)NULL;
                pAGPListBlock->hNext = (HDDRVITEM)NULL;
                hAGPHeapTail = hAGPListBlock;
            }
            hAGPHeapHead = hAGPListBlock;
        }
    }
    else
    {
#ifndef OLDSTUFF
        HEAPFREE(pDriverData->hAGPList_gbl, (HDDRVITEM)hAGPListBlock);
#else
        DDrvItemArrayFree(pDriverData->hAGPList_gbl, (HDDRVITEM)hAGPListBlock);
#endif
        return (0);
    }
    if ((pAGPListBlock->dwAlignedPointer & NV_TEXTURE_OFFSET_ALIGN)
     || (((pAGPListBlock->dwAlignedPointer - pDriverData->GARTLinearBase) & NV_TEXTURE_OFFSET_ALIGN)))
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "AllocAGPHeap - Alignment Error - dwPointer        = %08lx", pAGPListBlock->dwPointer);
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "                                 dwAlignedPointer = %08lx", pAGPListBlock->dwAlignedPointer);
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "                                 dwOffset         = %08lx", (pAGPListBlock->dwAlignedPointer - pDriverData->GARTLinearBase));
    }
    return (pAGPMem);
}
BOOL FreeAGPHeap
(
    LPDDRAWI_DIRECTDRAW_GBL pDrv,
    DWORD                   pMem
)
{
    DWORD           dwBlockLimit;
    DWORD           dwNewLimit;
    HDDRVITEM       hAGPListBlock;
    HDDRVITEM       hAGPHeap;
    PAGPHEAPLIST    pAGPHeap;
    PAGPHEAPLIST    pAGPHeapHead;
    PAGPHEAPLIST    pAGPHeapTail;
    PAGPHEAPLIST    pPrev;
    PAGPHEAPLIST    pNext;

    /*
     * Make sure this is AGP.
     */
    if (pDriverData->GARTLinearBase == 0)
        return (FALSE);

    /*
     * Find the allocation list block for this address.
     */
#ifndef OLDSTUFF
    pAGPHeapHead = (PAGPHEAPLIST)hAGPHeapHead;
    pAGPHeapTail = (PAGPHEAPLIST)hAGPHeapTail;
#else
    pAGPHeapHead = (PAGPHEAPLIST)DDrvItemArrayGetPtr(pDriverData->hAGPList_gbl, hAGPHeapHead);
    pAGPHeapTail = (PAGPHEAPLIST)DDrvItemArrayGetPtr(pDriverData->hAGPList_gbl, hAGPHeapTail);
#endif
    pAGPHeap     = pAGPHeapHead;
    hAGPHeap     = hAGPHeapHead;
    while ((pAGPHeap) && (pMem != pAGPHeap->dwAlignedPointer))
    {
        /*
         * Watch out for infinite looping.
         */
        if ((pAGPHeap->hNext) && (pAGPHeap->hNext != hAGPHeap))
        {
            hAGPHeap = pAGPHeap->hNext;
#ifndef OLDSTUFF
            pAGPHeap = (PAGPHEAPLIST)hAGPHeap;
#else
            pAGPHeap = (PAGPHEAPLIST)DDrvItemArrayGetPtr(pDriverData->hAGPList_gbl, hAGPHeap);
#endif
        }
        else
        {
            /*
             * Something is messed up because this block is pointing to itself.
             */
            pAGPHeap->hNext = (HDDRVITEM)NULL;
            hAGPHeapTail    = hAGPHeap;
            pAGPHeap        = (PAGPHEAPLIST)NULL;
            hAGPHeap        = (HDDRVITEM)NULL;
        }
    }

    if (pAGPHeap)
    {
        /*
         * Need to free the orignal pointer that was allocated.
         */
        pMem = pAGPHeap->dwPointer;

        /*
         * Remove the allocation block from the list.
         */
#ifndef OLDSTUFF
        pPrev = (PAGPHEAPLIST)pAGPHeap->hPrev;
        pNext = (PAGPHEAPLIST)pAGPHeap->hNext;
#else
        pPrev = (PAGPHEAPLIST)DDrvItemArrayGetPtr(pDriverData->hAGPList_gbl, pAGPHeap->hPrev);
        pNext = (PAGPHEAPLIST)DDrvItemArrayGetPtr(pDriverData->hAGPList_gbl, pAGPHeap->hNext);
#endif
        if (pPrev)
        {
            if (!(pPrev->hNext = pAGPHeap->hNext))
                hAGPHeapTail = pAGPHeap->hPrev;
        }
        else
        {
            hAGPHeapHead = pAGPHeap->hNext;
            pAGPHeapHead = pNext;
        }
        if (pNext)
        {
            if (!(pNext->hPrev = pAGPHeap->hPrev))
                hAGPHeapHead = pAGPHeap->hNext;
        }
        else
        {
            hAGPHeapTail = pAGPHeap->hPrev;
            pAGPHeapTail = pPrev;
        }
        dwNewLimit                 = (pAGPHeapTail) ? pAGPHeapTail->dwLimit : 0;
        dwBlockLimit               = pAGPHeap->dwLimit;
        pDriverData->dwAllocSize -= pAGPHeap->dwSize;

        /*
         * Free the allocation block memory.
         */
        hAGPListBlock = pAGPHeap->hCurrent;
#ifndef OLDSTUFF
        HEAPFREE(pDriverData->hAGPList_gbl, (HDDRVITEM)hAGPListBlock);
#else
        DDrvItemArrayFree(pDriverData->hAGPList_gbl, (HDDRVITEM)hAGPListBlock);
#endif

        /*
         * Check if reduction of AGP context limit is neccessary.
         */
        if ((pDriverData->NvDevFlatDma) && (pDriverData->NvBaseFlat))
        {
            if (dwBlockLimit > dwNewLimit)
            {
                /*
                 * Shrink the AGP limit in the context DMA.
                 * Setting old limit to new limit will make sure that this
                 * operation happens.  There's no reason it shouldn't since
                 * the limit is getting smaller.
                 * If the limit is 0, then map the context to the frame buffer
                 * because the RM/Hardware doesn't like having limts of 0.
                 */
#ifdef  CACHE_FREECOUNT
                nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
                NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
                UnplugSystemMemoryTextureContext();
                if (dwNewLimit != 0)
                    AdjustTextureLimit(D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY, pDriverData->GARTLinearBase, dwNewLimit, dwNewLimit);
                else
#ifndef WINNT
                    AdjustTextureLimit(D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY, pDriverData->BaseAddress, 0xFF, 0xFF);
#else
                    AdjustTextureLimit(D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY, pDriverData->ppdev->pjScreen, 0xFF, 0xFF);
#endif // #ifdef WINNT

                UpdateTriangleContexts();

#ifdef  CACHE_FREECOUNT
                pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
                NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
                /*
                 * Store the current texture heap limit.
                 */
                pDriverData->dwTextureHeapLimit = dwNewLimit;
            }
        }
    }

    /*
     * Destroy the texture heap if there's nothing left allocated in it.
     */
    if (pDriverData->dwAllocSize == 0)
        DestroyTextureHeap();

    /*
     * Free the AGP memory.
     */
    DDHAL32_VidMemFree(pDrv, AGP_HEAP, pMem);
    return (TRUE);
}
BOOL CreateAGPListArray
(
    void
)
{
#ifndef OLDSTUFF
    pDriverData->hAGPList_gbl = (HDDRVITEM)HEAPCREATE(AGPLIST_ARRAY_SIZE * sizeof(AGPHEAPLIST));
#else
    if (!DDrvItemArrayCreate(AGPLIST_ARRAY_SIZE,
                             sizeof(AGPHEAPLIST),
                             AGPLIST_ARRAY_DELTA,
                             &pDriverData->hAGPList_gbl))
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "CreateAGPListArray - AGP List array creation failed!");
        return (FALSE);
    }
#endif
    return (TRUE);
}
BOOL ResetAGPHeap
(
    void
)
{
    /*
     * Make sure this is AGP.
     */
    if ((pDriverData->dwD3DContextCount > 0)
     && (pDriverData->GARTLinearBase > 0))
        DestroyTextureHeap();
    return (TRUE);
}
BOOL DestroyAGPListArray
(
    void
)
{
    if (!pDriverData->hAGPList_gbl)
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "DestroyAGPListArray - No current AGP List array to destroy");
        return (TRUE);
    }
#ifndef OLDSTUFF
    HEAPDESTROY(pDriverData->hAGPList_gbl);
#else
    DDrvItemArrayApplyValid(pDriverData->hAGPList_gbl, DestroyAGPListCallback, 0L);
    DDrvItemArrayDestroy(pDriverData->hAGPList_gbl);
#endif

    /*
     * Once the list is destroyed, there can't be a head or a tail.
     */
    hAGPHeapHead = 0;
    hAGPHeapTail = 0;
    return (TRUE);
}
DWORD DestroyAGPListCallback
(
    LPVOID      lpData,
    HDDRVITEM   hItem,
    DWORD       dwExtra
)
{

    /*
     * No context was actually destroyed on this call, so return an
     * error so that the success count does not get updated for anyone
     * keeping track of these things.
     */
    return (DDRV_ERROR_CONTINUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\dvideo32.c ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *  Portions Copyright (C) 1997, 1998 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       dvideo32.c
 *  Content:    NVidia Direct Video/Active Movie Direct Draw support
 *              32 bit DirectDraw part.
 *
 ***************************************************************************/
#include "windows.h"
#include <conio.h>
#include "nvd3ddrv.h"
#include "nvcm.h"
#include "nv32.h"
#include "nvddobj.h"
#include "wingdi.h"
#include "arb_fifo.h" /* video bandwidth related stuff */
#include "nvrmapi.h"
#include "nvrmarch.inc"

/*
 * Make fixups for NV3->NV4 style includes.
 */
#undef NvChannel
#define NvChannel Nv3ChannelPio
#define nvContextDmaToMemory contextDmaToMemory

#if 0
DWORD __stdcall HandleVideoPortOverlayUpdate(LPDDHAL_UPDATEOVERLAYDATA lpUOData);
#endif

#ifdef NVPE
///// H.AZAR: (03/01/1999): this function is defined in nvpkrnl.c (nvpe.lib)
extern DWORD NVPUpdateOverlay();
#endif

/*
 * ConvertOverlay32
 *
 */

DWORD __stdcall
ConvertOverlay32(LPDDRAWI_DDRAWSURFACE_LCL lpDDSurface, BOOL waitForCompletion )
{
    FAST Nv10ControlDma         *npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl;
    DWORD                       caps;
    DWORD                       dwSrcYOffset;
    DWORD                       dwSrcVOffset;
    DWORD                       dwSrcUOffset;
    long                        dwSrcYPitch;
    long                        dwSrcUVPitch;
    long                        dwSrcUVHeight;
    DWORD                       dwDstYOffset;
    long                        dwDstYPitch;
    unsigned char               *fpSrcYMem;
    unsigned char               *fpSrcUMem;
    unsigned char               *fpSrcVMem;
    long                        dwSrcPitch;
    long                        dwSrcWidth;
    long                        dwSrcHeight;
    unsigned long               *dmaPusherPutAddress =
                                    (unsigned long *)pDriverData->NvDmaPusherPutAddress;
    unsigned long               *dmaPusherBufferBase =
                                    (unsigned long *)pDriverData->NvDmaPusherBufferBase;
#ifdef  CACHE_FREECOUNT
    long                        freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
    long                        freeCount = 0;
#endif  /* CACHE_FREECOUNT */

    pSurf_gbl = lpDDSurface->lpGbl;

    caps = lpDDSurface->ddsCaps.dwCaps;

    NV_DD_DMA_PUSHER_SYNC();

    /* If surface is IF09 format then must reformat data before
       video scaler can be used to display it */
    if ((pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_IF09) ||
        (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_YVU9) ||
        (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_IV32) ||
        (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_IV31)) {

        dwSrcYOffset = pSurf_gbl->fpVidMem - pDriverData->BaseAddress;
        dwSrcYPitch = (DWORD)pSurf_gbl->wWidth;
        dwSrcYPitch = (dwSrcYPitch + 3) & ~3L;
        dwDstYOffset = dwSrcYOffset + ((dwSrcYPitch * ((DWORD)pSurf_gbl->wHeight * 10L)) >> 3);
        dwDstYOffset = (dwDstYOffset + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
        dwDstYPitch = ((pSurf_gbl->wWidth + 1) & 0xFFFE) << 1;
        dwDstYPitch = (dwDstYPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;

        fpSrcYMem = (unsigned char *)pSurf_gbl->fpVidMem;
        dwSrcHeight = (DWORD)pSurf_gbl->wHeight;
        dwSrcHeight = (dwSrcHeight + 3) & ~3L;
        fpSrcVMem = fpSrcYMem + (dwSrcYPitch * dwSrcHeight);
        dwSrcHeight >>= 2;
        fpSrcUMem = fpSrcVMem + ((dwSrcYPitch >> 2) * dwSrcHeight);

        dwSrcUVHeight = (DWORD)pSurf_gbl->wHeight;
        dwSrcUVHeight = (dwSrcUVHeight + 3) & ~3L;
        dwSrcUVHeight >>= 2;

        dwSrcUVPitch = (DWORD)pSurf_gbl->wWidth;
        dwSrcUVPitch = (dwSrcUVPitch + 3) & ~3L;
        dwSrcUVPitch >>= 2;

        /* Let D3D code know that we have touched NV */
        pDriverData->TwoDRenderingOccurred = 1;

        while (freeCount < 25)
            NvGetDmaBufferFreeCount(npDev, freeCount, 25, dmaPusherPutAddress);
        freeCount -= 25;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
            SET_ROP_OFFSET | 0x40000;
        dmaPusherPutAddress[1] = 0x000000C0; /* MERGECOPY PSa */

        /* Temporarily change destination surface color format */
        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
            SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x80000;
        dmaPusherPutAddress[3] = NV042_SET_COLOR_FORMAT_LE_Y8;
        dmaPusherPutAddress[4] = (dwDstYPitch << 16) | dwDstYPitch;
        dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SURFACES) +
            SURFACES_2D_DEST_OFFSET | 0x40000;
        dmaPusherPutAddress[6] = dwDstYOffset;

        dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
        dmaPusherPutAddress[8] = NV_DD_CONTEXT_PATTERN;
        dmaPusherPutAddress[9] = dDrawSubchannelOffset(NV_DD_SPARE) +
            NV044_SET_MONOCHROME_SHAPE | 0x40000;
        dmaPusherPutAddress[10] = NV044_SET_MONOCHROME_SHAPE_64X_1Y;
        dmaPusherPutAddress[11] = dDrawSubchannelOffset(NV_DD_SPARE) +
            NV044_SET_MONOCHORME_COLOR0 | 0x100000;
        dmaPusherPutAddress[12] = 0;
        dmaPusherPutAddress[13] = 0xFFFFFFFF;

        /* First enable only V values to be written */
        dmaPusherPutAddress[14] = 0x11111111;
        dmaPusherPutAddress[15] = 0x11111111;

        dmaPusherPutAddress[16] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;
        dmaPusherPutAddress[17] = NV_DD_STRETCHED_UV_IMAGE_FROM_CPU;
        dmaPusherPutAddress[18] = dDrawSubchannelOffset(NV_DD_STRETCH) +
            STRETCHED_IMAGE_SIZE_IN_OFFSET | 0x180000;

        dmaPusherPutAddress[19] = asmMergeCoords(dwSrcUVPitch, dwSrcUVHeight);
        dmaPusherPutAddress[20] = 8 << 20;
        dmaPusherPutAddress[21] = 4 << 20;
        dmaPusherPutAddress[22] = 0;
        dmaPusherPutAddress[23] =
            asmMergeCoords((dwSrcYPitch << 1), (DWORD)pSurf_gbl->wHeight);
        dmaPusherPutAddress[24] = 0;

        dmaPusherPutAddress += 25;

        dwSrcHeight = dwSrcUVHeight;

        while (--dwSrcHeight >= 0) {
            FAST DWORD vPxls0;
            FAST DWORD vPxls1;

            dwSrcPitch = dwSrcUVPitch;

            /* Source scanlines may not be exact multiples of 4 */
            dwSrcPitch = (dwSrcPitch + 3) & ~3;

            // Get enough room for this scanline
            while (freeCount < (1 + (dwSrcPitch >> 2)))
                NvGetDmaBufferFreeCount(npDev, freeCount, (1 + (dwSrcPitch >> 2)), dmaPusherPutAddress);
            freeCount -= (1 + (dwSrcPitch >> 2));

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                STRETCHED_IMAGE_COLOR_OFFSET | (dwSrcPitch << 16);

            dmaPusherPutAddress += 1;

            while (dwSrcPitch >= 16) {
                dwSrcPitch -= 16;

                vPxls0 = *(unsigned long *)fpSrcVMem;
                vPxls1 = *(unsigned long *)&fpSrcVMem[4];

                dmaPusherPutAddress[0] = vPxls0;

                vPxls0 = *(unsigned long *)&fpSrcVMem[8];
                dmaPusherPutAddress[1] = vPxls1;
                vPxls1 = *(unsigned long *)&fpSrcVMem[12];
                dmaPusherPutAddress[2] = vPxls0;
                fpSrcVMem += 16;
                dmaPusherPutAddress[3] = vPxls1;

                dmaPusherPutAddress += 4;
            }

            while (dwSrcPitch >= 4) {
                dwSrcPitch -= 4;
                vPxls0 = *(unsigned long *)fpSrcVMem;
                fpSrcVMem += 4;
                dmaPusherPutAddress[0] = vPxls0;

                dmaPusherPutAddress += 1;
            }
        }

        /* Force write combine buffer to flush */
        pDriverData->NvDmaPusherBufferEnd[0] = 0;
        /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
        _outp (0x3d0,0);

        // Get NV started on reading the image data
        npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

        while (freeCount < 14)
            NvGetDmaBufferFreeCount(npDev, freeCount, 14, dmaPusherPutAddress);
        freeCount -= 14;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) +
            NV044_SET_MONOCHROME_SHAPE | 0x40000;
        dmaPusherPutAddress[1] = NV044_SET_MONOCHROME_SHAPE_64X_1Y;
        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
            NV044_SET_MONOCHORME_COLOR0 | 0x100000;
        dmaPusherPutAddress[3] = 0;
        dmaPusherPutAddress[4] = 0xFFFFFFFF;

        /* Now enable only U values to be written */
        dmaPusherPutAddress[5] = 0x44444444;
        dmaPusherPutAddress[6] = 0x44444444;

        dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_STRETCH) +
            STRETCHED_IMAGE_SIZE_IN_OFFSET | 0x180000;

        dmaPusherPutAddress[8] = asmMergeCoords(dwSrcUVPitch, dwSrcUVHeight);
        dmaPusherPutAddress[9] = 8 << 20;
        dmaPusherPutAddress[10] = 4 << 20;
        dmaPusherPutAddress[11] = 0;
        dmaPusherPutAddress[12] =
            asmMergeCoords((dwSrcYPitch << 1), (DWORD)pSurf_gbl->wHeight);
        dmaPusherPutAddress[13] = 0;

        dmaPusherPutAddress += 14;

        dwSrcHeight = dwSrcUVHeight;

        while (--dwSrcHeight >= 0) {
            FAST DWORD uPxls0;
            FAST DWORD uPxls1;

            dwSrcPitch = dwSrcUVPitch;

            /* Source scanlines may not be exact multiples of 4 */
            dwSrcPitch = (dwSrcPitch + 3) & ~3;

            // Get enough room for this scanline
            while (freeCount < (1 + (dwSrcPitch >> 2)))
                NvGetDmaBufferFreeCount(npDev, freeCount, (1 + (dwSrcPitch >> 2)), dmaPusherPutAddress);
            freeCount -= (1 + (dwSrcPitch >> 2));

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                STRETCHED_IMAGE_COLOR_OFFSET | (dwSrcPitch << 16);

            dmaPusherPutAddress += 1;

            while (dwSrcPitch >= 16) {
                dwSrcPitch -= 16;

                uPxls0 = *(unsigned long *)fpSrcUMem;
                uPxls1 = *(unsigned long *)&fpSrcUMem[4];

                dmaPusherPutAddress[0] = uPxls0;
                uPxls0 = *(unsigned long *)&fpSrcUMem[8];
                dmaPusherPutAddress[1] = uPxls1;
                uPxls1 = *(unsigned long *)&fpSrcUMem[12];
                dmaPusherPutAddress[2] = uPxls0;
                fpSrcUMem += 16;
                dmaPusherPutAddress[3] = uPxls1;

                dmaPusherPutAddress += 4;
            }

            while (dwSrcPitch >= 4) {
                dwSrcPitch -= 4;
                uPxls0 = *(unsigned long *)fpSrcUMem;
                fpSrcUMem += 4;
                dmaPusherPutAddress[0] = uPxls0;

                dmaPusherPutAddress += 1;
            }
        }

        /* Force write combine buffer to flush */
        pDriverData->NvDmaPusherBufferEnd[0] = 0;
        /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
        _outp (0x3d0,0);

        // Get NV started on reading the image data
        npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

        /* restore default stretch subchannel object */
        while (freeCount < 6)
            NvGetDmaBufferFreeCount(npDev, freeCount, 6, dmaPusherPutAddress);
        freeCount -= 6;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;
        if (pDriverData->bi.biBitCount == 8)
            dmaPusherPutAddress[1] = NV_DD_STRETCHED_IMAGE_FROM_CPU;
        else
            dmaPusherPutAddress[1] = NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;

        /* restore destination surface color format and reenable pattern object alpha */
        if (pDriverData->bi.biBitCount == 8) {

            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                NV042_SET_COLOR_FORMAT | 0x40000;
            dmaPusherPutAddress[3] = NV042_SET_COLOR_FORMAT_LE_Y8;
            dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SPARE) +
                NV044_SET_MONOCHORME_COLOR0 | 0x40000;
            dmaPusherPutAddress[5] = NV_ALPHA_1_008;

        } else if (pDriverData->bi.biBitCount == 16) {

            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                NV042_SET_COLOR_FORMAT | 0x40000;
            dmaPusherPutAddress[3] = NV042_SET_COLOR_FORMAT_LE_R5G6B5;
            dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SPARE) +
                NV044_SET_MONOCHORME_COLOR0 | 0x40000;
            dmaPusherPutAddress[5] = NV_ALPHA_1_016;

        } else {

            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                NV042_SET_COLOR_FORMAT | 0x40000;
            dmaPusherPutAddress[3] = NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;
            dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SPARE) +
                NV044_SET_MONOCHORME_COLOR0 | 0x40000;
            dmaPusherPutAddress[5] = NV_ALPHA_1_032;
        }

        dmaPusherPutAddress += 6;


        /* Update all Y values */
        while (freeCount < 11)
            NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
        freeCount -= 11;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
        dmaPusherPutAddress[1] = NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;
        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000;
        dmaPusherPutAddress[3] = dwSrcYOffset;
        dmaPusherPutAddress[4] = dwDstYOffset;
        dmaPusherPutAddress[5] = dwSrcYPitch;
        dmaPusherPutAddress[6] = dwDstYPitch;
        dmaPusherPutAddress[7] = dwSrcYPitch;
        dmaPusherPutAddress[8] = (DWORD)pSurf_gbl->wHeight;
        dmaPusherPutAddress[9] = (2 << 8) | 1;
        dmaPusherPutAddress[10] = 0;

        dmaPusherPutAddress += 11;

        pDriverData->dDrawSpareSubchannelObject = 0;

        pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

        /* Force write combine buffer to flush */
        pDriverData->NvDmaPusherBufferEnd[0] = 0;
        /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
        _outp (0x3d0,0);

        pDriverData->dwDmaPusherFreeCount = freeCount;

        npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

     /* YV12/420i surfaces also need reformated before the video scaler can display them */
    } else if ((pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_YV12) ||
               (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_420i)) {
        DWORD srcMemType = 0;
        DWORD interleaveUVFields = 0;

        /* First determine which source buffer is being used */
        dwSrcYOffset = pSurf_gbl->fpVidMem - pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0];

        dwSrcYPitch = (DWORD)pSurf_gbl->wWidth;
        dwSrcYPitch = (dwSrcYPitch + 3) & ~3L;

        dwSrcWidth = dwSrcYPitch;

        if (dwSrcYOffset == 0)
            dwDstYOffset = pDriverData->NvYUY2Surface0Mem -
                               pDriverData->BaseAddress;
        else if (pSurf_gbl->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1])
            dwDstYOffset = pDriverData->NvYUY2Surface1Mem -
                               pDriverData->BaseAddress;
        else if (pSurf_gbl->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2])
            dwDstYOffset = pDriverData->NvYUY2Surface2Mem -
                               pDriverData->BaseAddress;
        else
            dwDstYOffset = pDriverData->NvYUY2Surface3Mem -
                               pDriverData->BaseAddress;

        /* Now correct source offset if it is really in video memory */
        if ((pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] >= pDriverData->BaseAddress) && /* If video memory */
            (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] < pDriverData->BaseAddress + 0x1000000)) {
            dwSrcYOffset = pSurf_gbl->fpVidMem - pDriverData->BaseAddress;
            srcMemType = DDSCAPS_LOCALVIDMEM;
        }

        dwDstYPitch = ((pSurf_gbl->wWidth + 1) & 0xFFFE) << 1;
        dwDstYPitch = (dwDstYPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;

        dwSrcHeight = (DWORD)pSurf_gbl->wHeight;
        dwSrcHeight = (dwSrcHeight + 1) & ~1L;

        if (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_YV12) {
            dwSrcVOffset = dwSrcYOffset + (dwSrcYPitch * dwSrcHeight);
            dwSrcUOffset = dwSrcVOffset + ((dwSrcYPitch * dwSrcHeight) >> 2);

            dwSrcUVPitch = (DWORD)pSurf_gbl->wWidth;
            dwSrcUVPitch = (dwSrcUVPitch + 3) & ~3L;
            dwSrcUVPitch >>= 1;

        } else { /* FOURCC_420i */
            dwSrcVOffset = dwSrcYOffset + dwSrcYPitch;
            dwSrcYPitch += (dwSrcYPitch >> 1);
            dwSrcUOffset = dwSrcVOffset + dwSrcYPitch;

            dwSrcUVPitch = dwSrcYPitch << 1;
        }

        dwSrcUVHeight = (DWORD)pSurf_gbl->wHeight;
        dwSrcUVHeight = (dwSrcUVHeight + 1) & ~1L;
        dwSrcUVHeight >>= 1;

        /*
         * NOTE:
         *
         * NV3 MemToMemFormat does not double buffer it's methods.
         * Therefore, if a MemToMemFormat operation is started within
         * a channel, sending an additional MemToMemFormat request down the
         * FIFO will corrupt the state of the first MemToMemFormat operation if
         * it had not yet finished.  However, loading a new object
         * into a subchannel will ALWAYS be blocked until the object
         * previously in that subchannel has completed it's operation.
         * Since we can't afford to wait around in this algorithm, we
         * take advantage of the fact that this object blocking will occur
         * by loading several different MemToMemFormat object instances
         * to accomplish our format conversion.
         */

        /* Let D3D code know that we have touched NV */
        pDriverData->TwoDRenderingOccurred = 1;

        while (freeCount < 11)
            NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
        freeCount -= 11;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
        if (srcMemType == 0) /* If system memory */
            dmaPusherPutAddress[1] = NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT;
        else
            dmaPusherPutAddress[1] = NV_DD_VIDEO_MEMORY_V_TO_VIDEO_MEMORY_FORMAT;
        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000;
        dmaPusherPutAddress[3] = dwSrcVOffset;
        dmaPusherPutAddress[4] = (dwDstYOffset + 3);
        dmaPusherPutAddress[5] = dwSrcUVPitch;
        dmaPusherPutAddress[6] = (dwDstYPitch << 1);
        dmaPusherPutAddress[7] = (dwSrcWidth >> 1);
        dmaPusherPutAddress[8] = dwSrcUVHeight;
        dmaPusherPutAddress[9] = (4 << 8) | 1;
        dmaPusherPutAddress[10] = 0;

        dmaPusherPutAddress += 11;

        while (freeCount < 11)
            NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
        freeCount -= 11;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
        if (srcMemType == 0) /* If system memory */
            dmaPusherPutAddress[1] = NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT;
        else
            dmaPusherPutAddress[1] = NV_DD_VIDEO_MEMORY_U_TO_VIDEO_MEMORY_FORMAT;
        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000;
        dmaPusherPutAddress[3] = dwSrcUOffset;
        dmaPusherPutAddress[4] = (dwDstYOffset + 1);
        dmaPusherPutAddress[5] = dwSrcUVPitch;
        dmaPusherPutAddress[6] = (dwDstYPitch << 1);
        dmaPusherPutAddress[7] = (dwSrcWidth >> 1);
        dmaPusherPutAddress[8] = dwSrcUVHeight;
        dmaPusherPutAddress[9] = (4 << 8) | 1;
        dmaPusherPutAddress[10] = 0;

        dmaPusherPutAddress += 11;

        /* Force write combine buffer to flush */
        pDriverData->NvDmaPusherBufferEnd[0] = 0;
        /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
        _outp (0x3d0,0);

        // Get NV started on processing the image data
        npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

        if (interleaveUVFields) { /* repeat for odd field */

            while (freeCount < 11)
                NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
            freeCount -= 11;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
            if (srcMemType == 0) /* If system memory */
                dmaPusherPutAddress[1] = NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT;
            else
                dmaPusherPutAddress[1] = NV_DD_VIDEO_MEMORY_V_TO_VIDEO_MEMORY_FORMAT;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000;
            dmaPusherPutAddress[3] = (dwSrcVOffset + (dwSrcPitch >> 1));
            dmaPusherPutAddress[4] = (dwDstYOffset + 3);
            dmaPusherPutAddress[5] = dwSrcUVPitch;
            dmaPusherPutAddress[6] = (dwDstYPitch << 1);
            dmaPusherPutAddress[7] = (dwSrcWidth >> 1);
            dmaPusherPutAddress[8] = dwSrcUVHeight;
            dmaPusherPutAddress[9] = (4 << 8) | 1;
            dmaPusherPutAddress[10] = 0;

            dmaPusherPutAddress += 11;

            while (freeCount < 11)
                NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
            freeCount -= 11;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
            if (srcMemType == 0) /* If system memory */
                dmaPusherPutAddress[1] = NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT;
            else
                dmaPusherPutAddress[1] = NV_DD_VIDEO_MEMORY_U_TO_VIDEO_MEMORY_FORMAT;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000;
            dmaPusherPutAddress[3] = (dwSrcUOffset + (dwSrcPitch >> 1));
            dmaPusherPutAddress[4] = (dwDstYOffset + 1);
            dmaPusherPutAddress[5] = dwSrcUVPitch;
            dmaPusherPutAddress[6] = (dwDstYPitch << 1);
            dmaPusherPutAddress[7] = (dwSrcWidth >> 1);
            dmaPusherPutAddress[8] = dwSrcUVHeight;
            dmaPusherPutAddress[9] = (4 << 8) | 1;
            dmaPusherPutAddress[10] = 0;

            dmaPusherPutAddress += 11;

            while (freeCount < 11)
                NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
            freeCount -= 11;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
            dmaPusherPutAddress[1] = NV_DD_VIDEO_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000;
            dmaPusherPutAddress[3] = (dwDstYOffset + 1 + (dwDstYPitch >> 1));
            dmaPusherPutAddress[4] = (dwDstYOffset + 1 + (dwDstYPitch >> 1) + dwDstYPitch);
            dmaPusherPutAddress[5] = (dwDstYPitch << 1);
            dmaPusherPutAddress[6] = (dwDstYPitch << 1);
            dmaPusherPutAddress[7] = (dwDstYPitch >> 2);
            dmaPusherPutAddress[8] = (DWORD)pSurf_gbl->wHeight >> 2;
            dmaPusherPutAddress[9] = (2 << 8) | 2;
            dmaPusherPutAddress[10] = 0;

            dmaPusherPutAddress += 11;

            /* Force write combine buffer to flush */
            pDriverData->NvDmaPusherBufferEnd[0] = 0;
            /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
            _outp (0x3d0,0);

            // Get NV started on processing the image data
            npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

            /* restore Y pitch while processing interleaved Y values for full frame */
            dwDstYPitch >>= 1;
        }

        while (freeCount < 11)
            NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
        freeCount -= 11;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
        if (srcMemType == 0) /* If system memory */
            dmaPusherPutAddress[1] = NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;
        else
            dmaPusherPutAddress[1] = NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;
        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000;
        dmaPusherPutAddress[3] = dwSrcYOffset;
        dmaPusherPutAddress[4] = dwDstYOffset;
        dmaPusherPutAddress[5] = dwSrcYPitch;
        dmaPusherPutAddress[6] = dwDstYPitch;
        dmaPusherPutAddress[7] = dwSrcWidth;
        dmaPusherPutAddress[8] = (DWORD)pSurf_gbl->wHeight;
        dmaPusherPutAddress[9] = (2 << 8) | 1;
        dmaPusherPutAddress[10] = 0;

        dmaPusherPutAddress += 11;

        /* Force write combine buffer to flush */
        pDriverData->NvDmaPusherBufferEnd[0] = 0;
        /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
        _outp (0x3d0,0);

        // Get NV started on processing the image data
        npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

        if (interleaveUVFields)
            dwDstYPitch <<= 1;

        while (freeCount < 11)
            NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
        freeCount -= 11;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
        dmaPusherPutAddress[1] = NV_DD_VIDEO_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT;
        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000;
        dmaPusherPutAddress[3] = (dwDstYOffset + 1);
        dmaPusherPutAddress[4] = (dwDstYOffset + 1 + dwDstYPitch);
        dmaPusherPutAddress[5] = (dwDstYPitch << 1);
        dmaPusherPutAddress[6] = (dwDstYPitch << 1);
        if (interleaveUVFields) {
            dmaPusherPutAddress[7] = (dwDstYPitch >> 2);
            dmaPusherPutAddress[8] = (DWORD)pSurf_gbl->wHeight >> 2;
        } else {
            dmaPusherPutAddress[7] = (dwDstYPitch >> 1);
            dmaPusherPutAddress[8] = (DWORD)pSurf_gbl->wHeight >> 1;
        }
        dmaPusherPutAddress[9] = (2 << 8) | 2;
        dmaPusherPutAddress[10] = 0;

        dmaPusherPutAddress += 11;

        /* Force write combine buffer to flush */
        pDriverData->NvDmaPusherBufferEnd[0] = 0;
        /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
        _outp (0x3d0,0);

        // Get NV started on processing the image data
        npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

        if (waitForCompletion) {
            NvNotification *pDmaSyncNotifier =
                (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;

            // MUST wait for any pending notification to prevent possible loss of notification serialization
            while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP;

            while (freeCount < 4)
                NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
            freeCount -= 4;

            pDmaSyncNotifier->status = NV_IN_PROGRESS;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = 0;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
            dmaPusherPutAddress[3] = 0;

            dmaPusherPutAddress += 4;

            /* Force write combine buffer to flush */
            pDriverData->NvDmaPusherBufferEnd[0] = 0;
            /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
            _outp (0x3d0,0);

            npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

            while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification
        }

        pDriverData->dDrawSpareSubchannelObject = 0;

        pDriverData->dwDmaPusherFreeCount = freeCount;

        pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;
    }

    return DDHAL_DRIVER_HANDLED;

} /* ConvertOverlay32 */


/*
 * PreScaleOverlay32
 *
 * This function does not support interleaved overlay surfaces.
 *
 */

DWORD __stdcall
PreScaleOverlay32(LPDDRAWI_DDRAWSURFACE_LCL lpDDSurface )
{
    FAST Nv10ControlDma         *npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl;
    DWORD                       caps;
    DWORD                       dwOffset;
    DWORD                       dwPitch;
    DWORD                       preScaleOverlay = 0;
    DWORD                       srcPreShrinkDeltaX;
    DWORD                       srcPreShrinkDeltaY;
    BOOL                        surfaceIs422 = FALSE;
    unsigned long               *dmaPusherPutAddress =
                                    (unsigned long *)pDriverData->NvDmaPusherPutAddress;
    unsigned long               *dmaPusherBufferBase =
                                    (unsigned long *)pDriverData->NvDmaPusherBufferBase;
#ifdef  CACHE_FREECOUNT
    long                        freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
    long                        freeCount = 0;
#endif  /* CACHE_FREECOUNT */

    if (npDev == NULL) {
        return DDHAL_DRIVER_HANDLED;
    }

    pSurf_gbl = lpDDSurface->lpGbl;

    caps = lpDDSurface->ddsCaps.dwCaps;

    NV_DD_DMA_PUSHER_SYNC();

    /* Make sure we flip to the correct starting offset in new overlay surface */
    dwOffset = pSurf_gbl->fpVidMem - pDriverData->BaseAddress;

    if ((pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_IF09) ||
        (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_YVU9) ||
        (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_IV32) ||
        (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_IV31)) {
        /* Skip over Indeo portion of surface */
        dwPitch = (DWORD)pSurf_gbl->wWidth;
        dwOffset += ((dwPitch * ((DWORD)pSurf_gbl->wHeight * 10L)) >> 3);
        /* Force block to be properly aligned */
        dwOffset = (dwOffset + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
        dwPitch = ((pSurf_gbl->wWidth + 1) & 0xFFFE) << 1;
        dwPitch = (dwPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
    } else if ((pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_YV12) ||
               (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_420i)) {
        /* Assumes a separate overlay YUY2 surface in video memory */
        if (pSurf_gbl->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0])
            dwOffset = pDriverData->NvYUY2Surface0Mem -
                           pDriverData->BaseAddress;
        else if (pSurf_gbl->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1])
            dwOffset = pDriverData->NvYUY2Surface1Mem -
                           pDriverData->BaseAddress;
        else if (pSurf_gbl->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2])
            dwOffset = pDriverData->NvYUY2Surface2Mem -
                           pDriverData->BaseAddress;
        else
            dwOffset = pDriverData->NvYUY2Surface3Mem -
                           pDriverData->BaseAddress;

        dwPitch = ((pSurf_gbl->wWidth + 1) & 0xFFFE) << 1;
        dwPitch = (dwPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
    } else {
        dwPitch = (DWORD)pSurf_gbl->lPitch;
        surfaceIs422 = TRUE;
    }

    srcPreShrinkDeltaX = 0x100000;
    srcPreShrinkDeltaY = 0x100000;

    if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {

        if ((((pDriverData->dwOverlaySrcWidth + 7) >> 3) >
               pDriverData->dwOverlayDstWidth) && (pDriverData->dwOverlayDstWidth > 0)) {
            preScaleOverlay |= NV_PRESCALE_OVERLAY_X;
            srcPreShrinkDeltaX =
                (pDriverData->dwOverlaySrcWidth << 20) / pDriverData->dwOverlayDstWidth;
        }

        if ((((pDriverData->dwOverlaySrcHeight + 7) >> 3) >
               pDriverData->dwOverlayDstHeight) && (pDriverData->dwOverlayDstHeight > 0)) {
            preScaleOverlay |= NV_PRESCALE_OVERLAY_Y;
            srcPreShrinkDeltaY =
                (pDriverData->dwOverlaySrcHeight << 20) / pDriverData->dwOverlayDstHeight;
        }
    } else {

        if ((pDriverData->dwOverlaySrcWidth >
               pDriverData->dwOverlayDstWidth) && (pDriverData->dwOverlayDstWidth > 0)) {
            preScaleOverlay |= NV_PRESCALE_OVERLAY_X;
            srcPreShrinkDeltaX =
                (pDriverData->dwOverlaySrcWidth << 20) / pDriverData->dwOverlayDstWidth;
        }

        if ((pDriverData->dwOverlaySrcHeight >
               pDriverData->dwOverlayDstHeight) && (pDriverData->dwOverlayDstHeight > 0)) {
            preScaleOverlay |= NV_PRESCALE_OVERLAY_Y;
            srcPreShrinkDeltaY =
                (pDriverData->dwOverlaySrcHeight << 20) / pDriverData->dwOverlayDstHeight;
        }
    }

    if ((surfaceIs422) && (preScaleOverlay == 0) &&
        (pDriverData->dwOverlaySurfaces == 1) &&
        (pSurf_gbl->wHeight >= 480) &&
        (pDriverData->lockCount > 2))
        preScaleOverlay = NV_PRESCALE_OVERLAY_QUADRANT;

    /* Preshrink overlay surface if necessary */
    if ((pDriverData->TotalVRAM >> 20 > 4) && (preScaleOverlay)) {

        while (freeCount < 19)
            NvGetDmaBufferFreeCount(npDev, freeCount, 19, dmaPusherPutAddress);
        freeCount -= 19;

        /* Trash spare subchannel */
        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
        dmaPusherPutAddress[1] = NV_DD_DVD_SUBPICTURE;
        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
            NV038_IMAGE_OUT_POINT | 0x400000;
        dmaPusherPutAddress[3] = 0;

        /* Widths below are increased by 2 instead of 1 to remain hardware compatible */
        if (preScaleOverlay == NV_PRESCALE_OVERLAY_X) {
            dmaPusherPutAddress[4] =
                asmMergeCoords(((pDriverData->dwOverlayDstWidth + 2) & ~1),
                               pSurf_gbl->wHeight);
        } else if (preScaleOverlay == NV_PRESCALE_OVERLAY_X) {
            dmaPusherPutAddress[4] =
                asmMergeCoords(((pSurf_gbl->wWidth + 2) & ~1),
                               pDriverData->dwOverlayDstHeight);
        } else if (preScaleOverlay == (NV_PRESCALE_OVERLAY_X + NV_PRESCALE_OVERLAY_Y)) {
            dmaPusherPutAddress[4] =
                asmMergeCoords(((pDriverData->dwOverlayDstWidth + 2) & ~1),
                               pDriverData->dwOverlayDstHeight);
        } else {
            dmaPusherPutAddress[4] =
                asmMergeCoords(((pDriverData->dwOverlaySrcWidth + 2) & ~1),
                               pDriverData->dwOverlaySrcHeight);
        }

        if (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_UYVY)
            dmaPusherPutAddress[5] =
                (NV038_IMAGE_OUT_FORMAT_COLOR_LE_YB8V8YA8U8 << 16) | dwPitch;
        else
            dmaPusherPutAddress[5] =
                (NV038_IMAGE_OUT_FORMAT_COLOR_LE_V8YB8U8YA8 << 16) | dwPitch;

        /* Output to extra overlay surface memory area */
        if ((surfaceIs422) && (pDriverData->extra422OverlayOffset[pDriverData->OverlayBufferIndex] != 0))
            dmaPusherPutAddress[6] =
                pDriverData->extra422OverlayOffset[pDriverData->OverlayBufferIndex];
        else
            dmaPusherPutAddress[6] = (dwOffset + pSurf_gbl->dwReserved1);

        dmaPusherPutAddress[7] = srcPreShrinkDeltaX;
        dmaPusherPutAddress[8] = srcPreShrinkDeltaY;

        dmaPusherPutAddress[9] = pDriverData->OverlaySrcSize;

        if (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_UYVY)
            dmaPusherPutAddress[10] =
                (NV038_IMAGE_IN_FORMAT_COLOR_LE_YB8V8YA8U8 << 16) | dwPitch;
        else
            dmaPusherPutAddress[10] =
                (NV038_IMAGE_IN_FORMAT_COLOR_LE_V8YB8U8YA8 << 16) | dwPitch;

        /* Temporarily offset to the beginning of the visible portion of source surface */
        dwOffset += (pDriverData->OverlaySrcY * dwPitch);
        dwOffset += (pDriverData->OverlaySrcX << 1);

        dmaPusherPutAddress[11] = dwOffset;

        dmaPusherPutAddress[12] = 0;

        dmaPusherPutAddress[13] = srcPreShrinkDeltaX;
        dmaPusherPutAddress[14] = srcPreShrinkDeltaY;

        dmaPusherPutAddress[15] = pDriverData->OverlaySrcSize;

        dmaPusherPutAddress[16] =
            (NV038_OVERLAY_FORMAT_COLOR_LE_TRANSPARENT << 16) | dwPitch;

        dmaPusherPutAddress[17] = dwOffset;

        dmaPusherPutAddress[18] = 0;

        dmaPusherPutAddress += 19;

        pDriverData->dDrawSpareSubchannelObject = 0;

        pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

        /* Force write combine buffer to flush */
        pDriverData->NvDmaPusherBufferEnd[0] = 0;
        /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
        _outp (0x3d0,0);

        pDriverData->dwDmaPusherFreeCount = freeCount;

        npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
    }

    pDriverData->dwDmaPusherFreeCount = freeCount;

    pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

    return DDHAL_DRIVER_HANDLED;
}



/*
 * UpdateOverlay32
 *
 *
 * NOTES:
 *
 * This callback is invoked to update an overlay surface.
 * This is where the src/destination is specified, any effects, and
 * it is shown or hidden
 *
 * For overlay surfaces NOT associated with a video port the surface will
 * be shown (DDOVER_SHOW) according to the following criteria.
 *
 *     DDOVER_INTERLEAVED   DDOVER_BOB      DISPLAYED
 *
 *             1                1           Even field
 *             1                0           Full surface (no special processing)
 *             0                X           Full surface (no special processing)
 *
 */

DWORD __stdcall
UpdateOverlay32( LPDDHAL_UPDATEOVERLAYDATA lpUOData )
{
    FAST Nv3ChannelPio          *npDevVideo;
    FAST long                   videoFreeCount;
    NvNotification              *pPioFlipOverlayNotifier;
    long                        srcDeltaX;
    long                        srcDeltaY;
    long                        srcPreShrinkDeltaX;
    long                        srcPreShrinkDeltaY;
    long                        dwSrcOffset;
    long                        dwSrcWidth;
    long                        dwSrcHeight;
    long                        dwDstWidth;
    long                        dwDstHeight;
    long                        dwSrcPitch;
    DWORD                       index = 0;
    DWORD                       match = 0;
    DWORD                       showInterleavedFields = 0;
    DWORD                       preScaleOverlay = 0;
    U032                        bMediaPortControl = FALSE;
    BOOL                        surfaceIs422 = FALSE;

    LPDDRAWI_DDRAWSURFACE_LCL   srcx = lpUOData->lpDDSrcSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   src = srcx->lpGbl;

    NvSetDriverDataPtr(lpUOData->lpDD);

    npDevVideo = (NvChannel *)pDriverData->NvDevVideoFlatPio;
    videoFreeCount = pDriverData->NvVideoFreeCount;
    pPioFlipOverlayNotifier = (NvNotification *)pDriverData->NvPioFlipOverlayNotifierFlat;

#if 0
        // This code will eventually be used to specially opt out of overlay stuff when video port is in use
    if( srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT)  {

        lpUOData->ddRVal = HandleVideoPortOverlayUpdate( lpUOData);
    return DDHAL_DRIVER_HANDLED;

    }
#endif //
    if ((src->ddpfSurface.dwFourCC != FOURCC_UYVY) &&
        (src->ddpfSurface.dwFourCC != FOURCC_UYNV) &&
        (src->ddpfSurface.dwFourCC != FOURCC_YUY2) &&
        (src->ddpfSurface.dwFourCC != FOURCC_YUNV) &&
        (src->ddpfSurface.dwFourCC != FOURCC_YV12) &&
        (src->ddpfSurface.dwFourCC != FOURCC_420i) &&
        (src->ddpfSurface.dwFourCC != FOURCC_IF09) &&
        (src->ddpfSurface.dwFourCC != FOURCC_YVU9) &&
        (src->ddpfSurface.dwFourCC != FOURCC_IV32) &&
        (src->ddpfSurface.dwFourCC != FOURCC_IV31)) {
            lpUOData->ddRVal = DDERR_INVALIDSURFACETYPE;
            return DDHAL_DRIVER_HANDLED;
    }

    if (!(srcx->ddsCaps.dwCaps & DDSCAPS_OVERLAY)) {
            lpUOData->ddRVal = DDERR_NOTAOVERLAYSURFACE;
            return DDHAL_DRIVER_HANDLED;
    }

    while ((index < NV_MAX_OVERLAY_SURFACES) && (!match))
        if ((DWORD)srcx == pDriverData->dwOverlaySurfaceLCL[index++])
            match = 1;

    if (!match) {
        lpUOData->ddRVal = DDERR_OUTOFCAPS;
        return DDHAL_DRIVER_HANDLED;
    }

    NV_DD_DMA_PUSHER_SYNC();

    if (npDevVideo == NULL) {  /* Mode switches might occur without warning */
        lpUOData->ddRVal = DDERR_SURFACELOST;
        pDriverData->fDDrawFullScreenDosOccurred = 0;    /* reset flag */
        pDriverData->HALInfo.ddCaps.dwCurrVisibleOverlays = 0;
        pDriverData->dwOverlaySurfaces = 0;         /* should clean up AGP surface memory here if used */
        pDriverData->dwOverlayOwner = 0;
        pPioFlipOverlayNotifier[1].status = 0;      /* clear notifiers */
        pPioFlipOverlayNotifier[2].status = 0;
        return DDHAL_DRIVER_HANDLED;
    }
    pDriverData->dwRingZeroMutex = TRUE;

    if (pDriverData->fDDrawFullScreenDosOccurred) {
        pDriverData->OverlayRelaxOwnerCheck = 1;        /* relax owner check when we come back from DOS mode */
        pPioFlipOverlayNotifier[1].status = 0;      /* clear notifiers */
        pPioFlipOverlayNotifier[2].status = 0;
    }

    /* Alternate buffer indexes to keep the hardware happy */
    pDriverData->OverlayBufferIndex ^= 1;

    index = pDriverData->OverlayBufferIndex;
        
    if (lpUOData->dwFlags & DDOVER_HIDE ) {
        DPF("UPDATE OVERLAY - DDOVER_HIDE");

        pDriverData->dwOverlaySrcWidth = 0;
        pDriverData->dwOverlayDstWidth = 0;
        pDriverData->dwOverlaySrcHeight = 0;
        pDriverData->dwOverlayDstHeight = 0;

#ifdef NVPE
		// tell miniport to stop autoflip !
        if (srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT)
			NVPUpdateOverlay();
#endif	// #ifdef NVPE

        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {

            while (videoFreeCount < 32)
                videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);
            videoFreeCount -= 32;

            npDevVideo->dDrawSpare.SetObject = NV_VIDEO_OVERLAY;

       } else {

            while (videoFreeCount < 32)
                videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);
            videoFreeCount -= 32;

            /* Trash spare subchannel */
            npDevVideo->dDrawSpare.SetObject = NV_DD_VIDEO_COLOR_KEY;

            npDevVideo->dDrawSpare.videoColorKey.SetSize = 0;

            npDevVideo->dDrawSpare.SetObject = NV_DD_YUV422_VIDEO_FROM_MEMORY;

            npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].offset = 0;

            npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].pitch = 0;

            npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].size = 0;

            if ((src->ddpfSurface.dwFourCC == FOURCC_UYVY) ||
                (src->ddpfSurface.dwFourCC == FOURCC_UYNV))
                npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].format =
                    NV_VFM_FORMAT_COLOR_LE_Y8V8Y8U8;
            else
                npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].format =
                    NV_VFM_FORMAT_COLOR_LE_V8Y8U8Y8;

            npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].notify = 0;
        }
        
          //pDriverData->dwRingZeroMutex = FALSE;

        pDriverData->dDrawSpareSubchannelObject = 0;
        pDriverData->OverlayFormat = 0;     // This should hide things, since we'll stop flipping
            
        /* Let DDraw know how many visible overlays are active */
        pDriverData->HALInfo.ddCaps.dwCurrVisibleOverlays = 0;

        if (pDriverData->fDDrawFullScreenDosOccurred) {
            if (pDriverData->fDDrawFullScreenDosOccurred != 2) {  /* still in DOS mode ? */
                pDriverData->fDDrawFullScreenDosOccurred = 0;    /* reset flag */
            }
        }

    } else {
        DPF("UPDATE OVERLAY - DDOVER_SHOW OR MOVE/RESIZE ");
        DPF( "Source Rect = (%ld,%ld), (%ld,%ld)",
             lpUOData->rSrc.left, lpUOData->rSrc.top,
             lpUOData->rSrc.right, lpUOData->rSrc.bottom );

        DPF( "Dest Rect = (%ld,%ld), (%ld,%ld)",
             lpUOData->rDest.left, lpUOData->rDest.top,
             lpUOData->rDest.right, lpUOData->rDest.bottom );

        if ((lpUOData->rDest.left < 0) || (lpUOData->rDest.top < 0)) {
            pDriverData->dwRingZeroMutex = FALSE;
            
                lpUOData->ddRVal = DDERR_INVALIDPOSITION;
            return DDHAL_DRIVER_HANDLED;
        }

        if (pDriverData->fDDrawFullScreenDosOccurred) {
            if (pDriverData->fDDrawFullScreenDosOccurred == 2) {  /* still in DOS mode ? */
                pDriverData->dwRingZeroMutex = FALSE;
                 lpUOData->ddRVal = DDERR_SURFACEBUSY;
                return DDHAL_DRIVER_HANDLED;
            } else {                                        /* back to hires mode */
                pDriverData->fDDrawFullScreenDosOccurred = 0;    /* reset flag */
            }
        }

        /* This surface may need converted */
        if (pDriverData->dwOverlaySurfaces > 2)
            ConvertOverlay32(srcx, TRUE);

        dwSrcWidth = lpUOData->rSrc.right - lpUOData->rSrc.left;
        dwSrcHeight = lpUOData->rSrc.bottom - lpUOData->rSrc.top;
        dwDstWidth = lpUOData->rDest.right - lpUOData->rDest.left;
        dwDstHeight = lpUOData->rDest.bottom - lpUOData->rDest.top;
            
        if (srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT) {
            if (lpUOData->dwFlags & DDOVER_AUTOFLIP) {
                bMediaPortControl = TRUE;
            }
        }       
            
        /* Remember sizes so Flip32 knows what to do */
        pDriverData->dwOverlaySrcWidth = dwSrcWidth;
        pDriverData->dwOverlayDstWidth = dwDstWidth;
        pDriverData->dwOverlaySrcHeight = dwSrcHeight;
        pDriverData->dwOverlayDstHeight = dwDstHeight;

        /* Align to 2 pixel boundary + 1 for video scaler */
        dwDstWidth = (dwDstWidth + 2) & ~1L;
        dwDstHeight = (dwDstHeight + 1) & ~1L;

        srcDeltaX = (dwSrcWidth - 1) << 16;
        srcDeltaX /= dwDstWidth - 1;
        srcDeltaX <<= 4;

        srcDeltaY = (dwSrcHeight - 1) << 16;
        srcDeltaY /= dwDstHeight - 1;
        srcDeltaY <<= 4;

        pDriverData->dwOverlayDeltaY = (DWORD)srcDeltaY;

        if( !(srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT) ) {
            if ((lpUOData->dwFlags & DDOVER_INTERLEAVED) &&
                (lpUOData->dwFlags & DDOVER_BOB)) {

                showInterleavedFields = 1;
                dwSrcHeight >>= 1;
#ifdef  NOPRESTRETCH
                srcDeltaY = (dwSrcHeight - 1) << 16;
                srcDeltaY /= dwDstHeight - 1;
                srcDeltaY <<= 4;
#endif  // NOPRESTRETCH
            }
        }

        srcPreShrinkDeltaX = 0x100000;
        srcPreShrinkDeltaY = 0x100000;

        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {

            if ((((pDriverData->dwOverlaySrcWidth + 7) >> 3) >
                   pDriverData->dwOverlayDstWidth) && (pDriverData->dwOverlayDstWidth > 0)) {
                preScaleOverlay |= NV_PRESCALE_OVERLAY_X;
                srcPreShrinkDeltaX =
                    (pDriverData->dwOverlaySrcWidth << 20) / pDriverData->dwOverlayDstWidth;
                srcDeltaX = 0x100000;
            }

            if ((((pDriverData->dwOverlaySrcHeight + 7) >> 3) >
                   pDriverData->dwOverlayDstHeight) && (pDriverData->dwOverlayDstHeight > 0)) {
                preScaleOverlay |= NV_PRESCALE_OVERLAY_Y;
                srcPreShrinkDeltaY =
                    (pDriverData->dwOverlaySrcHeight << 20) / pDriverData->dwOverlayDstHeight;
#ifdef  NOPRESTRETCH
                if (showInterleavedFields) {
                    srcDeltaY = 0x80000;
                    pDriverData->dwOverlayDeltaY = 0x80000;
                } else {
#endif  // NOPRESTRETCH
                    srcDeltaY = 0x100000;
                    pDriverData->dwOverlayDeltaY = 0x100000;
#ifdef  NOPRESTRETCH
                }
#endif  // NOPRESTRETCH
            }
        } else {

            if ((pDriverData->dwOverlaySrcWidth >
                   pDriverData->dwOverlayDstWidth) && (pDriverData->dwOverlayDstWidth > 0)) {
                preScaleOverlay |= NV_PRESCALE_OVERLAY_X;
                srcPreShrinkDeltaX =
                    (pDriverData->dwOverlaySrcWidth << 20) / pDriverData->dwOverlayDstWidth;
                srcDeltaX = 0x100000;
            }

            if ((pDriverData->dwOverlaySrcHeight >
                   pDriverData->dwOverlayDstHeight) && (pDriverData->dwOverlayDstHeight > 0)) {
                preScaleOverlay |= NV_PRESCALE_OVERLAY_Y;
                srcPreShrinkDeltaY =
                    (pDriverData->dwOverlaySrcHeight << 20) / pDriverData->dwOverlayDstHeight;
#ifdef  NOPRESTRETCH
                if (showInterleavedFields) {
                    srcDeltaY = 0x80000;
                    pDriverData->dwOverlayDeltaY = 0x80000;
                } else {
#endif  // NOPRESTRETCH
                    srcDeltaY = 0x100000;
                    pDriverData->dwOverlayDeltaY = 0x100000;
#ifdef  NOPRESTRETCH
                }
#endif  // NOPRESTRETCH
            }
        }

#ifndef NOPRESTRETCH
        if ((showInterleavedFields) && (!(srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT))) {
            preScaleOverlay |= NV_PRESCALE_OVERLAY_FIELD;
            srcPreShrinkDeltaY >>= 1;
        }
#endif  // NOPRESTRETCH

        /* Check for Quadrant MCI DVD decoder */
        if ((preScaleOverlay == 0) && (surfaceIs422) &&
            (pDriverData->dwOverlaySurfaces == 1) &&
            (showInterleavedFields == 0) &&
            (src->wHeight >= 480) &&  // cannot make this larger due to widescreen problems
            (!(srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT)))
            preScaleOverlay = NV_PRESCALE_OVERLAY_QUADRANT;


        /* Must wait for any pending overlay flip to finish */
        /* if it is an autoflip then do not wait */
        if (!(lpUOData->dwFlags & DDOVER_AUTOFLIP)) {
            while (((volatile)pPioFlipOverlayNotifier[index + 1].status == NV_IN_PROGRESS))
                NV_SLEEP;
        }

        pPioFlipOverlayNotifier[index + 1].status = NV_IN_PROGRESS;

        dwSrcOffset = src->fpVidMem - pDriverData->BaseAddress;

        if ((src->ddpfSurface.dwFourCC == FOURCC_IF09) ||
            (src->ddpfSurface.dwFourCC == FOURCC_YVU9) ||
            (src->ddpfSurface.dwFourCC == FOURCC_IV32) ||
            (src->ddpfSurface.dwFourCC == FOURCC_IV31)) {
            /* Skip over Indeo portion of surface */
            dwSrcPitch = (DWORD)src->wWidth;
            dwSrcOffset += ((dwSrcPitch * ((DWORD)src->wHeight * 10L)) >> 3);
            /* Force block to be properly aligned */
            dwSrcOffset = (dwSrcOffset + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
            dwSrcPitch = ((src->wWidth + 1) & 0xFFFE) << 1;
            dwSrcPitch = (dwSrcPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
        } else if ((src->ddpfSurface.dwFourCC == FOURCC_YV12) ||
                   (src->ddpfSurface.dwFourCC == FOURCC_420i)) {
            /* Assumes a separate overlay YUY2 surface in video memory */
            if (src->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0])
                dwSrcOffset = pDriverData->NvYUY2Surface0Mem -
                                  pDriverData->BaseAddress;
            else if (src->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1])
                dwSrcOffset = pDriverData->NvYUY2Surface1Mem -
                                  pDriverData->BaseAddress;
            else if (src->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2])
                dwSrcOffset = pDriverData->NvYUY2Surface2Mem -
                                  pDriverData->BaseAddress;
            else
                dwSrcOffset = pDriverData->NvYUY2Surface3Mem -
                                  pDriverData->BaseAddress;

            dwSrcPitch = ((src->wWidth + 1) & 0xFFFE) << 1;
            dwSrcPitch = (dwSrcPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
        } else {
            dwSrcPitch = (DWORD)src->lPitch;
            surfaceIs422 = TRUE;
        }

        if (showInterleavedFields)
            dwSrcPitch <<= 1;

        /* Let the world know what the current overlay src offset is */
        pDriverData->OverlaySrcX = (short)(lpUOData->rSrc.left & ~1);
        pDriverData->OverlaySrcY = (short)lpUOData->rSrc.top;

        /* Preshrink overlay surface if necessary */
        if ((pDriverData->TotalVRAM >> 20 > 4) && (preScaleOverlay) &&
            (!(srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT))) {

            /* needed for Quadrant MCI DVD decoder fix only */
            pDriverData->lockCount = 0;

            while (videoFreeCount < 76)
                videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);
            videoFreeCount -= 76;

            //pDriverData->dwRingZeroMutex = TRUE;
            
                /* Trash spare subchannel */
            npDevVideo->dDrawSpare.SetObject = NV_DD_DVD_SUBPICTURE;

            npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutPoint = 0;

            /* Widths below are increased by 2 instead of 1 to remain hardware compatible */
            if (preScaleOverlay == NV_PRESCALE_OVERLAY_X) {
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                    asmMergeCoords(((pDriverData->dwOverlayDstWidth + 2) & ~1),
                                   dwSrcHeight);
            } else if (preScaleOverlay == NV_PRESCALE_OVERLAY_Y) {
                if (showInterleavedFields) {
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                        asmMergeCoords(((dwSrcWidth + 2) & ~1),
                                       (pDriverData->dwOverlayDstHeight >> 1));
                } else {
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                        asmMergeCoords(((dwSrcWidth + 2) & ~1),
                                       pDriverData->dwOverlayDstHeight);
                }
            } else if (preScaleOverlay == (NV_PRESCALE_OVERLAY_X + NV_PRESCALE_OVERLAY_Y)) {
                if (showInterleavedFields) {
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                        asmMergeCoords(((pDriverData->dwOverlayDstWidth + 2) & ~1),
                                       (pDriverData->dwOverlayDstHeight >> 1));
                } else {
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                        asmMergeCoords(((pDriverData->dwOverlayDstWidth + 2) & ~1),
                                       pDriverData->dwOverlayDstHeight);
                }
            } else if (preScaleOverlay == NV_PRESCALE_OVERLAY_FIELD) {
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                    asmMergeCoords(((pDriverData->dwOverlaySrcWidth + 2) & ~1),
                                   pDriverData->dwOverlaySrcHeight);
            } else if (preScaleOverlay == (NV_PRESCALE_OVERLAY_X + NV_PRESCALE_OVERLAY_FIELD)) {
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                    asmMergeCoords(((pDriverData->dwOverlayDstWidth + 2) & ~1),
                                   pDriverData->dwOverlaySrcHeight);
            } else if (preScaleOverlay == (NV_PRESCALE_OVERLAY_Y + NV_PRESCALE_OVERLAY_FIELD)) {
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                    asmMergeCoords(((dwSrcWidth + 2) & ~1),
                                   pDriverData->dwOverlayDstHeight);
            } else if (preScaleOverlay == (NV_PRESCALE_OVERLAY_X + NV_PRESCALE_OVERLAY_Y + NV_PRESCALE_OVERLAY_FIELD)) {
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                    asmMergeCoords(((pDriverData->dwOverlayDstWidth + 2) & ~1),
                                   pDriverData->dwOverlayDstHeight);
            } else { // NV_PRESCALE_OVERLAY_QUADRANT
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                    asmMergeCoords(((pDriverData->dwOverlaySrcWidth + 2) & ~1),
                                   pDriverData->dwOverlaySrcHeight);
            }

            if (preScaleOverlay & NV_PRESCALE_OVERLAY_FIELD) {
                if (src->ddpfSurface.dwFourCC == FOURCC_UYVY)
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutFormat =
                        (NV038_IMAGE_OUT_FORMAT_COLOR_LE_YB8V8YA8U8 << 16) | (dwSrcPitch >> 1);
                else
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutFormat =
                        (NV038_IMAGE_OUT_FORMAT_COLOR_LE_V8YB8U8YA8 << 16) | (dwSrcPitch >> 1);
            } else {
                if (src->ddpfSurface.dwFourCC == FOURCC_UYVY)
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutFormat =
                        (NV038_IMAGE_OUT_FORMAT_COLOR_LE_YB8V8YA8U8 << 16) | dwSrcPitch;
                else
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutFormat =
                        (NV038_IMAGE_OUT_FORMAT_COLOR_LE_V8YB8U8YA8 << 16) | dwSrcPitch;
            }

            /* Output to extra overlay surface memory area */
            if ((surfaceIs422) && (pDriverData->extra422OverlayOffset[index] != 0))
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutOffset =
                    pDriverData->extra422OverlayOffset[index];
            else
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutOffset =
                    (dwSrcOffset + src->dwReserved1);

            npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageInDeltaDuDx = srcPreShrinkDeltaX;
            npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageInDeltaDvDy = srcPreShrinkDeltaY;

            npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageInSize =
                asmMergeCoords(((pDriverData->dwOverlaySrcWidth + 1) & ~1), dwSrcHeight);

            if (src->ddpfSurface.dwFourCC == FOURCC_UYVY)
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageInFormat =
                    (NV038_IMAGE_IN_FORMAT_COLOR_LE_YB8V8YA8U8 << 16) | dwSrcPitch;
            else
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageInFormat =
                    (NV038_IMAGE_IN_FORMAT_COLOR_LE_V8YB8U8YA8 << 16) | dwSrcPitch;

            /* Temporarily offset to the beginning of the visible portion of source surface */
            dwSrcOffset += (lpUOData->rSrc.top * dwSrcPitch);
            dwSrcOffset += ((lpUOData->rSrc.left & ~1) << 1);

            npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageInOffset =
                dwSrcOffset;

            npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageInPoint = 0;

            npDevVideo->dDrawSpare.nv4DvdSubpicture.OverlayDeltaDuDx = srcPreShrinkDeltaX;
            npDevVideo->dDrawSpare.nv4DvdSubpicture.OverlayDeltaDvDy = srcPreShrinkDeltaY;

            npDevVideo->dDrawSpare.nv4DvdSubpicture.OverlaySize =
                asmMergeCoords(((pDriverData->dwOverlaySrcWidth + 1) & ~1), dwSrcHeight);

            npDevVideo->dDrawSpare.nv4DvdSubpicture.OverlayFormat =
                (NV038_OVERLAY_FORMAT_COLOR_LE_TRANSPARENT << 16) | dwSrcPitch;

            npDevVideo->dDrawSpare.nv4DvdSubpicture.OverlayOffset =
                dwSrcOffset;

            /* Restore offset */
            dwSrcOffset -= (lpUOData->rSrc.top * dwSrcPitch);
            dwSrcOffset -= ((lpUOData->rSrc.left & ~1) << 1);

            npDevVideo->dDrawSpare.nv4DvdSubpicture.OverlayPoint = 0;

            pDriverData->dDrawSpareSubchannelObject = 0;

            /* Change offset to point to shrunken overlay surface memory */
            if ((surfaceIs422) && (pDriverData->extra422OverlayOffset[index] != 0))
                dwSrcOffset = pDriverData->extra422OverlayOffset[index];
            else
                dwSrcOffset += src->dwReserved1;

            /* Restore overlay source pitch and height to normal since we prescaled it */
            if (preScaleOverlay & NV_PRESCALE_OVERLAY_FIELD) {
                dwSrcPitch >>= 1;
                dwSrcHeight <<= 1;
            }

            /* Force fifo to stall until shrink operation finishes */
            npDevVideo->dDrawSpare.nv4DvdSubpicture.Notify = 0;
            npDevVideo->dDrawSpare.nv4DvdSubpicture.NoOperation = 0;
                
                //pDriverData->dwRingZeroMutex = FALSE;
            
        } else {
            /* Offset to visible portion of source surface */
            dwSrcOffset += (lpUOData->rSrc.top * dwSrcPitch);
            dwSrcOffset += ((lpUOData->rSrc.left & ~1) << 1);
        }

        while (videoFreeCount <56)
            videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);
        videoFreeCount -= 56;

        //pDriverData->dwRingZeroMutex = TRUE;
            
        /* Trash spare subchannel */
        npDevVideo->dDrawSpare.SetObject = NV_DD_VIDEO_COLOR_KEY;
        npDevVideo->dDrawSpare.videoColorKey.SetPoint =
            asmMergeCoords(lpUOData->rDest.left, lpUOData->rDest.top);
        npDevVideo->dDrawSpare.videoColorKey.SetSize =
            asmMergeCoords((dwDstWidth & ~1), (dwDstHeight & ~1));

        /*
         * color key?
         */
        if( lpUOData->dwFlags & (DDOVER_KEYDESTOVERRIDE) ) {
            DPF( "Dest ColorKey = %08lx,%08lx",
                lpUOData->overlayFX.dckDestColorkey.dwColorSpaceLowValue,
                lpUOData->overlayFX.dckDestColorkey.dwColorSpaceHighValue );

            if (pDriverData->bi.biBitCount == 8)
                npDevVideo->dDrawSpare.videoColorKey.SetColorKey =
                    lpUOData->overlayFX.dckDestColorkey.dwColorSpaceLowValue |
                        NV_ALPHA_1_008;
            else if (pDriverData->bi.biBitCount == 16)
                npDevVideo->dDrawSpare.videoColorKey.SetColorKey =
                    lpUOData->overlayFX.dckDestColorkey.dwColorSpaceLowValue |
                        NV_ALPHA_1_016;
            else
                npDevVideo->dDrawSpare.videoColorKey.SetColorKey =
                    lpUOData->overlayFX.dckDestColorkey.dwColorSpaceLowValue |
                        NV_ALPHA_1_032;

        } else // disable color key
            npDevVideo->dDrawSpare.videoColorKey.SetColorKey = 0;


        npDevVideo->dDrawSpare.SetObject = NV_DD_VIDEO_SCALER;
        npDevVideo->dDrawSpare.videoScaler.SetPoint =
            asmMergeCoords(lpUOData->rDest.left, lpUOData->rDest.top);
        npDevVideo->dDrawSpare.videoScaler.SetDeltaDuDx = srcDeltaX;

        if( ! bMediaPortControl )
            npDevVideo->dDrawSpare.videoScaler.SetDeltaDvDy = srcDeltaY;

        npDevVideo->dDrawSpare.SetObject = NV_DD_YUV422_VIDEO_FROM_MEMORY;

// temp defines b4 becoming a class standard
#define NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_0 (0x04000000)
#define NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_1 (0x02000000)
#define NV_VFM_FORMAT_BOBFROMINTERLEAVE           (0x08000000)

        if (lpUOData->dwFlags & DDOVER_AUTOFLIP)
            index = 0; // overide index for mediaport/overlay autoflip

        if ((src->ddpfSurface.dwFourCC == FOURCC_UYVY) ||
            (src->ddpfSurface.dwFourCC == FOURCC_UYNV)) {
            U032 dwFormat = NV_VFM_FORMAT_COLOR_LE_Y8V8Y8U8;

            // we need to know if we're bobbing
            if((lpUOData->dwFlags & DDOVER_BOB) && (lpUOData->dwFlags & DDOVER_INTERLEAVED) ){
                dwFormat = dwFormat | NV_VFM_FORMAT_BOBFROMINTERLEAVE;
                DPF( "Video Port - Interleaved - BOB");
            }

            if (srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT) {

                if (lpUOData->dwFlags & DDOVER_AUTOFLIP) {
                    dwFormat |= (index ? NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_1 :
                                         NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_0);
                }

                if ((lpUOData->dwFlags & DDOVER_BOB) && (index == 1)) {
                    // improves quality on BOB for low resolution images
                    // only do a BOB if srcY >= 120
                    if ((lpUOData->rSrc.bottom - lpUOData->rSrc.top) >=120)
                        dwSrcPitch |= 2; // tell overlay to do a halfline offset
                }
            }

            if( ! bMediaPortControl )
                npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].format =
                    dwFormat;
            /* Let the world know what the overlay src info is */
            pDriverData->OverlayFormat = dwFormat;
        } else
            npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].format =
                NV_VFM_FORMAT_COLOR_LE_V8Y8U8Y8;

        /* Let the world know what the overlay src info is */
        pDriverData->OverlaySrcOffset = dwSrcOffset;

        pDriverData->OverlaySrcPitch = dwSrcPitch;

        pDriverData->OverlaySrcSize = asmMergeCoords(dwSrcWidth, dwSrcHeight);

        if( ! bMediaPortControl ) {
            npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].offset =
                dwSrcOffset;
            npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].pitch =
                dwSrcPitch;
            npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].size =
                asmMergeCoords(dwSrcWidth, dwSrcHeight);

            npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].notify = 0;
        }
      //pDriverData->dwRingZeroMutex = FALSE;
            
        pDriverData->dDrawSpareSubchannelObject = 0;

        /* Quadrant DVD decoder hack should NOT go here because DVD subpicture slows things down enough */

        /* Let DDraw know how many visible overlays are active */
        if (pDriverData->HALInfo.ddCaps.dwCurrVisibleOverlays == 0) {
            pDriverData->HALInfo.ddCaps.dwCurrVisibleOverlays = 1;
        }
    }

    pDriverData->NvVideoFreeCount = (short)videoFreeCount;
    
    pDriverData->dwRingZeroMutex = FALSE;

#ifdef NVPE
	///// H.AZAR: (03/01/1999): notify miniport of overlay changes !
	if (bMediaPortControl)
		NVPUpdateOverlay();
#endif	// #ifdef NVPE

    lpUOData->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;

} /* UpdateOverlay32 */


/*
 * SetOverlayPosition32
 */
DWORD __stdcall
SetOverlayPosition32( LPDDHAL_SETOVERLAYPOSITIONDATA lpSOPData )
{
    FAST Nv3ChannelPio          *npDevVideo;
    FAST long                   videoFreeCount;
    DWORD                       index = 0;
    DWORD                       match = 0;
    LPDDRAWI_DDRAWSURFACE_LCL   srcx = lpSOPData->lpDDSrcSurface;

    NvSetDriverDataPtr(lpSOPData->lpDD);

    npDevVideo = (NvChannel *)pDriverData->NvDevVideoFlatPio;
    videoFreeCount = pDriverData->NvVideoFreeCount;

    if (!(srcx->ddsCaps.dwCaps & DDSCAPS_OVERLAY)) {
            lpSOPData->ddRVal = DDERR_NOTAOVERLAYSURFACE;
            return DDHAL_DRIVER_HANDLED;
    }

    if ((lpSOPData->lXPos < 0) || (lpSOPData->lYPos < 0)) {
            lpSOPData->ddRVal = DDERR_INVALIDPOSITION;
            return DDHAL_DRIVER_HANDLED;
    }

    while ((index < NV_MAX_OVERLAY_SURFACES) && (!match))
        if ((DWORD)srcx == pDriverData->dwOverlaySurfaceLCL[index++])
            match = 1;

    if (!match) {
        lpSOPData->ddRVal = DDERR_OUTOFCAPS;
        return DDHAL_DRIVER_HANDLED;
    }

#if 0
        // This code will eventually be used to specially opt out of overlay stuff when video port is in use
    if( srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT)  {

        lpUOData->ddRVal = HandleVideoPortOverlayPosition( lpSOPData);
    return DDHAL_DRIVER_HANDLED;

    }
#endif //

    NV_DD_DMA_PUSHER_SYNC();

    if (npDevVideo == NULL) {  /* Mode switches might occur without warning */
        lpSOPData->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
    }

    while (videoFreeCount < 28)
        videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);
    videoFreeCount -= 28;

    /*
     * NOTES:
     *
     * This callback is invoked to set an overlay position
     */
    DPF( "SET OVERLAY POSITION" );
    DPF( "Overlay surface = %08lx", lpSOPData->lpDDSrcSurface );
    DPF( "(%ld,%ld)", lpSOPData->lXPos, lpSOPData->lYPos );

    pDriverData->dwRingZeroMutex = TRUE;
     /* Trash spare subchannel */
    npDevVideo->dDrawSpare.SetObject = NV_DD_VIDEO_COLOR_KEY;
    npDevVideo->dDrawSpare.videoColorKey.SetPoint =
        asmMergeCoords(lpSOPData->lXPos, lpSOPData->lYPos);

    npDevVideo->dDrawSpare.SetObject = NV_DD_VIDEO_SCALER;
    npDevVideo->dDrawSpare.videoScaler.SetPoint =
        asmMergeCoords(lpSOPData->lXPos, lpSOPData->lYPos);

    /* Our new mechanism requires that we use the VFM notifier to make this happen */
    npDevVideo->dDrawSpare.SetObject = NV_DD_YUV422_VIDEO_FROM_MEMORY;

    /* Alternate buffer indexes to keep the hardware happy */
    pDriverData->OverlayBufferIndex ^= 1;

    index = pDriverData->OverlayBufferIndex;

    npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].offset =
        pDriverData->OverlaySrcOffset;
    npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].pitch =
        pDriverData->OverlaySrcPitch;
    npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].size =
        pDriverData->OverlaySrcSize;
    /* We won't wait for this notifier so status won't be initialized */
    npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].notify = 0;

    pDriverData->dwRingZeroMutex = FALSE;
    pDriverData->dDrawSpareSubchannelObject = 0;

    pDriverData->NvVideoFreeCount = (short)videoFreeCount;

    lpSOPData->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;

} /* SetOverlayPosition32 */



/*
 * DestroyFloating422Context32
 *
 */

DWORD __stdcall
DestroyFloating422Context32(LPDDRAWI_DDRAWSURFACE_LCL lpDDSurface)
{
    FAST Nv10ControlDma         *npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf;
    LPDDRAWI_DDRAWSURFACE_GBL   psurf_gbl;
    unsigned long               *dmaPusherPutAddress =
                                    (unsigned long *)pDriverData->NvDmaPusherPutAddress;
    unsigned long               *dmaPusherBufferBase =
                                    (unsigned long *)pDriverData->NvDmaPusherBufferBase;
#ifdef  CACHE_FREECOUNT
    long                        freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
    long                        freeCount = 0;
#endif  /* CACHE_FREECOUNT */

    NV_DD_DMA_PUSHER_SYNC();

    /* Let D3D code know that we have touched NV */
    pDriverData->TwoDRenderingOccurred = 1;

    psurf = lpDDSurface;
    psurf_gbl = psurf->lpGbl;

   if ((psurf_gbl->ddpfSurface.dwFourCC == FOURCC_UYVY) ||
       (psurf_gbl->ddpfSurface.dwFourCC == FOURCC_UYNV)) {
        if ((pDriverData->fNvActiveFloatingContexts &
            NV_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
           (pDriverData->NvFloating0UYVYSurfaceMem == psurf_gbl->fpVidMem)) {
                long countDown;
            NvNotification *pDmaSyncNotifier =
                (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;

            // MUST wait for any pending notification to prevent possible loss of notification serialization
            countDown = 0x200000;
                while (((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) && (--countDown > 0)) NV_SLEEP;


            while (freeCount < 8)
                NvGetDmaBufferFreeCount(npDev, freeCount, 8, dmaPusherPutAddress);
            freeCount -= 8;

            pDriverData->dDrawSpareSubchannelObject = 0;

            pDmaSyncNotifier->status = NV_IN_PROGRESS;

            /* Trash spare subchannel */
            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
            dmaPusherPutAddress[1] = NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000;
            dmaPusherPutAddress[3] = NV1_NULL_OBJECT;
            dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
            dmaPusherPutAddress[5] = 0;
            dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
            dmaPusherPutAddress[7] = 0;

            dmaPusherPutAddress += 8;

            pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

            /* Force write combine buffer to flush */
            pDriverData->NvDmaPusherBufferEnd[0] = 0;
            /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
            _outp (0x3d0,0);

            npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

            countDown = 0x200000;
                while (((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS)&& (--countDown > 0)) NV_SLEEP; // wait for notification


#ifdef  MULTI_MON
            NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                     NV_DD_DMA_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY);
#else   /* MULTI_MON */
            while (freeCount < 6)
                NvGetDmaBufferFreeCount(npDev, freeCount, 6, dmaPusherPutAddress);
            freeCount -= 6;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
            dmaPusherPutAddress[1] = NV_DD_DMA_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_OFFSET | 0xC0000;
            dmaPusherPutAddress[3] = 0; // unlock system memory
            dmaPusherPutAddress[4] = 0;
            dmaPusherPutAddress[5] = 0;

            dmaPusherPutAddress += 6;
#endif  /* MULTI_MON */

            pDriverData->fNvActiveFloatingContexts &=
                ~NV_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        } else if ((pDriverData->fNvActiveFloatingContexts &
            NV_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
           (pDriverData->NvFloating1UYVYSurfaceMem == psurf_gbl->fpVidMem)) {
            NvNotification *pDmaSyncNotifier =
                (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;

            // MUST wait for any pending notification to prevent possible loss of notification serialization
            while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP;

            while (freeCount < 8)
                NvGetDmaBufferFreeCount(npDev, freeCount, 8, dmaPusherPutAddress);
            freeCount -= 8;

            pDriverData->dDrawSpareSubchannelObject = 0;

            pDmaSyncNotifier->status = NV_IN_PROGRESS;

            /* Trash spare subchannel */
            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
            dmaPusherPutAddress[1] = NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000;
            dmaPusherPutAddress[3] = NV1_NULL_OBJECT;
            dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
            dmaPusherPutAddress[5] = 0;
            dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
            dmaPusherPutAddress[7] = 0;

            dmaPusherPutAddress += 8;

            pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

            /* Force write combine buffer to flush */
            pDriverData->NvDmaPusherBufferEnd[0] = 0;
            /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
            _outp (0x3d0,0);

            npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

            while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification

#ifdef  MULTI_MON
            NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                     NV_DD_DMA_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY);
#else   /* MULTI_MON */
            while (freeCount < 6)
                NvGetDmaBufferFreeCount(npDev, freeCount, 6, dmaPusherPutAddress);
            freeCount -= 6;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
            dmaPusherPutAddress[1] = NV_DD_DMA_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_OFFSET | 0xC0000;
            dmaPusherPutAddress[3] = 0; // unlock system memory
            dmaPusherPutAddress[4] = 0;
            dmaPusherPutAddress[5] = 0;

            dmaPusherPutAddress += 6;
#endif  /* MULTI_MON */

            pDriverData->fNvActiveFloatingContexts &=
                ~NV_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
        }
    } else { /* YUYV */
        if ((pDriverData->fNvActiveFloatingContexts &
            NV_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
           (pDriverData->NvFloating0YUYVSurfaceMem == psurf_gbl->fpVidMem)) {
            NvNotification *pDmaSyncNotifier =
                (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;

            // MUST wait for any pending notification to prevent possible loss of notification serialization
            while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP;

            while (freeCount < 8)
                NvGetDmaBufferFreeCount(npDev, freeCount, 8, dmaPusherPutAddress);
            freeCount -= 8;

            pDriverData->dDrawSpareSubchannelObject = 0;

            pDmaSyncNotifier->status = NV_IN_PROGRESS;

            /* Trash spare subchannel */
            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
            dmaPusherPutAddress[1] = NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000;
            dmaPusherPutAddress[3] = NV1_NULL_OBJECT;
            dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
            dmaPusherPutAddress[5] = 0;
            dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
            dmaPusherPutAddress[7] = 0;

            dmaPusherPutAddress += 8;

            pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

            /* Force write combine buffer to flush */
            pDriverData->NvDmaPusherBufferEnd[0] = 0;
            /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
            _outp (0x3d0,0);

            npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

            while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification

#ifdef  MULTI_MON
            NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                     NV_DD_DMA_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY);
#else   /* MULTI_MON */
            while (freeCount < 6)
                NvGetDmaBufferFreeCount(npDev, freeCount, 6, dmaPusherPutAddress);
            freeCount -= 6;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
            dmaPusherPutAddress[1] = NV_DD_DMA_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_OFFSET | 0xC0000;
            dmaPusherPutAddress[3] = 0; // unlock system memory
            dmaPusherPutAddress[4] = 0;
            dmaPusherPutAddress[5] = 0;

            dmaPusherPutAddress += 6;
#endif  /* MULTI_MON */

            pDriverData->fNvActiveFloatingContexts &=
                ~NV_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        } else if ((pDriverData->fNvActiveFloatingContexts &
            NV_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
           (pDriverData->NvFloating1YUYVSurfaceMem == psurf_gbl->fpVidMem)) {
            NvNotification *pDmaSyncNotifier =
                (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;

            // MUST wait for any pending notification to prevent possible loss of notification serialization
            while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP;

            while (freeCount < 8)
                NvGetDmaBufferFreeCount(npDev, freeCount, 8, dmaPusherPutAddress);
            freeCount -= 8;

            pDriverData->dDrawSpareSubchannelObject = 0;

            pDmaSyncNotifier->status = NV_IN_PROGRESS;

            /* Trash spare subchannel */
            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
            dmaPusherPutAddress[1] = NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000;
            dmaPusherPutAddress[3] = NV1_NULL_OBJECT;
            dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
            dmaPusherPutAddress[5] = 0;
            dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
            dmaPusherPutAddress[7] = 0;

            dmaPusherPutAddress += 8;

            pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

            /* Force write combine buffer to flush */
            pDriverData->NvDmaPusherBufferEnd[0] = 0;
            /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
            _outp (0x3d0,0);

            npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

            while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification

#ifdef  MULTI_MON
            NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                     NV_DD_DMA_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY);
#else   /* MULTI_MON */
            while (freeCount < 6)
                NvGetDmaBufferFreeCount(npDev, freeCount, 6, dmaPusherPutAddress);
            freeCount -= 6;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
            dmaPusherPutAddress[1] = NV_DD_DMA_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_OFFSET | 0xC0000;
            dmaPusherPutAddress[3] = 0; // unlock system memory
            dmaPusherPutAddress[4] = 0;
            dmaPusherPutAddress[5] = 0;

            dmaPusherPutAddress += 6;
#endif  /* MULTI_MON */

            pDriverData->fNvActiveFloatingContexts &=
                ~NV_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
        }
    }

    pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

    /* Force write combine buffer to flush */
    pDriverData->NvDmaPusherBufferEnd[0] = 0;
    /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
    _outp (0x3d0,0);

    pDriverData->dwDmaPusherFreeCount = freeCount;

    npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

    return DDHAL_DRIVER_HANDLED;
}



/*
 * CreateFloating422Context32
 *
 */

DWORD __stdcall
CreateFloating422Context32(LPDDRAWI_DDRAWSURFACE_LCL lpDDSurface, DWORD dwBlockSize)
{
   FAST Nv10ControlDma         *npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;
   NvNotification              *pDmaDmaToMemNotifier =
                                   (NvNotification *)pDriverData->NvDmaDmaToMemNotifierFlat;
   LPDDRAWI_DDRAWSURFACE_LCL   psurf;
   LPDDRAWI_DDRAWSURFACE_GBL   psurf_gbl;
   unsigned long               *dmaPusherPutAddress =
                                   (unsigned long *)pDriverData->NvDmaPusherPutAddress;
   unsigned long               *dmaPusherBufferBase =
                                   (unsigned long *)pDriverData->NvDmaPusherBufferBase;
#ifdef  MULTI_MON
   unsigned long               status;
#endif  /* MULTI_MON */
#ifdef  CACHE_FREECOUNT
   long                        freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
   long                        freeCount = 0;
#endif  /* CACHE_FREECOUNT */

   NV_DD_DMA_PUSHER_SYNC();

   /* Let D3D code know that we have touched NV */
   pDriverData->TwoDRenderingOccurred = 1;

   psurf = lpDDSurface;
   psurf_gbl = psurf->lpGbl;

   if ((psurf_gbl->ddpfSurface.dwFourCC == FOURCC_UYVY) ||
       (psurf_gbl->ddpfSurface.dwFourCC == FOURCC_UYNV)) {
       if ((pDriverData->fNvActiveFloatingContexts &
           NV_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) == 0) {

#ifdef MULTI_MON
           status = NvRmAllocContextDma(pDriverData->dwRootHandle,
                               NV_DD_DMA_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY,
                               NV01_CONTEXT_DMA,
                               (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                                ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED),
                               (PVOID)psurf_gbl->fpVidMem,
                               (dwBlockSize - 1));

           if (status == ALLOC_CTX_DMA_STATUS_SUCCESS) {

               pDriverData->fNvActiveFloatingContexts |=
                   NV_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               pDriverData->NvFloating0UYVYSurfaceMem = psurf_gbl->fpVidMem;

               while (freeCount < 4)
                   NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
               freeCount -= 4;

               pDriverData->dDrawSpareSubchannelObject = 0;

               /* Trash spare subchannel */
               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
               dmaPusherPutAddress[1] = NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
               dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                        SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000;
               dmaPusherPutAddress[3] = NV_DD_DMA_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               dmaPusherPutAddress += 4;

               pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

               /* Force write combine buffer to flush */
               pDriverData->NvDmaPusherBufferEnd[0] = 0;
               /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
               _outp (0x3d0,0);

               pDriverData->dwDmaPusherFreeCount = freeCount;

               npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
           }

#else   /* MULTI_MON */

           pDmaDmaToMemNotifier->status = NV_IN_PROGRESS;

           /* Trash spare subchannel */
           while (freeCount < 13)
               NvGetDmaBufferFreeCount(npDev, freeCount, 13, dmaPusherPutAddress);
           freeCount -= 13;

           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
           dmaPusherPutAddress[1] = NV_DD_DMA_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
           dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_OFFSET | 0x80000;
           dmaPusherPutAddress[3] = (unsigned long)psurf_gbl->fpVidMem;
           dmaPusherPutAddress[4] = (unsigned long)NvGetFlatDataSelector();
           dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_NOTIFY_OFFSET | 0x40000;
           dmaPusherPutAddress[6] = 0;
           dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_LIMIT_OFFSET | 0x40000;
           dmaPusherPutAddress[8] = dwBlockSize - 1;

           dmaPusherPutAddress[9] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
           dmaPusherPutAddress[10] = NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
           dmaPusherPutAddress[11] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000;
           dmaPusherPutAddress[12] = NV_DD_DMA_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

           dmaPusherPutAddress += 13;

           pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

           /* Force write combine buffer to flush */
           pDriverData->NvDmaPusherBufferEnd[0] = 0;
           /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
           _outp (0x3d0,0);

           pDriverData->dwDmaPusherFreeCount = freeCount;

           npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

           while ((volatile)pDmaDmaToMemNotifier->status == NV_IN_PROGRESS) NV_SLEEP;

           if (pDmaDmaToMemNotifier->status == NV_STATUS_DONE_OK) {

               pDriverData->dDrawSpareSubchannelObject =
                   NV_DD_DMA_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               pDriverData->fNvActiveFloatingContexts |=
                   NV_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               pDriverData->NvFloating0UYVYSurfaceMem = psurf_gbl->fpVidMem;
           }
#endif  /* MULTI_MON */
       } else if ((pDriverData->fNvActiveFloatingContexts &
           NV_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) == 0) {

#ifdef MULTI_MON
           status = NvRmAllocContextDma(pDriverData->dwRootHandle,
                               NV_DD_DMA_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY,
                               NV01_CONTEXT_DMA,
                               (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                                ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED),
                               (PVOID)psurf_gbl->fpVidMem,
                               (dwBlockSize - 1));

           if (status == ALLOC_CTX_DMA_STATUS_SUCCESS) {

               pDriverData->fNvActiveFloatingContexts |=
                   NV_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               pDriverData->NvFloating1UYVYSurfaceMem = psurf_gbl->fpVidMem;

               while (freeCount < 4)
                   NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
               freeCount -= 4;

               pDriverData->dDrawSpareSubchannelObject = 0;

               /* Trash spare subchannel */
               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
               dmaPusherPutAddress[1] = NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
               dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                        SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000;
               dmaPusherPutAddress[3] = NV_DD_DMA_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               dmaPusherPutAddress += 4;

               pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

               /* Force write combine buffer to flush */
               pDriverData->NvDmaPusherBufferEnd[0] = 0;
               /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
               _outp (0x3d0,0);

               pDriverData->dwDmaPusherFreeCount = freeCount;

               npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
           }

#else   /* MULTI_MON */

           pDmaDmaToMemNotifier->status = NV_IN_PROGRESS;

           /* Trash spare subchannel */
           while (freeCount < 13)
               NvGetDmaBufferFreeCount(npDev, freeCount, 13, dmaPusherPutAddress);
           freeCount -= 13;

           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
           dmaPusherPutAddress[1] = NV_DD_DMA_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
           dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_OFFSET | 0x80000;
           dmaPusherPutAddress[3] = (unsigned long)psurf_gbl->fpVidMem;
           dmaPusherPutAddress[4] = (unsigned long)NvGetFlatDataSelector();
           dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_NOTIFY_OFFSET | 0x40000;
           dmaPusherPutAddress[6] = 0;
           dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_LIMIT_OFFSET | 0x40000;
           dmaPusherPutAddress[8] = dwBlockSize - 1;

           dmaPusherPutAddress[9] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
           dmaPusherPutAddress[10] = NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
           dmaPusherPutAddress[11] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000;
           dmaPusherPutAddress[12] = NV_DD_DMA_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

           dmaPusherPutAddress += 13;

           pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

           /* Force write combine buffer to flush */
           pDriverData->NvDmaPusherBufferEnd[0] = 0;
           /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
           _outp (0x3d0,0);

           pDriverData->dwDmaPusherFreeCount = freeCount;

           npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

           while ((volatile)pDmaDmaToMemNotifier->status == NV_IN_PROGRESS) NV_SLEEP;

           if (pDmaDmaToMemNotifier->status == NV_STATUS_DONE_OK) {

               pDriverData->dDrawSpareSubchannelObject =
                   NV_DD_PIO_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               pDriverData->fNvActiveFloatingContexts |=
                   NV_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               pDriverData->NvFloating1UYVYSurfaceMem = psurf_gbl->fpVidMem;
           }
#endif  /* MULTI_MON */
       }
   } else if ((psurf_gbl->ddpfSurface.dwFourCC == FOURCC_YUY2) ||
              (psurf_gbl->ddpfSurface.dwFourCC == FOURCC_YUNV)) {
       if ((pDriverData->fNvActiveFloatingContexts &
           NV_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) == 0) {

#ifdef MULTI_MON
           status = NvRmAllocContextDma(pDriverData->dwRootHandle,
                               NV_DD_DMA_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY,
                               NV01_CONTEXT_DMA,
                               (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                                ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED),
                               (PVOID)psurf_gbl->fpVidMem,
                               (dwBlockSize - 1));

           if (status == ALLOC_CTX_DMA_STATUS_SUCCESS) {

               pDriverData->fNvActiveFloatingContexts |=
                   NV_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               pDriverData->NvFloating0YUYVSurfaceMem = psurf_gbl->fpVidMem;

               while (freeCount < 4)
                   NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
               freeCount -= 4;

               pDriverData->dDrawSpareSubchannelObject = 0;

               /* Trash spare subchannel */
               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
               dmaPusherPutAddress[1] = NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
               dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                        SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000;
               dmaPusherPutAddress[3] = NV_DD_DMA_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               dmaPusherPutAddress += 4;

               pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

               /* Force write combine buffer to flush */
               pDriverData->NvDmaPusherBufferEnd[0] = 0;
               /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
               _outp (0x3d0,0);

               pDriverData->dwDmaPusherFreeCount = freeCount;

               npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
           }

#else   /* MULTI_MON */

           pDmaDmaToMemNotifier->status = NV_IN_PROGRESS;

           /* Trash spare subchannel */
           while (freeCount < 13)
               NvGetDmaBufferFreeCount(npDev, freeCount, 13, dmaPusherPutAddress);
           freeCount -= 13;

           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
           dmaPusherPutAddress[1] = NV_DD_DMA_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
           dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_OFFSET | 0x80000;
           dmaPusherPutAddress[3] = (unsigned long)psurf_gbl->fpVidMem;
           dmaPusherPutAddress[4] = (unsigned long)NvGetFlatDataSelector();
           dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_NOTIFY_OFFSET | 0x40000;
           dmaPusherPutAddress[6] = 0;
           dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_LIMIT_OFFSET | 0x40000;
           dmaPusherPutAddress[8] = dwBlockSize - 1;

           dmaPusherPutAddress[9] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
           dmaPusherPutAddress[10] = NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
           dmaPusherPutAddress[11] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000;
           dmaPusherPutAddress[12] = NV_DD_DMA_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

           dmaPusherPutAddress += 13;

           pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

           /* Force write combine buffer to flush */
           pDriverData->NvDmaPusherBufferEnd[0] = 0;
           /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
           _outp (0x3d0,0);

           pDriverData->dwDmaPusherFreeCount = freeCount;

           npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

           while ((volatile)pDmaDmaToMemNotifier->status == NV_IN_PROGRESS) NV_SLEEP;

           if (pDmaDmaToMemNotifier->status == NV_STATUS_DONE_OK) {

               pDriverData->dDrawSpareSubchannelObject =
                   NV_DD_PIO_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               pDriverData->fNvActiveFloatingContexts |=
                   NV_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               pDriverData->NvFloating0YUYVSurfaceMem = psurf_gbl->fpVidMem;
           }
#endif  /* MULTI_MON */
       } else if ((pDriverData->fNvActiveFloatingContexts &
           NV_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) == 0) {

#ifdef MULTI_MON
           status = NvRmAllocContextDma(pDriverData->dwRootHandle,
                               NV_DD_DMA_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY,
                               NV01_CONTEXT_DMA,
                               (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                                ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED),
                               (PVOID)psurf_gbl->fpVidMem,
                               (dwBlockSize - 1));

           if (status == ALLOC_CTX_DMA_STATUS_SUCCESS) {

               pDriverData->fNvActiveFloatingContexts |=
                   NV_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               pDriverData->NvFloating0YUYVSurfaceMem = psurf_gbl->fpVidMem;

               while (freeCount < 4)
                   NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
               freeCount -= 4;

               pDriverData->dDrawSpareSubchannelObject = 0;

               /* Trash spare subchannel */
               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
               dmaPusherPutAddress[1] = NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
               dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                        SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000;
               dmaPusherPutAddress[3] = NV_DD_DMA_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               dmaPusherPutAddress += 4;

               pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

               /* Force write combine buffer to flush */
               pDriverData->NvDmaPusherBufferEnd[0] = 0;
               /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
               _outp (0x3d0,0);

               pDriverData->dwDmaPusherFreeCount = freeCount;

               npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
           }

#else   /* MULTI_MON */

           pDmaDmaToMemNotifier->status = NV_IN_PROGRESS;

           /* Trash spare subchannel */
           while (freeCount < 13)
               NvGetDmaBufferFreeCount(npDev, freeCount, 13, dmaPusherPutAddress);
           freeCount -= 13;

           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
           dmaPusherPutAddress[1] = NV_DD_DMA_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
           dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_OFFSET | 0x80000;
           dmaPusherPutAddress[3] = (unsigned long)psurf_gbl->fpVidMem;
           dmaPusherPutAddress[4] = (unsigned long)NvGetFlatDataSelector();
           dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_NOTIFY_OFFSET | 0x40000;
           dmaPusherPutAddress[6] = 0;
           dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_LIMIT_OFFSET | 0x40000;
           dmaPusherPutAddress[8] = dwBlockSize - 1;

           dmaPusherPutAddress[9] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
           dmaPusherPutAddress[10] = NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
           dmaPusherPutAddress[11] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000;
           dmaPusherPutAddress[12] = NV_DD_DMA_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

           dmaPusherPutAddress += 13;

           pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

           /* Force write combine buffer to flush */
           pDriverData->NvDmaPusherBufferEnd[0] = 0;
           /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
           _outp (0x3d0,0);

           pDriverData->dwDmaPusherFreeCount = freeCount;

           npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

           while ((volatile)pDmaDmaToMemNotifier->status == NV_IN_PROGRESS) NV_SLEEP;

           if (pDmaDmaToMemNotifier->status == NV_STATUS_DONE_OK) {

               pDriverData->dDrawSpareSubchannelObject =
                   NV_DD_PIO_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               pDriverData->fNvActiveFloatingContexts |=
                   NV_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               pDriverData->NvFloating1YUYVSurfaceMem = psurf_gbl->fpVidMem;
           }
#endif  /* MULTI_MON */
       }
   }

   return DDHAL_DRIVER_HANDLED;
}



/*
 * Video scaler arbitration routines
 */


//
// Calculate the closest arbitration values for a given system configuration
//
// NOTE: Please excuse this code.  In comes from the hardware group...
//
VOID dacCalculateArbitration
(
           fifo_info *fifo,
           sim_state  *arb
)
{
  int data, pagemiss, cas,width, video_enable, color_key_enable, bpp, align;
  int nvclks, mclks, pclks, vpagemiss, crtpagemiss, vbs;
  int found, mclk_extra, mclk_loop, cbs, m1, p1;
  int mclk_freq, pclk_freq, nvclk_freq, mp_enable;
  int us_m, us_n, us_p, video_drain_rate, crtc_drain_rate;
  int vpm_us, us_video, vlwm, video_fill_us, cpm_us, us_crt,clwm;
  int craw, vraw;
  fifo->valid = 1;
  pclk_freq = arb->pclk_khz; // freq in KHz
  mclk_freq = arb->mclk_khz;
  nvclk_freq = arb->nvclk_khz;
  pagemiss = arb->mem_page_miss;
  cas = arb->mem_latency;
  width = arb->memory_width >> 6;
  video_enable = arb->enable_video;
  color_key_enable = arb->gr_during_vid;
  bpp = arb->pix_bpp;
  align = arb->mem_aligned;
  mp_enable = arb->enable_mp;
  clwm = 0;
  vlwm = 0;
  cbs = 128;
  pclks = 2; // lwm detect.

  nvclks = 2; // lwm -> sync.
  nvclks += 2; // fbi bus cycles (1 req + 1 busy)
  nvclks += 1; // fbi reqsync

  mclks = 5; // Fifo
  mclks += 3; // MA0 -> MA2
  mclks += 1; // pad->out
  mclks += cas; // Cas Latency.
  mclks += 1; // pad in
  mclks += 1; // latch data
  mclks += 1; // fifo load
  mclks += 1; // fifo write
  mclk_extra = 3; // Margin of error

  nvclks += 2; // fifo sync
  nvclks += 1; // read data
  nvclks += 1; // fbi_rdata
  nvclks += 1; // crtfifo load

  if(mp_enable)
    mclks+=4; // Mp can get in with a burst of 8.
  // Extra clocks determined by heuristics

  nvclks += 0;
  pclks += 0;
  found = 0;
  while(found != 1) {
    fifo->valid = 1;
    found = 1;
    mclk_loop = mclks+mclk_extra;
    us_m = mclk_loop *1000*1000 / mclk_freq; // Mclk latency in us
    us_n = nvclks*1000*1000 / nvclk_freq;// nvclk latency in us
    us_p = nvclks*1000*1000 / pclk_freq;// nvclk latency in us
    if(video_enable) {
      video_drain_rate = pclk_freq * 2; // MB/s
      crtc_drain_rate = pclk_freq * bpp/8; // MB/s

      vpagemiss = 2; // self generating page miss
      vpagemiss += 1; // One higher priority before

      crtpagemiss = 2; // self generating page miss

      vpm_us = (vpagemiss * pagemiss)*1000*1000/mclk_freq;


      if(nvclk_freq * 2 > mclk_freq * width) // nvclk is faster than mclk
    video_fill_us = cbs*1000*1000 / 16 / nvclk_freq ;
      else
    video_fill_us = cbs*1000*1000 / (8 * width) / mclk_freq;

      us_video = vpm_us + us_m + us_n + us_p + video_fill_us;

      vlwm = us_video * video_drain_rate/(1000*1000);
      vlwm++; // fixed point <= float_point - 1.  Fixes that
      vbs = 128;
      if(vlwm > 146) vbs = 64;

      if(nvclk_freq * 2 > mclk_freq * width) // nvclk is faster than mclk
    video_fill_us = vbs *1000*1000/ 16 / nvclk_freq ;
      else
    video_fill_us = vbs*1000*1000 / (8 * width) / mclk_freq;

      cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
      us_crt =
    us_video  // Wait for video
    +video_fill_us // Wait for video to fill up
    +cpm_us // CRT Page miss
    +us_m + us_n +us_p // other latency
    ;
      clwm = us_crt * crtc_drain_rate/(1000*1000);
      clwm++; // fixed point <= float_point - 1.  Fixes that
    } else {
      crtc_drain_rate = pclk_freq * bpp/8; // bpp * pclk/8

      crtpagemiss = 2; // self generating page miss
      crtpagemiss += 1; // MA0 page miss
      cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
      us_crt =  cpm_us + us_m + us_n + us_p ;
      clwm = us_crt * crtc_drain_rate/(1000*1000);
      clwm++; // fixed point <= float_point - 1.  Fixes that
    }
    /*
      Overfill check:

      */

    m1 = clwm + cbs - 512; /* Amount of overfill */
    p1 = m1 * pclk_freq / mclk_freq; /* pclk cycles to drain */
    p1 = p1 * bpp / 8; // bytes drained.

    if((p1 < m1) && (m1 > 0)) {
    fifo->valid = 0;
    found = 0;
    if(mclk_extra ==0)   found = 1; // Can't adjust anymore!
    mclk_extra--;
    }
    else if(video_enable){
      if((clwm > 511) || (vlwm > 255)) {
    fifo->valid = 0;
    found = 0;
    if(mclk_extra ==0)   found = 1; // Can't adjust anymore!
    mclk_extra--;
      }
    } else {
      if(clwm > 519){ // Have some margin
    fifo->valid = 0;
    found = 0;
    if(mclk_extra ==0)   found = 1; // Can't adjust anymore!
    mclk_extra--;
      }
    }
    craw = clwm;
    vraw = vlwm;
    if(clwm < 384) clwm = 384;
    if(vlwm < 128) vlwm = 128;
    data = (int)(clwm);
    //  printf("CRT LWM: %f bytes, prog: 0x%x, bs: 256\n", clwm, data );
    fifo->graphics_lwm = data;   fifo->graphics_burst_size = 128;
    //    fifo->craw = craw;

    data = (int)((vlwm+15));
    //  printf("VID LWM: %f bytes, prog: 0x%x, bs: %d\n, ", vlwm, data, vbs );
    fifo->video_lwm = data;  fifo->video_burst_size = vbs;
  }
}


#ifndef WINNT // For WINNT, this is a macro which checks the PDEV flag
              // to determine if overlay is supported in this mode.
/*
 * GetVideoScalerBandwidthStatus
 */
BOOL __stdcall GetVideoScalerBandwidthStatus32(unsigned long surfaceFlags)
{
    fifo_info fifo_data;
    sim_state sim_data;
    U032 M, N, O, P, crystal, NVclk, Mclk, Vclk;

    // Get the crystal (F in Hz)
#ifdef  MULTI_MON
    crystal = NvConfigGet(NV_CFG_CRYSTAL_FREQ, pDriverData->dwDeviceIDNum);
    Mclk = NvConfigGet(NV_CFG_DAC_MEMORY_CLOCK, pDriverData->dwDeviceIDNum);
    NVclk = NvConfigGet(NV_CFG_DAC_GRAPHICS_CLOCK, pDriverData->dwDeviceIDNum);
#else   /* MULTI_MON */
    crystal = NvConfigGet(NV_CFG_CRYSTAL_FREQ);
    Mclk = NvConfigGet(NV_CFG_DAC_MEMORY_CLOCK);
    NVclk = NvConfigGet(NV_CFG_DAC_GRAPHICS_CLOCK);
#endif  /* MULTI_MON */

    //
    // Recalculate the current PCLK setting.  We might have changed modes
    // recently.
    //

#ifdef  MULTI_MON
    M = NvConfigGet(NV_CFG_DAC_VPLL_M, pDriverData->dwDeviceIDNum);
    N = NvConfigGet(NV_CFG_DAC_VPLL_N, pDriverData->dwDeviceIDNum);
    O = 1;
    P = NvConfigGet(NV_CFG_DAC_VPLL_P, pDriverData->dwDeviceIDNum);

    Vclk = (N * crystal / (1 << P) / M);  // MHz

#else   /* MULTI_MON */
    M = NvConfigGet(NV_CFG_DAC_VPLL_M);
    N = NvConfigGet(NV_CFG_DAC_VPLL_N);
    O = 1;
    P = NvConfigGet(NV_CFG_DAC_VPLL_P);

    Vclk = (N * crystal / (1 << P) / M);  // MHz

#endif  /* MULTI_MON */

    //
    // Last minute kludge to work around the fact that new NV4 arbitration
    // algorithm NEVER rejects overlay requests.
    //

    if (((pDriverData->bi.biBitCount < 16) && (Vclk > 180000000)) ||
        ((pDriverData->bi.biBitCount == 16) && (Vclk > 130000000)) ||
        ((pDriverData->bi.biBitCount > 16) && (Vclk > 80000000)))
       return (FALSE);

    //
    // Build the sim table using current system settings
    //
    sim_data.pix_bpp        = (char)pDriverData->bi.biBitCount;
    sim_data.enable_video   = 1; // Video (monitor scan out) enabled
    sim_data.enable_mp      = (surfaceFlags & DDSCAPS_VIDEOPORT) ? 1 : 0;
#ifdef  MULTI_MON
    sim_data.memory_width   = NvConfigGet(NV_CFG_DAC_INPUT_WIDTH, pDriverData->dwDeviceIDNum);
#else   /* MULTI_MON */
    sim_data.memory_width   = NvConfigGet(NV_CFG_DAC_INPUT_WIDTH);
#endif  /* MULTI_MON */
    sim_data.mem_latency    = 3;
    sim_data.mem_aligned    = 1;
    sim_data.mem_page_miss  = 10;
    sim_data.gr_during_vid  = 1; // Color key enabled ??? (TONG says there is negligible bandwidth difference here)
    sim_data.pclk_khz       = Vclk / 1000;  // in kHz, not MHz
    sim_data.mclk_khz       = Mclk / 1000;  // in kHz, not MHz
    sim_data.nvclk_khz      = NVclk / 1000; // in kHz, not MHz
    //
    // Get those new numbers
    //
    dacCalculateArbitration(&fifo_data, &sim_data);

    //
    // If valid settings found, then video scaler can be used
    //
    if (fifo_data.valid)
        return(TRUE);
    else
        return(FALSE);
}
#endif // #ifndef WINNT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\disablec.c ===
/*
 ***************************************************************************
 *                                                                         *
 *  Copyright (C) 1995, 1998 NVidia Corporation.  All Rights Reserved.     *
 *                                                                         *
 ***************************************************************************
 */

/* NvDDDisable32() */

#include "windows.h"
#include <conio.h>
#include "nvd3ddrv.h"

#include "nv32.h"
#include "nvddobj.h"
#include "ddrvmem.h"
#include "d3dinc.h"

#ifdef  MULTI_MON
#include "nvrmapi.h"
#include "nvrmarch.inc"
#include "nvos.h"
#endif  /* MULTI_MON */

#ifdef NVHEAPMGR
#ifdef MULTI_MON
static NVIOControl_Param HeapParams;
#else   // !MULTI_MON
static struct
{
  U032 function;
  U032 device;
  U032 owner;
  U032 type;
  U032 depth;
  U032 width;
  U032 height;
  S032 pitch;
  U032 offset;
  U032 size;
  U032 address;
  U032 limit;
  U032 total;
  U032 free;
  V032 status;
} HeapParams;
#endif  // !MULTI_MON
#endif  // NVHEAPMGR


/*
 * NvDDDisable32()
 *
 */

int
NvDDDisable32()
{
   FAST Nv4ControlDma *npDev = (Nv4ControlDma *)pDriverData->NvDevFlatDma;
   Nv3ChannelPio *npDevVideo;
   long videoFreeCount;
   unsigned long *dmaPusherPutAddress =
       (unsigned long *)pDriverData->NvDmaPusherPutAddress;
   unsigned long *dmaPusherBufferBase =
       (unsigned long *)pDriverData->NvDmaPusherBufferBase;
   NvNotification *npDmaSyncNotifier =
       (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;
#ifdef  CACHE_FREECOUNT
   long freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
   long freeCount = 0;
#endif  /* CACHE_FREECOUNT */

   /*
    * Ensure the push buffer has completed prior to deleting objects
    * which it might reference.
    */

   while ((volatile)npDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification

   while (freeCount < 4)
       NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
   freeCount -= 4;

   npDmaSyncNotifier->status = NV_IN_PROGRESS;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
       RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
   dmaPusherPutAddress[1] = 0;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
       RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
   dmaPusherPutAddress[3] = 0;

   dmaPusherPutAddress += 4;

   /* Force write combine buffer to flush */
   pDriverData->NvDmaPusherBufferEnd[0] = 0;
   /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
   _outp (0x3d0,0);

   npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

   while ((volatile)npDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification

#ifndef MULTI_MON
   while (freeCount < 14)
       NvGetDmaBufferFreeCount(npDev, freeCount, 14, dmaPusherPutAddress);
   freeCount -= 14;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[1] = NV_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(0) + NVFFF_DESTROY_OFFSET | 0x40000;
   dmaPusherPutAddress[3] = NV_DD_DMA_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[4] = dDrawSubchannelOffset(0) + NVFFF_DESTROY_OFFSET | 0x40000;
   dmaPusherPutAddress[5] = NV_DD_DMA_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[6] = dDrawSubchannelOffset(0) + NVFFF_DESTROY_OFFSET | 0x40000;
   dmaPusherPutAddress[7] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[8] = dDrawSubchannelOffset(0) + NVFFF_DESTROY_OFFSET | 0x40000;
   dmaPusherPutAddress[9] = NV_DD_DMA_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[10] = dDrawSubchannelOffset(0) + NVFFF_DESTROY_OFFSET | 0x40000;
   dmaPusherPutAddress[11] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[12] = dDrawSubchannelOffset(0) + NVFFF_DESTROY_OFFSET | 0x40000;
   dmaPusherPutAddress[13] = NV_DD_DMA_CONTEXT_DMA_TO_SYSTEM_MEMORY;

   dmaPusherPutAddress += 14;

   while (freeCount < 12)
       NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
   freeCount -= 12;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(1) | 0x40000;
   dmaPusherPutAddress[1] = NV_CONTEXT_DMA_FROM_MEMORY;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(1) + NVFFF_DESTROY_OFFSET | 0x40000;
   dmaPusherPutAddress[3] = NV_DD_DMA_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[4] = dDrawSubchannelOffset(1) + NVFFF_DESTROY_OFFSET | 0x40000;
   dmaPusherPutAddress[5] = NV_DD_DMA_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[6] = dDrawSubchannelOffset(1) + NVFFF_DESTROY_OFFSET | 0x40000;
   dmaPusherPutAddress[7] = NV_DD_DMA_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[8] = dDrawSubchannelOffset(1) + NVFFF_DESTROY_OFFSET | 0x40000;
   dmaPusherPutAddress[9] = NV_DD_DMA_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[10] = dDrawSubchannelOffset(1) + NVFFF_DESTROY_OFFSET | 0x40000;
   dmaPusherPutAddress[11] = NV_DD_DMA_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

   dmaPusherPutAddress += 12;

   while (freeCount < 4)
       NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
   freeCount -= 4;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(1) | 0x40000;
   dmaPusherPutAddress[1] = NV_CONTEXT_DMA_IN_MEMORY;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(1) + NVFFF_DESTROY_OFFSET | 0x40000;
   dmaPusherPutAddress[3] = NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY;

   dmaPusherPutAddress += 4;

#endif  /* MULTI_MON */

   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_VIDEO_MEMORY_TO_SYSTEM_MEMORY_FORMAT) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_CONTEXT_ROP) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_CONTEXT_PATTERN) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_IMAGE_BLACK_RECTANGLE) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_CONTEXT_COLOR_KEY) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_BETA_SOLID) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_CONTEXT_BETA4) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_ROP_GDI_RECT_AND_TEXT) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_ABLEND_RECT_AND_TEXT) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_IMAGE_FROM_CPU) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_ALT_IMAGE_FROM_CPU) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_SRCCOPY_IMAGE_FROM_CPU) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_ABLEND_NOSRCALPHA_IMAGE_FROM_CPU) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_ABLEND_IMAGE_FROM_CPU) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_STRETCHED_UV_IMAGE_FROM_CPU) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_STRETCHED_IMAGE_FROM_CPU) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_SRCCOPY_STRETCHED_IMAGE_FROM_CPU) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_ABLEND_NOSRCALPHA_STRETCHED_IMAGE_FROM_CPU) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_ABLEND_STRETCHED_IMAGE_FROM_CPU) != NVOS00_STATUS_SUCCESS)
            return(0);

   if (pDriverData->bi.biBitCount > 8) {
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
                return(0);
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY) != NVOS00_STATUS_SUCCESS)
                return(0);
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
                return(0);
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY) != NVOS00_STATUS_SUCCESS)
                return(0);
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
                return(0);
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY) != NVOS00_STATUS_SUCCESS)
                return(0);
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
                return(0);
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
                return(0);
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
                return(0);
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
                return(0);

       if (pDriverData->bi.biBitCount > 16) {

        if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
                NV_DD_SRCCOPY_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
                    return(0);
        if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
                NV_DD_ABLEND_NOSRCALPHA_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
                    return(0);
        if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
                NV_DD_ABLEND_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
                    return(0);
        if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
                NV_DD_SRCCOPY_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY) != NVOS00_STATUS_SUCCESS)
                    return(0);
        if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
                NV_DD_ABLEND_NOSRCALPHA_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY) != NVOS00_STATUS_SUCCESS)
                    return(0);
        if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
                NV_DD_ABLEND_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY) != NVOS00_STATUS_SUCCESS)
                    return(0);
       }
   }
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
           NV_DD_IMAGE_BLIT) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
           NV_DD_SRCCOPY_IMAGE_BLIT) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
           NV_DD_SURFACES_2D) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
           NV_DD_PRIMARY_VIDEO_FROM_MEMORY) != NVOS00_STATUS_SUCCESS)
               return(0);

   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
           NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY) != NVOS00_STATUS_SUCCESS)
               return(0);

   if (pDriverData->bi.biBitCount == 8) {
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_P_V_SHARED_VIDEO_COLORMAP) != NVOS00_STATUS_SUCCESS)
            return(0);
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_SHARED_VIDEO_COLORMAP) != NVOS00_STATUS_SUCCESS)
            return(0);
   }

   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
           NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT) != NVOS00_STATUS_SUCCESS)
               return(0);

   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
           NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
           NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
           NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
           NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
           NV_DD_VIDEO_MEMORY_U_TO_VIDEO_MEMORY_FORMAT) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
           NV_DD_VIDEO_MEMORY_V_TO_VIDEO_MEMORY_FORMAT) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
           NV_DD_VIDEO_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT) != NVOS00_STATUS_SUCCESS)
               return(0);

   pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

   /* Force write combine buffer to flush */
   pDriverData->NvDmaPusherBufferEnd[0] = 0;
   /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
   _outp (0x3d0,0);

   pDriverData->dwDmaPusherFreeCount = freeCount;

   npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

   /* Wait for destruction to complete */
   while (npDev->Get != (unsigned long)((dmaPusherPutAddress - dmaPusherBufferBase) << 2));

   /* Destroy the D3D objects */
   nvD3DDestroyObjects();

   /*
    * Now destroy objects in video channel
    */

   npDevVideo = (Nv3ChannelPio *)pDriverData->NvDevVideoFlatPio;

   videoFreeCount = pDriverData->NvVideoFreeCount;

#ifndef MULTI_MON
   while (videoFreeCount < 24)
       videoFreeCount = NvGetFreeCount(npDevVideo, 0);
   videoFreeCount -= 24;

   npDevVideo->subchannel[0].SetObject = NV_CONTEXT_DMA_TO_MEMORY;
   npDevVideo->subchannel[0].nvClass.Destroy = NV_DD_PIO_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   npDevVideo->subchannel[0].nvClass.Destroy = NV_DD_PIO_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

   npDevVideo->subchannel[1].SetObject = NV_CONTEXT_DMA_FROM_MEMORY;
   npDevVideo->subchannel[1].nvClass.Destroy = NV_DD_PIO_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   npDevVideo->subchannel[1].nvClass.Destroy = NV_DD_PIO_CONTEXT_DMA_FROM_VIDEO_MEMORY;
#endif  /* MULTI_MON */

   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
           NV_DD_PRIMARY_VIDEO_FROM_MEMORY) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
           NV_DD_YUV422_VIDEO_FROM_MEMORY) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
           NV_DD_VIDEO_SINK) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
           NV_DD_VIDEO_COLOR_KEY) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
           NV_DD_VIDEO_SCALER) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
           NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
           NV_DD_P_V_YUV422_VIDEO_FROM_MEMORY) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
           NV_DD_P_V_VIDEO_SCALER) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
           NV_DD_P_V_VIDEO_COLOR_KEY) != NVOS00_STATUS_SUCCESS)
               return(0);

#ifdef WINNT
   /*
    * Destroy NV4 DVD subpicture object in both DMA Push and PIO
    * channels. Don't know why the destruction of these objects was
    * not in the common code.
    */
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_DVD_SUBPICTURE) != NVOS00_STATUS_SUCCESS)
        return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
    NV_DD_DVD_SUBPICTURE) != NVOS00_STATUS_SUCCESS)
        return(0);
#endif // WINNT

   if (pDriverData->bi.biBitCount == 8) {
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
            NV_DD_P_V_SHARED_VIDEO_COLORMAP) != NVOS00_STATUS_SUCCESS)
                    return(0);
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
            NV_DD_SHARED_VIDEO_COLORMAP) != NVOS00_STATUS_SUCCESS)
                    return(0);
   }

   pDriverData->NvVideoFreeCount = (unsigned short)videoFreeCount;

   return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4comp.c ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4COMP.C                                                         *
*   NV4 Triangle Inner Loop Compiler                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 08/27/98 - Created                      *
*                                                                           *
\***************************************************************************/
#include <math.h>
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv3ddbg.h"
#include "nv4vxmac.h"

#ifdef NV_FASTLOOPS

#ifdef NV_DUMPLOOPS
#include <stdio.h>
#endif

#include "..\x86\x86.h"

/*
 * switches
 */
//#define PRINT_NAME              // force inner loop name at creation (even for retail builds)
//#define CHECK_VALID_PUSHER      // int3 when edi goes below zero (which indicates a push error)
//#define PIX1

/*
 * constants
 */
#define LUIFLAG_FOGMODE         0x00000003
#define LUIFLAG_STRIDES         0x0000000c
#define LUIFLAG_INDEXED         0x00000010
#define LUIFLAG_FVF             0x00000020
#define LUIFLAG_DX6             0x00000040
#define LUIFLAG_FIXEDWBUF       0x00000080 // ff = 256 inner loops
#ifdef NV_CONTROLTRAFFIC
#define LUIFLAG_ZFRONT          0x00000100
#define LUIFLAG_ZBACK           0x00000200 // 3ff = 1024 inner loops
#endif //NV_CONTROLTRAFFIC

#define LUIFLAG_BASIC           0x00000000
#define LUIFLAG_MMX             0x00010000
#define LUIFLAG_KATMAI          0x00020000
#define LUIFLAG_AMD             0x00040000

#define LUIMASK_BRANCH          0x0000ffff

#ifdef PIX1
#define VC_DX5_AND              7
#define VC_DX5_ADD              3
#define VC_DX6_AND              3
#define VC_DX6_ADD              1
#else
#define VC_DX5_AND              15
#define VC_DX5_ADD              7
#define VC_DX6_AND              7
#define VC_DX6_ADD              3
#endif

/*
 * types
 */
typedef (__stdcall *PFNINNERLOOP)(void);

/*
 * structures
 */

/*
 * macros
 */
#define ilcData         global.dwILCData
#define ilcCount        global.dwILCCount
#define ilcMax          global.dwILCMax

/*
 * short-lived globals
 */
DWORD  ilcFlags;

/*
 * prototypes
 */
DWORD ILCCompileCode (DWORD);

/*
 * helper debug code
 */
#ifdef DEBUG
void __stdcall nvDebugFlush (DWORD dwType)
{
    dbgFlushType(pCurrentContext,dwType);
}
void __stdcall nvDebugShowVertex (DWORD *pdwAddr)
{
    dbgDisplayVertexData (pdwAddr[1],pdwAddr[2],pdwAddr[3],pdwAddr[4],
                          pdwAddr[5],pdwAddr[6],pdwAddr[7],pdwAddr[8]);
}
#endif // DEBUG

#ifdef NV_PROFILE
DWORD nvpTriCount;
DWORD nvpTriToGo;
float nvpTriArea;

void nvProfileLog (void)
{
    if (nvpTriCount > 40)
    {
        /*
         * flush HW
         */
        NV_D3D_GLOBAL_SAVE();
        nvFlushDmaBuffers();
        NV_D3D_GLOBAL_SETUP();

        /*
         * stop stopwatch
         */
        NVP_STOP (NVP_C_PIXPERSEC);

        /*
         * log update event
         */
        nvpLogEvent (NVP_E_TRIDISP);

        /*
         * log count
         */
        if (nvpTriCount)
        {
            nvpLogCount (NVP_C_TRICOUNT,nvpTriCount);
        }

        /*
         * log average area
         */
        nvpTriArea *= 0.5f;
        if (nvpTriCount)
        {
            nvpLogCount (NVP_C_TRIAREA,(DWORD)(nvpTriArea / (float)nvpTriCount));
        }

        /*
         * log tri per second
         */
        if (nvpTriCount) {
            double a;

            a  = 1.0e6 * (double)global.dwProcessorSpeed / (double)nvpTime[NVP_C_PIXPERSEC];
            a *= (double)nvpTriArea;
            nvpLogCount (NVP_C_PIXPERSEC,(DWORD)a);
        }
    }

    /*
     * start next
     */
    nvpTriArea  = 0.0f;
    nvpTriCount = 0;
    nvpTriToGo  = nvpTriPerSecWindow;
    NVP_START (NVP_C_PIXPERSEC);
}

void __stdcall nvProfileArea (float fArea)
{
    /*
     * total area
     */
    global.fTriangleArea += fArea;

    /*
     * pix per sec
     */
    if (nvpEnableBits & (1 << NVP_C_PIXPERSEC))
    {
        /*
         * add up area
         */
        nvpTriCount ++;
        nvpTriArea  += fArea;

        /*
         * time yet
         */
        if (!(--nvpTriToGo))
        {
            nvProfileLog();
        }
    }
}
#endif //NV_PROFILE

/****************************************************************************
 * inner loop generator helpers                                             *
 ****************************************************************************/

#ifdef DEBUG
/*
 * ILCExecute_dbgFlushTriangle
 *
 * vertex data helper
 */
void __stdcall ILCExecute_dbgFlushTriangle
(
    void
)
{
    dbgFlushTriangle (pCurrentContext);
}

/*
 * ILCCompile_dbgFlushTriangle
 *
 * flushes the triangle whe the right bits are set
 */
void ILCCompile_dbgFlushTriangle
(
    void
)
{
    xMOV_i32_r  ((DWORD)&nvFifo,rESI)
    xMOV_i32_r  ((DWORD)&nvFreeCount,rEDI)
    xPUSHAD
    xMOV_rm_imm (rmREG(rEBX),ILCExecute_dbgFlushTriangle)
    xCALL_rm    (rmREG(rEBX))
    xPOPAD
    xMOV_r_i32  (rESI,(DWORD)&nvFifo)
    xMOV_r_i32  (rEDI,(DWORD)&nvFreeCount)
}

/*
 * ILCExecute_dbgDisplayVertexData
 *
 * vertex data helper
 */
void __stdcall ILCExecute_dbgDisplayVertexData
(
    DWORD* p
)
{
    dbgDisplayVertexData (p[0],p[1],p[2],p[3],p[4],p[5],p[6],p[7]);
}

/*
 * ILCCompile_dbgDisplayVertexData
 *
 * Shows vertex data when right bits are set
 */
void ILCCompile_dbgDisplayVertexData
(
    DWORD disp
)
{
    xPUSHAD
    xSUB_rm_imm8 (rmREG(rESI),disp*4 - 4)
    xPUSH_r      (rESI)
    xMOV_rm_imm  (rmREG(rEBX),ILCExecute_dbgDisplayVertexData)
    xCALL_rm     (rmREG(rEBX))
    xPOPAD
}

#endif //DEBUG

/*
 * ILCCompile_mulvertexstride
 *
 * reg = reg * fvfData.dwVertexStride
 */
__inline void ILCCompile_mulvertexstride
(
    DWORD reg
)
{
    if (ilcFlags & LUIFLAG_FVF)
    {
        xIMUL_r_i32 (reg,(DWORD)&fvfData.dwVertexStride);
    }
    else
    {
        xSHL_rm_imm (rmREG(reg),5)
    }
}

/*
 * ILCCompile_reserve
 *
 * check and wait for enough space in fifo
 */
void ILCCompile_reserve
(
    DWORD dwCount
)
{
    DWORD label1;
    DWORD label2;

#ifdef CHECK_VALID_PUSHER
    {
        DWORD l;
        xTEST_rm_imm (rmREG(rEDI),0x80000000)
        l = ilcCount;
        xJZ          (0)
        xINT3
        *(BYTE*)(ilcData + l + 1) = (BYTE)(ilcCount - (l + 2));
    }
#endif

    xCMP_rm_imm  (rmREG(rEDI),dwCount)
    label1 = ilcCount;
    xJA          (0)
    xMOV_i32_r   ((DWORD)&nvFifo,rESI)
    xMOV_i32_r   ((DWORD)&nvFreeCount,rEDI)
    xMOV_rm_imm  (rmREG(rEBX),(DWORD)nvGetDmaFreeCount)
    label2 = ilcCount;
    xPUSH_imm    (dwCount)
    xCALL_rm     (rmREG(rEBX))
    xCMP_rm_imm  (rmREG(rEAX),dwCount)
    xJL          (label2)
    xMOV_r_rm    (rEDI,rmREG(rEAX))
    xMOV_r_i32   (rESI,(DWORD)&nvFifo)

#ifdef CHECK_VALID_PUSHER
    {
        DWORD l;
        xTEST_rm_imm (rmREG(rEDI),0x80000000)
        l = ilcCount;
        xJZ          (0)
        xINT3
        *(BYTE*)(ilcData + l + 1) = (BYTE)(ilcCount - (l + 2));
    }
#endif

    *(BYTE*)(ilcData + label1 + 1) = (BYTE)(ilcCount - (label1 + 2));
}

/*
 * ILCCompile_cullcheck
 *
 * do a cull check on the triangle loaded in dwVertex0..2
 * code ends with the z flag set to indicate culled (do not draw)
 *
 * for dx5 this routine will also attempt to minimize specular
 */
__inline void ILCCompile_cullcheck
(
    void
)
{
    /*
     * specular check
     */
    if (!(ilcFlags & LUIFLAG_DX6))
    {
        DWORD label0;
        DWORD label1;
        DWORD label2;
        DWORD label3;
        DWORD label4;

        /*
         * check for specular enable
         */
        xMOV_r_i32 (rEAX,(DWORD)&global.dwSpecularState)
        xTEST_rm_r (rmREG(rEAX),rEAX)
        label0 = ilcCount;
        xJZ32      (0)

        /*
         * fetch specular into ebx,ecx and edx
         */
        xMOV_r_i32 (rEBX,(DWORD)&global.dwVertex0)
        xMOV_r_i32 (rECX,(DWORD)&global.dwVertex1)
        xMOV_r_i32 (rEDX,(DWORD)&global.dwVertex2)
        if (ilcFlags & LUIFLAG_FVF)
        {
            xMOV_r_i32 (rEAX,(DWORD)&fvfData.dwSpecularMask)
            xMOV_r_i32 (rEBP,(DWORD)&fvfData.dwSpecularOffset)

            xAND_r_rm  (rEBX,rmREG(rEAX))
                xAND_r_rm  (rECX,rmREG(rEAX))
                    xAND_r_rm  (rEDX,rmREG(rEAX))

            xADD_r_rm  (rEBX,rmREG(rEBP))
                xADD_r_rm  (rECX,rmREG(rEBP))
                    xADD_r_rm  (rEDX,rmREG(rEBP))
        }
        else
        {
            xMOV_r_rm (rEBX,rmIND8(rEBX)) xOFS8 (20) // spec
            xMOV_r_rm (rECX,rmIND8(rECX)) xOFS8 (20) // spec
            xMOV_r_rm (rEDX,rmIND8(rEDX)) xOFS8 (20) // spec
        }
        /*
         * combine and check if tri needs specular
         */
        xOR_r_rm     (rEBX,rmREG(rECX))
        xOR_r_rm     (rEBX,rmREG(rEDX))
        xTEST_rm_imm (rmREG(rEBX),0x00fcfcfc)
        label1 = ilcCount;
        xJZ32        (0)
        /*
         * check if we have to change the state
         */
        xMOV_r_i32  (rEAX,(DWORD)&global.dwSpecCurr)
        xTEST_rm_r  (rmREG(rEAX),rEAX)
        label2 = ilcCount;
        xJNZ32      (0)
        /*
         * enable
         *  eax is zero when we get here
         */
        xMOV_i32_r  ((DWORD)&global.dwSpecCount,rEAX)

        xINC_rm     (rmREG(rEAX))
        xMOV_i32_r  ((DWORD)&global.dwSpecCurr,rEAX)

        xMOV_r_i32  (rEAX,(DWORD)&global.dwBlend)
        xOR_rm_imm  (rmREG(rEAX),DRF_DEF(054,_BLEND,_SPECULARENABLE,_TRUE))

        label3 = ilcCount;
        xJMP        (0)
        /*
         * disable
         */
        *(DWORD*)(ilcData + label1 + 2) = (ilcCount - (label1 + 6));

        xMOV_r_i32   (rEAX,(DWORD)&global.dwSpecCount)
        xINC_rm      (rmREG(rEAX))
        xMOV_i32_r   ((DWORD)&global.dwSpecCount,rEAX)
        xCMP_rm_imm  (rmREG(rEAX),5)
        label4 = ilcCount;
        xJNZ32       (0)

        xXOR_r_rm   (rEAX,rmREG(rEAX))
        xMOV_i32_r  ((DWORD)&global.dwSpecCurr,rEAX)

        xMOV_r_i32  (rEAX,(DWORD)&global.dwBlend)
        xAND_rm_imm (rmREG(rEAX),0xffff0fff)

        *(DWORD*)(ilcData + label3 + 1) = ilcCount - (label3 + 5);

        xPUSH_r      (rEAX)
        ILCCompile_reserve (2);
        xMOV_rm_imm  (rmREG(rEBX),((1<<2)<<16) | (NV_DD_SPARE<<13) | NV054_BLEND)
        xPOP_r       (rEAX)
        xMOV_rm_r    (rmIND(rESI),rEBX)
        xMOV_rm_r    (rmIND8(rESI),rEAX) xOFS8(4)
        xADD_rm_imm8 (rmREG(rESI),2*4)
        xSUB_rm_imm8 (rmREG(rEDI),2)

        /*
         * done
         */
        *(DWORD*)(ilcData + label0 + 2) = (ilcCount - (label0 + 6));
        *(DWORD*)(ilcData + label2 + 2) = (ilcCount - (label2 + 6));
        *(DWORD*)(ilcData + label4 + 2) = (ilcCount - (label4 + 6));
    }

    /*
     * cull
     */
    xMOV_r_i32 (rEAX,(DWORD)&global.dwVertex0)
    xFLD_rm32  (rmIND(rEAX))
    xMOV_r_i32 (rEBX,(DWORD)&global.dwVertex1)
    xFLD_rm32  (rmIND(rEBX))
    xFXCH_st   (rST1)
    xFSUBP_st  (rST1)
    xMOV_r_i32 (rECX,(DWORD)&global.dwVertex2)
    xFLD_rm32  (rmIND8(rECX)) xOFS8(4)
    xFXCH_st   (rST1)
    xFLD_rm32  (rmIND8(rEAX)) xOFS8(4)
    xFXCH_st   (rST1)
    xFLD_rm32  (rmIND(rECX))
    xFXCH_st   (rST3)
    xFLD_rm32  (rmIND(rEAX))
    xFXCH_st   (rST3)
    xFSUBP_st  (rST1)
    xFXCH_st   (rST3)
    xFLD_rm32  (rmIND8(rEBX)) xOFS8(4)
    xFXCH_st   (rST3)
    xFSUBP_st  (rST1)
    xFXCH_st   (rST3)
    xFLD_rm32  (rmIND8(rEAX)) xOFS8(4)
    xFXCH_st   (rST2)
    xFMULP_st  (rST1)
    xFXCH_st   (rST1)
    xFSUBP_st  (rST2)
    xFXCH_st   (rST2)
    xFMULP_st  (rST1)
    xFSUBP_st  (rST1)
    xFSTP_i32  ((DWORD)&global.dwTemp)
    xMOV_r_i32 (rEAX,(DWORD)&global.dwTemp)
    xXOR_r_i32 (rEAX,(DWORD)&global.dwCullMask1)
    xTEST_r_i32(rEAX,(DWORD)&global.dwCullMask2)
}

/*
 * ILCCompile_move
 *
 * moves memory from src to dest
 *  use best algorithm depoending on architecture
 *  will thrash eax,ebp,ebx,edx,ecx and mmx/xmmx
 *
 */
void ILCCompile_move
(
    DWORD dwDst,        // NULL means to ebx
    DWORD dwSrc,        // NULL means from edx
    DWORD dwCount       // 0 means ecx has the number of bytes
)
{
    BOOL  isKNI = ilcFlags & LUIFLAG_KATMAI;
    BOOL  isMMX = ilcFlags & LUIFLAG_MMX;
    BOOL  isS16 = dwSrc && !(dwSrc & 15); // true when source is guaranteed 16 byte aligned
    BOOL  isD16 = dwDst && !(dwDst & 15); // true when dest is guaranteed 16 byte aligned
    DWORD dwMax = isKNI ? (4*16) : (isMMX ? (4*8) : (4*2)); // cannot be > 128
    DWORD label1,label2;
    BOOL  mmx = FALSE;

    /*
     * load src and dest
     */
    if (dwSrc)
    {
        xMOV_rm_imm (rmREG(rEDX),dwSrc)
    }
    if (dwDst)
    {
        xMOV_rm_imm (rmREG(rEBX),dwDst)
    }

    /*
     * constant count
     */
    if ((dwCount) && (dwCount <= dwMax))
    {
        DWORD ofs = 0;
        if (isKNI)
        {
            DWORD count = dwCount >> 4;
            DWORD index;
            for (index = 0; index < count; index++)
            {
                if (isS16) { xMOVAPS_r_rm (index,rmIND8(rEDX)) xOFS8(ofs+index*16) }
                      else { xMOVLPS_r_rm (index,rmIND8(rEDX)) xOFS8(ofs+index*16) xMOVHPS_r_rm (index,rmIND8(rEDX)) xOFS8(ofs+index*16+8) }
            }
            for (index = 0; index < count; index++)
            {
                if (isD16) { xMOVAPS_rm_r (rmIND8(rEBX),index) xOFS8(ofs+index*16) }
                      else { xMOVLPS_rm_r (rmIND8(rEBX),index) xOFS8(ofs+index*16) xMOVHPS_rm_r (rmIND8(rEBX),index) xOFS8(ofs+index*16+8) }
            }
            dwCount -= count * 16;
            ofs     += count * 16;
        }
        if (isMMX)
        {
            DWORD count = dwCount >> 3;
            DWORD index;
            for (index = 0; index < count; index++)
            {
                xMOVQ_r_rm (index,rmIND8(rEDX)) xOFS8(ofs+index*8)
            }
            for (index = 0; index < count; index++)
            {
                xMOVQ_rm_r (rmIND8(rEBX),index) xOFS8(ofs+index*8)
                mmx = 1;
            }
            dwCount -= count * 8;
            ofs     += count * 8;
        }
        {
            while (dwCount >= 8)
            {
                xMOV_r_rm (rEAX,rmIND8(rEDX)) xOFS8(ofs+0)
                xMOV_r_rm (rECX,rmIND8(rEDX)) xOFS8(ofs+4)
                xMOV_rm_r (rmIND8(rEBX),rEAX) xOFS8(ofs+0)
                xMOV_rm_r (rmIND8(rEBX),rECX) xOFS8(ofs+4)
                dwCount -= 8;
                ofs     += 8;
            }
            while (dwCount >= 4)
            {
                xMOV_r_rm (rEAX,rmIND8(rEDX)) xOFS8(ofs)
                xMOV_rm_r (rmIND8(rEBX),rEAX) xOFS8(ofs)
                dwCount -= 4;
                ofs     += 4;
            }
            while (dwCount)
            {
                xMOV_r_rm8 (rAL,rmIND8(rEDX)) xOFS8(ofs)
                xMOV_rm8_r (rmIND8(rEBX),rAL) xOFS8(ofs)
                dwCount -= 1;
                ofs     += 1;
            }
        }

        if (mmx) { xEMMS }

        return;
    }

    /*
     * variable count - or long constant
     */
    if (dwCount)
    {
        xMOV_rm_imm (rmREG(rECX),dwCount)
    }
    else
    {
        dwCount = 0x7fffffff; // force all code paths
    }

    /*
     * 64 byte chunks
     */
    if (isKNI && (dwCount >= 64))
    {
        label2 = ilcCount;
        xCMP_rm_imm  (rmREG(rECX),64)
        label1 = ilcCount;
        xJL          (0)
        if (isS16)
        {
            xMOVAPS_r_rm (rXMM0,rmIND(rEDX))
            xMOVAPS_r_rm (rXMM1,rmIND8(rEDX)) xOFS8 (0x10)
            xMOVAPS_r_rm (rXMM2,rmIND8(rEDX)) xOFS8 (0x20)
            xMOVAPS_r_rm (rXMM3,rmIND8(rEDX)) xOFS8 (0x30)
        }
        else
        {
            xMOVLPS_r_rm (rXMM0,rmIND(rEDX))
            xMOVHPS_r_rm (rXMM0,rmIND8(rEDX)) xOFS8 (0x08)
            xMOVLPS_r_rm (rXMM1,rmIND8(rEDX)) xOFS8 (0x10)
            xMOVHPS_r_rm (rXMM1,rmIND8(rEDX)) xOFS8 (0x18)
            xMOVLPS_r_rm (rXMM2,rmIND8(rEDX)) xOFS8 (0x20)
            xMOVHPS_r_rm (rXMM2,rmIND8(rEDX)) xOFS8 (0x28)
            xMOVLPS_r_rm (rXMM3,rmIND8(rEDX)) xOFS8 (0x30)
            xMOVHPS_r_rm (rXMM3,rmIND8(rEDX)) xOFS8 (0x38)
        }
        if (isD16)
        {
            xMOVAPS_rm_r (rmIND(rEBX),rXMM0)
            xMOVAPS_rm_r (rmIND8(rEBX),rXMM1) xOFS8 (0x10)
            xMOVAPS_rm_r (rmIND8(rEBX),rXMM2) xOFS8 (0x20)
            xMOVAPS_rm_r (rmIND8(rEBX),rXMM3) xOFS8 (0x30)
        }
        else
        {
            xMOVLPS_rm_r (rmIND(rEBX),rXMM0)
            xMOVHPS_rm_r (rmIND8(rEBX),rXMM0) xOFS8 (0x08)
            xMOVLPS_rm_r (rmIND8(rEBX),rXMM1) xOFS8 (0x10)
            xMOVHPS_rm_r (rmIND8(rEBX),rXMM1) xOFS8 (0x18)
            xMOVLPS_rm_r (rmIND8(rEBX),rXMM2) xOFS8 (0x20)
            xMOVHPS_rm_r (rmIND8(rEBX),rXMM2) xOFS8 (0x28)
            xMOVLPS_rm_r (rmIND8(rEBX),rXMM3) xOFS8 (0x30)
            xMOVHPS_rm_r (rmIND8(rEBX),rXMM3) xOFS8 (0x38)
        }
        xADD_rm_imm8 (rmREG(rEBX),64)
        xADD_rm_imm8 (rmREG(rEDX),64)
        xSUB_rm_imm8 (rmREG(rECX),64)
        xJNZ         (label2)
        *(BYTE*)(ilcData + label1 + 1) = (BYTE)(ilcCount - (label1 + 2));

        dwCount &= ~63;
    }

    /*
     * 16-byte chunks
     */
    if (dwCount >= 16) {
        label2 = ilcCount;
        xCMP_rm_imm  (rmREG(rECX),16)
        label1 = ilcCount;
        xJL          (0)
        if (isKNI)
        {
            if (isS16) { xMOVAPS_r_rm (rXMM0,rmIND(rEDX)) }
                  else { xMOVLPS_r_rm (rXMM0,rmIND(rEDX)) xMOVHPS_r_rm (rXMM0,rmIND8(rEDX)) xOFS8 (8) }
            if (isD16) { xMOVAPS_rm_r (rmIND(rEBX),rXMM0) }
                  else { xMOVLPS_rm_r (rmIND(rEBX),rXMM0) xMOVHPS_rm_r (rmIND8(rEBX),rXMM0) xOFS8 (8) }
        } else if (isMMX)
        {
            xMOVQ_r_rm (rMM0,rmIND(rEDX))
            xMOVQ_r_rm (rMM1,rmIND8(rEDX)) xOFS8(8)
            xMOVQ_rm_r (rmIND(rEBX),rMM0)
            xMOVQ_rm_r (rmIND8(rEBX),rMM1) xOFS8(8)
            mmx = 1;
        } else
        {
            xMOV_r_rm (rEAX,rmIND(rEDX))
            xMOV_r_rm (rEBP,rmIND8(rEDX)) xOFS8(4)
            xMOV_rm_r (rmIND(rEBX),rEAX)
            xMOV_rm_r (rmIND8(rEBX),rEBP) xOFS8(4)
            xMOV_r_rm (rEAX,rmIND8(rEDX)) xOFS8(8)
            xMOV_r_rm (rEBP,rmIND8(rEDX)) xOFS8(12)
            xMOV_rm_r (rmIND8(rEBX),rEAX) xOFS8(8)
            xMOV_rm_r (rmIND8(rEBX),rEBP) xOFS8(12)
        }
        xADD_rm_imm8 (rmREG(rEBX),16)
        xADD_rm_imm8 (rmREG(rEDX),16)
        xSUB_rm_imm8 (rmREG(rECX),16)
        xJNZ         (label2)
        *(BYTE*)(ilcData + label1 + 1) = (BYTE)(ilcCount - (label1 + 2));

        dwCount &= ~15;
    }

    /*
     * 4-bytes
     */
    if (dwCount >= 4) {
        label2 = ilcCount;
        xCMP_rm_imm  (rmREG(rECX),4)
        label1 = ilcCount;
        xJL          (0)
        xMOV_r_rm (rEAX,rmIND(rEDX))
        xADD_rm_imm8 (rmREG(rEDX),4)
        xMOV_rm_r (rmIND(rEBX),rEAX)
        xADD_rm_imm8 (rmREG(rEBX),4)
        xSUB_rm_imm8 (rmREG(rECX),4)
        xJNZ         (label2)
        *(BYTE*)(ilcData + label1 + 1) = (BYTE)(ilcCount - (label1 + 2));

        dwCount &= ~3;
    }

    /*
     * 1-bytes
     */
    if (dwCount) {
        xTEST_rm_r   (rmREG(rECX),rECX)
        label1 = ilcCount;
        xJZ          (0)
        label2 = ilcCount;
        xMOV_r_rm8   (rAL,rmIND(rEDX))
        xINC_rm      (rmREG(rEDX))
        xMOV_rm8_r   (rmIND(rEBX),rAL)
        xINC_rm      (rmREG(rEBX))
        xDEC_rm      (rmREG(rECX))
        xJNZ         (label2)
        *(BYTE*)(ilcData + label1 + 1) = (BYTE)(ilcCount - (label1 + 2));
    }

    if (mmx) { xEMMS }
}

/*
 * ILCCompile_vertex
 *
 * send vertex to hardware
 *  edx = vertex start addr
 *  ebx = hw vertex position
 */
void ILCCompile_vertex
(
    DWORD dwPosition //= 0xffffffff for register ebx
)
{
    DWORD dwHWSize = (ilcFlags & LUIFLAG_DX6) ? 11 : 9;

    /*
     * select vertex type
     */
    if (dwPosition != 0xffffffff)
    {
        xMOV_rm_imm (rmREG(rEBX),((ilcFlags & LUIFLAG_DX6)
                                 ?(0x0028e400 | dwPosition*40)
                                 :(0x0020e400 | dwPosition*32)))
    }
    else
    {
        if (ilcFlags & LUIFLAG_DX6)
        {
            xLEA_r_rm   (rEBX,rmSIB) xSIB(rEBX,rEBX,x4)
            xSHL_rm_imm (rmREG(rEBX),3)
            xOR_rm_imm  (rmREG(rEBX),0x0028e400) // dx6 class specific
        }
        else
        {
            xSHL_rm_imm (rmREG(rEBX),5)
            xOR_rm_imm  (rmREG(rEBX),0x0020e400) // dx5 class specific
        }
    }

    /*
     * individual vertex overrides
     *  non-pipelined code for special cases (i.e need no gathering)
     *  ebx still has vertex type
     */
#ifdef NV_CONTROLTRAFFIC
    if (!(ilcFlags & (LUIFLAG_DX6 | LUIFLAG_FOGMODE | LUIFLAG_FVF | LUIFLAG_FIXEDWBUF | LUIFLAG_ZFRONT | LUIFLAG_ZBACK)))
#else
    if (!(ilcFlags & (LUIFLAG_DX6 | LUIFLAG_FOGMODE | LUIFLAG_FVF | LUIFLAG_FIXEDWBUF)))
#endif
    {
        /*
         * DX5 TL vertex
         */
        if (ilcFlags & LUIFLAG_KATMAI) // katmai version
        {
            xMOV_rm_r  (rmIND(rESI),rEBX)
            xMOVLPS_r_rm (rXMM0,rmIND(rEDX))
            xMOVHPS_r_rm (rXMM0,rmIND8(rEDX)) xOFS8(8)
            xMOVLPS_r_rm (rXMM1,rmIND8(rEDX)) xOFS8(16)
            xMOVHPS_r_rm (rXMM1,rmIND8(rEDX)) xOFS8(24)
            xMOVLPS_rm_r (rmIND8(rESI),rXMM0) xOFS8(4)
            xMOVHPS_rm_r (rmIND8(rESI),rXMM0) xOFS8(12)
            xMOVLPS_rm_r (rmIND8(rESI),rXMM1) xOFS8(20)
            xMOVHPS_rm_r (rmIND8(rESI),rXMM1) xOFS8(28)
            xADD_rm_imm8 (rmREG(rESI),9*4)
            xSUB_rm_imm8 (rmREG(rEDI),9)
        }
        else if (ilcFlags & LUIFLAG_MMX) // mmx version
        {
                xMOV_rm_r  (rmIND(rESI),rEBX)
            xMOVQ_r_rm (rMM0,rmIND(rEDX))
            xMOVQ_r_rm (rMM1,rmIND8(rEDX)) xOFS8(8)
            xMOVQ_r_rm (rMM2,rmIND8(rEDX)) xOFS8(16)
            xMOVQ_r_rm (rMM3,rmIND8(rEDX)) xOFS8(24)
                xMOVQ_rm_r (rmIND8(rESI),rMM0) xOFS8(4)
                xMOVQ_rm_r (rmIND8(rESI),rMM1) xOFS8(12)
                xMOVQ_rm_r (rmIND8(rESI),rMM2) xOFS8(20)
                xMOVQ_rm_r (rmIND8(rESI),rMM3) xOFS8(28)
            xEMMS
            xADD_rm_imm8   (rmREG(rESI),9*4)
            xSUB_rm_imm8   (rmREG(rEDI),9)
        }
        else // basic version
        {
                xMOV_rm_r  (rmIND(rESI),rEBX)
            xMOV_r_rm  (rEAX,rmIND(rEDX))
            xMOV_r_rm  (rEBX,rmIND8(rEDX)) xOFS8(4)
            xMOV_r_rm  (rECX,rmIND8(rEDX)) xOFS8(8)
            xMOV_r_rm  (rEBP,rmIND8(rEDX)) xOFS8(12)
                xMOV_rm_r  (rmIND8(rESI),rEAX) xOFS8(4)
                xMOV_rm_r  (rmIND8(rESI),rEBX) xOFS8(8)
                xMOV_rm_r  (rmIND8(rESI),rECX) xOFS8(12)
                xMOV_rm_r  (rmIND8(rESI),rEBP) xOFS8(16)
            xMOV_r_rm  (rEAX,rmIND8(rEDX)) xOFS8(16)
            xMOV_r_rm  (rEBX,rmIND8(rEDX)) xOFS8(20)
            xMOV_r_rm  (rECX,rmIND8(rEDX)) xOFS8(24)
            xMOV_r_rm  (rEBP,rmIND8(rEDX)) xOFS8(28)
                xMOV_rm_r  (rmIND8(rESI),rEAX) xOFS8(20)
                xMOV_rm_r  (rmIND8(rESI),rEBX) xOFS8(24)
                xMOV_rm_r  (rmIND8(rESI),rECX) xOFS8(28)
                xMOV_rm_r  (rmIND8(rESI),rEBP) xOFS8(32)
            xADD_rm_imm8   (rmREG(rESI),9*4)
            xSUB_rm_imm8   (rmREG(rEDI),9)
        }

#ifdef CHECK_VALID_PUSHER
    {
        DWORD l;
        xTEST_rm_imm (rmREG(rEDI),0x80000000)
        l = ilcCount;
        xJZ          (0)
        xINT3
        *(BYTE*)(ilcData + l + 1) = (BYTE)(ilcCount - (l + 2));
    }
#endif

#ifdef DEBUG
        /*
         * debug code
         */
        ILCCompile_dbgDisplayVertexData(9);
#endif // DEBUG

        /*
         * done
         */
        return;
    }


    /*
     * gather stage
     *  mostly does fvf decode and/or prepare for fog
     *  ebx still has vertex type
     *
     * gather buffer layout - (dx5 ? 36 : 44) bytes total
     *  +0  +4  +8  +12 +16 +20 +24 +28 +32 +36 +40
     *  vtx sx  sy  sz  rhw col spc u0  v0  u1  v1
     */
    if (ilcFlags & LUIFLAG_FVF)
    {
            xMOV_i32_r ( 0+(DWORD)&global.dwVertexGatherBuf,rEBX);
        // x,y,z
        xMOV_r_rm  (rEAX,rmIND(rEDX))
        xMOV_r_rm  (rEBX,rmIND8(rEDX)) xOFS8(4)
        xMOV_r_rm  (rECX,rmIND8(rEDX)) xOFS8(8)
            xMOV_i32_r ( 4+(DWORD)&global.dwVertexGatherBuf,rEAX);
            xMOV_i32_r ( 8+(DWORD)&global.dwVertexGatherBuf,rEBX);
            xMOV_i32_r (12+(DWORD)&global.dwVertexGatherBuf,rECX);
        // color,specular,u0,v0
        xMOV_r_rm  (rEAX,rmREG(rEDX))
            xMOV_r_rm  (rEBX,rmREG(rEDX))
                xMOV_r_rm  (rECX,rmREG(rEDX))
                    xMOV_r_rm  (rEBP,rmREG(rEDX))
        xAND_r_i32 (rEAX,(DWORD)&fvfData.dwRHWMask)
            xAND_r_i32 (rEBX,(DWORD)&fvfData.dwARGBMask)
                xAND_r_i32 (rECX,(DWORD)&fvfData.dwSpecularMask)
                    xAND_r_i32 (rEBP,(DWORD)&fvfData.dwUVMask)
        xADD_r_i32 (rEAX,(DWORD)&fvfData.dwRHWOffset)
            xADD_r_i32 (rEBX,(DWORD)&fvfData.dwARGBOffset)
                xADD_r_i32 (rECX,(DWORD)&fvfData.dwSpecularOffset)
                    xADD_r_i32 (rEBP,(DWORD)&fvfData.dwUVOffset)
        xMOV_r_rm (rEAX,rmIND(rEAX))
            xMOV_r_rm (rEBX,rmIND(rEBX))
                xMOV_r_rm (rECX,rmIND(rECX))
                    xMOV_r_i32 (rEDX,(DWORD)&global.pdwUVOffset)
        xMOV_i32_r (16+(DWORD)&global.dwVertexGatherBuf,rEAX);
                    xMOV_r_rm  (rEAX,rmIND(rEDX))
            xMOV_i32_r (20+(DWORD)&global.dwVertexGatherBuf,rEBX);
                    xDS xMOV_r_rm (rEBX,rmSIB) xSIB(rEAX,rEBP,x1)
                xMOV_i32_r (24+(DWORD)&global.dwVertexGatherBuf,rECX);
                        xDS xMOV_r_rm (rECX,rmSIB8) xSIB(rEAX,rEBP,x1) xOFS8 (4)
                    xMOV_i32_r (28+(DWORD)&global.dwVertexGatherBuf,rEBX);
                        xMOV_i32_r (32+(DWORD)&global.dwVertexGatherBuf,rECX);
        // u1,v1
        if (ilcFlags & LUIFLAG_DX6)
        {
                    xMOV_r_rm  (rEAX,rmIND8(rEDX)) xOFS8(4)
                    xDS xMOV_r_rm (rEBX,rmSIB) xSIB(rEAX,rEBP,x1)
                        xDS xMOV_r_rm (rECX,rmSIB8) xSIB(rEAX,rEBP,x1) xOFS8 (4)
                    xMOV_i32_r (36+(DWORD)&global.dwVertexGatherBuf,rEBX);
                        xMOV_i32_r (40+(DWORD)&global.dwVertexGatherBuf,rECX);
        }
    }
    else
    {
        xMOV_i32_r (0+(DWORD)&global.dwVertexGatherBuf,rEBX);
        ILCCompile_move (4+(DWORD)&global.dwVertexGatherBuf,0/*edx*/,32); // always TL when not FVF
    }

    /*
     * apply fog
     */
    if (ilcFlags & LUIFLAG_FOGMODE)
    {
        BOOL isExp2 = (ilcFlags & LUIFLAG_FOGMODE) == 2;
        BOOL isLin  = (ilcFlags & LUIFLAG_FOGMODE) == 3;

        /*
         * st(0) = (global.dvWNear == 1.0f) ? z : approx(1.0 / rhw)
         */
        xMOV_rm_imm  (rmREG(rEBX),0x3f800000*2)
        xSUB_r_i32   (rEBX,16+(DWORD)&global.dwVertexGatherBuf) // rhw
        xMOV_i32_r   ((DWORD)&global.dwTemp,rEBX)
        xFLD_i32     ((DWORD)&global.dwTemp)
        xFLD_st      (rST0)
        xFMUL_i32    (16+(DWORD)&global.dwVertexGatherBuf) // rhw
        xFLD_i32     ((DWORD)&global.fFogC1)
        xFSUBRP_st   (rST1)
        xFMULP_st    (rST1)

        xFSTP_i32    ((DWORD)&global.dwTemp)
        xMOV_r_i32   (rEDX,12+(DWORD)&global.dwVertexGatherBuf) // z
        xAND_r_i32   (rEDX,(DWORD)&global.dwWMask1)

        xMOV_r_i32   (rEBX,(DWORD)&global.dwTemp)
        xAND_r_i32   (rEBX,(DWORD)&global.dwWMask2)

        xOR_r_rm     (rEBX,rmREG(rEDX))
        xMOV_i32_r   ((DWORD)&global.dwTemp,rEBX)

        xFLD_i32     ((DWORD)&global.dwTemp)

        if (isLin)
        {
            /*
             * st(0) = (fFogTableEnd - st(0)) * fFogTableLinearScale
             */
            xFLD_i32   ((DWORD)&global.fFogTableEnd)
            xFSUBRP_st (rST1)
            xFMUL_i32  ((DWORD)&global.fFogTableLinearScale)
        }
        else
        {
            /*
             * st(0) *= fFogTableDensity
             */
            xFMUL_i32  ((DWORD)&global.fFogTableDensity)

            if (isExp2)
            {
                /*
                 * st(0) *= st(0)
                 */
                xFMUL_st (rST0)
            }

            /*
             * st(0) = exp( st(0) )
             */
            xFMUL_i32   ((DWORD)&global.fFogC2)
            xFISTP_i32  ((DWORD)&global.dwTemp)
            xMOV_rm_imm (rmREG(rEAX),0x3f800000)
            xADD_i32_r  ((DWORD)&global.dwTemp,rEAX)
            xFLD_i32    ((DWORD)&global.dwTemp)
        }

        /*
         * eax = int8bits ( st(0) ) << 24
         */
        xFLD1
        xFADDP_st    (rST1)
        xFSTP_i32    ((DWORD)&global.dwTemp)
        xMOV_r_i32   (rEAX,(DWORD)&global.dwTemp)

        xCMP_rm_imm  (rmREG(rEAX),0x3f800000)
        xSETG_rm8    (rmREG(rBL))
        xSHR_rm_imm  (rmREG(rEBX),1)
        xSBB_r_rm    (rEBP,rmREG(rEBP))

        xCMP_rm_imm  (rmREG(rEAX),0x40000000)
        xSETGE_rm8   (rmREG(rBL))
        xSHR_rm_imm  (rmREG(rEBX),1)
        xSBB_r_rm    (rEBX,rmREG(rEBX))

        xSHL_rm_imm  (rmREG(rEAX),9)
        xOR_r_rm     (rEAX,rmREG(rEBX))
        xAND_r_rm    (rEAX,rmREG(rEBP))
        xAND_rm_imm  (rmREG(rEAX),0xff000000)

        /*
         * update specular
         */
        xMOV_r_i32   (rEBX,24+(DWORD)&global.dwVertexGatherBuf) // spec
        xAND_rm_imm  (rmREG(rEBX),0x00ffffff)
        xOR_r_rm     (rEBX,rmREG(rEAX))
        xMOV_i32_r   (24+(DWORD)&global.dwVertexGatherBuf,rEBX) // spec
    }

    /*
     * apply fixed w-buffer scale
     */
    if (ilcFlags & LUIFLAG_FIXEDWBUF)
    {
        xFLD_i32  (16+(DWORD)&global.dwVertexGatherBuf) // rhw
        xFMUL_i32 ((DWORD)&global.fRWFar)
        xFSTP_i32 (16+(DWORD)&global.dwVertexGatherBuf) // rhw
    }

    /*
     * optimized z
     */
#ifdef NV_CONTROLTRAFFIC
    if (ilcFlags & (LUIFLAG_ZFRONT | LUIFLAG_ZBACK))
    {
        xMOV_r_i32   (rEAX,12+(DWORD)&global.dwVertexGatherBuf) // z

        if (ilcFlags & LUIFLAG_ZFRONT)
        {
            /*
             * clamp z to 1.0f
             */
            xCMP_rm_imm  (rmREG(rEAX),0x3f800000)
            xSETG_rm8    (rmREG(rBL))
            xSHR_rm_imm  (rmREG(rEBX),1)
            xSBB_r_rm    (rEBX,rmREG(rEBX))     // ebx = (eax > 1.0f) ? -1 : 0

            xMOV_r_rm    (rECX,rmREG(rEBX))
            xNOT_rm      (rmREG(rECX))          // ecx = (eax > 1.0f) ? 0 : -1

            xAND_rm_imm  (rmREG(rEBX),0x3f800000)
            xAND_r_rm    (rEAX,rmREG(rECX))
            xOR_r_rm     (rEAX,rmREG(rEBX))
        }

        if (ilcFlags & LUIFLAG_ZBACK)
        {
            /*
             * clamp z to 0.0f
             */
            xMOV_r_rm    (rEBX,rmREG(rEAX))
            xSHL_rm_imm  (rmREG(rEBX),1)
            xSBB_r_rm    (rEBX,rmREG(rEBX))     // ebx = (eax <= -0.0f) ? -1 : 0
            xNOT_rm      (rmREG(rEBX))          // ebx = (eax <= -0.0f) ? 0 : -1
            xAND_r_rm    (rEAX,rmREG(rEBX))
        }

        xMOV_i32_r   ((DWORD)&global.dwTemp,rEAX)

        /*
         * optimize
         */
        xFLD_i32  ((DWORD)&global.dwTemp)
        xFMUL_i32 ((DWORD)&global.fCTC1);
        if (ilcFlags & LUIFLAG_ZBACK)
        {
            xFLD1
            xFSUBRP_st (rST1);
        }
        xFSTP_i32  (12+(DWORD)&global.dwVertexGatherBuf) // z
    }
#endif //NV_CONTROLTRAFFIC

    /*
     * copy to push buffer
     */
    xMOV_r_rm (rEBX,rmREG(rESI))
    ILCCompile_move (0/*ebx*/,(DWORD)&global.dwVertexGatherBuf,dwHWSize*4);
    xADD_rm_imm8   (rmREG(rESI),dwHWSize*4)
    xSUB_rm_imm8   (rmREG(rEDI),dwHWSize)

#ifdef CHECK_VALID_PUSHER
    {
        DWORD l;
        xTEST_rm_imm (rmREG(rEDI),0x80000000)
        l = ilcCount;
        xJZ          (0)
        xINT3
        *(BYTE*)(ilcData + l + 1) = (BYTE)(ilcCount - (l + 2));
    }
#endif

#ifdef DEBUG
    /*
     * debug code
     */
    ILCCompile_dbgDisplayVertexData (dwHWSize);
#endif // DEBUG

}

/*
 * ILCCompile_launch
 *
 * send vertex to hardware
 *  eax,ebx,ecx will be used if dwCode == -1
 *  eax         will be used if dwCode == -2
 */
void ILCCompile_launch
(
    DWORD dwCode // == -1 for launch out of eax,ebx and ecx, -2 for launch from packed eax
)
{
#ifdef PIX1
    dwCode = (ilcFlags & LUIFLAG_DX6) ? 0x765 : 0xfed;
#endif //PIX1

    xMOV_rm_imm  (rmREG(rEDX),((ilcFlags & LUIFLAG_DX6) ? 0x0004e540 : 0x0004e600))
    switch (dwCode)
    {
        case 0xffffffff:
        {
            xSHL_rm_imm (rmREG(rECX),8)
            xSHL_rm_imm (rmREG(rEBX),4)
            xOR_r_rm    (rEAX,rmREG(rECX))
            xOR_r_rm    (rEAX,rmREG(rEBX))
            break;
        }
        case 0xfffffffe:
        {
            break;
        }
        default:
        {
            xMOV_rm_imm (rmREG(rEAX),dwCode)
            break;
        }
    }
    xMOV_rm_r    (rmIND(rESI),rEDX)
    xMOV_rm_r    (rmIND8(rESI),rEAX) xOFS8(4)
    xADD_rm_imm8 (rmREG(rESI),2*4)
    xSUB_rm_imm8 (rmREG(rEDI),2)
}

/****************************************************************************
 * inner loop generator                                                     *
 ****************************************************************************/

/*
 * ILCCompileCode
 *
 * Returns the entry point of a loop that will emit triangles in the format
 * specified. fvfData is implicitly passed
 */
DWORD ILCCompileCode
(
    DWORD dwFlags
)
{
    DWORD label_entry;
    DWORD label_loop;
    DWORD label_warmup;
    DWORD label_draw;
    DWORD label_cullbranch;
    DWORD label_arb11;
    DWORD label_arb12;
    DWORD label_arb21;
    DWORD label_arb22;
    DWORD ilcVertexSize;

    /*
     * setup
     */
    ilcFlags      = dwFlags;
    ilcVertexSize = (ilcFlags & LUIFLAG_DX6) ? 11 : 9;

    /*
     * begin code generation
     */
    while (ilcCount & 31) { xINT3 } // branch prediction helper


    /*
     * pocket of subroutines
     * ---------------------
     */

    /*
     * arbitration code (indexed lists)
     */
    label_arb11 = ilcCount;
    xADD_rm_imm8 (rmREG(rEBX),((ilcFlags & LUIFLAG_DX6) ? VC_DX6_ADD : VC_DX5_ADD))
    xAND_rm_imm8 (rmREG(rEBX),((ilcFlags & LUIFLAG_DX6) ? VC_DX6_AND : VC_DX5_AND))
    //xCMP_r_i32   (rEBX,(DWORD)&global.dwIndex0)
    //xJZ          (label_arb11)
    label_arb12 = ilcCount;
    xJMP         (0)
    while (ilcCount & 31) { xINT3 } // branch prediction helper

    label_arb21 = ilcCount;
    xADD_rm_imm8 (rmREG(rEBX),((ilcFlags & LUIFLAG_DX6) ? VC_DX6_ADD : VC_DX5_ADD))
    xAND_rm_imm8 (rmREG(rEBX),((ilcFlags & LUIFLAG_DX6) ? VC_DX6_AND : VC_DX5_AND))
    xCMP_r_i32   (rEBX,(DWORD)&global.dwIndex0)
    xJZ          (label_arb21)
    xCMP_r_i32   (rEBX,(DWORD)&global.dwIndex1)
    xJZ          (label_arb21)
    label_arb22 = ilcCount;
    xJMP         (0)
    while (ilcCount & 31) { xINT3 } // branch prediction helper


    /*
     * function entry code
     * -------------------
     */
    label_entry = ilcCount;
    xPUSH_r     (rEBP)
    xPUSH_r     (rESI)
    xPUSH_r     (rEDI)
    xMOV_r_i32  (rESI,(DWORD)&nvFifo);
    xMOV_r_i32  (rEDI,(DWORD)&nvFreeCount);


/*
    if (ilcFlags == 0x10010)
    {
        xINT3
        //__asm int 3
    }
//*/

    /*
     * warm cache
     */
    xMOV_r_i32 (rEAX,(DWORD)&global.dwVertex0)
    xMOV_r_i32 (rEAX,(DWORD)&global.dwTemp)
    xMOV_r_i32 (rEAX,(DWORD)&global.dwVertexCache)
    if ((ilcFlags & LUIFLAG_FOGMODE) || (ilcFlags & LUIFLAG_FVF))
    {
        // gather buffer
        xMOV_r_i32 (rEAX,(DWORD)&global.dwVertexGatherBuf)
        xMOV_r_i32 (rEAX,(DWORD)&global.dwVertexGatherBuf2)
    }
    xMOV_r_rm (rEAX,rmREG(rEBP)) // kill eax so we wont stall

    /*
     * setup loop
     * ----------
     */
    if (ilcFlags & LUIFLAG_INDEXED)
    {
        /*
         * setup indices
         */
        xXOR_r_rm   (rEAX,rmREG(rEAX))
        xMOV_i32_r  ((DWORD)&global.dwIndex0,rEAX)
        xINC_r      (rEAX)
        xMOV_i32_r  ((DWORD)&global.dwIndex1,rEAX)
        xINC_r      (rEAX)
        xMOV_i32_r  ((DWORD)&global.dwIndex2,rEAX)
        switch (ilcFlags & LUIFLAG_STRIDES)
        {
            case 0x04: // strip
            case 0x08: // fan
            {
                /*
                 * cull state
                 */
                xMOV_rm_imm (rmREG(rEBX),0x210)
                xMOV_i32_r  ((DWORD)&global.dwStripFanData,rEBX)

                /*
                 * basic translation
                 */
                xMOV_r_i32   (rEAX,(DWORD)&global.pIndices)
                xMOV_r_i32   (rEDX,(DWORD)&global.pVertices)
                xMOV_r_rm    (rEBX,rmIND(rEAX))
                        xMOV_r_rm    (rECX,rmREG(rEBX))
                xADD_rm_imm8 (rmREG(rEAX),4)
                    xAND_rm_imm  (rmREG(rEBX),0xffff)
                        xSHR_rm_imm  (rmREG(rECX),16)
                xMOV_i32_r   ((DWORD)&global.pIndices,rEAX)
                    ILCCompile_mulvertexstride (rEBX);
                        ILCCompile_mulvertexstride (rECX);
                    xADD_r_rm    (rEBX,rmREG(rEDX))
                        xADD_r_rm    (rECX,rmREG(rEDX))
                    xMOV_i32_r   ((DWORD)&global.dwVertex0,rEBX)
                        xMOV_i32_r   ((DWORD)&global.dwVertex1,rECX)
                break;
            }
        }

        /*
         * vertex cache serial number update
         */
        xMOV_r_i32 (rEAX,(DWORD)&global.dwVertexSN)
        xADD_rm_imm(rmREG(rEAX),0x10000)
        xMOV_i32_r ((DWORD)&global.dwVertexSN,rEAX)
    }
    else
    {
        xMOV_r_i32  (rEAX,(DWORD)&global.pVertices)
        xMOV_i32_r ((DWORD)&global.dwVertex0,rEAX)
        xADD_r_i32  (rEAX,(DWORD)&fvfData.dwVertexStride)
        xMOV_i32_r ((DWORD)&global.dwVertex1,rEAX)
        xADD_r_i32  (rEAX,(DWORD)&fvfData.dwVertexStride)
        xMOV_i32_r ((DWORD)&global.dwVertex2,rEAX)

        switch (ilcFlags & LUIFLAG_STRIDES)
        {
            case 0x04: // strip
            case 0x08: // fan
            {
                xMOV_i32_r  ((DWORD)&global.pVertices,rEAX)
                /*
                 * cull state
                 */
                xMOV_rm_imm (rmREG(rEBX),0x210)
                xMOV_i32_r  ((DWORD)&global.dwStripFanData,rEBX)
                break;
            }
        }
    }

    /*
     * inner loop setup
     * ----------------
     */
    label_loop = ilcCount;

    /*
     * cache warm-up
     * -------------
     *
     * pIndices must be kept up to date for the warm-up phase. So does pVertices for
     *  ordered primitives
     */

    /*
     * leave the number of primitives in ebx, number of verts in dwVertSubCount
     */
    switch (ilcFlags & LUIFLAG_STRIDES)
    {
        case 0x00: // list
        case 0x0c: // legacy
        {
            // prim = 3*vert, 32 triangles per batch (96 verts)
            xMOV_r_i32  (rEAX,(DWORD)&global.dwPrimCount)
            xMOV_r_rm   (rEBX,rmREG(rEAX))
            xSUB_rm_imm (rmREG(rEBX),32)
            xSBB_r_rm   (rECX,rmREG(rECX))
            xMOV_r_rm   (rEBX,rmREG(rECX))
            xNOT_rm     (rmREG(rEBX))
            xAND_rm_imm (rmREG(rEBX),32)
            xAND_r_rm   (rECX,rmREG(rEAX))
            xOR_r_rm    (rEBX,rmREG(rECX))
            xMOV_i32_r  ((DWORD)&global.dwPrimSubCount,rEBX)
            xSUB_i32_r  ((DWORD)&global.dwPrimCount,rEBX);
            xLEA_r_rm   (rEBX,rmSIB); xSIB(rEBX,rEBX,x2);
            // result in ebx
            break;
        }
        case 0x04: // strip
        case 0x08: // fan
        {
            // prim = vert, 96 triangles per batch
            xMOV_r_i32  (rEAX,(DWORD)&global.dwPrimCount)
            xMOV_r_rm   (rEBX,rmREG(rEAX))
            xSUB_rm_imm (rmREG(rEBX),96)
            xSBB_r_rm   (rECX,rmREG(rECX))
            xMOV_r_rm   (rEBX,rmREG(rECX))
            xNOT_rm     (rmREG(rEBX))
            xAND_rm_imm (rmREG(rEBX),96)
            xAND_r_rm   (rECX,rmREG(rEAX))
            xOR_r_rm    (rEBX,rmREG(rECX))
            xMOV_i32_r  ((DWORD)&global.dwPrimSubCount,rEBX)
            xSUB_i32_r  ((DWORD)&global.dwPrimCount,rEBX);
            // result in ebx
            break;
        }
    }

    /*
     * step through ebx vertices and just fetch them
     */
    xMOV_r_rm (rECX,rmREG(rEBX));
    if (ilcFlags & LUIFLAG_INDEXED)
    {
        xMOV_r_i32 (rEBX,(DWORD)&global.pIndices)
        if ((ilcFlags & LUIFLAG_STRIDES) == 0x0c)
        {
            xMOV_rm_imm (rmREG(rEBP),3);
        }
        label_warmup = ilcCount;

        xXOR_r_rm    (rEAX,rmREG(rEAX));
   x16r xMOV_r_rm    (rAX,rmIND(rEBX));
        xADD_rm_imm8 (rmREG(rEBX),2);
        ILCCompile_mulvertexstride (rEAX);
        xADD_r_i32 (rEAX,(DWORD)&global.pVertices)
        xMOV_r_rm  (rEAX,rmIND(rEAX))
        if ((ilcFlags & LUIFLAG_STRIDES) == 0x0c)
        {
            xMOV_rm_imm (rmREG(rEAX),0) // explicit move so we don't wait for eax to do xor eax,eax
            xDEC_rm     (rmREG(rEBP))
            xSETZ_rm8   (rmREG(rAL))
            xLEA_r_rm   (rEAX,rmSIB); xSIB(rEAX,rEAX,x2);
            xOR_r_rm    (rEBP,rmREG(rEAX))
            xAND_rm_imm8(rmREG(rEAX),2)
            xADD_r_rm   (rEBX,rmREG(rEAX))
        }
        else
        {
            xMOV_r_rm   (rEAX,rmREG(rEBP)) // kill eax so uproc do not try to wait for it to come in
        }
    }
    else
    {
        xMOV_r_i32   (rEBX,(DWORD)&global.pVertices)
        xMOV_r_i32   (rEDX,(DWORD)&fvfData.dwVertexStride)
        label_warmup = ilcCount;

        xMOV_r_rm (rEAX,rmIND(rEBX))
        xMOV_r_rm (rEAX,rmREG(rEBP)) // kill eax so uproc do not try to wait for it to come in
        xADD_r_rm (rEBX,rmREG(rEDX))
    }

    xDEC_r     (rECX)
    xJNZ       (label_warmup)

    /*
     * dispatch triangles
     * ------------------
     */
    label_draw = ilcCount;

    /*
     * we have a couple of different inner loop styles
     * each are treated special (don't say I don't work for my money... although anybody
     * that has to debug this would probably want to shoot me!  ;) )
     *
     */
    switch (ilcFlags & LUIFLAG_STRIDES)
    {
        case 0x00: // list
        case 0x0c: // legacy
        {
            /*
             * translate indices to vertices
             */
            if (ilcFlags & LUIFLAG_INDEXED)
            {
                xMOV_r_i32 (rECX,(DWORD)&global.pIndices)
                xMOV_r_i32 (rEDX,(DWORD)&global.pVertices)

                xXOR_r_rm  (rEBX,rmREG(rEBX))
           x16r xMOV_r_rm  (rBX,rmIND(rECX))
                xADD_rm_imm8(rmREG(rECX),2)
                xMOV_i32_r ((DWORD)&global.dwIndex0,rEBX)
                ILCCompile_mulvertexstride (rEBX);
                xADD_r_rm  (rEBX,rmREG(rEDX))
                xMOV_i32_r ((DWORD)&global.dwVertex0,rEBX)

                xXOR_r_rm  (rEBX,rmREG(rEBX))
           x16r xMOV_r_rm  (rBX,rmIND(rECX))
                xADD_rm_imm8(rmREG(rECX),2)
                xMOV_i32_r ((DWORD)&global.dwIndex1,rEBX)
                ILCCompile_mulvertexstride (rEBX);
                xADD_r_rm  (rEBX,rmREG(rEDX))
                xMOV_i32_r ((DWORD)&global.dwVertex1,rEBX)

                xXOR_r_rm  (rEBX,rmREG(rEBX))
           x16r xMOV_r_rm  (rBX,rmIND(rECX))
                xADD_rm_imm8(rmREG(rECX),2)
                xMOV_i32_r ((DWORD)&global.dwIndex2,rEBX)
                ILCCompile_mulvertexstride (rEBX);
                xADD_r_rm  (rEBX,rmREG(rEDX))
                xMOV_i32_r ((DWORD)&global.dwVertex2,rEBX)

                if ((ilcFlags & LUIFLAG_STRIDES) == 0x0c)
                {
                    xADD_rm_imm8(rmREG(rECX),2)
                }

                xMOV_i32_r ((DWORD)&global.pIndices,rECX)
            }

            /*
             * perform cull check
             */
            ILCCompile_cullcheck();
            label_cullbranch = ilcCount;
            xJZ32 (0); // to be patched up later

#ifdef NV_PROFILE // add result to triangle area - only if enabled
            if (nvpEnableBits & ((1 << NVP_C_TRIAREA) | (3 << NVP_C_1PIXCLK) | (1 << NVP_C_PIXPERSEC)))
            {
                xPUSH_i32   ((DWORD)&global.dwTemp)
                xMOV_rm_imm (rmREG(rEAX),(DWORD)nvProfileArea)
                xCALL_rm    (rmREG(rEAX))
            }
#endif

            /*
             * check push buffer space
             */
            ILCCompile_reserve (ilcVertexSize*3 + 2);

            /*
             * send geometry
             */
            if (ilcFlags & LUIFLAG_INDEXED)
            {
                DWORD label;

                /*
                 * vertex 0
                 */
                // setup
                xMOV_r_i32  (rEAX,(DWORD)&global.dwIndex0)
                xMOV_r_rm   (rEBX,rmREG(rEAX))
                xOR_r_i32   (rEAX,(DWORD)&global.dwVertexSN)
                xAND_rm_imm8(rmREG(rEBX),((ilcFlags & LUIFLAG_DX6) ? VC_DX6_AND : VC_DX5_AND))
                // arbitrate
                // test
                xCMP_r_rm   (rEAX,rmSIB) xSIB(rEBP,rEBX,x4) xOFS32((DWORD)&global.dwVertexCache) // cmp eax,[vc+ebx*4]
                xMOV_i32_r  ((DWORD)&global.dwIndex0,rEBX)
                label = ilcCount;
                xJZ32       (0)
                // send
                xMOV_rm_r   (rmSIB,rEAX) xSIB(rEBP,rEBX,x4) xOFS32((DWORD)&global.dwVertexCache) // mov [vc+ebx*4],eax
                xMOV_r_i32  (rEDX,(DWORD)&global.dwVertex0)
                ILCCompile_vertex (0xffffffff);
                *(DWORD*)(ilcData + label + 2) = ilcCount - (label + 6);
                /*
                 * vertex 1
                 */
                // setup
                xMOV_r_i32  (rEAX,(DWORD)&global.dwIndex1)
                xMOV_r_rm   (rEBX,rmREG(rEAX))
                xOR_r_i32   (rEAX,(DWORD)&global.dwVertexSN)
                xAND_rm_imm8(rmREG(rEBX),((ilcFlags & LUIFLAG_DX6) ? VC_DX6_AND : VC_DX5_AND))
                // arbitrate (ebx != dwIndex0)
                xCMP_r_i32   (rEBX,(DWORD)&global.dwIndex0)
                xJZ32       (label_arb11)
                *(DWORD*)(ilcData + label_arb12 + 1) = ilcCount - (label_arb12 + 5);
                // test
                xCMP_r_rm   (rEAX,rmSIB) xSIB(rEBP,rEBX,x4) xOFS32((DWORD)&global.dwVertexCache) // cmp eax,[vc+ebx*4]
                xMOV_i32_r  ((DWORD)&global.dwIndex1,rEBX)
                label = ilcCount;
                xJZ32       (0)
                // send
                xMOV_rm_r   (rmSIB,rEAX) xSIB(rEBP,rEBX,x4) xOFS32((DWORD)&global.dwVertexCache) // mov [vc+ebx*4],eax
                xMOV_r_i32  (rEDX,(DWORD)&global.dwVertex1)
                ILCCompile_vertex (0xffffffff);
                *(DWORD*)(ilcData + label + 2) = ilcCount - (label + 6);
                /*
                 * vertex 2
                 */
                // setup
                xMOV_r_i32  (rEAX,(DWORD)&global.dwIndex2)
                xMOV_r_rm   (rEBX,rmREG(rEAX))
                xOR_r_i32   (rEAX,(DWORD)&global.dwVertexSN)
                xAND_rm_imm8(rmREG(rEBX),((ilcFlags & LUIFLAG_DX6) ? VC_DX6_AND : VC_DX5_AND))
                // arbitrate (ebx != dwIndex0)
                xCMP_r_i32  (rEBX,(DWORD)&global.dwIndex0)
                xJZ32       (label_arb21)
                xCMP_r_i32  (rEBX,(DWORD)&global.dwIndex1)
                xJZ32       (label_arb21)
                *(DWORD*)(ilcData + label_arb22 + 1) = ilcCount - (label_arb22 + 5);
                // test
                xCMP_r_rm   (rEAX,rmSIB) xSIB(rEBP,rEBX,x4) xOFS32((DWORD)&global.dwVertexCache) // cmp eax,[vc+ebx*4]
                xMOV_i32_r  ((DWORD)&global.dwIndex2,rEBX)
                label = ilcCount;
                xJZ32       (0)
                // send
                xMOV_rm_r   (rmSIB,rEAX) xSIB(rEBP,rEBX,x4) xOFS32((DWORD)&global.dwVertexCache) // mov [vc+ebx*4],eax
                xMOV_r_i32  (rEDX,(DWORD)&global.dwVertex2)
                ILCCompile_vertex (0xffffffff);
                *(DWORD*)(ilcData + label + 2) = ilcCount - (label + 6);
                /*
                 * launch triangle
                 */
                xMOV_r_i32  (rEAX,(DWORD)&global.dwIndex0)
                xMOV_r_i32  (rEBX,(DWORD)&global.dwIndex1)
                xMOV_r_i32  (rECX,(DWORD)&global.dwIndex2)
                ILCCompile_launch (0xffffffff);
            }
            else
            {
                /*
                 * vertices
                 */
                xMOV_r_i32  (rEDX,(DWORD)&global.dwVertex0)
                ILCCompile_vertex (0);
                xMOV_r_i32  (rEDX,(DWORD)&global.dwVertex1)
                ILCCompile_vertex (1);
                xMOV_r_i32  (rEDX,(DWORD)&global.dwVertex2)
                ILCCompile_vertex (2);
                /*
                 * launch triangle
                 */
                ILCCompile_launch (0x00000210);
            }

            /*
             * patch up cull
             */
            *(DWORD*)(ilcData + label_cullbranch + 2) = ilcCount - (label_cullbranch + 6);

#ifdef DEBUG
            /*
             * debug code
             */
            ILCCompile_dbgFlushTriangle();
#endif

            /*
             * next
             */
            if (!(ilcFlags & LUIFLAG_INDEXED))
            {
                xMOV_r_i32 (rEAX,(DWORD)&fvfData.dwVertexStride)
                xLEA_r_rm  (rEAX,rmSIB) xSIB(rEAX,rEAX,x2)
                xADD_i32_r ((DWORD)&global.dwVertex0,rEAX)
                xADD_i32_r ((DWORD)&global.dwVertex1,rEAX)
                xADD_i32_r ((DWORD)&global.dwVertex2,rEAX)
                xADD_i32_r ((DWORD)&global.pVertices,rEAX)
            }
            break;
        }
        case 0x04: // strip
        case 0x08: // fan
        {
            BOOL  isFan = (ilcFlags & LUIFLAG_STRIDES) == 0x08;
            DWORD label_vx0;
            DWORD label_vx1;

            /*
             * translate index into vertex
             */
            if (ilcFlags & LUIFLAG_INDEXED)
            {
                xMOV_r_i32   (rECX,(DWORD)&global.pIndices)
                xMOV_r_i32   (rEDX,(DWORD)&global.pVertices)
                xXOR_r_rm    (rEBX,rmREG(rEBX))
           x16r xMOV_r_rm    (rBX,rmIND(rECX))
                xADD_rm_imm8 (rmREG(rECX),2)
                ILCCompile_mulvertexstride (rEBX);
                xMOV_i32_r   ((DWORD)&global.pIndices,rECX)
                xADD_r_rm    (rEBX,rmREG(rEDX))
                xMOV_i32_r   ((DWORD)&global.dwVertex2,rEBX)
            }

            /*
             * perform cull check
             */
            ILCCompile_cullcheck();
            label_cullbranch = ilcCount;
            xJZ32 (0) // to be patched up later

#ifdef NV_PROFILE // add result to triangle area - only if enabled
            if (nvpEnableBits & ((1 << NVP_C_TRIAREA) | (3 << NVP_C_1PIXCLK) | (1 << NVP_C_PIXPERSEC)))
            {
                xPUSH_i32   ((DWORD)&global.dwTemp)
                xMOV_rm_imm (rmREG(rEAX),(DWORD)nvProfileArea)
                xCALL_rm    (rmREG(rEAX))
            }
#endif

            /*
             * check push buffer space
             */
            ILCCompile_reserve (ilcVertexSize*3 + 2);

            /*
             * vertex 0
             */
            xMOV_r_i32    (rEBX,(DWORD)&global.dwStripFanData)
            xTEST_rm_imm  (rmREG(rEBX),0x40000)
            label_vx0 = ilcCount;
            xJNZ32        (0)

            xMOV_r_i32  (rEDX,(DWORD)&global.dwVertex0)
            xAND_rm_imm (rmREG(rEBX),0x00f)
            ILCCompile_vertex (0xffffffff);

            *(DWORD*)(ilcData + label_vx0 + 2) = ilcCount - (label_vx0 + 6);

            /*
             * vertex 1
             */
            xMOV_r_i32    (rEBX,(DWORD)&global.dwStripFanData)
            xTEST_rm_imm  (rmREG(rEBX),0x20000)
            label_vx1 = ilcCount;
            xJNZ32        (0)

            xMOV_r_i32  (rEDX,(DWORD)&global.dwVertex1)
            xAND_rm_imm (rmREG(rEBX),0x0f0)
            xSHR_rm_imm (rmREG(rEBX),4)
            ILCCompile_vertex (0xffffffff);

            *(DWORD*)(ilcData + label_vx1 + 2) = ilcCount - (label_vx1 + 6);

            /*
             * vertex 2
             */
            xMOV_r_i32  (rEBX,(DWORD)&global.dwStripFanData)
                xMOV_r_i32  (rEDX,(DWORD)&global.dwVertex2)
            xAND_rm_imm (rmREG(rEBX),0xf00)
            xSHR_rm_imm (rmREG(rEBX),8)
            ILCCompile_vertex (0xffffffff);

            /*
             * launch
             */
            xMOV_r_i32    (rEAX,(DWORD)&global.dwStripFanData)
                xMOV_r_rm     (rECX,rmREG(rEAX))
            xAND_rm_imm   (rmREG(rEAX),0xfff)
                xOR_rm_imm    (rmREG(rECX),0x70000)
                xMOV_i32_r    ((DWORD)&global.dwStripFanData,rECX)
            ILCCompile_launch (0xfffffffe);

            /*
             * patch up cull
             */
            *(DWORD*)(ilcData + label_cullbranch + 2) = ilcCount - (label_cullbranch + 6);

#ifdef DEBUG
            /*
             * debug code
             */
            ILCCompile_dbgFlushTriangle();
#endif

            /*
             * fan next tri
             */
            if (isFan)
            {
                xMOV_r_i32  (rEAX,(DWORD)&global.dwStripFanData)
                    xMOV_r_rm   (rEBX,rmREG(rEAX))
                xXOR_rm_imm (rmREG(rEAX),0x330)
                    xSHL_rm_imm (rmREG(rEBX),1)
                xAND_rm_imm (rmREG(rEAX),0x40fff)
                    xAND_rm_imm (rmREG(rEBX),0x30000)
                xOR_r_rm (rEAX,rmREG(rEBX))
                xMOV_i32_r  ((DWORD)&global.dwStripFanData,rEAX)

                xMOV_r_i32 (rEBX,(DWORD)&global.dwVertex2)
                xMOV_i32_r ((DWORD)&global.dwVertex1,rEBX)
                if (!(ilcFlags & LUIFLAG_INDEXED))
                {
                    xMOV_r_i32 (rEAX,(DWORD)&fvfData.dwVertexStride)
                    xADD_i32_r ((DWORD)&global.dwVertex2,rEAX)
                    xADD_i32_r ((DWORD)&global.pVertices,rEAX)
                }
            }
            /*
             * strip next tri
             */
            else
            {
                xMOV_rm_imm (rmREG(rEAX),0x80000000)
                xXOR_i32_r  ((DWORD)&global.dwCullMask1,rEAX)

                xMOV_r_i32  (rEAX,(DWORD)&global.dwStripFanData)
                    xMOV_r_rm   (rEBX,rmREG(rEAX))
                        xMOV_r_rm   (rECX,rmREG(rEAX))
                xSHR_rm_imm (rmREG(rEAX),4)
                    xSHL_rm_imm (rmREG(rEBX),1)
                        xSHL_rm_imm (rmREG(rECX),8)
                xAND_rm_imm (rmREG(rEAX),0x0ff)
                    xAND_rm_imm (rmREG(rEBX),0x70000)
                        xAND_rm_imm (rmREG(rECX),0xf00)
                xOR_r_rm (rEAX,rmREG(rEBX))
                xOR_r_rm (rEAX,rmREG(rECX))
                xMOV_i32_r  ((DWORD)&global.dwStripFanData,rEAX)

                xMOV_r_i32 (rEAX,(DWORD)&global.dwVertex1)
                xMOV_r_i32 (rEBX,(DWORD)&global.dwVertex2)
                xMOV_i32_r ((DWORD)&global.dwVertex0,rEAX)
                xMOV_i32_r ((DWORD)&global.dwVertex1,rEBX)
                if (!(ilcFlags & LUIFLAG_INDEXED))
                {
                    xMOV_r_i32 (rEAX,(DWORD)&fvfData.dwVertexStride)
                    xADD_i32_r ((DWORD)&global.dwVertex2,rEAX)
                    xADD_i32_r ((DWORD)&global.pVertices,rEAX)
                }
            }

            break;
        }
    }
    /*
     * prepare next primitive and loop
     * -------------------------------
     */
    xMOV_r_i32 (rEAX,(DWORD)&global.dwPrimSubCount)
    xDEC_rm    (rmREG(rEAX))
    xMOV_i32_r ((DWORD)&global.dwPrimSubCount,rEAX)
    xJNZ32     (label_draw)

    /*
     * prepare next batch and loop
     * ---------------------------
     */
    xMOV_r_i32 (rEAX,(DWORD)&global.dwPrimCount)
    xTEST_rm_r (rmREG(rEAX),rEAX)
    xJNZ32     (label_loop)

    /*
     * function exit code
     * ------------------
     */
    xMOV_i32_r ((DWORD)&nvFifo,rESI);
    xMOV_i32_r ((DWORD)&nvFreeCount,rEDI);
    xPOP_r     (rEDI)
    xPOP_r     (rESI)
    xPOP_r     (rEBP)
    xRET

    /*
     * done
     *  label_entry may never be 0
     */
    return label_entry;
}

/*
 * ILCGrowTo
 *
 * grows ilcData to asked for (or larger) size
 */
void ILCGrowTo
(
    DWORD dwNeed
)
{
    /*
     * determine how much memory we need
     */
    if (dwNeed > ilcMax)
    {
        /*
         * grow
         */
#ifdef DEBUG
        DWORD ilcOld = ilcMax;
#endif
        ilcMax  = (dwNeed + 4095) & ~4095;
        ilcData = (BYTE*)ReallocIPM(ilcData,ilcMax);
        // if this fails we are truly screwed
#ifdef DEBUG
        if (!ilcData)
        {
            DPF ("Memory allocation failed - things are going to go terribly wrong now");
            _asm int 3
        }

        memset (ilcData+ilcOld,0xcc,ilcMax-ilcOld);
#endif
    }
}

/****************************************************************************
 * C helper code                                                            *
 ****************************************************************************/

/*
 * TriangleSetup only choose the major things like:
 *      dx5 or dx6
 *      fog
 *      basic, mmx or katmai
 *      fixed wbuffer
 *
 * TriangleDispatch deal with:
 *      indexed vs non-indexed
 *      fvf vs non fvf
 *      list,strip,fan
 */


/*
 * nvDX5TriangleSetup
 *
 * DX5 triangle setup
 */
void __stdcall nvDX5TriangleSetup
(
    DWORD  dwPrimCount,
    LPWORD pIndices,
    DWORD  dwStrides,
    LPBYTE pVertices
)
{
    /*
     * Send the context state down to the hardware.
     */
    if (pCurrentContext->dwStateChange)
        nvSetHardwareState();
    nvSetDx5TriangleState(pCurrentContext);

    /*
     * override for aa
     * aa must be enabled and we must not be capturing the push buffer
     */
    if ( (pCurrentContext->dwAntiAliasFlags & AA_ENABLED_MASK)
     && !(pCurrentContext->dwAntiAliasFlags & AA_CAPTURE_PUSHBUFFER))
    {
        pCurrentContext->dwFunctionLookup = NV_AA_FUNCTION_INDEX;
        nvAACapturePrimitive (dwPrimCount,pIndices,dwStrides,pVertices);
        return;
    }
    /*
     * calc appropriate render function
     */
    pCurrentContext->dwFunctionLookup = (pCurrentContext->dwRenderState[D3DRENDERSTATE_FOGENABLE] ? pCurrentContext->dwRenderState[D3DRENDERSTATE_FOGTABLEMODE] : 0)
#ifndef FLOAT_W
                                      | ((pCurrentContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_USEW) ? LUIFLAG_FIXEDWBUF : 0)
#endif
                                      | ((global.dwCPUFeatureSet & FS_MMX)    ? LUIFLAG_MMX    : 0)
                                      | ((global.dwCPUFeatureSet & FS_KATMAI) ? LUIFLAG_KATMAI : 0);

#ifdef NV_CONTROLTRAFFIC
    if (pCurrentContext->dwCTFlags & NV_CT_ENABLED)
    {
        pCurrentContext->dwFunctionLookup |= (pCurrentContext->dwCTFlags & NV_CT_FRONT)
                                           ? LUIFLAG_ZFRONT
                                           : LUIFLAG_ZBACK;
    }
#endif //NV_CONTROLTRAFFIC

    return;
}

/*
 * nvDX6TriangleSetup
 *
 * DX6 triangle setup
 */
void __stdcall nvDX6TriangleSetup
(
    DWORD  dwPrimCount,
    LPWORD pIndices,
    DWORD  dwStrides,
    LPBYTE pVertices
)
{
    /*
     * setup HW if needed
     */
    if (pCurrentContext->dwStateChange)
    {
        nvSetMultiTextureHardwareState();
        if (!pCurrentContext->bUseDX6Class)
        {
            /*
             * The number of texture stages was reduced to 1.
             * Use DX5 Class instead of DX6 class.
             */
            nvDX5TriangleSetup(dwPrimCount,pIndices,dwStrides,pVertices);
            return;
        }
    }
    nvSetDx6MultiTextureState(pCurrentContext);

    /*
     * override for aa
     * aa must be enabled and we must not be capturing the push buffer
     */
    if ( (pCurrentContext->dwAntiAliasFlags & AA_ENABLED_MASK)
     && !(pCurrentContext->dwAntiAliasFlags & AA_CAPTURE_PUSHBUFFER))
    {
        pCurrentContext->dwFunctionLookup = NV_AA_FUNCTION_INDEX;
        nvAACapturePrimitive (dwPrimCount,pIndices,dwStrides,pVertices);
        return;
    }

    /*
     * calc appropriate render function
     */
    pCurrentContext->dwFunctionLookup = (pCurrentContext->dwRenderState[D3DRENDERSTATE_FOGENABLE] ? pCurrentContext->dwRenderState[D3DRENDERSTATE_FOGTABLEMODE] : 0)
#ifndef FLOAT_W
                                      | ((pCurrentContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_USEW) ? LUIFLAG_FIXEDWBUF : 0)
#endif
                                      | ((global.dwCPUFeatureSet & FS_MMX)    ? LUIFLAG_MMX    : 0)
                                      | ((global.dwCPUFeatureSet & FS_KATMAI) ? LUIFLAG_KATMAI : 0)
                                      | LUIFLAG_DX6
                                      | LUIFLAG_FVF;

#ifdef NV_CONTROLTRAFFIC
    if (pCurrentContext->dwCTFlags & NV_CT_ENABLED)
    {
        pCurrentContext->dwFunctionLookup |= (pCurrentContext->dwCTFlags & NV_CT_FRONT)
                                           ? LUIFLAG_ZFRONT
                                           : LUIFLAG_ZBACK;
    }
#endif //NV_CONTROLTRAFFIC

    return;
}


/*
 * nvTriangleDispatch(dwPrimCount,NULL,LEGACY_STRIDES,(LPBYTE)lpVertices);
 *
 * calls the triangle inner loop code
 *  - if it does not exist yet, build it
 */
void __stdcall nvTriangleDispatch
(
    DWORD  dwPrimCount,
    LPWORD pIndices,
    DWORD  dwStrides,
    LPBYTE pVertices
)
{
    DWORD dwFLUI;
    DWORD dwDrawPrim;

    if (!dwPrimCount) return; // do not waste time (or crash code that assume real work to be done)

    /*
    {
        extern BOOL nvPusherDisassemblerEnable;
        nvPusherDisassemblerEnable = 1;
    }
    */

    /*
     * get function pointer
     */
    dwFLUI = pCurrentContext->dwFunctionLookup;

    /*
     * if we have to call a fixed function, do it now
     *  current fixed functions are
     *      nvTriangleSetup
     *      nvAACapturePrimitive
     */
    if ((dwFLUI & LUIMASK_BRANCH) >= NV_FIXED_FUNCTION_INDEX)
    {
        switch (dwFLUI)
        {
            case NV_AA_FUNCTION_INDEX:
            {
                nvAACapturePrimitive (dwPrimCount,pIndices,dwStrides,pVertices);
                return;
            }
            case NV_SETUP_FUNCTION_INDEX:
            {
                (pCurrentContext->bUseDX6Class ? nvDX6TriangleSetup
                                               : nvDX5TriangleSetup)(dwPrimCount,pIndices,dwStrides,pVertices);

                /*
                 * reset dwFLUI
                 */
                dwFLUI = pCurrentContext->dwFunctionLookup;

                /*
                 * fall through so we can draw the primitives except for AA
                 */
                if ((dwFLUI & LUIMASK_BRANCH) >= NV_FIXED_FUNCTION_INDEX) return;


                break;
            }
        }
    }

#ifdef NV_TEX2
    /*
     * tell texture manager that we are now going to use textures
     * the calls may modify state so that we have to redo HW
     */
    if (pCurrentContext->pTexture0 || pCurrentContext->pTexture1)
    {
        if (pCurrentContext->pTexture0)
            nvTextureRef (pCurrentContext->pTexture0);
        if (pCurrentContext->pTexture1)
            nvTextureRef (pCurrentContext->pTexture1);
        /*
         * if the above changed state - update now
         * yes, it is possible to call setup twice but this happens very infrequently
         */
        (pCurrentContext->bUseDX6Class ? nvDX6TriangleSetup
                                       : nvDX5TriangleSetup)(dwPrimCount,pIndices,dwStrides,pVertices);

        /*
         * reset dwFLUI
         */
        dwFLUI = pCurrentContext->dwFunctionLookup;
    }
#endif

    /*
     * compute proper Lookup Index (LUI).
     *  nvTriangleSetup can only choose the major things like:
     *      dx5 or dx6
     *      fog
     *      (basic, mmx or katmai - determined at startup)
     *
     *  here we have to modify the pointer to deal with:
     *      indexed vs non-indexed
     *      fvf vs non fvf
     *      list,strip,fan
     */
    dwFLUI |= ( pIndices                                 ? LUIFLAG_INDEXED : 0)
           |  ((fvfData.dwVertexType != D3DFVF_TLVERTEX) ? LUIFLAG_FVF     : 0)
           |  ((dwStrides >> 24) << 2);

    /*
     * (dbgLevel & NVDBG_LEVEL_FASTLOOPS) will tell the world what we did here
     */
#if defined(DEBUG) || defined(PRINT_NAME)
    {
        static char *szFog[] = {"","ExpFog","Exp2Fog","LinFog"};
        static char *szPMT[] = {"List","Strip","Fan","Legacy"};
        static char *szIdx[] = {"Ordered","Indexed"};
        static char *szFVF[] = {"","FVF"};
        static char *szDX6[] = {"DX5","DX6"};
        static char *szFWB[] = {"","FixedWB"};
        static char *szMMX[] = {"","_MMX"};
        static char *szKTM[] = {"","_KATMAI"};
        char sz[512];
        strcpy (sz,"nvTriangleDispatch: ");
        strcat (sz,szDX6[(dwFLUI & LUIFLAG_DX6)       ? 1 : 0]);
        strcat (sz,szFVF[(dwFLUI & LUIFLAG_FVF)       ? 1 : 0]);
        strcat (sz,szFog[dwFLUI & LUIFLAG_FOGMODE]);
        strcat (sz,szIdx[(dwFLUI & LUIFLAG_INDEXED)   ? 1 : 0]);
        strcat (sz,"Triangle");
        strcat (sz,szPMT[(dwFLUI & LUIFLAG_STRIDES)>>2]);
        strcat (sz,szFWB[(dwFLUI & LUIFLAG_FIXEDWBUF) ? 1 : 0]);
        strcat (sz,szMMX[(dwFLUI & LUIFLAG_MMX)       ? 1 : 0]);
        strcat (sz,szKTM[(dwFLUI & LUIFLAG_KATMAI)    ? 1 : 0]);
        strcat (sz," (dwFLUI = %02x)");
#ifdef PRINT_NAME
        {
            char sz2[256];
            wsprintf (sz2,sz,dwFLUI);
            strcat (sz2,"\n");
            OutputDebugString (sz2);
        }
#else
        DPF_LEVEL (NVDBG_LEVEL_FASTLOOPS,sz,dwFLUI);
#endif
    }
#endif // DEBUG

    /*
     * get fptr
     */
    dwDrawPrim = dwDrawPrimitiveTable[dwFLUI & LUIMASK_BRANCH];

    /*
     * compile it if it does not exist
     */
    if (!dwDrawPrim)
    {
#ifdef NV_PROFILE
        NVP_START (NVP_T_BUILDLOOP);
#endif
        dwDrawPrim                                    = ILCCompileCode(dwFLUI);
        dwDrawPrimitiveTable[dwFLUI & LUIMASK_BRANCH] = dwDrawPrim;
#ifdef NV_PROFILE
        NVP_STOP (NVP_T_BUILDLOOP);
        nvpLogTime (NVP_T_BUILDLOOP,nvpTime[NVP_T_BUILDLOOP]);
#endif
    }

#ifdef NV_PROFILE
    global.fTriangleArea = 0.0f;
    NVP_START (NVP_T_INNERLOOP);
#endif
    /*
     * setup inner loop variables
     */
    global.dwPrimCount = dwPrimCount;
    global.dwStrides   = dwStrides;
    global.pVertices   = (DWORD)pVertices;
    global.pIndices    = (DWORD)pIndices;
    global.dwCullMask1 = (pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
    global.dwCullMask2 = (pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_NONE) ? 0xffffffff : 0x80000000;
    if (dwFLUI & LUIFLAG_FVF)
    {
        PNVD3DMULTITEXTURESTATE pTriangleState = (PNVD3DMULTITEXTURESTATE)&pCurrentContext->mtsState;
        global.pdwUVOffset = pTriangleState->dwUVOffset;
    }
    if (dwFLUI & LUIFLAG_FOGMODE)
    {
        global.fFogTableDensity     = pCurrentContext->fFogTableDensity;
        global.fFogTableLinearScale = pCurrentContext->fFogTableLinearScale;
        global.fFogTableEnd         = pCurrentContext->fFogTableEnd;
    }
    if (dwFLUI & LUIFLAG_FIXEDWBUF)
    {
        global.fRWFar               = pCurrentContext->dvRWFar;
    }
    if (dwFLUI & LUIFLAG_DX6)
    {
    }
    else
    {
        global.dwSpecularState = pCurrentContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE];
        global.dwSpecCurr      = pCurrentContext->ctxInnerLoop.dwCurrentSpecularState;
        global.dwBlend         = pCurrentContext->ctxInnerLoop.dwCurrentBlend;
        global.dwSpecCount     = pCurrentContext->ctxInnerLoop.dwNoSpecularTriangleCount;
    }

    global.dwWMask1 = ((pCurrentContext->dvWNear == 1.0f) && (pCurrentContext->dvWFar  == 1.0f)) ? 0xffffffff : 0;
    global.dwWMask2 = ~global.dwWMask1;

#ifdef NV_PROFILE
    if (nvpEnableBits & (1 << NVP_C_PIXPERSEC))
    {
        nvpTriArea  = 0.0f;
        nvpTriCount = 0;
        nvpTriToGo  = nvpTriPerSecWindow;
        NVP_START (NVP_C_PIXPERSEC);
    }
#endif

#ifdef PIX1
    {
        typedef struct
        {
            float x,y,z,rhw;
            DWORD c,s;
            float u0,v0,u1,v1;
        } SPECIAL;

        static SPECIAL vx0 = {0.0f,0.0f,0.5f,1.0f, 0x80ffffff,0x00000000, 0.0f,0.0f,0.0f,0.0f };
        static SPECIAL vx1 = {1.0f,0.0f,0.5f,1.0f, 0x80ffffff,0x00000000, 0.0f,0.0f,0.0f,0.0f };
        static SPECIAL vx2 = {0.0f,1.0f,0.5f,1.0f, 0x80ffffff,0x00000000, 0.0f,0.0f,0.0f,0.0f };

        DWORD dwCount = (dwFLUI & LUIFLAG_DX6) ? (sizeDx5TriangleTLVertex * 3)
                                               : (sizeDx6TriangleTLVertex * 3);
        DWORD dwSize  = (dwFLUI & LUIFLAG_DX6) ? 40 : 32;
        DWORD dwCode  = (dwFLUI & LUIFLAG_DX6) ? 0x0028e400 : 0x0020e400;
        DWORD dwBase  = (dwFLUI & LUIFLAG_DX6) ? 5 : 13;


        while (nvFreeCount < dwCount)
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, dwCount);

        ((DWORD*)nvFifo)[0] = dwCode + dwBase * dwSize;
        memcpy ((void*)(nvFifo + 4),&vx0,dwSize);
        nvFifo      += (dwSize + 4);
        nvFreeCount -= (dwSize + 4) / 4;

        dwBase ++;

        ((DWORD*)nvFifo)[0] = dwCode + dwBase * dwSize;
        memcpy ((void*)(nvFifo + 4),&vx1,dwSize);
        nvFifo      += (dwSize + 4);
        nvFreeCount -= (dwSize + 4) / 4;

        dwBase ++;

        ((DWORD*)nvFifo)[0] = dwCode + dwBase * dwSize;
        memcpy ((void*)(nvFifo + 4),&vx2,dwSize);
        nvFifo      += (dwSize + 4);
        nvFreeCount -= (dwSize + 4) / 4;
    }
#endif //PIX1

    /*
     * draw it
     */
    ((PFNINNERLOOP)(ilcData + dwDrawPrim))();

#ifdef NV_PROFILE
    if (nvpEnableBits & (1 << NVP_C_PIXPERSEC))
    {
        nvpTriToGo = 1;
        nvProfileLog(); // force tri/sec dump here
    }
#endif

    /*
     * finish loop variables
     */
    if (dwFLUI & LUIFLAG_DX6)
    {
    }
    else
    {
         pCurrentContext->ctxInnerLoop.dwNoSpecularTriangleCount = global.dwSpecCount;
         pCurrentContext->ctxInnerLoop.dwCurrentSpecularState    = global.dwSpecCurr;
         pCurrentContext->ctxInnerLoop.dwCurrentBlend            = global.dwBlend;
    }

    /*
     * update CT bits
     */
#ifdef NV_CONTROLTRAFFIC
    pCurrentContext->dwCTFlags |= NV_CT_DRAWPRIM;
#endif //NV_CONTROLTRAFFIC

#ifdef NV_PROFILE
    NVP_STOP (NVP_T_INNERLOOP);
    nvpLogTime (NVP_T_INNERLOOP,nvpTime[NVP_T_INNERLOOP]);
#endif

#ifdef NV_PROFILE
    /*
     * pixel per clock calculations
     */
    if (nvpEnableBits & (2 << NVP_C_1PIXCLK))
    {
        DWORD dwPixelsPerClock;

        if (dwFLUI & LUIFLAG_DX6)
        {
            dwPixelsPerClock = 1;
        }
        else
        {

            DWORD drfValueFilter;
            DWORD drfValueSpec;
            DWORD drfValueAlpha;
            DWORD drfValueFog;
            drfValueFilter = DRF_VAL(054, _FILTER, _TEXTUREMIN, pCurrentContext->ctxInnerLoop.dwFilter);
            drfValueSpec = DRF_VAL(054, _BLEND, _SPECULARENABLE, pCurrentContext->ctxInnerLoop.dwBlend);
            drfValueAlpha = DRF_VAL(054, _BLEND, _ALPHABLENDENABLE, pCurrentContext->ctxInnerLoop.dwBlend);
            drfValueFog = DRF_VAL(054, _BLEND, _FOGENABLE, pCurrentContext->ctxInnerLoop.dwBlend);

            if ((drfValueFilter == NV054_FILTER_TEXTUREMIN_LINEARMIPNEAREST) ||
                (drfValueFilter == NV054_FILTER_TEXTUREMIN_LINEARMIPLINEAR)) {
                dwPixelsPerClock = 1;

            } else if (drfValueSpec == NV054_BLEND_SPECULARENABLE_TRUE) {
                dwPixelsPerClock = 1;

            } else if (drfValueAlpha == NV054_BLEND_ALPHABLENDENABLE_TRUE &&
                       drfValueFog == NV054_BLEND_FOGENABLE_TRUE) {
                dwPixelsPerClock = 1;
            } else {
                dwPixelsPerClock = 2;
            }
        }

        nvpLogEvent (NVP_E_TRIDISP);
        switch (dwPixelsPerClock)
        {
            case 1:
            {
                nvpLogCount (NVP_C_1PIXCLK,(DWORD)(0.5f * global.fTriangleArea + 0.5f));
                break;
            }
            case 2:
            {
                nvpLogCount (NVP_C_2PIXCLK,(DWORD)(0.5f * global.fTriangleArea + 0.5f));
                break;
            }
        }
    }
#endif // NV_PROFILE

    /*
    {
        extern BOOL nvPusherDisassemblerEnable;
        NV_D3D_GLOBAL_SAVE();
        nvFlushDmaBuffers();
        NV_D3D_GLOBAL_SETUP();
        nvPusherDisassemblerEnable = 0;
    }
    */

}

#ifdef NV_DUMPLOOPS
void __cdecl print (HANDLE f,char *sz,...)
{
    char buf[512];
    DWORD dw;
    vsprintf (buf,sz,(char*)(((DWORD)&sz)+4));
    WriteFile (f,buf,strlen(buf),&dw,0);
}
#endif

#ifdef NV_EMBEDLOOPS   // -DNV_EMBEDLOOPS -Zm999
#include "\loops.c"
#endif

/*
 * ILCWarmCache
 *
 * loads the most common inner loops
 */
void ILCWarmCache
(
    void
)
{
    DWORD dwDefault = ((global.dwCPUFeatureSet & FS_MMX)    ? LUIFLAG_MMX    : 0)
                    | ((global.dwCPUFeatureSet & FS_KATMAI) ? LUIFLAG_KATMAI : 0);

#ifndef NV_EMBEDLOOPS
#ifndef NV_DUMPLOOPS
#ifndef NV_PROFILE // we do not prebuild code for the profiler since we read the enable bits too late
    DWORD dwFLUI;

    /*
     * dx5 TL verts
     */
    dwFLUI = dwDefault | 0x0000; // list
    dwDrawPrimitiveTable[dwFLUI & LUIMASK_BRANCH] = ILCCompileCode(dwFLUI);
    dwFLUI = dwDefault | 0x0004; // strip
    dwDrawPrimitiveTable[dwFLUI & LUIMASK_BRANCH] = ILCCompileCode(dwFLUI);
    dwFLUI = dwDefault | 0x0008; // fan
    dwDrawPrimitiveTable[dwFLUI & LUIMASK_BRANCH] = ILCCompileCode(dwFLUI);
    dwFLUI = dwDefault | 0x000c; // legacy
    dwDrawPrimitiveTable[dwFLUI & LUIMASK_BRANCH] = ILCCompileCode(dwFLUI);

    /*
     * dx6 fvf verts
     */
    dwFLUI = dwDefault | 0x0000 | LUIFLAG_FVF | LUIFLAG_DX6; // list
    dwDrawPrimitiveTable[dwFLUI & LUIMASK_BRANCH] = ILCCompileCode(dwFLUI);
    dwFLUI = dwDefault | 0x0004 | LUIFLAG_FVF | LUIFLAG_DX6; // strip
    dwDrawPrimitiveTable[dwFLUI & LUIMASK_BRANCH] = ILCCompileCode(dwFLUI);
    dwFLUI = dwDefault | 0x0008 | LUIFLAG_FVF | LUIFLAG_DX6; // fan
    dwDrawPrimitiveTable[dwFLUI & LUIMASK_BRANCH] = ILCCompileCode(dwFLUI);
    dwFLUI = dwDefault | 0x000c | LUIFLAG_FVF | LUIFLAG_DX6; // legacy
    dwDrawPrimitiveTable[dwFLUI & LUIMASK_BRANCH] = ILCCompileCode(dwFLUI);
#endif
#endif
#endif

#ifdef NV_DUMPLOOPS
    {
        DWORD  i;
        HANDLE f;

        /*
         * build all possible inner loops
         */
        for (i=0; i<256; i++)
        {
            dwDrawPrimitiveTable[i] = ILCCompileCode(i | dwDefault);
        }

        /*
         * save them to disk
         */
        f = CreateFile("\\loops.c",GENERIC_WRITE,0,0,CREATE_ALWAYS,0,0);
        if (f != INVALID_HANDLE_VALUE)
        {
            // max
            print (f,"DWORD embedMax = %d;",ilcMax);
            print (f,"\r\n\r\n");
            // data
            print (f,"void embedData (void) {\r\n");
            for (i = 0; i < ilcCount; i++)
            {
                if ((i & 31) ==  0) print (f,"    ");
                print (f,"__asm _emit 0x%02x ",ilcData[i]);
                if ((i & 31) == 31) print (f,"\r\n");
            }
            print (f,"}\r\n\r\n");
            CloseHandle (f);
        }
        else
        {
            OutputDebugString ("File creation failure\n");
            __asm int 3;
        }
    }
#endif

#ifdef NV_EMBEDLOOPS
    {
        DWORD i;

        ilcData  = (BYTE*)embedData;
        ilcMax   = embedMax;
        ilcCount = 0;

        for (i=0; i<256; i++)
        {
            dwDrawPrimitiveTable[i] = ILCCompileCode(i | dwDefault);
        }
    }
#endif
}

#endif //NV_FASTLOOPS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4clear.c ===
#ifdef  NV4
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4CLEAR.C                                                        *
*   NV4 Buffer Clear routines.                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       04/18/98 - created                      *
*                                                                           *
\***************************************************************************/
#include <math.h>
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv4dreg.h"
#include "nv3ddbg.h"
#include "nv4vxmac.h"

void nvSetClearSurface
(
    DWORD   dwDstOffset,
    DWORD   dwDstPitch,
    DWORD   dwDstFormat,
    DWORD   dwRectFormat,
    DWORD   dwFillValue
)
{
#ifdef  DDPUSH_0
    /*
     * Set the destination surface to be cleared.
     */
    while (nvFreeCount < (sizeSetRop5 + sizeSet2DSurfacesDestination + sizeSet2DSurfacesColorFormat + sizeSet2DSurfacesPitch + sizeDrawRopRectAndTextColor1A))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_ROP, (sizeSetRop5 + sizeSet2DSurfacesDestination + sizeSet2DSurfacesColorFormat + sizeSet2DSurfacesPitch + sizeDrawRopRectAndTextColor1A));
    nvglSetRop5(nvFifo, nvFreeCount, NV_DD_ROP, SRCCOPYINDEX);
    nvglSet2DSurfacesDestination(nvFifo, nvFreeCount, NV_DD_SURFACES, dwDstOffset);
    nvglSet2DSurfacesColorFormat(nvFifo, nvFreeCount, NV_DD_SURFACES, dwDstFormat);
    nvglSet2DSurfacesPitch(nvFifo, nvFreeCount, NV_DD_SURFACES, dwDstPitch, dwDstPitch);
    nvglDrawRopRectAndTextColor1A(nvFifo, nvFreeCount, NV_DD_ROP_RECT_AND_TEXT, dwFillValue);
#else   // D3D Channel
    /*
     * Set the destination surface to be cleared.
     */
    while (nvFreeCount < (sizeSetObject + sizeSet2DSurfacesDestination + sizeSet2DSurfacesColorFormat + sizeSet2DSurfacesPitch + sizeSetNv4SolidRectangleColorFormat + sizeNv4SolidRectangleColor))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSet2DSurfacesDestination + sizeSet2DSurfacesColorFormat + sizeSet2DSurfacesPitch + sizeSetNv4SolidRectangleColorFormat + sizeNv4SolidRectangleColor));
    nvglSet2DSurfacesDestination(nvFifo, nvFreeCount, NV_DD_SURFACES, dwDstOffset);
    nvglSet2DSurfacesColorFormat(nvFifo, nvFreeCount, NV_DD_SURFACES, dwDstFormat);
    nvglSet2DSurfacesPitch(nvFifo, nvFreeCount, NV_DD_SURFACES, dwDstPitch, dwDstPitch);
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_RENDER_SOLID_RECTANGLE);
    nvglSetNv4SolidRectangleColorFormat(nvFifo, nvFreeCount, NV_DD_SPARE, dwRectFormat);
    nvglNv4SolidRectangleColor(nvFifo, nvFreeCount, NV_DD_SPARE, dwFillValue);
    pDriverData->dDrawSpareSubchannelObject = D3D_RENDER_SOLID_RECTANGLE;
#endif
    return;
}
void nvReset2DSurfaceFormat
(
    void
)
{
    while (nvFreeCount < sizeSet2DSurfacesColorFormat)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SURFACES, sizeSet2DSurfacesColorFormat);

    if (pDriverData->bi.biBitCount == 8)
    {
        nvglSet2DSurfacesColorFormat(nvFifo, nvFreeCount, NV_DD_SURFACES, NV042_SET_COLOR_FORMAT_LE_Y8);
    }
    else if (pDriverData->bi.biBitCount == 16)
    {
        nvglSet2DSurfacesColorFormat(nvFifo, nvFreeCount, NV_DD_SURFACES, NV042_SET_COLOR_FORMAT_LE_R5G6B5);
    }
    else
    {
        nvglSet2DSurfacesColorFormat(nvFifo, nvFreeCount, NV_DD_SURFACES, NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8);
    }
    return;
}
void nvClearSurfaceRect
(
    DWORD   startx,
    DWORD   starty,
    DWORD   width,
    DWORD   height
)
{
#ifdef  DDPUSH_0
    /*
     * Clear the specified rectangle.
     */
    while (nvFreeCount < sizeDrawRopRectAndTextPointSize)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_ROP_RECT_AND_TEXT, sizeDrawRopRectAndTextPointSize);
    nvglDrawRopRectAndTextPointSize(nvFifo, nvFreeCount, NV_DD_ROP_RECT_AND_TEXT, startx, starty, width, height);
#else   // D3D Channel
    /*
     * Clear the specified rectangle.
     */
    while (nvFreeCount < sizeNv4SolidRectanglePointSize)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeNv4SolidRectanglePointSize);
    nvglNv4SolidRectanglePointSize(nvFifo, nvFreeCount, NV_DD_SPARE, startx, starty, width, height);
#endif  // D3D Channel
    return;
}

BOOL nvD3DClearZBuffer
(
    LPDDRAWI_DDRAWSURFACE_LCL   lpLcl,
    DWORD                       dwFillDepth
)
{
    DWORD                       dwDstOffset;
    DWORD                       dwDstPitch;
    DWORD                       startx = 0;
    DWORD                       starty = 0;
    DWORD                       width, height;
    DWORD                       dwBitCount;
    DWORD                       dwRectColorFormat;
    DWORD                       dwSurfColorFormat;
    LPDDRAWI_DDRAWSURFACE_GBL   dst;

    DPF_LEVEL(NVDBG_LEVEL_FUNCTION_CALL, "nvD3DClearZBuffer");

    if (!lpLcl)
        return(FALSE);

#if D3D_PUSH
#ifdef  D3D_HARDWARE
    if (!pDriverData->NvDevFlatDma)
        return (FALSE);
#endif  // D3D_HARDWARE
#endif  // D3DPUSH

    /*
     * Setup frequently accessed globals.
     */
    NV_D3D_GLOBAL_SETUP();


    dst         = lpLcl->lpGbl;
    dwDstOffset = dst->fpVidMem - pDriverData->BaseAddress;
    dwDstPitch  = dst->lPitch;
    width       = (DWORD)dst->wWidth;
    height      = (DWORD)dst->wHeight;

    /*
     * Anti-Aliasing
     */
    if (pCurrentContext
     && pCurrentContext->dwAntiAliasFlags & (AA_MODE_SUPER | AA_MODE_SINGLECHUNK))
    {
        pCurrentContext->dwAntiAliasFlags    |= AA_CLEAR_SCREEN;
        pCurrentContext->pAAContext->dwZFill  = dwFillDepth;
        return TRUE;
    }

    if (lpLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT)
        dwBitCount = lpLcl->lpGbl->ddpfSurface.dwRGBBitCount;
    else
        dwBitCount = pDriverData->bi.biBitCount;
    switch (dwBitCount)
    {
        case 16:
            dwRectColorFormat = NV05E_SET_COLOR_FORMAT_LE_X16R5G6B5;
            dwSurfColorFormat = NV042_SET_COLOR_FORMAT_LE_Y16;
            break;
        case 24:
        case 32:
            dwRectColorFormat = NV05E_SET_COLOR_FORMAT_LE_X8R8G8B8;
            dwSurfColorFormat = NV042_SET_COLOR_FORMAT_LE_Y32;
            break;
    }
#ifdef  CACHE_FREECOUNT
    nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_ROP, sizeSet2DSurfacesDestination);
#endif  // CACHE_FREECOUNT
    nvSetClearSurface(dwDstOffset, dwDstPitch, dwSurfColorFormat, dwRectColorFormat, dwFillDepth);
    nvClearSurfaceRect(startx, starty, width, height);
    nvReset2DSurfaceFormat();
    pDriverData->TwoDRenderingOccurred   = TRUE;
    pDriverData->ThreeDRenderingOccurred = 0;
    //nvStartDmaBuffer();
    NV_D3D_GLOBAL_SAVE();
#ifdef  CACHE_FREECOUNT
    pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
    return (TRUE);
}

/*
 * Clear render target and zeta-buffer in single call.
 */
DWORD nvClear
(
    LPD3DHAL_CLEARDATA  pcd
)
{
    DWORD dwDstOffset;
    DWORD dwDstPitch;
    DWORD dwRectColorFormat;
    DWORD dwSurfColorFormat;

    DPF_LEVEL(NVDBG_LEVEL_DDI_ENTRY, "nvClear - hContext = %08lx", pcd->dwhContext);
    if (!pCurrentContext->lpLcl)
    {
        pcd->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }

    if (!pDriverData->NvDevFlatDma)
    {
        pcd->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Need to make sure that an unfriendly mode switch didn't sneak and not cause
     * us to get re-enabled properly.
     */
    if (pDriverData->fFullScreenDosOccurred)
    {
        if (pDriverData->fFullScreenDosOccurred & 0x01)
            nvD3DReenable();
        else
        {
            pcd->ddrval = DD_OK;
            return (DDHAL_DRIVER_HANDLED);
        }
    }
    if (pCurrentContext->dwContextReset)
        nvResetContext((PNVD3DTEXTURE)NULL);

    /*
     * Get the format of the surface being cleared.
     */
    switch (DRF_VAL(053, _SET_FORMAT, _COLOR, pCurrentContext->dwSurfaceFormat))
    {
        case NV053_SET_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5:
        case NV053_SET_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5:
        case NV053_SET_FORMAT_COLOR_LE_R5G6B5:
            dwRectColorFormat = NV05E_SET_COLOR_FORMAT_LE_X16R5G6B5;
            dwSurfColorFormat = NV042_SET_COLOR_FORMAT_LE_Y16;
            break;
        case NV053_SET_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8:
        case NV053_SET_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8:
        case NV053_SET_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8:
        case NV053_SET_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8:
        case NV053_SET_FORMAT_COLOR_LE_A8R8G8B8:
            dwRectColorFormat = NV05E_SET_COLOR_FORMAT_LE_X8R8G8B8;
            dwSurfColorFormat = NV042_SET_COLOR_FORMAT_LE_Y32;
            break;
    }

    /*
     * Anti-Aliasing
     */
    if (pCurrentContext->dwAntiAliasFlags & (AA_MODE_SUPER | AA_MODE_SINGLECHUNK))
    {
        if (pcd->dwFlags & D3DCLEAR_TARGET)
        {
            if (dwSurfColorFormat == NV042_SET_COLOR_FORMAT_LE_Y16)
                /*
                 * Get the fill color (24bit RGB) and convert it to 16bpp (565) format.
                 */
                pCurrentContext->pAAContext->dwCFill = ((pcd->dwFillColor & 0x00F80000) >> 8)
                                                     | ((pcd->dwFillColor & 0x0000F800) >> 5)
                                                     | ((pcd->dwFillColor & 0x000000F8) >> 3);
            else
                pCurrentContext->pAAContext->dwCFill = pcd->dwFillColor;
        }
        if (pcd->dwFlags & D3DCLEAR_ZBUFFER) pCurrentContext->pAAContext->dwZFill = pcd->dwFillDepth;

        if (!(pCurrentContext->dwAntiAliasFlags & AA_COPY_SCREEN))
        {
            pCurrentContext->dwAntiAliasFlags |= AA_CLEAR_SCREEN;
            pcd->ddrval = DD_OK;
            return (DDHAL_DRIVER_HANDLED);
        }
    }

#ifdef NV_CONTROLTRAFFIC
    if (pDriverData->regD3DEnableBits1 & REG_BIT1_CONTROLTRAFFIC)
    {
        if ((pcd->dwFlags & (D3DCLEAR_ZBUFFER | D3DCLEAR_TARGET)) == D3DCLEAR_ZBUFFER)
        {
            DWORD f = pCurrentContext->dwCTFlags;
            BOOL  x;

            if (f & NV_CT_ENABLED)
            {
                if (f & NV_CT_DRAWPRIM) f ^= NV_CT_FRONT | NV_CT_DRAWPRIM;
                x = TRUE;
            }
            else
            {
                if (dwSurfColorFormat == NV042_SET_COLOR_FORMAT_LE_Y16)
                {
                    f |= (pcd->dwFillDepth & 0x8000) ? (NV_CT_FRONT | NV_CT_ENABLED)
                                                     : (              NV_CT_ENABLED);
                }
                else
                {
                    f |= (pcd->dwFillDepth & 0x80000000) ? (NV_CT_FRONT | NV_CT_ENABLED)
                                                         : (              NV_CT_ENABLED);
                }
                f &= ~NV_CT_DRAWPRIM;
                x  = FALSE;
            }
            pCurrentContext->dwCTFlags = f;

            NV_FORCE_TRI_SETUP (pCurrentContext);
            if (x)
            {
                pcd->ddrval = DD_OK;
                return (DDHAL_DRIVER_HANDLED);
            }
        }
        else
        {
            pCurrentContext->dwCTFlags = NV_CT_DISABLED;
            NV_FORCE_TRI_SETUP (pCurrentContext);
        }
    }
    else
    {
        pCurrentContext->dwCTFlags = NV_CT_DISABLED;
    }
#endif //NV_CONTROLTRAFFIC

    /*
     * Setup frequently accessed globals.
     */
    NV_D3D_GLOBAL_SETUP();

#ifdef  CACHE_FREECOUNT
    nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_ROP, sizeSet2DSurfacesDestination);
#endif  // CACHE_FREECOUNT

    /*
     * Make sure the context has the correct suface information in it.
     */
    pCurrentContext->dwSurfaceAddr = 0;
    if (dbgFrontRender)
    {
#ifdef WINNT
        if (pCurrentContext->lpLcl->lpGbl->lPitch)
#endif
        pCurrentContext->dwSurfaceAddr            = VIDMEM_ADDR(pDriverData->CurrentVisibleSurfaceAddress);
        pCurrentContext->dwSurfaceOffset          = VIDMEM_OFFSET(pDriverData->CurrentVisibleSurfaceAddress);
        pCurrentContext->surfacePitch.wColorPitch = (WORD)dbgFrontRenderPitch;
    }
    else
    {
#ifdef WINNT
        if (pCurrentContext->lpLcl->lpGbl->lPitch)
#endif
        pCurrentContext->dwSurfaceAddr            = VIDMEM_ADDR(pCurrentContext->lpLcl->lpGbl->fpVidMem);
        pCurrentContext->dwSurfaceOffset          = VIDMEM_OFFSET(pCurrentContext->lpLcl->lpGbl->fpVidMem - pDriverData->BaseAddress);
        pCurrentContext->surfacePitch.wColorPitch = (WORD)pCurrentContext->lpLcl->lpGbl->lPitch;
    }

    pCurrentContext->ZBufferAddr = 0;
    if (pCurrentContext->lpLclZ)
    {
        /*
         * I've seen it happen where the location of the z-buffer will actually
         * change without without the context being destroyed or the set render
         * target call happening. So it's neccessary to make sure that we have the
         * correct z-buffer address and offset here.
         */
    #ifdef WINNT
        if (pCurrentContext->lpLcl->lpGbl->lPitch)
    #endif
        pCurrentContext->ZBufferAddr             = VIDMEM_ADDR(pCurrentContext->lpLclZ->lpGbl->fpVidMem);
        pCurrentContext->ZBufferOffset           = VIDMEM_OFFSET(pCurrentContext->lpLclZ->lpGbl->fpVidMem);
        pCurrentContext->surfacePitch.wZetaPitch = (WORD)pCurrentContext->lpLclZ->lpGbl->lPitch;
    }

    if ((pcd->dwFlags & D3DCLEAR_ZBUFFER)
     && (pCurrentContext->lpLclZ && pCurrentContext->lpLclZ->lpGbl)
     && (pCurrentContext->ZBufferAddr))
    {
        DWORD dwFillDepth = pcd->dwFillDepth;

        /*
         * Normal (not AA)
         */
        {
            DWORD       dwNumRects  = pcd->dwNumRects;
            LPD3DRECT   lpRects     = pcd->lpRects;

            dwDstOffset = pCurrentContext->ZBufferOffset;
            dwDstPitch  = (DWORD)pCurrentContext->surfacePitch.wZetaPitch;

            if (dwNumRects)
            {
                /*
                 * Set the destination surface to be cleared.
                 */
                nvSetClearSurface(dwDstOffset, dwDstPitch, dwSurfColorFormat, dwRectColorFormat, dwFillDepth);
                while (dwNumRects)
                {
                    DWORD startx, starty;
                    DWORD width, height;

                    /*
                     * Get the next rectangle to clear.
                     */
                    startx = lpRects->x1;
                    starty = lpRects->y1;
                    width  = lpRects->x2 - startx;
                    height = lpRects->y2 - starty;

                    /*
                     * Use the hardware to do the clear.
                     */
                    nvClearSurfaceRect(startx, starty, width, height);

                    /*
                     * Move to the next rectangle.
                     */
                    lpRects++;
                    dwNumRects--;
                }
            }
        }
    }

    if ((pcd->dwFlags & D3DCLEAR_TARGET)
     && (pCurrentContext->lpLcl && pCurrentContext->lpLcl->lpGbl)
     && (pCurrentContext->dwSurfaceAddr))
    {
        DWORD       dwFillColor;
        DWORD       dwNumRects  = pcd->dwNumRects;
        LPD3DRECT   lpRects     = pcd->lpRects;

        if (dwSurfColorFormat == NV042_SET_COLOR_FORMAT_LE_Y16)
            /*
             * Get the fill color (24bit RGB) and convert it to 16bpp (565) format.
             */
            dwFillColor = ((pcd->dwFillColor & 0x00F80000) >> 8)
                        | ((pcd->dwFillColor & 0x0000F800) >> 5)
                        | ((pcd->dwFillColor & 0x000000F8) >> 3);
        else
            dwFillColor = pcd->dwFillColor;

        dwDstOffset = pCurrentContext->dwSurfaceOffset;
        dwDstPitch  = (DWORD)pCurrentContext->surfacePitch.wColorPitch;

        /*
         * Clear the rendering target.
         * Send the correct default objects for all the subchannels
         * just to be safe.
         */
        if (dwNumRects)
        {
            /*
             * Set the destination surface to be cleared.
             */
            nvSetClearSurface(dwDstOffset, dwDstPitch, dwSurfColorFormat, dwRectColorFormat, dwFillColor);
            while (dwNumRects)
            {
                DWORD startx, starty;
                DWORD width, height;

                /*
                 * Get the next rectangle to clear.
                 */
                startx = lpRects->x1;
                starty = lpRects->y1;
                width  = lpRects->x2 - startx;
                height = lpRects->y2 - starty;

                /*
                 * Use the hardware to do the clear.
                 */
                nvClearSurfaceRect(startx, starty, width, height);

                /*
                 * Move to the next rectangle.
                 */
                lpRects++;
                dwNumRects--;
            }
        }
    }
    nvReset2DSurfaceFormat();
    pDriverData->TwoDRenderingOccurred   = TRUE;
    pDriverData->ThreeDRenderingOccurred = 0;
    //nvStartDmaBuffer();
    dbgFlushDDI(pCurrentContext);
    NV_D3D_GLOBAL_SAVE();
#ifdef  CACHE_FREECOUNT
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
    pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#endif  // CACHE_FREECOUNT

    pcd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}

#ifdef  NVD3D_DX6
/*
 * DX6 callback for clearing render target, z-buffer and stencil buffer.
 */
DWORD nvClear2
(
    LPD3DHAL_CLEAR2DATA pc2d
)
{
    DWORD       dwFlags;
    DWORD       dwFillColor;
    DWORD       dwFillStencil;
    DWORD       dwNumRects;
    DWORD       dwTextureOffset, dwTextureFormat, dwTextureFilter;
    DWORD       dwCombine0Alpha, dwCombine0Color;
    DWORD       dwCombine1Alpha, dwCombine1Color;
    DWORD       dwCombineFactor, dwBlend, dwFogColor;
    DWORD       dwControl0, dwControl1, dwControl2;
    D3DVALUE    dvFillDepth;
    D3DVALUE    dvX1, dvY1, dvX2, dvY2;
    LPD3DRECT   lpRects;
    D3DTLVERTEX tlvVertex;

    DPF_LEVEL(NVDBG_LEVEL_DDI_ENTRY, "nvClear2 - hContext = %08lx", pc2d->dwhContext);

    if (!pDriverData->NvDevFlatDma)
    {
        pc2d->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Need to make sure that an unfriendly mode switch didn't sneak and not cause
     * us to get re-enabled properly.
     */
    if (pDriverData->fFullScreenDosOccurred)
    {
        if (pDriverData->fFullScreenDosOccurred & 0x01)
            nvD3DReenable();
        else
        {
            pc2d->ddrval = DD_OK;
            return (DDHAL_DRIVER_HANDLED);
        }
    }
    if (pCurrentContext->dwContextReset)
        nvResetContext((PNVD3DTEXTURE)NULL);

    // this is to fix some stupid WHQL bug. basically, they care what's stored in fields
    // that technically don't even exist. we have to make sure that alpha gets cleared to
    // zero when there isn't one.
    dwFillColor = pc2d->dwFillColor;
    if ((pCurrentContext->dwSurfaceFormat == (DRF_DEF(053, _SET_FORMAT, _TYPE, _PITCH) | DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_X1R5G5B5_Z1R5G5B5)))
     || (pCurrentContext->dwSurfaceFormat == (DRF_DEF(053, _SET_FORMAT, _TYPE, _PITCH) | DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_X8R8G8B8_Z8R8G8B8)))) {
        dwFillColor &= 0x00ffffff;
    }

    /*
     * if we do not have stencil, use faster clears
     */
    if (!(pc2d->dwFlags & D3DCLEAR_STENCIL))
    {
        /*
         * 16-bit
         */
        if ((pCurrentContext->dwSurfaceFormat == (DRF_DEF(053, _SET_FORMAT, _TYPE, _PITCH) | DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_X1R5G5B5_Z1R5G5B5)))
         || (pCurrentContext->dwSurfaceFormat == (DRF_DEF(053, _SET_FORMAT, _TYPE, _PITCH) | DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_R5G6B5))))
        {
            D3DHAL_CLEARDATA cd;

            cd.dwhContext  = pc2d->dwhContext;
            cd.dwFlags     = pc2d->dwFlags & ~D3DCLEAR_STENCIL;
            cd.dwFillColor = dwFillColor;
            cd.dwFillDepth = (DWORD)(pc2d->dvFillDepth * 65535.0f); // convert to 16-bit number
            cd.lpRects     = pc2d->lpRects;
            cd.dwNumRects  = pc2d->dwNumRects;

            nvClear (&cd);

            pc2d->ddrval = cd.ddrval;
            return DDHAL_DRIVER_HANDLED;
        }
        else
        /*
         * 32-bit (assumed if not 16-bit)
         */
        {
            D3DHAL_CLEARDATA cd;
            __int64          fd;

            /*
             * Can only do a fast clear of zbuffer if this is not a not a stencil buffer.
             */
            if ((pc2d->dwFlags & D3DCLEAR_ZBUFFER)
             && ((pCurrentContext->lpLclZ)
              && (pCurrentContext->lpLclZ->dwFlags & DDRAWISURF_HASPIXELFORMAT)
              && (pCurrentContext->lpLclZ->lpGbl->ddpfSurface.dwFlags & DDPF_STENCILBUFFER)))
                goto labelSlowClear;

            /*
             * It's ok to do a fast clear of the z-buffer.
             */
            fd = (__int64)((double)pc2d->dvFillDepth * (double)4294967295.0); // convert to 32-bit number
            if (fd > 0xffffffff) fd = 0xffffffff;
            if (fd < 0)          fd = 0;

            cd.dwhContext  = pc2d->dwhContext;
            cd.dwFlags     = pc2d->dwFlags & ~D3DCLEAR_STENCIL;
            cd.dwFillColor = dwFillColor;
            cd.dwFillDepth = (DWORD)fd;
            cd.lpRects     = pc2d->lpRects;
            cd.dwNumRects  = pc2d->dwNumRects;

            nvClear (&cd);

            pc2d->ddrval = cd.ddrval;
            return DDHAL_DRIVER_HANDLED;
        }
    }

labelSlowClear:
    dwFlags       = pc2d->dwFlags;
    dvFillDepth   = pc2d->dvFillDepth;
    dwFillStencil = pc2d->dwFillStencil;
    lpRects       = pc2d->lpRects;
    dwNumRects    = pc2d->dwNumRects;

    if (dwNumRects)
    {
        NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
        nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#else  // CACHE_FREECOUNT
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetRenderTargetContexts + sizeSetRenderTarget));
#endif  // CACHE_FREECOUNT

        /*
         * Make sure the surface is set up correctly.
         */
        pCurrentContext->dwSurfaceAddr = 0;
        if (dbgFrontRender)
        {
#ifdef WINNT
            if (pCurrentContext->lpLcl->lpGbl->lPitch)
#endif
            pCurrentContext->dwSurfaceAddr            = VIDMEM_ADDR(pDriverData->CurrentVisibleSurfaceAddress);
            pCurrentContext->dwSurfaceOffset          = VIDMEM_OFFSET(pDriverData->CurrentVisibleSurfaceAddress);
            pCurrentContext->surfacePitch.wColorPitch = (WORD)dbgFrontRenderPitch;
        }
        else
        {
#ifdef WINNT
            if (pCurrentContext->lpLcl->lpGbl->lPitch)
#endif
            pCurrentContext->dwSurfaceAddr            = VIDMEM_ADDR(pCurrentContext->lpLcl->lpGbl->fpVidMem);
            pCurrentContext->dwSurfaceOffset          = VIDMEM_OFFSET(pCurrentContext->lpLcl->lpGbl->fpVidMem);
            pCurrentContext->surfacePitch.wColorPitch = (WORD)pCurrentContext->lpLcl->lpGbl->lPitch;
        }
        pCurrentContext->ZBufferAddr = 0;
        if (pCurrentContext->lpLclZ)
        {
            /*
             * I've seen it happen where the location of the z-buffer will actually
             * change without without the context being destroyed or the set render
             * target call happening. So it's neccessary to make sure that we have the
             * correct z-buffer address and offset here.
             */
#ifdef WINNT
            if (pCurrentContext->lpLcl->lpGbl->lPitch)
#endif
            pCurrentContext->ZBufferAddr             = VIDMEM_ADDR(pCurrentContext->lpLclZ->lpGbl->fpVidMem);
            pCurrentContext->ZBufferOffset           = VIDMEM_OFFSET(pCurrentContext->lpLclZ->lpGbl->fpVidMem);
            pCurrentContext->surfacePitch.wZetaPitch = (WORD)pCurrentContext->lpLclZ->lpGbl->lPitch;
        }

        /*
         * Call the routine to set the surface if neccessary.
         */
        pDriverData->lpLast3DSurfaceRendered = 0; // force setting of surface.
        nvSetD3DSurfaceState(pCurrentContext);

        /*
         * Determine the triangle setup for the fill being done.
         */
        dwTextureOffset = pCurrentContext->dwDefaultTextureOffset;
        dwTextureFormat = DRF_NUM(055, _FORMAT,          _CONTEXT_DMA,          pCurrentContext->dwDefaultTextureContextDma)
                        | DRF_NUM(055, _FORMAT,          _COLOR,                pCurrentContext->dwDefaultTextureColorFormat)
                        | DRF_NUM(055, _FORMAT,          _MIPMAP_LEVELS,        1)
                        | DRF_DEF(055, _FORMAT,          _BASE_SIZE_U,          _1)
                        | DRF_DEF(055, _FORMAT,          _BASE_SIZE_V,          _1)
                        | DRF_DEF(055, _FORMAT,          _TEXTUREADDRESSU,      _CLAMP)
                        | DRF_DEF(055, _FORMAT,          _WRAPU,                _FALSE)
                        | DRF_DEF(055, _FORMAT,          _TEXTUREADDRESSV,      _CLAMP)
                        | DRF_DEF(055, _FORMAT,          _WRAPV,                _FALSE)
                        | DRF_DEF(055, _FORMAT,          _ORIGIN_ZOH,           _CENTER)
                        | DRF_DEF(055, _FORMAT,          _ORIGIN_FOH,           _CENTER);
        dwTextureFilter = DRF_DEF(055, _FILTER,          _MIPMAP_DITHER_ENABLE, _TRUE)
                        | DRF_NUM(055, _FILTER,          _MIPMAPLODBIAS,        1)
                        | DRF_DEF(055, _FILTER,          _TEXTUREMIN,           _NEAREST)
                        | DRF_DEF(055, _FILTER,          _TEXTUREMAG,           _NEAREST);
        dwCombine0Alpha = DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,            _INVERSE)
                        | DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0,           _ZERO)
                        | DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,            _INVERSE)
                        | DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1,           _ZERO)
                        | DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,            _NORMAL)
                        | DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2,           _ZERO)
                        | DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,            _NORMAL)
                        | DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3,           _ZERO)
                        | DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,            _ADD);
        dwCombine0Color = DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,            _INVERSE)
                        | DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,              _COLOR)
                        | DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0,           _ZERO)
                        | DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,            _NORMAL)
                        | DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,              _COLOR)
                        | DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1,           _DIFFUSE)
                        | DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,            _NORMAL)
                        | DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,              _COLOR)
                        | DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2,           _ZERO)
                        | DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,            _NORMAL)
                        | DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,              _COLOR)
                        | DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3,           _ZERO)
                        | DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,            _ADD);
        dwCombine1Alpha = DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_0,            _INVERSE)
                        | DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_0,           _ZERO)
                        | DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,            _NORMAL)
                        | DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1,           _INPUT)
                        | DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,            _NORMAL)
                        | DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2,           _ZERO)
                        | DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,            _NORMAL)
                        | DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3,           _ZERO)
                        | DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,            _ADD);
        dwCombine1Color = DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_0,            _NORMAL)
                        | DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_0,              _COLOR)
                        | DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_0,           _INPUT)
                        | DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,            _INVERSE)
                        | DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,              _COLOR)
                        | DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1,           _ZERO)
                        | DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_2,            _NORMAL)
                        | DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_2,              _COLOR)
                        | DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_2,           _ZERO)
                        | DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,            _NORMAL)
                        | DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,              _COLOR)
                        | DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3,           _ZERO)
                        | DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,            _ADD);
        dwCombineFactor = 0;
        dwBlend         = DRF_DEF(055, _BLEND,           _MASK_BIT,             _MSB)
                        | DRF_DEF(055, _BLEND,           _SHADEMODE,            _FLAT)
                        | DRF_DEF(055, _BLEND,           _TEXTUREPERSPECTIVE,   _TRUE)
                        | DRF_DEF(055, _BLEND,           _SPECULARENABLE,       _FALSE)
                        | DRF_DEF(055, _BLEND,           _FOGENABLE,            _FALSE)
                        | DRF_DEF(055, _BLEND,           _ALPHABLENDENABLE,     _TRUE);
        dwControl0      = DRF_NUM(055, _CONTROL0,        _ALPHAREF,             0)
                        | DRF_DEF(055, _CONTROL0,        _ALPHAFUNC,            _ALWAYS)
                        | DRF_DEF(055, _CONTROL0,        _ALPHATESTENABLE,      _FALSE)
                        | DRF_DEF(055, _CONTROL0,        _ORIGIN,               _CENTER)
                        | DRF_DEF(055, _CONTROL0,        _CULLMODE,             _NONE)
                        | DRF_DEF(055, _CONTROL0,        _DITHERENABLE,         _FALSE)
                        | DRF_DEF(055, _CONTROL0,        _ALPHA_WRITE_ENABLE,   _FALSE)
                        | DRF_DEF(055, _CONTROL0,        _RED_WRITE_ENABLE,     _TRUE)
                        | DRF_DEF(055, _CONTROL0,        _GREEN_WRITE_ENABLE,   _TRUE)
                        | DRF_DEF(055, _CONTROL0,        _BLUE_WRITE_ENABLE,    _TRUE)
                        | DRF_DEF(055, _CONTROL0,        _ZENABLE,              _TRUE)
                        | DRF_DEF(055, _CONTROL0,        _ZFUNC,                _ALWAYS);
        dwFogColor      = 0;

        /*
         * Fill in the static fields of the TLVertex data structure.
         */
        tlvVertex.sz       = dvFillDepth;
        tlvVertex.rhw      = 1.0f;
        tlvVertex.color    = dwFillColor;
        tlvVertex.specular = 0xFF000000;
        tlvVertex.tu       = 0.0f;
        tlvVertex.tv       = 0.0f;

        /*
         * Enable the buffers that are being cleared.
         */
        if ((dwFlags & D3DCLEAR_TARGET)
         && (pCurrentContext->dwSurfaceAddr))
        {
            dwBlend |= DRF_DEF(055, _BLEND,    _SRCBLEND,  _ONE)
                    |  DRF_DEF(055, _BLEND,    _DESTBLEND, _ZERO);
        }
        else
        {
            dwBlend |= DRF_DEF(055, _BLEND,    _SRCBLEND,  _ZERO)
                    |  DRF_DEF(055, _BLEND,    _DESTBLEND, _ONE);
        }

        if ((dwFlags & D3DCLEAR_ZBUFFER)
         && (pCurrentContext->ZBufferAddr))
        {
            dwControl0 |= DRF_DEF(055, _CONTROL0, _ZWRITEENABLE, _TRUE);
            /*
             * Scale the fill value if this is a w-buffer.
             */
            if (pCurrentContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_TRUE)
            {
                dwControl0 |= DRF_NUM(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, pDriverData->regZPerspectiveEnable)
                           |  DRF_NUM(055, _CONTROL0, _Z_FORMAT,             pDriverData->regZFormat);
            }
            else
            {
#ifdef  FLOAT_W
                // floating point w-buffer.
                dwControl0 |= DRF_DEF(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, _FALSE)
                           |  DRF_DEF(055, _CONTROL0, _Z_FORMAT,             _FLOAT);
                tlvVertex.sz  *= pCurrentContext->dvWFar;
#else
                // fixed point w-buffer.
                dwControl0 |= DRF_DEF(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, _FALSE)
                           |  DRF_DEF(055, _CONTROL0, _Z_FORMAT,             _FIXED);
#endif
            }
        }
        else
        {
            dwControl0 |= DRF_DEF(055, _CONTROL0, _ZWRITEENABLE,         _FALSE)
                       |  DRF_DEF(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, _FALSE)
                       |  DRF_DEF(055, _CONTROL0, _Z_FORMAT,             _FIXED);
        }

        if ((dwFlags & D3DCLEAR_STENCIL)
         && (pCurrentContext->ZBufferAddr))
        {
            dwControl0 |= DRF_DEF(055, _CONTROL0, _STENCIL_WRITE_ENABLE, _TRUE);

            dwControl1 = DRF_DEF(055, _CONTROL1, _STENCIL_TEST_ENABLE,  _TRUE)
                       | DRF_DEF(055, _CONTROL1, _STENCIL_FUNC,         _ALWAYS)
                       | DRF_NUM(055, _CONTROL1, _STENCIL_REF,          dwFillStencil)
                       | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_READ,    0xFF)
                       | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_WRITE,   0xFF);
            dwControl2 = DRF_DEF(055, _CONTROL2, _STENCIL_OP_FAIL,      _REPLACE)
                       | DRF_DEF(055, _CONTROL2, _STENCIL_OP_ZFAIL,     _REPLACE)
                       | DRF_DEF(055, _CONTROL2, _STENCIL_OP_ZPASS,     _REPLACE);
        }
        else
        {
            dwControl0 |= DRF_DEF(055, _CONTROL0, _STENCIL_WRITE_ENABLE, _FALSE);
            dwControl1  = DRF_DEF(055, _CONTROL1, _STENCIL_TEST_ENABLE,  _FALSE)
                        | DRF_DEF(055, _CONTROL1, _STENCIL_FUNC,         _NEVER)
                        | DRF_NUM(055, _CONTROL1, _STENCIL_REF,          0)
                        | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_READ,    0)
                        | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_WRITE,   0);
            dwControl2  = DRF_DEF(055, _CONTROL2, _STENCIL_OP_FAIL,      _KEEP)
                        | DRF_DEF(055, _CONTROL2, _STENCIL_OP_ZFAIL,     _KEEP)
                        | DRF_DEF(055, _CONTROL2, _STENCIL_OP_ZPASS,     _KEEP);
        }

        /*
         * Send the triangle rendering state to the hardware.
         */
        while (nvFreeCount < (sizeSetObject + sizeDX6TriangleState))
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_TRANSCOLOR, (sizeSetObject + sizeDX6TriangleState));
        nvglSetObject(nvFifo, nvFreeCount, NV_DD_TRANSCOLOR, D3D_DX6_MULTI_TEXTURE_TRIANGLE);
        nvglDx6TriangleOffset(nvFifo, nvFreeCount, NV_DD_TRANSCOLOR, dwTextureOffset, 0);
        nvglDx6TriangleOffset(nvFifo, nvFreeCount, NV_DD_TRANSCOLOR, dwTextureOffset, 1);
        nvglDx6TriangleFormat(nvFifo, nvFreeCount, NV_DD_TRANSCOLOR, dwTextureFormat, 0);
        nvglDx6TriangleFormat(nvFifo, nvFreeCount, NV_DD_TRANSCOLOR, dwTextureFormat, 1);
        nvglDx6TriangleFilter(nvFifo, nvFreeCount, NV_DD_TRANSCOLOR, dwTextureFilter, 0);
        nvglDx6TriangleFilter(nvFifo, nvFreeCount, NV_DD_TRANSCOLOR, dwTextureFilter, 1);
        nvglDx6TriangleStageState(nvFifo, nvFreeCount, NV_DD_TRANSCOLOR,
                                  dwCombine0Alpha, dwCombine0Color,
                                  dwCombine1Alpha, dwCombine1Color,
                                  dwCombineFactor, dwBlend,
                                  dwControl0,      dwControl1,
                                  dwControl2,      dwFogColor);

        /*
         * Now clear the buffers.
         */
        while (dwNumRects)
        {
            /*
             * Get the Upper Left and Lower Right fill coordinates as D3DVALUEs.
             */
            dvX1 = (D3DVALUE)lpRects->x1;
            dvY1 = (D3DVALUE)lpRects->y1;
            dvX2 = (D3DVALUE)lpRects->x2;
            dvY2 = (D3DVALUE)lpRects->y2;

            while (nvFreeCount < ((sizeDx6TriangleTLVertex * 4) + sizeDx6TriangleDrawPrimitive))
                nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_TRANSCOLOR, ((sizeDx6TriangleTLVertex * 4) + sizeDx6TriangleDrawPrimitive));


            /*
             * Send the fill rectangle down as two triangles and double kickoff.
             * Upper Left Vertex = i0
             */
            tlvVertex.sx = dvX1;
            tlvVertex.sy = dvY1;
            nvglDx6TriangleTLVertex(nvFifo, nvFreeCount, NV_DD_TRANSCOLOR, 0, tlvVertex);

            /*
             * Upper Right Vertex = i1
             */
            tlvVertex.sx = dvX2;
            tlvVertex.sy = dvY1;
            nvglDx6TriangleTLVertex(nvFifo, nvFreeCount, NV_DD_TRANSCOLOR, 1, tlvVertex);

            /*
             * Lower Right Vertex = i2
             */
            tlvVertex.sx = dvX2;
            tlvVertex.sy = dvY2;
            nvglDx6TriangleTLVertex(nvFifo, nvFreeCount, NV_DD_TRANSCOLOR, 2, tlvVertex);

            /*
             * Lower Left Vertex = i3
             */
            tlvVertex.sx = dvX1;
            tlvVertex.sy = dvY2;
            nvglDx6TriangleTLVertex(nvFifo, nvFreeCount, NV_DD_TRANSCOLOR, 3, tlvVertex);

            /*
             * Kick off two triangles (i0, i1, i2) and (i0, i2, i3)
             */
            nvglDx6TriangleDrawPrimitive(nvFifo, nvFreeCount, NV_DD_TRANSCOLOR, 3, 0x00320210);

            /*
             * Move to the next rectangle.
             */
            lpRects++;
            dwNumRects--;
        }
        /*
         * Kick off the fills.
         */
        //nvStartDmaBuffer();
        dbgFlushDDI(pCurrentContext);

        /*
         * Clear the dDrawSpareSubchannel6Object.  This will force the channel to
         * be reloaded or the next use of the DX6_MULTI_TEXTURE_TRIANGLE to reload
         * the state.
         */
        pDriverData->dDrawSpareSubchannel6Object = 0;
        NV_D3D_GLOBAL_SAVE();
#ifdef  CACHE_FREECOUNT
        pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
    }
    pc2d->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}
#endif  NVD3D_DX6

#endif  // NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4ctxt.c ===
#ifdef  NV4
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4CTXT.C                                                         *
*   Hardware specific context management routines.                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/31/97 - reorganzied.                 *
*                                                                           *
\***************************************************************************/
#include <windows.h>
#include "nvd3ddrv.h"
#include "nv32.h"
#include "ddrvmem.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nv4dreg.h"
#include "nvd3dmac.h"
#include "nv3ddbg.h"
#include "nv4vxmac.h"
#include "nvheap.h"
#ifdef  MULTI_MON
#include "nvrmapi.h"
#include "nvrmarch.inc"
#include "nvos.h"
#endif  // MULTI_MON

#ifndef WINNT
FLATPTR EXTERN_DDAPI DDHAL32_VidMemAlloc (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, DWORD dwXDim, DWORD dwYDim);
void EXTERN_DDAPI DDHAL32_VidMemFree (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, FLATPTR ptr);
extern Nv4ControlDma * __stdcall NvOpenDma(char *, int, int, int);
#endif // #ifndef WINNT

/*
 * Setup the context surface.
 */
BOOL nvSetContextSurface
(
    PNVD3DCONTEXT   pContext
)
{
    DWORD   dwRenderAlphaMask;
    DWORD   dwRenderRedMask;
    DWORD   dwRenderGreenMask;
    DWORD   dwRenderBlueMask;

    DWORD   dwRenderFormat;
    DWORD   dwRenderBitCount;
    DWORD   dwZetaBitCount;
    DWORD   dwAdjustedZetaBitCount;
    DWORD  *pdwZetaBitCount;

    if (pContext->lpLcl)
    {
        /*
         * Store the width and height of the surface in the context.
         */
        pContext->surfaceViewport.clipHorizontal.wX      = 0;
        pContext->surfaceViewport.clipHorizontal.wWidth  = pContext->lpLcl->lpGbl->wWidth;
        pContext->surfaceViewport.clipVertical.wY        = 0;
        pContext->surfaceViewport.clipVertical.wHeight   = pContext->lpLcl->lpGbl->wHeight;

        /*
         * Initialize current surface addresses.
         */
        pContext->dwSurfaceAddr            = VIDMEM_ADDR(pContext->lpLcl->lpGbl->fpVidMem);
        pContext->dwSurfaceOffset          = VIDMEM_OFFSET(pContext->lpLcl->lpGbl->fpVidMem);
        pContext->surfacePitch.wColorPitch = (WORD)pContext->lpLcl->lpGbl->lPitch;

        /*
         * Get the Render Target color format.
         */
        if (pContext->lpLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT)
        {
            DPF_LEVEL(NVDBG_LEVEL_INFO, "nvSetContextSurface: Render Target Pixel Format");
            dwRenderBitCount  = pContext->lpLcl->lpGbl->ddpfSurface.dwRGBBitCount;
            dwRenderAlphaMask = pContext->lpLcl->lpGbl->ddpfSurface.dwRGBAlphaBitMask;
            dwRenderRedMask   = pContext->lpLcl->lpGbl->ddpfSurface.dwRBitMask;
            dwRenderGreenMask = pContext->lpLcl->lpGbl->ddpfSurface.dwGBitMask;
            dwRenderBlueMask  = pContext->lpLcl->lpGbl->ddpfSurface.dwBBitMask;
        }
        else
        {
            DPF_LEVEL(NVDBG_LEVEL_INFO, "nvSetContextSurface: Render Format same as desktop!");
            dwRenderBitCount = pDriverData->bi.biBitCount;
            if (dwRenderBitCount == 16)
            {
                dwRenderAlphaMask = 0x00000000;
                dwRenderRedMask   = 0x0000F800;
                dwRenderGreenMask = 0x000007E0;
                dwRenderBlueMask  = 0X0000001F;
            }
            else if ((dwRenderBitCount == 24) || (dwRenderBitCount == 32))
            {
                dwRenderAlphaMask = 0x00000000;
                dwRenderRedMask   = 0x00FF0000;
                dwRenderGreenMask = 0x0000FF00;
                dwRenderBlueMask  = 0X000000FF;
            }
            else
            {
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "Invalid 3D rendering format!!");
                dbgD3DError();
                return (FALSE);
            }
        }
        DPF_LEVEL(NVDBG_LEVEL_INFO, "    BitCount = %02ld", dwRenderBitCount);
        DPF_LEVEL(NVDBG_LEVEL_INFO, "    RMask=%08lx, GMask=%08lx, BMask=%08lx, AMask=%08lx",
             dwRenderRedMask, dwRenderGreenMask, dwRenderBlueMask, dwRenderAlphaMask);
        DPF_LEVEL(NVDBG_LEVEL_INFO, "\r\n");
        if (dwRenderBitCount == 16)
        {
            switch (dwRenderAlphaMask)
            {
                case 0x00000000:
                    if (dwRenderRedMask == 0x7C00)
                        dwRenderFormat = 0x00007FFF;
                    else
                        dwRenderFormat = 0x0000FFFF;
                    break;
                default:
                    DPF_LEVEL(NVDBG_LEVEL_ERROR, "Invalid 16 bpp Render Target Format!!");
                    break;
            }
        }
        else if ((dwRenderBitCount == 24)
              || (dwRenderBitCount == 32))
        {
            switch (dwRenderAlphaMask)
            {
                case 0x00000000:
                    dwRenderFormat = 0x00FFFFFF;
                    break;
                case 0x7F000000:
                    dwRenderFormat = 0x7FFFFFFF;
                    break;
                case 0xFF000000:
                    dwRenderFormat = 0xFFFFFFFF;
                    break;
                default:
                    DPF_LEVEL(NVDBG_LEVEL_ERROR, "Invalid %02ld Bpp Render Target Format!!", dwRenderBitCount);
            }
        }
        else
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "Invalid %02ld Bpp Render Target Format!!", dwRenderBitCount);
    }
    else
    {
        pContext->surfaceViewport.clipHorizontal.wX     = 0;
        pContext->surfaceViewport.clipHorizontal.wWidth = 0;
        pContext->surfaceViewport.clipVertical.wY       = 0;
        pContext->surfaceViewport.clipVertical.wHeight  = 0;
        pContext->dwSurfaceAddr                         = 0;
        pContext->dwSurfaceOffset                       = 0;
        pContext->surfacePitch.wColorPitch              = 0;

        /*
         * No Render Target color format.
         */
        dwRenderFormat   = 0x00000000;
        dwRenderBitCount = 0;
    }

    /*
     * Enable/Disable the Z-Buffer based on whether one is supplied.
     */
    if (pContext->lpLclZ)
    {
        /*
         * Initialize Z-Buffer location.
         */
        pContext->ZBufferAddr             = pContext->lpLclZ->lpGbl->fpVidMem;
#ifdef WINNT
        pContext->ZBufferAddr += (ULONG) pDriverData->ppdev->pjScreen;
#endif // #ifndef WINNT
        pContext->ZBufferOffset           = pContext->lpLclZ->lpGbl->fpVidMem - pDriverData->BaseAddress;
        pContext->surfacePitch.wZetaPitch = (WORD)pContext->lpLclZ->lpGbl->lPitch;

        /*
         * Get the Zeta Buffer bit depth.
         * The bit depth of the render target and the zeta buffer MUST match.
         */
        if (pContext->lpLclZ->dwFlags & DDRAWISURF_HASPIXELFORMAT)
        {
            DPF_LEVEL(NVDBG_LEVEL_INFO, "D3D:nvSetContext Surface: Zeta Buffer Format");
            DPF_LEVEL(NVDBG_LEVEL_INFO, "    BitCount = %02ld", pContext->lpLclZ->lpGbl->ddpfSurface.dwRGBBitCount);
            DPF_LEVEL(NVDBG_LEVEL_INFO, "    RMask=%08lx, GMask=%08lx, BMask=%08lx, AMask=%08lx",
                      pContext->lpLclZ->lpGbl->ddpfSurface.dwRBitMask,
                      pContext->lpLclZ->lpGbl->ddpfSurface.dwGBitMask,
                      pContext->lpLclZ->lpGbl->ddpfSurface.dwBBitMask,
                      pContext->lpLclZ->lpGbl->ddpfSurface.dwRGBAlphaBitMask);
            DPF_LEVEL(NVDBG_LEVEL_INFO, "\r\n");
            dwZetaBitCount = pContext->lpLclZ->lpGbl->ddpfSurface.dwRGBBitCount;
            pdwZetaBitCount = (DWORD *)&pContext->lpLclZ->lpGbl->ddpfSurface.dwRGBBitCount;
            /*
             * Can't do stencil buffer in 16bpp rendering modes.
             */
            if ((pContext->lpLclZ->lpGbl->ddpfSurface.dwFlags & DDPF_STENCILBUFFER)
             && (dwRenderBitCount == 16))
                pContext->dwContextFlags |= NV_CONTEXT_ZETA_BUFFER_MISMATCH;
        }
        else
        {
            DPF_LEVEL(NVDBG_LEVEL_INFO, "No Zeta Format specified.  Make it same as render surface.");
            dwZetaBitCount = pContext->lpLcl->lpGbl->ddpfSurface.dwRGBBitCount;
            pdwZetaBitCount = NULL;
        }
    }
    else
    {
        /*
         * Disable the Z buffer.
         */
        pContext->dwRenderState[D3DRENDERSTATE_ZENABLE]      = FALSE;
        pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE] = FALSE;

        /*
         * There's no Z-Buffer addresses.
         */
        pContext->ZBufferAddr             = 0;
        pContext->ZBufferOffset           = 0;

        /*
         * When there is no z-buffer, the pitch still has to be non-zero. (I hate that!)
         */
        pContext->surfacePitch.wZetaPitch = 32;

        /*
         * No Zeta Buffer color format.
         */
        dwZetaBitCount  = 0;
        pdwZetaBitCount = NULL;
    }

    /*
     * Set the surface format.
     */
    pContext->dwSurfaceFormat = DRF_DEF(053, _SET_FORMAT, _TYPE, _PITCH);

    if ((pDriverData->regValidateZMethod == REG_VZM_FLEXIBLE)
     || ((pDriverData->regValidateZMethod == REG_VZM_MIXED) && (pContext->dwDXVersionLevel < APP_VERSION_DX6)))
    {
        /*
         * Match Z-Buffer Depth to Render Depth if the VALIDATEZMETHOD registry setting is:
         * REG_VZM_FLEXIBLE
         * OR
         * REG_VZM_MIXED and this is a legacy (DX5 or earlier) application.
         */
        switch (dwRenderFormat)
        {
            case 0x00007FFF:
                pContext->dwSurfaceFormat |= DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_X1R5G5B5_Z1R5G5B5);
                dwAdjustedZetaBitCount = 16;
                break;
            case 0x0000FFFF:
                pContext->dwSurfaceFormat |= DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_R5G6B5);
                dwAdjustedZetaBitCount = 16;
                break;
            case 0x00FFFFFF:
                pContext->dwSurfaceFormat |= DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_X8R8G8B8_Z8R8G8B8);
                dwAdjustedZetaBitCount = 24;
                break;
            case 0x7FFFFFFF:
                pContext->dwSurfaceFormat |= DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_X1A7R8G8B8_Z1A7R8G8B8);
                dwAdjustedZetaBitCount = 24;
                break;
            case 0xFFFFFFFF:
                pContext->dwSurfaceFormat |= DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_A8R8G8B8);
                dwAdjustedZetaBitCount = 24;
                break;
        }
        if (pdwZetaBitCount)
            *pdwZetaBitCount = dwAdjustedZetaBitCount;

        /*
         * Keep track of whether or not the z-buffer depth matches the rendering depth.  This information
         * will be used by SetRenderTarget.
         */
        if (((dwZetaBitCount == 16) && (dwRenderBitCount != 16))
         || ((dwZetaBitCount == 24) && (dwRenderBitCount == 16))
         || ((dwZetaBitCount == 32) && (dwRenderBitCount == 16)))
        {
            pContext->dwContextFlags |= NV_CONTEXT_ZETA_BUFFER_MISMATCH;
        }

    }
    else
    {
        /*
         * Make sure Z-Buffer Depth matches the Rendering Depth if the VALIDATEZMETHOD registry setting is:
         * REG_VZM_STRICT
         * OR
         * REG_VZM_MIXED and this is a DX6 or later application.
         */
        if (((dwZetaBitCount == 0) && (dwRenderBitCount != 0))
         || ((dwZetaBitCount == dwRenderBitCount)
         ||  ((dwZetaBitCount == 24) && (dwRenderBitCount == 32))
         ||  ((dwZetaBitCount == 32) && (dwRenderBitCount == 24))))
        {
            switch (dwRenderFormat)
            {
                case 0x00007FFF:
                    pContext->dwSurfaceFormat |= DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_X1R5G5B5_Z1R5G5B5);
                    break;
                case 0x0000FFFF:
                    pContext->dwSurfaceFormat |= DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_R5G6B5);
                    break;
                case 0x00FFFFFF:
                    pContext->dwSurfaceFormat |= DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_X8R8G8B8_Z8R8G8B8);
                    break;
                case 0x7FFFFFFF:
                    pContext->dwSurfaceFormat |= DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_X1A7R8G8B8_Z1A7R8G8B8);
                    break;
                case 0xFFFFFFFF:
                    pContext->dwSurfaceFormat |= DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_A8R8G8B8);
                    break;
            }
        }
        else
        {
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "Render Target Bit Depth and Zeta Bit Depth Don't match");
            return (FALSE);
        }
    }
    /*
     * If the WFar value is 0.0, then set a default based on the z-buffer precision.
     */
    if (pCurrentContext->dvWFar == 0.0f)
    {
        pCurrentContext->dvWNear = 0.0f;
        if ((pCurrentContext->dwSurfaceFormat == (DRF_DEF(053, _SET_FORMAT, _TYPE, _PITCH) | DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_X1R5G5B5_Z1R5G5B5)))
         || (pCurrentContext->dwSurfaceFormat == (DRF_DEF(053, _SET_FORMAT, _TYPE, _PITCH) | DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_R5G6B5))))
        {
            pCurrentContext->dvWFar  = (D3DVALUE)(1 << 16);
        }
        else
        {
            pCurrentContext->dvWFar  = (D3DVALUE)(1 << 24);
        }
        pCurrentContext->dvRWFar = pCurrentContext->dvWFar;
    }
    return (TRUE);
}
BOOL nvSetupContext
(
    PNVD3DCONTEXT   pContext
)
{
#ifdef  NVD3D_DX6
    DWORD   i;
#endif  // NVD3D_DX6

    /*
     * Clear all context flags to start out.
     */
    pContext->dwContextFlags = 0;

    /*
     * First setup the context surface.
     */
    if (!nvSetContextSurface(pContext))
        return (FALSE);

    /*
     * Set the default rendering state for the context.
     * The defaults come from the final DX5 D3D DDK Documentation.
     */
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE]      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_ANTIALIAS]          = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREADDRESS]     = D3DTADDRESS_WRAP;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_WRAPU]              = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_WRAPV]              = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]           = D3DFILL_SOLID;
    pContext->dwRenderState[D3DRENDERSTATE_SHADEMODE]          = D3DSHADE_GOURAUD;
    pContext->dwRenderState[D3DRENDERSTATE_LINEPATTERN]        = 0;
    pContext->dwRenderState[D3DRENDERSTATE_MONOENABLE]         = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_ROP2]               = R2_COPYPEN;
    pContext->dwRenderState[D3DRENDERSTATE_PLANEMASK]          = 0xFFFFFFFF;
    pContext->dwRenderState[D3DRENDERSTATE_ALPHATESTENABLE]    = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_LASTPIXEL]          = TRUE;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMAG]         = D3DFILTER_NEAREST;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMIN]         = D3DFILTER_NEAREST;
    pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND]           = D3DBLEND_ONE;
    pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND]          = D3DBLEND_ZERO;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMAPBLEND]    = D3DTBLEND_MODULATE;
    pContext->dwRenderState[D3DRENDERSTATE_CULLMODE]           = D3DCULL_CCW;
    pContext->dwRenderState[D3DRENDERSTATE_ZFUNC]              = D3DCMP_LESSEQUAL;
    pContext->dwRenderState[D3DRENDERSTATE_ALPHAREF]           = 0;
    pContext->dwRenderState[D3DRENDERSTATE_ALPHAFUNC]          = D3DCMP_ALWAYS;
    pContext->dwRenderState[D3DRENDERSTATE_DITHERENABLE]       = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE]   = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_FOGENABLE]          = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE]     = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_ZVISIBLE]           = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_SUBPIXEL]           = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_SUBPIXELX]          = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_STIPPLEDALPHA]      = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_FOGCOLOR]           = 0;
    pContext->dwRenderState[D3DRENDERSTATE_FOGTABLEMODE]       = D3DFOG_NONE;
    pContext->dwRenderState[D3DRENDERSTATE_FOGTABLESTART]      = 1;
    pContext->dwRenderState[D3DRENDERSTATE_FOGTABLEEND]        = 100;
    pContext->dwRenderState[D3DRENDERSTATE_FOGTABLEDENSITY]    = 1;
    pContext->dwRenderState[D3DRENDERSTATE_STIPPLEENABLE]      = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_EDGEANTIALIAS]      = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_COLORKEYENABLE]     = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_BORDERCOLOR]        = 0;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREADDRESSU]    = D3DTADDRESS_WRAP;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREADDRESSV]    = D3DTADDRESS_WRAP;
    pContext->dwRenderState[D3DRENDERSTATE_MIPMAPLODBIAS]      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_ZBIAS]              = 0;
    pContext->dwRenderState[D3DRENDERSTATE_RANGEFOGENABLE]     = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_ANISOTROPY]         = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_FLUSHBATCH]         = FALSE;

    /*
     * Enable the Z-Buffer if there is one attached.
     */
    if (pContext->lpLclZ)
    {
        pContext->dwRenderState[D3DRENDERSTATE_ZENABLE]      = TRUE;
        pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE] = TRUE;
    }
    else
    {
        pContext->dwRenderState[D3DRENDERSTATE_ZENABLE]      = FALSE;
        pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE] = FALSE;
    }

    /*
     * Initialize the hardware LOD bias as the value specified in the registry.
     */
    pContext->dwMipMapLODBias = pDriverData->regLODBiasAdjust;
#ifdef  NVD3D_DX6
    pContext->dwRenderState[D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT] = TRUE;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE]              = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILFAIL]                = D3DSTENCILOP_KEEP;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILZFAIL]               = D3DSTENCILOP_KEEP;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILPASS]                = D3DSTENCILOP_KEEP;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILFUNC]                = D3DCMP_ALWAYS;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILREF]                 = 0;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILMASK]                = 0xFFFFFFFF;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILWRITEMASK]           = 0xFFFFFFFF;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREFACTOR]              = 0xFFFFFFFF;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP0]                      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP1]                      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP2]                      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP3]                      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP4]                      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP5]                      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP6]                      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP7]                      = 0;


    /*
     * Initialize the texture stages.  Stage 1-7 are all defaulted to disabled.
     * Stage 0 is defaulted for no texturing.
     */
    pContext->tssState[0].dwTextureMap      = 0;
    pContext->tssState[0].dwAddressU        = D3DTADDRESS_WRAP;
    pContext->tssState[0].dwAddressV        = D3DTADDRESS_WRAP;
    pContext->tssState[0].dwMagFilter       = D3DTFG_POINT;
    pContext->tssState[0].dwMinFilter       = D3DTFN_POINT;
    pContext->tssState[0].dwMipFilter       = D3DTFP_POINT;
    pContext->tssState[0].dwColorOp         = D3DTOP_MODULATE;
    pContext->tssState[0].dwColorArg1       = D3DTA_TEXTURE;
    pContext->tssState[0].dwColorArg2       = D3DTA_CURRENT;
    pContext->tssState[0].dwAlphaOp         = D3DTOP_SELECTARG1;
    pContext->tssState[0].dwAlphaArg1       = D3DTA_TEXTURE;
    pContext->tssState[0].dwAlphaArg2       = D3DTA_CURRENT;
    pContext->tssState[0].dwBumpEnvMat00    = 0;
    pContext->tssState[0].dwBumpEnvMat01    = 0;
    pContext->tssState[0].dwBumpEnvMat10    = 0;
    pContext->tssState[0].dwBumpEnvMat11    = 0;
    pContext->tssState[0].dwTexCoordIndex   = 0;
    pContext->tssState[0].dwBorderColor     = 0x00000000;
    pContext->tssState[0].dwMipMapLODBias   = 0;
    pContext->tssState[0].dwMaxMipLevel     = 0;
    pContext->tssState[0].dwMaxAnisotropy   = 1;
    pContext->tssState[0].dwBumpEnvlScale   = 0;
    pContext->tssState[0].dwBumpEnvlOffset  = 0;
    pContext->tssState[0].bStageNumber      = 0;
    pContext->tssState[0].bWrapU            = 0;
    pContext->tssState[0].bWrapV            = 0;
    pContext->tssState[0].bLODBias          = (BYTE)(pDriverData->regLODBiasAdjust & 0x000000FF);

    for (i = 1; i < 8; i++)
    {
        pContext->tssState[i].dwTextureMap      = 0;
        pContext->tssState[i].dwAddressU        = D3DTADDRESS_WRAP;
        pContext->tssState[i].dwAddressV        = D3DTADDRESS_WRAP;
        pContext->tssState[i].dwMagFilter       = D3DTFG_POINT;
        pContext->tssState[i].dwMinFilter       = D3DTFN_POINT;
        pContext->tssState[i].dwMipFilter       = D3DTFP_POINT;
        pContext->tssState[i].dwColorOp         = D3DTOP_DISABLE;
        pContext->tssState[i].dwColorArg1       = D3DTA_TEXTURE;
        pContext->tssState[i].dwColorArg2       = D3DTA_CURRENT;
        pContext->tssState[i].dwAlphaOp         = D3DTOP_DISABLE;
        pContext->tssState[i].dwAlphaArg1       = D3DTA_TEXTURE;
        pContext->tssState[i].dwAlphaArg2       = D3DTA_CURRENT;
        pContext->tssState[i].dwBumpEnvMat00    = 0;
        pContext->tssState[i].dwBumpEnvMat01    = 0;
        pContext->tssState[i].dwBumpEnvMat10    = 0;
        pContext->tssState[i].dwBumpEnvMat11    = 0;
        pContext->tssState[i].dwTexCoordIndex   = 0;
        pContext->tssState[i].dwBorderColor     = 0x00000000;
        pContext->tssState[i].dwMipMapLODBias   = 0;
        pContext->tssState[i].dwMaxMipLevel     = 0;
        pContext->tssState[i].dwMaxAnisotropy   = 1;
        pContext->tssState[i].dwBumpEnvlScale   = 0;
        pContext->tssState[i].dwBumpEnvlOffset  = 0;
        pContext->tssState[i].bStageNumber      = (BYTE)i;
        pContext->tssState[i].bWrapU            = 0;
        pContext->tssState[i].bWrapV            = 0;
        pContext->tssState[i].bLODBias          = (BYTE)(pDriverData->regLODBiasAdjust & 0x000000FF);
    }
    pContext->dwStageCount = 1;
    pContext->bUseDX6Class = FALSE;
    pContext->dwContextFlags |= NV_CONTEXT_TBLEND_UNINITIALIZED;
    pContext->bUseTBlendSettings = FALSE;
#endif  // NVD3D_DX6

    /*
     * Allocate a default 1x1 texture.
     */
    nvAllocDefaultTexture(pContext);

    /*
     * Set the hardware state.
     */
    pCurrentContext = pContext;

    /*
     * Force an initial state load.
     */
    pCurrentContext->dwStateChange = TRUE;
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return(TRUE);
}
BOOL nvFinalContextCleanup
(
    void
)
{
    return (TRUE);
}
void nvAllocDefaultTexture
(
    PNVD3DCONTEXT   pContext
)
{
    unsigned char  *pData = 0;
#ifndef NVHEAPMGR
    LPDDRAWI_DIRECTDRAW_GBL pdrv     = pContext->lpLcl->lpGbl->lpDD;
#endif

    pContext->dwDefaultTextureContextDma  = NV054_FORMAT_CONTEXT_DMA_B;
#ifndef WINNT
    NVHEAP_ALLOC(((DWORD)pData), 2 + NV_TEXTURE_PAD, TYPE_TEXTURE);
#else
    NVHEAP_ALLOC(((DWORD)pData), ((2 + NV_TEXTURE_PAD + NV_TEXTURE_OFFSET_ALIGN) & ~pDriverData->dwSurfaceAlignPad), TYPE_TEXTURE);
#endif // #ifdef WINNT
    //pData = (unsigned char *)DDHAL32_VidMemAlloc(pContext->lpLcl->lpGbl->lpDD, 0, ((2 + NV_TEXTURE_PAD + NV_TEXTURE_OFFSET_ALIGN) & ~pDriverData->dwSurfaceAlignPad), 1);
    if (pData)
    {
        pContext->dwDefaultTextureBase   = (DWORD)pData;
        pContext->dwDefaultTextureOffset = VIDMEM_OFFSET((((DWORD)pData + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN) - pDriverData->BaseAddress);
        pData = (unsigned char *)VIDMEM_ADDR((pContext->dwDefaultTextureOffset));

        pData[0] = 0xFF;
        pData[1] = 0xFF;

        /*
         * Increment count of video memory surfaces allocated.
         */
        pDriverData->DDrawVideoSurfaceCount++;
    }
    else
    {
        pContext->dwDefaultTextureBase   = (DWORD)0;
        pContext->dwDefaultTextureOffset = 0;
    }
    pContext->dwDefaultTextureColorFormat = NV054_FORMAT_COLOR_LE_A1R5G5B5;


    /*
     * init psuedo-notifier memory
     */
    {
        DWORD size = 16;
#ifndef WINNT
        memset ((void*)(pDriverData->dwTMPseudoNotifierOffset + pDriverData->BaseAddress),0,size);
        *(DWORD*)(pDriverData->dwTMPseudoNotifierOffset + pDriverData->BaseAddress) = pDriverData->dwTMStageAddr;
#else
        memset ((void*)(pDriverData->dwTMPseudoNotifierMem),0,size);
        *(DWORD*)(pDriverData->dwTMPseudoNotifierMem) = pDriverData->dwTMStageAddr;
#endif
        pDriverData->dwTMHead = pDriverData->dwTMStageAddr;
        pDriverData->dwTMTail = pDriverData->dwTMStageAddr;
        pDriverData->dwRenderedFrame = pDriverData->dwCurrentFrame = 0;
        global.dwHWTextureDate = global.dwSWTextureDate;
    }

    /*
     * invalidate fvfData cache
     */
    fvfData.dwVertexType = 0;

    return;
}
void nvFreeDefaultTexture
(
    PNVD3DCONTEXT   pContext
)
{
#ifndef NVHEAPMGR
#ifndef WINNT // BUGBUG where do we get this from under NT?
    LPDDRAWI_DIRECTDRAW_GBL pdrv     = pContext->lpLcl->lpGbl->lpDD;
#else
    LPDDRAWI_DIRECTDRAW_GBL pdrv     = pContext->lpLcl->lpGbl->dwReserved1;
#endif // #ifndef WINNT
#endif
    if (!pContext) return;
    if ((pContext->lpLcl) &&
#ifndef WINNT
    (pContext->lpLcl->lpGbl) &&
    (pContext->lpLcl->lpGbl->lpDD) &&
#else
    (pContext->lpDD) &&
#endif // #ifndef WINNT
            (pContext->dwDefaultTextureBase))

    {
        NVHEAP_FREE (pContext->dwDefaultTextureBase);

        //DDHAL32_VidMemFree(pContext->lpLcl->lpGbl->lpDD, 0, pContext->dwDefaultTextureBase);
        pContext->dwDefaultTextureBase   = 0;
        pContext->dwDefaultTextureOffset = 0;

        /*
         * Increment count of video memory surfaces allocated.
         */
        pDriverData->DDrawVideoSurfaceCount--;
    }

    return;
}
#define NV4_PUSH_BUFFER_PAD     64

void nvD3DReenable()
{
    PNVD3DCONTEXT   pContext = 0;

    NV_D3D_GLOBAL_SETUP();

    /*
     * Run through all valid contexts and update push buffer information.
     */
    pContext = (PNVD3DCONTEXT)pDriverData->dwContextListHead;
    while (pContext)
    {
        pContext->dwDefaultTextureBase = 0;
        pContext->dwContextReset       = TRUE;
        pContext = pContext->pContextNext;
    }

    /*
     * Force reset of D3D rendering target and z-buffer.
     */
    pDriverData->fFullScreenDosOccurred  = 0;
    pDriverData->lpLast3DSurfaceRendered = 0;
    pDriverData->dwCurrentContextHandle  = 0;
    NV_D3D_GLOBAL_SAVE();
}

void nvResetContext
(
    PNVD3DTEXTURE   pTexture
)
{
    if (!pCurrentContext->dwDefaultTextureBase)
        nvAllocDefaultTexture(pCurrentContext);
    return;
}

/*
 * I'm just going to create my own objects for now....
 */
void nvD3DCreateObjects
(
    void
)
{
#ifdef HW_PAL8
    DWORD dwCount;
#endif

    if (!pDriverData->NvDevFlatDma)
        return;

    nvDmaPushOffsetMax        = pDriverData->dwDmaPushOffsetMax = pDriverData->NvDmaPusherBufferSize - NV4_PUSH_BUFFER_PAD;
    nvDmaPushBase             = pDriverData->NvDmaPusherBufferBase;
    nvFifo                    = pDriverData->NvDmaPusherPutAddress;
    nvFreeCount               = 0;
    pCurrentContext           = NULL; // no contexes created yet

    if (!nvFifo)
        return;

    /*
     * Get fifo address and the current free count.
     */
#ifdef  CACHE_FREECOUNT
    nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE,
                     (sizeSetObject + sizeCreateObject));
#endif  // CACHE_FREECOUNT

    /*
     * Make sure there aren't any dangling DMA context object.
     */
#ifdef MULTI_MON
    D3DDestroyTextureContexts();
#endif

#if 0 // BUGBUG -- Object creation needs to be moved and converted
#ifdef HW_PAL8
    /*
     * Create Indexed Image From CPU object for
     * palettized texture swizzling.                    NV 0x060
     */
    while (nvFreeCount < (sizeSetObject + sizeCreateObject))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeCreateObject));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, NV04_INDEXED_IMAGE_FROM_CPU);
    nvglCreateObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_INDEXED_IMAGE_FROM_CPU);

    /*
     * Create an Image From CPU object for moving
     * palettes into video memory                       NV 0x061
     */
    while (nvFreeCount < (sizeSetObject + sizeCreateObject))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeCreateObject));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, NV04_IMAGE_FROM_CPU);
    nvglCreateObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_IMAGE_FROM_CPU);
#endif // HW_PAL8
#endif // BUGBUG

#ifndef MULTI_MON
    /*
     * Create Context Dma To Memory for notifiers.      NV 0xFFD
     */
    while (nvFreeCount < (sizeSetObject + sizeCreateObject))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeCreateObject));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, NV_CONTEXT_DMA_TO_MEMORY);
    nvglCreateObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_NOTIFY_CONTEXT_DMA_TO_MEMORY);

    /*
     * Hook up DMA contexts.
     */
    while (nvFreeCount < (sizeSetObject + sizeCreateObject))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetDmaToMemory));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_NOTIFY_CONTEXT_DMA_TO_MEMORY);
    nvglSetDmaToMemory(nvFifo, nvFreeCount, NV_DD_SPARE, pDriverData->NvDmaPusherSyncNotifierFlat, NvGetFlatDataSelector(), (sizeof(NvNotification) - 1));
#endif  // !MULTI_MON

    nvStartDmaBuffer (FALSE);
    if (nvTMCreate())
    {
#ifdef  CACHE_FREECOUNT
        pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
        /*
         * Creation failed
         */
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "Texture Manager Creation failed");
        return;
    }

    /*
     * Point system memory texture context at video memory for now.  This will get changed later.
     * This is just to make sure that it is pointing at memory of some sort.
     */
#ifdef  MULTI_MON
    nvStartDmaBuffer (FALSE);
#ifndef WINNT
    if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                        D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY,
                        NV01_CONTEXT_DMA,
                        (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                         ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        (PVOID)pDriverData->BaseAddress,
                        0xFF) != ALLOC_CTX_DMA_STATUS_SUCCESS)
                            return(FALSE);
#else
    if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                        D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY,
                        NV01_CONTEXT_DMA,
                        (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                         ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        pDriverData->ppdev->pjScreen,
                        0xFF) != ALLOC_CTX_DMA_STATUS_SUCCESS)
                            return(FALSE);
#endif // #ifdef WINNT

    pDriverData->dwTextureContextValid = TRUE;
#else   // !MULTI_MON
    while (nvFreeCount < (sizeSetObject + sizeSetDmaFromMemoryNotify))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetDmaFromMemoryNotify));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY);
    nvglSetDmaFromMemory(nvFifo, nvFreeCount, NV_DD_SPARE,
                         pDriverData->BaseAddress, pDriverData->flatSelector, 0xFF);

    /*
     * Set the notify context.
     */
    while (nvFreeCount < (sizeSetObject + sizeSetDmaFromMemoryContextNotify))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetDmaFromMemoryContextNotify));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_LINEAR_TEXTURE_FROM_MEMORY);
    nvglSetDmaFromMemoryContextNotify(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_NOTIFY_CONTEXT_DMA_TO_MEMORY);

    while (nvFreeCount < (sizeSetObject + sizeSetDmaFromMemoryContextNotify))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetDmaFromMemoryContextNotify));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY);
    nvglSetDmaFromMemoryContextNotify(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_NOTIFY_CONTEXT_DMA_TO_MEMORY);
#endif  // !MULTI_MON

    /*
     * Hook up the ARGB_ZS surface context.
     */
    while (nvFreeCount < (sizeSetObject + sizeSetRenderTargetContexts))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetRenderTargetContexts));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SURFACES_ARGB_ZS);
    nvglSetRenderTargetContexts(nvFifo, nvFreeCount, NV_DD_SPARE,
                                NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

    /*
     * Hook up the Render Solid Rectangle.
     */
    while (nvFreeCount < (sizeSetObject + sizeSetNv4SolidRectangleSurface))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetNv4SolidRectangleSurface));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_RENDER_SOLID_RECTANGLE);
    nvglSetNv4SolidRectangleSurface(nvFifo, nvFreeCount, NV_DD_SPARE, NV_DD_SURFACES_2D);

    /*
     * Hook up Render Solid Rectangle 2.
     */
    while (nvFreeCount < (sizeSetObject + sizeSetNv4SolidRectangleSurface + 2*sizeSetStartMethod + 2*sizeSetData))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetNv4SolidRectangleSurface + 2*sizeSetStartMethod + 2*sizeSetData));
    nvglSetObject      (nvFifo, nvFreeCount, NV_DD_SPARE, D3D_RENDER_SOLID_RECTANGLE_2);
    nvglSetNv4SolidRectangleSurface(nvFifo, nvFreeCount, NV_DD_SPARE, NV_DD_SURFACES_2D);
    nvglSetStartMethod (nvFifo,nvFreeCount,NV_DD_SPARE, NV05E_SET_OPERATION,1);
    nvglSetData        (nvFifo,nvFreeCount,             NV05E_SET_OPERATION_SRCCOPY);
    nvglSetStartMethod (nvFifo,nvFreeCount,NV_DD_SPARE, NV05E_SET_COLOR_FORMAT,1);
    nvglSetData        (nvFifo,nvFreeCount,             NV05E_SET_COLOR_FORMAT_LE_X8R8G8B8);

    /*
     * Hook up the Dx5 Textured Triangle.
     * System/AGP goes to context A, Video Memory goes to context B.
     */
    while (nvFreeCount < (sizeSetObject + sizeSetDx5TriangleContexts + sizeSetDx5TriangleSurface))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE,
                         (sizeSetObject + sizeSetDx5TriangleContexts + sizeSetDx5TriangleSurface));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_DX5_TEXTURED_TRIANGLE);

    /*
     * Both A and B must be valid.
     */
    nvglSetDx5TriangleContexts(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
    nvglSetDx5TriangleSurface(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SURFACES_ARGB_ZS);


    /*
     * Plug in the notify context.
     */
#ifdef  MULTI_MON
    while (nvFreeCount < (sizeSetStartMethod + sizeSetData))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetStartMethod + sizeSetData))
    nvglSetStartMethod(nvFifo, nvFreeCount, NV_DD_SPARE, NV054_SET_CONTEXT_DMA_NOTIFIES, 1);
    nvglSetData(nvFifo, nvFreeCount, NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
#else   // !MULTI_MON
    while (nvFreeCount < (sizeSetStartMethod + sizeSetData))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetStartMethod + sizeSetData))
    nvglSetStartMethod(nvFifo, nvFreeCount, NV_DD_SPARE, NV054_SET_CONTEXT_DMA_NOTIFIES, 1);
    nvglSetData(nvFifo, nvFreeCount, D3D_NOTIFY_CONTEXT_DMA_TO_MEMORY);
#endif  // !MULTI_MON

    /*
     * Hook up the Dx6 Multi Textured Triangle.
     * System/AGP goes to context A, Video Memory goes to context B.
     */
    while (nvFreeCount < (sizeSetObject + sizeSetDx6TriangleContexts + sizeSetDx6TriangleSurface))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE,
                         (sizeSetObject + sizeSetDx6TriangleContexts + sizeSetDx6TriangleSurface));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_DX6_MULTI_TEXTURE_TRIANGLE);

    /*
     * Both A and B must be valid.
     */
    nvglSetDx6TriangleContexts(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
    nvglSetDx6TriangleSurface(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SURFACES_ARGB_ZS);

    /*
     * Plug in the notify context.
     */
#ifdef  MULTI_MON
    while (nvFreeCount < (sizeSetStartMethod + sizeSetData))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetStartMethod + sizeSetData))
    nvglSetStartMethod(nvFifo, nvFreeCount, NV_DD_SPARE, NV055_SET_CONTEXT_DMA_NOTIFIES, 1);
    nvglSetData(nvFifo, nvFreeCount, NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
#else   // !MULTI_MON
    while (nvFreeCount < (sizeSetStartMethod + sizeSetData))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetStartMethod + sizeSetData))
    nvglSetStartMethod(nvFifo, nvFreeCount, NV_DD_SPARE, NV055_SET_CONTEXT_DMA_NOTIFIES, 1);
    nvglSetData(nvFifo, nvFreeCount, D3D_NOTIFY_CONTEXT_DMA_TO_MEMORY);
#endif  // !MULTI_MON

    /*
     * Hook up the swizzled surface context.
     */
    while (nvFreeCount < (sizeSetObject + sizeSetSwizzledSurfaceContextImage))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetSwizzledSurfaceContextImage));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SURFACE_SWIZZLED);
    nvglSetSwizzledSurfaceContextImage(nvFifo, nvFreeCount, NV_DD_SPARE, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

    /*
     * Hook up the scaled image from memory object.
     * - Set the source image context.
     * - Set the destination surface context.
     * - Set operation
     */
    while (nvFreeCount < sizeSetObject)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeSetObject);
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_SCALED_IMAGE_FROM_MEMORY);

    while (nvFreeCount < sizeSetScaledImageContextImage)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeSetScaledImageContextImage);
    nvglSetScaledImageContextImage(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_LINEAR_TEXTURE_FROM_MEMORY);

    while (nvFreeCount < sizeSetScaledImageContextSurface)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeSetScaledImageContextSurface);
#ifdef DIRECTSWIZZLE
    nvglSetScaledImageContextSurface(nvFifo, nvFreeCount, NV_DD_SPARE, NV_DD_SURFACES_2D);
#else
    nvglSetScaledImageContextSurface(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SURFACE_SWIZZLED);
#endif

    while (nvFreeCount < (sizeSetScaledImageOperation))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetScaledImageOperation));
    nvglSetScaledImageOperation (nvFifo,nvFreeCount,NV_DD_SPARE, NV077_SET_OPERATION_SRCCOPY);

#ifdef HW_PAL8
    /*
     * Initialize Indexed Image from CPU object:
     * - set destination surface
     * - set LUT color format
     * - set index format: 8-bit (256-color palette) or 4-bit (16-color palette))
     * - set operation
     * - set point
     */
    while (nvFreeCount < sizeSetObject)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeSetObject);
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_INDEXED_IMAGE_FROM_CPU);

    // nv05 will be able to write to a swizzled surface. alas nv04 cannot
    //    while (nvFreeCount < sizeSetIndexedImageContextSurface)
    //        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeSetIndexedImageContextSurface);
    //    nvglSetIndexedImageContextSurface(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SURFACE_SWIZZLED);
    while (nvFreeCount < sizeSetIndexedImageContextSurface)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeSetIndexedImageContextSurface);
    nvglSetIndexedImageContextSurface(nvFifo, nvFreeCount, NV_DD_SPARE, NV_DD_SURFACES_2D);

    while (nvFreeCount < sizeSetIndexedImageColorFormat)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeSetIndexedImageColorFormat);
    nvglSetIndexedImageColorFormat(nvFifo,nvFreeCount,NV_DD_SPARE, NV060_SET_COLOR_FORMAT_LE_A8R8G8B8);

    // we only support 8-bit indices for now, so the default is OK here...
    //    while (nvFreeCount < sizeSetIndexedImageIndexFormat)
    //        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeSetIndexedImageIndexFormat);
    //    nvglSetIndexedImageIndexFormat(nvFifo,nvFreeCount,NV_DD_SPARE, NV_060_blahblahblah);

    while (nvFreeCount < (sizeSetIndexedImageOperation))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetIndexedImageOperation));
    nvglSetIndexedImageOperation (nvFifo, nvFreeCount, NV_DD_SPARE, NV060_SET_OPERATION_SRCCOPY);

    while (nvFreeCount < (sizeSetIndexedImagePoint))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetIndexedImagePoint));
    nvglSetIndexedImagePoint (nvFifo, nvFreeCount, NV_DD_SPARE, 0, 0);

    /*
     * Initialize Image from CPU object for moving palettes to video memory:
     * - set destination surface
     * - set opertion
     * - set format
     * - set point
     * - set sizes
     */
    dwCount = sizeSetObject + sizeSetStartMethod + 1*sizeSetData;
    while (nvFreeCount < dwCount)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, dwCount);
    nvglSetObject      (nvFifo, nvFreeCount, NV_DD_SPARE, D3D_IMAGE_FROM_CPU);
    nvglSetStartMethod (nvFifo, nvFreeCount, NV_DD_SPARE, NV061_SET_CONTEXT_SURFACE, 1);
    nvglSetData        (nvFifo, nvFreeCount, NV_DD_SURFACES_2D);  // context surface

    dwCount = sizeSetStartMethod + 2*sizeSetData;
    while (nvFreeCount < dwCount)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, dwCount);
    nvglSetStartMethod (nvFifo, nvFreeCount, NV_DD_SPARE, NV061_SET_OPERATION, 2);
    nvglSetData        (nvFifo, nvFreeCount, NV061_SET_OPERATION_SRCCOPY);  // operation
    nvglSetData        (nvFifo, nvFreeCount, NV061_SET_COLOR_FORMAT_LE_A8R8G8B8);  // format

#endif

    /*
     * Only need to set the operation once. This is only used for clears and those are always srccopy.
     */
    while (nvFreeCount < (sizeSetObject + sizeSetNv4SolidRectangleOperation))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetNv4SolidRectangleOperation));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_RENDER_SOLID_RECTANGLE);
    nvglSetNv4SolidRectangleOperation(nvFifo, nvFreeCount, NV_DD_SPARE, NV05E_SET_OPERATION_SRCCOPY);

    NV_D3D_GLOBAL_SAVE();
    nvFlushDmaBuffers();
    NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
    pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#endif  // CACHE_FREECOUNT
}

void nvD3DDestroyObjects
(
    void
)
{
    /*
     * Destroy Render Solid Rectangle for clearing the z-buffer and rendering surfaces.
     */
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        D3D_RENDER_SOLID_RECTANGLE) != NVOS00_STATUS_SUCCESS)
            return(0);

    /*
     * Destroy Render Solid Rectangle 2
     */
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        D3D_RENDER_SOLID_RECTANGLE_2) != NVOS00_STATUS_SUCCESS)
            return(0);

#ifndef MULTI_MON
    /*
     * Destroy Context Dma To Memory for notifiers.
     */
    while (nvFreeCount < (sizeSetObject + sizeDestroyObject))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeDestroyObject));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, NV_CONTEXT_DMA_TO_MEMORY);
    nvglDestroyObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_NOTIFY_CONTEXT_DMA_TO_MEMORY);

    /*
     * Destroy Context Dma From Memory for the source linear texture.
     * Destroy Context Dma From Memory for swizzled texture heap (PCI/AGP).
     */
    while (nvFreeCount < (sizeSetObject + (sizeDestroyObject * 3)))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeDestroyObject));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, NV_CONTEXT_DMA_FROM_MEMORY);
    nvglDestroyObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_LINEAR_TEXTURE_FROM_MEMORY);
    nvglDestroyObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY);
#endif  // !MULTI_MON

    /*
     * Destroy Scaled Image From Memory object for texture swizzling.
     */
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        D3D_SCALED_IMAGE_FROM_MEMORY) != NVOS00_STATUS_SUCCESS)
            return(0);

    /*
     * Destroy the swizzled surface context.
     */
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        D3D_CONTEXT_SURFACE_SWIZZLED) != NVOS00_STATUS_SUCCESS)
            return(0);

    /*
     * Destroy the ARGB_ZS surface context.
     */
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        D3D_CONTEXT_SURFACES_ARGB_ZS) != NVOS00_STATUS_SUCCESS)
            return(0);

    /*
     * Destroy the DX6 Multi Textured Triangle.
     */
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        D3D_DX6_MULTI_TEXTURE_TRIANGLE) != NVOS00_STATUS_SUCCESS)
            return(0);

    /*
     * Destroy the DX5 Textured Triangle.
     */
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        D3D_DX5_TEXTURED_TRIANGLE) != NVOS00_STATUS_SUCCESS)
            return(0);

    nvTMDestroy();
}
#endif  // NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\DDDRV32.C ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *  Portions Copyright (C) 1995, 1998 NVidia Corporation.  All Rights Reserved.
 *  Portions Copyright (C) 1997 SGS-THOMSON Microelectronics  All Rights Reserved.
 *
 *  File:       dddrv32.c
 *  Content:    sample Windows95 display driver
 *              32 bit DirectDraw part.
 *
 ***************************************************************************/
#ifndef WINNT
#define INITGUID
#endif // #ifndef WINNT
#include "nvd3ddrv.h"
#include "nvcm.h"
#include "nvtypes.h"
#include "nv32.h"
#include "nvddobj.h"
#include "wingdi.h"
#include "dmemmgr.h"

#include "ddrvmem.h"
#include "d3dinc.h"
#include "global.h"
#include "nv4dreg.h"
#include "nv3ddbg.h"
#include "nvheap.h"

#ifdef  MULTI_MON
#include "nvrmapi.h"
#include "nvrmarch.inc"
#endif  /* MULTI_MON */

#define ddHALInfo            pDriverData->HALInfo
//#define OVLCCTL

#define  ST_MAX_VIDEOPORTS   1

GLOBALDATA              *pDriverData;
static HINSTANCE        hInstance;
#ifdef WINNT
SURFACEALIGNMENT    AgpHeapAlignment;
LONG                AgpDummyPitch;
#endif // #ifdef WINNT

/*
 * list of ROPs we support
 *
 * SRCCOPY is the key one to support
 */
static DWORD ropList[] = {
    BLACKNESSBIT | NOTSRCERASEBIT,               // 0x00 - 0x1F
    NOTSRCCOPYBIT,                               // 0x20 - 0x3F
    SRCERASEBIT,                                 // 0x40 - 0x5F
    SRCINVERTBIT,                                // 0x60 - 0x7F
    SRCANDBIT,                                   // 0x80 - 0x9F
    MERGEPAINTBIT,                               // 0xA0 - 0xBF
    SRCCOPYBIT,                                  // 0xC0 - 0xDF
    SRCPAINTBIT | WHITENESSBIT                   // 0xE0 - 0xFF
};


/*
 * IN_VBLANK should be replaced by a test to see if the hardware is currently
 * in the vertical blank
 */
static BOOL     bInVBlank;
static BOOL     bInDisplay;
#define IN_VBLANK               (bInVBlank= !bInVBlank)
#define IN_DISPLAY              (bInDisplay= !bInDisplay)

/*
 * DRAW_ENGINE_BUSY should be replaced by a test to see the bltter is still
 * busy drawing
 */
#define DRAW_ENGINE_BUSY        FALSE

/*
 * ENOUGH_FIFO_FOR_BLT should be replaced with a test to see if there is enough
 * room in the hardware fifo for a blt
 */
#define ENOUGH_FIFO_FOR_BLT     TRUE

/*
 * CURRENT_VLINE should be replaced by a macro to retrieve the current
 * scanline
 */
#define CURRENT_VLINE   0

#ifndef WINNT
FLATPTR EXTERN_DDAPI DDHAL32_VidMemAlloc (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, DWORD dwXDim, DWORD dwYDim);
void EXTERN_DDAPI DDHAL32_VidMemFree (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, FLATPTR ptr);
#endif

extern Nv10ControlDma * __stdcall NvSysOpenDma(char *, int, int, int);
extern DWORD __stdcall NvSysOpen(DWORD);
extern void  __stdcall NvSysClose(DWORD);
extern DWORD __stdcall Blt8bpp32( LPDDHAL_BLTDATA pbd );
extern DWORD __stdcall Blt16bpp32( LPDDHAL_BLTDATA pbd );
extern DWORD __stdcall Blt32bpp32( LPDDHAL_BLTDATA pbd );
extern DWORD NvDDEnable32();
extern DWORD NvDDDisable32();


extern DWORD __stdcall ConvertOverlay32 ( LPDDRAWI_DDRAWSURFACE_LCL, BOOL waitForCompletion);
extern DWORD __stdcall PreScaleOverlay32 ( LPDDRAWI_DDRAWSURFACE_LCL );
extern DWORD __stdcall DestroyFloating422Context32 ( LPDDRAWI_DDRAWSURFACE_LCL );
extern DWORD __stdcall CreateFloating422Context32 ( LPDDRAWI_DDRAWSURFACE_LCL, DWORD dwBlockSize );
extern DWORD __stdcall UpdateOverlay32( LPDDHAL_UPDATEOVERLAYDATA );
extern DWORD __stdcall SetOverlayPosition32( LPDDHAL_SETOVERLAYPOSITIONDATA );

#ifndef WINNT
extern BOOL  __stdcall GetVideoScalerBandwidthStatus32( DWORD );
#endif

extern DWORD __stdcall CanCreateVideoPort32 ( LPDDHAL_CANCREATEVPORTDATA );
extern DWORD __stdcall CreateVideoPort32 ( LPDDHAL_CREATEVPORTDATA );
extern DWORD __stdcall FlipVideoPort32 ( LPDDHAL_FLIPVPORTDATA );
extern DWORD __stdcall GetVideoPortBandwidth32 ( LPDDHAL_GETVPORTBANDWIDTHDATA );
extern DWORD __stdcall GetVideoPortInputFormat32 ( LPDDHAL_GETVPORTINPUTFORMATDATA );
extern DWORD __stdcall GetVideoPortOutputFormat32 ( LPDDHAL_GETVPORTOUTPUTFORMATDATA );
extern DWORD __stdcall GetVideoPortField32 ( LPDDHAL_GETVPORTFIELDDATA );
extern DWORD __stdcall GetVideoPortLine32 ( LPDDHAL_GETVPORTLINEDATA );
extern DWORD __stdcall GetVideoPortConnectInfo ( LPDDHAL_GETVPORTCONNECTDATA );
extern DWORD __stdcall DestroyVideoPort32 ( LPDDHAL_DESTROYVPORTDATA );
extern DWORD __stdcall GetVideoPortFlipStatus32 ( LPDDHAL_GETVPORTFLIPSTATUSDATA );
extern DWORD __stdcall UpdateVideoPort32 ( LPDDHAL_UPDATEVPORTDATA );
extern DWORD __stdcall WaitForVideoPortSync32 ( LPDDHAL_WAITFORVPORTSYNCDATA );
extern DWORD __stdcall GetVideoSignalStatus32 ( LPDDHAL_GETVPORTSIGNALDATA );
extern DWORD HookUpVxdStorage();


#ifdef NVD3D
/*
 * D3D Hal Fcts
 */
extern BOOL __stdcall D3DHALCreateDriver(LPD3DHAL_GLOBALDRIVERDATA *lplpGlobal,
                                  LPD3DHAL_CALLBACKS* lplpHALCallbacks);
extern BOOL __stdcall D3DGetDriverInfo(LPDDHAL_GETDRIVERINFODATA lpData);

extern BOOL DestroyItemArrays(void);
#endif


#ifndef DEBUG
    #define DPF         1 ? (void)0 : (void)
#else
/*
 * Msg
 * Defined in ddsamp.c
 */
extern void __cdecl DPF( LPSTR szFormat, ... );


void __stdcall NvCachedFreeCountError(long freeCount, long correctFreeCount, DWORD *currentBufferAddress)
{
    DPF( "NvCachedFreeCountError: currentFreeCount=%08lx, correctFreeCount=%08lx, currentPutAddress=%08lx", freeCount, correctFreeCount, currentBufferAddress );
}

#endif


/*
 * ResetNV
 *
 * Reset NV after a mode change
 */
DWORD ResetNV()
{

    /* If currently in full screen DOS, don't allow channel to be enabled */
    if (pDriverData->fFullScreenDosOccurred == 2)
        return;

    if (pDriverData->fDDrawFullScreenDosOccurred == 2)
        return;

    if (pDriverData->NvAGPDmaPusherBufferBase != 0) {
        pDriverData->NvDmaPusherBufferBase = pDriverData->NvAGPDmaPusherBufferBase;
    } else if (pDriverData->NvDmaPusherBufferHandle == 0) {
        pDriverData->NvDmaPusherBufferHandle = (DWORD)
            HEAPCREATE(pDriverData->NvDmaPusherBufferSize);
        pDriverData->NvDmaPusherBufferBase = (DWORD)
            HEAPALLOC(pDriverData->NvDmaPusherBufferHandle, pDriverData->NvDmaPusherBufferSize);
    }

    /*
     * This obviously doesn't handle the case where the AGP push buffer gets moved.
     * That case is handled in UpdateNonlocalVidMem32().
     */

    if (pDriverData->dwDmaPusherCtxDmaSize == 0) {
        if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                           NV_DD_DMA_PUSHER_CONTEXT_DMA_FROM_MEMORY,
                           NV01_CONTEXT_DMA,
                           (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                           ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED),
                           (PVOID)pDriverData->NvDmaPusherBufferBase,
                           (pDriverData->NvDmaPusherBufferSize - 1)) != NVOS07_STATUS_SUCCESS)
                                return(FALSE);

        pDriverData->dwDmaPusherCtxDmaSize = pDriverData->NvDmaPusherBufferSize;
    }

    if (pDriverData->NvDevFlatDma == 0) {
        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
            if (NvRmAllocChannelDma(pDriverData->dwRootHandle, NV_WIN_DEVICE,
                                NV_DD_DEV_DMA, NV10_CHANNEL_DMA, 0,
                                NV_DD_DMA_PUSHER_CONTEXT_DMA_FROM_MEMORY, 0,
                                (PVOID)&pDriverData->NvDevFlatDma) != NVOS07_STATUS_SUCCESS)
                                    return(FALSE);
        } else {
            if (NvRmAllocChannelDma(pDriverData->dwRootHandle, NV_WIN_DEVICE,
                                NV_DD_DEV_DMA, NV4_CHANNEL_DMA, 0,
                                NV_DD_DMA_PUSHER_CONTEXT_DMA_FROM_MEMORY, 0,
                                (PVOID)&pDriverData->NvDevFlatDma) != NVOS07_STATUS_SUCCESS)
                                    return(FALSE);
        }

        pDriverData->NvDmaPusherPutAddress = pDriverData->NvDmaPusherBufferBase;
        pDriverData->NvDmaPusherBufferEnd = (long *)
            pDriverData->NvDmaPusherBufferBase + ((pDriverData->NvDmaPusherBufferSize - 4) >> 2);
    }

    if (pDriverData->NvDevVideoFlatPio == 0) {
        if (NvRmAllocChannelPio(pDriverData->dwRootHandle, NV_WIN_DEVICE,
                            NV_DD_DEV_VIDEO, NV3_CHANNEL_PIO, 0,
                            (PVOID)&pDriverData->NvDevVideoFlatPio,
                            ALLOC_CHL_PIO_FLAGS_FIFO_IGNORE_RUNOUT) != NVOS04_STATUS_SUCCESS)
                                return(FALSE);
    }

    pDriverData->wDDrawActive = (WORD)TRUE; // let everyone know DDraw is active

    if (!NvDDEnable32())
        return(FALSE);

    DPF( "    Successfully enabled NV" );

    /* Let D3D code know that we have touched NV */
    pDriverData->TwoDRenderingOccurred = 1;

    pDriverData->DDrawVideoSurfaceCount = 0;

    pDriverData->ddClipUpdate = TRUE;

    // All active floating DMA contexts have been reset
    pDriverData->fNvActiveFloatingContexts = 0;

    // reset overlay source offset
    pDriverData->OverlaySrcX = 0;
    pDriverData->OverlaySrcY = 0;
    pDriverData->OverlayFormat = 0;
    pDriverData->OverlaySrcPitch = 0;
    pDriverData->OverlaySrcSize = 0;

    pDriverData->OverlayBufferIndex = 1;

    /* Make sure overlay owner checking is enabled */
    pDriverData->OverlayRelaxOwnerCheck = 0;

    pDriverData->NvPrevDepth = (BYTE)pDriverData->bi.biBitCount;
    pDriverData->NvFirstCall = 0;

    // Initialize primary surface pointer
    pDriverData->CurrentVisibleSurfaceAddress = pDriverData->BaseAddress;

    // No DMA push blit synchronizations currently in progress
    pDriverData->syncDmaRecord.bSyncFlag = FALSE;

    return(TRUE);
}

#ifndef WINNT
/*
 * SetMode32
 */
DWORD __stdcall SetMode32(
        LPDDHAL_SETMODEDATA lpSetModeData )
{
    HDC hdc = GetDC(0);

    NvSetDriverDataPtr(lpSetModeData->lpDD);

    pDriverData->dwModeIndex = lpSetModeData->dwModeIndex;
    pDriverData->dwUseRefreshRate = lpSetModeData->useRefreshRate;

    // Call back to 16 bit direct draw code to set mode
    ExtEscape(hdc, NVSETDDRAWMODE, 0, 0, 0, 0);

    lpSetModeData->ddRVal = DD_OK;

    return DDHAL_DRIVER_HANDLED;
}
#endif


/*
 * updateFlipStatus
 *
 * checks and sees if the most recent flip has occurred
 */
static __inline HRESULT updateFlipStatus( FLATPTR fpVidMem )
{
    int index;

    /*
     * see if a flip has happened recently
     */
    if (pDriverData->flipPrimaryRecord.bFlipFlag &&
        ((fpVidMem == 0) || (fpVidMem == pDriverData->flipPrimaryRecord.fpFlipFrom)) ) {
        NvNotification *pDmaFlipPrimaryNotifier =
            (NvNotification *)pDriverData->NvDmaFlipPrimaryNotifierFlat;

        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
            if ((pDmaFlipPrimaryNotifier[1].status == NV_IN_PROGRESS) ||
                (pDmaFlipPrimaryNotifier[2].status == NV_IN_PROGRESS))
                return DDERR_WASSTILLDRAWING;
            else {
                pDriverData->CurrentVisibleSurfaceAddress = pDriverData->flipPrimaryRecord.fpFlipTo;
                pDriverData->flipPrimaryRecord.bFlipFlag = FALSE;
                return DD_OK;
            }
        } else {
            NvNotification *pDmaSyncNotifier =
                (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;
            /* pDmaSyncNotifier is used for NOVSYNC flips for devices < NV10 */
            if ((pDmaFlipPrimaryNotifier[1].status == NV_IN_PROGRESS) ||
                 ((pDmaSyncNotifier->status == NV_IN_PROGRESS) &&
                  (pDriverData->fIsBltStyleFlip)))
                return DDERR_WASSTILLDRAWING;
            else {
                pDriverData->CurrentVisibleSurfaceAddress = pDriverData->flipPrimaryRecord.fpFlipTo;
                pDriverData->flipPrimaryRecord.bFlipFlag = FALSE;
                return DD_OK;
            }
        }
    }

    if (pDriverData->flipOverlayRecord.bFlipFlag &&
        ((fpVidMem == 0) || (fpVidMem == pDriverData->flipOverlayRecord.fpFlipFrom)) ) {
        NvNotification *pPioFlipOverlayNotifier =
            (NvNotification *)pDriverData->NvPioFlipOverlayNotifierFlat;

        index = (pDriverData->OverlayBufferIndex ^ 1) + 1;

        if (pPioFlipOverlayNotifier[index].status == NV_IN_PROGRESS)
            return DDERR_WASSTILLDRAWING;
        else {
            pDriverData->flipOverlayRecord.bFlipFlag = FALSE;
            return DD_OK;
        }
    }

    return DD_OK;

} /* updateFlipStatus */


#ifndef WINNT
/*
 * getDisplayDuration
 *
 * get the length (in ticks) of a refresh cycle
 */
static void getDisplayDuration( void )
{
    int         i;
    __int64     start, end;
    DWORD       oldclass;
    HANDLE      hprocess;

    memset( &pDriverData->flipPrimaryRecord, 0, sizeof( pDriverData->flipPrimaryRecord ) );
    memset( &pDriverData->flipOverlayRecord, 0, sizeof( pDriverData->flipOverlayRecord ) );

    hprocess = GetCurrentProcess();
    oldclass = GetPriorityClass( hprocess );
//    SetPriorityClass( hprocess, REALTIME_PRIORITY_CLASS ); Can't do this due to Electronic Arts bug in Triple Play 97
    SetPriorityClass( hprocess, HIGH_PRIORITY_CLASS );

    NvConfigSet(NV_CFG_VBLANK_TOGGLE, 1, pDriverData->dwDeviceIDNum);
    while (NvConfigGet(NV_CFG_VBLANK_TOGGLE, pDriverData->dwDeviceIDNum)); // wait for next vertical blank to happen
    QueryPerformanceCounter((LARGE_INTEGER*)&start);
    #define LOOP_CNT    20
    for( i=0;i<LOOP_CNT;i++ ) {
        NvConfigSet(NV_CFG_VBLANK_TOGGLE, 1, pDriverData->dwDeviceIDNum);
        while (NvConfigGet(NV_CFG_VBLANK_TOGGLE, pDriverData->dwDeviceIDNum)); // wait for next vertical blank to happen
    }
    QueryPerformanceCounter((LARGE_INTEGER*)&end);

    SetPriorityClass( hprocess, oldclass );
    pDriverData->flipPrimaryRecord.dwFlipDuration = ((DWORD)(end-start) + LOOP_CNT/2)/LOOP_CNT;
    pDriverData->HALInfo.dwMonitorFrequency = (DWORD)start / pDriverData->flipPrimaryRecord.dwFlipDuration;

#ifdef DEBUG
    QueryPerformanceFrequency((LARGE_INTEGER*)&start);

    DPF( "Duration = %d ticks, %dms, %dHz",
        pDriverData->flipPrimaryRecord.dwFlipDuration,
        pDriverData->flipPrimaryRecord.dwFlipDuration * 1000 / (DWORD)start,
        (DWORD)start / pDriverData->flipPrimaryRecord.dwFlipDuration);
#endif
} /* getDisplayDuration */
#endif  // #ifndef WINNT



/*
 * GetBltStatus32
 */
DWORD __stdcall GetBltStatus32(LPDDHAL_GETBLTSTATUSDATA lpGetBltStatus )
{
    FAST Nv10ControlDma *npDev;
    NvNotification      *pDmaSyncNotifier;
    unsigned long       *dmaPusherPutAddress;
    unsigned long       *dmaPusherBufferBase;
    long                freeCount = 0;

    NvSetDriverDataPtr(lpGetBltStatus->lpDD);

    pDmaSyncNotifier = (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;
    dmaPusherPutAddress = (unsigned long *)pDriverData->NvDmaPusherPutAddress;
    dmaPusherBufferBase = (unsigned long *)pDriverData->NvDmaPusherBufferBase;

    /*
     * CANBLT: can we add a blt?
     */
    if( lpGetBltStatus->dwFlags == DDGBS_CANBLT ) {
        /*
         * make sure that we've flipped away from the destination surface
         */
        lpGetBltStatus->ddRVal = updateFlipStatus(
                        lpGetBltStatus->lpDDSurface->lpGbl->fpVidMem );

        if( lpGetBltStatus->ddRVal == DD_OK ) {

            npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

            if (npDev == NULL) {
                if (!ResetNV()) {
                    lpGetBltStatus->ddRVal = DDERR_GENERIC;
                    return DDHAL_DRIVER_HANDLED;
                }

                dmaPusherPutAddress = (unsigned long *)pDriverData->NvDmaPusherPutAddress;
                        pDriverData->fReset = FALSE;
                npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

                if (npDev == NULL) {
                    lpGetBltStatus->ddRVal = DDERR_SURFACELOST;
                    return DDHAL_DRIVER_HANDLED;
                }
            }

            /*
             * so there was no flip going on, is there room in the fifo
             * to add a blt?
             */

            NV_DD_DMA_PUSHER_SYNC();

            NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);

            /* Must save pointer in case it was changed by above macro */
            pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

            pDriverData->dwDmaPusherFreeCount = freeCount;

            if(freeCount < 10) {
                lpGetBltStatus->ddRVal = DDERR_WASSTILLDRAWING;
                return DDHAL_DRIVER_HANDLED;
            } else {
                lpGetBltStatus->ddRVal = DD_OK;
            }
        }
    } else {

    /*
     * DONEBLT: is a blt in progress?
     */

        /* Some apps call GetBltStatus many times after calling Blit even after they were told that it was done */
        if (pDriverData->blitCalled == FALSE) {
            lpGetBltStatus->ddRVal = DD_OK;
            return DDHAL_DRIVER_HANDLED;
        }

        npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

        if (npDev == NULL) {
            if (!ResetNV()) {
                lpGetBltStatus->ddRVal = DDERR_GENERIC;
                return DDHAL_DRIVER_HANDLED;
            }

            dmaPusherPutAddress = (unsigned long *)pDriverData->NvDmaPusherPutAddress;
                pDriverData->fReset = FALSE;
            npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

            if (npDev == NULL) {
                lpGetBltStatus->ddRVal = DDERR_SURFACELOST;
                return DDHAL_DRIVER_HANDLED;
            }
        }

        /* If a texture surface then just wait for notifier */
        if (lpGetBltStatus->lpDDSurface->ddsCaps.dwCaps & DDSCAPS_TEXTURE) {

            NV_DD_DMA_PUSHER_SYNC();

            /* Let D3D code know that we have touched NV */
            pDriverData->TwoDRenderingOccurred = 1;

#ifdef  CACHE_FREECOUNT
            freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
            NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
            freeCount = 0;
#endif  /* CACHE_FREECOUNT */

            while (freeCount < 4)
                NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
            freeCount -= 4;

            pDmaSyncNotifier->status = NV_IN_PROGRESS;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = 0;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
            dmaPusherPutAddress[3] = 0;

            dmaPusherPutAddress += 4;

            pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

            /* Force write combine buffer to flush */
            pDriverData->NvDmaPusherBufferEnd[0] = 0;
            /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
            _outp (0x3d0,0);

            pDriverData->dwDmaPusherFreeCount = freeCount;

            npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

            lpGetBltStatus->ddRVal = DD_OK;

            return DDHAL_DRIVER_HANDLED;
        }


        /* Is there a DMA push blit synchronization in progress ? */
        if (pDriverData->syncDmaRecord.bSyncFlag) { /* if so then check status */
            if (pDmaSyncNotifier->status == NV_IN_PROGRESS)
                lpGetBltStatus->ddRVal = DDERR_WASSTILLDRAWING;
            else {
                lpGetBltStatus->ddRVal = DD_OK;
                pDriverData->syncDmaRecord.bSyncFlag = FALSE;
                pDriverData->blitCalled = FALSE;
            }
        } else { /* start a blit synchronization sequence */
            pDriverData->syncDmaRecord.bSyncFlag = TRUE;

            NV_DD_DMA_PUSHER_SYNC();

            /* Let D3D code know that we have touched NV */
            pDriverData->TwoDRenderingOccurred = 1;

#ifdef  CACHE_FREECOUNT
            freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
            NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
            freeCount = 0;
#endif  /* CACHE_FREECOUNT */

            while (freeCount < 4)
                NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
            freeCount -= 4;

            pDmaSyncNotifier->status = NV_IN_PROGRESS;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = 0;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
            dmaPusherPutAddress[3] = 0;

            dmaPusherPutAddress += 4;

            pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

            /* Force write combine buffer to flush */
            pDriverData->NvDmaPusherBufferEnd[0] = 0;
            /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
            _outp (0x3d0,0);

            pDriverData->dwDmaPusherFreeCount = freeCount;

            npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

            if (pDmaSyncNotifier->status == NV_IN_PROGRESS)
                lpGetBltStatus->ddRVal = DDERR_WASSTILLDRAWING;
            else {
                lpGetBltStatus->ddRVal = DD_OK;
                pDriverData->syncDmaRecord.bSyncFlag = FALSE;
                pDriverData->blitCalled = FALSE;
            }
        }
    }

    return DDHAL_DRIVER_HANDLED;

} /* GetBltStatus32 */



/*
 * Blit32
 *
 * 32-bit Blt function for all surfaces.
 *
 * Stupid callback table is built before mode is changed so we never know
 * which function to call until after mode is changed.
 */
DWORD __stdcall Blit32( LPDDHAL_BLTDATA pbd )
{
    FAST Nv10ControlDma *npDev;
    HRESULT     ddrval;

    NvSetDriverDataPtr(pbd->lpDD);

    /*
     * This needs to be here for cases where the channel has closed due to
     * a mode switch or some other reason when there is a pending notification
     * which gets lost due to the channel closure.   ResetNV will deal
     * with clearing the pending notifier.
     */

    npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

    if (npDev == NULL) {
        if (!ResetNV()) {
            pbd->ddRVal = DDERR_GENERIC;
            return DDHAL_DRIVER_HANDLED;
        }

        pDriverData->fReset = FALSE;
        npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

        if (npDev == NULL) {
            pbd->ddRVal = DDERR_SURFACELOST;
            return DDHAL_DRIVER_HANDLED;
        }
    }

#ifdef NV_TEX2
    /*
     * texture manager wants full control before all the sync points below
     * it will check for these in time to not break
     */
    if (pbd->lpDDDestSurface->ddsCaps.dwCaps & DDSCAPS_TEXTURE)
    {
        return nvTextureBlt(pbd);
    }
#endif // NV_TEX2

    /*
     * is a flip in progress?
     */
#ifndef DX7
    // DX7 requires that Blit() NEVER return DDERR_WASSTILLDRAWING
    ddrval = updateFlipStatus(pbd->lpDDDestSurface->lpGbl->fpVidMem);
    if( ddrval != DD_OK ) {
        if (pbd->dwFlags & DDBLT_WAIT) {
           while (ddrval != DD_OK) {
               NV_SLEEPFLIP;
               ddrval = updateFlipStatus(pbd->lpDDDestSurface->lpGbl->fpVidMem);
           }
        } else {
           pbd->ddRVal = ddrval;
           return DDHAL_DRIVER_HANDLED;
        }
    }
#endif  // DX7

    pDriverData->blitCalled = TRUE;

    /*
     * Make sure push buffer idle.
     */
    NV_DD_DMA_PUSHER_SYNC();


    /*
     * yet another d3d aa semntics hack
     */
    {
        //pCurrentContext = (PNVD3DCONTEXT)pbd->dwhContext;
        // we depend on pCurrentContext to point to the last used context
        // this may fail if pCurrentContext is not valid
        if ((pCurrentContext)
         && (pCurrentContext->dwAntiAliasFlags & AA_ENABLED_MASK)
         && (pCurrentContext->dwAntiAliasFlags & AA_IN_SCENE))
        {
            NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
            nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
            NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetRenderTargetContexts + sizeSetRenderTarget));
#endif  // CACHE_FREECOUNT
            nvAARenderPrimitive();
            pCurrentContext->dwAntiAliasFlags |= AA_COPY_SCREEN;
            NV_D3D_GLOBAL_SAVE();
        }
    }

    if (pDriverData->bi.biBitCount == 8) {
        return(Blt8bpp32(pbd));
    } else if (pDriverData->bi.biBitCount == 16) {
        return(Blt16bpp32(pbd));
    } else {
        return(Blt32bpp32(pbd));
    }

} /* Blit32 */


/*
 * GetFlipStatus32
 *
 */
DWORD __stdcall GetFlipStatus32(LPDDHAL_GETFLIPSTATUSDATA lpGetFlipStatus )
{
    Nv10ControlDma *npDev;
    DWORD fpVidMem;

    NvSetDriverDataPtr(lpGetFlipStatus->lpDD);

    fpVidMem = lpGetFlipStatus->lpDDSurface->lpGbl->fpVidMem;

    lpGetFlipStatus->ddRVal = updateFlipStatus(fpVidMem);

    npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

    if (npDev == NULL) {
        lpGetFlipStatus->ddRVal = DDERR_SURFACELOST;
    } else {
        if (lpGetFlipStatus->dwFlags & (DDGFS_CANFLIP | DDGFS_ISFLIPDONE)) {
            NvNotification *pDmaFlipPrimaryNotifier =
                (NvNotification *)pDriverData->NvDmaFlipPrimaryNotifierFlat;

            if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
                if (((pDmaFlipPrimaryNotifier[1].status == NV_IN_PROGRESS) ||
                     (pDmaFlipPrimaryNotifier[2].status == NV_IN_PROGRESS)) &&
                     ((fpVidMem == pDriverData->flipPrimaryRecord.fpFlipFrom) ||
                      (fpVidMem == pDriverData->flipPrimaryRecord.fpFlipTo)))
                        lpGetFlipStatus->ddRVal = DDERR_WASSTILLDRAWING;
            } else {
                NvNotification *pDmaSyncNotifier =
                    (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;
                /* pDmaSyncNotifier is used for NOVSYNC flips for devices < NV10 */
                if (((fpVidMem == pDriverData->flipPrimaryRecord.fpFlipFrom) ||
                     (fpVidMem == pDriverData->flipPrimaryRecord.fpFlipTo)) &&
                     ((pDmaFlipPrimaryNotifier[1].status == NV_IN_PROGRESS) ||
                     ((pDriverData->fIsBltStyleFlip) &&
                      (pDmaSyncNotifier->status == NV_IN_PROGRESS))))
                        lpGetFlipStatus->ddRVal = DDERR_WASSTILLDRAWING;
            }
        }

        /*
         * Check if the push buffer is busy if someone wants to know if they can flip
         */

        if (lpGetFlipStatus->dwFlags & DDGFS_CANFLIP) {

            if (lpGetFlipStatus->ddRVal == DD_OK) {
                unsigned long *dmaPusherPutAddress =
                    (unsigned long *)pDriverData->NvDmaPusherPutAddress;
                unsigned long *dmaPusherBufferBase =
                    (unsigned long *)pDriverData->NvDmaPusherBufferBase;

                NV_DD_DMA_PUSHER_SYNC();

                /* Give the application a chance to do something else if push buffer isn't empty yet */
                if (npDev->Get != (unsigned long)(dmaPusherPutAddress - dmaPusherBufferBase) << 2) {
                    /* Force write combine buffer to flush */
                    pDriverData->NvDmaPusherBufferEnd[0] = 0;
                    /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                    _outp (0x3d0,0);
                    npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                    lpGetFlipStatus->ddRVal = DDERR_WASSTILLDRAWING;
                }
            }
        }
    }

    return DDHAL_DRIVER_HANDLED;

} /* GetFlipStatus32 */


// ------------------------------------------------------------------------------------------
// YUV422ColourControl
//      Simulates colour controls on YUV422 surfaces.  So far only supports contrast.
//      Returns TRUE if success
#ifndef OVLCCTL
#define YUV422ColourControl(a,b)
#else
BOOL __stdcall YUV422ColourControl(LPDDRAWI_DDRAWSURFACE_GBL lpGbl, LPDDCOLORCONTROL lpDDCC)
{
//FAST Nv10ControlDma *npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;
//unsigned long *dmaPusherPutAddress = (unsigned long *)pDriverData->NvDmaPusherPutAddress;
//unsigned long *dmaPusherBufferBase = (unsigned long *)pDriverData->NvDmaPusherBufferBase;
//long freeCount = 0;
DDPIXELFORMAT *lpPixelFormat = &lpGbl->ddpfSurface;
DWORD overlayFourCC = 0;
DWORD dwContrast;
DWORD  dwOffset = (DWORD)lpGbl->fpVidMem - (DWORD)pDriverData->BaseAddress;
FAST Nv3ChannelPio *npDevVideo = (Nv3ChannelPio *)pDriverData->NvDevVideoFlatPio;
FAST long videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);

    if (lpPixelFormat->dwSize == sizeof(DDPIXELFORMAT) && (lpPixelFormat->dwFlags & DDPF_FOURCC))
        overlayFourCC = lpPixelFormat->dwFourCC;
    if (overlayFourCC == MAKEFOURCC('Y','U','Y','2'))
        dwContrast = lpDDCC->lContrast | (lpDDCC->lContrast << 16) | 0xFF00FF00;
    else if (overlayFourCC == MAKEFOURCC('U','Y','V','Y'))
        dwContrast = (lpDDCC->lContrast << 8) | (lpDDCC->lContrast << 24) | 0x00FF00FF;
    else dwContrast = 0xFFFFFFFF;

    if (dwContrast == 0xFFFFFFFF) return FALSE;

    while (videoFreeCount < 48)
        videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);
    videoFreeCount -= 48;

    /* Trash spare subchannel */
    npDevVideo->dDrawSpare.SetObject = NV_DD_CONTEXT_BETA4;
    npDevVideo->dDrawSpare.nv4ContextBeta.SetBetaFactor = dwContrast;
    npDevVideo->dDrawSpare.SetObject = NV_DD_SURFACES_2D_A8R8G8B8;
    npDevVideo->dDrawSpare.nv4ContextSurfaces2D.SetPitch = (lpGbl->lPitch << 16) | lpGbl->lPitch;
    npDevVideo->dDrawSpare.nv4ContextSurfaces2D.SetOffsetSource = dwOffset;
    npDevVideo->dDrawSpare.nv4ContextSurfaces2D.SetOffsetDestin = dwOffset;
    npDevVideo->dDrawSpare.SetObject = NV_DD_SRCCOPY_PREMULT_A8R8G8B8_IMAGE_BLIT;
    npDevVideo->dDrawSpare.nv4ImageBlit.ControlPointIn = 0;
    npDevVideo->dDrawSpare.nv4ImageBlit.ControlPointOut = 0;
    npDevVideo->dDrawSpare.nv4ImageBlit.Size = (lpGbl->wHeight << 16) | (lpGbl->wWidth >> 1);

    pDriverData->dDrawSpareSubchannelObject = 0;

    /* Force fifo to stall until blit operation finishes */
    npDevVideo->dDrawSpare.nv4ImageBlit.Notify = 0;
    npDevVideo->dDrawSpare.nv4ImageBlit.NoOperation = 0;

    return TRUE;
}
#endif

/*
 * Flip32
 *
 * Flip RGB or overlay surfaces.
 *
 * NOTES:
 *
 * When flipping overlay surfaces NOT associated with a video port
 * the surface will be flipped according to the following criteria.
 * DDOVER_INTERLEAVED and DDOVER_BOB values used are those set on most
 * recent UpdateOverlay32 call referencing this overlay surface.
 *
 *  DDOVER_INTERLEAVED  DDOVER_BOB  DDFLIP_EVEN DDFLIP_ODD  DISPLAYED
 *
 *          1               1            1          0       Even field
 *          1               1            X          1       Odd field with BOB
 *          1               1            0          0       Full interleaved surface
 *          1               0            1          0       Even field
 *          1               0            X          1       Odd field
 *          1               0            0          0       Full interleaved surface
 *          0               1            X          X       Full non-interleaved surface
 *          0               0            X          X       Full non-interleaved surface
 *
 */

DWORD __stdcall Flip32(  LPDDHAL_FLIPDATA pfd )
{
    FAST Nv10ControlDma         *npDev;
    NvNotification              *pDmaFlipPrimaryNotifier;
    NvNotification              *pPioFlipOverlayNotifier;
    NvNotification              *pDmaSyncNotifier;
    NvNotification              *pDmaDmaFromMemNotifier;
    HRESULT                     ddrval;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurfTarg_gbl;
    BOOL                        bIsD3D;
    BOOL                        waitForVsync = TRUE;

    NvSetDriverDataPtr(pfd->lpDD);

    npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;
    pDmaFlipPrimaryNotifier = (NvNotification *)pDriverData->NvDmaFlipPrimaryNotifierFlat;
    pPioFlipOverlayNotifier = (NvNotification *)pDriverData->NvPioFlipOverlayNotifierFlat;
    pDmaSyncNotifier = (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;
    pDmaDmaFromMemNotifier = (NvNotification *)pDriverData->NvDmaDmaFromMemNotifierFlat;

    /*
     * NOTES:
     *
     * This callback is invoked whenever we are about to flip to from
     * one surface to another.   pfd->lpSurfCurr is the surface we were at,
     * pfd->lpSurfTarg is the one we are flipping to.
     *
     * You should point the hardware registers at the new surface, and
     * also keep track of the surface that was flipped away from, so
     * that if the user tries to lock it, you can be sure that it is done
     * being displayed
     */

    DPF_LEVEL(NVDBG_LEVEL_FLIP,"Flip32: curr=%08lx, targ=%08lx", pfd->lpSurfCurr, pfd->lpSurfTarg );
    DPF_LEVEL(NVDBG_LEVEL_FLIP,"        vidmem ptrs change: %08lx->%08lx",
                                        pfd->lpSurfCurr->lpGbl->fpVidMem,
                                        pfd->lpSurfTarg->lpGbl->fpVidMem );

    /*
     * D3D: no VSync will insert a Blt and exit
     */
    bIsD3D = (pfd->lpSurfTarg->ddsCaps.dwCaps & DDSCAPS_3DDEVICE)
          && (pfd->lpSurfCurr->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
          && (pfd->lpSurfCurr->ddsCaps.dwCaps & DDSCAPS_3DDEVICE);

    if ((((pDriverData->regD3DEnableBits1 & REG_BIT1_NO_WAIT_4_VSYNC) && bIsD3D)) ||
          (pfd->dwFlags & DDFLIP_NOVSYNC)) {

        /* DDFLIP_NOVSYNC flips must be restricted to normal frame depth count */
        if ((pfd->dwFlags & DDFLIP_NOVSYNC) &&
            (pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10)) {

            ddrval = updateFlipStatus(0);

            if (ddrval != DD_OK) {
                if (pfd->dwFlags & DDFLIP_WAIT) {
                    while (ddrval != DD_OK) {
                                        NV_SLEEPFLIP;
                        ddrval = updateFlipStatus(0);
                    }
                } else {
                    pfd->ddRVal = ddrval;
                    return DDHAL_DRIVER_HANDLED;
                }
            }
        }

        /*
         * Check how many frames we are ahead
         *  we want to limit this since we have serious lag effect on fast CPUs
         */
        // free count for d3d stuff must be accurate
#ifndef NV_NULL_HW_DRIVER
        {
            NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
            nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
            NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, 1);
#endif  /* CACHE_FREECOUNT */

            if ((int)(pDriverData->dwCurrentFrame - pDriverData->dwRenderedFrame) > pDriverData->regPreRenderLimit)
            {
                nvStartDmaBuffer (FALSE);
                /*
                 * if we do not have to wait here - don't
                 */
                /* it does not seem to work - some apps just fail to call Flip again
                if (!(pfd->dwFlags & DDFLIP_WAIT))
                {
                    pfd->ddRVal = DDERR_WASSTILLDRAWING;
                    return DDHAL_DRIVER_HANDLED;
                }
                */
                /*
                 * wait for HW to catch up
                 */
#ifdef NV_PROFILE
                NVP_START(NVP_T_FLIP);
#endif

                do
                {
                    NV_DELAY;
#ifndef WINNT
                  pDriverData->dwRenderedFrame = *(DWORD*)(pDriverData->dwTMPseudoNotifierOffset + NV_PN_SPOOFED_FLIP_COUNT + pDriverData->BaseAddress);
#else
                  pDriverData->dwRenderedFrame = *(DWORD*)(pDriverData->dwTMPseudoNotifierOffset + NV_PN_SPOOFED_FLIP_COUNT + (ULONG) pDriverData->ppdev->pjScreen);
#endif // #ifdef WINNT

                } while ((int)(pDriverData->dwCurrentFrame - pDriverData->dwRenderedFrame) > pDriverData->regPreRenderLimit);

#ifdef NV_PROFILE
                NVP_STOP(NVP_T_FLIP);
                nvpLogTime(NVP_T_FLIP,nvpTime[NVP_T_FLIP]);
#endif
            }
            /*
             * Update frame counters
             */
            pDriverData->dwCurrentFrame++;
            if (!pDriverData->dwCurrentFrame) { pDriverData->dwCurrentFrame = pDriverData->dwRenderedFrame = 0; } // wrap around case
            nvPlacePsuedoNotifier (NV_PN_SPOOFED_FLIP_COUNT,pDriverData->dwCurrentFrame);
            NV_D3D_GLOBAL_SAVE();
#ifdef  CACHE_FREECOUNT
            pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
            NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  /* CACHE_FREECOUNT */
        }
#endif  //!NV_NULL_HW_DRIVER


        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
            waitForVsync = FALSE;
        } else {
            /*
             * Do the Blt
             */
            DWORD  dwSrcOffset =  (DWORD)VIDMEM_OFFSET(pfd->lpSurfTarg->lpGbl->fpVidMem);
            DWORD  dwDstOffset =  (DWORD)VIDMEM_OFFSET(pfd->lpSurfCurr->lpGbl->fpVidMem);
            DWORD  dwPitch     = (pfd->lpSurfTarg->lpGbl->lPitch  << 16) | pfd->lpSurfCurr->lpGbl->lPitch;
            DWORD  dwDims      = (pfd->lpSurfCurr->lpGbl->wHeight << 16) | pfd->lpSurfCurr->lpGbl->wWidth;
            unsigned long *dmaPusherPutAddress =
                (unsigned long *)pDriverData->NvDmaPusherPutAddress;
            unsigned long *dmaPusherBufferBase =
                (unsigned long *)pDriverData->NvDmaPusherBufferBase;
#ifdef  CACHE_FREECOUNT
            long freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
            NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
            long freeCount = 0;
#endif  /* CACHE_FREECOUNT */

            if (pDriverData->dwSharedClipChangeCount != pDriverData->dwDDMostRecentClipChangeCount) {

                while (freeCount < 7)
                    NvGetDmaBufferFreeCount(npDev, freeCount, 7, dmaPusherPutAddress);
                freeCount -= 7;

                dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
                dmaPusherPutAddress[1] = NV_DD_IMAGE_BLACK_RECTANGLE;
                dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                    IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000;
                dmaPusherPutAddress[3] = 0;
                dmaPusherPutAddress[4] = asmMergeCoords(NV_MAX_X_CLIP, NV_MAX_Y_CLIP);
                dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
                dmaPusherPutAddress[6] = NV_DD_SURFACES_2D;

                dmaPusherPutAddress += 7;

                pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                /* Force write combine buffer to flush */
                pDriverData->NvDmaPusherBufferEnd[0] = 0;
                /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                _outp (0x3d0,0);

                pDriverData->dwDmaPusherFreeCount = freeCount;

                npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                pDriverData->dwSharedClipChangeCount++;

                pDriverData->dwDDMostRecentClipChangeCount = pDriverData->dwSharedClipChangeCount;
            }

            while (freeCount < 10)
                NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
            freeCount -= 10;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                SET_ROP_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = SRCCOPYINDEX;

            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_PITCH_OFFSET | 0xC0000;
            dmaPusherPutAddress[3] = dwPitch;
            dmaPusherPutAddress[4] = dwSrcOffset;
            dmaPusherPutAddress[5] = dwDstOffset;

            dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_BLIT) +
                BLIT_POINT_IN_OFFSET | 0xC0000;
            dmaPusherPutAddress[7] = 0;
            dmaPusherPutAddress[8] = 0;
            dmaPusherPutAddress[9] = dwDims;

            dmaPusherPutAddress += 10;

            if (pfd->dwFlags & DDFLIP_NOVSYNC) {

                pDriverData->flipPrimaryRecord.fpFlipFrom = pfd->lpSurfCurr->lpGbl->fpVidMem;
                pDriverData->flipPrimaryRecord.fpFlipTo = pfd->lpSurfTarg->lpGbl->fpVidMem;

                pDriverData->flipPrimaryRecord.bFlipFlag = TRUE;

                pDriverData->fIsBltStyleFlip = TRUE;

                pDmaSyncNotifier->status = NV_IN_PROGRESS;

                while (freeCount < 4)
                    NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
                freeCount -= 4;

                dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                    RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
                dmaPusherPutAddress[1] = 0;
                dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                    RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
                dmaPusherPutAddress[3] = 0;

                dmaPusherPutAddress += 4;
            }

            pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

            /* Force write combine buffer to flush */
            pDriverData->NvDmaPusherBufferEnd[0] = 0;
            /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
            _outp (0x3d0,0);

            pDriverData->dwDmaPusherFreeCount = freeCount;

            npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

            /*
             * flip the vidmem pointers (so ddraw can flip them back)
             */
            pfd->lpSurfCurr->lpGbl->fpVidMem = dwSrcOffset + (DWORD)pDriverData->BaseAddress;
            pfd->lpSurfTarg->lpGbl->fpVidMem = dwDstOffset + (DWORD)pDriverData->BaseAddress;

            /*
             * done
             */
            pfd->ddRVal = DD_OK;
            return DDHAL_DRIVER_HANDLED;
        }
    }

    /*
     * everything is OK, do the flip here
     */

    pDriverData->fIsBltStyleFlip = FALSE;

    pSurfTarg_gbl = pfd->lpSurfTarg->lpGbl;

    pDriverData->flipPrimaryRecord.bIsD3DSurface = FALSE;

    /* Is this an overlay surface ? */
    if (!(pfd->lpSurfTarg->ddsCaps.dwCaps & (DDSCAPS_OVERLAY | DDSCAPS_VIDEOPORT))) {
        /* No - assume it is the primary surface */
        unsigned long *dmaPusherPutAddress =
            (unsigned long *)pDriverData->NvDmaPusherPutAddress;
        unsigned long *dmaPusherBufferBase =
            (unsigned long *)pDriverData->NvDmaPusherBufferBase;
#ifdef  CACHE_FREECOUNT
        long freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
        long freeCount = 0;
#endif  /* CACHE_FREECOUNT */

#ifdef NV_PROFILE
        NVP_START(NVP_T_FLIP);
#endif

#ifdef FORCED_TRIPLE_BUFFER
        if (pDriverData->bNeedToAttachBuffer) {
            HRESULT result;
            IDirectDrawSurface *lpSurfPrimary_int = (IDirectDrawSurface *) pfd->lpDD->lpExclusiveOwner->lpPrimary;
            if (lpSurfPrimary_int) {
                result = IDirectDrawSurface_AddAttachedSurface(lpSurfPrimary_int, pDriverData->lpBuffer3);
                if (result != DD_OK) {
                    IDirectDrawSurface_Release(pDriverData->lpBuffer3);
                    pDriverData->lpBuffer3 = NULL;
                }
            }
            pDriverData->bNeedToAttachBuffer = FALSE;
        }
#endif // FORCED_TRIPLE_BUFFER

        ddrval = updateFlipStatus(0);

        if (ddrval != DD_OK) {
            /* Flush DMA push buffer on first Flip call regardless of current flip status */
            if (!(pDriverData->fDmaPushBufferHasBeenFlushed)) {

                /*
                 * is NV busy right now?
                 */
                NV_DD_DMA_PUSHER_SYNC();

                /* Optimize flip waits for D3D rendered surfaces. */
                pDriverData->flipPrimaryRecord.bIsD3DSurface = bIsD3D;

                if (npDev == NULL) {
                    pfd->ddRVal = DDERR_SURFACELOST;
                    return DDHAL_DRIVER_HANDLED;
                }

                while (freeCount < 4)
                    NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
                freeCount -= 4;

                /* Let D3D code know that we have touched NV */
                pDriverData->TwoDRenderingOccurred = 1;

                pDmaSyncNotifier->status = NV_IN_PROGRESS;

                dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                    RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
                dmaPusherPutAddress[1] = 0;
                dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                    RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
                dmaPusherPutAddress[3] = 0;

                dmaPusherPutAddress += 4;

                pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                /* Force write combine buffer to flush */
                pDriverData->NvDmaPusherBufferEnd[0] = 0;
                /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                _outp (0x3d0,0);

                pDriverData->dwDmaPusherFreeCount = freeCount;

                npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                pDriverData->fDmaPushBufferHasBeenFlushed = TRUE;
            }

            if (pfd->dwFlags & DDFLIP_WAIT) {
                while (ddrval != DD_OK) {
                    NV_SLEEPFLIP;
                    ddrval = updateFlipStatus(0);
                }
            } else {
                pfd->ddRVal = ddrval;
                return DDHAL_DRIVER_HANDLED;
            }
        }

        /*
         * is NV busy right now?
         */
        NV_DD_DMA_PUSHER_SYNC();

#ifdef NV_PROFILE
        NVP_STOP(NVP_T_FLIP);
        nvpLogTime(NVP_T_FLIP,nvpTime[NVP_T_FLIP]);
#endif

        /* Optimize flip waits for D3D rendered surfaces. */
        /*
        if (pSurfTarg_gbl->fpVidMem == pDriverData->lpLast3DSurfaceRendered)
            pDriverData->flipPrimaryRecord.bIsD3DSurface = TRUE;
        */
        pDriverData->flipPrimaryRecord.bIsD3DSurface = bIsD3D;

        if (npDev == NULL) {
            pfd->ddRVal = DDERR_SURFACELOST;
            return DDHAL_DRIVER_HANDLED;
        }

        while (freeCount < 4)
            NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
        freeCount -= 4;

        /* Let D3D code know that we have touched NV */
        pDriverData->TwoDRenderingOccurred = 1;

        pDmaSyncNotifier->status = NV_IN_PROGRESS;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
            RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
        dmaPusherPutAddress[1] = 0;
        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
            RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
        dmaPusherPutAddress[3] = 0;

        dmaPusherPutAddress += 4;

        pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

        pDriverData->flipPrimaryRecord.fpFlipFrom = pfd->lpSurfCurr->lpGbl->fpVidMem;
        pDriverData->flipPrimaryRecord.fpFlipTo = pSurfTarg_gbl->fpVidMem;

        pDriverData->flipPrimaryRecord.bFlipFlag = TRUE;

        pDriverData->primaryBufferIndex ^= 1;

        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {

            pDmaFlipPrimaryNotifier[pDriverData->primaryBufferIndex + 1].status = NV_IN_PROGRESS;

            /* Temporarily load VIDEO_LUT_CURSOR_DAC object */
            while (freeCount < 7)
                NvGetDmaBufferFreeCount(npDev, freeCount, 7, dmaPusherPutAddress);
            freeCount -= 7;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
            dmaPusherPutAddress[1] = NV_DD_VIDEO_LUT_CURSOR_DAC;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                NV067_SET_IMAGE_OFFSET(pDriverData->primaryBufferIndex) | 0x80000;
            dmaPusherPutAddress[3] = pSurfTarg_gbl->fpVidMem - pDriverData->BaseAddress;
            if (waitForVsync)
                dmaPusherPutAddress[4] = (NV067_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY << 31) ||
                                         (NV067_SET_IMAGE_FORMAT_WHEN_NOT_WITHIN_BUFFER << 20) ||
                                         pSurfTarg_gbl->lPitch;
            else
                dmaPusherPutAddress[4] = (NV067_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY << 31) ||
                                         (NV067_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY << 20) ||
                                         pSurfTarg_gbl->lPitch;
            dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
            dmaPusherPutAddress[6] = NV_DD_SURFACES_2D;

            dmaPusherPutAddress += 7;

        } else {

            pDmaFlipPrimaryNotifier[1].status = NV_IN_PROGRESS;

            /* Temporarily load VIDEO_FROM_MEMORY object */
            while (freeCount < 10)
                NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
            freeCount -= 10;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
            dmaPusherPutAddress[1] = NV_DD_PRIMARY_VIDEO_FROM_MEMORY;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                VIDEO_FROM_MEM_OFFSET_OFFSET | 0x140000;
            dmaPusherPutAddress[3] = pSurfTarg_gbl->fpVidMem - pDriverData->BaseAddress;
            dmaPusherPutAddress[4] = pSurfTarg_gbl->lPitch;
            dmaPusherPutAddress[5] = asmMergeCoords(pSurfTarg_gbl->wWidth, pSurfTarg_gbl->wHeight);
            if (pDriverData->bi.biBitCount == 8)
                dmaPusherPutAddress[6] = NV_VFM_FORMAT_COLOR_LE_Y8_P4;
            else if (pDriverData->bi.biBitCount == 16)
                dmaPusherPutAddress[6] = NV_VFM_FORMAT_COLOR_LE_X1R5G5B5_P2;
            else
                dmaPusherPutAddress[6] = NV_VFM_FORMAT_COLOR_LE_X8R8G8B8;
            dmaPusherPutAddress[7] = 0;
            dmaPusherPutAddress[8] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
            dmaPusherPutAddress[9] = NV_DD_SURFACES_2D;

            dmaPusherPutAddress += 10;
        }

        pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

        /* Force write combine buffer to flush */
        pDriverData->NvDmaPusherBufferEnd[0] = 0;
        /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
        _outp (0x3d0,0);

        pDriverData->dwDmaPusherFreeCount = freeCount;

        npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

        pDriverData->fDmaPushBufferHasBeenFlushed = FALSE;

        DPF( "Flip32: RGB Flip request completed successfully");

    } else if (pfd->lpSurfTarg->ddsCaps.dwCaps & DDSCAPS_OVERLAY) { /* flip overlay */
        FAST Nv3ChannelPio *npDevVideo = (Nv3ChannelPio *)pDriverData->NvDevVideoFlatPio;
        FAST long videoFreeCount;
        DWORD dwOffset;
        DWORD dwPitch;
        DWORD dwHeight;
        DWORD index;
        DWORD doBob = 0;
        DWORD dwFieldFlags = 0;
        DWORD dwOverlayDeltaY = pDriverData->dwOverlayDeltaY;
        DWORD preScaleOverlay = 0;
        DWORD srcPreShrinkDeltaX;
        DWORD srcPreShrinkDeltaY;
        BOOL  surfaceIs422 = FALSE;

        if (npDevVideo == NULL) {
            pfd->ddRVal = DDERR_SURFACELOST;
            return DDHAL_DRIVER_HANDLED;
        }

        if (pDriverData->fDDrawFullScreenDosOccurred) {
            pDriverData->OverlayRelaxOwnerCheck = 1;        /* relax owner check when we come back from DOS mode */
            if (pDriverData->fDDrawFullScreenDosOccurred == 2) {  /* still in DOS mode ? */
                pPioFlipOverlayNotifier[1].status = 0;      /* clear notifiers */
                pPioFlipOverlayNotifier[2].status = 0;
                pfd->ddRVal = DDERR_SURFACEBUSY;
                return DDHAL_DRIVER_HANDLED;
            } else {                                        /* back to hires mode */
                pPioFlipOverlayNotifier[1].status = 0;      /* clear notifiers */
                pPioFlipOverlayNotifier[2].status = 0;
                pDriverData->fDDrawFullScreenDosOccurred = 0;    /* reset flag */
            }
        }

        /* Limit flips to 1 at a time to work around NV4 RM limitation */
        ddrval = updateFlipStatus(pSurfTarg_gbl->fpVidMem);

        /* Only reject flip requests when flipping frames (but allow fields to proceed) */
        if (pfd->dwFlags & (DDFLIP_ODD | DDFLIP_EVEN) == 0) {
            if (ddrval != DD_OK) {
                if (pfd->dwFlags & DDFLIP_WAIT) {
                    // do contrast blt (only supports YUV422 style formats)
                    YUV422ColourControl(pfd->lpSurfTarg->lpGbl, &pDriverData->OverlayColourControl);

                    while (ddrval != DD_OK) {
                        NV_SLEEPFLIP;
                        ddrval = updateFlipStatus(pSurfTarg_gbl->fpVidMem);
                    }
                } else {
                    pfd->ddRVal = ddrval;
                    return DDHAL_DRIVER_HANDLED;
                }
            } else {
                // do contrast blt (only supports YUV422 style formats)
                YUV422ColourControl(pfd->lpSurfTarg->lpGbl, &pDriverData->OverlayColourControl);
            }
        } else {
            // do contrast blt (only supports YUV422 style formats)
            YUV422ColourControl(pfd->lpSurfTarg->lpGbl, &pDriverData->OverlayColourControl);
        }

        /*
         * is NV busy right now?
         */
        NV_DD_DMA_PUSHER_SYNC();

        if (pDriverData->dwOverlaySurfaces > 2)
            ConvertOverlay32(pfd->lpSurfTarg, TRUE);

        videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);

        pDriverData->flipOverlayRecord.fpFlipFrom = pfd->lpSurfCurr->lpGbl->fpVidMem;
        pDriverData->flipOverlayRecord.fpFlipTo = pSurfTarg_gbl->fpVidMem;

        pDriverData->flipOverlayRecord.bFlipFlag = TRUE;

        /* Make sure we flip to the correct starting offset in new overlay surface */
        dwOffset = pSurfTarg_gbl->fpVidMem - pDriverData->BaseAddress;

        if ((pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_IF09) ||
            (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_YVU9) ||
            (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_IV32) ||
            (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_IV31)) {
            /* Skip over Indeo portion of surface */
            dwPitch = (DWORD)pSurfTarg_gbl->wWidth;
            dwOffset += ((dwPitch * ((DWORD)pSurfTarg_gbl->wHeight * 10L)) >> 3);
            /* Force block to be properly aligned */
            dwOffset = (dwOffset + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
            dwPitch = ((pSurfTarg_gbl->wWidth + 1) & 0xFFFE) << 1;
            dwPitch = (dwPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
        } else if ((pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_YV12) ||
                   (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_420i)) {
            /* Assumes a separate overlay YUY2 surface in video memory */
            if (pSurfTarg_gbl->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0])
                dwOffset = pDriverData->NvYUY2Surface0Mem -
                               pDriverData->BaseAddress;
            else if (pSurfTarg_gbl->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1])
                dwOffset = pDriverData->NvYUY2Surface1Mem -
                               pDriverData->BaseAddress;
            else if (pSurfTarg_gbl->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2])
                dwOffset = pDriverData->NvYUY2Surface2Mem -
                               pDriverData->BaseAddress;
            else
                dwOffset = pDriverData->NvYUY2Surface3Mem -
                               pDriverData->BaseAddress;

            dwPitch = ((pSurfTarg_gbl->wWidth + 1) & 0xFFFE) << 1;
            dwPitch = (dwPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
        } else {
            dwPitch = (DWORD)pSurfTarg_gbl->lPitch;
            surfaceIs422 = TRUE;
        }

        /* Assume full surface height */
        dwHeight = (DWORD)pSurfTarg_gbl->wHeight;

        if ( !(pfd->lpSurfTarg->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT)  ) {
            if (pfd->dwFlags & (DDFLIP_ODD | DDFLIP_EVEN)) {
                if (pfd->lpSurfTarg->lpSurfMore) {
                    if (pfd->lpSurfTarg->lpSurfMore->dwOverlayFlags & DDOVER_INTERLEAVED) {
                        dwPitch <<= 1;
                        dwFieldFlags = pfd->dwFlags;
                        if ((pfd->dwFlags & DDFLIP_ODD) &&
                            (pfd->lpSurfTarg->lpSurfMore->dwOverlayFlags & DDOVER_BOB))
                            doBob = 2; /* Tell RM to BOB this field */
                    } else {
                        if ((pfd->dwFlags & DDFLIP_ODD) &&
                            (pfd->lpSurfTarg->lpSurfMore->dwOverlayFlags & DDOVER_BOB))
                            doBob = 2; /* Tell RM to BOB this field */
                    }
                }
                /* If flipping interleaved fields then halve the surface height */
                if (dwFieldFlags & (DDFLIP_ODD | DDFLIP_EVEN)) {
                    dwHeight >>= 1;
#ifdef  NOPRESTRETCH
                    dwOverlayDeltaY >>= 1;
#endif  // NOPRESTRETCH
                }
            } else {
                /* Sometimes we get calls with DDOVER_INTERLEAVED set but with neither DDFLIP_ODD nor DDFLIP_EVEN flags set. */
                /* This happens mostly during transitions when dynamic bob and weave are occurring. */
                if (pfd->lpSurfTarg->lpSurfMore) {
                    if (pfd->lpSurfTarg->lpSurfMore->dwOverlayFlags & DDOVER_INTERLEAVED) {
                        if (pfd->lpSurfTarg->lpSurfMore->dwOverlayFlags & DDOVER_BOB) {
#ifdef  NOPRESTRETCH
                            dwOverlayDeltaY >>= 1;
#endif  // NOPRESTRETCH
                            dwHeight >>= 1;
                            dwPitch <<= 1;
                            doBob = 2;
                            dwFieldFlags = DDFLIP_ODD;
                        }
                    }
                }
            }
        }

        srcPreShrinkDeltaX = 0x100000;
        srcPreShrinkDeltaY = 0x100000;

        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {

            if ((((pDriverData->dwOverlaySrcWidth + 7) >> 3) >
                   pDriverData->dwOverlayDstWidth) && (pDriverData->dwOverlayDstWidth > 0)) {
                preScaleOverlay |= NV_PRESCALE_OVERLAY_X;
                srcPreShrinkDeltaX =
                    (pDriverData->dwOverlaySrcWidth << 20) / pDriverData->dwOverlayDstWidth;
            }

            if ((((pDriverData->dwOverlaySrcHeight + 7) >> 3) >
                   pDriverData->dwOverlayDstHeight) && (pDriverData->dwOverlayDstHeight > 0)) {
                preScaleOverlay |= NV_PRESCALE_OVERLAY_Y;
                srcPreShrinkDeltaY =
                    (pDriverData->dwOverlaySrcHeight << 20) / pDriverData->dwOverlayDstHeight;
                dwOverlayDeltaY = pDriverData->dwOverlayDeltaY;
            }
        } else {

            if ((pDriverData->dwOverlaySrcWidth >
                   pDriverData->dwOverlayDstWidth) && (pDriverData->dwOverlayDstWidth > 0)) {
                preScaleOverlay |= NV_PRESCALE_OVERLAY_X;
                srcPreShrinkDeltaX =
                    (pDriverData->dwOverlaySrcWidth << 20) / pDriverData->dwOverlayDstWidth;
            }

            if ((pDriverData->dwOverlaySrcHeight >
                   pDriverData->dwOverlayDstHeight) && (pDriverData->dwOverlayDstHeight > 0)) {
                preScaleOverlay |= NV_PRESCALE_OVERLAY_Y;
                srcPreShrinkDeltaY =
                    (pDriverData->dwOverlaySrcHeight << 20) / pDriverData->dwOverlayDstHeight;
                dwOverlayDeltaY = pDriverData->dwOverlayDeltaY;
            }
        }

#ifndef NOPRESTRETCH
        if (dwFieldFlags & (DDFLIP_ODD | DDFLIP_EVEN)) {
            preScaleOverlay |= NV_PRESCALE_OVERLAY_FIELD;
            srcPreShrinkDeltaY >>= 1;
        }
#endif  // NOPRESTRETCH

        /* Alternate buffer indexes to keep the hardware happy */
        pDriverData->OverlayBufferIndex ^= 1;

        index = pDriverData->OverlayBufferIndex;

        /* Preshrink overlay surface if necessary */
        if ((pDriverData->TotalVRAM >> 20 > 4) && (preScaleOverlay) &&
            (!(pfd->lpSurfTarg->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT))) {

            while (videoFreeCount < 76)
                videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);
            videoFreeCount -= 76;

            /* Trash spare subchannel */
            npDevVideo->dDrawSpare.SetObject = NV_DD_DVD_SUBPICTURE;

            npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutPoint = 0;

            /* Widths below are increased by 2 instead of 1 to remain hardware compatible */
            if (preScaleOverlay == NV_PRESCALE_OVERLAY_X) {
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                    asmMergeCoords(((pDriverData->dwOverlayDstWidth + 2) & ~1),
                                   pSurfTarg_gbl->wHeight);
            } else if (preScaleOverlay == NV_PRESCALE_OVERLAY_Y) {
                if (dwFieldFlags & (DDFLIP_ODD | DDFLIP_EVEN)) {
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                        asmMergeCoords(((pSurfTarg_gbl->wWidth + 2) & ~1),
                                       (pDriverData->dwOverlayDstHeight >> 1));
                } else {
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                        asmMergeCoords(((pSurfTarg_gbl->wWidth + 2) & ~1),
                                       pDriverData->dwOverlayDstHeight);
                }
            } else if (preScaleOverlay == (NV_PRESCALE_OVERLAY_X + NV_PRESCALE_OVERLAY_Y)) {
                if (dwFieldFlags & (DDFLIP_ODD | DDFLIP_EVEN)) {
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                        asmMergeCoords(((pDriverData->dwOverlayDstWidth + 2) & ~1),
                                       (pDriverData->dwOverlayDstHeight >> 1));
                } else {
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                        asmMergeCoords(((pDriverData->dwOverlayDstWidth + 2) & ~1),
                                       pDriverData->dwOverlayDstHeight);
                }
            } else if (preScaleOverlay == NV_PRESCALE_OVERLAY_FIELD) {
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                    asmMergeCoords(((pDriverData->dwOverlaySrcWidth + 2) & ~1),
                                   pDriverData->dwOverlaySrcHeight);
            } else if (preScaleOverlay == (NV_PRESCALE_OVERLAY_X + NV_PRESCALE_OVERLAY_FIELD)) {
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                    asmMergeCoords(((pDriverData->dwOverlayDstWidth + 2) & ~1),
                                   pDriverData->dwOverlaySrcHeight);
            } else if (preScaleOverlay == (NV_PRESCALE_OVERLAY_Y + NV_PRESCALE_OVERLAY_FIELD)) {
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                    asmMergeCoords(((pSurfTarg_gbl->wWidth + 2) & ~1),
                                   pDriverData->dwOverlayDstHeight);
            } else { // NV_PRESCALE_OVERLAY_X + NV_PRESCALE_OVERLAY_Y + NV_PRESCALE_OVERLAY_FIELD
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                    asmMergeCoords(((pDriverData->dwOverlayDstWidth + 2) & ~1),
                                   pDriverData->dwOverlayDstHeight);
            }

            if (preScaleOverlay & NV_PRESCALE_OVERLAY_FIELD) {
                if (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_UYVY)
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutFormat =
                        (NV038_IMAGE_OUT_FORMAT_COLOR_LE_YB8V8YA8U8 << 16) | (dwPitch >> 1);
                else
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutFormat =
                        (NV038_IMAGE_OUT_FORMAT_COLOR_LE_V8YB8U8YA8 << 16) | (dwPitch >> 1);


            } else {
                if (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_UYVY)
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutFormat =
                        (NV038_IMAGE_OUT_FORMAT_COLOR_LE_YB8V8YA8U8 << 16) | dwPitch;
                else
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutFormat =
                        (NV038_IMAGE_OUT_FORMAT_COLOR_LE_V8YB8U8YA8 << 16) | dwPitch;
            }

            /* Output to extra overlay surface memory area */
            if ((surfaceIs422) && (pDriverData->extra422OverlayOffset[index] != 0)) {
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutOffset =
                    pDriverData->extra422OverlayOffset[index];
            } else {
                if (dwFieldFlags & DDFLIP_ODD)
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutOffset =
                        (dwOffset + (dwPitch >> 1) + pSurfTarg_gbl->dwReserved1);
                else
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutOffset =
                        (dwOffset + pSurfTarg_gbl->dwReserved1);
            }

            npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageInDeltaDuDx = srcPreShrinkDeltaX;
            npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageInDeltaDvDy = srcPreShrinkDeltaY;

            npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageInSize =
                asmMergeCoords(((pDriverData->dwOverlaySrcWidth + 1) & ~1), dwHeight);

            if (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_UYVY)
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageInFormat =
                    (NV038_IMAGE_IN_FORMAT_COLOR_LE_YB8V8YA8U8 << 16) | dwPitch;
            else
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageInFormat =
                    (NV038_IMAGE_IN_FORMAT_COLOR_LE_V8YB8U8YA8 << 16) | dwPitch;

            /* Temporarily offset to the beginning of the visible portion of source surface */
            dwOffset += (pDriverData->OverlaySrcY * dwPitch);
            dwOffset += ((pDriverData->OverlaySrcX & ~1) << 1);

            if (dwFieldFlags & DDFLIP_ODD)
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageInOffset =
                    (dwOffset + (dwPitch >> 1));
            else
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageInOffset =
                    dwOffset;

            npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageInPoint = 0;

            npDevVideo->dDrawSpare.nv4DvdSubpicture.OverlayDeltaDuDx = srcPreShrinkDeltaX;
            npDevVideo->dDrawSpare.nv4DvdSubpicture.OverlayDeltaDvDy = srcPreShrinkDeltaY;

            npDevVideo->dDrawSpare.nv4DvdSubpicture.OverlaySize =
                asmMergeCoords(((pDriverData->dwOverlaySrcWidth + 1) & ~1), dwHeight);

            npDevVideo->dDrawSpare.nv4DvdSubpicture.OverlayFormat =
                (NV038_OVERLAY_FORMAT_COLOR_LE_TRANSPARENT << 16) | dwPitch;

            if (dwFieldFlags & DDFLIP_ODD)
                npDevVideo->dDrawSpare.nv4DvdSubpicture.OverlayOffset =
                    (dwOffset + (dwPitch >> 1));
            else
                npDevVideo->dDrawSpare.nv4DvdSubpicture.OverlayOffset =
                    dwOffset;

            /* Restore offset */
            dwOffset -= (pDriverData->OverlaySrcY * dwPitch);
            dwOffset -= ((pDriverData->OverlaySrcX & ~1) << 1);

            npDevVideo->dDrawSpare.nv4DvdSubpicture.OverlayPoint = 0;

            pDriverData->dDrawSpareSubchannelObject = 0;

            /* Change offset to point to shrunken overlay surface memory */
            if ((surfaceIs422) && (pDriverData->extra422OverlayOffset[index] != 0))
                dwOffset = pDriverData->extra422OverlayOffset[index];
            else
                dwOffset += pSurfTarg_gbl->dwReserved1;

            /* Restore overlay source pitch and height to normal since we prescaled it */
            if (preScaleOverlay & NV_PRESCALE_OVERLAY_FIELD) {
                dwPitch >>= 1;
                dwHeight <<= 1;
            }

            /* Force fifo to stall until shrink operation finishes */
            npDevVideo->dDrawSpare.nv4DvdSubpicture.Notify = 0;
            npDevVideo->dDrawSpare.nv4DvdSubpicture.NoOperation = 0;
        } else {
            /* Offset to visible portion of source surface */
            if (pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) {
                dwOffset += (pDriverData->OverlaySrcY * dwPitch);
                dwOffset += ((pDriverData->OverlaySrcX & ~1) << 1);
            }
        }

        /* This actually refers to the video channel in this case */
        pDriverData->dDrawSpareSubchannelObject = 0;

        /* This should never wait unless there is a hardware glitch */
        while ((volatile)pPioFlipOverlayNotifier[index + 1].status == NV_IN_PROGRESS);

        pPioFlipOverlayNotifier[index + 1].status = NV_IN_PROGRESS;

        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
            DWORD dwPointIn;
            DWORD dwOverlayFormat;

            while (videoFreeCount < 40) {
                videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);
                if (videoFreeCount < 40)
                    NV_SLEEP;
            }

            /* Trash spare subchannel */
            npDevVideo->subchannel[NV_DD_SPARE].SetObject = NV_VIDEO_OVERLAY;

            npDevVideo->dDrawSpare.Nv10VideoOverlay.SetOverlay[index].colorKey =
                pDriverData->OverlayColorKey;

            if ((!(surfaceIs422)) && (dwFieldFlags & DDFLIP_ODD))
                dwOffset += dwPitch >> 1;

            /* Remember this in case we get a SetOverlayPosition call */
            pDriverData->OverlaySrcOffset = dwOffset;

            npDevVideo->dDrawSpare.Nv10VideoOverlay.SetOverlay[index].offset =
                dwOffset;

            npDevVideo->dDrawSpare.Nv10VideoOverlay.SetOverlay[index].sizeIn =
                (pDriverData->OverlaySrcSize & ~0x00010001);

            if (preScaleOverlay == 0) {
                dwPointIn = asmMergeCoords((pDriverData->OverlaySrcX << 4), (pDriverData->OverlaySrcY << 4));
            } else
                dwPointIn = 0;

            /* Offset source starting Y by -0.5 when bobing */
            if (doBob)
                dwPointIn += 0xFFF80000;

            npDevVideo->dDrawSpare.Nv10VideoOverlay.SetOverlay[index].pointIn = dwPointIn;

            if ( !(pfd->lpSurfTarg->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT) ) {
                npDevVideo->dDrawSpare.Nv10VideoOverlay.SetOverlay[index].duDx =
                    pDriverData->dwOverlayDeltaX;
                npDevVideo->dDrawSpare.Nv10VideoOverlay.SetOverlay[index].dvDy =
                    dwOverlayDeltaY;
            }

            npDevVideo->dDrawSpare.Nv10VideoOverlay.SetOverlay[index].pointOut =
                asmMergeCoords(pDriverData->OverlayDstX, pDriverData->OverlayDstY);

            if (preScaleOverlay) {
                npDevVideo->dDrawSpare.Nv10VideoOverlay.SetOverlay[index].sizeOut =
                    asmMergeCoords(pDriverData->dwOverlayDstWidth, pDriverData->dwOverlayDstHeight);
            } else {
                npDevVideo->dDrawSpare.Nv10VideoOverlay.SetOverlay[index].sizeOut =
                    asmMergeCoords(pSurfTarg_gbl->wWidth, dwHeight);
            }

            dwOverlayFormat = pDriverData->OverlayFormat;

            /* replace old surface pitch value with current pitch value */
            dwOverlayFormat &= 0xFFFF0000;

            dwOverlayFormat |= dwPitch;

            npDevVideo->dDrawSpare.Nv10VideoOverlay.SetOverlay[index].format = dwOverlayFormat;

        } else { // pre NV10

            while (videoFreeCount < 32) {
                videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);
                if (videoFreeCount < 32)
                    NV_SLEEP;
            }

            /* Trash spare subchannel */
            npDevVideo->subchannel[NV_DD_SPARE].SetObject = NV_DD_VIDEO_SCALER;

            if ( !(pfd->lpSurfTarg->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT) )
                    npDevVideo->subchannel[NV_DD_SPARE].videoScaler.SetDeltaDvDy = dwOverlayDeltaY;

            /* Temporarily load VIDEO_FROM_MEMORY object */
            npDevVideo->subchannel[NV_DD_SPARE].SetObject =
                NV_DD_YUV422_VIDEO_FROM_MEMORY;

            if ((!(surfaceIs422)) && (dwFieldFlags & DDFLIP_ODD))
                dwOffset += dwPitch >> 1;

            /* Remember this in case we get a SetOverlayPosition call */
            pDriverData->OverlaySrcOffset = dwOffset;

            npDevVideo->subchannel[NV_DD_SPARE].videoFromMemory.ImageScan[index].offset =
                dwOffset;

            npDevVideo->subchannel[NV_DD_SPARE].videoFromMemory.ImageScan[index].pitch =
                (dwPitch | doBob);

                if (preScaleOverlay) {
                npDevVideo->subchannel[NV_DD_SPARE].videoFromMemory.ImageScan[index].size =
                    asmMergeCoords(pDriverData->dwOverlayDstWidth,
                                   pDriverData->dwOverlayDstHeight);
                } else {
                npDevVideo->subchannel[NV_DD_SPARE].videoFromMemory.ImageScan[index].size =
                    asmMergeCoords(pSurfTarg_gbl->wWidth, dwHeight);
                }

            if (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_UYVY)
                npDevVideo->subchannel[NV_DD_SPARE].videoFromMemory.ImageScan[index].format =
                    NV_VFM_FORMAT_COLOR_LE_Y8V8Y8U8;
            else
                npDevVideo->subchannel[NV_DD_SPARE].videoFromMemory.ImageScan[index].format =
                    NV_VFM_FORMAT_COLOR_LE_V8Y8U8Y8;

            npDevVideo->subchannel[NV_DD_SPARE].videoFromMemory.ImageScan[index].notify =
                0;
        }

        pDriverData->NvVideoFreeCount = (short)NvGetFreeCount(npDevVideo, NV_DD_SPARE);

    } else { /* Video port flips handled by FlipVideoPort32 */
        pfd->ddRVal = DDERR_INVALIDSURFACETYPE;
        return DDHAL_DRIVER_HANDLED;
    }

    /*
     * D3D will not wait for flip to complete - so much for ddraw semantics
     */
    if (!bIsD3D && !(pfd->lpSurfTarg->ddsCaps.dwCaps & DDSCAPS_OVERLAY)) {
        if (pfd->dwFlags & DDFLIP_WAIT) {
            ddrval = updateFlipStatus(0);

            while (ddrval != DD_OK) {
                NV_SLEEPFLIP;
                ddrval = updateFlipStatus(0);
            }
        }
    }

    pfd->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;

} /* Flip32 */



/*
 * Lock32
 */
DWORD __stdcall Lock32( LPDDHAL_LOCKDATA lpLockData )
{
    HRESULT                                     ddrval;
    FAST Nv10ControlDma         *npDev;
    NvNotification                              *pDmaFlipPrimaryNotifier;
    NvNotification                              *pPioFlipOverlayNotifier;
    NvNotification                              *pDmaSyncNotifier;
    NvNotification                              *pDmaDmaFromMemNotifier;
    DWORD                                       dwOffset;
        DWORD                                           caps;
    LPDDRAWI_DDRAWSURFACE_GBL   psurf_gbl;
    unsigned long               *dmaPusherPutAddress;
    unsigned long               *dmaPusherBufferBase;
    long                        freeCount;

    NvSetDriverDataPtr(lpLockData->lpDD);
    npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

    /*
     * NOTES:
     *
     * This callback is invoked whenever a surface is about to be directly
     * accessed by the user.   This is where you need to make sure that
     * a surface can be safely accessed by the user.
     *
     * If your memory cannot be accessed while in accelerator mode, you
     * should either take the card out of accelerator mode or else
     * return DDERR_SURFACEBUSY
     *
     * If someone is accessing a surface that was just flipped away from,
     * make sure that the old surface (what was the primary) has finished
     * being displayed.
     */

    caps = lpLockData->lpDDSurface->ddsCaps.dwCaps;

    /*
     * Reset NV and get the monitor frequency after a mode reset
     */
    if( pDriverData->fReset ) {
        NV_DD_DMA_PUSHER_SYNC();
        getDisplayDuration();
        if (!ResetNV()) {
            lpLockData->ddRVal = DDERR_GENERIC;
            return(DDHAL_DRIVER_HANDLED);
        }
        pDriverData->fReset = FALSE;
    }

    pDmaFlipPrimaryNotifier = (NvNotification *)pDriverData->NvDmaFlipPrimaryNotifierFlat;
    pPioFlipOverlayNotifier = (NvNotification *)pDriverData->NvPioFlipOverlayNotifierFlat;
    pDmaSyncNotifier = (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;
    pDmaDmaFromMemNotifier = (NvNotification *)pDriverData->NvDmaDmaFromMemNotifierFlat;
    dmaPusherPutAddress = (unsigned long *)pDriverData->NvDmaPusherPutAddress;
    dmaPusherBufferBase = (unsigned long *)pDriverData->NvDmaPusherBufferBase;

    if ((npDev == NULL) && (caps & DDSCAPS_VIDEOMEMORY)) {  /* Mode switches might occur without warning */
        lpLockData->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
    }

    psurf_gbl = lpLockData->lpDDSurface->lpGbl;

    /*
     * check to see if any pending physical flip has occurred
     */


    if ((caps & DDSCAPS_OVERLAY) == 0) { /* Only wait for RGB surfaces */
        ddrval = updateFlipStatus(psurf_gbl->fpVidMem);
        if( ddrval != DD_OK ) {
            if (lpLockData->dwFlags & DDLOCK_WAIT) {
                while (ddrval != DD_OK) {
                    long countDown = 1000;  // sometimes we can loose a Flip notification
                    // do not sleep on non-overlay locks cuz OpenGL does alot of locks
                    // NV_SLEEPFLIP;
                    ddrval = updateFlipStatus(psurf_gbl->fpVidMem);
                    if (--countDown <= 0) {
                        pDmaFlipPrimaryNotifier[1].status = 0;
                        pDmaFlipPrimaryNotifier[2].status = 0;
                    }
                }
            } else {
                lpLockData->ddRVal = DDERR_WASSTILLDRAWING;
                return DDHAL_DRIVER_HANDLED;
            }
        }
    }

    /*
     * don't allow a lock if a blt is in progress (only do this if your
     * hardware requires it)
     */

//    if(DRAW_ENGINE_BUSY)
//    {
//        lpLockData->ddRVal = DDERR_WASSTILLDRAWING;
//        return DDHAL_DRIVER_HANDLED;
//    }

    if ((pDmaDmaFromMemNotifier->status == NV_IN_PROGRESS) &&
        (pDriverData->NvDmaFromMemSurfaceMem == psurf_gbl->fpVidMem)) {
        lpLockData->ddRVal = DDERR_WASSTILLDRAWING;
        return DDHAL_DRIVER_HANDLED;
    }

    if ((caps & DDSCAPS_VIDEOMEMORY) && ((caps & DDSCAPS_TEXTURE) == 0)) {

        // No need to lock textures even though they may currently be in use because
        //     their surface memory is not used directly when rendering
        // Every other surface type with DDSCAPS_VIDMEMORY set does need locked however


        if ((lpLockData->dwFlags & DDLOCK_WAIT) || // workaround for Telurian Defence bug
            ((lpLockData->dwFlags & DDLOCK_READONLY) == 0)) {

            NV_DD_DMA_PUSHER_SYNC();

            // Give the application a chance to do something else if push buffer isn't empty yet
            if (npDev->Get != (unsigned long)(dmaPusherPutAddress - dmaPusherBufferBase) << 2) {
                /* Force write combine buffer to flush */
                pDriverData->NvDmaPusherBufferEnd[0] = 0;
                /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                _outp (0x3d0,0);
                npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                lpLockData->ddRVal = DDERR_WASSTILLDRAWING;
                return DDHAL_DRIVER_HANDLED;
            }

            freeCount = 0; /* Force a hardware read */

            /* Let D3D code know that we have touched NV */
            pDriverData->TwoDRenderingOccurred = 1;

            // MUST wait for any pending notification to prevent possible loss of notification serialization
            while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS);

            while (freeCount < 4)
                NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
            freeCount -= 4;

            pDmaSyncNotifier->status = NV_IN_PROGRESS;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = 0;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
            dmaPusherPutAddress[3] = 0;

            dmaPusherPutAddress += 4;

            pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

            /* Force write combine buffer to flush */
            pDriverData->NvDmaPusherBufferEnd[0] = 0;
            /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
            _outp (0x3d0,0);

            pDriverData->dwDmaPusherFreeCount = freeCount;

            npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

            while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS);

            if (caps & DDSCAPS_VISIBLE) {
                pDriverData->fVidMemLocked = TRUE;
            }
        }
    }

    /*
     * Signal that the texture surface has been locked.  This means that the
     * texture has possibly been modified which means it needs to be retranslated.
     * This needs to be done no matter where the texture was allocated.
     */
    if (caps & DDSCAPS_TEXTURE) {
        PNVD3DTEXTURE   pTexture;
#ifdef NV_TEX2
        /*
         * user wants to lock a texture - process elsewhere
         */
        if (pTexture = (PNVD3DTEXTURE)lpLockData->lpDDSurface->dwReserved1)
        {
#ifdef WINNT
            DWORD retval;
            pTexture->lpLcl = lpLockData->lpDDSurface;
            retval = nvTextureLock(pTexture,lpLockData);
            pTexture->lpLcl = NULL;
            return(retval);
#else
            return(nvTextureLock(pTexture,lpLockData));
#endif // #ifndef WINNT
        }
#else // NV_TEX2
       if (pTexture = (PNVD3DTEXTURE)lpLockData->lpDDSurface->dwReserved1)
        {
            /*
             * When the application is locking and touching the texture directly, it's
             * neccessary to allocate a seperate block of system memory for it to use
             * since the texture memory used by the hardware stores the texture in a
             * different format than what the application understands.
             */
#ifdef WINNT
            pTexture->lpLcl = lpLockData->lpDDSurface;
            nvAllocateUserTexture(pTexture);
            pTexture->dwTextureFlags |= (NV3_TEXTURE_MODIFIED | NV3_TEXTURE_IS_LOCKED);
            lpLockData->lpSurfData = pTexture->lpLcl->lpGbl->fpVidMem;
            pTexture->lpLcl = NULL;
            lpLockData->ddRVal = DD_OK;
            return(DDHAL_DRIVER_HANDLED);
#else
            nvAllocateUserTexture(pTexture);
#endif // #ifdef WINNT
        }
#endif // NV_TEX2
    }

    /* Currently works only for pDriverData->bi.biBitCount pixel depth surfaces */
    if (lpLockData->bHasRect) {
        dwOffset = lpLockData->rArea.top * psurf_gbl->lPitch;
        dwOffset += (lpLockData->rArea.left * (pDriverData->bi.biBitCount >> 3));
        lpLockData->lpSurfData = (VOID *)((DWORD)psurf_gbl->fpVidMem + dwOffset);
    }

    return DDHAL_DRIVER_NOTHANDLED;

} /* Lock32 */


/*
 * Unlock32
 */
DWORD __stdcall Unlock32( LPDDHAL_UNLOCKDATA lpUnlockData )
{
    Nv10ControlDma              *npDev;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl;
    DWORD                       caps;

    NvSetDriverDataPtr(lpUnlockData->lpDD);

    npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

    caps = lpUnlockData->lpDDSurface->ddsCaps.dwCaps;

    if ((npDev == NULL) && (caps & DDSCAPS_VIDEOMEMORY)) {  /* Mode switches might occur without warning */
        lpUnlockData->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
    }

    pSurf_gbl = lpUnlockData->lpDDSurface->lpGbl;

    if ((caps & DDSCAPS_OVERLAY) && ((caps & DDSCAPS_VISIBLE) ||
        (pDriverData->dwOverlaySurfaces < 3))) {
        ConvertOverlay32(lpUnlockData->lpDDSurface, FALSE);
        if ((caps & DDSCAPS_VISIBLE) && ((caps & DDSCAPS_VIDEOPORT) == 0)) {
            if ((pDriverData->dwOverlaySurfaces == 1) && (pSurf_gbl->wHeight >= 480)) { // Quadrant MCI DVD decoder fix
                if (pDriverData->lockCount > 2)
                    PreScaleOverlay32(lpUnlockData->lpDDSurface);
            } else if (((pDriverData->dwOverlaySrcWidth > pDriverData->dwOverlayDstWidth) ||
                (pDriverData->dwOverlaySrcHeight > pDriverData->dwOverlayDstHeight))) {
                PreScaleOverlay32(lpUnlockData->lpDDSurface);
            }
        }
        pDriverData->lockCount++;
    }

    /*
     * Signal that the texture surface has been unlocked.  This means that the
     * texture has possibly been modified which means it needs to be retranslated.
     * This needs to be done no matter where the texture was allocated.
     */
    if (caps & DDSCAPS_TEXTURE) {
        PNVD3DTEXTURE   pTexture;
#ifdef NV_TEX2
        /*
         * user wants to unlock a texture - process elsewhere
         */
        if (pTexture = (PNVD3DTEXTURE)lpUnlockData->lpDDSurface->dwReserved1)
        {
#ifdef WINNT
            DWORD retval;
            pTexture->lpLcl = lpUnlockData->lpDDSurface;
            pDriverData->fVidMemLocked = FALSE;
            retval = nvTextureUnlock(pTexture,lpUnlockData);
            pTexture->lpLcl = NULL;
            return(retval);
#else
            pDriverData->fVidMemLocked = FALSE;
            return(nvTextureUnlock(pTexture,lpUnlockData));
#endif // #ifndef WINNT
        }
#else // NV_TEX2
        pTexture = (PNVD3DTEXTURE)lpUnlockData->lpDDSurface->dwReserved1;
        if (pTexture) {
            pTexture->dwTextureFlags |= NV3_TEXTURE_MODIFIED;
            pTexture->dwTextureFlags &= ~NV3_TEXTURE_IS_LOCKED;

            /*
             * Swizzle the texture now.
             */
#ifdef WINNT
            pTexture->lpLcl = lpUnlockData->lpDDSurface;
            nvLoadTexture(pTexture);
            pTexture->lpLcl = NULL;
#else
            nvLoadTexture(pTexture);
#endif // #ifndef WINNT

        }
#endif // NV_TEX2
    }

    pDriverData->fVidMemLocked = FALSE;

    lpUnlockData->ddRVal = DD_OK;

    return DDHAL_DRIVER_HANDLED;

} /* Unlock32 */




/*
 * WaitForVerticalBlank32
 */
DWORD __stdcall WaitForVerticalBlank32(
        LPDDHAL_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank )
{
    NvSetDriverDataPtr(lpWaitForVerticalBlank->lpDD);

    switch( lpWaitForVerticalBlank->dwFlags ) {

    case DDWAITVB_I_TESTVB:
        /*
         * if testvb is just a request for the current vertical blank status
         */
        lpWaitForVerticalBlank->ddRVal = DD_OK;
#ifndef WINNT
        if (NvConfigGet(NV_CFG_VBLANK_STATUS, pDriverData->dwDeviceIDNum))
#else
        if (pDriverData->ppdev->pfnVBlankIsActive(pDriverData->ppdev))
#endif // #ifdef WINNT
           lpWaitForVerticalBlank->bIsInVB = TRUE;
        else
           lpWaitForVerticalBlank->bIsInVB = FALSE;

        return DDHAL_DRIVER_HANDLED;

    case DDWAITVB_BLOCKBEGIN:
        /*
         * if blockbegin is requested we wait until the vertical blank
         * is over, and then wait for the display period to end.
         */
#ifndef WINNT
        while(NvConfigGet(NV_CFG_VBLANK_STATUS, pDriverData->dwDeviceIDNum) != 0);
        while(NvConfigGet(NV_CFG_VBLANK_STATUS, pDriverData->dwDeviceIDNum) == 0);
#else
        pDriverData->ppdev->pfnWaitWhileVBlankActive(pDriverData->ppdev);
        pDriverData->ppdev->pfnWaitWhileDisplayActive(pDriverData->ppdev);
#endif // #ifdef WINNT
        lpWaitForVerticalBlank->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;

    case DDWAITVB_BLOCKEND:
        /*
         * if blockend is requested we wait for the vblank interval to end.
         */
#ifndef WINNT
        if (NvConfigGet(NV_CFG_VBLANK_STATUS, pDriverData->dwDeviceIDNum)) {
            while(NvConfigGet(NV_CFG_VBLANK_STATUS, pDriverData->dwDeviceIDNum) != 0);
        } else {
            while(NvConfigGet(NV_CFG_VBLANK_STATUS, pDriverData->dwDeviceIDNum) == 0);
            while(NvConfigGet(NV_CFG_VBLANK_STATUS, pDriverData->dwDeviceIDNum) != 0);
        }
#else
        if (pDriverData->ppdev->pfnVBlankIsActive(pDriverData->ppdev)) {
            pDriverData->ppdev->pfnWaitWhileVBlankActive(pDriverData->ppdev);
        } else {
            pDriverData->ppdev->pfnWaitWhileDisplayActive(pDriverData->ppdev);
            pDriverData->ppdev->pfnWaitWhileVBlankActive(pDriverData->ppdev);
        }
#endif // #ifdef WINNT
        lpWaitForVerticalBlank->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    return DDHAL_DRIVER_NOTHANDLED;

} /* WaitForVerticalBlank32 */



/*
 * GetScanLine32
 */
DWORD __stdcall GetScanLine32( LPDDHAL_GETSCANLINEDATA lpGetScanLine )
{
    NvSetDriverDataPtr(lpGetScanLine->lpDD);

    /*
     * If a vertical blank is in progress the scan line is in
     * indeterminant. If the scan line is indeterminant we return
     * the error code DDERR_VERTICALBLANKINPROGRESS.
     * Otherwise we return the scan line and a success code
     */
#ifndef WINNT
    lpGetScanLine->dwScanLine = NvConfigGet(NV_CFG_CURRENT_SCANLINE, pDriverData->dwDeviceIDNum);
#else
    lpGetScanLine->dwScanLine = pDriverData->ppdev->pfnGetScanline(pDriverData->ppdev);
#endif // #ifdef WINNT

    if (lpGetScanLine->dwScanLine >= (DWORD)pDriverData->bi.biHeight)
        lpGetScanLine->ddRVal = DDERR_VERTICALBLANKINPROGRESS;
    else
        lpGetScanLine->ddRVal = DD_OK;

    return DDHAL_DRIVER_HANDLED;

} /* GetScanLine32 */



/*
 * SetSurfaceColorKey32
 */
DWORD __stdcall SetSurfaceColorKey32(LPDDHAL_SETCOLORKEYDATA lpSetColorKey)
{
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf;

    NvSetDriverDataPtr(lpSetColorKey->lpDD);

    pdrv = lpSetColorKey->lpDD;
    psurf = lpSetColorKey->lpDDSurface;

    DPF( "in SetSurfaceColorKey, lpSetColorKey->lpDD=%08lx, lpSetColorKey->lpDDSurface = %08lx",
                pdrv, lpSetColorKey->lpDDSurface );

    if (lpSetColorKey->dwFlags == DDCKEY_SRCBLT) {
        psurf->ddckCKSrcBlt.dwColorSpaceLowValue =
            lpSetColorKey->ckNew.dwColorSpaceLowValue & pDriverData->physicalColorMask;
        /* Use no mask on this one on NV3 so that our D3D driver can get all the bits when surface is 565 */
        psurf->ddckCKSrcBlt.dwColorSpaceHighValue =
            lpSetColorKey->ckNew.dwColorSpaceHighValue;
    } else if (lpSetColorKey->dwFlags == DDCKEY_DESTOVERLAY) {
        psurf->ddckCKDestOverlay.dwColorSpaceLowValue =
            lpSetColorKey->ckNew.dwColorSpaceLowValue & pDriverData->physicalColorMask;
        psurf->ddckCKDestOverlay.dwColorSpaceHighValue =
            lpSetColorKey->ckNew.dwColorSpaceHighValue & pDriverData->physicalColorMask;
    } else {
        lpSetColorKey->ddRVal = DDERR_UNSUPPORTED;
        return DDHAL_DRIVER_HANDLED;
    }


    lpSetColorKey->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}


/*
 * DestroySurface32
 */
DWORD __stdcall DestroySurface32( LPDDHAL_DESTROYSURFACEDATA lpDestroySurface )
{
    FAST Nv10ControlDma          *npDev;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf;
    LPDDRAWI_DDRAWSURFACE_GBL   psurf_gbl;
    HGLOBAL                     hMem;
    DWORD                       index = 0;

    NvSetDriverDataPtr(lpDestroySurface->lpDD);

    npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

    pdrv = lpDestroySurface->lpDD;
    DPF( "in DestroySurface, lpDestroySurface->lpDD=%08lx, lpDestroySurface->lpDDSurface = %08lx",
                pdrv, lpDestroySurface->lpDDSurface );

    psurf = lpDestroySurface->lpDDSurface;
    psurf_gbl = psurf->lpGbl;

    if (psurf_gbl->fpVidMem == pDriverData->BaseAddress) {
        lpDestroySurface->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    /*
       Should check if YUV surface is an active VPE surface and make sure
       to stop VPE hardware before destroying VPE surface somewhere in YUV
       surface code in this function.
    */

    if ((psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
        (psurf->ddsCaps.dwCaps & (DDSCAPS_VISIBLE | DDSCAPS_FRONTBUFFER))) {
        FAST Nv3ChannelPio *npDevVideo = (Nv3ChannelPio *)pDriverData->NvDevVideoFlatPio;
        FAST long          videoFreeCount = pDriverData->NvVideoFreeCount;
        NvNotification     *pPioFlipOverlayNotifier =
                            (NvNotification *)pDriverData->NvPioFlipOverlayNotifierFlat;

        pDriverData->HALInfo.ddCaps.dwCurrVisibleOverlays = 0;

        NV_DD_DMA_PUSHER_SYNC();

        if (npDevVideo == NULL) {  /* Mode switches might occur without warning */
            if (!ResetNV()) {
                lpDestroySurface->ddRVal = DDERR_GENERIC;
                return DDHAL_DRIVER_HANDLED;
            }
            pDriverData->fReset = FALSE;
            npDevVideo = (Nv3ChannelPio *)pDriverData->NvDevVideoFlatPio;
            videoFreeCount = pDriverData->NvVideoFreeCount;
            npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;
            if ((npDevVideo == NULL) || (npDev == NULL))  {
                pDriverData->dwOverlaySurfaces = 0;
                pDriverData->dwOverlayOwner = 0;
                lpDestroySurface->ddRVal = DDERR_SURFACELOST;
                return DDHAL_DRIVER_HANDLED;
            }
        }

        pDriverData->dwRingZeroMutex = TRUE;

        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {

            while (videoFreeCount < 12)
                videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);
            videoFreeCount -= 12;

            npDevVideo->dDrawSpare.SetObject = NV_VIDEO_OVERLAY;

            npDevVideo->dDrawSpare.Nv10VideoOverlay.StopOverlay[0] =
                NV07A_STOP_OVERLAY_BETWEEN_BUFFERS;

            npDevVideo->dDrawSpare.Nv10VideoOverlay.StopOverlay[1] =
                NV07A_STOP_OVERLAY_BETWEEN_BUFFERS;

        } else {

            while (videoFreeCount < 20)
                videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);
            videoFreeCount -= 20;

            /* Trash spare subchannel */
            npDevVideo->dDrawSpare.SetObject = NV_DD_VIDEO_COLOR_KEY;

            npDevVideo->dDrawSpare.videoColorKey.SetSize = 0; // hide overlay

            npDevVideo->dDrawSpare.SetObject = NV_DD_YUV422_VIDEO_FROM_MEMORY;

            npDevVideo->dDrawSpare.videoFromMemory.ImageScan[0].size = 0;

            npDevVideo->dDrawSpare.videoFromMemory.ImageScan[0].notify = 0;
        }

        pDriverData->dwRingZeroMutex = FALSE;
        pDriverData->dDrawSpareSubchannelObject = 0;

        pDriverData->NvVideoFreeCount = (short)videoFreeCount;

        /* Make sure we don't get confused later on */
        pPioFlipOverlayNotifier[1].status = 0;      /* clear notifiers */
        pPioFlipOverlayNotifier[2].status = 0;
        pDriverData->fDDrawFullScreenDosOccurred = 0;    /* reset flag */
    }

    if( (psurf->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
         (psurf_gbl->ddpfSurface.dwFlags & DDPF_FOURCC) ) {
             DPF( "  FOURCC surface" );

        switch( psurf->lpGbl->ddpfSurface.dwFourCC ) {
            case FOURCC_RGB0:
            case FOURCC_RAW8:
               if (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {
                   if (psurf_gbl->fpVidMem > 0) {
                       NVHEAP_FREE (psurf_gbl->fpVidMem);
                       //DDHAL32_VidMemFree(pdrv, 0, psurf_gbl->fpVidMem);
                       psurf_gbl->fpVidMem = 0;
                       if (pDriverData->DDrawVideoSurfaceCount > 0)
                           pDriverData->DDrawVideoSurfaceCount--;
                   }
               } else {
                   hMem = (HGLOBAL)psurf_gbl->dwReserved1;
                   GlobalUnlock(hMem);
                   GlobalFree(hMem);
                   psurf_gbl->dwReserved1 = 0;
               }
               lpDestroySurface->ddRVal = DD_OK;
               return DDHAL_DRIVER_HANDLED;
               break;

            case FOURCC_IF09:
            case FOURCC_YVU9:
            case FOURCC_IV32:
            case FOURCC_IV31:
            case FOURCC_YUY2:
            case FOURCC_YUNV:
            case FOURCC_UYVY:
            case FOURCC_UYNV:

               if (psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
                   while (index < NV_MAX_OVERLAY_SURFACES) {
                       if ((DWORD)psurf == pDriverData->dwOverlaySurfaceLCL[index]) {
                           pDriverData->dwOverlaySurfaceLCL[index] = 0;
                           if (pDriverData->dwOverlaySurfaces > 0)
                               pDriverData->dwOverlaySurfaces--;
                           if (pDriverData->dwOverlaySurfaces == 0) {
                               pDriverData->dwOverlayOwner = 0;
                               pDriverData->extra422OverlayOffset[0] = 0;
                               pDriverData->extra422OverlayOffset[1] = 0;
                           }
                       }
                       index++;
                   }
               }

               if ((psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
                   ((psurf->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) == 0)) {
                   if (psurf_gbl->fpVidMem > 0) {
                       if (psurf_gbl->fpVidMem + psurf_gbl->dwReserved1 - pDriverData->BaseAddress ==
                           pDriverData->extra422OverlayOffset[0]) {
                           pDriverData->extra422OverlayOffset[0] = 0;
                           pDriverData->extra422OverlayOffset[1] = 0;
                       }
                       NVHEAP_FREE (psurf_gbl->fpVidMem);
                       //DDHAL32_VidMemFree(pdrv, 0, psurf_gbl->fpVidMem);
                       psurf_gbl->fpVidMem = 0;
                       if (pDriverData->DDrawVideoSurfaceCount > 0)
                           pDriverData->DDrawVideoSurfaceCount--;
                   }
               } else {
                   if ((pDriverData->fNvActiveFloatingContexts) &&
                       ((psurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_UYVY) ||
                        (psurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_UYNV) ||
                        (psurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_YUY2) ||
                        (psurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_YUNV))) {

                       if (npDev == NULL) {  /* Mode switches might occur without warning */
                           lpDestroySurface->ddRVal = DDERR_SURFACELOST;
                           return DDHAL_DRIVER_HANDLED;
                       }

                       DestroyFloating422Context32(psurf);
                   }

                   hMem = (HGLOBAL)psurf_gbl->dwReserved1;
                   GlobalUnlock(hMem);
                   GlobalFree(hMem);
               }
               psurf_gbl->dwReserved1 = 0;
               lpDestroySurface->ddRVal = DD_OK;
               return DDHAL_DRIVER_HANDLED;
               break;
            case FOURCC_YV12:
            case FOURCC_420i:
               if (psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
                   while (index < NV_MAX_OVERLAY_SURFACES) {
                       if ((DWORD)psurf == pDriverData->dwOverlaySurfaceLCL[index]) {
                           pDriverData->dwOverlaySurfaceLCL[index] = 0;
                           if (pDriverData->dwOverlaySurfaces > 0)
                               pDriverData->dwOverlaySurfaces--;
                           if (pDriverData->dwOverlaySurfaces == 0) {
                               pDriverData->dwOverlayOwner = 0;
                           }
                       }
                       index++;
                   }
               }

               if ((psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
                   (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)) {
                   if (psurf_gbl->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0]) {

                       if (pDriverData->NvYUY2Surface0Mem > 0) {
                           NVHEAP_FREE (pDriverData->NvYUY2Surface0Mem);
                           //DDHAL32_VidMemFree(pdrv, 0, pDriverData->NvYUY2Surface0Mem);
                           pDriverData->NvYUY2Surface0Mem = 0;
                           if (pDriverData->DDrawVideoSurfaceCount > 0)
                               pDriverData->DDrawVideoSurfaceCount--;
                       }

                       NV_DD_DMA_PUSHER_SYNC();

                       if (npDev == NULL) {  /* Mode switches might occur without warning */
                           lpDestroySurface->ddRVal = DDERR_SURFACELOST;
                           return DDHAL_DRIVER_HANDLED;
                       }

                       /* If AGP memory then send a sync rectangle to make sure we are done with it */
                       if (psurf->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) {
                           NvNotification *pDmaSyncNotifier =
                               (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;
                           unsigned long *dmaPusherPutAddress =
                               (unsigned long *)pDriverData->NvDmaPusherPutAddress;
                           unsigned long *dmaPusherBufferBase =
                               (unsigned long *)pDriverData->NvDmaPusherBufferBase;
#ifdef  CACHE_FREECOUNT
                           long freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
                           NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
                           long freeCount = 0;
#endif  /* CACHE_FREECOUNT */

                           /* Let D3D code know that we have touched NV */
                           pDriverData->TwoDRenderingOccurred = 1;

                           // MUST wait for any pending notification to prevent possible loss of notification serialization
                           while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP;

                           while (freeCount < 4)
                               NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
                           freeCount -= 4;

                           pDmaSyncNotifier->status = NV_IN_PROGRESS;

                           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                               RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
                           dmaPusherPutAddress[1] = 0;
                           dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                               RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
                           dmaPusherPutAddress[3] = 0;

                           dmaPusherPutAddress += 4;

                           pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                           /* Force write combine buffer to flush */
                           pDriverData->NvDmaPusherBufferEnd[0] = 0;
                           /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                           _outp (0x3d0,0);

                           pDriverData->dwDmaPusherFreeCount = freeCount;

                           npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                           while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification
                       }

                       if ((pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] <
                            pDriverData->BaseAddress) || /* If system memory */
                           (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] >
                           (unsigned long)pDriverData->VideoHeapEnd)) {
                           NvNotification *pDmaSyncNotifier =
                               (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;
                           unsigned long *dmaPusherPutAddress =
                               (unsigned long *)pDriverData->NvDmaPusherPutAddress;
                           unsigned long *dmaPusherBufferBase =
                               (unsigned long *)pDriverData->NvDmaPusherBufferBase;
#ifdef  CACHE_FREECOUNT
                           long freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
                           NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
                           long freeCount = 0;
#endif  /* CACHE_FREECOUNT */

                           /* Let D3D code know that we have touched NV */
                           pDriverData->TwoDRenderingOccurred = 1;

                           // MUST wait for any pending notification to prevent possible loss of notification serialization
                           while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP;

                           while (freeCount < 28)
                               NvGetDmaBufferFreeCount(npDev, freeCount, 28, dmaPusherPutAddress);
                           freeCount -= 28;

                           pDriverData->dDrawSpareSubchannelObject = 0;

                           pDmaSyncNotifier->status = NV_IN_PROGRESS;

                           /* Trash spare subchannel */
                           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                           dmaPusherPutAddress[1] = NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;
                           dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                               MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                           dmaPusherPutAddress[3] = NV1_NULL_OBJECT;
                           dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SPARE) +
                               MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                           dmaPusherPutAddress[5] = NV1_NULL_OBJECT;
                           dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                           dmaPusherPutAddress[7] = NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT;
                           dmaPusherPutAddress[8] = dDrawSubchannelOffset(NV_DD_SPARE) +
                               MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                           dmaPusherPutAddress[9] = NV1_NULL_OBJECT;
                           dmaPusherPutAddress[10] = dDrawSubchannelOffset(NV_DD_SPARE) +
                               MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                           dmaPusherPutAddress[11] = NV1_NULL_OBJECT;
                           dmaPusherPutAddress[12] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                           dmaPusherPutAddress[13] = NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT;
                           dmaPusherPutAddress[14] = dDrawSubchannelOffset(NV_DD_SPARE) +
                               MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                           dmaPusherPutAddress[15] = NV1_NULL_OBJECT;
                           dmaPusherPutAddress[16] = dDrawSubchannelOffset(NV_DD_SPARE) +
                               MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                           dmaPusherPutAddress[17] = NV1_NULL_OBJECT;
                           dmaPusherPutAddress[18] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                           dmaPusherPutAddress[19] = NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT;
                           dmaPusherPutAddress[20] = dDrawSubchannelOffset(NV_DD_SPARE) +
                               MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                           dmaPusherPutAddress[21] = NV1_NULL_OBJECT;
                           dmaPusherPutAddress[22] = dDrawSubchannelOffset(NV_DD_SPARE) +
                               MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                           dmaPusherPutAddress[23] = NV1_NULL_OBJECT;
                           dmaPusherPutAddress[24] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                               RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
                           dmaPusherPutAddress[25] = 0;
                           dmaPusherPutAddress[26] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                               RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
                           dmaPusherPutAddress[27] = 0;

                           dmaPusherPutAddress += 28;

                           pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                           /* Force write combine buffer to flush */
                           pDriverData->NvDmaPusherBufferEnd[0] = 0;
                           /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                           _outp (0x3d0,0);

                           pDriverData->dwDmaPusherFreeCount = freeCount;

                           npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                           while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification

                           NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                                    NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY);
                       }

                        /* If in AGP memory then deallocate it from there */
                       if (psurf->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) {
                           DDHAL32_VidMemFree(pdrv, AGP_HEAP, psurf_gbl->fpVidMem);
                       } else {
                           if ((pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] <
                                pDriverData->BaseAddress) || /* If system memory */
                               (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] >
                               (unsigned long)pDriverData->VideoHeapEnd)) {
                               GlobalUnlock((HGLOBAL)pDriverData->NvFloatingMem2MemFormatMemoryHandle);
                               GlobalFree((HGLOBAL)pDriverData->NvFloatingMem2MemFormatMemoryHandle);
                           } else {
                               NVHEAP_FREE (psurf_gbl->fpVidMem);
                               //DDHAL32_VidMemFree(pdrv, 0, psurf_gbl->fpVidMem);
                               if (pDriverData->DDrawVideoSurfaceCount > 0)
                                   pDriverData->DDrawVideoSurfaceCount--;
                           }
                       }

                       pDriverData->NvFloatingMem2MemFormatMemoryHandle = 0;

                       pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] = 0;
                       pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1] = 0;
                       pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2] = 0;
                       pDriverData->NvFloatingMem2MemFormatSurfaceAddress[3] = 0;

                   } else {
                       if (psurf_gbl->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1]) {
                           pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1] = 0;
                           if (pDriverData->NvYUY2Surface1Mem > 0) {
                               NVHEAP_FREE (pDriverData->NvYUY2Surface1Mem);
                               //DDHAL32_VidMemFree(pdrv, 0, pDriverData->NvYUY2Surface1Mem);
                               pDriverData->NvYUY2Surface1Mem = 0;
                               if (pDriverData->DDrawVideoSurfaceCount > 0)
                                   pDriverData->DDrawVideoSurfaceCount--;
                           }
                       } else if (psurf_gbl->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2]) {
                           pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2] = 0;
                           if (pDriverData->NvYUY2Surface2Mem > 0) {
                               NVHEAP_FREE (pDriverData->NvYUY2Surface2Mem);
                               //DDHAL32_VidMemFree(pdrv, 0, pDriverData->NvYUY2Surface2Mem);
                               pDriverData->NvYUY2Surface2Mem = 0;
                               if (pDriverData->DDrawVideoSurfaceCount > 0)
                                   pDriverData->DDrawVideoSurfaceCount--;
                           }
                       } else {
                           if (pDriverData->NvYUY2Surface3Mem > 0) {
                               NVHEAP_FREE (pDriverData->NvYUY2Surface3Mem);
                               //DDHAL32_VidMemFree(pdrv, 0, pDriverData->NvYUY2Surface3Mem);
                               pDriverData->NvYUY2Surface3Mem = 0;
                               if (pDriverData->DDrawVideoSurfaceCount > 0)
                                   pDriverData->DDrawVideoSurfaceCount--;
                           }
                       }
                   }
                   psurf_gbl->fpVidMem = 0;
               } else if (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {
                   if (psurf_gbl->fpVidMem > 0) {
                       NVHEAP_FREE (psurf_gbl->fpVidMem);
                       //DDHAL32_VidMemFree(pdrv, 0, psurf_gbl->fpVidMem);
                       psurf_gbl->fpVidMem = 0;
                       if (pDriverData->DDrawVideoSurfaceCount > 0)
                           pDriverData->DDrawVideoSurfaceCount--;
                   }
               } else {
                   hMem = (HGLOBAL)psurf_gbl->dwReserved1;
                   GlobalUnlock(hMem);
                   GlobalFree(hMem);
               }
               psurf_gbl->dwReserved1 = 0;
               lpDestroySurface->ddRVal = DD_OK;
               return DDHAL_DRIVER_HANDLED;
               break;
        }
    } else if ((psurf->ddsCaps.dwCaps & DDSCAPS_OFFSCREENPLAIN) &&
        (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)) {
#ifndef WINNT
        if (psurf_gbl->fpVidMem > 0) {
#endif
            if ((psurf->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) &&
               (pDriverData->GARTLinearBase > 0)) {

               DDHAL32_VidMemFree(pdrv, AGP_HEAP, psurf_gbl->fpVidMem); // AGP memory
                } else {
               NVHEAP_FREE (psurf_gbl->fpVidMem);
               //DDHAL32_VidMemFree(pdrv, 0, psurf_gbl->fpVidMem);
               if (pDriverData->DDrawVideoSurfaceCount > 0)
                   pDriverData->DDrawVideoSurfaceCount--;
            }
            psurf_gbl->fpVidMem = 0;
#ifdef WINNT
            psurf_gbl->lPitch = 0;
#else
        }
#endif
        DPF( "    Offscreen deallocated" );
        psurf_gbl->dwReserved1 = 0;
        lpDestroySurface->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    } else if (psurf->ddsCaps.dwCaps & DDSCAPS_TEXTURE) {
        /*
         * Call the D3D driver to destroy the texture surface.
         */
        nvDestroyTextureSurface(lpDestroySurface, psurf, psurf_gbl);
        return DDHAL_DRIVER_HANDLED;
    } else if (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {
#ifndef WINNT
        if (psurf_gbl->fpVidMem > 0) {
#endif
            if ((psurf->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) &&
               (pDriverData->GARTLinearBase > 0))
               {
               DDHAL32_VidMemFree(pdrv, AGP_HEAP, psurf_gbl->fpVidMem); // AGP memory
                } else {
               NVHEAP_FREE (psurf_gbl->fpVidMem);
               //DDHAL32_VidMemFree(pdrv, 0, psurf_gbl->fpVidMem);
               if (pDriverData->DDrawVideoSurfaceCount > 0)
                   pDriverData->DDrawVideoSurfaceCount--;
            }
            psurf_gbl->fpVidMem = 0;
#ifdef WINNT
            psurf_gbl->lPitch = 0;
#else
        } else {
            DPF( "    Unspecified Video Memory deallocation not handled");
            return DDHAL_DRIVER_NOTHANDLED;
        }
#endif
        DPF( "    Offscreen deallocated" );
        psurf_gbl->dwReserved1 = 0;
        lpDestroySurface->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    } else if (psurf->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) {
        DPF( "    System memory deallocated" );
        hMem = (HGLOBAL)psurf_gbl->dwReserved1;
        GlobalUnlock(hMem);
        GlobalFree(hMem);
        psurf_gbl->dwReserved1 = 0;
        lpDestroySurface->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    return DDHAL_DRIVER_NOTHANDLED;
}



/*
 * CreateSurface32
 */
DWORD __stdcall CreateSurface32( LPDDHAL_CREATESURFACEDATA lpCreateSurface )
{
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    BOOL                        handled;
    int                         i;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf;
    LPDDRAWI_DDRAWSURFACE_LCL   *powner;
    LPDDRAWI_DDRAWSURFACE_GBL   psurf_gbl;
    LONG                        pitch;
    LONG                        adjustedHeight;
    HGLOBAL                     hMem;
    DWORD                       dwBlockSize;
    DWORD                       *fpVidMem;
    HRESULT                     ddrval;
    DWORD                       memType;
    DWORD                       index;
#ifdef DEBUG
    char                        fourCCStr[5];
#endif // DEBUG

    NvSetDriverDataPtr(lpCreateSurface->lpDD);

#if 0 //def WINNT
    /*
     * Under NT, if this is the "first" ddraw surface allocation, move all
     * offscreen DFBs into sys memory to make room for ddraw surfaces.
     */
     if (pDriverData->DDrawVideoSurfaceCount == 0) {
        bMoveAllDfbsFromOffscreenToDibs(pDriverData->ppdev);
        }
#endif

    /*
     * Reset NV and get the monitor frequency after a mode reset
     */
    if( pDriverData->fReset ) {
        getDisplayDuration();
        if (!ResetNV()) {
            lpCreateSurface->ddRVal = DDERR_GENERIC;
            return(DDHAL_DRIVER_HANDLED);
        }
        pDriverData->fReset = FALSE;
    }

    /*
     * is a flip in progress?
     */
    {
        HRESULT ddrval = updateFlipStatus(0);
        while (ddrval == DDERR_WASSTILLDRAWING)
        {
            NV_SLEEPFLIP;
            ddrval = updateFlipStatus(0);
        }
    }

    /*
     * NOTES:
     *
     * This callback is invoked once the surface objects have been created.
     * You can:
     *   - compute the size of the block, by returning
     *     DDHAL_PLEASEALLOC_BLOCKSIZE in fpVidMem, and putting the size
     *     in dwBlockSizeX and dwBlockSizeY
     *   - override some fields in the surface structure, like the pitch.
     *     (you must specifiy the pitch if you are computing the size)
     */

    pdrv = lpCreateSurface->lpDD;
    DPF( "in CreateSurface, lpCreateSurface->lpDD=%08lx, lpCreateSurface->lpDDSurfaceDesc = %08lx",
                pdrv, lpCreateSurface->lpDDSurfaceDesc );
    DPF( "lpCreateSurface->lplpSList=%08lx, lpCreateSurface->dwSCnt = %d", lpCreateSurface->lplpSList, lpCreateSurface->dwSCnt );

    /*
     * see if any of these surfaces are FOURCC codes...
     */
    handled = FALSE;

    powner = lpCreateSurface->lplpSList;

    for( i=0;i<(int)lpCreateSurface->dwSCnt;i++ ) {
        psurf = lpCreateSurface->lplpSList[i];
        psurf_gbl = psurf->lpGbl;

        DPF( "psurf=%08lx, psurf->lpGbl=%08lx", psurf, psurf_gbl );
        if (psurf->dwFlags & DDRAWISURF_HASPIXELFORMAT) {

            if (psurf_gbl->ddpfSurface.dwFlags & DDPF_ALPHAPREMULT) {
                DPF( "  ALPHA_PREMULT surface requested" );

                pitch = psurf_gbl->wWidth *
                        (pDriverData->bi.biBitCount >> 3);
                pitch = (pitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
                dwBlockSize = (pitch * ((DWORD)psurf_gbl->wHeight));
                psurf_gbl->ddpfSurface.dwRGBBitCount = pDriverData->bi.biBitCount;
                psurf_gbl->ddpfSurface.dwRGBAlphaBitMask = 0xFF000000;
                psurf_gbl->ddpfSurface.dwRBitMask = 0x00FF0000;
                psurf_gbl->ddpfSurface.dwGBitMask = 0x0000FF00;
                psurf_gbl->ddpfSurface.dwBBitMask = 0x000000FF;
                psurf_gbl->lPitch = pitch;
                psurf_gbl->fpVidMem = 0;
                psurf_gbl->dwReserved1 = 0;
                handled = TRUE;

                if (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {

                    /*
                     * Notify 16 bit display driver code that Direct Draw is beginning
                     * to use local video memory.
                     */
#ifndef WINNT
                    if (pDriverData->DDrawVideoSurfaceCount == 0) {
                        HDC hdc = GetDC(0);
                        ExtEscape(hdc, RECONFIGNVOFFSCREEN, 0, 0, 0, 0);
                    }
#endif // #ifndef WINNT

                    NVHEAP_ALLOC(psurf_gbl->fpVidMem, dwBlockSize, TYPE_IMAGE);
                    //psurf_gbl->fpVidMem = DDHAL32_VidMemAlloc(pdrv, 0, dwBlockSize, 1);

                    if (psurf_gbl->fpVidMem != 0) {
                        pDriverData->DDrawVideoSurfaceCount++;
                        psurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
                        psurf->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;
                        break;
                    }
                }

                hMem = GlobalAlloc(GHND | GMEM_SHARE, dwBlockSize);
                if (!hMem) {
                    DPF( "    System memory ALPHA_PREMULT surface allocation failed" );
                    lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
                    return DDHAL_DRIVER_HANDLED;
                } else {
                    DPF( "    System memory ALPHA_PREMULT surface allocation succeeded" );
                    psurf_gbl->fpVidMem = (FLATPTR)GlobalLock(hMem);
                    psurf_gbl->dwReserved1 = (DWORD)hMem;
                    psurf->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
                }
            }

            if (psurf_gbl->ddpfSurface.dwFlags & DDPF_FOURCC) {
                 DPF( "  FOURCC surface requested" );
                /*
                 * we know the FOURCC code is OK, because we validated it
                 * during CanCreateSurface.   Compute a block size based
                 * on the code, and allocate system memory for it.
                 */
                switch( psurf->lpGbl->ddpfSurface.dwFourCC ) {
                    case FOURCC_RGB0:
                    case FOURCC_RAW8:
                       if (psurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_RAW8)
                           pitch = psurf_gbl->wWidth;
                       else
                           pitch = psurf_gbl->wWidth *
                               (pDriverData->bi.biBitCount >> 3);
                       pitch = (pitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
                       dwBlockSize = (pitch * ((DWORD)psurf_gbl->wHeight));
                       if (psurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_RAW8) {
                           psurf_gbl->ddpfSurface.dwRGBBitCount = 8;
                           psurf_gbl->ddpfSurface.dwRBitMask = 0;
                           psurf_gbl->ddpfSurface.dwGBitMask = 0;
                           psurf_gbl->ddpfSurface.dwBBitMask = 0;
                       } else {
                           psurf_gbl->ddpfSurface.dwRGBBitCount = pDriverData->bi.biBitCount;
                           if (pDriverData->bi.biBitCount == 8) {
                               psurf_gbl->ddpfSurface.dwRBitMask = 0;
                               psurf_gbl->ddpfSurface.dwGBitMask = 0;
                               psurf_gbl->ddpfSurface.dwBBitMask = 0;
                               psurf_gbl->ddpfSurface.dwFlags |= DDPF_PALETTEINDEXED8;
                           } else if (pDriverData->bi.biBitCount == 16) {

                               psurf_gbl->ddpfSurface.dwRBitMask = 0x0000F800;
                               psurf_gbl->ddpfSurface.dwGBitMask = 0x000007E0;
                               psurf_gbl->ddpfSurface.dwBBitMask = 0x0000001F;

                           } else if (pDriverData->bi.biBitCount == 32) {
                               psurf_gbl->ddpfSurface.dwRBitMask = 0x00FF0000;
                               psurf_gbl->ddpfSurface.dwGBitMask = 0x0000FF00;
                               psurf_gbl->ddpfSurface.dwBBitMask = 0x000000FF;
                           }
                       }
                       psurf_gbl->ddpfSurface.dwRGBAlphaBitMask = 0;
#ifdef DEBUG
                       fourCCStr[0] = (char)psurf_gbl->ddpfSurface.dwFourCC & 0xFF;
                       fourCCStr[1] = (char)(psurf_gbl->ddpfSurface.dwFourCC >> 8) & 0xFF;
                       fourCCStr[2] = (char)(psurf_gbl->ddpfSurface.dwFourCC >> 16) & 0xFF;
                       fourCCStr[3] = (char)(psurf_gbl->ddpfSurface.dwFourCC >> 24) & 0xFF;
                       fourCCStr[4] = 0;
                       DPF( "FOURCC %s allocation: size=%lu bytes", &fourCCStr, dwBlockSize );
#endif // DEBUG
                       psurf_gbl->lPitch = pitch;
                       psurf_gbl->fpVidMem = 0;
                       psurf_gbl->dwReserved1 = 0;
                       psurf->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;
                       handled = TRUE;

                       if (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {

                           /*
                            * Notify 16 bit display driver code that Direct Draw is beginning
                            * to use local video memory.
                            */
#ifndef WINNT
                           if (pDriverData->DDrawVideoSurfaceCount == 0) {
                               HDC hdc = GetDC(0);
                               ExtEscape(hdc, RECONFIGNVOFFSCREEN, 0, 0, 0, 0);
                           }
#endif // #ifndef WINNT

                           NVHEAP_ALLOC(psurf_gbl->fpVidMem, dwBlockSize, TYPE_IMAGE);
                           //psurf_gbl->fpVidMem = DDHAL32_VidMemAlloc(pdrv, 0, dwBlockSize, 1);

                           if (psurf_gbl->fpVidMem != 0) {
                               pDriverData->DDrawVideoSurfaceCount++;
                               psurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
                               psurf->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;
                               break;
                           }
                       }

                       hMem = GlobalAlloc(GHND | GMEM_SHARE, dwBlockSize);
                       if (!hMem) {
                           DPF( "    System memory FOURCC surface allocation failed" );
                           lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
                           return DDHAL_DRIVER_HANDLED;
                       } else {
                           DPF( "    System memory FOURCC surface allocation succeeded" );
                           psurf_gbl->fpVidMem = (FLATPTR)GlobalLock(hMem);
                           psurf_gbl->dwReserved1 = (DWORD)hMem;
                           psurf->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
                       }
                    break;

                    case FOURCC_IF09:
                    case FOURCC_YVU9:
                    case FOURCC_IV32:
                    case FOURCC_IV31:

                       if ((psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
                           (pDriverData->dwOverlaySurfaces > 0)) {
                           if (pDriverData->OverlayRelaxOwnerCheck)
                                pDriverData->dwOverlayOwner = (DWORD)powner;
                           if ((pDriverData->dwOverlayOwner != (DWORD)powner) ||
                               (pDriverData->dwOverlaySurfaces + 1 >= NV_MAX_OVERLAY_SURFACES)) {
                               lpCreateSurface->ddRVal = DDERR_OUTOFCAPS;
                               return DDHAL_DRIVER_HANDLED;
                           }
                       }

                       /* First allocate enough video memory for YUY2 overlay pixel area */
                       pitch = ((psurf_gbl->wWidth + 1) & 0xFFFE) << 1;
                       pitch = (pitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
                       /* pad with an extra scanline */
                       dwBlockSize = (pitch * (DWORD)psurf_gbl->wHeight);
                       /* now allocate enough video memory for the Indeo part of the surface */
                       pitch = psurf_gbl->wWidth;
                       /* allow extra room for block skip bits between Indeo portion of surface and YUY2 portion */
                       dwBlockSize += ((pitch * ((DWORD)psurf_gbl->wHeight * 10L)) >> 3);
                       /* Force block to be properly aligned */
                       dwBlockSize = (dwBlockSize + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;

                       if ((psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) && (pDriverData->TotalVRAM >> 20 > 4)) {
                           /* Remember offset to 2nd half YUY2 portion of surface */
                           psurf_gbl->dwReserved1 = dwBlockSize;
                           /* Double actual amount of YUY2 video memory allocated for this surface */
                           pitch = ((psurf_gbl->wWidth + 1) & 0xFFFE) << 1;
                           pitch = (pitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
                           /* pad with an extra scanline */
                           dwBlockSize += (pitch * (DWORD)psurf_gbl->wHeight);
                           /* reset pitch to actual Indeo surface pitch */
                           pitch = psurf_gbl->wWidth;
                       } else
                           psurf_gbl->dwReserved1 = 0;

                       psurf_gbl->ddpfSurface.dwYUVBitCount = 9;
                       psurf_gbl->ddpfSurface.dwYBitMask = 0;
                       psurf_gbl->ddpfSurface.dwUBitMask = 0;
                       psurf_gbl->ddpfSurface.dwVBitMask = 0;
                       psurf_gbl->ddpfSurface.dwYUVAlphaBitMask = 0;
#ifdef DEBUG
                       fourCCStr[0] = (char)psurf_gbl->ddpfSurface.dwFourCC & 0xFF;
                       fourCCStr[1] = (char)(psurf_gbl->ddpfSurface.dwFourCC >> 8) & 0xFF;
                       fourCCStr[2] = (char)(psurf_gbl->ddpfSurface.dwFourCC >> 16) & 0xFF;
                       fourCCStr[3] = (char)(psurf_gbl->ddpfSurface.dwFourCC >> 24) & 0xFF;
                       fourCCStr[4] = 0;
                       DPF( "FOURCC %s allocation: size=%lu bytes", &fourCCStr, dwBlockSize );
#endif // DEBUG
                       psurf_gbl->lPitch = pitch;
                       psurf_gbl->fpVidMem = 0;
                       psurf->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;
                       handled = TRUE;

                       if (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {

                           /*
                            * Notify 16 bit display driver code that Direct Draw is beginning
                            * to use local video memory.
                            */
#ifndef WINNT
                           if (pDriverData->DDrawVideoSurfaceCount == 0) {
                               HDC hdc = GetDC(0);
                               ExtEscape(hdc, RECONFIGNVOFFSCREEN, 0, 0, 0, 0);
                           }
#endif // #ifndef WINNT

                           NVHEAP_ALLOC(psurf_gbl->fpVidMem, dwBlockSize, TYPE_OVERLAY);
                           //psurf_gbl->fpVidMem = DDHAL32_VidMemAlloc(pdrv, 0, dwBlockSize, 1);

                           if (psurf_gbl->fpVidMem != 0) {
                               pDriverData->DDrawVideoSurfaceCount++;
                               psurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
                               psurf->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;

                               if (psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
                                   index = 0;
                                   while ((pDriverData->dwOverlaySurfaceLCL[index] != 0) &&
                                          (index < NV_MAX_OVERLAY_SURFACES))
                                          index++;
                                   pDriverData->dwOverlaySurfaceLCL[index] = (DWORD) psurf;
                                   pDriverData->dwOverlayOwner = (DWORD)powner;
                                   pDriverData->dwOverlaySurfaces++;
                               }

                               break;
                           } else {
                               /* We can't support overlay surfaces in system memory */
                               if (psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
                                   lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
                                   return DDHAL_DRIVER_HANDLED;
                               }
                           }
                       }

                       hMem = GlobalAlloc(GHND | GMEM_SHARE, dwBlockSize);
                       if (!hMem) {
                           DPF( "    System memory FOURCC surface allocation failed" );
                           lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
                           return DDHAL_DRIVER_HANDLED;
                       } else {
                           DPF( "    System memory FOURCC surface allocation succeeded" );
                           psurf_gbl->fpVidMem = (FLATPTR)GlobalLock(hMem);
                           psurf_gbl->dwReserved1 = (DWORD)hMem;
                           psurf->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
                       }

                       if (psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
                           index = 0;
                           while ((pDriverData->dwOverlaySurfaceLCL[index] != 0) &&
                                  (index < NV_MAX_OVERLAY_SURFACES))
                                  index++;
                           pDriverData->dwOverlaySurfaceLCL[index] = (DWORD) psurf;
                           pDriverData->dwOverlayOwner = (DWORD)powner;
                           pDriverData->dwOverlaySurfaces++;
                       }

                    break;

                    case FOURCC_YUY2:
                    case FOURCC_YUNV:
                    case FOURCC_UYVY:
                    case FOURCC_UYNV:

                       if ((psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
                           (pDriverData->dwOverlaySurfaces > 0)) {
                           if (pDriverData->OverlayRelaxOwnerCheck)
                                pDriverData->dwOverlayOwner = (DWORD)powner;
                           if ((pDriverData->dwOverlayOwner != (DWORD)powner) ||
                               (pDriverData->dwOverlaySurfaces + 1 >= NV_MAX_OVERLAY_SURFACES)) {
                               lpCreateSurface->ddRVal = DDERR_OUTOFCAPS;
                               return DDHAL_DRIVER_HANDLED;
                           }
                       }

                       /* First try video memory */
                       pitch = ((psurf_gbl->wWidth + 1) & 0xFFFE) << 1;
                       pitch = (pitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
                       /* pad with an extra scanline */
                       dwBlockSize = (pitch * (DWORD)psurf_gbl->wHeight);
                       psurf_gbl->ddpfSurface.dwYUVBitCount = 16;
                       if (psurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_YUY2) {
                           psurf_gbl->ddpfSurface.dwYBitMask = 0x00FF00FF;
                           psurf_gbl->ddpfSurface.dwUBitMask = 0x0000FF00;
                           psurf_gbl->ddpfSurface.dwVBitMask = 0xFF000000;
                       } else {
                           psurf_gbl->ddpfSurface.dwYBitMask = 0xFF00FF00;
                           psurf_gbl->ddpfSurface.dwUBitMask = 0x000000FF;
                           psurf_gbl->ddpfSurface.dwVBitMask = 0x00FF0000;
                       }
                       psurf_gbl->ddpfSurface.dwYUVAlphaBitMask = 0;
#ifdef DEBUG
                       fourCCStr[0] = (char)psurf_gbl->ddpfSurface.dwFourCC & 0xFF;
                       fourCCStr[1] = (char)(psurf_gbl->ddpfSurface.dwFourCC >> 8) & 0xFF;
                       fourCCStr[2] = (char)(psurf_gbl->ddpfSurface.dwFourCC >> 16) & 0xFF;
                       fourCCStr[3] = (char)(psurf_gbl->ddpfSurface.dwFourCC >> 24) & 0xFF;
                       fourCCStr[4] = 0;
                       DPF( "FOURCC %s allocation: size=%lu bytes", &fourCCStr, dwBlockSize );
#endif // DEBUG
                       psurf_gbl->lPitch = pitch;
                       psurf_gbl->dwReserved1 = 0;
                       psurf_gbl->fpVidMem = 0;
                       psurf->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;
                       handled = TRUE;

                       /*
                        * Notify 16 bit display driver code that Direct Draw is beginning
                        * to use local video memory.
                        */
#ifndef WINNT
                       if (pDriverData->DDrawVideoSurfaceCount == 0) {
                           HDC hdc = GetDC(0);
                           ExtEscape(hdc, RECONFIGNVOFFSCREEN, 0, 0, 0, 0);
                       }
#endif // #ifndef WINNT

                       if ((psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) && (pDriverData->TotalVRAM >> 20 > 4)) {
                           /* Remember offset to 2nd half of surface */
                           psurf_gbl->dwReserved1 = dwBlockSize;
                           /* Tripple actual amount of video memory allocated for this surface only */
                           if (pDriverData->extra422OverlayOffset[0] == 0)
                               dwBlockSize *= 3;
                       }

                       NVHEAP_ALLOC(psurf_gbl->fpVidMem, dwBlockSize, TYPE_OVERLAY);
                       //psurf_gbl->fpVidMem = DDHAL32_VidMemAlloc(pdrv, 0, dwBlockSize, 1);

                       if (psurf_gbl->fpVidMem != 0) {
                           pDriverData->DDrawVideoSurfaceCount++;
                           psurf->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
                           psurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
                           if ((psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
                               (pDriverData->TotalVRAM >> 20 > 4) &&
                               (pDriverData->extra422OverlayOffset[0] == 0)) {
                               pDriverData->extra422OverlayOffset[0] =
                                   psurf_gbl->fpVidMem - pDriverData->BaseAddress;
                               pDriverData->extra422OverlayOffset[0] += psurf_gbl->dwReserved1;
                               pDriverData->extra422OverlayOffset[1] =
                                   pDriverData->extra422OverlayOffset[0] + psurf_gbl->dwReserved1;
                           }
                       } else {
                           /* We can't support overlay surfaces in system memory */
                           if (psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
                               lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
                               return DDHAL_DRIVER_HANDLED;
                           }

                           hMem = GlobalAlloc(GHND | GMEM_SHARE, dwBlockSize);

                           if (!hMem) {
                               DPF( "    System memory FOURCC surface allocation failed" );
                               lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
                               return DDHAL_DRIVER_HANDLED;
                           } else {

                               DPF( "    System memory FOURCC surface allocation succeeded" );
                               psurf_gbl->fpVidMem = (FLATPTR)GlobalLock(hMem);
                               psurf_gbl->dwReserved1 = (DWORD)hMem;
                               psurf->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;

                               CreateFloating422Context32(psurf, dwBlockSize);
                           }
                       }

                       if (psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
                           index = 0;
                           while ((pDriverData->dwOverlaySurfaceLCL[index] != 0) &&
                                  (index < NV_MAX_OVERLAY_SURFACES))
                                  index++;
                           pDriverData->dwOverlaySurfaceLCL[index] = (DWORD) psurf;
                           pDriverData->dwOverlayOwner = (DWORD)powner;
                           pDriverData->dwOverlaySurfaces++;
                       }

                    break;

                    case FOURCC_YV12:
                    case FOURCC_420i:

                       if ((psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
                           (pDriverData->dwOverlaySurfaces > 0)) {
                           if (pDriverData->OverlayRelaxOwnerCheck)
                                pDriverData->dwOverlayOwner = (DWORD)powner;
                           if ((pDriverData->dwOverlayOwner != (DWORD)powner) ||
                               (pDriverData->dwOverlaySurfaces + 1 >= NV_MAX_OVERLAY_SURFACES)) {
                               lpCreateSurface->ddRVal = DDERR_OUTOFCAPS;
                               return DDHAL_DRIVER_HANDLED;
                           }
                       }

                       /*
                        * Always split allocation of YV12/420i overlay surfaces.
                        *   Allocate the YV12/420i portion in AGP memory on AGP systems, local video memory on PCI systems.
                        *   Fall back to system memory only if preferred allocation fails.
                        *   Allocate additional YUY2 surfaces in local video memory for the video scaler to use
                        */
                       psurf_gbl->ddpfSurface.dwYUVBitCount = 12;
                       psurf_gbl->ddpfSurface.dwYBitMask = 0;
                       psurf_gbl->ddpfSurface.dwUBitMask = 0;
                       psurf_gbl->ddpfSurface.dwVBitMask = 0;
                       psurf_gbl->ddpfSurface.dwYUVAlphaBitMask = 0;

                       psurf_gbl->fpVidMem = 0;
                       psurf_gbl->dwReserved1 = 0;
                       psurf->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;
                       handled = TRUE;

                       pitch = ((psurf_gbl->wWidth + 1) & 0xFFFE) << 1;
                       pitch = (pitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;

                       adjustedHeight = (DWORD)((psurf_gbl->wHeight + 1) & ~1);

                       dwBlockSize = pitch * adjustedHeight;

                       if ((psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) && (pDriverData->TotalVRAM >> 20 > 4)) {
                           /* Remember offset to 2nd half of surface */
                           psurf_gbl->dwReserved1 = dwBlockSize;
                           /* Double actual amount of video memory allocated for this surface */
                           dwBlockSize <<= 1;
                       }

                       if (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {

                           /*
                            * Notify 16 bit display driver code that Direct Draw is beginning
                            * to use local video memory.
                            */
#ifndef WINNT
                           if (pDriverData->DDrawVideoSurfaceCount == 0) {
                               HDC hdc = GetDC(0);
                               ExtEscape(hdc, RECONFIGNVOFFSCREEN, 0, 0, 0, 0);
                           }
#endif // #ifndef WINNT

                           NVHEAP_ALLOC((unsigned long)fpVidMem, dwBlockSize, TYPE_OVERLAY);
                           //fpVidMem = (DWORD *)DDHAL32_VidMemAlloc(pdrv, 0, dwBlockSize, 1);

                           if (fpVidMem != 0) {
                               pDriverData->DDrawVideoSurfaceCount++;
                               psurf->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;
                               if (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] == 0)
                                   pDriverData->NvYUY2Surface0Mem = (DWORD)fpVidMem; /* save pointer to YUY2 overlay surface */
                               else if (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1] == 0)
                                   pDriverData->NvYUY2Surface1Mem = (DWORD)fpVidMem;
                               else if (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2] == 0)
                                   pDriverData->NvYUY2Surface2Mem = (DWORD)fpVidMem;
                               else if (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[3] == 0)
                                   pDriverData->NvYUY2Surface3Mem = (DWORD)fpVidMem;
                           } else {
                               /* one or more overlay surfaces could not be allocated, clean up already allocated memory */
                               if (pDriverData->NvYUY2Surface2Mem > 0) {
                                   NVHEAP_FREE (pDriverData->NvYUY2Surface2Mem);
                                   //DDHAL32_VidMemFree(pdrv, 0, pDriverData->NvYUY2Surface2Mem);
                                   pDriverData->NvYUY2Surface2Mem = 0;
                                   pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2] = 0;
                                   if (pDriverData->DDrawVideoSurfaceCount > 0)
                                       pDriverData->DDrawVideoSurfaceCount--;
                               }

                               if (pDriverData->NvYUY2Surface1Mem > 0) {
                                   NVHEAP_FREE (pDriverData->NvYUY2Surface1Mem);
                                   //DDHAL32_VidMemFree(pdrv, 0, pDriverData->NvYUY2Surface1Mem);
                                   pDriverData->NvYUY2Surface1Mem = 0;
                                   pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1] = 0;
                                   if (pDriverData->DDrawVideoSurfaceCount > 0)
                                       pDriverData->DDrawVideoSurfaceCount--;
                               }

                               if (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] != 0) {
                                   if (pDriverData->NvYUY2Surface0Mem > 0) {
                                       NVHEAP_FREE (pDriverData->NvYUY2Surface0Mem);
                                       //DDHAL32_VidMemFree(pdrv, 0, pDriverData->NvYUY2Surface0Mem);
                                       pDriverData->NvYUY2Surface0Mem = 0;
                                       if (pDriverData->DDrawVideoSurfaceCount > 0)
                                           pDriverData->DDrawVideoSurfaceCount--;
                                   }

                                   if ((pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] <
                                        pDriverData->BaseAddress) || /* If system memory */
                                       (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] >
                                        (unsigned long)pDriverData->VideoHeapEnd)) {
                                       NvNotification *pDmaSyncNotifier =
                                           (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;
                                       Nv10ControlDma *npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;
                                       unsigned long *dmaPusherPutAddress =
                                           (unsigned long *)pDriverData->NvDmaPusherPutAddress;
                                       unsigned long *dmaPusherBufferBase =
                                           (unsigned long *)pDriverData->NvDmaPusherBufferBase;
#ifdef  CACHE_FREECOUNT
                                       long freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
                                       NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
                                       long freeCount = 0;
#endif  /* CACHE_FREECOUNT */

                                       NV_DD_DMA_PUSHER_SYNC();

                                       /* Let D3D code know that we have touched NV */
                                       pDriverData->TwoDRenderingOccurred = 1;

                                       // MUST wait for any pending notification to prevent possible loss of notification serialization
                                       while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP;

                                       while (freeCount < 28)
                                           NvGetDmaBufferFreeCount(npDev, freeCount, 28, dmaPusherPutAddress);
                                       freeCount -= 28;

                                       pDriverData->dDrawSpareSubchannelObject = 0;

                                       pDmaSyncNotifier->status = NV_IN_PROGRESS;

                                       /* Trash spare subchannel */
                                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                                       dmaPusherPutAddress[1] = NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;
                                       dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                           MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                                       dmaPusherPutAddress[3] = NV1_NULL_OBJECT;
                                       dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                           MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                                       dmaPusherPutAddress[5] = NV1_NULL_OBJECT;
                                       dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                                       dmaPusherPutAddress[7] = NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT;
                                       dmaPusherPutAddress[8] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                           MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                                       dmaPusherPutAddress[9] = NV1_NULL_OBJECT;
                                       dmaPusherPutAddress[10] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                           MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                                       dmaPusherPutAddress[11] = NV1_NULL_OBJECT;
                                       dmaPusherPutAddress[12] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                                       dmaPusherPutAddress[13] = NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT;
                                       dmaPusherPutAddress[14] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                           MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                                       dmaPusherPutAddress[15] = NV1_NULL_OBJECT;
                                       dmaPusherPutAddress[16] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                           MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                                       dmaPusherPutAddress[17] = NV1_NULL_OBJECT;
                                       dmaPusherPutAddress[18] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                                       dmaPusherPutAddress[19] = NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT;
                                       dmaPusherPutAddress[20] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                           MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                                       dmaPusherPutAddress[21] = NV1_NULL_OBJECT;
                                       dmaPusherPutAddress[22] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                           MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                                       dmaPusherPutAddress[23] = NV1_NULL_OBJECT;
                                       dmaPusherPutAddress[24] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                                           RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
                                       dmaPusherPutAddress[25] = 0;
                                       dmaPusherPutAddress[26] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                                           RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
                                       dmaPusherPutAddress[27] = 0;

                                       dmaPusherPutAddress += 28;

                                       pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                                       /* Force write combine buffer to flush */
                                       pDriverData->NvDmaPusherBufferEnd[0] = 0;
                                       /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                                       _outp (0x3d0,0);

                                       pDriverData->dwDmaPusherFreeCount = freeCount;

                                       npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                                       while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification

                                       NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                                                NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY);
                                   }

                                   /* If in AGP memory then deallocate it from there */
                                   if ((pDriverData->GARTLinearBase > 0) &&
                                       ((pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] >= pDriverData->GARTLinearBase) &&
                                        (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] < (pDriverData->GARTLinearBase + NV_MAX_AGP_MEMORY_LIMIT)))) {
                                             DDHAL32_VidMemFree(pdrv, AGP_HEAP, pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0]);
                                   } else {
                                       if ((pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] <
                                            pDriverData->BaseAddress) || /* If system memory */
                                           (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] >
                                           (unsigned long)pDriverData->VideoHeapEnd)) {
                                           GlobalUnlock((HGLOBAL)pDriverData->NvFloatingMem2MemFormatMemoryHandle);
                                           GlobalFree((HGLOBAL)pDriverData->NvFloatingMem2MemFormatMemoryHandle);
                                       } else {
                                           NVHEAP_FREE (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0]);
                                           //DDHAL32_VidMemFree(pdrv, 0, pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0]);
                                           if (pDriverData->DDrawVideoSurfaceCount > 0)
                                               pDriverData->DDrawVideoSurfaceCount--;
                                       }
                                   }

                                   pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] = 0;
                                   pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1] = 0;
                                   pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2] = 0;
                               }

                               pDriverData->dwOverlayOwner = 0;
                               pDriverData->dwOverlaySurfaces = 0;

                               /* We can't support overlay surfaces in system memory */
                               if (psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
                                   lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
                                   return DDHAL_DRIVER_HANDLED;
                               }
                           }
                       }
#ifdef DEBUG
                       fourCCStr[0] = (char)psurf_gbl->ddpfSurface.dwFourCC & 0xFF;
                       fourCCStr[1] = (char)(psurf_gbl->ddpfSurface.dwFourCC >> 8) & 0xFF;
                       fourCCStr[2] = (char)(psurf_gbl->ddpfSurface.dwFourCC >> 16) & 0xFF;
                       fourCCStr[3] = (char)(psurf_gbl->ddpfSurface.dwFourCC >> 24) & 0xFF;
                       fourCCStr[4] = 0;
                       DPF( "FOURCC %s allocation: size=%lu bytes", &fourCCStr, dwBlockSize );
#endif // DEBUG
                       /* now allocate enough AGP memory or local video memory for the YV12 part of the surface */
                       pitch = psurf_gbl->wWidth;
                       psurf_gbl->lPitch = pitch;

                       dwBlockSize = ((pitch * (adjustedHeight * 12L)) >> 3);
                       /* Force block to be properly aligned */
                       dwBlockSize = (dwBlockSize + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;

                       if (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] == 0) { /* If this is the first of a complex overlay surface */

                           /*
                            * Allocate enough AGP, video, or system memory for ALL of the surfaces in the
                            * complex surface in a single block
                            */

                           if (lpCreateSurface->dwSCnt > 2)
                               dwBlockSize *= (DWORD)lpCreateSurface->dwSCnt;
                           else /* Assume that 2 of these surfaces will be created */
                               dwBlockSize <<= 1;

                           fpVidMem = 0;

                           memType = 0;

                           if (pDriverData->GARTLinearBase > 0) { /* First attempt to allocate in AGP memory */
                               fpVidMem = (DWORD *)DDHAL32_VidMemAlloc(pdrv, AGP_HEAP, dwBlockSize, 1);
                               if (fpVidMem != 0) {
                                   memType = DDSCAPS_NONLOCALVIDMEM;
                                   psurf->ddsCaps.dwCaps |= DDSCAPS_NONLOCALVIDMEM;
                               }
                           } else { /* else try to allocate the surfaces in framebuffer video memory */
                               /*
                                * Notify 16 bit display driver code that Direct Draw is beginning
                                * to use local video memory.
                                */
#ifndef WINNT
                               if (pDriverData->DDrawVideoSurfaceCount == 0) {
                                   HDC hdc = GetDC(0);
                                   ExtEscape(hdc, RECONFIGNVOFFSCREEN, 0, 0, 0, 0);
                               }
#endif // #ifndef WINNT

                               NVHEAP_ALLOC((unsigned long)fpVidMem, dwBlockSize, TYPE_OVERLAY);
                               //fpVidMem = (DWORD *)DDHAL32_VidMemAlloc(pdrv, 0, dwBlockSize, 1);

                               if (fpVidMem != 0) {
                                   memType = DDSCAPS_LOCALVIDMEM;
                                   pDriverData->DDrawVideoSurfaceCount++;
                               }
                           }

                           if (!fpVidMem) { /* Finally try system memory */
                               hMem = GlobalAlloc(GHND | GMEM_SHARE, dwBlockSize);
                               if (!hMem)
                                   memType = DDSCAPS_SYSTEMMEMORY;
                           }

                           if ((!hMem) && (!fpVidMem)) {
                               DPF( "    System memory FOURCC surface allocation failed" );
                               /* Free video memory just allocated above */
                               NVHEAP_FREE (psurf_gbl->dwReserved1);
                               //DDHAL32_VidMemFree(pdrv, 0, psurf_gbl->dwReserved1);
                               if (pDriverData->DDrawVideoSurfaceCount > 0)
                                   pDriverData->DDrawVideoSurfaceCount--;
                               psurf_gbl->dwReserved1 = 0;
                               lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
                               return DDHAL_DRIVER_HANDLED;
                           } else {
                               Nv10ControlDma *npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;
                               NvNotification *pDmaDmaToMemNotifier =
                                   (NvNotification *)pDriverData->NvDmaDmaToMemNotifierFlat;

                               DPF( "    System memory FOURCC surface allocation succeeded" );

                               if (fpVidMem) {
                                   pDriverData->NvFloatingMem2MemFormatMemoryHandle = 0;
                                   psurf_gbl->fpVidMem = (FLATPTR)fpVidMem;
                               } else {
                                   pDriverData->NvFloatingMem2MemFormatMemoryHandle = (DWORD)hMem;
                                   psurf_gbl->fpVidMem = (FLATPTR)GlobalLock(hMem);
                               }

                               NV_DD_DMA_PUSHER_SYNC();

                               /* Let D3D code know that we have touched NV */
                               pDriverData->TwoDRenderingOccurred = 1;

                               if ((memType == DDSCAPS_NONLOCALVIDMEM) || (memType == DDSCAPS_SYSTEMMEMORY)) { /* If system memory */
                                   NvNotification *pDmaSyncNotifier =
                                       (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;
                                   unsigned long *dmaPusherPutAddress =
                                       (unsigned long *)pDriverData->NvDmaPusherPutAddress;
                                   unsigned long *dmaPusherBufferBase =
                                       (unsigned long *)pDriverData->NvDmaPusherBufferBase;
                                   unsigned long status;
#ifdef  CACHE_FREECOUNT
                                   long freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
                                   NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
                                   long freeCount = 0;
#endif  /* CACHE_FREECOUNT */
                                   /* First disconnect everything */

                                   // MUST wait for any pending notification to prevent possible loss of notification serialization
                                   while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP;

                                   while (freeCount < 28)
                                       NvGetDmaBufferFreeCount(npDev, freeCount, 28, dmaPusherPutAddress);
                                   freeCount -= 28;

                                   pDriverData->dDrawSpareSubchannelObject = 0;

                                   pDmaSyncNotifier->status = NV_IN_PROGRESS;

                                   /* Trash spare subchannel */
                                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                                   dmaPusherPutAddress[1] = NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;
                                   dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                       MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                                   dmaPusherPutAddress[3] = NV1_NULL_OBJECT;
                                   dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                       MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                                   dmaPusherPutAddress[5] = NV1_NULL_OBJECT;
                                   dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                                   dmaPusherPutAddress[7] = NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT;
                                   dmaPusherPutAddress[8] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                       MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                                   dmaPusherPutAddress[9] = NV1_NULL_OBJECT;
                                   dmaPusherPutAddress[10] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                       MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                                   dmaPusherPutAddress[11] = NV1_NULL_OBJECT;
                                   dmaPusherPutAddress[12] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                                   dmaPusherPutAddress[13] = NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT;
                                   dmaPusherPutAddress[14] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                       MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                                   dmaPusherPutAddress[15] = NV1_NULL_OBJECT;
                                   dmaPusherPutAddress[16] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                       MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                                   dmaPusherPutAddress[17] = NV1_NULL_OBJECT;
                                   dmaPusherPutAddress[18] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                                   dmaPusherPutAddress[19] = NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT;
                                   dmaPusherPutAddress[20] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                       MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                                   dmaPusherPutAddress[21] = NV1_NULL_OBJECT;
                                   dmaPusherPutAddress[22] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                       MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                                   dmaPusherPutAddress[23] = NV1_NULL_OBJECT;
                                   dmaPusherPutAddress[24] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                                       RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
                                   dmaPusherPutAddress[25] = 0;
                                   dmaPusherPutAddress[26] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                                       RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
                                   dmaPusherPutAddress[27] = 0;

                                   dmaPusherPutAddress += 28;

                                   pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                                   /* Force write combine buffer to flush */
                                   pDriverData->NvDmaPusherBufferEnd[0] = 0;
                                   /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                                   _outp (0x3d0,0);

                                   pDriverData->dwDmaPusherFreeCount = freeCount;

                                   npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                                   while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification

                                   NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                                            NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY);

                                   /* Now reconnect everything */

                                   pDmaDmaToMemNotifier->status = NV_IN_PROGRESS;

                                   status = NvRmAllocContextDma(pDriverData->dwRootHandle,
                                                       NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY,
                                                       NV01_CONTEXT_DMA,
                                                       (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                                                       ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED),
                                                       (PVOID)psurf_gbl->fpVidMem,
                                                       (dwBlockSize - 1));

                                   if (status == ALLOC_CTX_DMA_STATUS_SUCCESS) {
                                       pDmaDmaToMemNotifier->status = NV_STATUS_DONE_OK;
                                   }

                                   while (freeCount < 20)
                                       NvGetDmaBufferFreeCount(npDev, freeCount, 20, dmaPusherPutAddress);
                                   freeCount -= 20;

                                   /* Both buffers must be reconnected due to an bug in NV4 */
                                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                                   dmaPusherPutAddress[1] = NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;
                                   dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                       MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x80000;
                                   dmaPusherPutAddress[3] = NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
                                   dmaPusherPutAddress[4] = NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY;
                                   dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                                   dmaPusherPutAddress[6] = NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT;
                                   dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                       MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x80000;
                                   dmaPusherPutAddress[8] = NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
                                   dmaPusherPutAddress[9] = NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY;
                                   dmaPusherPutAddress[10] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                                   dmaPusherPutAddress[11] = NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT;
                                   dmaPusherPutAddress[12] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                       MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x80000;
                                   dmaPusherPutAddress[13] = NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
                                   dmaPusherPutAddress[14] = NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY;
                                   dmaPusherPutAddress[15] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                                   dmaPusherPutAddress[16] = NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT;
                                   dmaPusherPutAddress[17] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                       MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x80000;
                                   dmaPusherPutAddress[18] = NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
                                   dmaPusherPutAddress[19] = NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY;

                                   dmaPusherPutAddress += 20;

                                   pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                                   /* Force write combine buffer to flush */
                                   pDriverData->NvDmaPusherBufferEnd[0] = 0;
                                   /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                                   _outp (0x3d0,0);

                                   pDriverData->dwDmaPusherFreeCount = freeCount;

                                   npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                                   while ((volatile)pDmaDmaToMemNotifier->status == NV_IN_PROGRESS) NV_SLEEP;

                               } else { /* If video memory */
                                   pDmaDmaToMemNotifier->status = NV_STATUS_DONE_OK;
                               }

                               if (pDmaDmaToMemNotifier->status == NV_STATUS_DONE_OK) {
                                   pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] =
                                       (DWORD)psurf_gbl->fpVidMem;
                               } else {
                                   /* Can't lock down system memory, forget using this technique */
                                   pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] = 0;
                                   /* Free video memory just allocated above */
                                   NVHEAP_FREE (pDriverData->NvYUY2Surface0Mem);
                                   //DDHAL32_VidMemFree(pdrv, 0, pDriverData->NvYUY2Surface0Mem);
                                   if (pDriverData->DDrawVideoSurfaceCount > 0)
                                       pDriverData->DDrawVideoSurfaceCount--;

                                   if (pDriverData->NvFloatingMem2MemFormatMemoryHandle) {
                                       GlobalUnlock((HGLOBAL)pDriverData->NvFloatingMem2MemFormatMemoryHandle);
                                       GlobalFree((HGLOBAL)pDriverData->NvFloatingMem2MemFormatMemoryHandle);
                                   } else {
                                       /* Free AGP memory just allocated above */
                                       DDHAL32_VidMemFree(pdrv, AGP_HEAP, psurf_gbl->fpVidMem);

                                   }
                                   psurf_gbl->fpVidMem = 0;
                                   lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
                                   return DDHAL_DRIVER_HANDLED;
                               }
                           }
                       } else {
                           /* Assign surface address within preallocated and locked video or AGP/system memory block */
                           if (i > 0) {
                               psurf_gbl->fpVidMem =
                                   pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] +
                                       (i * dwBlockSize);
                               if (i == 1)
                                   pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1] = psurf_gbl->fpVidMem;
                               else if (i == 2)
                                   pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2] = psurf_gbl->fpVidMem;
                               else if (i == 3)
                                   pDriverData->NvFloatingMem2MemFormatSurfaceAddress[3] = psurf_gbl->fpVidMem;
                           } else {
                               psurf_gbl->fpVidMem =
                                   pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] +
                                       dwBlockSize;
                               pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1] = psurf_gbl->fpVidMem;
                           }

                           /* If in AGP memory then set capability flag */
                           if (pDriverData->GARTLinearBase > 0) {
                               if ((psurf_gbl->fpVidMem >= pDriverData->GARTLinearBase) &&
                                   (psurf_gbl->fpVidMem < (pDriverData->GARTLinearBase + NV_MAX_AGP_MEMORY_LIMIT)))
                                   psurf->ddsCaps.dwCaps |= DDSCAPS_NONLOCALVIDMEM;
                           }
                       }

                       if (psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
                           index = 0;
                           while ((pDriverData->dwOverlaySurfaceLCL[index] != 0) &&
                                  (index < NV_MAX_OVERLAY_SURFACES))
                                  index++;
                           pDriverData->dwOverlaySurfaceLCL[index] = (DWORD) psurf;
                           pDriverData->dwOverlayOwner = (DWORD)powner;
                           pDriverData->dwOverlaySurfaces++;
                       }

                    break;
                }
#ifdef NVD3D
            } else if (psurf->ddsCaps.dwCaps & DDSCAPS_TEXTURE) {
                /*
                 * Notify 16 bit display driver code that Direct Draw is beginning
                 * to use local video memory.
                 */
#ifndef WINNT
                if (pDriverData->DDrawVideoSurfaceCount == 0) {
                    HDC hdc = GetDC(0);
                    ExtEscape(hdc, RECONFIGNVOFFSCREEN, 0, 0, 0, 0);
                }
#endif // #ifndef WINNT
                /*
                 * Call the texture surface allocation code in the D3D driver. (D3dtex.c)
                 * If the routine returns FALSE, then the surface creation failed and the
                 * error should be returned immediately.
                 */
                if (!(handled = nvCreateTextureSurface(lpCreateSurface, psurf, psurf_gbl)))
                   return DDHAL_DRIVER_HANDLED;
            } else if (psurf->ddsCaps.dwCaps & DDSCAPS_ZBUFFER) {

                if (pDriverData->regValidateZMethod == REG_VZM_STRICT) {
                    /*
                     * Allocate z-buffer memory exactly as the surface specifies.
                     * Z-Buffer must match render depth or D3D context creation will fail.
                     */
                    if ( (psurf->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
                         (psurf_gbl->ddpfSurface.dwFlags & DDPF_ZBUFFER) ) {
                       /*
                        * I need to check this here and reject it because a lot of times
                        * CanCreateSurface will be called and the format will not have been
                        * set and then CreateSurface will be called and the format will be
                        * set to something other than the current primary surface bit depth,
                        * which we can't support.
                        */
                       if (psurf_gbl->ddpfSurface.dwZBufferBitDepth != pDriverData->bi.biBitCount) {
                           lpCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                           return DDHAL_DRIVER_HANDLED;
                       }
                       pitch = ((psurf_gbl->wWidth <<
                                (psurf_gbl->ddpfSurface.dwZBufferBitDepth >> 4)) +
                                 pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
                    }
                    else
                       pitch = ((psurf_gbl->wWidth <<
                                (pDriverData->bi.biBitCount >> 4)) +
                                 pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
                }
                else {
                    /*
                     * Pad the z-buffer if neccessary to match z-buffer depth to the D3D rendering depth.
                     */
                    if ( (psurf->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
                         (psurf_gbl->ddpfSurface.dwFlags & DDPF_ZBUFFER) ) {
                       /*
                        * When allocating the z-buffer, we have to make sure that it matches
                        * the rendering surface.  I'm saying that I support 16, 24 and 32 bits
                        * of z-buffer, because applications seem to only understand 16 and 24.
                        * So here's what I'm going to do (this is subject to change).  If the
                        * application is running in 16bpp mode and it requests a 24 or 32 bit
                        * z buffer, they will only get 16 bpp of precision (because that's what
                        * the hardware supports) but we'll go ahead and waste as much memory
                        * as they request (for now anyway).  If the application requests a 16 or 24
                        * bit z-buffer when we are rendering in 32 bpp mode, then they will get
                        * 24 bit z-precision, but we will have to waste the full 32bpp to give
                        * it to them.
                        */
                       if (pDriverData->bi.biBitCount == 16) {
                           if (psurf_gbl->ddpfSurface.dwZBufferBitDepth == 16) {
                               pitch = ((psurf_gbl->wWidth << 1) +
                                         pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
                           }
                           else if ((psurf_gbl->ddpfSurface.dwZBufferBitDepth == 24)
                                 || (psurf_gbl->ddpfSurface.dwZBufferBitDepth == 32)) {
                               pitch = ((psurf_gbl->wWidth << 2) +
                                         pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
                           }
                           else {
                               /* Anything else just won't do. */
                               lpCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                               return DDHAL_DRIVER_HANDLED;
                           }
                       }
                       else if (pDriverData->bi.biBitCount == 32) {
                           if ((psurf_gbl->ddpfSurface.dwZBufferBitDepth == 16)
                            || (psurf_gbl->ddpfSurface.dwZBufferBitDepth == 24)
                            || (psurf_gbl->ddpfSurface.dwZBufferBitDepth == 32)) {
                               pitch = ((psurf_gbl->wWidth << 2) +
                                         pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
                           }
                           else {
                               /* Anything else just won't do. */
                               lpCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                               return DDHAL_DRIVER_HANDLED;
                           }
                       }
                       else {
                           /* Anything else just won't do. */
                           lpCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                           return DDHAL_DRIVER_HANDLED;
                       }
                    }
                    else
                       pitch = ((psurf_gbl->wWidth <<
                                (pDriverData->bi.biBitCount >> 4)) +
                                 pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
                }

                psurf_gbl->lPitch = pitch;
                dwBlockSize = pitch * psurf_gbl->wHeight;
                psurf_gbl->dwReserved1 = 0;

                /*
                 * Notify 16 bit display driver code that Direct Draw is beginning
                 * to use local video memory.
                 */
#ifndef WINNT
                if (pDriverData->DDrawVideoSurfaceCount == 0) {
                    HDC hdc = GetDC(0);
                    ExtEscape(hdc, RECONFIGNVOFFSCREEN, 0, 0, 0, 0);
                }
#endif // #ifndef WINNT
                NVHEAP_ALLOC_TILED(psurf_gbl->fpVidMem, psurf_gbl->lPitch, psurf_gbl->wHeight, TYPE_DEPTH);
                //psurf_gbl->fpVidMem = DDHAL32_VidMemAlloc(pdrv, 0, dwBlockSize, 1);

                if (psurf_gbl->fpVidMem != 0) {
                    pDriverData->DDrawVideoSurfaceCount++;
                    DPF( "    Video memory Z buffer surface allocation succeeded" );
                    psurf->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
                    psurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
                    handled = TRUE;
                } else {
                   DPF( "    Video memory Z buffer surface allocation failed" );
                   lpCreateSurface->ddRVal = DDERR_OUTOFVIDEOMEMORY;
                   return DDHAL_DRIVER_HANDLED;
                }
#endif // NVD3D
            }
        } else {
            if (psurf->ddsCaps.dwCaps &
               (DDSCAPS_FRONTBUFFER | DDSCAPS_PRIMARYSURFACE | DDSCAPS_VISIBLE)) {

                /* Must allow primary surface access even if not correct pixel depth for 3D */
                /* Fixes Jedi Knight bug */
                if ((psurf->ddsCaps.dwCaps & DDSCAPS_3DDEVICE) &&
                    (!(psurf->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE))) {
                    if (pDriverData->bi.biBitCount == 8) {
                        lpCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                        return DDHAL_DRIVER_HANDLED;
                    }
                }

                DPF( "    Front buffer granted" );
                pitch = pDriverData->bi.biWidth *
                        (pDriverData->bi.biBitCount >> 3);
                /* Force primary surface alignment to be correct */
                psurf_gbl->lPitch = (pitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;

                /* Must wait for any pending flip to finish so that CurrentVisibleSurface will be valid */
                ddrval = updateFlipStatus(0);
                if (ddrval != DD_OK) {
                    while (ddrval != DD_OK) {
                        NV_SLEEPFLIP;
                        ddrval = updateFlipStatus(0);
                    }
                }

                psurf->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
                psurf_gbl->fpVidMem = pDriverData->CurrentVisibleSurfaceAddress;
                psurf_gbl->dwReserved1 = 0;
                psurf->dwReserved1 = 0;
                handled = TRUE;
            } else if (psurf->ddsCaps.dwCaps & (DDSCAPS_BACKBUFFER | DDSCAPS_FLIP)) {
                DPF( "    Back buffer or flip surface granted" );
                pitch = pDriverData->bi.biWidth *
                        (pDriverData->bi.biBitCount >> 3);
                psurf_gbl->lPitch = (pitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
                dwBlockSize = psurf_gbl->lPitch * pDriverData->bi.biHeight;
                psurf_gbl->dwReserved1 = 0;
                psurf->dwReserved1 = 0;

                /*
                 * Notify 16 bit display driver code that Direct Draw is beginning
                 * to use local video memory.
                 */
#ifndef WINNT
                if (pDriverData->DDrawVideoSurfaceCount == 0) {
                    HDC hdc = GetDC(0);
                    ExtEscape(hdc, RECONFIGNVOFFSCREEN, 0, 0, 0, 0);
                }
#endif // #ifndef WINNT
                NVHEAP_ALLOC_TILED(psurf_gbl->fpVidMem, psurf_gbl->lPitch, pDriverData->bi.biHeight, MEM_TYPE_IMAGE_TILED);
                //psurf_gbl->fpVidMem = DDHAL32_VidMemAlloc(pdrv, 0, dwBlockSize, 1);

                if (psurf_gbl->fpVidMem != 0) {
                    pDriverData->DDrawVideoSurfaceCount++;
                    DPF( "    Backbuffer or flipable video memory surface allocation succeeded" );
                    psurf->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
                    psurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
                    handled = TRUE;

#ifdef FORCED_TRIPLE_BUFFER
                    // a flippable double buffered scenario has been granted,
                    // let's try and make it triple buffered
                    if (lpCreateSurface->dwSCnt == 2) {
                        IDirectDraw2 *lpDD_int = (IDirectDraw2 *) psurf->lpSurfMore->lpDD_int;
                        DDSURFACEDESC surfDesc;
                        HRESULT result;

                        if (lpDD_int) {
                            surfDesc = *(lpCreateSurface->lpDDSurfaceDesc);
                            surfDesc.dwFlags |= DDSD_HEIGHT | DDSD_WIDTH;
                            surfDesc.dwFlags &= ~DDSD_BACKBUFFERCOUNT;
                            surfDesc.dwWidth = psurf_gbl->wWidth;
                            surfDesc.dwHeight = psurf_gbl->wHeight;
                            surfDesc.dwBackBufferCount = 0;
                            surfDesc.ddsCaps.dwCaps &= ~(DDSCAPS_FRONTBUFFER | DDSCAPS_PRIMARYSURFACE | DDSCAPS_COMPLEX | DDSCAPS_FLIP);
                            result = IDirectDraw2_CreateSurface(lpDD_int, &surfDesc, &(pDriverData->lpBuffer3), NULL);
                            if (result == DD_OK) {
                                LPDDRAWI_DDRAWSURFACE_LCL lpSurfLcl = ((LPDDRAWI_DDRAWSURFACE_INT)pDriverData->lpBuffer3)->lpLcl;
                                pDriverData->bNeedToAttachBuffer = TRUE;
//                                lpSurfLcl->ddsCaps.dwCaps |= DDSCAPS_COMPLEX;
//                                lpSurfLcl->dwFlags |= 0x22; // private flags IMPLICITCREATE and PARTOFPRIMARYCHAIN
                                psurf->dwFlags &= ~0x2;
                            } else {
                                pDriverData->lpBuffer3 = NULL;
                                pDriverData->bNeedToAttachBuffer = FALSE;
                            }
                        }
                    }
#endif // FORCED_TRIPLE_BUFFER
                } else {
                    DPF( "    Backbuffer or flipable video memory surface allocation failed" );
                    lpCreateSurface->ddRVal = DDERR_OUTOFVIDEOMEMORY;
                    return DDHAL_DRIVER_HANDLED;
                }
            } else if (psurf->ddsCaps.dwCaps & DDSCAPS_OFFSCREENPLAIN) {
putInOffscreen:     DPF( "    Offscreen surface granted" );
                pitch = psurf_gbl->wWidth *
                        (pDriverData->bi.biBitCount >> 3);
                psurf_gbl->lPitch = (pitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
                dwBlockSize = psurf_gbl->lPitch * psurf_gbl->wHeight;
                psurf_gbl->dwReserved1 = 0;

                if ((psurf->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)  &&
                    (pDriverData->GARTLinearBase > 0))  { /* First attempt to allocate in AGP memory */
#ifndef WINNT
                        psurf_gbl->fpVidMem =  (FLATPTR)DDHAL32_VidMemAlloc(pdrv, AGP_HEAP, dwBlockSize, 1);
#else
                        psurf_gbl->fpVidMem = DDHAL_PLEASEALLOC_BLOCKSIZE;
                        psurf_gbl->dwBlockSizeX = dwBlockSize;
                        psurf_gbl->dwBlockSizeY = 1;
                        lpCreateSurface->lpDDSurfaceDesc->lPitch = psurf_gbl->lPitch;
                        lpCreateSurface->lpDDSurfaceDesc->dwFlags |= DDSD_PITCH;
#endif // WINNT
                    if (psurf_gbl->fpVidMem != 0) {
                        DPF( "    Offscreen AGP memory surface allocation succeeded" );
                        psurf->ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
                        psurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
#ifndef WINNT
                        handled = TRUE;
#else
                        handled = FALSE;
#endif // WINNT

                    } else {
                        DPF( "    Offscreen AGP memory surface allocation failed" );
                        psurf_gbl->dwReserved1 = 0; /* Make sure we don't try to deallocate it if DestroySurface is called */
                        lpCreateSurface->ddRVal = DDERR_OUTOFVIDEOMEMORY;
                        return DDHAL_DRIVER_HANDLED;
                    }
                } else {
                    /*
                     * Notify 16 bit display driver code that Direct Draw is beginning
                     * to use local video memory.
                     */
#ifndef WINNT
                    if (pDriverData->DDrawVideoSurfaceCount == 0) {
                        HDC hdc = GetDC(0);
                        ExtEscape(hdc, RECONFIGNVOFFSCREEN, 0, 0, 0, 0);
                    }
#endif // #ifndef WINNT

                    NVHEAP_ALLOC(psurf_gbl->fpVidMem, dwBlockSize, TYPE_IMAGE);
                    //psurf_gbl->fpVidMem = DDHAL32_VidMemAlloc(pdrv, 0, dwBlockSize, 1);

                    if (psurf_gbl->fpVidMem != 0) {
                        pDriverData->DDrawVideoSurfaceCount++;
                        DPF( "    Offscreen video memory surface allocation succeeded" );
                        psurf->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
                        psurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
                        handled = TRUE;
                    } else {
                        if (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {
                            DPF( "    Offscreen video memory surface allocation failed" );
                            psurf_gbl->dwReserved1 = 0; /* Make sure we don't try to deallocate it if DestroySurface is called */
                            lpCreateSurface->ddRVal = DDERR_OUTOFVIDEOMEMORY;
                            return DDHAL_DRIVER_HANDLED;
                        }

                        DPF( "    Offscreen surface allocation failed, trying system memory" );
                        pitch = (pitch * 3) & ~3L;
                        dwBlockSize = pitch * psurf_gbl->wHeight;
                        hMem = GlobalAlloc(GHND | GMEM_SHARE, dwBlockSize);
                        if (!hMem) {
                            DPF( "    System memory surface allocation failed" );
                            psurf_gbl->dwReserved1 = 0; /* Make sure we don't try to deallocate it if DestroySurface is called */
                            lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
                            return DDHAL_DRIVER_HANDLED;
                        } else {
                            DPF( "    System memory surface allocation succeeded" );
                        }
                        psurf_gbl->lPitch = pitch;
                        psurf_gbl->fpVidMem = (FLATPTR)GlobalLock(hMem);
                        psurf_gbl->dwReserved1 = (DWORD)hMem;
                        psurf->ddsCaps.dwCaps &= ~DDSCAPS_VIDEOMEMORY;
                        psurf->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
                        handled = TRUE;
                    }
                }
            } else if (psurf->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) {
                DPF( "    System memory surface requested" );
                pitch = psurf_gbl->wWidth *
                       (pDriverData->bi.biBitCount >> 3);
                pitch = (pitch + 3) & ~3L;  // pad to DWORD alignment
                hMem = GlobalAlloc(GHND | GMEM_SHARE, (pitch * psurf_gbl->wHeight));
                if (!hMem) {
                    DPF( "    System memory surface allocation failed" );
                    lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
                    return DDHAL_DRIVER_HANDLED;
                } else {
                    DPF( "    System memory surface allocation succeeded" );
                }
                psurf_gbl->lPitch = pitch;
                psurf_gbl->fpVidMem = (FLATPTR)GlobalLock(hMem);
                psurf_gbl->dwReserved1 = (DWORD)hMem;
                handled = TRUE;
#ifdef NVD3D
            } else if (psurf->ddsCaps.dwCaps & DDSCAPS_TEXTURE) {
                /*
                 * Notify 16 bit display driver code that Direct Draw is beginning
                 * to use local video memory.
                 */
#ifndef WINNT
                if (pDriverData->DDrawVideoSurfaceCount == 0) {
                    HDC hdc = GetDC(0);
                    ExtEscape(hdc, RECONFIGNVOFFSCREEN, 0, 0, 0, 0);
                }
#endif // #ifndef WINNT
                /*
                 * Call the texture surface allocation code in the D3D driver. (D3dtex.c)
                 * If the routine returns FALSE, then the surface creation failed and the
                 * error should be returned immediately.
                 */
                if (!(handled = nvCreateTextureSurface(lpCreateSurface, psurf, psurf_gbl)))
                   return DDHAL_DRIVER_HANDLED;
#endif  // NVD3D
            } else if (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {
                goto putInOffscreen;
            }
        }
    }

    if( handled ) {
        lpCreateSurface->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    /*
     * if we return handled, then it is assumed that we did SOMETHING
     * with the surface structures to indicate either what size of block
     * or a new pitch or some modification; or we are returning an error.
     */
    return DDHAL_DRIVER_NOTHANDLED;

} /* CreateSurface32 */


/*
 * CanCreateSurface32
 */
DWORD __stdcall CanCreateSurface32( LPDDHAL_CANCREATESURFACEDATA lpCanCreateSurface ) {
    DWORD               caps;
    LPDDSURFACEDESC     lpDDSurface;
    int                 i;

    NvSetDriverDataPtr(lpCanCreateSurface->lpDD);

    /*
     * Reset NV and get the monitor frequency after a mode reset
     */
    if( pDriverData->fReset ) {
        getDisplayDuration();
        if (!ResetNV()) {
            lpCanCreateSurface->ddRVal = DDERR_GENERIC;
            return(DDHAL_DRIVER_HANDLED);
        }
        pDriverData->fReset = FALSE;
    }

    /*
     * NOTES:
     *
     * This entry point is called after parameter validation but before
     * any object creation.   You can decide here if it is possible for
     * you to create this surface.  For example, if the person is trying
     * to create an overlay, and you already have the maximum number of
     * overlays created, this is the place to fail the call.
     *
     * You also need to check if the pixel format specified can be supported.
     *
     * lpCanCreateSurface->bIsDifferentPixelFormat tells us if the pixel format of the
     * surface being created matches that of the primary surface.  It can be
     * true for Z buffer and alpha buffers, so don't just reject it out of
     * hand...
     */
    DPF( "CanCreateSurface, lpCanCreateSurface->lpDD=%08lx", lpCanCreateSurface->lpDD );
    DPF( "    lpCanCreateSurface->lpDDSurfaceDesc=%08lx", lpCanCreateSurface->lpDDSurfaceDesc );

    lpDDSurface = lpCanCreateSurface->lpDDSurfaceDesc;

    caps = lpDDSurface->ddsCaps.dwCaps;

    if (caps & (DDSCAPS_MODEX | DDSCAPS_PALETTE))
        return DDHAL_DRIVER_NOTHANDLED;

    if (pDriverData->bi.biBitCount == 8) {
        if (caps & DDSCAPS_ALPHA)
            return DDHAL_DRIVER_NOTHANDLED;
    }

    /*
     * check pixel format.   Don't allow pixel formats that aren't
     * the same, unless we have a valid fourcc code, an overlay,
     * an alpha surface, or z buffer.
     */
    if ( lpCanCreateSurface->bIsDifferentPixelFormat ) {
        DPF( "    different pixel format!" );

        if ( lpDDSurface->ddpfPixelFormat.dwFlags & DDPF_ALPHAPREMULT ) {
            if ((pDriverData->bi.biBitCount == 8) || (pDriverData->bi.biBitCount == 16)) {
                /* We don't support alpha surfaces in 8bpp mode */
                DPF("NVDD32: CanCreateSurface32 - no alpha surf in 8bpp");
                lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                return DDHAL_DRIVER_HANDLED;
            }

            if (pDriverData->bi.biBitCount == 32) {
                if ((lpDDSurface->ddpfPixelFormat.dwRGBAlphaBitMask != 0xFF000000) ||
                    (lpDDSurface->ddpfPixelFormat.dwRBitMask != 0x00FF0000) ||
                    (lpDDSurface->ddpfPixelFormat.dwGBitMask != 0x0000FF00) ||
                    (lpDDSurface->ddpfPixelFormat.dwBBitMask != 0x000000FF)) {
                    DPF("NVDD32: CanCreateSurface32 - unsupported format 10");
                    lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                    return DDHAL_DRIVER_HANDLED;
                } else {
                    lpCanCreateSurface->ddRVal = DD_OK;
                    return DDHAL_DRIVER_HANDLED;
                }
            }
        }

        if ( lpDDSurface->ddpfPixelFormat.dwFlags & DDPF_FOURCC ) {
            if (pDriverData->bi.biBitCount == 8) {
                /* We don't support RGB FOURCCs in 8bpp mode */
                if (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_RGB0) {
                    DPF("NVDD32: CanCreateSurface32 - invalid pixel format 10");
                    lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                    return DDHAL_DRIVER_HANDLED;
                }
            }

            DPF( "    FourCC requested (%4.4hs, 0x%08lx)",
                (LPSTR) &lpDDSurface->ddpfPixelFormat.dwFourCC,
                lpDDSurface->ddpfPixelFormat.dwFourCC );

            for( i=0; i < NV_MAX_FOURCC; i++ ) {
                if( lpDDSurface->ddpfPixelFormat.dwFourCC == pDriverData->fourCC[i] ) {
                    DPF( "    FOURCC=%4.4hs", (LPSTR) &pDriverData->fourCC[i] );
                    if (caps & DDSCAPS_OVERLAY) {
                        if ((lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_UYVY) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_UYNV) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_YUY2) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_YUNV) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_YV12) &&
//                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_420i) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_IF09) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_YVU9) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_IV32) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_IV31)) {
                            DPF("NVDD32: CanCreateSurface32 - unsupported format 20");
                            lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                            return DDHAL_DRIVER_HANDLED;
                        }

                        if ((caps & (DDSCAPS_VIDEOPORT | DDSCAPS_FLIP)) == (DDSCAPS_VIDEOPORT | DDSCAPS_FLIP)) {
                            // Surface is for overlay with flip associated with video port
                            // check number of buffers, can't have more than 5 surfaces
                            // This will probably change when we have kernel mode flipping support
                            if ((lpDDSurface->dwFlags & DDSD_BACKBUFFERCOUNT) &&
                                (lpDDSurface->dwBackBufferCount > 4)) {
                                DPF("NVDD32: CanCreateSurface32 - invalid parameters 10");
                                lpCanCreateSurface->ddRVal = DDERR_INVALIDPARAMS;
                                return DDHAL_DRIVER_HANDLED;
                            }
                        } else {
                            // Workaround for Microsoft DirectVideo Cinepak decoding bug
                            // The reason for the existence of FOURCC_UYNV and FOURCC_YUNV
//                          if ((lpDDSurface->dwFlags & DDSD_BACKBUFFERCOUNT) &&
//                                (lpDDSurface->dwBackBufferCount > 1) &&
//                                ((lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_UYVY) ||
//                                 (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_YUY2))) {
//                              lpCanCreateSurface->ddRVal = DDERR_INVALIDPARAMS;
//                                return DDHAL_DRIVER_HANDLED;
//                          }

                            // We must limit number of YV12 overlay surfaces to the maximum number we can manage reformatting
                            if ((lpDDSurface->dwFlags & DDSD_BACKBUFFERCOUNT) &&
                                (lpDDSurface->dwBackBufferCount > 3) &&
                                (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_YV12)) {
                                DPF("NVDD32: CanCreateSurface32 - out of caps 10");
                                lpCanCreateSurface->ddRVal = DDERR_OUTOFCAPS;
                                return DDHAL_DRIVER_HANDLED;
                            }
                        }

                        if (pDriverData->dwOverlaySurfaces > 0) {
                            DPF("NVDD32: CanCreateSurface32 - out of caps 20");
                            lpCanCreateSurface->ddRVal = DDERR_OUTOFCAPS;
                            return DDHAL_DRIVER_HANDLED;
                        }

                        if (GetVideoScalerBandwidthStatus32(caps) == FALSE) {
                            DPF("NVDD32: CanCreateSurface32 - no overlay hardware 10");
                            lpCanCreateSurface->ddRVal = DDERR_NOOVERLAYHW;
                            return DDHAL_DRIVER_HANDLED;
                        }
                    } else if (caps & (DDSCAPS_VIDEOMEMORY | DDSCAPS_OFFSCREENPLAIN)) {
                        /* Front end YUV support cannot reformat data so Indeo is not supported */
                        /* Currently also disallowing front end YUV420 since YUYV or UYVY
                           should do ok when not enough backend bandwidth is available */
                        if ((lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_IF09) ||
                            (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_YVU9) ||
                            (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_IV32) ||
                            (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_IV31) ||
                            (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_YV12) ||
                            (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_420i)) {
                            DPF("NVDD32: CanCreateSurface32 - unsupported format 30");
                            lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                            return DDHAL_DRIVER_HANDLED;
                        }

                        if (caps & DDSCAPS_VIDEOPORT) {
                            /* Nonoverlay FOURCC video surfaces are only supported for YUV422
                               formats and only when associated with the video port */
                            if ((lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_YUY2) &&
                                (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_YUNV) &&
                                (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_UYVY) &&
                                (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_UYNV) &&
                                          (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_RAW8)
                                          ) {
                                DPF("NVDD32: CanCreateSurface32 - unsupported format 40");
                                lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                                return DDHAL_DRIVER_HANDLED;
                            }
                        /* Front end YUV support not available in 8bit indexed mode */
                        } else if (pDriverData->bi.biBitCount == 8) {
                            if (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_RAW8) {
                                DPF("NVDD32: CanCreateSurface32 - unsupported format 50");
                                lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                                return DDHAL_DRIVER_HANDLED;
                            }
                        }
                    }

                    if (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_RGB0) {
                        if (((pDriverData->bi.biBitCount == 16) &&
                            (lpDDSurface->ddpfPixelFormat.dwRGBBitCount != DDBD_16)) ||
                            ((pDriverData->bi.biBitCount == 32) &&
                            (lpDDSurface->ddpfPixelFormat.dwRGBBitCount != DDBD_32))) {
                            DPF("NVDD32: CanCreateSurface32 - invalid pixel format 20");
                            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                            return DDHAL_DRIVER_HANDLED;
                        }
                    }

                    lpCanCreateSurface->ddRVal = DD_OK;
                    return DDHAL_DRIVER_HANDLED;
                }
            }

        } else if( lpDDSurface->ddpfPixelFormat.dwFlags & DDPF_RGB ) {

            /* Don't allow 3D devices in 8bpp */
            if (caps & DDSCAPS_3DDEVICE) {
                if (lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 8) {
                    DPF("NVDD32: CanCreateSurface32 - invalid pixel format 30");
                    lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                    return DDHAL_DRIVER_HANDLED;
                }
            }

            if (caps & DDSCAPS_TEXTURE) {
                /* Don't allow textures in 8bpp. */
                if (pDriverData->bi.biBitCount == 8)
                {
                    DPF("NVDD32: CanCreateSurface32 - invalid pixel format 40");
                    lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                    return DDHAL_DRIVER_NOTHANDLED;
                }
                /* accept 8 bpp texture formats if conversion is enabled */
                if ((lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 8) &&
                    (pDriverData->regPal8TextureConvert != REG_P8TC_NONE))
                {
                    lpCanCreateSurface->ddRVal = DD_OK;
                    return DDHAL_DRIVER_HANDLED;
                }
                /* accept all 16 and 32 bpp texture formats */
                if ((lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 16) ||
                    (lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 32))
                {
                    lpCanCreateSurface->ddRVal = DD_OK;
                    return DDHAL_DRIVER_HANDLED;
                }
            }

            if (caps & DDSCAPS_ZBUFFER) {
                if (pDriverData->regValidateZMethod == REG_VZM_STRICT) {
                    /* For now, support z buffers in video memory only when our primary rendering depth is 16 bpp */

                    if ((lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 16)
                     && (pDriverData->bi.biBitCount == 16))
                    {
                        /* accept all 16 bpp z buffer formats when in 16 bpp disply mode */
                        lpCanCreateSurface->ddRVal = DD_OK;
                        return DDHAL_DRIVER_HANDLED;
                    }

                    if ((lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 32)
                     && (pDriverData->bi.biBitCount == 32))
                    {
                        /* accept all 32 bpp z buffer formats when in 32 bpp disply mode */
                        lpCanCreateSurface->ddRVal = DD_OK;
                        return DDHAL_DRIVER_HANDLED;
                    }

                    /*
                     * Any other z buffer depth or combination of z/display surface depths
                     * are invalid.
                     */
                    return DDHAL_DRIVER_NOTHANDLED;
                }
                else {
                    /* Allocate the z-buffer with the proper padding based on the bit depth of the primary surface */
                    /* accept all 16, 24, 32 bpp z buffer formats when in 16 bpp disply mode */
                    if ((lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 16)
                     || (lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 24)
                     || (lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 32)) {
                        lpCanCreateSurface->ddRVal = DD_OK;
                        return DDHAL_DRIVER_HANDLED;
                    }

                    /*
                     * Any other z buffer depth or combination of z/display surface depths
                     * are invalid.
                     */
                    return DDHAL_DRIVER_NOTHANDLED;
               }
            }

            /* We don't support any other RGB surfaces not in our native format */
            DPF("NVDD32: CanCreateSurface32 - invalid pixel format 50");
            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            return DDHAL_DRIVER_HANDLED;

        } else if( lpDDSurface->ddpfPixelFormat.dwFlags & DDPF_ZBUFFER ) {

            /* Don't allow z-buffer surfaces in 8bpp */
            if (caps & DDSCAPS_ZBUFFER) {
                if (pDriverData->bi.biBitCount == 8) {
                    DPF("NVDD32: CanCreateSurface32 - invalid pixel format 60");
                    lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                    return DDHAL_DRIVER_NOTHANDLED;
                }

                if (pDriverData->regValidateZMethod == REG_VZM_STRICT) {
                    if ((lpDDSurface->ddpfPixelFormat.dwZBufferBitDepth != pDriverData->bi.biBitCount)) {
                        DPF("NVDD32: CanCreateSurface32 - invalid pixel format 70");
                        lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                        return DDHAL_DRIVER_NOTHANDLED;
                    }
                }
                else {
                    if ((lpDDSurface->ddpfPixelFormat.dwZBufferBitDepth != 16)
                     && (lpDDSurface->ddpfPixelFormat.dwZBufferBitDepth != 24)
                     && (lpDDSurface->ddpfPixelFormat.dwZBufferBitDepth != 32)) {
                        DPF("NVDD32: CanCreateSurface32 - invalid pixel format 80");
                        lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                        return DDHAL_DRIVER_NOTHANDLED;
                    }
                }
            }

            DPF( "Z BUFFER OK!" );
            lpCanCreateSurface->ddRVal = DD_OK;
            return DDHAL_DRIVER_HANDLED;
        }

        /*
         * can't handle any other kinds of different fourcc or RGB overlays
         */
        DPF("NVDD32: CanCreateSurface32 - invalid pixel format 90");
        lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
        return DDHAL_DRIVER_HANDLED;
   }

   if (caps & DDSCAPS_MODEX) {
       DPF( "    Mode X requested" );
       lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDMODE;
       return DDHAL_DRIVER_HANDLED;
   }

   /* Don't allow 3D devices in 8bpp (except for primary surface access, fixes Jedi Knight) */
   if ((caps & DDSCAPS_3DDEVICE) && (!(caps & DDSCAPS_PRIMARYSURFACE))) {
       if (pDriverData->bi.biBitCount == 8) {
           DPF("NVDD32: CanCreateSurface32 - invalid pixel format 100");
           lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
           return DDHAL_DRIVER_HANDLED;
       }
   }

   if (caps & (DDSCAPS_FRONTBUFFER | DDSCAPS_PRIMARYSURFACE | DDSCAPS_VISIBLE))  {
       DPF( "    Frontbuffer requested" );

       if (caps & DDSCAPS_OVERLAY) {
           DPF("NVDD32: CanCreateSurface32 - invalid pixel format 110");
           lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
           return DDHAL_DRIVER_HANDLED;
       }

       if (caps & DDSCAPS_FLIP) {
           if (lpDDSurface->dwHeight > (unsigned long)pDriverData->bi.biHeight) {
               if (lpDDSurface->dwFlags & DDSD_HEIGHT) {
                   DPF("NVDD32: CanCreateSurface32 - height too big 10");
                   lpCanCreateSurface->ddRVal = DDERR_TOOBIGHEIGHT;
                   return DDHAL_DRIVER_HANDLED;
               } else {
                   lpDDSurface->dwHeight = (unsigned long)pDriverData->bi.biHeight;
               }

           }
           if (lpDDSurface->dwWidth > (unsigned long)pDriverData->bi.biWidth) {
               if (lpDDSurface->dwFlags & DDSD_WIDTH) {
                   DPF("NVDD32: CanCreateSurface32 - width too big 10");
                   lpCanCreateSurface->ddRVal = DDERR_TOOBIGWIDTH;
                   return DDHAL_DRIVER_HANDLED;
               } else {
                   lpDDSurface->dwWidth = (unsigned long)pDriverData->bi.biWidth;
               }
           }
       }
       lpCanCreateSurface->ddRVal = DD_OK;
       return DDHAL_DRIVER_HANDLED;

   } else if (caps & DDSCAPS_BACKBUFFER) {
       DPF( "    Backbuffer requested" );
#ifndef NVHEAPMGR
       if (pDriverData->HALInfo.vmiData.dwNumHeaps == 0) {
           DPF("NVDD32: CanCreateSurface32 - out of video memory 10");
           lpCanCreateSurface->ddRVal = DDERR_OUTOFVIDEOMEMORY;
           return DDHAL_DRIVER_HANDLED;
       }
#endif
       if (caps & DDSCAPS_OVERLAY) {
           DPF("NVDD32: CanCreateSurface32 - invalid pixel format 120");
           lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
           return DDHAL_DRIVER_HANDLED;
       }

       if (caps & DDSCAPS_FLIP) {
           if (lpDDSurface->dwHeight > (unsigned long)pDriverData->bi.biWidth) {
               if (lpDDSurface->dwFlags & DDSD_HEIGHT) {
                   DPF("NVDD32: CanCreateSurface32 - height too big 20");
                   lpCanCreateSurface->ddRVal = DDERR_TOOBIGHEIGHT;
                   return DDHAL_DRIVER_HANDLED;
               } else {
                   lpDDSurface->dwHeight = (unsigned long)pDriverData->bi.biHeight;
               }

           }
           if (lpDDSurface->dwWidth > (unsigned long)pDriverData->bi.biWidth) {
               if (lpDDSurface->dwFlags & DDSD_WIDTH) {
                   DPF("NVDD32: CanCreateSurface32 - width too big 20");
                   lpCanCreateSurface->ddRVal = DDERR_TOOBIGWIDTH;
                   return DDHAL_DRIVER_HANDLED;
               } else {
                   lpDDSurface->dwWidth = (unsigned long)pDriverData->bi.biWidth;
               }
           }
       }
       lpCanCreateSurface->ddRVal = DD_OK;
       return DDHAL_DRIVER_HANDLED;

   } else if (caps & DDSCAPS_TEXTURE) {

       /* Don't allow textures in 8bpp */
       if (pDriverData->bi.biBitCount == 8) {
           DPF("NVDD32: CanCreateSurface32 - invalid pixel format 130");
           lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
           return DDHAL_DRIVER_HANDLED;
       }

       lpDDSurface->ddsCaps.dwCaps &= ~DDSCAPS_VIDEOMEMORY;
       lpDDSurface->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
       lpCanCreateSurface->ddRVal = DD_OK;
       return DDHAL_DRIVER_HANDLED;

   } else if (caps & DDSCAPS_OFFSCREENPLAIN) {
       DPF( "    Can create offscreen requested" );

       if (caps & DDSCAPS_VIDEOMEMORY) {
#ifndef NVHEAPMGR
           if (pDriverData->HALInfo.vmiData.dwNumHeaps == 0) {
               DPF("NVDD32: CanCreateSurface32 - out of video memory 20");
               lpCanCreateSurface->ddRVal = DDERR_OUTOFVIDEOMEMORY;
               return DDHAL_DRIVER_HANDLED;
           }
#endif
           if (caps & DDSCAPS_OVERLAY) {
               DPF("NVDD32: CanCreateSurface32 - invalid pixel format 140");
               lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
               return DDHAL_DRIVER_HANDLED;
           }

           if (caps & DDSCAPS_FLIP) {
               if (lpDDSurface->dwHeight > (unsigned long)pDriverData->bi.biHeight) {
                   if (lpDDSurface->dwFlags & DDSD_HEIGHT) {
                       DPF("NVDD32: CanCreateSurface32 - height too big 30");
                       lpCanCreateSurface->ddRVal = DDERR_TOOBIGHEIGHT;
                       return DDHAL_DRIVER_HANDLED;
                   } else {
                       lpDDSurface->dwHeight = (unsigned long)pDriverData->bi.biHeight;
                   }
               }
               if (lpDDSurface->dwWidth > (unsigned long)pDriverData->bi.biWidth) {
                   if (lpDDSurface->dwFlags & DDSD_WIDTH) {
                       DPF("NVDD32: CanCreateSurface32 - width too big 30");
                       lpCanCreateSurface->ddRVal = DDERR_TOOBIGWIDTH;
                       return DDHAL_DRIVER_HANDLED;
                   } else {
                       lpDDSurface->dwWidth = (unsigned long)pDriverData->bi.biWidth;
                   }

               }
           }
       }
       lpCanCreateSurface->ddRVal = DD_OK;
       DPF( "    Can create offscreen granted" );
       return DDHAL_DRIVER_HANDLED;

   } else if (caps & (DDSCAPS_FLIP | DDSCAPS_VIDEOMEMORY | DDSCAPS_ZBUFFER)) {
       DPF( "    Can create flipping surface requested" );

       if (caps & DDSCAPS_OVERLAY) {
           DPF("NVDD32: CanCreateSurface32 - invalid pixel format 150");
           lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
           return DDHAL_DRIVER_HANDLED;
       }

       if (caps & DDSCAPS_ZBUFFER) {
           if ((pDriverData->bi.biBitCount != 16) &&
               (pDriverData->bi.biBitCount != 32)) {
               DPF("NVDD32: CanCreateSurface32 - invalid pixel format 160");
               lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
               return DDHAL_DRIVER_HANDLED;
           }
       }

#ifndef NVHEAPMGR
       if (pDriverData->HALInfo.vmiData.dwNumHeaps == 0) {
           DPF("NVDD32: CanCreateSurface32 - out of video memory 30");
           lpCanCreateSurface->ddRVal = DDERR_OUTOFVIDEOMEMORY;
           return DDHAL_DRIVER_HANDLED;
       }
       else
#endif
       {
           DPF( "    Can create flipping surface available" );
           lpCanCreateSurface->ddRVal = DD_OK;
           return DDHAL_DRIVER_HANDLED;
       }

   } else if (caps & DDSCAPS_SYSTEMMEMORY) {
       lpCanCreateSurface->ddRVal = DD_OK;
       DPF( "    Can create system memory requested" );
       return DDHAL_DRIVER_HANDLED;
   }


#ifdef NVD3D
   if (caps & DDSCAPS_TEXTURE) {
       lpCanCreateSurface->ddRVal = DD_OK;
       return DDHAL_DRIVER_HANDLED;
   }
#endif

   return DDHAL_DRIVER_NOTHANDLED;

} /* CanCreateSurface32 */

/***************************************************************************
 * DestroyDriver32
 ***************************************************************************/

#ifndef WINNT
HRESULT __stdcall DestroyDriver32(LPDDHAL_DESTROYDRIVERDATA pDestroyDriverData)
#else
HRESULT __stdcall DestroyDriver32(GLOBALDATA *pGlobalData)
#endif // #ifdef WINNT
{
    FAST Nv10ControlDma         *npDev;
    FAST Nv3ChannelPio          *npDevVideo;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    DWORD                       index = 0;

    DPF("DestroyDriver32");
#ifndef WINNT
    pdrv = pDestroyDriverData->lpDD;
#else
    /*
     * Load global ptr variable to "global" data
     */
    pDriverData = pGlobalData;

#endif

    npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;
    npDevVideo = (Nv3ChannelPio *)pDriverData->NvDevVideoFlatPio;

    /* If an overlay is currently active then shut it down */
    if ((npDevVideo != NULL) && (pDriverData->dwOverlaySurfaces > 0)) {
        FAST long videoFreeCount = pDriverData->NvVideoFreeCount;

        NV_DD_DMA_PUSHER_SYNC();

        /* Trash spare subchannel */
        pDriverData->dwRingZeroMutex = TRUE;

        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {

            while (videoFreeCount < 12)
                videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);
            videoFreeCount -= 12;

            npDevVideo->dDrawSpare.SetObject = NV_VIDEO_OVERLAY;

            npDevVideo->dDrawSpare.Nv10VideoOverlay.StopOverlay[0] =
                NV07A_STOP_OVERLAY_BETWEEN_BUFFERS;

            npDevVideo->dDrawSpare.Nv10VideoOverlay.StopOverlay[1] =
                NV07A_STOP_OVERLAY_BETWEEN_BUFFERS;

        } else { // pre NV10

            while (videoFreeCount < 20)
                videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);
            videoFreeCount -= 20;

            npDevVideo->dDrawSpare.SetObject = NV_DD_VIDEO_COLOR_KEY;

            npDevVideo->dDrawSpare.videoColorKey.SetSize = 0; // hide overlay

            npDevVideo->dDrawSpare.SetObject = NV_DD_YUV422_VIDEO_FROM_MEMORY;

            npDevVideo->dDrawSpare.videoFromMemory.ImageScan[0].size = 0;

            npDevVideo->dDrawSpare.videoFromMemory.ImageScan[0].notify = 0;
        }

        pDriverData->dwRingZeroMutex = FALSE;
        pDriverData->dDrawSpareSubchannelObject = 0;

        pDriverData->dwOverlayOwner = 0;

        pDriverData->dwOverlaySurfaces = 0;

        while (index < NV_MAX_OVERLAY_SURFACES)
            pDriverData->dwOverlaySurfaceLCL[index++] = 0;

        pDriverData->HALInfo.ddCaps.dwCurrVisibleOverlays = 0;

        pDriverData->NvVideoFreeCount = (short)videoFreeCount;
    }

    /* Unlock and free any remaining locked down system memory */
    if (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] > 0) {
        if ((pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] <
                 pDriverData->BaseAddress) || /* If system memory */
            (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] >
                 (unsigned long)pDriverData->VideoHeapEnd)) {
            NvNotification *pDmaSyncNotifier =
                (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;
            unsigned long *dmaPusherPutAddress =
                (unsigned long *)pDriverData->NvDmaPusherPutAddress;
            unsigned long *dmaPusherBufferBase =
                (unsigned long *)pDriverData->NvDmaPusherBufferBase;
#ifdef  CACHE_FREECOUNT
            long freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
            NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
            long freeCount = 0;
#endif  /* CACHE_FREECOUNT */

            if (npDev != NULL) {

                NV_DD_DMA_PUSHER_SYNC();

                // MUST wait for any pending notification to prevent possible loss of notification serialization
                while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP;

                while (freeCount < 28)
                    NvGetDmaBufferFreeCount(npDev, freeCount, 28, dmaPusherPutAddress);
                freeCount -= 28;

                pDriverData->dDrawSpareSubchannelObject = 0;

                pDmaSyncNotifier->status = NV_IN_PROGRESS;

                /* Trash spare subchannel */
                dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                dmaPusherPutAddress[1] = NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;
                dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                dmaPusherPutAddress[3] = NV1_NULL_OBJECT;
                dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                dmaPusherPutAddress[5] = NV1_NULL_OBJECT;
                dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                dmaPusherPutAddress[7] = NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT;
                dmaPusherPutAddress[8] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                dmaPusherPutAddress[9] = NV1_NULL_OBJECT;
                dmaPusherPutAddress[10] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                dmaPusherPutAddress[11] = NV1_NULL_OBJECT;
                dmaPusherPutAddress[12] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                dmaPusherPutAddress[13] = NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT;
                dmaPusherPutAddress[14] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                dmaPusherPutAddress[15] = NV1_NULL_OBJECT;
                dmaPusherPutAddress[16] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                dmaPusherPutAddress[17] = NV1_NULL_OBJECT;
                dmaPusherPutAddress[18] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                dmaPusherPutAddress[19] = NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT;
                dmaPusherPutAddress[20] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                dmaPusherPutAddress[21] = NV1_NULL_OBJECT;
                dmaPusherPutAddress[22] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                dmaPusherPutAddress[23] = NV1_NULL_OBJECT;
                dmaPusherPutAddress[24] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                    RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
                dmaPusherPutAddress[25] = 0;
                dmaPusherPutAddress[26] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                    RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
                dmaPusherPutAddress[27] = 0;

                dmaPusherPutAddress += 28;

                pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                /* Force write combine buffer to flush */
                pDriverData->NvDmaPusherBufferEnd[0] = 0;
                /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                _outp (0x3d0,0);

                pDriverData->dwDmaPusherFreeCount = freeCount;

                npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification

                NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                         NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY);
            }

            pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] = 0;
            pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1] = 0;
            pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2] = 0;
            pDriverData->NvFloatingMem2MemFormatSurfaceAddress[3] = 0;

            GlobalUnlock((HGLOBAL)pDriverData->NvFloatingMem2MemFormatMemoryHandle);
            GlobalFree((HGLOBAL)pDriverData->NvFloatingMem2MemFormatMemoryHandle);

            pDriverData->NvFloatingMem2MemFormatMemoryHandle = 0;

        } else { /* If video memory */
            NVHEAP_FREE (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0]);
            //DDHAL32_VidMemFree(pdrv, 0, pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0]);

            pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] = 0;
            pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1] = 0;
            pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2] = 0;
            pDriverData->NvFloatingMem2MemFormatSurfaceAddress[3] = 0;
        }
    }

    /* Unlock and free any remaining locked down system memory */

#ifndef WINNT
    pDriverData->HALCallbacks.lpSetInfo = 0;
#endif

    if (pDriverData->NvDevFlatDma != 0) {
        NvNotification *npDmaSyncNotifier =
            (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;
        long freeCount = 0;
        unsigned long *dmaPusherPutAddress =
            (unsigned long *)pDriverData->NvDmaPusherPutAddress;
        unsigned long *dmaPusherBufferBase =
            (unsigned long *)pDriverData->NvDmaPusherBufferBase;
        /*
         * Ensure the push buffer has completed prior to deleting objects
         * which it might reference.
         */
        while ((volatile)npDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification

        while (freeCount < 4)
            NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
        freeCount -= 4;

        npDmaSyncNotifier->status = NV_IN_PROGRESS;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
            RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
        dmaPusherPutAddress[1] = 0;
        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
            RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
        dmaPusherPutAddress[3] = 0;

        dmaPusherPutAddress += 4;

        /* Force write combine buffer to flush */
        pDriverData->NvDmaPusherBufferEnd[0] = 0;
        /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
        _outp (0x3d0,0);

        NV_DD_DMA_PUSHER_SYNC();
        npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
        pDriverData->NvDmaPusherPutAddress = dmaPusherPutAddress;
        while ((volatile)npDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification

        /* Unlock and free any remaining locked down system memory */

        /*
        * This routine will insure that any allocated texture heap is destroyed.
        */
        D3DDestroyTextureContexts();
        if (pDriverData->DDrawVideoSurfaceCount > 0)
            if (!NvDDDisable32())
                return(FALSE);
        if (NvRmFree(pDriverData->dwRootHandle, NV_WIN_DEVICE,
                 NV_DD_DEV_DMA) != NVOS00_STATUS_SUCCESS)
                    return(FALSE);
        pDriverData->NvDevFlatDma = 0;
    }

    /*
     * This routine will insure that any allocated texture heap is destroyed.
     */

    if (pDriverData->dwDmaPusherCtxDmaSize) {

        if (NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                 NV_DD_DMA_PUSHER_CONTEXT_DMA_FROM_MEMORY) != NVOS00_STATUS_SUCCESS)
                    return(FALSE);

        pDriverData->dwDmaPusherCtxDmaSize = 0;
    }

    if (pDriverData->NvAGPDmaPusherBufferBase != 0) {
        /* Make sure we destroy the AGP push buffer context DMA */
#ifndef WINNT
        DDHAL32_VidMemFree(pdrv, AGP_HEAP, pDriverData->NvAGPDmaPusherBufferBase);
#endif // WINNT
        pDriverData->NvAGPDmaPusherBufferBase = 0;
    }

    if ((pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) &&
        (pDriverData->NvDevVideoFlatPio != 0)) {
        if (NvRmFree(pDriverData->dwRootHandle, NV_WIN_DEVICE,
                 NV_DD_DEV_VIDEO) != NVOS00_STATUS_SUCCESS)
                    return(FALSE);
        pDriverData->NvDevVideoFlatPio = 0;
    }

    pDriverData->extra422OverlayOffset[0] = 0;
    pDriverData->extra422OverlayOffset[1] = 0;

    // Let 16 bit Display Driver code know that Direct Draw is no longer active
    pDriverData->DDrawVideoSurfaceCount = 0;

    pDriverData->fNvActiveFloatingContexts = 0;

    // Reset AGP GART addresses
    pDriverData->GARTLinearBase = 0;
    pDriverData->GARTPhysicalBase = 0;

    pDriverData->wDDrawActive = (WORD)FALSE; // let everyone know DDraw is no longer active
    pDriverData->dwRingZeroMutex = FALSE;
#ifdef WINNT
    if (NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
             NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY) != NVOS00_STATUS_SUCCESS)
                return(FALSE);
    if (NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
             NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY) != NVOS00_STATUS_SUCCESS)
                return(FALSE);
    if (NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
             NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY) != NVOS00_STATUS_SUCCESS)
                return(FALSE);
#endif // #ifdef WINNT

#ifndef WINNT
    pDestroyDriverData->ddRVal = DD_OK;
#endif // #ifndef WINNT
    return DDHAL_DRIVER_HANDLED;

} /* DestroyDriver32 */

#ifndef WINNT
/*
 * GetHeapAlignment32
 *
 * Returns more specific heap alignment requirements to DDRAW than
 * those described in the heap structure.
 */

DWORD __stdcall GetHeapAlignment32(LPDDHAL_GETHEAPALIGNMENTDATA lpGhaData) {

    lpGhaData->ddRVal= DD_OK;

    if (lpGhaData->dwHeap == 0) {
        lpGhaData->Alignment.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN |
                                              DDSCAPS_EXECUTEBUFFER |
                                              DDSCAPS_OVERLAY |
                                              DDSCAPS_TEXTURE |
                                              DDSCAPS_ZBUFFER |
                                              DDSCAPS_ALPHA |
                                              DDSCAPS_FLIP;

        /* Alignments in bytes */

        lpGhaData->Alignment.ExecuteBuffer.Linear.dwStartAlignment = 0;
        lpGhaData->Alignment.ExecuteBuffer.Linear.dwPitchAlignment = 0;

        lpGhaData->Alignment.Overlay.Linear.dwStartAlignment = NV_BYTE_ALIGNMENT;
        lpGhaData->Alignment.Overlay.Linear.dwPitchAlignment = NV_BYTE_ALIGNMENT;

        lpGhaData->Alignment.Texture.Linear.dwStartAlignment = NV_BYTE_ALIGNMENT; /* Texture surfaces, not our optimized texture alignment */
        lpGhaData->Alignment.Texture.Linear.dwPitchAlignment = NV_BYTE_ALIGNMENT;

        lpGhaData->Alignment.ZBuffer.Linear.dwStartAlignment = NV_BYTE_ALIGNMENT;
        lpGhaData->Alignment.ZBuffer.Linear.dwPitchAlignment = NV_BYTE_ALIGNMENT;

        lpGhaData->Alignment.AlphaBuffer.Linear.dwStartAlignment = NV_BYTE_ALIGNMENT;
        lpGhaData->Alignment.AlphaBuffer.Linear.dwPitchAlignment = NV_BYTE_ALIGNMENT;

        lpGhaData->Alignment.Offscreen.Linear.dwStartAlignment = NV_BYTE_ALIGNMENT;
        lpGhaData->Alignment.Offscreen.Linear.dwPitchAlignment = NV_BYTE_ALIGNMENT;

        lpGhaData->Alignment.FlipTarget.Linear.dwStartAlignment = NV_SCAN_OUT_BYTE_ALIGNMENT;
        lpGhaData->Alignment.FlipTarget.Linear.dwPitchAlignment = NV_BYTE_ALIGNMENT;

    } else {
        DPF("D3D: GetHeapAlignment32 - invalid parameters 10");
        lpGhaData->ddRVal = DDERR_INVALIDPARAMS;
        return DDHAL_DRIVER_NOTHANDLED;
    }

    return DDHAL_DRIVER_HANDLED;

} /* GetHeapAlignment32 */


/*
 * UpdateNonLocalHeap32
 *
 * Records actual AGP memory linear and physical addresses.
 */

DWORD __stdcall UpdateNonLocalHeap32( LPDDHAL_UPDATENONLOCALHEAPDATA lpd )
{
    unsigned long oldDmaPusherBufferBase;

    NvSetDriverDataPtr(lpd->lpDD);

    oldDmaPusherBufferBase = pDriverData->NvAGPDmaPusherBufferBase;

    if( lpd->dwHeap == AGP_HEAP ) { /* AGP heap */
        /* This it the linear non-local heap we use for DMA push buffers, textures and YV12 surfaces... */
        pDriverData->GARTLinearBase = lpd->fpGARTLin;
        pDriverData->GARTPhysicalBase = lpd->fpGARTDev;

        /* Let the resource manager know this information */
        NvConfigSet(NV_CFG_AGP_PHYS_BASE, pDriverData->GARTPhysicalBase, pDriverData->dwDeviceIDNum);
        NvConfigSet(NV_CFG_AGP_LINEAR_BASE, pDriverData->GARTLinearBase, pDriverData->dwDeviceIDNum);
        /* currently limit AGP memory to 32 MB */
        NvConfigSet(NV_CFG_AGP_LIMIT, NV_MAX_AGP_MEMORY_LIMIT, pDriverData->dwDeviceIDNum);

        pDriverData->NvAGPDmaPusherBufferBase =
            (DWORD) DDHAL32_VidMemAlloc(lpd->lpDD, AGP_HEAP, pDriverData->NvDmaPusherBufferSize, 1);

        /* Handle case where AGP DMA push buffer gets moved */
        if ((oldDmaPusherBufferBase) &&
            (oldDmaPusherBufferBase != pDriverData->NvAGPDmaPusherBufferBase) &&
            (pDriverData->dwDmaPusherCtxDmaSize)) {

            if (NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                     NV_DD_DMA_PUSHER_CONTEXT_DMA_FROM_MEMORY) != NVOS00_STATUS_SUCCESS) {
                lpd->ddRVal = DDERR_GENERIC;
                return DDHAL_DRIVER_HANDLED;
            }
            pDriverData->dwDmaPusherCtxDmaSize = 0;
        }
    }

    lpd->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;

} /* UpdateNonLocalHeap32 */
#endif // #ifndef WINNT

/*
 * GetAvailDriverMemory32
 *
 * Reports amount of memory that the driver is managing itself.
 */
DWORD __stdcall GetAvailDriverMemory32( LPDDHAL_GETAVAILDRIVERMEMORYDATA lpd )
{
    NvSetDriverDataPtr(lpd->lpDD);

#ifdef NVHEAPMGR
    /*
     * The driver is using the RM to manage video memory.
     */
    lpd->dwTotal = pDriverData->VideoHeapTotal;
    lpd->dwFree  = pDriverData->VideoHeapFree;
#else
    /*
     * The driver is only managing private memory on PCI systems for textures.
     */
    lpd->dwTotal = 0;
    lpd->dwFree  = 0;
#endif
    /*
     * The driver is only managing private memory on PCI systems for textures.
     */
    if ((lpd->DDSCaps.dwCaps & DDSCAPS_TEXTURE) && (pDriverData->GARTLinearBase == 0))
    {
        /* Check to see if D3D has been fired up yet. */
        if (pDriverData->dwTextureHeapSizeMax == 0)
        {
            /*
             * If the current texture heap size is not initialized yet, then this means
             * D3D has not be fired up yet to actually allocate the texture heap.  In this
             * case return the amount that is being requested.  Once D3D is up and running,
             * the memory sizes will be based on what the heap size really is.
             */
            lpd->dwTotal += pDriverData->regTexHeap;
            lpd->dwFree  += pDriverData->regTexHeap;
        }
        else
        {
            /*
             * Return the maximum and available size of the internal PCI
             * system meory texture heap
             */
            lpd->dwTotal += pDriverData->dwTextureHeapSizeMax;
            lpd->dwFree  += pDriverData->dwFreeSize;
        }
    }
    else
    {
        /*
         * For non-texture surface requests or AGP systems, there is no internal memory.
         */
        lpd->dwTotal += 0;
        lpd->dwFree  += 0;
    }
    lpd->ddRVal = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}


/* Safe procedures, basically if they are called nothing happens */
DWORD FAR PASCAL SafeSyncSurfaceData(LPDDHAL_SYNCSURFACEDATA lpInput)
{
    lpInput->ddRVal= DD_OK;

    return DDHAL_DRIVER_HANDLED;
}

DWORD FAR PASCAL SafeSyncVideoPortData(LPDDHAL_SYNCVIDEOPORTDATA lpInput)
{
    lpInput->ddRVal= DD_OK;

    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// nvSetOverlayColorControl
//      Sets the colour control for the hardware overlay.  This is a private
//      interface for codec vendors.  The colour controls will be applied to
//      any flippable overlay to the target surface.  Only YUY2 and UYVY surfaces
//      are supported.  If the lpDDCC is NULL, then capabilities are returned,
//      otherwise returns TRUE if succeeded.
//      NOTE to codec vendors: if you are applying this to an anchor frame that
//      needs to be used again, blit it somewhere else first because the frame
//      data is modified in place to the flip target.
DWORD __stdcall nvSetOverlayColorControl(LPDDCOLORCONTROL lpDDCC)
{
    if (lpDDCC) {
#ifdef OVLCCTL
        if (lpDDCC->dwSize != sizeof(DDCOLORCONTROL)) return FALSE;
        pDriverData->OverlayColourControl.lContrast = lpDDCC->lContrast;
        if ((lpDDCC->dwFlags & ~DDCOLOR_CONTRAST) != 0) return FALSE;
        return TRUE;
#else
        return FALSE;
#endif
    } else {
#ifdef OVLCCTL
        return DDCOLOR_CONTRAST;
#else
        return 0;
#endif
    }
}

#ifdef OVLCCTL
/*
 * GetTranslatedOffset(DWORD lBrightness )
 *
 * Converts linear brightness into an offset to program into
 * CSC registers, this algorithm is non-linear and
 * includes two ranges.
 */
DWORD GetTranslatedOffset( unsigned long lBrightness)
{
    DWORD dwOffset;

    if (lBrightness>10000)
        lBrightness = 10,000;

    if (lBrightness<=750)
        {
        dwOffset = 1+ ( 0x3D * (lBrightness/749) );
        }
    else
        {
        dwOffset = (0x69 * (lBrightness/(10,000-750)));
        }

    return dwOffset;
}

#define NV_PVIDEO_RED_CSC 0x680280
#define NV_PVIDEO_GREEN_CSC 0x680284
#define NV_PVIDEO_BLUE_CSC 0x680288

DWORD GetOffsetTranslated()
{
    U032 * nvBase;
    U032 dwRedCsc;

    // all of this is based of the red csc value
    nvBase = (U032 *) (pDriverData->NvBaseFlat);

    dwRedCsc = nvBase[NV_PVIDEO_RED_CSC/4];

    if (dwRedCsc>=0x69)
        {// 750 to 0 range
        return (750 * ((dwRedCsc-0x69)/0x3E));
        }
    else
        {// 750-10,000 range
        return (750 + ((10000-750)* ((0x69-dwRedCsc)/0x69)) );
        }
}


/*
 * Colour Control
 * Extended functionality of DirectDraw/VPE
 */
DWORD FAR PASCAL ColourControl( LPDDHAL_COLORCONTROLDATA pvpcd )
{
    U032 *nvBase;

    if (pvpcd->lpDDSurface->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {

        NvSetDriverDataPtr(pvpcd->lpDD);

        if (pvpcd->dwFlags & DDRAWI_GETCOLOR ) {

            pvpcd->lpColorData->dwSize = sizeof(DDCOLORCONTROL);

            // time being can only do brightness and contrast
            pvpcd->lpColorData->dwFlags = DDCOLOR_BRIGHTNESS; // DDCOLOR_HUE
            pvpcd->lpColorData->dwFlags = DDCOLOR_CONTRAST;

            // is in units of 1, maximum is 10,000
            pvpcd->lpColorData->lBrightness = GetOffsetTranslated();

            // contrast ranges from 0 to 20,000 (intended to be 0 to 200%)
            // since we can't do overcontrasting, make 20,000 equal to 100% (technically not illegal)
            pvpcd->lpColorData->lContrast = min(pDriverData->OverlayColourControl.lContrast * 20000 / 255, 20000);

            pvpcd->ddRVal = DD_OK;
            return DDHAL_DRIVER_HANDLED;
        }

        if (pvpcd->dwFlags & DDRAWI_SETCOLOR ) {
            // can only do brightness and contrast, any other request is denied
            if (pvpcd->lpColorData->dwFlags & DDCOLOR_BRIGHTNESS) {
                DWORD dwCscOffset;
                DWORD dwCscRed, dwCscGreen, dwCscBlue;

                dwCscOffset = GetTranslatedOffset( pvpcd->lpColorData->lBrightness );

                dwCscRed = 0x69     + dwCscOffset;
                dwCscGreen = 0x3E   - dwCscOffset;
                dwCscBlue  = 0x89   + dwCscOffset;

                nvBase = (U032 *) (pDriverData->NvBaseFlat);

                nvBase[NV_PVIDEO_RED_CSC/4] = dwCscRed;
                nvBase[NV_PVIDEO_GREEN_CSC/4] = dwCscGreen;
                nvBase[NV_PVIDEO_BLUE_CSC/4] = dwCscBlue;
            }
            if (pvpcd->lpColorData->dwFlags & DDCOLOR_CONTRAST) {
                pDriverData->OverlayColourControl.lContrast = min(pvpcd->lpColorData->lContrast * 256 / 20000, 255);
            }
            if (pvpcd->lpColorData->dwFlags & (DDCOLOR_BRIGHTNESS | DDCOLOR_CONTRAST)) {
                pvpcd->ddRVal = DD_OK;
                return DDHAL_DRIVER_HANDLED;
            }
        }
    }

    return DDHAL_DRIVER_NOTHANDLED;
}
#endif

#ifndef WINNT
/*
 * GetDriverInfo32
 *
 * Initialize Extended Functionality Classes
 */

DWORD __stdcall GetDriverInfo32(LPDDHAL_GETDRIVERINFODATA lpData)
{
    pDriverData = (GLOBALDATA *)lpData->dwContext;

    lpData->ddRVal = DDERR_CURRENTLYNOTAVAIL;

    if (IsEqualIID(&(lpData->guidInfo), &GUID_MiscellaneousCallbacks) ) {
        DDHAL_DDMISCELLANEOUSCALLBACKS miscCB;
        DWORD dwSize = lpData->dwExpectedSize;

        if ( sizeof(miscCB) < dwSize )
            dwSize = sizeof(miscCB);
        lpData->dwActualSize = sizeof(miscCB);
        memset(&miscCB, 0, dwSize);
        miscCB.dwSize = dwSize;

        miscCB.dwFlags =
#ifndef WINNT
                         DDHAL_MISCCB32_GETHEAPALIGNMENT |
                         DDHAL_MISCCB32_UPDATENONLOCALHEAP |
#endif
                         DDHAL_MISCCB32_GETAVAILDRIVERMEMORY;

#ifndef WINNT
        miscCB.GetHeapAlignment = GetHeapAlignment32;
        miscCB.UpdateNonLocalHeap = UpdateNonLocalHeap32;
#endif
        miscCB.GetAvailDriverMemory = GetAvailDriverMemory32;

        memcpy(lpData->lpvData, &miscCB, dwSize );
        lpData->ddRVal = DD_OK;
    }

#ifdef  DX7
    if (IsEqualIID(&(lpData->guidInfo), &GUID_Miscellaneous2Callbacks) ) {
        DDHAL_DDMISCELLANEOUS2CALLBACKS misc2CB;
        DWORD dwSize = lpData->dwExpectedSize;

        if ( sizeof(misc2CB) < dwSize )
            dwSize = sizeof(misc2CB);
        lpData->dwActualSize = sizeof(misc2CB);
        memset(&misc2CB, 0, dwSize);
        misc2CB.dwSize = dwSize;

        misc2CB.dwFlags = DDHAL_MISC2CB32_ALPHABLT;

        misc2CB.AlphaBlt = Blit32;  /* Use common callback with Blit32 calls */

        memcpy(lpData->lpvData, &misc2CB, dwSize );
        lpData->ddRVal = DD_OK;
    }
#endif  /* DX7 */

    if( IsEqualGUID( &lpData->guidInfo, &GUID_NonLocalVidMemCaps ) ) {
        DWORD dwSize;
        LPDDNONLOCALVIDMEMCAPS lpCaps;
        int i;

        /* Size validation code omitted for clarity */
        dwSize = min(lpData->dwExpectedSize, sizeof(DDNONLOCALVIDMEMCAPS));
        lpCaps = (LPDDNONLOCALVIDMEMCAPS)(lpData->lpvData);
        lpCaps->dwSize = dwSize;

        lpCaps->dwNLVBCaps = ddHALInfo.ddCaps.dwCaps;
        lpCaps->dwNLVBCaps2 = ddHALInfo.ddCaps.dwCaps2;
        lpCaps->dwNLVBCKeyCaps = ddHALInfo.ddCaps.dwCKeyCaps;
        lpCaps->dwNLVBFXCaps = ddHALInfo.ddCaps.dwFXCaps;

        for( i=0; i < DD_ROP_SPACE; i++ )
            lpCaps->dwNLVBRops[i] = ropList[i];

        lpData->dwActualSize = dwSize;
        lpData->ddRVal = DD_OK;
    }


    if (IsEqualIID(&(lpData->guidInfo), &GUID_VideoPortCallbacks) ) {
        DDHAL_DDVIDEOPORTCALLBACKS vpCB;
        DWORD dwSize = lpData->dwExpectedSize;

        if ( sizeof(vpCB) < dwSize )
            dwSize = sizeof(vpCB);
        lpData->dwActualSize = sizeof(vpCB);
        memset(&vpCB, 0, dwSize);
        vpCB.dwSize = dwSize;

        vpCB.dwFlags = DDHAL_VPORT32_CANCREATEVIDEOPORT |
                       DDHAL_VPORT32_CREATEVIDEOPORT    |
                       DDHAL_VPORT32_DESTROY            |
                       DDHAL_VPORT32_FLIP               |
                       DDHAL_VPORT32_GETBANDWIDTH       |
                       DDHAL_VPORT32_GETINPUTFORMATS    |
                       DDHAL_VPORT32_GETOUTPUTFORMATS   |
                       DDHAL_VPORT32_GETFIELD           |
                       DDHAL_VPORT32_GETCONNECT         |
                       DDHAL_VPORT32_GETFLIPSTATUS      |
                       DDHAL_VPORT32_UPDATE             |
                       DDHAL_VPORT32_WAITFORSYNC        |
                       DDHAL_VPORT32_GETSIGNALSTATUS;


        vpCB.CanCreateVideoPort         = CanCreateVideoPort32;
        vpCB.CreateVideoPort            = CreateVideoPort32;
        vpCB.DestroyVideoPort           = DestroyVideoPort32;
        vpCB.FlipVideoPort              = FlipVideoPort32;

        vpCB.GetVideoPortBandwidth      = GetVideoPortBandwidth32;
        vpCB.GetVideoPortInputFormats   = GetVideoPortInputFormat32;
        vpCB.GetVideoPortOutputFormats  = GetVideoPortOutputFormat32;
        vpCB.GetVideoPortField          = GetVideoPortField32;
        vpCB.GetVideoPortConnectInfo    = GetVideoPortConnectInfo;

        vpCB.GetVideoPortFlipStatus     = GetVideoPortFlipStatus32;
        vpCB.UpdateVideoPort            = UpdateVideoPort32;
        vpCB.WaitForVideoPortSync       = WaitForVideoPortSync32;
        vpCB.GetVideoSignalStatus       = GetVideoSignalStatus32;

        memcpy(lpData->lpvData, &vpCB, dwSize );
        lpData->ddRVal = DD_OK;
    }

#ifdef OVLCCTL
    if (IsEqualIID(&(lpData->guidInfo),&GUID_ColorControlCallbacks) ) {
        DDHAL_DDCOLORCONTROLCALLBACKS ccCB;
        DWORD dwSize = lpData->dwExpectedSize;

        lpData->dwActualSize = sizeof( DDHAL_DDCOLORCONTROLCALLBACKS );

        ccCB.dwSize = (dwSize<lpData->dwActualSize)?
                        dwSize:lpData->dwActualSize;


        ccCB.dwFlags = DDHAL_COLOR_COLORCONTROL;
        ccCB.ColorControl = ColourControl;

        memcpy(lpData->lpvData, &ccCB, ccCB.dwSize );

        lpData->ddRVal = DD_OK;
    }
#endif

    if (IsEqualIID(&(lpData->guidInfo), &GUID_VideoPortCaps) ) {
        DDVIDEOPORTCAPS VideoPortCaps;
        DDVIDEOPORTCAPS *pVideoPortCapsDest = lpData->lpvData;
        DWORD dwIndex;

        // expecting query for 1 video port
        if (lpData->dwExpectedSize != (sizeof(VideoPortCaps)) )
            return DDHAL_DRIVER_HANDLED;

        lpData->dwActualSize = (sizeof(VideoPortCaps) );

    // index changed to allow only 1 report resolution, for time being only NTSC
    // until class structure is changed to test PAL etc
        for (dwIndex = 0; dwIndex < 1; dwIndex++) {

        memset(&VideoPortCaps, 0, sizeof(DDVIDEOPORTCAPS));

        VideoPortCaps.dwSize = sizeof(DDVIDEOPORTCAPS);

        VideoPortCaps.dwFlags = DDVPD_WIDTH             |
                                DDVPD_HEIGHT            |
                                DDVPD_ID                |
                                DDVPD_CAPS              |
                                DDVPD_FX                |
                                DDVPD_AUTOFLIP          |
                                DDVPD_ALIGN             |
                                DDVPD_PREFERREDAUTOFLIP |
                                DDVPD_FILTERQUALITY;

        VideoPortCaps.dwVideoPortID = dwIndex;
        // for more supported video modes, place the resolutions here
//        VideoPortCaps.dwMaxWidth  = ST_VPE_MAX_INPUT_X;
//       VideoPortCaps.dwMaxVBIWidth = ST_VPE_MAX_INPUT_X;
//      VideoPortCaps.dwMaxHeight   = ST_VPE_MAX_INPUT_Y;
        VideoPortCaps.dwMaxWidth    = 4096;     // must talk to joe and get the details on this..
        VideoPortCaps.dwMaxVBIWidth = 4096;
        VideoPortCaps.dwMaxHeight   = 640;      // just arbitarily larger than PAL field *2 for progressive

// could have share even/odd, but for now keep things simple

        VideoPortCaps.dwCaps =
                                DDVPCAPS_AUTOFLIP       |
                                DDVPCAPS_INTERLACED     |
                                DDVPCAPS_NONINTERLACED  |
//                              DDVPCAPS_SHAREABLE      |
                                DDVPCAPS_SKIPEVENFIELDS |
                                DDVPCAPS_SKIPODDFIELDS  |
                                DDVPCAPS_VBISURFACE     |
                                DDVPCAPS_OVERSAMPLEDVBI;

        VideoPortCaps.dwFX =
                                DDVPFX_CROPTOPDATA      |
                                DDVPFX_INTERLEAVE       |
                                DDVPFX_PRESHRINKXB      |
                                DDVPFX_PRESHRINKY       | // y can accept arbitary (except 0)
                                DDVPFX_VBICONVERT       |
                                DDVPFX_VBINOSCALE       |
                                DDVPFX_VBINOINTERLEAVE  |
                                DDVPFX_IGNOREVBIXCROP;


       VideoPortCaps.dwNumAutoFlipSurfaces = 5;


        VideoPortCaps.dwAlignVideoPortBoundary      = NV_BYTE_ALIGNMENT;
        VideoPortCaps.dwAlignVideoPortPrescaleWidth = 1;

// can't crop to an arbitary rectangle!!
        VideoPortCaps.dwAlignVideoPortCropBoundary  = 1;
        VideoPortCaps.dwAlignVideoPortCropWidth     = 1;

// not valid for PRESHRINKX/YB flag as set above
        VideoPortCaps.dwPreshrinkXStep = 24;
        VideoPortCaps.dwPreshrinkYStep = 0x400;


        VideoPortCaps.dwNumVBIAutoFlipSurfaces = 5;

        VideoPortCaps.dwNumPreferredAutoflip =3;
        VideoPortCaps.wNumFilterTapsX = 2;
        VideoPortCaps.wNumFilterTapsY = 1;

        memcpy(&pVideoPortCapsDest[dwIndex], &VideoPortCaps, sizeof(VideoPortCaps) );
        }
        lpData->ddRVal = DD_OK;
    }

    if (IsEqualIID(&(lpData->guidInfo), &GUID_KernelCallbacks) ) {
        DDHAL_DDKERNELCALLBACKS kCB;
        DWORD dwSize = lpData->dwExpectedSize;

        if ( sizeof(kCB) < dwSize )
            dwSize = sizeof(kCB);
        lpData->dwActualSize = sizeof(kCB);

        kCB.dwSize = sizeof(DDHAL_DDKERNELCALLBACKS);
        kCB.dwFlags = DDHAL_KERNEL_SYNCSURFACEDATA | DDHAL_KERNEL_SYNCVIDEOPORTDATA;
        kCB.SyncSurfaceData = SafeSyncSurfaceData;          // we're not doing anything on EITHER of these yet
        kCB.SyncVideoPortData = SafeSyncVideoPortData;

        memcpy(lpData->lpvData, &kCB, dwSize );
        //lpData->ddRVal = DDERR_CURRENTLYNOTAVAIL;
        lpData->ddRVal = DD_OK;
    }

    if (IsEqualIID(&(lpData->guidInfo), &GUID_KernelCaps) ) {
        DDKERNELCAPS KernelCaps;

        if (lpData->dwExpectedSize != sizeof(DDKERNELCAPS) )
            return DDHAL_DRIVER_HANDLED;

        lpData->dwActualSize = sizeof(DDKERNELCAPS);

        KernelCaps.dwSize = sizeof(DDKERNELCAPS);
        KernelCaps.dwCaps =
            DDKERNELCAPS_SKIPFIELDS         |
            DDKERNELCAPS_AUTOFLIP           |
            DDKERNELCAPS_SETSTATE           |
            DDKERNELCAPS_LOCK                   |
//          DDKERNELCAPS_FLIPVIDEOPORT      |
            DDKERNELCAPS_FLIPOVERLAY        |
//          DDKERNELCAPS_CAPTURE_SYSMEM |
//          DDKERNELCAPS_CAPTURE_NONLOCALVIDMEM |
            DDKERNELCAPS_FIELDPOLARITY      ;
//          DDKERNELCAPS_CAPTURE_INVERTED   ;

        KernelCaps.dwIRQCaps = DDIRQ_VPORT0_VSYNC |
//                                      DDIRQ_BUSMASTER;
//                                      #define DDIRQ_BUSMASTER             0x00000002l
                                        0x00000002;

//          DDIRQ_DISPLAY_VSYNC |
//          DDIRQ_RESERVED1     |
//          DDIRQ_VPORT0_VSYNC          // this is the only IRQ we'll be supporting
//          DDIRQ_VPORT0_LINE       |
//          DDIRQ_VPORT1_VSYNC  |
//          DDIRQ_VPORT1_LINE   |

        memcpy(lpData->lpvData, &KernelCaps, sizeof(DDKERNELCAPS) );
        //lpData->ddRVal = DDERR_CURRENTLYNOTAVAIL;
        lpData->ddRVal = DD_OK;
    }

#ifdef  DX7
    if (IsEqualIID(&(lpData->guidInfo), &GUID_DDMoreCaps) ) {
        DDMORECAPS ddMoreCaps;

        if (lpData->dwExpectedSize != sizeof(DDMORECAPS) )
            return DDHAL_DRIVER_HANDLED;

        lpData->dwActualSize = sizeof(DDMORECAPS);

        ddMoreCaps.dwSize = sizeof(DDMORECAPS);

        ddMoreCaps.dwAlphaCaps = DDALPHACAPS_BLTALPHAPIXELS |
                                 DDALPHACAPS_BLTSATURATE |
                                 DDALPHACAPS_BLTPREMULT |
//                                 DDALPHACAPS_BLTNONPREMULT |
                                 DDALPHACAPS_BLTRGBASCALE1F |
                                 DDALPHACAPS_BLTRGBASCALE4F |
                                 DDALPHACAPS_BLTALPHAFILL;

        ddMoreCaps.dwSVBAlphaCaps = DDALPHACAPS_BLTALPHAPIXELS |
                                    DDALPHACAPS_BLTSATURATE |
                                    DDALPHACAPS_BLTPREMULT |
//                                    DDALPHACAPS_BLTNONPREMULT |
                                    DDALPHACAPS_BLTRGBASCALE1F |
                                    DDALPHACAPS_BLTRGBASCALE4F |
                                    DDALPHACAPS_BLTALPHAFILL;

        ddMoreCaps.dwFilterCaps = DDFILTCAPS_BLTBILINEARFILTER |
                                  DDFILTCAPS_BLTFLATFILTER |
                                  DDFILTCAPS_OVERLAYBILINEARFILTER;

        ddMoreCaps.dwSVBFilterCaps = DDFILTCAPS_BLTBILINEARFILTER |
                                     DDFILTCAPS_BLTFLATFILTER;

        memcpy(lpData->lpvData, &ddMoreCaps,
            sizeof(DDMORECAPS) );
        lpData->ddRVal = DD_OK;
    }
#endif  /* DX7 */


#ifdef NVD3D
    /*
     * Call D3D HAL to see if there's any GUIDs it wants to handle.
     */
    D3DGetDriverInfo(lpData);
#endif

    return DDHAL_DRIVER_HANDLED;

} /* GetDriverInfo32 */
#endif // #ifndef WINNT

/*
 * buildDDHALInfo32
 *
 * build DDHALInfo structure
 */
BOOL buildDDHALInfo32()
{
   int i;

    /*
     * modify the structures inour shared window with the 16bit driver
     */
    #define cbDDCallbacks        pDriverData->DDCallbacks
    #define cbDDSurfaceCallbacks pDriverData->DDSurfaceCallbacks
    #define cbDDPaletteCallbacks pDriverData->DDPaletteCallbacks

    /*
     * fill out the main driver callbacks
     */
    memset(&cbDDCallbacks, 0, sizeof(DDHAL_DDCALLBACKS));
    cbDDCallbacks.dwSize                = sizeof(DDHAL_DDCALLBACKS);
//    cbDDCallbacks.SetMode               = SetMode32;   Never called by DDRAW
    cbDDCallbacks.WaitForVerticalBlank  = WaitForVerticalBlank32;
    cbDDCallbacks.GetScanLine           = GetScanLine32;
    cbDDCallbacks.CreateSurface         = CreateSurface32;
    cbDDCallbacks.CanCreateSurface      = CanCreateSurface32;
#ifndef WINNT       // this is called from DrvDisableDirectDraw
    cbDDCallbacks.DestroyDriver         = DestroyDriver32;
#endif              // WINNT

    cbDDCallbacks.dwFlags               = DDHAL_CB32_WAITFORVERTICALBLANK |
//                                          DDHAL_CB32_SETMODE |
                                          DDHAL_CB32_GETSCANLINE |
                                          DDHAL_CB32_CANCREATESURFACE |
                                          DDHAL_CB32_CREATESURFACE |
                                          DDHAL_CB32_DESTROYDRIVER;

    /*
     * fill out the palette callbacks
     */
    memset(&cbDDPaletteCallbacks, 0, sizeof(DDHAL_DDPALETTECALLBACKS));
    cbDDPaletteCallbacks.dwSize  = sizeof(DDHAL_DDPALETTECALLBACKS);
    cbDDPaletteCallbacks.dwFlags = 0;

    /*
     * fill out the HALINFO
     */
    memset(&ddHALInfo, 0, sizeof(DDHALINFO));
    ddHALInfo.dwSize = sizeof(DDHALINFO);

    /*
     * callback functions
     */
#ifndef WINNT
    ddHALInfo.lpDDCallbacks        = &cbDDCallbacks;
    ddHALInfo.lpDDSurfaceCallbacks = &cbDDSurfaceCallbacks;
    ddHALInfo.lpDDPaletteCallbacks = &cbDDPaletteCallbacks;

    /*
     * return our HINSTANCE
     */
    ddHALInfo.hInstance = (DWORD)hInstance;

    /*
     * pdevice
     */
    ddHALInfo.lpPDevice = (LPVOID)pDriverData->lpPDevice;
#else
    ddHALInfo.lpD3DHALCallbacks        = &cbDDCallbacks;
#endif // #ifdef WINNT

    /*
     * ROPS supported
     */

    for( i=0; i < DD_ROP_SPACE; i++ )
        ddHALInfo.ddCaps.dwRops[i] = ropList[i];

    for( i=0; i < DD_ROP_SPACE; i++ )
        ddHALInfo.ddCaps.dwSVBRops[i] = ropList[i];


   /*
    * fill out the surface callbacks
    */
    memset(&cbDDSurfaceCallbacks, 0, sizeof(DDHAL_DDSURFACECALLBACKS));
    cbDDSurfaceCallbacks.dwSize             = sizeof(DDHAL_DDSURFACECALLBACKS);
    cbDDSurfaceCallbacks.DestroySurface     = DestroySurface32;
    cbDDSurfaceCallbacks.Blt                = Blit32;
    cbDDSurfaceCallbacks.Flip               = Flip32;
    cbDDSurfaceCallbacks.Lock               = Lock32;
    cbDDSurfaceCallbacks.Unlock             = Unlock32;
    cbDDSurfaceCallbacks.GetBltStatus       = GetBltStatus32;
    cbDDSurfaceCallbacks.GetFlipStatus      = GetFlipStatus32;
    cbDDSurfaceCallbacks.UpdateOverlay      = UpdateOverlay32;
    cbDDSurfaceCallbacks.SetOverlayPosition = SetOverlayPosition32;
    cbDDSurfaceCallbacks.SetColorKey        = SetSurfaceColorKey32;
    cbDDSurfaceCallbacks.dwFlags            = DDHAL_SURFCB32_BLT |
                                              DDHAL_SURFCB32_FLIP |
                                              DDHAL_SURFCB32_LOCK |
                                              DDHAL_SURFCB32_UNLOCK |
                                              DDHAL_SURFCB32_SETCOLORKEY |
                                              DDHAL_SURFCB32_GETBLTSTATUS |
                                              DDHAL_SURFCB32_GETFLIPSTATUS |
                                              DDHAL_SURFCB32_UPDATEOVERLAY |
                                              DDHAL_SURFCB32_SETOVERLAYPOSITION |
                                              DDHAL_SURFCB32_DESTROYSURFACE;

    /*
     * capabilities supported
     */

    ddHALInfo.ddCaps.dwCaps = DDCAPS_ALIGNSTRIDE |
                              DDCAPS_ALIGNBOUNDARYDEST |
                              DDCAPS_GDI |
                              DDCAPS_BLT |
                              DDCAPS_BLTFOURCC |
                              DDCAPS_BLTSTRETCH |
                              DDCAPS_BLTQUEUE |
                              DDCAPS_BLTCOLORFILL |
                              DDCAPS_CANBLTSYSMEM |
#ifdef  DX7
                              DDCAPS_ALPHA |
#endif  /* DX7 */
                              DDCAPS_COLORKEY |
                              DDCAPS_OVERLAY |
                              DDCAPS_OVERLAYCANTCLIP  |
                              DDCAPS_OVERLAYFOURCC |
                              DDCAPS_OVERLAYSTRETCH |
                              DDCAPS_READSCANLINE |
                              DDCAPS_BLTDEPTHFILL |
                              DDCAPS_3D;

    ddHALInfo.ddCaps.dwCaps2 |= DDCAPS2_NOPAGELOCKREQUIRED |
                                DDCAPS2_WIDESURFACES |
                                DDCAPS2_FLIPNOVSYNC |
#ifndef WINNT
                                DDCAPS2_PRIMARYGAMMA |
#endif // #ifndef WINNT
                                DDCAPS2_CANRENDERWINDOWED |
                                DDCAPS2_CANBOBHARDWARE |
                                DDCAPS2_CANBOBINTERLEAVED |
                                DDCAPS2_CANFLIPODDEVEN |
#ifdef OVLCCTL
                                DDCAPS2_COLORCONTROLOVERLAY |
#endif
                                DDCAPS2_NONLOCALVIDMEMCAPS;

    ddHALInfo.ddCaps.dwSVBCaps = ddHALInfo.ddCaps.dwCaps;

    ddHALInfo.ddCaps.dwSVBCaps2 = ddHALInfo.ddCaps.dwCaps2;


    ddHALInfo.ddCaps.ddsCaps.dwCaps = DDSCAPS_VIDEOMEMORY |
                                      DDSCAPS_SYSTEMMEMORY |
                                      DDSCAPS_PRIMARYSURFACE |
                                      DDSCAPS_HWCODEC |
                                      DDSCAPS_OFFSCREENPLAIN |
                                      DDSCAPS_VISIBLE |
                                      DDSCAPS_FLIP |
                                      DDSCAPS_FRONTBUFFER |
                                      DDSCAPS_BACKBUFFER |
                                      DDSCAPS_OVERLAY |
                                      DDSCAPS_ZBUFFER |
                                      DDSCAPS_3DDEVICE |
#ifdef  DX7
                                      DDSCAPS_ALPHA |
#endif  /* DX7 */
                                      DDSCAPS_TEXTURE |
                                      DDSCAPS_MIPMAP;

    ddHALInfo.ddCaps.dwFXAlphaCaps  = 0;

    ddHALInfo.ddCaps.dwCKeyCaps = DDCKEYCAPS_SRCBLT |
                                  DDCKEYCAPS_DESTOVERLAY |
                                  DDCKEYCAPS_DESTOVERLAYONEACTIVE;

    ddHALInfo.ddCaps.dwSVBCKeyCaps = ddHALInfo.ddCaps.dwCKeyCaps;

    ddHALInfo.ddCaps.dwFXCaps = DDFXCAPS_BLTARITHSTRETCHY |
//                              DDFXCAPS_BLTMIRRORLEFTRIGHT |
                              DDFXCAPS_BLTMIRRORUPDOWN |
                              DDFXCAPS_BLTSHRINKX |
                              DDFXCAPS_BLTSHRINKY |
                              DDFXCAPS_BLTSTRETCHX |
                              DDFXCAPS_BLTSTRETCHY |
#ifdef  DX7
                              DDFXCAPS_BLTALPHA |
                              DDFXCAPS_BLTFILTER |
                              DDFXCAPS_OVERLAYFILTER |
                              DDFXCAPS_OVERLAYMIRRORLEFTRIGHT |
#endif  /* DX7 */
                              DDFXCAPS_OVERLAYMIRRORUPDOWN |
                              DDFXCAPS_OVERLAYSHRINKX |
                              DDFXCAPS_OVERLAYSHRINKY |
                              DDFXCAPS_OVERLAYSTRETCHX |
                              DDFXCAPS_OVERLAYARITHSTRETCHY |
                              DDFXCAPS_OVERLAYSTRETCHY;

    ddHALInfo.ddCaps.dwSVBFXCaps = ddHALInfo.ddCaps.dwFXCaps;



    /*
     * Z buffer bit depths supported
     */

    ddHALInfo.ddCaps.dwZBufferBitDepths = DDBD_16 | DDBD_24;

    /*
     * NV3 Required alignments
     */

    ddHALInfo.ddCaps.dwAlignBoundaryDest = 1;
    /* All video memory surfaces must be aligned with aligned strides */
    ddHALInfo.ddCaps.dwAlignStrideAlign = NV_BYTE_ALIGNMENT;

    /*
     * NV3 stretching capabilities
     */

    ddHALInfo.ddCaps.dwMinOverlayStretch = 100;
    ddHALInfo.ddCaps.dwMaxOverlayStretch = 20000;

    ddHALInfo.ddCaps.dwMinLiveVideoStretch = 100;
    ddHALInfo.ddCaps.dwMaxLiveVideoStretch = 20000;

    ddHALInfo.ddCaps.dwMinHwCodecStretch = 1;
    ddHALInfo.ddCaps.dwMaxHwCodecStretch = 4095000;

    /*
     *  FOURCCs supported
     *
     *  Table address MUST be set in 16 bit portion of Direct Draw Driver but
     *  can add more FOURCC codes to table here if needed.
     */

    ddHALInfo.ddCaps.dwNumFourCCCodes = NV_MAX_FOURCC;

    /*
     *  Maximum number of overlays supported
     */

    ddHALInfo.ddCaps.dwMaxVisibleOverlays = 1;

#ifndef WINNT
    /*
     * current video mode, the 16bit driver will fill this out for real.
     */

    ddHALInfo.dwModeIndex = DDUNSUPPORTEDMODE;
#endif // #ifndef WINNT

    /*
     * required byte alignments of the scan lines for each kind of memory
     * (default is 4, NV3 needs 16, NV4 needs 32, NV10 wants 64
     */
    ddHALInfo.vmiData.dwOffscreenAlign = NV_BYTE_ALIGNMENT;
    ddHALInfo.vmiData.dwOverlayAlign   = NV_BYTE_ALIGNMENT;
    ddHALInfo.vmiData.dwTextureAlign   = NV_BYTE_ALIGNMENT; /* Texture surface, not our optimized texture */
    ddHALInfo.vmiData.dwAlphaAlign     = NV_BYTE_ALIGNMENT;
    ddHALInfo.vmiData.dwZBufferAlign   = NV_BYTE_ALIGNMENT;

#ifdef NVD3D
    pDriverData->lpLast3DSurfaceRendered = 0;
    pDriverData->ThreeDRenderingOccurred = FALSE;

    /*
     * fill out the D3D callbacks
     */
    D3DHALCreateDriver((LPD3DHAL_GLOBALDRIVERDATA*)&ddHALInfo.lpD3DGlobalDriverData,
                       (LPD3DHAL_CALLBACKS*)&ddHALInfo.lpD3DHALCallbacks);
#endif


    /*
     * Video Port Capabilities
     */


   ddHALInfo.ddCaps.dwCaps2 |=  DDCAPS2_VIDEOPORT               |
                                DDCAPS2_CANBOBINTERLEAVED       |
                                DDCAPS2_CANBOBNONINTERLEAVED    |
                                DDCAPS2_AUTOFLIPOVERLAY;

    ddHALInfo.ddCaps.dwMaxVideoPorts = ST_MAX_VIDEOPORTS;
    ddHALInfo.ddCaps.dwCurrVideoPorts = 0;
#ifndef WINNT
    ddHALInfo.GetDriverInfo = GetDriverInfo32;
    ddHALInfo.dwFlags |= DDHALINFO_GETDRIVERINFOSET | DDHALINFO_MODEXILLEGAL;
    DPF("Display: Filling in ddHALInfo.GetDriverInfo: %lx", GetDriverInfo32);
#endif // #ifndef WINNT

    return TRUE;

} /* buildDDHALInfo */

/*
 * DriverInit
 *
 * this is the entry point called by DirectDraw to
 * initialize the 32-bit driver.
 *
 */
DWORD __stdcall DriverInit( DWORD dwDriverData)
{
    DWORD index = 0;

    pDriverData = (GLOBALDATA *)dwDriverData;

    /* Make sure we match the GLOBALDATA structure size of the current display driver */
    if (pDriverData->dwGlobalStructSize < sizeof(GLOBALDATA))
        return(0);

    pDriverData->dwCurrentFrame = 0;
    pDriverData->dwRenderedFrame = 0;
    pDriverData->dwRingZeroMutex = FALSE;

    pDriverData->blitCalled = FALSE;

    pDriverData->NvFirstCall = 1;    // let ddEnable32 know this is the first call

#ifdef WINNT
    pDriverData->dwSurfaceAlignPad = pDriverData->ppdev->ulSurfaceAlign;
    pDriverData->dwSurfaceAlign = pDriverData->ppdev->ulSurfaceAlign + 1;
    pDriverData->dwSurfaceBitAlign = pDriverData->ppdev->ulSurfaceBitAlign;
#else
    pDriverData->dwSurfaceAlignPad = NV_BYTE_ALIGNMENT_PAD;
    pDriverData->dwSurfaceAlign =    NV_BYTE_ALIGNMENT;
    pDriverData->dwSurfaceBitAlign = NV_BIT_ALIGNMENT;
#endif    

    /* Some apps call DriverInit during mode switches */
    if (pDriverData->dwDmaPusherCtxDmaSize) {

        if (NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                 NV_DD_DMA_PUSHER_CONTEXT_DMA_FROM_MEMORY) != NVOS00_STATUS_SUCCESS)
                    return(FALSE);

        pDriverData->dwDmaPusherCtxDmaSize = 0;
    }

    pDriverData->NvAGPDmaPusherBufferBase = 0;
#ifndef WINNT
    // dynamically assign pusher space
    //
    //  >= 60Mb memory gets a 4 meg push buffer
    //          else a 2 meg opush buffer
    //      note - the GlobalMemoryStatus function does not return exact
    //             amounts thus we give it some head room
    {
        MEMORYSTATUS ms;
        ms.dwLength = sizeof(ms);
        GlobalMemoryStatus (&ms);
        if (ms.dwTotalPhys >= 60*1024*1024)
            pDriverData->NvDmaPusherBufferSize = NV_DD_DMA_PUSH_BUFFER_SIZE_LRG;
        else
            pDriverData->NvDmaPusherBufferSize = NV_DD_DMA_PUSH_BUFFER_SIZE;
    }
    #else
        pDriverData->NvDmaPusherBufferSize = NV_DD_DMA_PUSH_BUFFER_SIZE;
    #endif        // #ifdef WINNT
    // Reset in case of a mode switch which unloaded the driver
    pDriverData->HALInfo.ddCaps.dwCurrVisibleOverlays = 0;

    pDriverData->extra422OverlayOffset[0] = 0;
    pDriverData->extra422OverlayOffset[1] = 0;

    pDriverData->dwOverlayOwner = 0;

    pDriverData->dwOverlaySurfaces = 0;

    while (index < NV_MAX_OVERLAY_SURFACES)
        pDriverData->dwOverlaySurfaceLCL[index++] = 0;

    pDriverData->dwVideoPortsAvailable = 1;

    pDriverData->OverlayColourControl.dwSize = sizeof(DDCOLORCONTROL);
    pDriverData->OverlayColourControl.dwFlags = DDCOLOR_CONTRAST;
    pDriverData->OverlayColourControl.lBrightness = 0;
    pDriverData->OverlayColourControl.lContrast = 0xFF;
    pDriverData->OverlayColourControl.lHue = 0;
    pDriverData->OverlayColourControl.lSaturation = 0xFF;
    pDriverData->OverlayColourControl.lGamma = 0xFF;
    pDriverData->OverlayColourControl.lColorEnable = 1;

#ifdef FORCED_TRIPLE_BUFFER
    pDriverData->bNeedToAttachBuffer = FALSE;
    pDriverData->lpBuffer3 = NULL;
#endif

    buildDDHALInfo32();

    DPF( "    Successfully built 32 bit HAL Info" );

    pDriverData->DDrawVideoSurfaceCount = 0;

    // Set the reset flag here for a future call to ResetNV
    // Don't do the call here because we don't neccessarily now about AGP memory yet.
    pDriverData->fReset = TRUE;
//    if (pDriverData->fReset == FALSE) {
//        ResetNV();
//    }

    // Can't reinitialize NV here because mode change may not have happened yet.

#ifndef WINNT // BUGBUG -- no vpe for nt right now.
    // this call is for VPE/KMVT stuff, to hook up with and initialize their storage
        HookUpVxdStorage();
#else
#if _WIN32_WINNT >= 0x0500
        if (pDriverData->ppdev->AgpHeapBase)
            {
            LPDDRAWI_DIRECTDRAW_GBL     pdrv = NULL;
            //*******************************************************
            // Initialize GLOBALDATA's copy of AGP base address.
            //*******************************************************
            pDriverData->GARTLinearBase = pDriverData->ppdev->AgpHeapBase;

            //********************************************************
            // Alloc AGP DMA Push Buffer
            //********************************************************
            pDriverData->NvAGPDmaPusherBufferBase =
                (ULONG) pDriverData->GARTLinearBase +
                (ULONG) pDriverData->ppdev->DmaPushBufTotalSize;
                    //pDriverData->NvDmaPusherBufferSize;
            }
#endif // #if _WIN32_WINNT >= 0x0500
#endif  // !WINNT


    return dwDriverData;

} /* DriverInit */


#ifndef WINNT
/*
 * DllMain
 */
BOOL WINAPI DllMain(HINSTANCE hModule, DWORD dwReason, LPVOID lpvReserved)
{
    hInstance = hModule;

    switch( dwReason ) {

    case DLL_PROCESS_ATTACH:
#ifndef WINNT
        DisableThreadLibraryCalls( hModule );
#endif // #ifndef WINNT
#ifdef  NVD3D
        init_globals();
#endif  // NVD3D
        break;

    case DLL_PROCESS_DETACH:
#ifdef  NVD3D
        // Destroy Item Arrays
        DestroyItemArrays ();
        DestroyIPM();
#endif  // NVD3D
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;

    default:
        break;
    }

    return TRUE;

} /* DllMain */

/*
 * D3D DX5 Draw Primitive entry points
 */
DWORD __stdcall DrawOnePrimitive32(LPD3DHAL_DRAWONEPRIMITIVEDATA pdopd)
{
    /*
     * Get the pointer to the D3D context data.
     */
    pCurrentContext = (PNVD3DCONTEXT)pdopd->dwhContext;
    if (!pCurrentContext)
    {
        DPF("D3D:DrawOnePrimitive32 - Bad Context");
        pdopd->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }
    NvSetDriverDataPtrFromContext(pCurrentContext);
#if 0 // D3D will take care of waiting for flip by itself
    /*
     * Check if this surface is waiting to be flipped.  If it is, then
     * return to D3D and let it do the right thing.
     */
    if ((pdopd->ddrval = updateFlipStatus(pCurrentContext->lpLcl->lpGbl->fpVidMem)) != DD_OK)
        return (DDHAL_DRIVER_HANDLED);
#endif

    return (nvDrawOnePrimitive(pdopd));
}

DWORD __stdcall DrawOneIndexedPrimitive32(LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA pdoipd)
{
    /*
     * Get the pointer to the D3D context data.
     */
    pCurrentContext = (PNVD3DCONTEXT)pdoipd->dwhContext;
    if (!pCurrentContext)
    {
        DPF("D3D:DrawOneIndexedPrimitive32 - Bad Context");
        pdoipd->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }
    NvSetDriverDataPtrFromContext(pCurrentContext);

#if 0 // D3D will take care of waiting for flip by itself
    /*
     * Check if this surface is waiting to be flipped.  If it is, then
     * return to D3D and let it do the right thing.
     */
    if ((pdoipd->ddrval = updateFlipStatus(pCurrentContext->lpLcl->lpGbl->fpVidMem)) != DD_OK)
        return (DDHAL_DRIVER_HANDLED);
#endif
    return (nvDrawOneIndexedPrimitive(pdoipd));
}

DWORD __stdcall DrawPrimitives32(LPD3DHAL_DRAWPRIMITIVESDATA pdpd)
{
    /*
     * Get the pointer to the D3D context data.
     */
    pCurrentContext = (PNVD3DCONTEXT)pdpd->dwhContext;
    if (!pCurrentContext)
    {
        DPF("D3D:DrawPrimitives32 - Bad Context");
        pdpd->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }
    NvSetDriverDataPtrFromContext(pCurrentContext);

#if 0 // D3D will take care of waiting for flip by itself
    /*
     * Check if this surface is waiting to be flipped.  If it is, then
     * return to D3D and let it do the right thing.
     */
    if ((pdpd->ddrval = updateFlipStatus(pCurrentContext->lpLcl->lpGbl->fpVidMem)) != DD_OK)
        return (DDHAL_DRIVER_HANDLED);
#endif

    return (nvDrawPrimitives(pdpd));
}
DWORD __stdcall Clear32(LPD3DHAL_CLEARDATA pcd)
{
    /*
     * Get the pointer to the D3D context data.
     */
    pCurrentContext = (PNVD3DCONTEXT)pcd->dwhContext;
    if (!pCurrentContext)
    {
        DPF("D3D:Clear32 - Bad Context");
        pcd->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }
    NvSetDriverDataPtrFromContext(pCurrentContext);

#if 0 // D3D will take care of waiting for flip by itself
    /*
     * Check if this surface is waiting to be flipped.  If it is, then
     * return to D3D and let it do the right thing.
     */

//    if ((pcd->ddrval = updateFlipStatus(pCurrentContext->lpLcl->lpGbl->fpVidMem)) != DD_OK)
//        return (DDHAL_DRIVER_HANDLED);
    /*
     * Wait until the flip has occurred, otherwise we will start clearing the buffer while
     * it is still visible.
     */
    while ((pcd->ddrval = updateFlipStatus(pCurrentContext->lpLcl->lpGbl->fpVidMem)) != DD_OK);
#endif

    return (nvClear(pcd));
}
#endif
#ifdef  NVD3D_DX6
DWORD FAR PASCAL DrawPrimitives2
(
    LPD3DHAL_DRAWPRIMITIVES2DATA pdp2d
)
{
    /*
     * Get the pointer to the D3D context data.
     */
    pCurrentContext = (PNVD3DCONTEXT)pdp2d->dwhContext;
    if (!pCurrentContext)
    {
        DPF("D3D:nvDrawPrimitives2 - Bad Context");
        pdp2d->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }
    if (!pCurrentContext->lpLcl)
    {
        pdp2d->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }
    if (!pDriverData->NvDevFlatDma)
    {
        pdp2d->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }
    NvSetDriverDataPtrFromContext(pCurrentContext);

#ifdef  WINNT // D3D will take care of waiting for flip by itself
    /*
     * Check if this surface is waiting to be flipped.  If it is, then
     * return to D3D and let it do the right thing.
     */
    if ((pdp2d->ddrval = updateFlipStatus(pCurrentContext->lpLcl->lpGbl->fpVidMem)) != DD_OK)
        return (DDHAL_DRIVER_HANDLED);
#endif

    return(nvDrawPrimitives2(pdp2d));
}
DWORD FAR PASCAL Clear2
(
    LPD3DHAL_CLEAR2DATA pc2d
)
{
    /*
     * Get the pointer to the D3D context data.
     */
    pCurrentContext = (PNVD3DCONTEXT)pc2d->dwhContext;
    if (!pCurrentContext)
    {
        DPF("D3D:Clear2 - Bad Context");
        pc2d->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }
    if (!pCurrentContext->lpLcl)
    {
        pc2d->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }
    if (!pDriverData->NvDevFlatDma)
    {
        pc2d->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }
    NvSetDriverDataPtrFromContext(pCurrentContext);

#ifdef  WINNT // D3D will take care of waiting for flip by itself
    /*
     * Check if this surface is waiting to be flipped.  If it is, then
     * return to D3D and let it do the right thing.
     */

//    if ((pc2d->ddrval = updateFlipStatus(pCurrentContext->lpLcl->lpGbl->fpVidMem)) != DD_OK)
//        return (DDHAL_DRIVER_HANDLED);

    /*
     * Wait until the flip has occurred, otherwise we will start clearing the buffer while
     * it is still visible.
     */
    while ((pc2d->ddrval = updateFlipStatus(pCurrentContext->lpLcl->lpGbl->fpVidMem)) != DD_OK);
#endif
    return(nvClear2(pc2d));
}

/*
 * WaitForVSync
 */
void WaitForVSync (void)
{
    HRESULT ddrval;

    /*
     * wait until flip has occurred
     */
    for (;;)
    {
        ddrval = updateFlipStatus(0);
        if (ddrval == DD_OK) break;
    }
}

#endif

/*
 * DPF debug stuff
 */
#ifdef DEBUG

#define START_STR       "NVDD32: "
#define END_STR         "\r\n"

/*
 * Msg
 */
#ifndef WINNT
void __cdecl DPF(LPSTR szFormat, ...)
{
    char str[256];

    lstrcpy(str, START_STR);
    wvsprintf(str+lstrlen(str), szFormat, (LPVOID)(&szFormat+1));
    lstrcat(str, END_STR);
    OutputDebugString(str);
}
#else
void __cdecl DPF(LPSTR szFormat, ...)
{
    va_list ap;

    va_start(ap, szFormat);
    EngDebugPrint(START_STR, szFormat, ap);
    EngDebugPrint("", "\n", ap);

    va_end(ap);
}
#endif // #ifdef WINNT

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\global.c ===
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"

#ifdef NV_TEX2
#ifdef NV_FASTLOOPS
#include "..\x86\x86.h"
void ILCCompile_move (DWORD,DWORD,DWORD);
#endif
#endif

#ifdef NV_FASTLOOPS
void ILCWarmCache (void);
#endif

//#pragma data_seg("GLOBAL")
#pragma pack(push,1) // we control alignment
global_struc global={{0}};
#pragma pack(pop)

void init_globals (void) {
    memset (&global,0,sizeof(global));

#ifdef NV_FASTLOOPS
    global.fFogC1     = 2.0f;
    global.fFogC2     = -1.44269504f * (float)0x800000;

    global.fCTC1      = 0.5f;

    global.dwILCData  = NULL;
    global.dwILCCount = 0;
    global.dwILCMax   = 0;

#else  //!NV_FASTLOOPS
    dwVertexSN  = 1;
#endif //!NV_FASTLOOPS

#ifndef WINNT
// setup processor speed
    global.dwProcessorSpeed = nvGetCPUSpeed();

// detect MMX
    {
        BOOL isMMX = nvDetectMMX();
        global.dwCPUFeatureSet |= isMMX ? FS_MMX : 0;
    }

// detect KATMAI
    {
        BOOL isKATMAI = nvDetectKATMAI();
        global.dwCPUFeatureSet |= isKATMAI ? FS_KATMAI : 0;
    }
#endif // #ifndef WINNT

// generate some commonly used inner loops
#ifdef NV_FASTLOOPS
    ILCWarmCache();
#endif //NV_FASTLOOPS

// setup automipmap table
    {
        extern BYTE nvAutoMipPush[256];
        int i;

        for (i=0; i<256; i++)
        {
            float x = ((float)i - 127.5f) / 127.5f;
            if (x > 0)
            {
                x = 2.0f*x - x*x;
            }
            else
            {
                x = 2.0f*x + x*x;
            }
            nvAutoMipPush[i] = (BYTE)((x * 127.5f)+127.5f);
        }
    }

    /*
     * texture sync
     */
#ifdef NV_TEX2
    global.dwHWTextureDate = 10;
    global.dwSWTextureDate = 10;
#if 0
    {
        extern DWORD dbgLevel;
        dbgLevel = 0xffffffff;
    }
#endif
#if 0
    {
        extern DWORD dbgPreviewTexture;
        extern DWORD dbgPreviewTexturePitch;

        dbgPreviewTexture      = 0xffffffff;
        dbgPreviewTexturePitch = 640*2;
    }
#endif

#endif // NV_TEX2
    //*********************************************************
    // Set default surface alignment for AGP push buf heap. There
    // are no alignment restrictions, but we need to pass the
    // SURFACEALIGMENT struct to the ddraw surface allocation
    // routines.
    //*********************************************************
    AgpHeapAlignment.Linear.dwStartAlignment = 4;
    AgpHeapAlignment.Linear.dwPitchAlignment = 0;
}

//////////////////////////////////////////////////////////////////////////////
// InterProcessMemory code
//
static HANDLE hIPM=0;

#ifndef OLDSTUFF
void* AllocIPM (unsigned size) {
    if (!hIPM) hIPM=HEAPCREATE (size);
    return HEAPALLOC (hIPM,size);
}

void FreeIPM (void* ptr) {
    HEAPFREE (hIPM,ptr);
}

void DestroyIPM (void) {
    if (hIPM) HEAPDESTROY (hIPM);
}

void* ReallocIPM (void* ptr,unsigned size) {
    if (!hIPM) hIPM=HEAPCREATE (size);
    if (!ptr) return HEAPALLOC (hIPM,size);
    HEAPREALLOC (hIPM,ptr,size);
    return ptr;
}
#else
void* AllocIPM (unsigned size) {
    if (!hIPM) hIPM=HeapCreate (HEAP_SHARED,size,0);
    return HeapAlloc (hIPM,0,size);
}

void FreeIPM (void* ptr) {
    HeapFree (hIPM,0,ptr);
}

void DestroyIPM (void) {
    if (hIPM) HeapDestroy (hIPM);
}

void* ReallocIPM (void* ptr,unsigned size) {
    if (!hIPM) hIPM=HeapCreate (HEAP_SHARED,size,0);
    if (!ptr) return HeapAlloc (hIPM,0,size);
    return HeapReAlloc (hIPM,0,ptr,size);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\ENABLEC.C ===
/*
 ***************************************************************************
 *                                                                         *
 *  Copyright (C) 1995, 1998 NVidia Corporation.  All Rights Reserved.     *
 *                                                                         *
 ***************************************************************************
 */

/* NvDDEnable32() */

#include "windows.h"
#include <conio.h>
#include "nvd3ddrv.h"
#include "nv32.h"
#include "nvddobj.h"
#include "ddrvmem.h"
#include "d3dinc.h"

#ifdef  MULTI_MON
#include "nvrmapi.h"
#include "nvrmarch.inc"
#include "nvos.h"
#else   /* MULTI_MON */
#define NV_ERROR_NOTIFIER          0x0FF5
#endif  /* MULTI_MON */

#ifdef NVHEAPMGR
#ifdef MULTI_MON
static NVIOControl_Param HeapParams;
#else   // !MULTI_MON
static struct
{
  U032 function;
  U032 device;
  U032 owner;
  U032 type;
  U032 depth;
  U032 width;
  U032 height;
  S032 pitch;
  U032 offset;
  U032 size;
  U032 address;
  U032 limit;
  U032 total;
  U032 free;
  V032 status;
} HeapParams;
#endif  // !MULTI_MON
#endif  // NVHEAPMGR

/*
 * NvDDEnable32()
 *
 */

int
NvDDEnable32()
{
   NvNotification *npPioDmaToMemNotifier;
   NvNotification *npPioFlipOverlayNotifier;
   NvNotification *npDmaDmaToMemNotifier;
   NvNotification *npDmaDmaFromMemNotifier;
   NvNotification *npDmaFlipPrimaryNotifier;
   NvNotification *npDmaPusherSyncNotifier;
   NvNotification *npDmaSyncNotifier;
   FAST Nv4ControlDma *npDev;
   Nv3ChannelPio *npDevVideo;
   unsigned long temp;
   FAST long videoFreeCount;
   int pxlDepth;
   unsigned long *dmaPusherPutAddress =
       (unsigned long *)pDriverData->NvDmaPusherPutAddress;
   unsigned long *dmaPusherBufferBase =
       (unsigned long *)pDriverData->NvDmaPusherBufferBase;
   long freeCount;
   DWORD tmpIndex;

   npDev = (Nv4ControlDma *)pDriverData->NvDevFlatDma;

   pxlDepth = pDriverData->bi.biBitCount;

   /*
    * Allocate DMA notifiers and pixel/texel buffers
    *
    * Request 8 pages (NV_DD_COMMON_DMA_BUFFER_SIZE bytes) of memory.
    * Allows 2 buffers where 1 buffer can use
    * (NV_DD_COMMON_DMA_BUFFER_SIZE - (sizeof(NvNotification) << 4))/2 bytes
    * with up to 16 separate notifiers at the beginning of the buffer.
    *
    * Actual memory allocation done it 16 bit portion of driver.
    */

   pDriverData->NvDmaDmaToMemNotifierFlat = pDriverData->NvCommonDmaBufferFlat;

   pDriverData->NvDmaBufferNotifierFlat = pDriverData->NvCommonDmaBufferFlat;

   pDriverData->NvDmaDmaFromMemNotifierFlat = pDriverData->NvCommonDmaBufferFlat +
       (sizeof(NvNotification) << 1);

   pDriverData->NvDmaPusherSyncNotifierFlat = pDriverData->NvCommonDmaBufferFlat +
       (sizeof(NvNotification) << 1) + sizeof(NvNotification);

   pDriverData->NvDmaSyncNotifierFlat = pDriverData->NvCommonDmaBufferFlat +
       (sizeof(NvNotification) << 2);

   /* Notifier array offsets 5, 6, 7, 8, and 9 */
   pDriverData->NvDmaFlipPrimaryNotifierFlat = pDriverData->NvCommonDmaBufferFlat +
       (sizeof(NvNotification) << 2) + sizeof(NvNotification);

//   /* Notifier array offsets A, B, C, D, and E */
//   pDriverData->NvPioFlipOverlayNotifierFlat = pDriverData->NvCommonDmaBufferFlat +
//       (sizeof(NvNotification) << 3) + (sizeof(NvNotification) << 1);

   /* Notifier array offset (sizeof(NvNotification) << 3) + (sizeof(NvNotification) << 2) + (sizeof(NvNotification) << 1) + sizeof(NvNotification) currently unused */

   pDriverData->NvScanlineBufferFlat = pDriverData->NvCommonDmaBufferFlat +
       (sizeof(NvNotification) << 4);

   npDmaDmaToMemNotifier = (NvNotification *)pDriverData->NvDmaDmaToMemNotifierFlat;
   npDmaDmaFromMemNotifier = (NvNotification *)pDriverData->NvDmaDmaFromMemNotifierFlat;
   npDmaPusherSyncNotifier = (NvNotification *)pDriverData->NvDmaPusherSyncNotifierFlat;
   npDmaSyncNotifier = (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;
   npDmaFlipPrimaryNotifier = (NvNotification *)pDriverData->NvDmaFlipPrimaryNotifierFlat;

   /* Deal with possible mode change during pending flip */
   if (npDmaFlipPrimaryNotifier[1].status == NV_IN_PROGRESS) {
       long countDown = 0x200000;
       while ((npDmaFlipPrimaryNotifier[1].status == NV_IN_PROGRESS) && (--countDown > 0));
   }
   /* Deal with possible mode change during pending flip */
   if (npDmaFlipPrimaryNotifier[2].status == NV_IN_PROGRESS) {
       long countDown = 0x200000;
       while ((npDmaFlipPrimaryNotifier[2].status == NV_IN_PROGRESS) && (--countDown > 0));
   }

   /* MUST MAKE SURE STATUS FLAG IS CLEAR BEFORE INITIAL USE */

   npDmaDmaToMemNotifier->status = 0;

   npDmaDmaFromMemNotifier->status = 0;

   npDmaSyncNotifier->status = 0;

   npDmaFlipPrimaryNotifier[1].status = 0;
   npDmaFlipPrimaryNotifier[2].status = 0;


   /* First create some objects */

   freeCount = 0;

#ifndef MULTI_MON
   while (freeCount < 14)
       NvGetDmaBufferFreeCount(npDev, freeCount, 14, dmaPusherPutAddress);
   freeCount -= 14;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[1] = NV_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(0) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[3] = NV_DD_DMA_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[4] = dDrawSubchannelOffset(0) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[5] = NV_DD_DMA_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[6] = dDrawSubchannelOffset(0) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[7] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[8] = dDrawSubchannelOffset(0) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[9] = NV_DD_DMA_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[10] = dDrawSubchannelOffset(0) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[11] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[12] = dDrawSubchannelOffset(0) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[13] = NV_DD_DMA_CONTEXT_DMA_TO_SYSTEM_MEMORY;

   dmaPusherPutAddress += 14;

   while (freeCount < 12)
       NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
   freeCount -= 12;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(1) | 0x40000;
   dmaPusherPutAddress[1] = NV_CONTEXT_DMA_FROM_MEMORY;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(1) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[3] = NV_DD_DMA_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[4] = dDrawSubchannelOffset(1) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[5] = NV_DD_DMA_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[6] = dDrawSubchannelOffset(1) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[7] = NV_DD_DMA_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[8] = dDrawSubchannelOffset(1) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[9] = NV_DD_DMA_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[10] = dDrawSubchannelOffset(1) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[11] = NV_DD_DMA_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

   dmaPusherPutAddress += 12;

   while (freeCount < 4)
       NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
   freeCount -= 4;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(1) | 0x40000;
   dmaPusherPutAddress[1] = NV_CONTEXT_DMA_IN_MEMORY;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(1) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[3] = NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY;

   dmaPusherPutAddress += 4;

#endif  /* MULTI_MON */
   /*
    * Create ddraw objects.
    */
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_VIDEO_MEMORY_TO_SYSTEM_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT) != NVOS05_STATUS_SUCCESS)
        return(0);

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_CONTEXT_ROP, NV3_CONTEXT_ROP) != NVOS05_STATUS_SUCCESS)
        return(0);

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_CONTEXT_PATTERN, NV4_CONTEXT_PATTERN) != NVOS05_STATUS_SUCCESS)
        return(0);

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_IMAGE_BLACK_RECTANGLE, NV1_IMAGE_BLACK_RECTANGLE) != NVOS05_STATUS_SUCCESS)
    return(0);

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_CONTEXT_COLOR_KEY, NV4_CONTEXT_COLOR_KEY) != NVOS05_STATUS_SUCCESS)
        return(0);

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_BETA_SOLID, NV1_BETA_SOLID) != NVOS05_STATUS_SUCCESS)
        return(0);

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_CONTEXT_BETA4, NV4_CONTEXT_BETA) != NVOS05_STATUS_SUCCESS)
        return(0);

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_ROP_GDI_RECT_AND_TEXT, NV4_GDI_RECTANGLE_TEXT) != NVOS05_STATUS_SUCCESS)
        return(0);

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_ABLEND_RECT_AND_TEXT, NV4_GDI_RECTANGLE_TEXT) != NVOS05_STATUS_SUCCESS)
        return(0);

  if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_IMAGE_FROM_CPU, NV4_IMAGE_FROM_CPU) != NVOS05_STATUS_SUCCESS)
        return(0);

  if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_ALT_IMAGE_FROM_CPU, NV4_IMAGE_FROM_CPU) != NVOS05_STATUS_SUCCESS)
        return(0);

  if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_SRCCOPY_IMAGE_FROM_CPU, NV4_IMAGE_FROM_CPU) != NVOS05_STATUS_SUCCESS)
        return(0);

  if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_ABLEND_NOSRCALPHA_IMAGE_FROM_CPU, NV4_IMAGE_FROM_CPU) != NVOS05_STATUS_SUCCESS)
        return(0);

  if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_ABLEND_IMAGE_FROM_CPU, NV4_IMAGE_FROM_CPU) != NVOS05_STATUS_SUCCESS)
        return(0);

  if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_STRETCHED_UV_IMAGE_FROM_CPU, NV4_STRETCHED_IMAGE_FROM_CPU) != NVOS05_STATUS_SUCCESS)
        return(0);

  if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_STRETCHED_IMAGE_FROM_CPU, NV4_STRETCHED_IMAGE_FROM_CPU) != NVOS05_STATUS_SUCCESS)
        return(0);

  if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_SRCCOPY_STRETCHED_IMAGE_FROM_CPU, NV4_STRETCHED_IMAGE_FROM_CPU) != NVOS05_STATUS_SUCCESS)
        return(0);

  if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_ABLEND_NOSRCALPHA_STRETCHED_IMAGE_FROM_CPU, NV4_STRETCHED_IMAGE_FROM_CPU) != NVOS05_STATUS_SUCCESS)
        return(0);

  if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_ABLEND_STRETCHED_IMAGE_FROM_CPU, NV4_STRETCHED_IMAGE_FROM_CPU) != NVOS05_STATUS_SUCCESS)
        return(0);

   if (pxlDepth > 8) {

        if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                return(0);

        if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                return(0);

        if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                return(0);

        if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                return(0);

        if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                return(0);

        if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                return(0);

        if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                return(0);

        if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                return(0);

        if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                return(0);

        if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                return(0);

        if (pxlDepth > 16) {
            if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
                NV_DD_SRCCOPY_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                    return(0);
            if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
                NV_DD_ABLEND_NOSRCALPHA_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                    return(0);
            if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
                NV_DD_ABLEND_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                    return(0);
            if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
                NV_DD_SRCCOPY_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                    return(0);
            if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
                NV_DD_ABLEND_NOSRCALPHA_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                    return(0);
            if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
                NV_DD_ABLEND_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                    return(0);
       }
   }

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_IMAGE_BLIT, NV4_IMAGE_BLIT) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_SRCCOPY_IMAGE_BLIT, NV4_IMAGE_BLIT) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_SURFACES_2D, NV4_CONTEXT_SURFACES_2D) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_PRIMARY_VIDEO_FROM_MEMORY, NV_VIDEO_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
        return(0);

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY, NV_PATCHCORD_VIDEO) != NVOS05_STATUS_SUCCESS)
        return(0);

   if (pxlDepth == 8) {
    if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_P_V_SHARED_VIDEO_COLORMAP, NV_PATCHCORD_VIDEO) != NVOS05_STATUS_SUCCESS)
            return(0);
    }

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_VIDEO_MEMORY_U_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_VIDEO_MEMORY_V_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_VIDEO_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_VIDEO_SINK, NV_VIDEO_SINK) != NVOS05_STATUS_SUCCESS)
        return(0);

   if (pxlDepth == 8) {

      if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_SHARED_VIDEO_COLORMAP, NV_VIDEO_COLORMAP) != NVOS05_STATUS_SUCCESS)
            return(0);
   }
#ifdef WINNT
   /*
    * Create NV4 DVD subpicture object in both DMA Push and PIO
    * channels. Don't know why the creation of these objects was
    * not in the common code.
    */
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_DVD_SUBPICTURE, NV04_DVD_SUBPICTURE) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
    NV_DD_DVD_SUBPICTURE, NV04_DVD_SUBPICTURE) != NVOS05_STATUS_SUCCESS)
        return(0);
#endif // WINNT

    /*
     * Create D3D objects.
     */

    /*
     * Create the DX5 Textured Triangle.
     */
    if (pDriverData->ppdev->flCaps & (CAPS_NV10_IS_PRESENT | CAPS_NV10ULTRA_IS_PRESENT | CAPS_NV10GL_IS_PRESENT))
        {
        if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            D3D_DX5_TEXTURED_TRIANGLE, NV10_DX5_TEXTURED_TRIANGLE) != NVOS05_STATUS_SUCCESS)
                return(0);
        }
    else
        if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            D3D_DX5_TEXTURED_TRIANGLE, NV04_DX5_TEXTURED_TRIANGLE) != NVOS05_STATUS_SUCCESS)
                return(0);

    /*
     * Create the DX6 Textured Triangle.
     */
        if (pDriverData->ppdev->flCaps & (CAPS_NV10_IS_PRESENT | CAPS_NV10ULTRA_IS_PRESENT | CAPS_NV10GL_IS_PRESENT))
            {
            if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
                D3D_DX6_MULTI_TEXTURE_TRIANGLE, NV10_DX6_MULTI_TEXTURE_TRIANGLE) != NVOS05_STATUS_SUCCESS)
                    return(0);
            }
        else
            if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
                D3D_DX6_MULTI_TEXTURE_TRIANGLE, NV04_DX6_MULTI_TEXTURE_TRIANGLE) != NVOS05_STATUS_SUCCESS)
                    return(0);

    /*
     * Create the ARGB_ZS surface context.
     */
    if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        D3D_CONTEXT_SURFACES_ARGB_ZS, NV04_CONTEXT_SURFACES_ARGB_ZS) != NVOS05_STATUS_SUCCESS)
            return(0);

    /*
     * Create the swizzled surface context.
     */
    if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        D3D_CONTEXT_SURFACE_SWIZZLED, NV04_CONTEXT_SURFACE_SWIZZLED) != NVOS05_STATUS_SUCCESS)
            return(0);


    /*
     * Create Scaled Image From Memory object for texture swizzling.
     */
    if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        D3D_SCALED_IMAGE_FROM_MEMORY, NV04_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
            return(0);

    /*
     * Create Render Solid Rectangle for clearing the z-buffer and rendering surfaces.
     */
    if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        D3D_RENDER_SOLID_RECTANGLE, NV4_RENDER_SOLID_RECTANGLE) != NVOS05_STATUS_SUCCESS)
            return(0);
    if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        D3D_RENDER_SOLID_RECTANGLE_2, NV4_RENDER_SOLID_RECTANGLE) != NVOS05_STATUS_SUCCESS)
            return(0);

    /*
     * Create Video objects.
     */

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
    NV_DD_PRIMARY_VIDEO_FROM_MEMORY, NV_VIDEO_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
    NV_DD_YUV422_VIDEO_FROM_MEMORY, NV_VIDEO_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
        return(0);

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
    NV_DD_VIDEO_COLOR_KEY, NV_VIDEO_COLOR_KEY) != NVOS05_STATUS_SUCCESS)
        return(0);

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
    NV_DD_VIDEO_SCALER, NV_VIDEO_SCALER) != NVOS05_STATUS_SUCCESS)
        return(0);

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
    NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY, NV_PATCHCORD_VIDEO) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
    NV_DD_P_V_YUV422_VIDEO_FROM_MEMORY, NV_PATCHCORD_VIDEO) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
    NV_DD_P_V_VIDEO_SCALER, NV_PATCHCORD_VIDEO) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
    NV_DD_P_V_VIDEO_COLOR_KEY, NV_PATCHCORD_VIDEO) != NVOS05_STATUS_SUCCESS)
        return(0);

   if (pxlDepth == 8) {
    if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
        NV_DD_P_V_SHARED_VIDEO_COLORMAP, NV_PATCHCORD_VIDEO) != NVOS05_STATUS_SUCCESS)
            return(0);

       if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
        NV_DD_SHARED_VIDEO_COLORMAP, NV_VIDEO_COLORMAP) != NVOS05_STATUS_SUCCESS)
            return(0);
   }


#ifdef MULTI_MON

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
        NV_DD_VIDEO_SINK, NV_VIDEO_SINK) != NVOS05_STATUS_SUCCESS)
            return(0);




   /*
    * Start patching things together (from bottom to top of patch)
    *    and otherwise initializing objects
    */

#ifdef MULTI_MON

   /* Free any existing dynamic context dma objects */
   if (pDriverData->dwVidMemCtxDmaSize != 0) {

       NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
       NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY);
       NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY);

       pDriverData->dwVidMemCtxDmaSize = 0;
   }

   /* Allocate our video memory context dmas */

   pDriverData->dwVidMemCtxDmaSize =
       (unsigned long)(pDriverData->VideoHeapEnd - pDriverData->BaseAddress);
   pDriverData->dwVidMemCtxDmaSize += 4096; /* Make sure to include permanently allocated video memory page */
#ifndef WINNT
   if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                       NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY,
                       NV01_CONTEXT_DMA,
                       (ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR |
                        ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                       (PVOID)pDriverData->BaseAddress,
                       pDriverData->dwVidMemCtxDmaSize) != ALLOC_CTX_DMA_STATUS_SUCCESS)
                            return(FALSE);

   if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                       NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY,
                       NV01_CONTEXT_DMA,
                       (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                        ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                       (PVOID)pDriverData->BaseAddress,
                       pDriverData->dwVidMemCtxDmaSize) != ALLOC_CTX_DMA_STATUS_SUCCESS)
                            return(FALSE);

   if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                       NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY,
                       NV01_CONTEXT_DMA,
                       (ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY |
                        ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                       (PVOID)pDriverData->BaseAddress,
                       pDriverData->dwVidMemCtxDmaSize) != ALLOC_CTX_DMA_STATUS_SUCCESS)
                            return(FALSE);
#else
   if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                       NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY,
                       NV01_CONTEXT_DMA,
                       (ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR |
                        ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                       (PVOID)pDriverData->ppdev->pjScreen,
                       pDriverData->dwVidMemCtxDmaSize) != ALLOC_CTX_DMA_STATUS_SUCCESS)
                            return(FALSE);

   if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                       NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY,
                       NV01_CONTEXT_DMA,
                       (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                        ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                       (PVOID)pDriverData->ppdev->pjScreen,
                       pDriverData->dwVidMemCtxDmaSize) != ALLOC_CTX_DMA_STATUS_SUCCESS)
                            return(FALSE);

   if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                       NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY,
                       NV01_CONTEXT_DMA,
                       (ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY |
                        ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                       (PVOID)pDriverData->ppdev->pjScreen,
                       pDriverData->dwVidMemCtxDmaSize) != ALLOC_CTX_DMA_STATUS_SUCCESS)
                            return(FALSE);
#endif // #ifdef WINNT

   if (pxlDepth == 8) {

       while (freeCount < 5)
           NvGetDmaBufferFreeCount(npDev, freeCount, 5, dmaPusherPutAddress);
       freeCount -= 5;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(3) | 0x40000;
       dmaPusherPutAddress[1] = NV_DD_SHARED_VIDEO_COLORMAP;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(3) + NVFF9_SET_VIDEO_OUTPUT | 0x80000;
       dmaPusherPutAddress[3] = NV_DD_P_V_SHARED_VIDEO_COLORMAP;
       dmaPusherPutAddress[4] = NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY;

       dmaPusherPutAddress += 5;
   }

   while (freeCount < 4)
       NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
   freeCount -= 4;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(5) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_VIDEO_SINK;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(5) + NVFFA_SET_VIDEO_INPUT | 0x40000;

   if (pxlDepth == 8)
       dmaPusherPutAddress[3] = NV_DD_P_V_SHARED_VIDEO_COLORMAP;
   else
       dmaPusherPutAddress[3] = NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY;

   dmaPusherPutAddress += 4;

   while (freeCount < 16)
       NvGetDmaBufferFreeCount(npDev, freeCount, 16, dmaPusherPutAddress);
   freeCount -= 16;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(4) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(4) +
       NV039_SET_CONTEXT_DMA_NOTIFIES | 0x40000;
   dmaPusherPutAddress[3] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

   dmaPusherPutAddress[4] = dDrawSubchannelOffset(5) | 0x40000;
   dmaPusherPutAddress[5] = NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT;
   dmaPusherPutAddress[6] = dDrawSubchannelOffset(5) +
       NV039_SET_CONTEXT_DMA_NOTIFIES | 0x40000;
   dmaPusherPutAddress[7] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

   dmaPusherPutAddress[8] = dDrawSubchannelOffset(6) | 0x40000;
   dmaPusherPutAddress[9] = NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT;
   dmaPusherPutAddress[10] = dDrawSubchannelOffset(6) +
       NV039_SET_CONTEXT_DMA_NOTIFIES | 0x40000;
   dmaPusherPutAddress[11] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

   dmaPusherPutAddress[12] = dDrawSubchannelOffset(7) | 0x40000;
   dmaPusherPutAddress[13] = NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT;
   dmaPusherPutAddress[14] = dDrawSubchannelOffset(7) +
       NV039_SET_CONTEXT_DMA_NOTIFIES | 0x40000;
   dmaPusherPutAddress[15] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

   dmaPusherPutAddress += 16;

#else   /* MULTI_MON */

   while (freeCount < 30)
       NvGetDmaBufferFreeCount(npDev, freeCount, 30, dmaPusherPutAddress);
   freeCount -= 30;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_DMA_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(0) + NVFFD_SET_DMA_SPECIFIER | 0xC0000;
   dmaPusherPutAddress[3] = (unsigned long)npDmaDmaToMemNotifier;
   dmaPusherPutAddress[4] = (unsigned long)pDriverData->flatSelector;
   dmaPusherPutAddress[5] = (sizeof(NvNotification) - 1);

   dmaPusherPutAddress[6] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[7] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[8] = dDrawSubchannelOffset(0) + NVFFD_SET_DMA_SPECIFIER | 0xC0000;
   dmaPusherPutAddress[9] = (unsigned long)npDmaDmaToMemNotifier;
   dmaPusherPutAddress[10] = (unsigned long)pDriverData->flatSelector;
   dmaPusherPutAddress[11] = ((2 * sizeof(NvNotification)) - 1);

   dmaPusherPutAddress[12] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[13] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[14] = dDrawSubchannelOffset(0) + NVFFD_SET_DMA_SPECIFIER | 0xC0000;
   dmaPusherPutAddress[15] =
       ((unsigned long)npDmaDmaToMemNotifier + (sizeof(NvNotification) << 1));
   dmaPusherPutAddress[16] = (unsigned long)pDriverData->flatSelector;
   dmaPusherPutAddress[17] = (sizeof(NvNotification) - 1);

   dmaPusherPutAddress[18] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[19] = NV_DD_DMA_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[20] = dDrawSubchannelOffset(0) + NVFFD_SET_DMA_SPECIFIER | 0xC0000;
   dmaPusherPutAddress[21] =
       ((unsigned long)npDmaDmaToMemNotifier + (sizeof(NvNotification) << 2));
   dmaPusherPutAddress[22] = (unsigned long)pDriverData->flatSelector;
   dmaPusherPutAddress[23] = (sizeof(NvNotification) - 1);

   dmaPusherPutAddress[24] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[25] = NV_DD_DMA_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[26] = dDrawSubchannelOffset(0) + NVFFD_SET_DMA_SPECIFIER | 0xC0000;
   dmaPusherPutAddress[27] =
       ((unsigned long)npDmaDmaToMemNotifier + (sizeof(NvNotification) << 2) +
       sizeof(NvNotification));
   dmaPusherPutAddress[28] = (unsigned long)pDriverData->flatSelector;
   dmaPusherPutAddress[29] = ((5 * sizeof(NvNotification)) - 1);

   dmaPusherPutAddress += 30;

   while (freeCount < 12)
       NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
   freeCount -= 12;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_DMA_CONTEXT_DMA_TO_SYSTEM_MEMORY;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(0) + NVFFD_SET_DMA_SPECIFIER | 0xC0000;
   dmaPusherPutAddress[3] = (unsigned long)npDmaDmaToMemNotifier;
   dmaPusherPutAddress[4] = (unsigned long)pDriverData->flatSelector;
   dmaPusherPutAddress[5] = (NV_DD_COMMON_DMA_BUFFER_SIZE - 1);

   dmaPusherPutAddress[6] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[7] = NV_DD_DMA_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[8] = dDrawSubchannelOffset(0) + NVFFD_SET_DMA_SPECIFIER | 0xC0000;
   dmaPusherPutAddress[9] = (unsigned long)npDmaDmaToMemNotifier;
   dmaPusherPutAddress[10] = (unsigned long)pDriverData->flatSelector;
   dmaPusherPutAddress[11] = (NV_DD_COMMON_DMA_BUFFER_SIZE - 1);

   dmaPusherPutAddress += 12;

   while (freeCount < 4)
       NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
   freeCount -= 4;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(1) | 0x40000;
   dmaPusherPutAddress[1] = NV_VIDEO_SINK;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(1) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[3] = NV_DD_VIDEO_SINK;

   dmaPusherPutAddress += 4;

   if (pxlDepth == 8) {

       while (freeCount < 9)
           NvGetDmaBufferFreeCount(npDev, freeCount, 9, dmaPusherPutAddress);
       freeCount -= 9;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(2) | 0x40000;
       dmaPusherPutAddress[1] = NV_VIDEO_COLORMAP;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(2) + NVFFF_CREATE_OFFSET | 0x40000;
       dmaPusherPutAddress[3] = NV_DD_SHARED_VIDEO_COLORMAP;
       dmaPusherPutAddress[4] = dDrawSubchannelOffset(3) | 0x40000;
       dmaPusherPutAddress[5] = NV_DD_SHARED_VIDEO_COLORMAP;
       dmaPusherPutAddress[6] = dDrawSubchannelOffset(3) + NVFF9_SET_VIDEO_OUTPUT | 0x80000;
       dmaPusherPutAddress[7] = NV_DD_P_V_SHARED_VIDEO_COLORMAP;
       dmaPusherPutAddress[8] = NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY;

       dmaPusherPutAddress += 9;
   }

   while (freeCount < 12)
       NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
   freeCount -= 12;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[1] = NV_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(0) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[3] = NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY;

   dmaPusherPutAddress[4] = dDrawSubchannelOffset(1) | 0x40000;
   dmaPusherPutAddress[5] = NV_CONTEXT_DMA_FROM_MEMORY;
   dmaPusherPutAddress[6] = dDrawSubchannelOffset(1) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[7] = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;

   dmaPusherPutAddress[8] = dDrawSubchannelOffset(2) | 0x40000;
   dmaPusherPutAddress[9] = NV_CONTEXT_DMA_FROM_MEMORY;
   dmaPusherPutAddress[10] = dDrawSubchannelOffset(2) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[11] = NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

   dmaPusherPutAddress += 12;


   while (freeCount < 12)
       NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
   freeCount -= 12;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(3) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(3) + NVFFD_SET_DMA_SPECIFIER | 0xC0000;
   dmaPusherPutAddress[3] = (unsigned long)pDriverData->BaseAddress;
   dmaPusherPutAddress[4] = (unsigned long)pDriverData->flatSelector;
   dmaPusherPutAddress[5] =
       (unsigned long)(pDriverData->VideoHeapEnd - pDriverData->BaseAddress);

   dmaPusherPutAddress[6] = dDrawSubchannelOffset(4) | 0x40000;
   dmaPusherPutAddress[7] = NV_ERROR_NOTIFIER;
   dmaPusherPutAddress[8] = dDrawSubchannelOffset(4) + NVFFD_SET_DMA_SPECIFIER | 0xC0000;
   dmaPusherPutAddress[9] = (unsigned long)pDriverData->NvDmaBufferNotifierFlat;
   dmaPusherPutAddress[10] = (unsigned long)pDriverData->flatSelector;
   dmaPusherPutAddress[11] =
       (NV_DD_COMMON_DMA_BUFFER_SIZE - (sizeof(NvNotification) << 2) -
       (sizeof(NvNotification) << 1) - 1);

   dmaPusherPutAddress += 12;

   while (freeCount < 4)
       NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
   freeCount -= 4;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(5) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_VIDEO_SINK;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(5) + NVFFA_SET_VIDEO_INPUT | 0x40000;

   if (pxlDepth == 8)
       dmaPusherPutAddress[3] = NV_DD_P_V_SHARED_VIDEO_COLORMAP;
   else
       dmaPusherPutAddress[3] = NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY;

   dmaPusherPutAddress += 4;

   while (freeCount < 12)
       NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
   freeCount -= 12;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(6) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(6) + NVFFD_SET_DMA_SPECIFIER | 0xC0000;
   dmaPusherPutAddress[3] = (unsigned long)pDriverData->BaseAddress;
   dmaPusherPutAddress[4] = (unsigned long)pDriverData->flatSelector;
   dmaPusherPutAddress[5] =
       (unsigned long)(pDriverData->VideoHeapEnd - pDriverData->BaseAddress);

   dmaPusherPutAddress[6] = dDrawSubchannelOffset(7) | 0x40000;
   dmaPusherPutAddress[7] = NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY;
   dmaPusherPutAddress[8] = dDrawSubchannelOffset(7) + NVFFD_SET_DMA_SPECIFIER | 0xC0000;
   dmaPusherPutAddress[9] = (unsigned long)pDriverData->BaseAddress;
   dmaPusherPutAddress[10] = (unsigned long)pDriverData->flatSelector;
   dmaPusherPutAddress[11] =
       (unsigned long)pDriverData->VideoHeapEnd - pDriverData->BaseAddress;

   dmaPusherPutAddress += 12;

   while (freeCount < 20)
       NvGetDmaBufferFreeCount(npDev, freeCount, 20, dmaPusherPutAddress);
   freeCount -= 20;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(0) + NVFFD_SET_CONTEXT_DMA_NOTIFIES | 0x40000;
   dmaPusherPutAddress[3] = NV_DD_DMA_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

   dmaPusherPutAddress[4] = dDrawSubchannelOffset(1) | 0x40000;
   dmaPusherPutAddress[5] = NV_DD_DMA_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[6] = dDrawSubchannelOffset(1) + NVFFD_SET_CONTEXT_DMA_NOTIFIES | 0x40000;
   dmaPusherPutAddress[7] = NV_DD_DMA_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

   dmaPusherPutAddress[8] = dDrawSubchannelOffset(2) | 0x40000;
   dmaPusherPutAddress[9] = NV_DD_DMA_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[10] = dDrawSubchannelOffset(2) + NVFFD_SET_CONTEXT_DMA_NOTIFIES | 0x40000;
   dmaPusherPutAddress[11] = NV_DD_DMA_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

   dmaPusherPutAddress[12] = dDrawSubchannelOffset(3) | 0x40000;
   dmaPusherPutAddress[13] = NV_DD_DMA_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[14] = dDrawSubchannelOffset(3) + NVFFD_SET_CONTEXT_DMA_NOTIFIES | 0x40000;
   dmaPusherPutAddress[15] = NV_DD_DMA_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

   dmaPusherPutAddress[16] = dDrawSubchannelOffset(4) | 0x40000;
   dmaPusherPutAddress[17] = NV_DD_DMA_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[18] = dDrawSubchannelOffset(4) + NVFFD_SET_CONTEXT_DMA_NOTIFIES | 0x40000;
   dmaPusherPutAddress[19] = NV_DD_DMA_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

   dmaPusherPutAddress += 20;

   while (freeCount < 12)
       NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
   freeCount -= 12;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(4) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(4) +
       NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000;
   dmaPusherPutAddress[3] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[4] = NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[5] = NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY;

   dmaPusherPutAddress[6] = dDrawSubchannelOffset(5) | 0x40000;
   dmaPusherPutAddress[7] = NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT;
   dmaPusherPutAddress[8] = dDrawSubchannelOffset(5) +
       NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000;
   dmaPusherPutAddress[9] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[10] = NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[11] = NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY;

   dmaPusherPutAddress += 12;

   while (freeCount < 12)
       NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
   freeCount -= 12;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(6) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(6) +
       NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000;
   dmaPusherPutAddress[3] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[4] = NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[5] = NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY;

   dmaPusherPutAddress[6] = dDrawSubchannelOffset(7) | 0x40000;
   dmaPusherPutAddress[7] = NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT;
   dmaPusherPutAddress[8] = dDrawSubchannelOffset(7) +
       NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000;
   dmaPusherPutAddress[9] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[10] = NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[11] = NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY;

   dmaPusherPutAddress += 12;

#endif  /* MULTI_MON */

   while (freeCount < 24)
       NvGetDmaBufferFreeCount(npDev, freeCount, 24, dmaPusherPutAddress);
   freeCount -= 24;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(0) +
       NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000;
   dmaPusherPutAddress[3] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[4] = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;
   dmaPusherPutAddress[5] = NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY;

   dmaPusherPutAddress[6] = dDrawSubchannelOffset(1) | 0x40000;
   dmaPusherPutAddress[7] = NV_DD_VIDEO_MEMORY_U_TO_VIDEO_MEMORY_FORMAT;
   dmaPusherPutAddress[8] = dDrawSubchannelOffset(1) +
       NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000;
   dmaPusherPutAddress[9] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[10] = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;
   dmaPusherPutAddress[11] = NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY;

   dmaPusherPutAddress[12] = dDrawSubchannelOffset(2) | 0x40000;
   dmaPusherPutAddress[13] = NV_DD_VIDEO_MEMORY_V_TO_VIDEO_MEMORY_FORMAT;
   dmaPusherPutAddress[14] = dDrawSubchannelOffset(2) +
       NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000;
   dmaPusherPutAddress[15] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[16] = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;
   dmaPusherPutAddress[17] = NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY;

   dmaPusherPutAddress[18] = dDrawSubchannelOffset(3) | 0x40000;
   dmaPusherPutAddress[19] = NV_DD_VIDEO_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT;
   dmaPusherPutAddress[20] = dDrawSubchannelOffset(3) +
       NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000;
   dmaPusherPutAddress[21] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[22] = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;
   dmaPusherPutAddress[23] = NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY;

   dmaPusherPutAddress += 24;

   while (freeCount < 19)
       NvGetDmaBufferFreeCount(npDev, freeCount, 19, dmaPusherPutAddress);
   freeCount -= 19;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(7) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_PRIMARY_VIDEO_FROM_MEMORY;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(7) +
       NVFF8_SET_VIDEO_OUTPUT | 0x40000;
   dmaPusherPutAddress[3] = NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY;
   dmaPusherPutAddress[4] = dDrawSubchannelOffset(7) +
       NVFF8_SET_CONTEXT_DMA_NOTIFIES | 0xC0000;
   dmaPusherPutAddress[5] = NV_DD_DMA_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[6] = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;
   dmaPusherPutAddress[7] = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;
   dmaPusherPutAddress[8] = dDrawSubchannelOffset(7) +
       NVFF8_IMAGE_SCAN_OFFSET | 0x280000;
   dmaPusherPutAddress[9] = 0;
   dmaPusherPutAddress[10] = pDriverData->HALInfo.vmiData.lDisplayPitch;
   dmaPusherPutAddress[11] =
       asmMergeCoords(pDriverData->bi.biWidth, pDriverData->bi.biHeight);

   if (pxlDepth == 8)
       dmaPusherPutAddress[12] = NV_VFM_FORMAT_COLOR_LE_Y8_P4;
   else if (pxlDepth == 16)
       dmaPusherPutAddress[12] = NV_VFM_FORMAT_COLOR_LE_R5G6B5_P2;
   else
       dmaPusherPutAddress[12] = NV_VFM_FORMAT_COLOR_LE_X8R8G8B8;

   dmaPusherPutAddress[13] = 0;

   dmaPusherPutAddress[14] = 0;
   dmaPusherPutAddress[15] = pDriverData->HALInfo.vmiData.lDisplayPitch;
   dmaPusherPutAddress[16] =
       asmMergeCoords(pDriverData->bi.biWidth, pDriverData->bi.biHeight);

   if (pxlDepth == 8)
       dmaPusherPutAddress[17] = NV_VFM_FORMAT_COLOR_LE_Y8_P4;
   else if (pxlDepth == 16)
       dmaPusherPutAddress[17] = NV_VFM_FORMAT_COLOR_LE_R5G6B5_P2;
   else
       dmaPusherPutAddress[17] = NV_VFM_FORMAT_COLOR_LE_X8R8G8B8;

   dmaPusherPutAddress[18] = 0;

   dmaPusherPutAddress += 19;

   /*
    * Connect buffer patch objects
    */


   while (freeCount < 11)
       NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
   freeCount -= 11;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(2) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_SURFACES_2D;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(2) +
       NV042_SET_COLOR_FORMAT | 0x40000;

   if (pxlDepth == 8)
       dmaPusherPutAddress[3] = NV042_SET_COLOR_FORMAT_LE_Y8;
   else if (pxlDepth == 16)
       dmaPusherPutAddress[3] = NV042_SET_COLOR_FORMAT_LE_R5G6B5;
   else
       dmaPusherPutAddress[3] = NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;

   dmaPusherPutAddress[4] = dDrawSubchannelOffset(2) +
       NV042_SET_CONTEXT_DMA_IMAGE_SOURCE | 0x80000;
   dmaPusherPutAddress[5] = NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY;
   dmaPusherPutAddress[6] = NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY;
   dmaPusherPutAddress[7] = dDrawSubchannelOffset(2) +
       NV042_SET_PITCH | 0xC0000;
   dmaPusherPutAddress[8] =
       (pDriverData->HALInfo.vmiData.lDisplayPitch << 16) |
        pDriverData->HALInfo.vmiData.lDisplayPitch;
   dmaPusherPutAddress[9] = 0;
   dmaPusherPutAddress[10] = 0;

   dmaPusherPutAddress += 11;

   while (freeCount < 11)
       NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
   freeCount -= 11;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_IMAGE_BLIT;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(0) +
       NV05F_SET_CONTEXT_COLOR_KEY | 0x40000;
   dmaPusherPutAddress[3] = NV_DD_CONTEXT_COLOR_KEY;
//       NV_DD_IMAGE_BLACK_RECTANGLE;  // messes up D3D surface clip
   dmaPusherPutAddress[4] = dDrawSubchannelOffset(0) +
       NV05F_SET_CONTEXT_PATTERN | 0x80000;
   dmaPusherPutAddress[5] = NV_DD_CONTEXT_PATTERN;
   dmaPusherPutAddress[6] = NV_DD_CONTEXT_ROP;
   dmaPusherPutAddress[7] = dDrawSubchannelOffset(0) +
       NV05F_SET_OPERATION | 0x40000;
   dmaPusherPutAddress[8] = NV05F_SET_OPERATION_ROP_AND;
   dmaPusherPutAddress[9] = dDrawSubchannelOffset(0) +
       NV05F_SET_CONTEXT_SURFACES | 0x40000;
   dmaPusherPutAddress[10] = NV_DD_SURFACES_2D;

   dmaPusherPutAddress += 11;

   while (freeCount < 6)
       NvGetDmaBufferFreeCount(npDev, freeCount, 6, dmaPusherPutAddress);
   freeCount -= 6;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_SRCCOPY_IMAGE_BLIT;
//   dmaPusherPutAddress[2] = dDrawSubchannelOffset(0) +
//       NV05F_SET_CONTEXT_COLOR_KEY | 0x40000;   // destination alpha not supported if context color key set
//   dmaPusherPutAddress[3] = NV_DD_CONTEXT_COLOR_KEY;
//       NV_DD_IMAGE_BLACK_RECTANGLE;  // messes up D3D surface clip
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(0) +
       NV05F_SET_OPERATION | 0x40000;
   dmaPusherPutAddress[3] = NV05F_SET_OPERATION_SRCCOPY;
   dmaPusherPutAddress[4] = dDrawSubchannelOffset(0) +
       NV05F_SET_CONTEXT_SURFACES | 0x40000;
   dmaPusherPutAddress[5] = NV_DD_SURFACES_2D;

   dmaPusherPutAddress += 6;

   while (freeCount < 11)
       NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
   freeCount -= 11;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(1) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_STRETCHED_UV_IMAGE_FROM_CPU;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(1) +
       NV076_SET_CONTEXT_PATTERN | 0x80000;
   dmaPusherPutAddress[3] = NV_DD_CONTEXT_PATTERN;
   dmaPusherPutAddress[4] = NV_DD_CONTEXT_ROP;
   dmaPusherPutAddress[5] = dDrawSubchannelOffset(1) +
       NV076_SET_OPERATION | 0x40000;
   dmaPusherPutAddress[6] = NV076_SET_OPERATION_ROP_AND;
   dmaPusherPutAddress[7] = dDrawSubchannelOffset(1) +
       NV076_SET_CONTEXT_SURFACE | 0x40000;
   dmaPusherPutAddress[8] = NV_DD_SURFACES_2D;
   dmaPusherPutAddress[9] = dDrawSubchannelOffset(1) +
       NV076_SET_COLOR_FORMAT | 0x40000;
   /* A8Y8 color format assumed by hardware when destination surface in 8bpp mode */
   /* Must be set to a legal value but hardware ignores it otherwise */
   dmaPusherPutAddress[10] = NV076_SET_COLOR_FORMAT_LE_X8R8G8B8;

   dmaPusherPutAddress += 11;

   if (pxlDepth == 8) {

       while (freeCount < 13)
           NvGetDmaBufferFreeCount(npDev, freeCount, 13, dmaPusherPutAddress);
       freeCount -= 13;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(0) | 0x40000;
       dmaPusherPutAddress[1] = NV_DD_STRETCHED_IMAGE_FROM_CPU;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(0) +
           NV076_SET_CONTEXT_COLOR_KEY | 0x40000;
       dmaPusherPutAddress[3] = NV_DD_CONTEXT_COLOR_KEY;
       dmaPusherPutAddress[4] = dDrawSubchannelOffset(0) +
           NV076_SET_CONTEXT_PATTERN | 0x80000;
       dmaPusherPutAddress[5] = NV_DD_CONTEXT_PATTERN;
       dmaPusherPutAddress[6] = NV_DD_CONTEXT_ROP;
       dmaPusherPutAddress[7] = dDrawSubchannelOffset(0) +
           NV076_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[8] = NV076_SET_OPERATION_ROP_AND;
       dmaPusherPutAddress[9] = dDrawSubchannelOffset(0) +
           NV076_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[10] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[11] = dDrawSubchannelOffset(0) +
           NV076_SET_COLOR_FORMAT | 0x40000;
       /* A8Y8 color format assumed by hardware when destination surface in 8bpp mode */
       /* Must be set to a legal value but hardware ignores it otherwise */
       dmaPusherPutAddress[12] = NV076_SET_COLOR_FORMAT_LE_X8R8G8B8;

       dmaPusherPutAddress += 13;

   } else {

       while (freeCount < 13)
           NvGetDmaBufferFreeCount(npDev, freeCount, 13, dmaPusherPutAddress);
       freeCount -= 13;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(0) | 0x40000;
       dmaPusherPutAddress[1] = NV_DD_STRETCHED_IMAGE_FROM_CPU;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(0) +
           NV076_SET_CONTEXT_COLOR_KEY | 0x40000;
       dmaPusherPutAddress[3] = NV_DD_CONTEXT_COLOR_KEY;
       dmaPusherPutAddress[4] = dDrawSubchannelOffset(0) +
           NV076_SET_CONTEXT_PATTERN | 0x80000;
       dmaPusherPutAddress[5] = NV_DD_CONTEXT_PATTERN;
       dmaPusherPutAddress[6] = NV_DD_CONTEXT_ROP;
       dmaPusherPutAddress[7] = dDrawSubchannelOffset(0) +
           NV076_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[8] = NV076_SET_OPERATION_ROP_AND;
       dmaPusherPutAddress[9] = dDrawSubchannelOffset(0) +
           NV076_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[10] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[11] = dDrawSubchannelOffset(0) +
           NV076_SET_COLOR_FORMAT | 0x40000;
       if (pxlDepth == 16)
           dmaPusherPutAddress[12] = NV076_SET_COLOR_FORMAT_LE_R5G6B5;
       else
           dmaPusherPutAddress[12] = NV076_SET_COLOR_FORMAT_LE_X8R8G8B8;

       dmaPusherPutAddress += 13;


       if (pxlDepth > 16) {

           while (freeCount < 10)
               NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
           freeCount -= 10;

           dmaPusherPutAddress[0] = dDrawSubchannelOffset(1) | 0x40000;
           dmaPusherPutAddress[1] = NV_DD_SRCCOPY_STRETCHED_IMAGE_FROM_CPU;
           dmaPusherPutAddress[2] = dDrawSubchannelOffset(1) +
               NV076_SET_CONTEXT_COLOR_KEY | 0x40000;
           dmaPusherPutAddress[3] = NV_DD_CONTEXT_COLOR_KEY;
           dmaPusherPutAddress[4] = dDrawSubchannelOffset(1) +
               NV076_SET_OPERATION | 0x40000;
           dmaPusherPutAddress[5] = NV076_SET_OPERATION_SRCCOPY;
           dmaPusherPutAddress[6] = dDrawSubchannelOffset(1) +
               NV076_SET_CONTEXT_SURFACE | 0x40000;
           dmaPusherPutAddress[7] = NV_DD_SURFACES_2D;
           dmaPusherPutAddress[8] = dDrawSubchannelOffset(1) +
               NV076_SET_COLOR_FORMAT | 0x40000;
           dmaPusherPutAddress[9] = NV076_SET_COLOR_FORMAT_LE_A8R8G8B8;

           dmaPusherPutAddress += 10;

           while (freeCount < 12)
               NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
           freeCount -= 12;

           dmaPusherPutAddress[0] = dDrawSubchannelOffset(2) | 0x40000;
           dmaPusherPutAddress[1] = NV_DD_ABLEND_NOSRCALPHA_STRETCHED_IMAGE_FROM_CPU;
           dmaPusherPutAddress[2] = dDrawSubchannelOffset(2) +
               NV076_SET_CONTEXT_COLOR_KEY | 0x40000;
           dmaPusherPutAddress[3] = NV_DD_CONTEXT_COLOR_KEY;
           dmaPusherPutAddress[4] = dDrawSubchannelOffset(2) +
               NV076_SET_OPERATION | 0x40000;
           dmaPusherPutAddress[5] = NV076_SET_OPERATION_BLEND_PREMULT;
           dmaPusherPutAddress[6] = dDrawSubchannelOffset(2) +
               NV076_SET_CONTEXT_BETA4 | 0x40000;
           dmaPusherPutAddress[7] = NV_DD_CONTEXT_BETA4;
           dmaPusherPutAddress[8] = dDrawSubchannelOffset(2) +
               NV076_SET_CONTEXT_SURFACE | 0x40000;
           dmaPusherPutAddress[9] = NV_DD_SURFACES_2D;
           dmaPusherPutAddress[10] = dDrawSubchannelOffset(2) +
               NV076_SET_COLOR_FORMAT | 0x40000;
           dmaPusherPutAddress[11] = NV076_SET_COLOR_FORMAT_LE_X8R8G8B8;

           dmaPusherPutAddress += 12;

           while (freeCount < 12)
               NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
           freeCount -= 12;

           dmaPusherPutAddress[0] = dDrawSubchannelOffset(3) | 0x40000;
           dmaPusherPutAddress[1] = NV_DD_ABLEND_STRETCHED_IMAGE_FROM_CPU;
           dmaPusherPutAddress[2] = dDrawSubchannelOffset(3) +
               NV076_SET_CONTEXT_COLOR_KEY | 0x40000;
           dmaPusherPutAddress[3] = NV_DD_CONTEXT_COLOR_KEY;
           dmaPusherPutAddress[4] = dDrawSubchannelOffset(3) +
               NV076_SET_OPERATION | 0x40000;
           dmaPusherPutAddress[5] = NV076_SET_OPERATION_BLEND_PREMULT;
           dmaPusherPutAddress[6] = dDrawSubchannelOffset(3) +
               NV076_SET_CONTEXT_BETA4 | 0x40000;
           dmaPusherPutAddress[7] = NV_DD_CONTEXT_BETA4;
           dmaPusherPutAddress[8] = dDrawSubchannelOffset(3) +
               NV076_SET_CONTEXT_SURFACE | 0x40000;
           dmaPusherPutAddress[9] = NV_DD_SURFACES_2D;
           dmaPusherPutAddress[10] = dDrawSubchannelOffset(3) +
               NV076_SET_COLOR_FORMAT | 0x40000;
           dmaPusherPutAddress[11] = NV076_SET_COLOR_FORMAT_LE_A8R8G8B8;

           dmaPusherPutAddress += 12;
       }


       while (freeCount < 14)
           NvGetDmaBufferFreeCount(npDev, freeCount, 14, dmaPusherPutAddress);
       freeCount -= 14;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(0) | 0x40000;
       dmaPusherPutAddress[1] = NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(0) +
           NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
       dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
       dmaPusherPutAddress[4] = NV_DD_DMA_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[5] = dDrawSubchannelOffset(0) +
           NV077_SET_CONTEXT_PATTERN | 0x80000;
       dmaPusherPutAddress[6] = NV_DD_CONTEXT_PATTERN;
       dmaPusherPutAddress[7] = NV_DD_CONTEXT_ROP;
       dmaPusherPutAddress[8] = dDrawSubchannelOffset(0) +
           NV077_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[9] = NV077_SET_OPERATION_ROP_AND;
       dmaPusherPutAddress[10] = dDrawSubchannelOffset(0) +
           NV077_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[11] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[12] = dDrawSubchannelOffset(0) +
           NV077_SET_COLOR_FORMAT | 0x40000;
       if (pxlDepth == 16)
           dmaPusherPutAddress[13] = NV077_SET_COLOR_FORMAT_LE_R5G6B5;
       else
           dmaPusherPutAddress[13] = NV077_SET_COLOR_FORMAT_LE_X8R8G8B8;

       dmaPusherPutAddress += 14;


       if (pxlDepth > 16) {

           while (freeCount < 11)
               NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
           freeCount -= 11;

           dmaPusherPutAddress[0] = dDrawSubchannelOffset(1) | 0x40000;
           dmaPusherPutAddress[1] =
               NV_DD_SRCCOPY_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;
           dmaPusherPutAddress[2] = dDrawSubchannelOffset(1) +
               NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
           dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
           dmaPusherPutAddress[4] = NV_DD_DMA_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
           dmaPusherPutAddress[5] = dDrawSubchannelOffset(1) +
               NV077_SET_OPERATION | 0x40000;
           dmaPusherPutAddress[6] = NV077_SET_OPERATION_SRCCOPY;
           dmaPusherPutAddress[7] = dDrawSubchannelOffset(1) +
               NV077_SET_CONTEXT_SURFACE | 0x40000;
           dmaPusherPutAddress[8] = NV_DD_SURFACES_2D;
           dmaPusherPutAddress[9] = dDrawSubchannelOffset(1) +
               NV077_SET_COLOR_FORMAT | 0x40000;
           dmaPusherPutAddress[10] = NV077_SET_COLOR_FORMAT_LE_A8R8G8B8;

           dmaPusherPutAddress += 11;

           while (freeCount < 13)
               NvGetDmaBufferFreeCount(npDev, freeCount, 13, dmaPusherPutAddress);
           freeCount -= 13;

           dmaPusherPutAddress[0] = dDrawSubchannelOffset(2) | 0x40000;
           dmaPusherPutAddress[1] =
               NV_DD_ABLEND_NOSRCALPHA_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;
           dmaPusherPutAddress[2] = dDrawSubchannelOffset(2) +
               NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
           dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
           dmaPusherPutAddress[4] = NV_DD_DMA_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
           dmaPusherPutAddress[5] = dDrawSubchannelOffset(2) +
               NV077_SET_OPERATION | 0x40000;
           dmaPusherPutAddress[6] = NV077_SET_OPERATION_BLEND_PREMULT;
           dmaPusherPutAddress[7] = dDrawSubchannelOffset(2) +
               NV077_SET_CONTEXT_BETA4 | 0x40000;
           dmaPusherPutAddress[8] = NV_DD_CONTEXT_BETA4;
           dmaPusherPutAddress[9] = dDrawSubchannelOffset(2) +
               NV077_SET_CONTEXT_SURFACE | 0x40000;
           dmaPusherPutAddress[10] = NV_DD_SURFACES_2D;
           dmaPusherPutAddress[11] = dDrawSubchannelOffset(2) +
               NV077_SET_COLOR_FORMAT | 0x40000;
           dmaPusherPutAddress[12] = NV077_SET_COLOR_FORMAT_LE_X8R8G8B8;

           dmaPusherPutAddress += 13;

           while (freeCount < 13)
               NvGetDmaBufferFreeCount(npDev, freeCount, 13, dmaPusherPutAddress);
           freeCount -= 13;

           dmaPusherPutAddress[0] = dDrawSubchannelOffset(2) | 0x40000;
           dmaPusherPutAddress[1] =
               NV_DD_ABLEND_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;
           dmaPusherPutAddress[2] = dDrawSubchannelOffset(2) +
               NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
           dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
           dmaPusherPutAddress[4] = NV_DD_DMA_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
           dmaPusherPutAddress[5] = dDrawSubchannelOffset(2) +
               NV077_SET_OPERATION | 0x40000;
           dmaPusherPutAddress[6] = NV077_SET_OPERATION_BLEND_PREMULT;
           dmaPusherPutAddress[7] = dDrawSubchannelOffset(2) +
               NV077_SET_CONTEXT_BETA4 | 0x40000;
           dmaPusherPutAddress[8] = NV_DD_CONTEXT_BETA4;
           dmaPusherPutAddress[9] = dDrawSubchannelOffset(2) +
               NV077_SET_CONTEXT_SURFACE | 0x40000;
           dmaPusherPutAddress[10] = NV_DD_SURFACES_2D;
           dmaPusherPutAddress[11] = dDrawSubchannelOffset(2) +
               NV077_SET_COLOR_FORMAT | 0x40000;
           dmaPusherPutAddress[12] = NV077_SET_COLOR_FORMAT_LE_A8R8G8B8;

           dmaPusherPutAddress += 13;
       }


       while (freeCount < 14)
           NvGetDmaBufferFreeCount(npDev, freeCount, 14, dmaPusherPutAddress);
       freeCount -= 14;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(0) | 0x40000;
       dmaPusherPutAddress[1] = NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(0) +
           NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
       dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
       dmaPusherPutAddress[4] = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;
       dmaPusherPutAddress[5] = dDrawSubchannelOffset(0) +
           NV077_SET_CONTEXT_PATTERN | 0x80000;
       dmaPusherPutAddress[6] = NV_DD_CONTEXT_PATTERN;
       dmaPusherPutAddress[7] = NV_DD_CONTEXT_ROP;
       dmaPusherPutAddress[8] = dDrawSubchannelOffset(0) +
           NV077_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[9] = NV077_SET_OPERATION_ROP_AND;
       dmaPusherPutAddress[10] = dDrawSubchannelOffset(0) +
           NV077_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[11] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[12] = dDrawSubchannelOffset(0) +
           NV077_SET_COLOR_FORMAT | 0x40000;
       if (pxlDepth == 16)
           dmaPusherPutAddress[13] = NV077_SET_COLOR_FORMAT_LE_R5G6B5;
       else
           dmaPusherPutAddress[13] = NV077_SET_COLOR_FORMAT_LE_X8R8G8B8;

       dmaPusherPutAddress += 14;


       if (pxlDepth > 16) {

           while (freeCount < 11)
               NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
           freeCount -= 11;

           dmaPusherPutAddress[0] = dDrawSubchannelOffset(1) | 0x40000;
           dmaPusherPutAddress[1] =
               NV_DD_SRCCOPY_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
           dmaPusherPutAddress[2] = dDrawSubchannelOffset(1) +
               NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
           dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
           dmaPusherPutAddress[4] = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;
           dmaPusherPutAddress[5] = dDrawSubchannelOffset(1) +
               NV077_SET_OPERATION | 0x40000;
           dmaPusherPutAddress[6] = NV077_SET_OPERATION_SRCCOPY;
           dmaPusherPutAddress[7] = dDrawSubchannelOffset(1) +
               NV077_SET_CONTEXT_SURFACE | 0x40000;
           dmaPusherPutAddress[8] = NV_DD_SURFACES_2D;
           dmaPusherPutAddress[9] = dDrawSubchannelOffset(1) +
               NV077_SET_COLOR_FORMAT | 0x40000;
           dmaPusherPutAddress[10] = NV077_SET_COLOR_FORMAT_LE_A8R8G8B8;

           dmaPusherPutAddress += 11;

           while (freeCount < 13)
               NvGetDmaBufferFreeCount(npDev, freeCount, 13, dmaPusherPutAddress);
           freeCount -= 13;

           dmaPusherPutAddress[0] = dDrawSubchannelOffset(2) | 0x40000;
           dmaPusherPutAddress[1] =
               NV_DD_ABLEND_NOSRCALPHA_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
           dmaPusherPutAddress[2] = dDrawSubchannelOffset(2) +
               NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
           dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
           dmaPusherPutAddress[4] = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;
           dmaPusherPutAddress[5] = dDrawSubchannelOffset(2) +
               NV077_SET_OPERATION | 0x40000;
           dmaPusherPutAddress[6] = NV077_SET_OPERATION_BLEND_PREMULT;
           dmaPusherPutAddress[7] = dDrawSubchannelOffset(2) +
               NV077_SET_CONTEXT_BETA4 | 0x40000;
           dmaPusherPutAddress[8] = NV_DD_CONTEXT_BETA4;
           dmaPusherPutAddress[9] = dDrawSubchannelOffset(2) +
               NV077_SET_CONTEXT_SURFACE | 0x40000;
           dmaPusherPutAddress[10] = NV_DD_SURFACES_2D;
           dmaPusherPutAddress[11] = dDrawSubchannelOffset(2) +
               NV077_SET_COLOR_FORMAT | 0x40000;
           dmaPusherPutAddress[12] = NV077_SET_COLOR_FORMAT_LE_X8R8G8B8;

           dmaPusherPutAddress += 13;

           while (freeCount < 13)
               NvGetDmaBufferFreeCount(npDev, freeCount, 13, dmaPusherPutAddress);
           freeCount -= 13;

           dmaPusherPutAddress[0] = dDrawSubchannelOffset(2) | 0x40000;
           dmaPusherPutAddress[1] =
               NV_DD_ABLEND_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
           dmaPusherPutAddress[2] = dDrawSubchannelOffset(2) +
               NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
           dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
           dmaPusherPutAddress[4] = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;
           dmaPusherPutAddress[5] = dDrawSubchannelOffset(2) +
               NV077_SET_OPERATION | 0x40000;
           dmaPusherPutAddress[6] = NV077_SET_OPERATION_BLEND_PREMULT;
           dmaPusherPutAddress[7] = dDrawSubchannelOffset(2) +
               NV077_SET_CONTEXT_BETA4 | 0x40000;
           dmaPusherPutAddress[8] = NV_DD_CONTEXT_BETA4;
           dmaPusherPutAddress[9] = dDrawSubchannelOffset(2) +
               NV077_SET_CONTEXT_SURFACE | 0x40000;
           dmaPusherPutAddress[10] = NV_DD_SURFACES_2D;
           dmaPusherPutAddress[11] = dDrawSubchannelOffset(2) +
               NV077_SET_COLOR_FORMAT | 0x40000;
           dmaPusherPutAddress[12] = NV077_SET_COLOR_FORMAT_LE_A8R8G8B8;

           dmaPusherPutAddress += 13;
       }


       while (freeCount < 11)
           NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
       freeCount -= 11;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(4) | 0x40000;
       dmaPusherPutAddress[1] =
           NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(4) +
           NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
       dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
       dmaPusherPutAddress[4] = NV_DD_DMA_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[5] = dDrawSubchannelOffset(4) +
           NV077_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[6] = NV077_SET_OPERATION_SRCCOPY;
       dmaPusherPutAddress[7] = dDrawSubchannelOffset(4) +
           NV077_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[8] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[9] = dDrawSubchannelOffset(4) +
           NV077_SET_COLOR_FORMAT | 0x40000;
       dmaPusherPutAddress[10] = NV077_SET_COLOR_FORMAT_LE_YB8V8YA8U8;

       dmaPusherPutAddress += 11;

       while (freeCount < 11)
           NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
       freeCount -= 11;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(5) | 0x40000;
       dmaPusherPutAddress[1] =
           NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(5) +
           NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
       dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
       dmaPusherPutAddress[4] = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;
       dmaPusherPutAddress[5] = dDrawSubchannelOffset(5) +
           NV077_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[6] = NV077_SET_OPERATION_SRCCOPY;
       dmaPusherPutAddress[7] = dDrawSubchannelOffset(5) +
           NV077_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[8] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[9] = dDrawSubchannelOffset(5) +
           NV077_SET_COLOR_FORMAT | 0x40000;
       dmaPusherPutAddress[10] = NV077_SET_COLOR_FORMAT_LE_YB8V8YA8U8;

       dmaPusherPutAddress += 11;

       while (freeCount < 11)
           NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
       freeCount -= 11;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(6) | 0x40000;
       dmaPusherPutAddress[1] =
           NV_DD_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(6) +
           NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
       dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
       dmaPusherPutAddress[4] = NV_DD_DMA_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[5] = dDrawSubchannelOffset(6) +
           NV077_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[6] = NV077_SET_OPERATION_SRCCOPY;
       dmaPusherPutAddress[7] = dDrawSubchannelOffset(6) +
           NV077_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[8] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[9] = dDrawSubchannelOffset(6) +
           NV077_SET_COLOR_FORMAT | 0x40000;
       dmaPusherPutAddress[10] = NV077_SET_COLOR_FORMAT_LE_V8YB8U8YA8;

       dmaPusherPutAddress += 11;

       while (freeCount < 11)
           NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
       freeCount -= 11;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(7) | 0x40000;
       dmaPusherPutAddress[1] =
           NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(7) +
           NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
       dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
       dmaPusherPutAddress[4] = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;
       dmaPusherPutAddress[5] = dDrawSubchannelOffset(7) +
           NV077_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[6] = NV077_SET_OPERATION_SRCCOPY;
       dmaPusherPutAddress[7] = dDrawSubchannelOffset(7) +
           NV077_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[8] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[9] = dDrawSubchannelOffset(7) +
           NV077_SET_COLOR_FORMAT | 0x40000;
       dmaPusherPutAddress[10] = NV077_SET_COLOR_FORMAT_LE_V8YB8U8YA8;

       dmaPusherPutAddress += 11;

#ifdef  MULTI_MON

       while (freeCount < 10)
           NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
       freeCount -= 10;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(4) | 0x40000;
       dmaPusherPutAddress[1] =
           NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(4) +
           NV077_SET_CONTEXT_DMA_NOTIFIES | 0x40000;
       dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
       dmaPusherPutAddress[4] = dDrawSubchannelOffset(4) +
           NV077_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[5] = NV077_SET_OPERATION_SRCCOPY;
       dmaPusherPutAddress[6] = dDrawSubchannelOffset(4) +
           NV077_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[7] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[8] = dDrawSubchannelOffset(4) +
           NV077_SET_COLOR_FORMAT | 0x40000;
       dmaPusherPutAddress[9] = NV077_SET_COLOR_FORMAT_LE_YB8V8YA8U8;

       dmaPusherPutAddress += 10;

       while (freeCount < 10)
           NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
       freeCount -= 10;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(5) | 0x40000;
       dmaPusherPutAddress[1] =
           NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(5) +
           NV077_SET_CONTEXT_DMA_NOTIFIES | 0x40000;
       dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
       dmaPusherPutAddress[4] = dDrawSubchannelOffset(5) +
           NV077_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[5] = NV077_SET_OPERATION_SRCCOPY;
       dmaPusherPutAddress[6] = dDrawSubchannelOffset(5) +
           NV077_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[7] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[8] = dDrawSubchannelOffset(5) +
           NV077_SET_COLOR_FORMAT | 0x40000;
       dmaPusherPutAddress[9] = NV077_SET_COLOR_FORMAT_LE_YB8V8YA8U8;

       dmaPusherPutAddress += 10;

       while (freeCount < 10)
           NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
       freeCount -= 10;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(6) | 0x40000;
       dmaPusherPutAddress[1] =
           NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(6) +
           NV077_SET_CONTEXT_DMA_NOTIFIES | 0x40000;
       dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
       dmaPusherPutAddress[4] = dDrawSubchannelOffset(6) +
           NV077_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[5] = NV077_SET_OPERATION_SRCCOPY;
       dmaPusherPutAddress[6] = dDrawSubchannelOffset(6) +
           NV077_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[7] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[8] = dDrawSubchannelOffset(6) +
           NV077_SET_COLOR_FORMAT | 0x40000;
       dmaPusherPutAddress[9] = NV077_SET_COLOR_FORMAT_LE_V8YB8U8YA8;

       dmaPusherPutAddress += 10;

       while (freeCount < 10)
           NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
       freeCount -= 10;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(7) | 0x40000;
       dmaPusherPutAddress[1] =
           NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(7) +
           NV077_SET_CONTEXT_DMA_NOTIFIES | 0x40000;
       dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
       dmaPusherPutAddress[4] = dDrawSubchannelOffset(7) +
           NV077_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[5] = NV077_SET_OPERATION_SRCCOPY;
       dmaPusherPutAddress[6] = dDrawSubchannelOffset(7) +
           NV077_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[7] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[8] = dDrawSubchannelOffset(7) +
           NV077_SET_COLOR_FORMAT | 0x40000;
       dmaPusherPutAddress[9] = NV077_SET_COLOR_FORMAT_LE_V8YB8U8YA8;

       dmaPusherPutAddress += 10;

#else   /* MULTI_MON */

       while (freeCount < 11)
           NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
       freeCount -= 11;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(4) | 0x40000;
       dmaPusherPutAddress[1] =
           NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(4) +
           NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
       dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
       dmaPusherPutAddress[4] = NV_DD_DMA_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[5] = dDrawSubchannelOffset(4) +
           NV077_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[6] = NV077_SET_OPERATION_SRCCOPY;
       dmaPusherPutAddress[7] = dDrawSubchannelOffset(4) +
           NV077_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[8] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[9] = dDrawSubchannelOffset(4) +
           NV077_SET_COLOR_FORMAT | 0x40000;
       dmaPusherPutAddress[10] = NV077_SET_COLOR_FORMAT_LE_YB8V8YA8U8;

       dmaPusherPutAddress += 11;

       while (freeCount < 11)
           NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
       freeCount -= 11;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(5) | 0x40000;
       dmaPusherPutAddress[1] =
           NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(5) +
           NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
       dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
       dmaPusherPutAddress[4] = NV_DD_DMA_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[5] = dDrawSubchannelOffset(5) +
           NV077_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[6] = NV077_SET_OPERATION_SRCCOPY;
       dmaPusherPutAddress[7] = dDrawSubchannelOffset(5) +
           NV077_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[8] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[9] = dDrawSubchannelOffset(5) +
           NV077_SET_COLOR_FORMAT | 0x40000;
       dmaPusherPutAddress[10] = NV077_SET_COLOR_FORMAT_LE_YB8V8YA8U8;

       dmaPusherPutAddress += 11;

       while (freeCount < 11)
           NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
       freeCount -= 11;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(6) | 0x40000;
       dmaPusherPutAddress[1] =
           NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(6) +
           NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
       dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
       dmaPusherPutAddress[4] = NV_DD_DMA_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[5] = dDrawSubchannelOffset(6) +
           NV077_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[6] = NV077_SET_OPERATION_SRCCOPY;
       dmaPusherPutAddress[7] = dDrawSubchannelOffset(6) +
           NV077_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[8] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[9] = dDrawSubchannelOffset(6) +
           NV077_SET_COLOR_FORMAT | 0x40000;
       dmaPusherPutAddress[10] = NV077_SET_COLOR_FORMAT_LE_V8YB8U8YA8;

       dmaPusherPutAddress += 11;

       while (freeCount < 11)
           NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
       freeCount -= 11;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(7) | 0x40000;
       dmaPusherPutAddress[1] =
           NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(7) +
           NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
       dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
       dmaPusherPutAddress[4] = NV_DD_DMA_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[5] = dDrawSubchannelOffset(7) +
           NV077_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[6] = NV077_SET_OPERATION_SRCCOPY;
       dmaPusherPutAddress[7] = dDrawSubchannelOffset(7) +
           NV077_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[8] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[9] = dDrawSubchannelOffset(7) +
           NV077_SET_COLOR_FORMAT | 0x40000;
       dmaPusherPutAddress[10] = NV077_SET_COLOR_FORMAT_LE_V8YB8U8YA8;

       dmaPusherPutAddress += 11;

#endif  /* MULTI_MON */
   }


   while (freeCount < 12)
       NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
   freeCount -= 12;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(2) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_ALT_IMAGE_FROM_CPU;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(2) +
       NV061_SET_CONTEXT_COLOR_KEY | 0x100000;
   dmaPusherPutAddress[3] = NV_DD_CONTEXT_COLOR_KEY;
   dmaPusherPutAddress[4] = NV_DD_IMAGE_BLACK_RECTANGLE;
   dmaPusherPutAddress[5] = NV_DD_CONTEXT_PATTERN;
   dmaPusherPutAddress[6] = NV_DD_CONTEXT_ROP;
   dmaPusherPutAddress[7] = dDrawSubchannelOffset(2) +
       NV061_SET_CONTEXT_SURFACE | 0x40000;
   dmaPusherPutAddress[8] = NV_DD_SURFACES_2D;
   dmaPusherPutAddress[9] = dDrawSubchannelOffset(2) +
       NV061_SET_OPERATION | 0x80000;
   dmaPusherPutAddress[10] = NV061_SET_OPERATION_ROP_AND;

   if (pxlDepth == 8)
       /* Y8 color format assumed by hardware when destination surface in 8bpp mode */
       /* Must be set to a legal value but hardware ignores it otherwise */
       dmaPusherPutAddress[11] = NV061_SET_COLOR_FORMAT_LE_X8R8G8B8;
   else if (pxlDepth == 16)
       dmaPusherPutAddress[11] = NV061_SET_COLOR_FORMAT_LE_X8R8G8B8;
   else if (pxlDepth == 32)
       dmaPusherPutAddress[11] = NV061_SET_COLOR_FORMAT_LE_R5G6B5;

   dmaPusherPutAddress += 12;

   while (freeCount < 12)
       NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
   freeCount -= 12;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(2) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_IMAGE_FROM_CPU;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(2) +
       NV061_SET_CONTEXT_COLOR_KEY | 0x100000;
   dmaPusherPutAddress[3] = NV_DD_CONTEXT_COLOR_KEY;
   dmaPusherPutAddress[4] = NV_DD_IMAGE_BLACK_RECTANGLE;
   dmaPusherPutAddress[5] = NV_DD_CONTEXT_PATTERN;
   dmaPusherPutAddress[6] = NV_DD_CONTEXT_ROP;
   dmaPusherPutAddress[7] = dDrawSubchannelOffset(2) +
       NV061_SET_CONTEXT_SURFACE | 0x40000;
   dmaPusherPutAddress[8] = NV_DD_SURFACES_2D;
   dmaPusherPutAddress[9] = dDrawSubchannelOffset(2) +
       NV061_SET_OPERATION | 0x80000;
   dmaPusherPutAddress[10] = NV061_SET_OPERATION_ROP_AND;

   if (pxlDepth == 8)
       /* Y8 color format assumed by hardware when destination surface in 8bpp mode */
       /* Must be set to a legal value but hardware ignores it otherwise */
       dmaPusherPutAddress[11] = NV061_SET_COLOR_FORMAT_LE_X8R8G8B8;
   else if (pxlDepth == 16)
       dmaPusherPutAddress[11] = NV061_SET_COLOR_FORMAT_LE_R5G6B5;
   else if (pxlDepth == 32)
       dmaPusherPutAddress[11] = NV061_SET_COLOR_FORMAT_LE_X8R8G8B8;

   dmaPusherPutAddress += 12;


   if (pxlDepth > 16) {

       while (freeCount < 9)
           NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
       freeCount -= 9;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(3) | 0x40000;
       dmaPusherPutAddress[1] = NV_DD_SRCCOPY_IMAGE_FROM_CPU;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(3) +
           NV061_SET_CONTEXT_COLOR_KEY | 0x40000;
       dmaPusherPutAddress[3] = NV_DD_CONTEXT_COLOR_KEY;
       dmaPusherPutAddress[4] = dDrawSubchannelOffset(3) +
           NV061_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[5] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[6] = dDrawSubchannelOffset(3) +
           NV061_SET_OPERATION | 0x80000;
       dmaPusherPutAddress[7] = NV061_SET_OPERATION_SRCCOPY;
       dmaPusherPutAddress[8] = NV061_SET_COLOR_FORMAT_LE_A8R8G8B8;

       dmaPusherPutAddress += 9;

       while (freeCount < 10)
           NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
       freeCount -= 10;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(4) | 0x40000;
       dmaPusherPutAddress[1] = NV_DD_ABLEND_NOSRCALPHA_IMAGE_FROM_CPU;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(4) +
           NV061_SET_CONTEXT_COLOR_KEY | 0x40000;
       dmaPusherPutAddress[3] = NV_DD_CONTEXT_COLOR_KEY;
       dmaPusherPutAddress[4] = dDrawSubchannelOffset(4) +
           NV061_SET_CONTEXT_BETA4 | 0x80000;
       dmaPusherPutAddress[5] = NV_DD_CONTEXT_BETA4;
       dmaPusherPutAddress[6] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[7] = dDrawSubchannelOffset(4) +
           NV061_SET_OPERATION | 0x80000;
       dmaPusherPutAddress[8] = NV061_SET_OPERATION_BLEND_PREMULT;
       dmaPusherPutAddress[9] = NV061_SET_COLOR_FORMAT_LE_X8R8G8B8;

       dmaPusherPutAddress += 10;

       while (freeCount < 10)
           NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
       freeCount -= 10;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(5) | 0x40000;
       dmaPusherPutAddress[1] = NV_DD_ABLEND_IMAGE_FROM_CPU;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(5) +
           NV061_SET_CONTEXT_COLOR_KEY | 0x40000;
       dmaPusherPutAddress[3] = NV_DD_CONTEXT_COLOR_KEY;
       dmaPusherPutAddress[4] = dDrawSubchannelOffset(5) +
           NV061_SET_CONTEXT_BETA4 | 0x80000;
       dmaPusherPutAddress[5] = NV_DD_CONTEXT_BETA4;
       dmaPusherPutAddress[6] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[7] = dDrawSubchannelOffset(5) +
           NV061_SET_OPERATION | 0x80000;
       dmaPusherPutAddress[8] = NV061_SET_OPERATION_BLEND_PREMULT;
       dmaPusherPutAddress[9] = NV061_SET_COLOR_FORMAT_LE_A8R8G8B8;

       dmaPusherPutAddress += 10;
   }


   while (freeCount < 13)
       NvGetDmaBufferFreeCount(npDev, freeCount, 13, dmaPusherPutAddress);
   freeCount -= 13;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(2) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_ROP_GDI_RECT_AND_TEXT;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(2) +
       NV04A_SET_CONTEXT_DMA_NOTIFIES | 0x40000;
   dmaPusherPutAddress[3] = NV_DD_DMA_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[4] = dDrawSubchannelOffset(2) +
       NV04A_SET_CONTEXT_PATTERN | 0x80000;
   dmaPusherPutAddress[5] = NV_DD_CONTEXT_PATTERN;
   dmaPusherPutAddress[6] = NV_DD_CONTEXT_ROP;
   dmaPusherPutAddress[7] = dDrawSubchannelOffset(2) +
       NV04A_SET_CONTEXT_SURFACE | 0x40000;
   dmaPusherPutAddress[8] = NV_DD_SURFACES_2D;
   dmaPusherPutAddress[9] = dDrawSubchannelOffset(2) +
       NV04A_SET_OPERATION | 0xC0000;
   dmaPusherPutAddress[10] = NV04A_SET_OPERATION_ROP_AND;

   if (pxlDepth == 8)
       /* Y8 color format assumed by hardware when destination surface in 8bpp mode */
       /* Must be set to a legal value but hardware ignores it otherwise */
       dmaPusherPutAddress[11] = NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8;
   else if (pxlDepth == 16)
       dmaPusherPutAddress[11] = NV04A_SET_COLOR_FORMAT_LE_X16R5G6B5;
   else if (pxlDepth == 32)
       dmaPusherPutAddress[11] = NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8;

   dmaPusherPutAddress[12] = NV04A_SET_MONOCHROME_FORMAT_CGA6_M1;

   dmaPusherPutAddress += 13;


   if (pxlDepth > 16) {

       while (freeCount < 9)
           NvGetDmaBufferFreeCount(npDev, freeCount, 9, dmaPusherPutAddress);
       freeCount -= 9;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(3) | 0x40000;
       dmaPusherPutAddress[1] = NV_DD_ABLEND_RECT_AND_TEXT;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(3) +
           NV04A_SET_CONTEXT_BETA4 | 0x80000;
       dmaPusherPutAddress[3] = NV_DD_CONTEXT_BETA4;
       dmaPusherPutAddress[4] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[5] = dDrawSubchannelOffset(3) +
           NV04A_SET_OPERATION | 0xC0000;
       dmaPusherPutAddress[6] = NV04A_SET_OPERATION_BLEND_PREMULT;
       dmaPusherPutAddress[7] = NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8;
       dmaPusherPutAddress[8] = NV04A_SET_MONOCHROME_FORMAT_CGA6_M1;

       dmaPusherPutAddress += 9;
   }


   while (freeCount < 6)
       NvGetDmaBufferFreeCount(npDev, freeCount, 6, dmaPusherPutAddress);
   freeCount -= 6;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(4) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_VIDEO_MEMORY_TO_SYSTEM_MEMORY_FORMAT;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(4) +
       NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000;
   dmaPusherPutAddress[3] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[4] = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;
   dmaPusherPutAddress[5] = NV_DD_DMA_CONTEXT_DMA_TO_SYSTEM_MEMORY;

   dmaPusherPutAddress += 6;

   while (freeCount < 5)
       NvGetDmaBufferFreeCount(npDev, freeCount, 5, dmaPusherPutAddress);
   freeCount -= 5;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(5) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_CONTEXT_COLOR_KEY;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(5) +
       NV057_SET_COLOR_FORMAT | 0x80000;

   if (pxlDepth == 8)
       /* A8Y8 color format assumed by hardware when destination surface in 8bpp mode */
       /* Must be set to a legal value but hardware ignores it otherwise */
       dmaPusherPutAddress[3] = NV057_SET_COLOR_FORMAT_LE_A8R8G8B8;
   else if (pxlDepth == 16)
       dmaPusherPutAddress[3] = NV057_SET_COLOR_FORMAT_LE_A16R5G6B5;
   else if (pxlDepth == 32)
       dmaPusherPutAddress[3] = NV057_SET_COLOR_FORMAT_LE_A8R8G8B8;

   dmaPusherPutAddress[4] = 0;

   dmaPusherPutAddress += 5;

   /*
    * Pattern is currently only used for overlay video UV masking so
    * always set it's color format to 8 bit indexed.
    */

   while (freeCount < 9)
       NvGetDmaBufferFreeCount(npDev, freeCount, 9, dmaPusherPutAddress);
   freeCount -= 9;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(6) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_CONTEXT_PATTERN;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(6) +
       NV044_SET_COLOR_FORMAT | 0x80000;
   /* A8Y8 color format assumed by hardware when destination surface in 8bpp mode */
   /* Must be set to a legal value but hardware ignores it otherwise */
   dmaPusherPutAddress[3] = NV044_SET_COLOR_FORMAT_LE_A8R8G8B8;
   dmaPusherPutAddress[4] = NV044_SET_MONOCHROME_FORMAT_CGA6_M1;
   dmaPusherPutAddress[5] = dDrawSubchannelOffset(6) +
       NV044_SET_PATTERN_SELECT | 0xC0000;
   dmaPusherPutAddress[6] = NV044_SET_PATTERN_SELECT_MONOCHROME;

   if (pxlDepth == 8) {
       dmaPusherPutAddress[7] = NV_ALPHA_1_008;
       dmaPusherPutAddress[8] = NV_ALPHA_1_008;
   } else if (pxlDepth == 16) {
       dmaPusherPutAddress[7] = NV_ALPHA_1_016;
       dmaPusherPutAddress[8] = NV_ALPHA_1_016;
   } else {
       dmaPusherPutAddress[7] = NV_ALPHA_1_032;
       dmaPusherPutAddress[8] = NV_ALPHA_1_032;
   }

   dmaPusherPutAddress += 9;

   /* Create the D3D objects */
   pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

   pDriverData->dwDmaPusherFreeCount = freeCount;

   nvD3DCreateObjects();

   dmaPusherPutAddress = (unsigned long *)pDriverData->NvDmaPusherPutAddress;

#ifdef  CACHE_FREECOUNT
   freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
   freeCount = 0;
#endif  /* CACHE_FREECOUNT */

   /* Make final subchannel assignments */

   while (freeCount < 5)
       NvGetDmaBufferFreeCount(npDev, freeCount, 5, dmaPusherPutAddress);
   freeCount -= 5;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_IMAGE_BLACK_RECTANGLE;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(0) +
       NV019_SET_POINT | 0x80000;
   dmaPusherPutAddress[3] = 0;
   dmaPusherPutAddress[4] = asmMergeCoords(pDriverData->bi.biWidth,
                                           pDriverData->maxOffScreenY);

   dmaPusherPutAddress += 5;

   while (freeCount < 18)
       NvGetDmaBufferFreeCount(npDev, freeCount, 18, dmaPusherPutAddress);
   freeCount -= 18;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_CONTEXT_ROP;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(6) | 0x40000;
   dmaPusherPutAddress[3] = NV_DD_CONTEXT_COLOR_KEY;
   dmaPusherPutAddress[4] = dDrawSubchannelOffset(1) | 0x40000;
   dmaPusherPutAddress[5] = NV_DD_SURFACES_2D;
   dmaPusherPutAddress[6] = dDrawSubchannelOffset(1) +
       NV042_SET_PITCH | 0xC0000;

   dmaPusherPutAddress[7] = (pDriverData->HALInfo.vmiData.lDisplayPitch << 16) |
    pDriverData->HALInfo.vmiData.lDisplayPitch;

   dmaPusherPutAddress[8] = 0;
   dmaPusherPutAddress[9] = 0;

   dmaPusherPutAddress[10] = dDrawSubchannelOffset(2) | 0x40000;
   dmaPusherPutAddress[11] = NV_DD_ROP_GDI_RECT_AND_TEXT;
   dmaPusherPutAddress[12] = dDrawSubchannelOffset(3) | 0x40000;
   dmaPusherPutAddress[13] = NV_DD_IMAGE_BLIT;
   dmaPusherPutAddress[14] = dDrawSubchannelOffset(4) | 0x40000;
   dmaPusherPutAddress[15] = NV_DD_IMAGE_FROM_CPU;
   dmaPusherPutAddress[16] = dDrawSubchannelOffset(5) | 0x40000;

   if (pxlDepth == 8)
       dmaPusherPutAddress[17] = NV_DD_STRETCHED_IMAGE_FROM_CPU;
   else
       dmaPusherPutAddress[17] = NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;

   dmaPusherPutAddress += 18;

   while (freeCount < 8)
       NvGetDmaBufferFreeCount(npDev, freeCount, 8, dmaPusherPutAddress);
   freeCount -= 8;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
       NV043_SET_ROP5 | 0x40000;
   dmaPusherPutAddress[1] = 0x00000000;

   /* Force rectangle portion of patch to be validated (assures no RM interrupts on Lock calls) */

   dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
       NV04A_COLOR1_A | 0xC0000;
   dmaPusherPutAddress[3] = 0;
   dmaPusherPutAddress[4] = 0;
   dmaPusherPutAddress[5] = 0;

   /* Force Blit to be instantiated */

   dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_BLIT) +
       NV05F_CONTROL_POINT_IN | 0x40000;
   dmaPusherPutAddress[7] = 0;

   dmaPusherPutAddress += 8;

   /* Force write combine buffer to flush */
   pDriverData->NvDmaPusherBufferEnd[0] = 0;
   /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
   _outp (0x3d0,0);

   npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

   /* Wait for initialization to complete */
   while (npDev->Get != (unsigned long)((dmaPusherPutAddress - dmaPusherBufferBase) << 2));

   pDriverData->dwDDDmaPusherChannelIndex = 1;
   pDriverData->dwDDDmaPusherChannelMask = 0;

   /* Make sure ALL NV DMA channels are idle */
   NV_DD_DMA_PUSHER_SYNC();

   tmpIndex = -1;

   while (tmpIndex != pDriverData->dwDDDmaPusherChannelIndex) {

       pDriverData->dwDDDmaPusherChannelIndex = tmpIndex;

       while (freeCount < 4)
           NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
       freeCount -= 4;

       npDmaSyncNotifier->status = NV_IN_PROGRESS;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
           RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
       dmaPusherPutAddress[1] = 0;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
           RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
       dmaPusherPutAddress[3] = 0;

       dmaPusherPutAddress += 4;

       /* Force write combine buffer to flush */
       pDriverData->NvDmaPusherBufferEnd[0] = 0;
       /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
       _outp (0x3d0,0);

       npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

       while ((volatile)npDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification

       NV_DD_GET_DMA_CHANNEL_INDEX(tmpIndex);
   }

   pDriverData->dwDDDmaPusherChannelMask = 1 << pDriverData->dwDDDmaPusherChannelIndex;

   pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

   pDriverData->dwDmaPusherFreeCount = freeCount;

   /*
    * Perform any re-enabling of D3D.
    * After a mode switch, it is necessary to make sure that the proper
    * setup is done on the push buffer and texture contexts.
    */
   nvD3DReenable();

   pDriverData->dDrawSpareSubchannel6Object = 0;
   pDriverData->dDrawSpareSubchannelObject = 0; // subchannel 7


   /*
    * Now initialize video channel
    *
    * NOTE:
    *
    *  Video channel should contain NO graphics rendering objects.  This should
    *  prevent frequent context switches when switching between graphics and video channels.
    *
    */

   npDevVideo = (Nv3ChannelPio *)pDriverData->NvDevVideoFlatPio;

   videoFreeCount = 0;

   /* Initialize for PIO notifiers */

   pDriverData->NvPioDmaToMemNotifierFlat = pDriverData->NvCommonDmaBufferFlat;

   pDriverData->NvPioBufferNotifierFlat = pDriverData->NvCommonDmaBufferFlat;

//   pDriverData->NvPioDmaFromMemNotifierFlat = pDriverData->NvCommonDmaBufferFlat +
//       (sizeof(NvNotification) << 1);

//   pDriverData->NvDmaPusherSyncNotifierFlat = pDriverData->NvCommonDmaBufferFlat +
//       (sizeof(NvNotification) << 1) + sizeof(NvNotification);

//   pDriverData->NvPioSyncNotifierFlat = pDriverData->NvCommonDmaBufferFlat +
//       (sizeof(NvNotification) << 2);

//   /* Notifier array offsets 5, 6, 7, 8, and 9 */
//   pDriverData->NvPioFlipPrimaryNotifierFlat = pDriverData->NvCommonDmaBufferFlat +
//       (sizeof(NvNotification) << 2) + sizeof(NvNotification);

   /* Notifier array offsets A, B, C, D, and E */
   pDriverData->NvPioFlipOverlayNotifierFlat = pDriverData->NvCommonDmaBufferFlat +
       (sizeof(NvNotification) << 3) + (sizeof(NvNotification) << 1);

   /* Notifier array offset (sizeof(NvNotification) << 3) + (sizeof(NvNotification) << 2) + (sizeof(NvNotification) << 1) + sizeof(NvNotification) currently unused */

   npPioDmaToMemNotifier = (NvNotification *)pDriverData->NvPioDmaToMemNotifierFlat;
   npPioFlipOverlayNotifier = (NvNotification *)pDriverData->NvPioFlipOverlayNotifierFlat;

   /* Deal with possible mode change during pending flip */
   if (npDmaPusherSyncNotifier->status == NV_IN_PROGRESS) {
       long countDown = 0x200000;
       while ((npDmaPusherSyncNotifier->status == NV_IN_PROGRESS) && (--countDown > 0));
   }
   /* Deal with possible mode change during pending flip */
   if (npPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) {
       long countDown = 0x200000;
       while ((npPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) && (--countDown > 0));
   }
   /* Deal with possible mode change during pending flip */
   if (npPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS) {
       long countDown = 0x200000;
       while ((npPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS) && (--countDown > 0));
   }

   /* MUST MAKE SURE STATUS FLAG IS CLEAR BEFORE INITIAL USE */

   npDmaPusherSyncNotifier->status = 0;

   npPioDmaToMemNotifier->status = 0;

   npPioFlipOverlayNotifier[1].status = 0;
   npPioFlipOverlayNotifier[2].status = 0;


#ifndef MULTI_MON
   while (videoFreeCount < 24)
       videoFreeCount = NvGetFreeCount(npDevVideo, 0);
   videoFreeCount -= 24;

   npDevVideo->subchannel[0].SetObject = NV_CONTEXT_DMA_TO_MEMORY;
   npDevVideo->subchannel[0].nvClass.Create = NV_DD_PIO_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   npDevVideo->subchannel[0].nvClass.Create = NV_DD_PIO_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

   npDevVideo->subchannel[1].SetObject = NV_CONTEXT_DMA_FROM_MEMORY;
   npDevVideo->subchannel[1].nvClass.Create = NV_DD_PIO_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   npDevVideo->subchannel[1].nvClass.Create = NV_DD_PIO_CONTEXT_DMA_FROM_VIDEO_MEMORY;
#endif  /* MULTI_MON */

   if (pxlDepth == 8) {

       while (videoFreeCount < 12)
           videoFreeCount = NvGetFreeCount(npDevVideo, 2);
       videoFreeCount -= 12;

       npDevVideo->subchannel[3].SetObject = NV_DD_SHARED_VIDEO_COLORMAP;
       npDevVideo->subchannel[3].videoColormap.SetVideoOutput =
           NV_DD_P_V_SHARED_VIDEO_COLORMAP;
       npDevVideo->subchannel[3].videoColormap.SetVideoInput =
           NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY;
   }

   while (videoFreeCount < 8)
       videoFreeCount = NvGetFreeCount(npDevVideo, 5);
   videoFreeCount -= 8;

   npDevVideo->subchannel[5].SetObject = NV_DD_VIDEO_SINK;
   npDevVideo->subchannel[5].videoSink.SetVideoInput[0] =
       NV_DD_P_V_VIDEO_COLOR_KEY;

#else   /* MULTI_MON */

   while (videoFreeCount < 40)
       videoFreeCount = NvGetFreeCount(npDevVideo, 0);
   videoFreeCount -= 40;

   npDevVideo->subchannel[0].SetObject =
       NV_DD_PIO_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   npDevVideo->subchannel[0].contextDmaToMemory.SetDmaSpecifier.address[0] =
       (unsigned long)npPioDmaToMemNotifier;
   npDevVideo->subchannel[0].contextDmaToMemory.SetDmaSpecifier.address[1] =
       (unsigned long)pDriverData->flatSelector;
   npDevVideo->subchannel[0].contextDmaToMemory.SetDmaSpecifier.limit =
       (sizeof(NvNotification) - 1);

   npDevVideo->subchannel[0].SetObject =
       NV_DD_PIO_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   npDevVideo->subchannel[0].contextDmaToMemory.SetDmaSpecifier.address[0] =
       ((unsigned long)npPioDmaToMemNotifier + (sizeof(NvNotification) << 3) +
        (sizeof(NvNotification) << 1));
   npDevVideo->subchannel[0].contextDmaToMemory.SetDmaSpecifier.address[1] =
       (unsigned long)pDriverData->flatSelector;
   npDevVideo->subchannel[0].contextDmaToMemory.SetDmaSpecifier.limit =
       ((5 * sizeof(NvNotification)) - 1);

   npDevVideo->subchannel[1].SetObject = NV_VIDEO_SINK;
   npDevVideo->subchannel[1].nvClass.Create = NV_DD_VIDEO_SINK;

   if (pxlDepth == 8) {

       while (videoFreeCount < 20)
           videoFreeCount = NvGetFreeCount(npDevVideo, 2);
       videoFreeCount -= 20;

       npDevVideo->subchannel[2].SetObject = NV_VIDEO_COLORMAP;
       npDevVideo->subchannel[2].nvClass.Create = NV_DD_SHARED_VIDEO_COLORMAP;

       npDevVideo->subchannel[3].SetObject = NV_DD_SHARED_VIDEO_COLORMAP;
       npDevVideo->subchannel[3].videoColormap.SetVideoOutput =
           NV_DD_P_V_SHARED_VIDEO_COLORMAP;
       npDevVideo->subchannel[3].videoColormap.SetVideoInput =
           NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY;
   }

   while (videoFreeCount < 40)
       videoFreeCount = NvGetFreeCount(npDevVideo, 4);
   videoFreeCount -= 40;

   npDevVideo->subchannel[4].SetObject = NV_ERROR_NOTIFIER;
   npDevVideo->subchannel[4].contextDmaToMemory.SetDmaSpecifier.address[0] =
       (unsigned long)pDriverData->NvPioBufferNotifierFlat;
   npDevVideo->subchannel[4].contextDmaToMemory.SetDmaSpecifier.address[1] =
       (unsigned long)pDriverData->flatSelector;
   npDevVideo->subchannel[4].contextDmaToMemory.SetDmaSpecifier.limit =
       (NV_DD_COMMON_DMA_BUFFER_SIZE - (sizeof(NvNotification) << 2) -
       (sizeof(NvNotification) << 1) - 1);

   npDevVideo->subchannel[5].SetObject = NV_DD_VIDEO_SINK;
   npDevVideo->subchannel[5].videoSink.SetVideoInput[0] =
       NV_DD_P_V_VIDEO_COLOR_KEY;

   npDevVideo->subchannel[6].SetObject = NV_DD_PIO_CONTEXT_DMA_FROM_VIDEO_MEMORY;
   npDevVideo->subchannel[6].contextDmaFromMemory.SetDmaSpecifier.address[0] =
       (unsigned long)pDriverData->BaseAddress;
   npDevVideo->subchannel[6].contextDmaFromMemory.SetDmaSpecifier.address[1] =
       (unsigned long)pDriverData->flatSelector;
   npDevVideo->subchannel[6].contextDmaFromMemory.SetDmaSpecifier.limit =
       (unsigned long)pDriverData->VideoHeapEnd - pDriverData->BaseAddress;

#endif  /* MULTI_MON */

   while (videoFreeCount < 60)
       videoFreeCount = NvGetFreeCount(npDevVideo, 2);
   videoFreeCount -= 60;

   npDevVideo->subchannel[2].SetObject = NV_DD_VIDEO_COLOR_KEY;
   npDevVideo->subchannel[2].videoColorKey.SetVideoOutput =
       NV_DD_P_V_VIDEO_COLOR_KEY;
   npDevVideo->subchannel[2].videoColorKey.SetVideoInput[0] =
       NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY;

   if (pxlDepth == 8)
       npDevVideo->subchannel[2].videoColorKey.SetVideoInput[1] =
           NV_DD_P_V_SHARED_VIDEO_COLORMAP;
   else
       npDevVideo->subchannel[2].videoColorKey.SetVideoInput[1] =
           NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY;

   npDevVideo->subchannel[2].videoColorKey.SetVideoInput[2] =
       NV_DD_P_V_VIDEO_SCALER;

   if (pxlDepth == 8)
       npDevVideo->subchannel[2].videoColorKey.SetColorFormat =
           NVFF6_SET_COLOR_FORMAT_LE_X16A8Y8;
   else if (pxlDepth == 16)
       npDevVideo->subchannel[2].videoColorKey.SetColorFormat =
           NVFF6_SET_COLOR_FORMAT_LE_A16R5G6B5;
   else
       npDevVideo->subchannel[2].videoColorKey.SetColorFormat =
           NVFF6_SET_COLOR_FORMAT_LE_A8R8G8B8;

   npDevVideo->subchannel[2].videoColorKey.SetColorKey = 0;
   npDevVideo->subchannel[2].videoColorKey.SetPoint = 0;
   npDevVideo->subchannel[2].videoColorKey.SetSize = 0;

   npDevVideo->subchannel[3].SetObject = NV_DD_VIDEO_SCALER;
   npDevVideo->subchannel[3].videoScaler.SetVideoOutput =
       NV_DD_P_V_VIDEO_SCALER;
   npDevVideo->subchannel[3].videoScaler.SetVideoInput =
       NV_DD_P_V_YUV422_VIDEO_FROM_MEMORY;
   npDevVideo->subchannel[3].videoScaler.SetDeltaDuDx = 0x100000;
   npDevVideo->subchannel[3].videoScaler.SetDeltaDvDy = 0x100000;
   npDevVideo->subchannel[3].videoScaler.SetPoint = 0;

   while (videoFreeCount < 60)
       videoFreeCount = NvGetFreeCount(npDevVideo, 3);
   videoFreeCount -= 60;

   npDevVideo->subchannel[3].SetObject = NV_DD_YUV422_VIDEO_FROM_MEMORY;
   npDevVideo->subchannel[3].videoFromMemory.SetVideoOutput =
       NV_DD_P_V_YUV422_VIDEO_FROM_MEMORY;
   npDevVideo->subchannel[3].videoFromMemory.SetImageCtxDma[0] =
       NV_DD_PIO_CONTEXT_DMA_FROM_VIDEO_MEMORY;
   npDevVideo->subchannel[3].videoFromMemory.SetImageCtxDma[1] =
       NV_DD_PIO_CONTEXT_DMA_FROM_VIDEO_MEMORY;
   npDevVideo->subchannel[3].videoFromMemory.SetImageNotifyCtxDma =
       NV_DD_PIO_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   npDevVideo->subchannel[3].videoFromMemory.ImageScan[0].offset = 0;
   npDevVideo->subchannel[3].videoFromMemory.ImageScan[0].pitch = 0;
   npDevVideo->subchannel[3].videoFromMemory.ImageScan[0].size = 0;
   npDevVideo->subchannel[3].videoFromMemory.ImageScan[0].format =
       NV_VFM_FORMAT_COLOR_LE_Y8V8Y8U8;
   npDevVideo->subchannel[3].videoFromMemory.ImageScan[0].notify = 0;
   npDevVideo->subchannel[3].videoFromMemory.ImageScan[1].offset = 0;
   npDevVideo->subchannel[3].videoFromMemory.ImageScan[1].pitch = 0;
   npDevVideo->subchannel[3].videoFromMemory.ImageScan[1].size = 0;
   npDevVideo->subchannel[3].videoFromMemory.ImageScan[1].format =
       NV_VFM_FORMAT_COLOR_LE_Y8V8Y8U8;
   npDevVideo->subchannel[3].videoFromMemory.ImageScan[1].notify = 0;


   while (videoFreeCount < 24)
       videoFreeCount = NvGetFreeCount(npDevVideo, 7);
   videoFreeCount -= 24;

   npDevVideo->subchannel[7].SetObject = NV_DD_PRIMARY_VIDEO_FROM_MEMORY;
   npDevVideo->subchannel[7].videoFromMemory.SetVideoOutput =
       NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY;
   npDevVideo->subchannel[7].videoFromMemory.SetImageCtxDma[0] =
       NV_DD_PIO_CONTEXT_DMA_FROM_VIDEO_MEMORY;
   npDevVideo->subchannel[7].videoFromMemory.SetImageCtxDma[1] =
       NV_DD_PIO_CONTEXT_DMA_FROM_VIDEO_MEMORY;
//   npDevVideo->subchannel[7].videoFromMemory.SetImageNotifyCtxDma =
//       NV_DD_PIO_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
//   npDevVideo->subchannel[7].videoFromMemory.ImageScan[0].offset = 0;
//   npDevVideo->subchannel[7].videoFromMemory.ImageScan[0].pitch =
//       pDriverData->HALInfo.vmiData.lDisplayPitch;
//   npDevVideo->subchannel[7].videoFromMemory.ImageScan[0].size =
//       asmMergeCoords(pDriverData->bi.biWidth, pDriverData->bi.biHeight);
   if (pxlDepth == 8)
       npDevVideo->subchannel[7].videoFromMemory.ImageScan[0].format =
           NV_VFM_FORMAT_COLOR_LE_Y8_P4;
   else if (pxlDepth == 16)
       npDevVideo->subchannel[7].videoFromMemory.ImageScan[0].format =
           NV_VFM_FORMAT_COLOR_LE_R5G6B5_P2;
   else
       npDevVideo->subchannel[7].videoFromMemory.ImageScan[0].format =
           NV_VFM_FORMAT_COLOR_LE_X8R8G8B8;
//   npDevVideo->subchannel[7].videoFromMemory.ImageScan[0].notify = 0;

//   npDevVideo->subchannel[7].videoFromMemory.ImageScan[1].offset = 0;
//   npDevVideo->subchannel[7].videoFromMemory.ImageScan[1].pitch =
//       pDriverData->HALInfo.vmiData.lDisplayPitch;
//   npDevVideo->subchannel[7].videoFromMemory.ImageScan[1].size =
//       asmMergeCoords(pDriverData->bi.biWidth, pDriverData->bi.biHeight);
   if (pxlDepth == 8)
       npDevVideo->subchannel[7].videoFromMemory.ImageScan[1].format =
           NV_VFM_FORMAT_COLOR_LE_Y8_P4;
   else if (pxlDepth == 16)
       npDevVideo->subchannel[7].videoFromMemory.ImageScan[1].format =
           NV_VFM_FORMAT_COLOR_LE_R5G6B5_P2;
   else
       npDevVideo->subchannel[7].videoFromMemory.ImageScan[1].format =
           NV_VFM_FORMAT_COLOR_LE_X8R8G8B8;
//   npDevVideo->subchannel[7].videoFromMemory.ImageScan[1].notify = 0;

   while (videoFreeCount < 20)
       videoFreeCount = NvGetFreeCount(npDevVideo, 0);
   videoFreeCount -= 20;

   npDevVideo->subchannel[0].SetObject = NV_DD_DVD_SUBPICTURE;
   npDevVideo->subchannel[0].nv4DvdSubpicture.SetContextDmaNotifies =
       NV_DD_PIO_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   npDevVideo->subchannel[0].nv4DvdSubpicture.SetContextDmaOverlay =
       NV_DD_PIO_CONTEXT_DMA_FROM_VIDEO_MEMORY;
   npDevVideo->subchannel[0].nv4DvdSubpicture.SetContextDmaImageIn =
       NV_DD_PIO_CONTEXT_DMA_FROM_VIDEO_MEMORY;
   npDevVideo->subchannel[0].nv4DvdSubpicture.SetContextDmaImageOut =
       NV_DD_PIO_CONTEXT_DMA_TO_VIDEO_MEMORY;


   pDriverData->NvVideoFreeCount = (unsigned short)videoFreeCount;


    /*
     * Allocate psuedo-notifier memory
     *  we use <size> bytes starting at the highest 512 byte boundary inside of
     *  the 4k of persistent memory of the disp driver. This is so that we
     *  can set up a proper surface because of alignment restrictions.
     *  the caluclation is done in <addr>
     * Modify <size> only if you modify it in nv4ctxt.c also (I need some #defines)
     */
    {
        DWORD size =  16;
        DWORD addr = (pDriverData->VideoHeapEnd + 4096) & ~511;

#ifndef WINNT
        pDriverData->dwTMPseudoNotifierMem    = addr;
        pDriverData->dwTMPseudoNotifierOffset = pDriverData->dwTMPseudoNotifierMem - pDriverData->BaseAddress;
        memset ((void*)(pDriverData->dwTMPseudoNotifierOffset + pDriverData->BaseAddress),0,size);
#else
        pDriverData->dwTMPseudoNotifierOffset    = addr;
        pDriverData->dwTMPseudoNotifierMem = pDriverData->ppdev->pjScreen + pDriverData->dwTMPseudoNotifierOffset;
        memset ((void*)(pDriverData->dwTMPseudoNotifierMem),0,size);
#endif

        //DPF_LEVEL(NVDBG_LEVEL_INFO, "TM: Initial notifier = %08x",dwTMStageAddr);
        pDriverData->dwTMHead = pDriverData->dwTMStageAddr;
        pDriverData->dwTMTail = pDriverData->dwTMStageAddr;
        pDriverData->dwRenderedFrame = pDriverData->dwCurrentFrame = 0;
    }

   return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4loop.c ===
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4LOOP.C                                                         *
*   NV4 Inner loop include file. This file is referenced in nv4vx.c         *
*   ...it is also one mother of an #ifdef hell...                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 05/23/98 - created                      *
*                                                                           *
\***************************************************************************/

// macro        desc
// PROC_        Name of inner loop as string
// PROC         Name of inner loop
// VERTEX       Name of vertex macro
// DX6          defined for DX6 class triangles
// VXSIZE       size of a vertex in push buffer
// FOG          when defined it is either 1-ExpFog, 2-Exp2Fog or 3-LinearFog
// INDEXED      defined for indexed primitives
// FVF          defined for Flex vertices
// ANTIALIAS    defined when we want to capture geometry for antialiasing

//#define DPF_ON_ENTRY        // print entry point name
//#define BREAK_ON_ENTRY      // int3 on entry

/*
 * switches
 */

/*
 * constants & general macros
 */
#ifdef DX6
#define DRAW        nvglDx6TriangleDrawPrimitive
#define COUNT1      ((DWORD)((sizeDx6TriangleTLVertex * 1) + sizeDx6TriangleDrawPrimitive))
#define COUNT2      ((DWORD)((sizeDx6TriangleTLVertex * 2) + sizeDx6TriangleDrawPrimitive))
#define COUNT3      ((DWORD)((sizeDx6TriangleTLVertex * 3) + sizeDx6TriangleDrawPrimitive))
#define COUNT4      ((DWORD)((sizeDx6TriangleTLVertex * 4) + sizeDx6TriangleDrawPrimitive))
#define VC_MASK     7
#define VC_ADD      3
#else //!DX6
#define DRAW        nvglDx5TriangleDrawPrimitive
#define COUNT1      ((DWORD)((sizeDx5TriangleTLVertex * 1) + sizeDx5TriangleDrawPrimitive))
#define COUNT2      ((DWORD)((sizeDx5TriangleTLVertex * 2) + sizeDx5TriangleDrawPrimitive))
#define COUNT3      ((DWORD)((sizeDx5TriangleTLVertex * 3) + sizeDx5TriangleDrawPrimitive))
#define COUNT4      ((DWORD)((sizeDx5TriangleTLVertex * 4) + sizeDx5TriangleDrawPrimitive))
#define VC_MASK     15
#define VC_ADD      7
#endif //!DX6

#ifdef FVF
#define IF_FVF(x,y)  (x)
#define EMIT_VX(x,y) VERTEX (nvFifo, nvFreeCount, NV_DD_SPARE, (y), (x), fvfData, pTriangleState->dwUVOffset)
#else //!FVF
#define IF_FVF(x,y)  (y)
#define EMIT_VX(x,y) VERTEX (nvFifo, nvFreeCount, NV_DD_SPARE, (y), (x))
#endif //!FVF

/*
 * cull macro
 */
#define IF_NOT_CULLED_BEGIN(v0,v1,v2,cv) {             \
    DWORD _sx0  = v0 + 0;                              \
    DWORD _sy0  = v0 + 4;                              \
    DWORD _sx1  = v1 + 0;                              \
    DWORD _sy1  = v1 + 4;                              \
    DWORD _sx2  = v2 + 0;                              \
    DWORD _sy2  = v2 + 4;                              \
    float _dx10 = *(float*)_sx1 - *(float*)_sx0;       \
    float _dy10 = *(float*)_sy1 - *(float*)_sy0;       \
    float _dx20 = *(float*)_sx2 - *(float*)_sx0;       \
    float _dy20 = *(float*)_sy2 - *(float*)_sy0;       \
           cv   = _dx10*_dy20  - _dx20*_dy10;          \
    if (((*(DWORD*)&cv) ^ dwCullMask1) & dwCullMask2) {
#define IF_NOT_CULLED_END } }

/*
 * statistics macro
 */
#ifdef NV_STATS
#define UPDATE_STATS                                                    \
{                                                                       \
    extern DWORD dwPrimCount;                                           \
    extern DWORD dwPrimLegacyCount;                                     \
    extern DWORD dwPrimListCount;                                       \
    extern DWORD dwPrimStripCount;                                      \
    extern DWORD dwPrimFanCount;                                        \
                                                                        \
    dwPrimCount += nPrimCount;                                          \
    switch (dwStrides)                                                  \
    {                                                                   \
        case LEGACY_STRIDES: dwPrimLegacyCount += nPrimCount;           \
                             break;                                     \
        case LIST_STRIDES:   dwPrimListCount   += nPrimCount;           \
                             break;                                     \
        case STRIP_STRIDES:  dwPrimStripCount  += nPrimCount;           \
                             break;                                     \
        case FAN_STRIDES:    dwPrimFanCount    += nPrimCount;           \
                             break;                                     \
    }                                                                   \
}
#else
#define UPDATE_STATS
#endif


//////////////////////////////////////////////////////////////////////////////
// Entry Point
#ifdef INDEXED
#ifdef FVF
void PROC (DWORD nPrimCount,LPWORD pIndices,DWORD dwStrides,LPBYTE        pVertices ) {
#else //!FVF
void PROC (DWORD nPrimCount,LPWORD pIndices,DWORD dwStrides,LPD3DTLVERTEX pVertices) {
#endif //!FVF
#else //!INDEXED
#ifdef FVF
void PROC ( WORD nPrimCount,                DWORD dwStrides,LPBYTE        pVertices ) {
#else //!FVF
void PROC ( WORD nPrimCount,                DWORD dwStrides,LPD3DTLVERTEX pVertices) {
#endif //!FVF
#endif //!INDEXED

#ifdef ANTIALIAS
    UPDATE_STATS
#ifdef INDEXED
    nvAACapturePrimitive (nPrimCount,pIndices,dwStrides,(LPBYTE)pVertices);
    //aatodo - render edge
#else //!INDEXED
    nvAACapturePrimitive (nPrimCount,NULL    ,dwStrides,(LPBYTE)pVertices);
    //aatodo - render edge
#endif
#else //!ANTIALIAS

//////////////////////////////////////////////////////////////////////////////
// Common code
    DWORD v0,v1,v2;         // vertices
    DWORD dwCullMask1;
    DWORD dwCullMask2;
    float dwCullValue;

#ifdef FVF
    DWORD dwVertexStride = fvfData.dwVertexStride;
    PNVD3DMULTITEXTURESTATE pTriangleState
        = (PNVD3DMULTITEXTURESTATE)&pCurrentContext->mtsState;
#endif //FVF

#ifdef  SPEC_HACK
#ifndef DX6
    DWORD   dwSpec0, dwSpec1, dwSpec2;
    DWORD   dwNoSpecCount     = pCurrentContext->ctxInnerLoop.dwNoSpecularTriangleCount;
    DWORD   dwSpecularState   = pCurrentContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE];
    DWORD   dwSpecularCurrent = pCurrentContext->ctxInnerLoop.dwCurrentSpecularState;
    DWORD   dwBlend           = pCurrentContext->ctxInnerLoop.dwCurrentBlend;
#endif  // !DX6
#endif  // SPEC_HACK

    UPDATE_STATS

#ifdef DPF_ON_ENTRY
    DPF (PROC_);
    DPF ("  dwStrides = %08x",dwStrides);
#endif
#ifdef BREAK_ON_ENTRY
    __asm int 3;
#endif

    dwCullMask1 = (pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
    dwCullMask2 = (pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

    switch (dwStrides)
    {
//////////////////////////////////////////////////////////////////////////////
// List
//////////////////////////////////////////////////////////////////////////////
        case LIST_STRIDES:
        case LEGACY_STRIDES:
        {
#ifdef INDEXED
            DWORD dwVertexSNBits = (dwVertexSN++) << 16;
#else //!INDEXED
            /*
             * setup vertices (non-indexed)
             */
            v0 = ((DWORD)pVertices) + 0 * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
            v1 = ((DWORD)pVertices) + 1 * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
            v2 = ((DWORD)pVertices) + 2 * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
#ifdef FVF
            dwVertexStride *= 3;
#endif //!FVF
#endif //!INDEXED

            dwStrides &= 255; // strip off uninteresting strip info

            while (nPrimCount) 
            {
#ifdef INDEXED
                DWORD i0,i1,i2;
                /*
                 * fetch indices
                 */
                i0  = ((DWORD*)pIndices)[0];
                i1  = i0 >> 16;
                i0 &= 0xffff;
                i2  = (( WORD*)pIndices)[2];
#endif //INDEXED

#ifdef INDEXED
                /*
                 * fetch vertices
                 */
                v0 = ((DWORD)pVertices) + i0 * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
                v1 = ((DWORD)pVertices) + i1 * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
                v2 = ((DWORD)pVertices) + i2 * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
#endif //INDEXED

                /*
                 * cull triangle
                 */
                IF_NOT_CULLED_BEGIN(v0,v1,v2,dwCullValue)
#ifdef INDEXED
                    DWORD x0,x1,x2,tmp;
#endif //INDEXED

#ifdef  SPEC_HACK   // check for contributing specular highlight
#ifndef DX6         // when using the DX5 class only.
#ifdef  FVF
                    dwSpec0 = *(DWORD*)((v0 & fvfData.dwSpecularMask) + fvfData.dwSpecularOffset);
                    dwSpec1 = *(DWORD*)((v1 & fvfData.dwSpecularMask) + fvfData.dwSpecularOffset);
                    dwSpec2 = *(DWORD*)((v2 & fvfData.dwSpecularMask) + fvfData.dwSpecularOffset);
#else   !FVF
                    dwSpec0 = (*(DWORD*)(v0 + 20));
                    dwSpec1 = (*(DWORD*)(v1 + 20));
                    dwSpec2 = (*(DWORD*)(v2 + 20));
#endif  // !FVF
                    SPEC_CHECK(dwSpecularState, dwSpecularCurrent, dwSpec0, dwSpec1, dwSpec2, dwNoSpecCount, dwBlend);
#endif  // !DX6
#endif  // SPEC_HACK

                    /*
                     * Send tri
                     */
                    while (nvFreeCount < COUNT3) 
                        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, COUNT3);
#ifdef INDEXED
                // vertex 0
                    tmp = i0 | dwVertexSNBits;
                    x0  = i0 & VC_MASK;
                    if (tmp != dwVertexCache[x0]) { // cache miss
                        dwVertexCache[x0] = tmp;
                        EMIT_VX (v0,x0);
                    }
                // vertex 1
                    tmp = i1 | dwVertexSNBits;
                    x1  = i1 & VC_MASK;
                    while (x1 == x0) x1 = (x1+VC_ADD) & VC_MASK;
                    if (tmp != dwVertexCache[x1]) { // cache miss
                        dwVertexCache[x1] = tmp;
                        EMIT_VX (v1,x1);
                    }
                // vertex 2
                    tmp = i2 | dwVertexSNBits;
                    x2  = i2 & VC_MASK;
                    while ((x2 == x1)||(x2 == x0)) x2 = (x2+VC_ADD) & VC_MASK;
                    if (tmp != dwVertexCache[x2]) { // cache miss
                        dwVertexCache[x2] = tmp;
                        EMIT_VX (v2,x2);
                    }
                    DRAW    (nvFifo, nvFreeCount, NV_DD_SPARE, 0, ((x2<<8)|(x1<<4)|x0));
#else //!INDEXED
                    EMIT_VX (v0,0);
                    EMIT_VX (v1,1);
                    EMIT_VX (v2,2);
                    DRAW    (nvFifo, nvFreeCount, NV_DD_SPARE, 0, 0x210);
#endif //!INDEXED
                IF_NOT_CULLED_END

                /*
                 * next triangle
                 */
                nPrimCount--;

#ifdef INDEXED
                pIndices += dwStrides;
#else //!INDEXED
                v0 += IF_FVF(dwVertexStride,3 * sizeof(D3DTLVERTEX));
                v1 += IF_FVF(dwVertexStride,3 * sizeof(D3DTLVERTEX));
                v2 += IF_FVF(dwVertexStride,3 * sizeof(D3DTLVERTEX));
#endif //!INDEXED
                /*
                 * The following code is only enabled for the DEBUG driver build.
                 * Flush each triangle.
                 */            
                dbgFlushTriangle(pCurrentContext);
            }
            break;
        }
//////////////////////////////////////////////////////////////////////////////
// Strip
//////////////////////////////////////////////////////////////////////////////
        case STRIP_STRIDES:
        {
            static DWORD table[6] = { 0x210,0x201,0x102,0x120,0x021,0x012 };
            DWORD funky  = 0;
            DWORD launch = 0x210;
            DWORD place  = 0x808182;

#ifdef INDEXED
            v0 = ((DWORD)pVertices) + ((WORD*)pIndices)[0] * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
            v1 = ((DWORD)pVertices) + ((WORD*)pIndices)[1] * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
            pIndices += 2;
#else //!INDEXED
            /*
             * setup vertices (non-indexed)
             */
            v0 = ((DWORD)pVertices) + 0 * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
            v1 = ((DWORD)pVertices) + 1 * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
            ((DWORD)pVertices) += 2 * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
#endif //!INDEXED

#ifdef  SPEC_HACK   // check for contributing specular highlight
#ifndef DX6         // when using the DX5 class only.
#ifdef  FVF
            dwSpec0 = *(DWORD*)((v0 & fvfData.dwSpecularMask) + fvfData.dwSpecularOffset);
            dwSpec1 = *(DWORD*)((v1 & fvfData.dwSpecularMask) + fvfData.dwSpecularOffset);
#else   !FVF
            dwSpec0 = (*(DWORD*)(v0 + 20));
            dwSpec1 = (*(DWORD*)(v1 + 20));
#endif  // !FVF
#endif  // !DX6
#endif  // SPEC_HACK

            while (nPrimCount) 
            {
#ifdef INDEXED
                v2 = ((DWORD)pVertices) + ((WORD*)pIndices)[0] * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
                pIndices++;
#else //!INDEXED
                v2 = ((DWORD)pVertices);
                ((DWORD)pVertices) += IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
#endif //!INDEXED
#ifdef  SPEC_HACK   // check for contributing specular highlight
#ifndef DX6         // when using the DX5 class only.
#ifdef  FVF
                    dwSpec2 = *(DWORD*)((v2 & fvfData.dwSpecularMask) + fvfData.dwSpecularOffset);
#else   !FVF
                    dwSpec2 = (*(DWORD*)(v2 + 20));
#endif  // !FVF
#endif  // !DX6
#endif  // SPEC_HACK

                /*
                 * cull triangle
                 */
                IF_NOT_CULLED_BEGIN(v0,v1,v2,dwCullValue)
                    DWORD p;

#ifdef  SPEC_HACK   // check for contributing specular highlight
#ifndef DX6         // when using the DX5 class only.
                    SPEC_CHECK(dwSpecularState, dwSpecularCurrent, dwSpec0, dwSpec1, dwSpec2, dwNoSpecCount, dwBlend);
#endif  // !DX6
#endif  // SPEC_HACK

                    /*
                     * Send tri
                     */
                    if ((place & 0x800000) == 0x800000) {
                        p      = (place >> 16) & 127;
                        place &= ~0x800000;
                        while (nvFreeCount < COUNT1) 
                            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, COUNT1);
                        EMIT_VX (v0,p);
                    }
                    if ((place & 0x008000) == 0x008000) {
                        p      = (place >> 8) & 127;
                        place &= ~0x008000;
                        while (nvFreeCount < COUNT1) 
                            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, COUNT1);
                        EMIT_VX (v1,p);
                    }
                    p      = place & 127;
                    place &= ~0x000080;
                    while (nvFreeCount < COUNT1) 
                        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, COUNT1);
                    EMIT_VX (v2,p);
                    DRAW (nvFifo, nvFreeCount, NV_DD_SPARE, 0, launch);
                IF_NOT_CULLED_END

                /*
                 * next triangle
                 */
                v0      = v1; 
                v1      = v2;
#ifdef  SPEC_HACK   // check for contributing specular highlight
#ifndef DX6         // when using the DX5 class only.
                dwSpec0 = dwSpec1;
                dwSpec1 = dwSpec2;
#endif  // !DX6
#endif  // SPEC_HACK
                {
                    DWORD x = place & 0x7f;
                    if (x == 2) x = 0x80; else x+=0x81;
                    place = (place<<8) | x;
                }
                funky        = (funky == 5) ? 0 : (funky + 1);
                launch       = table[funky];
                dwCullMask1 ^= 0x80000000;
                nPrimCount--;

                /*
                 * The following code is only enabled for the DEBUG driver build.
                 * Flush each triangle.
                 */            
                dbgFlushTriangle(pCurrentContext);
            }
            break;
        }
//////////////////////////////////////////////////////////////////////////////
// Fan
//////////////////////////////////////////////////////////////////////////////
        case FAN_STRIDES:
        {
            DWORD place  = 0x8182;
            DWORD launch = 0x210;

#ifdef INDEXED
            v0 = ((DWORD)pVertices) + ((WORD*)pIndices)[0] * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
            v1 = ((DWORD)pVertices) + ((WORD*)pIndices)[1] * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
            pIndices += 2;
#else //!INDEXED
            /*
             * setup vertices (non-indexed)
             */
            v0 = ((DWORD)pVertices) + 0 * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
            v1 = ((DWORD)pVertices) + 1 * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
            ((DWORD)pVertices) += 2 * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
#endif //!INDEXED
#ifdef  SPEC_HACK   // check for contributing specular highlight
#ifndef DX6         // when using the DX5 class only.
#ifdef  FVF
            dwSpec0 = *(DWORD*)((v0 & fvfData.dwSpecularMask) + fvfData.dwSpecularOffset);
            dwSpec1 = *(DWORD*)((v1 & fvfData.dwSpecularMask) + fvfData.dwSpecularOffset);
#else   !FVF
            dwSpec0 = (*(DWORD*)(v0 + 20));
            dwSpec1 = (*(DWORD*)(v1 + 20));
#endif  // !FVF
#endif  // !DX6
#endif  // SPEC_HACK

            while (nvFreeCount < COUNT1)
                nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, COUNT1);
            EMIT_VX (v0,0);

            while (nPrimCount) 
            {
#ifdef INDEXED
                v2 = ((DWORD)pVertices) + ((WORD*)pIndices)[0] * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
                pIndices++;
#else //!INDEXED
                v2 = ((DWORD)pVertices);
                ((DWORD)pVertices) += IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
#endif //!INDEXED
#ifdef  SPEC_HACK   // check for contributing specular highlight
#ifndef DX6         // when using the DX5 class only.
#ifdef  FVF
                dwSpec2 = *(DWORD*)((v2 & fvfData.dwSpecularMask) + fvfData.dwSpecularOffset);
#else   !FVF
                dwSpec2 = (*(DWORD*)(v2 + 20));
#endif  // !FVF
#endif  // !DX6
#endif  // SPEC_HACK

                /*
                 * cull triangle
                 */
                IF_NOT_CULLED_BEGIN(v0,v1,v2,dwCullValue)
                    DWORD p;

#ifdef  SPEC_HACK   // check for contributing specular highlight
#ifndef DX6         // when using the DX5 class only.
                    SPEC_CHECK(dwSpecularState, dwSpecularCurrent, dwSpec0, dwSpec1, dwSpec2, dwNoSpecCount, dwBlend);
#endif  // !DX6
#endif  // SPEC_HACK

                    /*
                     * Send tri
                     */
                    if ((place & 0x008000) == 0x008000) {
                        p      = (place >> 8) & 127;
                        place &= ~0x008000;
                        while (nvFreeCount < COUNT1) 
                            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, COUNT1);
                        EMIT_VX (v1,p);
                    }
                    p      = place & 127;
                    place &= ~0x000080;
                    while (nvFreeCount < COUNT1) 
                        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, COUNT1);
                    EMIT_VX (v2,p);
                    DRAW (nvFifo, nvFreeCount, NV_DD_SPARE, 0, launch);
                IF_NOT_CULLED_END

                /*
                 * next triangle
                 */
                v1 ^= v2;
                v2 ^= v1;
                v1 ^= v2;

#ifdef  SPEC_HACK   // check for contributing specular highlight
#ifndef DX6         // when using the DX5 class only.
#ifdef  FVF
                dwSpec1 = *(DWORD*)((v1 & fvfData.dwSpecularMask) + fvfData.dwSpecularOffset);
#else   !FVF
                dwSpec1 = (*(DWORD*)(v1 + 20));
#endif  // !FVF
#endif  // !DX6
#endif  // SPEC_HACK
                {
                    DWORD x = place & 0x7f;
                    x      ^= 0x81 ^ 2; // toggle 1 <-> 2 & or 0x80
                    place   = (place<<8) | x;
                }
                launch ^= 0x210 ^ 0x120;
                nPrimCount--;

                /*
                 * The following code is only enabled for the DEBUG driver build.
                 * Flush each triangle.
                 */            
                dbgFlushTriangle(pCurrentContext);
            }

            break;
        }
    }

#ifdef  SPEC_HACK   // check for contributing specular highlight
#ifndef DX6         // when using the DX5 class only.
     pCurrentContext->ctxInnerLoop.dwNoSpecularTriangleCount = dwNoSpecCount;
     pCurrentContext->ctxInnerLoop.dwCurrentSpecularState    = dwSpecularCurrent;
     pCurrentContext->ctxInnerLoop.dwCurrentBlend            = dwBlend;
#endif  // !DX6
#endif  // SPEC_HACK

#endif //!ANTIALIAS
}

#undef IF_NOT_CULLED_BEGIN
#undef IF_NOT_CULLED_END
#undef VC_ADD
#undef VC_MASK
#undef IF_FVF
#undef EMIT_VX
#undef COUNT4
#undef COUNT3
#undef COUNT2
#undef COUNT1
#undef DRAW
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4mem.c ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4MEM.C                                                          *
*   NVIDIA Fast memory copy loops - copyright strictly enforced             *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 11/05/98 - Created                      *
*                                                                           *
\***************************************************************************/
#include <windows.h>
#include "ddrvmem.h"
#include "nvd3ddrv.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv4dreg.h"
#include "nv3ddbg.h"
#include "nv4vxmac.h"
#include "nvheap.h"
#include "..\x86\x86.h"

/*
 * local macros
 */
#define movaps_r_rm8(r,rm,ofs)      __asm _emit 0x0f __asm _emit 0x28 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define movaps_rm8_r(rm,ofs,r)      __asm _emit 0x0f __asm _emit 0x29 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define movups_r_rm8(r,rm,ofs)      __asm _emit 0x0f __asm _emit 0x10 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define movups_rm8_r(rm,ofs,r)      __asm _emit 0x0f __asm _emit 0x11 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)

/*
 * nvMemCopy1
 *
 * copies src to dest using byte atoms
 */
__inline void nvMemCopy1
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount
)
{
    while (dwCount)
    {
        *(BYTE*)dwDest = *(BYTE*)dwSrc;
        dwSrc  ++;
        dwDest ++;
        dwCount--;
    }
}

/*
 * nvMemCopy4
 *
 * copies src to dest using dword atoms.
 */
__inline void nvMemCopy4
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount   // in dwords
)
{
    while (dwCount)
    {
        *(DWORD*)dwDest = *(DWORD*)dwSrc;
        dwSrc  += 4;
        dwDest += 4;
        dwCount--;
    }
}

/*
 * nvMemCopy16
 *
 * copies src to dest using 4*dword atoms (if possible).
 */
__inline void nvMemCopy16
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount
)
{
    if (global.dwCPUFeatureSet & FS_KATMAI)
    {
        if (dwSrc & 15)
        {
            if (dwDest & 15)
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
            mc16_11: movups_r_rm8 (rXMM0,rmIND8(rEBX),0)
                     add ebx,16
                     movups_rm8_r (rmIND8(rEDX),rXMM0,0)
                     add edx,16
                     dec ecx
                    jnz mc16_11
                }
            }
            else
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
            mc16_12: movups_r_rm8 (rXMM0,rmIND8(rEBX),0)
                     add ebx,16
                     movaps_rm8_r (rmIND8(rEDX),rXMM0,0)
                     add edx,16
                     dec ecx
                    jnz mc16_12
                }
            }
        }
        else
        {
            if (dwDest & 15)
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
            mc16_13: movaps_r_rm8 (rXMM0,rmIND8(rEBX),0)
                     add ebx,16
                     movups_rm8_r (rmIND8(rEDX),rXMM0,0)
                     add edx,16
                     dec ecx
                    jnz mc16_13
                }
            }
            else
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
            mc16_14: movaps_r_rm8 (rXMM0,rmIND8(rEBX),0)
                     add ebx,16
                     movaps_rm8_r (rmIND8(rEDX),rXMM0,0)
                     add edx,16
                     dec ecx
                    jnz mc16_14
                }
            }
        }
    }
#ifndef WINNT  // BUGBUG - WHY NO WORKY IN NT5 BUILD?
    else if (global.dwCPUFeatureSet & FS_MMX)
    {
        __asm
        {
            mov ebx,[dwSrc]
            mov edx,[dwDest]
            mov ecx,[dwCount]
mc16_2:      movq mm0,[ebx]
             movq mm1,[ebx+8]
             add ebx,16
             movq [edx],mm0
             movq [edx+8],mm1
             add edx,16
             dec ecx
            jnz mc16_2
            emms
        }
    }
#endif  // !WINNT
    else
    {
        nvMemCopy4 (dwDest,dwSrc,dwCount*4);
    }
}

/*
 * nvMemCopy64
 *
 * copies src to dest using 16*dword atoms (if possible).
 */
__inline void nvMemCopy64
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount   // in dwords
)
{
    if (global.dwCPUFeatureSet & FS_KATMAI)
    {
        if (dwSrc & 15)
        {
            if (dwDest & 15)
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
        mc64_11:     movups_r_rm8 (rXMM0,rmIND8(rEBX), 0)
                     movups_r_rm8 (rXMM1,rmIND8(rEBX),16)
                     movups_r_rm8 (rXMM2,rmIND8(rEBX),32)
                     movups_r_rm8 (rXMM3,rmIND8(rEBX),48)
                     add ebx,64
                     movups_rm8_r (rmIND8(rEDX), 0,rXMM0)
                     movups_rm8_r (rmIND8(rEDX),16,rXMM1)
                     movups_rm8_r (rmIND8(rEDX),32,rXMM2)
                     movups_rm8_r (rmIND8(rEDX),48,rXMM3)
                     add edx,64
                     dec ecx
                    jnz mc64_11
                }
            }
            else
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
        mc64_12:     movups_r_rm8 (rXMM0,rmIND8(rEBX), 0)
                     movups_r_rm8 (rXMM1,rmIND8(rEBX),16)
                     movups_r_rm8 (rXMM2,rmIND8(rEBX),32)
                     movups_r_rm8 (rXMM3,rmIND8(rEBX),48)
                     add ebx,64
                     movaps_rm8_r (rmIND8(rEDX), 0,rXMM0)
                     movaps_rm8_r (rmIND8(rEDX),16,rXMM1)
                     movaps_rm8_r (rmIND8(rEDX),32,rXMM2)
                     movaps_rm8_r (rmIND8(rEDX),48,rXMM3)
                     add edx,64
                     dec ecx
                    jnz mc64_12
                }
            }
        }
        else
        {
            if (dwDest & 15)
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
        mc64_13:     movaps_r_rm8 (rXMM0,rmIND8(rEBX), 0)
                     movaps_r_rm8 (rXMM1,rmIND8(rEBX),16)
                     movaps_r_rm8 (rXMM2,rmIND8(rEBX),32)
                     movaps_r_rm8 (rXMM3,rmIND8(rEBX),48)
                     add ebx,64
                     movups_rm8_r (rmIND8(rEDX), 0,rXMM0)
                     movups_rm8_r (rmIND8(rEDX),16,rXMM1)
                     movups_rm8_r (rmIND8(rEDX),32,rXMM2)
                     movups_rm8_r (rmIND8(rEDX),48,rXMM3)
                     add edx,64
                     dec ecx
                    jnz mc64_13
                }
            }
            else
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
        mc64_14:     movaps_r_rm8 (rXMM0,rmIND8(rEBX), 0)
                     movaps_r_rm8 (rXMM1,rmIND8(rEBX),16)
                     movaps_r_rm8 (rXMM2,rmIND8(rEBX),32)
                     movaps_r_rm8 (rXMM3,rmIND8(rEBX),48)
                     add ebx,64
                     movaps_rm8_r (rmIND8(rEDX), 0,rXMM0)
                     movaps_rm8_r (rmIND8(rEDX),16,rXMM1)
                     movaps_rm8_r (rmIND8(rEDX),32,rXMM2)
                     movaps_rm8_r (rmIND8(rEDX),48,rXMM3)
                     add edx,64
                     dec ecx
                    jnz mc64_14
                }
            }
        }
    }
#ifndef WINNT  // BUGBUG - WHY NO WORKY IN NT5 BUILD?
    else if (global.dwCPUFeatureSet & FS_MMX)
    {
        __asm
        {
            mov ebx,[dwSrc]
            mov edx,[dwDest]
            mov ecx,[dwCount]
mc64_2:      movq mm0,[ebx+ 0]
             movq mm1,[ebx+ 8]
             movq mm2,[ebx+16]
             movq mm3,[ebx+24]
             movq mm4,[ebx+32]
             movq mm5,[ebx+40]
             movq mm6,[ebx+48]
             movq mm7,[ebx+56]
             add ebx,64
             movq [edx+ 0],mm0
             movq [edx+ 8],mm1
             movq [edx+16],mm2
             movq [edx+24],mm3
             movq [edx+32],mm4
             movq [edx+40],mm5
             movq [edx+48],mm6
             movq [edx+56],mm7
             add edx,64
             dec ecx
            jnz mc64_2
            emms
        }
    }
#endif  // !WINNT
    else
    {
        nvMemCopy4 (dwDest,dwSrc,dwCount*16);
    }
}

/*
 * nvMemCopy
 *
 * copy memory as fast as we can
 */
void nvMemCopy
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount,
    DWORD dwFlags
)
{
    /*
     * small block optimizations
     *  less than 32 bytes gets unaligned dword accesses followed by some bytes (normal memcpy)
     *  less than 128 bytes and caller does not care for alignment
     */
    if ( (dwCount < 32)
     || ((dwCount < 128) && (dwFlags == NV_MEMCOPY_DONTCARE)))
    {
        memcpy ((void*)dwDest,(void*)dwSrc,dwCount);
        return;
    }

    /*
     * align source or dest depending on flags
     */
    {
        DWORD dwNum = (dwFlags & NV_MEMCOPY_WANTSRCALIGNED)
                    ? (dwSrc  & 15)
                    : (dwDest & 15);

        if (dwCount >= 4)
        {
            /*
             * align to 4
             */
            if (dwNum & 3)
            {
                DWORD dwTemp = 4 - (dwNum & 3);
                nvMemCopy1 (dwDest,dwSrc,dwTemp);
                dwSrc   += dwTemp;
                dwDest  += dwTemp;
                dwCount -= dwTemp;
            }

            if (dwCount >= 16)
            {
                /*
                 * align to 16
                 */
                if (dwNum & 12)
                {
                    DWORD dwTemp = 16 - (dwNum & 12);
                    nvMemCopy4 (dwDest,dwSrc,dwTemp / 4);
                    dwSrc   += dwTemp;
                    dwDest  += dwTemp;
                    dwCount -= dwTemp;
                }
            }
        }
    }

    /*
     * copy remaining data
     */
    {
        DWORD dw64 = dwCount & 0xffffffc0;
        DWORD dw16 = dwCount & 0x00000030;
        DWORD dw4  = dwCount & 0x0000000c;
        DWORD dw1  = dwCount & 0x00000003;

        if (dw64)
        {
            nvMemCopy64 (dwDest,dwSrc,dw64 / 64);
            dwDest += dw64;
            dwSrc  += dw64;
        }
        if (dw16)
        {
            nvMemCopy16 (dwDest,dwSrc,dw16 / 16);
            dwDest += dw16;
            dwSrc  += dw16;
        }
        if (dw4)
        {
            nvMemCopy4 (dwDest,dwSrc,dw4 / 4);
            dwDest += dw4;
            dwSrc  += dw4;
        }
        if (dw1)
        {
            nvMemCopy1 (dwDest,dwSrc,dw1 / 1);
            dwDest += dw1;
            dwSrc  += dw1;
        }
    }
}

/*
 * nvMemTouch
 *
 * moves given data block to L1 cache if it fits - else is wastes time
 */
void nvMemTouch
(
    DWORD dwSrc,
    DWORD dwCount
)
{
    __asm
    {
        mov ecx,[dwCount]
        shr ecx,5
         jz mts

        mov ebx,[dwSrc]

    mtl: mov eax,[ebx]
         add ebx,32
         dec ecx
        jnz mtl

    mts:
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4mini.c ===
#ifdef  NV4
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4MINI.H                                                         *
* Hardware specific driver setup routines.                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman               01/31/98 - created.                     *
*                                                                           *
\***************************************************************************/
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "d3dinc.h"
#include "nv4dreg.h"
#include "nvd3dcap.h"
#include "nv3ddbg.h"
#include "nvtexfmt.h"

#ifdef  NVD3D_DX6
/*
 * Define the Z-Buffer/Stencil Buffer Formats supported.
 */
#define NV_NUM_ZBUFFER_FORMATS      3
typedef struct _def_zpixel_formats
{
    DWORD           dwNumZFormats;
    DDPIXELFORMAT   NvZBufferFormats[NV_NUM_ZBUFFER_FORMATS];
} ZPIXELFORMATS;
static  ZPIXELFORMATS   NvZPixelFormats =
{
    NV_NUM_ZBUFFER_FORMATS,
    {
        /*
         * 16 bit z buffer
         */
        {
            sizeof (DDPIXELFORMAT),                 // dwSize
            DDPF_ZBUFFER,                           // dwFlags
            0,                                      // dwFourCC (Not used)
            16,                                     // dwZBufferBitDepth
            0,                                      // dwStencilBitDepth
            0x0000FFFF,                             // dwZBitMask
            0x00000000,                             // dwStencilBitMask
            0x00000000                              // dwRGBZBitMask (Not used)
        },
        /*
         * 24 bit z-buffer, no stencil
         */
        {
            sizeof (DDPIXELFORMAT),                 // dwSize
            DDPF_ZBUFFER,                           // dwFlags
            0,                                      // dwFourCC (Not used)
            24,                                     // dwZBufferBitDepth
            0,                                      // dwStencilBitDepth
            0xFFFFFF00,                             // dwZBitMask
            0x00000000,                             // dwStencilBitMask
            0x00000000                              // dwRGBZBitMask (Not used)
        },
        /*
         * 24 bit z-buffer, 8 bit stencil
         */
        {
            sizeof (DDPIXELFORMAT),                 // dwSize
            DDPF_ZBUFFER | DDPF_STENCILBUFFER,      // dwFlags
            0,                                      // dwFourCC (Not used)
            32,                                     // dwZBufferBitDepth - This is so brain dead.  MS needs to learn consistency.
            8,                                      // dwStencilBitDepth
            0xFFFFFF00,                             // dwZBitMask
            0x000000FF,                             // dwStencilBitMask
            0x00000000                              // dwRGBZBitMask (Not used)
        }
    }
};
#endif  // NVD3D_DX6

/*
 * Read the current driver settings from the registry.
 */
void D3DReadRegistry
(
    void
)
{
    DWORD   dwSize;
    DWORD   dwType;
    DWORD   dwValue;
    HKEY    hKey;

    /*
     * Set the defaults first.
     */
    pDriverData->regD3DEnableBits1       = DEFAULT_FOG_TABLE
                                         | DEFAULT_ANTI_ALIAS_ENABLE
                                         | DEFAULT_USER_MIPMAPS
                                         | DEFAULT_VIDEO_TEXTURE
                                         | DEFAULT_NO_WAIT_4_VSYNC
                                         | DEFAULT_MIPMAP_DITHER_ENABLE
                                         | DEFAULT_CKCOMPATABILITY_ENABLE
                                         | DEFAULT_CONTROLTRAFFIC;
    pDriverData->regMipMapLevels         = DEFAULT_MIPMAP_LEVELS;
    pDriverData->regTexHeap              = DEFAULT_TEX_HEAP;
    pDriverData->regMinVideoTextureSize  = DEFAULT_MIN_VIDEO_TEX_SIZE;
    pDriverData->regD3DContextMax        = DEFAULT_D3D_CONTEXT_MAX;
    pDriverData->regD3DTextureMax        = DEFAULT_D3D_TEXTURE_MAX;
    pDriverData->regDmaPushBufferSizeMax = DEFAULT_PUSH_BUFFER_SIZE_MAX_PCI;
    pDriverData->regDmaMinPushCount      = DEFAULT_DMA_MIN_PUSH_COUNT_PCI;
    pDriverData->regTexelAlignment       = DEFAULT_TEXEL_ALIGNMENT;
    pDriverData->regLODBiasAdjust        = DEFAULT_LOD_BIAS_ADJUST;
    pDriverData->regAutoMipMapMethod     = DEFAULT_AUTO_MIPMAP_METHOD;
    pDriverData->regPal8TextureConvert   = DEFAULT_PAL8_TEXTURE_CONVERT;

    pDriverData->regD3DDx6Enable         = DEFAULT_DX6_ENABLE;

    pDriverData->regPreRenderLimit       = DEFAULT_PRERENDER_LIMIT;

#if 1
    pDriverData->regZPerspectiveEnable = NV054_CONTROL_Z_PERSPECTIVE_ENABLE_FALSE;
    pDriverData->regZFormat            = NV054_CONTROL_Z_FORMAT_FIXED;
#else
    pDriverData->regZPerspectiveEnable = NV054_CONTROL_Z_PERSPECTIVE_ENABLE_TRUE;
    pDriverData->regZFormat            = NV054_CONTROL_Z_FORMAT_FLOAT;
#endif

    pDriverData->regAAMethod           = DEFAULT_AAMETHOD;
    pDriverData->regValidateZMethod    = DEFAULT_VALIDATE_Z_METHOD;

    pDriverData->regColorkeyRef        = DEFAULT_CKREF;

    pDriverData->regAGPTexCutOff       = DEFAULT_AGPTEX_CUTOFF;


#ifndef WINNT // BUGBUG need to seperate Registry routines into seperate lib

    /*
     * Next try reading the overrides from the registry.
     */
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;

    /*
     * Try and open the Direct3D Registry Key.
     */
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, NV4D3D_APP_STRING, 0, KEY_QUERY_VALUE, &hKey) != ERROR_SUCCESS)
        hKey = 0;

    if (hKey)
    {

        if (RegQueryValueEx(hKey,
                            NVD3D_AGPTEXTURE_CUTOFF,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            pDriverData->regAGPTexCutOff = dwValue;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_ANTI_ALIAS_ENABLE_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            pDriverData->regD3DEnableBits1 &= ~REG_BIT1_ANTI_ALIAS_ENABLE;
            pDriverData->regD3DEnableBits1 |= (dwValue) ? REG_BIT1_ANTI_ALIAS_ENABLE : 0;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_AAMETHOD_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwValue < REG_AAMETHOD_MIN) dwValue = REG_AAMETHOD_MIN;
            if (dwValue > REG_AAMETHOD_MAX) dwValue = REG_AAMETHOD_MAX;
            pDriverData->regAAMethod = dwValue;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_MIPMAP_LEVELS_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            pDriverData->regMipMapLevels = dwValue;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_USER_MIPMAPS_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            pDriverData->regD3DEnableBits1 &= ~REG_BIT1_USER_MIPMAPS_ENABLE;
            pDriverData->regD3DEnableBits1 |= (dwValue) ? REG_BIT1_USER_MIPMAPS_ENABLE : 0;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_TEX_HEAP_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            if ((dwValue) && (dwValue >= NV_MIN_TEXTURE_HEAP_SIZE))
                pDriverData->regTexHeap = dwValue;
            else
                pDriverData->regTexHeap = NV_MIN_TEXTURE_HEAP_SIZE;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_VIDEO_TEXTURE_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            pDriverData->regD3DEnableBits1 &= ~REG_BIT1_VIDEO_TEXTURE_ENABLE;
            pDriverData->regD3DEnableBits1 |= (dwValue) ? REG_BIT1_VIDEO_TEXTURE_ENABLE : 0;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_NO_WAIT_4_VSYNC_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            pDriverData->regD3DEnableBits1 &= ~REG_BIT1_NO_WAIT_4_VSYNC;
            pDriverData->regD3DEnableBits1 |= (dwValue) ? REG_BIT1_NO_WAIT_4_VSYNC : 0;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_MIN_VIDEO_TEX_SIZE_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            pDriverData->regMinVideoTextureSize = dwValue;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_DMA_PUSH_BUFFER_SIZE_MAX_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwValue)
            {
                pDriverData->regDmaPushBufferSizeMax  = dwValue;
                pDriverData->regD3DEnableBits1       |= REG_BIT1_DMA_PUSH_SIZE_OVERRIDE;

            }
            else
            {
                pDriverData->regDmaPushBufferSizeMax  = DEFAULT_PUSH_BUFFER_SIZE_MAX_PCI;
                pDriverData->regD3DEnableBits1       &= ~REG_BIT1_DMA_PUSH_SIZE_OVERRIDE;
            }
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_DMA_MIN_PUSH_COUNT_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwValue)
            {
                pDriverData->regDmaMinPushCount  = dwValue;
                pDriverData->regD3DEnableBits1  |= REG_BIT1_DMA_PUSH_COUNT_OVERRIDE;
            }
            else
            {
                pDriverData->regDmaMinPushCount  = DEFAULT_DMA_MIN_PUSH_COUNT_PCI;
                pDriverData->regD3DEnableBits1  &= ~REG_BIT1_DMA_PUSH_COUNT_OVERRIDE;
            }

        }

        if (RegQueryValueEx(hKey,
                            NVD3D_FOG_TABLE_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            pDriverData->regD3DEnableBits1 &= ~REG_BIT1_FOG_TABLE_ENABLE;
            pDriverData->regD3DEnableBits1 |= (dwValue) ? REG_BIT1_FOG_TABLE_ENABLE : 0;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_CONTEXT_MAX_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            pDriverData->regD3DContextMax = dwValue;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_TEXTURE_MAX_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            pDriverData->regD3DTextureMax = dwValue;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_TEXEL_ALIGNMENT_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwValue > REG_TA_MAX)
                dwValue = DEFAULT_TEXEL_ALIGNMENT;
            pDriverData->regTexelAlignment = dwValue;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_LOD_BIAS_ADJUST_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwValue & 0xFFFFFF00)
                dwValue = DEFAULT_LOD_BIAS_ADJUST;
            pDriverData->regLODBiasAdjust = dwValue;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_AUTO_MIPMAP_METHOD_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwValue > REG_AMMM_MAX)
                dwValue = DEFAULT_AUTO_MIPMAP_METHOD;
            pDriverData->regAutoMipMapMethod = dwValue;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_MIPMAP_DITHER_ENABLE_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            pDriverData->regD3DEnableBits1 &= ~REG_BIT1_MIPMAP_DITHER_ENABLE;
            pDriverData->regD3DEnableBits1 |= (dwValue) ? REG_BIT1_MIPMAP_DITHER_ENABLE : 0;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_PAL8_TEXTURE_CONVERT_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwValue > REG_P8TC_MAX)
                dwValue = DEFAULT_PAL8_TEXTURE_CONVERT;
            pDriverData->regPal8TextureConvert = dwValue;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_DX6_ENABLE_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwValue > REG_DX6E_MAX)
                dwValue = DEFAULT_DX6_ENABLE;
            pDriverData->regD3DDx6Enable = dwValue;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_CKCOMPATABILITY_ENABLE_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwValue > REG_CKCE_MAX)
                dwValue = DEFAULT_CKCOMPATABILITY_ENABLE;
            pDriverData->regD3DEnableBits1 &= ~REG_BIT1_CKCOMPATABILITY_ENABLE;
            pDriverData->regD3DEnableBits1 |= (dwValue) ? REG_BIT1_CKCOMPATABILITY_ENABLE : 0;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_CONTROLTRAFFIC_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            pDriverData->regD3DEnableBits1 &= ~REG_BIT1_CONTROLTRAFFIC;
            pDriverData->regD3DEnableBits1 |= (dwValue) ? REG_BIT1_CONTROLTRAFFIC : 0;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_CKREF_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwValue > REG_CKREF_MAX)
                dwValue = DEFAULT_CKREF;
            pDriverData->regColorkeyRef = dwValue;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_PRERENDER_LIMIT_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwValue > REG_PRERENDER_MAX)
                dwValue = REG_PRERENDER_MAX;
            if (dwValue < REG_PRERENDER_MIN)
                dwValue = REG_PRERENDER_MIN;
            pDriverData->regPreRenderLimit = dwValue;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_VALIDATE_Z_METHOD_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwValue > REG_VZM_MAX)
                dwValue = DEFAULT_VALIDATE_Z_METHOD;
            pDriverData->regValidateZMethod = dwValue;
        }

        RegCloseKey(hKey);
    }
#endif // #ifndef WINNT
    if (pDriverData->regMipMapLevels == REG_MML_RESTRICTED)
    {
        pDriverData->regMipMapLevels = REG_MML_ENABLE;
        pDriverData->regD3DEnableBits1 |= REG_BIT1_RESTRICT_AUTO_MIPMAPS;
    }

    return;
}
/*
 * Read the current driver settings from the registry.
 */
void D3DModifyCapabilities
(
    D3DHAL_GLOBALDRIVERDATA  *pNvGlobal
)
{
    /*
     * Set the Fog Table Caps bit based on the registry setting.
     */
    pNvGlobal->hwCaps.dpcLineCaps.dwRasterCaps &= ~D3DPRASTERCAPS_FOGTABLE;
    pNvGlobal->hwCaps.dpcTriCaps.dwRasterCaps  &= ~D3DPRASTERCAPS_FOGTABLE;
    if (pDriverData->regD3DEnableBits1 & REG_BIT1_FOG_TABLE_ENABLE)
    {
        pNvGlobal->hwCaps.dpcLineCaps.dwRasterCaps |= D3DPRASTERCAPS_FOGTABLE;
        pNvGlobal->hwCaps.dpcTriCaps.dwRasterCaps  |= D3DPRASTERCAPS_FOGTABLE;
    }

    /*
     * Set anti-aliasing capabilities based on the registry setting.
     */
    pNvGlobal->hwCaps.dpcLineCaps.dwRasterCaps &= ~(D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT | D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT | D3DPRASTERCAPS_ANTIALIASEDGES);
    pNvGlobal->hwCaps.dpcTriCaps.dwRasterCaps  &= ~(D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT | D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT | D3DPRASTERCAPS_ANTIALIASEDGES);
    if (pDriverData->regD3DEnableBits1 & REG_BIT1_ANTI_ALIAS_ENABLE)
    {
        /* for now we only support scene aa
        pNvGlobal->hwCaps.dpcLineCaps.dwRasterCaps |= (D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT | D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT | D3DPRASTERCAPS_ANTIALIASEDGES);
        pNvGlobal->hwCaps.dpcTriCaps.dwRasterCaps  |= (D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT | D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT | D3DPRASTERCAPS_ANTIALIASEDGES);
        */
        pNvGlobal->hwCaps.dpcLineCaps.dwRasterCaps |= (D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT | D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT);
        pNvGlobal->hwCaps.dpcTriCaps.dwRasterCaps  |= (D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT | D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT);
    }

    /*
     * Remove 8bit texture format if the registry says so.
     */
    if (pDriverData->regPal8TextureConvert == REG_P8TC_NONE)

        pNvGlobal->dwNumTextureFormats -= NV_NUM_8BIT_TEXTURE_FORMATS;
    else if (pDriverData->regPal8TextureConvert == REG_P8TC_Y8ONLY)
        pNvGlobal->dwNumTextureFormats -= NV_NUM_8BIT_Y8ONLY_TEXTURE_FORMATS;

    /*
     * Set the DRAWPRIMITVES2 capability bit when driver is exporting DX6 capabilities.
     */
#ifdef  NVD3D_DX6
    pNvGlobal->hwCaps.dwDevCaps &= ~D3DDEVCAPS_DRAWPRIMITIVES2;
    if (pDriverData->regD3DDx6Enable)
        pNvGlobal->hwCaps.dwDevCaps |= D3DDEVCAPS_DRAWPRIMITIVES2;
#endif  // NVD3D_DX6

    return;
}
/*
 * Return D3D Driver Information.
 */
BOOL __stdcall D3DGetDriverInfo
(
    LPDDHAL_GETDRIVERINFODATA lpData
)
{
    DWORD               dwSize;

    /*
     * Is this an extended D3D Callback GUID?
     */
#ifdef  NVD3D_DX6
    /*
     * Is this an extended D3D Callback3 GUID?
     */
    if ((IsEqualIID(&lpData->guidInfo, &GUID_D3DCallbacks3))
     && (pDriverData->regD3DDx6Enable != REG_DX6E_DISABLE))
    {
        D3DHAL_CALLBACKS3   D3DCallbacks3;

        DPF_LEVEL(NVDBG_LEVEL_INFO, "D3DGetDriverInfo - Process GUID_D3DCallbacks3");
        memset(&D3DCallbacks3, 0, sizeof(D3DHAL_CALLBACKS3));
        dwSize               = min(lpData->dwExpectedSize, sizeof(D3DHAL_CALLBACKS3));
        lpData->dwActualSize = sizeof(D3DHAL_CALLBACKS3);
        D3DCallbacks3.dwSize = dwSize;

        /*
         * Export DX6 DrawPrimitives2 DDI callback.
         */
        D3DCallbacks3.dwFlags |= D3DHAL3_CB32_DRAWPRIMITIVES2;
        D3DCallbacks3.DrawPrimitives2 = DrawPrimitives2;

        /*
         * Export DX6 Mult-Texture state validation callback.
         */
        D3DCallbacks3.dwFlags |= D3DHAL3_CB32_VALIDATETEXTURESTAGESTATE;
        D3DCallbacks3.ValidateTextureStageState = nvValidateTextureStageState;

        /*
         * Export DX6 callback for clear Render target, Z-Buffer and Stencil Buffer.
         */
        D3DCallbacks3.dwFlags |= D3DHAL3_CB32_CLEAR2;
        D3DCallbacks3.Clear2 = Clear2;

        /*
         * Copy as much of the data as possible up to dwExpectedSize.
         */
        memcpy(lpData->lpvData, &D3DCallbacks3, dwSize);

        /*
         * Set successful return code.
         */
        lpData->ddRVal = DD_OK;
    }
    if ((IsEqualIID(&lpData->guidInfo, &GUID_D3DParseUnknownCommandCallback))
     && (pDriverData->regD3DDx6Enable != REG_DX6E_DISABLE))
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "D3DGetDriverInfo - Process GUID_D3DParseUnknownCommandCallback");

        /*
         * Get address of callback function.
         */
        fnD3DParseUnknownCommandCallback = lpData->lpvData;

        /*
         * Set successful return code.
         */
        lpData->ddRVal = DD_OK;
    }
    if ((IsEqualIID(&lpData->guidInfo, &GUID_ZPixelFormats))
     && (pDriverData->regD3DDx6Enable != REG_DX6E_DISABLE))
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "D3DGetDriverInfo - Process GUID_ZPixelFormats");

        /*
         * Return a pointer to the z-buffer format data.
         */
        dwSize = min(lpData->dwExpectedSize, sizeof(NvZPixelFormats));
        memcpy(lpData->lpvData, &NvZPixelFormats, dwSize);
        lpData->dwActualSize = dwSize;

        /*
         * Set successful return code.
         */
        lpData->ddRVal = DD_OK;
    }
#endif  // NVD3D_DX6

    if (IsEqualIID(&lpData->guidInfo, &GUID_D3DCallbacks2))
    {
        D3DHAL_CALLBACKS2   D3DCallbacks2;

        DPF_LEVEL(NVDBG_LEVEL_INFO, "D3DGetDriverInfo - Process GUID_D3DCallbacks2");
        memset(&D3DCallbacks2, 0, sizeof(D3DHAL_CALLBACKS2));
        dwSize               = min(lpData->dwExpectedSize, sizeof(D3DHAL_CALLBACKS2));
        lpData->dwActualSize = sizeof(D3DHAL_CALLBACKS2);
        D3DCallbacks2.dwSize = dwSize;

        /*
         * Always export the SetRenderTarget callback.
         */
        D3DCallbacks2.dwFlags = D3DHAL2_CB32_SETRENDERTARGET;
        D3DCallbacks2.SetRenderTarget = nvSetRenderTarget;

        /*
         * Always export the D3D Clear callback.
         */
#ifndef WINNT
        D3DCallbacks2.dwFlags |= D3DHAL2_CB32_CLEAR;
        D3DCallbacks2.Clear    = Clear32;

        /*
         * Always export the DrawPrimitive callbacks.
         */
        D3DCallbacks2.dwFlags |= D3DHAL2_CB32_DRAWONEPRIMITIVE
                              |  D3DHAL2_CB32_DRAWONEINDEXEDPRIMITIVE
                              |  D3DHAL2_CB32_DRAWPRIMITIVES;
        D3DCallbacks2.DrawOnePrimitive        = DrawOnePrimitive32;
        D3DCallbacks2.DrawOneIndexedPrimitive = DrawOneIndexedPrimitive32;
        D3DCallbacks2.DrawPrimitives          = DrawPrimitives32;
#endif // #ifdef WINNT

        /*
         * Copy as much of the data as possible up to dwExpectedSize.
         */
        memcpy(lpData->lpvData, &D3DCallbacks2, dwSize);

        /*
         * Set successful return code.
         */
        lpData->ddRVal = DD_OK;
    }

    if (IsEqualIID(&lpData->guidInfo, &GUID_D3DExtendedCaps))
    {
        D3DHAL_D3DEXTENDEDCAPS  D3DExtendedCaps;

        memset(&D3DExtendedCaps, 0, sizeof(D3DHAL_D3DEXTENDEDCAPS));
        dwSize                 = min(lpData->dwExpectedSize, sizeof(D3DHAL_D3DEXTENDEDCAPS));
        lpData->dwActualSize   = dwSize;
        D3DExtendedCaps.dwSize = dwSize;

        /*
         * Fill in the extended capabilities.
         *
         * Set supported texture min/max dimensions.
         */
        D3DExtendedCaps.dwMinTextureWidth  = 1;
        D3DExtendedCaps.dwMaxTextureWidth  = 2048;
        D3DExtendedCaps.dwMinTextureHeight = 1;
        D3DExtendedCaps.dwMaxTextureHeight = 2048;

        /*
         * Set supported stipple min/max dimensions.
         */
//        D3DExtendedCaps.dwMinStippleWidth  = 0;
//        D3DExtendedCaps.dwMaxStippleWidth  = 0;
//        D3DExtendedCaps.dwMinStippleHeight = 0;
//        D3DExtendedCaps.dwMaxStippleHeight = 0;

#ifdef  NVD3D_DX6
        if (pDriverData->regD3DDx6Enable != REG_DX6E_DISABLE)
        {
            D3DExtendedCaps.dwMaxTextureRepeat       = NV_CAPS_MAX_TEXTURE_REPEAT;
            D3DExtendedCaps.dwMaxTextureAspectRatio  = NV_CAPS_MAX_TEXTURE_ASPECT_RATIO;
            D3DExtendedCaps.dwMaxAnisotropy          = NV_CAPS_MAX_ANISOTROPY;
            D3DExtendedCaps.dvGuardBandLeft          = NV_CAPS_GUARD_BAND_LEFT;
            D3DExtendedCaps.dvGuardBandTop           = NV_CAPS_GUARD_BAND_TOP;
            D3DExtendedCaps.dvGuardBandRight         = NV_CAPS_GUARD_BAND_RIGHT;
            D3DExtendedCaps.dvGuardBandBottom        = NV_CAPS_GUARD_BAND_BOTTOM;
            D3DExtendedCaps.dvExtentsAdjust          = NV_CAPS_EXTENTS_ADJUST;
            D3DExtendedCaps.dwStencilCaps            = D3DSTENCILCAPS_KEEP
                                                     | D3DSTENCILCAPS_ZERO
                                                     | D3DSTENCILCAPS_REPLACE
                                                     | D3DSTENCILCAPS_INCRSAT
                                                     | D3DSTENCILCAPS_DECRSAT
                                                     | D3DSTENCILCAPS_INVERT
                                                     | D3DSTENCILCAPS_INCR
                                                     | D3DSTENCILCAPS_DECR;
            D3DExtendedCaps.dwFVFCaps                = NV_CAPS_FVF_CAPS
                                                     | D3DFVFCAPS_DONOTSTRIPELEMENTS;
            D3DExtendedCaps.dwTextureOpCaps          = D3DTEXOPCAPS_DISABLE
                                                     | D3DTEXOPCAPS_SELECTARG1
                                                     | D3DTEXOPCAPS_SELECTARG2
                                                     | D3DTEXOPCAPS_MODULATE
                                                     | D3DTEXOPCAPS_MODULATE2X
                                                     | D3DTEXOPCAPS_MODULATE4X
                                                     | D3DTEXOPCAPS_ADD
                                                     | D3DTEXOPCAPS_ADDSIGNED
                                                     | D3DTEXOPCAPS_ADDSIGNED2X
                                                     | D3DTEXOPCAPS_ADDSMOOTH
                                                     | D3DTEXOPCAPS_SUBTRACT
                                                     | D3DTEXOPCAPS_BLENDDIFFUSEALPHA
                                                     | D3DTEXOPCAPS_BLENDTEXTUREALPHA
                                                     | D3DTEXOPCAPS_BLENDFACTORALPHA
                                                     | D3DTEXOPCAPS_BLENDTEXTUREALPHAPM
                                                     | D3DTEXOPCAPS_BLENDCURRENTALPHA
                                                     | D3DTEXOPCAPS_PREMODULATE
                                                     | D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR
                                                     | D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA
                                                     | D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR
                                                     | D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA;
            D3DExtendedCaps.wMaxTextureBlendStages   = NV_CAPS_MAX_TEXTURE_BLEND_STATES;
            D3DExtendedCaps.wMaxSimultaneousTextures = NV_CAPS_MAX_SIMULTANEOUS_TEXTURES;
        }
#endif  // NVD3D_DX6

        /*
         * Copy as much of the data as possible up to dwExpectedSize.
         */
        memcpy(lpData->lpvData, &D3DExtendedCaps, dwSize);

        /*
         * Set successful return code.
         */
        lpData->ddRVal = DD_OK;
    }

    /*
     * Return successfully.
     */
    return (TRUE);
}
#endif  // NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4mip.c ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4MIP.C                                                          *
*   Mipmapping routines.                                                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 04/20/98 - wrote it                     *
*                                                                           *
\***************************************************************************/
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv4dreg.h"
#include "nv3ddbg.h"
#include "nv4vxmac.h"

static int nvMipMapTable[64] = {
// make, copy idx for 1, copy idx for 0
    0, 0, 2, -1, // 0 = 00 00  ....
    0, 0, 1, -1, // 1 = 10 00  0...
    0, 1, 0, -1, // 2 = 01 00  .0..
    1, 0, 2, -1, // 3 = 11 00  1...   bottom
    0, 2, 3, -1, // 4 = 00 10  ..0.
    0, 2, 1, -1, // 5 = 10 10  ..1.   left
    1, 1, 3, -1, // 6 = 01 10  .1..   equal - look at error
    1, 0, 3, -1, // 7 = 11 10  2...
    0, 3, 0, -1, // 8 = 00 01  ...0
    1, 3, 1, -1, // 9 = 10 01  ...1   equal - look at error
    1, 1, 2, -1, // a = 01 01  .2..   right
    1, 3, 2, -1, // b = 11 01  ...2
    0, 2, 0, -1, // c = 00 11  ..2.   top
    1, 0, 1, -1, // d = 10 11  3...
    1, 1, 0, -1, // e = 01 11  .3..
    1, 2, 0, -1, // f = 11 11  ..3.
};

BYTE  nvAutoMipPush[256];

#ifdef NV_TEX2

extern BYTE nvTexelScratchBuffer[8192];
DWORD nvTextureCalcMipMapSize (DWORD dwLogU,DWORD dwLogV,DWORD dwMipMapLevels);
DWORD _key;

typedef void (*NVCOMBINETEXELFPTR)(DWORD);

/****************************************************************************/
/* 16 bpp                                                                   */
/****************************************************************************/

/*
 * x1r5g5b5 no color key
 */
void nvCombineTexelsX1R5G5B5
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD REDBLU = 0x7c1f;
        DWORD GRN    = 0x03e0;
        DWORD a,b,c,d;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);
        b = a >> 16;
        c = *(DWORD*)(src+4);
        d = c >> 16;

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & GRN   ) + (b & GRN   ) + (c & GRN   ) + (d & GRN   )) >> 2) & GRN   ;

        *(WORD*)dst = (WORD)(rb|ag);

        src   += 8;
        dst   += 2;
        count -= 4;
    }
}

/*
 * a1r5g5b5 no color key
 */
void nvCombineTexelsA1R5G5B5
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD t00 = *(WORD*)(src+0);
        DWORD t01 = *(WORD*)(src+2);
        DWORD t10 = *(WORD*)(src+4);
        DWORD t11 = *(WORD*)(src+6);

        DWORD alp = ((t00 & 0x8000) >> 13)
                  | ((t01 & 0x8000) >> 12)
                  | ((t10 & 0x8000) >> 11)
                  | ((t11 & 0x8000) >> 10);

        *(WORD*)dst = *(WORD*)(src+(nvMipMapTable[alp + 1 + nvMipMapTable[alp]] << 1));

        src   += 8;
        dst   += 2;
        count -= 4;
    }
}

/*
 * a4r4g4b4 no color key
 */
void nvCombineTexelsA4R4G4B4
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD REDBLU = 0x0f0f;
        DWORD ALPGRN = 0xf0f0;
        DWORD a,b,c,d;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);
        b = a >> 16;
        c = *(DWORD*)(src+4);
        d = c >> 16;

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & ALPGRN) + (b & ALPGRN) + (c & ALPGRN) + (d & ALPGRN)) >> 2) & ALPGRN;

        *(WORD*)dst = (WORD)(rb|ag);

        src   += 8;
        dst   += 2;
        count -= 4;
    }
}

/*
 * r5g6b5 no color key
 */
void nvCombineTexelsR5G6B5
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD REDBLU = 0xf81f;
        DWORD GRN    = 0x07e0;
        DWORD a,b,c,d;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);
        b = a >> 16;
        c = *(DWORD*)(src+4);
        d = c >> 16;

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & GRN   ) + (b & GRN   ) + (c & GRN   ) + (d & GRN   )) >> 2) & GRN   ;

        *(WORD*)dst = (WORD)(rb|ag);

        src   += 8;
        dst   += 2;
        count -= 4;
    }
}

/*
 * y16 no color key
 */
void nvCombineTexelsY16CK
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD t00 = *(WORD*)(src+0);
        DWORD t01 = *(WORD*)(src+2);
        DWORD t10 = *(WORD*)(src+4);
        DWORD t11 = *(WORD*)(src+6);

        DWORD alp = ((t00 != _key) ?  4 : 0)
                  | ((t01 != _key) ?  8 : 0)
                  | ((t10 != _key) ? 16 : 0)
                  | ((t11 != _key) ? 32 : 0);

        if (nvMipMapTable[alp])
        {
            *(WORD*)dst = *(WORD*)(src+(nvMipMapTable[alp+1] << 1));
        }
        else
        {
            *(WORD*)dst = (WORD)_key;
        }

        src   += 8;
        dst   += 2;
        count -= 4;
    }
}

/****************************************************************************/
/* 32 bpp                                                                   */
/****************************************************************************/

/*
 * x8r8g8b8 no color key
 */
void nvCombineTexelsX8R8G8B8
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD REDBLU = 0x00ff00ff;
        DWORD GRN    = 0x0000ff00;
        DWORD a,b,c,d;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);
        b = *(DWORD*)(src+4);
        c = *(DWORD*)(src+8);
        d = *(DWORD*)(src+12);

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & GRN   ) + (b & GRN   ) + (c & GRN   ) + (d & GRN   )) >> 2) & GRN   ;

        *(DWORD*)dst = rb|ag;

        src   += 16;
        dst   += 4;
        count -= 4;
    }
}

/*
 * a8r8g8b8 no color key
 */
void nvCombineTexelsA8R8G8B8
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD REDBLU = 0x00ff00ff;
        DWORD GRN    = 0x0000ff00;
        DWORD ALP    = 0xff000000;
        DWORD a,b,c,d;
        DWORD A,B,C,D;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);  A = a & ALP;
        b = *(DWORD*)(src+4);  B = b & ALP;
        c = *(DWORD*)(src+8);  C = c & ALP;
        d = *(DWORD*)(src+12); D = d & ALP;

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & GRN   ) + (b & GRN   ) + (c & GRN   ) + (d & GRN   )) >> 2) & GRN   ;

        A = (A>>24) + (B>>24) + (C>>24) + (D>>24);
        A = nvAutoMipPush[A>>2] << 24;

        *(DWORD*)dst = rb|ag|A;

        src   += 16;
        dst   += 4;
        count -= 4;
    }
}

/*
 * y32 no color key
 */
void nvCombineTexelsY32CK
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD t00 = *(DWORD*)(src+ 0);
        DWORD t01 = *(DWORD*)(src+ 4);
        DWORD t10 = *(DWORD*)(src+ 8);
        DWORD t11 = *(DWORD*)(src+12);

        DWORD alp = ((t00 != _key) ?  4 : 0)
                  | ((t01 != _key) ?  8 : 0)
                  | ((t10 != _key) ? 16 : 0)
                  | ((t11 != _key) ? 32 : 0);

        if (nvMipMapTable[alp])
        {
            *(DWORD*)dst = *(DWORD*)(src+(nvMipMapTable[alp+1] << 2));
        }
        else
        {
            *(DWORD*)dst = _key;
        }

        src   += 16;
        dst   += 4;
        count -= 4;
    }
}

/*
 * nvTextureAutoMipMap
 *
 * automipmap given texture
 */
void nvTextureAutoMipMap
(
    PNVD3DTEXTURE pTexture
)
{
    NVCOMBINETEXELFPTR fncCombineTexels;

#ifdef DEBUG
    /*
     * sanity checks
     */
    if (!pTexture)
    {
        DPF ("nvTextureAutoMipMap: pTexture == NULL");
        dbgD3DError();
        __asm int 3;
        return;
    }
    if (!TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags))
    {
        DPF ("nvTextureAutoMipMap: pTexture->dwSwizzleAddr[current] == NULL");
        dbgD3DError();
        __asm int 3;
        return;
    }
#endif //DEBUG

    /*
     * get proper reduction function
     */
    {
        if (pTexture->lpLcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT) // have colorkey and it matters
        {
            switch (pTexture->dwTextureColorFormat)
            {
                case NV054_FORMAT_COLOR_LE_X1R5G5B5:
                case NV054_FORMAT_COLOR_LE_R5G6B5:
                case NV054_FORMAT_COLOR_LE_A1R5G5B5:
                case NV054_FORMAT_COLOR_LE_A4R4G4B4:
                    fncCombineTexels = nvCombineTexelsY16CK;
                    _key  = pTexture->lpLcl->ddckCKSrcBlt.dwColorSpaceHighValue & 0x00007FFF;
                    break;
                case NV054_FORMAT_COLOR_LE_X8R8G8B8:
                case NV054_FORMAT_COLOR_LE_A8R8G8B8:
                    fncCombineTexels = nvCombineTexelsY32CK;
                    _key  = pTexture->lpLcl->ddckCKSrcBlt.dwColorSpaceHighValue;
                    break;
            }
        }
        else
        {
            switch (pTexture->dwTextureColorFormat)
            {
                case NV054_FORMAT_COLOR_LE_X1R5G5B5: fncCombineTexels = nvCombineTexelsX1R5G5B5;
                                                     break;
                case NV054_FORMAT_COLOR_LE_R5G6B5:   fncCombineTexels = nvCombineTexelsR5G6B5;
                                                     break;
                case NV054_FORMAT_COLOR_LE_A1R5G5B5: fncCombineTexels = nvCombineTexelsA1R5G5B5;
                                                     break;
                case NV054_FORMAT_COLOR_LE_A4R4G4B4: fncCombineTexels = nvCombineTexelsA4R4G4B4;
                                                     break;
                case NV054_FORMAT_COLOR_LE_X8R8G8B8: fncCombineTexels = nvCombineTexelsX8R8G8B8;
                                                     break;
                case NV054_FORMAT_COLOR_LE_A8R8G8B8: fncCombineTexels = nvCombineTexelsA8R8G8B8;
                                                     break;
            }
        }
    }

    /*
     * sync
     */
    nvTextureBlock (pTexture->dwRetireDate[TEX_SWIZZLE_INDEX(pTexture->dwTextureFlags)]);

    {
        int   i,s,c;
        DWORD dwAddr[12];
        DWORD dwOffset[12];
        DWORD dwCount[12];
        DWORD dwMipMapLevel;

        DWORD dwLogU         = pTexture->dwMipMapBaseU;
        DWORD dwLogV         = pTexture->dwMipMapBaseV;
        DWORD dwMipMapLevels = pTexture->dwMipMapLevels;
        DWORD dwBPP          = (pTexture->dwBPP == 4) ? 2 : 1; // shift amount

        /*
         * setup mipmap base tables
         */
        s = TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags);
        c  = 1 << (dwLogU + dwLogV);
        for (i = dwMipMapLevels-1; i >= 0; i--)
        {
            dwAddr[i]   = s;
            dwOffset[i] = 0;
            dwCount[i]  = c;

            s  += c << dwBPP;
            c >>= 2;
        }

        /*
         * for all pending work
         */
        for (dwMipMapLevel = dwMipMapLevels - 1; dwMipMapLevel; )
        {
            /*
             * setup
             */
            DWORD dwMip  = dwMipMapLevel;
            DWORD dwToGo = min(dwCount[dwMip],1024);

            /*
             * read a line
             */
            nvMemCopy ((DWORD)nvTexelScratchBuffer,
                       dwAddr[dwMip] + (dwOffset[dwMip] << dwBPP),
                       dwToGo << dwBPP,
                       NV_MEMCOPY_WANTSRCALIGNED);

            /*
             * for as many mipmaps we can possibly do
             */
            for (; dwMip && (dwToGo >= 4); )
            {
                /*
                 * mipmap cached block of data
                 */
                (fncCombineTexels)(dwToGo);

                /*
                 * write dest
                 */
                nvMemCopy (dwAddr[dwMip-1] + ((dwOffset[dwMip] >> 2) << dwBPP),
                           (DWORD)nvTexelScratchBuffer,
                           (dwToGo >> 2) << dwBPP,
                           NV_MEMCOPY_WANTDESTALIGNED);

                /*
                 * advance to next mip level
                 */
                dwCount[dwMip]  -= dwToGo;
                dwOffset[dwMip] += dwToGo;
                dwToGo >>= 2;
                dwMip--;
            }

            /*
             * advance to next level
             */
            while (dwMipMapLevel && !dwCount[dwMipMapLevel])  dwMipMapLevel--;
        }
    }
}

#else

typedef void (*NVCOMBINETEXELFPTR)(DWORD,DWORD,DWORD);

DWORD _key;

/****************************************************************************/
/* 16 bpp                                                                   */
/****************************************************************************/

/*
 * x1r5g5b5 no color key
 */
void nvCombineTexelsX1R5G5B5
(
    DWORD src,
    DWORD dst,
    DWORD count
)
{
    while (count)
    {
        DWORD REDBLU = 0x7c1f;
        DWORD GRN    = 0x03e0;
        DWORD a,b,c,d;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);
        b = a >> 16;
        c = *(DWORD*)(src+4);
        d = c >> 16;

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & GRN   ) + (b & GRN   ) + (c & GRN   ) + (d & GRN   )) >> 2) & GRN   ;

        *(WORD*)dst = (WORD)(rb|ag);

        src   += 8;
        dst   += 2;
        count --;
    }
}

/*
 * a1r5g5b5 no color key
 */
void nvCombineTexelsA1R5G5B5
(
    DWORD src,
    DWORD dst,
    DWORD count
)
{
    while (count)
    {
        DWORD t00 = *(WORD*)(src+0);
        DWORD t01 = *(WORD*)(src+2);
        DWORD t10 = *(WORD*)(src+4);
        DWORD t11 = *(WORD*)(src+6);

        DWORD alp = ((t00 & 0x8000) >> 13)
                  | ((t01 & 0x8000) >> 12)
                  | ((t10 & 0x8000) >> 11)
                  | ((t11 & 0x8000) >> 10);

        *(WORD*)dst = *(WORD*)(src+(nvMipMapTable[alp + 1 + nvMipMapTable[alp]] << 1));

        src   += 8;
        dst   += 2;
        count --;
    }
}

/*
 * a4r4g4b4 no color key
 */
void nvCombineTexelsA4R4G4B4
(
    DWORD src,
    DWORD dst,
    DWORD count
)
{
    while (count)
    {
        DWORD REDBLU = 0x0f0f;
        DWORD ALPGRN = 0xf0f0;
        DWORD a,b,c,d;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);
        b = a >> 16;
        c = *(DWORD*)(src+4);
        d = c >> 16;

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & ALPGRN) + (b & ALPGRN) + (c & ALPGRN) + (d & ALPGRN)) >> 2) & ALPGRN;

        *(WORD*)dst = (WORD)(rb|ag);

        src   += 8;
        dst   += 2;
        count --;
    }
}

/*
 * r5g6b5 no color key
 */
void nvCombineTexelsR5G6B5
(
    DWORD src,
    DWORD dst,
    DWORD count
)
{
    while (count)
    {
        DWORD REDBLU = 0xf81f;
        DWORD GRN    = 0x07e0;
        DWORD a,b,c,d;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);
        b = a >> 16;
        c = *(DWORD*)(src+4);
        d = c >> 16;

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & GRN   ) + (b & GRN   ) + (c & GRN   ) + (d & GRN   )) >> 2) & GRN   ;

        *(WORD*)dst = (WORD)(rb|ag);

        src   += 8;
        dst   += 2;
        count --;
    }
}

#if 0
/*
 * y16
 */
void nvCombineTexelsY16
(
    DWORD src,
    DWORD dst,
    DWORD count
)
{
    DWORD roll = 0;
    while (count)
    {
        *(WORD*)dst = *(WORD*)(src+roll);
        roll   = (roll + 2) & 6;
        src   += 8;
        dst   += 2;
        count --;
    }
}
#endif

/*
 * y16 no color key
 */
void nvCombineTexelsY16CK
(
    DWORD src,
    DWORD dst,
    DWORD count
)
{
    while (count)
    {
        DWORD t00 = *(WORD*)(src+0);
        DWORD t01 = *(WORD*)(src+2);
        DWORD t10 = *(WORD*)(src+4);
        DWORD t11 = *(WORD*)(src+6);

        DWORD alp = ((t00 != _key) ?  4 : 0)
                  | ((t01 != _key) ?  8 : 0)
                  | ((t10 != _key) ? 16 : 0)
                  | ((t11 != _key) ? 32 : 0);

        if (nvMipMapTable[alp])
        {
            *(WORD*)dst = *(WORD*)(src+(nvMipMapTable[alp+1] << 1));
        }
        else
        {
            *(WORD*)dst = (WORD)_key;
        }

        src   += 8;
        dst   += 2;
        count --;
    }
}

/****************************************************************************/
/* 32 bpp                                                                   */
/****************************************************************************/

/*
 * x8r8g8b8 no color key
 */
void nvCombineTexelsX8R8G8B8
(
    DWORD src,
    DWORD dst,
    DWORD count
)
{
    while (count)
    {
        DWORD REDBLU = 0x00ff00ff;
        DWORD GRN    = 0x0000ff00;
        DWORD a,b,c,d;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);
        b = *(DWORD*)(src+4);
        c = *(DWORD*)(src+8);
        d = *(DWORD*)(src+12);

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & GRN   ) + (b & GRN   ) + (c & GRN   ) + (d & GRN   )) >> 2) & GRN   ;

        *(DWORD*)dst = rb|ag;

        src   += 16;
        dst   += 4;
        count --;
    }
}

/*
 * a8r8g8b8 no color key
 */
void nvCombineTexelsA8R8G8B8
(
    DWORD src,
    DWORD dst,
    DWORD count
)
{
    while (count)
    {
        DWORD REDBLU = 0x00ff00ff;
        DWORD GRN    = 0x0000ff00;
        DWORD ALP    = 0xff000000;
        DWORD a,b,c,d;
        DWORD A,B,C,D;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);  A = a & ALP;
        b = *(DWORD*)(src+4);  B = b & ALP;
        c = *(DWORD*)(src+8);  C = c & ALP;
        d = *(DWORD*)(src+12); D = d & ALP;

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & GRN   ) + (b & GRN   ) + (c & GRN   ) + (d & GRN   )) >> 2) & GRN   ;

        A = (A>>24) + (B>>24) + (C>>24) + (D>>24);
        A = nvAutoMipPush[A>>2] << 24;

        *(DWORD*)dst = rb|ag|A;

        src   += 16;
        dst   += 4;
        count --;
    }
/*
    while (count)
    {
        DWORD REDBLU = 0x00ff00ff;
        DWORD ALPGRN = 0xff00ff00;
        DWORD a,b,c,d;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);
        b = *(DWORD*)(src+4);
        c = *(DWORD*)(src+8);
        d = *(DWORD*)(src+12);

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & ALPGRN) >> 2) + ((b & ALPGRN) >> 2) + ((c & ALPGRN) >> 2) + ((d & ALPGRN) >> 2)) & ALPGRN;

        *(DWORD*)dst = rb|ag;

        src   += 16;
        dst   += 4;
        count --;
    }
*/
}

#if 0
/*
 * y32
 */
void nvCombineTexelsY32
(
    DWORD src,
    DWORD dst,
    DWORD count
)
{
    DWORD roll = 0;

    while (count)
    {
        *(DWORD*)dst = *(DWORD*)(src+roll);
        roll   = (roll + 4) & 12;
        src   += 16;
        dst   += 4;
        count --;
    }
}
#endif

/*
 * y32 no color key
 */
void nvCombineTexelsY32CK
(
    DWORD src,
    DWORD dst,
    DWORD count
)
{
    DWORD err = 0;
    while (count)
    {
        DWORD t00 = *(DWORD*)(src+ 0);
        DWORD t01 = *(DWORD*)(src+ 4);
        DWORD t10 = *(DWORD*)(src+ 8);
        DWORD t11 = *(DWORD*)(src+12);

        DWORD alp = ((t00 != _key) ?  4 : 0)
                  | ((t01 != _key) ?  8 : 0)
                  | ((t10 != _key) ? 16 : 0)
                  | ((t11 != _key) ? 32 : 0);

        if (nvMipMapTable[alp])
        {
            *(DWORD*)dst = *(DWORD*)(src+(nvMipMapTable[alp+1] << 2));
        }
        else
        {
            *(DWORD*)dst = _key;
        }

        src   += 16;
        dst   += 4;
        count --;
    }
}

/*
 * automipmap given texture
 */
void nvTextureAutoMipMap
(
    PNVD3DTEXTURE pTexture
)
{
    DWORD dwBaseAddress;
    DWORD dwLogWidth;
    DWORD dwLogHeight;
    DWORD dwBPP;
    DWORD dwMip0;
    DWORD dwMip1;
    DWORD dwCount;
    NVCOMBINETEXELFPTR fncCombineTexels;

    /*
     * Update update statistics
     */
    if ((++pTexture->dwUpdateCount) > 3)
    {
        /*
         * texture updated more than 3 times - we will disable automips
         */
        DPF_LEVEL(NVDBG_LEVEL_INFO, "AUTOMIP: Texture updated too many times - automips killed");
        pTexture->dwTextureFlags &= ~NV4_TEXTURE_AUTOMIPMAPPED;
        pTexture->dwMipMapLevels  = 1;
        /*
         * force hw reprogram
         */
        pCurrentContext->dwStateChange = TRUE;
        NV_FORCE_TRI_SETUP(pCurrentContext);
        return;
    }

    DPF_LEVEL(NVDBG_LEVEL_INFO, "AUTOMIP: Auto Mipmapping texture");

    /*
     * extract basic texture info into locals
     */
    if (pTexture->dwTextureFlags & NV3_TEXTURE_VIDEO_MEMORY)
    {
        dwBaseAddress = pDriverData->BaseAddress + pTexture->dwTextureOffset;
#ifdef WINNT
        dwBaseAddress += (ULONG) pDriverData->ppdev->pjScreen;
#endif // #ifdef WINNT
    }
    else
    {
        if (pDriverData->GARTLinearBase > 0)
            dwBaseAddress = pTexture->dwTexturePointer;
        else
            dwBaseAddress = GetPointerTextureHeap(pTexture->dwTextureOffset);
    }
    dwLogWidth    = pTexture->dwMipMapBaseU;
    dwLogHeight   = pTexture->dwMipMapBaseV;

    /*
     * bilinear filtering options
     */
    //if (1) (we do bilinear filtering)
    {
        if (pTexture->lpLcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT) // have colorkey and it matters
        {
            switch (pTexture->dwTextureColorFormat)
            {

                case NV054_FORMAT_COLOR_LE_X1R5G5B5:
                case NV054_FORMAT_COLOR_LE_R5G6B5:
                case NV054_FORMAT_COLOR_LE_A1R5G5B5:
                case NV054_FORMAT_COLOR_LE_A4R4G4B4:
                    fncCombineTexels = nvCombineTexelsY16CK;
                    _key  = pTexture->lpLcl->ddckCKSrcBlt.dwColorSpaceHighValue & 0x00007FFF;
                    dwBPP = 2;
                    break;
                case NV054_FORMAT_COLOR_LE_X8R8G8B8:
                case NV054_FORMAT_COLOR_LE_A8R8G8B8:
                    fncCombineTexels = nvCombineTexelsY32CK;
                    _key  = pTexture->lpLcl->ddckCKSrcBlt.dwColorSpaceHighValue;
                    dwBPP = 4;
                    break;
            }
        }
        else
        {
            switch (pTexture->dwTextureColorFormat)
            {
                case NV054_FORMAT_COLOR_LE_X1R5G5B5: fncCombineTexels = nvCombineTexelsX1R5G5B5;
                                                     dwBPP = 2;
                                                     break;
                case NV054_FORMAT_COLOR_LE_R5G6B5:   fncCombineTexels = nvCombineTexelsR5G6B5;
                                                     dwBPP = 2;
                                                     break;
                case NV054_FORMAT_COLOR_LE_A1R5G5B5: fncCombineTexels = nvCombineTexelsA1R5G5B5;
                                                     dwBPP = 2;
                                                     break;
                case NV054_FORMAT_COLOR_LE_A4R4G4B4: fncCombineTexels = nvCombineTexelsA4R4G4B4;
                                                     dwBPP = 2;
                                                     break;
                case NV054_FORMAT_COLOR_LE_X8R8G8B8: fncCombineTexels = nvCombineTexelsX8R8G8B8;
                                                     dwBPP = 4;
                                                     break;
                case NV054_FORMAT_COLOR_LE_A8R8G8B8: fncCombineTexels = nvCombineTexelsA8R8G8B8;
                                                     dwBPP = 4;
                                                     break;
            }
        }
    }
#if 0
    else
    {
        /*
         * simple downsampling
         */
        switch (pTexture->dwTextureColorFormat)
        {
            case NV054_FORMAT_COLOR_LE_X1R5G5B5:
            case NV054_FORMAT_COLOR_LE_R5G6B5:
            case NV054_FORMAT_COLOR_LE_A1R5G5B5:
            case NV054_FORMAT_COLOR_LE_A4R4G4B4: fncCombineTexels = nvCombineTexelsY16;
                                                 dwBPP = 2;
                                                 break;
            case NV054_FORMAT_COLOR_LE_X8R8G8B8:
            case NV054_FORMAT_COLOR_LE_A8R8G8B8: fncCombineTexels = nvCombineTexelsY32;
                                                 dwBPP = 4;
                                                 break;
        }
    }
#endif

    /*
     * calc mip values
     */
    dwCount = (1 << (dwLogWidth + dwLogHeight)) * dwBPP; // # bytes in first mip level
    dwMip0  = dwBaseAddress;
    dwMip1  = dwBaseAddress + dwCount;
    dwCount = (pTexture->dwMipMapSizeBytes - dwCount) / dwBPP; // # texels in other levels

    /*
     * flush hardware if needed
     *  todo - check if texture is used by HW
     */
    NV_D3D_GLOBAL_SAVE();
    nvFlushDmaBuffers();
    NV_D3D_GLOBAL_SETUP();

    /*
     * compute
     */
    (*fncCombineTexels)(dwMip0,dwMip1,dwCount);
}

#endif // NV_TEX2
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4index.c ===
#ifdef  NV4
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4INDX.C                                                         *
*   NV4 DX5 DrawOneIndexedPrimitive DDI routines.                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/31/98 - created                      *
*                                                                           *
\***************************************************************************/
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv3ddbg.h"
#include "nv4vxmac.h"

#ifndef NV_FASTLOOPS
/*
 * DirectX 5.0 DrawOneIndexedPrimitive entry point.
 */
void nvDX5IndexedTriangleSetup
(
    DWORD           dwPrimCount,
    LPWORD          lpwIndices,
    DWORD           dwStrides,
    LPD3DTLVERTEX   lpVertices
)
{
    /*
     * Send the context state down to the hardware.
     */
    if (pCurrentContext->dwStateChange)
        nvSetHardwareState();
    nvSetDx5TriangleState(pCurrentContext);

    /*
     * Now calculate the appropriate rendering routine and call it.
     *
     * Determine the fog table mode based on if fog is enabled and the
     * selected fog table mode.  A computed value of 0 = vertex or no fog,
     * non-zero values indicate the fog table mode.
     */
    CALC_FUNCTION_INDEX (pCurrentContext);

    fnDX5IndexedTable[pCurrentContext->dwFunctionLookup](dwPrimCount, lpwIndices, dwStrides, lpVertices);
    return;
}
#endif //!NV_FASTLOOPS

#ifndef WINNT
DWORD nvDrawOneIndexedPrimitive
(
    LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA    pdoipd
)
{
    DWORD   dwPrimCount;

#ifdef NV_NULL_DRIVER
    pdoipd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
#endif //NV_NULL_DRIVER

    DPF_LEVEL(NVDBG_LEVEL_DDI_ENTRY, "nvDrawOneIndexedPrimitive - PrimitiveType = %08lx, Index Count = %08lx", pdoipd->PrimitiveType, pdoipd->dwNumIndices);

    if (!pCurrentContext->lpLcl)
    {
        pdoipd->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }

    if (!pDriverData->NvDevFlatDma)
    {
        pdoipd->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }


    /*
     * Need to make sure that an unfriendly mode switch didn't sneak and not cause
     * us to get re-enabled properly.
     */
    if (pDriverData->fFullScreenDosOccurred)
    {
        if (pDriverData->fFullScreenDosOccurred & 0x01)
            nvD3DReenable();
        else
        {
            pdoipd->ddrval = DD_OK;
            return (DDHAL_DRIVER_HANDLED);
        }
    }
    if (pCurrentContext->dwContextReset)
        nvResetContext((PNVD3DTEXTURE)NULL);

    /*
     * prep fvf data
     */
    {
        DWORD dwDummy1,dwDummy2;
        CHECK_FVF_DATA_AND_LOAD_TL (fvfData,D3DFVF_TLVERTEX,dwDummy1,dwDummy2);
    }

    if (pdoipd->dwNumVertices && pdoipd->dwNumIndices)
    {
        /*
         * Setup frequently accessed globals.
         */
        NV_D3D_GLOBAL_SETUP();
        NV_AA_SEMANTICS_CHECK(pCurrentContext);
        if ((pCurrentContext->dwStateChange || pDriverData->TwoDRenderingOccurred)
         || (pDriverData->dDrawSpareSubchannelObject != D3D_DX5_TEXTURED_TRIANGLE))
            NV_FORCE_TRI_SETUP(pCurrentContext);

        /*
         * Always read the current free count on entry.
         */
#ifdef  CACHE_FREECOUNT
        nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetRenderTargetContexts + sizeSetRenderTarget));
#endif  // CACHE_FREECOUNT

        /*
         * Send down the surface information if neccessary.
         */
        nvSetD3DSurfaceState(pCurrentContext);
        switch (pdoipd->PrimitiveType)
        {
            case D3DPT_TRIANGLELIST:
                dwPrimCount =  pdoipd->dwNumIndices / 3;
                switch (pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE])
                {
                    case D3DFILL_SOLID:
#ifdef NV_FASTLOOPS
                        nvTriangleDispatch(dwPrimCount, (LPWORD)pdoipd->lpwIndices, LIST_STRIDES, (LPBYTE)pdoipd->lpvVertices);
#else
                        fnDX5IndexedTable[pCurrentContext->dwFunctionLookup](dwPrimCount, (LPWORD)pdoipd->lpwIndices, LIST_STRIDES, (LPD3DTLVERTEX)pdoipd->lpvVertices);
#endif
                        break;
                    case D3DFILL_WIREFRAME:
                        nvIndexedWireframeTriangle(dwPrimCount, (LPWORD)pdoipd->lpwIndices, LIST_STRIDES, (LPD3DTLVERTEX)pdoipd->lpvVertices);
                        break;
                    case D3DFILL_POINT:
                        nvIndexedPointTriangle(dwPrimCount, (LPWORD)pdoipd->lpwIndices, LIST_STRIDES, (LPD3DTLVERTEX)pdoipd->lpvVertices);
                        break;
                }
                break;
            case D3DPT_TRIANGLESTRIP:
                dwPrimCount = pdoipd->dwNumIndices - 2;
                switch (pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE])
                {
                    case D3DFILL_SOLID:
#ifdef NV_FASTLOOPS
                        nvTriangleDispatch(dwPrimCount, (LPWORD)pdoipd->lpwIndices, STRIP_STRIDES, (LPBYTE)pdoipd->lpvVertices);
#else
                        fnDX5IndexedTable[pCurrentContext->dwFunctionLookup](dwPrimCount, (LPWORD)pdoipd->lpwIndices, STRIP_STRIDES, (LPD3DTLVERTEX)pdoipd->lpvVertices);
#endif
                        break;
                    case D3DFILL_WIREFRAME:
                        nvIndexedWireframeTriangle(dwPrimCount, (LPWORD)pdoipd->lpwIndices, STRIP_STRIDES, (LPD3DTLVERTEX)pdoipd->lpvVertices);
                        break;
                    case D3DFILL_POINT:
                        nvIndexedPointTriangle(dwPrimCount, (LPWORD)pdoipd->lpwIndices, STRIP_STRIDES, (LPD3DTLVERTEX)pdoipd->lpvVertices);
                        break;
                }
                break;
            case D3DPT_TRIANGLEFAN:
                dwPrimCount = pdoipd->dwNumIndices - 2;
                switch (pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE])
                {
                    case D3DFILL_SOLID:
#ifdef NV_FASTLOOPS
                        nvTriangleDispatch(dwPrimCount, (LPWORD)pdoipd->lpwIndices, FAN_STRIDES, (LPBYTE)pdoipd->lpvVertices);
#else
                        fnDX5IndexedTable[pCurrentContext->dwFunctionLookup](dwPrimCount, (LPWORD)pdoipd->lpwIndices, FAN_STRIDES, (LPD3DTLVERTEX)pdoipd->lpvVertices);
#endif
                        break;
                    case D3DFILL_WIREFRAME:
                        nvIndexedWireframeTriangle(dwPrimCount, (LPWORD)pdoipd->lpwIndices, FAN_STRIDES, (LPD3DTLVERTEX)pdoipd->lpvVertices);
                        break;
                    case D3DFILL_POINT:
                        nvIndexedPointTriangle(dwPrimCount, (LPWORD)pdoipd->lpwIndices, FAN_STRIDES, (LPD3DTLVERTEX)pdoipd->lpvVertices);
                        break;
                }
                break;
            case D3DPT_LINELIST:
                /*
                 * Calculate the number of lines to draw.
                 */
                dwPrimCount = pdoipd->dwNumIndices / 2;
                nvIndexedLine(dwPrimCount, (LPWORD)pdoipd->lpwIndices, 2, (LPD3DTLVERTEX)pdoipd->lpvVertices);
                break;
            case D3DPT_LINESTRIP:
                dwPrimCount = pdoipd->dwNumIndices - 1;
                nvIndexedLine(dwPrimCount, (LPWORD)pdoipd->lpwIndices, 1, (LPD3DTLVERTEX)pdoipd->lpvVertices);
                break;
            case D3DPT_POINTLIST:
                /*
                 * Indexed points kind of suck under the current scheme.
                 */


                break;
        }

        /*
         * Tell DDRAW that thee global clip state has changed.
         * Probably don't need this, but I'd rather be safe.
         */
        pDriverData->ddClipUpdate = TRUE;
    }

    /*
     * Update the put offset.
     */
    nvStartDmaBuffer (TRUE);
    pDriverData->TwoDRenderingOccurred   = 0;
    pDriverData->ThreeDRenderingOccurred = TRUE;

    /*
     * Return successfully.
     */
    NV_D3D_GLOBAL_SAVE();

#ifdef  CACHE_FREECOUNT
    pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT

    pdoipd->ddrval = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}
#endif // #ifndef WINNT
#endif  // NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4line.c ===
#ifdef  NV4
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4LINE.C                                                         *
*   The Direct 3d Line Rendereing routines.                                 *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       04/12/97 - created                      *
*                                                                           *
\***************************************************************************/
#include <math.h>
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv4vxmac.h"

static WORD EdgeLine[6*3] =
{
    0,1,3,
    1,3,4,
    1,2,5,
    2,5,6,
    0,2,7,
    0,7,8
};

#define LINE_WIDTH  1.0f

/*
 * cull macro
 */
#define IF_NOT_CULLED_BEGIN(v0,v1,v2,cv) {             \
    DWORD _sx0  = v0 + 0;                              \
    DWORD _sy0  = v0 + 4;                              \
    DWORD _sx1  = v1 + 0;                              \
    DWORD _sy1  = v1 + 4;                              \
    DWORD _sx2  = v2 + 0;                              \
    DWORD _sy2  = v2 + 4;                              \
    float _dx10 = *(float*)_sx1 - *(float*)_sx0;       \
    float _dy10 = *(float*)_sy1 - *(float*)_sy0;       \
    float _dx20 = *(float*)_sx2 - *(float*)_sx0;       \
    float _dy20 = *(float*)_sy2 - *(float*)_sy0;       \
           cv   = _dx10*_dy20  - _dx20*_dy10;          \
    if (((*(DWORD*)&cv) ^ dwCullMask1) & dwCullMask2) {
#define IF_NOT_CULLED_END } }

/*
 * Non-Indexed TLVertex Format Line Lists.
 */
void nvDrawLine
(
    DWORD           dwPrimCount,
    DWORD           dwVertexInc,
    LPD3DTLVERTEX   lpVertices
)
{
    DWORD           dwControl;
    DWORD           dwOldCull;
    D3DTLVERTEX     LineVerts[4];

    if (dwPrimCount)
    {
        /*
         * Calculate the new hardware state if neccessary.
         */
        if (pCurrentContext->dwStateChange)
        {
#ifdef  NVD3D_DX6
            if (pCurrentContext->bUseDX6Class)
            {
                nvSetMultiTextureHardwareState();
                if (pCurrentContext->bUseDX6Class)
                    nvSetHardwareState();
            }
            else
#endif  // NVD3D_DX6
                nvSetHardwareState();
        }

        /*
         * Disable culling.
         */
        dwControl = pCurrentContext->ctxInnerLoop.dwControl;
        pCurrentContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
        pCurrentContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        dwOldCull = pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        /*
         * Force first call to be to the triangle state setup routine.
         */
        NV_FORCE_TRI_SETUP(pCurrentContext);

        /*
         * Draw the lines.
         */
        while (dwPrimCount--)
        {
            /*
             * Each line is rendered as a one pixel wide rectangle.
             */
            LineVerts[0] = lpVertices[0];
            LineVerts[2] = lpVertices[0];
            LineVerts[1] = lpVertices[1];
            LineVerts[3] = lpVertices[1];
            lpVertices += dwVertexInc;
            if (fabs(LineVerts[2].sx - LineVerts[3].sx) < fabs(LineVerts[2].sy - LineVerts[3].sy))
            {
                LineVerts[2].sx += LINE_WIDTH;
                LineVerts[3].sx += LINE_WIDTH;
            }
            else
            {
                LineVerts[2].sy += LINE_WIDTH;
                LineVerts[3].sy += LINE_WIDTH;
            }
            /*
             * Call the low level rendering routine to draw the "line".
             */
#ifdef NV_FASTLOOPS
            nvTriangleDispatch(2, NULL, STRIP_STRIDES, (LPBYTE)LineVerts);
#else
            fnDX5Table[pCurrentContext->dwFunctionLookup](2, STRIP_STRIDES, LineVerts);
#endif
        }
        /*
         * Restore the culling mode.
         */
        pCurrentContext->ctxInnerLoop.dwControl = dwControl;
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    /*
     * Force next render call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return;
}

/*
 * Indexed TLVertex Format Line Lists.
 */
void nvIndexedLine
(
    DWORD           dwPrimCount,
    LPWORD          lpIndices,
    DWORD           dwIndexInc,
    LPD3DTLVERTEX   lpVertices
)
{
    DWORD           dwControl;
    DWORD           dwOldCull;
    D3DTLVERTEX     LineVerts[4];

    if (dwPrimCount)
    {
        /*
         * Calculate the new hardware state if neccessary.
         */
        if (pCurrentContext->dwStateChange)
        {
#ifdef  NVD3D_DX6
            if (pCurrentContext->bUseDX6Class)
            {
                nvSetMultiTextureHardwareState();
                if (pCurrentContext->bUseDX6Class)
                    nvSetHardwareState();
            }
            else
#endif  // NVD3D_DX6
                nvSetHardwareState();
        }

        /*
         * Disable culling.
         */
        dwControl = pCurrentContext->ctxInnerLoop.dwControl;
        pCurrentContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
        pCurrentContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        dwOldCull = pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        /*
         * Force first call to be to the triangle state setup routine.
         */
        NV_FORCE_TRI_SETUP(pCurrentContext);

        /*
         * Draw the lines.
         */
        while (dwPrimCount--)
        {
            /*
             * Each line is rendered as a one pixel wide rectangle.
             */
            LineVerts[0] = lpVertices[lpIndices[0]];
            LineVerts[2] = lpVertices[lpIndices[0]];
            LineVerts[1] = lpVertices[lpIndices[1]];
            LineVerts[3] = lpVertices[lpIndices[1]];
            lpIndices += dwIndexInc;
            if (fabs(LineVerts[2].sx - LineVerts[3].sx) < fabs(LineVerts[2].sy - LineVerts[3].sy))
            {
                LineVerts[2].sx += LINE_WIDTH;
                LineVerts[3].sx += LINE_WIDTH;
            }
            else
            {
                LineVerts[2].sy += LINE_WIDTH;
                LineVerts[3].sy += LINE_WIDTH;
            }
            /*
             * Call the low level rendering routine to draw the "line".
             */
#ifdef NV_FASTLOOPS
            nvTriangleDispatch(2, NULL, STRIP_STRIDES, (LPBYTE)LineVerts);
#else
            fnDX5Table[pCurrentContext->dwFunctionLookup](2, STRIP_STRIDES, LineVerts);
#endif
        }
        /*
         * Restore the culling mode.
         */
        pCurrentContext->ctxInnerLoop.dwControl = dwControl;
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    /*
     * Force first call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return;
}

DWORD nvRenderLine
(
    DWORD           dwPrimCount,
    LPBYTE          lpPrim,
    LPD3DTLVERTEX   lpVertices
)
{
    nvIndexedLine(dwPrimCount, (LPWORD)lpPrim, 2, lpVertices);
    return (DD_OK);
}
void nvDrawWireframeTriangle
(
    DWORD         dwPrimCount,
    DWORD         dwStrides,
    LPD3DTLVERTEX lpVertices
)
{
    D3DTLVERTEX LineVerts[9];
    DWORD       v0,v1,v2;
    DWORD       dwControl;
    DWORD       dwOldCull;
    DWORD       dwIndex1, dwIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    float       dwCullValue;

    if (dwPrimCount)
    {
        /*
         * Calculate the new hardware state if neccessary.
         */
        if (pCurrentContext->dwStateChange)
        {
#ifdef  NVD3D_DX6
            if (pCurrentContext->bUseDX6Class)
            {
                nvSetMultiTextureHardwareState();
                if (pCurrentContext->bUseDX6Class)
                    nvSetHardwareState();
            }
            else
#endif  // NVD3D_DX6
                nvSetHardwareState();
        }

        /*
         * Disable lower level culling while drawing lines.
         */
        dwControl = pCurrentContext->ctxInnerLoop.dwControl;
        pCurrentContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
        pCurrentContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        dwOldCull = pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        /*
         * Calculate the culling masks.
         */
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        /*
         * Force first call to be to the triangle state setup routine.
         */
        NV_FORCE_TRI_SETUP(pCurrentContext);

        dwStrides     &= 0xffffff; // mask interesting bits
        dwIndex1       = 0;
        dwIndex2       = 1;
        dwIndexStrides = dwStrides;

        /*
         * Draw all triangles as a wireframe.
         */
        while (dwPrimCount--)
        {
            v0 = dwIndex1;
            v1 = dwIndex2 + (dwIndexStrides >> 24);
            v2 = dwIndex2 + ((dwIndexStrides >> 24) ^ 1);

            /*
             * Move on to the next triangle.
             */
            dwIndex1       += (BYTE)(dwIndexStrides >> 8);
            dwIndex2       += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwStrides << 8) & 0xff000000;

            /*
             * Since culling needs to be disabled to insure that the triangle edges get drawn properly,
             * back face culling of the triangle needs to be performed up front by software.
             */
            IF_NOT_CULLED_BEGIN((DWORD)&lpVertices[v0],(DWORD)&lpVertices[v1],(DWORD)&lpVertices[v2],dwCullValue)
                /*
                 * Each edge line is rendered as a one pixel wide rectangle.
                 */
                LineVerts[0] = lpVertices[v0];
                LineVerts[3] = lpVertices[v0];
                LineVerts[8] = lpVertices[v0];
                LineVerts[1] = lpVertices[v1];
                LineVerts[4] = lpVertices[v1];
                LineVerts[5] = lpVertices[v1];
                LineVerts[2] = lpVertices[v2];
                LineVerts[6] = lpVertices[v2];
                LineVerts[7] = lpVertices[v2];
                if (fabs(LineVerts[3].sx - LineVerts[4].sx) < fabs(LineVerts[3].sy - LineVerts[4].sy))
                {
                    LineVerts[3].sx += LINE_WIDTH;
                    LineVerts[4].sx += LINE_WIDTH;
                }
                else
                {
                    LineVerts[3].sy += LINE_WIDTH;
                    LineVerts[4].sy += LINE_WIDTH;
                }
                if (fabs(LineVerts[5].sx - LineVerts[6].sx) < fabs(LineVerts[5].sy - LineVerts[6].sy))
                {
                    LineVerts[5].sx += LINE_WIDTH;
                    LineVerts[6].sx += LINE_WIDTH;
                }
                else
                {
                    LineVerts[5].sy += LINE_WIDTH;
                    LineVerts[6].sy += LINE_WIDTH;
                }
                if (fabs(LineVerts[7].sx - LineVerts[8].sx) < fabs(LineVerts[7].sy - LineVerts[8].sy))
                {
                    LineVerts[7].sx += LINE_WIDTH;
                    LineVerts[8].sx += LINE_WIDTH;
                }
                else
                {
                    LineVerts[7].sy += LINE_WIDTH;
                    LineVerts[8].sy += LINE_WIDTH;
                }

                /*
                 * Draw the triangle edges.
                 */
#ifdef NV_FASTLOOPS
                nvTriangleDispatch(6, EdgeLine, LIST_STRIDES, (LPBYTE)LineVerts);
#else
                fnDX5IndexedTable[pCurrentContext->dwFunctionLookup](6, EdgeLine, LIST_STRIDES, LineVerts);
#endif
            IF_NOT_CULLED_END
        }
        /*
         * Restore the culling mode.
         */
        pCurrentContext->ctxInnerLoop.dwControl = dwControl;
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    /*
     * Force first call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return;
}
void nvIndexedWireframeTriangle
(
    DWORD         dwPrimCount,
    LPWORD        lpIndices,
    DWORD         dwStrides,
    LPD3DTLVERTEX lpVertices
)
{
    D3DTLVERTEX LineVerts[9];
    DWORD       v0,v1,v2;
    DWORD       dwControl;
    DWORD       dwOldCull;
    DWORD       dwIndex1, dwIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    float       dwCullValue;

    if (dwPrimCount)
    {
        /*
         * Calculate the new hardware state if neccessary.
         */
        if (pCurrentContext->dwStateChange)
        {
#ifdef  NVD3D_DX6
            if (pCurrentContext->bUseDX6Class)
            {
                nvSetMultiTextureHardwareState();
                if (pCurrentContext->bUseDX6Class)
                    nvSetHardwareState();
            }
            else
#endif  // NVD3D_DX6
                nvSetHardwareState();
        }

        /*
         * Disable lower level culling while drawing lines.
         */
        dwControl = pCurrentContext->ctxInnerLoop.dwControl;
        pCurrentContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
        pCurrentContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        dwOldCull = pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        /*
         * Calculate the culling masks.
         */
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        /*
         * Force first call to be to the triangle state setup routine.
         */
        NV_FORCE_TRI_SETUP(pCurrentContext);

        dwStrides     &= 0xffffff; // mask interesting bits
        dwIndex1       = (DWORD)lpIndices;
        dwIndex2       = (DWORD)lpIndices + 2;
        dwIndexStrides = dwStrides * 2;

        /*
         * Draw all triangles as a wireframe.
         */
        while (dwPrimCount--)
        {
            v0 = *(WORD*) dwIndex1;
            v1 = *(WORD*)(dwIndex2 +  (dwIndexStrides >> 24));
            v2 = *(WORD*)(dwIndex2 + ((dwIndexStrides >> 24) ^ 2));

            /*
             * Move on to the next triangle.
             */
            dwIndex1       += (BYTE)(dwIndexStrides >> 8);
            dwIndex2       += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwIndexStrides << 8) & 0xff000000;

            /*
             * Since culling needs to be disabled to insure that the triangle edges get drawn properly,
             * back face culling of the triangle needs to be performed up front by software.
             */
            IF_NOT_CULLED_BEGIN((DWORD)&lpVertices[v0],(DWORD)&lpVertices[v1],(DWORD)&lpVertices[v2],dwCullValue)
                /*
                 * Each edge line is rendered as a one pixel wide rectangle.
                 */
                LineVerts[0] = lpVertices[v0];
                LineVerts[3] = lpVertices[v0];
                LineVerts[8] = lpVertices[v0];
                LineVerts[1] = lpVertices[v1];
                LineVerts[4] = lpVertices[v1];
                LineVerts[5] = lpVertices[v1];
                LineVerts[2] = lpVertices[v2];
                LineVerts[6] = lpVertices[v2];
                LineVerts[7] = lpVertices[v2];
                if (fabs(LineVerts[3].sx - LineVerts[4].sx) < fabs(LineVerts[3].sy - LineVerts[4].sy))
                {
                    LineVerts[3].sx += LINE_WIDTH;
                    LineVerts[4].sx += LINE_WIDTH;
                }
                else
                {
                    LineVerts[3].sy += LINE_WIDTH;
                    LineVerts[4].sy += LINE_WIDTH;
                }
                if (fabs(LineVerts[5].sx - LineVerts[6].sx) < fabs(LineVerts[5].sy - LineVerts[6].sy))
                {
                    LineVerts[5].sx += LINE_WIDTH;
                    LineVerts[6].sx += LINE_WIDTH;
                }
                else
                {
                    LineVerts[5].sy += LINE_WIDTH;
                    LineVerts[6].sy += LINE_WIDTH;
                }
                if (fabs(LineVerts[7].sx - LineVerts[8].sx) < fabs(LineVerts[7].sy - LineVerts[8].sy))
                {
                    LineVerts[7].sx += LINE_WIDTH;
                    LineVerts[8].sx += LINE_WIDTH;
                }
                else
                {
                    LineVerts[7].sy += LINE_WIDTH;
                    LineVerts[8].sy += LINE_WIDTH;
                }
                /*
                 * If this was called with RenderPrim, dwStrides will be LEGACY_STRIDES, otherwise it won't.
                 */
                if ((dwStrides != (LEGACY_STRIDES & 0xffffff)) ||
                    ((  ((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLETRIANGLE) == D3DTRIFLAG_EDGEENABLETRIANGLE))
                {
                    /*
                     * Draw the triangle edges.
                     */
#ifdef NV_FASTLOOPS
                    nvTriangleDispatch(6, EdgeLine, LIST_STRIDES, (LPBYTE)LineVerts);
#else
                    fnDX5IndexedTable[pCurrentContext->dwFunctionLookup](6, EdgeLine, LIST_STRIDES, LineVerts);
#endif
                }
                else
                {
                    DWORD tri;
                    WORD  triLine[6*3];

                    tri = 0;
                    if (((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLE1)
                    {
                        triLine[0*3+0]   = EdgeLine[0*3+0];
                        triLine[0*3+1]   = EdgeLine[0*3+1];
                        triLine[0*3+2]   = EdgeLine[0*3+2];
                        tri++;
                        triLine[1*3+0] = EdgeLine[1*3+0];
                        triLine[1*3+1] = EdgeLine[1*3+1];
                        triLine[1*3+2] = EdgeLine[1*3+2];
                        tri++;
                    }
                    if (((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLE2)
                    {
                        triLine[tri*3+0] = EdgeLine[2*3+0];
                        triLine[tri*3+1] = EdgeLine[2*3+1];
                        triLine[tri*3+2] = EdgeLine[2*3+2];
                        tri++;
                        triLine[tri*3+0] = EdgeLine[3*3+0];
                        triLine[tri*3+1] = EdgeLine[3*3+1];
                        triLine[tri*3+2] = EdgeLine[3*3+2];
                        tri++;
                    }
                    if (((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLE3)
                    {
                        triLine[tri*3+0] = EdgeLine[4*3+0];
                        triLine[tri*3+1] = EdgeLine[4*3+1];
                        triLine[tri*3+2] = EdgeLine[4*3+2];
                        tri++;
                        triLine[tri*3+0] = EdgeLine[5*3+0];
                        triLine[tri*3+1] = EdgeLine[5*3+1];
                        triLine[tri*3+2] = EdgeLine[5*3+2];
                        tri++;
                    }
                    if (tri)
                    {
                        /*
                         * Draw the specified triangle edges.
                         */
#ifdef NV_FASTLOOPS
                        nvTriangleDispatch(tri, triLine, LIST_STRIDES, (LPBYTE)LineVerts);
#else
                        fnDX5IndexedTable[pCurrentContext->dwFunctionLookup](tri, triLine, LIST_STRIDES, LineVerts);
#endif
                    }
                }
            IF_NOT_CULLED_END
        }
        /*
         * Restore the culling mode.
         */
        pCurrentContext->ctxInnerLoop.dwControl = dwControl;
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    /*
     * Force first call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return;
}
#ifdef  NVD3D_DX6
/*
 * Non-Indexed Flexible Vertex Format Lines.
 */
void nvFVFDrawLine
(
    DWORD           dwPrimCount,
    DWORD           dwVertexInc,
    LPBYTE          lpVertices
)
{
    BYTE            LineVerts[4 * ((sizeof (D3DTLVERTEX)) + (7*2*4))];
    DWORD           dwLineVert0Ptr, dwLineVert1Ptr, dwLineVert2Ptr, dwLineVert3Ptr;
    DWORD           dwVert0Ptr, dwVert1Ptr;
    DWORD           i, dwDwordsPerVert;
    DWORD           dwControl;
    DWORD           dwOldCull;
    DWORD           dwVertexStride;
    DWORD           dwNextLine;

    if (dwPrimCount)
    {
        /*
         * Calculate the new hardware state if neccessary.
         */
        if (pCurrentContext->dwStateChange)
        {
            if (pCurrentContext->bUseDX6Class)
            {
                nvSetMultiTextureHardwareState();
                if (pCurrentContext->bUseDX6Class)
                    nvSetHardwareState();
            }
            else
                nvSetHardwareState();
        }

        /*
         * Disable culling.
         */
        if (!pCurrentContext->bUseDX6Class)
        {
            dwControl = pCurrentContext->ctxInnerLoop.dwControl;
            pCurrentContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
            pCurrentContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        }
        else
        {
            dwControl = pCurrentContext->mtsState.dwControl0;
            pCurrentContext->mtsState.dwControl0 &= ~(DRF_MASK(NV055_CONTROL0_CULLMODE) << DRF_SHIFT(NV055_CONTROL0_CULLMODE));
            pCurrentContext->mtsState.dwControl0 |= DRF_DEF(055, _CONTROL0, _CULLMODE, _NONE);
        }
        dwOldCull = pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        /*
         * Force first call to be to the triangle state setup routine.
         */
        NV_FORCE_TRI_SETUP(pCurrentContext);

        /*
         * Calculate number of vertex bytes to increment after each line.
         */
        dwVertexStride  = fvfData.dwVertexStride;
        dwNextLine      = dwVertexInc * dwVertexStride;
        dwDwordsPerVert = fvfData.dwVertexStride >> 2;

        /*
         * Get pointers to each of the 4 FVF line vertices.
         */
        GET_FVF_POINTER(dwLineVert0Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 0, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert1Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 1, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert2Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 2, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert3Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 3, fvfData.dwVertexStride);

        /*
         * Draw the lines.
         */
        while (dwPrimCount--)
        {
            /*
             * Each line is rendered as a one pixel wide rectangle.
             * Since we're contstructing new TLVERTEX structures anyway,
             * Construct full TLVERTEX structures up front from the FVF data
             * structures and then just call the TLVERTEX rendering loop.
             *
             * Get pointers to each vertex of current line.
             */
            GET_FVF_POINTER(dwVert0Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, 0, fvfData.dwVertexStride);
            GET_FVF_POINTER(dwVert1Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, 1, fvfData.dwVertexStride);
            lpVertices += dwNextLine;

            /*
             * Copy the vertices.
             */
            for (i = 0; i < dwDwordsPerVert; i++)
            {
                DWORD   dwValue;
                dwValue = ((DWORD *)dwVert0Ptr)[i];
                ((DWORD *)dwLineVert0Ptr)[i] = dwValue;
                ((DWORD *)dwLineVert2Ptr)[i] = dwValue;
                dwValue = ((DWORD *)dwVert1Ptr)[i];
                ((DWORD *)dwLineVert1Ptr)[i] = dwValue;
                ((DWORD *)dwLineVert3Ptr)[i] = dwValue;
            }
            if (fabs(((LPD3DTLVERTEX)dwLineVert2Ptr)->sx - ((LPD3DTLVERTEX)dwLineVert3Ptr)->sx) < fabs(((LPD3DTLVERTEX)dwLineVert2Ptr)->sy - ((LPD3DTLVERTEX)dwLineVert3Ptr)->sy))
            {
                ((LPD3DTLVERTEX)dwLineVert2Ptr)->sx += LINE_WIDTH;
                ((LPD3DTLVERTEX)dwLineVert3Ptr)->sx += LINE_WIDTH;
            }
            else
            {
                ((LPD3DTLVERTEX)dwLineVert2Ptr)->sy += LINE_WIDTH;
                ((LPD3DTLVERTEX)dwLineVert3Ptr)->sy += LINE_WIDTH;
            }

            /*
             * Call the low level rendering routine to draw the "line".
             */
#ifdef NV_FASTLOOPS
            nvTriangleDispatch(2, NULL, STRIP_STRIDES, (LPBYTE)LineVerts);
#else
            if (!pCurrentContext->bUseDX6Class)
                fnDX5FlexTable[pCurrentContext->dwFunctionLookup](2, STRIP_STRIDES, (LPBYTE)LineVerts);
            else
                fnDX6FlexTable[pCurrentContext->dwFunctionLookup](2, STRIP_STRIDES, (LPBYTE)LineVerts);
#endif
        }
        /*
         * Restore the culling mode.
         */
        if (!pCurrentContext->bUseDX6Class)
            pCurrentContext->ctxInnerLoop.dwControl = dwControl;
        else
            pCurrentContext->mtsState.dwControl0 = dwControl;

        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    /*
     * Force next render call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return;
}

/*
 * Indexed Flexible Vertex Format Lines.
 */
void nvFVFIndexedLine
(
    DWORD           dwPrimCount,
    LPWORD          lpIndices,
    DWORD           dwIndexInc,
    LPBYTE          lpVertices
)
{
    BYTE            LineVerts[4 * ((sizeof (D3DTLVERTEX)) + (7*2*4))];
    DWORD           dwLineVert0Ptr, dwLineVert1Ptr, dwLineVert2Ptr, dwLineVert3Ptr;
    DWORD           dwVert0Ptr, dwVert1Ptr;
    DWORD           i, dwDwordsPerVert;
    DWORD           dwControl;
    DWORD           dwOldCull;

    if (dwPrimCount)
    {
        /*
         * Calculate the new hardware state if neccessary.
         */
        if (pCurrentContext->dwStateChange)
        {
            if (pCurrentContext->bUseDX6Class)
            {
                nvSetMultiTextureHardwareState();
                if (pCurrentContext->bUseDX6Class)
                    nvSetHardwareState();
            }
            else
                nvSetHardwareState();
        }

        /*
         * Disable culling.
         */
        if (!pCurrentContext->bUseDX6Class)
        {
            dwControl = pCurrentContext->ctxInnerLoop.dwControl;
            pCurrentContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
            pCurrentContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        }
        else
        {
            dwControl = pCurrentContext->mtsState.dwControl0;
            pCurrentContext->mtsState.dwControl0 &= ~(DRF_MASK(NV055_CONTROL0_CULLMODE) << DRF_SHIFT(NV055_CONTROL0_CULLMODE));
            pCurrentContext->mtsState.dwControl0 |= DRF_DEF(055, _CONTROL0, _CULLMODE, _NONE);
        }
        dwOldCull = pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        /*
         * Force first call to be to the triangle state setup routine.
         */
        NV_FORCE_TRI_SETUP(pCurrentContext);

        dwDwordsPerVert = fvfData.dwVertexStride >> 2;

        /*
         * Get pointers to each of the 9 FVF wireframe line vertices.
         */
        GET_FVF_POINTER(dwLineVert0Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 0, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert1Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 1, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert2Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 2, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert3Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 3, fvfData.dwVertexStride);

        /*
         * Draw the lines.
         */
        while (dwPrimCount--)
        {
            /*
             * Each line is rendered as a one pixel wide rectangle.
             * Since we're contstructing new TLVERTEX structures anyway,
             * Construct full TLVERTEX structures up front from the FVF data
             * structures and then just call the TLVERTEX rendering loop.
             *
             * Get pointers to each vertex of current line.
             */
            GET_FVF_POINTER(dwVert0Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, lpIndices[0], fvfData.dwVertexStride);
            GET_FVF_POINTER(dwVert1Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, lpIndices[1], fvfData.dwVertexStride);
            lpIndices += dwIndexInc;

            /*
             * Copy the vertices.
             */
            for (i = 0; i < dwDwordsPerVert; i++)
            {
                DWORD   dwValue;
                dwValue = ((DWORD *)dwVert0Ptr)[i];
                ((DWORD *)dwLineVert0Ptr)[i] = dwValue;
                ((DWORD *)dwLineVert2Ptr)[i] = dwValue;
                dwValue = ((DWORD *)dwVert1Ptr)[i];
                ((DWORD *)dwLineVert1Ptr)[i] = dwValue;
                ((DWORD *)dwLineVert3Ptr)[i] = dwValue;
            }
            if (fabs(((LPD3DTLVERTEX)dwLineVert2Ptr)->sx - ((LPD3DTLVERTEX)dwLineVert3Ptr)->sx) < fabs(((LPD3DTLVERTEX)dwLineVert2Ptr)->sy - ((LPD3DTLVERTEX)dwLineVert3Ptr)->sy))
            {
                ((LPD3DTLVERTEX)dwLineVert2Ptr)->sx += LINE_WIDTH;
                ((LPD3DTLVERTEX)dwLineVert3Ptr)->sx += LINE_WIDTH;
            }
            else
            {
                ((LPD3DTLVERTEX)dwLineVert2Ptr)->sy += LINE_WIDTH;
                ((LPD3DTLVERTEX)dwLineVert3Ptr)->sy += LINE_WIDTH;
            }

            /*
             * Call the low level rendering routine to draw the "line".
             */
#ifdef NV_FASTLOOPS
            nvTriangleDispatch(2, NULL, STRIP_STRIDES, (LPBYTE)LineVerts);
#else
            if (!pCurrentContext->bUseDX6Class)
                fnDX5FlexTable[pCurrentContext->dwFunctionLookup](2, STRIP_STRIDES, (LPBYTE)LineVerts);
            else
                fnDX6FlexTable[pCurrentContext->dwFunctionLookup](2, STRIP_STRIDES, (LPBYTE)LineVerts);
#endif
        }
        /*
         * Restore the culling mode.
         */
        if (!pCurrentContext->bUseDX6Class)
            pCurrentContext->ctxInnerLoop.dwControl = dwControl;
        else
            pCurrentContext->mtsState.dwControl0 = dwControl;

        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    /*
     * Force next render call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return;
}

void nvFVFDrawWireframeTriangle
(
    DWORD         dwPrimCount,
    DWORD         dwStrides,
    LPBYTE        lpVertices
)
{
    BYTE        LineVerts[9 * ((sizeof (D3DTLVERTEX)) + (7*2*4))];
    DWORD       dwLineVert0Ptr, dwLineVert1Ptr, dwLineVert2Ptr;
    DWORD       dwLineVert3Ptr, dwLineVert4Ptr, dwLineVert5Ptr;
    DWORD       dwLineVert6Ptr, dwLineVert7Ptr, dwLineVert8Ptr;
    DWORD       dwVert0Ptr, dwVert1Ptr, dwVert2Ptr;
    DWORD       i, dwDwordsPerVert;
    DWORD       v0,v1,v2;
    DWORD       dwControl;
    DWORD       dwOldCull;
    DWORD       dwIndex1, dwIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    float       dwCullValue;

    if (dwPrimCount)
    {
        /*
         * Calculate the new hardware state if neccessary.
         */
        if (pCurrentContext->dwStateChange)
        {
            if (pCurrentContext->bUseDX6Class)
            {
                nvSetMultiTextureHardwareState();
                if (pCurrentContext->bUseDX6Class)
                    nvSetHardwareState();
            }
            else
                nvSetHardwareState();
        }

        /*
         * Disable lower level culling while drawing lines.
         */
        if (!pCurrentContext->bUseDX6Class)
        {
            dwControl = pCurrentContext->ctxInnerLoop.dwControl;
            pCurrentContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
            pCurrentContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        }
        else
        {
            dwControl = pCurrentContext->mtsState.dwControl0;
            pCurrentContext->mtsState.dwControl0 &= ~(DRF_MASK(NV055_CONTROL0_CULLMODE) << DRF_SHIFT(NV055_CONTROL0_CULLMODE));
            pCurrentContext->mtsState.dwControl0 |= DRF_DEF(055, _CONTROL0, _CULLMODE, _NONE);
        }
        dwOldCull = pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        /*
         * Calculate the culling masks.
         */
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        /*
         * Force first call to be to the triangle state setup routine.
         */
        NV_FORCE_TRI_SETUP(pCurrentContext);

        dwStrides      &= 0xffffff; // mask interesting bits
        dwIndex1        = 0;
        dwIndex2        = 1;
        dwIndexStrides  = dwStrides;
        dwDwordsPerVert = fvfData.dwVertexStride >> 2;

        /*
         * Get pointers to each of the 9 FVF wireframe line vertices.
         */
        GET_FVF_POINTER(dwLineVert0Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 0, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert1Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 1, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert2Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 2, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert3Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 3, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert4Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 4, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert5Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 5, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert6Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 6, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert7Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 7, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert8Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 8, fvfData.dwVertexStride);

        /*
         * Draw all triangles as a wireframe.
         */
        while (dwPrimCount--)
        {
            v0 = dwIndex1;
            v1 = dwIndex2 + (dwIndexStrides >> 24);
            v2 = dwIndex2 + ((dwIndexStrides >> 24) ^ 1);

            /*
             * Move on to the next triangle.
             */
            dwIndex1       += (BYTE)(dwIndexStrides >> 8);
            dwIndex2       += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwStrides << 8) & 0xff000000;

            /*
             * Each edge line is rendered as a one pixel wide rectangle.
             *
             * Get pointers to each vertex of current triangle.
             */
            GET_FVF_POINTER(dwVert0Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, v0, fvfData.dwVertexStride);
            GET_FVF_POINTER(dwVert1Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, v1, fvfData.dwVertexStride);
            GET_FVF_POINTER(dwVert2Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, v2, fvfData.dwVertexStride);

            /*
             * Since culling needs to be disabled to insure that the triangle edges get drawn properly,
             * back face culling of the triangle needs to be performed up front by software.
             */
            IF_NOT_CULLED_BEGIN(dwVert0Ptr,dwVert1Ptr,dwVert2Ptr,dwCullValue)
                for (i = 0; i < dwDwordsPerVert; i++)
                {
                    DWORD   dwValue;
                    dwValue = ((DWORD *)dwVert0Ptr)[i];
                    ((DWORD *)dwLineVert0Ptr)[i] = dwValue;
                    ((DWORD *)dwLineVert3Ptr)[i] = dwValue;
                    ((DWORD *)dwLineVert8Ptr)[i] = dwValue;

                    dwValue = ((DWORD *)dwVert1Ptr)[i];
                    ((DWORD *)dwLineVert1Ptr)[i] = dwValue;
                    ((DWORD *)dwLineVert4Ptr)[i] = dwValue;
                    ((DWORD *)dwLineVert5Ptr)[i] = dwValue;

                    dwValue = ((DWORD *)dwVert2Ptr)[i];
                    ((DWORD *)dwLineVert2Ptr)[i] = dwValue;
                    ((DWORD *)dwLineVert6Ptr)[i] = dwValue;
                    ((DWORD *)dwLineVert7Ptr)[i] = dwValue;
                }
                if (fabs(((LPD3DTLVERTEX)dwLineVert3Ptr)->sx - ((LPD3DTLVERTEX)dwLineVert4Ptr)->sx) < fabs(((LPD3DTLVERTEX)dwLineVert3Ptr)->sy - ((LPD3DTLVERTEX)dwLineVert4Ptr)->sy))
                {
                    ((LPD3DTLVERTEX)dwLineVert3Ptr)->sx += LINE_WIDTH;
                    ((LPD3DTLVERTEX)dwLineVert4Ptr)->sx += LINE_WIDTH;
                }
                else
                {
                    ((LPD3DTLVERTEX)dwLineVert3Ptr)->sy += LINE_WIDTH;
                    ((LPD3DTLVERTEX)dwLineVert4Ptr)->sy += LINE_WIDTH;
                }
                if (fabs(((LPD3DTLVERTEX)dwLineVert5Ptr)->sx - ((LPD3DTLVERTEX)dwLineVert6Ptr)->sx) < fabs(((LPD3DTLVERTEX)dwLineVert5Ptr)->sy - ((LPD3DTLVERTEX)dwLineVert6Ptr)->sy))
                {
                    ((LPD3DTLVERTEX)dwLineVert5Ptr)->sx += LINE_WIDTH;
                    ((LPD3DTLVERTEX)dwLineVert6Ptr)->sx += LINE_WIDTH;
                }
                else
                {
                    ((LPD3DTLVERTEX)dwLineVert5Ptr)->sy += LINE_WIDTH;
                    ((LPD3DTLVERTEX)dwLineVert6Ptr)->sy += LINE_WIDTH;
                }
                if (fabs(((LPD3DTLVERTEX)dwLineVert7Ptr)->sx - ((LPD3DTLVERTEX)dwLineVert8Ptr)->sx) < fabs(((LPD3DTLVERTEX)dwLineVert7Ptr)->sy - ((LPD3DTLVERTEX)dwLineVert8Ptr)->sy))
                {
                    ((LPD3DTLVERTEX)dwLineVert7Ptr)->sx += LINE_WIDTH;
                    ((LPD3DTLVERTEX)dwLineVert8Ptr)->sx += LINE_WIDTH;
                }
                else
                {
                    ((LPD3DTLVERTEX)dwLineVert7Ptr)->sy += LINE_WIDTH;
                    ((LPD3DTLVERTEX)dwLineVert8Ptr)->sy += LINE_WIDTH;
                }

                /*
                 * Draw the triangle edges.
                 */
#ifdef NV_FASTLOOPS
                nvTriangleDispatch(6, EdgeLine, LIST_STRIDES, (LPBYTE)LineVerts);
#else
                if (!pCurrentContext->bUseDX6Class)
                    fnDX5FlexIndexedTable[pCurrentContext->dwFunctionLookup](6, EdgeLine, LIST_STRIDES, LineVerts);
                else
                    fnDX6FlexIndexedTable[pCurrentContext->dwFunctionLookup](6, EdgeLine, LIST_STRIDES, LineVerts);
#endif
            IF_NOT_CULLED_END
        }
        /*
         * Restore the culling mode.
         */
        if (!pCurrentContext->bUseDX6Class)
            pCurrentContext->ctxInnerLoop.dwControl = dwControl;
        else
            pCurrentContext->mtsState.dwControl0 = dwControl;

        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    /*
     * Force first call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return;
}
void nvFVFIndexedWireframeTriangle
(
    DWORD         dwPrimCount,
    LPWORD        lpIndices,
    DWORD         dwStrides,
    LPBYTE        lpVertices
)
{
    BYTE        LineVerts[9 * ((sizeof (D3DTLVERTEX)) + (7*2*4))];
    DWORD       dwLineVert0Ptr, dwLineVert1Ptr, dwLineVert2Ptr;
    DWORD       dwLineVert3Ptr, dwLineVert4Ptr, dwLineVert5Ptr;
    DWORD       dwLineVert6Ptr, dwLineVert7Ptr, dwLineVert8Ptr;
    DWORD       dwVert0Ptr, dwVert1Ptr, dwVert2Ptr;
    DWORD       i, dwDwordsPerVert;
    DWORD       v0,v1,v2;
    DWORD       dwControl;
    DWORD       dwOldCull;
    DWORD       dwIndex1, dwIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    float       dwCullValue;

    if (dwPrimCount)
    {
        /*
         * Calculate the new hardware state if neccessary.
         */
        if (pCurrentContext->dwStateChange)
        {
            if (pCurrentContext->bUseDX6Class)
            {
                nvSetMultiTextureHardwareState();
                if (pCurrentContext->bUseDX6Class)
                    nvSetHardwareState();
            }
            else
                nvSetHardwareState();
        }

        /*
         * Disable lower level culling while drawing lines.
         */
        if (!pCurrentContext->bUseDX6Class)
        {
            dwControl = pCurrentContext->ctxInnerLoop.dwControl;
            pCurrentContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
            pCurrentContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        }
        else
        {
            dwControl = pCurrentContext->mtsState.dwControl0;
            pCurrentContext->mtsState.dwControl0 &= ~(DRF_MASK(NV055_CONTROL0_CULLMODE) << DRF_SHIFT(NV055_CONTROL0_CULLMODE));
            pCurrentContext->mtsState.dwControl0 |= DRF_DEF(055, _CONTROL0, _CULLMODE, _NONE);
        }
        dwOldCull = pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        /*
         * Calculate the culling masks.
         */
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        /*
         * Force first call to be to the triangle state setup routine.
         */
        NV_FORCE_TRI_SETUP(pCurrentContext);

        dwStrides     &= 0xffffff; // mask interesting bits
        dwIndex1       = (DWORD)lpIndices;
        dwIndex2       = (DWORD)lpIndices + 2;
        dwIndexStrides = dwStrides * 2;
        dwDwordsPerVert = fvfData.dwVertexStride >> 2;

        /*
         * Get pointers to each of the 9 FVF wireframe line vertices.
         */
        GET_FVF_POINTER(dwLineVert0Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 0, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert1Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 1, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert2Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 2, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert3Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 3, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert4Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 4, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert5Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 5, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert6Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 6, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert7Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 7, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert8Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 8, fvfData.dwVertexStride);

        /*
         * Draw all triangles as a wireframe.
         */
        while (dwPrimCount--)
        {
            v0 = *(WORD*) dwIndex1;
            v1 = *(WORD*)(dwIndex2 +  (dwIndexStrides >> 24));
            v2 = *(WORD*)(dwIndex2 + ((dwIndexStrides >> 24) ^ 2));

            /*
             * Move on to the next triangle.
             */
            dwIndex1       += (BYTE)(dwIndexStrides >> 8);
            dwIndex2       += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwIndexStrides << 8) & 0xff000000;

            /*
             * Each edge line is rendered as a one pixel wide rectangle.
             *
             * Get pointers to each vertex of current triangle.
             */
            GET_FVF_POINTER(dwVert0Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, v0, fvfData.dwVertexStride);
            GET_FVF_POINTER(dwVert1Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, v1, fvfData.dwVertexStride);
            GET_FVF_POINTER(dwVert2Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, v2, fvfData.dwVertexStride);

            /*
             * Since culling needs to be disabled to insure that the triangle edges get drawn properly,
             * back face culling of the triangle needs to be performed up front by software.
             */
            IF_NOT_CULLED_BEGIN(dwVert0Ptr,dwVert1Ptr,dwVert2Ptr,dwCullValue)
                for (i = 0; i < dwDwordsPerVert; i++)
                {
                    DWORD   dwValue;
                    dwValue = ((DWORD *)dwVert0Ptr)[i];
                    ((DWORD *)dwLineVert0Ptr)[i] = dwValue;
                    ((DWORD *)dwLineVert3Ptr)[i] = dwValue;
                    ((DWORD *)dwLineVert8Ptr)[i] = dwValue;

                    dwValue = ((DWORD *)dwVert1Ptr)[i];
                    ((DWORD *)dwLineVert1Ptr)[i] = dwValue;
                    ((DWORD *)dwLineVert4Ptr)[i] = dwValue;
                    ((DWORD *)dwLineVert5Ptr)[i] = dwValue;

                    dwValue = ((DWORD *)dwVert2Ptr)[i];
                    ((DWORD *)dwLineVert2Ptr)[i] = dwValue;
                    ((DWORD *)dwLineVert6Ptr)[i] = dwValue;
                    ((DWORD *)dwLineVert7Ptr)[i] = dwValue;
                }
                if (fabs(((LPD3DTLVERTEX)dwLineVert3Ptr)->sx - ((LPD3DTLVERTEX)dwLineVert4Ptr)->sx) < fabs(((LPD3DTLVERTEX)dwLineVert3Ptr)->sy - ((LPD3DTLVERTEX)dwLineVert4Ptr)->sy))
                {
                    ((LPD3DTLVERTEX)dwLineVert3Ptr)->sx += LINE_WIDTH;
                    ((LPD3DTLVERTEX)dwLineVert4Ptr)->sx += LINE_WIDTH;
                }
                else
                {
                    ((LPD3DTLVERTEX)dwLineVert3Ptr)->sy += LINE_WIDTH;
                    ((LPD3DTLVERTEX)dwLineVert4Ptr)->sy += LINE_WIDTH;
                }
                if (fabs(((LPD3DTLVERTEX)dwLineVert5Ptr)->sx - ((LPD3DTLVERTEX)dwLineVert6Ptr)->sx) < fabs(((LPD3DTLVERTEX)dwLineVert5Ptr)->sy - ((LPD3DTLVERTEX)dwLineVert6Ptr)->sy))
                {
                    ((LPD3DTLVERTEX)dwLineVert5Ptr)->sx += LINE_WIDTH;
                    ((LPD3DTLVERTEX)dwLineVert6Ptr)->sx += LINE_WIDTH;
                }
                else
                {
                    ((LPD3DTLVERTEX)dwLineVert5Ptr)->sy += LINE_WIDTH;
                    ((LPD3DTLVERTEX)dwLineVert6Ptr)->sy += LINE_WIDTH;
                }
                if (fabs(((LPD3DTLVERTEX)dwLineVert7Ptr)->sx - ((LPD3DTLVERTEX)dwLineVert8Ptr)->sx) < fabs(((LPD3DTLVERTEX)dwLineVert7Ptr)->sy - ((LPD3DTLVERTEX)dwLineVert8Ptr)->sy))
                {
                    ((LPD3DTLVERTEX)dwLineVert7Ptr)->sx += LINE_WIDTH;
                    ((LPD3DTLVERTEX)dwLineVert8Ptr)->sx += LINE_WIDTH;
                }
                else
                {
                    ((LPD3DTLVERTEX)dwLineVert7Ptr)->sy += LINE_WIDTH;
                    ((LPD3DTLVERTEX)dwLineVert8Ptr)->sy += LINE_WIDTH;
                }

                /*
                 * If this was called with RenderPrim, dwStrides will be LEGACY_STRIDES, otherwise it won't.
                 */
                if ((dwStrides != (LEGACY_STRIDES & 0xffffff)) ||
                    ((  ((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLETRIANGLE) == D3DTRIFLAG_EDGEENABLETRIANGLE))
                {
                    /*
                     * Draw the triangle edges.
                     */
#ifdef NV_FASTLOOPS
                    nvTriangleDispatch(6, EdgeLine, LIST_STRIDES, (LPBYTE)LineVerts);
#else
                    if (!pCurrentContext->bUseDX6Class)
                        fnDX5FlexIndexedTable[pCurrentContext->dwFunctionLookup](6, EdgeLine, LIST_STRIDES, LineVerts);
                    else
                        fnDX6FlexIndexedTable[pCurrentContext->dwFunctionLookup](6, EdgeLine, LIST_STRIDES, LineVerts);
#endif
                }
                else
                {
                    DWORD tri;
                    WORD  triLine[6*3];

                    tri = 0;
                    if (((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLE1)
                    {
                        triLine[0*3+0]   = EdgeLine[0*3+0];
                        triLine[0*3+1]   = EdgeLine[0*3+1];
                        triLine[0*3+2]   = EdgeLine[0*3+2];
                        tri++;
                        triLine[1*3+0] = EdgeLine[1*3+0];
                        triLine[1*3+1] = EdgeLine[1*3+1];
                        triLine[1*3+2] = EdgeLine[1*3+2];
                        tri++;
                    }
                    if (((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLE2)
                    {
                        triLine[tri*3+0] = EdgeLine[2*3+0];
                        triLine[tri*3+1] = EdgeLine[2*3+1];
                        triLine[tri*3+2] = EdgeLine[2*3+2];
                        tri++;
                        triLine[tri*3+0] = EdgeLine[3*3+0];
                        triLine[tri*3+1] = EdgeLine[3*3+1];
                        triLine[tri*3+2] = EdgeLine[3*3+2];
                        tri++;
                    }
                    if (((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLE3)
                    {
                        triLine[tri*3+0] = EdgeLine[4*3+0];
                        triLine[tri*3+1] = EdgeLine[4*3+1];
                        triLine[tri*3+2] = EdgeLine[4*3+2];
                        tri++;
                        triLine[tri*3+0] = EdgeLine[5*3+0];
                        triLine[tri*3+1] = EdgeLine[5*3+1];
                        triLine[tri*3+2] = EdgeLine[5*3+2];
                        tri++;
                    }
                    if (tri)
                    {
                        /*
                         * Draw the specified triangle edges.
                         */
#ifdef NV_FASTLOOPS
                        nvTriangleDispatch(tri, triLine, LIST_STRIDES, (LPBYTE)LineVerts);
#else
                        if (!pCurrentContext->bUseDX6Class)
                            fnDX5FlexIndexedTable[pCurrentContext->dwFunctionLookup](tri, triLine, LIST_STRIDES, LineVerts);
                        else
                            fnDX6FlexIndexedTable[pCurrentContext->dwFunctionLookup](tri, triLine, LIST_STRIDES, LineVerts);
#endif
                    }
                }
            IF_NOT_CULLED_END
        }
        /*
         * Restore the culling mode.
         */
        if (!pCurrentContext->bUseDX6Class)
            pCurrentContext->ctxInnerLoop.dwControl = dwControl;
        else
            pCurrentContext->mtsState.dwControl0 = dwControl;

        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    /*
     * Force first call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return;
}
#endif  // NVD3D_DX6
#endif  // NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4multi.c ===
#ifdef  NV4
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4MULTI.C                                                        *
*   NV4 DX6 Multi-texture routines.                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       04/24/98 - created                      *
*                                                                           *
\***************************************************************************/
#include <math.h>
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv3ddbg.h"
#include "nv4vxmac.h"

#ifdef  NVD3D_DX6

#ifndef NV_FASTLOOPS
void nvDX6FlexTriangleSetup
(
    WORD            wPrimCount,
    DWORD           dwStrides,
    LPBYTE          lpVertices
)
{
    if (pCurrentContext->dwStateChange)
    {
        nvSetMultiTextureHardwareState();
        if (!pCurrentContext->bUseDX6Class)
        {
            /*
             * The number of texture stages was reduced to 1.
             * Use DX5 Class instead of DX6 class.
             */
            nvDX5FlexTriangleSetup(wPrimCount, dwStrides, lpVertices);
            return;
        }
    }
    nvSetDx6MultiTextureState(pCurrentContext);
    /*
     * Now calculate the appropriate rendering routine and call it.
     *
     * Determine the fog table mode based on if fog is enabled and the
     * selected fog table mode.  A computed value of 0 = vertex or no fog,
     * non-zero values indicate the fog table mode.
     */
    CALC_FUNCTION_INDEX (pCurrentContext);

    fnDX6FlexTable[pCurrentContext->dwFunctionLookup](wPrimCount, dwStrides, lpVertices);
    return;
}

void nvDX6FlexIndexedTriangleSetup
(
    DWORD           dwPrimCount,
    LPWORD          lpwIndices,
    DWORD           dwStrides,
    LPBYTE          lpVertices
)
{
    if (pCurrentContext->dwStateChange)
    {
        nvSetMultiTextureHardwareState();
        if (!pCurrentContext->bUseDX6Class)
        {
            /*
             * The number of texture stages was reduced to 1.
             * Use DX5 Class instead of DX6 class.
             */
            nvDX5FlexIndexedTriangleSetup(dwPrimCount, lpwIndices, dwStrides, lpVertices);
            return;
        }
    }
    nvSetDx6MultiTextureState(pCurrentContext);
    /*
     * Now calculate the appropriate rendering routine and call it.
     *
     * Determine the fog table mode based on if fog is enabled and the
     * selected fog table mode.  A computed value of 0 = vertex or no fog,
     * non-zero values indicate the fog table mode.
     */
    CALC_FUNCTION_INDEX (pCurrentContext);

    fnDX6FlexIndexedTable[pCurrentContext->dwFunctionLookup](dwPrimCount, lpwIndices, dwStrides, lpVertices);
    return;
}

#endif //!NV_FASTLOOPS

#endif  // NVD3D_DX6

#endif  // NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4point.c ===
#ifdef  NV4
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4POINT.C                                                        *
*   The Direct 3d Point Rendereing routines.                                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       04/12/97 - created                      *
*                                                                           *
\***************************************************************************/
#include <math.h>
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv4vxmac.h"

/*
 * cull macro
 */
#define IF_NOT_CULLED_BEGIN(v0,v1,v2,cv) {             \
    DWORD _sx0  = v0 + 0;                              \
    DWORD _sy0  = v0 + 4;                              \
    DWORD _sx1  = v1 + 0;                              \
    DWORD _sy1  = v1 + 4;                              \
    DWORD _sx2  = v2 + 0;                              \
    DWORD _sy2  = v2 + 4;                              \
    float _dx10 = *(float*)_sx1 - *(float*)_sx0;       \
    float _dy10 = *(float*)_sy1 - *(float*)_sy0;       \
    float _dx20 = *(float*)_sx2 - *(float*)_sx0;       \
    float _dy20 = *(float*)_sy2 - *(float*)_sy0;       \
           cv   = _dx10*_dy20  - _dx20*_dy10;          \
    if (((*(DWORD*)&cv) ^ dwCullMask1) & dwCullMask2) {
#define IF_NOT_CULLED_END } }

/*
 * Non-Indexed TLVertex Point Lists.
 * This routine renders the specified number of points starting
 * with the vertex pointed to by lpVertices.
 * lpVertices is assumed to point to the first point to be rendered.
 */
void nvDrawPointList
(
    DWORD           dwPrimCount,
    LPD3DTLVERTEX   lpVertices
)
{
    DWORD           dwControl;
    DWORD           dwOldCull;
    D3DTLVERTEX     PointVerts[3];

    /*
     * Calculate the new hardware state if neccessary.
     */
    if (pCurrentContext->dwStateChange)
        {
#ifdef  NVD3D_DX6
            if (pCurrentContext->bUseDX6Class)
            {
                nvSetMultiTextureHardwareState();
                if (pCurrentContext->bUseDX6Class)
                    nvSetHardwareState();
            }
            else
#endif  // NVD3D_DX6
                nvSetHardwareState();
    }

    /*
     * Disable lower level culling while drawing lines.
     */
    dwControl = pCurrentContext->ctxInnerLoop.dwControl;
    pCurrentContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
    pCurrentContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
    dwOldCull = pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
    pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

    /*
     * Force first call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);

    /*
     * Draw all points.
     */
    while (dwPrimCount--)
    {
        /*
         * Render each point as a one pixel size triangle.
         */
        PointVerts[0] = lpVertices[0];

        PointVerts[0].sx += 0.5f;
        PointVerts[0].sy += 0.5f;
        nvFloor(PointVerts[0].sx, PointVerts[0].sx);
        nvFloor(PointVerts[0].sy, PointVerts[0].sy);

        PointVerts[1] = PointVerts[0];
        PointVerts[2] = PointVerts[0];
        PointVerts[1].sx += 1.0f;
        PointVerts[2].sy += 1.0f;

#ifdef NV_FASTLOOPS
        nvTriangleDispatch(1, NULL, STRIP_STRIDES, (LPBYTE)PointVerts);
#else
        fnDX5Table[pCurrentContext->dwFunctionLookup](1, STRIP_STRIDES, PointVerts);
#endif
        lpVertices++;
    }
    /*
     * Restore cull mode.
     */
    pCurrentContext->ctxInnerLoop.dwControl = dwControl;
    pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;

    /*
     * Force next render call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return;
}

DWORD nvRenderPoint
(
    DWORD           dwPrimCount,
    LPBYTE          lpPrim,
    LPD3DTLVERTEX   lpVertices
)
{
    nvDrawPointList(dwPrimCount, lpVertices);
    return (DD_OK);
}

void nvDrawPointTriangle
(
    DWORD         dwPrimCount,
    DWORD         dwStrides,
    LPD3DTLVERTEX lpVertices
)
{
    WORD        Point[9];
    D3DTLVERTEX PointVerts[9];
    DWORD       v1,v2,v3;
    DWORD       dwControl;
    DWORD       dwOldCull;
    DWORD       dwIndex1, dwIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    float       dwCullValue;

    if (dwPrimCount)
    {
        /*
         * Calculate the new hardware state if neccessary.
         */
        if (pCurrentContext->dwStateChange)
        {
#ifdef  NVD3D_DX6
            if (pCurrentContext->bUseDX6Class)
            {
                nvSetMultiTextureHardwareState();
                if (pCurrentContext->bUseDX6Class)
                    nvSetHardwareState();
            }
            else
#endif  // NVD3D_DX6
                nvSetHardwareState();
        }

        /*
         * Disable lower level culling while drawing lines.
         */
        dwControl = pCurrentContext->ctxInnerLoop.dwControl;
        pCurrentContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
        pCurrentContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        dwOldCull = pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        /*
         * Calculate the culling masks.
         */
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        /*
         * Force first call to be to the triangle state setup routine.
         */
        NV_FORCE_TRI_SETUP(pCurrentContext);

        dwStrides     &= 0xffffff; // mask interesting bits
        dwIndex1       = 0;
        dwIndex2       = 1;
        dwIndexStrides = dwStrides;

        /*
         * Make these a static array someday to improve performance.
         */
        Point[0] = 0;
        Point[1] = 1;
        Point[2] = 2;
        Point[3] = 3;
        Point[4] = 4;
        Point[5] = 5;
        Point[6] = 6;
        Point[7] = 7;
        Point[8] = 8;
        /*
         * Draw all triangles as vertex points.
         */
        while (dwPrimCount--)
        {
            v1 = dwIndex1;
            v2 = dwIndex2 + (dwIndexStrides >> 24);
            v3 = dwIndex2 + ((dwIndexStrides >> 24) ^ 1);

            /*
             * Move on to the next triangle.
             */
            dwIndex1       += (BYTE)(dwIndexStrides >> 8);
            dwIndex2       += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwIndexStrides << 8) & 0xff000000;

            /*
             * Since culling needs to be disabled to insure that the triangle edges get drawn properly,
             * back face culling of the triangle needs to be performed up front by software.
             */
            IF_NOT_CULLED_BEGIN((DWORD)&lpVertices[v1],(DWORD)&lpVertices[v2],(DWORD)&lpVertices[v3],dwCullValue)
                /*
                 * Each vertex is rendered as a one pixel size triangle.
                 */
                PointVerts[0] = lpVertices[v1];
                PointVerts[0].sx += 0.5f;
                PointVerts[0].sy += 0.5f;
                nvFloor(PointVerts[0].sx, PointVerts[0].sx);
                nvFloor(PointVerts[0].sy, PointVerts[0].sy);
                PointVerts[1] = lpVertices[v1];
                PointVerts[2] = lpVertices[v1];
                PointVerts[1].sx += 1.0f;
                PointVerts[2].sy += 1.0f;


                PointVerts[3] = lpVertices[v2];
                PointVerts[3].sx += 0.5f;
                PointVerts[3].sy += 0.5f;
                nvFloor(PointVerts[3].sx, PointVerts[3].sx);
                nvFloor(PointVerts[3].sy, PointVerts[3].sy);
                PointVerts[4] = lpVertices[v2];
                PointVerts[5] = lpVertices[v2];
                PointVerts[4].sx += 1.0f;
                PointVerts[5].sy += 1.0f;

                PointVerts[6] = lpVertices[v3];
                PointVerts[6].sx += 0.5f;
                PointVerts[6].sy += 0.5f;
                nvFloor(PointVerts[6].sx, PointVerts[6].sx);
                nvFloor(PointVerts[6].sy, PointVerts[6].sy);
                PointVerts[7] = lpVertices[v3];
                PointVerts[8] = lpVertices[v3];
                PointVerts[7].sx += 1.0f;
                PointVerts[8].sy += 1.0f;

                /*
                 * Draw the triangle vertices.
                 */
#ifdef NV_FASTLOOPS
                nvTriangleDispatch(3, Point, LIST_STRIDES, (LPBYTE)PointVerts);
#else
                fnDX5IndexedTable[pCurrentContext->dwFunctionLookup](3, Point, LIST_STRIDES, PointVerts);
#endif
            IF_NOT_CULLED_END
        }
        /*
         * Restore the culling mode.
         */
        pCurrentContext->ctxInnerLoop.dwControl = dwControl;
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    /*
     * Force first call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return;
}
void nvIndexedPointTriangle
(
    DWORD         dwPrimCount,
    LPWORD        lpIndices,
    DWORD         dwStrides,
    LPD3DTLVERTEX lpVertices
)
{
    WORD        Point[9];
    D3DTLVERTEX PointVerts[9];
    DWORD       v1,v2,v3;
    DWORD       dwControl;
    DWORD       dwOldCull;
    DWORD       dwIndex1, dwIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    float       dwCullValue;

    if (dwPrimCount)
    {
        /*
         * Calculate the new hardware state if neccessary.
         */
        if (pCurrentContext->dwStateChange)
        {
#ifdef  NVD3D_DX6
            if (pCurrentContext->bUseDX6Class)
            {
                nvSetMultiTextureHardwareState();
                if (pCurrentContext->bUseDX6Class)
                    nvSetHardwareState();
            }
            else
#endif  // NVD3D_DX6
                nvSetHardwareState();
        }

        /*
         * Disable lower level culling while drawing lines.
         */
        dwControl = pCurrentContext->ctxInnerLoop.dwControl;
        pCurrentContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
        pCurrentContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        dwOldCull = pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        /*
         * Calculate the culling masks.
         */
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        /*
         * Force first call to be to the triangle state setup routine.
         */
        NV_FORCE_TRI_SETUP(pCurrentContext);

        dwStrides     &= 0xffffff; // mask interesting bits
        dwIndex1       = (DWORD)lpIndices;
        dwIndex2       = (DWORD)lpIndices + 2;
        dwIndexStrides = dwStrides * 2;

        /*
         * Make these a static array someday to improve performance.
         */
        Point[0] = 0;
        Point[1] = 1;
        Point[2] = 2;
        Point[3] = 3;
        Point[4] = 4;
        Point[5] = 5;
        Point[6] = 6;
        Point[7] = 7;
        Point[8] = 8;
        /*
         * Draw all triangles as vertex points.
         */
        while (dwPrimCount--)
        {
            v1 = *(WORD*) dwIndex1;
            v2 = *(WORD*)(dwIndex2 +  (dwIndexStrides >> 24));
            v3 = *(WORD*)(dwIndex2 + ((dwIndexStrides >> 24) ^ 2));

            /*
             * Move on to the next triangle.
             */
            dwIndex1       += (BYTE)(dwIndexStrides >> 8);
            dwIndex2       += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwIndexStrides << 8) & 0xff000000;

            /*
             * Since culling needs to be disabled to insure that the triangle edges get drawn properly,
             * back face culling of the triangle needs to be performed up front by software.
             */
            IF_NOT_CULLED_BEGIN((DWORD)&lpVertices[v1],(DWORD)&lpVertices[v2],(DWORD)&lpVertices[v3],dwCullValue)
                /*
                 * Each vertex is rendered as a one pixel size triangle.
                 */
                PointVerts[0] = lpVertices[v1];
                PointVerts[0].sx += 0.5f;
                PointVerts[0].sy += 0.5f;
                nvFloor(PointVerts[0].sx, PointVerts[0].sx);
                nvFloor(PointVerts[0].sy, PointVerts[0].sy);
                PointVerts[1] = lpVertices[v1];
                PointVerts[2] = lpVertices[v1];
                PointVerts[1].sx += 1.0f;
                PointVerts[2].sy += 1.0f;

                PointVerts[3] = lpVertices[v2];
                PointVerts[3].sx += 0.5f;
                PointVerts[3].sy += 0.5f;
                nvFloor(PointVerts[3].sx, PointVerts[3].sx);
                nvFloor(PointVerts[3].sy, PointVerts[3].sy);
                PointVerts[4] = lpVertices[v2];
                PointVerts[5] = lpVertices[v2];
                PointVerts[4].sx += 1.0f;
                PointVerts[5].sy += 1.0f;

                PointVerts[6] = lpVertices[v3];
                PointVerts[6].sx += 0.5f;
                PointVerts[6].sy += 0.5f;
                nvFloor(PointVerts[6].sx, PointVerts[6].sx);
                nvFloor(PointVerts[6].sy, PointVerts[6].sy);
                PointVerts[7] = lpVertices[v3];
                PointVerts[8] = lpVertices[v3];
                PointVerts[7].sx += 1.0f;
                PointVerts[8].sy += 1.0f;

                /*
                 * Draw the triangle vertices.
                 */
#ifdef NV_FASTLOOPS
                nvTriangleDispatch(3, Point, LIST_STRIDES, (LPBYTE)PointVerts);
#else
                fnDX5IndexedTable[pCurrentContext->dwFunctionLookup](3, Point, LIST_STRIDES, PointVerts);
#endif
            IF_NOT_CULLED_END
        }
        /*
         * Restore the culling mode.
         */
        pCurrentContext->ctxInnerLoop.dwControl = dwControl;
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    /*
     * Force first call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return;
}
#ifdef  NVD3D_DX6
/*
 * Non-Indexed Flexible Vertex Format Point Lists.
 * This routine renders the specified number of points starting
 * with the vertex pointed to by lpVertices.
 * lpVertices is assumed to point to the first point to be rendered.
 */
void nvFVFDrawPointList
(
    DWORD           dwPrimCount,
    LPBYTE          lpVertices
)
{
    BYTE            PointVerts[3 * ((sizeof (D3DTLVERTEX)) + (7*2*4))];
    DWORD           dwPointVert0Ptr, dwPointVert1Ptr, dwPointVert2Ptr;
    DWORD           dwVert0Ptr;
    DWORD           i, dwDwordsPerVert;
    DWORD           dwControl;
    DWORD           dwOldCull;
    DWORD           dwVertexStride;

    /*
     * Calculate the new hardware state if neccessary.
     */
    if (pCurrentContext->dwStateChange)
    {
        if (pCurrentContext->bUseDX6Class)
        {
            nvSetMultiTextureHardwareState();
            if (pCurrentContext->bUseDX6Class)
                nvSetHardwareState();
        }
        else
            nvSetHardwareState();
    }

    /*
     * Disable lower level culling while drawing lines.
     */
    if (!pCurrentContext->bUseDX6Class)
    {
        dwControl = pCurrentContext->ctxInnerLoop.dwControl;
        pCurrentContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
        pCurrentContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
    }
    else
    {
        dwControl = pCurrentContext->mtsState.dwControl0;
        pCurrentContext->mtsState.dwControl0 &= ~(DRF_MASK(NV055_CONTROL0_CULLMODE) << DRF_SHIFT(NV055_CONTROL0_CULLMODE));
        pCurrentContext->mtsState.dwControl0 |= DRF_DEF(055, _CONTROL0, _CULLMODE, _NONE);
    }
    dwOldCull = pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
    pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;


    /*
     * Force first call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);

    /*
     * Draw all points.
     */
    dwVertexStride  = fvfData.dwVertexStride;
    dwDwordsPerVert = fvfData.dwVertexStride >> 2;

    /*
     * Get pointers to each of the 3 FVF point vertices.
     */
    GET_FVF_POINTER(dwPointVert0Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 0, fvfData.dwVertexStride);
    GET_FVF_POINTER(dwPointVert1Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 1, fvfData.dwVertexStride);
    GET_FVF_POINTER(dwPointVert2Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 2, fvfData.dwVertexStride);
    while (dwPrimCount--)
    {
        /*
         * Render each point as a one pixel size triangle.
         *
         * Get pointers to the vertex of current point.
         */
        GET_FVF_POINTER(dwVert0Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, 0, fvfData.dwVertexStride);
        lpVertices += dwVertexStride;

        /*
         * Copy the vertex data.
         */
        for (i = 0; i < dwDwordsPerVert; i++)
        {
            DWORD   dwValue;
            dwValue = ((DWORD *)dwVert0Ptr)[i];
            ((DWORD *)dwPointVert0Ptr)[i] = dwValue;
            ((DWORD *)dwPointVert1Ptr)[i] = dwValue;
            ((DWORD *)dwPointVert2Ptr)[i] = dwValue;
        }

        /*
         * Adjust vertex 0.
         */
        ((LPD3DTLVERTEX)dwPointVert0Ptr)->sx += 0.5f;
        ((LPD3DTLVERTEX)dwPointVert0Ptr)->sy += 0.5f;
        nvFloor(((LPD3DTLVERTEX)dwPointVert0Ptr)->sx, ((LPD3DTLVERTEX)dwPointVert0Ptr)->sx);
        nvFloor(((LPD3DTLVERTEX)dwPointVert0Ptr)->sy, ((LPD3DTLVERTEX)dwPointVert0Ptr)->sy);

        /*
         * Adjust vertex 1.
         */
        ((LPD3DTLVERTEX)dwPointVert1Ptr)->sx = ((LPD3DTLVERTEX)dwPointVert0Ptr)->sx + 1.0f;
        ((LPD3DTLVERTEX)dwPointVert1Ptr)->sy = ((LPD3DTLVERTEX)dwPointVert0Ptr)->sy;

        /*
         * Adjust vertex 2.
         */
        ((LPD3DTLVERTEX)dwPointVert2Ptr)->sx = ((LPD3DTLVERTEX)dwPointVert0Ptr)->sx;
        ((LPD3DTLVERTEX)dwPointVert2Ptr)->sy = ((LPD3DTLVERTEX)dwPointVert0Ptr)->sy + 1.0f;

#ifdef NV_FASTLOOPS
        nvTriangleDispatch(1, NULL, STRIP_STRIDES, (LPBYTE)PointVerts);
#else
        if (!pCurrentContext->bUseDX6Class)
            fnDX5FlexTable[pCurrentContext->dwFunctionLookup](1, STRIP_STRIDES, (LPBYTE)PointVerts);
        else
            fnDX6FlexTable[pCurrentContext->dwFunctionLookup](1, STRIP_STRIDES, (LPBYTE)PointVerts);
#endif
    }
    /*
     * Restore cull mode.
     */
    if (!pCurrentContext->bUseDX6Class)
        pCurrentContext->ctxInnerLoop.dwControl = dwControl;
    else
        pCurrentContext->mtsState.dwControl0 = dwControl;
    pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;

    /*
     * Force next render call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return;
}
void nvFVFDrawPointTriangle
(
    DWORD         dwPrimCount,
    DWORD         dwStrides,
    LPBYTE        lpVertices
)
{
    WORD        Point[9];
    BYTE        PointVerts[9 * ((sizeof (D3DTLVERTEX)) + (7*2*4))];
    DWORD       dwPointVert0Ptr, dwPointVert1Ptr, dwPointVert2Ptr;
    DWORD       dwPointVert3Ptr, dwPointVert4Ptr, dwPointVert5Ptr;
    DWORD       dwPointVert6Ptr, dwPointVert7Ptr, dwPointVert8Ptr;
    DWORD       dwVert0Ptr, dwVert1Ptr, dwVert2Ptr;
    DWORD       i, dwDwordsPerVert;
    DWORD       v1,v2,v3;
    DWORD       dwControl;
    DWORD       dwOldCull;
    DWORD       dwIndex1, dwIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    float       dwCullValue;

    if (dwPrimCount)
    {
        /*
         * Calculate the new hardware state if neccessary.
         */
        if (pCurrentContext->dwStateChange)
        {
            if (pCurrentContext->bUseDX6Class)
            {
                nvSetMultiTextureHardwareState();
                if (pCurrentContext->bUseDX6Class)
                    nvSetHardwareState();
            }
            else
                nvSetHardwareState();
        }

        /*
         * Disable lower level culling while drawing lines.
         */
        if (!pCurrentContext->bUseDX6Class)
        {
            dwControl = pCurrentContext->ctxInnerLoop.dwControl;
            pCurrentContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
            pCurrentContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        }
        else
        {
            dwControl = pCurrentContext->mtsState.dwControl0;
            pCurrentContext->mtsState.dwControl0 &= ~(DRF_MASK(NV055_CONTROL0_CULLMODE) << DRF_SHIFT(NV055_CONTROL0_CULLMODE));
            pCurrentContext->mtsState.dwControl0 |= DRF_DEF(055, _CONTROL0, _CULLMODE, _NONE);
        }
        dwOldCull = pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        /*
         * Calculate the culling masks.
         */
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        /*
         * Force first call to be to the triangle state setup routine.
         */
        NV_FORCE_TRI_SETUP(pCurrentContext);

        dwStrides     &= 0xffffff; // mask interesting bits
        dwIndex1       = 0;
        dwIndex2       = 1;
        dwIndexStrides = dwStrides;
        dwDwordsPerVert = fvfData.dwVertexStride >> 2;

        /*
         * Get pointers to each of the 9 FVF point triangle vertices.
         */
        GET_FVF_POINTER(dwPointVert0Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 0, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert1Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 1, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert2Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 2, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert3Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 3, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert4Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 4, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert5Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 5, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert6Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 6, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert7Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 7, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert8Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 8, fvfData.dwVertexStride);

        /*
         * Make these a static array someday to improve performance.
         */
        Point[0] = 0;
        Point[1] = 1;
        Point[2] = 2;
        Point[3] = 3;
        Point[4] = 4;
        Point[5] = 5;
        Point[6] = 6;
        Point[7] = 7;
        Point[8] = 8;
        /*
         * Draw all triangles as vertex points.
         */
        while (dwPrimCount--)
        {
            v1 = dwIndex1;
            v2 = dwIndex2 + (dwIndexStrides >> 24);
            v3 = dwIndex2 + ((dwIndexStrides >> 24) ^ 1);

            /*
             * Move on to the next triangle.
             */
            dwIndex1       += (BYTE)(dwIndexStrides >> 8);
            dwIndex2       += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwIndexStrides << 8) & 0xff000000;

            /*
             * Each vertex is rendered as a one pixel size triangle.
             *
             * Get pointers to each vertex of current triangle.
             */
            GET_FVF_POINTER(dwVert0Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, v1, fvfData.dwVertexStride);
            GET_FVF_POINTER(dwVert1Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, v2, fvfData.dwVertexStride);
            GET_FVF_POINTER(dwVert2Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, v3, fvfData.dwVertexStride);

            /*
             * Since culling needs to be disabled to insure that the triangle edges get drawn properly,
             * back face culling of the triangle needs to be performed up front by software.
             */
            IF_NOT_CULLED_BEGIN(dwVert0Ptr,dwVert1Ptr,dwVert2Ptr,dwCullValue)
                for (i = 0; i < dwDwordsPerVert; i++)
                {
                    DWORD   dwValue;
                    dwValue = ((DWORD *)dwVert0Ptr)[i];
                    ((DWORD *)dwPointVert0Ptr)[i] = dwValue;
                    ((DWORD *)dwPointVert1Ptr)[i] = dwValue;
                    ((DWORD *)dwPointVert2Ptr)[i] = dwValue;

                    dwValue = ((DWORD *)dwVert1Ptr)[i];
                    ((DWORD *)dwPointVert3Ptr)[i] = dwValue;
                    ((DWORD *)dwPointVert4Ptr)[i] = dwValue;
                    ((DWORD *)dwPointVert5Ptr)[i] = dwValue;

                    dwValue = ((DWORD *)dwVert2Ptr)[i];
                    ((DWORD *)dwPointVert6Ptr)[i] = dwValue;
                    ((DWORD *)dwPointVert7Ptr)[i] = dwValue;
                    ((DWORD *)dwPointVert8Ptr)[i] = dwValue;
                }

                ((LPD3DTLVERTEX)dwPointVert0Ptr)->sx += 0.5f;
                ((LPD3DTLVERTEX)dwPointVert0Ptr)->sy += 0.5f;
                nvFloor(((LPD3DTLVERTEX)dwPointVert0Ptr)->sx, ((LPD3DTLVERTEX)dwPointVert0Ptr)->sx);
                nvFloor(((LPD3DTLVERTEX)dwPointVert0Ptr)->sy, ((LPD3DTLVERTEX)dwPointVert0Ptr)->sy);
                ((LPD3DTLVERTEX)dwPointVert1Ptr)->sx = ((LPD3DTLVERTEX)dwPointVert0Ptr)->sx + 1.0f;
                ((LPD3DTLVERTEX)dwPointVert1Ptr)->sy = ((LPD3DTLVERTEX)dwPointVert0Ptr)->sy;
                ((LPD3DTLVERTEX)dwPointVert2Ptr)->sx = ((LPD3DTLVERTEX)dwPointVert0Ptr)->sx;
                ((LPD3DTLVERTEX)dwPointVert2Ptr)->sy = ((LPD3DTLVERTEX)dwPointVert0Ptr)->sy + 1.0f;

                ((LPD3DTLVERTEX)dwPointVert3Ptr)->sx += 0.5f;
                ((LPD3DTLVERTEX)dwPointVert3Ptr)->sy += 0.5f;
                nvFloor(((LPD3DTLVERTEX)dwPointVert3Ptr)->sx, ((LPD3DTLVERTEX)dwPointVert3Ptr)->sx);
                nvFloor(((LPD3DTLVERTEX)dwPointVert3Ptr)->sy, ((LPD3DTLVERTEX)dwPointVert3Ptr)->sy);
                ((LPD3DTLVERTEX)dwPointVert4Ptr)->sx = ((LPD3DTLVERTEX)dwPointVert3Ptr)->sx + 1.0f;
                ((LPD3DTLVERTEX)dwPointVert4Ptr)->sy = ((LPD3DTLVERTEX)dwPointVert3Ptr)->sy;
                ((LPD3DTLVERTEX)dwPointVert5Ptr)->sx = ((LPD3DTLVERTEX)dwPointVert3Ptr)->sx;
                ((LPD3DTLVERTEX)dwPointVert5Ptr)->sy = ((LPD3DTLVERTEX)dwPointVert3Ptr)->sy + 1.0f;

                ((LPD3DTLVERTEX)dwPointVert6Ptr)->sx += 0.5f;
                ((LPD3DTLVERTEX)dwPointVert6Ptr)->sy += 0.5f;
                nvFloor(((LPD3DTLVERTEX)dwPointVert6Ptr)->sx, ((LPD3DTLVERTEX)dwPointVert6Ptr)->sx);
                nvFloor(((LPD3DTLVERTEX)dwPointVert6Ptr)->sy, ((LPD3DTLVERTEX)dwPointVert6Ptr)->sy);
                ((LPD3DTLVERTEX)dwPointVert7Ptr)->sx = ((LPD3DTLVERTEX)dwPointVert6Ptr)->sx + 1.0f;
                ((LPD3DTLVERTEX)dwPointVert7Ptr)->sy = ((LPD3DTLVERTEX)dwPointVert6Ptr)->sy;
                ((LPD3DTLVERTEX)dwPointVert8Ptr)->sx = ((LPD3DTLVERTEX)dwPointVert6Ptr)->sx;
                ((LPD3DTLVERTEX)dwPointVert8Ptr)->sy = ((LPD3DTLVERTEX)dwPointVert6Ptr)->sy + 1.0f;

                /*
                 * Draw the triangle vertices.
                 */
#ifdef NV_FASTLOOPS
                nvTriangleDispatch(3, Point, LIST_STRIDES, (LPBYTE)PointVerts);
#else
                if (!pCurrentContext->bUseDX6Class)
                    fnDX5FlexIndexedTable[pCurrentContext->dwFunctionLookup](3, Point, LIST_STRIDES, PointVerts);
                else
                    fnDX6FlexIndexedTable[pCurrentContext->dwFunctionLookup](3, Point, LIST_STRIDES, PointVerts);
#endif
            IF_NOT_CULLED_END
        }
        /*
         * Restore the culling mode.
         */
        if (!pCurrentContext->bUseDX6Class)
            pCurrentContext->ctxInnerLoop.dwControl = dwControl;
        else
            pCurrentContext->mtsState.dwControl0 = dwControl;

        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    /*
     * Force first call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return;
}
void nvFVFIndexedPointTriangle
(
    DWORD         dwPrimCount,
    LPWORD        lpIndices,
    DWORD         dwStrides,
    LPBYTE        lpVertices
)
{
    WORD        Point[9];
    BYTE        PointVerts[9 * ((sizeof (D3DTLVERTEX)) + (7*2*4))];
    DWORD       dwPointVert0Ptr, dwPointVert1Ptr, dwPointVert2Ptr;
    DWORD       dwPointVert3Ptr, dwPointVert4Ptr, dwPointVert5Ptr;
    DWORD       dwPointVert6Ptr, dwPointVert7Ptr, dwPointVert8Ptr;
    DWORD       dwVert0Ptr, dwVert1Ptr, dwVert2Ptr;
    DWORD       i, dwDwordsPerVert;
    DWORD       v1,v2,v3;
    DWORD       dwControl;
    DWORD       dwOldCull;
    DWORD       dwIndex1, dwIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    float       dwCullValue;

    if (dwPrimCount)
    {
        /*
         * Calculate the new hardware state if neccessary.
         */
        if (pCurrentContext->dwStateChange)
        {
            if (pCurrentContext->bUseDX6Class)
            {
                nvSetMultiTextureHardwareState();
                if (pCurrentContext->bUseDX6Class)
                    nvSetHardwareState();
            }
            else
                nvSetHardwareState();
        }

        /*
         * Disable lower level culling while drawing lines.
         */
        if (!pCurrentContext->bUseDX6Class)
        {
            dwControl = pCurrentContext->ctxInnerLoop.dwControl;
            pCurrentContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
            pCurrentContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        }
        else
        {
            dwControl = pCurrentContext->mtsState.dwControl0;
            pCurrentContext->mtsState.dwControl0 &= ~(DRF_MASK(NV055_CONTROL0_CULLMODE) << DRF_SHIFT(NV055_CONTROL0_CULLMODE));
            pCurrentContext->mtsState.dwControl0 |= DRF_DEF(055, _CONTROL0, _CULLMODE, _NONE);
        }
        dwOldCull = pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        /*
         * Calculate the culling masks.
         */
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        /*
         * Force first call to be to the triangle state setup routine.
         */
        NV_FORCE_TRI_SETUP(pCurrentContext);

        dwStrides     &= 0xffffff; // mask interesting bits
        dwIndex1       = (DWORD)lpIndices;
        dwIndex2       = (DWORD)lpIndices + 2;
        dwIndexStrides = dwStrides * 2;
        dwDwordsPerVert = fvfData.dwVertexStride >> 2;

        /*
         * Get pointers to each of the 9 FVF point triangle vertices.
         */
        GET_FVF_POINTER(dwPointVert0Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 0, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert1Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 1, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert2Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 2, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert3Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 3, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert4Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 4, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert5Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 5, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert6Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 6, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert7Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 7, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert8Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 8, fvfData.dwVertexStride);

        /*
         * Make these a static array someday to improve performance.
         */
        Point[0] = 0;
        Point[1] = 1;
        Point[2] = 2;
        Point[3] = 3;
        Point[4] = 4;
        Point[5] = 5;
        Point[6] = 6;
        Point[7] = 7;
        Point[8] = 8;
        /*
         * Draw all triangles as vertex points.
         */
        while (dwPrimCount--)
        {
            v1 = *(WORD*) dwIndex1;
            v2 = *(WORD*)(dwIndex2 +  (dwIndexStrides >> 24));
            v3 = *(WORD*)(dwIndex2 + ((dwIndexStrides >> 24) ^ 2));

            /*
             * Move on to the next triangle.
             */
            dwIndex1       += (BYTE)(dwIndexStrides >> 8);
            dwIndex2       += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwIndexStrides << 8) & 0xff000000;

            /*
             * Each vertex is rendered as a one pixel size triangle.
             *
             * Get pointers to each vertex of current triangle.
             */
            GET_FVF_POINTER(dwVert0Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, v1, fvfData.dwVertexStride);
            GET_FVF_POINTER(dwVert1Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, v2, fvfData.dwVertexStride);
            GET_FVF_POINTER(dwVert2Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, v3, fvfData.dwVertexStride);

            /*
             * Since culling needs to be disabled to insure that the triangle edges get drawn properly,
             * back face culling of the triangle needs to be performed up front by software.
             */
            IF_NOT_CULLED_BEGIN(dwVert0Ptr,dwVert1Ptr,dwVert2Ptr,dwCullValue)
                for (i = 0; i < dwDwordsPerVert; i++)
                {
                    DWORD   dwValue;
                    dwValue = ((DWORD *)dwVert0Ptr)[i];
                    ((DWORD *)dwPointVert0Ptr)[i] = dwValue;
                    ((DWORD *)dwPointVert1Ptr)[i] = dwValue;
                    ((DWORD *)dwPointVert2Ptr)[i] = dwValue;

                    dwValue = ((DWORD *)dwVert1Ptr)[i];
                    ((DWORD *)dwPointVert3Ptr)[i] = dwValue;
                    ((DWORD *)dwPointVert4Ptr)[i] = dwValue;
                    ((DWORD *)dwPointVert5Ptr)[i] = dwValue;

                    dwValue = ((DWORD *)dwVert2Ptr)[i];
                    ((DWORD *)dwPointVert6Ptr)[i] = dwValue;
                    ((DWORD *)dwPointVert7Ptr)[i] = dwValue;
                    ((DWORD *)dwPointVert8Ptr)[i] = dwValue;
                }
                ((LPD3DTLVERTEX)dwPointVert0Ptr)->sx += 0.5f;
                ((LPD3DTLVERTEX)dwPointVert0Ptr)->sy += 0.5f;
                nvFloor(((LPD3DTLVERTEX)dwPointVert0Ptr)->sx, ((LPD3DTLVERTEX)dwPointVert0Ptr)->sx);
                nvFloor(((LPD3DTLVERTEX)dwPointVert0Ptr)->sy, ((LPD3DTLVERTEX)dwPointVert0Ptr)->sy);
                ((LPD3DTLVERTEX)dwPointVert1Ptr)->sx = ((LPD3DTLVERTEX)dwPointVert0Ptr)->sx + 1.0f;
                ((LPD3DTLVERTEX)dwPointVert1Ptr)->sy = ((LPD3DTLVERTEX)dwPointVert0Ptr)->sy;
                ((LPD3DTLVERTEX)dwPointVert2Ptr)->sx = ((LPD3DTLVERTEX)dwPointVert0Ptr)->sx;
                ((LPD3DTLVERTEX)dwPointVert2Ptr)->sy = ((LPD3DTLVERTEX)dwPointVert0Ptr)->sy + 1.0f;

                ((LPD3DTLVERTEX)dwPointVert3Ptr)->sx += 0.5f;
                ((LPD3DTLVERTEX)dwPointVert3Ptr)->sy += 0.5f;
                nvFloor(((LPD3DTLVERTEX)dwPointVert3Ptr)->sx, ((LPD3DTLVERTEX)dwPointVert3Ptr)->sx);
                nvFloor(((LPD3DTLVERTEX)dwPointVert3Ptr)->sy, ((LPD3DTLVERTEX)dwPointVert3Ptr)->sy);
                ((LPD3DTLVERTEX)dwPointVert4Ptr)->sx = ((LPD3DTLVERTEX)dwPointVert3Ptr)->sx + 1.0f;
                ((LPD3DTLVERTEX)dwPointVert4Ptr)->sy = ((LPD3DTLVERTEX)dwPointVert3Ptr)->sy;
                ((LPD3DTLVERTEX)dwPointVert5Ptr)->sx = ((LPD3DTLVERTEX)dwPointVert3Ptr)->sx;
                ((LPD3DTLVERTEX)dwPointVert5Ptr)->sy = ((LPD3DTLVERTEX)dwPointVert3Ptr)->sy + 1.0f;

                ((LPD3DTLVERTEX)dwPointVert6Ptr)->sx += 0.5f;
                ((LPD3DTLVERTEX)dwPointVert6Ptr)->sy += 0.5f;
                nvFloor(((LPD3DTLVERTEX)dwPointVert6Ptr)->sx, ((LPD3DTLVERTEX)dwPointVert6Ptr)->sx);
                nvFloor(((LPD3DTLVERTEX)dwPointVert6Ptr)->sy, ((LPD3DTLVERTEX)dwPointVert6Ptr)->sy);
                ((LPD3DTLVERTEX)dwPointVert7Ptr)->sx = ((LPD3DTLVERTEX)dwPointVert6Ptr)->sx + 1.0f;
                ((LPD3DTLVERTEX)dwPointVert7Ptr)->sy = ((LPD3DTLVERTEX)dwPointVert6Ptr)->sy;
                ((LPD3DTLVERTEX)dwPointVert8Ptr)->sx = ((LPD3DTLVERTEX)dwPointVert6Ptr)->sx;
                ((LPD3DTLVERTEX)dwPointVert8Ptr)->sy = ((LPD3DTLVERTEX)dwPointVert6Ptr)->sy + 1.0f;

                /*
                 * Draw the triangle vertices.
                 */
#ifdef NV_FASTLOOPS
                nvTriangleDispatch(3, Point, LIST_STRIDES, (LPBYTE)PointVerts);
#else
                if (!pCurrentContext->bUseDX6Class)
                    fnDX5FlexIndexedTable[pCurrentContext->dwFunctionLookup](3, Point, LIST_STRIDES, PointVerts);
                else
                    fnDX6FlexIndexedTable[pCurrentContext->dwFunctionLookup](3, Point, LIST_STRIDES, PointVerts);
#endif
            IF_NOT_CULLED_END
        }
        /*
         * Restore the culling mode.
         */
        if (!pCurrentContext->bUseDX6Class)
            pCurrentContext->ctxInnerLoop.dwControl = dwControl;
        else
            pCurrentContext->mtsState.dwControl0 = dwControl;

        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    /*
     * Force first call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return;
}
#endif  // NVD3D_DX6
#endif  // NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4prim.c ===
#ifdef  NV4
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4PRIM.C                                                         *
*   NV4 DX5 DrawPrimitives and DrawOnePrimitive DDI routines.               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/31/98 - created                      *
*                                                                           *
\***************************************************************************/
#include <math.h>
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv3ddbg.h"
#include "nv4vxmac.h"

#ifndef NV_FASTLOOPS
void nvDX5TriangleSetup
(
    WORD            wPrimCount,
    DWORD           dwStrides,
    LPD3DTLVERTEX   lpVertices
)
{
    /*
     * Send the context state down to the hardware.
     */
    if (pCurrentContext->dwStateChange)
        nvSetHardwareState();
    nvSetDx5TriangleState(pCurrentContext);

    /*
     * Now calculate the appropriate rendering routine and call it.
     *
     * Determine the fog table mode based on if fog is enabled and the
     * selected fog table mode.  A computed value of 0 = vertex or no fog,
     * non-zero values indicate the fog table mode.
     */
    CALC_FUNCTION_INDEX (pCurrentContext);

    fnDX5Table[pCurrentContext->dwFunctionLookup](wPrimCount, dwStrides, lpVertices);
    return;
}
#endif //!NV_FASTLOOPS

#ifndef WINNT
void nvDrawPrimitive
(
    WORD            wPrimType,
    WORD            wNumVertices,
    LPBYTE          lpVertexData

)
{
    WORD            wPrimCount;
    LPD3DTLVERTEX   lpVertices;

    lpVertices = (LPD3DTLVERTEX)lpVertexData;
    switch (wPrimType)
    {
        case D3DPT_TRIANGLELIST:
            wPrimCount = wNumVertices / 3;
            switch (pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE])
            {
                case D3DFILL_SOLID:
#ifdef NV_FASTLOOPS
                    nvTriangleDispatch(wPrimCount, NULL, LIST_STRIDES, (LPBYTE)lpVertices);
#else
                    fnDX5Table[pCurrentContext->dwFunctionLookup](wPrimCount, LIST_STRIDES, lpVertices);
#endif
                    break;
                case D3DFILL_WIREFRAME:
                    nvDrawWireframeTriangle(wPrimCount, LIST_STRIDES, lpVertices);
                    break;
                case D3DFILL_POINT:
                    nvDrawPointTriangle(wPrimCount, LIST_STRIDES, lpVertices);
                    break;
            }
            break;
        case D3DPT_TRIANGLESTRIP:
            wPrimCount = wNumVertices - 2;
            switch (pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE])
            {
                case D3DFILL_SOLID:
#ifdef NV_FASTLOOPS
                    nvTriangleDispatch(wPrimCount, NULL, STRIP_STRIDES, (LPBYTE)lpVertices);
#else
                    fnDX5Table[pCurrentContext->dwFunctionLookup](wPrimCount, STRIP_STRIDES, lpVertices);
#endif
                    break;
                case D3DFILL_WIREFRAME:
                    nvDrawWireframeTriangle(wPrimCount, STRIP_STRIDES, lpVertices);
                    break;
                case D3DFILL_POINT:
                    nvDrawWireframeTriangle(wPrimCount, STRIP_STRIDES, lpVertices);
                    break;
            }
            break;
        case D3DPT_TRIANGLEFAN:
            if ((wPrimCount = wNumVertices - 2) == 0)
                break;
            switch (pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE])
            {
                case D3DFILL_SOLID:
#ifdef NV_FASTLOOPS
                    nvTriangleDispatch(wPrimCount, NULL, FAN_STRIDES, (LPBYTE)lpVertices);
#else
                    fnDX5Table[pCurrentContext->dwFunctionLookup](wPrimCount, FAN_STRIDES, lpVertices);
#endif
                    break;
                case D3DFILL_WIREFRAME:
                    nvDrawWireframeTriangle(wPrimCount, FAN_STRIDES, lpVertices);
                    break;
                case D3DFILL_POINT:
                    nvDrawWireframeTriangle(wPrimCount, FAN_STRIDES, lpVertices);
                    break;
            }
            break;
        case D3DPT_LINELIST:
            wPrimCount = wNumVertices / 2;
            nvDrawLine((DWORD)wPrimCount, 2, lpVertices);
            break;
        case D3DPT_LINESTRIP:
            wPrimCount = wNumVertices - 1;
            nvDrawLine((DWORD)wPrimCount, 1, lpVertices);
            break;
        case D3DPT_POINTLIST:
//            nvDrawPointList((DWORD)((LPD3DHAL_DP2POINTS)lpPrim)->wCount, (LPD3DTLVERTEX)&lpVertices[((LPD3DHAL_DP2POINTS)lpPrim)->wVStart]);
            break;
    }
    /*
     * Update the put offset.
     */
    nvStartDmaBuffer (TRUE);
    pDriverData->TwoDRenderingOccurred   = 0;
    pDriverData->ThreeDRenderingOccurred = TRUE;
    return;
}

/*
 * DirectX 5.0 DrawOnePrimitive entry point.
 */
DWORD nvDrawOnePrimitive
(
    LPD3DHAL_DRAWONEPRIMITIVEDATA   pdopd
)
{
#ifdef NV_NULL_DRIVER
    pdopd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
#endif //NV_NULL_DRIVER

    DPF_LEVEL(NVDBG_LEVEL_DDI_ENTRY, "nvDrawOnePrimitive - PrimitiveType = %08lx, Vertex Count = %08lx", pdopd->PrimitiveType, pdopd->dwNumVertices);

    if (!pCurrentContext->lpLcl)
    {
        pdopd->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }

    if (!pDriverData->NvDevFlatDma)
    {
        pdopd->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Need to make sure that an unfriendly mode switch didn't sneak and not cause
     * us to get re-enabled properly.
     */
    if (pDriverData->fFullScreenDosOccurred)
    {
        if (pDriverData->fFullScreenDosOccurred & 0x01)
            nvD3DReenable();
        else
        {
            pdopd->ddrval = DD_OK;
            return (DDHAL_DRIVER_HANDLED);
        }
    }
    if (pCurrentContext->dwContextReset)
        nvResetContext((PNVD3DTEXTURE)NULL);

    /*
     * prep fvf data
     */
    {
        DWORD dwDummy1,dwDummy2;
        CHECK_FVF_DATA_AND_LOAD_TL (fvfData,D3DFVF_TLVERTEX,dwDummy1,dwDummy2);
    }

    /*
     * Just pass off this call to the DrawPrimitive helper routine.
     */
    if (pdopd->dwNumVertices)
    {
        /*
         * Setup frequently accessed globals.
         */
        NV_D3D_GLOBAL_SETUP();
        NV_AA_SEMANTICS_CHECK(pCurrentContext);
        if ((pCurrentContext->dwStateChange || pDriverData->TwoDRenderingOccurred)
         || (pDriverData->dDrawSpareSubchannelObject != D3D_DX5_TEXTURED_TRIANGLE))
            NV_FORCE_TRI_SETUP(pCurrentContext);

        /*
         * Always read the current free count on entry.
         */
#ifdef  CACHE_FREECOUNT
        nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetRenderTargetContexts + sizeSetRenderTarget));
#endif  // CACHE_FREECOUNT

        /*
         * If the surface has changed since the last render call, switch it now.
         */
        nvSetD3DSurfaceState(pCurrentContext);

        nvDrawPrimitive((WORD)pdopd->PrimitiveType,
                        (WORD)pdopd->dwNumVertices,
                        (LPBYTE)pdopd->lpvVertices);
        NV_D3D_GLOBAL_SAVE();
#ifdef  CACHE_FREECOUNT
        pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
    }

    /*
     * Return successfully.
     */
    pdopd->ddrval = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}

/*
 * DirectX 5.0 DrawPrimitives entry point.
 */
DWORD nvDrawPrimitives
(
    LPD3DHAL_DRAWPRIMITIVESDATA pdpd
)
{
    WORD                        wStateCount;
    LPBYTE                      lpData;
    LPDWORD                     lpStateChanges;
    LPD3DHAL_DRAWPRIMCOUNTS     lpDrawPrimCounts;

#ifdef NV_NULL_DRIVER
    pdpd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
#endif //NV_NULL_DRIVER

    DPF_LEVEL(NVDBG_LEVEL_DDI_ENTRY, "nvDrawPrimitives - hContext = %08lx", pdpd->dwhContext);

    /*
     * assert valid
     */
    if (!pCurrentContext->lpLcl)
    {
        pdpd->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }

    if (!pDriverData->NvDevFlatDma)
    {
        pdpd->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Need to make sure that an unfriendly mode switch didn't sneak and not cause
     * us to get re-enabled properly.
     */
    if (pDriverData->fFullScreenDosOccurred)
    {
        if (pDriverData->fFullScreenDosOccurred & 0x01)
            nvD3DReenable();
        else
        {
            pdpd->ddrval = DD_OK;
            return (DDHAL_DRIVER_HANDLED);
        }
    }
    if (pCurrentContext->dwContextReset)
        nvResetContext((PNVD3DTEXTURE)NULL);

    /*
     * Setup frequently accessed globals.
     */
    NV_D3D_GLOBAL_SETUP();
    if ((pCurrentContext->dwStateChange || pDriverData->TwoDRenderingOccurred)
     || (pDriverData->dDrawSpareSubchannelObject != D3D_DX5_TEXTURED_TRIANGLE))
        NV_FORCE_TRI_SETUP(pCurrentContext);

    /*
     * prep fvf data
     */
    {
        DWORD dwDummy1,dwDummy2;
        CHECK_FVF_DATA_AND_LOAD_TL (fvfData,D3DFVF_TLVERTEX,dwDummy1,dwDummy2);
    }

    /*
     * Always read the current free count on entry.
     */
#ifdef  CACHE_FREECOUNT
    nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetRenderTargetContexts + sizeSetRenderTarget));
#endif  // CACHE_FREECOUNT

    /*
     * If the surface has changed since the last render call, switch it now.
     */
    nvSetD3DSurfaceState(pCurrentContext);

    /*
     * Get the pointer to the primitive data.
     */
    lpData            = (LPBYTE)pdpd->lpvData;
    lpDrawPrimCounts  = (LPD3DHAL_DRAWPRIMCOUNTS)lpData;

    /*
     * Step through callback data until there are no more vertices left
     * in the structure.
     */
    do
    {
        /*
         * Get the next draw primitive data structure.
         */
        lpDrawPrimCounts  = (LPD3DHAL_DRAWPRIMCOUNTS)lpData;
        lpData           += sizeof(D3DHAL_DRAWPRIMCOUNTS);

        if (!lpDrawPrimCounts)
        {
            dbgD3DError();
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvDrawPrimitives - Invalid lpDrawPrimCounts!!");
        }

        /*
         * Get the pointer to the first set of state change data.
         * If the wNumStateChanges value is 0, then there are no
         * state changes for this set of vertices.  This can happen
         * at any time, including for the first set of vertices, which
         * means that the current state should be used, or even for
         * two or more blocks of vertices in a row.
         */
        lpStateChanges    = (LPDWORD)lpData;
        if (!lpStateChanges)
        {
            dbgD3DError();
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvDrawPrimitives - Invalid lpDrawPrimCounts!!");
        }
        if (wStateCount = lpDrawPrimCounts->wNumStateChanges)
        {
            while (wStateCount--)
            {
                /*
                 * Process the state changes for the next set of vertices.
                 */
                nvSetContextState(lpStateChanges[0], lpStateChanges[1], &pdpd->ddrval);
                if (pdpd->ddrval != DD_OK)
                    return (DDHAL_DRIVER_HANDLED);
                lpStateChanges += 2;
            }
            /*
             * If the state has changed force a hardware state load.
             */
            if (pCurrentContext->dwStateChange)
                NV_FORCE_TRI_SETUP(pCurrentContext);
        }

        /*
         * Move the pointer to the first block of vertices to be rendered.
         */
        lpData += ((lpDrawPrimCounts->wNumStateChanges * sizeof(DWORD) * 2) + 31);
        lpData = (LPBYTE)((DWORD)lpData & ~31);

        /*
         * Render the vertices.
         */
        if (lpDrawPrimCounts->wNumVertices)
        {
            WORD wPrimitiveType = lpDrawPrimCounts->wPrimitiveType;

            nvDrawPrimitive(wPrimitiveType,
                            lpDrawPrimCounts->wNumVertices,
                            lpData);

            lpData += (lpDrawPrimCounts->wNumVertices * sizeof(D3DTLVERTEX));
        }
    } while (lpDrawPrimCounts->wNumVertices);

    /*
     * Return successfully.
     */
    NV_D3D_GLOBAL_SAVE();
#ifdef  CACHE_FREECOUNT
    pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
    pdpd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}
#endif // #ifndef WINNT
#endif  // NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4rendr.c ===
#ifdef  NV4
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4RENDR.C                                                        *
*   HW Specivic D3D Rendereing routines.                                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman               01/31/98 - NV4 development.             *
*                                                                           *
\***************************************************************************/
#include <math.h>
#include <windows.h>
#include <conio.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv4dreg.h"
#include "nv3ddbg.h"

#define PUSH_THRESHOLD (DWORD)(1024)

/*
 * DMA kickoff routines.
 */
#define sizeDmaBufferPad 0

DWORD   dbgLastGetAddr;

DWORD __stdcall nvGetDmaFreeCount
(
    long sizeRequired
)
{
    Nv4ControlDma *dmaChannel         = (Nv4ControlDma *)pDriverData->NvDevFlatDma;
    DWORD          getOffset;
    DWORD          putOffset;
    long           freeCount;
    BOOL           bWait;

    /*
     * aa capture override - allocate more space
     */
    if ((pCurrentContext)
     && (pCurrentContext->dwAntiAliasFlags & AA_CAPTURE_PUSHBUFFER))
    {
        PNVAACONTEXT pCtx = pCurrentContext->pAAContext;
        DWORD        dif  = ((sizeRequired << 2) + 16383) & ~16383;
        pCtx->dwCapIndex  = nvFifo - pCtx->dwCapAddr;
        pCtx->dwCapSize  += dif;
        pCtx->dwCapAddr   = (DWORD)ReallocIPM((void*)pCtx->dwCapAddr,pCtx->dwCapSize);
        nvFifo            = pCtx->dwCapAddr + pCtx->dwCapIndex;
        return (pCtx->dwCapSize - pCtx->dwCapIndex) >> 2;
    }

#ifdef NV_PROFILE
    /*
     * FreeCount Wait Log
     */
    NVP_START(NVP_T_FREECOUNT);
#endif

    bWait = FALSE;
    for (;;) {
        getOffset   = (DWORD)(volatile)dmaChannel->Get;
#ifdef DEBUG
        if (getOffset > nvDmaPushOffsetMax)
        {
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "Invalid Get Offset!!");
            dbgD3DError();
        }
        dbgLastGetAddr = getOffset;
#endif
        putOffset = (DWORD)nvFifo - (DWORD)nvDmaPushBase;

        if (putOffset >= getOffset)
        /*
         * |       G......P     |
         */
        {
            freeCount = (long)(nvDmaPushOffsetMax - putOffset) >> 2;
        // deal with wrapping around
            if ((freeCount <= sizeRequired) && getOffset)
            {
                *((volatile DWORD *)nvFifo) = (0x20000000 | (0));
#if 1
                /*
                 * Don't want this, but it's currently the only known way to
                 * guarantee a write combine flush.
                 */
                _outp (0x3d0,0);
#endif

#ifdef NV_NULL_HW_DRIVER
                if (nvDmaLastPutAddr) ((DWORD*)nvDmaLastPutAddr)[0] = 0x20000000 | 0;
#endif //NV_NULL_HW_DRIVER

                *((volatile DWORD *)&pDriverData->NvDmaPusherBufferEnd[0]) = 0;

                /*
                 * Multiple push buffer sync up.
                 */
                WAIT_FOR_VSYNC(pCurrentContext);
                NV_DD_DMA_PUSHER_SYNC();

                /*
                 * push buffer disassembler
                 */
#ifdef NV_DISASM
                {
                    extern HANDLE nvPusherFile;
                    extern BOOL   nvPusherDisassemblerEnable;
                    if (nvPusherFile && nvPusherDisassemblerEnable)
                    {
                        DWORD dw;
                        WriteFile (nvPusherFile,(void*)nvDmaLastPutAddr,(DWORD)nvFifo-(DWORD)nvDmaLastPutAddr+4,&dw,0);
                        FlushFileBuffers (nvPusherFile);
                    }
                }
#endif
                (volatile)dmaChannel->Put = putOffset = 0;
                nvDmaLastPutAddr = nvFifo = (DWORD)nvDmaPushBase;
                DPF_LEVEL(NVDBG_LEVEL_INFO2, "Last Put = 0x%08lx",nvDmaLastPutAddr);

                bWait = FALSE;
            }
        }
        else
        /*
         * |.......P      G.....|
         */
        {
            freeCount = ((getOffset - putOffset) >> 2) - 1;
        }

        /*
         * Maximize freeCount
         */
        if (((DWORD)nvFifo - (DWORD)nvDmaLastPutAddr) >= PUSH_THRESHOLD)
        {
            *((volatile DWORD *)&pDriverData->NvDmaPusherBufferEnd[0]) = putOffset;
#if 1
                /*
                 * Don't want this, but it's currently the only known way to
                 * guarantee a write combine flush.
                 */
                _outp (0x3d0,0);
#endif

            /*
             * Multiple push buffer sync up.
             */
            WAIT_FOR_VSYNC(pCurrentContext);
            NV_DD_DMA_PUSHER_SYNC();

#ifdef NV_NULL_HW_DRIVER
            if (nvDmaLastPutAddr) ((DWORD*)nvDmaLastPutAddr)[0] = 0x20000000 | putOffset;
#endif //NV_NULL_HW_DRIVER

            /*
             * push buffer disassembler
             */
#ifdef NV_DISASM
            {
                extern HANDLE nvPusherFile;
                extern BOOL   nvPusherDisassemblerEnable;
                if (nvPusherFile && nvPusherDisassemblerEnable)
                {
                    DWORD dw;
                    WriteFile (nvPusherFile,(void*)nvDmaLastPutAddr,(DWORD)nvFifo-(DWORD)nvDmaLastPutAddr,&dw,0);
                    FlushFileBuffers (nvPusherFile);
                }
            }
#endif
            (volatile)dmaChannel->Put = putOffset;
            nvDmaLastPutAddr = nvFifo;
            DPF_LEVEL(NVDBG_LEVEL_INFO2, "Last Put = 0x%08lx",nvDmaLastPutAddr);
        }

        if (freeCount > sizeRequired) break;

        if (bWait)
        {
            NV_DELAY;
        }
        bWait = TRUE;
    }

#ifdef NV_PROFILE
    /*
     * FreeCount Wait Log
     */
    NVP_STOP(NVP_T_FREECOUNT);
    nvpLogTime (NVP_T_FREECOUNT,nvpTime[NVP_T_FREECOUNT]);
#endif

    return freeCount;
}

void nvStartDmaBuffer
(
    BOOL bOptional
)
{
    DWORD           dwCurrentOffset;
    Nv4ControlDma  *nvDmaControl;

    /*
     * aa capture override - ignore kickoff
     */
    if (pCurrentContext)
        if (pCurrentContext->dwAntiAliasFlags & AA_CAPTURE_PUSHBUFFER)
            return;

    /*
     * Is it worth sending stuff now?
     */
    if (bOptional)
    {
        if (((DWORD)nvFifo-(DWORD)nvDmaLastPutAddr) < PUSH_THRESHOLD) return;
    }
//    if (nvDmaLastPutAddr == nvFifo)
//        return;

    /*
     * Update the ending dma offset.
     */
    if ((!pDriverData->NvDevFlatDma)
     || (pDriverData->fFullScreenDosOccurred))
        return;

    nvDmaControl = (Nv4ControlDma *)pDriverData->NvDevFlatDma;

    dwCurrentOffset = nvFifo - nvDmaPushBase;

#ifdef NV_NULL_HW_DRIVER
    if (nvDmaLastPutAddr) ((DWORD*)nvDmaLastPutAddr)[0] = 0x20000000 | dwCurrentOffset;
#endif //NV_NULL_HW_DRIVER

    dwCurrentOffset = nvFifo - nvDmaPushBase;
    *((volatile DWORD *)&pDriverData->NvDmaPusherBufferEnd[0]) = dwCurrentOffset;
#if 1
                /*
                 * Don't want this, but it's currently the only known way to
                 * guarantee a write combine flush.
                 */
                _outp (0x3d0,0);
#endif

    /*
     * Multiple push buffer sync up.
     */
    WAIT_FOR_VSYNC(pCurrentContext);
    NV_DD_DMA_PUSHER_SYNC();

#ifdef NV_PROFILE
    nvpLogEvent (NVP_E_PUT);
    {
        DWORD put = nvDmaLastPutAddr - nvDmaPushBase;
        DWORD get = (volatile)nvDmaControl->Get;

        if (put >= get)
        {
            nvpLogCount (NVP_C_PENDING,put-get);
        }
        else
        {
            get = (nvDmaPushOffsetMax - get) + put;
            nvpLogCount (NVP_C_PENDING,get);
        }
    }
#endif

    /*
     * push buffer disassembler
     */
#ifdef NV_DISASM
    {
        extern HANDLE nvPusherFile;
        extern BOOL   nvPusherDisassemblerEnable;
        if (nvPusherFile && nvPusherDisassemblerEnable)
        {
            DWORD dw;
            WriteFile (nvPusherFile,(void*)nvDmaLastPutAddr,(DWORD)nvFifo-(DWORD)nvDmaLastPutAddr,&dw,0);
            FlushFileBuffers (nvPusherFile);
        }
    }
#endif

    (volatile)nvDmaControl->Put = dwCurrentOffset;

    nvDmaLastPutAddr = nvFifo; // important - used by TexMan
    DPF_LEVEL(NVDBG_LEVEL_INFO2, "Last Put = 0x%08lx",nvDmaLastPutAddr);
    return;
}

void nvFlushDmaBuffers
(
    void
)
{
    DWORD           dwDmaLastPutOffset;
    Nv4ControlDma  *nvDmaControl;

    if ((!pDriverData->NvDevFlatDma)
     || (pDriverData->fFullScreenDosOccurred))
        return;

    /*
     * aa capture override - ignore kickoff
     */
    if (pCurrentContext)
        if (pCurrentContext->dwAntiAliasFlags & AA_CAPTURE_PUSHBUFFER)
            return;

    nvDmaControl = (Nv4ControlDma *)pDriverData->NvDevFlatDma;

    /*
     * Setup frequently accessed globals.
     */
    NV_D3D_GLOBAL_SETUP();

    DPF_LEVEL(NVDBG_LEVEL_INFO2, "nvFlushDmaBuffers - Kick off outstanding data.");
    nvStartDmaBuffer (FALSE);

    /*
     * Wait for the buffer to finish.
     * This is done by waiting for the (Get == LastPut)
     */
    dwDmaLastPutOffset = nvFifo - nvDmaPushBase;
    while (nvDmaControl->Get != dwDmaLastPutOffset)
    {
        NV_DELAY;
    }

#if 1   // TEMPORARY_HACK
    DPF_LEVEL(NVDBG_LEVEL_INFO2, "nvFlushDmaBuffers - Wait for Graphics Engine Idle!!!");
    while (*(volatile DWORD *)(pDriverData->NvBaseFlat + 0x400700));
#endif

    NV_D3D_GLOBAL_SAVE();
    return;
}
#endif  // NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4prof.c ===
#ifdef NV4
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4PROF.C                                                         *
*   NV4 Specific profiling routines.                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 05/28/98 - NV4 development.             *
*                                                                           *
\***************************************************************************/
#include <math.h>
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv3ddbg.h"
#include "nv4dinc.h"
#include "..\..\..\..\..\sdk\nvidia\inc\nvcm.h"

#ifdef NV_PROFILE

#if 0

/*
 * ----------
 * Locutus II
 * ----------
 */

/*
 * header files
 * ------------
 */
#include <stdio.h>
#include "..\..\..\..\..\apps\performance\locutus ii\dbase.h"

/*
 * constants
 * ---------
 */
#define L2_REG_VALUE            "Direct3D"

#define NVP_CAPMAX              65536
#define NVP_CAPMARK             65000

/*
 * locals
 * ------
 */
DWORD   nvpContextCount  = 0;
HANDLE  nvpFile          = 0;
DWORD   nvpCount         = 0;
DWORD   nvpEnableBits    = 0;
DWORD   nvpCyclesPerNanoSecond = 0;
__int64 nvpStartTime;
__int64 nvpTime[256];
BYTE    nvpData[NVP_CAPMAX];

L2ALPHABET nvpL2Alphabet[] =
{
    { NVP_T_CLOCK,      "t.clock",              L2_ALPHABETFLAG_TIME},
    { NVP_T_FLUSH,      "t.flush2disk",         L2_ALPHABETFLAG_TIME},
    { NVP_T_SCENE,      "t.scene",              L2_ALPHABETFLAG_TIME},
    { NVP_T_FLIP,       "t.wait4flip",          L2_ALPHABETFLAG_TIME},
    { NVP_T_DP2,        "t.dprim2",             L2_ALPHABETFLAG_TIME},
    { NVP_T_FREECOUNT,  "t.wait4pushbuffer",    L2_ALPHABETFLAG_TIME},
    { NVP_T_SCENE,      "t.scene",              L2_ALPHABETFLAG_TIME},
    { NVP_T_TSTAGE,     "t.wait4texstaging",    L2_ALPHABETFLAG_TIME},

    { NVP_E_PUT,        "e.put",                L2_ALPHABETFLAG_TIME},
    { NVP_E_BEGINSCENE, "e.beginscene",         L2_ALPHABETFLAG_TIME},

    { NVP_C_PENDING,    "c.pending",            L2_ALPHABETFLAG_COUNT},
};

/*
 * public functions
 * ----------------
 */

/*
 * nvpFlush
 *
 * commits data to disk
 */
void nvpFlush
(
    void
)
{
    /*
     * do we have pending data?
     */
    if (nvpCount) {
        DWORD dw;

        /*
         * time the HD access
         */
        NVP_START (NVP_T_FLUSH);

        /*
         * flush data
         */
        WriteFile(nvpFile,nvpData,nvpCount,&dw,0);
        FlushFileBuffers (nvpFile);
        nvpCount = 0;

        /*
         * log HD access time
         */
        NVP_STOP (NVP_T_FLUSH);
        nvpLogTime (NVP_T_FLUSH,nvpTime[NVP_T_FLUSH]);
    }
}

/*
 * nvpCreate
 *
 * creates a profiling session
 */
void nvpCreate
(
    void
)
{
    HKEY  hKey;
    char  szFilename[512];
    DWORD i,j;

    /*
     * setup defaults and read overrides from regisry
     */
    nvpCyclesPerNanoSecond = 1000 / global.dwProcessorSpeed; // works up to 1GHz
    nvpEnableBits          = 7;

    /*
     * open
     */
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, L2_REG_KEY, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
    {
        DWORD dwType  = REG_DWORD;
        DWORD dwSize  = sizeof(DWORD);
        DWORD dwValue;

        /*
         * read enable bits
         */
        if (RegQueryValueEx(hKey,
                            L2_REG_VALUE,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            nvpEnableBits = dwValue;
        }

        /*
         * close
         */
        RegCloseKey (hKey);
    }

    /*
     * always force flush2disk and clock ticks on
     * always disable unused bits
     */
    nvpEnableBits &= NVP_EVERYTHING;
    nvpEnableBits |= 3;

    /*
     * create profiling file
     */
    sprintf (szFilename,"\\cap%02d.lc2",++nvpContextCount);
    nvpFile = CreateFile(szFilename,GENERIC_WRITE,0,0,CREATE_ALWAYS,0,0);
    if (nvpFile == INVALID_HANDLE_VALUE)
    {
        OutputDebugString ("Profiler failed\n");
        __asm int 3;
    }
    nvpCount = 0;

    /*
     * write header
     */
    for (i = nvpEnableBits, j = 0; i;)
    {
        i &= i-1;
        j++;
    }
    {
        L2HEADER nvpL2Header =
        {
            L2_FILEID,
            j
        };
        memcpy (nvpData + nvpCount,&nvpL2Header,sizeof(nvpL2Header));
        nvpCount += sizeof(nvpL2Header);
    }

    /*
     * write alphabet entries
     */
    for (j = 0; j < 32; j++)
    {
        if (nvpEnableBits & (1 << j))
        {
            for (i = 0; i<sizeof(nvpL2Alphabet) / sizeof(nvpL2Alphabet[0]); i++)
            {
                if (j == nvpL2Alphabet[i].bID)
                {
                    memcpy (nvpData + nvpCount,nvpL2Alphabet + i,sizeof(nvpL2Alphabet[0]));
                    nvpCount += sizeof(nvpL2Alphabet[0]);
                    break;
                }
            }
        }
    }

    /*
     * log start time - used for events
     *  spoof my macros to give me negative abs time
     */
    nvpTime[0] = 0;
    NVP_START(0);
    nvpStartTime = nvpTime[0];
}

/*
 * nvpDestroy
 *
 * terminates profiling session
 */
void nvpDestroy
(
    void
)
{
    /*
     * write out pending data
     */
    nvpFlush();

    /*
     * close file
     */
    CloseHandle (nvpFile);

    /*
     * reset values
     */
    nvpFile = 0;
}

/*
 * nvpLogCount
 *
 * logs a count
 */
void nvpLogCount
(
    DWORD   id,
    __int64 count
)
{
    if (nvpEnableBits & (1 << id))
    {
        L2ENTRY *entry = (L2ENTRY*)(nvpData + nvpCount);
        entry->bID     = (BYTE)id;
        entry->qwValue = count;
        nvpCount += sizeof(L2ENTRY);
        if (nvpCount > NVP_CAPMARK) nvpFlush();
    }
}

/*
 * nvpLogTime
 *
 * logs a time in nanoseconds (argument is in clock ticks)
 */
void nvpLogTime
(
    DWORD   id,
    __int64 time
)
{
    if (nvpEnableBits & (1 << id))
    {
        L2ENTRY *entry = (L2ENTRY*)(nvpData + nvpCount);
        entry->bID     = (BYTE)id;
        entry->qwValue = time * nvpCyclesPerNanoSecond;
        nvpCount += sizeof(L2ENTRY);
        if (nvpCount > NVP_CAPMARK) nvpFlush();
    }
}

/*
 * nvpLogEvent
 *
 * logs the time an event took place
 */
void nvpLogEvent
(
    DWORD id
)
{
    if (nvpEnableBits & (1 << id))
    {
        nvpTime[255] = nvpStartTime;
        NVP_STOP(255);
        nvpLogTime (id,nvpTime[255]);
    }
}

#endif // 0

#if 1

/*
 * Locutus profiler section
 */
DWORD nvGetCPUSpeed (void);

//////////////////////////////////////////////////////////////////////////////
// constants
#define LOCUTUS_REG_KEY             "SOFTWARE\\NVIDIA Corporation\\Locutus"
#define LOCUTUS_REG_ENABLEBITS      "D3DEnableBits"
#define LOCUTUS_REG_TRIPERSECWINDOW "D3DTriPerSecWindow"

#define BTFT_1              0x42EC5201  // version 1 file header
#define BTRT_EOF            0xff

#define BTAA_EVENT          0x00000000  // event
#define BTAA_TIME           0x00000001  // time
#define BTAA_COUNT          0x00000002  // count

#define CAP_SIZE            (65536*8)
#define CAP_MARK            (CAP_SIZE - 32)

//////////////////////////////////////////////////////////////////////////////
// structures
#pragma pack(push,1)

typedef __int64 CBTTime;
typedef int     CBTCount;

typedef struct {
    char  m_szName[16];                 // human readable description
    DWORD m_dwRecordSize;               // size of record
    DWORD m_dwAttributes;               // Record description
} CBTAlphabet;

typedef struct {
    DWORD dwFileType;
    DWORD dwClockSpeed;
    DWORD dwAlphabetCount;
} CBTHeader;
#pragma pack(pop)

//////////////////////////////////////////////////////////////////////////////
// locals
DWORD   nvDeviceBase       = 0;
DWORD   nvpEnableBits      = 0x0000fffb;
DWORD   nvpTriPerSecWindow = 50;

__int64 nvpTime[256];           // stopwatch storage
#define nvp_time nvpTime        // alias
int     nvp_context_count = 1;  // we count contexi to generate unique file names
HANDLE  nvp_file          = 0;  // capture file
BYTE    nvp_buffer[CAP_SIZE];   // local capture buffer
DWORD   nvp_index;              // buffer index

CBTAlphabet nvp_alphabet[] = {                //            mask   default groups
    { "BeginScene",         0,  BTAA_EVENT }, // 0          0x00000001  *
    { "Put",                0,  BTAA_EVENT }, // 1          0x00000002  *
    { "TriDispatch",        0,  BTAA_EVENT }, // 2          0x00000004     abc
    { "SceneTime",          8,  BTAA_TIME  }, // 3          0x00000008  *
    { "FreeCountTime",      8,  BTAA_TIME  }, // 4          0x00000010  *
    { "FlipTime",           8,  BTAA_TIME  }, // 5          0x00000020  *
    { "TStageTime",         8,  BTAA_TIME  }, // 6          0x00000040  *
    { "DP2Time",            8,  BTAA_TIME  }, // 7          0x00000080  *
    { "HDFlushTime",        8,  BTAA_TIME  }, // 8          0x00000100  *
    { "TexWaitTime",        8,  BTAA_TIME  }, // 9          0x00000200  *
    { "TexSWBltTime",       8,  BTAA_TIME  }, // 10         0x00000400  *
    { "TexHWBltTime",       8,  BTAA_TIME  }, // 11         0x00000800  *
    { "InnerLoopTime",      8,  BTAA_TIME  }, // 12         0x00001000  *
    { "BuildLoopTime",      8,  BTAA_TIME  }, // 13         0x00002000  *
    { "PendingSize",        4,  BTAA_COUNT }, // 14         0x00004000  *
    { "BltArea",            4,  BTAA_COUNT }, // 15         0x00008000  *
    { "1pix/clk",           4,  BTAA_COUNT }, // 16         0x00010000    a
    { "2pix/clk",           4,  BTAA_COUNT }, // 17         0x00020000    a
    { "TriArea",            4,  BTAA_COUNT }, // 18         0x00040000      c
    { "PixPerSec",          4,  BTAA_COUNT }, // 19         0x00080000     b
    { "TriCount",           4,  BTAA_COUNT }, // 20         0x00100000     b
};

void nvpCreate (void) {
    HKEY  hKey;
    char  s[256];

    nvDeviceBase = (U032)NvDeviceBaseGet(NV_DEV_BASE,pDriverData->dwDeviceIDNum);

    wsprintf (s,"\\captr%03d.btd",nvp_context_count);
    nvp_file=CreateFile(s,GENERIC_WRITE,0,0,CREATE_ALWAYS,0,0);
    if (nvp_file==INVALID_HANDLE_VALUE) {
        MessageBeep (0);
        __asm int 3;
    }
    nvp_context_count ++;

// place header
    nvp_index = 0;
    *(DWORD*)(nvp_buffer + nvp_index) = BTFT_1;
    nvp_index += 4;
    *(DWORD*)(nvp_buffer + nvp_index) = nvGetCPUSpeed();
    nvp_index += 4;
    *(DWORD*)(nvp_buffer + nvp_index) = sizeof(nvp_alphabet)/sizeof(nvp_alphabet[0]);
    nvp_index += 4;
    memcpy (nvp_buffer+nvp_index,nvp_alphabet,sizeof(nvp_alphabet));
    nvp_index += sizeof(nvp_alphabet);

// read registry for enabled bits
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, LOCUTUS_REG_KEY, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
    {
        DWORD dwType  = REG_DWORD;
        DWORD dwSize  = sizeof(DWORD);
        DWORD dwValue;

        /*
         * read enable bits
         */
        if (RegQueryValueEx(hKey,
                            LOCUTUS_REG_ENABLEBITS,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            nvpEnableBits = dwValue;
        }

        /*
         * read the tri per sec window (only used when tripersec is enabled)
         */
        if (RegQueryValueEx(hKey,
                            LOCUTUS_REG_TRIPERSECWINDOW,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            nvpTriPerSecWindow = dwValue;
        }

        /*
         * close
         */
        RegCloseKey (hKey);
    }

    /*
     * enable compulsory flags
     */
    if (nvpEnableBits & ((1 << NVP_C_1PIXCLK) | (1 << NVP_C_2PIXCLK)))
    {
        nvpEnableBits |= (1 << NVP_C_1PIXCLK) | (1 << NVP_C_2PIXCLK) | (1 << NVP_E_TRIDISP);
    }

    if (nvpEnableBits & (1 << NVP_C_TRIAREA))
    {
        nvpEnableBits |= (1 << NVP_E_TRIDISP);
    }

    if (nvpEnableBits & (1 << NVP_C_PIXPERSEC))
    {
        nvpEnableBits |= (1 << NVP_E_TRIDISP);
    }
}

void nvpDestroy (void) {
    nvp_buffer[nvp_index++] = BTRT_EOF;
    nvpFlush();
    CloseHandle (nvp_file);
}

void nvpFlush (void) {
    NVP_START (NVP_T_HDFLUSH);
    if (nvp_index) {
        DWORD dw;
        if (!WriteFile(nvp_file,nvp_buffer,nvp_index,&dw,0)) {
            DWORD dw=GetLastError();
            __asm {
                mov eax,[dw]
                int 3
            }
        }
        FlushFileBuffers (nvp_file);
        nvp_index = 0;
    }
    NVP_STOP (NVP_T_HDFLUSH);
    nvpLogTime (NVP_T_HDFLUSH,nvpTime[NVP_T_HDFLUSH]);
}

void nvpLogEvent (DWORD id) {
    if (nvpEnableBits & (1<<id))
    {
        nvp_buffer[nvp_index++] = (BYTE)id;
        if (nvp_index>CAP_MARK) nvpFlush();
    }
}

void nvpLogCount (DWORD id,int count) {
    if (nvpEnableBits & (1<<id))
    {
        BYTE *b = nvp_buffer + nvp_index;
        *((BYTE*)b)         = (BYTE)id;
        *((CBTCount*)(b+1)) = count;
        nvp_index += sizeof(BYTE)+sizeof(CBTCount);
        if (nvp_index>CAP_MARK) nvpFlush();
    }
}

void nvpLogTime (DWORD id,__int64 time) {
    if (nvpEnableBits & (1<<id))
    {
        BYTE *b = nvp_buffer + nvp_index;
        *((BYTE*)b)        = (BYTE)id;
        *((CBTTime*)(b+1)) = time;
        nvp_index += sizeof(BYTE)+sizeof(CBTTime);
        if (nvp_index>CAP_MARK) nvpFlush();
    }
}
#endif // 1

#endif // NV_PROFILE

//////////////////////////////////////////////////////////////////////////////
// Processor Speed
//
#define LATCH_VALUE(x,y)    if (fabs(((x)-(y))/(y)) < 0.05) return (DWORD)(y)

__int64 _clock_ticks;
DWORD nvGetCPUSpeed (void) {
    double      speed;
    DWORD       dwCaps;
    SYSTEM_INFO si;
#ifndef WINNT
    GetSystemInfo (&si);
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL) return 1; // unknown
    if (si.dwProcessorType != PROCESSOR_INTEL_PENTIUM) return 1; // not pentium
#endif // #ifndef WINNT
    __asm
    {
        mov eax,1
        // cpuid
        _emit 0x0f
        _emit 0xa2
        mov [dwCaps],edx
    }
    if (!(dwCaps & 0x00000010)) return 1; // does not have tsc


    SetPriorityClass  (GetCurrentProcess(),REALTIME_PRIORITY_CLASS);
    SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
#ifndef WINNT
    GetTickCount(); // break in cache
#endif // #ifndef WINNT
    {
#ifndef WINNT
        DWORD start,stop;
        start = GetTickCount();
#else
        LONGLONG start,stop;
        EngQueryPerformanceCounter(&start);
#endif // #ifdef WINNT
        __asm {
            pushad

            // rdtsc
            _emit 0x0f
            _emit 0x31
            mov ebp,eax
            mov ebx,edx
#ifdef NV_PROFILE
            mov ecx,8000000h
#else
            mov ecx,1000000h
#endif
        here:
            loop here

            // rdtsc
            _emit 0x0f
            _emit 0x31
            sub eax,ebp
            sbb edx,ebx

            mov [dword ptr _clock_ticks  ],eax
            mov [dword ptr _clock_ticks+4],edx

            popad
        }
#ifndef WINNT
        stop = GetTickCount();
#else
        EngQueryPerformanceCounter(&stop);
#endif // #ifndef WINNT
        speed = ((double)_clock_ticks)/(1000.0*(double)(stop-start));
    }
    SetPriorityClass  (GetCurrentProcess(),NORMAL_PRIORITY_CLASS);
    SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_NORMAL);

// normalize to known values
    LATCH_VALUE (speed, 90);
    LATCH_VALUE (speed,100);
    LATCH_VALUE (speed,166);
    LATCH_VALUE (speed,200);
    LATCH_VALUE (speed,233);
    LATCH_VALUE (speed,266);
    LATCH_VALUE (speed,300);
    LATCH_VALUE (speed,333);
    LATCH_VALUE (speed,400);
    LATCH_VALUE (speed,450);
    LATCH_VALUE (speed,500);
    LATCH_VALUE (speed,550);
    LATCH_VALUE (speed,600);
// did not latch - return unaltered (can be up to 10% off)
    return (DWORD)speed;
}

BOOL nvDetectMMX
(
    void
)
{
    DWORD       dwCaps;
    SYSTEM_INFO si;
#ifndef WINNT
    GetSystemInfo (&si);
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL) return FALSE; // unknown
    if (si.dwProcessorType != PROCESSOR_INTEL_PENTIUM) return FALSE; // not pentium
#endif // #ifndef WINNT
    __asm
    {
        mov eax,1
        // cpuid
        _emit 0x0f
        _emit 0xa2
        mov [dwCaps],edx
    }

    return (dwCaps & 0x00800000) ? TRUE : FALSE;
}

BOOL nvDetectKATMAI
(
    void
)
{
    DWORD       dwCaps;
//    DWORD       dwCR4;
    SYSTEM_INFO si;

#ifndef WINNT
    GetSystemInfo (&si);
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL) return FALSE; // unknown
    if (si.dwProcessorType != PROCESSOR_INTEL_PENTIUM) return FALSE; // not pentium
#endif // #ifndef WINNT

    __asm
    {
        mov eax,1
        // cpuid
        _emit 0x0f
        _emit 0xa2
        mov [dwCaps],edx

/*
        //mov eax,cr4
        _emit 0x0f
        _emit 0x20
        _emit 0xe0
        mov [dwCR4],eax
*/
    }

    return ((dwCaps & 0x02000000) /*&& (dwCR4 & 0x200)*/) ? TRUE : FALSE;
}

#endif // NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4prim2.c ===
#ifdef  NV4
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4PRIM2.C                                                        *
*   NV4 DX6 DrawPrimitives2 routines.                                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       04/18/98 - created                      *
*                                                                           *
\***************************************************************************/
#include <math.h>
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv4dreg.h"
#include "nv3ddbg.h"
#include "nv4vxmac.h"

#ifdef  NVD3D_DX6

#ifdef  WINNT
#define CHECK_CMDBUF_LIMITS(pDP2Data, pBuf)                                                 \
{                                                                                           \
    LPBYTE pBase,pEnd;                                                                      \
    pBase = (LPBYTE)(pDP2Data->lpDDCommands->lpGbl->fpVidMem + pDP2Data->dwCommandOffset);  \
    pEnd  = pBase + pDP2Data->dwCommandLength;                                              \
    if (! ((LPBYTE)pBuf < pEnd) && ( pBase <= (LPBYTE)pBuf))                                \
    {                                                                                       \
        pDP2Data->dwErrorOffset = (DWORD)lpCommands - dwCommandBufferStart;                 \
        pDP2Data->ddrval = D3DERR_COMMAND_UNPARSED;                                         \
        return DDHAL_DRIVER_HANDLED;                                                        \
    }                                                                                       \
}

#define CHECK_DATABUF_LIMITS(pDP2Data, iIndex)                                              \
{                                                                                           \
    if (!(((LONG)iIndex >= 0)                                                               \
     &&   ((LONG)iIndex < (LONG)pDP2Data->dwVertexLength)))                                 \
    {                                                                                       \
        pDP2Data->dwErrorOffset = (DWORD)lpCommands - dwCommandBufferStart;                 \
        pDP2Data->ddrval = D3DERR_COMMAND_UNPARSED;                                         \
        return DDHAL_DRIVER_HANDLED;                                                        \
    }                                                                                       \
}
#else   // !WINNT
#define CHECK_CMDBUF_LIMITS(pDP2Data, pBuf)
#define CHECK_DATABUF_LIMITS(pDP2Data, iIndex)
#endif  // !WINNT

D3DTLVERTEX tlvDefault =
{
    0.0f,           // sx
    0.0f,           // sy
    0.0f,           // sz
    1.0f,           // rhw
    0xFFFFFFFF,     // argb
    0xFF000000,     // specular
    0.0f,           // tu
    0.0f            // tv
};

/*
 * TL Vertex in Flex Format
 */
NVD3DFVFDATA constFVFData =
{
    D3DFVF_TLVERTEX,
    32,
    0xffffffff,0,
    0xffffffff,12,
    0xffffffff,16,
    0xffffffff,20,
    0xffffffff,24,
    1,
    0,0,0
};

PFND3DPARSEUNKNOWNCOMMAND   fnD3DParseUnknownCommandCallback;

#ifndef NV_FASTLOOPS
/*
 * DirectX 6.0 DrawPrimitives2 entry point.
 */
void nvDX5FlexTriangleSetup
(
    WORD            wPrimCount,
    DWORD           dwStrides,
    LPBYTE          lpVertices
)
{
    /*
     * Send the context state down to the hardware.
     */
    if (pCurrentContext->dwStateChange)
        nvSetHardwareState();
    nvSetDx5TriangleState(pCurrentContext);

    /*
     * Now calculate the appropriate rendering routine and call it.
     *
     * Determine the fog table mode based on if fog is enabled and the
     * selected fog table mode.  A computed value of 0 = vertex or no fog,
     * non-zero values indicate the fog table mode.
     */
    CALC_FUNCTION_INDEX (pCurrentContext);

    fnDX5FlexTable[pCurrentContext->dwFunctionLookup](wPrimCount, dwStrides, lpVertices);
    return;
}

void nvDX5FlexIndexedTriangleSetup
(
    DWORD           dwPrimCount,
    LPWORD          lpwIndices,
    DWORD           dwStrides,
    LPBYTE          lpVertices
)
{
    /*
     * Send the context state down to the hardware.
     */
    if (pCurrentContext->dwStateChange)
        nvSetHardwareState();
    nvSetDx5TriangleState(pCurrentContext);

    /*
     * Now calculate the appropriate rendering routine and call it.
     *
     * Determine the fog table mode based on if fog is enabled and the
     * selected fog table mode.  A computed value of 0 = vertex or no fog,
     * non-zero values indicate the fog table mode.
     */
    CALC_FUNCTION_INDEX (pCurrentContext);

    fnDX5FlexIndexedTable[pCurrentContext->dwFunctionLookup](dwPrimCount, lpwIndices, dwStrides, lpVertices);
    return;
}
#endif //!NV_FASTLOOPS

void nvSolidIndexedTriangle
(
    DWORD           dwPrimCount,
    LPWORD          lpwIndices,
    DWORD           dwStrides,
    LPBYTE          lpVertices
)
{
#ifdef NV_FASTLOOPS
    nvTriangleDispatch(dwPrimCount, lpwIndices, dwStrides, lpVertices);
#else
    if (!pCurrentContext->bUseDX6Class)
    {
        if (fvfData.dwVertexType == D3DFVF_TLVERTEX)
            fnDX5IndexedTable[pCurrentContext->dwFunctionLookup](dwPrimCount, lpwIndices, dwStrides, (LPD3DTLVERTEX)lpVertices);
        else
            fnDX5FlexIndexedTable[pCurrentContext->dwFunctionLookup](dwPrimCount, lpwIndices, dwStrides, lpVertices);
    }
    else
    {
        /*
         * Call an inner loop that uses the DX6_MULTI_TEXTURE_TRIANGLE class.
         */
        fnDX6FlexIndexedTable[pCurrentContext->dwFunctionLookup](dwPrimCount, lpwIndices, dwStrides, lpVertices);
    }
    return;
#endif //!NV_FASTLOOPS
}

void nvWireframeIndexedTriangle
(
    DWORD           dwPrimCount,
    LPWORD          lpwIndices,
    DWORD           dwStrides,
    LPBYTE          lpVertices
)
{
    if (!pCurrentContext->bUseDX6Class)
    {
        if (fvfData.dwVertexType == D3DFVF_TLVERTEX)
            nvIndexedWireframeTriangle(dwPrimCount, lpwIndices, dwStrides, (LPD3DTLVERTEX)lpVertices);
        else
            nvFVFIndexedWireframeTriangle(dwPrimCount, lpwIndices, dwStrides, lpVertices);
    }
    else
        nvFVFIndexedWireframeTriangle(dwPrimCount, lpwIndices, dwStrides, lpVertices);
    return;
}
void nvPointIndexedTriangle
(
    DWORD           dwPrimCount,
    LPWORD          lpwIndices,
    DWORD           dwStrides,
    LPBYTE          lpVertices
)
{
    if (!pCurrentContext->bUseDX6Class)
    {
        if (fvfData.dwVertexType == D3DFVF_TLVERTEX)
            nvIndexedPointTriangle(dwPrimCount, lpwIndices, dwStrides, (LPD3DTLVERTEX)lpVertices);
        else
            nvFVFIndexedPointTriangle(dwPrimCount, lpwIndices, dwStrides, lpVertices);
    }
    else
        nvFVFIndexedPointTriangle(dwPrimCount, lpwIndices, dwStrides, lpVertices);
    return;
}

void nvSolidNonIndexedTriangle
(
    WORD            wPrimCount,
    DWORD           dwStrides,
    LPBYTE          lpVertices
)
{
#ifdef NV_FASTLOOPS
    nvTriangleDispatch(wPrimCount, NULL, dwStrides, lpVertices);
#else
    if (!pCurrentContext->bUseDX6Class)
    {
        if (fvfData.dwVertexType == D3DFVF_TLVERTEX)
            fnDX5Table[pCurrentContext->dwFunctionLookup](wPrimCount, dwStrides, (LPD3DTLVERTEX)lpVertices);
        else
            fnDX5FlexTable[pCurrentContext->dwFunctionLookup](wPrimCount, dwStrides, lpVertices);
    }
    else
    {
        /*
         * Call an inner loop that uses the DX6_MULTI_TEXTURE_TRIANGLE class.
         */
        fnDX6FlexTable[pCurrentContext->dwFunctionLookup](wPrimCount, dwStrides, lpVertices);
    }
    return;
#endif //!NV_FASTLOOPS
}
void nvWireframeNonIndexedTriangle
(
    WORD            wPrimCount,
    DWORD           dwStrides,
    LPBYTE          lpVertices
)
{
    if (!pCurrentContext->bUseDX6Class)
    {
        if (fvfData.dwVertexType == D3DFVF_TLVERTEX)
            nvDrawWireframeTriangle(wPrimCount, dwStrides, (LPD3DTLVERTEX)lpVertices);
        else
            nvFVFDrawWireframeTriangle(wPrimCount, dwStrides, lpVertices);
    }
    else
        nvFVFDrawWireframeTriangle(wPrimCount, dwStrides, lpVertices);
    return;
}
void nvPointNonIndexedTriangle
(
    WORD            wPrimCount,
    DWORD           dwStrides,
    LPBYTE          lpVertices
)
{
    if (!pCurrentContext->bUseDX6Class)
    {
        if (fvfData.dwVertexType == D3DFVF_TLVERTEX)
            nvDrawPointTriangle(wPrimCount, dwStrides, (LPD3DTLVERTEX)lpVertices);
        else
            nvFVFDrawPointTriangle(wPrimCount, dwStrides, lpVertices);
    }
    else
        nvFVFDrawPointTriangle(wPrimCount, dwStrides, lpVertices);
    return;
}

LPNVFVFINDEXEDPRIM fnFillModeIndexedTriangle[] =
{
    0,
    nvPointIndexedTriangle,
    nvWireframeIndexedTriangle,
    nvSolidIndexedTriangle
};

LPNVFVFDRAWPRIM fnFillModeNonIndexedTriangle[] =
{
    0,
    nvPointNonIndexedTriangle,
    nvWireframeNonIndexedTriangle,
    nvSolidNonIndexedTriangle
};

DWORD nvDrawPrimitives2
(
    LPD3DHAL_DRAWPRIMITIVES2DATA pdp2d
)
{
    WORD                i;
    WORD                wCommandCount;
    WORD                wIndex, wCount;
    BOOL                bFilterChanged;
    BOOL                bTSSChanged;
    BOOL                bLoadFVFVertex;
    DWORD               dwMagFilter;
    DWORD               dwMinFilter;
    DWORD               dwStage;
    DWORD               dwState;
    DWORD               dwValue;
    DWORD               dwVertexType;
    DWORD               dwVertexStride;
    DWORD               dwUVCount;
    DWORD               dwCommandBufferStart;
    DWORD               dwCommandBufferEnd;
    DWORD               dwCommandBufferOffset;
    DWORD               dwCommandBufferLength;
    DWORD               dwVertexBufferStart;
    DWORD               dwVertexBufferOffset;
    DWORD               dwVertexBufferLength;
    HRESULT             ddrval;
    LPBYTE              lpPrim, lpFVFVertices;
    LPD3DHAL_DP2COMMAND lpCommands, lpResumeCommands;
    LPD3DTLVERTEX       lpVertices;

#ifdef NV_NULL_DRIVER
    pdp2d->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
#endif //NV_NULL_DRIVER
#ifdef NV_PROFILE
    NVP_START (NVP_T_DP2);
#endif
#ifdef NV_STATS
    {
        extern DWORD dwDP2CallCount;
        dwDP2CallCount ++;
    }
#endif

    DPF_LEVEL(NVDBG_LEVEL_DDI_ENTRY, "nvDrawPrimitives2 - hContext = %08lx", pdp2d->dwhContext);

    /*
     * Need to make sure that an unfriendly mode switch didn't sneak and not cause
     * us to get re-enabled properly.
     */
    if (pDriverData->fFullScreenDosOccurred)
    {
        if (pDriverData->fFullScreenDosOccurred & 0x01)
            nvD3DReenable();
        else
        {
#ifdef NV_PROFILE
            NVP_STOP (NVP_T_DP2);
            nvpLogTime (NVP_T_DP2,nvpTime[NVP_T_DP2]);
#endif
            pdp2d->ddrval = DD_OK;
            return (DDHAL_DRIVER_HANDLED);
        }
    }
    if (pCurrentContext->dwContextReset)
        nvResetContext((PNVD3DTEXTURE)NULL);

    /*
     * Setup frequently accessed globals.
     */
    NV_D3D_GLOBAL_SETUP();

    /*
     * check aa semantics
     */
    NV_AA_SEMANTICS_CHECK(pCurrentContext);

    /*
     * Get address of command buffer.
     */
    if (!(dwCommandBufferStart = (DWORD)pdp2d->lpDDCommands->lpGbl->fpVidMem))
    {
#ifdef NV_PROFILE
        NVP_STOP (NVP_T_DP2);
        nvpLogTime (NVP_T_DP2,nvpTime[NVP_T_DP2]);
#endif
        pdp2d->ddrval = DDERR_CANTLOCKSURFACE;
        return (DDHAL_DRIVER_HANDLED);
    }
    dwCommandBufferOffset = pdp2d->dwCommandOffset;
    dwCommandBufferLength = pdp2d->dwCommandLength;
    dwCommandBufferEnd    = dwCommandBufferStart + dwCommandBufferOffset + dwCommandBufferLength;

    /*
     * Calculate pointer to the first command to be processed.
     */
    lpCommands = (LPD3DHAL_DP2COMMAND)(dwCommandBufferStart + dwCommandBufferOffset);

    /*
     * Get address of vertex buffer.
     */
    if (pdp2d->dwFlags & D3DHALDP2_USERMEMVERTICES)
        dwVertexBufferStart = (DWORD)pdp2d->lpVertices;
    else
        dwVertexBufferStart = (DWORD)pdp2d->lpDDVertex->lpGbl->fpVidMem;
    if (!dwVertexBufferStart)
    {
#ifdef NV_PROFILE
        NVP_STOP (NVP_T_DP2);
        nvpLogTime (NVP_T_DP2,nvpTime[NVP_T_DP2]);
#endif
        pdp2d->ddrval = DDERR_CANTLOCKSURFACE;
        return (DDHAL_DRIVER_HANDLED);
    }
    dwVertexBufferOffset = pdp2d->dwVertexOffset;
    dwVertexBufferLength = pdp2d->dwVertexLength;
    lpVertices = (LPD3DTLVERTEX)(dwVertexBufferStart + dwVertexBufferOffset);

    /*
     * Get local copy of vertex flags
     */
    dwVertexType = pdp2d->dwVertexType;
    if (dwVertexType == D3DFVF_TLVERTEX)
        DPF_LEVEL(NVDBG_LEVEL_INFO, "D3D:nvDrawPrimitives2 - FVF Type = TLVERTEX");
    else
        DPF_LEVEL(NVDBG_LEVEL_INFO, "D3D:nvDrawPrimitives2 - FVF Type = %08lx", dwVertexType);

    /*
     * check if cached & short circuit fvfData calculation
     *  bLoadFVFVertex becomes TRUE when we need to recalc
     *  it will not go TRUE for TL verts - instead we just copy from a preset table
     */
    CHECK_FVF_DATA_AND_LOAD_TL (fvfData,dwVertexType,dwVertexStride,bLoadFVFVertex);

    /*
     * Calculate fvf data only if needed
     */
    if (bLoadFVFVertex)
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "D3D:nvDrawPrimitives2 - Re-Calculate FVF Data.");

        /*
         * Make sure there aren't any totally invalid FVF bits set.
         */
        if (dwVertexType & (D3DFVF_RESERVED0 | D3DFVF_RESERVED1 | D3DFVF_RESERVED2 | D3DFVF_NORMAL))
        {
#ifdef NV_PROFILE
            NVP_STOP (NVP_T_DP2);
            nvpLogTime (NVP_T_DP2,nvpTime[NVP_T_DP2]);
#endif
            pdp2d->ddrval = D3DERR_COMMAND_UNPARSED;
            pdp2d->dwErrorOffset = dwCommandBufferOffset;
            return (DDHAL_DRIVER_HANDLED);
        }

        /*
         * Calculate the number of texture coordinates present.
         * On NV4 we can accept 2 sets of UV coordinates
         * bdw: this is a usage restriction - the flex vertex is allowed to contain more
         */
        dwUVCount = (dwVertexType & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;
        /*
        if (dwUVCount > NV_UV_COORDINATE_COUNT_MAX)
        {
            pdp2d->ddrval = D3DERR_COMMAND_UNPARSED;
            pdp2d->dwErrorOffset = dwCommandBufferOffset;
            return (DDHAL_DRIVER_HANDLED);
        }
        */

        /*
         * Vertex always has to have XYZ components.
         */
        if ((dwVertexType & (D3DFVF_XYZ | D3DFVF_XYZRHW)) == 0)
        {
#ifdef NV_PROFILE
            NVP_STOP (NVP_T_DP2);
            nvpLogTime (NVP_T_DP2,nvpTime[NVP_T_DP2]);
#endif
            pdp2d->ddrval = D3DERR_COMMAND_UNPARSED;
            pdp2d->dwErrorOffset = dwCommandBufferOffset;
            return (DDHAL_DRIVER_HANDLED);
        }
        dwVertexStride = sizeof(D3DVALUE) * 3;

        /*
         * Set up masks and offsets for each component of the FVF.
         * The location to get the vertex component data from will be calculated as follows:
         *      (lpVertices & ComponentMask) + ComponentOffset;
         * When ComponentMask == 0xFFFFFFFF, ComponentOffset will be an offset from the start
         * of the vertex data to the specific component.
         * When ComponentMask == 0x00000000, ComponentOffset will be a pointer to the default vertex data.
         *
         * FVF's must always have XYZ components.
         */
        fvfData.dwXYZMask   = 0xFFFFFFFF;
        fvfData.dwXYZOffset = 0;

        /*
         * Run down the variable vertex component list in the order they
         * will appear in the vertex data.
         */
        if (dwVertexType & D3DFVF_XYZRHW)
        {
            fvfData.dwRHWMask    = 0xFFFFFFFF;
            fvfData.dwRHWOffset  = dwVertexStride;
            dwVertexStride      += sizeof(D3DVALUE);
        }
        else
        {
            /*
             * No RHW specified, get it from the default vertex structure.
             */
            fvfData.dwRHWMask    = 0x00000000;
            fvfData.dwRHWOffset  = (DWORD)&tlvDefault.rhw;
        }
        if (dwVertexType & D3DFVF_DIFFUSE)
        {
            fvfData.dwARGBMask    = 0xFFFFFFFF;
            fvfData.dwARGBOffset  = dwVertexStride;
            dwVertexStride += sizeof(D3DCOLOR);
        }
        else
        {
            /*
             * No Diffuse Color specified, get it from the default vertex structure.
             */
            fvfData.dwARGBMask    = 0x00000000;
            fvfData.dwARGBOffset  = (DWORD)&tlvDefault.color;
        }
        if (dwVertexType & D3DFVF_SPECULAR)
        {
            fvfData.dwSpecularMask    = 0xFFFFFFFF;
            fvfData.dwSpecularOffset  = dwVertexStride;
            dwVertexStride           += sizeof(D3DCOLOR);
        }
        else
        {
            /*
             * No Specular component specified, get it from the default vertex structure.
             */
            fvfData.dwSpecularMask    = 0x00000000;
            fvfData.dwSpecularOffset  = (DWORD)&tlvDefault.specular;
        }
        if (dwUVCount)
        {
            fvfData.dwUVMask    = 0xFFFFFFFF;
            fvfData.dwUVOffset  = dwVertexStride;
            dwVertexStride     += (sizeof(D3DVALUE) * 2) * dwUVCount;
        }
        else
        {
            /*
             * No UV components specified, get it from the default vertex structure.
             */
            fvfData.dwUVMask    = 0x00000000;
            fvfData.dwUVOffset  = (DWORD)&tlvDefault.tu;
        }

        /*
         * Fill in rest of FVF data structure.
         */
        fvfData.dwVertexType   = dwVertexType;
        fvfData.dwVertexStride = dwVertexStride;
        fvfData.dwUVCount      = dwUVCount;
    }
    else
        DPF_LEVEL(NVDBG_LEVEL_INFO, "D3D:nvDrawPrimitives2 - FVF Data already loaded.");

    /*
     * Always read the current free count on entry.
     */
#ifdef  CACHE_FREECOUNT
    nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetRenderTargetContexts + sizeSetRenderTarget));
#endif  // CACHE_FREECOUNT

    /*
     * If the surface has changed since the last render call, switch it now.
     */
    nvSetD3DSurfaceState(pCurrentContext);

    /*
     * If the spare subchannel does not contain the correct triangle
     * object, force an object state load.
     */
    if (!pCurrentContext->bUseDX6Class)
    {
        if ((pCurrentContext->dwStateChange || pDriverData->TwoDRenderingOccurred)
         || (pDriverData->dDrawSpareSubchannelObject != D3D_DX5_TEXTURED_TRIANGLE))
            NV_FORCE_TRI_SETUP(pCurrentContext);
    }
    else
    {
        if ((pCurrentContext->dwStateChange || pDriverData->TwoDRenderingOccurred)
         || (pDriverData->dDrawSpareSubchannelObject != D3D_DX6_MULTI_TEXTURE_TRIANGLE))
            NV_FORCE_TRI_SETUP(pCurrentContext);
    }

    /*
     * Parse the command buffer.
     */
    while ((DWORD)lpCommands < dwCommandBufferEnd)
    {
        wCommandCount = lpCommands->wPrimitiveCount;
        lpPrim        = (LPBYTE)lpCommands + sizeof(D3DHAL_DP2COMMAND);
        dbgDisplayDrawPrimitives2Info(lpCommands->bCommand, wCommandCount);
        switch (lpCommands->bCommand)
        {
            /*
             * Point Lists.
             */
            case D3DDP2OP_POINTS:
#ifdef  WINNT
                {
                    DWORD               i;
                    D3DHAL_DP2POINTS   *lpPrimCheck;

                    lpPrimCheck = (D3DHAL_DP2POINTS *)lpPrim;
                    for (i = 0; i < wCommandCount; i++)
                    {
                        CHECK_CMDBUF_LIMITS(pdp2d, lpPrimCheck);
                        wIndex = lpPrimCheck->wVStart;
                        wCount = lpPrimCheck->wCount;
                        CHECK_DATABUF_LIMITS(pdp2d, wIndex);
                        CHECK_DATABUF_LIMITS(pdp2d, (LONG)wIndex + wCount - 1);
                        lpPrimCheck++;
                    }
                }
#endif
                for (i = 0; i < wCommandCount; i++)
                {
                    if (!pCurrentContext->bUseDX6Class)
                    {
                        if (dwVertexType == D3DFVF_TLVERTEX)
                            nvDrawPointList((DWORD)((LPD3DHAL_DP2POINTS)lpPrim)->wCount, (LPD3DTLVERTEX)&lpVertices[((LPD3DHAL_DP2POINTS)lpPrim)->wVStart]);
                        else
                        {
                            lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2POINTS)lpPrim)->wVStart * dwVertexStride);
                            nvFVFDrawPointList((DWORD)((LPD3DHAL_DP2POINTS)lpPrim)->wCount, lpFVFVertices);
                        }
                    }
                    else
                    {
                        lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2POINTS)lpPrim)->wVStart * dwVertexStride);
                        nvFVFDrawPointList((DWORD)((LPD3DHAL_DP2POINTS)lpPrim)->wCount, lpFVFVertices);
                    }
                    lpPrim += sizeof(D3DHAL_DP2POINTS);
                }
                /*
                 * Update the put offset.
                 */
                //nvStartDmaBuffer(); // For some reason, taking these lines out caused dropped triangles, especially in 3D winbench!  Why???
                dbgFlushDmaBuffers(pCurrentContext);
                NEXTINSTRUCTION(lpCommands, D3DHAL_DP2POINTS, wCommandCount, 0);
                break;
            /*
             * Line Lists.
             *
             *
             * Old Execute Buffer RenderPrimitive style indexed line list.
             */
            case D3DDP2OP_INDEXEDLINELIST:
#ifdef  WINNT
                {
                    D3DHAL_DP2INDEXEDLINELIST  *lpPrimCheck;
                    DWORD                       i;

                    lpPrimCheck = (D3DHAL_DP2INDEXEDLINELIST *)lpPrim;
                    for (i = 0; i < wCommandCount; i++)
                    {
                        CHECK_CMDBUF_LIMITS(pdp2d, lpPrimCheck);
                        CHECK_DATABUF_LIMITS(pdp2d, lpPrimCheck->wV1);
                        CHECK_DATABUF_LIMITS(pdp2d, lpPrimCheck->wV2);
                        lpPrimCheck++;
                    }
                }
#endif
                if (!pCurrentContext->bUseDX6Class)
                {
                    if (dwVertexType == D3DFVF_TLVERTEX)
                        nvIndexedLine((DWORD)wCommandCount, (LPWORD)lpPrim, 2, lpVertices);
                    else
                        nvFVFIndexedLine((DWORD)wCommandCount, (LPWORD)lpPrim, 2, (LPBYTE)lpVertices);
                }
                else
                    nvFVFIndexedLine((DWORD)wCommandCount, (LPWORD)lpPrim, 2, (LPBYTE)lpVertices);
                /*
                 * Update the put offset.
                 */
                //nvStartDmaBuffer(); // For some reason, taking these lines out caused dropped triangles, especially in 3D winbench!  Why???
                dbgFlushDmaBuffers(pCurrentContext);
                NEXTINSTRUCTION(lpCommands, D3DHAL_DP2INDEXEDLINELIST, wCommandCount, 0);
                break;
            /*
             * Triangle lists.
             *
             *
             * Old style RenderPrimitive Execute Buffer entry.
             */
            case D3DDP2OP_INDEXEDTRIANGLELIST:
#ifdef  WINNT
                {
                    D3DHAL_DP2INDEXEDTRIANGLELIST  *lpPrimCheck;
                    DWORD                           i;

                    lpPrimCheck = (D3DHAL_DP2INDEXEDTRIANGLELIST *)lpPrim;
                    for (i = 0; i < wCommandCount; i++)
                    {
                        CHECK_CMDBUF_LIMITS(pdp2d, lpPrimCheck);
                        CHECK_DATABUF_LIMITS(pdp2d, lpPrimCheck->wV1);
                        CHECK_DATABUF_LIMITS(pdp2d, lpPrimCheck->wV2);
                        CHECK_DATABUF_LIMITS(pdp2d, lpPrimCheck->wV3);
                        lpPrimCheck++;
                    }
                }
#endif
                fnFillModeIndexedTriangle[pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE]]((DWORD)wCommandCount, (LPWORD)lpPrim, LEGACY_STRIDES, (LPBYTE)lpVertices);
                /*
                 * Update the put offset.
                 */
                //nvStartDmaBuffer(); // For some reason, taking these lines out caused dropped triangles, especially in 3D winbench!  Why???
                dbgFlushDmaBuffers(pCurrentContext);
                NEXTINSTRUCTION(lpCommands, D3DHAL_DP2INDEXEDTRIANGLELIST, wCommandCount, 0);
                break;
            /*
             * Render State change.
             */
            case D3DDP2OP_RENDERSTATE:
                /*
                 * Run through the render state list.
                 */
                for (i = 0; i < wCommandCount; i++)
                {
                    DWORD   dwStateType, dwStateValue;

                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrim);

                    dwStateType  = ((LPD3DHAL_DP2RENDERSTATE)lpPrim)->RenderState;
                    dwStateValue = ((LPD3DHAL_DP2RENDERSTATE)lpPrim)->dwState;
                    lpPrim += sizeof(D3DHAL_DP2RENDERSTATE);

                    if (IS_OVERRIDE(dwStateType))
                    {
                        DWORD override = GET_OVERRIDE(dwStateType);
                        if (dwStateValue)
                        {
                            DPF_LEVEL (NVDBG_LEVEL_INFO, "nvDrawPrimitives2 - setting override for state %08lx", override);
                            STATESET_SET(pCurrentContext->overrides, override);
                        }
                        else
                        {
                            DPF_LEVEL (NVDBG_LEVEL_INFO, "nvDrawPrimitives2, clearing override for state %08lx", override);
                            STATESET_CLEAR(pCurrentContext->overrides, override);
                        }
                        continue;
                    }
                    if (STATESET_ISSET(pCurrentContext->overrides, dwStateType))
                    {
                        DPF_LEVEL (NVDBG_LEVEL_INFO, "nvDrawPrimitives2, state %08lx is overridden, ignoring", dwStateType);
                        continue;
                    }
                    if (pdp2d->lpdwRStates)
                        pdp2d->lpdwRStates[dwStateType] = dwStateValue;
                    nvSetContextState(dwStateType, dwStateValue, &ddrval);

                    /*
                     * Want to show that the application has set texturemapblend renderstate even if
                     * it's the same as the last time.
                     */
                    if (dwStateType == D3DRENDERSTATE_TEXTUREMAPBLEND)
                    {
                        /*
                         * If this is the first call to set TBLEND, then we want to set bUseTBlendSettings to FALSE since
                         * it is just an initialization call and doesn't count as an application usage.
                         * All subsequent calls should set bUseTBlendSettings to TRUE.
                         * Upon the first entry, NV_CONTEXT_TBLEND_UNINITIALIZED will be set.  All subseqent calls it will be
                         * cleared.
                         */
                        pCurrentContext->dwContextFlags &= ~NV_CONTEXT_TBLEND_UNINITIALIZED;
                        pCurrentContext->bUseTBlendSettings = !(pCurrentContext->dwContextFlags & NV_CONTEXT_TBLEND_UNINITIALIZED);
                    }

                }
                /*
                 * If the state has changed force a hardware state load.
                 */
                if (pCurrentContext->dwStateChange)
                {
                    /*
                     * If this is a DX6 application, then force hardware steup through
                     * the DX6 hardware setup routine, even if there is only one stage.
                     */
                    pCurrentContext->bUseDX6Class     = (pCurrentContext->dwDXVersionLevel >= APP_VERSION_DX6);
                    NV_FORCE_TRI_SETUP(pCurrentContext);
                }
                /*
                 * Determine the fog table mode based on if fog is enabled and the
                 * selected fog table mode.  A computed value of 0 = vertex or no fog,
                 * non-zero values indicate the fog table mode.
                 */
                NEXTINSTRUCTION(lpCommands, D3DHAL_DP2RENDERSTATE, wCommandCount, 0);
                break;
            /*
             * DX5 DrawOnePrimitive style non-indexed line list.
             */
            case D3DDP2OP_LINELIST:
#ifdef  WINNT
                {
                    D3DHAL_DP2LINELIST  *lpPrimCheck;

                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrim);
                    lpPrimCheck = (D3DHAL_DP2LINELIST *)lpPrim;
                    wIndex = lpPrimCheck->wVStart;
                    CHECK_DATABUF_LIMITS(pdp2d, wIndex);
                    CHECK_DATABUF_LIMITS(pdp2d, (LONG)wIndex + (2 * wCommandCount) - 1);
                }
#endif
                if (!pCurrentContext->bUseDX6Class)
                {
                    if (dwVertexType == D3DFVF_TLVERTEX)
                    {
                        lpPrim = (LPBYTE)&lpVertices[((LPD3DHAL_DP2LINELIST)lpPrim)->wVStart];
                        nvDrawLine((DWORD)wCommandCount, 2, (LPD3DTLVERTEX)lpPrim);
                    }
                    else
                    {
                        lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2LINELIST)lpPrim)->wVStart * dwVertexStride);
                        nvFVFDrawLine((DWORD)wCommandCount, 2, lpFVFVertices);
                    }
                }
                else
                {
                    lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2LINELIST)lpPrim)->wVStart * dwVertexStride);
                    nvFVFDrawLine((DWORD)wCommandCount, 2, lpFVFVertices);
                }
                /*
                 * Update the put offset.
                 */
                //nvStartDmaBuffer(); // For some reason, taking these lines out caused dropped triangles, especially in 3D winbench!  Why???
                dbgFlushDmaBuffers(pCurrentContext);
                NEXTINSTRUCTION(lpCommands, D3DHAL_DP2LINELIST, 1, 0);
                break;
            /*
             * DX5 DrawOnePrimitive style non-indexed line strip.
             */
            case D3DDP2OP_LINESTRIP:
#ifdef  WINNT
                {
                    D3DHAL_DP2LINESTRIP *lpPrimCheck;

                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrim);
                    lpPrimCheck = (D3DHAL_DP2LINESTRIP *)lpPrim;
                    wIndex = lpPrimCheck->wVStart;
                    CHECK_DATABUF_LIMITS(pdp2d, wIndex);
                    CHECK_DATABUF_LIMITS(pdp2d, wIndex + wCommandCount);
                }
#endif
                if (!pCurrentContext->bUseDX6Class)
                {
                    if (dwVertexType == D3DFVF_TLVERTEX)
                    {
                        lpPrim = (LPBYTE)&lpVertices[((LPD3DHAL_DP2LINESTRIP)lpPrim)->wVStart];
                        nvDrawLine((DWORD)wCommandCount, 1, (LPD3DTLVERTEX)lpPrim);
                    }
                    else
                    {
                        lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2LINESTRIP)lpPrim)->wVStart * dwVertexStride);
                        nvFVFDrawLine((DWORD)wCommandCount, 1, lpFVFVertices);
                    }
                }
                else
                {
                    lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2LINESTRIP)lpPrim)->wVStart * dwVertexStride);
                    nvFVFDrawLine((DWORD)wCommandCount, 1, lpFVFVertices);
                }
                /*
                 * Update the put offset.
                 */
                //nvStartDmaBuffer(); // For some reason, taking these lines out caused dropped triangles, especially in 3D winbench!  Why???
                dbgFlushDmaBuffers(pCurrentContext);
                NEXTINSTRUCTION(lpCommands, D3DHAL_DP2LINESTRIP, 1, 0);
                break;
            /*
             * Line Strips.
             *
             *
             * DX5 DrawOneIndexedPrimitive style indexed line strip.
             */
            case D3DDP2OP_INDEXEDLINESTRIP:
#ifdef  WINNT
                {
                    DWORD                       i;
                    WORD                        wIndexBase, wIndex1, wIndex2;
                    D3DHAL_DP2INDEXEDLINESTRIP *lpPrimCheck;
                    LPBYTE                      lpV1, lpV2;

                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrim);
                    wIndexBase = ((D3DHAL_DP2STARTVERTEX *)lpPrim)->wVStart;
                    lpPrimCheck = (D3DHAL_DP2INDEXEDLINESTRIP *)(lpPrim + sizeof(D3DHAL_DP2STARTVERTEX));
                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrimCheck);
                    wIndex1 = lpPrimCheck->wV[0];
                    wIndex2 = lpPrimCheck->wV[1];
                    CHECK_DATABUF_LIMITS(pdp2d, wIndexBase + wIndex1);
                    for (i = 0; i < wCommandCount; i++)
                    {
                        CHECK_DATABUF_LIMITS(pdp2d, wIndexBase + wIndex2);
                        if (i % 2)
                            wIndex2 = lpPrimCheck->wV[1];
                        else
                        {
                            lpPrimCheck++;
                            CHECK_CMDBUF_LIMITS(pdp2d, lpPrimCheck);
                            wIndex2 = lpPrimCheck->wV[0];
                        }
                    }
                }
#endif

                if (!pCurrentContext->bUseDX6Class)
                {
                    if (dwVertexType == D3DFVF_TLVERTEX)
                        nvIndexedLine((DWORD)wCommandCount, (LPWORD)(lpPrim + sizeof(D3DHAL_DP2STARTVERTEX)), 1, (LPD3DTLVERTEX)&lpVertices[((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart]);
                    else
                    {
                        lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart * dwVertexStride);
                        nvFVFIndexedLine((DWORD)wCommandCount, (LPWORD)(lpPrim + sizeof(D3DHAL_DP2STARTVERTEX)), 1, lpFVFVertices);
                    }
                }
                else
                {
                    lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart * dwVertexStride);
                    nvFVFIndexedLine((DWORD)wCommandCount, (LPWORD)(lpPrim + sizeof(D3DHAL_DP2STARTVERTEX)), 1, lpFVFVertices);
                }

                /*
                 * Update the put offset.
                 */
                //nvStartDmaBuffer(); // For some reason, taking these lines out caused dropped triangles, especially in 3D winbench!  Why???
                dbgFlushDmaBuffers(pCurrentContext);
                NEXTINSTRUCTION(lpCommands, WORD, wCommandCount + 1, sizeof(D3DHAL_DP2STARTVERTEX));
                break;
            /*
             * DX5 DrawOnePrimitive style non-indexed triangle list.
             */
            case D3DDP2OP_TRIANGLELIST:
#ifdef  WINNT
                {
                    DWORD                   i;
                    D3DHAL_DP2TRIANGLELIST *lpPrimCheck;

                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrim);
                    lpPrimCheck = (D3DHAL_DP2TRIANGLELIST *)lpPrim;
                    wIndex = lpPrimCheck->wVStart;

                    CHECK_DATABUF_LIMITS(pdp2d, wIndex);
                    CHECK_DATABUF_LIMITS(pdp2d, (LONG)wIndex + 3 * wCommandCount - 1);
                }
#endif
                lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2TRIANGLELIST)lpPrim)->wVStart * dwVertexStride);
                fnFillModeNonIndexedTriangle[pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE]](wCommandCount, LIST_STRIDES, lpFVFVertices);

                /*
                 * Update the put offset.
                 */
                //nvStartDmaBuffer(); // For some reason, taking these lines out caused dropped triangles, especially in 3D winbench!  Why???
                dbgFlushDmaBuffers(pCurrentContext);
                NEXTINSTRUCTION(lpCommands, D3DHAL_DP2TRIANGLELIST, 1, 0);
                break;
            /*
             * DX5 DrawOnePrimitive style non-indexed triangle strip.
             */
            case D3DDP2OP_TRIANGLESTRIP:
#ifdef  WINNT
                {
                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrim);
                    wIndex = ((LPD3DHAL_DP2TRIANGLESTRIP)lpPrim)->wVStart;
                    CHECK_DATABUF_LIMITS(pdp2d, wIndex);
                    CHECK_DATABUF_LIMITS(pdp2d, wIndex + wCommandCount + 1);
                }
#endif
                lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2TRIANGLESTRIP)lpPrim)->wVStart * dwVertexStride);
                fnFillModeNonIndexedTriangle[pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE]](wCommandCount, STRIP_STRIDES, lpFVFVertices);

                /*
                 * Update the put offset.
                 */
                //nvStartDmaBuffer(); // For some reason, taking these lines out caused dropped triangles, especially in 3D winbench!  Why???
                dbgFlushDmaBuffers(pCurrentContext);
                NEXTINSTRUCTION(lpCommands, D3DHAL_DP2TRIANGLESTRIP, 1, 0);
                break;
            /*
             * Triangle strips.
             *
             *
             * DX5 DrawOneIndexedPrimitive style indexed triangle strip.
             */
            case D3DDP2OP_INDEXEDTRIANGLESTRIP:
#ifdef  WINNT
                {
                    WORD                            wIndexBase, wIndex0, wIndex1, wIndex2;
                    DWORD                           i;
                    D3DHAL_DP2INDEXEDTRIANGLESTRIP *lpPrimCheck;

                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrim);
                    wIndexBase = ((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart;
                    lpPrimCheck = (D3DHAL_DP2INDEXEDTRIANGLESTRIP *)(lpPrim + sizeof(D3DHAL_DP2STARTVERTEX));
                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrimCheck);
                    wIndex0 = lpPrimCheck->wV[0];
                    wIndex1 = lpPrimCheck->wV[1];
                    CHECK_DATABUF_LIMITS(pdp2d, wIndexBase + wIndex0);
                    CHECK_DATABUF_LIMITS(pdp2d, wIndexBase + wIndex1);
                    for (i = 0; i < wCommandCount; i++)
                    {
                        CHECK_CMDBUF_LIMITS(pdp2d, lpPrimCheck);
                        wIndex2 = lpPrimCheck->wV[2];
                        CHECK_DATABUF_LIMITS(pdp2d, wIndexBase + wIndex2);
                        lpPrimCheck = (LPBYTE)lpPrimCheck + sizeof(WORD);
                    }
                }
#endif
                lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart * dwVertexStride);
                fnFillModeIndexedTriangle[pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE]]((DWORD)wCommandCount, (LPWORD)(lpPrim + sizeof(D3DHAL_DP2STARTVERTEX)), STRIP_STRIDES, lpFVFVertices);

                /*
                 * Update the put offset.
                 */
                //nvStartDmaBuffer(); // For some reason, taking these lines out caused dropped triangles, especially in 3D winbench!  Why???
                dbgFlushDmaBuffers(pCurrentContext);
                NEXTINSTRUCTION(lpCommands, WORD, wCommandCount + 2, sizeof(D3DHAL_DP2STARTVERTEX));
                break;
            /*
             * Triangle fans.
             *
             * DX5 DrawOnePrimitive style non-indexed triangle fan.
             */
            case D3DDP2OP_TRIANGLEFAN:
#ifdef  WINNT
                {
                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrim);
                    wIndex = ((LPD3DHAL_DP2TRIANGLEFAN)lpPrim)->wVStart;
                    CHECK_DATABUF_LIMITS(pdp2d, wIndex);
                    CHECK_DATABUF_LIMITS(pdp2d, wIndex + wCommandCount + 1);
                }
#endif
                lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2TRIANGLEFAN)lpPrim)->wVStart * dwVertexStride);
                fnFillModeNonIndexedTriangle[pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE]](wCommandCount, FAN_STRIDES, lpFVFVertices);

                /*
                 * Update the put offset.
                 */
                //nvStartDmaBuffer(); // For some reason, taking these lines out caused dropped triangles, especially in 3D winbench!  Why???
                dbgFlushDmaBuffers(pCurrentContext);
                NEXTINSTRUCTION(lpCommands, D3DHAL_DP2TRIANGLEFAN, 1, 0);
                break;
            /*
             * DX5 DrawOneIndexedPrimitive style indexed triangle fan.
             */
            case D3DDP2OP_INDEXEDTRIANGLEFAN:
#ifdef  WINNT
                {
                    WORD                            wIndexBase, wIndex0, wIndex1, wIndex2;
                    DWORD                           i;
                    D3DHAL_DP2INDEXEDTRIANGLEFAN   *lpPrimCheck;

                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrim);
                    wIndexBase = ((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart;
                    lpPrimCheck = (D3DHAL_DP2INDEXEDTRIANGLEFAN *)(lpPrim + sizeof(D3DHAL_DP2STARTVERTEX));
                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrimCheck);
                    wIndex0 = lpPrimCheck->wV[0];
                    wIndex1 = lpPrimCheck->wV[1];
                    CHECK_DATABUF_LIMITS(pdp2d, wIndexBase + wIndex0);
                    CHECK_DATABUF_LIMITS(pdp2d, wIndexBase + wIndex1);
                    for (i = 0; i < wCommandCount; i++)
                    {
                        CHECK_CMDBUF_LIMITS(pdp2d, lpPrimCheck);
                        wIndex2 = lpPrimCheck->wV[2];
                        CHECK_DATABUF_LIMITS(pdp2d, wIndexBase + wIndex2);
                        lpPrimCheck = (LPBYTE)lpPrimCheck + sizeof(WORD);
                    }
                }
#endif
                lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart * dwVertexStride);
                fnFillModeIndexedTriangle[pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE]]((DWORD)wCommandCount, (LPWORD)(lpPrim + sizeof(D3DHAL_DP2STARTVERTEX)), FAN_STRIDES, lpFVFVertices);

                /*
                 * Update the put offset.
                 */
                //nvStartDmaBuffer(); // For some reason, taking these lines out caused dropped triangles, especially in 3D winbench!  Why???
                dbgFlushDmaBuffers(pCurrentContext);
                NEXTINSTRUCTION(lpCommands, WORD, wCommandCount + 2, sizeof(D3DHAL_DP2STARTVERTEX));
                break;
            /*
             * Inline command buffer non-indexed triangle fans.
             * Similar to DX5 style DrawOnePrimitive.
             */
            case D3DDP2OP_TRIANGLEFAN_IMM:
                /*
                 * Skip over edge flags to get pointer to start of vertex list.
                 * Also, vertices are DWORD aligned, so just make sure that the
                 * alignment is correct.
                 */
                lpPrim += sizeof(D3DHAL_DP2TRIANGLEFAN_IMM);
                lpPrim = (LPBYTE)(((DWORD)lpPrim + 3) & ~3);

#ifdef  WINNT
                {
                    LPBYTE  lpV0, lpV1, lpV2;
                    lpV0 = lpPrim;
                    lpV1 = lpV0 + dwVertexStride;
                    lpV2 = lpV1 + dwVertexStride;
                    CHECK_CMDBUF_LIMITS(pdp2d, lpV0);
                    CHECK_CMDBUF_LIMITS(pdp2d, lpV1);
                    for (i = 0; i < wCommandCount; i++)
                    {
                        CHECK_CMDBUF_LIMITS(pdp2d, lpV2);
                        lpV1 = lpV2;
                        lpV2 += dwVertexStride;
                    }
                }
#endif

                fnFillModeNonIndexedTriangle[pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE]](wCommandCount, FAN_STRIDES, lpPrim);

                dbgFlushDmaBuffers(pCurrentContext);
                NEXTINSTRUCTION(lpCommands, BYTE, ((wCommandCount + 2) * dwVertexStride), sizeof(D3DHAL_DP2TRIANGLEFAN_IMM));
                /*
                 * Realign next command since vertices are dword aligned
                 * and store # of primitives before affecting the pointer
                 */
                lpCommands = (LPD3DHAL_DP2COMMAND)(( ((DWORD)lpCommands) + 3 ) & ~ 3);
                break;
            /*
             * DX5 DrawOnePrimitive style in-line command buffer non-indexed line list.
             */
            case D3DDP2OP_LINELIST_IMM:
                /*
                 * Make sure command buffer is DWORD aligned for immediate line list vertices.
                 */
                lpPrim = (LPBYTE)(((DWORD)lpPrim + 3) & ~3);
#ifdef  WINNT
                {
                    LPBYTE  lpV0, lpV1;

                    lpV0 = lpPrim;
                    lpV1 = lpV0 + dwVertexStride;
                    CHECK_CMDBUF_LIMITS(pdp2d, lpV0);
                    for (i = 0; i < wCommandCount; i++)
                    {
                        CHECK_CMDBUF_LIMITS(pdp2d, lpV1);
                        lpV0 = lpV1;
                        lpV1 += dwVertexStride;
                    }
                }
#endif

                if (!pCurrentContext->bUseDX6Class)
                {
                    if (dwVertexType == D3DFVF_TLVERTEX)
                        nvDrawLine((DWORD)wCommandCount, 2, (LPD3DTLVERTEX)lpPrim);
                    else
                        nvFVFDrawLine((DWORD)wCommandCount, 2, lpPrim);
                }
                else
                    nvFVFDrawLine((DWORD)wCommandCount, 2, lpPrim);

                dbgFlushDmaBuffers(pCurrentContext);
                NEXTINSTRUCTION(lpCommands, BYTE, ((wCommandCount + 1) * dwVertexStride), 0);
                /*
                 * Realign next command since vertices are dword aligned
                 */
                lpCommands = (LPD3DHAL_DP2COMMAND)(( ((DWORD)lpCommands) + 3 ) & ~ 3);
                break;
            /*
             * Change the texture stage state.
             */
            case D3DDP2OP_TEXTURESTAGESTATE:
                bFilterChanged = FALSE;
                bTSSChanged = FALSE;

                /*
                 * Display the texture stage state changes.
                 */
                for (i = 0; i < wCommandCount; i++)
                {
                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrim);

                    dwStage = (DWORD)((LPD3DHAL_DP2TEXTURESTAGESTATE)lpPrim)->wStage;
                    dwState = ((LPD3DHAL_DP2TEXTURESTAGESTATE)lpPrim)->TSState;
                    dwValue = ((LPD3DHAL_DP2TEXTURESTAGESTATE)lpPrim)->dwValue;
                    if (dbgShowState & NVDBG_SHOW_RENDER_STATE)
                        DPF("Texture Stage State Change - Stage: %ld, Type: %ld, State: %ld", dwStage, dwState, dwValue);
                    switch (dwState)
                    {
                        // D3DTSS_TEXTUREMAP
                        case 0:
                            /*
                             * Turn the texture handle into a texture pointer.
                             */
                            // test with default texture -paul

                            if (dwValue)
                            {
                                dwValue |= 0x80000000;
                                if (pCurrentContext->tssState[dwStage].dwTextureMap != dwValue)
                                {
                                    pCurrentContext->tssState[dwStage].dwTextureMap = dwValue;
                                    bTSSChanged = TRUE;
                                }
                            }
                            else
                            {
                                if (pCurrentContext->tssState[dwStage].dwTextureMap)
                                {
                                    pCurrentContext->tssState[dwStage].dwTextureMap = dwValue;
                                    bTSSChanged = TRUE;
                                }
                            }
                            /*
                             * For texture stage 0, propogate the change to DX5 class renderstate.
                             */
                            if (dwStage == 0)
                                nvSetContextState(D3DRENDERSTATE_TEXTUREHANDLE, dwValue, &ddrval);
                            break;
                        case D3DTSS_ADDRESS:
                            if ((pCurrentContext->tssState[dwStage].dwAddressU != dwValue)
                             || (pCurrentContext->tssState[dwStage].dwAddressV != dwValue))
                            {
                                pCurrentContext->tssState[dwStage].dwAddressU = dwValue;
                                pCurrentContext->tssState[dwStage].dwAddressV = dwValue;
                                bTSSChanged = TRUE;
                            }
                            /*
                             * For texture stage 0, propogate the change to DX5 class renderstate.
                             */
                            if (dwStage == 0)
                                nvSetContextState(D3DRENDERSTATE_TEXTUREADDRESS, dwValue, &ddrval);
                            break;
                        case D3DTSS_ADDRESSU:
                            if (pCurrentContext->tssState[dwStage].dwAddressU != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwAddressU = dwValue;
                                bTSSChanged = TRUE;
                            }
                            /*
                             * For texture stage 0, propogate the change to DX5 class renderstate.
                             */
                            if (dwStage == 0)
                                nvSetContextState(D3DRENDERSTATE_TEXTUREADDRESSU, dwValue, &ddrval);
                            break;
                        case D3DTSS_ADDRESSV:
                            if (pCurrentContext->tssState[dwStage].dwAddressV != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwAddressV = dwValue;
                                bTSSChanged = TRUE;
                            }
                            /*
                             * For texture stage 0, propogate the change to DX5 class renderstate.
                             */
                            if (dwStage == 0)
                                nvSetContextState(D3DRENDERSTATE_TEXTUREADDRESSV, ((LPD3DHAL_DP2TEXTURESTAGESTATE)lpPrim)->dwValue, &ddrval);
                            break;
                        case D3DTSS_MAGFILTER:
                            if (pCurrentContext->tssState[dwStage].dwMagFilter != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwMagFilter = dwValue;
                                bTSSChanged = TRUE;
                            }
                            if (dwStage == 0)
                                bFilterChanged = TRUE;
                            break;
                        case D3DTSS_MINFILTER:
                            if (pCurrentContext->tssState[dwStage].dwMinFilter != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwMinFilter = dwValue;
                                bTSSChanged = TRUE;
                            }
                            if (dwStage == 0)
                                bFilterChanged = TRUE;
                            break;
                        case D3DTSS_MIPFILTER:
                            if (pCurrentContext->tssState[dwStage].dwMipFilter != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwMipFilter = dwValue;
                                bTSSChanged = TRUE;
                            }
                            if (dwStage == 0)
                                bFilterChanged = TRUE;
                            break;
                        case D3DTSS_COLOROP:
                            if (pCurrentContext->tssState[dwStage].dwColorOp != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwColorOp = dwValue;
                                bTSSChanged = TRUE;
                            }
                            pCurrentContext->bUseTBlendSettings = FALSE;
                            break;
                        case D3DTSS_COLORARG1:
                            if (pCurrentContext->tssState[dwStage].dwColorArg1 != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwColorArg1 = dwValue;
                                bTSSChanged = TRUE;
                            }
                            pCurrentContext->bUseTBlendSettings = FALSE;
                            break;
                        case D3DTSS_COLORARG2:
                            if (pCurrentContext->tssState[dwStage].dwColorArg2 != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwColorArg2 = dwValue;
                                bTSSChanged = TRUE;
                            }
                            pCurrentContext->bUseTBlendSettings = FALSE;
                            break;
                        case D3DTSS_ALPHAOP:
                            if (pCurrentContext->tssState[dwStage].dwAlphaOp != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwAlphaOp = dwValue;
                                bTSSChanged = TRUE;
                            }
                            pCurrentContext->bUseTBlendSettings = FALSE;
                            break;
                        case D3DTSS_ALPHAARG1:
                            if (pCurrentContext->tssState[dwStage].dwAlphaArg1 != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwAlphaArg1 = dwValue;
                                bTSSChanged = TRUE;
                            }
                            pCurrentContext->bUseTBlendSettings = FALSE;
                            break;
                        case D3DTSS_ALPHAARG2:
                            if (pCurrentContext->tssState[dwStage].dwAlphaArg2 != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwAlphaArg2 = dwValue;
                                bTSSChanged = TRUE;
                            }
                            pCurrentContext->bUseTBlendSettings = FALSE;
                            break;
                        case D3DTSS_BUMPENVMAT00:
                            if (pCurrentContext->tssState[dwStage].dwBumpEnvMat00 != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwBumpEnvMat00 = dwValue;
                                bTSSChanged = TRUE;
                            }
                            break;
                        case D3DTSS_BUMPENVMAT01:
                            if (pCurrentContext->tssState[dwStage].dwBumpEnvMat01 != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwBumpEnvMat01 = dwValue;
                                bTSSChanged = TRUE;
                            }
                            break;
                        case D3DTSS_BUMPENVMAT10:
                            if (pCurrentContext->tssState[dwStage].dwBumpEnvMat10 != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwBumpEnvMat10 = dwValue;
                                bTSSChanged = TRUE;
                            }
                            break;
                        case D3DTSS_BUMPENVMAT11:
                            if (pCurrentContext->tssState[dwStage].dwBumpEnvMat11 != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwBumpEnvMat11 = dwValue;
                                bTSSChanged = TRUE;
                            }
                            break;
                        case D3DTSS_TEXCOORDINDEX:
                            if (pCurrentContext->tssState[dwStage].dwTexCoordIndex != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwTexCoordIndex = dwValue;
                                bTSSChanged = TRUE;
                            }
                            break;
                        case D3DTSS_BORDERCOLOR:
                            if (pCurrentContext->tssState[dwStage].dwBorderColor != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwBorderColor = dwValue;
                                bTSSChanged = TRUE;
                            }
                            break;
                        case D3DTSS_MIPMAPLODBIAS:
                            if (pCurrentContext->tssState[dwStage].dwMipMapLODBias != dwValue)
                            {
                                /*
                                 * Convert LODBIAS value to NV hardware value.
                                 * Here is the true meaning of this value as implemented by the reference rasterizer:
                                 *    Floating-point D3DVALUE value used to change the level of detail (LOD) bias.
                                 *    This value offsets the value of the mipmap level that is computed by trilinear
                                 *    texturing. It is usually in the range  -1.0 to 1.0; the default value is 0.0.
                                 *    Each unit bias (+/-1.0) biases the selection by exactly one mipmap level.
                                 *    A negative bias will cause the use of larger mipmap levels, resulting in a
                                 *    sharper but more aliased image.
                                 *    A positive bias will cause the use of smaller mipmap levels, resulting in a
                                 *    blurrier image.
                                 *    Applying a positive bias also results in the referencing of a smaller amount
                                 *    of texture data, which can boost performance on some systems.
                                 */
                                pCurrentContext->tssState[dwStage].dwMipMapLODBias = dwValue;
                                if (!dwValue)
                                    pCurrentContext->dwMipMapLODBias = pDriverData->regLODBiasAdjust;
                                else
                                {
                                    D3DVALUE dvLODBias;
                                    dvLODBias = *((D3DVALUE *)&dwValue);
                                    if (dvLODBias > 15.0f)
                                        dvLODBias = 15.0f;
                                    else if (dvLODBias < -15.0f)
                                        dvLODBias = -15.0f;
                                    /*
                                     * Convert the floating point value from D3D into a 5.3 NV value.
                                     * 0x08 == 1.0f
                                     */
                                    dvLODBias *= 8.0;
                                    pCurrentContext->tssState[dwStage].bLODBias = (BYTE)((long)dvLODBias & 0x000000FF);
                                }
                                bTSSChanged = TRUE;
                            }
                            /*
                             * For texture stage 0, propogate the change to DX5 class renderstate.
                             */
                            if (dwStage == 0)
                                nvSetContextState(D3DRENDERSTATE_MIPMAPLODBIAS, dwValue, &ddrval);
                            break;
                        case D3DTSS_MAXMIPLEVEL:
                            if (pCurrentContext->tssState[dwStage].dwMaxMipLevel != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwMaxMipLevel = dwValue;
                                bTSSChanged = TRUE;
                            }
                            break;
                        case D3DTSS_MAXANISOTROPY:
                            if (pCurrentContext->tssState[dwStage].dwMaxAnisotropy != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwMaxAnisotropy = dwValue;
                                bTSSChanged = TRUE;
                            }
                            break;
                        case D3DTSS_BUMPENVLSCALE:
                            if (pCurrentContext->tssState[dwStage].dwBumpEnvlScale != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwBumpEnvlScale = dwValue;
                                bTSSChanged = TRUE;
                            }
                            break;
                        case D3DTSS_BUMPENVLOFFSET:
                            if (pCurrentContext->tssState[dwStage].dwBumpEnvlOffset != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwBumpEnvlOffset = dwValue;
                                bTSSChanged = TRUE;
                            }
                            break;
                        default:
                            DPF_LEVEL(NVDBG_LEVEL_ERROR, "Unimplemented Texture Stage State!!!  Stage: %ld, Type: %ld, State: %ld",
                                      dwStage, dwState, dwValue);
                            dbgD3DError();
                            break;
                    }
                    lpPrim += sizeof(D3DHAL_DP2TEXTURESTAGESTATE);
                }
                if (bFilterChanged)
                {
                    /*
                     * Calculate equivalent TEXTUREMIN and TEXTUREMAG bits from MINFILTER, MAGFILTER and MIPFILTER.
                     */
                    switch (pCurrentContext->tssState[0].dwMagFilter)
                    {
                        case D3DTFG_POINT:
                            dwMagFilter = D3DFILTER_NEAREST;
                            break;
                        case D3DTFG_LINEAR:
                            dwMagFilter = D3DFILTER_LINEAR;
                            break;
                        default:
                            dwMagFilter = D3DFILTER_LINEAR;
                            break;
                    }

                    if (pCurrentContext->tssState[0].dwMipFilter == D3DTFP_NONE)
                    {
                        switch (pCurrentContext->tssState[0].dwMinFilter)
                        {
                            case D3DTFN_POINT:
                                dwMinFilter = D3DFILTER_NEAREST;
                                break;
                            case D3DTFN_LINEAR:
                                dwMinFilter = D3DFILTER_LINEAR;
                                break;
                            default:
                                dwMinFilter = D3DFILTER_LINEAR;
                                break;
                        }
                    }
                    else if (pCurrentContext->tssState[0].dwMipFilter == D3DTFP_POINT)
                    {
                        switch (pCurrentContext->tssState[0].dwMinFilter)
                        {
                            case D3DTFN_POINT:
                                dwMinFilter = D3DFILTER_MIPNEAREST;
                                break;
                            case D3DTFN_LINEAR:
                                dwMinFilter = D3DFILTER_MIPLINEAR;
                                break;
                            default:
                                dwMinFilter = D3DFILTER_MIPLINEAR;
                                break;
                        }
                    }
                    else
                    {
                        switch (pCurrentContext->tssState[0].dwMinFilter)
                        {
                            case D3DTFN_POINT:
                                dwMinFilter = D3DFILTER_LINEARMIPNEAREST;
                                break;
                            case D3DTFN_LINEAR:
                                dwMinFilter = D3DFILTER_LINEARMIPLINEAR;
                                break;
                            default:
                                dwMinFilter = D3DFILTER_LINEARMIPLINEAR;
                                break;
                        }
                    }
                    nvSetContextState(D3DRENDERSTATE_TEXTUREMAG, dwMagFilter, &ddrval);
                    nvSetContextState(D3DRENDERSTATE_TEXTUREMIN, dwMinFilter, &ddrval);
                }
                /*
                 * If the state has changed force a hardware state load.
                 */
                if (bTSSChanged)
                {
                    /*
                     * If this is a DX6 application, then force hardware steup through
                     * the DX6 hardware setup routine, even if there is only one stage.
                     */
                    pCurrentContext->bUseDX6Class     = (pCurrentContext->dwDXVersionLevel >= APP_VERSION_DX6);
                    pCurrentContext->dwStateChange    = TRUE;
                    NV_FORCE_TRI_SETUP(pCurrentContext);
                }
                NEXTINSTRUCTION(lpCommands, D3DHAL_DP2TEXTURESTAGESTATE, wCommandCount, 0);
                break;
            /*
             * DX5 style DrawOneIndexedPrimitive indexed triangle strip.
             */
            case D3DDP2OP_INDEXEDTRIANGLELIST2:
#ifdef  WINNT
                {
                    WORD    wIndexBase, wIndex1, wIndex2, wIndex3;
                    DWORD   i;
                    D3DHAL_DP2INDEXEDTRIANGLELIST2 *lpPrimCheck;

                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrim);
                    wIndexBase = ((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart;
                    lpPrimCheck = (D3DHAL_DP2INDEXEDTRIANGLELIST2 *)(lpPrim + sizeof(D3DHAL_DP2STARTVERTEX));
                    for (i = 0; i < wCommandCount; i++)
                    {
                        CHECK_CMDBUF_LIMITS(pdp2d, lpPrimCheck);
                        wIndex1 = lpPrimCheck->wV1;
                        wIndex2 = lpPrimCheck->wV2;
                        wIndex3 = lpPrimCheck->wV3;
                        CHECK_DATABUF_LIMITS(pdp2d, wIndexBase + wIndex1);
                        CHECK_DATABUF_LIMITS(pdp2d, wIndexBase + wIndex2);
                        CHECK_DATABUF_LIMITS(pdp2d, wIndexBase + wIndex3);
                        lpPrimCheck++;
                    }
                }
#endif
                lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart * dwVertexStride);
                fnFillModeIndexedTriangle[pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE]]((DWORD)wCommandCount, (LPWORD)(lpPrim + sizeof(D3DHAL_DP2STARTVERTEX)), LIST_STRIDES, lpFVFVertices);

                /*
                 * Update the put offset.
                 */
                //nvStartDmaBuffer(); // For some reason, taking these lines out caused dropped triangles, especially in 3D winbench!  Why???
                dbgFlushDmaBuffers(pCurrentContext);
                NEXTINSTRUCTION(lpCommands, D3DHAL_DP2INDEXEDTRIANGLELIST2, wCommandCount, sizeof(D3DHAL_DP2STARTVERTEX));
                break;
            /*
             * DX5 DrawOneIndexedPrimitive style indexed line list.
             */
            case D3DDP2OP_INDEXEDLINELIST2:
#ifdef  WINNT
                {
                    WORD    wIndexBase, wIndex1, wIndex2;
                    DWORD   i;
                    D3DHAL_DP2INDEXEDLINELIST *lpPrimCheck;

                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrim);
                    wIndexBase = ((D3DHAL_DP2STARTVERTEX*)lpPrim)->wVStart;
                    lpPrimCheck = (D3DHAL_DP2INDEXEDLINELIST *)(lpPrim + sizeof(D3DHAL_DP2STARTVERTEX));
                    for (i = 0; i < wCommandCount; i++)
                    {
                        CHECK_CMDBUF_LIMITS(pdp2d, lpPrimCheck);
                        wIndex1 = lpPrimCheck->wV1;
                        wIndex2 = lpPrimCheck->wV2;
                        CHECK_DATABUF_LIMITS(pdp2d, wIndexBase + wIndex1);
                        CHECK_DATABUF_LIMITS(pdp2d, wIndexBase + wIndex2);
                        lpPrimCheck++;
                    }
                }
#endif
                if (!pCurrentContext->bUseDX6Class)
                {
                    if (dwVertexType == D3DFVF_TLVERTEX)
                        nvIndexedLine((DWORD)wCommandCount, (LPWORD)(lpPrim + sizeof(D3DHAL_DP2STARTVERTEX)), 2, (LPD3DTLVERTEX)&lpVertices[((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart]);
                    else
                    {
                        lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart * dwVertexStride);
                        nvFVFIndexedLine((DWORD)wCommandCount, (LPWORD)(lpPrim + sizeof(D3DHAL_DP2STARTVERTEX)), 2, lpFVFVertices);
                    }
                }
                else
                {
                    lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart * dwVertexStride);
                    nvFVFIndexedLine((DWORD)wCommandCount, (LPWORD)(lpPrim + sizeof(D3DHAL_DP2STARTVERTEX)), 2, lpFVFVertices);
                }

                /*
                 * Update the put offset.
                 */
                //nvStartDmaBuffer(); // For some reason, taking these lines out caused dropped triangles, especially in 3D winbench!  Why???
                dbgFlushDmaBuffers(pCurrentContext);
                NEXTINSTRUCTION(lpCommands, D3DHAL_DP2INDEXEDLINELIST, wCommandCount, sizeof(D3DHAL_DP2STARTVERTEX));
                break;
            /*
             *
             */
            case D3DDP2OP_VIEWPORTINFO:
            {
                WORD    wX      = (WORD)(((LPD3DHAL_DP2VIEWPORTINFO)lpPrim)->dwX & 0x0000FFFF);
                WORD    wY      = (WORD)(((LPD3DHAL_DP2VIEWPORTINFO)lpPrim)->dwY & 0x0000FFFF);
                WORD    wWidth  = (WORD)(((LPD3DHAL_DP2VIEWPORTINFO)lpPrim)->dwWidth & 0x0000FFFF);
                WORD    wHeight = (WORD)(((LPD3DHAL_DP2VIEWPORTINFO)lpPrim)->dwHeight & 0x0000FFFF);
                if ((pCurrentContext->surfaceViewport.clipHorizontal.wX != wX)
                 || (pCurrentContext->surfaceViewport.clipVertical.wY != wY)
                 || (pCurrentContext->surfaceViewport.clipHorizontal.wWidth != wWidth)
                 || (pCurrentContext->surfaceViewport.clipVertical.wHeight != wHeight))
                {
                    pCurrentContext->surfaceViewport.clipHorizontal.wX     = wX;
                    pCurrentContext->surfaceViewport.clipVertical.wY       = wY;
                    pCurrentContext->surfaceViewport.clipHorizontal.wWidth = wWidth;
                    pCurrentContext->surfaceViewport.clipVertical.wHeight  = wHeight;
                    nvSetD3DSurfaceViewport(pCurrentContext);
                }
                NEXTINSTRUCTION(lpCommands, D3DHAL_DP2VIEWPORTINFO, 1, 0);
                break;
            }
            /*
             *
             */
            case D3DDP2OP_WINFO:
                pCurrentContext->dvWNear = ((LPD3DHAL_DP2WINFO)lpPrim)->dvWNear;
                pCurrentContext->dvWFar  = ((LPD3DHAL_DP2WINFO)lpPrim)->dvWFar;
                /*
                 * If the WFar value is 0.0, then set a default based on the z-buffer precision.
                 */
                if (pCurrentContext->dvWFar == 0.0f)
                {
                    pCurrentContext->dvWNear = 0.0f;
                    if ((pCurrentContext->dwSurfaceFormat == (DRF_DEF(053, _SET_FORMAT, _TYPE, _PITCH) | DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_X1R5G5B5_Z1R5G5B5)))
                     || (pCurrentContext->dwSurfaceFormat == (DRF_DEF(053, _SET_FORMAT, _TYPE, _PITCH) | DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_R5G6B5))))
                    {
                        pCurrentContext->dvWFar  = (D3DVALUE)(1 << 16);
                    }
                    else
                    {
                        pCurrentContext->dvWFar  = (D3DVALUE)(1 << 24);
                    }
                }
//                pCurrentContext->dvRWFar = 1.0f / ((LPD3DHAL_DP2WINFO)lpPrim)->dvWFar;
                pCurrentContext->dvRWFar = ((LPD3DHAL_DP2WINFO)lpPrim)->dvWFar;
                NEXTINSTRUCTION(lpCommands, D3DHAL_DP2WINFO, 1, 0);
                break;

            /*
             * Unknown command.  Pass it to the Unknown Command Callback for handling.
             */
            default:
                if (fnD3DParseUnknownCommandCallback)
                {
                    ddrval=fnD3DParseUnknownCommandCallback(lpCommands, &lpResumeCommands);
                    if (ddrval != DD_OK)
                    {
                        nvStartDmaBuffer (TRUE);
                        pdp2d->ddrval = ddrval;
                        pdp2d->dwErrorOffset = (DWORD)lpCommands - dwCommandBufferStart;
                        NV_D3D_GLOBAL_SAVE();
#ifdef  CACHE_FREECOUNT
                        pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
                        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
#ifdef NV_PROFILE
                        NVP_STOP (NVP_T_DP2);
                        nvpLogTime (NVP_T_DP2,nvpTime[NVP_T_DP2]);
#endif
                        return (DDHAL_DRIVER_HANDLED);
                    }

                    /*
                     * Set the resume address.
                     */
                    lpCommands = lpResumeCommands;
                }
                else
                {
                    nvStartDmaBuffer (TRUE);
                    pdp2d->ddrval = D3DERR_COMMAND_UNPARSED;
                    pdp2d->dwErrorOffset = (DWORD)lpCommands - dwCommandBufferStart;
                    NV_D3D_GLOBAL_SAVE();
#ifdef  CACHE_FREECOUNT
                    pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
                    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
#ifdef NV_PROFILE
                    NVP_STOP (NVP_T_DP2);
                    nvpLogTime (NVP_T_DP2,nvpTime[NVP_T_DP2]);
#endif
                    return (DDHAL_DRIVER_HANDLED);
                }
                break;
        }
    }
    nvStartDmaBuffer (TRUE);
    pDriverData->TwoDRenderingOccurred   = 0;
    pDriverData->ThreeDRenderingOccurred = TRUE;
    NV_D3D_GLOBAL_SAVE();
    dbgFlushDDI(pCurrentContext);

#ifdef  CACHE_FREECOUNT
    pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT

#ifdef NV_PROFILE
    NVP_STOP (NVP_T_DP2);
    nvpLogTime (NVP_T_DP2,nvpTime[NVP_T_DP2]);
#endif

    pdp2d->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}
#endif  // NVD3D_DX6
#endif  // NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4swiz.c ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4SWIZ.C                                                         *
*   Texture swizzling routines (some HW dependence).                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 10/20/98 - wrote it                     *
*                                                                           *
\***************************************************************************/
#include <windows.h>
#include <assert.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv4dreg.h"
#include "nv3ddbg.h"

#ifdef NV_TEX2

/*
 * constants
 */
#define L2MB        5
#define MB          (1<<L2MB)   // swizzle macroblock size

#define MB_UMASK    ((MB*MB-1) & 0x55555555)
#define MB_VMASK    ((MB*MB-1) & 0xaaaaaaaa)

/*
 * macros
 */
#define ilcData         global.dwILCData
#define ilcCount        global.dwILCCount
#define ilcMax          global.dwILCMax

#define TEXELCOPY(d,s,bpp)                          \
{                                                   \
    if ((bpp) == 2) *(WORD*)(d)  = *(WORD*)(s);     \
    /*else if ((bpp) == 1) *(BYTE*)(d)  = *(BYTE*)(s);*/\
    else *(DWORD*)(d) = *(DWORD*)(s);               \
}

/*
 * swizzle table buffer layout
 */
BYTE nvTexelScratchBuffer[8192];  // must be as wide as the widest pitch (4 * 2048 = 8192)

#ifdef HW_PAL8
DWORD nvTextureBase_meta; // != NULL for palettized textures
WORD  nvPalette[256];
#endif

/*
 * helpers
 * -------
 */

/*
 * nvSwizzleCalcSwizInfo
 *
 * converts an x,y position to a swizzled blt
 * up to 2048x2048 textures supported
 */
void nvSwizzleCalcSwizzleInfo
(
    DWORD  dwX,
    DWORD  dwY,
    DWORD  dwLogW,
    DWORD  dwLogH,
    DWORD  dwBPP,
    DWORD *pdwOffset,
    DWORD *pdwDUDXor,
    DWORD *pdwDUDXand,
    DWORD *pdwDVDYor,
    DWORD *pdwDVDYand
)
{
    DWORD dwLog       = min(dwLogW,dwLogH);
    DWORD dw2Log      = dwLog << 1;            // # of bits to interleave
    DWORD dwUpperMask = ~((1 << dw2Log) - 1);  // bits to preserve
    DWORD dwLowerMask = ~dwUpperMask;          // bits to interleave

    /*
     * calc offset
     */
    DWORD dwUpperU    = (dwX << dwLog) & dwUpperMask;
    DWORD dwUpperV    = (dwY << dwLog) & dwUpperMask;

    DWORD dwLower     = ((dwX & 0x001) <<  0) | ((dwY & 0x001) <<  1)
                      | ((dwX & 0x002) <<  1) | ((dwY & 0x002) <<  2)
                      | ((dwX & 0x004) <<  2) | ((dwY & 0x004) <<  3)
                      | ((dwX & 0x008) <<  3) | ((dwY & 0x008) <<  4)
                      | ((dwX & 0x010) <<  4) | ((dwY & 0x010) <<  5)
                      | ((dwX & 0x020) <<  5) | ((dwY & 0x020) <<  6)
                      | ((dwX & 0x040) <<  6) | ((dwY & 0x040) <<  7)
                      | ((dwX & 0x080) <<  7) | ((dwY & 0x080) <<  8)
                      | ((dwX & 0x100) <<  8) | ((dwY & 0x100) <<  9)
                      | ((dwX & 0x200) <<  9) | ((dwY & 0x200) << 10)
                      | ((dwX & 0x400) << 10) | ((dwY & 0x400) << 11)
                      | ((dwX & 0x800) << 11) | ((dwY & 0x800) << 12);

    *pdwOffset = ((dwLower & dwLowerMask) | dwUpperU | dwUpperV) * dwBPP;

    /*
     * calc masks
     */
    *pdwDUDXor  = (0xaaaaaaaa & dwLowerMask) * dwBPP;
    *pdwDUDXand = (0x55555555 | dwUpperMask) * dwBPP;
    *pdwDVDYor  = (0x55555555 & dwLowerMask) * dwBPP;
    *pdwDVDYand = (0xaaaaaaaa | dwUpperMask) * dwBPP;
}

/*
 * SOFTWARE SWIZZLE
 * ----------------
 */

/*
 * nvSwizzleSmallBlock
 *
 * swizzles any texture with a dimension less than 8 (i.e. 2048 x 4)
 */
void nvSwizzleSmallBlock
(
    DWORD dwSrcBase,
    DWORD dwSrcPitch,

    DWORD dwDestBase,

    DWORD dwLogW,
    DWORD dwLogH,
    DWORD dwBPP
)
{
    DWORD dwOffset;
    DWORD dwDUDXor;
    DWORD dwDUDXand;
    DWORD dwDVDYor;
    DWORD dwDVDYand;
    DWORD dwCount,dwSize,dwLine;
    DWORD dwScratch0,dwScratch1;
    DWORD u,v,x,y;
    void *pMemory;

    /*
     * optimize for really thin textures (swizzle bits do not work with width==1)
     */
    if (!dwLogW)
    {
        if (dwSrcPitch != (dwBPP << dwLogH))
        {
            switch (dwBPP)
            {
                case 1:
                {
                    u = (DWORD)nvTexelScratchBuffer;
                    for (y = (1 << dwLogH); y; y--)
                    {
                        *(BYTE*)u = *(BYTE*)dwSrcBase;
                        dwSrcBase += dwSrcPitch;
                        u += 1;
                    }
                    break;
                }
                case 2:
                {
                    u = (DWORD)nvTexelScratchBuffer;
                    for (y = (1 << dwLogH); y; y--)
                    {
                        *(WORD*)u = *(WORD*)dwSrcBase;
                        dwSrcBase += dwSrcPitch;
                        u += 2;
                    }
                    break;
                }
                case 4:
                {
                    u = (DWORD)nvTexelScratchBuffer;
                    for (y = (1 << dwLogH); y; y--)
                    {
                        *(DWORD*)u = *(DWORD*)dwSrcBase;
                        dwSrcBase += dwSrcPitch;
                        u += 4;
                    }
                    break;
                }
            }
            nvMemCopy (dwDestBase,(DWORD)nvTexelScratchBuffer,dwBPP << dwLogH,NV_MEMCOPY_WANTDESTALIGNED);
            return;
        }
        else
        {
            /*
             * pitch == width, treat as thin horz texture
             */
            dwLogW = dwLogH;
            dwLogH = 0;
        }
    }
    if (!dwLogH)
    {
        nvMemCopy ((DWORD)nvTexelScratchBuffer,dwSrcBase,dwBPP << dwLogW,NV_MEMCOPY_WANTSRCALIGNED);
        nvMemCopy (dwDestBase,(DWORD)nvTexelScratchBuffer,dwBPP << dwLogW,NV_MEMCOPY_WANTDESTALIGNED);
        return;
    }

    /*
     * figure out bits
     */
    nvSwizzleCalcSwizzleInfo (0,0,dwLogW,dwLogH,dwBPP,
                              &dwOffset,
                              &dwDUDXor,&dwDUDXand,
                              &dwDVDYor,&dwDVDYand);

    /*
     * figure out memory requirements
     */
    dwCount = 1     << (dwLogW + dwLogH);
    dwSize  = dwBPP << (dwLogW + dwLogH);
    if (dwSize > 4096)
    {
        pMemory = AllocIPM(dwSize * 2);
        dwScratch0 = (DWORD)pMemory;
        dwScratch1 = ((DWORD)pMemory) + dwSize;
    }
    else
    {
        pMemory    = NULL;
        dwScratch0 = (DWORD)(nvTexelScratchBuffer + 0);
        dwScratch1 = (DWORD)(nvTexelScratchBuffer + 4096);
    }

    /*
     * read texels
     */
    dwLine = dwBPP << dwLogW;
    if (dwLine != dwSrcPitch)
    {
        u = dwSrcBase;
        v = dwScratch0;
        for (y = (1 << dwLogH); y; y--)
        {
            nvMemCopy (v,u,dwLine,NV_MEMCOPY_WANTSRCALIGNED);
            v += dwLine;
            u += dwSrcPitch;
        }
    }
    else
    {
        nvMemCopy (dwScratch0,dwSrcBase,dwLine << dwLogH,NV_MEMCOPY_WANTSRCALIGNED);
    }

    /*
     * do swizzle
     */
    switch (dwBPP)
    {
        case 1:
        {
            v = 0;
            for (y = (1 << dwLogH); y; y--)
            {
                u = 0;
                for (x = (1 << dwLogW); x; x--)
                {
                    *(BYTE*)(dwScratch1 + (u | v)) = *(BYTE*)dwScratch0;

                    dwScratch0 += 1;
                    u           = ((u | dwDUDXor) + 1) & dwDUDXand;
                }
                v = ((v | dwDVDYor) + (1*2)) & dwDVDYand;
            }
            break;
        }
        case 2:
        {
            v = 0;
            for (y = (1 << dwLogH); y; y--)
            {
                u = 0;
                for (x = (1 << dwLogW); x; x--)
                {
                    *(WORD*)(dwScratch1 + (u | v)) = *(WORD*)dwScratch0;

                    dwScratch0 += 2;
                    u           = ((u | dwDUDXor) + 2) & dwDUDXand;
                }
                v = ((v | dwDVDYor) + (2*2)) & dwDVDYand;
            }
            break;
        }
        case 4:
        {
            v = 0;
            for (y = (1 << dwLogH); y; y--)
            {
                u = 0;
                for (x = (1 << dwLogW); x; x--)
                {
                    *(DWORD*)(dwScratch1 + (u | v)) = *(DWORD*)dwScratch0;

                    dwScratch0 += 4;
                    u           = ((u | dwDUDXor) + 4) & dwDUDXand;
                }
                v = ((v | dwDVDYor) + (4*2)) & dwDVDYand;
            }
            break;
        }
    }

    /*
     * write texels
     */
#ifdef HW_PAL8
    if (nvTextureBase_meta)
    {
        DWORD i = dwSize;

        u = dwScratch1;
        v = dwScratch0;
        while (i)
        {
            BYTE bIndex = *(BYTE*)u;
            WORD wColor = nvPalette[bIndex];
            *(WORD*)v = wColor;
            u ++;
            v += 2;
            i --;
        }
        u = dwScratch0;
        v = dwDestBase;
        nvMemCopy (v,u,dwSize*2,NV_MEMCOPY_WANTDESTALIGNED);
    }
    else
    {
        u = dwScratch1;
        v = dwDestBase;
        nvMemCopy (v,u,dwSize,NV_MEMCOPY_WANTDESTALIGNED);
    }
#else
    u = dwScratch1;
    v = dwDestBase;
    nvMemCopy (v,u,dwSize,NV_MEMCOPY_WANTDESTALIGNED);
#endif

    /*
     * free memory
     */
    if (pMemory) FreeIPM (pMemory);
}

/*
 * nvSwizzleMacroBlock_LS
 *
 * swizzles a full MBxMB block (lin -> swz)
 */
void nvSwizzleMacroBlock_LS
(
    DWORD dwSrcBase,
    DWORD dwSrcPitch,
    DWORD dwDestBase,
    DWORD dwBPP
)
{
    DWORD src,dst,cnt;
    DWORD x,y,u,v;

    /*
     * read texels
     */
    src = dwSrcBase;
    dst = (DWORD)(nvTexelScratchBuffer + 0);
    cnt = dwBPP << L2MB;
    for (y=MB; y; y--)
    {
        nvMemCopy (dst,src,cnt,NV_MEMCOPY_WANTSRCALIGNED);
        dst += cnt;
        src += dwSrcPitch;
    }

    /*
     * swizzle texels
     */
    src = (DWORD)(nvTexelScratchBuffer + 0);
    dst = (DWORD)(nvTexelScratchBuffer + 4096);
    u   = 0;
    v   = 0;
    switch (dwBPP)
    {
        case 1:
        {
            for (y=MB; y; y--)
            {
                u = 0;
                for (x=MB; x; x--)
                {
                    *(BYTE*)(dst + (u | v)) = *(BYTE*)src;
                    src += 1;
                    u = ((u | (MB_VMASK*1)) + 1*1) & (MB_UMASK*1);
                }
                v = ((v | (MB_UMASK*1)) + 2*1) & (MB_VMASK*1);
            }
            break;
        }
        case 2:
        {
            for (y=MB; y; y--)
            {
                u = 0;
                for (x=MB; x; x--)
                {
                    *(WORD*)(dst + (u | v)) = *(WORD*)src;
                    src += 2;
                    u = ((u | (MB_VMASK*2)) + 1*2) & (MB_UMASK*2);
                }
                v = ((v | (MB_UMASK*2)) + 2*2) & (MB_VMASK*2);
            }
            break;
        }
        case 4:
        {
            for (y=MB; y; y--)
            {
                u = 0;
                for (x=MB; x; x--)
                {
                    *(DWORD*)(dst + (u | v)) = *(DWORD*)src;
                    src += 4;
                    u = ((u | (MB_VMASK*4)) + 1*4) & (MB_UMASK*4);
                }
                v = ((v | (MB_UMASK*4)) + 2*4) & (MB_VMASK*4);
            }
            break;
        }
    }

    /*
     * write out
     */
#ifdef HW_PAL8
    if (nvTextureBase_meta)
    {
        DWORD i;
        src   = (DWORD)(nvTexelScratchBuffer + 4096);
        dst   = (DWORD)(nvTexelScratchBuffer + 0);
        cnt <<= L2MB;

        i = cnt;
        while (i)
        {
            BYTE bIndex = *(BYTE*)src;
            WORD wColor = nvPalette[bIndex];
            *(WORD*)dst = wColor;
            src ++;
            dst += 2;
            i   --;
        }

        src = (DWORD)(nvTexelScratchBuffer + 0);
        dst = (dwDestBase - nvTextureBase_meta) * 2 + nvTextureBase_meta; // fixup dest (all code currently assume src & dst bpp the same)
        nvMemCopy (dst,src,cnt*2,NV_MEMCOPY_WANTDESTALIGNED);
    }
    else
    {
        src   = (DWORD)(nvTexelScratchBuffer + 4096);
        dst   = dwDestBase;
        cnt <<= L2MB;
        nvMemCopy (dst,src,cnt,NV_MEMCOPY_WANTDESTALIGNED);
    }
#else
    src   = (DWORD)(nvTexelScratchBuffer + 4096);
    dst   = dwDestBase;
    cnt <<= L2MB;
    nvMemCopy (dst,src,cnt,NV_MEMCOPY_WANTDESTALIGNED);
#endif
}

/*
 * nvSwizzleBlt_LS_FT
 *
 * software swizzle algorithm for full textures
 *  full texture means:
 *    source width & height == dest width & height
 *    blt rectangle is (0,0) - (w,h)
 */
void nvSwizzleBlt_LS_FT
(
    DWORD dwSrcBase,
    DWORD dwSrcPitch,

    DWORD dwDestBase,

    DWORD dwLogW,
    DWORD dwLogH,
    DWORD dwBPP
)
{
    DWORD dwOffset;
    DWORD dwDUDXor;
    DWORD dwDUDXand;
    DWORD dwDVDYor;
    DWORD dwDVDYand;
    DWORD dwMBPP,dwMBPP2;
    DWORD u,v,x,y;

    /*
     * handle small cases
     */
    if ((dwLogW < L2MB) || (dwLogH < L2MB))
    {
        nvSwizzleSmallBlock (dwSrcBase,dwSrcPitch,
                             dwDestBase,
                             dwLogW,dwLogH,dwBPP);
        return;
    }

    /*
     * adjust width & height for macroblocks
     */
    dwLogW -= L2MB;
    dwLogH -= L2MB;
    dwMBPP  = dwBPP << L2MB;
    dwMBPP2 = dwBPP << (L2MB + L2MB);

    /*
     * optimize for thin vertival case (swizzle bit does not work for this)
     */
    if (!dwLogW)
    {
        for (y = (1 << dwLogH); y; y--)
        {
            nvSwizzleMacroBlock_LS (dwSrcBase,dwSrcPitch,
                                    dwDestBase,
                                    dwBPP);
            dwSrcBase  += dwSrcPitch << L2MB;
            dwDestBase += dwMBPP2;
        }
        return;
    }

    /*
     * figure out bits for macro blocks
     */
    nvSwizzleCalcSwizzleInfo (0,0,dwLogW,dwLogH,dwMBPP2,
                              &dwOffset,
                              &dwDUDXor,&dwDUDXand,
                              &dwDVDYor,&dwDVDYand);

    /*
     * do macroblock swizzle
     */
    v = 0;
    for (y = (1 << dwLogH); y; y--)
    {
        DWORD dwSrc = dwSrcBase;

        u = 0;
        for (x = (1 << dwLogW); x; x--)
        {
            nvSwizzleMacroBlock_LS (dwSrc,dwSrcPitch,
                                    dwDestBase + (u | v),
                                    dwBPP);

            u = ((u | dwDUDXor) + dwMBPP2) & dwDUDXand;
            dwSrc += dwBPP << L2MB;
        }
        v = ((v | dwDVDYor) + dwMBPP2*2) & dwDVDYand;

        dwSrcBase += dwSrcPitch << L2MB;
    }
}

/*
 * nvSwizzleBlt_aa_bb_cc
 *
 *  aa E (LL, SL, LS, SS)
 *  bb E (XX, ST)
 *  cc E (XX, LR, LW)
 *
 * swizzle blts we can build - other indices are undefined
 *
 *  lin -> lin, subtexture, machine dep  linear r/w        nvSwizzleBlt_LL_ST_RW
 *  swz -> lin, subtexture, machine dep, linear write      nvSwizzleBlt_SL_ST_LW
 *  lin -> swz, subtexture, machine dep, linear read       nvSwizzleBlt_LS_ST_LR
 *  swz -> swz, subtexture, machine dep                    nvSwizzleBlt_SS_ST_XX
 *  swz -> swz,             machine dep  linear r/w        nvSwizzleBlt_SS_XX_RW
 */
void nvSwizzleBlt_LL_ST_RW
(
    DWORD dwSrcAddr,
    DWORD dwSrcPitch,

    DWORD dwDestAddr,
    DWORD dwDestPitch,

    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwSubHeight,
    DWORD dwBPP
)
{
    DWORD dwBytes = dwWidth * dwBPP;
    DWORD y;

    for (y = dwHeight; y;)
    {
        DWORD a;
        DWORD h;
        DWORD f = min(dwSubHeight,y);

        /*
         * read linear
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            nvMemCopy (a,dwSrcAddr,dwBytes,NV_MEMCOPY_WANTSRCALIGNED);
            dwSrcAddr += dwSrcPitch;
            a         += dwBytes;
        }

        /*
         * write linear
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            nvMemCopy (dwDestAddr,a,dwBytes,NV_MEMCOPY_WANTDESTALIGNED);
            a          += dwBytes;
            dwDestAddr += dwDestPitch;
        }

        y -= f;
    }
}

void nvSwizzleBlt_SL_ST_LW
(
    DWORD dwSrcBase,
    DWORD dwSrcOffset,
    DWORD dwSrcDUDXor,
    DWORD dwSrcDUDXand,
    DWORD dwSrcDVDYor,
    DWORD dwSrcDVDYand,

    DWORD dwDestAddr,
    DWORD dwDestPitch,

    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwSubHeight,
    DWORD dwBPP
)
{
    DWORD dwBytes   = dwWidth * dwBPP;
    DWORD y;

    for (y = dwHeight; y;)
    {
        DWORD a;
        DWORD h;
        DWORD f = min(dwSubHeight,y);

        /*
         * read swizzle
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            DWORD u;
            DWORD v;
            DWORD b;
            DWORD x;

            v = dwSrcOffset & dwSrcDVDYand;
            b = dwSrcOffset;
            for (x = dwWidth; x; x--)
            {
                TEXELCOPY (a,dwSrcBase + b,dwBPP);
                a += dwBPP;
                u = ((b | dwSrcDUDXor) + dwBPP) & dwSrcDUDXand;
                b = u | v;
            }
            u = dwSrcOffset & dwSrcDUDXand;
            v = ((dwSrcOffset | dwSrcDVDYor) + (dwBPP*2)) & dwSrcDVDYand;
            dwSrcOffset = u | v;
        }

        /*
         * write linear
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            nvMemCopy (dwDestAddr,a,dwBytes,NV_MEMCOPY_WANTDESTALIGNED);
            a          += dwBytes;
            dwDestAddr += dwDestPitch;
        }

        y -= f;
    }
}

void nvSwizzleBlt_LS_ST_LR
(
    DWORD dwSrcAddr,
    DWORD dwSrcPitch,

    DWORD dwDestBase,
    DWORD dwDestOffset,
    DWORD dwDestDUDXor,
    DWORD dwDestDUDXand,
    DWORD dwDestDVDYor,
    DWORD dwDestDVDYand,

    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwSubHeight,
    DWORD dwBPP
)
{
    DWORD dwBytes   = dwWidth * dwBPP;
    DWORD y;

    for (y = dwHeight; y;)
    {
        DWORD a;
        DWORD h;
        DWORD f = min(dwSubHeight,y);

        /*
         * read linear
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            nvMemCopy (a,dwSrcAddr,dwBytes,NV_MEMCOPY_WANTSRCALIGNED);
            a         += dwBytes;
            dwSrcAddr += dwSrcPitch;
        }

        /*
         * write swizzle
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            DWORD u;
            DWORD v;
            DWORD b;
            DWORD x;

            v = dwDestOffset & dwDestDVDYand;
            b = dwDestOffset;
            for (x = dwWidth; x; x--)
            {
                TEXELCOPY (dwDestBase + b,a,dwBPP);
                a += dwBPP;
                u = ((b | dwDestDUDXor) + dwBPP) & dwDestDUDXand;
                b = u | v;
            }
            u = dwDestOffset & dwDestDUDXand;
            v = ((dwDestOffset | dwDestDVDYor) + (dwBPP*2)) & dwDestDVDYand;
            dwDestOffset = u | v;
        }

        y -= f;
    }
}

void nvSwizzleBlt_SS_ST_XX
(
    DWORD dwSrcBase,
    DWORD dwSrcOffset,
    DWORD dwSrcDUDXor,
    DWORD dwSrcDUDXand,
    DWORD dwSrcDVDYor,
    DWORD dwSrcDVDYand,

    DWORD dwDestBase,
    DWORD dwDestOffset,
    DWORD dwDestDUDXor,
    DWORD dwDestDUDXand,
    DWORD dwDestDVDYor,
    DWORD dwDestDVDYand,

    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwSubHeight,
    DWORD dwBPP
)
{
    DWORD dwBytes   = dwWidth * dwBPP;
    DWORD y;

    for (y = dwHeight; y;)
    {
        DWORD a;
        DWORD h;
        DWORD f = min(dwSubHeight,y);

        /*
         * read swizzle
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            DWORD u;
            DWORD v;
            DWORD b;
            DWORD x;

            v = dwSrcOffset & dwSrcDVDYand;
            b = dwSrcOffset;
            for (x = dwWidth; x; x--)
            {
                TEXELCOPY (a,dwSrcBase + b,dwBPP);
                a += dwBPP;
                u = ((b | dwSrcDUDXor) + dwBPP) & dwSrcDUDXand;
                b = u | v;
            }
            u = dwSrcOffset & dwSrcDUDXand;
            v = ((dwSrcOffset | dwSrcDVDYor) + (dwBPP*2)) & dwSrcDVDYand;
            dwSrcOffset = u | v;
        }

        /*
         * write swizzle
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            DWORD u;
            DWORD v;
            DWORD b;
            DWORD x;

            v = dwDestOffset & dwSrcDVDYand;
            b = dwDestOffset;
            for (x = dwWidth; x; x--)
            {
                TEXELCOPY (dwDestBase + b,a,dwBPP);
                a += dwBPP;
                u = ((b | dwDestDUDXor) + dwBPP) & dwDestDUDXand;
                b = u | v;
            }
            u = dwDestOffset & dwDestDUDXand;
            v = ((dwDestOffset | dwDestDVDYor) + (dwBPP*2)) & dwDestDVDYand;
            dwDestOffset = u | v;
        }

        y -= f;
    }
}

void nvSwizzleBlt_SS_XX_RW
(
    DWORD dwSrcAddr,

    DWORD dwDestAddr,

    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwSubHeight,
    DWORD dwBPP
)
{
    DWORD dwBytes = dwWidth * dwBPP;
    DWORD y;

    for (y = dwHeight; y;)
    {
        DWORD f = min(dwSubHeight,y);
        DWORD c = f * dwBytes;

        /*
         * read linear (swizzled texels)
         */
        nvMemCopy ((DWORD)&nvTexelScratchBuffer,dwSrcAddr,c,NV_MEMCOPY_WANTSRCALIGNED);
        dwSrcAddr += c;

        /*
         * write linear (swizzled texels)
         */
        nvMemCopy (dwDestAddr,(DWORD)&nvTexelScratchBuffer,c,NV_MEMCOPY_WANTDESTALIGNED);
        dwDestAddr += c;

        y -= f;
    }
}

/*
 * HARDWARE SWIZZLE
 * ----------------
 */

/*
 * nvHWSwizzleBlt
 *
 * perform a HW swizzle blt
 */
void nvHWSwizzleBlt
(
    DWORD dwSrcOffset,
    DWORD dwSrcPitch,
    DWORD dwImageColorFormat,
    DWORD dwSrcX0,
    DWORD dwSrcY0,
    DWORD dwSrcAlloc,

    DWORD dwDstSwizzleOffset,
    DWORD dwMipMapBaseU,
    DWORD dwMipMapBaseV,
    DWORD dwSurfaceColorFormat,

    DWORD dwDstX0,
    DWORD dwDstY0,

    DWORD dwBlitWidth,
    DWORD dwBlitHeight

#ifdef DIRECTSWIZZLE
    ,DWORD dwBPP
#endif
)
{
#ifdef DIRECTSWIZZLE
    {
        /*
         * target surface
         */
        DWORD dwCount = sizeSetObject * 1 + sizeSetStartMethod * 1 + sizeSetData * 4;
        while (nvFreeCount < dwCount)
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, dwCount);

        nvglSetObject      (nvFifo, nvFreeCount, NV_DD_SPARE, NV_DD_SURFACES_2D);
        nvglSetStartMethod (nvFifo, nvFreeCount, NV_DD_SPARE, NV042_SET_COLOR_FORMAT,4);
        nvglSetData        (nvFifo, nvFreeCount,              dwSurfaceColorFormat);
        nvglSetData        (nvFifo, nvFreeCount,              (dwBPP << (16 + dwMipMapBaseU)) | dwSrcPitch);
        nvglSetData        (nvFifo, nvFreeCount,              dwDstSwizzleOffset); // not used
        nvglSetData        (nvFifo, nvFreeCount,              dwDstSwizzleOffset);
    }
#else //!DIRECTSWIZZLE
    /*
     * target surface
     */
    while (nvFreeCount < (sizeSetObject + sizeSetSwizzledSurface))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetSwizzledSurface));
    nvglSetObject          (nvFifo,nvFreeCount,NV_DD_SPARE, D3D_CONTEXT_SURFACE_SWIZZLED);
    nvglSetSwizzledSurface (nvFifo,nvFreeCount,NV_DD_SPARE,
                                        (DRF_NUM(052,_SET_FORMAT,_COLOR ,dwSurfaceColorFormat)
                                        |DRF_NUM(052,_SET_FORMAT,_WIDTH ,dwMipMapBaseU)
                                        |DRF_NUM(052,_SET_FORMAT,_HEIGHT,dwMipMapBaseV)),
                                         dwDstSwizzleOffset);
#endif //!DIRECTSWIZZLE

    /*
     * format
     */
    while (nvFreeCount < (sizeSetObject + sizeSetScaledImageFormat))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetScaledImageFormat));
    nvglSetObject               (nvFifo,nvFreeCount,NV_DD_SPARE, D3D_SCALED_IMAGE_FROM_MEMORY);
    nvglSetScaledImageFormat    (nvFifo,nvFreeCount,NV_DD_SPARE, dwImageColorFormat);

    /*
     * source memory context
     */
    while (nvFreeCount < sizeSetScaledImageContextImage)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeSetScaledImageContextImage);
    if (dwSrcAlloc & NV4_TEXLOC_AGP)
    {
        nvglSetScaledImageContextImage(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY);
    } else if (dwSrcAlloc & NV4_TEXLOC_VID)
    {
        nvglSetScaledImageContextImage(nvFifo, nvFreeCount, NV_DD_SPARE, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
    } else if (dwSrcAlloc & NV4_TEXLOC_PCI)
    {
        nvglSetScaledImageContextImage(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY);
    }

    /*
     * clip
     */
    while (nvFreeCount < (sizeScaledImageClip + sizeScaledImageOut + sizeScaledImageDeltaDuDxDvDy))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeScaledImageClip + sizeScaledImageOut + sizeScaledImageDeltaDuDxDvDy));
    nvglScaledImageClip          (nvFifo,nvFreeCount,NV_DD_SPARE, ((DWORD)dwDstX0), ((DWORD)dwDstY0), dwBlitWidth, dwBlitHeight);
    nvglScaledImageOut           (nvFifo,nvFreeCount,NV_DD_SPARE, ((DWORD)dwDstX0), ((DWORD)dwDstY0), dwBlitWidth, dwBlitHeight);
    nvglScaledImageDeltaDuDxDvDy (nvFifo,nvFreeCount,NV_DD_SPARE, (1<<20), (1<<20));

    /*
     * src & go
     */
    while (nvFreeCount < (sizeScaledImageInSize + sizeScaledImageInFormat + sizeScaledImageInOffset + sizeScaledImageInPoint))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeScaledImageInSize + sizeScaledImageInFormat + sizeScaledImageInOffset + sizeScaledImageInPoint));
    nvglScaledImageInSize   (nvFifo, nvFreeCount, NV_DD_SPARE, dwBlitWidth, dwBlitHeight);
    nvglScaledImageInFormat (nvFifo, nvFreeCount, NV_DD_SPARE,
                             (DRF_NUM(077,_IMAGE_IN_FORMAT,_PITCH,        dwSrcPitch)
                             |DRF_DEF(077,_IMAGE_IN_FORMAT,_ORIGIN,       _CORNER)
                             |DRF_DEF(077,_IMAGE_IN_FORMAT,_INTERPOLATOR, _ZOH)));
    nvglScaledImageInOffset (nvFifo, nvFreeCount, NV_DD_SPARE, dwSrcOffset);
    nvglScaledImageInPoint  (nvFifo, nvFreeCount, NV_DD_SPARE, dwSrcX0, dwSrcY0);

    pDriverData->dDrawSpareSubchannelObject = D3D_SCALED_IMAGE_FROM_MEMORY;
}

#ifdef HW_PAL8
/*
 * nvHWSwizzleBltPal8
 *
 * perform a HW swizzle blt from an 8-bit palettized texture
 */
void nvHWSwizzleBltPal8
(
    // LUT parameters
    DWORD dwLUTOffset,

    // indexed (source) image parameters
    DWORD dwSrcImageAddr,

    // destination surface parameters
    DWORD dwDstSwizzleOffset,
    DWORD dwDstLogU,
    DWORD dwDstLogV,
    DWORD dwDstColorFormat,
    DWORD dwDstBPP,

    // general parameters
    DWORD dwWidth,
    DWORD dwHeight
)
{
    DWORD dwMaxScanLinesPerIteration, dwScanLinesLeftToWrite, dwScanLinesToWrite;
    DWORD dwCount, x0, y0;
    DWORD dwSrcSizeWords;

    if (dwWidth*dwHeight < 4) {
        // this is going to be an annoying special case because it
        // means the stupid thing is less than one DWORD. just bail for now.
        dbgD3DError();
        return;
    }

    // we can put at most 0x1c00 bytes into the buffer at a time
    assert(dwWidth < 0x1c00);
    dwMaxScanLinesPerIteration = 0x1c00 / dwWidth;
    dwScanLinesLeftToWrite = dwHeight;

    //
    // set stuff that doesn't change from one iteration to the next
    //

    // target surface parameters
    // nv05 will be able to write to a swizzled surface. alas nv04 cannot
    /*
    while (nvFreeCount < (sizeSetObject + sizeSetSwizzledSurface))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetSwizzledSurface));
    nvglSetObject          (nvFifo,nvFreeCount,NV_DD_SPARE, D3D_CONTEXT_SURFACE_SWIZZLED);
    nvglSetSwizzledSurface (nvFifo,nvFreeCount,NV_DD_SPARE,
                                        (DRF_NUM(052,_SET_FORMAT,_COLOR ,dwDstColorFormat)
                                        |DRF_NUM(052,_SET_FORMAT,_WIDTH ,dwDstLogU))
                                        |DRF_NUM(052,_SET_FORMAT,_HEIGHT,dwDstLogV)),
                                         dwDstSwizzleOffset);  */
    dwCount = sizeSetObject + sizeSetStartMethod + 4*sizeSetData;
    while (nvFreeCount < dwCount)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, dwCount);
    nvglSetObject      (nvFifo, nvFreeCount, NV_DD_SPARE, NV_DD_SURFACES_2D);
    nvglSetStartMethod (nvFifo, nvFreeCount, NV_DD_SPARE, NV042_SET_COLOR_FORMAT, 4);
    nvglSetData        (nvFifo, nvFreeCount,              dwDstColorFormat);
    nvglSetData        (nvFifo, nvFreeCount,              ((dwDstBPP << dwDstLogU) << 16) |
                                                           (dwDstBPP << dwDstLogU));  // not used
    nvglSetData        (nvFifo, nvFreeCount,              dwDstSwizzleOffset);  // not used
    nvglSetData        (nvFifo, nvFreeCount,              dwDstSwizzleOffset);

    // source parameters
    dwCount = sizeSetObject + sizeSetIndexedImageContextDmaLUT + sizeSetIndexedImageLUTOffset;
    while (nvFreeCount < dwCount)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, dwCount);
    nvglSetObject (nvFifo,nvFreeCount,NV_DD_SPARE, D3D_INDEXED_IMAGE_FROM_CPU);
    nvglSetIndexedImageContextDmaLUT(nvFifo, nvFreeCount, NV_DD_SPARE,
                                     NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
    nvglSetIndexedImageLUTOffset(nvFifo,nvFreeCount,NV_DD_SPARE, dwLUTOffset);

    //
    // now iterate as many times as necessary to feed the whole thing into the buffer
    //
    x0 = y0 = 0;

    while (dwScanLinesLeftToWrite > 0) {

        dwScanLinesToWrite = (dwScanLinesLeftToWrite > dwMaxScanLinesPerIteration) ?
            dwMaxScanLinesPerIteration : dwScanLinesLeftToWrite;

        // set point and image sizes
        dwCount = sizeSetIndexedImagePoint + sizeSetIndexedImageSizes;
        while (nvFreeCount < dwCount)
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, dwCount);
        nvglSetIndexedImagePoint(nvFifo,nvFreeCount,NV_DD_SPARE, x0,y0);
        nvglSetIndexedImageSizes(nvFifo,nvFreeCount,NV_DD_SPARE,
                                 dwWidth, dwScanLinesToWrite,
                                 dwWidth, dwScanLinesToWrite);

        // put the indices into the push buffer
        assert((dwScanLinesToWrite*dwWidth & 0x3) == 0);
        dwSrcSizeWords = (dwScanLinesToWrite*dwWidth) >> 2;
        while (nvFreeCount < (1+dwSrcSizeWords))
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (1+dwSrcSizeWords));
        nvglSetIndexedImageIndices(nvFifo,nvFreeCount,NV_DD_SPARE,
                                   dwSrcSizeWords, (DWORD *)dwSrcImageAddr);

        // increment / decrement counters and pointers
        y0 += dwScanLinesToWrite;
        dwScanLinesLeftToWrite -= dwScanLinesToWrite;
        (DWORD *)dwSrcImageAddr += dwSrcSizeWords;
    }

    pDriverData->dDrawSpareSubchannelObject = D3D_INDEXED_IMAGE_FROM_CPU;
}

// munge the palette from Microsoft form into X8R8G8B8 form
// and move it into video memory where the HW can use it

BOOL nvPreparePalette(PNVD3DTEXTURE pSrcTexture)
{
    LPPALETTEENTRY pPaletteSrc;
    DWORD pPaletteDst, dwCount;

    // make sure we have a palette
    if ((!pSrcTexture) ||
        (!pSrcTexture->lpLcl) ||
        (!pSrcTexture->lpLcl->lpDDPalette) ||
        (!pSrcTexture->lpLcl->lpDDPalette->lpLcl) ||
        (!pSrcTexture->lpLcl->lpDDPalette->lpLcl->lpGbl) ||
        (!pSrcTexture->lpLcl->lpDDPalette->lpLcl->lpGbl->lpColorTable)) {
        dbgD3DError();
        return FALSE;
    }

    pPaletteSrc = pSrcTexture->lpLcl->lpDDPalette->lpLcl->lpGbl->lpColorTable;
    pPaletteDst = pCurrentContext->dwTexturePaletteAddr;

    // feed the palette through the push buffer via
    // an NV04_IMAGE_FROM_CPU object so as to keep palettes
    // synchronized with the textures that use them.

    // set up the destination surface
    dwCount = sizeSetObject + sizeSetStartMethod + 4*sizeSetData;
    while (nvFreeCount < dwCount)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, dwCount);
    nvglSetObject      (nvFifo, nvFreeCount, NV_DD_SPARE, NV_DD_SURFACES_2D);
    nvglSetStartMethod (nvFifo, nvFreeCount, NV_DD_SPARE, NV042_SET_COLOR_FORMAT, 4);
    nvglSetData        (nvFifo, nvFreeCount,              NV042_SET_COLOR_FORMAT_LE_A8R8G8B8);
    nvglSetData        (nvFifo, nvFreeCount,              ((256*4) << 16) |
                                                           (256*4));        // not used
    nvglSetData        (nvFifo, nvFreeCount,              pPaletteDst);     // not used
    nvglSetData        (nvFifo, nvFreeCount,              pPaletteDst);

    // set image_from_cpu object and feed the palette into the push buffer
    dwCount = sizeSetObject + sizeSetStartMethod + 3*sizeSetData;
    while (nvFreeCount < dwCount)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, dwCount);
    nvglSetObject      (nvFifo, nvFreeCount, NV_DD_SPARE, D3D_IMAGE_FROM_CPU);
    nvglSetStartMethod (nvFifo, nvFreeCount, NV_DD_SPARE, NV061_POINT, 3);
    nvglSetData        (nvFifo, nvFreeCount, 0);                  // point
    nvglSetData        (nvFifo, nvFreeCount, (0x1<<16) | 0x100);  // sizeout = 1H x 256W
    nvglSetData        (nvFifo, nvFreeCount, (0x1<<16) | 0x100);  // sizein = sizeout

    dwCount = sizeSetStartMethod + 256;
    while (nvFreeCount < dwCount)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, dwCount);
    nvglSetStartMethod (nvFifo, nvFreeCount, NV_DD_SPARE, NV061_COLOR(0), 256);

    for (dwCount=0; dwCount<256; dwCount++) {
        *(DWORD *)nvFifo = (((DWORD)(0xff000000))                |  // A
                            ((DWORD)(pPaletteSrc->peRed) << 16)  |  // R
                            ((DWORD)(pPaletteSrc->peGreen) << 8) |  // G
                            ((DWORD)(pPaletteSrc->peBlue) << 0));   // B
        (DWORD *)pPaletteSrc += 1;
        (DWORD *)nvFifo += 1;
    }
    nvFreeCount -= 256;

    //NV_D3D_GLOBAL_SAVE();
    //nvFlushDmaBuffers();

    return TRUE;
}

#endif  // HW_PAL8

/*
 * exported
 * --------
 */

/*
 * nvSwizzleBlt
 *
 * performs swizzle or deswizzle in the most optimal fashion depending
 * on surface location and specified flags
 *
 * if pTexture != NULL we will block CPU before writing (if needed)
 * & also update retirement date for proper syncronization.
 */
BOOL nvSwizzleBlt
(
    DWORD         dwSrcAddr,
    DWORD         dwSrcAlloc,
    DWORD         dwSrcLogW,
    DWORD         dwSrcLogH,
    DWORD         dwSrcX0,
    DWORD         dwSrcY0,
    DWORD         dwSrcX1,
    DWORD         dwSrcY1,
    DWORD         dwSrcPitch,
    PNVD3DTEXTURE pSrcTexture,

    DWORD         dwDestAddr,
    DWORD         dwDestAlloc,
    DWORD         dwDestLogW,
    DWORD         dwDestLogH,
    DWORD         dwDestX,
    DWORD         dwDestY,
    DWORD         dwDestPitch,
    PNVD3DTEXTURE pDestTexture,

    DWORD         dwBPP,
    DWORD         dwFlags
)
{
    /*
     * prepare common variables
     */
    DWORD dwW         = dwSrcX1 - dwSrcX0;
    DWORD dwH         = dwSrcY1 - dwSrcY0;
    BOOL  bWholeSrc   = ((1U << dwSrcLogW)  == dwW) && ((1U << dwSrcLogH)  == dwH);
    BOOL  bWholeDest  = ((1U << dwDestLogW) == dwW) && ((1U << dwDestLogH) == dwH);
    BOOL  bFullTex    = bWholeSrc && bWholeDest && (dwSrcLogW == dwDestLogW) && (dwSrcLogH == dwDestLogH);
    DWORD dwMemory;

    /*
     * sanity check
     */
    if (!dwH || !dwW || !dwSrcAddr || !dwDestAddr) return FALSE;

    /*
     * can we perform this operation using HW?
     */
    if (dwFlags & NV_SWIZFLAG_ALLOWHW)
    {
        /*
         * break into different swizzle cases
         */
        switch (dwFlags & (NV_SWIZFLAG_SRCSWIZZLED | NV_SWIZFLAG_DESTSWIZZLED))
        {
            case NV_SWIZFLAG_DESTSWIZZLED:  // lin -> swz
            {
                /*
                 * is the source and dest in HW reachable locations?
                 */
                if ((dwSrcAlloc & (NV4_TEXLOC_AGP | NV4_TEXLOC_VID | NV4_TEXLOC_PCI))
                 && (dwDestAlloc & NV4_TEXLOC_VID)
                 && pSrcTexture
                 && pDestTexture)
                {
                    DWORD dwIndex = TEX_SWIZZLE_INDEX(pDestTexture->dwTextureFlags);
                    DWORD dwImageColorFormat;
                    DWORD dwSurfaceColorFormat;

                    /*
                     * program HW
                     */
#ifdef HW_PAL8
                    if (dwFlags & NV_SWIZFLAG_PALETTIZED)
                    {
                        // setup
                        switch (pDestTexture->dwTextureColorFormat) {
                            case NV054_FORMAT_COLOR_LE_X1R5G5B5:
                            case NV054_FORMAT_COLOR_LE_R5G6B5:
                            case NV054_FORMAT_COLOR_LE_A1R5G5B5:
                            case NV054_FORMAT_COLOR_LE_A4R4G4B4:
                                dwSurfaceColorFormat = NV042_SET_COLOR_FORMAT_LE_R5G6B5;
                                break;
                            case NV054_FORMAT_COLOR_LE_X8R8G8B8:
                            case NV054_FORMAT_COLOR_LE_A8R8G8B8:
                                dwSurfaceColorFormat = NV042_SET_COLOR_FORMAT_LE_A8R8G8B8;
                                break;
                        }

                        // prepare the palette
                        if (!nvPreparePalette(pSrcTexture)) return FALSE;

                        // swizzle the palettized texture
                        nvSwizzleBlt(dwSrcAddr, dwSrcAlloc,
                                     dwSrcLogW, dwSrcLogH,
                                     dwSrcX0, dwSrcY0,
                                     dwSrcX1, dwSrcY1,
                                     dwW,   // pitch == width for 8 bpp
                                     pSrcTexture,
                                     dwDestAddr, dwDestAlloc,
                                     dwDestLogW, dwDestLogH,
                                     dwDestX, dwDestY,
                                     dwW,   // pitch == width for 8 bpp
                                     pDestTexture,
                                     1,     // 1 BPP
                                     dwFlags & ~(NV_SWIZFLAG_PALETTIZED |
                                                 NV_SWIZFLAG_ALLOWHW));

                        // de-palettize the texture
                        nvHWSwizzleBltPal8 (pCurrentContext->dwTexturePaletteOffset,
                                            pSrcTexture->dwLinearAddr,
                                            pDestTexture->dwSwizzleOffset,
                                            pDestTexture->dwMipMapBaseU,
                                            pDestTexture->dwMipMapBaseV,
                                            dwSurfaceColorFormat,
                                            pDestTexture->dwBPP,
                                            dwW,dwH);
                    }
                    else
#endif  // HW_PAL8
                    {
                        /*
                         * prepare for blt
                         */
                        switch (pDestTexture->dwTextureColorFormat) {
                            case NV054_FORMAT_COLOR_LE_X1R5G5B5:
                            case NV054_FORMAT_COLOR_LE_R5G6B5:
                            case NV054_FORMAT_COLOR_LE_A1R5G5B5:
                            case NV054_FORMAT_COLOR_LE_A4R4G4B4:
                                dwImageColorFormat   = NV077_SET_COLOR_FORMAT_LE_R5G6B5;
#ifdef DIRECTSWIZZLE
                                dwSurfaceColorFormat = NV042_SET_COLOR_FORMAT_LE_R5G6B5;
#else
                                dwSurfaceColorFormat = NV052_SET_FORMAT_COLOR_LE_R5G6B5;
#endif
                                break;
                            case NV054_FORMAT_COLOR_LE_X8R8G8B8:
                            case NV054_FORMAT_COLOR_LE_A8R8G8B8:
                                dwImageColorFormat   = NV077_SET_COLOR_FORMAT_LE_A8R8G8B8;
#ifdef DIRECTSWIZZLE
                                dwSurfaceColorFormat = NV042_SET_COLOR_FORMAT_LE_A8R8G8B8;
#else
                                dwSurfaceColorFormat = NV052_SET_FORMAT_COLOR_LE_A8R8G8B8;
#endif
                                break;
                        }

                        nvHWSwizzleBlt (pSrcTexture->dwLinearOffset,
                                        pSrcTexture->dwPitch,
                                        dwImageColorFormat,
                                        dwSrcX0,dwSrcY0,
                                        dwSrcAlloc,
                                        pDestTexture->dwSwizzleOffset[dwIndex],
                                        pDestTexture->dwMipMapBaseU,pDestTexture->dwMipMapBaseV,
                                        dwSurfaceColorFormat,
                                        dwDestX,dwDestY,
                                        dwW,dwH
#ifdef DIRECTSWIZZLE
                                        ,pDestTexture->dwBPP
#endif
                                        );
#if 0
NV_D3D_GLOBAL_SAVE();
nvFlushDmaBuffers();
NV_D3D_GLOBAL_SETUP();
#endif
                    }

                    /*
                     * block other processes from reading or writing until we have finished
                     */
                    pDestTexture->dwRetireDate[dwIndex] = global.dwSWTextureDate;
                    nvTextureSetBlockPoint();

                    /*
                     * done
                     */
                    return TRUE;
                }
            }
        }
    }

    /*
     * quicky memory configuration bit field
     *  1 == src  is uncached,
     *  2 == dest is uncached
     */
    dwMemory    = ((dwSrcAlloc  & (NV4_TEXLOC_AGP | NV4_TEXLOC_VID)) ? 1 : 0)
                | ((dwDestAlloc & (NV4_TEXLOC_AGP | NV4_TEXLOC_VID)) ? 2 : 0);

    /*
     * CPU has to do the work...
     *
     * sync HW & CPU for the given textures
     */
#ifdef NV_PROFILE // remove texture wait from these timings
    NVP_STOP (NVP_T_TEXSWBLT);
    NVP_STOP (NVP_T_TEXHWBLT);
    //NVP_START (NVP_X_FLOAT0);
#endif
    if (pSrcTexture)  nvTextureBlock (pSrcTexture ->dwRetireDate[(dwFlags & NV_SWIZFLAG_SRCSWIZZLED)  ? (TEX_SWIZZLE_INDEX(pSrcTexture-> dwTextureFlags)) : NV4_TEXCOUNT_SWIZZLE]);
    if (pDestTexture) nvTextureBlock (pDestTexture->dwRetireDate[(dwFlags & NV_SWIZFLAG_DESTSWIZZLED) ? (TEX_SWIZZLE_INDEX(pDestTexture->dwTextureFlags)) : NV4_TEXCOUNT_SWIZZLE]);
#ifdef NV_PROFILE
    //NVP_STOP (NVP_X_FLOAT0);
    //nvpLogTime (NVP_X_FLOAT0,nvpTime[NVP_X_FLOAT0]);
    NVP_RESTART (NVP_T_TEXSWBLT);
    NVP_RESTART (NVP_T_TEXHWBLT);
#endif

    /*
     * break into different swizzle cases
     */
    switch (dwFlags & (NV_SWIZFLAG_SRCSWIZZLED | NV_SWIZFLAG_DESTSWIZZLED))
    {
        case 0:                         // lin -> lin
        {
            DWORD dwSubHeight = 4096 / (dwW * dwBPP);
            if (!dwSubHeight) dwSubHeight = 1;
                         else dwSubHeight = min(dwSubHeight,dwH);

            //OutputDebugString ("nvSwizzleBlt_LL_ST_RW\n");
            nvSwizzleBlt_LL_ST_RW (dwSrcAddr + dwSrcY0 * dwSrcPitch + dwSrcX0 * dwBPP,
                                   dwSrcPitch,
                                   dwDestAddr + dwDestY * dwDestPitch + dwDestX * dwBPP,
                                   dwDestPitch,
                                   dwW,dwH,dwSubHeight,dwBPP);
            break;
        }
        case NV_SWIZFLAG_SRCSWIZZLED:   // swz -> lin
        {
            if (/*!bFullTex*/1) // txtodo - fast fulltexture deswizzle needed
            {
                DWORD dwSrcOffset;
                DWORD dwSrcDUDXor;
                DWORD dwSrcDUDXand;
                DWORD dwSrcDVDYor;
                DWORD dwSrcDVDYand;

                DWORD dwSubHeight = 4096 / (dwW * dwBPP);
                if (!dwSubHeight) dwSubHeight = 1;
                             else dwSubHeight = min(dwSubHeight,dwH);

                nvSwizzleCalcSwizzleInfo (dwSrcX0,dwSrcY0,dwSrcLogW,dwSrcLogH,dwBPP,
                                          &dwSrcOffset,
                                          &dwSrcDUDXor,&dwSrcDUDXand,
                                          &dwSrcDVDYor,&dwSrcDVDYand);

                //OutputDebugString ("nvSwizzleBlt_SL_ST_LW\n");
                nvSwizzleBlt_SL_ST_LW (dwSrcAddr,dwSrcOffset,
                                       dwSrcDUDXor,dwSrcDUDXand,
                                       dwSrcDVDYor,dwSrcDVDYand,
                                       dwDestAddr + dwDestY * dwDestPitch + dwDestX * dwBPP,
                                       dwDestPitch,
                                       dwW,dwH,dwSubHeight,dwBPP);
            }
            else
            {
            }
        }
        case NV_SWIZFLAG_DESTSWIZZLED:  // lin -> swz
        {
            if (!bFullTex)
            {
                DWORD dwDestOffset;
                DWORD dwDestDUDXor;
                DWORD dwDestDUDXand;
                DWORD dwDestDVDYor;
                DWORD dwDestDVDYand;

                DWORD dwSubHeight = 4096 / (dwW * dwBPP);
                if (!dwSubHeight) dwSubHeight = 1;
                             else dwSubHeight = min(dwSubHeight,dwH);

                nvSwizzleCalcSwizzleInfo (dwDestX,dwDestY,dwDestLogW,dwDestLogH,dwBPP,
                                          &dwDestOffset,
                                          &dwDestDUDXor,&dwDestDUDXand,
                                          &dwDestDVDYor,&dwDestDVDYand);

                //OutputDebugString ("nvSwizzleBlt_LS_ST_LR\n");
                nvSwizzleBlt_LS_ST_LR (dwSrcAddr + dwSrcY0 * dwSrcPitch + dwSrcX0 * dwBPP,
                                       dwSrcPitch,
                                       dwDestAddr,dwDestOffset,
                                       dwDestDUDXor,dwDestDUDXand,
                                       dwDestDVDYor,dwDestDVDYand,
                                       dwW,dwH,dwSubHeight,dwBPP);
            }
            else
            {
#ifdef HW_PAL8
                if (pDestTexture->dwTextureFlags & NV4_TEXFLAG_PALETTIZED)
                {
                    LPPALETTEENTRY pPalette;
                    DWORD          i;

                    nvTextureBase_meta = dwDestAddr;

                    if (pDestTexture->lpLcl->lpDDPalette)
                    {
                        pPalette = pDestTexture->lpLcl->lpDDPalette->lpLcl->lpGbl->lpColorTable;
                        for (i=0; i<256; i++)
                        {
                            extern WORD nvPalette[256];

                            nvPalette[i] = ((WORD)(pPalette[i].peRed   & 0xF8) << 8)
                                         | ((WORD)(pPalette[i].peGreen & 0xFC) << 3)
                                         | ((WORD)(pPalette[i].peBlue  & 0xF8) >> 3);
                        }
                    }
                    else
                    {
                        // no palette - what now?
                        // we just do the work anyway withou the correct palette
                    }

                    nvSwizzleBlt_LS_FT (dwSrcAddr,dwSrcPitch,
                                        dwDestAddr,
                                        dwSrcLogW,dwSrcLogH,1);
                }
                else
                {
                    nvTextureBase_meta = 0;
                    nvSwizzleBlt_LS_FT (dwSrcAddr,dwSrcPitch,
                                        dwDestAddr,
                                        dwSrcLogW,dwSrcLogH,dwBPP);
                }
#else
                nvSwizzleBlt_LS_FT (dwSrcAddr,dwSrcPitch,
                                    dwDestAddr,
                                    dwSrcLogW,dwSrcLogH,dwBPP);
#endif
            }
            break;
        }
        case NV_SWIZFLAG_SRCSWIZZLED | NV_SWIZFLAG_DESTSWIZZLED: // swz -> swz
        {
            if (!bFullTex)
            {
                DWORD dwSrcOffset;
                DWORD dwSrcDUDXor;
                DWORD dwSrcDUDXand;
                DWORD dwSrcDVDYor;
                DWORD dwSrcDVDYand;

                DWORD dwDestOffset;
                DWORD dwDestDUDXor;
                DWORD dwDestDUDXand;
                DWORD dwDestDVDYor;
                DWORD dwDestDVDYand;

                DWORD dwSubHeight = 4096 / (dwW * dwBPP);
                if (!dwSubHeight) dwSubHeight = 1;
                             else dwSubHeight = min(dwSubHeight,dwH);

                nvSwizzleCalcSwizzleInfo (dwSrcX0,dwSrcY0,dwSrcLogW,dwSrcLogH,dwBPP,
                                          &dwSrcOffset,
                                          &dwSrcDUDXor,&dwSrcDUDXand,
                                          &dwSrcDVDYor,&dwSrcDVDYand);

                nvSwizzleCalcSwizzleInfo (dwDestX,dwDestY,dwDestLogW,dwDestLogH,dwBPP,
                                          &dwDestOffset,
                                          &dwDestDUDXor,&dwDestDUDXand,
                                          &dwDestDVDYor,&dwDestDVDYand);

                //OutputDebugString ("nvSwizzleBlt_SS_ST_XX\n");
                nvSwizzleBlt_SS_ST_XX (dwSrcAddr,dwSrcOffset,
                                       dwSrcDUDXor,dwSrcDUDXand,
                                       dwSrcDVDYor,dwSrcDVDYand,
                                       dwDestAddr,dwDestOffset,
                                       dwDestDUDXor,dwDestDUDXand,
                                       dwDestDVDYor,dwDestDVDYand,
                                       dwW,dwH,dwSubHeight,dwBPP);
            }
            else
            {
                DWORD dwSubHeight = 4096 / (dwBPP << dwSrcLogW);
                if (!dwSubHeight) dwSubHeight = 1;
                             else dwSubHeight = min(dwSubHeight,(DWORD)(1 << dwSrcLogH));

                //OutputDebugString ("nvSwizzleBlt_SS_XX_RW\n");
                nvSwizzleBlt_SS_XX_RW (dwSrcAddr,
                                       dwDestAddr,
                                       1 << dwSrcLogW,1 << dwSrcLogH,dwSubHeight,dwBPP);
            }
            break;
        }
    }

#if 0
    /*
     * fill dest with solid color
     */
    {
        DWORD dl = dwDestAddr;
        DWORD x,y;

        for (y=0; y<dwH; y++)
        {
            DWORD da = dl;

            for (x=0; x<dwW; x++)
            {
                *(WORD*)da = 0xaa55;
                da += 2;
            }

            dl += dwDestPitch;
        }
    }
#endif

#if 0
    /*
     * show what we have done
     */
    /*if (dwFlags & NV_SWIZFLAG_DESTSWIZZLED)*/ {
        DWORD sl = dwSrcAddr;
        DWORD dl = dwDestAddr;
        DWORD vl = pDriverData->CurrentVisibleSurfaceAddress;

        DWORD x,y;

        for (y=0; y<dwH; y++)
        {
            DWORD sa = sl;
            DWORD da = dl;
            DWORD va = vl;

            for (x=0; x<dwW; x++)
            {
                *(WORD*)va            = *(WORD*)sa;
                *(WORD*)(va + dwW* 2) = *(WORD*)da;

                sa += 2;
                da += 2;
                va += 2;
            }

            sl += dwSrcPitch;
            dl += dwDestPitch;
            vl += 1024 * 2;
        }

        DPF("nvSwizzleBlt - dwFlags    = %08x",dwFlags);
        DPF("               dwSrcAddr  = %08x",dwSrcAddr);
        DPF("               dwDestAddr = %08x",dwDestAddr);
        DPF("               dwW        = %d",dwW);
        DPF("               dwH        = %d",dwH);
        __asm int 3;
    }
#endif

    /*
     * done
     */
    return TRUE;
}

#endif //NV_TEX2
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4scene.c ===
#ifdef  NV4
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4SCENE.C                                                        *
*   The direct 3d HAL scene capture routines is implemented in this module. *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       03/24/97 - wrote and cleaned up.        *
*                                                                           *
\***************************************************************************/
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "d3dinc.h"
#include "nv4dmac.h"
#include "nv4dreg.h"
#include "nv3ddbg.h"
#include "nv4vxmac.h"

#ifdef NV_MARKER
DWORD dwMarkerCount = 0;
#endif

#ifdef NV_STATS
DWORD dwSceneCount;
DWORD dwSceneTime;
DWORD dwDP2CallCount;
DWORD dwPrimCount;
DWORD dwPrimLegacyCount;
DWORD dwPrimListCount;
DWORD dwPrimStripCount;
DWORD dwPrimFanCount;
DWORD dwHWPCount;
#endif

/*
 * Scene Capture start and end points
 */
DWORD __stdcall nvSceneCapture
(
    LPD3DHAL_SCENECAPTUREDATA   pscd
)
{
    NvNotification *pPusherSyncNotifier;

    /*
     * Get the pointer to the context.
     */
    pCurrentContext = (PNVD3DCONTEXT)pscd->dwhContext;
    if (!pCurrentContext)
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvSceneCapture: - Bad Context");
        pscd->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Get pointer to global driver. data structure.
     */
    NvSetDriverDataPtrFromContext(pCurrentContext);

    /*
     * Need to make sure that an unfriendly mode switch didn't sneak and not cause
     * us to get re-enabled properly.
     */
    if (pDriverData->fFullScreenDosOccurred)
    {
        if (pDriverData->fFullScreenDosOccurred & 0x01)
            nvD3DReenable();
        else
        {
            pscd->ddrval = DD_OK;
            return (DDHAL_DRIVER_HANDLED);
        }
    }

    /*
     * Setup frequently accessed globals.
     */
    NV_D3D_GLOBAL_SETUP();

    pPusherSyncNotifier = (NvNotification *)pDriverData->NvDmaPusherSyncNotifierFlat;
    switch (pscd->dwFlag)
    {
//////////////////////////////////////////////////////////////////////////////
        case D3DHAL_SCENE_CAPTURE_START:
#ifdef NV_PROFILE
            /*
             * Scene Timer Start & log
             */
            //nvpLogEvent (NVP_T_CLOCK);
            nvpLogEvent (NVP_E_BEGINSCENE);
            NVP_START(NVP_T_SCENE);
#endif
#ifdef NV_MARKER
            if (1)
            {
                extern DWORD dwMarkerCount;
                dwMarkerCount ++;
                *(DWORD*)(pDriverData->BaseAddress) = (dwMarkerCount << 16) | dwMarkerCount;
            }
            else
                *(DWORD*)(pDriverData->BaseAddress) = 0xaaaaaaaa;
#endif
#ifdef NV_STATS
            dwSceneTime       = (DWORD)-(int)GetTickCount();
            dwDP2CallCount    = 0;
            dwPrimCount       = 0;
            dwPrimLegacyCount = 0;
            dwPrimListCount   = 0;
            dwPrimStripCount  = 0;
            dwPrimFanCount    = 0;
            dwHWPCount        = 0;
#endif

            DPF_LEVEL(NVDBG_LEVEL_DDI_ENTRY, "nvSceneCapture - Begin Scene");

            /*
             * bump # of frames render
             */
            pCurrentContext->dwSceneCount ++;
            pCurrentContext->dwMipMapsInThisScene = 0;

            /*
             * Make sure the context has the correct suface information in it.
             */
            if (dbgFrontRender)
            {
                pCurrentContext->dwSurfaceAddr            = pDriverData->CurrentVisibleSurfaceAddress;
                pCurrentContext->dwSurfaceOffset          = VIDMEM_OFFSET(pDriverData->CurrentVisibleSurfaceAddress);
                pCurrentContext->surfacePitch.wColorPitch = (WORD)dbgFrontRenderPitch;
                pDriverData->lpLast3DSurfaceRendered      = 0;
            }
            else
            {
                pCurrentContext->dwSurfaceAddr            = VIDMEM_ADDR(pCurrentContext->lpLcl->lpGbl->fpVidMem);
                pCurrentContext->dwSurfaceOffset          = VIDMEM_OFFSET(pCurrentContext->lpLcl->lpGbl->fpVidMem);
                pCurrentContext->surfacePitch.wColorPitch = (WORD)pCurrentContext->lpLcl->lpGbl->lPitch;
            }
            if (pCurrentContext->lpLclZ)
            {
                /*
                 * I've seen it happen where the location of the z-buffer will actually
                 * change without without the context being destroyed or the set render
                 * target call happening. So it's neccessary to make sure that we have the
                 * correct z-buffer address and offset here.
                 */
                pCurrentContext->ZBufferAddr             = VIDMEM_ADDR(pCurrentContext->lpLclZ->lpGbl->fpVidMem);
                pCurrentContext->ZBufferOffset           = VIDMEM_OFFSET(pCurrentContext->lpLclZ->lpGbl->fpVidMem);
                pCurrentContext->surfacePitch.wZetaPitch = (WORD)pCurrentContext->lpLclZ->lpGbl->lPitch;
            }

            /*
             * anti-aliasing semantics check
             */
            pCurrentContext->dwAntiAliasFlags |= AA_IN_SCENE;
            NV_AA_SEMANTICS_SETUP (pCurrentContext);

            /*
             * Get the current freecount and try kicking off any outstanding data in the buffer
             * if the hardware is idle.
             */
            nvglIdleKickoff(sizeSetHeaderDmaPush);
            break;

//////////////////////////////////////////////////////////////////////////////
        case D3DHAL_SCENE_CAPTURE_END:
//            if ((!(pCurrentContext->lpLcl->dwReserved1 & NV_D3D_HAS_FLIPPED))
//             && (!nvglDmaFifoIdle()))
//            {
//                NV_D3D_GLOBAL_SAVE();
//                pscd->ddrval = DD_OK;
//                return (DDHAL_DRIVER_HANDLED);
//            }

            DPF_LEVEL(NVDBG_LEVEL_DDI_ENTRY, "nvSceneCapture - End Scene");

            /*
             * Anti-Alias post processing
             */
            if (pCurrentContext->dwAntiAliasFlags & AA_ENABLED_MASK)
            {
                /*
                 * AA will use the push buffer. Get proper freecount here.
                 */
#ifdef  CACHE_FREECOUNT
                nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#else   // CACHE_FREECOUNT
                nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetRenderTargetContexts + sizeSetRenderTarget));
#endif  // CACHE_FREECOUNT

                /*
                 * aa post-processing
                 */
                nvAARenderPrimitive();
            }

            /*
             * aa - check for bad semantics
             */
            if ((pCurrentContext->dwAntiAliasFlags & AA_MIX_MASK) == AA_MIX_MASK)
            {
                DPF_LEVEL(NVDBG_LEVEL_AA_INFO,"    Invalid Semantics Tagged");
                pCurrentContext->dwAntiAliasFlags &= ~AA_ENABLED_MASK;
                pCurrentContext->dwAntiAliasFlags |=  AA_INVALID_SEMANTICS;
                NV_FORCE_TRI_SETUP(pCurrentContext);
                NV_D3D_GLOBAL_SAVE();
                nvFlushDmaBuffers();
                NV_D3D_GLOBAL_SETUP();
                pDriverData->lpLast3DSurfaceRendered = 0;
                nvSetD3DSurfaceState (pCurrentContext);
            }

            pCurrentContext->dwAntiAliasFlags &= ~AA_IN_SCENE;

#ifdef NV_TEX2
            /*
             * set block point for textures
             */
            nvTextureSetBlockPoint();
#endif // NV_TEX2

            /*
             * Start pushing buffer.
             */
            nvStartDmaBuffer (FALSE);

#ifdef NV_STATS
            dwSceneTime  += GetTickCount();
            dwSceneCount ++;
            {
                char sz[512];
                wsprintf (sz,"Scene %d ********************************************\n",dwSceneCount);
                OutputDebugString (sz);
                wsprintf (sz,"Scene Time                = %dms\n",dwSceneTime);
                OutputDebugString (sz);
                wsprintf (sz,"DP2 Call Count            = %d\n",dwDP2CallCount);
                OutputDebugString (sz);
                wsprintf (sz,"Primitive Count           = %d\n",dwPrimCount);
                OutputDebugString (sz);
                wsprintf (sz,"Primitive Legacy Count    = %d\n",dwPrimLegacyCount);
                OutputDebugString (sz);
                wsprintf (sz,"Primitive List Count      = %d\n",dwPrimListCount);
                OutputDebugString (sz);
                wsprintf (sz,"Primitive Strip Count     = %d\n",dwPrimStripCount);
                OutputDebugString (sz);
                wsprintf (sz,"Primitive Fan Count       = %d\n",dwPrimFanCount);
                OutputDebugString (sz);
                wsprintf (sz,"HW Program Count          = %d\n",dwHWPCount);
                OutputDebugString (sz);
                if (dwSceneTime)
                {
                    wsprintf (sz,"Primitives/second  = %d\n",(dwPrimCount*1000)/dwSceneTime);
                    OutputDebugString (sz);
                }
            }
#endif
#ifdef NV_MARKER
            *(DWORD*)(pDriverData->BaseAddress) = 0xbbbbbbbb;
#endif
#ifdef NV_PROFILE
            /*
             * Scene Timer Stop and log
             */
            NVP_STOP(NVP_T_SCENE);
            nvpLogTime (NVP_T_SCENE,nvpTime[NVP_T_SCENE]);
#endif
            break;
        default:
            break;
    }
    /*
     * Return driver not handled since we want D3D to call our RenderPrimitive
     * routine.
     */
    NV_D3D_GLOBAL_SAVE();
    pscd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}
#endif  // NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4state.c ===
#ifdef  NV4
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4STATE.C                                                        *
*   NV4 state management routines.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman               04/18/98 - NV4 development.             *
*                                                                           *
\***************************************************************************/
#include <math.h>
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3d.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv4dblnd.h"
#include "nv3ddbg.h"
#include "nv4vxmac.h"
#include "nv4dreg.h"

#ifdef NV_CONTROLTRAFFIC
DWORD dwCTTable[] =
{
    0,
    D3DCMP_NEVER,
    D3DCMP_GREATER,
    D3DCMP_EQUAL,
    D3DCMP_GREATEREQUAL,
    D3DCMP_LESS,
    D3DCMP_NOTEQUAL,
    D3DCMP_LESSEQUAL,
    D3DCMP_ALWAYS,
};

__inline DWORD CTFunc
(
    DWORD dw
)
{
    if ((pCurrentContext->dwCTFlags & (NV_CT_ENABLED | NV_CT_FRONT)) == NV_CT_ENABLED)
    {
        return dwCTTable[dw];
    }
    else
    {
        return dw;
    }
}

#endif //NV_CONTROLTRAFFIC

/*
 * Send suface setup to the hardware.
 */
void nvSetD3DSurfaceState
(
    PNVD3DCONTEXT   pContext
)
{
    /*
     * Only need to update the surface if it has changed since the last render call
     * or the global clip state has changed.
     */
    if ((pDriverData->lpLast3DSurfaceRendered != pContext->lpLcl->lpGbl->fpVidMem)
     || (pDriverData->TwoDRenderingOccurred))
    {
        /*
         * Make sure the context has the correct suface information in it.
         */
        if (dbgFrontRender)
        {
            pContext->dwSurfaceAddr            = pDriverData->CurrentVisibleSurfaceAddress;
            pContext->dwSurfaceOffset          = VIDMEM_OFFSET(pDriverData->CurrentVisibleSurfaceAddress);
            pContext->surfacePitch.wColorPitch = (WORD)dbgFrontRenderPitch;
        }
        else
        {
            pContext->dwSurfaceAddr            = VIDMEM_ADDR(pContext->lpLcl->lpGbl->fpVidMem);
            pContext->dwSurfaceOffset          = VIDMEM_OFFSET(pContext->lpLcl->lpGbl->fpVidMem);
            pContext->surfacePitch.wColorPitch = (WORD)pContext->lpLcl->lpGbl->lPitch;
        }
        if (pContext->lpLclZ)
        {
            /*
             * I've seen it happen where the location of the z-buffer will actually
             * change without without the context being destroyed or the set render
             * target call happening. So it's neccessary to make sure that we have the
             * correct z-buffer address and offset here.
             */
            pContext->ZBufferAddr             = VIDMEM_ADDR(pContext->lpLclZ->lpGbl->fpVidMem);
            pContext->ZBufferOffset           = VIDMEM_OFFSET(pContext->lpLclZ->lpGbl->fpVidMem);
            pContext->surfacePitch.wZetaPitch = (WORD)pContext->lpLclZ->lpGbl->lPitch;
        }
        /*
         * Send to hardware
         */
        while (nvFreeCount < (sizeSetObject + sizeSetRenderTargetContexts))
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SURFACES, (sizeSetObject + sizeSetRenderTargetContexts));
        nvglSetObject(nvFifo, nvFreeCount, NV_DD_SURFACES, D3D_CONTEXT_SURFACES_ARGB_ZS);
        nvglSetRenderTargetContexts(nvFifo, nvFreeCount, NV_DD_SURFACES,
                                    NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

        /*
         * AA overrides (AA is disabled when dwAntiAliasFlags == 0)
         */
        if (pContext->dwAntiAliasFlags & AA_MODE_SINGLECHUNK)
        {
            /*
             * single chunk super sampled aa
             */
            PNVAACONTEXT pCtx = pContext->pAAContext;
            DWORD clip  = (pCtx->dwSuperHeight << 16)
                        |  pCtx->dwSuperWidth;
            DWORD pitch = (pCtx->dwSuperZPitch << 16)
                        |  pCtx->dwSuperPitch;
            while (nvFreeCount < sizeSetRenderTarget2)
                nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SURFACES, sizeSetRenderTarget2);
            nvglSetRenderTarget2(nvFifo, nvFreeCount, NV_DD_SURFACES,
                                 pContext->dwSurfaceFormat, clip,
                                 pitch,  pCtx->dwSuperOffset,
                                 pCtx->dwSuperZOffset);
        }
        else
        if (pContext->dwAntiAliasFlags & AA_RENDER)
        {
            /*
             * multi chunk super sampled aa
             */
            PNVAACONTEXT pCtx = pContext->pAAContext;
            DWORD clip  = (pCtx->dwSuperHeight << 16)
                        |  pCtx->dwSuperWidth;
            DWORD pitch = (pContext->surfacePitch.wZetaPitch << 16)
                        |  pCtx->dwSuperPitch;
            while (nvFreeCount < sizeSetRenderTarget2)
                nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SURFACES, sizeSetRenderTarget2);
            nvglSetRenderTarget2(nvFifo, nvFreeCount, NV_DD_SURFACES,
                                 pContext->dwSurfaceFormat, clip,
                                 pitch,  pCtx->dwSuperOffset,
                                 pContext->ZBufferOffset);
        }
        else
        /*
         * Normal case
         */
        {
            if (!(pContext->surfaceViewport.clipHorizontal.wX)
             && !(pContext->surfaceViewport.clipVertical.wY))
            {
                DWORD clip = (((DWORD)pContext->surfaceViewport.clipVertical.wHeight) << 16)
                           | pContext->surfaceViewport.clipHorizontal.wWidth;
                while (nvFreeCount < sizeSetRenderTarget2)
                    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SURFACES, sizeSetRenderTarget2);
                nvglSetRenderTarget2(nvFifo, nvFreeCount, NV_DD_SURFACES,
                                     pContext->dwSurfaceFormat, clip,
                                     pContext->dwSurfacePitch,  pContext->dwSurfaceOffset,
                                     pContext->ZBufferOffset);
            }
            else
            {
#if 0
                /*
                 * If this didn't cause an exception to the RM, this is how I'd program this.
                 */
                while (nvFreeCount < sizeSetRenderTarget)
                    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SURFACES, sizeSetRenderTarget);
                nvglSetRenderTarget(nvFifo, nvFreeCount, NV_DD_SURFACES,
                                    pContext->surfaceViewport.dwClipHorizontal, pContext->surfaceViewport.dwClipVertical,
                                    pContext->dwSurfaceFormat,
                                    pContext->dwSurfacePitch,  pContext->dwSurfaceOffset,
                                    pContext->ZBufferOffset);
#else
                /*
                 * Until programming the clipped viewport doesn't cause an RM exception,
                 * program it this way.
                 */
                DWORD clip = (((DWORD)pContext->surfaceViewport.clipVertical.wHeight) << 16)
                           | pContext->surfaceViewport.clipHorizontal.wWidth;
                while (nvFreeCount < (sizeSetRenderTarget2 + sizeSetObject + sizeSetClip))
                    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SURFACES, (sizeSetRenderTarget2 + sizeSetObject + sizeSetClip));
                nvglSetRenderTarget2(nvFifo, nvFreeCount, NV_DD_SURFACES,
                                     pContext->dwSurfaceFormat, clip,
                                     pContext->dwSurfacePitch,  pContext->dwSurfaceOffset,
                                     pContext->ZBufferOffset);

                /*
                 * Set the image black rectangle to the clip region.
                 */
                nvglSetObject(nvFifo, nvFreeCount, NV_DD_SURFACES, NV_DD_IMAGE_BLACK_RECTANGLE);
                nvglSetClip(nvFifo, nvFreeCount, NV_DD_SURFACES,
                            pContext->surfaceViewport.clipHorizontal.wX, pContext->surfaceViewport.clipVertical.wY,
                            pContext->surfaceViewport.clipHorizontal.wWidth, pContext->surfaceViewport.clipVertical.wHeight);
#endif
            }
        }
        while (nvFreeCount < sizeSetObject)
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SURFACES, sizeSetObject);
        nvglSetObject(nvFifo, nvFreeCount, NV_DD_SURFACES, NV_DD_SURFACES_2D);
        pDriverData->TwoDRenderingOccurred = 0;
        pDriverData->ThreeDRenderingOccurred = TRUE;
        pDriverData->dDrawSpareSubchannelObject = 0; // force a reload.
    }
    pDriverData->lpLast3DSurfaceRendered = pContext->lpLcl->lpGbl->fpVidMem;
    pDriverData->ddClipUpdate = TRUE;
    pDriverData->dwSharedClipChangeCount++;
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return;
}
void nvSetD3DSurfaceViewport
(
    PNVD3DCONTEXT   pContext
)
{
    /*
     * AA does not need to tell the HW about the viewport at this point
     *  early exit
     */
    if (pContext->dwAntiAliasFlags & (AA_MODE_SUPER | AA_MODE_SINGLECHUNK))
    {
        return;
    }

    /*
     * Send to hardware
     */
#if 0
    /*
     * If this didn't cause an exception to the RM, this is how I'd program this.
     */
    while (nvFreeCount < (sizeSetObject + sizeSetRenderTargetViewport + sizeSetObject))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SURFACES, (sizeSetObject + sizeSetRenderTargetViewport + sizeSetObject));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SURFACES, D3D_CONTEXT_SURFACES_ARGB_ZS);
    nvglSetRenderTargetViewport(nvFifo, nvFreeCount, NV_DD_SURFACES,
                                pContext->surfaceViewport.dwClipHorizontal, pContext->surfaceViewport.dwClipVertical);
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SURFACES, NV_DD_SURFACES_2D);
#else
    /*
     * Until programming the clipped viewport doesn't cause an RM exception,
     * program it this way.
     */
    while (nvFreeCount < (sizeSetObject + sizeSetClip + sizeSetObject))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SURFACES, (sizeSetObject + sizeSetClip + sizeSetObject));

    /*
     * Set the image black rectangle to the clip region.
     */
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SURFACES, NV_DD_IMAGE_BLACK_RECTANGLE);
    nvglSetClip(nvFifo, nvFreeCount, NV_DD_SURFACES,
                pContext->surfaceViewport.clipHorizontal.wX, pContext->surfaceViewport.clipVertical.wY,
                pContext->surfaceViewport.clipHorizontal.wWidth, pContext->surfaceViewport.clipVertical.wHeight);

    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SURFACES, NV_DD_SURFACES_2D);
#endif
    pDriverData->TwoDRenderingOccurred      = 0;
    pDriverData->ThreeDRenderingOccurred    = TRUE;
    pDriverData->dDrawSpareSubchannelObject = 0; // force a reload.
    pDriverData->lpLast3DSurfaceRendered    = pContext->lpLcl->lpGbl->fpVidMem;
    pDriverData->ddClipUpdate = TRUE;
    pDriverData->dwSharedClipChangeCount++;
    NV_FORCE_TRI_SETUP(pContext);
}

/*
 * Send DX5 Triangle class state to the hardware.
 */
void nvSetDx5TriangleState
(
    PNVD3DCONTEXT   pContext
)
{
    DWORD  *pTriangleState;
    DWORD  *pTriangleStateShadow;

    /*
     * Validate the inner loop hardware control registers.
     */
    dbgValidateControlRegisters(pCurrentContext);

    /*
     * AA semantics check - I hate these
     */
    if (pContext->dwAntiAliasFlags & AA_ENABLED_MASK)
        pContext->dwAntiAliasFlags |= AA_MIX_DP_NOAA;
    else
        pContext->dwAntiAliasFlags |= AA_MIX_DP_AA;

    /*
     * we do not send state when we capture geometry for super sampled AA
     */
    if (pCurrentContext->dwAntiAliasFlags & AA_MODE_SUPER)
    {
        if (!(pCurrentContext->dwAntiAliasFlags & AA_CAPTURE_PUSHBUFFER))
        {
            return;
        }
    }

#if 0
    /*
     * Send down the triangle state.
     */
    while (nvFreeCount < (sizeSetObject + sizeDx5TriangleState))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeDx5TriangleState));
    pTriangleState = (DWORD *)&pContext->ctxInnerLoop;
    /*
     * Only write channel if it is not selected - avoids texture cache invalidates
     */
    if (pDriverData->dDrawSpareSubchannelObject != D3D_DX5_TEXTURED_TRIANGLE)
    {
        nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_DX5_TEXTURED_TRIANGLE);
    }
    nvglDx5TriangleState(nvFifo, nvFreeCount, NV_DD_SPARE,
                         *(pTriangleState++), *(pTriangleState++), *(pTriangleState++),
                         *(pTriangleState++), *(pTriangleState++), *(pTriangleState++),
                         *(pTriangleState));
    pDriverData->dDrawSpareSubchannelObject = D3D_DX5_TEXTURED_TRIANGLE;
#else
    /*
     * prep variables
     */
    pTriangleState       = (DWORD*)&pContext->ctxInnerLoop;
    PREFETCH (pTriangleState);
    pTriangleStateShadow = (DWORD*)&pContext->ctxInnerLoopShadow;
    PREFETCH (pTriangleStateShadow);

    /*
     * set object if needed
     */
    if (pDriverData->dDrawSpareSubchannelObject != D3D_DX5_TEXTURED_TRIANGLE)
    {
        while (nvFreeCount < sizeSetObject)
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeSetObject);
        nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_DX5_TEXTURED_TRIANGLE);
        pDriverData->dDrawSpareSubchannelObject = D3D_DX5_TEXTURED_TRIANGLE;

        /*
         * force state load
         */
        pTriangleStateShadow[0] = ~pTriangleState[0];
        pTriangleStateShadow[1] = ~pTriangleState[1];
    }

    /*
     * wait-for-fe-idle methods
     */
    if ((pTriangleState[1] != pTriangleStateShadow[1])  // offset
     || (pTriangleState[2] != pTriangleStateShadow[2])) // format
    {
        while (nvFreeCount < (sizeSetData * 2 + sizeSetStartMethod * 1))
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetData * 2 + sizeSetStartMethod * 1));
        nvglSetStartMethod (nvFifo,nvFreeCount,NV_DD_SPARE,NV054_OFFSET,2);
        nvglSetData        (nvFifo,nvFreeCount,            pTriangleState[1]);
        pTriangleStateShadow[1] = pTriangleState[1];
        nvglSetData        (nvFifo,nvFreeCount,            pTriangleState[2]);
        pTriangleStateShadow[2] = pTriangleState[2];
    }

    /*
     * wait-for-idle methods
     */
    if ((pTriangleState[0] != pTriangleStateShadow[0])  // colorKey
     || (pTriangleState[3] != pTriangleStateShadow[3])  // filter
     || (pTriangleState[4] != pTriangleStateShadow[4])  // blend
     || (pTriangleState[5] != pTriangleStateShadow[5])  // control
     || (pTriangleState[6] != pTriangleStateShadow[6])) // fogColor
    {
        while (nvFreeCount < (sizeSetData * 5 + sizeSetStartMethod * 2))
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetData * 5 + sizeSetStartMethod * 2));
        nvglSetStartMethod (nvFifo,nvFreeCount,NV_DD_SPARE,NV054_COLOR_KEY,1);
        nvglSetData        (nvFifo,nvFreeCount,            pTriangleState[0]);
        pTriangleStateShadow[0] = pTriangleState[0];
        nvglSetStartMethod (nvFifo,nvFreeCount,NV_DD_SPARE,NV054_FILTER,4);
        nvglSetData        (nvFifo,nvFreeCount,            pTriangleState[3]);
        pTriangleStateShadow[3] = pTriangleState[3];
#ifdef  SPEC_HACK
        /*
         * Send the current blend state. This is an attempt to maximize the ability to
         * get 2 pixels per clock out of the DX5 class when specular highlighting is
         * enabled.
         */
        nvglSetData        (nvFifo,nvFreeCount,            pTriangleState[8]);
#else   // SPEC_HACK
        nvglSetData        (nvFifo,nvFreeCount,            pTriangleState[4]);
#endif
        pTriangleStateShadow[4] = pTriangleState[4];
        nvglSetData        (nvFifo,nvFreeCount,            pTriangleState[5]);
        pTriangleStateShadow[5] = pTriangleState[5];
        nvglSetData        (nvFifo,nvFreeCount,            pTriangleState[6]);
        pTriangleStateShadow[6] = pTriangleState[6];
    }
#endif

    return;
}

/*
 * Context and hardware state set routines.
 */
DWORD nvSetContextState
(
    DWORD           dwStateType,
    DWORD           dwStateValue,
    HRESULT        *pddrval
)
{
    /*
     * Make sure the state being set is within the range the driver is handling.
     */
    if (dwStateType <= D3D_RENDERSTATE_MAX)
    {
        /*
         * Only update the state if it's different.
         */
        if (pCurrentContext->dwRenderState[dwStateType] != dwStateValue)
        {
            if (dbgShowState & NVDBG_SHOW_RENDER_STATE)
            {
                DPF("nvSetContextState:Change Render State");
                DPF("State = %08ld", dwStateType);
                DPF("Data  = 0x%08lx", dwStateValue);
            }
            pCurrentContext->dwRenderState[dwStateType] = dwStateValue;
            pCurrentContext->dwStateChange = TRUE;

            /*
             * Handle some special case render states now.
             */
            switch (dwStateType)
            {
                case D3DRENDERSTATE_TEXTUREHANDLE:
                    if (dwStateValue)
                    {
                        pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] |= 0x80000000;
#ifdef  NVD3D_DX6
                        pCurrentContext->tssState[0].dwTextureMap = pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE];
#endif  // NVD3D_DX6
                    }
                    break;
                case D3DRENDERSTATE_TEXTUREADDRESS:
                    pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREADDRESSU] = dwStateValue;
                    pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREADDRESSV] = dwStateValue;
                    break;
                case D3DRENDERSTATE_MIPMAPLODBIAS:
                    /*
                     * Convert LODBIAS value to NV hardware value.
                     * Here is the true meaning of this value as implemented by the reference rasterizer:
                     *    Floating-point D3DVALUE value used to change the level of detail (LOD) bias.
                     *    This value offsets the value of the mipmap level that is computed by trilinear
                     *    texturing. It is usually in the range  -1.0 to 1.0; the default value is 0.0.
                     *    Each unit bias (+/-1.0) biases the selection by exactly one mipmap level.
                     *    A negative bias will cause the use of larger mipmap levels, resulting in a
                     *    sharper but more aliased image.
                     *    A positive bias will cause the use of smaller mipmap levels, resulting in a
                     *    blurrier image.
                     *    Applying a positive bias also results in the referencing of a smaller amount
                     *    of texture data, which can boost performance on some systems.
                     */
                    if (!pCurrentContext->dwRenderState[D3DRENDERSTATE_MIPMAPLODBIAS])
                        pCurrentContext->dwMipMapLODBias = pDriverData->regLODBiasAdjust;
                    else
                    {
                        D3DVALUE dvLODBias;

                        dvLODBias = *((D3DVALUE *)&(pCurrentContext->dwRenderState[D3DRENDERSTATE_MIPMAPLODBIAS]));
                        if (dvLODBias > 15.0f)
                            dvLODBias = 15.0f;
                        else if (dvLODBias < -15.0f)
                            dvLODBias = -15.0f;
                        /*
                         * Convert the floating point value from D3D into a 5.3 NV value.
                         * 0x08 == 1.0f
                         */
                        dvLODBias *= 8.0;
                        pCurrentContext->dwMipMapLODBias = (DWORD)((long)dvLODBias & 0x000000FF);
                    }
                    break;

                /*
                 * Stupid DX will occasionally send a WrapU/WrapV other than TRUE(1) or FALSE(0)
                 * which can cause problems when the value is or'd directly into the hareware
                 * register.  Make sure that our value is only 0 or 1.
                 */
                case D3DRENDERSTATE_WRAPU:
                    if (dwStateValue)
                        pCurrentContext->dwRenderState[D3DRENDERSTATE_WRAPU] = TRUE;
                    else
                        pCurrentContext->dwRenderState[D3DRENDERSTATE_WRAPU] = FALSE;
                    break;
                case D3DRENDERSTATE_WRAPV:
                    if (dwStateValue)
                        pCurrentContext->dwRenderState[D3DRENDERSTATE_WRAPV] = TRUE;
                    else
                        pCurrentContext->dwRenderState[D3DRENDERSTATE_WRAPV] = FALSE;
                    break;
                case D3DRENDERSTATE_FILLMODE:
                    if (!(dwStateValue)
                     || (dwStateValue > D3DFILL_SOLID))
                    {
                        pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE] = D3DFILL_SOLID;
                    }
                    break;
#ifdef  NVD3D_DX6
                case D3DRENDERSTATE_TEXTUREMIN:
                    switch (dwStateValue)
                    {
                        case D3DFILTER_NEAREST:
                            pCurrentContext->tssState[0].dwMinFilter = D3DTFN_POINT;
                            pCurrentContext->tssState[0].dwMipFilter = D3DTFP_NONE;
                            break;
                        case D3DFILTER_LINEAR:
                            pCurrentContext->tssState[0].dwMinFilter = D3DTFN_LINEAR;
                            pCurrentContext->tssState[0].dwMipFilter = D3DTFP_NONE;
                            break;
                        case D3DFILTER_MIPNEAREST:
                            pCurrentContext->tssState[0].dwMinFilter = D3DTFN_POINT;
                            pCurrentContext->tssState[0].dwMipFilter = D3DTFP_POINT;
                            break;
                        case D3DFILTER_MIPLINEAR:
                            pCurrentContext->tssState[0].dwMinFilter = D3DTFN_LINEAR;
                            pCurrentContext->tssState[0].dwMipFilter = D3DTFP_POINT;
                            break;
                        case D3DFILTER_LINEARMIPNEAREST:
                            pCurrentContext->tssState[0].dwMinFilter = D3DTFN_POINT;
                            pCurrentContext->tssState[0].dwMipFilter = D3DTFP_LINEAR;
                            break;
                        case D3DFILTER_LINEARMIPLINEAR:
                            pCurrentContext->tssState[0].dwMinFilter = D3DTFN_LINEAR;
                            pCurrentContext->tssState[0].dwMipFilter = D3DTFP_LINEAR;
                            break;
                        default:
                            pCurrentContext->tssState[0].dwMinFilter = D3DTFN_POINT;
                            pCurrentContext->tssState[0].dwMipFilter = D3DTFP_NONE;
                            break;
                    }
                    break;
                case D3DRENDERSTATE_TEXTUREMAG:
                    switch (dwStateValue)
                    {
                        case D3DFILTER_NEAREST:
                            pCurrentContext->tssState[0].dwMagFilter = D3DTFG_POINT;
                            break;
                        case D3DFILTER_LINEAR:
                            pCurrentContext->tssState[0].dwMagFilter = D3DTFG_LINEAR;
                            break;
                        default:
                            pCurrentContext->tssState[0].dwMagFilter = D3DTFG_POINT;
                            break;
                    }
                    break;
#if 0
                case D3DRENDERSTATE_TEXTUREMAPBLEND:
                {
                    DWORD   i;
                    /*
                     * When we get a texturemapblend renderstate, we will also modify the texture stage
                     * state to reflect this change. An application should not be using both TEXTUREMAPBLEND
                     * as well as texture stages so this should be a safe thing to do.  But, as the docs say:
                     *
                     *      Legacy Blending Modes and Texture Stages
                     *
                     *      Although Direct3D still supports the texture blending render state,
                     *      D3DRENDERSTATE_TEXTUREMAPBLEND, the blending modes it offers should not be
                     *      used in combination with texture stage based texture blending, as the
                     *      results can be unpredictable.
                     */
                    switch (dwStateValue)
                    {
                        case D3DTBLEND_DECAL:
                        case D3DTBLEND_COPY:
                        case D3DTBLEND_DECALMASK:
                            pCurrentContext->tssState[0].dwColorOp   = D3DTOP_SELECTARG1;
                            pCurrentContext->tssState[0].dwColorArg1 = D3DTA_TEXTURE;
                            pCurrentContext->tssState[0].dwColorArg2 = D3DTA_DIFFUSE;
                            pCurrentContext->tssState[0].dwAlphaOp   = D3DTOP_SELECTARG1;
                            pCurrentContext->tssState[0].dwAlphaArg1 = D3DTA_TEXTURE;
                            pCurrentContext->tssState[0].dwAlphaArg2 = D3DTA_DIFFUSE;
                            break;
                        case D3DTBLEND_MODULATE:
                        case D3DTBLEND_MODULATEMASK:
                            pCurrentContext->tssState[0].dwColorOp   = D3DTOP_MODULATE;
                            pCurrentContext->tssState[0].dwColorArg1 = D3DTA_TEXTURE;
                            pCurrentContext->tssState[0].dwColorArg2 = D3DTA_DIFFUSE;
                            pCurrentContext->tssState[0].dwAlphaOp   = D3DTOP_SELECTARG1;
                            pCurrentContext->tssState[0].dwAlphaArg1 = D3DTA_TEXTURE;
                            pCurrentContext->tssState[0].dwAlphaArg2 = D3DTA_DIFFUSE;
                            break;
                        case D3DTBLEND_DECALALPHA:
                            pCurrentContext->tssState[0].dwColorOp   = D3DTOP_SELECTARG1;
                            pCurrentContext->tssState[0].dwColorArg1 = D3DTA_TEXTURE;
                            pCurrentContext->tssState[0].dwColorArg2 = D3DTA_DIFFUSE;
                            pCurrentContext->tssState[0].dwAlphaOp   = D3DTOP_SELECTARG1;
                            pCurrentContext->tssState[0].dwAlphaArg1 = D3DTA_DIFFUSE;
                            pCurrentContext->tssState[0].dwAlphaArg2 = D3DTA_DIFFUSE;
                            break;
                        case D3DTBLEND_MODULATEALPHA:
                            pCurrentContext->tssState[0].dwColorOp   = D3DTOP_MODULATE;
                            pCurrentContext->tssState[0].dwColorArg1 = D3DTA_TEXTURE;
                            pCurrentContext->tssState[0].dwColorArg2 = D3DTA_DIFFUSE;
                            pCurrentContext->tssState[0].dwAlphaOp   = D3DTOP_MODULATE;
                            pCurrentContext->tssState[0].dwAlphaArg1 = D3DTA_TEXTURE;
                            pCurrentContext->tssState[0].dwAlphaArg2 = D3DTA_DIFFUSE;
                            break;
                        case D3DTBLEND_ADD:
                            pCurrentContext->tssState[0].dwColorOp   = D3DTOP_ADD;
                            pCurrentContext->tssState[0].dwColorArg1 = D3DTA_TEXTURE;
                            pCurrentContext->tssState[0].dwColorArg2 = D3DTA_DIFFUSE;
                            pCurrentContext->tssState[0].dwAlphaOp   = D3DTOP_SELECTARG1;
                            pCurrentContext->tssState[0].dwAlphaArg1 = D3DTA_DIFFUSE;
                            pCurrentContext->tssState[0].dwAlphaArg2 = D3DTA_DIFFUSE;
                            break;
                        default:
                            pCurrentContext->tssState[0].dwColorOp   = D3DTOP_MODULATE;
                            pCurrentContext->tssState[0].dwColorArg1 = D3DTA_TEXTURE;
                            pCurrentContext->tssState[0].dwColorArg2 = D3DTA_DIFFUSE;
                            pCurrentContext->tssState[0].dwAlphaOp   = D3DTOP_MODULATE;
                            pCurrentContext->tssState[0].dwAlphaArg1 = D3DTA_TEXTURE;
                            pCurrentContext->tssState[0].dwAlphaArg2 = D3DTA_DIFFUSE;
                            break;
                    }
                    /*
                     * Disable all but stage 0.
                     */
                    for (i = 1; i < 8; i++)
                    {
                        pCurrentContext->tssState[i].dwColorOp = D3DTOP_DISABLE;
                        pCurrentContext->tssState[i].dwAlphaOp = D3DTOP_DISABLE;
                    }
                    break;
                }
#endif
                case D3DRENDERSTATE_WRAP0:
                    pCurrentContext->dwRenderState[D3DRENDERSTATE_WRAPU] =
                    pCurrentContext->tssState[0].bWrapU                  = ((dwStateValue & D3DWRAP_U) == D3DWRAP_U);
                    pCurrentContext->dwRenderState[D3DRENDERSTATE_WRAPV] =
                    pCurrentContext->tssState[0].bWrapV                  = ((dwStateValue & D3DWRAP_V) == D3DWRAP_V);
                    break;
                case D3DRENDERSTATE_WRAP1:
                case D3DRENDERSTATE_WRAP2:
                case D3DRENDERSTATE_WRAP3:
                case D3DRENDERSTATE_WRAP4:
                case D3DRENDERSTATE_WRAP5:
                case D3DRENDERSTATE_WRAP6:
                case D3DRENDERSTATE_WRAP7:
                    pCurrentContext->tssState[dwStateType - D3DRENDERSTATE_WRAP0].bWrapU = ((dwStateValue & D3DWRAP_U) == D3DWRAP_U);
                    pCurrentContext->tssState[dwStateType - D3DRENDERSTATE_WRAP0].bWrapV = ((dwStateValue & D3DWRAP_V) == D3DWRAP_V);
                    break;
#endif  // NVD3D_DX6
                case D3DRENDERSTATE_ANTIALIAS:
                    {
                        BOOL bWasEnabled;
                        BOOL bWillEnable;

                        /*
                         * prep for toggle counts
                         */
                        bWasEnabled = (pCurrentContext->dwAntiAliasFlags & AA_ENABLED_MASK) ? 1 : 0;
                        bWillEnable =  dwStateValue != D3DANTIALIAS_NONE;

                        /*
                         * assume disabled
                         */
                        pCurrentContext->dwAntiAliasFlags &= ~(AA_ENABLED_MASK | AA_2D_COUNT_MASK | AA_MIX_MASK);

                        /*
                         * check master switch
                         */
                        if (pDriverData->regD3DEnableBits1 & REG_BIT1_ANTI_ALIAS_ENABLE)
                        {
                            /*
                             * enable aa only if app request aa and is behaving well
                             */
                            if ((dwStateValue != D3DANTIALIAS_NONE)
                             && !(pCurrentContext->dwAntiAliasFlags & AA_INVALID_SEMANTICS))
                            {
                                /*
                                 * decide which AA strategy to use depending on registry
                                 */
                                // aatodo - check aamethod in registry
                                if (1)
                                {
                                    /*
                                     * enable super sampled AA
                                     */
                                    if (pCurrentContext->dwAntiAliasFlags & AA_BUFALLOC_MASK)
                                    {
                                        /*
                                         * enable correct aa mode depending on buffers that where allocated
                                         */
                                        if (pCurrentContext->dwAntiAliasFlags & AA_BUFALLOC_SUPER)
                                            pCurrentContext->dwAntiAliasFlags |= AA_MODE_SUPER;
                                        if (pCurrentContext->dwAntiAliasFlags & AA_BUFALLOC_SINGLECHUNK)
                                            pCurrentContext->dwAntiAliasFlags |= AA_MODE_SINGLECHUNK;
                                        if (pCurrentContext->dwAntiAliasFlags & AA_BUFALLOC_EDGE)
                                            pCurrentContext->dwAntiAliasFlags |= AA_MODE_EDGE;
                                    }
                                    else
                                    {
                                        pCurrentContext->dwAntiAliasFlags |= AA_MODE_SUPER;
                                    }
                                }
                                else
                                {
                                    /*
                                     * enable edge AA
                                     */
                                    pCurrentContext->dwAntiAliasFlags |= AA_MODE_EDGE;
                                }

                                /*
                                 * allocate proper buffers if needed
                                 */
                                if (!(pCurrentContext->dwAntiAliasFlags & AA_BUFALLOC_MASK))
                                {
                                    if (!nvAACreateBuffers())
                                    {
                                        /*
                                         * fail to create buffers - punt
                                         */
                                        pCurrentContext->dwAntiAliasFlags &= ~(AA_ENABLED_MASK | AA_BUFALLOC_MASK);
                                        *pddrval = DDERR_OUTOFVIDEOMEMORY;
                                        return (DDHAL_DRIVER_HANDLED);
                                    }
                                }
                            }
                        }
                    }
                    break;
            }
        }
    }

    /*
     * Force a reload of the global context state.
     */
    pDriverData->dwCurrentContextHandle = 0;
    *pddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}
/*
 * Calculate the hardware state register based on the D3D context state settings.
 */
void nvCalculateHardwareStateDX5
(
    DWORD   dwTBlendState,
    DWORD   dwMinFilter,
    DWORD   dwMagFilter,
    BOOL    bDx6ToDx5Conversion
)
{
    BOOL            bAlphaTexture = FALSE;
    DWORD           dwMMDE;
    DWORD           dwAlphaRef;
    DWORD           dwAlphaFunc       = 0;  // Will get initialized before being used.
    DWORD           dwTextureColorFormat;
    DWORD           dwZOHMode, dwFOHMode, dwTexelOrigin;
    DWORD           dwTexturePerspective;
    DWORD           dwSrcBlend;
    DWORD           dwDstBlend;
    DWORD           dwAlphaBlendEnable;
    DWORD           dwColorKey        = 0;
    DWORD           dwOffset          = 0;
    DWORD           dwFormat          = 0;
    DWORD           dwFilter          = 0;
    DWORD           dwBlend           = 0;
    DWORD           dwControl         = 0;
    DWORD           dwFogColor        = 0;
    DWORD          *pdwRenderState    = 0;
    PNVD3DTEXTURE   pTexture;

    pdwRenderState = (DWORD *)pCurrentContext->dwRenderState;

    // txtodo - validate swizzled texture copy


    dwZOHMode     = ((pDriverData->regTexelAlignment & REG_TA_ZOH_MASK) == REG_TA_ZOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_ZOH_CENTER : NV054_FORMAT_ORIGIN_ZOH_CORNER;
    dwFOHMode     = ((pDriverData->regTexelAlignment & REG_TA_FOH_MASK) == REG_TA_FOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_FOH_CENTER : NV054_FORMAT_ORIGIN_FOH_CORNER;
    dwTexelOrigin = ((pDriverData->regTexelAlignment & REG_TA_TEXEL_MASK) == REG_TA_TEXEL_CENTER)
                  ? NV054_CONTROL_ORIGIN_CENTER : NV054_CONTROL_ORIGIN_CORNER;

    /*
     * Maximize 2 pixels per clock.
     */
    dwMMDE = ((pdwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_ONE) && (pdwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_ONE)) || ((pDriverData->regD3DEnableBits1 & REG_BIT1_MIPMAP_DITHER_ENABLE) == REG_BIT1_MIPMAP_DITHER_ENABLE);

    /*
     * Set up the texture format register.
     */
    if (pTexture = (PNVD3DTEXTURE)pdwRenderState[D3DRENDERSTATE_TEXTUREHANDLE])
        NV_LOCK_TEXTURE_SURFACE(pTexture);
    if ((pTexture)
     && (pTexture->lpLcl))
    {
        /*
         * DEBUG only.
         * Display the new texture to the current visible buffer.
         */
        dbgDisplayTexture(pCurrentContext, pTexture);

#ifdef NV_TEX2
        /*
         * setup current texture(s)
         */
        pCurrentContext->pTexture0 = pTexture;
        pCurrentContext->pTexture1 = NULL;
#endif

        /*
         * Grab the color key from the texture.
         */
        dwTextureColorFormat = pTexture->dwTextureColorFormat;
        if (pTexture->lpLcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT)
        {
#ifndef NV_TEX2
            if (pDriverData->regD3DEnableBits1 & REG_BIT1_RESTRICT_AUTO_MIPMAPS)
                pTexture->dwTextureFlags &= ~NV4_TEXTURE_CAN_AUTO_MIPMAP;
#endif
            switch (dwTextureColorFormat)
            {
                case NV054_FORMAT_COLOR_LE_Y8:
                    break;
                /*
                 * Must assume the application does the right thing here and passes in the
                 * exact color key value as is in the texture map.  If the alpha bits are masked
                 * here, WHQL will fail.
                 */
                case NV054_FORMAT_COLOR_LE_A1R5G5B5:
                case NV054_FORMAT_COLOR_LE_A4R4G4B4:
//                case NV054_FORMAT_COLOR_LE_X1R5G5B5:
                case NV054_FORMAT_COLOR_LE_R5G6B5:
                    dwColorKey = (pTexture->lpLcl->ddckCKSrcBlt.dwColorSpaceHighValue & 0x0000FFFF);
                    break;
                case NV054_FORMAT_COLOR_LE_X1R5G5B5:
                    dwColorKey = (pTexture->lpLcl->ddckCKSrcBlt.dwColorSpaceHighValue & 0x00007FFF);
                    break;
                case NV054_FORMAT_COLOR_LE_A8R8G8B8:
                case NV054_FORMAT_COLOR_LE_X8R8G8B8:
                    dwColorKey = pTexture->lpLcl->ddckCKSrcBlt.dwColorSpaceHighValue;
                    break;
            }
            dwFormat |= DRF_NUM(054, _FORMAT, _COLORKEYENABLE,  pdwRenderState[D3DRENDERSTATE_COLORKEYENABLE]);
        }
        else
            dwFormat |= DRF_DEF(054, _FORMAT, _COLORKEYENABLE,  _FALSE);

        /*
         * Get the texture format and offset.
         */
#ifdef NV_TEX2
        dwOffset  = TEX_SWIZZLE_OFFSET(pTexture,pTexture->dwTextureFlags);
#else
        dwOffset  = pTexture->dwTextureOffset;
#endif
        dwFormat |= DRF_NUM(054, _FORMAT, _CONTEXT_DMA,      pTexture->dwTextureContextDma)
                 |  DRF_NUM(054, _FORMAT, _COLOR,            dwTextureColorFormat)
                 |  DRF_NUM(054, _FORMAT, _BASE_SIZE_U,      pTexture->dwMipMapBaseU)
                 |  DRF_NUM(054, _FORMAT, _BASE_SIZE_V,      pTexture->dwMipMapBaseV)
                 |  DRF_NUM(054, _FORMAT, _TEXTUREADDRESSU,  pdwRenderState[D3DRENDERSTATE_TEXTUREADDRESSU])
                 |  DRF_NUM(054, _FORMAT, _WRAPU,            pdwRenderState[D3DRENDERSTATE_WRAPU])
                 |  DRF_NUM(054, _FORMAT, _TEXTUREADDRESSV,  pdwRenderState[D3DRENDERSTATE_TEXTUREADDRESSV])
                 |  DRF_NUM(054, _FORMAT, _WRAPV,            pdwRenderState[D3DRENDERSTATE_WRAPV]);
        dwFormat |= DRF_NUM(054, _FORMAT, _ORIGIN_ZOH,       dwZOHMode)
                 |  DRF_NUM(054, _FORMAT, _ORIGIN_FOH,       dwFOHMode);

        /*
         * When there is a texture, use the texture map blend set by the user.
         * One exception.  For textures that do not have an alpha component, set MODULATEALPHA
         * instead of MODULATE.
         *
         * NOTE: For some reason, this does not work when SRCBLEND == DESTBLEND == D3DBLEND_ONE
         *       WHY? (Incoming)
         *
         * NOTE: I'm going to use the fact that the hardware doesn't implement MODULATE exactly
         *       as specified in order to get two pixels per clock out of the following DX6
         *       single texture stage 0 setup: COLOROP = MODULATE, COLORARG1 = TEXTURE,
         *       COLORARG2 = CURRENT/DIFFUSE ALPHAOP = SELECTARG1, ALPHAARG1 = TEXTURE.
         *       When useing TBLEND=MODULATE and a non-alpha texture, the alpha should come from the
         *       Diffuse color component, however when using texture stages, we should not do this.
         *       On entry, if we are converting from a texture stage setup, the bUseDX6Class flag will
         *       still be set, and under this condition, we should not modify the passed in TBLEND value.
         */
        if ((!bDx6ToDx5Conversion)
         && (dwTBlendState == D3DTBLEND_MODULATE)
         && (pdwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE])
         && !((pdwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_ONE)
          &&  (pdwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_ONE))
         && ((dwTextureColorFormat == NV054_FORMAT_COLOR_LE_X1R5G5B5)
          || (dwTextureColorFormat == NV054_FORMAT_COLOR_LE_R5G6B5)
          || (dwTextureColorFormat == NV054_FORMAT_COLOR_LE_X8R8G8B8)))
        {
            dwTBlendState = D3DTBLEND_MODULATEALPHA;
            dwBlend  |= DRF_DEF(054, _BLEND, _TEXTUREMAPBLEND, _MODULATEALPHA);
        }
        else
            dwBlend  |= DRF_NUM(054, _BLEND, _TEXTUREMAPBLEND, dwTBlendState);

        if ((pTexture->lpLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP)
         || (pTexture->dwMipMapLevels == 1))
        {
            /*
             * When this is a user supplied mipmap chain
             * OR the number of mipmap levels is 1 (i.e. no mipmaps, only base texture)
             * set the MIN/MAG filters as specified by the render states.
             */
            dwFilter |= DRF_NUM(054, _FILTER, _MIPMAP_DITHER_ENABLE, dwMMDE)
                     |  DRF_NUM(054, _FILTER, _TEXTUREMIN,    dwMinFilter)
                     |  DRF_NUM(054, _FILTER, _TEXTUREMAG,    dwMagFilter);

            /*
             * The only way to guarantee that mipmapping is disabled is to set MIPMAP_LEVELS to 1.
             * In cases where there are the user has supplied mipmaps but the minification filter is
             * set to D3DFILTER_NEAREST or D3DFILTER_LINEAR, force the mipmap levels field to be a 1.
             */
            if ((dwMinFilter == D3DFILTER_NEAREST)
             || (dwMinFilter == D3DFILTER_LINEAR))
                dwFormat |= DRF_NUM(054, _FORMAT, _MIPMAP_LEVELS, 1);
            else
                dwFormat |= DRF_NUM(054, _FORMAT, _MIPMAP_LEVELS, pTexture->dwMipMapLevels);
        }
        else
        {
#ifdef NV_TEX2
            if (pTexture->dwTextureFlags & NV4_TEXFLAG_AUTOMIPMAP)
#else
            if (pTexture->dwTextureFlags & NV4_TEXTURE_CAN_AUTO_MIPMAP)
#endif
            {
                /*
                 * This is the auto-generated mipmap case. In order to get the some sort of mipmapping
                 * to happen, the MIN/MAG filters must be modified if they are NEAREST or LINEAR.
                 */
                dwFilter |= DRF_NUM(054, _FILTER, _MIPMAP_DITHER_ENABLE, dwMMDE);
                dwFormat |= DRF_NUM(054, _FORMAT, _MIPMAP_LEVELS,  pTexture->dwMipMapLevels);

                /*
                 * Set the MINIFICATION filter.
                 */
                if (pDriverData->regAutoMipMapMethod == REG_AMMM_BILINEAR)
                {
                    if (dwMinFilter == D3DFILTER_NEAREST)
                        dwFilter |= DRF_DEF(054, _FILTER, _TEXTUREMIN, _MIPNEAREST);
                    else if (dwMinFilter == D3DFILTER_LINEAR)
                        dwFilter |= DRF_DEF(054, _FILTER, _TEXTUREMIN, _MIPLINEAR);
                    else
                        dwFilter |= DRF_NUM(054, _FILTER, _TEXTUREMIN, dwMinFilter);
                }
                else
                {
                    if (dwMinFilter == D3DFILTER_NEAREST)
                        dwFilter |= DRF_DEF(054, _FILTER, _TEXTUREMIN, _LINEARMIPNEAREST);
                    else if (dwMinFilter == D3DFILTER_LINEAR)
                        dwFilter |= DRF_DEF(054, _FILTER, _TEXTUREMIN, _LINEARMIPLINEAR);
                    else
                        dwFilter |= DRF_NUM(054, _FILTER, _TEXTUREMIN, dwMinFilter);
                }

                /*
                 * Set the MAGNIFICATION filter.
                 * Can only validly be set to NEAREST or LINEAR
                 */
                dwFilter |= DRF_NUM(054, _FILTER, _TEXTUREMAG,    dwMagFilter);
            }
            else
            {
                /*
                 * This texture is flagged as not a auto-generated mipmapable texture.
                 */
                dwFilter |= DRF_NUM(054, _FILTER, _MIPMAP_DITHER_ENABLE, dwMMDE)
                         |  DRF_NUM(054, _FILTER, _TEXTUREMIN,    dwMinFilter)
                         |  DRF_NUM(054, _FILTER, _TEXTUREMAG,    dwMagFilter);
                dwFormat |= DRF_NUM(054, _FORMAT, _MIPMAP_LEVELS, 1);
            }
        }

        /*
         * When texturing, always select the proper TexturePerspective render state value.
         */
        dwTexturePerspective = pdwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE];
        NV_UNLOCK_TEXTURE_SURFACE(pTexture);
    }
    else
    {
        /*
         * There is no texture set the default texture format and offset.
         */
        dwTextureColorFormat = pCurrentContext->dwDefaultTextureColorFormat;
        dwOffset  = pCurrentContext->dwDefaultTextureOffset;
        dwFormat |= DRF_NUM(054, _FORMAT, _CONTEXT_DMA,      pCurrentContext->dwDefaultTextureContextDma)
                 |  DRF_DEF(054, _FORMAT, _COLORKEYENABLE,  _FALSE)
                 |  DRF_NUM(054, _FORMAT, _COLOR,            dwTextureColorFormat)
                 |  DRF_NUM(054, _FORMAT, _MIPMAP_LEVELS,    1)
                 |  DRF_DEF(054, _FORMAT, _BASE_SIZE_U,     _1)
                 |  DRF_DEF(054, _FORMAT, _BASE_SIZE_V,     _1)
                 |  DRF_DEF(054, _FORMAT, _TEXTUREADDRESSU, _CLAMP)
                 |  DRF_DEF(054, _FORMAT, _WRAPU,           _FALSE)
                 |  DRF_DEF(054, _FORMAT, _TEXTUREADDRESSV, _CLAMP)
                 |  DRF_DEF(054, _FORMAT, _WRAPV,           _FALSE);
        dwFormat |= DRF_NUM(054, _FORMAT, _ORIGIN_ZOH,      dwZOHMode)
                 |  DRF_NUM(054, _FORMAT, _ORIGIN_FOH,      dwFOHMode);

        /*
         * When there is no texture, always set texture map blend to be MODULATEALPHA
         */
        if (pdwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE])
            dwBlend  |= DRF_DEF(054, _BLEND, _TEXTUREMAPBLEND, _MODULATEALPHA);
        else
            dwBlend  |= DRF_DEF(054, _BLEND, _TEXTUREMAPBLEND, _MODULATE);

        /*
         * When there's no texture, always set for nearest (point sample) filtering.
         */
        dwFilter |= DRF_DEF(054, _FILTER, _MIPMAP_DITHER_ENABLE, _FALSE)
                 |  DRF_DEF(054, _FILTER, _TEXTUREMIN,    _NEAREST)
                 |  DRF_DEF(054, _FILTER, _TEXTUREMAG,    _NEAREST);

        /*
         * When there is no texture, set texture perspective to false to insure that no 0 RHW values
         * screw up the hardware.
         * But this isn't a good hack.  So it's gone.
         */
//        dwTexturePerspective = FALSE;
        dwTexturePerspective = pdwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE];
    }

    /*
     * Set the Mipmap LOD BIAS based on registery setting and render state setting.
     */
    dwFilter |= DRF_NUM(054, _FILTER, _MIPMAPLODBIAS, pCurrentContext->dwMipMapLODBias);

    /*
     * D3DRENDERSTATE_ANISOTROPY defines 1 as no anisotropy.
     * The following if statement is based on the reference rasterizer.
     */
    if (pdwRenderState[D3DRENDERSTATE_ANISOTROPY] > 1)
    {
        dwFilter |= DRF_NUM(054, _FILTER, _KERNEL_SIZE_X,              0x1F)
                 |  DRF_NUM(054, _FILTER, _KERNEL_SIZE_Y,              0x1F)
                 |  DRF_DEF(054, _FILTER, _ANISOTROPIC_MINIFY_ENABLE,  _TRUE)
                 |  DRF_DEF(054, _FILTER, _ANISOTROPIC_MAGNIFY_ENABLE, _TRUE);
    }
    else
    {
        dwFilter |= DRF_DEF(054, _FILTER, _ANISOTROPIC_MINIFY_ENABLE,  _FALSE)
                 |  DRF_DEF(054, _FILTER, _ANISOTROPIC_MAGNIFY_ENABLE, _FALSE);
    }

    /*
     * Set up the control register.
     */
    dwControl |= DRF_NUM(054, _CONTROL, _ORIGIN,               dwTexelOrigin)
#ifdef NV_CONTROLTRAFFIC
              |  DRF_NUM(054, _CONTROL, _ZFUNC,                CTFunc(pdwRenderState[D3DRENDERSTATE_ZFUNC]))
#else
              |  DRF_NUM(054, _CONTROL, _ZFUNC,                pdwRenderState[D3DRENDERSTATE_ZFUNC])
#endif
#ifdef NV_FASTLOOPS
              |  DRF_NUM(054, _CONTROL, _CULLMODE,             D3DCULL_NONE)
#else
              |  DRF_NUM(054, _CONTROL, _CULLMODE,             pdwRenderState[D3DRENDERSTATE_CULLMODE])
#endif
              |  DRF_NUM(054, _CONTROL, _DITHERENABLE,         pdwRenderState[D3DRENDERSTATE_DITHERENABLE]);

    /*
     * Get the Src/Dest blending state
     */
    dwAlphaBlendEnable = pdwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE];
    dwSrcBlend         = pdwRenderState[D3DRENDERSTATE_SRCBLEND];
    dwDstBlend         = pdwRenderState[D3DRENDERSTATE_DESTBLEND];

    /*
     * Colorkey setup.
     */
    if ((pdwRenderState[D3DRENDERSTATE_COLORKEYENABLE])
     && ((dwFormat >> DRF_SHIFT(NV054_FORMAT_COLORKEYENABLE)) & DRF_MASK(NV054_FORMAT_COLORKEYENABLE)))
    {
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "D3D:nvCalculateHardwareStateDX5 - ColorKey Enabled");
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    ColorKey Color     = %08lx", dwColorKey);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    AlphaTestEnable    = %08lx", pdwRenderState[D3DRENDERSTATE_ALPHATESTENABLE]);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    AlphaRef           = %08lx", pdwRenderState[D3DRENDERSTATE_ALPHAREF]);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    AlphaFunc          = %08lx", pdwRenderState[D3DRENDERSTATE_ALPHAFUNC]);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    AlphaBlendEnable   = %08lx", pdwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE]);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    SrcBlend           = %08lx", pdwRenderState[D3DRENDERSTATE_SRCBLEND]);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    DstBlend           = %08lx", pdwRenderState[D3DRENDERSTATE_DESTBLEND]);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    TextureMapBlend    = %08lx", dwTBlendState);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    TextureColorFormat = %08lx", dwTextureColorFormat);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    MagFliter          = %08lx", dwMagFilter);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    MinFliter          = %08lx", dwMinFilter);

        bAlphaTexture = ((dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A1R5G5B5)
                      || (dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A4R4G4B4)
                      || (dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A8R8G8B8));

        if (!(pDriverData->regD3DEnableBits1 & REG_BIT1_CKCOMPATABILITY_ENABLE))
        {
            DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "ColorKey Compatability Disabled");
            goto    labelColorKeySetupNoAlphaTest;
        }

        /*
         * Check the texture format and alpha blending operation.
         * for 8888 and 1555 textures, if (alpha blending is disabled) OR
         * (alpha blending is enabled and neither srcblend and destblend use the source
         * alpha) then change the format sent to hardware to be the complimentery non-alpha
         * texture format.
         */
        if ((dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A1R5G5B5)
         || (dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A8R8G8B8))
        {
            DWORD dwNewFormat;
            dwNewFormat = (dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A1R5G5B5) ? NV054_FORMAT_COLOR_LE_X1R5G5B5 : NV054_FORMAT_COLOR_LE_X8R8G8B8;

            if (!dwAlphaBlendEnable)
            {
                /*
                 * When alpha blending is disabled, force 1555 and 8888 textures to be x555 and x888
                 * repectively so that non-colorkey 0 alpha texels don't get alpha tested away.
                 */
                dwFormat &= ~(DRF_MASK(NV054_FORMAT_COLOR) << DRF_SHIFT(NV054_FORMAT_COLOR));
                dwFormat |= DRF_NUM(054, _FORMAT, _COLOR, dwNewFormat);
            }
            else
            {
                if ((dwSrcBlend != D3DBLEND_SRCALPHA)
                 && (dwSrcBlend != D3DBLEND_INVSRCALPHA)
                 && (dwSrcBlend != D3DBLEND_SRCALPHASAT)
                 && (dwSrcBlend != D3DBLEND_BOTHSRCALPHA)
                 && (dwSrcBlend != D3DBLEND_BOTHINVSRCALPHA)
                 && (dwDstBlend != D3DBLEND_SRCALPHA)
                 && (dwDstBlend != D3DBLEND_INVSRCALPHA)
                 && (dwDstBlend != D3DBLEND_SRCALPHASAT)
                 && (dwDstBlend != D3DBLEND_BOTHSRCALPHA)
                 && (dwDstBlend != D3DBLEND_BOTHINVSRCALPHA))
                {
                    /*
                     * When alpha blending is enabled but the srcalpha is not being used, force 1555
                     * and 8888 textures to be x555 and x888 repectively so that non-colorkey 0 alpha
                     * texels don't get alpha tested away.
                     */
                    dwFormat &= ~(DRF_MASK(NV054_FORMAT_COLOR) << DRF_SHIFT(NV054_FORMAT_COLOR));
                    dwFormat |= DRF_NUM(054, _FORMAT, _COLOR,            dwNewFormat);
                }
            }
        }

        /*
         * Change color key implementation to always use alpha test
         */
        if (!pdwRenderState[D3DRENDERSTATE_ALPHATESTENABLE])
        {
            DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "ColorKey with registry alphatest");

            /*
             * Special case for non-alpha textures when blending is enabled and the source blend
             * is set to D3DBLEND_ONE and the texturemap blend is set to modulate alpha.  Switch
             * the TBLEND to be modulate since the vertex alpha doesn't matter.
             * But one other requirement is that the SRCALPHA cannot be involved in the destblend either.
             * This will prevent vertices with alphas set to all zero to not get keyed away.
             */
            if ((dwAlphaBlendEnable) //&& (!bAlphaTexture)
             && (dwTBlendState == D3DTBLEND_MODULATEALPHA)
             && (dwSrcBlend == D3DBLEND_ONE)
             && ((dwDstBlend != D3DBLEND_SRCALPHA)
              && (dwDstBlend != D3DBLEND_INVSRCALPHA)
              && (dwDstBlend != D3DBLEND_SRCALPHASAT)
              && (dwDstBlend != D3DBLEND_BOTHSRCALPHA)
              && (dwDstBlend != D3DBLEND_BOTHINVSRCALPHA)))
            {
                dwBlend &= ~DRF_MASK(NV054_BLEND_TEXTUREMAPBLEND);
                dwBlend |= DRF_DEF(054, _BLEND, _TEXTUREMAPBLEND, _MODULATE);
            }

            /*
             * Set the colorkey alphatest mode.
             */
            dwAlphaRef = pDriverData->regColorkeyRef;
            dwControl |= DRF_NUM(054, _CONTROL, _ALPHAREF,        dwAlphaRef)
                      |  DRF_DEF(054, _CONTROL, _ALPHAFUNC,       _GREATER)
                      |  DRF_DEF(054, _CONTROL, _ALPHATESTENABLE, _TRUE);
        }
        else
        {
            DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "ColorKey with app alphatest");

            /*
             * Calculate the hardware alpha test reference value.
             */
            dwAlphaRef = pdwRenderState[D3DRENDERSTATE_ALPHAREF];
            if (dwAlphaRef == 0x00010000)
                dwAlphaRef = 0xFF;
            else if (dwAlphaRef & 0xFF00)
                dwAlphaRef >>= 8;

            /*
             * Get the application specified alpha test comparison function.
             */
            dwAlphaFunc = pdwRenderState[D3DRENDERSTATE_ALPHAFUNC];

            /*
             * There is a very specialized case where we want to actually modify the alphatest setup
             * from what is passed in by the application.  This is for Motoracer2 which does something
             * very strange...but not all the time.  This is most likely an application bug, but I'm
             * working around it here...yuck.
             *
             * The situation is this, occasionally, Motoracer2 will set the following alphatest state:
             * AlphaTestEnable = 1
             * AlphaRef = 0x00
             * AlphaFunc = 7 (GREATEREQUAL)
             * AlphaBlendEnable = 1
             * SrcBlend = 5 (SRCALPHA)
             * DstBlend = 2 (ONE)
             * TextureMapBlend = 4 (MODULATEALPHA)
             * TextureColorFormat = 5 (R5G6B5)
             * However, in this situation, with the alpharef of 0 and the alphafunc set to GREATEREQUAL,
             * the colorkey (which has it's alpha forced to 0) will still show up since the alphatest
             * comparison will always be TRUE.
             * So, I'll make a general case where if the I see this combination when colorkeying is enabled,
             * I'll just change the alphafunc to be GREATER.
             */
            if ((dwAlphaRef == 0x00)
             && (dwAlphaFunc == D3DCMP_GREATEREQUAL ||
                 dwAlphaFunc == D3DCMP_ALWAYS))
            {
                DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "Modify application alphafunc");
                dwAlphaFunc = D3DCMP_GREATER;
            }

            /*
             * Set the hardware alpha test state.
             */
            dwControl |= DRF_NUM(054, _CONTROL, _ALPHAREF,        dwAlphaRef)
                      |  DRF_NUM(054, _CONTROL, _ALPHAFUNC,       dwAlphaFunc)
                      |  DRF_NUM(054, _CONTROL, _ALPHATESTENABLE, pdwRenderState[D3DRENDERSTATE_ALPHATESTENABLE]);
        }
    }
    else
    {
#if 0   // VR POWERBOAT RACING HACK - NEED SOMETHING EXTREMELY SPECIFIC TO VR POWERBOAT RACING HERE.
        if ((!pdwRenderState[D3DRENDERSTATE_ALPHATESTENABLE])
         && (pdwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE])
         && (dwSrcBlend != D3DBLEND_ONE))
        {
            /*
             * Alpha test away zero alpha pixels to repress z-writes when alpha test
             * is not enabled and alpha blending is enabled.  This is a HACK to work
             * around an application bug in VR Powerboat Racing.
             */
            dwControl |= DRF_NUM(054, _CONTROL, _ALPHAREF,        0x00)
                      |  DRF_NUM(054, _CONTROL, _ALPHAFUNC,       D3DCMP_GREATER)
                      |  DRF_NUM(054, _CONTROL, _ALPHATESTENABLE, TRUE);
        }
        else
#endif  // VR POWERBOAT RACING HACK
        {
labelColorKeySetupNoAlphaTest:
            dwAlphaRef = pdwRenderState[D3DRENDERSTATE_ALPHAREF];
            if (dwAlphaRef == 0x00010000)
                dwAlphaRef = 0xFF;
            else if (dwAlphaRef & 0xFF00)
                dwAlphaRef >>= 8;
            dwControl |= DRF_NUM(054, _CONTROL, _ALPHAREF,        dwAlphaRef)
                      |  DRF_NUM(054, _CONTROL, _ALPHAFUNC,       pdwRenderState[D3DRENDERSTATE_ALPHAFUNC])
                      |  DRF_NUM(054, _CONTROL, _ALPHATESTENABLE, pdwRenderState[D3DRENDERSTATE_ALPHATESTENABLE]);
        }
    }

    /*
     * Set up the texture map blending control register.
     * Not sure about the MASK_BIT.
     */
    dwBlend |= DRF_DEF(054, _BLEND, _MASK_BIT,           _MSB)
            |  DRF_NUM(054, _BLEND, _SHADEMODE,          pdwRenderState[D3DRENDERSTATE_SHADEMODE])
            |  DRF_NUM(054, _BLEND, _TEXTUREPERSPECTIVE, dwTexturePerspective)
            |  DRF_NUM(054, _BLEND, _SPECULARENABLE,     pdwRenderState[D3DRENDERSTATE_SPECULARENABLE])
            |  DRF_NUM(054, _BLEND, _FOGENABLE,          pdwRenderState[D3DRENDERSTATE_FOGENABLE])
            |  DRF_NUM(054, _BLEND, _ALPHABLENDENABLE,   dwAlphaBlendEnable);
    if ((pdwRenderState[D3DRENDERSTATE_SRCBLEND]) == D3DBLEND_BOTHSRCALPHA)
        dwBlend |= DRF_DEF(054, _BLEND, _SRCBLEND,  _SRCALPHA)
                |  DRF_DEF(054, _BLEND, _DESTBLEND, _INVSRCALPHA);
    else if ((pdwRenderState[D3DRENDERSTATE_SRCBLEND]) == D3DBLEND_BOTHINVSRCALPHA)
        dwBlend |= DRF_DEF(054, _BLEND, _SRCBLEND,  _INVSRCALPHA)
                |  DRF_DEF(054, _BLEND, _DESTBLEND, _SRCALPHA);
    else if ((pdwRenderState[D3DRENDERSTATE_DESTBLEND]) == D3DBLEND_BOTHSRCALPHA)
        dwBlend |= DRF_DEF(054, _BLEND, _SRCBLEND,  _SRCALPHA)
                |  DRF_DEF(054, _BLEND, _DESTBLEND, _INVSRCALPHA);
    else if ((pdwRenderState[D3DRENDERSTATE_DESTBLEND]) == D3DBLEND_BOTHINVSRCALPHA)
        dwBlend |= DRF_DEF(054, _BLEND, _SRCBLEND,  _INVSRCALPHA)
                |  DRF_DEF(054, _BLEND, _DESTBLEND, _SRCALPHA);
    else
        dwBlend |= DRF_NUM(054, _BLEND, _SRCBLEND,  dwSrcBlend)
                |  DRF_NUM(054, _BLEND, _DESTBLEND, dwDstBlend);

    if ((pCurrentContext->lpLclZ)
     && (pdwRenderState[D3DRENDERSTATE_ZENABLE]))
    {
        if (pdwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_TRUE)
        {
            /*
             * Plain Z-Buffer.
             */
            dwControl |= DRF_DEF(054, _CONTROL, _ZENABLE,              _TRUE)
                      |  DRF_NUM(054, _CONTROL, _ZWRITEENABLE,         pdwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
                      |  DRF_NUM(054, _CONTROL, _Z_PERSPECTIVE_ENABLE, pDriverData->regZPerspectiveEnable)
                      |  DRF_NUM(054, _CONTROL, _Z_FORMAT,             pDriverData->regZFormat);
        }
        else
        {
            /*
             * W-Buffer.
             */
            // Fixed point w-buffer reqires scaling of RHW but gives more precision in 16bit w-buffers.
            dwControl |= DRF_DEF(054, _CONTROL,  _ZENABLE,              _TRUE)
                      |  DRF_NUM(054, _CONTROL,  _ZWRITEENABLE,         pdwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
                      |  DRF_DEF(054, _CONTROL,  _Z_PERSPECTIVE_ENABLE, _TRUE)
                      |  DRF_DEF(054, _CONTROL,  _Z_FORMAT,             _FIXED);
        }
    }
    else
    {
        dwControl |= DRF_DEF(054, _CONTROL, _ZENABLE,      _FALSE)
                  |  DRF_DEF(054, _CONTROL, _ZWRITEENABLE, _FALSE)
                  |  DRF_NUM(054, _CONTROL, _Z_PERSPECTIVE_ENABLE, pDriverData->regZPerspectiveEnable)
                  |  DRF_NUM(054, _CONTROL, _Z_FORMAT,             pDriverData->regZFormat);

    }

    /*
     * Set the fog color.
     */
    dwFogColor = pdwRenderState[D3DRENDERSTATE_FOGCOLOR];

    /*
     * Store fog table values as floats in the context structure.
     */
    pCurrentContext->dwFogTableMode   = pdwRenderState[D3DRENDERSTATE_FOGTABLEMODE];
    pCurrentContext->fFogTableStart   = *(float *)&pdwRenderState[D3DRENDERSTATE_FOGTABLESTART];
    pCurrentContext->fFogTableEnd     = *(float *)&pdwRenderState[D3DRENDERSTATE_FOGTABLEEND];
    pCurrentContext->fFogTableDensity = *(float *)&pdwRenderState[D3DRENDERSTATE_FOGTABLEDENSITY];
    if (pCurrentContext->dwFogTableMode == D3DFOG_LINEAR)
    {
        if (pCurrentContext->fFogTableEnd != pCurrentContext->fFogTableStart)
            pCurrentContext->fFogTableLinearScale = 1.0f / (pCurrentContext->fFogTableEnd - pCurrentContext->fFogTableStart);
        else
            pCurrentContext->fFogTableLinearScale = 0.0f;
    }

    /*
     * Store the register values.
     */
    pCurrentContext->ctxInnerLoop.dwColorKey      = dwColorKey;
    pCurrentContext->ctxInnerLoop.dwTextureOffset = dwOffset;
    pCurrentContext->ctxInnerLoop.dwFormat        = dwFormat;
    pCurrentContext->ctxInnerLoop.dwFilter        = dwFilter;
    pCurrentContext->ctxInnerLoop.dwBlend         = dwBlend;
    pCurrentContext->ctxInnerLoop.dwControl       = dwControl;
    pCurrentContext->ctxInnerLoop.dwFogColor      = dwFogColor;
    pCurrentContext->dwStateChange                = FALSE;

#ifdef  SPEC_HACK
    /*
     * Update the current blend mode but set the specular enable bit the way it was left.
     * If specular is disabled in the render state, then it should be disabled in the current state.
     * Otherwise just use the last know state of specular highlighting.  It will get enabled when it is
     * needed if it was previously disabled.
     */
    if (!pdwRenderState[D3DRENDERSTATE_SPECULARENABLE])
        pCurrentContext->ctxInnerLoop.dwCurrentSpecularState = FALSE;

    pCurrentContext->ctxInnerLoop.dwCurrentBlend = (dwBlend & 0xFFFF0FFF)
                                                 |  DRF_NUM(054, _BLEND, _SPECULARENABLE, pCurrentContext->ctxInnerLoop.dwCurrentSpecularState);
    pCurrentContext->ctxInnerLoop.dwNoSpecularTriangleCount = 0;
#endif  // SPEC_HACK

    return;
}
BOOL nvSetHardwareState
(
    void
)
{
    DWORD   dwTBlend;
    DWORD   dwMinFilter, dwMagFilter;

#ifdef NV_STATS
    {
        extern DWORD dwHWPCount;
        dwHWPCount ++;
    }
#endif

    /*
     * This code is only enabled in the DEBUG build.
     * Display the DX5 render state to be calculated.
     */
    dbgDisplayContextState(NVDBG_SHOW_RENDER_STATE, pCurrentContext);

    /*
     * Get state to be passed to the hardware setup routine.
     */
    dwTBlend = pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREMAPBLEND];
    dwMinFilter = pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREMIN];
    dwMagFilter = pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREMAG];

    /*
     * Build up the DX5 control state.
     */
    nvCalculateHardwareStateDX5(dwTBlend, dwMinFilter, dwMagFilter, FALSE);

    /*
     * This code is only enabled in the DEBUG build.
     * Validate the inner loop hardware control registers.
     */
    dbgValidateControlRegisters(pCurrentContext);

    /*
     * This code is only enabled in the DEBUG build.
     * Display the hardware registers that were calculated.
     */
    dbgDisplayContextState(NVDBG_SHOW_DX5_CLASS_STATE, pCurrentContext);
    return (TRUE);
}

//-------------------------------------------------------------------------------------

/*
 * Format of the cobine data is:
 * Bits 31-24  23-16  15-8  7 - 0
 *       00     op    arg2  arg1
 */

/*
 * DX5 D3DTBLEND_DECAL equivalent texture stage state.
 */
#define DX5_TSSCOLOR_DECAL_MASK_1      0x00FF00FF
#define DX5_TSSCOLOR_DECAL_1           ((D3DTA_TEXTURE << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSCOLOR_DECAL_MASK_2      0x00FFFF00
#define DX5_TSSCOLOR_DECAL_2           ((D3DTA_TEXTURE << 8) | (D3DTOP_SELECTARG2 << 16))

#define DX5_TSSALPHA_DECAL_MASK_1      0x00FF00FF
#define DX5_TSSALPHA_DECAL_1           ((D3DTA_TEXTURE << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSALPHA_DECAL_MASK_2      0x00FFFF00
#define DX5_TSSALPHA_DECAL_2           ((D3DTA_TEXTURE << 8) | (D3DTOP_SELECTARG2 << 16))

/*
 * DX5 D3DTBLEND_DECALALPHA equivalent texture stage state.
 */
#define DX5_TSSCOLOR_DECALALPHA_MASK    0x00FFFFFF
#define DX5_TSSCOLOR_DECALALPHA_1       ((D3DTA_TEXTURE << 0) | (D3DTA_DIFFUSE << 8) | (D3DTOP_BLENDTEXTUREALPHA << 16))
#define DX5_TSSCOLOR_DECALALPHA_2       ((D3DTA_TEXTURE << 0) | (D3DTA_CURRENT << 8) | (D3DTOP_BLENDTEXTUREALPHA << 16))
#define DX5_TSSCOLOR_DECALALPHA_3       ((D3DTA_DIFFUSE << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_BLENDTEXTUREALPHA << 16))
#define DX5_TSSCOLOR_DECALALPHA_4       ((D3DTA_CURRENT << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_BLENDTEXTUREALPHA << 16))

#define DX5_TSSALPHA_DECALALPHA_MASK_12 0x00FF00FF
#define DX5_TSSALPHA_DECALALPHA_1       ((D3DTA_DIFFUSE << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSALPHA_DECALALPHA_2       ((D3DTA_CURRENT << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSALPHA_DECALALPHA_MASK_34 0x00FFFF00
#define DX5_TSSALPHA_DECALALPHA_3       ((D3DTA_DIFFUSE << 8) | (D3DTOP_SELECTARG2 << 16))
#define DX5_TSSALPHA_DECALALPHA_4       ((D3DTA_CURRENT << 8) | (D3DTOP_SELECTARG2 << 16))

/*
 * DX5 D3DTBLEND_MODULATE equivalent texture stage state.
 */
#define DX5_TSSCOLOR_MODULATE_MASK      0x00FFFFFF
#define DX5_TSSCOLOR_MODULATE_1         ((D3DTA_TEXTURE << 0) | (D3DTA_DIFFUSE << 8) | (D3DTOP_MODULATE << 16))
#define DX5_TSSCOLOR_MODULATE_2         ((D3DTA_TEXTURE << 0) | (D3DTA_CURRENT << 8) | (D3DTOP_MODULATE << 16))
#define DX5_TSSCOLOR_MODULATE_3         ((D3DTA_DIFFUSE << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_MODULATE << 16))
#define DX5_TSSCOLOR_MODULATE_4         ((D3DTA_CURRENT << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_MODULATE << 16))


#define DX5_TSSALPHA_MODULATE_MASK_1    0x00FF00FF
#define DX5_TSSALPHA_MODULATE_1         ((D3DTA_TEXTURE << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSALPHA_MODULATE_MASK_2    0x00FFFF00
#define DX5_TSSALPHA_MODULATE_2         ((D3DTA_TEXTURE << 8) | (D3DTOP_SELECTARG2 << 16))

#define DX5_TSSALPHA_MODULATE_MASK_34   0x00FFFF00
#define DX5_TSSALPHA_MODULATE_3         ((D3DTA_DIFFUSE << 8) | (D3DTOP_SELECTARG2 << 16))
#define DX5_TSSALPHA_MODULATE_4         ((D3DTA_CURRENT << 8) | (D3DTOP_SELECTARG2 << 16))

#define DX5_TSSALPHA_MODULATE_MASK_56   0x00FF00FF
#define DX5_TSSALPHA_MODULATE_5         ((D3DTA_DIFFUSE << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSALPHA_MODULATE_6         ((D3DTA_CURRENT << 0) | (D3DTOP_SELECTARG1 << 16))

/*
 * DX5 D3DTBLEND_MODULATEALPHA equivalent texture stage state.
 */
#define DX5_TSSALPHA_MODULATEALPHA_MASK 0x00FFFFFF
#define DX5_TSSALPHA_MODULATEALPHA_1    ((D3DTA_TEXTURE << 0) | (D3DTA_DIFFUSE << 8) | (D3DTOP_MODULATE << 16))
#define DX5_TSSALPHA_MODULATEALPHA_2    ((D3DTA_TEXTURE << 0) | (D3DTA_CURRENT << 8) | (D3DTOP_MODULATE << 16))
#define DX5_TSSALPHA_MODULATEALPHA_3    ((D3DTA_DIFFUSE << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_MODULATE << 16))
#define DX5_TSSALPHA_MODULATEALPHA_4    ((D3DTA_CURRENT << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_MODULATE << 16))

/*
 * DX5 D3DTBLEND_ADD equivalent texture stage state.
 */
#define DX5_TSSCOLOR_ADD_MASK           0x00FFFFFF
#define DX5_TSSCOLOR_ADD_1              ((D3DTA_TEXTURE << 0) | (D3DTA_DIFFUSE << 8) | (D3DTOP_ADD << 16))
#define DX5_TSSCOLOR_ADD_2              ((D3DTA_TEXTURE << 0) | (D3DTA_CURRENT << 8) | (D3DTOP_ADD << 16))
#define DX5_TSSCOLOR_ADD_3              ((D3DTA_DIFFUSE << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_ADD << 16))
#define DX5_TSSCOLOR_ADD_4              ((D3DTA_CURRENT << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_ADD << 16))

#define DX5_TSSALPHA_ADD_MASK_12        0x00FF00FF
#define DX5_TSSALPHA_ADD_1              ((D3DTA_DIFFUSE << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSALPHA_ADD_2              ((D3DTA_CURRENT << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSALPHA_ADD_MASK_34        0x00FFFF00
#define DX5_TSSALPHA_ADD_3              ((D3DTA_DIFFUSE << 8) | (D3DTOP_SELECTARG2 << 16))
#define DX5_TSSALPHA_ADD_4              ((D3DTA_CURRENT << 8) | (D3DTOP_SELECTARG2 << 16))

//-------------------------------------------------------------------------------------

BOOL nvConvertTextureStageToDX5Class
(
)
{
    BOOL                    bAlphaTexture;
    DWORD                   tssAlphaBlend, tssColorBlend;
    DWORD                   dwMinFilter, dwMagFilter;
    DWORD                   dwTBlend;
    DWORD                   dwTexture;
    PNVD3DTEXTURE           pTexture;
    PNVD3DTEXSTAGESTATE     ptssState0;
    PNVD3DMULTITEXTURESTATE pmtsState;


    ptssState0 = &pCurrentContext->tssState[0];
    pmtsState  = &pCurrentContext->mtsState;

    tssAlphaBlend = ((ptssState0->dwAlphaArg1 & 0x000000FF) << 0)
                  | ((ptssState0->dwAlphaArg2 & 0x000000FF) << 8)
                  | ((ptssState0->dwAlphaOp & 0x000000FF) << 16);
    tssColorBlend = ((ptssState0->dwColorArg1 & 0x000000FF) << 0)
                  | ((ptssState0->dwColorArg2 & 0x000000FF) << 8)
                  | ((ptssState0->dwColorOp & 0x000000FF) << 16);

    /*
     * Save off the current texture handle.  This may be changed under some circumstances.
     * MUST BE RESTORED BEFORE EXITING ROUTINE.
     */
    dwTexture = pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE];

    /*
     * Determine if the single texture stage can be converted to a DX5 TEXTUREMAPBLEND state.
     */
    if (ptssState0->dwColorOp != D3DTOP_DISABLE)
    {
        if ((((tssColorBlend & DX5_TSSCOLOR_DECAL_MASK_1) == DX5_TSSCOLOR_DECAL_1) ||
             ((tssColorBlend & DX5_TSSCOLOR_DECAL_MASK_2) == DX5_TSSCOLOR_DECAL_2))
         && (((tssAlphaBlend & DX5_TSSALPHA_DECAL_MASK_1) == DX5_TSSALPHA_DECAL_1) ||
             ((tssAlphaBlend & DX5_TSSALPHA_DECAL_MASK_2) == DX5_TSSALPHA_DECAL_2)))
        {
            /*
             * TEXTUREMAPBLEND equivalent is DECAL.
             */
            dwTBlend = D3DTBLEND_DECAL;
        }
        else if ((((tssColorBlend & DX5_TSSCOLOR_DECALALPHA_MASK) == DX5_TSSCOLOR_DECALALPHA_1) ||
                  ((tssColorBlend & DX5_TSSCOLOR_DECALALPHA_MASK) == DX5_TSSCOLOR_DECALALPHA_2) ||
                  ((tssColorBlend & DX5_TSSCOLOR_DECALALPHA_MASK) == DX5_TSSCOLOR_DECALALPHA_3) ||
                  ((tssColorBlend & DX5_TSSCOLOR_DECALALPHA_MASK) == DX5_TSSCOLOR_DECALALPHA_4))
              && (((tssAlphaBlend & DX5_TSSALPHA_DECALALPHA_MASK_12) == DX5_TSSALPHA_DECALALPHA_1) ||
                  ((tssAlphaBlend & DX5_TSSALPHA_DECALALPHA_MASK_12) == DX5_TSSALPHA_DECALALPHA_2) ||
                  ((tssAlphaBlend & DX5_TSSALPHA_DECALALPHA_MASK_34) == DX5_TSSALPHA_DECALALPHA_3) ||
                  ((tssAlphaBlend & DX5_TSSALPHA_DECALALPHA_MASK_34) == DX5_TSSALPHA_DECALALPHA_4)))
        {
            /*
             * TEXTUREMAPBLEND equivalent is DECALALPHA.
             */
            dwTBlend = D3DTBLEND_DECALALPHA;
        }
        else if ((((tssColorBlend & DX5_TSSCOLOR_ADD_MASK) == DX5_TSSCOLOR_ADD_1) ||
                  ((tssColorBlend & DX5_TSSCOLOR_ADD_MASK) == DX5_TSSCOLOR_ADD_2) ||
                  ((tssColorBlend & DX5_TSSCOLOR_ADD_MASK) == DX5_TSSCOLOR_ADD_3) ||
                  ((tssColorBlend & DX5_TSSCOLOR_ADD_MASK) == DX5_TSSCOLOR_ADD_4))
              && (((tssAlphaBlend & DX5_TSSALPHA_ADD_MASK_12) == DX5_TSSALPHA_ADD_1) ||
                  ((tssAlphaBlend & DX5_TSSALPHA_ADD_MASK_12) == DX5_TSSALPHA_ADD_2) ||
                  ((tssAlphaBlend & DX5_TSSALPHA_ADD_MASK_34) == DX5_TSSALPHA_ADD_3) ||
                  ((tssAlphaBlend & DX5_TSSALPHA_ADD_MASK_34) == DX5_TSSALPHA_ADD_4)))
        {
            /*
             * TEXTUREMAPBLEND equivalent is ADD.
             */
            dwTBlend = D3DTBLEND_ADD;
        }
        else if (((tssColorBlend & DX5_TSSCOLOR_MODULATE_MASK) == DX5_TSSCOLOR_MODULATE_1) ||
                 ((tssColorBlend & DX5_TSSCOLOR_MODULATE_MASK) == DX5_TSSCOLOR_MODULATE_2) ||
                 ((tssColorBlend & DX5_TSSCOLOR_MODULATE_MASK) == DX5_TSSCOLOR_MODULATE_3) ||
                 ((tssColorBlend & DX5_TSSCOLOR_MODULATE_MASK) == DX5_TSSCOLOR_MODULATE_4))
        {
            bAlphaTexture = FALSE;
            if (pTexture = (PNVD3DTEXTURE)dwTexture)
            {
                bAlphaTexture = ((pTexture->dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A1R5G5B5)
                              || (pTexture->dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A4R4G4B4)
                              || (pTexture->dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A8R8G8B8));
            }
            if (((tssAlphaBlend & DX5_TSSALPHA_MODULATEALPHA_MASK) == DX5_TSSALPHA_MODULATEALPHA_1) ||
                ((tssAlphaBlend & DX5_TSSALPHA_MODULATEALPHA_MASK) == DX5_TSSALPHA_MODULATEALPHA_2) ||
                ((tssAlphaBlend & DX5_TSSALPHA_MODULATEALPHA_MASK) == DX5_TSSALPHA_MODULATEALPHA_3) ||
                ((tssAlphaBlend & DX5_TSSALPHA_MODULATEALPHA_MASK) == DX5_TSSALPHA_MODULATEALPHA_4))
            {
                /*
                 * TEXTUREMAPBLEND equivalent is MODULATEALPHA.
                 */
                dwTBlend = D3DTBLEND_MODULATEALPHA;
            }
            else if (((tssAlphaBlend & DX5_TSSALPHA_MODULATE_MASK_1) == DX5_TSSALPHA_MODULATE_1) ||
                     ((tssAlphaBlend & DX5_TSSALPHA_MODULATE_MASK_2) == DX5_TSSALPHA_MODULATE_2))
            {
                /*
                 * TEXTUREMAPBLEND equqivalent is MODULATE and the texture has an alpha component,
                 * so program the DX5 class with MODULATE.
                 * However, if there is no texture selected, the DX5 class should be programmed as
                 * MODULATEALPHA to use the vertex alpha values.
                 */
                if (!pTexture)
                    dwTBlend = D3DTBLEND_MODULATEALPHA;
                else
                    dwTBlend = D3DTBLEND_MODULATE;
            }
            else if (((!bAlphaTexture) || (!pTexture))
                  && (((tssAlphaBlend & DX5_TSSALPHA_MODULATE_MASK_34) == DX5_TSSALPHA_MODULATE_3) ||
                      ((tssAlphaBlend & DX5_TSSALPHA_MODULATE_MASK_34) == DX5_TSSALPHA_MODULATE_4) ||
                      ((tssAlphaBlend & DX5_TSSALPHA_MODULATE_MASK_56) == DX5_TSSALPHA_MODULATE_5) ||
                      ((tssAlphaBlend & DX5_TSSALPHA_MODULATE_MASK_56) == DX5_TSSALPHA_MODULATE_6)))
            {
                /*
                 * When the TEXTUREMAPBLEND equivalent is MODULATE but the texture format does
                 * not have an alpha component, need to program the DX5 class as MODULATEALPHA.
                 */
                dwTBlend = D3DTBLEND_MODULATEALPHA;
            }
            else
                return (FALSE);
        }
        else
            return (FALSE);
    }
    else
    {
        /*
         * When stage 0 is disabled, force DX5 setup with no texture.
         */
        pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] = 0;
        nvCalculateHardwareStateDX5(D3DTBLEND_MODULATEALPHA, D3DFILTER_NEAREST, D3DFILTER_NEAREST, TRUE);
        pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] = dwTexture;
        return (TRUE);
    }

    /*
     * Calculate the MIN and MAG filters from the texture stage state.
     */
    /*
     * Need to calculate the MIN and MAG filters.
     */
    switch (ptssState0->dwMagFilter)
    {
        case D3DTFG_POINT:
            dwMagFilter = D3DFILTER_NEAREST;
            break;
        case D3DTFG_LINEAR:
            dwMagFilter = D3DFILTER_LINEAR;
            break;
        default:
            dwMagFilter = D3DFILTER_LINEAR;
            break;
    }
    if (ptssState0->dwMipFilter == D3DTFP_NONE)
    {
        switch (ptssState0->dwMinFilter)
        {
            case D3DTFN_POINT:
                dwMinFilter = D3DFILTER_NEAREST;
                break;
            case D3DTFN_LINEAR:
                dwMinFilter = D3DFILTER_LINEAR;
                break;
            default:
                dwMinFilter = D3DFILTER_LINEAR;
                break;
        }
    }
    else if (ptssState0->dwMipFilter == D3DTFP_POINT)
    {
        switch (ptssState0->dwMinFilter)
        {
            case D3DTFN_POINT:
                dwMinFilter = D3DFILTER_MIPNEAREST;
                break;
            case D3DTFN_LINEAR:
                dwMinFilter = D3DFILTER_MIPLINEAR;
                break;
            default:
                dwMinFilter = D3DFILTER_MIPLINEAR;
                break;
        }
    }
    else
    {
        switch (ptssState0->dwMinFilter)
        {
            case D3DTFN_POINT:
                dwMinFilter = D3DFILTER_LINEARMIPNEAREST;
                break;
            case D3DTFN_LINEAR:
                dwMinFilter = D3DFILTER_LINEARMIPLINEAR;
                break;
            default:
                dwMinFilter = D3DFILTER_LINEARMIPLINEAR;
                break;
        }
    }

    /*
     * Need to track down the mipmap level that the application wants to start from.
     */
    if (pTexture = (PNVD3DTEXTURE)dwTexture)
        NV_LOCK_TEXTURE_SURFACE(pTexture);

    if ((pTexture) && (pTexture->lpLcl)
     && (pTexture->lpLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP)
     && (ptssState0->dwMaxMipLevel)
     && (ptssState0->dwMaxMipLevel < pTexture->dwMipMapLevels))
    {
        DWORD   i;

        for (i = 0; i < ptssState0->dwMaxMipLevel; i++)
            pTexture = (PNVD3DTEXTURE)pTexture->lpLcl->lpAttachList->lpAttached->dwReserved1;

        /*
         * Update the render state handle for the starting mipmap level.
         */
        pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] = (DWORD)pTexture;
        NV_UNLOCK_TEXTURE_SURFACE(pTexture);
    }

    /*
     * All other state comes directly from the renderstate.
     * Build up the DX5 control state.
     */
    nvCalculateHardwareStateDX5(dwTBlend, dwMinFilter, dwMagFilter, TRUE);

    /*
     * Restore the original texture handle.
     */
    pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] = dwTexture;

    /*
     * Validate the inner loop hardware control registers.
     */
    dbgValidateControlRegisters(pCurrentContext);

    /*
     * This code is only enabled in the DEBUG build.
     * Display the hardware registers that were calculated.
     */
    dbgDisplayContextState(NVDBG_SHOW_DX5_CLASS_STATE, pCurrentContext);

    /*
     * Determine the UV coordinate offset for the first stage.
     */
    pmtsState->dwUVOffset[0] = (2 * sizeof(D3DVALUE)) * ptssState0->dwTexCoordIndex;

    return (TRUE);
}

//-------------------------------------------------------------------------------------

void nvSetDx6MultiTextureState
(
    PNVD3DCONTEXT   pContext
)
{
    NVD3DMULTITEXTURESTATE *pState;
    NVD3DMULTITEXTURESTATE *pShadowState;

    /*
     * AA semantics check - I hate these
     */
    if (pContext->dwAntiAliasFlags & AA_ENABLED_MASK)
        pContext->dwAntiAliasFlags |= AA_MIX_DP_NOAA;
    else
        pContext->dwAntiAliasFlags |= AA_MIX_DP_AA;

    /*
     * we do not send state when we capture geometry for super sampled AA
     */
    if (pCurrentContext->dwAntiAliasFlags & AA_MODE_SUPER)
    {
        if (!(pCurrentContext->dwAntiAliasFlags & AA_CAPTURE_PUSHBUFFER))
        {
            return;
        }
    }

    while (nvFreeCount < (sizeSetObject + sizeDX6TriangleState))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeDX6TriangleState));

    /*
     * setup locals
     */
    pState       = &pCurrentContext->mtsState;
    pShadowState = &pCurrentContext->mtsShadowState;

    /*
     * Only write channel if it is not selected - avoids texture cache invalidates
     */
    if (pDriverData->dDrawSpareSubchannelObject != D3D_DX6_MULTI_TEXTURE_TRIANGLE)
    {
        /*
         * select object
         */
        nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_DX6_MULTI_TEXTURE_TRIANGLE);

        /*
         * program everything
         */
        nvglDx6TriangleOffset(nvFifo, nvFreeCount, NV_DD_SPARE,
                              pState->dwTextureOffset[0], 0);
        nvglDx6TriangleOffset(nvFifo, nvFreeCount, NV_DD_SPARE,
                              pState->dwTextureOffset[1], 1);
        nvglDx6TriangleFormat(nvFifo, nvFreeCount, NV_DD_SPARE,
                              pState->dwTextureFormat[0], 0);
        nvglDx6TriangleFormat(nvFifo, nvFreeCount, NV_DD_SPARE,
                              pState->dwTextureFormat[1], 1);
        nvglDx6TriangleFilter(nvFifo, nvFreeCount, NV_DD_SPARE,
                              pState->dwTextureFilter[0], 0);
        nvglDx6TriangleFilter(nvFifo, nvFreeCount, NV_DD_SPARE,
                              pState->dwTextureFilter[1], 1);
        nvglDx6TriangleStageState(nvFifo, nvFreeCount, NV_DD_SPARE,
                                  pState->dwCombine0Alpha, pState->dwCombine0Color,
                                  pState->dwCombine1Alpha, pState->dwCombine1Color,
                                  pState->dwCombineFactor, pState->dwBlend,
                                  pState->dwControl0,      pState->dwControl1,
                                  pState->dwControl2,      pState->dwFogColor);

        pDriverData->dDrawSpareSubchannelObject = D3D_DX6_MULTI_TEXTURE_TRIANGLE;

        /*
         * cache everything
         */
        *pShadowState = *pState;
    }
    else
    {
        if (pShadowState->dwTextureOffset[0] != pState->dwTextureOffset[0])
        {
            nvglDx6TriangleOffset(nvFifo, nvFreeCount, NV_DD_SPARE,
                                  pState->dwTextureOffset[0], 0);

            pShadowState->dwTextureOffset[0] = pState->dwTextureOffset[0];
        }

        if (pShadowState->dwTextureOffset[1] != pState->dwTextureOffset[1])
        {
            nvglDx6TriangleOffset(nvFifo, nvFreeCount, NV_DD_SPARE,
                                  pState->dwTextureOffset[1], 1);

            pShadowState->dwTextureOffset[1] = pState->dwTextureOffset[1];
        }

        if (pShadowState->dwTextureFormat[0] != pState->dwTextureFormat[0])
        {
            nvglDx6TriangleFormat(nvFifo, nvFreeCount, NV_DD_SPARE,
                                  pState->dwTextureFormat[0], 0);

            pShadowState->dwTextureFormat[0] = pState->dwTextureFormat[0];
        }

        if (pShadowState->dwTextureFormat[1] != pState->dwTextureFormat[1])
        {
            nvglDx6TriangleFormat(nvFifo, nvFreeCount, NV_DD_SPARE,
                                  pState->dwTextureFormat[1], 1);

            pShadowState->dwTextureFormat[1] = pState->dwTextureFormat[1];
        }

        if (pShadowState->dwTextureFilter[0] != pState->dwTextureFilter[0])
        {
            nvglDx6TriangleFilter(nvFifo, nvFreeCount, NV_DD_SPARE,
                                  pState->dwTextureFilter[0], 0);

            pShadowState->dwTextureFilter[0] = pState->dwTextureFilter[0];
        }

        if (pShadowState->dwTextureFilter[1] != pState->dwTextureFilter[1])
        {
            nvglDx6TriangleFilter(nvFifo, nvFreeCount, NV_DD_SPARE,
                                  pState->dwTextureFilter[1], 1);

            pShadowState->dwTextureFilter[1] = pState->dwTextureFilter[1];
        }

        /*
         * must be evaluated last
         */
        if ((pShadowState->dwCombine0Alpha != pState->dwCombine0Alpha)
         || (pShadowState->dwCombine0Color != pState->dwCombine0Color)
         || (pShadowState->dwCombine1Alpha != pState->dwCombine1Alpha)
         || (pShadowState->dwCombine1Color != pState->dwCombine1Color)
         || (pShadowState->dwCombineFactor != pState->dwCombineFactor)
         || (pShadowState->dwBlend         != pState->dwBlend        )
         || (pShadowState->dwControl0      != pState->dwControl0     )
         || (pShadowState->dwControl1      != pState->dwControl1     )
         || (pShadowState->dwControl2      != pState->dwControl2     )
         || (pShadowState->dwFogColor      != pState->dwFogColor     ))
        {
            nvglDx6TriangleStageState(nvFifo, nvFreeCount, NV_DD_SPARE,
                                      pState->dwCombine0Alpha, pState->dwCombine0Color,
                                      pState->dwCombine1Alpha, pState->dwCombine1Color,
                                      pState->dwCombineFactor, pState->dwBlend,
                                      pState->dwControl0,      pState->dwControl1,
                                      pState->dwControl2,      pState->dwFogColor);

            /*
             * cache everything - this is why this part is last
             */
            *pShadowState = *pState;
        }
    }

    return;
}

//-------------------------------------------------------------------------------------

/*
 * Validate the multi-texture rendering state.
 */
DWORD FAR PASCAL nvValidateTextureStageState
(
    LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA  pvtssd
)
{
    DWORD   i;

    pCurrentContext = (PNVD3DCONTEXT)pvtssd->dwhContext;
    if (!pCurrentContext)
    {
        return (DDHAL_DRIVER_HANDLED);
    }
    nvSetMultiTextureHardwareState();
    pvtssd->ddrval = pCurrentContext->mtsState.ddrval;

    /*
     * If returning DD_OK, then we can do this operation in 1 pass.
     * If returning an error, then who the heck knows.  Return an obnoxious number.
     */
    if (pvtssd->ddrval == DD_OK)
    {
        /*
         * Hardware setup didn't catch any problems, but there may be some things that we don't support that
         * hardware setup doesn't catch.  Check for them now.
         */
        for (i = 0; i < pCurrentContext->dwStageCount; i++)
        {
            if ((pCurrentContext->tssState[i].dwColorOp != D3DTOP_DISABLE)
             && ((pCurrentContext->tssState[i].dwAddressU == D3DTADDRESS_BORDER)
              || (pCurrentContext->tssState[i].dwAddressV == D3DTADDRESS_BORDER)))
            {
                pvtssd->ddrval      = D3DERR_CONFLICTINGRENDERSTATE;
                pvtssd->dwNumPasses = 0xFFFFFFFF;
                return (DDHAL_DRIVER_HANDLED);
            }
#ifdef DX7
            if ((pCurrentContext->tssState[i].dwColorArg1 == D3DTA_SPECULAR) ||
                (pCurrentContext->tssState[i].dwColorArg2 == D3DTA_SPECULAR))
            {
                pvtssd->ddrval      = D3DERR_UNSUPPORTEDCOLORARG;
                pvtssd->dwNumPasses = 0xFFFFFFFF;
                return (DDHAL_DRIVER_HANDLED);
            }

            if ((pCurrentContext->tssState[i].dwAlphaArg1 == D3DTA_SPECULAR) ||
                (pCurrentContext->tssState[i].dwAlphaArg2 == D3DTA_SPECULAR))
            {
                pvtssd->ddrval      = D3DERR_UNSUPPORTEDALPHAARG;
                pvtssd->dwNumPasses = 0xFFFFFFFF;
                return (DDHAL_DRIVER_HANDLED);
            }
#endif
        }
        /*
         * If the DX6 class is being used and colorkey is enabled, return an error.
         */
        if ((pCurrentContext->bUseDX6Class)
         && (pCurrentContext->dwRenderState[D3DRENDERSTATE_COLORKEYENABLE]))
        {
            pvtssd->ddrval      = D3DERR_CONFLICTINGRENDERSTATE;
            pvtssd->dwNumPasses = 0xFFFFFFFF;
            return (DDHAL_DRIVER_HANDLED);
        }
        pvtssd->dwNumPasses = 1;
    }
    else
        pvtssd->dwNumPasses = 0xFFFFFFFF;
    return (DDHAL_DRIVER_HANDLED);
}

/**************************** DX6 Multi Texture Setup************************\
*
* In all cases we can use one combiner for each TSS (when they map).
* So we can advertise that we handle 2 textures and 2 stages.
*
* At some point we may want to consider setup of the hardware to support
* 3 stages and sometimes even 4 stages into our 2 combiners.
*
* D3DTA_FACTOR    factor
* D3DTA_DIFFUSE   diffuse
* D3DTA_SPECULAR  ** error not supported **
* D3DTA_CURRENT   diffuse
* D3DTA_TEXTURE   Texture 0
*
* DX6 arg in stage 1 & ~(D3DTA_ALPHA | D3DTA_INV) NV4 arg for combiner 1
*
* D3DTA_FACTOR    factor
* D3DTA_DIFFUSE   diffuse
* D3DTA_SPECULAR  ** error not supported **
* D3DTA_CURRENT   input
* D3DTA_TEXTURE   Texture 1
*
* If (DX6arg & D3DTA_ALPHA) NV4arg |= alpha
* If (DX6arg & D3DTA_INV) NV4arg |= inv
*
* Map the DX6 Arguments and operations as follows:
*
* DX6op                     | NV4op         | NV4arg1            | NV4arg2          | NV4arg3      | NV4arg4
* ==========================+===============+====================+==================+==============+===============
* Selectarg1                | Add           | Arg1               | Inv | zero       | Zero         | Zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Selectarg2                | Add           | Arg2               | Inv | zero       | Zero         | Zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Modulate                  | Add           | Arg1               | Arg2             | Zero         | Zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Modulate2x                | Add           | Arg1               | Arg2             | Arg1         | Arg2
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Modulate4x                | Add2          | Arg1               | Arg2             | Arg1         | Arg2
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Add                       | Add           | Arg1               | Inv | zero       | Arg2         | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Addsigned                 | Addsigned     | Arg1               | Inv | zero       | Arg2         | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Addsigned2x               | Addsigned2    | Arg1               | Inv | zero       | Arg2         | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Addsmoth                  | Add           | Arg1               | Inv | zero       | Inv | Arg1   | Arg2
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Subtract                  | addcomplement | Arg1 | inv         | Inv | zero       | Arg2         | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* blenddiffusealpha         | Add           | Arg1               | Alpha | diffuse  | Arg2         | Inv | alpha |
*                           |               |                    |                  |              | diffuse
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Blendtexturealpha         | Add           | Arg1               | Alpha | tex<0|1> | Arg2         | Inv | alpha |
*                           |               |                    |                  |              | tex<0|1>
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Blendfactoralpha          | Add           | Arg1               | Alpha | factor   | Arg2         | Inv | alpha |
*                           |               |                    |                  |              | factor
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Blendtexturealphapm       | Add           | Arg1               | Inv | zero       | Arg2         | Inv | alpha |
*                           |               |                    |                  |              | texture
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Blendcurrentalpha         | Add           | Arg1               | Alpha | input    | Arg2         | Inv | alpha |
*                           |               |                    |                  |              | diffuse
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* premodulate               | ** error **   |                    |                  |              |
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* MODULATEALPHA_ADDCOLOR    | Add           | Arg1 | alpha       | Arg2             | Arg1         | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* MODULATECOLOR_ADDALPHA    | Add           | Arg1               | Arg2             | Arg1 | alpha | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* MODULATEINVALPHA_ADDCOLOR | Add           | Arg1 | alpha | inv | Arg2             | Arg1         | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* MODULATEINVCOLOR_ADDALPHA | Add           | Arg1 | inv         | Arg2             | Arg1 | alpha | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* BUMPENVMAP                | ** error **   |                    |                  |              |
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* BUMPENVMAPLUMINANCE       | ** error **   |                    |                  |              |
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* BUMPMAPLIGHT              | ** error **   |                    |                  |              |
* ==========================+===============+====================+==================+==============+===============
*
\****************************************************************************/

BOOL nvCheckStencilBuffer
(
    void
)
{
    /*
     * If the rendering surface is 16bpp, then there can't be a stencil buffer.
     */
    if ((pCurrentContext->dwSurfaceFormat == (DRF_DEF(053, _SET_FORMAT, _TYPE, _PITCH) |
                                              DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_X1R5G5B5_Z1R5G5B5)))
     || (pCurrentContext->dwSurfaceFormat == (DRF_DEF(053, _SET_FORMAT, _TYPE, _PITCH) |
                                              DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_R5G6B5))))
        return (FALSE);

    /*
     * If there is no Z-Buffer, then there can't be a stencil buffer.
     */
    if (!pCurrentContext->lpLclZ)
        return (FALSE);

    /*
     * Make sure Surface pixel format is specified.  If it's not, there can't
     * be a stencil buffer.
     */
    if (!(pCurrentContext->lpLclZ->dwFlags & DDRAWISURF_HASPIXELFORMAT))
        return (FALSE);

    /*
     * If the z-buffer pixel format does not specify a stencil buffer,
     * then there is no stencil buffer.
     */
    if (!(pCurrentContext->lpLclZ->lpGbl->ddpfSurface.dwFlags & DDPF_STENCILBUFFER))
        return (FALSE);

    /*
     * There is a stencil buffer and the rendering surface is 32bpp,
     * return whether the stencil buffer is enabled or not.
     */
    return (pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE]);
}

//-------------------------------------------------------------------------------------

void nvSetDX6TextureState
(
    DWORD                   dwTextureNum,
    PNVD3DTEXSTAGESTATE     ptssState,
    PNVD3DMULTITEXTURESTATE pmtsState
)
{
    DWORD           dwMagFilter;
    DWORD           dwMinFilter;
    DWORD           dwZOHMode, dwFOHMode;
    PNVD3DTEXTURE   pTexture;

    /*
     * setup state
     */
    dwZOHMode     = ((pDriverData->regTexelAlignment & REG_TA_ZOH_MASK) == REG_TA_ZOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_ZOH_CENTER : NV054_FORMAT_ORIGIN_ZOH_CORNER;
    dwFOHMode     = ((pDriverData->regTexelAlignment & REG_TA_FOH_MASK) == REG_TA_FOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_FOH_CENTER : NV054_FORMAT_ORIGIN_FOH_CORNER;

    if (pTexture = (PNVD3DTEXTURE)ptssState->dwTextureMap)
        NV_LOCK_TEXTURE_SURFACE(pTexture);
    if ((pTexture)
     && (pTexture->lpLcl))
    {
        if ((ptssState->dwMaxMipLevel)
         && (pTexture->lpLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP))
        {
            if (ptssState->dwMaxMipLevel < pTexture->dwMipMapLevels)
            {
                DWORD   i;
                /*
                 * Need to track down the mipmap level that the application wants to start from.
                 */
                for (i = 0; i < ptssState->dwMaxMipLevel; i++)
                    pTexture = (PNVD3DTEXTURE)pTexture->lpLcl->lpAttachList->lpAttached->dwReserved1;
            }
        }
#ifdef NV_TEX2
        pmtsState->dwTextureOffset[dwTextureNum] = TEX_SWIZZLE_OFFSET(pTexture,pTexture->dwTextureFlags);
#else
        pmtsState->dwTextureOffset[dwTextureNum] = pTexture->dwTextureOffset;
#endif
        pmtsState->dwTextureFormat[dwTextureNum] = DRF_NUM(055, _FORMAT, _CONTEXT_DMA,     pTexture->dwTextureContextDma)
                                                 | DRF_NUM(055, _FORMAT, _COLOR,           pTexture->dwTextureColorFormat)
                                                 | DRF_NUM(055, _FORMAT, _BASE_SIZE_U,     pTexture->dwMipMapBaseU)
                                                 | DRF_NUM(055, _FORMAT, _BASE_SIZE_V,     pTexture->dwMipMapBaseV)
                                                 | DRF_NUM(055, _FORMAT, _TEXTUREADDRESSU, ptssState->dwAddressU)
                                                 | DRF_NUM(055, _FORMAT, _WRAPU,           (DWORD)ptssState->bWrapU)
                                                 | DRF_NUM(055, _FORMAT, _TEXTUREADDRESSV, ptssState->dwAddressV)
                                                 | DRF_NUM(055, _FORMAT, _WRAPV,           (DWORD)ptssState->bWrapU);
        pmtsState->dwTextureFormat[dwTextureNum] |= DRF_NUM(055, _FORMAT, _ORIGIN_ZOH,     dwZOHMode)
                                                 |  DRF_NUM(055, _FORMAT, _ORIGIN_FOH,     dwFOHMode);

        /*
         * Need to calculate the MIN and MAG filters.
         */
        switch (ptssState->dwMagFilter)
        {
            case D3DTFG_POINT:
                dwMagFilter = D3DFILTER_NEAREST;
                break;
            case D3DTFG_LINEAR:
                dwMagFilter = D3DFILTER_LINEAR;
                break;
            case D3DTFG_ANISOTROPIC:
                dwMagFilter = D3DFILTER_LINEAR;
                pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(054, _FILTER, _KERNEL_SIZE_X,              0x1F)
                                                         |  DRF_NUM(054, _FILTER, _KERNEL_SIZE_Y,              0x1F)
                                                         |  DRF_DEF(054, _FILTER, _ANISOTROPIC_MAGNIFY_ENABLE, _TRUE);
                break;
            default:
                dwMagFilter = D3DFILTER_LINEAR;
                break;
        }
        if (ptssState->dwMipFilter == D3DTFP_NONE)
        {
            switch (ptssState->dwMinFilter)
            {
                case D3DTFN_POINT:
                    dwMinFilter = D3DFILTER_NEAREST;
                    break;
                case D3DTFN_LINEAR:
                    dwMinFilter = D3DFILTER_LINEAR;
                    break;
                case D3DTFN_ANISOTROPIC:
                    dwMinFilter = D3DFILTER_LINEAR;
                    pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(054, _FILTER, _KERNEL_SIZE_X,              0x1F)
                                                             |  DRF_NUM(054, _FILTER, _KERNEL_SIZE_Y,              0x1F)
                                                             |  DRF_DEF(054, _FILTER, _ANISOTROPIC_MINIFY_ENABLE,  _TRUE);
                    break;
                default:
                    dwMinFilter = D3DFILTER_LINEAR;
                    break;
            }
        }
        else if (ptssState->dwMipFilter == D3DTFP_POINT)
        {
            switch (ptssState->dwMinFilter)
            {
                case D3DTFN_POINT:
                    dwMinFilter = D3DFILTER_MIPNEAREST;
                    break;
                case D3DTFN_LINEAR:
                    dwMinFilter = D3DFILTER_MIPLINEAR;
                    break;
                case D3DTFN_ANISOTROPIC:
                    dwMinFilter = D3DFILTER_MIPLINEAR;
                    pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(054, _FILTER, _KERNEL_SIZE_X,              0x1F)
                                                             |  DRF_NUM(054, _FILTER, _KERNEL_SIZE_Y,              0x1F)
                                                             |  DRF_DEF(054, _FILTER, _ANISOTROPIC_MINIFY_ENABLE,  _TRUE);
                    break;
                default:
                    dwMinFilter = D3DFILTER_MIPLINEAR;
                    break;
            }
        }
        else
        {
            switch (ptssState->dwMinFilter)
            {
                case D3DTFN_POINT:
                    dwMinFilter = D3DFILTER_LINEARMIPNEAREST;
                    break;
                case D3DTFN_LINEAR:
                    dwMinFilter = D3DFILTER_LINEARMIPLINEAR;
                    break;
                case D3DTFN_ANISOTROPIC:
                    dwMinFilter = D3DFILTER_LINEARMIPLINEAR;
                    pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(054, _FILTER, _KERNEL_SIZE_X,              0x1F)
                                                             |  DRF_NUM(054, _FILTER, _KERNEL_SIZE_Y,              0x1F)
                                                             |  DRF_DEF(054, _FILTER, _ANISOTROPIC_MINIFY_ENABLE,  _TRUE);
                    break;
                default:
                    dwMinFilter = D3DFILTER_LINEARMIPLINEAR;
                    break;
            }
        }

        if ((pTexture->lpLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP)
         || (pTexture->dwMipMapLevels == 1))
        {
            /*
             * When this is a user supplied mipmap chain
             * OR the number of mipmap levels is 1 (i.e. no mipmaps, only base texture)
             * set the MIN/MAG filters as specified by the render states.
             */
            pmtsState->dwTextureFilter[dwTextureNum] |= DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _TRUE);
            pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(055, _FILTER, _TEXTUREMIN, dwMinFilter)
                                                     |  DRF_NUM(055, _FILTER, _TEXTUREMAG, dwMagFilter);

            /*
             * The only way to guarantee that mipmapping is disabled is to set MIPMAP_LEVELS to 1.
             * In cases where there are the user has supplied mipmaps but the minification filter is
             * set to D3DFILTER_NEAREST or D3DFILTER_LINEAR, force the mipmap levels field to be a 1.
             */
            if ((dwMinFilter == D3DFILTER_NEAREST)
             || (dwMinFilter == D3DFILTER_LINEAR))
                pmtsState->dwTextureFormat[dwTextureNum] |= DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS, 1);
            else
                pmtsState->dwTextureFormat[dwTextureNum] |= DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS, pTexture->dwMipMapLevels);
        }
        else
        {
#ifdef NV_TEX2
            if (pTexture->dwTextureFlags & NV4_TEXFLAG_AUTOMIPMAP)
#else
            if (pTexture->dwTextureFlags & NV4_TEXTURE_CAN_AUTO_MIPMAP)
#endif
            {
                /*
                 * This is the auto-generated mipmap case. In order to get the some sort of mipmapping
                 * to happen, the MIN/MAG filters must be modified if they are NEAREST or LINEAR.
                 */
                pmtsState->dwTextureFilter[dwTextureNum] |= DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _TRUE);
                pmtsState->dwTextureFormat[dwTextureNum] |= DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS, pTexture->dwMipMapLevels);

                /*
                 * Set the MINIFICATION filter.
                 */
                if (pDriverData->regAutoMipMapMethod == REG_AMMM_BILINEAR)
                {
                    if (dwMinFilter == D3DFILTER_NEAREST)
                        pmtsState->dwTextureFilter[dwTextureNum] |= DRF_DEF(055, _FILTER, _TEXTUREMIN, _MIPNEAREST);
                    else if (dwMinFilter == D3DFILTER_LINEAR)
                        pmtsState->dwTextureFilter[dwTextureNum] |= DRF_DEF(055, _FILTER, _TEXTUREMIN, _MIPLINEAR);
                    else
                        pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(055, _FILTER, _TEXTUREMIN, dwMinFilter);
                }
                else
                {
                    if (dwMinFilter == D3DFILTER_NEAREST)
                        pmtsState->dwTextureFilter[dwTextureNum] |= DRF_DEF(055, _FILTER, _TEXTUREMIN, _LINEARMIPNEAREST);
                    else if (dwMinFilter == D3DFILTER_LINEAR)
                        pmtsState->dwTextureFilter[dwTextureNum] |= DRF_DEF(055, _FILTER, _TEXTUREMIN, _LINEARMIPLINEAR);
                    else
                        pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(055, _FILTER, _TEXTUREMIN, dwMinFilter);
                }

                /*
                 * Set the MAGNIFICATION filter.
                 * Can only validly be set to NEAREST or LINEAR
                 */
                pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(055, _FILTER, _TEXTUREMAG, dwMagFilter);
            }
            else
            {
                /*
                 * This texture is flagged as not a auto-generated mipmapable texture.
                 */
                pmtsState->dwTextureFilter[dwTextureNum] |= DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _TRUE)
                                                         |  DRF_NUM(055, _FILTER, _TEXTUREMIN,    dwMinFilter)
                                                         |  DRF_NUM(055, _FILTER, _TEXTUREMAG,    dwMagFilter);
                pmtsState->dwTextureFormat[dwTextureNum] |= DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS, 1);
            }
        }
        dbgDisplayTexture(pCurrentContext, pTexture);
        NV_LOCK_TEXTURE_SURFACE(pTexture);
    }
    else
    {
        /*
         * There is no texture set the default texture format and offset.
         */
        pmtsState->dwTextureOffset[dwTextureNum] = pCurrentContext->dwDefaultTextureOffset;
        pmtsState->dwTextureFormat[dwTextureNum] = DRF_NUM(055, _FORMAT, _CONTEXT_DMA,     pCurrentContext->dwDefaultTextureContextDma)
                                                 | DRF_NUM(055, _FORMAT, _COLOR,           pCurrentContext->dwDefaultTextureColorFormat)
                                                 | DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS,   1)
                                                 | DRF_DEF(055, _FORMAT, _BASE_SIZE_U,     _1)
                                                 | DRF_DEF(055, _FORMAT, _BASE_SIZE_V,     _1)
                                                 | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSU, _CLAMP)
                                                 | DRF_DEF(055, _FORMAT, _WRAPU,           _FALSE)
                                                 | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSV, _CLAMP)
                                                 | DRF_DEF(055, _FORMAT, _WRAPV,           _FALSE);
        pmtsState->dwTextureFormat[dwTextureNum] |= DRF_NUM(055, _FORMAT, _ORIGIN_ZOH,     dwZOHMode)
                                                 |  DRF_NUM(055, _FORMAT, _ORIGIN_FOH,     dwFOHMode);



        /*
         * When there's no texture, always set for nearest (point sample) filtering.
         */
        pmtsState->dwTextureFilter[dwTextureNum] |= DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _FALSE)
                                                 |  DRF_DEF(055, _FILTER, _TEXTUREMIN,           _NEAREST)
                                                 |  DRF_DEF(055, _FILTER, _TEXTUREMAG,           _NEAREST);
    }

    /*
     * Setup stage texture filter
     */
    pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(055, _FILTER, _MIPMAPLODBIAS, (DWORD)ptssState->bLODBias);

    /*
     * Determine the UV coordinate offset for this texture stage.
     */
    pmtsState->dwUVOffset[dwTextureNum] = (2 * sizeof(D3DVALUE)) * ptssState->dwTexCoordIndex;
    return;
}

//-------------------------------------------------------------------------------------

void nvSetDX6State
(
    DWORD                   *pdwRenderState,
    PNVD3DMULTITEXTURESTATE  pmtsState
)
{
    DWORD   dwAlphaRef;
    DWORD   dwTexelOrigin;

    dwTexelOrigin = ((pDriverData->regTexelAlignment & REG_TA_TEXEL_MASK) == REG_TA_TEXEL_CENTER)
                  ? NV054_CONTROL_ORIGIN_CENTER : NV054_CONTROL_ORIGIN_CORNER;

    /*
     * Set the Combine Factor.
     */
    pmtsState->dwCombineFactor = pdwRenderState[D3DRENDERSTATE_TEXTUREFACTOR];

    /*
     * Setup Blend control.
     */
    pmtsState->dwBlend = DRF_DEF(055, _BLEND, _MASK_BIT,           _MSB)
                       | DRF_NUM(055, _BLEND, _SHADEMODE,          pdwRenderState[D3DRENDERSTATE_SHADEMODE])
                       | DRF_NUM(055, _BLEND, _TEXTUREPERSPECTIVE, pdwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE])
                       | DRF_NUM(055, _BLEND, _SPECULARENABLE,     pdwRenderState[D3DRENDERSTATE_SPECULARENABLE])
                       | DRF_NUM(055, _BLEND, _FOGENABLE,          pdwRenderState[D3DRENDERSTATE_FOGENABLE])
                       | DRF_NUM(055, _BLEND, _ALPHABLENDENABLE,   pdwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE]);

    if ((pdwRenderState[D3DRENDERSTATE_SRCBLEND]) == D3DBLEND_BOTHSRCALPHA)
        pmtsState->dwBlend |= DRF_DEF(055, _BLEND, _SRCBLEND,  _SRCALPHA)
                           |  DRF_DEF(055, _BLEND, _DESTBLEND, _INVSRCALPHA);
    else if ((pdwRenderState[D3DRENDERSTATE_SRCBLEND]) == D3DBLEND_BOTHINVSRCALPHA)
        pmtsState->dwBlend |= DRF_DEF(055, _BLEND, _SRCBLEND,  _INVSRCALPHA)
                           |  DRF_DEF(055, _BLEND, _DESTBLEND, _SRCALPHA);
    else
        pmtsState->dwBlend |= DRF_NUM(055, _BLEND, _SRCBLEND,  pdwRenderState[D3DRENDERSTATE_SRCBLEND])
                           |  DRF_NUM(055, _BLEND, _DESTBLEND, pdwRenderState[D3DRENDERSTATE_DESTBLEND]);

    /*
     * Setup Control0.
     */
    if (pdwRenderState[D3DRENDERSTATE_ALPHAREF] == 0x00010000)
        dwAlphaRef = 0xFF;
    else
        dwAlphaRef = (pdwRenderState[D3DRENDERSTATE_ALPHAREF] & 0x0000FF00)
                   ? (pdwRenderState[D3DRENDERSTATE_ALPHAREF] >> 8)
                   : (pdwRenderState[D3DRENDERSTATE_ALPHAREF] & 0x000000FF);
    pmtsState->dwControl0 = DRF_NUM(055, _CONTROL0, _ALPHAREF,             dwAlphaRef)
                          | DRF_NUM(055, _CONTROL0, _ALPHAFUNC,            pdwRenderState[D3DRENDERSTATE_ALPHAFUNC])
                          | DRF_NUM(055, _CONTROL0, _ALPHATESTENABLE,      pdwRenderState[D3DRENDERSTATE_ALPHATESTENABLE])
                          | DRF_NUM(055, _CONTROL0, _ORIGIN,               dwTexelOrigin)
#ifdef NV_CONTROLTRAFFIC
                          | DRF_NUM(055, _CONTROL0, _ZFUNC,                CTFunc(pdwRenderState[D3DRENDERSTATE_ZFUNC]))
#else
                          | DRF_NUM(055, _CONTROL0, _ZFUNC,                pdwRenderState[D3DRENDERSTATE_ZFUNC])
#endif
#ifdef NV_FASTLOOPS
                          | DRF_NUM(055, _CONTROL0, _CULLMODE,             D3DCULL_NONE)
#else
                          | DRF_NUM(055, _CONTROL0, _CULLMODE,             pdwRenderState[D3DRENDERSTATE_CULLMODE])
#endif
                          | DRF_NUM(055, _CONTROL0, _DITHERENABLE,         pdwRenderState[D3DRENDERSTATE_DITHERENABLE]);

    /*
     * Set Control0 z-buffer enable bits.
     */
    if ((pCurrentContext->lpLclZ)
     && (pdwRenderState[D3DRENDERSTATE_ZENABLE]))
    {
        if (pdwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_TRUE)
        {
            /*
             * Plain Z-Buffer.
             */
            pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ZENABLE,              _TRUE)
                                  |  DRF_NUM(055, _CONTROL0, _ZWRITEENABLE,         pdwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
                                  |  DRF_NUM(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, pDriverData->regZPerspectiveEnable)
                                  |  DRF_NUM(055, _CONTROL0, _Z_FORMAT,             pDriverData->regZFormat);
        }
        else
        {
            /*
             * W-Buffer.
             */
            pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ZENABLE,              _TRUE)
                                  |  DRF_NUM(055, _CONTROL0, _ZWRITEENABLE,         pdwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
                                  |  DRF_DEF(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, _TRUE)
                                  |  DRF_DEF(055, _CONTROL0, _Z_FORMAT,             _FIXED);
        }
    }
    else
    {
        pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ZENABLE,              _FALSE)
                              |  DRF_DEF(055, _CONTROL0, _ZWRITEENABLE,         _FALSE)
                              |  DRF_NUM(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, pDriverData->regZPerspectiveEnable)
                              |  DRF_NUM(055, _CONTROL0, _Z_FORMAT,             pDriverData->regZFormat);
    }
    /*
     * Set Control0 stencil buffer enable bits.
     */
    if (nvCheckStencilBuffer())
    {
        pmtsState->dwControl0 |= DRF_NUM(055, _CONTROL0, _STENCIL_WRITE_ENABLE, pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE]);
        /*
         * Setup Control1.
         * Stencil buffer control bits.
         */
        pmtsState->dwControl1 = DRF_NUM(055, _CONTROL1, _STENCIL_TEST_ENABLE, pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_FUNC,        pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILFUNC])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_REF,         pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILREF])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_READ,   pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILMASK])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_WRITE,  pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILWRITEMASK]);

        /*
         * Setup Control2.
         * More stencil buffer control bits.
         */
        pmtsState->dwControl2 = DRF_NUM(055, _CONTROL2, _STENCIL_OP_FAIL,  pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILFAIL])
                              | DRF_NUM(055, _CONTROL2, _STENCIL_OP_ZFAIL, pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILZFAIL])
                              | DRF_NUM(055, _CONTROL2, _STENCIL_OP_ZPASS, pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILPASS]);
    }
    else
    {
        pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _STENCIL_WRITE_ENABLE, _FALSE);
        /*
         * Setup Control1.
         * Stencil buffer control bits.
         */
        pmtsState->dwControl1 = DRF_DEF(055, _CONTROL1, _STENCIL_TEST_ENABLE, _FALSE)
                              | DRF_DEF(055, _CONTROL1, _STENCIL_FUNC,        _NEVER)
                              | DRF_NUM(055, _CONTROL1, _STENCIL_REF,         0)
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_READ,   0)
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_WRITE,  0);

        /*
         * Setup Control2.
         * More stencil buffer control bits.
         */
        pmtsState->dwControl2 = DRF_DEF(055, _CONTROL2, _STENCIL_OP_FAIL,  _KEEP)
                              | DRF_DEF(055, _CONTROL2, _STENCIL_OP_ZFAIL, _KEEP)
                              | DRF_DEF(055, _CONTROL2, _STENCIL_OP_ZPASS, _KEEP);
    }
    /*
     * Set ARGB write enbles.
     * Always enable RGB only enable Alpha for alpha frame buffers.
     */
//    if
//    else
    {
        pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ALPHA_WRITE_ENABLE, _FALSE);
    }
    pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _RED_WRITE_ENABLE,   _TRUE);
    pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _GREEN_WRITE_ENABLE, _TRUE);
    pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _BLUE_WRITE_ENABLE,  _TRUE);

    /*
     * Set the Fog color.
     */
    pmtsState->dwFogColor = pdwRenderState[D3DRENDERSTATE_FOGCOLOR];

    /*
     * Store fog table values as floats in the context structure.
     */
    pCurrentContext->dwFogTableMode   = pdwRenderState[D3DRENDERSTATE_FOGTABLEMODE];
    pCurrentContext->fFogTableStart   = *(float *)&pdwRenderState[D3DRENDERSTATE_FOGTABLESTART];
    pCurrentContext->fFogTableEnd     = *(float *)&pdwRenderState[D3DRENDERSTATE_FOGTABLEEND];
    pCurrentContext->fFogTableDensity = *(float *)&pdwRenderState[D3DRENDERSTATE_FOGTABLEDENSITY];
    if (pCurrentContext->dwFogTableMode == D3DFOG_LINEAR)
    {
        if (pCurrentContext->fFogTableEnd != pCurrentContext->fFogTableStart)
            pCurrentContext->fFogTableLinearScale = 1.0f / (pCurrentContext->fFogTableEnd - pCurrentContext->fFogTableStart);
        else
            pCurrentContext->fFogTableLinearScale = 0.0f;
    }
    return;
}

//-------------------------------------------------------------------------------------

void nvSetDefaultMultiTextureHardwareState
(
)
{
    DWORD                   dwZOHMode, dwFOHMode, dwTexelOrigin;
    DWORD                   dwTextureOffset;
    DWORD                   dwTextureContextDma;
    DWORD                   dwTextureColorFormat;
    DWORD                   dwMipMapLevels;
    DWORD                   dwMipMapBaseU;
    DWORD                   dwMipMapBaseV;
    PNVD3DTEXTURE           pTexture0;
    PNVD3DMULTITEXTURESTATE pmtsState;

    // txtodo - check texture valid for HW program

    dwZOHMode     = ((pDriverData->regTexelAlignment & REG_TA_ZOH_MASK) == REG_TA_ZOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_ZOH_CENTER : NV054_FORMAT_ORIGIN_ZOH_CORNER;
    dwFOHMode     = ((pDriverData->regTexelAlignment & REG_TA_FOH_MASK) == REG_TA_FOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_FOH_CENTER : NV054_FORMAT_ORIGIN_FOH_CORNER;
    dwTexelOrigin = ((pDriverData->regTexelAlignment & REG_TA_TEXEL_MASK) == REG_TA_TEXEL_CENTER)
                  ? NV054_CONTROL_ORIGIN_CENTER : NV054_CONTROL_ORIGIN_CORNER;

    /*
     * Grab texture from the render state array.  This is guaranteed to always have the
     * correct texture no matter if it was set using the render state method or the texture
     * stage 0 method.
     */
    pTexture0 = (PNVD3DTEXTURE)pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE];
    if (pTexture0)
    {
#ifdef NV_TEX2
        dwTextureOffset      = TEX_SWIZZLE_OFFSET(pTexture0,pTexture0->dwTextureFlags);
#else
        dwTextureOffset      = pTexture0->dwTextureOffset;
#endif
        dwTextureContextDma  = pTexture0->dwTextureContextDma;
        dwTextureColorFormat = pTexture0->dwTextureColorFormat;
        dwMipMapBaseU        = pTexture0->dwMipMapBaseU;
        dwMipMapBaseV        = pTexture0->dwMipMapBaseV;
        dwMipMapLevels       = pTexture0->dwMipMapLevels;
    }
    else
    {
        /*
         * No texture, setup default.
         */
        dwTextureOffset      = pCurrentContext->dwDefaultTextureOffset;
        dwTextureContextDma  = pCurrentContext->dwDefaultTextureContextDma;
        dwTextureColorFormat = pCurrentContext->dwDefaultTextureColorFormat;
        dwMipMapLevels       = 1;
        dwMipMapBaseU        = NV055_FORMAT_BASE_SIZE_U_1;
        dwMipMapBaseV        = NV055_FORMAT_BASE_SIZE_V_1;
    }

    pmtsState  = &pCurrentContext->mtsState;
    pmtsState->dwTextureOffset[0] =  dwTextureOffset;
    pmtsState->dwTextureFormat[0] =  DRF_NUM(055, _FORMAT, _CONTEXT_DMA,     dwTextureContextDma)
                                  |  DRF_NUM(055, _FORMAT, _COLOR,           dwTextureColorFormat)
                                  |  DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS,   dwMipMapLevels)
                                  |  DRF_NUM(055, _FORMAT, _BASE_SIZE_U,     dwMipMapBaseU)
                                  |  DRF_NUM(055, _FORMAT, _BASE_SIZE_V,     dwMipMapBaseV)
                                  |  DRF_DEF(055, _FORMAT, _TEXTUREADDRESSU, _CLAMP)
                                  |  DRF_DEF(055, _FORMAT, _WRAPU,           _FALSE)
                                  |  DRF_DEF(055, _FORMAT, _TEXTUREADDRESSV, _CLAMP)
                                  |  DRF_DEF(055, _FORMAT, _WRAPV,           _FALSE);
    pmtsState->dwTextureFormat[0] |= DRF_NUM(055, _FORMAT, _ORIGIN_ZOH,      dwZOHMode)
                                  |  DRF_NUM(055, _FORMAT, _ORIGIN_FOH,      dwFOHMode);
    pmtsState->dwTextureFilter[0] =  DRF_NUM(055, _FILTER, _KERNEL_SIZE_X, 0)
                                  |  DRF_NUM(055, _FILTER, _KERNEL_SIZE_Y, 0)
                                  |  DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _FALSE)
                                  |  DRF_DEF(055, _FILTER, _TEXTUREMIN,    _NEAREST)
                                  |  DRF_DEF(055, _FILTER, _ANISOTROPIC_MINIFY_ENABLE, _FALSE)
                                  |  DRF_DEF(055, _FILTER, _TEXTUREMAG,    _NEAREST)
                                  |  DRF_DEF(055, _FILTER, _ANISOTROPIC_MAGNIFY_ENABLE, _FALSE);

    pmtsState->dwTextureFilter[0] |= DRF_NUM(055, _FILTER, _MIPMAPLODBIAS, pDriverData->regLODBiasAdjust);

    pmtsState->dwTextureOffset[1] =  pCurrentContext->dwDefaultTextureOffset;
    pmtsState->dwTextureFormat[1] =  DRF_NUM(055, _FORMAT, _CONTEXT_DMA,      pCurrentContext->dwDefaultTextureContextDma)
                                  |  DRF_NUM(055, _FORMAT, _COLOR,            pCurrentContext->dwDefaultTextureColorFormat)
                                  |  DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS,    1)
                                  |  DRF_DEF(055, _FORMAT, _BASE_SIZE_U,     _1)
                                  |  DRF_DEF(055, _FORMAT, _BASE_SIZE_V,     _1)
                                  |  DRF_DEF(055, _FORMAT, _TEXTUREADDRESSU, _CLAMP)
                                  |  DRF_DEF(055, _FORMAT, _WRAPU,           _FALSE)
                                  |  DRF_DEF(055, _FORMAT, _TEXTUREADDRESSV, _CLAMP)
                                  |  DRF_DEF(055, _FORMAT, _WRAPV,           _FALSE);
    pmtsState->dwTextureFormat[1] |= DRF_NUM(055, _FORMAT, _ORIGIN_ZOH,      dwZOHMode)
                                  |  DRF_NUM(055, _FORMAT, _ORIGIN_FOH,      dwFOHMode);
    pmtsState->dwTextureFilter[1] =  DRF_NUM(055, _FILTER, _KERNEL_SIZE_X, 0)
                                  |  DRF_NUM(055, _FILTER, _KERNEL_SIZE_Y, 0)
                                  |  DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _TRUE)
                                  |  DRF_DEF(055, _FILTER, _TEXTUREMIN,    _NEAREST)
                                  |  DRF_DEF(055, _FILTER, _ANISOTROPIC_MINIFY_ENABLE, _FALSE)
                                  |  DRF_DEF(055, _FILTER, _TEXTUREMAG,    _NEAREST)
                                  |  DRF_DEF(055, _FILTER, _ANISOTROPIC_MAGNIFY_ENABLE, _FALSE);

    pmtsState->dwTextureFilter[1] |= DRF_NUM(055, _FILTER, _MIPMAPLODBIAS, pDriverData->regLODBiasAdjust);

    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_DEFAULT;
    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_DEFAULT;
    pmtsState->dwCombine1Alpha = DX6TRI_COMBINE0ALPHA_DEFAULT;;
    pmtsState->dwCombine1Color = DX6TRI_COMBINE0COLOR_DEFAULT;;

    pmtsState->dwCombineFactor = 0;
    pmtsState->dwBlend         = DRF_DEF(055, _BLEND, _MASK_BIT,           _MSB)
                               | DRF_NUM(055, _BLEND, _SHADEMODE,          pCurrentContext->dwRenderState[D3DRENDERSTATE_SHADEMODE])
                               | DRF_NUM(055, _BLEND, _TEXTUREPERSPECTIVE, pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE])
                               | DRF_NUM(055, _BLEND, _SPECULARENABLE,     pCurrentContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE])
                               | DRF_NUM(055, _BLEND, _FOGENABLE,          pCurrentContext->dwRenderState[D3DRENDERSTATE_FOGENABLE])
                               | DRF_NUM(055, _BLEND, _ALPHABLENDENABLE,   pCurrentContext->dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE]);

    if (pCurrentContext->dwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_BOTHSRCALPHA)
        pmtsState->dwBlend |= DRF_DEF(055, _BLEND, _SRCBLEND,  _SRCALPHA)
                           |  DRF_DEF(055, _BLEND, _DESTBLEND, _INVSRCALPHA);
    else if (pCurrentContext->dwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_BOTHINVSRCALPHA)
        pmtsState->dwBlend |= DRF_DEF(055, _BLEND, _SRCBLEND,  _INVSRCALPHA)
                           |  DRF_DEF(055, _BLEND, _DESTBLEND, _SRCALPHA);
    else
        pmtsState->dwBlend |= DRF_NUM(055, _BLEND, _SRCBLEND,  pCurrentContext->dwRenderState[D3DRENDERSTATE_SRCBLEND])
                           |  DRF_NUM(055, _BLEND, _DESTBLEND, pCurrentContext->dwRenderState[D3DRENDERSTATE_DESTBLEND]);

    pmtsState->dwControl0      = DRF_NUM(055, _CONTROL0, _ALPHAREF,             0)
                               | DRF_DEF(055, _CONTROL0, _ALPHAFUNC,            _ALWAYS)
                               | DRF_DEF(055, _CONTROL0, _ALPHATESTENABLE,      _FALSE)
                               | DRF_NUM(055, _CONTROL0, _ORIGIN,               dwTexelOrigin)
#ifdef NV_CONTROLTRAFFIC
                               | DRF_NUM(055, _CONTROL0, _ZFUNC,                CTFunc(pCurrentContext->dwRenderState[D3DRENDERSTATE_ZFUNC]))
#else
                               | DRF_NUM(055, _CONTROL0, _ZFUNC,                pCurrentContext->dwRenderState[D3DRENDERSTATE_ZFUNC])
#endif
#ifdef NV_FASTLOOPS
                               | DRF_NUM(055, _CONTROL0, _CULLMODE,             D3DCULL_NONE)
#else
                               | DRF_NUM(055, _CONTROL0, _CULLMODE,             pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE])
#endif
                               | DRF_NUM(055, _CONTROL0, _DITHERENABLE,         pCurrentContext->dwRenderState[D3DRENDERSTATE_DITHERENABLE]);
    if ((pCurrentContext->lpLclZ)
     && (pCurrentContext->dwRenderState[D3DRENDERSTATE_ZENABLE]))
    {
        if (pCurrentContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_TRUE)
        {
            /*
             * Plain Z-Buffer.
             */
            pmtsState->dwControl0 |= DRF_NUM(055, _CONTROL0, _ZENABLE,              pCurrentContext->dwRenderState[D3DRENDERSTATE_ZENABLE])
                                  |  DRF_NUM(055, _CONTROL0, _ZWRITEENABLE,         pCurrentContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
                                  |  DRF_NUM(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, pDriverData->regZPerspectiveEnable)
                                  |  DRF_NUM(055, _CONTROL0, _Z_FORMAT,             pDriverData->regZFormat);
        }
        else
        {
            /*
             * W-Buffer.
             */
            // Fixed point w-buffer reqires scaling of RHW but gives more precision in 16bit w-buffers.
            pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ZENABLE,              _TRUE)
                                  |  DRF_NUM(055, _CONTROL0, _ZWRITEENABLE,         pCurrentContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
                                  |  DRF_DEF(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, _TRUE)
                                  |  DRF_DEF(055, _CONTROL0, _Z_FORMAT,             _FIXED);
        }
    }
    else
    {
        pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ZENABLE,      _FALSE)
                              |  DRF_DEF(055, _CONTROL0, _ZWRITEENABLE, _FALSE);
    }
    pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ALPHA_WRITE_ENABLE,   _FALSE);
    pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _RED_WRITE_ENABLE,     _TRUE);
    pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _GREEN_WRITE_ENABLE,   _TRUE);
    pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _BLUE_WRITE_ENABLE,    _TRUE);
    if (nvCheckStencilBuffer())
    {
        pmtsState->dwControl0 |= DRF_NUM(055, _CONTROL0, _STENCIL_WRITE_ENABLE, pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE]);
        /*
         * Setup Control1.
         * Stencil buffer control bits.
         */
        pmtsState->dwControl1 = DRF_NUM(055, _CONTROL1, _STENCIL_TEST_ENABLE, pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_FUNC,        pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILFUNC])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_REF,         pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILREF])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_READ,   pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILMASK])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_WRITE,  pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILWRITEMASK]);

        /*
         * Setup Control2.
         * More stencil buffer control bits.
         */
        pmtsState->dwControl2 = DRF_NUM(055, _CONTROL2, _STENCIL_OP_FAIL,  pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILFAIL])
                              | DRF_NUM(055, _CONTROL2, _STENCIL_OP_ZFAIL, pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILZFAIL])
                              | DRF_NUM(055, _CONTROL2, _STENCIL_OP_ZPASS, pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILPASS]);
    }
    else
    {
        pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _STENCIL_WRITE_ENABLE, _FALSE);

        /*
         * Setup Control1.
         * Stencil buffer control bits.
         */
        pmtsState->dwControl1 = DRF_DEF(055, _CONTROL1, _STENCIL_TEST_ENABLE, _FALSE)
                              | DRF_DEF(055, _CONTROL1, _STENCIL_FUNC,        _NEVER)
                              | DRF_NUM(055, _CONTROL1, _STENCIL_REF,         0)
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_READ,   0)
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_WRITE,  0);

        /*
         * Setup Control2.
         * More stencil buffer control bits.
         */
        pmtsState->dwControl2 = DRF_DEF(055, _CONTROL2, _STENCIL_OP_FAIL,  _KEEP)
                              | DRF_DEF(055, _CONTROL2, _STENCIL_OP_ZFAIL, _KEEP)
                              | DRF_DEF(055, _CONTROL2, _STENCIL_OP_ZPASS, _KEEP);
    }
    pmtsState->dwFogColor = pCurrentContext->dwRenderState[D3DRENDERSTATE_FOGCOLOR];

    /*
     * Store fog table values as floats in the context structure.
     */
    pCurrentContext->dwFogTableMode   = pCurrentContext->dwRenderState[D3DRENDERSTATE_FOGTABLEMODE];
    pCurrentContext->fFogTableStart   = *(float *)&pCurrentContext->dwRenderState[D3DRENDERSTATE_FOGTABLESTART];
    pCurrentContext->fFogTableEnd     = *(float *)&pCurrentContext->dwRenderState[D3DRENDERSTATE_FOGTABLEEND];
    pCurrentContext->fFogTableDensity = *(float *)&pCurrentContext->dwRenderState[D3DRENDERSTATE_FOGTABLEDENSITY];
    if (pCurrentContext->dwFogTableMode == D3DFOG_LINEAR)
    {
        if (pCurrentContext->fFogTableEnd != pCurrentContext->fFogTableStart)
            pCurrentContext->fFogTableLinearScale = 1.0f / (pCurrentContext->fFogTableEnd - pCurrentContext->fFogTableStart);
        else
            pCurrentContext->fFogTableLinearScale = 0.0f;
    }
    return;
}

//-------------------------------------------------------------------------------------

void nvSetMultiTextureHardwareState
(
)
{
#ifdef  DEBUG
    BOOL                    bStage0UsesTexture = FALSE;
    BOOL                    bStage1UsesTexture = FALSE;
#endif  // DEBUG
    DWORD                   dwStageCount;
    DWORD                   dwStageOp;
    DWORD                   arg1Select, arg1Invert, arg1AlphaRep;
    DWORD                   arg2Select, arg2Invert, arg2AlphaRep;
    PNVD3DTEXSTAGESTATE     ptssState0, ptssState1, ptssState2, ptssState3;
    PNVD3DMULTITEXTURESTATE pmtsState;
    DWORD                  *pdwRenderState = 0;

#ifdef NV_STATS
    {
        extern DWORD dwHWPCount;
        dwHWPCount ++;
    }
#endif

    /*
     * This code is only enabled in the DEBUG build.
     * Display the DX5/DX6 render state to be calculated.
     */
    dbgDisplayContextState((NVDBG_SHOW_RENDER_STATE | NVDBG_SHOW_MTS_STATE), pCurrentContext);

    pdwRenderState = (DWORD *)pCurrentContext->dwRenderState;
    dwStageCount   = 0;
    ptssState0     = &pCurrentContext->tssState[0];
    ptssState1     = &pCurrentContext->tssState[1];
    pmtsState      = &pCurrentContext->mtsState;

    /*
     * Our bump mapping algorithm is done in a single pass with four texture
     * stages being specified.
     * This is the only four stage operation that we are supporting. Look
     * for it now and reject any other 4 stage operations.
     */
    if ((pCurrentContext->tssState[0].dwColorOp != D3DTOP_DISABLE)
     && (pCurrentContext->tssState[1].dwColorOp != D3DTOP_DISABLE)
     && (pCurrentContext->tssState[2].dwColorOp != D3DTOP_DISABLE)
     && (pCurrentContext->tssState[3].dwColorOp != D3DTOP_DISABLE)
     && (pCurrentContext->tssState[4].dwColorOp == D3DTOP_DISABLE))
    {
        ptssState2     = &pCurrentContext->tssState[2];
        ptssState3     = &pCurrentContext->tssState[3];

        /*
         * Make specific check for our version of bump mapping.
         *
         * THIS IS A VERY SPECIFIC CHECK FOR OUR BUMP MAPPING ALGORITHM.  ALL CONDITIONS MUST BE
         * TRUE OR WE WILL FAIL VALIDATION AND NOT RENDER ANYTHING PREDICTABLE.
         *
         * Even though D3D specifies that Arg2 cannot be a texture, since we used to do this for
         * our bump mapping algorithm, I'm going to continue to allow it so that we don't break
         * anything.
         */
        if ((ptssState0->dwAlphaOp != D3DTOP_SELECTARG1)
         || (ptssState0->dwAlphaArg1 != (D3DTA_TEXTURE | D3DTA_COMPLEMENT))
         || (ptssState0->dwColorOp == D3DTOP_DISABLE)
         || (ptssState0->dwTexCoordIndex != 0)
         || (ptssState1->dwAlphaOp != D3DTOP_ADDSIGNED)
         || (!((ptssState1->dwAlphaArg1 == D3DTA_TEXTURE)
            && (ptssState1->dwAlphaArg2 == D3DTA_CURRENT))
          && !((ptssState1->dwAlphaArg1 == D3DTA_CURRENT)
            && (ptssState1->dwAlphaArg2 == D3DTA_TEXTURE)))
         || (ptssState1->dwColorOp == D3DTOP_DISABLE)
         || (ptssState1->dwTexCoordIndex != 1)
         || (ptssState2->dwAlphaOp != D3DTOP_DISABLE)
         || (ptssState2->dwColorOp != D3DTOP_ADDSIGNED2X)
         || (ptssState2->dwColorArg1 != (D3DTA_CURRENT | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE))
         || (ptssState2->dwColorArg2 != D3DTA_DIFFUSE)
         || (ptssState3->dwAlphaOp != D3DTOP_DISABLE)
         || (ptssState3->dwColorOp != D3DTOP_MODULATE)
         || (ptssState3->dwColorArg1 != D3DTA_TEXTURE)
         || (ptssState3->dwTexCoordIndex != 0))
        {
            nvSetDefaultMultiTextureHardwareState();
            pCurrentContext->mtsState.bTSSValid = FALSE;
            pCurrentContext->mtsState.ddrval    = D3DERR_TOOMANYOPERATIONS;
            pCurrentContext->dwStageCount       = 1;
            pCurrentContext->bUseDX6Class       = FALSE;
            /*
             * Note that the state has changed and needs to be sent to the hardware.
             */
            NV_FORCE_TRI_SETUP(pCurrentContext);
            return;
        }
        /*
         * Set up Bump Mapping State.
         *
         * Texture0 and Texture1 comes from stage 0, 1 or 3 (always same texture).
         * Texture0 is used for stages with TEXCOORDINDEX = 0
         * Texture1 is used for stages with TEXCOORDINDEX = 1
         */
        nvSetDX6TextureState(0, ptssState0, pmtsState);
        nvSetDX6TextureState(1, ptssState1, pmtsState);
        pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_BUMP;
        pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_BUMP;
        pmtsState->dwCombine1Alpha = DX6TRI_COMBINE1ALPHA_BUMP;
        pmtsState->dwCombine1Color = DX6TRI_COMBINE1COLOR_BUMP;
        nvSetDX6State(pdwRenderState, pmtsState);
        /*
         *
         */
        pCurrentContext->mtsState.bTSSValid = TRUE;
        pCurrentContext->mtsState.ddrval    = DD_OK;
        /*
         * Enable use of multi-texture triangle class if there is more than one texture
         * stage or if the stencil buffer is enabled.
         */
        pCurrentContext->dwStageCount  = 4;
        pCurrentContext->bUseDX6Class  = TRUE;
        pCurrentContext->dwStateChange = FALSE;

        /*
         * This code is only enabled in the DEBUG build.
         * Display the hardware registers that were calculated.
         */
        dbgDisplayContextState(NVDBG_SHOW_DX6_CLASS_STATE, pCurrentContext);
        return;
    }

    /*
     * Clear out the current state.
     */
    pmtsState->dwTextureOffset[0] = 0;
    pmtsState->dwTextureOffset[1] = 0;
    pmtsState->dwTextureFormat[0] = 0;
    pmtsState->dwTextureFormat[1] = 0;
    pmtsState->dwTextureFilter[0] = 0;
    pmtsState->dwTextureFilter[1] = 0;
    pmtsState->dwCombine0Alpha    = 0;
    pmtsState->dwCombine0Color    = 0;
    pmtsState->dwCombine1Alpha    = 0;
    pmtsState->dwCombine1Color    = 0;
    pmtsState->dwBlend            = 0;
    pmtsState->dwControl0         = 0;
    pmtsState->dwControl1         = 0;
    pmtsState->dwControl2         = 0;
    pmtsState->dwFogColor         = 0;

    /*
     * If D3DRENDERSTATE_TEXTUREMAPBLEND was invoked more recently than TEXTURESTAGESTATE,
     * then use the current TEXTUREMAPBLEND setting.
     */
    if (pCurrentContext->bUseTBlendSettings)
    {
        if (!nvCheckStencilBuffer())
        {
            /*
             * When using TEXTUREMAPBLEND settings, as long as there is no stencil buffer we
             * can use the faster DX5 class.
             */
            nvSetHardwareState();
            pCurrentContext->bUseDX6Class       = FALSE;
            pCurrentContext->mtsState.bTSSValid = FALSE;
            pCurrentContext->dwStateChange      = FALSE;
        }
        else
        {
            DWORD   dwZOHMode, dwFOHMode;
            dwZOHMode = ((pDriverData->regTexelAlignment & REG_TA_ZOH_MASK) == REG_TA_ZOH_CENTER)
                      ? NV054_FORMAT_ORIGIN_ZOH_CENTER : NV054_FORMAT_ORIGIN_ZOH_CORNER;
            dwFOHMode = ((pDriverData->regTexelAlignment & REG_TA_FOH_MASK) == REG_TA_FOH_CENTER)
                      ? NV054_FORMAT_ORIGIN_FOH_CENTER : NV054_FORMAT_ORIGIN_FOH_CORNER;

            /*
             * Setup stage 0 texture offset
             * Setup stage 0 texture format
             */
            nvSetDX6TextureState(0, ptssState0, pmtsState);

            /*
             * Setup combine0 based on the TEXTUREMAPBLEND setting.
             */
            switch (pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREMAPBLEND])
            {
                case D3DTBLEND_DECAL:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_DECAL;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_DECAL;
                    break;

                case D3DTBLEND_MODULATE:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_MODULATE;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_MODULATE;
                    break;

                case D3DTBLEND_DECALALPHA:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_DECALALPHA;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_DECALALPHA;
                    break;

                case D3DTBLEND_MODULATEALPHA:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_MODULATEALPHA;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_MODULATEALPHA;
                    break;

                case D3DTBLEND_DECALMASK:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_DECALMASK;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_DECALMASK;
                    break;

                case D3DTBLEND_MODULATEMASK:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_MODULATEMASK;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_MODULATEMASK;
                    break;

                case D3DTBLEND_COPY:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_COPY;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_COPY;
                    break;

                case D3DTBLEND_ADD:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_ADD;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_ADD;
                    break;
            }

            /*
             * If there is no texture specified, then set to modulatealpha.
             */
            if (!pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE])
            {
                pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_MODULATEALPHA;
                pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_MODULATEALPHA;
            }

            /*
             * Set the default texture format and offset.
             */
            pmtsState->dwTextureOffset[1] = pCurrentContext->dwDefaultTextureOffset;
            pmtsState->dwTextureFormat[1] = DRF_NUM(055, _FORMAT, _CONTEXT_DMA,     pCurrentContext->dwDefaultTextureContextDma)
                                          | DRF_NUM(055, _FORMAT, _COLOR,           pCurrentContext->dwDefaultTextureColorFormat)
                                          | DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS,   1)
                                          | DRF_DEF(055, _FORMAT, _BASE_SIZE_U,     _1)
                                          | DRF_DEF(055, _FORMAT, _BASE_SIZE_V,     _1)
                                          | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSU, _CLAMP)
                                          | DRF_DEF(055, _FORMAT, _WRAPU,           _FALSE)
                                          | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSV, _CLAMP)
                                          | DRF_DEF(055, _FORMAT, _WRAPV,           _FALSE);
            pmtsState->dwTextureFormat[1] |= DRF_NUM(055, _FORMAT, _ORIGIN_ZOH,     dwZOHMode)
                                          |  DRF_NUM(055, _FORMAT, _ORIGIN_FOH,     dwFOHMode);

            /*
             * Setup stage texture filter
             */
            pmtsState->dwTextureFilter[1] = DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _TRUE)
                                          | DRF_NUM(055, _FILTER, _TEXTUREMIN, D3DFILTER_NEAREST)
                                          | DRF_NUM(055, _FILTER, _TEXTUREMAG, D3DFILTER_NEAREST);

            pmtsState->dwTextureFilter[1] |= DRF_NUM(055, _FILTER, _MIPMAPLODBIAS, pDriverData->regLODBiasAdjust);

            /*
             * Always set combine1 to pass through.
             */
            pmtsState->dwCombine1Alpha = DX6TRI_COMBINE1ALPHA_PASS_THRU;
            pmtsState->dwCombine1Color = DX6TRI_COMBINE1COLOR_PASS_THRU;

            /*
             * Use the first set of texture coordinates when disabled.
             */
            pmtsState->dwUVOffset[1] = 0;

            /*
             * Setup the rest of the DX6 triangle state.
             */
            nvSetDX6State(pdwRenderState, pmtsState);

            /*
             * Need to use the DX6 triangle class here.
             */
            pCurrentContext->bUseDX6Class       = TRUE;
            pCurrentContext->mtsState.bTSSValid = TRUE;
            pCurrentContext->dwStateChange      = FALSE;

            /*
             * This code is only enabled in the DEBUG build.
             * Display the hardware registers that were calculated.
             */
            dbgDisplayContextState(NVDBG_SHOW_DX6_CLASS_STATE, pCurrentContext);
        }

        pCurrentContext->mtsState.ddrval    = DD_OK;
        pCurrentContext->dwStageCount       = 1;
        /*
         * Note that the state has changed and needs to be sent to the hardware.
         */
        NV_FORCE_TRI_SETUP(pCurrentContext);
        return;
    }


    /*
     * Compile the hardware state for each texture stage.
     * Any errors during compile will result in disabling multi-textureing.
     *
     * Stage 0.
     */
    if (ptssState0->dwColorOp == D3DTOP_DISABLE)
    {
        /*
         * No texturing at all!
         */
        if (!nvCheckStencilBuffer())
        {
            nvConvertTextureStageToDX5Class();
            pCurrentContext->bUseDX6Class       = FALSE;
            pCurrentContext->mtsState.bTSSValid = FALSE;
            pCurrentContext->dwStateChange      = FALSE;
        }
        else
        {
            nvSetDefaultMultiTextureHardwareState();
            pCurrentContext->bUseDX6Class       = TRUE;
            pCurrentContext->mtsState.bTSSValid = TRUE;
        }
        pCurrentContext->mtsState.ddrval    = DD_OK;
        pCurrentContext->dwStageCount       = 1;

        /*
         * This code is only enabled in the DEBUG build.
         * Display the hardware registers that were calculated.
         */
        dbgDisplayContextState(NVDBG_SHOW_DX6_CLASS_STATE, pCurrentContext);

        /*
         * Note that the state has changed and needs to be sent to the hardware.
         */
        NV_FORCE_TRI_SETUP(pCurrentContext);
        return;
    }

    /*
     * Check for a texture stage state that can be handled by the DX5 class.
     */
    if ((ptssState1->dwColorOp == D3DTOP_DISABLE)
     && (!nvCheckStencilBuffer()))
    {
        /*
         * If there's only one texture stage, and no stencil buffer.
         * There's an opportunity to use the DX5 class for this
         * operation and get 2 Pixels per clock.
         */
        if (nvConvertTextureStageToDX5Class())
        {
            /*
             * Single texture stage was converted to DX5 class.
             * Use it instead.
             */
            pCurrentContext->bUseDX6Class  = FALSE;
            pCurrentContext->dwStateChange = FALSE;

            /*
             * Show that the DX6 class state is not calculated.
             */
            pCurrentContext->mtsState.bTSSValid = FALSE;
            pCurrentContext->mtsState.ddrval    = DD_OK;
            return;
        }
        if (ptssState0->dwAlphaOp != D3DTOP_DISABLE)
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "D3D:nvSetMultiTextureHardwareState - Single Texture Stage Using DX6 Class!!!");
    }

    /*
     * Setup stage 0 texture offset
     * Setup stage 0 texture format
     */
    nvSetDX6TextureState(0, ptssState0, pmtsState);

#ifdef NV_TEX2
    /*
     * setup current texture
     */
    pCurrentContext->pTexture0 = (PNVD3DTEXTURE)ptssState0->dwTextureMap;
#endif

    /*
     * Setup stage 0 Alpha Combiner.
     */
    dwStageOp = ptssState0->dwAlphaOp;
    switch (ptssState0->dwAlphaArg1 & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            if (ptssState0->dwTextureMap)
                arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE0;
            else
            {
                /*
                 * Disable Arg1 if there is no texture handle selected.
                 */
                arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
                dwStageOp  = D3DTOP_SELECTARG1;
            }
            break;
        case D3DTA_TFACTOR:
            arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_FACTOR;
            break;
    }
    arg1Invert = !((ptssState0->dwAlphaArg1 & D3DTA_COMPLEMENT) == 0);
    switch (ptssState0->dwAlphaArg2 & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            /*
             * D3DTA_TEXTURE isn't really a valid argument for Arg2.
             */
            if (ptssState0->dwTextureMap)
                arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE0;
            else
                arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_FACTOR;
            break;
    }
    arg2Invert = !((ptssState0->dwAlphaArg2 & D3DTA_COMPLEMENT) == 0);
#ifdef  DEBUG
    if ((arg1Select == NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE0)
     && (ptssState0->dwAlphaOp != D3DTOP_DISABLE)
     && (ptssState0->dwTextureMap))
        bStage0UsesTexture = TRUE;
#endif  // DEBUG
    switch (dwStageOp)
    {
        case D3DTOP_DISABLE:
            pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_DISABLE;
            break;
        case D3DTOP_SELECTARG1:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_SELECTARG2:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATE:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_1, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATE2X:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_3,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_3, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATE4X:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_3,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_3, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD2);
            break;
        case D3DTOP_ADD:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_ADDSIGNED:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADDSIGNED);
            break;
        case D3DTOP_ADDSIGNED2X:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADDSIGNED2);
            break;
        case D3DTOP_SUBTRACT:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_0_COLOR_INVERSE_0_INVERSE))
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADDCOMPLEMENT);
            break;
        case D3DTOP_ADDSMOOTH:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  (arg1Invert ^ NV055_COMBINE_0_ALPHA_INVERSE_2_INVERSE))
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_3,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_3, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDDIFFUSEALPHA:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _DIFFUSE)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _DIFFUSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDTEXTUREALPHA:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _TEXTURE0)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _TEXTURE0)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDFACTORALPHA:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _FACTOR)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _FACTOR)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDTEXTUREALPHAPM:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _TEXTURE0)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDCURRENTALPHA:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _DIFFUSE)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _DIFFUSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_PREMODULATE:
            if (ptssState1->dwColorOp != D3DTOP_DISABLE)
            {
                DWORD   arg1InvertStage1;
                DWORD   arg1SelectStage1;

#if 0
                /*
                 * When there is a second texture stage, stage 0 for PREMODULATE is defined as:
                 * Stage 0 arg1 * Stage 1 arg1
                 */
                switch (ptssState1->dwAlphaArg1 & D3DTA_SELECTMASK)
                {
                    case D3DTA_DIFFUSE:
                        arg1SelectStage1 = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
                        break;
                    case D3DTA_CURRENT:
                        arg1SelectStage1 = NV055_COMBINE_0_ALPHA_ARGUMENT_0_INPUT;
                        break;
                    case D3DTA_TEXTURE:
                        if (ptssState1->dwTextureMap)
                            arg1SelectStage1 = NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE1;
                        else
                            arg1SelectStage1 = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
                        break;
                    case D3DTA_TFACTOR:
                        arg1SelectStage1 = NV055_COMBINE_0_ALPHA_ARGUMENT_0_FACTOR;
                        break;
                }
                arg1InvertStage1 = !((ptssState1->dwAlphaArg1 & D3DTA_COMPLEMENT) == 0);
#else
                if (ptssState1->dwTextureMap)
                    arg1SelectStage1 = NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE1;
                else
                    arg1SelectStage1 = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
                arg1InvertStage1 = NV055_COMBINE_0_ALPHA_INVERSE_1_NORMAL;
#endif
                pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_1,  arg1InvertStage1)
                                           |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_1, arg1SelectStage1)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            }
            else
            {
                /*
                 * When second texture stage is disabled, this is the same as SELECTARG1.
                 */
                pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            }
            break;
        default:
            nvSetDefaultMultiTextureHardwareState();
            pCurrentContext->mtsState.bTSSValid = FALSE;
            pCurrentContext->mtsState.ddrval    = D3DERR_UNSUPPORTEDALPHAOPERATION;
            pCurrentContext->dwStageCount       = 1;
            if (!nvCheckStencilBuffer())
                pCurrentContext->bUseDX6Class       = FALSE;
            else
                pCurrentContext->bUseDX6Class       = TRUE;

            /*
             * This code is only enabled in the DEBUG build.
             * Display the hardware registers that were calculated.
             */
            dbgDisplayContextState(NVDBG_SHOW_DX6_CLASS_STATE, pCurrentContext);

            /*
             * Note that the state has changed and needs to be sent to the hardware.
             */
            NV_FORCE_TRI_SETUP(pCurrentContext);
            return;
    }


    /*
     * Setup stage 0 Color Combiner.
     */
    dwStageOp = ptssState0->dwColorOp;
    switch (ptssState0->dwColorArg1 & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            if (ptssState0->dwTextureMap)
                arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE0;
            else
            {
                /*
                 * Disable Arg1 if there is no texture handle selected.
                 */
                arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
                dwStageOp  = D3DTOP_SELECTARG1;
            }
            break;
        case D3DTA_TFACTOR:
            arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_FACTOR;
            break;
    }
    arg1Invert   = !((ptssState0->dwColorArg1 & D3DTA_COMPLEMENT) == 0);
    arg1AlphaRep = !((ptssState0->dwColorArg1 & D3DTA_ALPHAREPLICATE) == 0);
    switch (ptssState0->dwColorArg2 & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            /*
             * D3DTA_TEXTURE isn't really a valid argument for Arg2.
             */
            if (ptssState0->dwTextureMap)
                arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE0;
            else
                arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_FACTOR;
            break;
    }
    arg2Invert   = !((ptssState0->dwColorArg2 & D3DTA_COMPLEMENT) == 0);
    arg2AlphaRep = !((ptssState0->dwColorArg2 & D3DTA_ALPHAREPLICATE) == 0);
#ifdef  DEBUG
    if ((arg1Select == NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE0)
     && (ptssState0->dwColorOp != D3DTOP_DISABLE)
     && (ptssState0->dwTextureMap))
        bStage0UsesTexture = TRUE;
#endif  // DEBUG
    switch (dwStageOp)
    {
        case D3DTOP_DISABLE:
            pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_DISABLE;
            break;
        case D3DTOP_SELECTARG1:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_SELECTARG2:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATE:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATE2X:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_3,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_3,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_3, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATE4X:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_3,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_3,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_3, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD2);
            break;
        case D3DTOP_ADD:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_ADDSIGNED:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADDSIGNED);
            break;
        case D3DTOP_ADDSIGNED2X:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADDSIGNED2);
            break;
        case D3DTOP_SUBTRACT:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_0_COLOR_INVERSE_0_INVERSE))
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADDCOMPLEMENT);
            break;
        case D3DTOP_ADDSMOOTH:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  (arg1Invert ^ NV055_COMBINE_0_COLOR_INVERSE_2_INVERSE))
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_3,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_3,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_3, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDDIFFUSEALPHA:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _DIFFUSE)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _DIFFUSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDTEXTUREALPHA:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _TEXTURE0)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _TEXTURE0)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDFACTORALPHA:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _FACTOR)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _FACTOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDTEXTUREALPHAPM:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _TEXTURE0)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDCURRENTALPHA:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _DIFFUSE)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _DIFFUSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_PREMODULATE:
            if (ptssState1->dwColorOp != D3DTOP_DISABLE)
            {
                DWORD   arg1InvertStage1;
                DWORD   arg1AlphaRepStage1;
                DWORD   arg1SelectStage1;

#if 0
                /*
                 * When there is a second texture stage, stage 0 for PREMODULATE is defined as:
                 * Stage 0 arg1 * Stage 1 arg1
                 */
                switch (ptssState1->dwColorArg1 & D3DTA_SELECTMASK)
                {
                    case D3DTA_DIFFUSE:
                        arg1SelectStage1 = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
                        break;
                    case D3DTA_CURRENT:
                        arg1SelectStage1 = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
                        break;
                    case D3DTA_TEXTURE:
                        if (ptssState1->dwTextureMap)
                            arg1SelectStage1 = NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE1;
                        else
                            arg1SelectStage1 = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
                        break;
                    case D3DTA_TFACTOR:
                        arg1SelectStage1 = NV055_COMBINE_0_COLOR_ARGUMENT_0_FACTOR;
                        break;
                }
                arg1InvertStage1   = !((ptssState1->dwColorArg1 & D3DTA_COMPLEMENT) == 0);
                arg1AlphaRepStage1 = !((ptssState1->dwColorArg1 & D3DTA_ALPHAREPLICATE) == 0);
#else
                if (ptssState1->dwTextureMap)
                    arg1SelectStage1 = NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE1;
                else
                    arg1SelectStage1 = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
                arg1InvertStage1   = NV055_COMBINE_0_COLOR_INVERSE_1_NORMAL;
                arg1AlphaRepStage1 = NV055_COMBINE_0_COLOR_ALPHA_1_COLOR;
#endif
                pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg1InvertStage1)
                                           |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg1AlphaRepStage1)
                                           |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg1SelectStage1)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            }
            else
            {
                /*
                 * When second texture stage is disabled, this is the same as SELECTARG1.
                 */
                pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            }
            break;

        case D3DTOP_MODULATEALPHA_ADDCOLOR:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    _ALPHA)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATECOLOR_ADDALPHA:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    _ALPHA)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATEINVALPHA_ADDCOLOR:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_0_COLOR_INVERSE_0_INVERSE))
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    _ALPHA)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATEINVCOLOR_ADDALPHA:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_0_COLOR_INVERSE_0_INVERSE))
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    _ALPHA)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        default:
            nvSetDefaultMultiTextureHardwareState();
            pCurrentContext->mtsState.bTSSValid = FALSE;
            pCurrentContext->mtsState.ddrval    = D3DERR_UNSUPPORTEDCOLOROPERATION;
            pCurrentContext->dwStageCount       = 1;
            if (!nvCheckStencilBuffer())
                pCurrentContext->bUseDX6Class       = FALSE;
            else
                pCurrentContext->bUseDX6Class       = TRUE;

            /*
             * This code is only enabled in the DEBUG build.
             * Display the hardware registers that were calculated.
             */
            dbgDisplayContextState(NVDBG_SHOW_DX6_CLASS_STATE, pCurrentContext);

            /*
             * Note that the state has changed and needs to be sent to the hardware.
             */
            NV_FORCE_TRI_SETUP(pCurrentContext);
            return;
    }
    dwStageCount++;

    /*
     * Stage 1.
     */
    if (ptssState1->dwColorOp != D3DTOP_DISABLE)
    {
        nvSetDX6TextureState(1, ptssState1, pmtsState);

#ifdef NV_TEX2
        /*
         * setup current texture
         */
        pCurrentContext->pTexture1 = (PNVD3DTEXTURE)ptssState1->dwTextureMap;
#endif
        /*
         * Setup stage 1 Alpha Combiner.
         */
        dwStageOp = ptssState1->dwAlphaOp;
        switch (ptssState1->dwAlphaArg1 & D3DTA_SELECTMASK)
        {
            case D3DTA_DIFFUSE:
                arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_DIFFUSE;
                break;
            case D3DTA_CURRENT:
                arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_INPUT;
                break;
            case D3DTA_TEXTURE:
                if (ptssState1->dwTextureMap)
                    arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE1;
                else
                {
                    /*
                     * Disable Arg1 if there is no texture handle selected.
                     */
                    arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_INPUT;
//                    dwStageOp  = D3DTOP_SELECTARG1;
                }
                break;
            case D3DTA_TFACTOR:
                arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_FACTOR;
                break;
        }
        arg1Invert = !((ptssState1->dwAlphaArg1 & D3DTA_COMPLEMENT) == 0);
        switch (ptssState1->dwAlphaArg2 & D3DTA_SELECTMASK)
        {
            case D3DTA_DIFFUSE:
                arg2Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_DIFFUSE;
                break;
            case D3DTA_CURRENT:
                arg2Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_INPUT;
                break;
            case D3DTA_TEXTURE:
                /*
                 * D3DTA_TEXTURE isn't really a valid argument for Arg2.
                 */
                arg2Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE1;
                break;
            case D3DTA_TFACTOR:
                arg2Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_FACTOR;
                break;
        }
        arg2Invert = !((ptssState1->dwAlphaArg2 & D3DTA_COMPLEMENT) == 0);
#ifdef  DEBUG
        if ((arg1Select == NV055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE1)
         && (ptssState1->dwAlphaOp != D3DTOP_DISABLE)
         && (ptssState1->dwTextureMap))
            bStage1UsesTexture = TRUE;
#endif  // DEBUG
        switch (dwStageOp)
        {
            case D3DTOP_DISABLE:
                pmtsState->dwCombine1Alpha = DX6TRI_COMBINE1ALPHA_PASS_THRU;//DX6TRI_COMBINE1ALPHA_DISABLE;
                break;
            case D3DTOP_SELECTARG1:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_SELECTARG2:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATE:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_1, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATE2X:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_3,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_3, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATE4X:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_3,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_3, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD2);
                break;
            case D3DTOP_ADD:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_ADDSIGNED:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADDSIGNED);
                break;
            case D3DTOP_ADDSIGNED2X:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADDSIGNED2);
                break;
            case D3DTOP_SUBTRACT:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_0_COLOR_INVERSE_0_INVERSE))
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADDCOMPLEMENT);
                break;
            case D3DTOP_ADDSMOOTH:

                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  (arg1Invert ^ NV055_COMBINE_1_ALPHA_INVERSE_2_INVERSE))
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_3,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_3, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDDIFFUSEALPHA:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _DIFFUSE)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _DIFFUSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDTEXTUREALPHA:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _TEXTURE1)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _TEXTURE1)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDFACTORALPHA:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _FACTOR)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _FACTOR)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDTEXTUREALPHAPM:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _TEXTURE1)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDCURRENTALPHA:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _INPUT)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _INPUT)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_PREMODULATE:
                /*
                 * When premodulate is set on stage 1, this is the same as just a selctarg1 since we
                 * don't support more than 2 texture stages.
                 * It would seem rather silly to do this on stage 1 anyway because you lose whatever was
                 * set on stage 0.
                 */
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            default:
                nvSetDefaultMultiTextureHardwareState();
                pCurrentContext->mtsState.bTSSValid = FALSE;
                pCurrentContext->mtsState.ddrval    = D3DERR_UNSUPPORTEDALPHAOPERATION;
                pCurrentContext->dwStageCount       = 1;
                if (!nvCheckStencilBuffer())
                    pCurrentContext->bUseDX6Class       = FALSE;
                else
                    pCurrentContext->bUseDX6Class       = TRUE;

                /*
                 * This code is only enabled in the DEBUG build.
                 * Display the hardware registers that were calculated.
                 */
                dbgDisplayContextState(NVDBG_SHOW_DX6_CLASS_STATE, pCurrentContext);

                /*
                 * Note that the state has changed and needs to be sent to the hardware.
                 */
                NV_FORCE_TRI_SETUP(pCurrentContext);
                return;
        }

        /*
         * Setup stage 1 Color Combiner.
         */
        dwStageOp = ptssState1->dwColorOp;
        switch (ptssState1->dwColorArg1 & D3DTA_SELECTMASK)
        {
            case D3DTA_DIFFUSE:
                arg1Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_DIFFUSE;
                break;
            case D3DTA_CURRENT:
                arg1Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_INPUT;
                break;
            case D3DTA_TEXTURE:
                if (ptssState1->dwTextureMap)
                    arg1Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE1;
                else
                {
                    /*
                     * Disable Arg1 if there is no texture handle selected.
                     */
                    arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_INPUT;
//                    dwStageOp  = D3DTOP_SELECTARG1;
                }
                break;
            case D3DTA_TFACTOR:
                arg1Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_FACTOR;
                break;
        }
        arg1Invert   = !((ptssState1->dwColorArg1 & D3DTA_COMPLEMENT) == 0);
        arg1AlphaRep = !((ptssState1->dwColorArg1 & D3DTA_ALPHAREPLICATE) == 0);
        switch (ptssState1->dwColorArg2 & D3DTA_SELECTMASK)
        {
            case D3DTA_DIFFUSE:
                arg2Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_DIFFUSE;
                break;
            case D3DTA_CURRENT:
                arg2Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_INPUT;
                break;
            case D3DTA_TEXTURE:
                /*
                 * D3DTA_TEXTURE isn't really a valid argument for Arg2.
                 */
                arg2Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE1;
                break;
            case D3DTA_TFACTOR:
                arg2Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_FACTOR;
                break;
        }
        arg2Invert   = !((ptssState1->dwColorArg2 & D3DTA_COMPLEMENT) == 0);
        arg2AlphaRep = !((ptssState1->dwColorArg2 & D3DTA_ALPHAREPLICATE) == 0);
#ifdef  DEBUG
        if ((arg1Select == NV055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE1)
         && (ptssState1->dwColorOp != D3DTOP_DISABLE)
         && (ptssState1->dwTextureMap))
            bStage1UsesTexture = TRUE;
#endif  // DEBUG
        switch (dwStageOp)
        {
            case D3DTOP_DISABLE:
                pmtsState->dwCombine1Color = DX6TRI_COMBINE1COLOR_DISABLE;
                break;
            case D3DTOP_SELECTARG1:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_2,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_SELECTARG2:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_2,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATE:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_1,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_1, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_2,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATE2X:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_1,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_3,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_3,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_3, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATE4X:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_1,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_3,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_3,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_3, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD2);
                break;
            case D3DTOP_ADD:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_ADDSIGNED:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADDSIGNED);
                break;
            case D3DTOP_ADDSIGNED2X:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADDSIGNED2);
                break;
            case D3DTOP_SUBTRACT:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_0_COLOR_INVERSE_0_INVERSE))
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADDCOMPLEMENT);
                break;
            case D3DTOP_ADDSMOOTH:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  (arg1Invert ^ NV055_COMBINE_1_COLOR_INVERSE_2_INVERSE))
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_3,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_3,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_3, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDDIFFUSEALPHA:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _DIFFUSE)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _DIFFUSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDTEXTUREALPHA:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _TEXTURE1)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _TEXTURE1)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDFACTORALPHA:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _FACTOR)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _FACTOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDTEXTUREALPHAPM:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _TEXTURE1)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDCURRENTALPHA:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _INPUT)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _INPUT)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_PREMODULATE:
                /*
                 * When premodulate is set on stage 1, this is the same as just a selctarg1 since we
                 * don't support more than 2 texture stages.
                 * It would seem rather silly to do this on stage 1 anyway because you lose whatever was
                 * set on stage 0.
                 */
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_2,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATEALPHA_ADDCOLOR:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    _ALPHA)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_1,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATECOLOR_ADDALPHA:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_1,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    _ALPHA)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATEINVALPHA_ADDCOLOR:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_1_COLOR_INVERSE_0_INVERSE))
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    _ALPHA)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_1,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATEINVCOLOR_ADDALPHA:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_1_COLOR_INVERSE_0_INVERSE))
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_1,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    _ALPHA)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            default:
                nvSetDefaultMultiTextureHardwareState();
                pCurrentContext->mtsState.bTSSValid = FALSE;
                pCurrentContext->mtsState.ddrval    = D3DERR_UNSUPPORTEDCOLOROPERATION;
                pCurrentContext->dwStageCount       = 1;
                if (!nvCheckStencilBuffer())
                    pCurrentContext->bUseDX6Class       = FALSE;
                else
                    pCurrentContext->bUseDX6Class       = TRUE;

                /*
                 * This code is only enabled in the DEBUG build.
                 * Display the hardware registers that were calculated.
                 */
                dbgDisplayContextState(NVDBG_SHOW_DX6_CLASS_STATE, pCurrentContext);

                /*
                 * Note that the state has changed and needs to be sent to the hardware.
                 */
                NV_FORCE_TRI_SETUP(pCurrentContext);
                return;
        }
        dwStageCount++;
#ifdef  DEBUG
        if (bStage0UsesTexture && bStage1UsesTexture)
        {
            PNVD3DTEXTURE   pTexture0, pTexture1;
            pTexture0 = (PNVD3DTEXTURE)(ptssState0->dwTextureMap);
            pTexture1 = (PNVD3DTEXTURE)(ptssState1->dwTextureMap);
            if (pTexture0->dwTextureContextDma != pTexture1->dwTextureContextDma)
            {
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "D3D:nvSetMultiTextureHardwareState - Multi-Textures Memory Space Error!!");
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "        pTexture0 = %08lx,  Context = %08lx", ptssState0->dwTextureMap, pTexture0->dwTextureContextDma);
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "        pTexture1 = %08lx,  Context = %08lx", ptssState1->dwTextureMap, pTexture1->dwTextureContextDma);
                dbgD3DError();
            }
            else
            {
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "D3D:nvSetMultiTextureHardwareState - YEAH! Multi-Textures Memory Space OK!!");
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "        pTexture0 = %08lx,  Context = %08lx", ptssState0->dwTextureMap, pTexture0->dwTextureContextDma);
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "        pTexture1 = %08lx,  Context = %08lx", ptssState1->dwTextureMap, pTexture1->dwTextureContextDma);
            }
        }
#endif  // DEBUG
    }
    else
    {
        DWORD   dwZOHMode, dwFOHMode;
        dwZOHMode = ((pDriverData->regTexelAlignment & REG_TA_ZOH_MASK) == REG_TA_ZOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_ZOH_CENTER : NV054_FORMAT_ORIGIN_ZOH_CORNER;
        dwFOHMode = ((pDriverData->regTexelAlignment & REG_TA_FOH_MASK) == REG_TA_FOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_FOH_CENTER : NV054_FORMAT_ORIGIN_FOH_CORNER;

        /*
         * Set the default texture format and offset.
         */
        pmtsState->dwTextureOffset[1] = pCurrentContext->dwDefaultTextureOffset;
        pmtsState->dwTextureFormat[1] = DRF_NUM(055, _FORMAT, _CONTEXT_DMA,     pCurrentContext->dwDefaultTextureContextDma)
                                      | DRF_NUM(055, _FORMAT, _COLOR,           pCurrentContext->dwDefaultTextureColorFormat)
                                      | DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS,   1)
                                      | DRF_DEF(055, _FORMAT, _BASE_SIZE_U,     _1)
                                      | DRF_DEF(055, _FORMAT, _BASE_SIZE_V,     _1)
                                      | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSU, _CLAMP)
                                      | DRF_DEF(055, _FORMAT, _WRAPU,           _FALSE)
                                      | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSV, _CLAMP)
                                      | DRF_DEF(055, _FORMAT, _WRAPV,           _FALSE);
        pmtsState->dwTextureFormat[1] |= DRF_NUM(055, _FORMAT, _ORIGIN_ZOH,     dwZOHMode)
                                      |  DRF_NUM(055, _FORMAT, _ORIGIN_FOH,     dwFOHMode);

        /*
         * Setup stage texture filter
         */
        pmtsState->dwTextureFilter[1] = DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _TRUE)
                                      | DRF_NUM(055, _FILTER, _TEXTUREMIN, D3DFILTER_NEAREST)
                                      | DRF_NUM(055, _FILTER, _TEXTUREMAG, D3DFILTER_NEAREST);

        pmtsState->dwTextureFilter[1] |= DRF_NUM(055, _FILTER, _MIPMAPLODBIAS, pDriverData->regLODBiasAdjust);

        /*
         * No stage 1 texture blending.
         * Set the stage 1 combiners to something sane.
         */
        pmtsState->dwCombine1Alpha = DX6TRI_COMBINE1ALPHA_PASS_THRU;
        pmtsState->dwCombine1Color = DX6TRI_COMBINE1COLOR_PASS_THRU;

        /*
         * Use the first set of texture coordinates when disabled.
         */
        pmtsState->dwUVOffset[1] = 0;

#ifdef NV_TEX2
        /*
         * setup current texture
         */
        pCurrentContext->pTexture0 = NULL;
#endif
    }
    nvSetDX6State(pdwRenderState, pmtsState);

    /*
     * If stage 3 is not disabled, flag the error but the hardware will still
     * use the first two stages of setup.
     */
    if (pCurrentContext->tssState[2].dwColorOp != D3DTOP_DISABLE)
    {
        pCurrentContext->mtsState.bTSSValid = FALSE;
        pCurrentContext->mtsState.ddrval    = D3DERR_TOOMANYOPERATIONS;
        pCurrentContext->bUseDX6Class       = TRUE;

        /*
         * This code is only enabled in the DEBUG build.
         * Display the hardware registers that were calculated.
         */
        dbgDisplayContextState(NVDBG_SHOW_DX6_CLASS_STATE, pCurrentContext);

        return;
    }

    /*
     *
     */
    pCurrentContext->mtsState.bTSSValid = TRUE;
    pCurrentContext->mtsState.ddrval    = DD_OK;

    /*
     * Assume that the DX6 class is going to be used for rendering.
     * stage or if the stencil buffer is enabled.
     */
    pCurrentContext->bUseDX6Class  = TRUE;
    pCurrentContext->dwStateChange = FALSE;

    /*
     * This code is only enabled in the DEBUG build.
     * Display the hardware registers that were calculated.
     */
    dbgDisplayContextState(NVDBG_SHOW_DX6_CLASS_STATE, pCurrentContext);
    return;
}
#endif  // NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4tex.c ===
#ifdef  NV4
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4TEX.C                                                          *
*   HW Specific Texture routines.                                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/31/98 - re-wrote and cleaned up.     *
*       Ben de Waal                 10/12/98 - overhaul                     *
*                                                                           *
\***************************************************************************/
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv4dreg.h"
#include "nv3ddbg.h"
#include "nv4vxmac.h"
#include "nvheap.h"

#ifdef  MULTI_MON
#include "nvrmapi.h"
#include "nvrmarch.inc"
#include "nvos.h"
#endif  /* MULTI_MON */

/***************************************************************************\
  texture manager 2.0 implementation notes:

  * texture has one optional linear surface. Depending on its heap location
    the logic will use it to stage for AGP/PCI -> VID transfers. The linear
    surface is not maintained at all times. For AGP swizzled surfaces the
    linear surface will only be made valid for lock/unlocks and will be
    invalidated on Blts. This saves us from maintaining more than one surface
    with the CPU. If the swizzle surface is in VID the the linear surface
    can be used for staging during blt and it will stay valid.

  * texture has 1 or more swizzled surfaces. Only one surface is current at
    a time but the others retire lazily (and therefore more than one swizzled
    surface can be used at a time). The current surface might have mipmaps
    that is not carriend forward from the previous texture. In order to use
    them one must bring them forward. nvTextureRef takse care of this and is
    called before we render triangles

  * We maintain dirty rects for locks and blts

\***************************************************************************/

#ifndef WINNT
FLATPTR EXTERN_DDAPI DDHAL32_VidMemAlloc (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, DWORD dwXDim, DWORD dwYDim);
void EXTERN_DDAPI DDHAL32_VidMemFree (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, FLATPTR ptr);
#endif // #ifndef WINNT

/*
 * external
 */
void nvTextureAutoMipMap (PNVD3DTEXTURE);

#ifdef NV_TEX2
/*****************************************************************************
 * helpers
 * -------
 *****************************************************************************/

/*
 * nvTextureCalcMipMapSize
 *
 * calculates the amount of bytes needed with a given number of mipmaps
 */
DWORD nvTextureCalcMipMapSize
(
    DWORD dwLogU,
    DWORD dwLogV,
    DWORD dwMipMapLevels
)
{
    DWORD dwBits  = ((dwLogU + dwLogV) & 1) ? 0xaaaaaaaa : 0x55555555;
    DWORD dwTotal =  ((1 << (dwLogU + dwLogV + 1)) - 1) & dwBits;
    DWORD dwMask  = ~((1 << (dwLogU + dwLogV + 2 - dwMipMapLevels * 2)) - 1);
    return dwTotal & dwMask;
}

/*
 * GetTextureAddrFromOffset
 *
 * computes the surface address from a heap ID and an offset
 */
__inline DWORD GetTextureAddrFromOffset
(
    DWORD dwOffset,
    DWORD dwLocation
)
{
#ifndef WINNT
    return (dwLocation & NV4_TEXLOC_VID)
           ? (dwOffset + pDriverData->BaseAddress)
           : (dwLocation & NV4_TEXLOC_AGP)
                ? (dwOffset + pDriverData->GARTLinearBase)
                : (dwLocation & NV4_TEXLOC_PCI)
                    ? (dwOffset + pDriverData->pTextureHeapBase)
                    : dwOffset; // base address == 0 for sys memory
#else
    return (dwLocation & NV4_TEXLOC_VID)
           ? (dwOffset + pDriverData->ppdev->pjScreen)
           : (dwLocation & NV4_TEXLOC_AGP)
                ? (dwOffset + pDriverData->GARTLinearBase)
                : (dwLocation & NV4_TEXLOC_PCI)
                    ? (dwOffset + pDriverData->pTextureHeapBase)
                    : dwOffset; // base address == 0 for sys memory
#endif  // WINNT
}

/*
 * GetTextureOffsetFromAddr
 *
 * computes the surface address from a heap ID and an offset
 */
__inline DWORD GetTextureOffsetFromAddr
(
    DWORD dwAddr,
    DWORD dwLocation
)
{
#ifndef WINNT
    return (dwLocation & NV4_TEXLOC_VID)
           ? (dwAddr - pDriverData->BaseAddress)
           : (dwLocation & NV4_TEXLOC_AGP)
                ? (dwAddr - pDriverData->GARTLinearBase)
                : (dwLocation & NV4_TEXLOC_PCI)
                    ? (dwAddr - pDriverData->pTextureHeapBase)
                    : 0xffffffff; // HW cannot reach sys memory
#else
    return (dwLocation & NV4_TEXLOC_VID)
           ? (dwAddr - (DWORD)pDriverData->ppdev->pjScreen)
           : (dwLocation & NV4_TEXLOC_AGP)
                ? (dwAddr - pDriverData->GARTLinearBase)
                : (dwLocation & NV4_TEXLOC_PCI)
                    ? (dwAddr - pDriverData->pTextureHeapBase)
                    : 0xffffffff; // HW cannot reach sys memory
#endif  // WINNT
}

/*
 * nvTextureGrowDirtyRect
 *
 * grows dirty rect to include the given rectangle
 */
__inline void nvTextureGrowDirtyRect
(
    PNVD3DTEXTURE pTexture,
    DWORD         x0,
    DWORD         y0,
    DWORD         x1,
    DWORD         y1
)
{
#ifdef DEBUG
    if (!pTexture)
    {
        DPF ("nvTextureGrowDirtyRect: pTexture == NULL");
        dbgD3DError();
        __asm int 3;
        return;
    }
#endif //DEBUG

    /*
     * if rect is empty, trivially accept new
     */
    if ((pTexture->dwDirtyX0 == pTexture->dwDirtyX1)
     || (pTexture->dwDirtyY0 == pTexture->dwDirtyY1))
    {
        pTexture->dwDirtyX0 = x0;
        pTexture->dwDirtyY0 = y0;
        pTexture->dwDirtyX1 = x1;
        pTexture->dwDirtyY1 = y1;
        return;
    }

    /*
     * grow
     */
    pTexture->dwDirtyX0 = min(pTexture->dwDirtyX0,x0);
    pTexture->dwDirtyY0 = min(pTexture->dwDirtyY0,y0);
    pTexture->dwDirtyX1 = min(pTexture->dwDirtyX1,x1);
    pTexture->dwDirtyY1 = min(pTexture->dwDirtyY1,y1);

    /*
     * done
     */
    return;
}

/*
 * nvTextureDirtyRectEmpty
 *
 * returns true is dirty rect is empty
 */
__inline BOOL nvTextureDirtyRectEmpty
(
    PNVD3DTEXTURE pTexture
)
{
#ifdef DEBUG
    if (!pTexture)
    {
        DPF ("nvTextureGrowDirtyRect: pTexture == NULL");
        dbgD3DError();
        __asm int 3;
        return FALSE;
    }
#endif //DEBUG

    return (pTexture->dwDirtyX0 == pTexture->dwDirtyX1) || (pTexture->dwDirtyY0 == pTexture->dwDirtyY1);
}

/*
 * nvTextureAllocSurface
 *
 * allocates a surface in any of the given heaps
 */
BOOL nvTextureAllocSurface
(
    LPDDRAWI_DIRECTDRAW_GBL lpDriverObject,
    DWORD  dwAllocFlags,
    DWORD  dwAllocPreference,   // which heap gets preference (1 set bit only)
    DWORD  dwSize,
    DWORD *pdwAddr,
    DWORD *pdwResultFlags
)
{
    DWORD dwAddr;

    // we have to allow for the "legitimate" possibility of a zero-size texture
    // here since some dumb apps seem to set un-created textures from time to time
    // without actually using them to render.
    if (!dwSize)
    {
        DPF ("nvTextureAllocSurface: dwSize == 0");
        return FALSE;
    }

    /*
     * no preference would start with video memory
     */
    dwAllocPreference = (dwAllocPreference) ? (dwAllocPreference & NV4_TEXLOC_ANYWHERE)
                                            : NV4_TEXLOC_VID;

    /*
     * if the video res is 1k or larger
     */
    if (pCurrentContext && (pCurrentContext->lpLcl->lpGbl->wWidth >= pDriverData->regAGPTexCutOff))
    {
        /*
         * if we are allowed agp and video memory to allocate in
         */
        if ((dwAllocFlags & (NV4_TEXLOC_VID | NV4_TEXLOC_AGP)) == (NV4_TEXLOC_VID | NV4_TEXLOC_AGP))
        {
            /*
             * if we want video
             */
            if (dwAllocPreference == NV4_TEXLOC_VID)
            {
                /*
                 * override to agp
                 */
                dwAllocPreference = NV4_TEXLOC_AGP;
            }
        }
    }

    /*
     * try to allocate in all allowed memory heaps
     */
    while (dwAllocFlags)
    {
        /*
         * video
         */
        if (dwAllocFlags & dwAllocPreference & NV4_TEXLOC_VID)
        {
            if (pDriverData->regD3DEnableBits1 & REG_BIT1_VIDEO_TEXTURE_ENABLE)
            {
                /*
                 * Call DDRAW to allocate memory from the video memory heap.
                 */
                NVHEAP_ALLOC(dwAddr, dwSize, TYPE_TEXTURE);
                if (dwAddr)
                {
                    /*
                     * Increment count of video memory surfaces allocated.
                     */
                    pDriverData->DDrawVideoSurfaceCount++;

                    /*
                     * Handy statistics.
                     */
                    statTextureCountVideo++;
                    statTextureSizeVideo += dwSize;
                    //statTextureDimensionMinVideo = min(statTextureDimensionMinVideo, pTexture->dwWidth);
                    //statTextureDimensionMaxVideo = max(statTextureDimensionMaxVideo, pTexture->dwWidth);
                    /*
                     * done
                     */
#ifndef WINNT
                    *pdwAddr        = dwAddr;
#else
                    *pdwAddr        = (dwAddr + (DWORD)pDriverData->ppdev->pjScreen);
#endif  // WINNT
                    *pdwResultFlags = NV4_TEXLOC_VID;
                    return TRUE;
                }
            }

            /*
             * fail - don't try again
             */
            DPF_LEVEL(NVDBG_LEVEL_INFO,"nvTextureAllocSurface: Texture Surface in VID failed");
            dwAllocFlags &= ~NV4_TEXLOC_VID;
        }

        /*
         * agp
         */
        if (dwAllocFlags & dwAllocPreference & NV4_TEXLOC_AGP)
        {
            if (pDriverData->GARTLinearBase)
            {
                /*
                 * On AGP, allocate call DDRAW to allocate the AGP memory.
                 */
                dwAddr = (DWORD)AllocAGPHeap(lpDriverObject, dwSize);
                if (dwAddr)
                {
                    /*
                     * Handy statistics.
                     */
                    statTextureCountAgpHeap++;
                    statTextureSizeAgpHeap += dwSize;
                    //statTextureDimensionMinAgpHeap = min(statTextureDimensionMinAgpHeap, pTexture->dwWidth);
                    //statTextureDimensionMaxAgpHeap = max(statTextureDimensionMaxAgpHeap, pTexture->dwWidth);
                    /*
                     * done
                     */
                    *pdwAddr        = dwAddr;
                    *pdwResultFlags = NV4_TEXLOC_AGP;
                    return TRUE;
                }
            }

            /*
             * fail - don't try again
             */
            DPF_LEVEL(NVDBG_LEVEL_INFO,"nvTextureAllocSurface: Texture Surface in AGP failed");
            dwAllocFlags &= ~NV4_TEXLOC_AGP;
        }

        /*
         * pci
         */
        if (dwAllocFlags & dwAllocPreference & NV4_TEXLOC_PCI)
        {
            /*
             * On PCI, allocate from our internal texture heap.
             */
            dwAddr = AllocTextureHeap(dwSize);
            if (dwAddr)
            {
                /*
                 * Handy statistics.
                 */
                statTextureCountPciHeap++;
                statTextureSizePciHeap += dwSize;
                //statTextureDimensionMinPciHeap = min(statTextureDimensionMinPciHeap, pTexture->dwWidth);
                //statTextureDimensionMaxPciHeap = max(statTextureDimensionMaxPciHeap, pTexture->dwWidth);
                /*
                 * done
                 */
                *pdwAddr        = dwAddr;
                *pdwResultFlags = NV4_TEXLOC_PCI;
                return TRUE;
            }

            /*
             * fail - don't try again
             */
            DPF_LEVEL(NVDBG_LEVEL_INFO,"nvTextureAllocSurface: Texture Surface in PCI failed");
            dwAllocFlags &= ~NV4_TEXLOC_PCI;
        }

        /*
         * system memory
         */
        if (dwAllocFlags & dwAllocPreference & NV4_TEXLOC_SYS)
        {
            /*
             * For system meory, allocate from global heap.
             */
            dwAddr = (DWORD)GlobalAlloc(GPTR,dwSize);
            if (dwAddr)
            {
                /*
                 * done
                 */
                *pdwAddr        = dwAddr;
                *pdwResultFlags = NV4_TEXLOC_SYS;
                return TRUE;
            }

            /*
             * fail - don't try again
             */
            DPF_LEVEL(NVDBG_LEVEL_INFO,"nvTextureAllocSurface: Texture Surface in SYSMEM failed");
            dwAllocFlags &= ~NV4_TEXLOC_SYS;
        }

        /*
         * next
         */
        dwAllocPreference = (dwAllocPreference << 1) & NV4_TEXLOC_ANYWHERE;
        dwAllocPreference = dwAllocPreference ? dwAllocPreference
                                              : NV4_TEXLOC_VID;
    }

    /*
     * not allocated
     */
    DPF_LEVEL(NVDBG_LEVEL_INFO,"nvTextureAllocSurface: Texture Surface Not allocated");
    dbgD3DError();

    *pdwAddr        = 0;
    *pdwResultFlags = NV4_TEXLOC_NOWHERE;
    return FALSE;
}

/*
 * nvTextureFreeSurface
 *
 * frees a surface
 */
BOOL nvTextureFreeSurface
(
    LPDDRAWI_DIRECTDRAW_GBL lpDriverObject,
    DWORD dwAddr,
    DWORD dwSize,
    DWORD dwAllocFlags
)
{
    /*
     * video
     */
    if (dwAllocFlags & NV4_TEXLOC_VID)
    {
        /*
         * Call DDRAW to de-allocate memory from the video memory heap.
         */
        NVHEAP_FREE (dwAddr);

        /*
         * Decrement count of video memory surfaces allocated.
         */
        pDriverData->DDrawVideoSurfaceCount--;

        /*
         * Update texture statistics.
         */
        statTextureCountVideo--;
        statTextureSizeVideo -= dwSize;

        /*
         * done
         */
        return TRUE;
    }

    /*
     * agp
     */
    if (dwAllocFlags & NV4_TEXLOC_AGP)
    {
        /*
         * On AGP call DDRAW to de-allocate memory from AGP heap.
         */
        FreeAGPHeap(lpDriverObject, dwAddr);

        /*
         * Update texture statistics.
         */
        statTextureCountAgpHeap--;
        statTextureSizeAgpHeap -= dwSize;

        /*
         * done
         */
        return TRUE;
    }

    /*
     * pci
     */
    if (dwAllocFlags & NV4_TEXLOC_PCI)
    {
        /*
         * On PCI, de-allocate from our internal texture heap.
         */
        FreeTextureHeap(dwAddr);

        /*
         * Update texture statistics.
         */
        statTextureCountPciHeap--;
        statTextureSizePciHeap -= dwSize;

        /*
         * done
         */
        return TRUE;
    }

    /*
     * sys
     */
    if (dwAllocFlags & NV4_TEXLOC_SYS)
    {
        /*
         * free from global heap
         */
        GlobalFree ((HGLOBAL)dwAddr);

        /*
         * done
         */
        return TRUE;
    }

    /*
     * failed
     */
    return FALSE;
}

/*****************************************************************************
 * exported code
 * -------------
 *****************************************************************************/

/*
 * nvTextureRef
 *
 * called whenever the HW is about to use the texture.
 * the swizzle surface MUST be made valid (NV4_TEXFLAG_SWIZZLE_VALID)
 * this is also where we would automipmap if we are allowed to and the proper
 * timeout elapsed
 *
 */
BOOL nvTextureRef
(
    PNVD3DTEXTURE pTexture
)
{
    DWORD dwFlags;
    DWORD dwIndex;
    DWORD dwSurfaceFlags;
    BOOL  bForceHWUpdate = FALSE;

    /*
     * valid texture?
     */
    if (!pTexture) return FALSE;

    /*
     * extract texture info
     */
    dwFlags        = pTexture->dwTextureFlags;
    dwIndex        = TEX_SWIZZLE_INDEX(dwFlags);
    dwSurfaceFlags = pTexture->dwSwizzleFlags[dwIndex];

    /*
     * check if swizzle surface is valid
     */
    if (!(dwSurfaceFlags & NV4_TEXFLAG_VALID))
    {
        /*
         * make valid
         */
        if (!nvUpdateSwizzleSurface(pTexture)) return FALSE;
        /*
         * force hw reprogram
         */
        bForceHWUpdate = TRUE;
        /*
         * re-read texture info
         */
        dwFlags        = pTexture->dwTextureFlags;
        dwIndex        = TEX_SWIZZLE_INDEX(dwFlags);
        dwSurfaceFlags = pTexture->dwSwizzleFlags[dwIndex];
    }

#if 0 // obsolete
    /*
     * check if have dirty user mipmaps
     */
    if (pTexture->dwTextureFlags & NV4_TEXFLAG_MIPMAPS_DIRTY)
    {
        LPDDRAWI_DDRAWSURFACE_LCL lpLcl;
        LPDDRAWI_DDRAWSURFACE_LCL lclMip;
        /*
         * run down the chain and make sure the swizzled versions are up to date
         */
        lpLcl = pTexture->lpLcl;
        lclMip = lpLcl->lpAttachList->lpAttached;

        while (lclMip)
        {
            PNVD3DTEXTURE   pMipMap;

            pMipMap = (PNVD3DTEXTURE)lclMip->dwReserved1;
            if (pMipMap)
            {
                if (!(pMipMap->dwTextureFlags & NV4_TEXFLAG_SWIZZLE_VALID))
                {
                    /*
                     * make valid
                     */
                    nvUpdateSwizzleSurface (pMipMap);
                }
            }

            /*
             * next
             */
            lclMip = (lclMip->lpAttachList) ? lclMip->lpAttachList->lpAttached
                                            : NULL;
        }

        /*
         * update flags
         */
        pTexture->dwTextureFlags &= ~NV4_TEXFLAG_MIPMAPS_DIRTY;

        /*
         * force hw reprogram
         */
        bForceHWUpdate = TRUE;
    }
#endif //0

    /*
     * check if we have auto mipmaps enabled for this texture
     */
    if (dwFlags & NV4_TEXFLAG_AUTOMIPMAP)
    {
        /*
         * check if we still have to create the auto mipmaps this texture
         */
        if (!(dwFlags & NV4_TEXFLAG_AUTOMIPMAP_VALID))
        {
            /*
             * is it time to create them yet?
             */
            if (pTexture->dwAutoMipMapScene < pCurrentContext->dwSceneCount)
            {
                /*
                 * do we have an opportunity to still mipmap stuff in this scene?
                 */
                if (pCurrentContext->dwMipMapsInThisScene < NV3_TEXDEFAULT_MIPSPERSCENE)
                {
                    /*
                     * update flags
                     */
                    pTexture->dwTextureFlags    = dwFlags | NV4_TEXFLAG_AUTOMIPMAP_VALID;
                    pTexture->dwMipMapLevels    = pTexture->dwAutoMipMapCount;
                    pTexture->dwAutoMipMapScene = 0xffffffff; // inhibit further mipmapping (above test always fails)

                    /*
                     * perform mipmap (nv4mip.c)
                     */
                    nvTextureAutoMipMap (pTexture);

                    /*
                     * force hw reprogram
                     */
                    pCurrentContext->dwMipMapsInThisScene ++;
                    bForceHWUpdate = TRUE;

                    /*
                     * re-read texture info
                     */
                    dwFlags        = pTexture->dwTextureFlags;
                    dwIndex        = TEX_SWIZZLE_INDEX(dwFlags);
                    dwSurfaceFlags = pTexture->dwSwizzleFlags[dwIndex];
                }
            }
        }
    }
    else
    {
        /*
         * check is we have to bring user mipmaps forward
         */
        if ((dwSurfaceFlags & NV4_TEXMASK_MIPMASK) != NV4_TEXMASK_MIPMASK)
        {
            // txtodo
            // remember to store & load values
        }
    }

    /*
     * store cached values
     */
    pTexture->dwTextureFlags = dwFlags;

    /*
     * HW update
     */
    if (bForceHWUpdate)
    {
        pCurrentContext->dwStateChange = TRUE;
        NV_FORCE_TRI_SETUP(pCurrentContext);
    }

    /*
     * done
     */
    return TRUE;
}

/*
 * nvTextureTestBlock
 *
 * return TRUE if the CPU will have to block for this texture - similar
 *  logic to nvTextureBlock
 */
BOOL nvTextureTestBlock
(
    DWORD dwDate
)
{
    /*
     * aa override
     */
    if (pCurrentContext->dwAntiAliasFlags & (AA_MODE_SUPER | AA_MODE_SINGLECHUNK))
    {
        return FALSE; // capturing nature of AA implicitly provides syncronization
    }

    /*
     * check if we know it has retired
     */
    if (global.dwHWTextureDate > dwDate) return FALSE;

    /*
     * read latest HW date
     */
#ifndef WINNT
    global.dwHWTextureDate = *(DWORD*)(pDriverData->dwTMPseudoNotifierOffset + NV_PN_TEXTURE_RETIRE + pDriverData->BaseAddress);
#else
    global.dwHWTextureDate = *(DWORD*)(pDriverData->dwTMPseudoNotifierOffset + NV_PN_TEXTURE_RETIRE + pDriverData->ppdev->pjScreen);
#endif

    /*
     * test again
     */
    if (global.dwHWTextureDate > dwDate) return FALSE;

    /*
     * we will have to stall
     */
    return TRUE;
}

/*
 * nvTextureBlock
 *
 * block the CPU until HW has finished with the given frame.
 */
void nvTextureBlock
(
    DWORD dwDate
)
{
    /*
     * aa override
     */
    if (pCurrentContext->dwAntiAliasFlags & (AA_MODE_SUPER | AA_MODE_SINGLECHUNK))
    {
        return; // capturing nature of AA implicitly provides syncronization
    }

    /*
     * check if we know it has retired
     */
    if (global.dwHWTextureDate > dwDate) return;

    /*
     * read latest HW date
     */
#ifndef WINNT
    global.dwHWTextureDate = *(DWORD*)(pDriverData->dwTMPseudoNotifierOffset + NV_PN_TEXTURE_RETIRE + pDriverData->BaseAddress);
#else
    global.dwHWTextureDate = *(DWORD*)(pDriverData->dwTMPseudoNotifierOffset + NV_PN_TEXTURE_RETIRE + pDriverData->ppdev->pjScreen);
#endif  // WINNT

    /*
     * test again
     */
    if (global.dwHWTextureDate > dwDate) return;

    /*
     * check if we can do a partial stall
     *  this can happen when we wait for a date that is not the current SW date
     */
    if (dwDate < global.dwSWTextureDate)
    {
        for (;;)
        {
            /*
             * wait
             */
            NV_DELAY;

            /*
             * get new HW date
             */
#ifndef WINNT
            global.dwHWTextureDate = *(DWORD*)(pDriverData->dwTMPseudoNotifierOffset + NV_PN_TEXTURE_RETIRE + pDriverData->BaseAddress);
#else
            global.dwHWTextureDate = *(DWORD*)(pDriverData->dwTMPseudoNotifierOffset + NV_PN_TEXTURE_RETIRE + pDriverData->ppdev->pjScreen);
#endif  // WINNT

            /*
             * test again
             */
            if (global.dwHWTextureDate > dwDate) return;
        }
    }

    /*
     * date must be this frame so we sync hard. texture renaming tries to
     * avoid this case
     */
#ifdef NV_PROFILE
    NVP_START(NVP_T_TEXWAIT);
#endif
    NV_D3D_GLOBAL_SAVE();
    nvFlushDmaBuffers();
    NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
   nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
   NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
   nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_ROP, sizeSet2DSurfacesDestination);
#endif  // CACHE_FREECOUNT
#ifdef NV_PROFILE
    NVP_STOP(NVP_T_TEXWAIT);
    nvpLogTime (NVP_T_TEXWAIT,nvpTime[NVP_T_TEXWAIT]);
#endif
}

/*
 * nvTextureSetBlockPoint
 *
 * writes the proper semaphores to block texture accesses
 *  this should be called very infrequently
 */
void nvTextureSetBlockPoint
(
    void
)
{
    if (pCurrentContext->dwAntiAliasFlags & (AA_MODE_SUPER | AA_MODE_SINGLECHUNK))
    {
        return; // capturing nature of AA implicitly provides syncronization
    }

    /*
     * update block value
     */
    global.dwSWTextureDate ++;

    /*
     * write into command stream
     */
    nvPlacePsuedoNotifier (NV_PN_TEXTURE_RETIRE,global.dwSWTextureDate);
}

/*
 * nvTextureLock
 *
 * locks a texture so the user can party on the texels
 */
DWORD nvTextureLock
(
    PNVD3DTEXTURE    pTexture,
    LPDDHAL_LOCKDATA lpLockData
)
{
#ifdef DEBUG
    if (!pTexture)
    {
        DPF ("nvTextureLock: pTexture == NULL");
        dbgD3DError();
        __asm int 3;
        return 0;
    }
#endif // DEBUG

    /*
     * enter
     */
    NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
    nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_ROP, sizeSet2DSurfacesDestination);
#endif  // CACHE_FREECOUNT


    /*
     * make linear valid if we need to
     */
    nvUpdateLinearSurface (pTexture);

    /*
     * update texture flags for this lock - kill mipmaps and tag swizzled surface as invalid
     */
    TEX_SWIZZLE_FLAGS(pTexture,pTexture->dwTextureFlags) &= ~NV4_TEXFLAG_VALID;
    pTexture->dwTextureFlags   &= ~NV4_TEXFLAG_AUTOMIPMAP_VALID;
    pTexture->dwMipMapLevels    = 1;
    pTexture->dwAutoMipMapScene = pCurrentContext->dwSceneCount + NV4_TEXDEFAULT_AUTOMIPMAPTIME;

    /*
     * force hw reprogram
     */
    pCurrentContext->dwStateChange = TRUE;
    NV_FORCE_TRI_SETUP(pCurrentContext);

/* - txtodo - decide if this is really needed
    if ((++pTexture->dwUpdateCount) > NV4_TEXDEFAULT_MAXMODIFYCOUNT)
    {
        / *
         * modified too many times
         * /
        pTexture->dwTextureFlags   &= ~NV4_TEXFLAG_AUTOMIPMAP;
    }
*/

    /*
     * grow dirty rectangle to lock extents if it exists (else the whole thing)
     */
    if (lpLockData->bHasRect)
    {
        nvTextureGrowDirtyRect (pTexture,
                                lpLockData->rArea.left,
                                lpLockData->rArea.top,
                                lpLockData->rArea.right,
                                lpLockData->rArea.bottom);
    }
    else
    {
        pTexture->dwDirtyX0 = pTexture->dwDirtyY0
                            = 0;
        pTexture->dwDirtyX1 = pTexture->dwWidth;
        pTexture->dwDirtyY1 = pTexture->dwHeight;
    }

    /*
     * setup DDRAW with surface information
     */
    lpLockData->lpDDSurface->lpGbl->fpVidMem = pTexture->dwLinearAddr;
    lpLockData->lpDDSurface->lpGbl->lPitch   = pTexture->dwPitch;

    /*
     * sync HW - even when READONLY is specified (due to deswizzle possibly being done by HW)
     */
    nvTextureBlock (pTexture->dwRetireDate[NV4_TEXCOUNT_SWIZZLE]);

    /*
     * leave
     */
    NV_D3D_GLOBAL_SAVE();

    /*
     * done
     *  return that we did not handle the lock although we did - really weird ms semantics...
     */
    lpLockData->ddRVal = DD_OK;
#ifndef WINNT
    return DDHAL_DRIVER_NOTHANDLED/*DDHAL_DRIVER_HANDLED*/;
#else
    return DDHAL_DRIVER_HANDLED;
#endif  // WINNT
}

/*
 * nvTextureUnlock
 *
 * unlocks a texture after the user partied on the texels
 */
DWORD nvTextureUnlock
(
    PNVD3DTEXTURE      pTexture,
    LPDDHAL_UNLOCKDATA lpUnlockData
)
{
#ifdef DEBUG
    if (!pTexture)
    {
        DPF ("nvTextureUnlock: pTexture == NULL");
        dbgD3DError();
        __asm int 3;
        return 0;
    }
#endif // DEBUG

    /*
     * unlock ddraw's view of this texture
     */
    // txtodo - we might want to swizzle here instead of later

    /*
     * done
     */
    lpUnlockData->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}

/*
 * nvTextureBlt
 *
 * performs a 16 or 32 bpp blt to a texture
 */
DWORD nvTextureBlt
(
    LPDDHAL_BLTDATA lpBltData
)
{
    /*
     * source surface
     */
    DWORD dwSrcAddr  = lpBltData->lpDDSrcSurface->lpGbl->fpVidMem;
    DWORD dwSrcAlloc = 0;
    DWORD dwSrcX0    = lpBltData->rSrc.left;
    DWORD dwSrcY0    = lpBltData->rSrc.top;
    DWORD dwSrcX1    = lpBltData->rSrc.right;
    DWORD dwSrcY1    = lpBltData->rSrc.bottom;
    DWORD dwSrcPitch = lpBltData->lpDDSrcSurface->lpGbl->lPitch;
    DWORD dwSrcBPP   = ((lpBltData->lpDDSrcSurface->lpGbl->ddpfSurface.dwFlags & DDPF_RGB)
                     ? lpBltData->lpDDSrcSurface->lpGbl->ddpfSurface.dwRGBBitCount
                     : pDriverData->bi.biBitCount) / 8;
    DWORD dwSrcLogW;
    DWORD dwSrcLogH;

    // txtodo - if source is a texture then we can do a swiz to swiz blt
    //PNVD3DTEXTURE pSrcTexture = (PNVD3DTEXTURE)lpBltData->lpDDSrcSurface->dwReserved1;

    /*
     * dest texture surface
     */
    PNVD3DTEXTURE pTexture   = (PNVD3DTEXTURE)lpBltData->lpDDDestSurface->dwReserved1;
    DWORD         dwDestX0   = lpBltData->rDest.left;
    DWORD         dwDestY0   = lpBltData->rDest.top;
    DWORD         dwDestX1   = lpBltData->rDest.right;
    DWORD         dwDestY1   = lpBltData->rDest.bottom;
    DWORD         dwDestLogW;
    DWORD         dwDestLogH;
    DWORD         dwIndex;

#ifdef NV_NULL_DRIVER
    lpBltData->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
#endif //NV_NULL_DRIVER

    /*
     * determine source texture allocation heap
     */
    if (lpBltData->lpDDSrcSurface->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
    {
        if (lpBltData->lpDDSrcSurface->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
        {
            if (pDriverData->GARTLinearBase)
                dwSrcAlloc = NV4_TEXLOC_AGP;
            else
                dwSrcAlloc = NV4_TEXLOC_PCI;
        }
        else if (lpBltData->lpDDSrcSurface->ddsCaps.dwCaps & DDSCAPS_LOCALVIDMEM)
        {
            dwSrcAlloc = NV4_TEXLOC_VID;
        }
        else { // unknown location - assume system (the safe option)
            dwSrcAlloc = NV4_TEXLOC_SYS;
        }
    }
    else
    {
        dwSrcAlloc = NV4_TEXLOC_SYS;
    }

    /*
     * enter
     */
    NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
    nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_ROP, sizeSet2DSurfacesDestination);
#endif  // CACHE_FREECOUNT

    /*
     * sanity checks
     */
    if (!pTexture)
    {
        // no dest texture structure
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureBlt - pTexture == NULL!!");
        dbgD3DError();
        // fail
        NV_D3D_GLOBAL_SAVE();
        lpBltData->ddRVal = DDERR_UNSUPPORTED;
        return DDHAL_DRIVER_HANDLED;
    }

    if (dwSrcBPP != pTexture->dwBPP)
    {
        if ((pDriverData->regPal8TextureConvert == REG_P8TC_NONE) ||
            (!(pTexture->dwTextureFlags & NV4_TEXFLAG_PALETTIZED))) {
            // different bit depths are not allowed
            DPF_LEVEL(NVDBG_LEVEL_ERROR,
                      "nvTextureBlt - Source and destination have different bit depths!!");
            dbgD3DError();
            // fail
            NV_D3D_GLOBAL_SAVE();
            lpBltData->ddRVal = DDERR_UNSUPPORTED;
            return DDHAL_DRIVER_HANDLED;
        }
    }

    if (dwSrcBPP == 1)
    {
        if (!(pTexture->dwTextureFlags & NV4_TEXFLAG_PALETTIZED)) {
            // 8 bpp non-palettized
            DPF_LEVEL(NVDBG_LEVEL_ERROR,
                      "nvTextureBlt - 8 bpp not supported with unpalettized textures!!");
            dbgD3DError();
            // fail
            NV_D3D_GLOBAL_SAVE();
            lpBltData->ddRVal = DDERR_UNSUPPORTED;
            return DDHAL_DRIVER_HANDLED;
        }
    }
    else if ((dwSrcBPP != 2) && (dwSrcBPP != 4))
    {
        // not 16 or 32 bpp
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureBlt - %d bpp not supported!!",dwSrcBPP*8);
        dbgD3DError();
        // fail
        NV_D3D_GLOBAL_SAVE();
        lpBltData->ddRVal = DDERR_UNSUPPORTED;
        return DDHAL_DRIVER_HANDLED;
    }

    /*
     * cache some texture info
     */
    dwIndex = TEX_SWIZZLE_INDEX(pTexture->dwTextureFlags);

    /*
     * get log width and height of whole surface - need this for swizzle
     */
    {
        dwSrcLogW  = lpBltData->lpDDSrcSurface->lpGbl->wWidth;
        dwSrcLogH  = lpBltData->lpDDSrcSurface->lpGbl->wHeight;
        dwDestLogW = lpBltData->lpDDDestSurface->lpGbl->wWidth;
        dwDestLogH = lpBltData->lpDDDestSurface->lpGbl->wHeight;
        __asm
        {
            mov eax,[dwSrcLogW]
            mov ebx,[dwSrcLogH]
            bsf ecx,eax
            bsf edx,ebx
            mov [dwSrcLogW],ecx
            mov [dwSrcLogH],edx

            mov eax,[dwDestLogW]
            mov ebx,[dwDestLogH]
            bsf ecx,eax
            bsf edx,ebx
            mov [dwSrcLogW],ecx
            mov [dwSrcLogH],edx
        }
    }

    /*
     * update stats
     */
    pTexture->dwBlitUpdateCount ++;

#ifdef NV_PROFILE
    nvpLogCount (NVP_C_BLTSIZE,(dwSrcX1 - dwSrcX0) * (dwSrcY1 - dwSrcY0) * dwSrcBPP);
#endif

    /*
     * do we have swizzled memory allocated yet?
     */
    if (!(TEX_SWIZZLE_FLAGS(pTexture,pTexture->dwTextureFlags) & NV4_TEXMASK_LOCATION))
    {
        /*
         * do we have enough info to do so now?
         */
        if (pTexture->dwMipMapSizeBytes)
        {
            nvAllocateInternalTexture (pTexture);
        }
        else
        {
            DPF_LEVEL(NVDBG_LEVEL_ERROR,
                      "nvTextureBlt - internal texture cannot be allocated (createsurface was never called)!!");
            dbgD3DError();
            // fail
            NV_D3D_GLOBAL_SAVE();
            lpBltData->ddRVal = DDERR_UNSUPPORTED;
            return DDHAL_DRIVER_HANDLED;
        }
    }

    /*
     * if source is in a HW reachable location, do blt directly from there
     *  implied syncronous operation and will not have to idle HW
     */
    if (dwSrcAlloc & (NV4_TEXLOC_PCI | NV4_TEXLOC_AGP | NV4_TEXLOC_VID))
    {
#ifdef NV_PROFILE
            NVP_START(NVP_T_TEXHWBLT);
#endif
        /*
         * make swizzle valid
         * - if it is not valid
         * - we already have dirty swizzled texels
         * - and we do not intend to blt the whole thing
         */
        if (dwDestX0 || dwDestY0 || (dwDestX1 != pTexture->dwWidth) || (dwDestY1 != pTexture->dwHeight))
        {
            if (!(pTexture->dwSwizzleFlags[dwIndex] & NV4_TEXFLAG_VALID)
              && (pTexture->dwTextureFlags & NV4_TEXFLAG_LINEAR_VALID))
            {
                if (!nvTextureDirtyRectEmpty(pTexture))
                {
                    nvUpdateSwizzleSurface (pTexture);
                }
            }
        }

        /*
         * perform lin -> swizzle copy
         */
        nvSwizzleBlt (dwSrcAddr,dwSrcAlloc,
                           dwSrcLogW,dwSrcLogH,
                           dwSrcX0,dwSrcY0,dwSrcX1,dwSrcY1,
                           dwSrcPitch,
                           NULL,
                      pTexture->dwSwizzleAddr[dwIndex],pTexture->dwSwizzleFlags[dwIndex] & NV4_TEXMASK_LOCATION,
                           dwDestLogW,dwDestLogH,
                           dwDestX0,dwDestY0,
                           pTexture->dwPitch,
                           pTexture,
                      dwSrcBPP,
                      NV_SWIZFLAG_SRCLINEAR | NV_SWIZFLAG_DESTSWIZZLED | NV_SWIZFLAG_ALLOWHW);

        /*
         * update flags
         */
        pTexture->dwTextureFlags          &= ~NV4_TEXFLAG_LINEAR_VALID;
        pTexture->dwSwizzleFlags[dwIndex] |=  NV4_TEXFLAG_VALID;
        if (pTexture->dwTextureFlags & NV4_TEXFLAG_AUTOMIPMAP)
        {
            pTexture->dwTextureFlags   &= ~NV4_TEXFLAG_AUTOMIPMAP_VALID;
            pTexture->dwMipMapLevels    = 1;
            pTexture->dwAutoMipMapScene = pCurrentContext->dwSceneCount + NV4_TEXDEFAULT_AUTOMIPMAPTIME;

            /*
             * force hw reprogram
             */
            pCurrentContext->dwStateChange = TRUE;
            NV_FORCE_TRI_SETUP(pCurrentContext);
        }
        if (pTexture->dwTextureFlags & NV4_TEXFLAG_USER_MIP_LEVEL)
        {
            /*
             * tag mipmap as current
             */
            ((PNVD3DTEXTURE)pTexture->hMipBaseTexture)->dwSwizzleFlags[dwIndex] &= ~(4 << pTexture->dwMipMapLevels);
        }

        /*
         * update dirty rect
         */
        nvTextureGrowDirtyRect (pTexture,dwDestX0,dwDestY0,dwDestX1,dwDestY1);

#ifdef NV_PROFILE
        NVP_STOP(NVP_T_TEXHWBLT);
        nvpLogTime (NVP_T_TEXHWBLT,nvpTime[NVP_T_TEXHWBLT]);
#endif

        /*
         * done
         */
        NV_D3D_GLOBAL_SAVE();
        lpBltData->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    /*
     * if we have a linear copy of the texture try to use a HW swizzle blit
     */
    if (pTexture->dwLinearAddr)
    {
        /*
         * can HW read from linear texture?
         */
        if (pTexture->dwTextureFlags & ((NV4_TEXLOC_VID | NV4_TEXLOC_AGP | NV4_TEXLOC_PCI) << NV4_TEXMASK_LINEAR_SHIFT))
        {
#ifdef NV_PROFILE
            NVP_START(NVP_T_TEXHWBLT);
#endif
            /*
             * make linear valid
             * - if it is not valid
             * - we already have dirty swizzled texels
             * - and we do not intend to blt the whole thing
             */
            if (dwDestX0 || dwDestY0 || (dwDestX1 != pTexture->dwWidth) || (dwDestY1 != pTexture->dwHeight))
            {
                if (!(pTexture->dwTextureFlags & (NV4_TEXFLAG_LINEAR_VALID)
                  && (pTexture->dwSwizzleFlags[dwIndex] & NV4_TEXFLAG_VALID)))
                {
                    if (!nvTextureDirtyRectEmpty(pTexture))
                    {
                        nvUpdateLinearSurface (pTexture);
                    }
                }
            }

            /*
             * perform linear copy
             */
            nvSwizzleBlt (dwSrcAddr,dwSrcAlloc,
                               dwSrcLogW,dwSrcLogH,
                               dwSrcX0,dwSrcY0,dwSrcX1,dwSrcY1,
                               dwSrcPitch,
                               NULL,
                          pTexture->dwLinearAddr,pTexture->dwTextureFlags >> NV4_TEXMASK_LINEAR_SHIFT,
                               dwDestLogW,dwDestLogH,
                               dwDestX0,dwDestY0,
                               pTexture->dwPitch,
                               pTexture,
                          dwSrcBPP,
                          NV_SWIZFLAG_SRCLINEAR | NV_SWIZFLAG_DESTLINEAR | NV_SWIZFLAG_ALLOWHW);
            /*
             * update flags
             */
            pTexture->dwSwizzleFlags[dwIndex] &= ~NV4_TEXFLAG_VALID;
            pTexture->dwTextureFlags          |=  NV4_TEXFLAG_LINEAR_VALID;
            if (pTexture->dwTextureFlags & NV4_TEXFLAG_AUTOMIPMAP)
            {
                pTexture->dwTextureFlags   &= ~NV4_TEXFLAG_AUTOMIPMAP_VALID;
                pTexture->dwMipMapLevels    = 1;
                pTexture->dwAutoMipMapScene = (pCurrentContext ? pCurrentContext->dwSceneCount : 0 ) + NV4_TEXDEFAULT_AUTOMIPMAPTIME;

                /*
                 * force hw reprogram
                 */
                pCurrentContext->dwStateChange = TRUE;
                NV_FORCE_TRI_SETUP(pCurrentContext);
            }
            if (pTexture->dwTextureFlags & NV4_TEXFLAG_USER_MIP_LEVEL)
            {
                /*
                 * tag mipmap as current
                 */
                ((PNVD3DTEXTURE)pTexture->hMipBaseTexture)->dwSwizzleFlags[dwIndex] &= ~(4 << pTexture->dwMipMapLevels);
            }

            /*
             * update dirty rect
             */
            nvTextureGrowDirtyRect (pTexture,dwDestX0,dwDestY0,dwDestX1,dwDestY1);

#ifdef NV_PROFILE
            NVP_STOP(NVP_T_TEXHWBLT);
            nvpLogTime (NVP_T_TEXHWBLT,nvpTime[NVP_T_TEXHWBLT]);
#endif

            /*
             * done
             */
            NV_D3D_GLOBAL_SAVE();
            lpBltData->ddRVal = DD_OK;
            return DDHAL_DRIVER_HANDLED;
        }
    }

    /*
     * see if we should do a staged HW swizzle blt
     */
    if ((!pTexture->dwLinearAddr)
     && (pTexture->dwSwizzleFlags[dwIndex] & NV4_TEXLOC_VID))
    {
        extern BOOL bTMHadToWaitForStagingSpace;

#if 0
        /*
         * prep call
         */
        bTMHadToWaitForStagingSpace = FALSE;
#endif

#ifdef NV_PROFILE
        NVP_START(NVP_T_TEXHWBLT);
#endif

        /*
         * do it
         */
        nvTMVideoTextureBlt (dwSrcAddr,dwSrcPitch,
                                dwSrcX0,dwSrcY0,dwSrcX1,dwSrcY1,
                             0,0, /* fake these parameters - nv_tex2 does not need this */
                                dwDestX0,dwDestY0,
                             pTexture->dwSwizzleOffset[dwIndex],
                                pTexture->dwMipMapBaseU,pTexture->dwMipMapBaseV,
                                pTexture->dwTextureColorFormat);

        /*
         * update flags
         */
        pTexture->dwTextureFlags          &= ~NV4_TEXFLAG_LINEAR_VALID;
        pTexture->dwSwizzleFlags[dwIndex] |= NV4_TEXFLAG_VALID;
        if (pTexture->dwTextureFlags & NV4_TEXFLAG_AUTOMIPMAP)
        {
            pTexture->dwTextureFlags   &= ~NV4_TEXFLAG_AUTOMIPMAP_VALID;
            pTexture->dwMipMapLevels    = 1;
            pTexture->dwAutoMipMapScene = (pCurrentContext ? pCurrentContext->dwSceneCount : 0) + NV4_TEXDEFAULT_AUTOMIPMAPTIME;

            /*
             * force hw reprogram
             */
            pCurrentContext->dwStateChange = TRUE;
            NV_FORCE_TRI_SETUP(pCurrentContext);
        }
        if (pTexture->dwTextureFlags & NV4_TEXFLAG_USER_MIP_LEVEL)
        {
            /*
             * tag mipmap as current
             */
            ((PNVD3DTEXTURE)pTexture->hMipBaseTexture)->dwSwizzleFlags[dwIndex] &= ~(4 << pTexture->dwMipMapLevels);
        }

        /*
         * update dirty rect
         */
        nvTextureGrowDirtyRect (pTexture,dwDestX0,dwDestY0,dwDestX1,dwDestY1);

        /*
         * block access to this texture
         */
        nvTextureSetBlockPoint ();

#ifdef NV_PROFILE
        NVP_STOP(NVP_T_TEXHWBLT);
        nvpLogTime (NVP_T_TEXHWBLT,nvpTime[NVP_T_TEXHWBLT]);
#endif

#if 0
        /*
         * check if we can balance staging space by allocating linear copies
         */
        if (bTMHadToWaitForStagingSpace
         && (pTexture->dwBlitUpdateCount >= NV4_TEXDEFAULT_MAXBLTCOUNT))
        {
            __asm int 3;
            goto forceLinearTextureCreation;
        }
#endif

        /*
         * done
         */
        NV_D3D_GLOBAL_SAVE();
        lpBltData->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }

#ifdef NV_PROFILE
    NVP_START(NVP_T_TEXSWBLT);
#endif

    /*
     * make swizzled valid if it is not valid and we already have dirty linear texels
     *   not likely but it can happen
     */
    if ((pTexture->dwTextureFlags & NV4_TEXFLAG_LINEAR_VALID)
    && !(pTexture->dwSwizzleFlags[dwIndex] & NV4_TEXFLAG_VALID))
    {
        if (!nvTextureDirtyRectEmpty(pTexture))
        {
            nvUpdateSwizzleSurface (pTexture);
        }
    }

#if 0 // txtodo
    /*
     * If the texture is in AGP memory we kick in a dynamic renamings scheme
     *  so the cpu will not wait for HW idle on blts
     */
    if (pTexture->dwSwizzleFlags[dwIndex] & NV4_TEXLOC_AGP)
    {
        /*
         * are we going to have to wait on this texture in order to blt?
         */
        if (nvTextureTestBlock(pTexture->dwRetireDate[dwIndex]))
        {
            __asm int 3;

            /*
             * check if the blt operation will fill the whole surface
             */
            /*if*/
            {
                /*
                 * do we have a free surface or do we need to quickly allocate one
                 */
                /*if*/
                {
                    /*
                     * quickly allocate new surface
                     */
                }

                /*
                 * switch to new surface
                 */
                // date = old
            }
        }
    }
#endif

    /*
     * move & swizzle texels
     */
    nvSwizzleBlt (dwSrcAddr,dwSrcAlloc,
                       dwSrcLogW,dwSrcLogH,
                       dwSrcX0,dwSrcY0,dwSrcX1,dwSrcY1,
                       dwSrcPitch,
                       NULL,
                  pTexture->dwSwizzleAddr[dwIndex],pTexture->dwSwizzleFlags[dwIndex] & NV4_TEXMASK_LOCATION,
                       pTexture->dwMipMapBaseU,pTexture->dwMipMapBaseV,
                       dwDestX0,dwDestY0,
                       pTexture->dwPitch,
                       pTexture,
                  dwSrcBPP,
                  NV_SWIZFLAG_SRCLINEAR | NV_SWIZFLAG_DESTSWIZZLED | NV_SWIZFLAG_ALLOWHW);

    /*
     * update flags
     */
    pTexture->dwTextureFlags          &= ~NV4_TEXFLAG_LINEAR_VALID;
    pTexture->dwSwizzleFlags[dwIndex] |=  NV4_TEXFLAG_VALID;

    /*
     * update auto-mipmaps
     *  if we have not rendered anything yet, do it now, else tag for
     *  later completion.
     */
    if (pTexture->dwTextureFlags & NV4_TEXFLAG_AUTOMIPMAP)
    {
        if (pCurrentContext->dwSceneCount)
        {
            /*
             * update flags
             */
            pTexture->dwTextureFlags   &= ~NV4_TEXFLAG_AUTOMIPMAP_VALID;
            pTexture->dwMipMapLevels    = 1;
            pTexture->dwAutoMipMapScene = (pCurrentContext ? pCurrentContext->dwSceneCount : 0) + NV4_TEXDEFAULT_AUTOMIPMAPTIME;

            /*
             * force hw reprogram
             */
            pCurrentContext->dwStateChange = TRUE;
            NV_FORCE_TRI_SETUP(pCurrentContext);
        }
        else
        {
            /*
             * update flags
             */
            pTexture->dwTextureFlags   |= NV4_TEXFLAG_AUTOMIPMAP_VALID;
            pTexture->dwMipMapLevels    = pTexture->dwAutoMipMapCount;
            pTexture->dwAutoMipMapScene = 0xffffffff; // inhibit further mipmapping

            /*
             * perform mipmap (nv4mip.c)
             */
            nvTextureAutoMipMap (pTexture);

            /*
             * force hw reprogram
             */
            pCurrentContext->dwStateChange = TRUE;
            NV_FORCE_TRI_SETUP(pCurrentContext);
        }
    }

    /*
     * update dirty rect
     */
    nvTextureGrowDirtyRect (pTexture,dwDestX0,dwDestY0,dwDestX1,dwDestY1);

//NVP_START (NVP_X_FLOAT0);

#if 0 // this does not work fast enough...
    /*
     * keep track of how many times we used the slow swizzle blit
     */
    if (pTexture->dwBlitUpdateCount >= NV4_TEXDEFAULT_MAXBLTCOUNT)
    {
#if 0
forceLinearTextureCreation:
#endif
        if (!pTexture->dwLinearAddr)
        {
            /*
             * create a linear texture for staging - if this succeeds we will use
             * HW swizzling in the future
             */
            DWORD dwAllocFlags = (pDriverData->GARTLinearBase) ? (NV4_TEXLOC_VID | NV4_TEXLOC_AGP)
                                                               : (NV4_TEXLOC_VID | NV4_TEXLOC_PCI);
            nvTextureAllocLinearSurface (pTexture,
                                         pTexture->dwPitch * pTexture->dwHeight,
                                         dwAllocFlags,
                                         dwAllocFlags & (NV4_TEXLOC_AGP | NV4_TEXLOC_PCI));
        }
    }
#endif //0

//NVP_STOP (NVP_X_FLOAT0);
//nvpLogTime (NVP_X_FLOAT0,nvpTime[NVP_X_FLOAT0]);

#ifdef NV_PROFILE
    NVP_STOP(NVP_T_TEXSWBLT);
    nvpLogTime (NVP_T_TEXSWBLT,nvpTime[NVP_T_TEXSWBLT]);
#endif

    /*
     * done
     */
    NV_D3D_GLOBAL_SAVE();
    lpBltData->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}

/*
 * nvTextureAllocSwizzleSurface
 *
 * allocate a swizzled surface
 */
BOOL nvTextureAllocSwizzleSurface
(
    PNVD3DTEXTURE pTexture,
    DWORD         dwSize,
    DWORD         dwAllocFlags,
    DWORD         dwAllocPrefs
)
{
    DWORD dwIndex;
    DWORD dwAddr;

#ifdef DEBUG
    if (!pTexture)
    {
        DPF ("nvTextureAllocSwizzleSurface: pTexture == NULL");
        dbgD3DError();
        __asm int 3;
        return FALSE;
    }
#endif // DEBUG

    dwIndex = TEX_SWIZZLE_INDEX(pTexture->dwTextureFlags);

    if (pTexture->dwSwizzleAddr[dwIndex])
    {
        /*
         * the texure is allocated already - assume we are relocating it (destructive)
         */
        if (!nvTextureFreeSwizzleSurface(pTexture)) return FALSE;
    }

    /*
     * allocate texture surface
     */

    pTexture->dwSwizzleAddr[dwIndex] = pTexture->dwSwizzleOffset[dwIndex]
                                     = 0;
    if (!nvTextureAllocSurface(pTexture->lpDriverObject,dwAllocFlags,dwAllocPrefs,dwSize,
                               &dwAddr,&dwAllocFlags)) return FALSE;

    /*
     * get offset
     */
    pTexture->dwSwizzleAddr[dwIndex]   = dwAddr;
    pTexture->dwSwizzleOffset[dwIndex] = GetTextureOffsetFromAddr(dwAddr,dwAllocFlags);
    pTexture->dwSwizzleFlags[dwIndex] &= ~NV4_TEXMASK_LOCATION;
    pTexture->dwSwizzleFlags[dwIndex] |= dwAllocFlags;
    pTexture->dwTextureContextDma      = (dwAllocFlags & NV4_TEXLOC_VID)
                                       ? (NV054_FORMAT_CONTEXT_DMA_B)
                                       : (NV054_FORMAT_CONTEXT_DMA_A);

    /*
     * done
     */
    return TRUE;
}

/*
 * nvTextureFreeSwizzleSurface
 *
 * frees a swizzled surface
 */
BOOL nvTextureFreeSwizzleSurface
(
    PNVD3DTEXTURE pTexture
)
{
    DWORD i,j;

#ifdef DEBUG
    if (!pTexture)
    {
        DPF ("nvTextureFreeSwizzleSurface: pTexture == NULL");
        dbgD3DError();
        __asm int 3;
        return FALSE;
    }
#endif // DEBUG

    j = (pTexture->dwTextureFlags & NV4_TEXFLAG_SWIZZLE_INDEX_MAX) >> 4; // # of swizzle surfaces allocated
    for (i=0; i<=j; i++)
    {
        if (pTexture->dwSwizzleAddr[i])
        {
            if (!nvTextureFreeSurface(pTexture->lpDriverObject,
                                      pTexture->dwSwizzleAddr[i],
                                      pTexture->dwMipMapSizeBytes,
                                      pTexture->dwSwizzleFlags[i] & NV4_TEXMASK_LOCATION)) return FALSE;
        }

        pTexture->dwSwizzleAddr[i]   = pTexture->dwSwizzleOffset[i]
                                     = 0;
        pTexture->dwSwizzleFlags[i] &= ~NV4_TEXMASK_LOCATION;
    }


    return FALSE;
}

/*
 * nvTextureAllocLinearSurface
 *
 * allocate a linear surface
 */
BOOL nvTextureAllocLinearSurface
(
    PNVD3DTEXTURE pTexture,
    DWORD         dwSize,
    DWORD         dwAllocFlags,
    DWORD         dwAllocPrefs
)
{
    DWORD dwAddr;

#ifdef DEBUG
    if (!pTexture)
    {
        DPF ("nvTextureAllocLinearSurface: pTexture == NULL");
        dbgD3DError();
        __asm int 3;
        return FALSE;
    }
#endif // DEBUG

    if (pTexture->dwLinearAddr)
    {
        /*
         * the texure is allocated already - assume we are relocating it (destructive)
         */
        if (!nvTextureFreeLinearSurface(pTexture)) return FALSE;
    }

    /*
     * allocate texture surface
     */
    pTexture->dwLinearAddr = pTexture->dwLinearOffset
                           = 0;
    if (!nvTextureAllocSurface(pTexture->lpDriverObject,dwAllocFlags,dwAllocPrefs,dwSize,
                               &dwAddr,&dwAllocFlags)) return FALSE;

    /*
     * get offset
     */
    pTexture->dwLinearAddr    = dwAddr;
    pTexture->dwLinearOffset  = GetTextureOffsetFromAddr(dwAddr,dwAllocFlags);
    pTexture->dwTextureFlags &= ~(NV4_TEXLOC_ANYWHERE << NV4_TEXMASK_LINEAR_SHIFT);
    pTexture->dwTextureFlags |=  (dwAllocFlags        << NV4_TEXMASK_LINEAR_SHIFT);

    /*
     * done
     */
    return TRUE;
}

/*
 * nvTextureFreeLinearSurface
 *
 * frees a linear surface
 */
BOOL nvTextureFreeLinearSurface
(
    PNVD3DTEXTURE pTexture
)
{
#ifdef DEBUG
    if (!pTexture)
    {
        DPF ("nvTextureFreeLinearSurface: pTexture == NULL");
        dbgD3DError();
        __asm int 3;
        return FALSE;
    }
#endif // DEBUG

    if (pTexture->dwLinearAddr)
    {
        if (!nvTextureFreeSurface(pTexture->lpDriverObject,
                                  pTexture->dwLinearAddr,
                                  pTexture->dwMipMapSizeBytes,
                                  pTexture->dwTextureFlags >> NV4_TEXMASK_LINEAR_SHIFT)) return FALSE;
    }

    pTexture->dwLinearAddr = pTexture->dwLinearOffset
                           = 0;
    pTexture->dwTextureFlags &= ~(NV4_TEXLOC_ANYWHERE << NV4_TEXMASK_LINEAR_SHIFT);

    return FALSE;
}

/*
 * nvUpdateSwizzleSurface
 *
 * create and/or fill the swizzled surface from the linear surface
 * very much like the legacy nvLoadTexture
 */
BOOL nvUpdateSwizzleSurface
(
    PNVD3DTEXTURE pTexture
)
{
    DWORD dwIndex;

#ifdef DEBUG
    if (!pTexture)
    {
        DPF ("nvUpdateSwizzleSurface: pTexture == NULL");
        dbgD3DError();
        __asm int 3;
        return FALSE;
    }
#endif // DEBUG

    /*
     * get texture info
     */
    dwIndex = TEX_SWIZZLE_INDEX(pTexture->dwTextureFlags);

    /*
     * does surface exist already?
     */
    if (!TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags))
    {
        /*
         * no - create it now
         */
        DWORD dwAllocFlags = pDriverData->GARTLinearBase ? (NV4_TEXLOC_VID | NV4_TEXLOC_AGP)
                                                         : (NV4_TEXLOC_VID | NV4_TEXLOC_PCI);
        DWORD dwAllocPrefs = NV4_TEXLOC_NOWHERE; // preference
        if (pTexture->lpLcl)
        {
            /*
             * agp / pci
             */
            if (pTexture->lpLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
            {
                if (pDriverData->GARTLinearBase)
                    dwAllocPrefs = NV4_TEXLOC_AGP;
                else
                    dwAllocPrefs = NV4_TEXLOC_PCI;
            }

            /*
             * video
             */
            if (dwAllocPrefs == NV4_TEXLOC_NOWHERE)
            {
                dwAllocPrefs = NV4_TEXLOC_VID;
            }
        }
        if (!nvTextureAllocSwizzleSurface(pTexture,pTexture->dwMipMapSizeBytes,dwAllocFlags,dwAllocPrefs))
        {
            return FALSE;
        }
    }
    else
    {
        /*
         * is surface already up to date?
         *  texels must be valid and
         */
        if (pTexture->dwSwizzleFlags[dwIndex] & NV4_TEXFLAG_VALID)
        {
            return TRUE;
        }
    }

#ifdef DEBUG
    /*
     * is the source up to date?
     *  if not we cannot do any work. the algorithm always assume at least one
     *  surface to be valid (have up-to-date texels)
     */
    if (!(pTexture->dwTextureFlags & NV4_TEXFLAG_LINEAR_VALID))
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvUpdateSwizzleSurface: Both swizzle and linear not valid.");
    }
#endif


    /*
     * perform swizzle (nv4swiz.c)
     */
    nvSwizzleBlt (pTexture->dwLinearAddr, pTexture->dwTextureFlags >> NV4_TEXMASK_LINEAR_SHIFT,
                      pTexture->dwMipMapBaseU,pTexture->dwMipMapBaseV,
                      pTexture->dwDirtyX0,pTexture->dwDirtyY0,pTexture->dwDirtyX1,pTexture->dwDirtyY1,
                      pTexture->dwPitch,
                      pTexture,
                  TEX_SWIZZLE_ADDR(pTexture,dwIndex),TEX_SWIZZLE_FLAGS(pTexture,dwIndex) & NV4_TEXMASK_LOCATION,
                      pTexture->dwMipMapBaseU,pTexture->dwMipMapBaseV,
                      pTexture->dwDirtyX0,pTexture->dwDirtyY0,
                      pTexture->dwPitch,
                      pTexture,
                  pTexture->dwBPP,
                  NV_SWIZFLAG_SRCLINEAR | NV_SWIZFLAG_DESTSWIZZLED | NV_SWIZFLAG_ALLOWHW
#ifdef HW_PAL8
                      | ((pTexture->dwTextureFlags & NV4_TEXFLAG_PALETTIZED) ?
                      NV_SWIZFLAG_PALETTIZED : 0)
#endif
                  );

    /*
     * update flags & reset dirty rectangle. kill auto mips if they are enabled
     */
    if (pTexture->dwTextureFlags & NV4_TEXFLAG_AUTOMIPMAP)
    {
        pTexture->dwTextureFlags   &= ~NV4_TEXFLAG_AUTOMIPMAP_VALID;
        pTexture->dwMipMapLevels    = 1;
        pTexture->dwAutoMipMapScene = pCurrentContext->dwSceneCount + NV4_TEXDEFAULT_AUTOMIPMAPTIME;

        /*
         * force hw reprogram
         */
        pCurrentContext->dwStateChange = TRUE;
        NV_FORCE_TRI_SETUP(pCurrentContext);
    }
    pTexture->dwSwizzleFlags[dwIndex] |= NV4_TEXFLAG_VALID;
    pTexture->dwDirtyX0 = pTexture->dwDirtyY0
                        = pTexture->dwDirtyX1
                        = pTexture->dwDirtyY1
                        = 0;
    /*
     * done
     */
    return TRUE;
}

/*
 * nvUpdateLinearSurface
 *
 * create and/or fill the linear surface from the swizzled surface
 */
BOOL nvUpdateLinearSurface
(
    PNVD3DTEXTURE pTexture
)
{
    DWORD dwIndex;

#ifdef DEBUG
    if (!pTexture)
    {
        DPF ("nvUpdateLinearSurface: pTexture == NULL");
        dbgD3DError();
        __asm int 3;
        return FALSE;
    }
#endif // DEBUG

    /*
     * cache texture info
     */
    dwIndex = TEX_SWIZZLE_INDEX(pTexture->dwTextureFlags);

    /*
     * does surface exist already?
     */
    if (!pTexture->dwLinearAddr)
    {
        /*
         * no - create it now
         */
        DWORD dwAllocFlags = pDriverData->GARTLinearBase ? (NV4_TEXLOC_VID | NV4_TEXLOC_AGP | NV4_TEXLOC_SYS)
                                                         : (NV4_TEXLOC_VID | NV4_TEXLOC_PCI | NV4_TEXLOC_SYS);
        if (!nvTextureAllocLinearSurface(pTexture,
                                         pTexture->dwPitch * pTexture->dwHeight,
                                         dwAllocFlags,
                                         dwAllocFlags & (NV4_TEXLOC_AGP | NV4_TEXLOC_PCI)))
        {
            return FALSE;
        }
    }
    else
    {
        /*
         * is surface already up to date?
         */
        if (pTexture->dwTextureFlags & NV4_TEXFLAG_LINEAR_VALID)
        {
            return TRUE;
        }
    }

    /*
     * Is the swizzle surface valid?
     *  if so then we deswizzle here. This is skipped usually when the app wants to
     *  lock the texture and haven't touched a pixel yet
     */
    if (pTexture->dwSwizzleFlags[dwIndex] & NV4_TEXFLAG_VALID)
    {
        /*
         * obtain access
         */
        nvTextureBlock (pTexture->dwRetireDate[dwIndex]);

        /*
         * perform deswizzle (nv4swiz.c)
         */
        nvSwizzleBlt (TEX_SWIZZLE_ADDR(pTexture,dwIndex),TEX_SWIZZLE_FLAGS(pTexture,dwIndex) & NV4_TEXMASK_LOCATION,
                          pTexture->dwMipMapBaseU,pTexture->dwMipMapBaseV,
                          pTexture->dwDirtyX0,pTexture->dwDirtyY0,pTexture->dwDirtyX1,pTexture->dwDirtyY1,
                          pTexture->dwPitch,
                          pTexture,
                      pTexture->dwLinearAddr, pTexture->dwTextureFlags >> NV4_TEXMASK_LINEAR_SHIFT,
                          pTexture->dwMipMapBaseU,pTexture->dwMipMapBaseV,
                          pTexture->dwDirtyX0,pTexture->dwDirtyY0,
                          pTexture->dwPitch,
                          pTexture,
                      pTexture->dwBPP,
                      NV_SWIZFLAG_SRCSWIZZLED | NV_SWIZFLAG_DESTLINEAR | NV_SWIZFLAG_ALLOWHW);
    }

    /*
     * update flags & reset dirty rectangle
     */
    pTexture->dwTextureFlags |= NV4_TEXFLAG_LINEAR_VALID;
    pTexture->dwDirtyX0       = pTexture->dwDirtyY0
                              = pTexture->dwDirtyX1
                              = pTexture->dwDirtyY1
                              = 0;

    /*
     * done
     */
    return TRUE;
}

#endif // NV_TEX2
/*****************************************************************************
 * Legacy code
 *****************************************************************************/

#ifndef NV_TEX2

BOOL nvFillTextureBuffer16Bpp(DWORD,DWORD,DWORD,DWORD,DWORD,DWORD);
BOOL nvFillTextureBuffer32Bpp(DWORD,DWORD,DWORD,DWORD,DWORD,DWORD);
BOOL nvHWSwizzleBlit(DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD);
BOOL nvVideoTextureBlit(WORD,WORD,WORD,WORD,WORD,WORD,DWORD,DWORD,WORD,WORD,WORD,WORD,WORD,WORD,DWORD,DWORD,DWORD,DWORD,WORD,WORD,DWORD);

#endif //!NV_TEX2


/*
 * --------------------------------------------------------------------------
 * NV Specific Texture routines. (legacy)
 * --------------------------------------------------------------------------
 */

/*
 * nvAllocateInternalTexture
 *
 * allocates the swizzled surface for a texture.
 * legacy code names 'internal' what we now call 'swizzle'
 *               and 'user'     what we now call 'linear'
 */
BOOL nvAllocateInternalTexture
(
    PNVD3DTEXTURE   pTexture
)
{
#ifdef NV_TEX2
    DWORD dwAllocFlags;
    DWORD dwAllocPrefs;

#ifdef DEBUG
    if (!pTexture)
    {
        DPF ("nvAllocateInternalTexture: pTexture == NULL");
        dbgD3DError();
        __asm int 3;
        return FALSE;
    }
    if (!pTexture->dwMipMapSizeBytes)
    {
        DPF ("nvAllocateInternalTexture: pTexture->dwMipMapSizeBytes == 0");
        dbgD3DError();
        __asm int 3;
        return FALSE;
    }
#endif // DEBUG

    /*
     * deterine alloc flags & prefs
     */
    dwAllocFlags = (pDriverData->GARTLinearBase) ? (NV4_TEXLOC_VID | NV4_TEXLOC_AGP)
                                                 : (NV4_TEXLOC_VID | NV4_TEXLOC_PCI);

    dwAllocPrefs = NV4_TEXLOC_NOWHERE; // preference
    if (pTexture->lpLcl)
    {
        /*
         * agp / pci
         */
        if (pTexture->lpLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
        {
            if (pDriverData->GARTLinearBase)
                dwAllocPrefs = NV4_TEXLOC_AGP;
            else
                dwAllocPrefs = NV4_TEXLOC_PCI;
        }

        /*
         * video
         */
        if (dwAllocPrefs == NV4_TEXLOC_NOWHERE)
        {
            dwAllocPrefs = NV4_TEXLOC_VID;
        }
    }

    /*
     * allocate surface
     */
    if (!nvTextureAllocSwizzleSurface(pTexture,pTexture->dwMipMapSizeBytes,dwAllocFlags,dwAllocPrefs))
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvAllocateInternalTexture: Internal Texture Allocation Failed");
        dbgD3DError();
        return (FALSE);
    }

    /*
     * Handy statistics.
     */
    statTextureCountTotal++;
    statTextureOmniCountTotal++;
    statTextureSizeTotal += pTexture->dwMipMapSizeBytes;
    statTextureOmniSizeTotal += pTexture->dwMipMapSizeBytes;

    if (pTexture->lpLcl->lpGbl->ddpfSurface.dwFlags & DDPF_PALETTEINDEXED8) {
        statTextureOmniCountPalette++;
        statTextureOmniSizePalette += pTexture->dwMipMapSizeBytes;
    }

    /*
     * done
     */
    return TRUE;

#else // !NV_TEX2

#ifndef NVHEAPMGR
    LPDDRAWI_DIRECTDRAW_GBL pdrv = pTexture->lpDriverObject;
#endif
    /*
     * First check if Non-Local video memory explicitly specified.
     * If so, then don't try and put this texture in video memory unless there's no
     * room left in non-local memory.
     */
    if ((pTexture->lpLcl)
     && (pTexture->lpLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM))
    {
        if (pDriverData->GARTLinearBase > 0)
        {
            /*
             * On AGP, allocate call DDRAW to allocate the AGP memory.
             */
            pTexture->dwTexturePointer = AllocAGPHeap(pTexture->lpDriverObject, pTexture->dwMipMapSizeBytes);
            if (pTexture->dwTexturePointer)
            {
                /*
                 * Calculate the offset from the AGP heap base to the start of the texture data.
                 */
                pTexture->dwTextureOffset     = pTexture->dwTexturePointer - pDriverData->GARTLinearBase;
                pTexture->dwTextureContextDma = NV054_FORMAT_CONTEXT_DMA_A;

                /*
                 * Handy statistics.
                 */
                statTextureCountAgpHeap++;
                statTextureSizeAgpHeap += pTexture->dwMipMapSizeBytes;
                statTextureDimensionMinAgpHeap = min(statTextureDimensionMinAgpHeap, pTexture->dwWidth);
                statTextureDimensionMaxAgpHeap = max(statTextureDimensionMaxAgpHeap, pTexture->dwWidth);
                DPF_LEVEL(NVDBG_LEVEL_INFO, "nvAllocateInternalTexture: AGP Memory Allocated");
            }
            else
                DPF_LEVEL(NVDBG_LEVEL_INFO, "nvAllocateInternalTexture: AGP Memory Allocation failed");

        }
        else
        {
            /*
             * On PCI, allocate from our internal texture heap.
             */
            pTexture->dwTexturePointer = AllocTextureHeap(pTexture->dwMipMapSizeBytes);
            if (pTexture->dwTexturePointer)
            {
                pTexture->dwTextureOffset     = pTexture->dwTexturePointer;
                pTexture->dwTextureContextDma = NV054_FORMAT_CONTEXT_DMA_A;

                /*
                 * Handy statistics.
                 */
                statTextureCountPciHeap++;
                statTextureSizePciHeap += pTexture->dwMipMapSizeBytes;
                statTextureDimensionMinPciHeap = min(statTextureDimensionMinPciHeap, pTexture->dwWidth);
                statTextureDimensionMaxPciHeap = max(statTextureDimensionMaxPciHeap, pTexture->dwWidth);
                DPF_LEVEL(NVDBG_LEVEL_INFO, "nvAllocateInternalTexture: PCI Memory Allocated");
            }
            else
                DPF_LEVEL(NVDBG_LEVEL_INFO, "nvAllocateInternalTexture: PCI Memory Allocation failed");
        }
    }

    /*
     * If the memory hasn't been allocated yet, try putting it in local video memory.
     */
    if ((!pTexture->dwTexturePointer)
     && (pDriverData->regD3DEnableBits1 & REG_BIT1_VIDEO_TEXTURE_ENABLE))
    {
        /*
         * Try putting the texture in video memory first if it meets the size requirement.
         */
        if (pTexture->dwWidth >= pDriverData->regMinVideoTextureSize)
        {
            /*
             * Call DDRAW to allocate memory from the video memory heap.
             */
#ifndef WINNT
            NVHEAP_ALLOC(pTexture->dwTexturePointer, pTexture->dwMipMapSizeBytes, TYPE_TEXTURE);
#else
            NVHEAP_ALLOC(pTexture->dwTexturePointer, (pTexture->dwMipMapSizeBytes + NV_TEXTURE_PAD + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad, TYPE_TEXTURE);
#endif  // !WINNT
            //pTexture->dwTexturePointer = DDHAL32_VidMemAlloc(pTexture->lpDriverObject, 0, (pTexture->dwMipMapSizeBytes + NV_TEXTURE_PAD + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad, 1);
            if (pTexture->dwTexturePointer)
            {
                /*
                 * Calculate the offset from the video heap base to the start of texture data.
                 */
                pTexture->dwTextureOffset      = ((pTexture->dwTexturePointer + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN) - pDriverData->BaseAddress;
                pTexture->dwTextureContextDma  = NV054_FORMAT_CONTEXT_DMA_B;
                pTexture->dwTextureFlags      |= NV3_TEXTURE_VIDEO_MEMORY;

                /*
                 * Show where the texture was allocated.
                 */
                pTexture->lpLcl->ddsCaps.dwCaps &= ~(DDSCAPS_NONLOCALVIDMEM | DDSCAPS_LOCALVIDMEM);
                pTexture->lpLcl->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;

                /*
                 * Increment count of video memory surfaces allocated.
                 */
                pDriverData->DDrawVideoSurfaceCount++;

                /*
                 * Handy statistics.
                 */
                statTextureCountVideo++;
                statTextureSizeVideo += pTexture->dwMipMapSizeBytes;
                statTextureDimensionMinVideo = min(statTextureDimensionMinVideo, pTexture->dwWidth);
                statTextureDimensionMaxVideo = max(statTextureDimensionMaxVideo, pTexture->dwWidth);
                DPF_LEVEL(NVDBG_LEVEL_INFO, "nvAllocateInternalTexture: Video Memory Allocated");
            }
            else
                DPF_LEVEL(NVDBG_LEVEL_INFO, "nvAllocateInternalTexture: Video Memory Allocation failed");
        }
    }

    /*
     * If the texture wasn't put into video memory, then try to put it in the system memory heap.
     */
    if (!pTexture->dwTexturePointer)
    {
        if (pDriverData->GARTLinearBase > 0)
        {
            /*
             * On AGP, allocate call DDRAW to allocate the AGP memory.
             */
            pTexture->dwTexturePointer = AllocAGPHeap(pTexture->lpDriverObject, pTexture->dwMipMapSizeBytes);
            if (pTexture->dwTexturePointer)
            {
                /*
                 * Calculate the offset from the AGP heap base to the start of the texture data.
                 */
                pTexture->dwTextureOffset     = pTexture->dwTexturePointer - pDriverData->GARTLinearBase;
                pTexture->dwTextureContextDma = NV054_FORMAT_CONTEXT_DMA_A;

                /*
                 * Show where the texture was allocated.
                 */
                pTexture->lpLcl->ddsCaps.dwCaps &= ~(DDSCAPS_NONLOCALVIDMEM | DDSCAPS_LOCALVIDMEM);
                pTexture->lpLcl->ddsCaps.dwCaps |= DDSCAPS_NONLOCALVIDMEM;

                /*
                 * Handy statistics.
                 */
                statTextureCountAgpHeap++;
                statTextureSizeAgpHeap += pTexture->dwMipMapSizeBytes;
                statTextureDimensionMinAgpHeap = min(statTextureDimensionMinAgpHeap, pTexture->dwWidth);
                statTextureDimensionMaxAgpHeap = max(statTextureDimensionMaxAgpHeap, pTexture->dwWidth);
                DPF_LEVEL(NVDBG_LEVEL_INFO, "nvAllocateInternalTexture: AGP Memory Allocated");
            }
            else
                DPF_LEVEL(NVDBG_LEVEL_INFO, "nvAllocateInternalTexture: AGP Memory Allocation failed");
        }
        else
        {
            /*
             * On PCI, allocate from our internal texture heap.
             */
            pTexture->dwTexturePointer = AllocTextureHeap(pTexture->dwMipMapSizeBytes);
            if (pTexture->dwTexturePointer)
            {
                pTexture->dwTextureOffset     = pTexture->dwTexturePointer;
                pTexture->dwTextureContextDma = NV054_FORMAT_CONTEXT_DMA_A;

                /*
                 * Show where the texture was allocated.
                 */
                pTexture->lpLcl->ddsCaps.dwCaps &= ~(DDSCAPS_NONLOCALVIDMEM | DDSCAPS_LOCALVIDMEM);
                pTexture->lpLcl->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;

                /*
                 * Handy statistics.
                 */
                statTextureCountPciHeap++;
                statTextureSizePciHeap += pTexture->dwMipMapSizeBytes;
                statTextureDimensionMinPciHeap = min(statTextureDimensionMinPciHeap, pTexture->dwWidth);
                statTextureDimensionMaxPciHeap = max(statTextureDimensionMaxPciHeap, pTexture->dwWidth);
                DPF_LEVEL(NVDBG_LEVEL_INFO, "nvAllocateInternalTexture: PCI Memory Allocated");
            }
            else
                DPF_LEVEL(NVDBG_LEVEL_INFO, "nvAllocateInternalTexture: PCI Memory Allocation failed");
        }
        if (pTexture->dwTexturePointer)
            pTexture->dwTextureFlags   &= ~NV3_TEXTURE_VIDEO_MEMORY;
        else
        {
            /*
             * Unable to allocate the texture.  Will need to do special
             * handling for this texture every time it is used.
             */
            if (pDriverData->regD3DEnableBits1 & REG_BIT1_VIDEO_TEXTURE_ENABLE)
            {
                /*
                 * Call DDRAW to allocate memory from the video memory heap.
                 */
#ifndef WINNT
                NVHEAP_ALLOC(pTexture->dwTexturePointer, pTexture->dwMipMapSizeBytes, TYPE_TEXTURE);
#else
                NVHEAP_ALLOC(pTexture->dwTexturePointer, (pTexture->dwMipMapSizeBytes + NV_TEXTURE_PAD + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad, TYPE_TEXTURE);
#endif  // !WINNT
                //pTexture->dwTexturePointer = DDHAL32_VidMemAlloc(pTexture->lpDriverObject, 0, (pTexture->dwMipMapSizeBytes + NV_TEXTURE_PAD + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad, 1);
                if (pTexture->dwTexturePointer)
                {
                    /*
                     * Calculate the offset from the video heap base to the start of texture data.
                     */
                    pTexture->dwTextureOffset      = ((pTexture->dwTexturePointer + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN) - pDriverData->BaseAddress;
                    pTexture->dwTextureContextDma  = NV054_FORMAT_CONTEXT_DMA_B;
                    pTexture->dwTextureFlags      |= NV3_TEXTURE_VIDEO_MEMORY;

                    /*
                     * Show where the texture was allocated.
                     */
                    pTexture->lpLcl->ddsCaps.dwCaps &= ~(DDSCAPS_NONLOCALVIDMEM | DDSCAPS_LOCALVIDMEM);
                    pTexture->lpLcl->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;

                    /*
                     * Increment count of video memory surfaces allocated.
                     */
                    pDriverData->DDrawVideoSurfaceCount++;

                    /*
                     * Handy statistics.
                     */
                    statTextureCountVideo++;
                    statTextureSizeVideo += pTexture->dwMipMapSizeBytes;
                    statTextureDimensionMinVideo = min(statTextureDimensionMinVideo, pTexture->dwWidth);
                    statTextureDimensionMaxVideo = max(statTextureDimensionMaxVideo, pTexture->dwWidth);
                    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvAllocateInternalTexture: Video Memory Allocated");
                }
                else
                    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvAllocateInternalTexture: Video Memory Allocation failed");
            }
        }
    }

    /*
     * If there is no valid texture pointer at this point, then there simply is no memory left
     * to allocate it.  Return the error.
     */
    if (!pTexture->dwTexturePointer)
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvAllocateInternalTexture: Internal Texture Allocation Failed");
        dbgD3DError();
        return (FALSE);
    }

    /*
     * Show that the internal texture memory has been allocated.
     * Also, since the memory has just been allocted, it can't possibly have valid
     * texture data, so mark it in need of loading.
     */
    pTexture->dwTextureFlags |= NV3_TEXTURE_INTERNAL_ALLOCATED;

    /*
     * Handy statistics.
     */
    statTextureCountTotal++;
    statTextureOmniCountTotal++;
    statTextureSizeTotal += pTexture->dwMipMapSizeBytes;
    statTextureOmniSizeTotal += pTexture->dwMipMapSizeBytes;

    if (pTexture->lpLcl->lpGbl->ddpfSurface.dwFlags & DDPF_PALETTEINDEXED8) {
        statTextureOmniCountPalette++;
        statTextureOmniSizePalette += pTexture->dwMipMapSizeBytes;
    }

    /*
     * Texture has been successfully created (but NOT loaded)
     */
    return (TRUE);
#endif // !NV_TEX2
}

/*
 * nvDestroyInternalTexture
 *
 * frees the swizzled surface for a texture.
 * legacy code names 'internal' what we now call 'swizzle'
 *               and 'user'     what we now call 'linear'
 */
BOOL nvDestroyInternalTexture
(
    PNVD3DCONTEXT   pContext,
    PNVD3DTEXTURE   pTexture
)
{
#ifdef NV_TEX2

#ifdef DEBUG
    if (!pTexture)
    {
        DPF ("nvDestroyInternalTexture: pTexture == NULL");
        dbgD3DError();
        __asm int 3;
        return FALSE;
    }
#endif // DEBUG

    /*
     * Validate the texture.
     */
    if (!pTexture) return FALSE;

    /*
     * Check for work
     */
    if (!TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags)) return TRUE;

    /*
     * Deallocate the internal texture surface.
     */
    if (!nvTextureFreeSwizzleSurface(pTexture))
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvDestroyInternalTexture: Internal Texture Deallocation Failed");
        dbgD3DError();
        return FALSE;
    }

    /*
     * Update texture statistics.
     */
    statTextureCountTotal--;
    statTextureSizeTotal -= pTexture->dwMipMapSizeBytes;

    /*
     * done
     */
    return TRUE;

#else !NV_TEX2

#ifndef NVHEAPMGR
    LPDDRAWI_DIRECTDRAW_GBL pdrv     = pTexture->lpDriverObject;
#endif

    /*
     * Validate the texture.
     */
    if (!pTexture)
        return (FALSE);

    /*
     * Deallocate the internal texture surface.
     */
    if (!pTexture->dwTexturePointer)
        return (TRUE);

    if (pTexture->dwTextureFlags & NV3_TEXTURE_VIDEO_MEMORY)
    {
        /*
         * Call DDRAW to de-allocate memory from the video memory heap.
         */
        NVHEAP_FREE (pTexture->dwTexturePointer);
        //DDHAL32_VidMemFree(pTexture->lpDriverObject, 0, pTexture->dwTexturePointer);

        /*
         * Decrement count of video memory surfaces allocated.
         */
        pDriverData->DDrawVideoSurfaceCount--;

        /*
         * Update texture statistics.
         */
        statTextureCountVideo--;
        statTextureSizeVideo -= pTexture->dwMipMapSizeBytes;
    }
    else
    {

        if (pDriverData->GARTLinearBase > 0)
        {
            /*
             * On AGP call DDRAW to de-allocate memory from AGP heap.
             */
            FreeAGPHeap(pTexture->lpDriverObject, pTexture->dwTexturePointer);

            /*
             * Update texture statistics.
             */
            statTextureCountAgpHeap--;
            statTextureSizeAgpHeap -= pTexture->dwMipMapSizeBytes;
        }
        else
        {
            /*
             * On PCI, de-allocate from our internal texture heap.
             */
            FreeTextureHeap(pTexture->dwTexturePointer);

            /*
             * Update texture statistics.
             */
            statTextureCountPciHeap--;
            statTextureSizePciHeap -= pTexture->dwMipMapSizeBytes;
        }
    }
    pTexture->dwTexturePointer  = (DWORD)NULL;
    pTexture->dwTextureOffset   = (DWORD)NULL;
    pTexture->dwTextureFlags   &= ~NV3_TEXTURE_INTERNAL_ALLOCATED;

    /*
     * Update texture statistics.
     */
    statTextureCountTotal--;
    statTextureSizeTotal -= pTexture->dwMipMapSizeBytes;
    return (TRUE);

#endif // !NV_TEX2
}


#ifndef NV_TEX2

void nvSwizzleTexture16Bpp
(
    DWORD   dwSrcX0,
    DWORD   dwSrcY0,
    DWORD   dwSrcX1,
    DWORD   dwSrcY1,
    DWORD   dwWidth,
    DWORD   dwHeight,
    DWORD   dwSrcPitch,
    DWORD   dwSrcLinearBase,
    DWORD   dwDstX0,
    DWORD   dwDstY0,
    DWORD   dwDstSwizzleBase
)
{
    DWORD   u0, u, v;
    DWORD   uInc, uInc2, vInc, uMask, vMask;
    DWORD   xSrcCurrent, ySrcCurrent;
    unsigned short *pSrcLinear;
    unsigned short *pDstSwizzle;

    U_INTERLEAVE(u0, dwDstX0, dwWidth, dwHeight);
    V_INTERLEAVE(v,  dwDstY0, dwWidth, dwHeight);
    U_INC2_MASK(uInc, uInc2, uMask, dwHeight);
    V_INC_MASK(vInc, vMask, dwWidth);
    pDstSwizzle = (unsigned short *)dwDstSwizzleBase;
    /*
     * X1 is exclusive, so if X1 is even, then the real last texel is on an odd boundry and will
     * be included in the last DWORD copied by the inne