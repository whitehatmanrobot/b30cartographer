ize -= Avail;
            Done += Avail;
        }
    }
    __except(MappingExceptionFilter(GetExceptionInformation()))
    {
        Done = 0;
    }

    return Done;
}

ULONG
DmppWriteFileOffset(ULONG FileIndex,
                    ULONG64 Offset, PVOID Buffer, ULONG BufferSize)
{
    ULONG Done = 0;
    ULONG Avail;
    PUCHAR Mapping;
    ULONG Protect;
    PDUMP_INFO_FILE File = &g_DumpInfoFiles[FileIndex];

    if (File->File == NULL)
    {
        // Information for this kind of file wasn't provided.
        return 0;
    }
    
    __try
    {
        while (BufferSize > 0)
        {
            Mapping = DmppFileOffsetToMappedAddress(File, Offset, TRUE,
                                                    &Avail);
            if (Mapping == NULL)
            {
                break;
            }

            if (Avail > BufferSize)
            {
                Avail = BufferSize;
            }
            VirtualProtect(Mapping, Avail, PAGE_WRITECOPY, &Protect);
            memcpy(Mapping, Buffer, Avail);

            Offset += Avail;
            Buffer = (PUCHAR)Buffer + Avail;
            BufferSize -= Avail;
            Done += Avail;
        }
    }
    __except(MappingExceptionFilter(GetExceptionInformation()))
    {
        Done = 0;
    }

    return Done;
}

HRESULT
AddDumpInfoFile(PCSTR FileName, ULONG Index, ULONG InitialView)
{
    HRESULT Status;
    PDUMP_INFO_FILE File = &g_DumpInfoFiles[Index];
    
    DBG_ASSERT(((g_DumpCacheGranularity - 1) & InitialView) == 0);

    if (File->File != NULL)
    {
        return E_INVALIDARG;
    }

    // We have to share everything in order to be
    // able to reopen already-open temporary files
    // expanded from CABs as they are marked as
    // delete-on-close.
    File->File = CreateFile(FileName,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE |
                            FILE_SHARE_DELETE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);
    if (File->File == INVALID_HANDLE_VALUE)
    {
        goto LastStatus;
    }

    //
    // Get file size and map initial view.
    //

    ULONG SizeLow, SizeHigh;

    SizeLow = GetFileSize(File->File, &SizeHigh);
    File->FileSize = ((ULONG64)SizeHigh << 32) | SizeLow;
    File->Map = CreateFileMapping(File->File, NULL, PAGE_READONLY,
                                  0, 0, NULL);
    if (File->Map == NULL)
    {
        goto LastStatus;
    }

    if (File->FileSize < InitialView)
    {
        InitialView = (ULONG)File->FileSize;
    }

    File->MapBase = MapViewOfFile(File->Map, FILE_MAP_READ, 0, 0,
                                  InitialView);
    if (File->MapBase == NULL)
    {
        goto LastStatus;
    }

    switch(Index)
    {
    case DUMP_INFO_PAGE_FILE:
        if (memcmp(File->MapBase, DMPPF_IDENTIFIER,
                   sizeof(DMPPF_IDENTIFIER) - 1) != 0)
        {
            Status = HR_DUMP_CORRUPT;
            goto Fail;
        }
        break;
    }
    
    File->MapSize = InitialView;
    DmppDumpFileCacheInit(File);
    
    return S_OK;
    
 LastStatus:
    Status = WIN32_LAST_STATUS();
 Fail:
    CloseDumpInfoFile(Index);
    return Status;
}

void
CloseDumpInfoFile(ULONG Index)
{
    PDUMP_INFO_FILE File = &g_DumpInfoFiles[Index];

    if (Index == DUMP_INFO_DUMP)
    {
        g_DumpBase = NULL;
    }
    
    DmppDumpFileCacheCleanup(File);
    if (File->MapBase != NULL)
    {
        UnmapViewOfFile(File->MapBase);
        File->MapBase = NULL;
    }
    if (File->Map != NULL)
    {
        CloseHandle(File->Map);
        File->Map = NULL;
    }
    if (File->File != NULL && File->File != INVALID_HANDLE_VALUE)
    {
        CloseHandle(File->File);
    }
    File->File = NULL;
}

void
CloseDumpInfoFiles(void)
{
    ULONG i;

    for (i = 0; i < DUMP_INFO_COUNT; i++)
    {
        CloseDumpInfoFile(i);
    }
}

HRESULT
DmpInitialize(LPCSTR FileName)
{
    HRESULT Status;

    dprintf("\nLoading Dump File [%s]\n", FileName);

    if ((Status = AddDumpInfoFile(FileName, DUMP_INFO_DUMP,
                                  DUMP_INITIAL_VIEW_SIZE)) != S_OK)
    {
        return Status;
    }

    PDUMP_INFO_FILE File = &g_DumpInfoFiles[DUMP_INFO_DUMP];
    ULONG i;
    ULONG64 BaseMapSize;

    g_DumpBase = File->MapBase;
    for (i = 0; i < DTYPE_COUNT; i++)
    {
        BaseMapSize = File->MapSize;
        Status = g_DumpTargets[i]->IdentifyDump(&BaseMapSize);
        if (Status != E_NOINTERFACE)
        {
            break;
        }
    }

    if (Status == E_NOINTERFACE)
    {
        ErrOut("Could not match Dump File signature - "
               "invalid file format\n");
    }
    else if (Status == S_OK &&
             BaseMapSize > File->MapSize)
    {
        if (BaseMapSize > File->FileSize ||
            BaseMapSize > DUMP_MAXIMUM_VIEW_SIZE)
        {
            ErrOut("Dump file is too large to map\n");
            Status = E_INVALIDARG;
        }
        else
        {
            // Target requested a larger mapping so
            // try and do so.  Round up to a multiple
            // of the initial view size for cache alignment.
            BaseMapSize =
                (BaseMapSize + DUMP_INITIAL_VIEW_SIZE - 1) &
                ~(DUMP_INITIAL_VIEW_SIZE - 1);
            if (BaseMapSize > File->FileSize)
            {
                BaseMapSize = File->FileSize;
            }
            UnmapViewOfFile(File->MapBase);
            File->MapBase = MapViewOfFile(File->Map, FILE_MAP_READ,
                                          0, 0, (ULONG)BaseMapSize);
            if (File->MapBase == NULL)
            {
                Status = WIN32_LAST_STATUS();
            }
        }
    }

    if (Status == S_OK)
    {
        File->MapSize = (ULONG)BaseMapSize;
        g_DumpType = (DTYPE)i;
        g_DumpBase = File->MapBase;
    }
    else
    {
        CloseDumpInfoFile(DUMP_INFO_DUMP);
    }
    
    return Status;
}

VOID
DmpUninitialize(VOID)
{
    if (g_DumpType < DTYPE_COUNT)
    {
        g_DumpTargets[g_DumpType]->Uninitialize();
        g_DumpType = DTYPE_COUNT;
    }
}

HRESULT
DmppInitGlobals(ULONG BuildNumber, ULONG CheckedBuild,
                ULONG MachineType, ULONG PlatformId,
                ULONG MajorVersion, ULONG MinorVersion)
{
    SetTargetSystemVersionAndBuild(BuildNumber, PlatformId);
    g_TargetCheckedBuild = CheckedBuild;
    DbgKdApi64 = (g_SystemVersion > NT_SVER_NT4);
    HRESULT Status = InitializeMachines(MachineType);
    if (Status != S_OK)
    {
        return Status;
    }
    if (g_TargetMachine == NULL)
    {
        ErrOut("Dump has an unknown processor type, 0x%X\n", MachineType);
        return HR_DUMP_CORRUPT;
    }

    g_TargetPlatformId = PlatformId;

    g_KdVersion.MachineType = (USHORT) MachineType;
    g_KdVersion.MajorVersion = (USHORT) MajorVersion;
    g_KdVersion.MinorVersion = (USHORT) MinorVersion;
    g_KdVersion.Flags = DBGKD_VERS_FLAG_DATA |
        (g_TargetMachine->m_Ptr64 ? DBGKD_VERS_FLAG_PTR64 : 0);

    return S_OK;
}

//----------------------------------------------------------------------------
//
// DumpTargetInfo.
//
//----------------------------------------------------------------------------

void
DumpTargetInfo::Uninitialize(void)
{
    CloseDumpInfoFiles();
    g_DumpType = DTYPE_COUNT;
    g_DumpFormatFlags = 0;
}

HRESULT
DumpTargetInfo::ReadVirtual(
    ULONG64 Offset,
    PVOID Buffer,
    ULONG BufferSize,
    PULONG BytesRead
    )
{
    ULONG Done = 0;
    ULONG FileIndex;
    ULONG Avail;
    ULONG Attempt;
    ULONG64 FileOffset;

    if (BufferSize == 0)
    {
        *BytesRead = 0;
        return S_OK;
    }

    while (BufferSize > 0)
    {
        FileOffset = VirtualToOffset(Offset, &FileIndex, &Avail);
        if (FileOffset == 0)
        {
            break;
        }

        if (Avail > BufferSize)
        {
            Avail = BufferSize;
        }

        Attempt = DmppReadFileOffset(FileIndex, FileOffset, Buffer, Avail);
        Done += Attempt;

        if (Attempt < Avail)
        {
            break;
        }

        Offset += Avail;
        Buffer = (PUCHAR)Buffer + Avail;
        BufferSize -= Avail;
    }

    *BytesRead = Done;
    // If we didn't read anything return an error.
    return Done == 0 ? E_FAIL : S_OK;
}

HRESULT
DumpTargetInfo::WriteVirtual(
    ULONG64 Offset,
    PVOID Buffer,
    ULONG BufferSize,
    PULONG BytesWritten
    )
{
    ULONG Done = 0;
    ULONG FileIndex;
    ULONG Avail;
    ULONG Attempt;
    ULONG64 FileOffset;

    if (BufferSize == 0)
    {
        *BytesWritten = 0;
        return S_OK;
    }

    while (BufferSize > 0)
    {
        FileOffset = VirtualToOffset(Offset, &FileIndex, &Avail);
        if (FileOffset == 0)
        {
            break;
        }

        if (Avail > BufferSize)
        {
            Avail = BufferSize;
        }

        Attempt = DmppWriteFileOffset(FileIndex, FileOffset, Buffer, Avail);
        Done += Attempt;

        if (Attempt < Avail)
        {
            break;
        }

        Offset += Avail;
        Buffer = (PUCHAR)Buffer + Avail;
        BufferSize -= Avail;
    }

    *BytesWritten = Done;
    // If we didn't write anything return an error.
    return Done == 0 ? E_FAIL : S_OK;
}

HRESULT
DumpTargetInfo::Write(HANDLE hFile, ULONG FormatFlags, PCSTR Comment)
{
    ErrOut("Dump file type does not support writing\n");
    return E_NOTIMPL;
}

//----------------------------------------------------------------------------
//
// KernelDumpTargetInfo.
//
//----------------------------------------------------------------------------

void
OutputHeaderString(PCSTR Format, PSTR Str)
{
    if (*(PULONG)Str == DUMP_SIGNATURE32 ||
        Str[0] == 0)
    {
        // String not present.
        return;
    }

    dprintf(Format, Str);
}

void
KernelDumpTargetInfo::Uninitialize(void)
{
    m_HeaderContext = NULL;
    ZeroMemory(g_DumpKiProcessors, sizeof(g_DumpKiProcessors));
    g_DumpKiPcrBaseAddress = 0;
    DumpTargetInfo::Uninitialize();
}

HRESULT
DmppReadControlSpaceAxp(
    ULONG   Processor,
    ULONG64 Offset,
    PVOID   Buffer,
    ULONG   BufferSize,
    PULONG  BytesRead
    )
{
    ULONG64 StartAddr;
    ULONG Read = 0;
    HRESULT Status;
    ULONG PtrSize = g_TargetMachine->m_Ptr64 ?
        sizeof(ULONG64) : sizeof(ULONG);

    if (BufferSize < PtrSize)
    {
        return E_INVALIDARG;
    }

    switch(Offset)
    {
    case ALPHA_DEBUG_CONTROL_SPACE_PCR:
        if (g_DumpKiPcrBaseAddress == 0)
        {
            WarnOut("Unable to determine KiPcrBaseAddress\n");
            Status = E_FAIL;
        }
        else
        {
            // Return the PCR address for the current processor.
            Status = g_Target->ReadVirtual(g_DumpKiPcrBaseAddress,
                                           Buffer,
                                           PtrSize, &Read);
        }
        break;

    case ALPHA_DEBUG_CONTROL_SPACE_PRCB:
        //
        // Return the prcb address for the current processor.
        //
        memcpy(Buffer, &g_DumpKiProcessors[Processor], PtrSize);
        Read = PtrSize;
        Status = S_OK;
        break;

    case ALPHA_DEBUG_CONTROL_SPACE_THREAD:
        //
        // Return the pointer to the current thread address for the
        // current processor.
        //
        StartAddr = g_DumpKiProcessors[Processor] +
            (g_TargetMachine->m_Ptr64 ?
             KPRCB_CURRENT_THREAD_OFFSET_64 :
             KPRCB_CURRENT_THREAD_OFFSET_32);
        Status = g_Target->ReadVirtual(StartAddr, Buffer,
                                       PtrSize, &Read);
        break;

    case ALPHA_DEBUG_CONTROL_SPACE_TEB:
        //
        // Return the current Thread Environment Block pointer for the
        // current thread on the current processor.
        //
        StartAddr = g_DumpKiProcessors[Processor] +
            (g_TargetMachine->m_Ptr64 ?
             KPRCB_CURRENT_THREAD_OFFSET_64 :
             KPRCB_CURRENT_THREAD_OFFSET_32);
        Status = g_Target->ReadPointer(g_TargetMachine, StartAddr, &StartAddr);
        if (Status == S_OK)
        {
            StartAddr += g_TargetMachine->m_OffsetKThreadTeb;
            Status = g_Target->ReadVirtual(StartAddr, Buffer,
                                           PtrSize, &Read);
        }
        break;
    }

    *BytesRead = Read;
    return Status;
}

HRESULT
DmppReadControlSpaceIa64(
    ULONG   Processor,
    ULONG64 Offset,
    PVOID   Buffer,
    ULONG   BufferSize,
    PULONG  BytesRead
    )
{
    ULONG64 StartAddr;
    ULONG Read = 0;
    HRESULT Status;

    if (BufferSize < sizeof(ULONG64))
    {
        return E_INVALIDARG;
    }

    switch(Offset)
    {
    case IA64_DEBUG_CONTROL_SPACE_PCR:
        StartAddr = g_DumpKiProcessors[Processor] +
            FIELD_OFFSET(IA64_PARTIAL_KPRCB, PcrPage);
        Status = g_Target->ReadVirtual(StartAddr, &StartAddr,
                                       sizeof(StartAddr), &Read);
        if (Status == S_OK && Read == sizeof(StartAddr))
        {
            *(PULONG64)Buffer =
                (StartAddr << IA64_PAGE_SHIFT) + IA64_PHYSICAL1_START;
        }
        break;

    case IA64_DEBUG_CONTROL_SPACE_PRCB:
        *(PULONG64)Buffer = g_DumpKiProcessors[Processor];
        Read = sizeof(ULONG64);
        Status = S_OK;
        break;

    case IA64_DEBUG_CONTROL_SPACE_KSPECIAL:
        StartAddr = g_DumpKiProcessors[Processor] +
            FIELD_OFFSET(IA64_PARTIAL_KPRCB, ProcessorState.SpecialRegisters);
        Status = g_Target->ReadVirtual(StartAddr, Buffer, BufferSize, &Read);
        break;

    case IA64_DEBUG_CONTROL_SPACE_THREAD:
        StartAddr = g_DumpKiProcessors[Processor] +
            FIELD_OFFSET(IA64_PARTIAL_KPRCB, CurrentThread);
        Status = g_Target->ReadVirtual(StartAddr, Buffer,
                                       sizeof(ULONG64), &Read);
        break;
    }

    *BytesRead = Read;
    return Status;
}

HRESULT
DmppReadControlSpaceAmd64(
    ULONG   Processor,
    ULONG64 Offset,
    PVOID   Buffer,
    ULONG   BufferSize,
    PULONG  BytesRead
    )
{
    ULONG64 StartAddr;
    ULONG Read = 0;
    HRESULT Status;

    if (BufferSize < sizeof(ULONG64))
    {
        return E_INVALIDARG;
    }

    switch(Offset)
    {
    case AMD64_DEBUG_CONTROL_SPACE_PCR:
        *(PULONG64)Buffer = g_DumpKiProcessors[Processor] -
            FIELD_OFFSET(AMD64_KPCR, Prcb);
        Read = sizeof(ULONG64);
        Status = S_OK;
        break;

    case AMD64_DEBUG_CONTROL_SPACE_PRCB:
        *(PULONG64)Buffer = g_DumpKiProcessors[Processor];
        Read = sizeof(ULONG64);
        Status = S_OK;
        break;

    case AMD64_DEBUG_CONTROL_SPACE_KSPECIAL:
        StartAddr = g_DumpKiProcessors[Processor] +
            FIELD_OFFSET(AMD64_PARTIAL_KPRCB, ProcessorState.SpecialRegisters);
        Status = g_Target->ReadVirtual(StartAddr, Buffer, BufferSize, &Read);
        break;

    case AMD64_DEBUG_CONTROL_SPACE_THREAD:
        StartAddr = g_DumpKiProcessors[Processor] +
            FIELD_OFFSET(AMD64_PARTIAL_KPRCB, CurrentThread);
        Status = g_Target->ReadVirtual(StartAddr, Buffer,
                                       sizeof(ULONG64), &Read);
        break;
    }

    *BytesRead = Read;
    return Status;
}

HRESULT
KernelDumpTargetInfo::ReadControl(
    IN ULONG Processor,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesRead
    )
{
    ULONG64 StartAddr;

    //
    // This function will not currently work if the symbols are not loaded.
    //
    if (!IS_KERNEL_TRIAGE_DUMP() &&
        KdDebuggerData.KiProcessorBlock == 0)
    {
        ErrOut("ReadControl failed - ntoskrnl symbols must be loaded first\n");

        return E_FAIL;
    }

    if (g_DumpKiProcessors[Processor] == 0)
    {
        // This error message is a little too verbose.
#if 0
        ErrOut("No control space information for processor %d\n", Processor);
#endif
        return E_FAIL;
    }

    switch(g_TargetMachineType)
    {
    case IMAGE_FILE_MACHINE_I386:
        StartAddr = Offset +
            g_DumpKiProcessors[Processor] +
            g_TargetMachine->m_OffsetPrcbProcessorState;
        return ReadVirtual(StartAddr, Buffer, BufferSize, BytesRead);

    case IMAGE_FILE_MACHINE_ALPHA:
    case IMAGE_FILE_MACHINE_AXP64:
        return DmppReadControlSpaceAxp(Processor, Offset, Buffer,
                                       BufferSize, BytesRead);

    case IMAGE_FILE_MACHINE_IA64:
        return DmppReadControlSpaceIa64(Processor, Offset, Buffer,
                                        BufferSize, BytesRead);

    case IMAGE_FILE_MACHINE_AMD64:
        return DmppReadControlSpaceAmd64(Processor, Offset, Buffer,
                                         BufferSize, BytesRead);
    }

    return E_FAIL;
}

HRESULT
KernelDumpTargetInfo::GetThreadIdByProcessor(
    IN ULONG Processor,
    OUT PULONG Id
    )
{
    *Id = VIRTUAL_THREAD_ID(Processor);
    return S_OK;
}

HRESULT
KernelDumpTargetInfo::GetThreadInfoDataOffset(PTHREAD_INFO Thread,
                                              ULONG64 ThreadHandle,
                                              PULONG64 Offset)
{
    return KdGetThreadInfoDataOffset(Thread, ThreadHandle, Offset);
}

HRESULT
KernelDumpTargetInfo::GetProcessInfoDataOffset(PTHREAD_INFO Thread,
                                               ULONG Processor,
                                               ULONG64 ThreadData,
                                               PULONG64 Offset)
{
    return KdGetProcessInfoDataOffset(Thread, Processor, ThreadData, Offset);
}

HRESULT
KernelDumpTargetInfo::GetThreadInfoTeb(PTHREAD_INFO Thread,
                                       ULONG ThreadIndex,
                                       ULONG64 ThreadData,
                                       PULONG64 Offset)
{
    return KdGetThreadInfoTeb(Thread, ThreadIndex, ThreadData, Offset);
}

HRESULT
KernelDumpTargetInfo::GetProcessInfoPeb(PTHREAD_INFO Thread,
                                        ULONG Processor,
                                        ULONG64 ThreadData,
                                        PULONG64 Offset)
{
    return KdGetProcessInfoPeb(Thread, Processor, ThreadData, Offset);
}

ULONG64
KernelDumpTargetInfo::GetCurrentTimeDateN(void)
{
    if (g_SystemVersion < NT_SVER_W2K)
    {
        ULONG64 TimeDate;

        // Header time not available.  Try and read
        // the time saved in the shared user data segment.
        if (ReadSharedUserTimeDateN(&TimeDate) == S_OK)
        {
            return TimeDate;
        }
        else
        {
            return 0;
        }
    }

    return g_TargetMachine->m_Ptr64 ?
        ((PDUMP_HEADER64)g_DumpBase)->SystemTime.QuadPart :
        ((PDUMP_HEADER32)g_DumpBase)->SystemTime.QuadPart;
}

ULONG64
KernelDumpTargetInfo::GetCurrentSystemUpTimeN(void)
{
    ULONG64 page = 'EGAP';
    ULONG64 page64 = page | (page << 32);

    ULONG64 SystemUpTime = g_TargetMachine->m_Ptr64 ?
        ((PDUMP_HEADER64)g_DumpBase)->SystemUpTime.QuadPart :
        ((PDUMP_HEADER32)g_DumpBase)->SystemUpTime.QuadPart;

    if (SystemUpTime && (SystemUpTime != page64))
    {
        return SystemUpTime;
    }

    // Header time not available.  Try and read
    // the time saved in the shared user data segment.

    if (ReadSharedUserUpTimeN(&SystemUpTime) == S_OK)
    {
        return SystemUpTime;
    }
    else
    {
        return 0;
    }
}

HRESULT
KernelDumpTargetInfo::InitGlobals32(PMEMORY_DUMP32 Dump)
{
    if (Dump->Header.DirectoryTableBase == 0)
    {
        ErrOut("Invalid directory table base value 0x%x\n",
               Dump->Header.DirectoryTableBase);
        return HR_DUMP_CORRUPT;
    }
    
    if (Dump->Header.MinorVersion > 1381 &&
        Dump->Header.PaeEnabled == TRUE )
    {
        KdDebuggerData.PaeEnabled = TRUE;
    }
    else
    {
        KdDebuggerData.PaeEnabled = FALSE;
    }

    KdDebuggerData.PsLoadedModuleList =
        EXTEND64(Dump->Header.PsLoadedModuleList);
    g_TargetNumberProcessors = Dump->Header.NumberProcessors;
    ExceptionRecord32To64(&Dump->Header.Exception, &g_DumpException);
    g_DumpExceptionFirstChance = FALSE;
    m_HeaderContext = Dump->Header.ContextRecord;

    // New field in Windows Whistler and NT SP1 and above
    if ((Dump->Header.KdDebuggerDataBlock) &&
        (Dump->Header.KdDebuggerDataBlock != DUMP_SIGNATURE32))
    {
        g_KdDebuggerDataBlock = EXTEND64(Dump->Header.KdDebuggerDataBlock);
    }

    OutputHeaderString("Comment: '%s'\n", Dump->Header.Comment);

    HRESULT Status =
        DmppInitGlobals(Dump->Header.MinorVersion,
                        Dump->Header.MajorVersion & 0xFF,
                        Dump->Header.MachineImageType,
                        VER_PLATFORM_WIN32_NT,
                        Dump->Header.MajorVersion,
                        Dump->Header.MinorVersion);
    if (Status != S_OK)
    {
        return Status;
    }

    ULONG NextIdx;
    
    return g_TargetMachine->
        SetPageDirectory(PAGE_DIR_KERNEL, Dump->Header.DirectoryTableBase,
                         &NextIdx);
}

HRESULT
KernelDumpTargetInfo::InitGlobals64(PMEMORY_DUMP64 Dump)
{
    if (Dump->Header.DirectoryTableBase == 0)
    {
        ErrOut("Invalid directory table base value 0x%I64x\n",
               Dump->Header.DirectoryTableBase);
        return HR_DUMP_CORRUPT;
    }
    
    KdDebuggerData.PaeEnabled = FALSE;
    KdDebuggerData.PsLoadedModuleList =
        Dump->Header.PsLoadedModuleList;
    g_TargetNumberProcessors = Dump->Header.NumberProcessors;
    g_DumpException = Dump->Header.Exception;
    g_DumpExceptionFirstChance = FALSE;
    m_HeaderContext = Dump->Header.ContextRecord;

    // New field in Windows Whistler and NT SP1 and above
    if ((Dump->Header.KdDebuggerDataBlock) &&
        (Dump->Header.KdDebuggerDataBlock != DUMP_SIGNATURE32))
    {
        g_KdDebuggerDataBlock = Dump->Header.KdDebuggerDataBlock;
    }

    OutputHeaderString("Comment: '%s'\n", Dump->Header.Comment);

    HRESULT Status =
        DmppInitGlobals(Dump->Header.MinorVersion,
                        Dump->Header.MajorVersion & 0xFF,
                        Dump->Header.MachineImageType,
                        VER_PLATFORM_WIN32_NT,
                        Dump->Header.MajorVersion,
                        Dump->Header.MinorVersion);
    if (Status != S_OK)
    {
        return Status;
    }

    ULONG NextIdx;
    
    return g_TargetMachine->
        SetPageDirectory(PAGE_DIR_KERNEL, Dump->Header.DirectoryTableBase,
                         &NextIdx);
}

void
KernelDumpTargetInfo::DumpHeader32(PDUMP_HEADER32 Header)
{
    dprintf("\nDUMP_HEADER32:\n");
    dprintf("MajorVersion        %08lx\n", Header->MajorVersion);
    dprintf("MinorVersion        %08lx\n", Header->MinorVersion);
    dprintf("DirectoryTableBase  %08lx\n", Header->DirectoryTableBase);
    dprintf("PfnDataBase         %08lx\n", Header->PfnDataBase);
    dprintf("PsLoadedModuleList  %08lx\n", Header->PsLoadedModuleList);
    dprintf("PsActiveProcessHead %08lx\n", Header->PsActiveProcessHead);
    dprintf("MachineImageType    %08lx\n", Header->MachineImageType);
    dprintf("NumberProcessors    %08lx\n", Header->NumberProcessors);
    dprintf("BugCheckCode        %08lx\n", Header->BugCheckCode);
    dprintf("BugCheckParameter1  %08lx\n", Header->BugCheckParameter1);
    dprintf("BugCheckParameter2  %08lx\n", Header->BugCheckParameter2);
    dprintf("BugCheckParameter3  %08lx\n", Header->BugCheckParameter3);
    dprintf("BugCheckParameter4  %08lx\n", Header->BugCheckParameter4);
    OutputHeaderString("VersionUser         '%s'\n", Header->VersionUser);
    dprintf("PaeEnabled          %08lx\n", Header->PaeEnabled);
    dprintf("KdDebuggerDataBlock %08lx\n", Header->KdDebuggerDataBlock);
    OutputHeaderString("Comment             '%s'\n", Header->Comment);
}

void
KernelDumpTargetInfo::DumpHeader64(PDUMP_HEADER64 Header)
{
    dprintf("\nDUMP_HEADER64:\n");
    dprintf("MajorVersion        %08lx\n", Header->MajorVersion);
    dprintf("MinorVersion        %08lx\n", Header->MinorVersion);
    dprintf("DirectoryTableBase  %s\n",
            FormatAddr64(Header->DirectoryTableBase));
    dprintf("PfnDataBase         %s\n",
            FormatAddr64(Header->PfnDataBase));
    dprintf("PsLoadedModuleList  %s\n",
            FormatAddr64(Header->PsLoadedModuleList));
    dprintf("PsActiveProcessHead %s\n",
            FormatAddr64(Header->PsActiveProcessHead));
    dprintf("MachineImageType    %08lx\n", Header->MachineImageType);
    dprintf("NumberProcessors    %08lx\n", Header->NumberProcessors);
    dprintf("BugCheckCode        %08lx\n", Header->BugCheckCode);
    dprintf("BugCheckParameter1  %s\n",
            FormatAddr64(Header->BugCheckParameter1));
    dprintf("BugCheckParameter2  %s\n",
            FormatAddr64(Header->BugCheckParameter2));
    dprintf("BugCheckParameter3  %s\n",
            FormatAddr64(Header->BugCheckParameter3));
    dprintf("BugCheckParameter4  %s\n",
            FormatAddr64(Header->BugCheckParameter4));
    OutputHeaderString("VersionUser         '%s'\n", Header->VersionUser);
    dprintf("KdDebuggerDataBlock %s\n",
            FormatAddr64(Header->KdDebuggerDataBlock));
    OutputHeaderString("Comment             '%s'\n", Header->Comment);
}

//----------------------------------------------------------------------------
//
// KernelFullSumDumpTargetInfo.
//
//----------------------------------------------------------------------------

HRESULT
PageFileOffset(ULONG PfIndex, ULONG64 PfOffset, PULONG64 FileOffset)
{
    PDUMP_INFO_FILE File = &g_DumpInfoFiles[DUMP_INFO_PAGE_FILE];
    if (File->File == NULL)
    {
        return HR_PAGE_NOT_AVAILABLE;
    }
    if (PfIndex > MAX_PAGING_FILE_MASK)
    {
        return HR_DUMP_CORRUPT;
    }

    //
    // We can safely assume the header information is present
    // in the base mapping.
    //
    
    DMPPF_FILE_HEADER* Hdr = (DMPPF_FILE_HEADER*)File->MapBase;
    DMPPF_PAGE_FILE_INFO* FileInfo = &Hdr->PageFiles[PfIndex];
    ULONG64 PfPage = PfOffset >> g_TargetMachine->m_PageShift;

    if (PfPage >= FileInfo->MaximumSize)
    {
        return HR_PAGE_NOT_AVAILABLE;
    }

    ULONG i;
    ULONG PageDirOffs = sizeof(*Hdr) + (ULONG)PfPage * sizeof(ULONG);

    for (i = 0; i < PfIndex; i++)
    {
        PageDirOffs += Hdr->PageFiles[i].MaximumSize * sizeof(ULONG);
    }

    ULONG PageDirEnt;

    if (DmppReadFileOffset(DUMP_INFO_PAGE_FILE, PageDirOffs,
                           &PageDirEnt, sizeof(PageDirEnt)) !=
        sizeof(PageDirEnt))
    {
        return HR_DUMP_CORRUPT;
    }

    if (PageDirEnt == DMPPF_PAGE_NOT_PRESENT)
    {
        return HR_PAGE_NOT_AVAILABLE;
    }

    *FileOffset = Hdr->PageData +
        (PageDirEnt << g_TargetMachine->m_PageShift) +
        (PfOffset & (g_Machine->m_PageSize - 1));
    return S_OK;
}

HRESULT
KernelFullSumDumpTargetInfo::Initialize(void)
{
    InitSelCache();
    m_ProvokingVirtAddr = 0;
    return S_OK;
}

HRESULT
KernelFullSumDumpTargetInfo::ReadPhysical(
    ULONG64 Offset,
    PVOID Buffer,
    ULONG BufferSize,
    PULONG BytesRead
    )
{
    ULONG Done = 0;
    ULONG Avail;
    ULONG Attempt;
    ULONG64 FileOffset;

    if (BufferSize == 0)
    {
        *BytesRead = 0;
        return S_OK;
    }

    while (BufferSize > 0)
    {
        FileOffset = PhysicalToOffset(Offset, &Avail);
        if (FileOffset == 0)
        {
            break;
        }

        if (Avail > BufferSize)
        {
            Avail = BufferSize;
        }

        Attempt = DmppReadFileOffset(DUMP_INFO_DUMP,
                                     FileOffset, Buffer, Avail);
        Done += Attempt;

        if (Attempt < Avail)
        {
            break;
        }

        Offset += Avail;
        Buffer = (PUCHAR)Buffer + Avail;
        BufferSize -= Avail;
    }

    *BytesRead = Done;
    // If we didn't read anything return an error.
    return Done == 0 ? E_FAIL : S_OK;
}

HRESULT
KernelFullSumDumpTargetInfo::WritePhysical(
    ULONG64 Offset,
    PVOID Buffer,
    ULONG BufferSize,
    PULONG BytesWritten
    )
{
    ULONG Done = 0;
    ULONG Avail;
    ULONG Attempt;
    ULONG64 FileOffset;

    if (BufferSize == 0)
    {
        *BytesWritten = 0;
        return S_OK;
    }

    while (BufferSize > 0)
    {
        FileOffset = PhysicalToOffset(Offset, &Avail);
        if (FileOffset == 0)
        {
            break;
        }

        if (Avail > BufferSize)
        {
            Avail = BufferSize;
        }

        Attempt = DmppWriteFileOffset(DUMP_INFO_DUMP,
                                      FileOffset, Buffer, Avail);
        Done += Attempt;

        if (Attempt < Avail)
        {
            break;
        }

        Offset += Avail;
        Buffer = (PUCHAR)Buffer + Avail;
        BufferSize -= Avail;
    }

    *BytesWritten = Done;
    // If we didn't write anything return an error.
    return Done == 0 ? E_FAIL : S_OK;
}

HRESULT
KernelFullSumDumpTargetInfo::GetProcessorId
    (ULONG Processor, PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id)
{
    return g_TargetMachine->ReadKernelProcessorId(Processor, Id);
}

HRESULT
KernelFullSumDumpTargetInfo::ReadPageFile(ULONG PfIndex, ULONG64 PfOffset,
                                          PVOID Buffer, ULONG Size)
{
    HRESULT Status;
    ULONG64 FileOffset;

    if ((Status = PageFileOffset(PfIndex, PfOffset, &FileOffset)) != S_OK)
    {
        return Status;
    }

    // It's assumed that all page file reads are for the
    // entire amount requested, as there are no situations
    // where it's useful to only read part of a page from the
    // page file.
    if (DmppReadFileOffset(DUMP_INFO_PAGE_FILE, FileOffset,
                           Buffer, Size) < Size)
    {
        return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
    }
    else
    {
        return S_OK;
    }
}

HRESULT
KernelFullSumDumpTargetInfo::GetTargetContext(
    ULONG64 Thread,
    PVOID Context
    )
{
    ULONG Read;
    HRESULT Status;

    Status = ReadVirtual(g_DumpKiProcessors[VIRTUAL_THREAD_INDEX(Thread)] +
                         g_TargetMachine->m_OffsetPrcbProcessorState,
                         Context, g_TargetMachine->m_SizeTargetContext,
                         &Read);
    if (Status != S_OK)
    {
        return Status;
    }

    return Read == g_TargetMachine->m_SizeTargetContext ? S_OK : E_FAIL;
}

HRESULT
KernelFullSumDumpTargetInfo::GetSelDescriptor(MachineInfo* Machine,
                                              ULONG64 Thread,
                                              ULONG Selector,
                                              PDESCRIPTOR64 Desc)
{
    return KdGetSelDescriptor(Machine, Thread, Selector, Desc);
}

void
KernelFullSumDumpTargetInfo::DumpDebug(void)
{
    ULONG i;

    dprintf("\nKiProcessorBlock at %s\n",
            FormatAddr64(KdDebuggerData.KiProcessorBlock));
    dprintf("  %d KiProcessorBlock entries:\n ", g_TargetNumberProcessors);
    for (i = 0; i < g_TargetNumberProcessors; i++)
    {
        dprintf(" %s", FormatAddr64(g_DumpKiProcessors[i]));
    }
    dprintf("\n");

    PDUMP_INFO_FILE PageDump = &g_DumpInfoFiles[DUMP_INFO_PAGE_FILE];
    if (PageDump->File != NULL)
    {
        // XXX drewb - Display more information when format is understood.
        dprintf("\nAdditional page file in use\n");
    }
}

ULONG64
KernelFullSumDumpTargetInfo::VirtualToOffset(ULONG64 Virt,
                                             PULONG File, PULONG Avail)
{
    HRESULT Status;
    ULONG Levels;
    ULONG PfIndex;
    ULONG64 Phys;

    *File = DUMP_INFO_DUMP;
    
    if ((Status = g_TargetMachine->
         GetVirtualTranslationPhysicalOffsets(Virt, NULL, 0, &Levels,
                                              &PfIndex, &Phys)) != S_OK)
    {
        // If the virtual address was paged out we got back
        // a page file reference for the address.  The user
        // may have provided a page file in addition to the
        // normal dump file so translate the reference into
        // a secondary dump information file request.
        if (Status == HR_PAGE_IN_PAGE_FILE)
        {
            if (PageFileOffset(PfIndex, Phys, &Phys) != S_OK)
            {
                return 0;
            }
            
            *File = DUMP_INFO_PAGE_FILE;
            // Page files always have complete pages so the amount
            // available is always the remainder of the page.
            ULONG PageIndex = (ULONG)Virt & (g_TargetMachine->m_PageSize - 1);
            *Avail = g_TargetMachine->m_PageSize - PageIndex;
            return Phys;
        }
        else
        {
            return 0;
        }
    }
    else
    {
        ULONG64 Offs;

        // A summary dump will not contain any pages that
        // are mapped by user-mode addresses.  The virtual
        // translation tables may still have valid mappings,
        // though, so VToO will succeed.  We want to suppress
        // page-not-available messages in this case since
        // the dump is known not to contain user pages.
        // Record the provoking virtual address so that
        // summary dump's PhysicalToOffset will know whether
        // a message should be displayed or not.

        m_ProvokingVirtAddr = Virt;

        Offs = PhysicalToOffset(Phys, Avail);

        m_ProvokingVirtAddr = 0;

        return Offs;
    }
}

ULONG
KernelFullSumDumpTargetInfo::GetCurrentProcessor(void)
{
    ULONG i;

    for (i = 0; i < g_TargetNumberProcessors; i++)
    {
        CROSS_PLATFORM_CONTEXT Context;

        if (g_Target->GetContext(VIRTUAL_THREAD_HANDLE(i), &Context) == S_OK)
        {
            switch(g_TargetMachineType)
            {
            case IMAGE_FILE_MACHINE_I386:
                if (Context.X86Nt5Context.Esp ==
                    ((PX86_NT5_CONTEXT)m_HeaderContext)->Esp)
                {
                    return i;
                }
                break;

            case IMAGE_FILE_MACHINE_ALPHA:
                if (g_SystemVersion <= NT_SVER_NT4)
                {
                    if (Context.AlphaNt5Context.IntSp ==
                        (((PALPHA_CONTEXT)m_HeaderContext)->IntSp |
                         ((ULONG64)((PALPHA_CONTEXT)m_HeaderContext)->
                          HighIntSp << 32)))
                    {
                        return i;
                    }
                    break;
                }
                // Fall through.

            case IMAGE_FILE_MACHINE_AXP64:
                if (Context.AlphaNt5Context.IntSp ==
                    ((PALPHA_NT5_CONTEXT)m_HeaderContext)->IntSp)
                {
                    return i;
                }
                break;

            case IMAGE_FILE_MACHINE_IA64:
                if (Context.IA64Context.IntSp ==
                    ((PIA64_CONTEXT)m_HeaderContext)->IntSp)
                {
                    return i;
                }
                break;

            case IMAGE_FILE_MACHINE_AMD64:
                if (Context.Amd64Context.Rsp ==
                    ((PAMD64_CONTEXT)m_HeaderContext)->Rsp)
                {
                    return i;
                }
                break;
            }
        }
    }

    // Give up and just pick the default processor.
    return 0;
}

//----------------------------------------------------------------------------
//
// KernelSummaryDumpTargetInfo.
//
//----------------------------------------------------------------------------

void
KernelSummaryDumpTargetInfo::Uninitialize(void)
{
    delete m_LocationCache;
    m_LocationCache = NULL;
    m_PageBitmapSize = 0;
    ZeroMemory(&m_PageBitmap, sizeof(m_PageBitmap));
    KernelDumpTargetInfo::Uninitialize();
}

void
KernelSummaryDumpTargetInfo::ConstructLocationCache(ULONG BitmapSize,
                                                    ULONG SizeOfBitMap,
                                                    PULONG Buffer)
{
    PULONG Cache;
    ULONG Index;
    ULONG Offset;

    m_PageBitmapSize = BitmapSize;
    m_PageBitmap.SizeOfBitMap = SizeOfBitMap;
    m_PageBitmap.Buffer = Buffer;

    //
    // Create a direct mapped cache.
    //

    Cache = new ULONG[BitmapSize];
    if (!Cache)
    {
        // Not a failure; there just won't be a cache.
        return;
    }

    //
    // For each bit set in the bitmask fill the appropriate cache
    // line location with the correct offset
    //

    Offset = 0;
    for (Index = 0; Index < BitmapSize; Index++)
    {
        //
        // If this page is in the summary dump fill in the offset
        //

        if ( RtlCheckBit (&m_PageBitmap, Index) )
        {
            Cache[ Index ] = Offset++;
        }
    }

    //
    // Assign back to the global storing the cache data.
    //

    m_LocationCache = Cache;
}

ULONG64
KernelSummaryDumpTargetInfo::SumPhysicalToOffset(ULONG HeaderSize,
                                                 ULONG64 Phys,
                                                 PULONG Avail)
{
    ULONG Offset, j;
    ULONG64 Page = Phys >> g_TargetMachine->m_PageShift;

    //
    // Make sure this page is included in the dump
    //

    if ( Page >= m_PageBitmapSize )
    {
        ErrOut("Page %x too large to be in the dump file.\n", Page);
        return 0;
    }

    if ( !RtlCheckBit ( &m_PageBitmap, Page ) )
    {
        // If this page lookup is the result of a user-mode
        // address translation it's guaranteed that
        // the page won't be present since summary dumps
        // exclude user pages.  Don't bother displaying
        // an error message in that case.
        if (!m_ProvokingVirtAddr || m_ProvokingVirtAddr >= g_SystemRangeStart)
        {
            ErrOut("Page %x not present in the dump file.\n", Page);
        }
        return 0;
    }

    //
    // If the cache exists then find the location the easy way
    //

    if (m_LocationCache != NULL)
    {
        Offset = m_LocationCache[ Page ];
    }
    else
    {
        //
        // CAVEAT This code will never execute unless there is a failure
        //        creating the summary dump (cache) mapping information
        //
        //
        // The page is in the summary dump locate it's offset
        // Note: this is painful. The offset is a count of
        // all the bits set up to this page
        //

        Offset = 0;

        for (j = 0; j < m_PageBitmapSize; j++ )
        {
            if ( RtlCheckBit( &m_PageBitmap, j ) )
            {
                //
                // If the offset is equal to the page were done.
                //

                if (j == Page)
                {
                    break;
                }

                Offset++;
            }
        }

        //
        // Sanity check that we didn't drop out of the loop.
        //

        if ( j >= m_PageBitmapSize )
        {
            return 0;
        }
    }

    //
    // The actual address is calculated as follows
    // Header size    - Size of header plus summary dump header
    //

    ULONG PageIndex = (ULONG)Phys & (g_TargetMachine->m_PageSize - 1);
    *Avail = g_TargetMachine->m_PageSize - PageIndex;
    return HeaderSize + (Offset * g_TargetMachine->m_PageSize) + PageIndex;
}

HRESULT
KernelSummary32DumpTargetInfo::Initialize(void)
{
    // Pick up any potentially modified base mapping pointer.
    m_Dump = (PMEMORY_DUMP32)g_DumpBase;

    dprintf("Kernel Summary Dump File: "
            "Only kernel address space is available\n\n");

    g_TargetClass          = DEBUG_CLASS_KERNEL;
    g_TargetClassQualifier = DEBUG_KERNEL_DUMP;

    ConstructLocationCache(m_Dump->Summary.BitmapSize,
                           m_Dump->Summary.Bitmap.SizeOfBitMap,
                           m_Dump->Summary.Bitmap.Buffer);
    g_DumpInfoFiles[DUMP_INFO_DUMP].FileSize = m_Dump->Header.RequiredDumpSpace.QuadPart;

    HRESULT Status = InitGlobals32(m_Dump);
    if (Status != S_OK)
    {
        return Status;
    }

    return KernelFullSumDumpTargetInfo::Initialize();
}

void
KernelSummary32DumpTargetInfo::Uninitialize(void)
{
    m_Dump = NULL;
    KernelSummaryDumpTargetInfo::Uninitialize();
}

HRESULT
KernelSummary32DumpTargetInfo::ReadBugCheckData(PULONG Code, ULONG64 Args[4])
{
    *Code = m_Dump->Header.BugCheckCode;
    Args[0] = EXTEND64(m_Dump->Header.BugCheckParameter1);
    Args[1] = EXTEND64(m_Dump->Header.BugCheckParameter2);
    Args[2] = EXTEND64(m_Dump->Header.BugCheckParameter3);
    Args[3] = EXTEND64(m_Dump->Header.BugCheckParameter4);
    return S_OK;
}

HRESULT
KernelSummary32DumpTargetInfo::IdentifyDump(PULONG64 BaseMapSize)
{
    HRESULT Status = E_NOINTERFACE;
    PMEMORY_DUMP32 Dump = (PMEMORY_DUMP32)g_DumpBase;

    if (Dump->Header.Signature != DUMP_SIGNATURE32 ||
        Dump->Header.ValidDump != DUMP_VALID_DUMP32)
    {
        return Status;
    }

    __try
    {
        if (Dump->Header.DumpType == DUMP_TYPE_SUMMARY)
        {
            if (Dump->Summary.Signature != DUMP_SUMMARY_SIGNATURE)
            {
                // The header says it's a summary dump but
                // it doesn't have a valid signature, so assume
                // it's not a valid dump.
                Status = HR_DUMP_CORRUPT;
            }
            else
            {
                Status = S_OK;
                m_Dump = Dump;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return Status;
}

ULONG64
KernelSummary32DumpTargetInfo::PhysicalToOffset(ULONG64 Phys, PULONG Avail)
{
    return SumPhysicalToOffset(m_Dump->Summary.HeaderSize, Phys, Avail);
}

HRESULT
KernelSummary64DumpTargetInfo::Initialize(void)
{
    // Pick up any potentially modified base mapping pointer.
    m_Dump = (PMEMORY_DUMP64)g_DumpBase;

    dprintf("Kernel Summary Dump File: "
            "Only kernel address space is available\n\n");

    g_TargetClass          = DEBUG_CLASS_KERNEL;
    g_TargetClassQualifier = DEBUG_KERNEL_DUMP;

    ConstructLocationCache(m_Dump->Summary.BitmapSize,
                           m_Dump->Summary.Bitmap.SizeOfBitMap,
                           m_Dump->Summary.Bitmap.Buffer);
    g_DumpInfoFiles[DUMP_INFO_DUMP].FileSize = m_Dump->Header.RequiredDumpSpace.QuadPart;

    HRESULT Status = InitGlobals64(m_Dump);
    if (Status != S_OK)
    {
        return Status;
    }

    return KernelFullSumDumpTargetInfo::Initialize();
}

void
KernelSummary32DumpTargetInfo::DumpDebug(void)
{
    PSUMMARY_DUMP32 Sum = &m_Dump->Summary;

    dprintf("----- 32 bit Kernel Summary Dump Analysis\n");

    DumpHeader32(&m_Dump->Header);

    dprintf("\nSUMMARY_DUMP32:\n");
    dprintf("DumpOptions         %08lx\n", Sum->DumpOptions);
    dprintf("HeaderSize          %08lx\n", Sum->HeaderSize);
    dprintf("BitmapSize          %08lx\n", Sum->BitmapSize);
    dprintf("Pages               %08lx\n", Sum->Pages);
    dprintf("Bitmap.SizeOfBitMap %08lx\n", Sum->Bitmap.SizeOfBitMap);

    KernelFullSumDumpTargetInfo::DumpDebug();
}

void
KernelSummary64DumpTargetInfo::Uninitialize(void)
{
    m_Dump = NULL;
    KernelSummaryDumpTargetInfo::Uninitialize();
}

HRESULT
KernelSummary64DumpTargetInfo::ReadBugCheckData(PULONG Code, ULONG64 Args[4])
{
    *Code = m_Dump->Header.BugCheckCode;
    Args[0] = m_Dump->Header.BugCheckParameter1;
    Args[1] = m_Dump->Header.BugCheckParameter2;
    Args[2] = m_Dump->Header.BugCheckParameter3;
    Args[3] = m_Dump->Header.BugCheckParameter4;
    return S_OK;
}

HRESULT
KernelSummary64DumpTargetInfo::IdentifyDump(PULONG64 BaseMapSize)
{
    HRESULT Status = E_NOINTERFACE;
    PMEMORY_DUMP64 Dump = (PMEMORY_DUMP64)g_DumpBase;

    if (Dump->Header.Signature != DUMP_SIGNATURE64 ||
        Dump->Header.ValidDump != DUMP_VALID_DUMP64)
    {
        return Status;
    }

    __try
    {
        if (Dump->Header.DumpType == DUMP_TYPE_SUMMARY)
        {
            if (Dump->Summary.Signature != DUMP_SUMMARY_SIGNATURE)
            {
                // The header says it's a summary dump but
                // it doesn't have a valid signature, so assume
                // it's not a valid dump.
                Status = HR_DUMP_CORRUPT;
            }
            else
            {
                Status = S_OK;
                m_Dump = Dump;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return Status;
}

ULONG64
KernelSummary64DumpTargetInfo::PhysicalToOffset(ULONG64 Phys, PULONG Avail)
{
    return SumPhysicalToOffset(m_Dump->Summary.HeaderSize, Phys, Avail);
}

void
KernelSummary64DumpTargetInfo::DumpDebug(void)
{
    PSUMMARY_DUMP64 Sum = &m_Dump->Summary;

    dprintf("----- 64 bit Kernel Summary Dump Analysis\n");

    DumpHeader64(&m_Dump->Header);

    dprintf("\nSUMMARY_DUMP64:\n");
    dprintf("DumpOptions         %08lx\n", Sum->DumpOptions);
    dprintf("HeaderSize          %08lx\n", Sum->HeaderSize);
    dprintf("BitmapSize          %08lx\n", Sum->BitmapSize);
    dprintf("Pages               %08lx\n", Sum->Pages);
    dprintf("Bitmap.SizeOfBitMap %08lx\n", Sum->Bitmap.SizeOfBitMap);

    KernelFullSumDumpTargetInfo::DumpDebug();
}

//----------------------------------------------------------------------------
//
// KernelTriageDumpTargetInfo.
//
//----------------------------------------------------------------------------

void
KernelTriageDumpTargetInfo::Uninitialize(void)
{
    m_PrcbOffset = 0;
    MemoryMap_Destroy();
    KernelDumpTargetInfo::Uninitialize();
    g_TriageDumpHasDebuggerData = FALSE;
}

void
KernelTriageDumpTargetInfo::NearestDifferentlyValidOffsets(ULONG64 Offset,
                                                           PULONG64 NextOffset,
                                                           PULONG64 NextPage)
{
    //
    // In a minidump there can be memory fragments mapped at
    // arbitrary locations so we cannot assume validity
    // changes on page boundaries.  We could attempt to
    // scan the memory list and try to find the closest valid
    // chunk of memory but it's rarely important that
    // complete accuracy is required.  Just return the
    // next byte.
    //

    if (NextOffset != NULL)
    {
        *NextOffset = Offset + 1;
    }
    if (NextPage != NULL)
    {
        *NextPage = (Offset + g_TargetMachine->m_PageSize) &
            ~((ULONG64)g_TargetMachine->m_PageSize - 1);
    }
}
    
HRESULT
KernelTriageDumpTargetInfo::ReadVirtual(
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesRead
    )
{
    // All virtual memory is contained in the memory map.
    return MemoryMap_ReadMemory(Offset, Buffer, BufferSize,
                                BytesRead) ? S_OK : E_FAIL;
}

HRESULT
KernelTriageDumpTargetInfo::GetProcessorSystemDataOffset(
    IN ULONG Processor,
    IN ULONG Index,
    OUT PULONG64 Offset
    )
{
    if (Processor != GetCurrentProcessor())
    {
        return E_INVALIDARG;
    }

    ULONG64 Prcb = g_DumpKiProcessors[Processor];
    HRESULT Status;

    switch(Index)
    {
    case DEBUG_DATA_KPCR_OFFSET:
        // We don't have a full PCR, just a PRCB.
        return E_FAIL;

    case DEBUG_DATA_KPRCB_OFFSET:
        *Offset = Prcb;
        break;

    case DEBUG_DATA_KTHREAD_OFFSET:
        if ((Status = ReadPointer(g_TargetMachine,
                                  Prcb + (g_TargetMachine->m_Ptr64 ?
                                          KPRCB_CURRENT_THREAD_OFFSET_64 :
                                          KPRCB_CURRENT_THREAD_OFFSET_32),
                                  Offset)) != S_OK)
        {
            return Status;
        }
        break;
    }

    return S_OK;
}

HRESULT
KernelTriageDumpTargetInfo::GetTargetContext(
    ULONG64 Thread,
    PVOID Context
    )
{
    // We only have the current context in a triage dump.
    if (VIRTUAL_THREAD_INDEX(Thread) != GetCurrentProcessor())
    {
        return E_INVALIDARG;
    }

    // The KPRCB could be used to retrieve context information as in
    // KernelFullSumDumpTargetInfo::GetTargetContext but
    // for consistency the header context is used since it's
    // the officially advertised place.
    memcpy(Context, m_HeaderContext, g_TargetMachine->m_SizeTargetContext);

    return S_OK;
}

HRESULT
KernelTriageDumpTargetInfo::GetSelDescriptor(MachineInfo* Machine,
                                             ULONG64 Thread,
                                             ULONG Selector,
                                             PDESCRIPTOR64 Desc)
{
    return EmulateNtSelDescriptor(Machine, Selector, Desc);
}

ULONG64
KernelTriageDumpTargetInfo::VirtualToOffset(ULONG64 Virt,
                                            PULONG File, PULONG Avail)
{
    ULONG64 Base;
    ULONG Size;
    PVOID Mapping, Param;

    *File = DUMP_INFO_DUMP;
    
    // ReadVirtual is overridden to read the memory map directly
    // so this function will only be called from the generic
    // WriteVirtual.  We can only write regions mapped out of
    // the dump so only return memory regions that don't have
    // an image pointer as their user data.
    if (MemoryMap_GetRegionInfo(Virt, &Base, &Size, &Mapping, &Param) &&
        Param == NULL)
    {
        *Avail = Size - (ULONG)(Virt - Base);
        return (PUCHAR)Mapping - (PUCHAR)g_DumpBase;
    }

    return 0;
}

ULONG
KernelTriageDumpTargetInfo::GetCurrentProcessor(void)
{
    // Extract the processor number from the
    // PRCB in the dump.
    return *(PUCHAR)
        IndexByByte(g_DumpBase, m_PrcbOffset +
                    g_TargetMachine->m_OffsetPrcbNumber);
}

HRESULT
KernelTriageDumpTargetInfo::MapMemoryRegions(ULONG PrcbOffset,
                                             ULONG ThreadOffset,
                                             ULONG ProcessOffset,
                                             ULONG64 TopOfStack,
                                             ULONG SizeOfCallStack,
                                             ULONG CallStackOffset,
                                             ULONG64 BStoreLimit,
                                             ULONG SizeOfBStore,
                                             ULONG BStoreOffset,
                                             ULONG64 DataPageAddress,
                                             ULONG DataPageOffset,
                                             ULONG DataPageSize,
                                             ULONG64 DebuggerDataAddress,
                                             ULONG DebuggerDataOffset,
                                             ULONG DebuggerDataSize,
                                             ULONG MmDataOffset,
                                             ULONG DataBlocksOffset,
                                             ULONG DataBlocksCount)

{
    HRESULT Status;
    
    if (!MemoryMap_Create())
    {
        return E_OUTOFMEMORY;
    }

    // Technically a triage dump doesn't have to contain a KPRCB
    // but we really want it to have one.  Nobody generates them
    // without a KPRCB so this is really just a sanity check.
    if (PrcbOffset == 0)
    {
        ErrOut("Dump does not contain KPRCB\n");
        return E_FAIL;
    }

    // Set this first so GetCurrentProcessor works.
    m_PrcbOffset = PrcbOffset;

    ULONG Processor = GetCurrentProcessor();

    // The dump contains one PRCB for the current processor.
    // Map the PRCB at the processor-zero location because
    // that location should not ever have some other mapping
    // for the dump.
    g_DumpKiProcessors[Processor] = g_TargetMachine->m_TriagePrcbOffset;
    if ((Status = MemoryMap_AddRegion(g_DumpKiProcessors[Processor],
                                      g_TargetMachine->m_SizePrcb,
                                      IndexByByte(g_DumpBase, PrcbOffset),
                                      NULL, FALSE)) != S_OK)
    {
        return Status;
    }

    //
    // Add ETHREAD and EPROCESS memory regions if available.
    //

    if (ThreadOffset != 0)
    {
        PVOID CurThread =
            IndexByByte(g_DumpBase, PrcbOffset +
                        (g_TargetMachine->m_Ptr64 ?
                         KPRCB_CURRENT_THREAD_OFFSET_64 :
                         KPRCB_CURRENT_THREAD_OFFSET_32));
        ULONG64 ThreadAddr, ProcAddr;

        if (g_TargetMachine->m_Ptr64)
        {
            ThreadAddr = *(PULONG64)CurThread;
            ProcAddr = *(PULONG64)
                IndexByByte(g_DumpBase, ThreadOffset +
                            g_TargetMachine->m_OffsetKThreadApcProcess);
        }
        else
        {
            ThreadAddr = EXTEND64(*(PULONG)CurThread);
            ProcAddr = EXTEND64(*(PULONG)
                IndexByByte(g_DumpBase, ThreadOffset +
                            g_TargetMachine->m_OffsetKThreadApcProcess));
        }

        if ((Status = MemoryMap_AddRegion(ThreadAddr,
                                          g_TargetMachine->m_SizeEThread,
                                          IndexByByte(g_DumpBase,
                                                      ThreadOffset),
                                          NULL, TRUE)) != S_OK)
        {
            return Status;
        }

        if (ProcessOffset != 0)
        {
            if ((Status = MemoryMap_AddRegion(ProcAddr,
                                              g_TargetMachine->m_SizeEProcess,
                                              IndexByByte(g_DumpBase,
                                                          ProcessOffset),
                                              NULL, TRUE)) != S_OK)
            {
                return Status;
            }
        }
        else
        {
            WarnOut("Mini Kernel Dump does not have "
                    "process information\n");
        }
    }
    else
    {
        WarnOut("Mini Kernel Dump does not have thread information\n");
    }

    // Add the backing store region.
    if (g_TargetMachineType == IMAGE_FILE_MACHINE_IA64)
    {
        if (BStoreOffset != 0)
        {
            if ((Status = MemoryMap_AddRegion(BStoreLimit - SizeOfBStore,
                                              SizeOfBStore,
                                              IndexByByte(g_DumpBase,
                                                          BStoreOffset),
                                              NULL, TRUE)) != S_OK)
            {
                return Status;
            }
        }
        else
        {
            WarnOut("Mini Kernel Dump does not have "
                    "backing store information\n");
        }
    }

    // Add data page if available
    if (DataPageAddress)
    {
        if ((Status = MemoryMap_AddRegion(DataPageAddress, DataPageSize,
                                          IndexByByte(g_DumpBase,
                                                      DataPageOffset),
                                          NULL, TRUE)) != S_OK)
        {
            return Status;
        }
    }

    // Map any debugger data.
    if (DebuggerDataAddress)
    {
        if ((Status = MemoryMap_AddRegion(DebuggerDataAddress,
                                          DebuggerDataSize,
                                          IndexByByte(g_DumpBase,
                                                      DebuggerDataOffset),
                                          NULL, TRUE)) != S_OK)
        {
            return Status;
        }

        g_TriageDumpHasDebuggerData = TRUE;
        
        if (MmDataOffset)
        {
            MM_TRIAGE_TRANSLATION* Trans = g_MmTriageTranslations;
            
            // Map memory fragments for MM Triage information
            // that equates to entries in the debugger data.
            while (Trans->DebuggerDataOffset > 0)
            {
                ULONG64 DbgData;
                ULONG MmData;
                ULONG Size;

                DbgData = *(ULONG64 UNALIGNED*)
                    IndexByByte(g_DumpBase, DebuggerDataOffset +
                                Trans->DebuggerDataOffset);
                Size = sizeof(ULONG);
                if (g_TargetMachine->m_Ptr64)
                {
                    MmData = MmDataOffset + Trans->Triage64Offset;
                    if (Trans->PtrSize)
                    {
                        Size = sizeof(ULONG64);
                    }
                }
                else
                {
                    MmData = MmDataOffset + Trans->Triage32Offset;
                    DbgData = EXTEND64(DbgData);
                }
                
                if ((Status = MemoryMap_AddRegion(DbgData, Size,
                                                  IndexByByte(g_DumpBase,
                                                              MmData),
                                                  NULL, TRUE)) != S_OK)
                {
                    return Status;
                }

                Trans++;
            }
        }
    }

    // Map arbitrary data blocks.
    if (DataBlocksCount > 0)
    {
        PTRIAGE_DATA_BLOCK Block;

        Block = (PTRIAGE_DATA_BLOCK)IndexByByte(g_DumpBase, DataBlocksOffset);
        while (DataBlocksCount-- > 0)
        {
            if ((Status = MemoryMap_AddRegion(Block->Address,
                                              Block->Size,
                                              IndexByByte(g_DumpBase,
                                                          Block->Offset),
                                              NULL, TRUE)) != S_OK)
            {
                return Status;
            }

            Block++;
        }
    }
    
    // Add the stack to the valid memory region.
    return MemoryMap_AddRegion(TopOfStack, SizeOfCallStack,
                               IndexByByte(g_DumpBase, CallStackOffset),
                               NULL, TRUE);
}

HRESULT
KernelTriage32DumpTargetInfo::Initialize(void)
{
    // Pick up any potentially modified base mapping pointer.
    m_Dump = (PMEMORY_DUMP32)g_DumpBase;

    dprintf("Mini Kernel Dump File: "
            "Only registers and stack trace are available\n\n");

    g_TargetClass          = DEBUG_CLASS_KERNEL;
    g_TargetClassQualifier = DEBUG_KERNEL_SMALL_DUMP;

    PTRIAGE_DUMP32 Triage = &m_Dump->Triage;

    HRESULT Status = InitGlobals32(m_Dump);
    if (Status != S_OK)
    {
        return Status;
    }

    //
    // Optional memory page
    //

    ULONG64 DataPageAddress = 0;
    ULONG   DataPageOffset = 0;
    ULONG   DataPageSize = 0;

    if (((m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_BASIC_INFO) ==
            TRIAGE_DUMP_BASIC_INFO) &&
        (m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_DATAPAGE))
    {
        DataPageAddress = Triage->DataPageAddress;
        DataPageOffset  = Triage->DataPageOffset;
        DataPageSize    = Triage->DataPageSize;
    }

    //
    // Optional KDDEBUGGER_DATA64.
    //
    
    ULONG64 DebuggerDataAddress = 0;
    ULONG   DebuggerDataOffset = 0;
    ULONG   DebuggerDataSize = 0;

    if (((m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_BASIC_INFO) ==
            TRIAGE_DUMP_BASIC_INFO) &&
        (m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_DEBUGGER_DATA))
    {
        // DebuggerDataBlock field must be valid if the dump is
        // new enough to have a data block in it.
        DebuggerDataAddress = EXTEND64(m_Dump->Header.KdDebuggerDataBlock);
        DebuggerDataOffset  = Triage->DebuggerDataOffset;
        DebuggerDataSize    = Triage->DebuggerDataSize;
    }

    //
    // Optional data blocks.
    //
    
    ULONG DataBlocksOffset = 0;
    ULONG DataBlocksCount = 0;

    if (((m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_BASIC_INFO) ==
            TRIAGE_DUMP_BASIC_INFO) &&
        (m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_DATA_BLOCKS))
    {
        DataBlocksOffset = Triage->DataBlocksOffset;
        DataBlocksCount  = Triage->DataBlocksCount;
    }

    //
    // We store the servicepack version in the header because we
    // don't store the actual memory
    //

    SetTargetNtCsdVersion(m_Dump->Triage.ServicePackBuild);

    return MapMemoryRegions(Triage->PrcbOffset, Triage->ThreadOffset,
                            Triage->ProcessOffset,
                            EXTEND64(Triage->TopOfStack),
                            Triage->SizeOfCallStack, Triage->CallStackOffset,
                            0, 0, 0,
                            DataPageAddress, DataPageOffset, DataPageSize,
                            DebuggerDataAddress, DebuggerDataOffset,
                            DebuggerDataSize, Triage->MmOffset,
                            DataBlocksOffset, DataBlocksCount);
}

void
KernelTriage32DumpTargetInfo::Uninitialize(void)
{
    m_Dump = NULL;
    KernelTriageDumpTargetInfo::Uninitialize();
}

HRESULT
KernelTriage32DumpTargetInfo::ReadBugCheckData(PULONG Code, ULONG64 Args[4])
{
    *Code = m_Dump->Header.BugCheckCode;
    Args[0] = EXTEND64(m_Dump->Header.BugCheckParameter1);
    Args[1] = EXTEND64(m_Dump->Header.BugCheckParameter2);
    Args[2] = EXTEND64(m_Dump->Header.BugCheckParameter3);
    Args[3] = EXTEND64(m_Dump->Header.BugCheckParameter4);
    return S_OK;
}

HRESULT
KernelTriage32DumpTargetInfo::IdentifyDump(PULONG64 BaseMapSize)
{
    HRESULT Status = E_NOINTERFACE;
    PMEMORY_DUMP32 Dump = (PMEMORY_DUMP32)g_DumpBase;

    if (Dump->Header.Signature != DUMP_SIGNATURE32 ||
        Dump->Header.ValidDump != DUMP_VALID_DUMP32)
    {
        return Status;
    }

    __try
    {
        if (Dump->Header.DumpType == DUMP_TYPE_TRIAGE)
        {
            if (*(PULONG)IndexByByte(Dump, Dump->Triage.SizeOfDump -
                                     sizeof(ULONG)) != TRIAGE_DUMP_VALID)
            {
                // The header says it's a triage dump but
                // it doesn't have a valid signature, so assume
                // it's not a valid dump.
                Status = HR_DUMP_CORRUPT;
            }
            else
            {
                Status = S_OK;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    if (Status != S_OK)
    {
        return Status;
    }

    // Make sure that the dump has the minimal information that
    // we want.
    if (Dump->Triage.ContextOffset == 0 ||
        Dump->Triage.ExceptionOffset == 0 ||
        Dump->Triage.PrcbOffset == 0 ||
        Dump->Triage.CallStackOffset == 0)
    {
        ErrOut("Mini Kernel Dump does not contain enough "
               "information to be debugged\n");
        return E_FAIL;
    }

    // We rely on being able to directly access the entire
    // content of the dump through the default view so
    // ensure that it's possible.
    *BaseMapSize = g_DumpInfoFiles[DUMP_INFO_DUMP].FileSize;

    m_Dump = Dump;
    return Status;
}

ModuleInfo*
KernelTriage32DumpTargetInfo::GetModuleInfo(BOOL UserMode)
{
    return UserMode ? NULL : &g_KernelTriage32ModuleIterator;
}

UnloadedModuleInfo*
KernelTriage32DumpTargetInfo::GetUnloadedModuleInfo(void)
{
    return &g_KernelTriage32UnloadedModuleIterator;
}

void
KernelTriage32DumpTargetInfo::DumpDebug(void)
{
    PTRIAGE_DUMP32 Triage = &m_Dump->Triage;

    dprintf("----- 32 bit Kernel Mini Dump Analysis\n");

    DumpHeader32(&m_Dump->Header);
    dprintf("MiniDumpFields      %08lx \n", m_Dump->Header.MiniDumpFields);

    dprintf("\nTRIAGE_DUMP32:\n");
    dprintf("ServicePackBuild      %08lx \n", Triage->ServicePackBuild      );
    dprintf("SizeOfDump            %08lx \n", Triage->SizeOfDump            );
    dprintf("ValidOffset           %08lx \n", Triage->ValidOffset           );
    dprintf("ContextOffset         %08lx \n", Triage->ContextOffset         );
    dprintf("ExceptionOffset       %08lx \n", Triage->ExceptionOffset       );
    dprintf("MmOffset              %08lx \n", Triage->MmOffset              );
    dprintf("UnloadedDriversOffset %08lx \n", Triage->UnloadedDriversOffset );
    dprintf("PrcbOffset            %08lx \n", Triage->PrcbOffset            );
    dprintf("ProcessOffset         %08lx \n", Triage->ProcessOffset         );
    dprintf("ThreadOffset          %08lx \n", Triage->ThreadOffset          );
    dprintf("CallStackOffset       %08lx \n", Triage->CallStackOffset       );
    dprintf("SizeOfCallStack       %08lx \n", Triage->SizeOfCallStack       );
    dprintf("DriverListOffset      %08lx \n", Triage->DriverListOffset      );
    dprintf("DriverCount           %08lx \n", Triage->DriverCount           );
    dprintf("StringPoolOffset      %08lx \n", Triage->StringPoolOffset      );
    dprintf("StringPoolSize        %08lx \n", Triage->StringPoolSize        );
    dprintf("BrokenDriverOffset    %08lx \n", Triage->BrokenDriverOffset    );
    dprintf("TriageOptions         %08lx \n", Triage->TriageOptions         );
    dprintf("TopOfStack            %08lx \n", Triage->TopOfStack            );

    if (((m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_BASIC_INFO) ==
            TRIAGE_DUMP_BASIC_INFO) &&
        (m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_DATAPAGE))
    {
        dprintf("DataPageAddress       %08lx \n", Triage->DataPageAddress   );
        dprintf("DataPageOffset        %08lx \n", Triage->DataPageOffset    );
        dprintf("DataPageSize          %08lx \n", Triage->DataPageSize      );
    }

    if (((m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_BASIC_INFO) ==
            TRIAGE_DUMP_BASIC_INFO) &&
        (m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_DEBUGGER_DATA))
    {
        dprintf("DebuggerDataOffset    %08lx \n", Triage->DebuggerDataOffset);
        dprintf("DebuggerDataSize      %08lx \n", Triage->DebuggerDataSize  );
    }

    if (((m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_BASIC_INFO) ==
            TRIAGE_DUMP_BASIC_INFO) &&
        (m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_DATA_BLOCKS))
    {
        dprintf("DataBlocksOffset      %08lx \n", Triage->DataBlocksOffset  );
        dprintf("DataBlocksCount       %08lx \n", Triage->DataBlocksCount   );
    }
}

HRESULT
KernelTriage64DumpTargetInfo::Initialize(void)
{
    // Pick up any potentially modified base mapping pointer.
    m_Dump = (PMEMORY_DUMP64)g_DumpBase;

    dprintf("Mini Kernel Dump File: "
            "Only registers and stack trace are available\n\n");

    g_TargetClass          = DEBUG_CLASS_KERNEL;
    g_TargetClassQualifier = DEBUG_KERNEL_SMALL_DUMP;

    PTRIAGE_DUMP64 Triage = &m_Dump->Triage;

    HRESULT Status = InitGlobals64(m_Dump);
    if (Status != S_OK)
    {
        return Status;
    }

    //
    // Optional memory page
    //

    ULONG64 DataPageAddress = 0;
    ULONG   DataPageOffset = 0;
    ULONG   DataPageSize = 0;

    if (((m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_BASIC_INFO) ==
            TRIAGE_DUMP_BASIC_INFO) &&
        (m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_DATAPAGE))
    {
        DataPageAddress = Triage->DataPageAddress;
        DataPageOffset  = Triage->DataPageOffset;
        DataPageSize    = Triage->DataPageSize;
    }

    //
    // Optional KDDEBUGGER_DATA64.
    //
    
    ULONG64 DebuggerDataAddress = 0;
    ULONG   DebuggerDataOffset = 0;
    ULONG   DebuggerDataSize = 0;

    if (((m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_BASIC_INFO) ==
            TRIAGE_DUMP_BASIC_INFO) &&
        (m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_DEBUGGER_DATA))
    {
        // DebuggerDataBlock field must be valid if the dump is
        // new enough to have a data block in it.
        DebuggerDataAddress = m_Dump->Header.KdDebuggerDataBlock;
        DebuggerDataOffset  = Triage->DebuggerDataOffset;
        DebuggerDataSize    = Triage->DebuggerDataSize;
    }

    //
    // Optional data blocks.
    //
    
    ULONG DataBlocksOffset = 0;
    ULONG DataBlocksCount = 0;

    if (((m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_BASIC_INFO) ==
            TRIAGE_DUMP_BASIC_INFO) &&
        (m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_DATA_BLOCKS))
    {
        DataBlocksOffset = Triage->DataBlocksOffset;
        DataBlocksCount  = Triage->DataBlocksCount;
    }

    //
    // We store the servicepack version in the header because we
    // don't store the actual memory
    //

    SetTargetNtCsdVersion(m_Dump->Triage.ServicePackBuild);

    return MapMemoryRegions(Triage->PrcbOffset, Triage->ThreadOffset,
                            Triage->ProcessOffset, Triage->TopOfStack,
                            Triage->SizeOfCallStack, Triage->CallStackOffset,
                            Triage->ArchitectureSpecific.Ia64.LimitOfBStore,
                            Triage->ArchitectureSpecific.Ia64.SizeOfBStore,
                            Triage->ArchitectureSpecific.Ia64.BStoreOffset,
                            DataPageAddress, DataPageOffset, DataPageSize,
                            DebuggerDataAddress, DebuggerDataOffset,
                            DebuggerDataSize, Triage->MmOffset,
                            DataBlocksOffset, DataBlocksCount);
}

void
KernelTriage64DumpTargetInfo::Uninitialize(void)
{
    m_Dump = NULL;
    KernelTriageDumpTargetInfo::Uninitialize();
}

HRESULT
KernelTriage64DumpTargetInfo::ReadBugCheckData(PULONG Code, ULONG64 Args[4])
{
    *Code = m_Dump->Header.BugCheckCode;
    Args[0] = m_Dump->Header.BugCheckParameter1;
    Args[1] = m_Dump->Header.BugCheckParameter2;
    Args[2] = m_Dump->Header.BugCheckParameter3;
    Args[3] = m_Dump->Header.BugCheckParameter4;
    return S_OK;
}

HRESULT
KernelTriage64DumpTargetInfo::IdentifyDump(PULONG64 BaseMapSize)
{
    HRESULT Status = E_NOINTERFACE;
    PMEMORY_DUMP64 Dump = (PMEMORY_DUMP64)g_DumpBase;

    if (Dump->Header.Signature != DUMP_SIGNATURE64 ||
        Dump->Header.ValidDump != DUMP_VALID_DUMP64)
    {
        return Status;
    }

    __try
    {
        if (Dump->Header.DumpType == DUMP_TYPE_TRIAGE)
        {
            if (*(PULONG)IndexByByte(Dump, Dump->Triage.SizeOfDump -
                                     sizeof(ULONG)) != TRIAGE_DUMP_VALID)
            {
                // The header says it's a triage dump but
                // it doesn't have a valid signature, so assume
                // it's not a valid dump.
                Status = HR_DUMP_CORRUPT;
            }
            else
            {
                Status = S_OK;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    if (Status != S_OK)
    {
        return Status;
    }

    // Make sure that the dump has the minimal information that
    // we want.
    if (Dump->Triage.ContextOffset == 0 ||
        Dump->Triage.ExceptionOffset == 0 ||
        Dump->Triage.PrcbOffset == 0 ||
        Dump->Triage.CallStackOffset == 0)
    {
        ErrOut("Mini Kernel Dump does not contain enough "
               "information to be debugged\n");
        return E_FAIL;
    }

    // We rely on being able to directly access the entire
    // content of the dump through the default view so
    // ensure that it's possible.
    *BaseMapSize = g_DumpInfoFiles[DUMP_INFO_DUMP].FileSize;

    m_Dump = Dump;
    return Status;
}

ModuleInfo*
KernelTriage64DumpTargetInfo::GetModuleInfo(BOOL UserMode)
{
    return UserMode ? NULL : &g_KernelTriage64ModuleIterator;
}

UnloadedModuleInfo*
KernelTriage64DumpTargetInfo::GetUnloadedModuleInfo(void)
{
    return &g_KernelTriage64UnloadedModuleIterator;
}

void
KernelTriage64DumpTargetInfo::DumpDebug(void)
{
    PTRIAGE_DUMP64 Triage = &m_Dump->Triage;

    dprintf("----- 64 bit Kernel Mini Dump Analysis\n");

    DumpHeader64(&m_Dump->Header);
    dprintf("MiniDumpFields      %08lx \n", m_Dump->Header.MiniDumpFields);

    dprintf("\nTRIAGE_DUMP64:\n");
    dprintf("ServicePackBuild      %08lx \n", Triage->ServicePackBuild      );
    dprintf("SizeOfDump            %08lx \n", Triage->SizeOfDump            );
    dprintf("ValidOffset           %08lx \n", Triage->ValidOffset           );
    dprintf("ContextOffset         %08lx \n", Triage->ContextOffset         );
    dprintf("ExceptionOffset       %08lx \n", Triage->ExceptionOffset       );
    dprintf("MmOffset              %08lx \n", Triage->MmOffset              );
    dprintf("UnloadedDriversOffset %08lx \n", Triage->UnloadedDriversOffset );
    dprintf("PrcbOffset            %08lx \n", Triage->PrcbOffset            );
    dprintf("ProcessOffset         %08lx \n", Triage->ProcessOffset         );
    dprintf("ThreadOffset          %08lx \n", Triage->ThreadOffset          );
    dprintf("CallStackOffset       %08lx \n", Triage->CallStackOffset       );
    dprintf("SizeOfCallStack       %08lx \n", Triage->SizeOfCallStack       );
    dprintf("DriverListOffset      %08lx \n", Triage->DriverListOffset      );
    dprintf("DriverCount           %08lx \n", Triage->DriverCount           );
    dprintf("StringPoolOffset      %08lx \n", Triage->StringPoolOffset      );
    dprintf("StringPoolSize        %08lx \n", Triage->StringPoolSize        );
    dprintf("BrokenDriverOffset    %08lx \n", Triage->BrokenDriverOffset    );
    dprintf("TriageOptions         %08lx \n", Triage->TriageOptions         );
    dprintf("TopOfStack            %s \n",
            FormatAddr64(Triage->TopOfStack));
    dprintf("BStoreOffset          %08lx \n",
            Triage->ArchitectureSpecific.Ia64.BStoreOffset );
    dprintf("SizeOfBStore          %08lx \n",
            Triage->ArchitectureSpecific.Ia64.SizeOfBStore );
    dprintf("LimitOfBStore         %s \n",
            FormatAddr64(Triage->ArchitectureSpecific.Ia64.LimitOfBStore));

    if (((m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_BASIC_INFO) ==
            TRIAGE_DUMP_BASIC_INFO) &&
        (m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_DATAPAGE))
    {
        dprintf("DataPageAddress       %s \n",
                FormatAddr64(Triage->DataPageAddress));
        dprintf("DataPageOffset        %08lx \n", Triage->DataPageOffset    );
        dprintf("DataPageSize          %08lx \n", Triage->DataPageSize      );
    }

    if (((m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_BASIC_INFO) ==
            TRIAGE_DUMP_BASIC_INFO) &&
        (m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_DEBUGGER_DATA))
    {
        dprintf("DebuggerDataOffset    %08lx \n", Triage->DebuggerDataOffset);
        dprintf("DebuggerDataSize      %08lx \n", Triage->DebuggerDataSize  );
    }

    if (((m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_BASIC_INFO) ==
            TRIAGE_DUMP_BASIC_INFO) &&
        (m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_DATA_BLOCKS))
    {
        dprintf("DataBlocksOffset      %08lx \n", Triage->DataBlocksOffset  );
        dprintf("DataBlocksCount       %08lx \n", Triage->DataBlocksCount   );
    }
}

//----------------------------------------------------------------------------
//
// KernelFullDumpTargetInfo.
//
//----------------------------------------------------------------------------

HRESULT
KernelFull32DumpTargetInfo::Initialize(void)
{
    // Pick up any potentially modified base mapping pointer.
    m_Dump = (PMEMORY_DUMP32)g_DumpBase;

    dprintf("Kernel Dump File: Full address space is available\n\n");

    g_TargetClass          = DEBUG_CLASS_KERNEL;
    g_TargetClassQualifier = DEBUG_KERNEL_FULL_DUMP;

    HRESULT Status = InitGlobals32(m_Dump);
    if (Status != S_OK)
    {
        return Status;
    }

    return KernelFullSumDumpTargetInfo::Initialize();
}

void
KernelFull32DumpTargetInfo::Uninitialize(void)
{
    m_Dump = NULL;
    KernelDumpTargetInfo::Uninitialize();
}

HRESULT
KernelFull32DumpTargetInfo::ReadBugCheckData(PULONG Code, ULONG64 Args[4])
{
    *Code = m_Dump->Header.BugCheckCode;
    Args[0] = EXTEND64(m_Dump->Header.BugCheckParameter1);
    Args[1] = EXTEND64(m_Dump->Header.BugCheckParameter2);
    Args[2] = EXTEND64(m_Dump->Header.BugCheckParameter3);
    Args[3] = EXTEND64(m_Dump->Header.BugCheckParameter4);
    return S_OK;
}

HRESULT
KernelFull32DumpTargetInfo::IdentifyDump(PULONG64 BaseMapSize)
{
    m_Dump = (PMEMORY_DUMP32)g_DumpBase;

    if (m_Dump->Header.Signature != DUMP_SIGNATURE32 ||
        m_Dump->Header.ValidDump != DUMP_VALID_DUMP32 ||
        (m_Dump->Header.DumpType != DUMP_SIGNATURE32 &&
         m_Dump->Header.DumpType != DUMP_TYPE_FULL))
    {
        m_Dump = NULL;
        return E_NOINTERFACE;
    }

    // Summary and triage dumps must be checked before this
    // so there's nothing left to check.
    return S_OK;
}

ULONG64
KernelFull32DumpTargetInfo::PhysicalToOffset(ULONG64 Phys, PULONG Avail)
{
    ULONG PageIndex = (ULONG)Phys & (g_TargetMachine->m_PageSize - 1);

    *Avail = g_TargetMachine->m_PageSize - PageIndex;

    PPHYSICAL_MEMORY_DESCRIPTOR32 PhysDesc = &m_Dump->Header.PhysicalMemoryBlock;
    ULONG64 Page = Phys >> g_TargetMachine->m_PageShift;

    //
    // Memory start after one page.
    //

    ULONG64 Offset = 1;
    ULONG j = 0;

    while (j < PhysDesc->NumberOfRuns)
    {
        if ((Page >= PhysDesc->Run[j].BasePage) &&
            (Page < (PhysDesc->Run[j].BasePage +
                     PhysDesc->Run[j].PageCount)))
        {
            Offset += Page - PhysDesc->Run[j].BasePage;
            return Offset * g_TargetMachine->m_PageSize + PageIndex;
        }

        Offset += PhysDesc->Run[j].PageCount;
        j += 1;
    }

    KdOut("Physical Memory Address %s is greater than MaxPhysicalAddress\n",
           FormatDisp64(Phys));

    return 0;
}

void
KernelFull32DumpTargetInfo::DumpDebug(void)
{
    PPHYSICAL_MEMORY_DESCRIPTOR32 PhysDesc =
        &m_Dump->Header.PhysicalMemoryBlock;
    ULONG PageSize = g_TargetMachine->m_PageSize;

    dprintf("----- 32 bit Kernel Full Dump Analysis\n");

    DumpHeader32(&m_Dump->Header);

    dprintf("\nPhysical Memory Description:\n");
    dprintf("Number of runs: %d\n", PhysDesc->NumberOfRuns);

    dprintf("          FileOffset  Start Address  Length\n");

    ULONG j = 0;
    ULONG Offset = 1;

    while (j < PhysDesc->NumberOfRuns)
    {
        dprintf("           %08lx     %08lx     %08lx\n",
                 Offset * PageSize,
                 PhysDesc->Run[j].BasePage * PageSize,
                 PhysDesc->Run[j].PageCount * PageSize);

        Offset += PhysDesc->Run[j].PageCount;
        j += 1;
    }

    j--;
    dprintf("Last Page: %08lx     %08lx\n",
             (Offset - 1) * PageSize,
             (PhysDesc->Run[j].BasePage + PhysDesc->Run[j].PageCount - 1) *
                 PageSize);

    KernelFullSumDumpTargetInfo::DumpDebug();
}

HRESULT
KernelFull64DumpTargetInfo::Initialize(void)
{
    // Pick up any potentially modified base mapping pointer.
    m_Dump = (PMEMORY_DUMP64)g_DumpBase;

    dprintf("Kernel Dump File: Full address space is available\n\n");

    g_TargetClass          = DEBUG_CLASS_KERNEL;
    g_TargetClassQualifier = DEBUG_KERNEL_FULL_DUMP;

    HRESULT Status = InitGlobals64(m_Dump);
    if (Status != S_OK)
    {
        return Status;
    }

    return KernelFullSumDumpTargetInfo::Initialize();
}

void
KernelFull64DumpTargetInfo::Uninitialize(void)
{
    m_Dump = NULL;
    KernelDumpTargetInfo::Uninitialize();
}

HRESULT
KernelFull64DumpTargetInfo::ReadBugCheckData(PULONG Code, ULONG64 Args[4])
{
    *Code = m_Dump->Header.BugCheckCode;
    Args[0] = m_Dump->Header.BugCheckParameter1;
    Args[1] = m_Dump->Header.BugCheckParameter2;
    Args[2] = m_Dump->Header.BugCheckParameter3;
    Args[3] = m_Dump->Header.BugCheckParameter4;
    return S_OK;
}

HRESULT
KernelFull64DumpTargetInfo::IdentifyDump(PULONG64 BaseMapSize)
{
    m_Dump = (PMEMORY_DUMP64)g_DumpBase;

    if (m_Dump->Header.Signature != DUMP_SIGNATURE64 ||
        m_Dump->Header.ValidDump != DUMP_VALID_DUMP64 ||
        (m_Dump->Header.DumpType != DUMP_SIGNATURE32 &&
         m_Dump->Header.DumpType != DUMP_TYPE_FULL))
    {
        m_Dump = NULL;
        return E_NOINTERFACE;
    }

    // Summary and triage dumps must be checked before this
    // so there's nothing left to check.
    return S_OK;
}

ULONG64
KernelFull64DumpTargetInfo::PhysicalToOffset(ULONG64 Phys, PULONG Avail)
{
    ULONG PageIndex = (ULONG)Phys & (g_TargetMachine->m_PageSize - 1);

    *Avail = g_TargetMachine->m_PageSize - PageIndex;

    PPHYSICAL_MEMORY_DESCRIPTOR64 PhysDesc = &m_Dump->Header.PhysicalMemoryBlock;
    ULONG64 Page = Phys >> g_TargetMachine->m_PageShift;

    //
    // Memory start after one page.
    //

    ULONG64 Offset = 1;
    ULONG j = 0;

    while (j < PhysDesc->NumberOfRuns)
    {
        if ((Page >= PhysDesc->Run[j].BasePage) &&
            (Page < (PhysDesc->Run[j].BasePage +
                     PhysDesc->Run[j].PageCount)))
        {
            Offset += Page - PhysDesc->Run[j].BasePage;
            return Offset * g_TargetMachine->m_PageSize + PageIndex;
        }

        Offset += PhysDesc->Run[j].PageCount;
        j += 1;
    }

    KdOut("Physical Memory Address %I64 is greater than MaxPhysicalAddress\n",
           Phys);

    return 0;
}

void
KernelFull64DumpTargetInfo::DumpDebug(void)
{
    PPHYSICAL_MEMORY_DESCRIPTOR64 PhysDesc =
        &m_Dump->Header.PhysicalMemoryBlock;
    ULONG PageSize = g_TargetMachine->m_PageSize;

    dprintf("----- 64 bit Kernel Full Dump Analysis\n");

    DumpHeader64(&m_Dump->Header);

    dprintf("\nPhysical Memory Description:\n");
    dprintf("Number of runs: %d\n", PhysDesc->NumberOfRuns);

    dprintf("          FileOffset           Start Address           Length\n");

    ULONG j = 0;
    ULONG64 Offset = 1;

    while (j < PhysDesc->NumberOfRuns)
    {
        dprintf("           %s     %s     %s\n",
                FormatAddr64(Offset * PageSize),
                FormatAddr64(PhysDesc->Run[j].BasePage * PageSize),
                FormatAddr64(PhysDesc->Run[j].PageCount * PageSize));

        Offset += PhysDesc->Run[j].PageCount;
        j += 1;
    }

    j--;
    dprintf("Last Page: %s     %s\n",
            FormatAddr64((Offset - 1) * PageSize),
            FormatAddr64((PhysDesc->Run[j].BasePage +
                          PhysDesc->Run[j].PageCount - 1) *
                         PageSize));

    KernelFullSumDumpTargetInfo::DumpDebug();
}

//----------------------------------------------------------------------------
//
// UserDumpTargetInfo.
//
//----------------------------------------------------------------------------

void
UserDumpTargetInfo::Uninitialize(void)
{
    m_HighestMemoryRegion32 = 0;
    m_EventProcess = 0;
    m_EventThread = 0;
    m_ThreadCount = 0;
    DumpTargetInfo::Uninitialize();
}

HRESULT
UserDumpTargetInfo::GetThreadInfoDataOffset(PTHREAD_INFO Thread,
                                            ULONG64 ThreadHandle,
                                            PULONG64 Offset)
{
    if (Thread != NULL && Thread->DataOffset != 0)
    {
        *Offset = Thread->DataOffset;
        return S_OK;
    }

    BOOL ContextThread = FALSE;

    if (Thread != NULL)
    {
        ThreadHandle = Thread->Handle;
        ContextThread = Thread == g_RegContextThread;
    }
    else if (ThreadHandle == NULL)
    {
        ThreadHandle = g_CurrentProcess->CurrentThread->Handle;
        ContextThread = g_CurrentProcess->CurrentThread == g_RegContextThread;
    }

    HRESULT Status;
    ULONG64 TebAddr;
    ULONG Id, Suspend;

    if ((Status = GetThreadInfo(VIRTUAL_THREAD_INDEX(ThreadHandle),
                                &Id, &Suspend, &TebAddr)) != S_OK)
    {
        ErrOut("User dump thread %u not available\n",
               VIRTUAL_THREAD_INDEX(ThreadHandle));
        return Status;
    }

    if (TebAddr == 0)
    {
        //
        // NT4 dumps have a bug - they do not fill in the TEB value.
        // luckily, for pretty much all user mode processes, the
        // TEBs start two pages down from the highest user address.
        // For example, on x86 we try 0x7FFDE000 (on 3GB systems 0xBFFDE000).
        //

        if (!g_TargetMachine->m_Ptr64 && m_HighestMemoryRegion32 > 0x80000000)
        {
            TebAddr = 0xbffe0000;
        }
        else
        {
            TebAddr = 0x7ffe0000;
        }
        TebAddr -= 2 * g_TargetMachine->m_PageSize;

        //
        // Try and validate that this is really a TEB.
        // If it isn't search lower memory addresses for
        // a while, but don't get hung up here.
        //

        ULONG64 TebCheck = TebAddr;
        ULONG Attempts = 8;
        BOOL IsATeb = FALSE;

        while (Attempts > 0)
        {
            ULONG64 TebSelf;

            // Check if this looks like a TEB.  TEBs have a
            // self pointer in the TIB that's useful for this.
            if (ReadPointer(g_TargetMachine,
                            TebCheck + 6 * (g_TargetMachine->m_Ptr64 ? 8 : 4),
                            &TebSelf) == S_OK &&
                TebSelf == TebCheck)
            {
                // It looks like it's a TEB.  Remember this address
                // so that if all searching fails we'll at least
                // return some TEB.
                TebAddr = TebCheck;
                IsATeb = TRUE;

                // If the given thread is the current register context
                // thread we can check and see if the current SP falls
                // within the stack limits in the TEB.
                if (ContextThread)
                {
                    ULONG64 StackBase, StackLimit;
                    ADDR Sp;

                    g_TargetMachine->GetSP(&Sp);
                    if (g_TargetMachine->m_Ptr64)
                    {
                        StackBase = STACK_BASE_FROM_TEB64;
                        StackLimit = StackBase + 8;
                    }
                    else
                    {
                        StackBase = STACK_BASE_FROM_TEB32;
                        StackLimit = StackBase + 4;
                    }
                    if (ReadPointer(g_TargetMachine,
                                    TebCheck + StackBase,
                                    &StackBase) == S_OK &&
                        ReadPointer(g_TargetMachine,
                                    TebCheck + StackLimit,
                                    &StackLimit) == S_OK &&
                        Flat(Sp) >= StackLimit &&
                        Flat(Sp) <= StackBase)
                    {
                        // SP is within stack limits, everything
                        // looks good.
                        break;
                    }
                }
                else
                {
                    // Can't validate SP so just go with it.
                    break;
                }

                // As long as we're looking through real TEBs
                // we'll continue searching.  Otherwise we
                // wouldn't be able to locate TEBs in dumps that
                // have a lot of threads.
                Attempts++;
            }

            // The memory either wasn't a TEB or was the
            // wrong TEB.  Drop down a page and try again.
            TebCheck -= g_TargetMachine->m_PageSize;
            Attempts--;
        }

        WarnOut("WARNING: Teb %u pointer is NULL - "
                "defaulting to %s\n", VIRTUAL_THREAD_INDEX(ThreadHandle),
                FormatAddr64(TebAddr));
        if (!IsATeb)
        {
            WarnOut("WARNING: %s does not appear to be a TEB\n",
                    FormatAddr64(TebAddr));
        }
        else if (Attempts == 0)
        {
            WarnOut("WARNING: %s does not appear to be the right TEB\n",
                    FormatAddr64(TebAddr));
        }
    }

    *Offset = TebAddr;
    if (Thread != NULL)
    {
        Thread->DataOffset = TebAddr;
    }
    return S_OK;
}

HRESULT
UserDumpTargetInfo::GetProcessInfoDataOffset(PTHREAD_INFO Thread,
                                             ULONG Processor,
                                             ULONG64 ThreadData,
                                             PULONG64 Offset)
{
    if (Thread != NULL && Thread->Process->DataOffset != 0)
    {
        *Offset = Thread->Process->DataOffset;
        return S_OK;
    }

    HRESULT Status;

    if (Thread != NULL || ThreadData == 0)
    {
        if ((Status = GetThreadInfoDataOffset(Thread,
                                              VIRTUAL_THREAD_HANDLE(Processor),
                                              &ThreadData)) != S_OK)
        {
            return Status;
        }
    }

    ThreadData += g_TargetMachine->m_Ptr64 ? PEB_FROM_TEB64 : PEB_FROM_TEB32;
    if ((Status = ReadPointer(g_TargetMachine, ThreadData, Offset)) != S_OK)
    {
        return Status;
    }

    if (Thread != NULL)
    {
        Thread->Process->DataOffset = *Offset;
    }

    return S_OK;
}

HRESULT
UserDumpTargetInfo::GetThreadInfoTeb(PTHREAD_INFO Thread,
                                     ULONG Processor,
                                     ULONG64 ThreadData,
                                     PULONG64 Offset)
{
    return GetThreadInfoDataOffset(Thread, ThreadData, Offset);
}

HRESULT
UserDumpTargetInfo::GetProcessInfoPeb(PTHREAD_INFO Thread,
                                      ULONG Processor,
                                      ULONG64 ThreadData,
                                      PULONG64 Offset)
{
    // Thread data is not useful.
    return GetProcessInfoDataOffset(Thread, 0, 0, Offset);
}

HRESULT
UserDumpTargetInfo::GetSelDescriptor(MachineInfo* Machine,
                                     ULONG64 Thread, ULONG Selector,
                                     PDESCRIPTOR64 Desc)
{
    return EmulateNtSelDescriptor(Machine, Selector, Desc);
}

//----------------------------------------------------------------------------
//
// UserFullDumpTargetInfo.
//
//----------------------------------------------------------------------------

void
UserFullDumpTargetInfo::Uninitialize(void)
{
    UserDumpTargetInfo::Uninitialize();
}

HRESULT
UserFullDumpTargetInfo::GetBuildAndPlatform(ULONG MajorVersion,
                                            ULONG MinorVersion,
                                            PULONG BuildNumber,
                                            PULONG PlatformId)
{
    //
    // The only way to distinguish user dump
    // platforms is guessing from the Major/MinorVersion
    // and the extra QFE/Hotfix data.
    //

    switch(MajorVersion)
    {
    case 4:
        switch(MinorVersion & 0xffff)
        {
        case 0:
            // This could be Win95 or NT4.  We mostly
            // deal with NT dumps so just assume NT.
            *BuildNumber = 1381;
            *PlatformId = VER_PLATFORM_WIN32_NT;
            break;
        case 3:
            // Win95 OSR releases were 4.03.  Treat them
            // as Win95 for now.
            *BuildNumber = 950;
            *PlatformId = VER_PLATFORM_WIN32_WINDOWS;
            break;
        case 10:
            // This could be Win98 or Win98SE.  Go with Win98.
            *BuildNumber = 1998;
            *PlatformId = VER_PLATFORM_WIN32_WINDOWS;
            break;
        }
        break;

    case 5:
        *PlatformId = VER_PLATFORM_WIN32_NT;
        switch(MinorVersion & 0xffff)
        {
        case 0:
            *BuildNumber = 2195;
            break;
        case 1:
            // Just has to be greater than 2195 to
            // distinguish it from Win2K RTM.
            *BuildNumber = 2196;
            break;
        }
        break;

    case 0:
        // AV: Busted BETA of the debugger generates a broken dump file
        // Guess it's 2195.
        WarnOut("Dump file was generated with NULL version - guessing NT5, ");
        *PlatformId = VER_PLATFORM_WIN32_NT;
        *BuildNumber = 2195;
        break;

    default:
        // Other platforms are not supported.
        ErrOut("Dump file was generated by an unsupported system, ");
        ErrOut("version %x.%x\n", MajorVersion, MinorVersion & 0xffff);
        return E_INVALIDARG;
    }

    // Newer full user dumps have the actual build number in
    // the high word, so use it if it's present.
    if (MinorVersion >> 16)
    {
        *BuildNumber = MinorVersion >> 16;
    }
    
    return S_OK;
}

HRESULT
UserFull32DumpTargetInfo::Initialize(void)
{
    // Pick up any potentially modified base mapping pointer.
    m_Header = (PUSERMODE_CRASHDUMP_HEADER32)g_DumpBase;

    dprintf("User Dump File: Only application data is available\n\n");

    g_TargetClass          = DEBUG_CLASS_USER_WINDOWS;
    g_TargetClassQualifier = DEBUG_USER_WINDOWS_DUMP;

    ULONG BuildNumber;
    ULONG PlatformId;
    HRESULT Status;

    if ((Status = GetBuildAndPlatform(m_Header->MajorVersion,
                                      m_Header->MinorVersion,
                                      &BuildNumber, &PlatformId)) != S_OK)
    {
        return Status;
    }

    if ((Status = DmppInitGlobals(BuildNumber, 0,
                                  m_Header->MachineImageType, PlatformId,
                                  m_Header->MajorVersion,
                                  m_Header->MinorVersion & 0xffff)) != S_OK)
    {
        return Status;
    }

    // Dump does not contain this information.
    g_TargetNumberProcessors = 1;

    DEBUG_EVENT32 Event;

    if (DmppReadFileOffset(DUMP_INFO_DUMP, m_Header->DebugEventOffset, &Event,
                           sizeof(Event)) != sizeof(Event))
    {
        ErrOut("Unable to read debug event at offset %x\n",
               m_Header->DebugEventOffset);
        return E_FAIL;
    }

    m_EventProcess = Event.dwProcessId;
    m_EventThread = Event.dwThreadId;

    if (Event.dwDebugEventCode == EXCEPTION_DEBUG_EVENT)
    {
        ExceptionRecord32To64(&Event.u.Exception.ExceptionRecord,
                              &g_DumpException);
        g_DumpExceptionFirstChance = Event.u.Exception.dwFirstChance;
    }
    else
    {
        // Fake an exception.
        ZeroMemory(&g_DumpException, sizeof(g_DumpException));
        g_DumpException.ExceptionCode = STATUS_BREAKPOINT;
        g_DumpExceptionFirstChance = FALSE;
    }

    m_ThreadCount = m_Header->ThreadCount;

    m_Memory = (PMEMORY_BASIC_INFORMATION32)
        IndexByByte(m_Header, m_Header->MemoryRegionOffset);

    //
    // Determine the highest memory region address.
    // This helps differentiate 2GB systems from 3GB systems.
    //

    ULONG i;
    PMEMORY_BASIC_INFORMATION32 Mem;
    ULONG TotalMemory;

    Mem = m_Memory;
    m_HighestMemoryRegion32 = 0;
    for (i = 0; i < m_Header->MemoryRegionCount; i++)
    {
        if (Mem->BaseAddress > m_HighestMemoryRegion32)
        {
            m_HighestMemoryRegion32 = Mem->BaseAddress;
        }

        Mem++;
    }

    VerbOut("  Memory regions: %d\n",
            m_Header->MemoryRegionCount);
    TotalMemory = 0;
    Mem = m_Memory;
    for (i = 0; i < m_Header->MemoryRegionCount; i++)
    {
        VerbOut("  %5d: %08X - %08X off %08X, prot %08X, type %08X\n",
                i, Mem->BaseAddress,
                Mem->BaseAddress + Mem->RegionSize - 1,
                TotalMemory + m_Header->DataOffset,
                Mem->Protect, Mem->Type);

        if ((Mem->Protect & PAGE_GUARD) ||
            (Mem->Protect & PAGE_NOACCESS) ||
            (Mem->State & MEM_FREE) ||
            (Mem->State & MEM_RESERVE))
        {
            VerbOut("       Region has data-less pages\n");
        }

        TotalMemory += Mem->RegionSize;
        Mem++;
    }

    VerbOut("  Total memory region size %X, file %08X - %08X\n",
            TotalMemory, m_Header->DataOffset,
            m_Header->DataOffset + TotalMemory - 1);

    //
    // Determine whether guard pages are present in
    // the dump content or not.
    //
    // First try with IgnoreGuardPages == TRUE.
    //

    m_IgnoreGuardPages = TRUE;

    if (!VerifyModules())
    {
        //
        // That didn't work, try IgnoreGuardPages == FALSE.
        //

        m_IgnoreGuardPages = FALSE;

        if (!VerifyModules())
        {
            ErrOut("Module list is corrupt\n");
            return E_FAIL;
        }
    }

    return S_OK;
}

void
UserFull32DumpTargetInfo::Uninitialize(void)
{
    m_Header = NULL;
    m_Memory = NULL;
    m_IgnoreGuardPages = TRUE;
    UserFullDumpTargetInfo::Uninitialize();
}

HRESULT
UserFull32DumpTargetInfo::GetTargetContext(
    ULONG64 Thread,
    PVOID Context
    )
{
    if (VIRTUAL_THREAD_INDEX(Thread) >= m_Header->ThreadCount)
    {
        return E_INVALIDARG;
    }

    if (DmppReadFileOffset(DUMP_INFO_DUMP,
                           m_Header->ThreadOffset +
                           VIRTUAL_THREAD_INDEX(Thread) *
                           g_TargetMachine->m_SizeTargetContext,
                           Context,
                           g_TargetMachine->m_SizeTargetContext) ==
        g_TargetMachine->m_SizeTargetContext)
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

HRESULT
UserFull32DumpTargetInfo::GetImageVersionInformation(PCSTR ImagePath,
                                                     ULONG64 ImageBase,
                                                     PCSTR Item,
                                                     PVOID Buffer,
                                                     ULONG BufferSize,
                                                     PULONG VerInfoSize)
{
    HRESULT Status;
    IMAGE_DOS_HEADER DosHdr;
    IMAGE_NT_HEADERS32 NtHdr;

    if ((Status = ReadAllVirtual(ImageBase, &DosHdr, sizeof(DosHdr))) != S_OK)
    {
        return Status;
    }
    if (DosHdr.e_magic != IMAGE_DOS_SIGNATURE)
    {
        return E_FAIL;
    }
    
    if ((Status = ReadAllVirtual(ImageBase + DosHdr.e_lfanew,
                                 &NtHdr, sizeof(NtHdr))) != S_OK)
    {
        return Status;
    }
    if (NtHdr.Signature != IMAGE_NT_SIGNATURE ||
        NtHdr.OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC)
    {
        return E_FAIL;
    }

    if (NtHdr.OptionalHeader.NumberOfRvaAndSizes <=
        IMAGE_DIRECTORY_ENTRY_RESOURCE)
    {
        // No resource information so no version information.
        return E_NOINTERFACE;
    }

    return ReadImageVersionInfo(ImageBase, Item,
                                Buffer, BufferSize, VerInfoSize,
                                &NtHdr.OptionalHeader.
                                DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE]);
}

HRESULT
UserFull32DumpTargetInfo::QueryMemoryRegion(PULONG64 Handle,
                                            BOOL HandleIsOffset,
                                            PMEMORY_BASIC_INFORMATION64 Info)
{
    ULONG Index;
    
    if (HandleIsOffset)
    {
        for (Index = 0; Index < m_Header->MemoryRegionCount; Index++)
        {
            if ((ULONG)*Handle >= m_Memory[Index].BaseAddress &&
                (ULONG)*Handle < m_Memory[Index].BaseAddress +
                m_Memory[Index].RegionSize)
            {
                break;
            }
        }
        
        if (Index >= m_Header->MemoryRegionCount)
        {
            return E_NOINTERFACE;
        }
    }
    else
    {
        Index = (ULONG)*Handle;

        for (;;)
        {
            if (Index >= m_Header->MemoryRegionCount)
            {
                return HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES);
            }

            if (!(m_Memory[Index].Protect & PAGE_GUARD))
            {
                break;
            }

            Index++;
        }
    }

    MemoryBasicInformation32To64(&m_Memory[Index], Info);
    *Handle = ++Index;

    return S_OK;
}

HRESULT
UserFull32DumpTargetInfo::IdentifyDump(PULONG64 BaseMapSize)
{
    m_Header = (PUSERMODE_CRASHDUMP_HEADER32)g_DumpBase;

    if (m_Header->Signature != USERMODE_CRASHDUMP_SIGNATURE ||
        m_Header->ValidDump != USERMODE_CRASHDUMP_VALID_DUMP32)
    {
        m_Header = NULL;
        return E_NOINTERFACE;
    }

    //
    // Check for the presence of some basic things.
    //
    
    if (m_Header->ThreadCount == 0 ||
        m_Header->ModuleCount == 0 ||
        m_Header->MemoryRegionCount == 0)
    {
        ErrOut("Thread, module or memory region count is zero.\n"
               "The dump file is probably corrupt.\n");
        return HR_DUMP_CORRUPT;
    }
    
    if (m_Header->ThreadOffset == 0 ||
        m_Header->ModuleOffset == 0 ||
        m_Header->DataOffset == 0 ||
        m_Header->MemoryRegionOffset == 0 ||
        m_Header->DebugEventOffset == 0 ||
        m_Header->ThreadStateOffset == 0)
    {
        ErrOut("A dump header data offset is zero.\n"
               "The dump file is probably corrupt.\n");
        return HR_DUMP_CORRUPT;
    }
        
    // We don't want to have to call DmppReadFileOffset
    // every time we check memory ranges so just require
    // that the memory descriptors fit in the base view.
    *BaseMapSize = m_Header->MemoryRegionOffset +
        m_Header->MemoryRegionCount * sizeof(*m_Memory);

    return S_OK;
}

void
UserFull32DumpTargetInfo::DumpDebug(void)
{
    dprintf("----- 32 bit User Full Dump Analysis\n\n");
    
    dprintf("MajorVersion:      %d\n", m_Header->MajorVersion);
    dprintf("MinorVersion:      %d (Build %d)\n",
            m_Header->MinorVersion & 0xffff,
            m_Header->MinorVersion >> 16);
    dprintf("MachineImageType:  %08lx\n", m_Header->MachineImageType);
    dprintf("ThreadCount:       %08lx\n", m_Header->ThreadCount);
    dprintf("ThreadOffset:      %08lx\n", m_Header->ThreadOffset);
    dprintf("ModuleCount:       %08lx\n", m_Header->ModuleCount);
    dprintf("ModuleOffset:      %08lx\n", m_Header->ModuleOffset);
    dprintf("DebugEventOffset:  %08lx\n", m_Header->DebugEventOffset);
    dprintf("VersionInfoOffset: %08lx\n", m_Header->VersionInfoOffset);
    dprintf("\nVirtual Memory Description:\n");
    dprintf("Number of regions: %d\n", m_Header->MemoryRegionCount);

    dprintf("          FileOffset   Start Address   Length\n");

    ULONG j = 0;
    ULONG64 Offset = 0;
    BOOL Skip;

    while (j < m_Header->MemoryRegionCount)
    {
        Skip = FALSE;

        dprintf("      %12I64lx      %08lx       %08lx",
                 Offset,
                 m_Memory[j].BaseAddress,
                 m_Memory[j].RegionSize);

        if (m_Memory[j].Protect & PAGE_GUARD)
        {
            dprintf("   Guard Page");

            if (m_IgnoreGuardPages)
            {
                dprintf(" - Ignored");
                Skip = TRUE;
            }
        }

        if (!Skip)
        {
            Offset += m_Memory[j].RegionSize;
        }

        dprintf("\n");

        j += 1;
    }
}

ULONG64
UserFull32DumpTargetInfo::VirtualToOffset(ULONG64 Virt,
                                          PULONG File, PULONG Avail)
{
    ULONG i;
    ULONG Offset = 0;

    *File = DUMP_INFO_DUMP;
    
    // Ignore the upper 32 bits to avoid getting
    // confused by sign extensions in pointer handling
    Virt &= 0xffffffff;

    for (i = 0; i < m_Header->MemoryRegionCount; i++)
    {
        if (m_IgnoreGuardPages)
        {
            //
            // Guard pages get reported, but they are not written
            // out to the file
            //

            if (m_Memory[i].Protect & PAGE_GUARD)
            {
                continue;
            }
        }

        if (Virt >= m_Memory[i].BaseAddress &&
            Virt < m_Memory[i].BaseAddress + m_Memory[i].RegionSize)
        {
            ULONG Frag = (ULONG)Virt - m_Memory[i].BaseAddress;
            *Avail = m_Memory[i].RegionSize - Frag;

            if (Virt == (g_DebugDump_VirtualAddress & 0xffffffff))
            {
                g_NtDllCalls.DbgPrint("%X at offset %X\n",
                                      (ULONG)Virt,
                                      m_Header->DataOffset + Offset + Frag);
            }

            return m_Header->DataOffset + Offset + Frag;
        }

        Offset += m_Memory[i].RegionSize;
    }

    return 0;
}

HRESULT
UserFull32DumpTargetInfo::GetThreadInfo(ULONG Index,
                                        PULONG Id, PULONG Suspend,
                                        PULONG64 Teb)
{
    if (Index >= m_ThreadCount)
    {
        return E_INVALIDARG;
    }

    CRASH_THREAD32 Thread;
    if (DmppReadFileOffset(DUMP_INFO_DUMP,
                           m_Header->ThreadStateOffset +
                           Index * sizeof(Thread),
                           &Thread, sizeof(Thread)) != sizeof(Thread))
    {
        return E_FAIL;
    }

    *Id = Thread.ThreadId;
    *Suspend = Thread.SuspendCount;
    *Teb = EXTEND64(Thread.Teb);

    return S_OK;
}

// #define DBG_VERIFY_MOD

BOOL
UserFull32DumpTargetInfo::VerifyModules(void)
{
    CRASH_MODULE32   CrashModule;
    ULONG            i;
    IMAGE_DOS_HEADER DosHeader;
    ULONG            Read;
    BOOL             Succ = TRUE;
    ULONG            Offset;
    PSTR             Env;

    Env = getenv("DBGENG_VERIFY_MODULES");
    if (Env != NULL)
    {
        return atoi(Env) == m_IgnoreGuardPages;
    }

    Offset = m_Header->ModuleOffset;

#ifdef DBG_VERIFY_MOD
    g_NtDllCalls.DbgPrint("Verify %d modules at offset %X\n",
                          m_Header->ModuleCount, Offset);
#endif

    for (i = 0; i < m_Header->ModuleCount; i++)
    {
        if (DmppReadFileOffset(DUMP_INFO_DUMP, Offset,
                               &CrashModule, sizeof(CrashModule)) !=
            sizeof(CrashModule))
        {
            return FALSE;
        }

#ifdef DBG_VERIFY_MOD
        g_NtDllCalls.DbgPrint("Mod %d of %d offs %X, base %s, ",
                              i, m_Header->ModuleCount, Offset,
                              FormatAddr64(CrashModule.BaseOfImage));
        if (ReadVirtual(CrashModule.BaseOfImage, &DosHeader,
                        sizeof(DosHeader), &Read) != S_OK ||
            Read != sizeof(DosHeader))
        {
            g_NtDllCalls.DbgPrint("unable to read header\n");
        }
        else
        {
            g_NtDllCalls.DbgPrint("magic %04X\n", DosHeader.e_magic);
        }
#endif

        //
        // It is not strictly a requirement that every image
        // begin with an MZ header, though all of our tools
        // today produce images like this.  Check for it
        // as a sanity check since it's so common nowadays.
        //

        if (ReadVirtual(CrashModule.BaseOfImage, &DosHeader,
                        sizeof(DosHeader), &Read) != S_OK ||
            Read != sizeof(DosHeader) ||
            DosHeader.e_magic != IMAGE_DOS_SIGNATURE)
        {
            Succ = FALSE;
            break;
        }

        Offset += sizeof(CrashModule) + CrashModule.ImageNameLength;
    }

#ifdef DBG_VERIFY_MOD
    g_NtDllCalls.DbgPrint("VerifyModules returning %d, %d of %d mods\n",
                          Succ, i, m_Header->ModuleCount);
#endif

    return Succ;
}

HRESULT
UserFull64DumpTargetInfo::Initialize(void)
{
    // Pick up any potentially modified base mapping pointer.
    m_Header = (PUSERMODE_CRASHDUMP_HEADER64)g_DumpBase;

    dprintf("User Dump File: Only application data is available\n\n");

    g_TargetClass          = DEBUG_CLASS_USER_WINDOWS;
    g_TargetClassQualifier = DEBUG_USER_WINDOWS_DUMP;

    ULONG BuildNumber;
    ULONG PlatformId;
    HRESULT Status;

    if ((Status = GetBuildAndPlatform(m_Header->MajorVersion,
                                      m_Header->MinorVersion,
                                      &BuildNumber, &PlatformId)) != S_OK)
    {
        return Status;
    }

    if ((Status = DmppInitGlobals(BuildNumber, 0,
                                  m_Header->MachineImageType, PlatformId,
                                  m_Header->MajorVersion,
                                  m_Header->MinorVersion & 0xffff)) != S_OK)
    {
        return Status;
    }

    // Dump does not contain this information.
    g_TargetNumberProcessors = 1;

    DEBUG_EVENT64 Event;

    if (DmppReadFileOffset(DUMP_INFO_DUMP, m_Header->DebugEventOffset, &Event,
                           sizeof(Event)) != sizeof(Event))
    {
        ErrOut("Unable to read debug event at offset %I64x\n",
               m_Header->DebugEventOffset);
        return E_FAIL;
    }

    m_EventProcess = Event.dwProcessId;
    m_EventThread = Event.dwThreadId;

    if (Event.dwDebugEventCode == EXCEPTION_DEBUG_EVENT)
    {
        g_DumpException = Event.u.Exception.ExceptionRecord;
        g_DumpExceptionFirstChance = Event.u.Exception.dwFirstChance;
    }
    else
    {
        // Fake an exception.
        ZeroMemory(&g_DumpException, sizeof(g_DumpException));
        g_DumpException.ExceptionCode = STATUS_BREAKPOINT;
        g_DumpExceptionFirstChance = FALSE;
    }

    m_ThreadCount = m_Header->ThreadCount;

    m_Memory = (PMEMORY_BASIC_INFORMATION64)
        IndexByByte(m_Header, m_Header->MemoryRegionOffset);

    ULONG64 TotalMemory;
    ULONG i;

    VerbOut("  Memory regions: %d\n",
            m_Header->MemoryRegionCount);
    TotalMemory = 0;

    PMEMORY_BASIC_INFORMATION64 Mem = m_Memory;
    for (i = 0; i < m_Header->MemoryRegionCount; i++)
    {
        VerbOut("  %5d: %s - %s, prot %08X, type %08X\n",
                i, FormatAddr64(Mem->BaseAddress),
                FormatAddr64(Mem->BaseAddress + Mem->RegionSize - 1),
                Mem->Protect, Mem->Type);

        if ((Mem->Protect & PAGE_GUARD) ||
            (Mem->Protect & PAGE_NOACCESS) ||
            (Mem->State & MEM_FREE) ||
            (Mem->State & MEM_RESERVE))
        {
            VerbOut("       Region has data-less pages\n");
        }

        TotalMemory += Mem->RegionSize;
        Mem++;
    }

    VerbOut("  Total memory region size %s\n",
            FormatAddr64(TotalMemory));

    return S_OK;
}

void
UserFull64DumpTargetInfo::Uninitialize(void)
{
    m_Header = NULL;
    m_Memory = NULL;
    UserFullDumpTargetInfo::Uninitialize();
}

HRESULT
UserFull64DumpTargetInfo::GetTargetContext(
    ULONG64 Thread,
    PVOID Context
    )
{
    if (VIRTUAL_THREAD_INDEX(Thread) >= m_Header->ThreadCount)
    {
        return E_INVALIDARG;
    }

    if (DmppReadFileOffset(DUMP_INFO_DUMP,
                           m_Header->ThreadOffset +
                           VIRTUAL_THREAD_INDEX(Thread) *
                           g_TargetMachine->m_SizeTargetContext,
                           Context,
                           g_TargetMachine->m_SizeTargetContext) ==
        g_TargetMachine->m_SizeTargetContext)
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

HRESULT
UserFull64DumpTargetInfo::GetImageVersionInformation(PCSTR ImagePath,
                                                     ULONG64 ImageBase,
                                                     PCSTR Item,
                                                     PVOID Buffer,
                                                     ULONG BufferSize,
                                                     PULONG VerInfoSize)
{
    HRESULT Status;
    IMAGE_DOS_HEADER DosHdr;
    IMAGE_NT_HEADERS64 NtHdr;

    if ((Status = ReadAllVirtual(ImageBase, &DosHdr, sizeof(DosHdr))) != S_OK)
    {
        return Status;
    }
    if (DosHdr.e_magic != IMAGE_DOS_SIGNATURE)
    {
        return E_FAIL;
    }
    
    if ((Status = ReadAllVirtual(ImageBase + DosHdr.e_lfanew,
                                 &NtHdr, sizeof(NtHdr))) != S_OK)
    {
        return Status;
    }
    if (NtHdr.Signature != IMAGE_NT_SIGNATURE ||
        NtHdr.OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC)
    {
        return E_FAIL;
    }

    if (NtHdr.OptionalHeader.NumberOfRvaAndSizes <=
        IMAGE_DIRECTORY_ENTRY_RESOURCE)
    {
        // No resource information so no version information.
        return E_NOINTERFACE;
    }

    return ReadImageVersionInfo(ImageBase, Item,
                                Buffer, BufferSize, VerInfoSize,
                                &NtHdr.OptionalHeader.
                                DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE]);
}

HRESULT
UserFull64DumpTargetInfo::QueryMemoryRegion(PULONG64 Handle,
                                            BOOL HandleIsOffset,
                                            PMEMORY_BASIC_INFORMATION64 Info)
{
    ULONG Index;
    
    if (HandleIsOffset)
    {
        for (Index = 0; Index < m_Header->MemoryRegionCount; Index++)
        {
            if (*Handle >= m_Memory[Index].BaseAddress &&
                *Handle < m_Memory[Index].BaseAddress +
                m_Memory[Index].RegionSize)
            {
                break;
            }
        }
        
        if (Index >= m_Header->MemoryRegionCount)
        {
            return E_NOINTERFACE;
        }
    }
    else
    {
        Index = (ULONG)*Handle;
        if (Index >= m_Header->MemoryRegionCount)
        {
            return HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES);
        }

        // 64-bit user dump support came into being after
        // guard pages were suppressed so they never contain them.
    }

    *Info = m_Memory[Index];
    *Handle = ++Index;

    return S_OK;
}

HRESULT
UserFull64DumpTargetInfo::IdentifyDump(PULONG64 BaseMapSize)
{
    m_Header = (PUSERMODE_CRASHDUMP_HEADER64)g_DumpBase;

    if (m_Header->Signature != USERMODE_CRASHDUMP_SIGNATURE ||
        m_Header->ValidDump != USERMODE_CRASHDUMP_VALID_DUMP64)
    {
        m_Header = NULL;
        return E_NOINTERFACE;
    }

    //
    // Check for the presence of some basic things.
    //
    
    if (m_Header->ThreadCount == 0 ||
        m_Header->ModuleCount == 0 ||
        m_Header->MemoryRegionCount == 0)
    {
        ErrOut("Thread, module or memory region count is zero.\n"
               "The dump file is probably corrupt.\n");
        return HR_DUMP_CORRUPT;
    }
    
    if (m_Header->ThreadOffset == 0 ||
        m_Header->ModuleOffset == 0 ||
        m_Header->DataOffset == 0 ||
        m_Header->MemoryRegionOffset == 0 ||
        m_Header->DebugEventOffset == 0 ||
        m_Header->ThreadStateOffset == 0)
    {
        ErrOut("A dump header data offset is zero.\n"
               "The dump file is probably corrupt.\n");
        return HR_DUMP_CORRUPT;
    }
        
    // We don't want to have to call DmppReadFileOffset
    // every time we check memory ranges so just require
    // that the memory descriptors fit in the default view.
    *BaseMapSize = m_Header->MemoryRegionOffset +
        m_Header->MemoryRegionCount * sizeof(*m_Memory);

    return S_OK;
}

void
UserFull64DumpTargetInfo::DumpDebug(void)
{
    dprintf("----- 64 bit User Full Dump Analysis\n\n");

    dprintf("MajorVersion:      %d\n", m_Header->MajorVersion);
    dprintf("MinorVersion:      %d (Build %d)\n",
            m_Header->MinorVersion & 0xffff,
            m_Header->MinorVersion >> 16);
    dprintf("MachineImageType:  %08lx\n", m_Header->MachineImageType);
    dprintf("ThreadCount:       %08lx\n", m_Header->ThreadCount);
    dprintf("ThreadOffset:      %12I64lx\n", m_Header->ThreadOffset);
    dprintf("ModuleCount:       %08lx\n", m_Header->ModuleCount);
    dprintf("ModuleOffset:      %12I64lx\n", m_Header->ModuleOffset);
    dprintf("DebugEventOffset:  %12I64lx\n", m_Header->DebugEventOffset);
    dprintf("VersionInfoOffset: %12I64lx\n", m_Header->VersionInfoOffset);
    dprintf("\nVirtual Memory Description:\n");
    dprintf("Number of regions: %d\n", m_Header->MemoryRegionCount);

    dprintf("    FileOffset            Start Address"
            "             Length\n");

    ULONG j = 0;
    ULONG64 Offset = 0;

    while (j < m_Header->MemoryRegionCount)
    {
        dprintf("      %12I64lx      %s       %12I64x",
                Offset,
                FormatAddr64(m_Memory[j].BaseAddress),
                m_Memory[j].RegionSize);

        Offset += m_Memory[j].RegionSize;

        dprintf("\n");

        j += 1;
    }
}

ULONG64
UserFull64DumpTargetInfo::VirtualToOffset(ULONG64 Virt,
                                          PULONG File, PULONG Avail)
{
    ULONG i;
    ULONG64 Offset = 0;

    *File = DUMP_INFO_DUMP;
    
    for (i = 0; i < m_Header->MemoryRegionCount; i++)
    {
        //
        // Guard pages get reported, but they are not written
        // out to the file
        //

        if (m_Memory[i].Protect & PAGE_GUARD)
        {
            continue;
        }

        if (Virt >= m_Memory[i].BaseAddress &&
            Virt < m_Memory[i].BaseAddress + m_Memory[i].RegionSize)
        {
            ULONG64 Frag = Virt - m_Memory[i].BaseAddress;
            ULONG64 Avail64 = m_Memory[i].RegionSize - Frag;
            // It's extremely unlikely that there'll be a single
            // region greater than 4GB, but check anyway.  No
            // reads should ever require more than 4GB so just
            // indicate that 4GB is available.
            if (Avail64 > 0xffffffff)
            {
                *Avail = 0xffffffff;
            }
            else
            {
                *Avail = (ULONG)Avail64;
            }
            return m_Header->DataOffset + Offset + Frag;
        }

        Offset += m_Memory[i].RegionSize;
    }

    return 0;
}

HRESULT
UserFull64DumpTargetInfo::GetThreadInfo(ULONG Index,
                                        PULONG Id, PULONG Suspend,
                                        PULONG64 Teb)
{
    if (Index >= m_ThreadCount)
    {
        return E_INVALIDARG;
    }

    CRASH_THREAD64 Thread;
    if (DmppReadFileOffset(DUMP_INFO_DUMP,
                           m_Header->ThreadStateOffset +
                           Index * sizeof(Thread),
                           &Thread, sizeof(Thread)) != sizeof(Thread))
    {
        return E_FAIL;
    }

    *Id = Thread.ThreadId;
    *Suspend = Thread.SuspendCount;
    *Teb = Thread.Teb;

    return S_OK;
}

//----------------------------------------------------------------------------
//
// UserMiniDumpTargetInfo.
//
//----------------------------------------------------------------------------

HRESULT
UserMiniDumpTargetInfo::Initialize(void)
{
    // Pick up any potentially modified base mapping pointer.
    m_Header = (PMINIDUMP_HEADER)g_DumpBase;
    // Clear pointers that have already been set so
    // that they get picked up again.
    m_SysInfo = NULL;

    g_TargetClass          = DEBUG_CLASS_USER_WINDOWS;
    g_TargetClassQualifier = DEBUG_USER_WINDOWS_SMALL_DUMP;

    g_DumpFormatFlags = 0;
    if (m_Header->Flags & MiniDumpWithFullMemory)
    {
        g_DumpFormatFlags |= DEBUG_FORMAT_USER_SMALL_FULL_MEMORY;
    }
    if (m_Header->Flags & MiniDumpWithHandleData)
    {
        g_DumpFormatFlags |= DEBUG_FORMAT_USER_SMALL_HANDLE_DATA;
    }

    MINIDUMP_DIRECTORY UNALIGNED *Dir;
    ULONG i;

    Dir = (MINIDUMP_DIRECTORY UNALIGNED *)
        IndexRva(m_Header->StreamDirectoryRva,
                 m_Header->NumberOfStreams * sizeof(*Dir),
                 "Directory");
    if (Dir == NULL)
    {
        return HR_DUMP_CORRUPT;
    }

    for (i = 0; i < m_Header->NumberOfStreams; i++)
    {
        switch(Dir->StreamType)
        {
        case ThreadListStream:
            if (IndexDirectory(i, Dir, (PVOID*)&m_Threads) == NULL)
            {
                break;
            }

            m_ActualThreadCount =
                ((MINIDUMP_THREAD_LIST UNALIGNED *)m_Threads)->NumberOfThreads;
            m_ThreadStructSize = sizeof(MINIDUMP_THREAD);
            if (Dir->Location.DataSize !=
                sizeof(MINIDUMP_THREAD_LIST) +
                sizeof(MINIDUMP_THREAD) * m_ActualThreadCount)
            {
                m_Threads = NULL;
                m_ActualThreadCount = 0;
            }
            else
            {
                // Move past count to actual thread data.
                m_Threads += sizeof(MINIDUMP_THREAD_LIST);
            }
            break;

        case ThreadExListStream:
            if (IndexDirectory(i, Dir, (PVOID*)&m_Threads) == NULL)
            {
                break;
            }

            m_ActualThreadCount =
                ((MINIDUMP_THREAD_EX_LIST UNALIGNED *)m_Threads)->
                NumberOfThreads;
            m_ThreadStructSize = sizeof(MINIDUMP_THREAD_EX);
            if (Dir->Location.DataSize !=
                sizeof(MINIDUMP_THREAD_EX_LIST) +
                sizeof(MINIDUMP_THREAD_EX) * m_ActualThreadCount)
            {
                m_Threads = NULL;
                m_ActualThreadCount = 0;
            }
            else
            {
                // Move past count to actual thread data.
                m_Threads += sizeof(MINIDUMP_THREAD_EX_LIST);
            }
            break;

        case ModuleListStream:
            if (IndexDirectory(i, Dir, (PVOID*)&m_Modules) == NULL)
            {
                break;
            }

            if (Dir->Location.DataSize !=
                sizeof(MINIDUMP_MODULE_LIST) +
                sizeof(MINIDUMP_MODULE) * m_Modules->NumberOfModules)
            {
                m_Modules = NULL;
            }
            break;

        case MemoryListStream:
            if (m_Header->Flags & MiniDumpWithFullMemory)
            {
                ErrOut("Full memory minidumps can't have MemoryListStreams\n");
                return HR_DUMP_CORRUPT;
            }

            if (IndexDirectory(i, Dir, (PVOID*)&m_Memory) == NULL)
            {
                break;
            }

            if (Dir->Location.DataSize !=
                sizeof(MINIDUMP_MEMORY_LIST) +
                sizeof(MINIDUMP_MEMORY_DESCRIPTOR) *
                m_Memory->NumberOfMemoryRanges)
            {
                m_Memory = NULL;
            }
            break;

        case Memory64ListStream:
            if (!(m_Header->Flags & MiniDumpWithFullMemory))
            {
                ErrOut("Partial memory minidumps can't have "
                       "Memory64ListStreams\n");
                return HR_DUMP_CORRUPT;
            }

            if (IndexDirectory(i, Dir, (PVOID*)&m_Memory64) == NULL)
            {
                break;
            }

            if (Dir->Location.DataSize !=
                sizeof(MINIDUMP_MEMORY64_LIST) +
                sizeof(MINIDUMP_MEMORY_DESCRIPTOR64) *
                m_Memory64->NumberOfMemoryRanges)
            {
                m_Memory64 = NULL;
            }
            break;

        case ExceptionStream:
            if (IndexDirectory(i, Dir, (PVOID*)&m_Exception) == NULL)
            {
                break;
            }

            if (Dir->Location.DataSize !=
                sizeof(MINIDUMP_EXCEPTION_STREAM))
            {
                m_Exception = NULL;
            }
            break;

        case SystemInfoStream:
            if (IndexDirectory(i, Dir, (PVOID*)&m_SysInfo) == NULL)
            {
                break;
            }

            if (Dir->Location.DataSize != sizeof(MINIDUMP_SYSTEM_INFO))
            {
                m_SysInfo = NULL;
            }
            break;

        case CommentStreamA:
            PSTR CommentA;

            CommentA = NULL;
            if (IndexDirectory(i, Dir, (PVOID*)&CommentA) == NULL)
            {
                break;
            }

            dprintf("Comment: '%s'\n", CommentA);
            break;

        case CommentStreamW:
            PWSTR CommentW;

            CommentW = NULL;
            if (IndexDirectory(i, Dir, (PVOID*)&CommentW) == NULL)
            {
                break;
            }

            dprintf("Comment: '%ls'\n", CommentW);
            break;

        case HandleDataStream:
            if (IndexDirectory(i, Dir, (PVOID*)&m_Handles) == NULL)
            {
                break;
            }

            if (Dir->Location.DataSize !=
                m_Handles->SizeOfHeader +
                m_Handles->SizeOfDescriptor *
                m_Handles->NumberOfDescriptors)
            {
                m_Handles = NULL;
            }
            break;

        case FunctionTableStream:
            if (IndexDirectory(i, Dir, (PVOID*)&m_FunctionTables) == NULL)
            {
                break;
            }

            // Don't bother walking every table to verify the size,
            // just do a simple minimum size check.
            if (Dir->Location.DataSize <
                m_FunctionTables->SizeOfHeader +
                m_FunctionTables->SizeOfDescriptor *
                m_FunctionTables->NumberOfDescriptors)
            {
                m_FunctionTables = NULL;
            }
            break;

        case UnusedStream:
            // Nothing to do.
            break;

        default:
            WarnOut("WARNING: Minidump contains unknown stream type 0x%x\n",
                    Dir->StreamType);
            break;
        }

        Dir++;
    }

    // This was already checked in Identify but check
    // again just in case something went wrong.
    if (m_SysInfo == NULL)
    {
        ErrOut("Unable to locate system info\n");
        return HR_DUMP_CORRUPT;
    }

    HRESULT Status;

    if ((Status = DmppInitGlobals(m_SysInfo->BuildNumber, 0,
                                  m_ImageType, m_SysInfo->PlatformId,
                                  m_SysInfo->MajorVersion,
                                  m_SysInfo->MinorVersion)) != S_OK)
    {
        return Status;
    }

    // Dump does not contain this information.
    g_TargetNumberProcessors = 1;

    if (m_SysInfo->CSDVersionRva != 0)
    {
        MINIDUMP_STRING UNALIGNED *CsdString = (MINIDUMP_STRING UNALIGNED *)
            IndexRva(m_SysInfo->CSDVersionRva, sizeof(*CsdString),
                     "CSD string");
        if (CsdString != NULL && CsdString->Length > 0)
        {
            WCHAR UNALIGNED *WideStr = CsdString->Buffer;
            ULONG WideLen = wcslen((PWSTR)WideStr);

            if (g_ActualSystemVersion > W9X_SVER_START &&
                g_ActualSystemVersion < W9X_SVER_END)
            {
                WCHAR UNALIGNED *Str;

                //
                // Win9x CSD strings are usually just a single
                // letter surrounded by whitespace, so clean them
                // up a little bit.
                //

                while (iswspace(*WideStr))
                {
                    WideStr++;
                }
                Str = WideStr;
                WideLen = 0;
                while (*Str && !iswspace(*Str))
                {
                    WideLen++;
                    Str++;
                }
            }

            sprintf(g_TargetServicePackString, "%.*S", WideLen, WideStr);
        }
    }

    // Minidumps don't store the process ID.
    m_EventProcess = VIRTUAL_PROCESS_ID;

    if (m_Exception != NULL)
    {
        m_EventThread = m_Exception->ThreadId;

        C_ASSERT(sizeof(m_Exception->ExceptionRecord) ==
                 sizeof(EXCEPTION_RECORD64));
        g_DumpException = *(EXCEPTION_RECORD64 UNALIGNED *)
            &m_Exception->ExceptionRecord;
    }
    else
    {
        m_EventThread = VIRTUAL_THREAD_ID(0);

        // Fake an exception.
        ZeroMemory(&g_DumpException, sizeof(g_DumpException));
        g_DumpException.ExceptionCode = STATUS_BREAKPOINT;
    }
    g_DumpExceptionFirstChance = FALSE;

    if (m_Threads != NULL)
    {
        m_ThreadCount = m_ActualThreadCount;

        if (m_Exception == NULL)
        {
            m_EventThread = IndexThreads(0)->ThreadId;
        }
    }
    else
    {
        m_ThreadCount = 1;
    }

    return S_OK;
}

void
UserMiniDumpTargetInfo::Uninitialize(void)
{
    MemoryMap_Destroy();
    m_Header = NULL;
    m_SysInfo = NULL;
    m_ActualThreadCount = 0;
    m_ThreadStructSize = 0;
    m_Threads = NULL;
    m_Modules = NULL;
    m_Memory = NULL;
    m_Memory64 = NULL;
    m_Memory64DataBase = 0;
    m_Exception = NULL;
    m_Handles = NULL;
    m_FunctionTables = NULL;
    m_ImageType = IMAGE_FILE_MACHINE_UNKNOWN;
    UserDumpTargetInfo::Uninitialize();
}

void
UserMiniDumpTargetInfo::NearestDifferentlyValidOffsets(ULONG64 Offset,
                                                       PULONG64 NextOffset,
                                                       PULONG64 NextPage)
{
    //
    // In a minidump there can be memory fragments mapped at
    // arbitrary locations so we cannot assume validity
    // changes on page boundaries.  We could attempt to
    // scan the memory list and try to find the closest valid
    // chunk of memory but it's rarely important that
    // complete accuracy is required.  Just return the
    // next byte.
    //

    if (NextOffset != NULL)
    {
        *NextOffset = Offset + 1;
    }
    if (NextPage != NULL)
    {
        *NextPage = (Offset + g_TargetMachine->m_PageSize) &
            ~((ULONG64)g_TargetMachine->m_PageSize - 1);
    }
}
    
HRESULT
UserMiniDumpTargetInfo::ReadHandleData(
    IN ULONG64 Handle,
    IN ULONG DataType,
    OUT OPTIONAL PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG DataSize
    )
{
    if (m_Handles == NULL)
    {
        return E_FAIL;
    }

    MINIDUMP_HANDLE_DESCRIPTOR UNALIGNED *Desc;

    if (DataType != DEBUG_HANDLE_DATA_TYPE_HANDLE_COUNT)
    {
        PUCHAR RawDesc = (PUCHAR)m_Handles + m_Handles->SizeOfHeader;
        ULONG i;

        for (i = 0; i < m_Handles->NumberOfDescriptors; i++)
        {
            Desc = (MINIDUMP_HANDLE_DESCRIPTOR UNALIGNED *)RawDesc;
            if (Desc->Handle == Handle)
            {
                break;
            }

            RawDesc += m_Handles->SizeOfDescriptor;
        }

        if (i >= m_Handles->NumberOfDescriptors)
        {
            return E_NOINTERFACE;
        }
    }

    ULONG Used;
    RVA StrRva;

    switch(DataType)
    {
    case DEBUG_HANDLE_DATA_TYPE_BASIC:
        Used = sizeof(DEBUG_HANDLE_DATA_BASIC);
        if (Buffer == NULL)
        {
            break;
        }

        if (BufferSize < Used)
        {
            return E_INVALIDARG;
        }

        PDEBUG_HANDLE_DATA_BASIC Basic;

        Basic = (PDEBUG_HANDLE_DATA_BASIC)Buffer;
        Basic->TypeNameSize = Desc->TypeNameRva == 0 ? 0 :
            ((MINIDUMP_STRING UNALIGNED *)
             IndexByByte(m_Header, Desc->TypeNameRva))->
            Length / sizeof(WCHAR) + 1;
        Basic->ObjectNameSize = Desc->ObjectNameRva == 0 ? 0 :
            ((MINIDUMP_STRING UNALIGNED *)
             IndexByByte(m_Header, Desc->ObjectNameRva))->
            Length / sizeof(WCHAR) + 1;
        Basic->Attributes = Desc->Attributes;
        Basic->GrantedAccess = Desc->GrantedAccess;
        Basic->HandleCount = Desc->HandleCount;
        Basic->PointerCount = Desc->PointerCount;
        break;

    case DEBUG_HANDLE_DATA_TYPE_TYPE_NAME:
        StrRva = Desc->TypeNameRva;
        break;

    case DEBUG_HANDLE_DATA_TYPE_OBJECT_NAME:
        StrRva = Desc->ObjectNameRva;
        break;

    case DEBUG_HANDLE_DATA_TYPE_HANDLE_COUNT:
        Used = sizeof(ULONG);
        if (Buffer == NULL)
        {
            break;
        }
        if (BufferSize < Used)
        {
            return E_INVALIDARG;
        }
        *(PULONG)Buffer = m_Handles->NumberOfDescriptors;
        break;
    }

    if (DataType == DEBUG_HANDLE_DATA_TYPE_TYPE_NAME ||
        DataType == DEBUG_HANDLE_DATA_TYPE_OBJECT_NAME)
    {
        if (StrRva == 0)
        {
            Used = 1;
            if (Buffer != NULL && BufferSize < Used)
            {
                return E_INVALIDARG;
            }

            *(PCHAR)Buffer = 0;
        }
        else
        {
            MINIDUMP_STRING UNALIGNED *Str = (MINIDUMP_STRING UNALIGNED *)
                IndexRva(StrRva, sizeof(*Str), "Handle name string");
            if (Str == NULL)
            {
                return HR_DUMP_CORRUPT;
            }
            Used = Str->Length / sizeof(WCHAR) + 1;
            if (Buffer != NULL &&
                WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)Str->Buffer,
                                    -1, (LPSTR)Buffer, BufferSize,
                                    NULL, NULL) == 0)
            {
                return WIN32_LAST_STATUS();
            }
        }
    }

    if (DataSize != NULL)
    {
        *DataSize = Used;
    }

    return S_OK;
}

HRESULT
UserMiniDumpTargetInfo::GetProcessorId
    (ULONG Processor, PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id)
{
    LPTSTR vendor = "<unavailable>";

    if (Processor != 0)
    {
        return E_INVALIDARG;
    }

    if (m_SysInfo == NULL)
    {
        return E_UNEXPECTED;
    }

    switch(m_SysInfo->ProcessorArchitecture)
    {
    case PROCESSOR_ARCHITECTURE_INTEL:
        Id->X86.Family = m_SysInfo->ProcessorLevel;
        Id->X86.Model = (m_SysInfo->ProcessorRevision >> 8) & 0xf;
        Id->X86.Stepping = m_SysInfo->ProcessorRevision & 0xf;
        strcpy(&(Id->X86.VendorString[0]), vendor);
        break;

    case PROCESSOR_ARCHITECTURE_ALPHA:
        Id->Alpha.Type = m_SysInfo->ProcessorLevel;
        Id->Alpha.Revision = m_SysInfo->ProcessorRevision;
        break;
        
    case PROCESSOR_ARCHITECTURE_IA64:
        Id->Ia64.Model = m_SysInfo->ProcessorLevel;
        Id->Ia64.Revision = m_SysInfo->ProcessorRevision;
        strcpy(&(Id->Ia64.VendorString[0]), vendor);
        break;
        
    case PROCESSOR_ARCHITECTURE_AMD64:
        Id->Amd64.Family = m_SysInfo->ProcessorLevel;
        Id->Amd64.Model = (m_SysInfo->ProcessorRevision >> 8) & 0xf;
        Id->Amd64.Stepping = m_SysInfo->ProcessorRevision & 0xf;
        strcpy(&(Id->Amd64.VendorString[0]), vendor);
        break;
    }

    return S_OK;
}

PVOID
UserMiniDumpTargetInfo::FindDynamicFunctionEntry(MachineInfo* Machine,
                                                 ULONG64 Address)
{
    if (m_FunctionTables == NULL)
    {
        return NULL;
    }

    PUCHAR StreamData =
        (PUCHAR)m_FunctionTables + m_FunctionTables->SizeOfHeader +
        m_FunctionTables->SizeOfAlignPad;
    ULONG TableIdx;

    for (TableIdx = 0;
         TableIdx < m_FunctionTables->NumberOfDescriptors;
         TableIdx++)
    {
        // Stream structure contents are guaranteed to be
        // properly aligned.
        PMINIDUMP_FUNCTION_TABLE_DESCRIPTOR Desc =
            (PMINIDUMP_FUNCTION_TABLE_DESCRIPTOR)StreamData;
        StreamData += m_FunctionTables->SizeOfDescriptor;

        PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE RawTable =
            (PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE)StreamData;
        StreamData += m_FunctionTables->SizeOfNativeDescriptor;

        PVOID TableData = (PVOID)StreamData;
        StreamData += Desc->EntryCount *
            m_FunctionTables->SizeOfFunctionEntry +
            Desc->SizeOfAlignPad;
        
        if (Address >= Desc->MinimumAddress && Address < Desc->MaximumAddress)
        {
            PVOID Entry = Machine->FindDynamicFunctionEntry
                (RawTable, Address, TableData,
                 Desc->EntryCount * m_FunctionTables->SizeOfFunctionEntry);
            if (Entry)
            {
                return Entry;
            }
        }
    }

    return NULL;
}

ULONG64
UserMiniDumpTargetInfo::GetDynamicFunctionTableBase(MachineInfo* Machine,
                                                    ULONG64 Address)
{
    if (m_FunctionTables == NULL)
    {
        return 0;
    }

    PUCHAR StreamData =
        (PUCHAR)m_FunctionTables + m_FunctionTables->SizeOfHeader +
        m_FunctionTables->SizeOfAlignPad;
    ULONG TableIdx;

    for (TableIdx = 0;
         TableIdx < m_FunctionTables->NumberOfDescriptors;
         TableIdx++)
    {
        // Stream structure contents are guaranteed to be
        // properly aligned.
        PMINIDUMP_FUNCTION_TABLE_DESCRIPTOR Desc =
            (PMINIDUMP_FUNCTION_TABLE_DESCRIPTOR)StreamData;
        StreamData +=
            m_FunctionTables->SizeOfDescriptor +
            m_FunctionTables->SizeOfNativeDescriptor +
            Desc->EntryCount * m_FunctionTables->SizeOfFunctionEntry +
            Desc->SizeOfAlignPad;
        
        if (Address >= Desc->MinimumAddress && Address < Desc->MaximumAddress)
        {
            return Desc->BaseAddress;
        }
    }

    return 0;
}

HRESULT
UserMiniDumpTargetInfo::GetTargetContext(
    ULONG64 Thread,
    PVOID Context
    )
{
    if (m_Threads == NULL ||
        VIRTUAL_THREAD_INDEX(Thread) >= m_ActualThreadCount)
    {
        return E_INVALIDARG;
    }

    PVOID ContextData =
        IndexRva(IndexThreads(VIRTUAL_THREAD_INDEX(Thread))->ThreadContext.Rva,
                 g_TargetMachine->m_SizeTargetContext,
                 "Thread context data");
    if (ContextData == NULL)
    {
        return HR_DUMP_CORRUPT;
    }

    memcpy(Context, ContextData, g_TargetMachine->m_SizeTargetContext);

    return S_OK;
}

HRESULT
UserMiniDumpTargetInfo::IdentifyDump(PULONG64 BaseMapSize)
{
    m_Header = (PMINIDUMP_HEADER)g_DumpBase;

    if (m_Header->Signature != MINIDUMP_SIGNATURE ||
        (m_Header->Version & 0xffff) != MINIDUMP_VERSION)
    {
        m_Header = NULL;
        return E_NOINTERFACE;
    }

    MINIDUMP_DIRECTORY UNALIGNED *Dir;
    ULONG i;

    Dir = (MINIDUMP_DIRECTORY UNALIGNED *)
        IndexRva(m_Header->StreamDirectoryRva,
                 m_Header->NumberOfStreams * sizeof(*Dir),
                 "Directory");
    if (Dir == NULL)
    {
        return HR_DUMP_CORRUPT;
    }

    for (i = 0; i < m_Header->NumberOfStreams; i++)
    {
        switch(Dir->StreamType)
        {
        case SystemInfoStream:
            if (IndexDirectory(i, Dir, (PVOID*)&m_SysInfo) == NULL)
            {
                break;
            }
            if (Dir->Location.DataSize != sizeof(MINIDUMP_SYSTEM_INFO))
            {
                m_SysInfo = NULL;
            }
            break;
        case Memory64ListStream:
            MINIDUMP_MEMORY64_LIST Mem64;

            // The memory for the full memory list may not
            // fit within the initial mapping used at identify
            // time so do not directly index.  Instead, use
            // the adaptive read to get the data so we can
            // determine the data base.
            if (DmppReadFileOffset(DUMP_INFO_DUMP, Dir->Location.Rva,
                                   &Mem64, sizeof(Mem64)) == sizeof(Mem64) &&
                Dir->Location.DataSize ==
                sizeof(MINIDUMP_MEMORY64_LIST) +
                sizeof(MINIDUMP_MEMORY_DESCRIPTOR64) *
                Mem64.NumberOfMemoryRanges)
            {
                m_Memory64DataBase = Mem64.BaseRva;
            }

            // Clear any cache entries that may have been
            // added by the above read so that only the
            // identify mapping is active.
            DmppDumpFileCacheEmpty(&g_DumpInfoFiles[DUMP_INFO_DUMP]);
            break;
        }

        Dir++;
    }

    if (m_SysInfo == NULL)
    {
        ErrOut("Minidump does not have system info\n");
        return E_FAIL;
    }

    switch(m_SysInfo->ProcessorArchitecture)
    {
    case PROCESSOR_ARCHITECTURE_INTEL:
        m_ImageType = IMAGE_FILE_MACHINE_I386;
        break;
    case PROCESSOR_ARCHITECTURE_ALPHA:
        m_ImageType = IMAGE_FILE_MACHINE_ALPHA;
        break;
    case PROCESSOR_ARCHITECTURE_IA64:
        m_ImageType = IMAGE_FILE_MACHINE_IA64;
        break;
    case PROCESSOR_ARCHITECTURE_ALPHA64:
        m_ImageType = IMAGE_FILE_MACHINE_AXP64;
        break;
    case PROCESSOR_ARCHITECTURE_AMD64:
        m_ImageType = IMAGE_FILE_MACHINE_AMD64;
        break;
    default:
        return E_FAIL;
    }

    // We rely on being able to directly access the entire
    // content of the dump through the default view so
    // ensure that it's possible.
    *BaseMapSize = g_DumpInfoFiles[DUMP_INFO_DUMP].FileSize;

    return S_OK;
}

ModuleInfo*
UserMiniDumpTargetInfo::GetModuleInfo(BOOL UserMode)
{
    DBG_ASSERT(UserMode);
    return &g_UserMiniModuleIterator;
}

HRESULT
UserMiniDumpTargetInfo::GetImageVersionInformation(PCSTR ImagePath,
                                                   ULONG64 ImageBase,
                                                   PCSTR Item,
                                                   PVOID Buffer,
                                                   ULONG BufferSize,
                                                   PULONG VerInfoSize)
{
    //
    // Find the image in the dump module list.
    //

    if (m_Modules == NULL)
    {
        return E_NOINTERFACE;
    }

    ULONG i;
    MINIDUMP_MODULE UNALIGNED *Mod = m_Modules->Modules;
    for (i = 0; i < m_Modules->NumberOfModules; i++)
    {
        if (ImageBase == Mod->BaseOfImage)
        {
            break;
        }

        Mod++;
    }

    if (i == m_Modules->NumberOfModules)
    {
        return E_NOINTERFACE;
    }

    PVOID Data = NULL;
    ULONG DataSize = 0;

    if (Item[0] == '\\' && Item[1] == 0)
    {
        Data = &Mod->VersionInfo;
        DataSize = sizeof(Mod->VersionInfo);
    }
    else
    {
        return E_INVALIDARG;
    }

    return FillDataBuffer(Data, DataSize, Buffer, BufferSize, VerInfoSize);
}

HRESULT
UserMiniDumpTargetInfo::GetExceptionContext(PCROSS_PLATFORM_CONTEXT Context)
{
    if (m_Exception != NULL)
    {
        PVOID ContextData;

        if (m_Exception->ThreadContext.DataSize <
            g_TargetMachine->m_SizeTargetContext ||
            (ContextData = IndexRva(m_Exception->ThreadContext.Rva,
                                    g_TargetMachine->m_SizeTargetContext,
                                    "Exception context")) == NULL)
        {
            return E_FAIL;
        }

        memcpy(Context, ContextData, g_TargetMachine->m_SizeTargetContext);
        return S_OK;
    }
    else
    {
        ErrOut("Minidump doesn't have an exception context\n");
        return E_FAIL;
    }
}

ULONG64
UserMiniDumpTargetInfo::GetCurrentTimeDateN(void)
{
    return TimeDateStampToFileTime(m_Header->TimeDateStamp);
}

HRESULT
UserMiniDumpTargetInfo::GetThreadInfo(ULONG Index,
                                      PULONG Id, PULONG Suspend, PULONG64 Teb)
{
    if (m_Threads == NULL || Index >= m_ActualThreadCount)
    {
        return E_INVALIDARG;
    }

    MINIDUMP_THREAD_EX UNALIGNED *Thread = IndexThreads(Index);
    *Id = Thread->ThreadId;
    *Suspend = Thread->SuspendCount;
    *Teb = Thread->Teb;

    return S_OK;
}

PSTR g_MiniStreamNames[] =
{
    "UnusedStream", "ReservedStream0", "ReservedStream1", "ThreadListStream",
    "ModuleListStream", "MemoryListStream", "ExceptionStream",
    "SystemInfoStream", "ThreadExListStream", "Memory64ListStream",
    "CommentStreamA", "CommentStreamW", "HandleDataStream",
    "FunctionTableStream",
};

PSTR
MiniStreamTypeName(ULONG32 Type)
{
    if (Type < sizeof(g_MiniStreamNames) / sizeof(g_MiniStreamNames[0]))
    {
        return g_MiniStreamNames[Type];
    }
    else
    {
        return "???";
    }
}

PVOID
UserMiniDumpTargetInfo::IndexRva(RVA Rva, ULONG Size, PCSTR Title)
{
    if (Rva >= g_DumpInfoFiles[DUMP_INFO_DUMP].MapSize)
    {
        ErrOut("ERROR: %s not present in dump (RVA 0x%X)\n",
               Title, Rva);
        return NULL;
    }
    else if (Rva + Size > g_DumpInfoFiles[DUMP_INFO_DUMP].MapSize)
    {
        ErrOut("ERROR: %s only partially present in dump "
               "(RVA 0x%X, size 0x%X)\n",
               Title, Rva, Size);
        return NULL;
    }

    return IndexByByte(m_Header, Rva);
}

PVOID
UserMiniDumpTargetInfo::IndexDirectory(ULONG Index,
                                       MINIDUMP_DIRECTORY UNALIGNED *Dir,
                                       PVOID* Store)
{
    if (*Store != NULL)
    {
        WarnOut("WARNING: Ignoring extra %s stream, dir entry %d\n",
                MiniStreamTypeName(Dir->StreamType), Index);
        return NULL;
    }

    char Msg[128];

    sprintf(Msg, "Dir entry %d, %s stream",
            Index, MiniStreamTypeName(Dir->StreamType));

    PVOID Ptr = IndexRva(Dir->Location.Rva, Dir->Location.DataSize, Msg);
    if (Ptr != NULL)
    {
        *Store = Ptr;
    }
    return Ptr;
}

void
UserMiniDumpTargetInfo::DumpDebug(void)
{
    ULONG i;

    dprintf("----- User Mini Dump Analysis\n");

    dprintf("\nMINIDUMP_HEADER:\n");
    dprintf("Version         %X (%X)\n",
            m_Header->Version & 0xffff, m_Header->Version >> 16);
    dprintf("NumberOfStreams %d\n", m_Header->NumberOfStreams);
    dprintf("Flags %X\n", m_Header->Flags);

    MINIDUMP_DIRECTORY UNALIGNED *Dir;

    dprintf("\nStreams:\n");
    Dir = (MINIDUMP_DIRECTORY UNALIGNED *)
        IndexRva(m_Header->StreamDirectoryRva,
                 m_Header->NumberOfStreams * sizeof(*Dir),
                 "Directory");
    if (Dir == NULL)
    {
        return;
    }

    PVOID Data;

    for (i = 0; i < m_Header->NumberOfStreams; i++)
    {
        dprintf("Stream %d: type %s (%d), size %08X, RVA %08X\n",
                i, MiniStreamTypeName(Dir->StreamType), Dir->StreamType,
                Dir->Location.DataSize, Dir->Location.Rva);

        Data = NULL;
        if (IndexDirectory(i, Dir, &Data) == NULL)
        {
            continue;
        }

        ULONG j;
        RVA Rva;
        
        Rva = Dir->Location.Rva;

        switch(Dir->StreamType)
        {
        case ModuleListStream:
            MINIDUMP_MODULE_LIST UNALIGNED *ModList;
            MINIDUMP_MODULE UNALIGNED *Mod;

            ModList = (MINIDUMP_MODULE_LIST UNALIGNED *)Data;
            Mod = ModList->Modules;
            dprintf("  %d modules\n", ModList->NumberOfModules);
            Rva += FIELD_OFFSET(MINIDUMP_MODULE_LIST, Modules);
            for (j = 0; j < ModList->NumberOfModules; j++)
            {
                PVOID Str = IndexRva(Mod->ModuleNameRva,
                                     sizeof(MINIDUMP_STRING),
                                     "Module entry name");
                dprintf("  RVA %08X, %s - %s: '%S'\n",
                        Rva,
                        FormatAddr64(Mod->BaseOfImage),
                        FormatAddr64(Mod->BaseOfImage + Mod->SizeOfImage),
                        Str != NULL ?
                        ((MINIDUMP_STRING UNALIGNED *)Str)->Buffer :
                        L"** Invalid **");
                Mod++;
                Rva += sizeof(*Mod);
            }
            break;

        case MemoryListStream:
            {
            MINIDUMP_MEMORY_LIST UNALIGNED *MemList;

            MemList = (MINIDUMP_MEMORY_LIST UNALIGNED *)Data;
            dprintf("  %d memory ranges\n", MemList->NumberOfMemoryRanges);
            dprintf("  range#    Address      %sSize\n",
                    g_TargetMachine->m_Ptr64 ? "       " : "");
            for (j = 0; j < MemList->NumberOfMemoryRanges; j++)
            {
                dprintf("    %4d    %s   %s\n",
                        j,
                        FormatAddr64(MemList->MemoryRanges[j].StartOfMemoryRange),
                        FormatAddr64(MemList->MemoryRanges[j].Memory.DataSize));
            }
            break;
            }

        case Memory64ListStream:
            {
            MINIDUMP_MEMORY64_LIST UNALIGNED *MemList;

            MemList = (MINIDUMP_MEMORY64_LIST UNALIGNED *)Data;
            dprintf("  %d memory ranges\n", MemList->NumberOfMemoryRanges);
            dprintf("  RVA 0x%X BaseRva\n", (ULONG)(MemList->BaseRva));
            dprintf("  range#   Address      %sSize\n",
                    g_TargetMachine->m_Ptr64 ? "       " : "");
            for (j = 0; j < MemList->NumberOfMemoryRanges; j++)
            {
                dprintf("    %4d  %s %s\n",
                        j,
                        FormatAddr64(MemList->MemoryRanges[j].StartOfMemoryRange),
                        FormatAddr64(MemList->MemoryRanges[j].DataSize));
            }
            break;
            }

        case CommentStreamA:
            dprintf("  '%s'\n", Data);
            break;

        case CommentStreamW:
            dprintf("  '%ls'\n", Data);
            break;
        }

        Dir++;
    }
}

//----------------------------------------------------------------------------
//
// UserMiniPartialDumpTargetInfo.
//
//----------------------------------------------------------------------------

HRESULT
UserMiniPartialDumpTargetInfo::Initialize(void)
{
    HRESULT Status;

    dprintf("User Mini Dump File: Only registers and stack "
            "trace are available\n\n");

    if ((Status = UserMiniDumpTargetInfo::Initialize()) != S_OK)
    {
        return Status;
    }

    if (m_Memory != NULL)
    {
        //
        // Map every piece of memory in the dump.  This makes
        // ReadVirtual very simple and there shouldn't be that
        // many ranges so it doesn't require that many map regions.
        //

        if (!MemoryMap_Create())
        {
            return E_OUTOFMEMORY;
        }

        MINIDUMP_MEMORY_DESCRIPTOR UNALIGNED *Mem;
        ULONG i;
        ULONG64 TotalMemory;

        Mem = m_Memory->MemoryRanges;
        for (i = 0; i < m_Memory->NumberOfMemoryRanges; i++)
        {
            PVOID Data = IndexRva(Mem->Memory.Rva, Mem->Memory.DataSize,
                                  "Memory range data");
            if (Data == NULL)
            {
                return HR_DUMP_CORRUPT;
            }
            if ((Status = MemoryMap_AddRegion(Mem->StartOfMemoryRange,
                                              Mem->Memory.DataSize, Data,
                                              NULL, FALSE)) != S_OK)
            {
                return Status;
            }

            Mem++;
        }

        VerbOut("  Memory regions: %d\n",
                m_Memory->NumberOfMemoryRanges);
        Mem = m_Memory->MemoryRanges;
        TotalMemory = 0;
        for (i = 0; i < m_Memory->NumberOfMemoryRanges; i++)
        {
            VerbOut("  %5d: %s - %s\n",
                    i, FormatAddr64(Mem->StartOfMemoryRange),
                    FormatAddr64(Mem->StartOfMemoryRange +
                                 Mem->Memory.DataSize - 1));
            TotalMemory += Mem->Memory.DataSize;
            Mem++;
        }
        VerbOut("  Total memory region size %s\n",
                FormatAddr64(TotalMemory));
    }

    return S_OK;
}

HRESULT
UserMiniPartialDumpTargetInfo::ReadVirtual(
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesRead
    )
{
    // All virtual memory is contained in the memory map.
    return MemoryMap_ReadMemory(Offset, Buffer, BufferSize,
                                BytesRead) ? S_OK : E_FAIL;
}

HRESULT
UserMiniPartialDumpTargetInfo::QueryMemoryRegion
    (PULONG64 Handle,
     BOOL HandleIsOffset,
     PMEMORY_BASIC_INFORMATION64 Info)
{
    ULONG Index;
    MINIDUMP_MEMORY_DESCRIPTOR UNALIGNED *Mem;
    
    if (HandleIsOffset)
    {
        if (m_Memory == NULL)
        {
            return E_NOINTERFACE;
        }
        
        Mem = m_Memory->MemoryRanges;
        for (Index = 0; Index < m_Memory->NumberOfMemoryRanges; Index++)
        {
            if (*Handle >= Mem->StartOfMemoryRange &&
                *Handle < Mem->StartOfMemoryRange + Mem->Memory.DataSize)
            {
                break;
            }

            Mem++;
        }
        
        if (Index >= m_Memory->NumberOfMemoryRanges)
        {
            return E_NOINTERFACE;
        }
    }
    else
    {
        Index = (ULONG)*Handle;
        if (m_Memory == NULL || Index >= m_Memory->NumberOfMemoryRanges)
        {
            return HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES);
        }
        
        Mem = m_Memory->MemoryRanges + Index;
    }

    Info->BaseAddress = Mem->StartOfMemoryRange;
    Info->AllocationBase = Mem->StartOfMemoryRange;
    Info->AllocationProtect = PAGE_READWRITE;
    Info->__alignment1 = 0;
    Info->RegionSize = Mem->Memory.DataSize;
    Info->State = MEM_COMMIT;
    Info->Protect = PAGE_READWRITE;
    Info->Type = MEM_PRIVATE;
    Info->__alignment2 = 0;
    *Handle = ++Index;

    return S_OK;
}

HRESULT
UserMiniPartialDumpTargetInfo::IdentifyDump(PULONG64 BaseMapSize)
{
    HRESULT Status;

    if ((Status = UserMiniDumpTargetInfo::IdentifyDump(BaseMapSize)) != S_OK)
    {
        return Status;
    }

    if (m_Header->Flags & MiniDumpWithFullMemory)
    {
        return E_NOINTERFACE;
    }

    return S_OK;
}

ULONG64
UserMiniPartialDumpTargetInfo::VirtualToOffset(ULONG64 Virt,
                                               PULONG File, PULONG Avail)
{
    *File = DUMP_INFO_DUMP;
    
    if (m_Memory == NULL)
    {
        return 0;
    }

    MINIDUMP_MEMORY_DESCRIPTOR UNALIGNED *Mem = m_Memory->MemoryRanges;
    ULONG i;

    for (i = 0; i < m_Memory->NumberOfMemoryRanges; i++)
    {
        if (Virt >= Mem->StartOfMemoryRange &&
            Virt < Mem->StartOfMemoryRange + Mem->Memory.DataSize)
        {
            ULONG Frag = (ULONG)(Virt - Mem->StartOfMemoryRange);
            *Avail = Mem->Memory.DataSize - Frag;
            return Mem->Memory.Rva + Frag;
        }

        Mem++;
    }

    return 0;
}

//----------------------------------------------------------------------------
//
// UserMiniFullDumpTargetInfo.
//
//----------------------------------------------------------------------------

HRESULT
UserMiniFullDumpTargetInfo::Initialize(void)
{
    HRESULT Status;

    dprintf("User Mini Dump File with Full Memory: Only application "
            "data is available\n\n");

    if ((Status = UserMiniDumpTargetInfo::Initialize()) != S_OK)
    {
        return Status;
    }

    if (m_Memory != NULL)
    {
        ULONG64 TotalMemory;
        ULONG i;
        MINIDUMP_MEMORY_DESCRIPTOR64 UNALIGNED *Mem;
        
        VerbOut("  Memory regions: %d\n",
                m_Memory64->NumberOfMemoryRanges);
        Mem = m_Memory64->MemoryRanges;
        TotalMemory = 0;
        for (i = 0; i < m_Memory64->NumberOfMemoryRanges; i++)
        {
            VerbOut("  %5d: %s - %s\n",
                    i, FormatAddr64(Mem->StartOfMemoryRange),
                    FormatAddr64(Mem->StartOfMemoryRange +
                                 Mem->DataSize - 1));
            TotalMemory += Mem->DataSize;
            Mem++;
        }
        VerbOut("  Total memory region size %s\n",
                FormatAddr64(TotalMemory));
    }

    return S_OK;
}

HRESULT
UserMiniFullDumpTargetInfo::QueryMemoryRegion
    (PULONG64 Handle,
     BOOL HandleIsOffset,
     PMEMORY_BASIC_INFORMATION64 Info)
{
    ULONG Index;
    MINIDUMP_MEMORY_DESCRIPTOR64 UNALIGNED *Mem;
    
    if (HandleIsOffset)
    {
        if (m_Memory64 == NULL)
        {
            return E_NOINTERFACE;
        }
        
        Mem = m_Memory64->MemoryRanges;
        for (Index = 0; Index < m_Memory64->NumberOfMemoryRanges; Index++)
        {
            if (*Handle >= Mem->StartOfMemoryRange &&
                *Handle < Mem->StartOfMemoryRange + Mem->DataSize)
            {
                break;
            }

            Mem++;
        }
        
        if (Index >= m_Memory64->NumberOfMemoryRanges)
        {
            return E_NOINTERFACE;
        }
    }
    else
    {
        Index = (ULONG)*Handle;
        if (m_Memory64 == NULL || Index >= m_Memory64->NumberOfMemoryRanges)
        {
            return HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES);
        }
        
        Mem = m_Memory64->MemoryRanges + Index;
    }

    Info->BaseAddress = Mem->StartOfMemoryRange;
    Info->AllocationBase = Mem->StartOfMemoryRange;
    Info->AllocationProtect = PAGE_READWRITE;
    Info->__alignment1 = 0;
    Info->RegionSize = Mem->DataSize;
    Info->State = MEM_COMMIT;
    Info->Protect = PAGE_READWRITE;
    Info->Type = MEM_PRIVATE;
    Info->__alignment2 = 0;
    *Handle = ++Index;

    return S_OK;
}

HRESULT
UserMiniFullDumpTargetInfo::IdentifyDump(PULONG64 BaseMapSize)
{
    HRESULT Status;

    if ((Status = UserMiniDumpTargetInfo::IdentifyDump(BaseMapSize)) != S_OK)
    {
        return Status;
    }

    if (!(m_Header->Flags & MiniDumpWithFullMemory))
    {
        return E_NOINTERFACE;
    }
    if (m_Memory64DataBase == 0)
    {
        ErrOut("Full-memory minidump must have a Memory64ListStream\n");
        return E_FAIL;
    }

    // In the case of a full memory minidump we don't
    // want to map the entire dump as it can be very large.
    // Fortunately, we are guaranteed that all of the raw
    // memory data in a full memory minidump will be at the
    // end of the dump, so we can just map the dump up
    // to the memory content and stop.
    *BaseMapSize = m_Memory64DataBase;

    return S_OK;
}

ULONG64
UserMiniFullDumpTargetInfo::VirtualToOffset(ULONG64 Virt,
                                            PULONG File, PULONG Avail)
{
    *File = DUMP_INFO_DUMP;
    
    if (m_Memory64 == NULL)
    {
        return 0;
    }

    MINIDUMP_MEMORY_DESCRIPTOR64 UNALIGNED *Mem = m_Memory64->MemoryRanges;
    ULONG i;
    ULONG64 Offset = m_Memory64->BaseRva;

    for (i = 0; i < m_Memory64->NumberOfMemoryRanges; i++)
    {
        if (Virt >= Mem->StartOfMemoryRange &&
            Virt < Mem->StartOfMemoryRange + Mem->DataSize)
        {
            ULONG64 Frag = Virt - Mem->StartOfMemoryRange;
            ULONG64 Avail64 = Mem->DataSize - Frag;
            if (Avail64 > 0xffffffff)
            {
                *Avail = 0xffffffff;
            }
            else
            {
                *Avail = (ULONG)Avail64;
            }
            return Offset + Frag;
        }

        Offset += Mem->DataSize;
        Mem++;
    }

    return 0;
}

//----------------------------------------------------------------------------
//
// ModuleInfo implementations.
//
//----------------------------------------------------------------------------

HRESULT
KernelTriage32ModuleInfo::Initialize(void)
{
    m_Target = (KernelTriage32DumpTargetInfo*)g_Target;

    if (m_Target->m_Dump->Triage.DriverListOffset != 0)
    {
        m_Head = m_Target->m_Dump->Triage.DriverCount;
        m_Cur = 0;
        return S_OK;
    }
    else
    {
        dprintf("Mini Kernel Dump does not contain driver list\n");
        return S_FALSE;
    }
}

HRESULT
KernelTriage32ModuleInfo::GetEntry(PMODULE_INFO_ENTRY Entry)
{
    if (m_Cur == m_Head)
    {
        return S_FALSE;
    }

    PDUMP_DRIVER_ENTRY32 DriverEntry;
    PDUMP_STRING DriverName;

    DBG_ASSERT(m_Target->m_Dump->Triage.DriverListOffset != 0);

    DriverEntry = (PDUMP_DRIVER_ENTRY32)
        IndexByByte(m_Target->m_Dump,
                    m_Target->m_Dump->Triage.DriverListOffset +
                    m_Cur * sizeof(*DriverEntry));
    DriverName = (PDUMP_STRING)
        IndexByByte(m_Target->m_Dump, DriverEntry->DriverNameOffset);

    Entry->NamePtr = (PSTR)DriverName->Buffer;
    Entry->UnicodeNamePtr = 1;
    Entry->NameLength = DriverName->Length * sizeof(WCHAR);
    Entry->Base = EXTEND64(DriverEntry->LdrEntry.DllBase);
    Entry->Size = DriverEntry->LdrEntry.SizeOfImage;
    Entry->ImageInfoValid = TRUE;
    Entry->CheckSum = DriverEntry->LdrEntry.CheckSum;
    Entry->TimeDateStamp = DriverEntry->LdrEntry.TimeDateStamp;

    m_Cur++;
    return S_OK;
}

KernelTriage32ModuleInfo g_KernelTriage32ModuleIterator;

HRESULT
KernelTriage64ModuleInfo::Initialize(void)
{
    m_Target = (KernelTriage64DumpTargetInfo*)g_Target;

    if (m_Target->m_Dump->Triage.DriverListOffset != 0)
    {
        m_Head = m_Target->m_Dump->Triage.DriverCount;
        m_Cur = 0;
        return S_OK;
    }
    else
    {
        dprintf("Mini Kernel Dump does not contain driver list\n");
        return S_FALSE;
    }
}

HRESULT
KernelTriage64ModuleInfo::GetEntry(PMODULE_INFO_ENTRY Entry)
{
    if (m_Cur == m_Head)
    {
        return S_FALSE;
    }

    PDUMP_DRIVER_ENTRY64 DriverEntry;
    PDUMP_STRING DriverName;

    DBG_ASSERT(m_Target->m_Dump->Triage.DriverListOffset != 0);

    DriverEntry = (PDUMP_DRIVER_ENTRY64)
        IndexByByte(m_Target->m_Dump,
                    m_Target->m_Dump->Triage.DriverListOffset +
                    m_Cur * sizeof(*DriverEntry));
    DriverName = (PDUMP_STRING)
        IndexByByte(m_Target->m_Dump, DriverEntry->DriverNameOffset);

    Entry->NamePtr = (PSTR)DriverName->Buffer;
    Entry->UnicodeNamePtr = 1;
    Entry->NameLength = DriverName->Length * sizeof(WCHAR);
    Entry->Base = DriverEntry->LdrEntry.DllBase;
    Entry->Size = DriverEntry->LdrEntry.SizeOfImage;
    Entry->ImageInfoValid = TRUE;
    Entry->CheckSum = DriverEntry->LdrEntry.CheckSum;
    Entry->TimeDateStamp = DriverEntry->LdrEntry.TimeDateStamp;

    m_Cur++;
    return S_OK;
}

KernelTriage64ModuleInfo g_KernelTriage64ModuleIterator;

HRESULT
UserMiniModuleInfo::Initialize(void)
{
    m_Target = (UserMiniDumpTargetInfo*)g_Target;

    if (m_Target->m_Modules != NULL)
    {
        m_Head = m_Target->m_Modules->NumberOfModules;
        m_Cur = 0;
        return S_OK;
    }
    else
    {
        m_Head = 0;
        m_Cur = 0;
        dprintf("User Mode Mini Dump does not have a module list\n");
        return S_FALSE;
    }
}

HRESULT
UserMiniModuleInfo::GetEntry(PMODULE_INFO_ENTRY Entry)
{
    if (m_Cur == m_Head)
    {
        return S_FALSE;
    }

    MINIDUMP_MODULE UNALIGNED *Mod;
    MINIDUMP_STRING UNALIGNED *ModName;

    DBG_ASSERT(m_Target->m_Modules != NULL);

    Mod = m_Target->m_Modules->Modules + m_Cur;
    ModName = (MINIDUMP_STRING UNALIGNED *)
        m_Target->IndexRva(Mod->ModuleNameRva, sizeof(*ModName),
                           "Module entry name");
    if (ModName == NULL)
    {
        return HR_DUMP_CORRUPT;
    }

    Entry->NamePtr = (PSTR)ModName->Buffer;
    Entry->UnicodeNamePtr = 1;
    Entry->NameLength = ModName->Length;
    // Some dumps do not have properly sign-extended addresses,
    // so force the extension on 32-bit platforms.
    if (g_TargetMachineType == IMAGE_FILE_MACHINE_I386 ||
        g_TargetMachineType == IMAGE_FILE_MACHINE_ALPHA)
    {
        Entry->Base = EXTEND64(Mod->BaseOfImage);
    }
    else
    {
        Entry->Base = Mod->BaseOfImage;
    }
    Entry->Size = Mod->SizeOfImage;
    Entry->ImageInfoValid = TRUE;
    Entry->CheckSum = Mod->CheckSum;
    Entry->TimeDateStamp = Mod->TimeDateStamp;

    m_Cur++;
    return S_OK;
}

UserMiniModuleInfo g_UserMiniModuleIterator;

HRESULT
KernelTriage32UnloadedModuleInfo::Initialize(void)
{
    m_Target = (KernelTriage32DumpTargetInfo*)g_Target;

    if (m_Target->m_Dump->Triage.UnloadedDriversOffset != 0)
    {
        PVOID Data = IndexByByte
            (m_Target->m_Dump, m_Target->m_Dump->Triage.UnloadedDriversOffset);
        m_Cur = (PDUMP_UNLOADED_DRIVERS32)((PULONG)Data + 1);
        m_End = m_Cur + *(PULONG)Data;
        return S_OK;
    }
    else
    {
        dprintf("Mini Kernel Dump does not contain unloaded driver list\n");
        return S_FALSE;
    }
}

HRESULT
KernelTriage32UnloadedModuleInfo::GetEntry(PSTR Name,
                                           PDEBUG_MODULE_PARAMETERS Params)
{
    if (m_Cur == m_End)
    {
        return S_FALSE;
    }

    ZeroMemory(Params, sizeof(*Params));
    Params->Base = EXTEND64(m_Cur->StartAddress);
    Params->Size = m_Cur->EndAddress - m_Cur->StartAddress;
    Params->Flags = DEBUG_MODULE_UNLOADED;

    if (Name != NULL)
    {
        USHORT NameLen = m_Cur->Name.Length;
        if (NameLen > MAX_UNLOADED_NAME_LENGTH)
        {
            NameLen = MAX_UNLOADED_NAME_LENGTH;
        }
        if (WideCharToMultiByte(CP_ACP, 0, m_Cur->DriverName,
                                NameLen / sizeof(WCHAR),
                                Name,
                                MAX_UNLOADED_NAME_LENGTH / sizeof(WCHAR) + 1,
                                NULL, NULL) == 0)
        {
            return WIN32_LAST_STATUS();
        }

        Name[NameLen / sizeof(WCHAR)] = 0;
    }

    m_Cur++;
    return S_OK;
}

KernelTriage32UnloadedModuleInfo g_KernelTriage32UnloadedModuleIterator;

HRESULT
KernelTriage64UnloadedModuleInfo::Initialize(void)
{
    m_Target = (KernelTriage64DumpTargetInfo*)g_Target;

    if (m_Target->m_Dump->Triage.UnloadedDriversOffset != 0)
    {
        PVOID Data = IndexByByte
            (m_Target->m_Dump, m_Target->m_Dump->Triage.UnloadedDriversOffset);
        m_Cur = (PDUMP_UNLOADED_DRIVERS64)((PULONG64)Data + 1);
        m_End = m_Cur + *(PULONG)Data;
        return S_OK;
    }
    else
    {
        dprintf("Mini Kernel Dump does not contain unloaded driver list\n");
        return S_FALSE;
    }
}

HRESULT
KernelTriage64UnloadedModuleInfo::GetEntry(PSTR Name,
                                           PDEBUG_MODULE_PARAMETERS Params)
{
    if (m_Cur == m_End)
    {
        return S_FALSE;
    }

    ZeroMemory(Params, sizeof(*Params));
    Params->Base = m_Cur->StartAddress;
    Params->Size = (ULONG)(m_Cur->EndAddress - m_Cur->StartAddress);
    Params->Flags = DEBUG_MODULE_UNLOADED;

    if (Name != NULL)
    {
        USHORT NameLen = m_Cur->Name.Length;
        if (NameLen > MAX_UNLOADED_NAME_LENGTH)
        {
            NameLen = MAX_UNLOADED_NAME_LENGTH;
        }
        if (WideCharToMultiByte(CP_ACP, 0, m_Cur->DriverName,
                                NameLen / sizeof(WCHAR),
                                Name,
                                MAX_UNLOADED_NAME_LENGTH / sizeof(WCHAR) + 1,
                                NULL, NULL) == 0)
        {
            return WIN32_LAST_STATUS();
        }

        Name[NameLen / sizeof(WCHAR)] = 0;
    }

    m_Cur++;
    return S_OK;
}

KernelTriage64UnloadedModuleInfo g_KernelTriage64UnloadedModuleIterator;

//----------------------------------------------------------------------------
//
// Validation code.
//
//----------------------------------------------------------------------------

#if DBG

VOID
DumpPageMap (
    IN PRTL_BITMAP PageMap
    )
{
    PFN_NUMBER32 StartOfRun;
    BOOL Mapped;
    ULONG LineCount;
    ULONG i;

    printf ("VERBOSE:\nSummary Dump Page Map (not mapped pages): \n\n");

    LineCount = 0;
    StartOfRun = 0;
    Mapped = RtlCheckBit (PageMap, 0);

    for (i = 1; i < PageMap->SizeOfBitMap; i++) {

        if (RtlCheckBit (PageMap, i)) {
            printf ("%4.4x ", (SHORT) i);
            if (LineCount == 11) {
                printf ("\n");
                LineCount = 0;
            }
            LineCount++;
        }
    }

    printf ("\n\n");
}

#endif


// XXX drewb - Verification disabled until we decide what we want.
#ifdef VALIDATE_DUMPS


BOOL
DmppVerifyPagePresentInDumpFile(
    ULONG Page,
    ULONG Size
    )
{
    CHAR * Address;
    CHAR ch;
    BOOL ret = FALSE;


    __try {

        Address = DmppFileOffsetToMappedAddress (
            DmppPageToOffset( Page ), FALSE);

        if (!Address) {
            ret = FALSE;
            __leave;
        }

        ch = *Address;
        Address += Size - 1;
        ch = *Address;
        ret = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        ret = FALSE;
    }

    return ret;
}


BOOL
WINAPI
DmpValidateDumpFile(
    BOOL ThoroughCheck
    )

/*++

Routine Description:

    Validate that a dump file is valid. This will do the work of checking
    if the file is a user-mode or kernel-mode dump file and verifying
    that it is correct.

Arguments:

    ThoroughCheck - If TRUE, instructs DmpValidateDumpFile to do a thorough
        (significantly slower) check of the dump file. Otherwise a qicker,
        less complete check is done.

Return Values:

    TRUE - The dumpfile is valid.

    FALSE - The dumpfile is invalid. Extended error status is available using
            GetLastError.

--*/
{
    PPHYSICAL_MEMORY_DESCRIPTOR32 PhysicalMemoryBlock;
    BOOL ret = TRUE;


    if (IS_FULL_USER_DUMP()) {

        // ret = DmppUserModeTestHeader ();
        // if (ret == 1 && ThoroughCheck) {
        //     ret = DmppUserModeTestContents ();
        //  }

    } else {

        PhysicalMemoryBlock = &g_DumpHeaderKernel32->Header.PhysicalMemoryBlock;

        if (IS_SUMMARY_DUMP()) {

            //
            // The summary dump will have holes in the page table, so it's
            // useless to even check it.
            //
            ret = TRUE;
        } else {
            if (g_DumpAddressExtensions) {
                //
                // This function is broken.
                //

                return TRUE;

#if 0
                ULONG i;
                ULONG j;
                BOOL ret;
                X86PAE_HARDWARE_PDPTE * PageDirectoryPointerTableBase;
                X86PAE_HARDWARE_PDPTE * PageDirectoryPointerTableEntry;
                HARDWARE_PDE_X86PAE * PageDirectoryBase;
                HARDWARE_PDE_X86PAE * PageDirectoryEntry;
                HARDWARE_PTE_X86PAE * PageTableBase;

                //
                // On a PAE kernel DmpPdePage is actually a pointer to the
                // Page-Directory-Pointer-Table, not the Page-Directory.
                //

                //ASSERT ( DmpPdePage );

                PageDirectoryPointerTableBase = (X86PAE_HARDWARE_PDPTE *) DmpPdePage;

                //
                // Loop through the top-level Page-Directory-Dointer Table.
                //

                ret = TRUE;
                for (i = 0; i < 4; i++) {

                    PageDirectoryPointerTableEntry = &PageDirectoryPointerTableBase [ i ];
                    if (!PageDirectoryPointerTableEntry->Valid) {

                        //
                        // All Page-Directory-Pointer Table Entries must be present.
                        //

                        ret = FALSE;
                        break;
                    }

                    PageDirectoryBase = DmppFileOffsetToMappedAddress(
                          DmppPageToOffset(PageDirectoryPointerTableEntry->PageFrameNumber),
                          TRUE);

                    if (!PageDirectoryBase) {

                        //
                        // The specified page frame number did not map to a valid page.
                        //

                        ret = FALSE;
                        break;
                    }

                    //
                    // Loop through the Page-Directory Table.
                    //

                    for (j = 0; (j < 512) && (ret == TRUE) ; j++) {

                        PageDirectoryEntry = &PageDirectoryBase [ j ];

                        if (!PageDirectoryEntry->Valid) {

                            //
                            // The specific Page Table is not present. Not an error.
                            //

                            continue;
                        }

                        PageTableBase = DmppFileOffsetToMappedAddress(
                              DmppPageToOffset(PageDirectoryEntry->PageFrameNumber),
                              TRUE);

                        if (!PageTableBase) {

                            //
                            // The Page Table did not map to a valid address.
                            //

                            ret = FALSE;
                            break;
                        }
                    }
                }

#endif

            } else {
                // NOT implemented
                ret = TRUE;
            }

            //
            // Dump validation routine. This routine verifies that any
            // memory present in the MmPhysicalMemoryBlock was actually
            // written to the dump file.

            if (ret == 0 && ThoroughCheck) {

                PFN_NUMBER32 i;
                PFN_NUMBER32 j;
                PFN_NUMBER32 Page;

                for (i = 0; i < PhysicalMemoryBlock->NumberOfRuns; i++) {
                    for (j = 0; j < PhysicalMemoryBlock->Run [ i ].PageCount; j++) {

                        Page = PhysicalMemoryBlock->Run [ i ].BasePage + j;

                        if (!DmppVerifyPagePresentInDumpFile (Page, PageSize)) {
                            ret = FALSE;
                            break;
                        }
                    }
                }
            }
        }
    }

    return ret;
}

#endif // #ifdef VALIDATE_DUMPS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\dbgsym.cpp ===
//----------------------------------------------------------------------------
//
// IDebugSymbols implementation.
//
// Copyright (C) Microsoft Corporation, 1999-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

// Special type status value that maps to E_UNEXPECTED.
#define TYPE_E_UNEXPECTED 0xfefefefe

BOOL
GetModuleName(
    ULONG64 Base,
    PCHAR Name,
    ULONG SizeOfName
    );

//#define DBG_SYMGROUP_ENABLED 1 

HRESULT
ResultFromTypeStatus(ULONG Status)
{
    switch(Status)
    {
    case NO_ERROR:
        return S_OK;
        
    case MEMORY_READ_ERROR:
    case EXIT_ON_CONTROLC:
        return E_FAIL;
            
    case SYMBOL_TYPE_INDEX_NOT_FOUND:
    case SYMBOL_TYPE_INFO_NOT_FOUND:
        return E_NOINTERFACE;
        
    case FIELDS_DID_NOT_MATCH:
    case NULL_SYM_DUMP_PARAM:
    case NULL_FIELD_NAME:
    case INCORRECT_VERSION_INFO:
        return E_INVALIDARG;
        
    case CANNOT_ALLOCATE_MEMORY:
    case INSUFFICIENT_SPACE_TO_COPY:
        return E_OUTOFMEMORY;

    case TYPE_E_UNEXPECTED:
        return E_UNEXPECTED;
    }
    
    return E_FAIL;
}

STDMETHODIMP
DebugClient::GetSymbolOptions(
    THIS_
    OUT PULONG Options
    )
{
    ENTER_ENGINE();
    
    *Options = g_SymOptions;

    LEAVE_ENGINE();
    return S_OK;
}

#define ALL_SYMBOL_OPTIONS         \
    (SYMOPT_CASE_INSENSITIVE |     \
     SYMOPT_UNDNAME |              \
     SYMOPT_DEFERRED_LOADS |       \
     SYMOPT_NO_CPP |               \
     SYMOPT_LOAD_LINES |           \
     SYMOPT_OMAP_FIND_NEAREST |    \
     SYMOPT_LOAD_ANYTHING |        \
     SYMOPT_IGNORE_CVREC |         \
     SYMOPT_NO_UNQUALIFIED_LOADS | \
     SYMOPT_FAIL_CRITICAL_ERRORS | \
     SYMOPT_EXACT_SYMBOLS |        \
     SYMOPT_DEBUG)

STDMETHODIMP
DebugClient::AddSymbolOptions(
    THIS_
    IN ULONG Options
    )
{
    if (Options & ~ALL_SYMBOL_OPTIONS)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();
    
    SetSymOptions(g_SymOptions | Options);
    
    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::RemoveSymbolOptions(
    THIS_
    IN ULONG Options
    )
{
    if (Options & ~ALL_SYMBOL_OPTIONS)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();
    
    SetSymOptions(g_SymOptions & ~Options);

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::SetSymbolOptions(
    THIS_
    IN ULONG Options
    )
{
    if (Options & ~ALL_SYMBOL_OPTIONS)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();
    
    SetSymOptions(Options);
    
    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetNameByOffset(
    THIS_
    IN ULONG64 Offset,
    OUT OPTIONAL PSTR NameBuffer,
    IN ULONG NameBufferSize,
    OUT OPTIONAL PULONG NameSize,
    OUT OPTIONAL PULONG64 Displacement
    )
{
    HRESULT Status;

    ENTER_ENGINE();
    
    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        char Sym[MAX_SYMBOL_LEN];
    
        if (GetNearSymbol(Offset, Sym, sizeof(Sym), Displacement, 0))
        {
            Status = FillStringBuffer(Sym, 0, NameBuffer, NameBufferSize,
                                      NameSize);
        }
        else
        {
            Status = E_FAIL;
        }
    }
    
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetOffsetByName(
    THIS_
    IN PCSTR Symbol,
    OUT PULONG64 Offset
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    ULONG Count;
    
    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else if (Count = GetOffsetFromSym(Symbol, Offset, NULL))
    {
        Status = Count > 1 ? S_FALSE : S_OK;
    }
    else
    {
        Status = E_FAIL;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetNearNameByOffset(
    THIS_
    IN ULONG64 Offset,
    IN LONG Delta,
    OUT OPTIONAL PSTR NameBuffer,
    IN ULONG NameBufferSize,
    OUT OPTIONAL PULONG NameSize,
    OUT OPTIONAL PULONG64 Displacement
    )
{
    HRESULT Status;

    ENTER_ENGINE();
    
    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        char Sym[MAX_SYMBOL_LEN];
    
        if (GetNearSymbol(Offset, Sym, sizeof(Sym), Displacement, Delta))
        {
            Status = FillStringBuffer(Sym, 0, NameBuffer, NameBufferSize,
                                      NameSize);
        }
        else
        {
            Status = E_NOINTERFACE;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetLineByOffset(
    THIS_
    IN ULONG64 Offset,
    OUT OPTIONAL PULONG Line,
    OUT OPTIONAL PSTR FileBuffer,
    IN ULONG FileBufferSize,
    OUT OPTIONAL PULONG FileSize,
    OUT OPTIONAL PULONG64 Displacement
    )
{
    HRESULT Status;

    ENTER_ENGINE();
    
    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        IMAGEHLP_LINE64 DbgLine;
        ULONG Disp;

        DbgLine.SizeOfStruct = sizeof(DbgLine);
        if (SymGetLineFromAddr64(g_CurrentProcess->Handle, Offset,
                                 &Disp, &DbgLine))
        {
            if (Line != NULL)
            {
                *Line = DbgLine.LineNumber;
            }
            Status = FillStringBuffer(DbgLine.FileName, 0,
                                      FileBuffer, FileBufferSize, FileSize);
            if (Displacement != NULL)
            {
                *Displacement = Disp;
            }
        }
        else
        {
            Status = E_FAIL;
        }
    }
        
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetOffsetByLine(
    THIS_
    IN ULONG Line,
    IN PCSTR File,
    OUT PULONG64 Offset
    )
{
    HRESULT Status;

    ENTER_ENGINE();
    
    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        IMAGEHLP_LINE64 DbgLine;
        LONG Disp;

        DbgLine.SizeOfStruct = sizeof(DbgLine);
        if (SymGetLineFromName64(g_CurrentProcess->Handle, NULL, (PSTR)File,
                                 Line, &Disp, &DbgLine))
        {
            *Offset = DbgLine.Address;
            Status = S_OK;
        }
        else
        {
            Status = E_FAIL;
        }
    }

    LEAVE_ENGINE();
    return Status;
}
    
STDMETHODIMP
DebugClient::GetNumberModules(
    THIS_
    OUT PULONG Loaded,
    OUT PULONG Unloaded
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Loaded = g_CurrentProcess->NumberImages;
        *Unloaded = g_NumUnloadedModules;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

HRESULT
GetUnloadedModuleByIndex(ULONG Index, UnloadedModuleInfo** IterRet,
                         PSTR Name, PDEBUG_MODULE_PARAMETERS Params)
{
    HRESULT Status;
    UnloadedModuleInfo* Iter;

    if ((Iter = g_Target->GetUnloadedModuleInfo()) == NULL)
    {
        return E_FAIL;
    }

    if ((Status = Iter->Initialize()) != S_OK)
    {
        return Status;
    }

    do
    {
        if ((Status = Iter->GetEntry(Name, Params)) != S_OK)
        {
            if (Status == S_FALSE)
            {
                return E_INVALIDARG;
            }
            
            return Status;
        }
    } while (Index-- > 0);

    if (IterRet != NULL)
    {
        *IterRet = Iter;
    }
    return S_OK;
}
    
STDMETHODIMP
DebugClient::GetModuleByIndex(
    THIS_
    IN ULONG Index,
    OUT PULONG64 Base
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else if (Index >= g_CurrentProcess->NumberImages)
    {
        DEBUG_MODULE_PARAMETERS Params;
        
        if ((Status = GetUnloadedModuleByIndex
             (Index - g_CurrentProcess->NumberImages,
              NULL, NULL, &Params)) == S_OK)
        {
            *Base = Params.Base;
        }
    }
    else
    {
        *Base = GetImageByIndex(g_CurrentProcess, Index)->BaseOfImage;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetModuleByModuleName(
    THIS_
    IN PCSTR Name,
    IN ULONG StartIndex,
    OUT OPTIONAL PULONG Index,
    OUT OPTIONAL PULONG64 Base
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG Idx = 0;
        
        Status = E_NOINTERFACE;
        
        PDEBUG_IMAGE_INFO Image = g_CurrentProcess->ImageHead;
        while (Image != NULL)
        {
            if (StartIndex == 0 &&
                !_strcmpi(Name, Image->ModuleName))
            {
                if (Index != NULL)
                {
                    *Index = Idx;
                }
                if (Base != NULL)
                {
                    *Base = Image->BaseOfImage;
                }
                Status = S_OK;
                break;
            }

            Image = Image->Next;
            Idx++;
            if (StartIndex > 0)
            {
                StartIndex--;
            }
        }

        if (Image == NULL)
        {
            UnloadedModuleInfo* Iter;
            char UnlName[MAX_UNLOADED_NAME_LENGTH / sizeof(WCHAR) + 1];
            DEBUG_MODULE_PARAMETERS Params;
        
            Status = GetUnloadedModuleByIndex(StartIndex, &Iter, UnlName,
                                              &Params);
            for (;;)
            {
                if (Status == S_FALSE || Status == E_INVALIDARG)
                {
                    Status = E_NOINTERFACE;
                    break;
                }
                else if (Status != S_OK)
                {
                    break;
                }
                
                if (!_strcmpi(Name, UnlName))
                {
                    if (Index != NULL)
                    {
                        *Index = Idx;
                    }
                    if (Base != NULL)
                    {
                        *Base = Params.Base;
                    }
                    Status = S_OK;
                    break;
                }

                Status = Iter->GetEntry(UnlName, &Params);
                Idx++;
            }
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetModuleByOffset(
    THIS_
    IN ULONG64 Offset,
    IN ULONG StartIndex,
    OUT OPTIONAL PULONG Index,
    OUT OPTIONAL PULONG64 Base
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG Idx = 0;
        
        Status = E_NOINTERFACE;
        
        PDEBUG_IMAGE_INFO Image = g_CurrentProcess->ImageHead;
        while (Image != NULL)
        {
            if (StartIndex == 0 &&
                Offset >= Image->BaseOfImage &&
                Offset < Image->BaseOfImage + Image->SizeOfImage)
            {
                if (Index != NULL)
                {
                    *Index = Idx;
                }
                if (Base != NULL)
                {
                    *Base = Image->BaseOfImage;
                }
                Status = S_OK;
                break;
            }

            Image = Image->Next;
            Idx++;
            if (StartIndex > 0)
            {
                StartIndex--;
            }
        }
        
        if (Image == NULL)
        {
            UnloadedModuleInfo* Iter;
            DEBUG_MODULE_PARAMETERS Params;
        
            Status = GetUnloadedModuleByIndex(StartIndex, &Iter, NULL,
                                              &Params);
            for (;;)
            {
                if (Status == S_FALSE || Status == E_INVALIDARG)
                {
                    Status = E_NOINTERFACE;
                    break;
                }
                else if (Status != S_OK)
                {
                    break;
                }
                
                if (Offset >= Params.Base &&
                    Offset < Params.Base + Params.Size)
                {
                    if (Index != NULL)
                    {
                        *Index = Idx;
                    }
                    if (Base != NULL)
                    {
                        *Base = Params.Base;
                    }
                    Status = S_OK;
                    break;
                }

                Status = Iter->GetEntry(NULL, &Params);
                Idx++;
            }
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetModuleNames(
    THIS_
    IN ULONG Index,
    IN ULONG64 Base,
    OUT OPTIONAL PSTR ImageNameBuffer,
    IN ULONG ImageNameBufferSize,
    OUT OPTIONAL PULONG ImageNameSize,
    OUT OPTIONAL PSTR ModuleNameBuffer,
    IN ULONG ModuleNameBufferSize,
    OUT OPTIONAL PULONG ModuleNameSize,
    OUT OPTIONAL PSTR LoadedImageNameBuffer,
    IN ULONG LoadedImageNameBufferSize,
    OUT OPTIONAL PULONG LoadedImageNameSize
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG Idx = 0;
        
        Status = E_NOINTERFACE;
        
        PDEBUG_IMAGE_INFO Image = g_CurrentProcess->ImageHead;
        while (Image != NULL)
        {
            if ((Index != DEBUG_ANY_ID && Idx == Index) ||
                (Index == DEBUG_ANY_ID && Base == Image->BaseOfImage))
            {
                IMAGEHLP_MODULE64 ModInfo;
    
                ModInfo.SizeOfStruct = sizeof(ModInfo);
                if (!SymGetModuleInfo64(g_CurrentProcess->Handle,
                                        Image->BaseOfImage, &ModInfo))
                {
                    Status = WIN32_LAST_STATUS();
                    break;
                }
                
                Status = FillStringBuffer(Image->ImagePath, 0,
                                          ImageNameBuffer,
                                          ImageNameBufferSize,
                                          ImageNameSize);
                if (FillStringBuffer(Image->ModuleName, 0,
                                     ModuleNameBuffer,
                                     ModuleNameBufferSize,
                                     ModuleNameSize) == S_FALSE)
                {
                    Status = S_FALSE;
                }
                if (FillStringBuffer(ModInfo.LoadedImageName, 0,
                                     LoadedImageNameBuffer,
                                     LoadedImageNameBufferSize,
                                     LoadedImageNameSize) == S_FALSE)
                {
                    Status = S_FALSE;
                }
                break;
            }

            Image = Image->Next;
            Idx++;
        }
        
        if (Image == NULL)
        {
            UnloadedModuleInfo* Iter;
            char UnlName[MAX_UNLOADED_NAME_LENGTH / sizeof(WCHAR) + 1];
            DEBUG_MODULE_PARAMETERS Params;
            ULONG StartIndex = 0;

            if (Index != DEBUG_ANY_ID)
            {
                // If the index was already hit we
                // shouldn't be here.
                DBG_ASSERT(Index >= Idx);
                StartIndex = Index - Idx;
            }
            
            Status = GetUnloadedModuleByIndex(StartIndex, &Iter, UnlName,
                                              &Params);
            Idx += StartIndex;
            for (;;)
            {
                if (Status == S_FALSE || Status == E_INVALIDARG)
                {
                    Status = E_NOINTERFACE;
                    break;
                }
                else if (Status != S_OK)
                {
                    break;
                }
                
                if ((Index != DEBUG_ANY_ID && Idx == Index) ||
                    (Index == DEBUG_ANY_ID && Base == Params.Base))
                {
                    Status = FillStringBuffer(UnlName, 0,
                                              ImageNameBuffer,
                                              ImageNameBufferSize,
                                              ImageNameSize);
                    FillStringBuffer(NULL, 0,
                                     ModuleNameBuffer,
                                     ModuleNameBufferSize,
                                     ModuleNameSize);
                    FillStringBuffer(NULL, 0,
                                     LoadedImageNameBuffer,
                                     LoadedImageNameBufferSize,
                                     LoadedImageNameSize);
                    break;
                }

                Status = Iter->GetEntry(UnlName, &Params);
                Idx++;
            }
        }
    }

    LEAVE_ENGINE();
    return Status;
}

void
FillModuleParameters(PDEBUG_IMAGE_INFO Image, PDEBUG_MODULE_PARAMETERS Params)
{
    Params->Base = Image->BaseOfImage;
    Params->Size = Image->SizeOfImage;
    Params->TimeDateStamp = Image->TimeDateStamp;
    Params->Checksum = Image->CheckSum;
    Params->Flags = 0;
    Params->SymbolType = DEBUG_SYMTYPE_DEFERRED;
    Params->ImageNameSize = strlen(Image->ImagePath) + 1;
    Params->ModuleNameSize = strlen(Image->ModuleName) + 1;
    Params->LoadedImageNameSize = 0;
    ZeroMemory(Params->Reserved, sizeof(Params->Reserved));

    IMAGEHLP_MODULE64 ModInfo;
    
    ModInfo.SizeOfStruct = sizeof(ModInfo);
    if (SymGetModuleInfo64(g_CurrentProcess->Handle,
                           Image->BaseOfImage, &ModInfo))
    {
        // DEBUG_SYMTYPE_* values match imagehlp's SYM_TYPE.
        // Assert some key equivalences.
        C_ASSERT(DEBUG_SYMTYPE_PDB == SymPdb &&
                 DEBUG_SYMTYPE_EXPORT == SymExport &&
                 DEBUG_SYMTYPE_DEFERRED == SymDeferred &&
                 DEBUG_SYMTYPE_DIA == SymDia);
        
        Params->SymbolType = (ULONG)ModInfo.SymType;
        Params->LoadedImageNameSize = strlen(ModInfo.LoadedImageName) + 1;
    }
    
    DBH_MODSYMINFO SymFile;

    SymFile.function = dbhModSymInfo;
    SymFile.sizeofstruct = sizeof(SymFile);
    SymFile.addr = Image->BaseOfImage;
    if (dbghelp(g_CurrentProcess->Handle, &SymFile))
    {
        Params->SymbolFileNameSize = strlen(SymFile.file) + 1;
    }

    Params->MappedImageNameSize = strlen(Image->MappedImagePath) + 1;
}

STDMETHODIMP
DebugClient::GetModuleParameters(
    THIS_
    IN ULONG Count,
    IN OPTIONAL /* size_is(Count) */ PULONG64 Bases,
    IN ULONG Start,
    OUT /* size_is(Count) */ PDEBUG_MODULE_PARAMETERS Params
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    UnloadedModuleInfo* Iter;
    
    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else if (Bases != NULL)
    {
        Status = S_OK;
        while (Count-- > 0)
        {
            PDEBUG_IMAGE_INFO Image = g_CurrentProcess->ImageHead;
            while (Image != NULL)
            {
                if (*Bases == Image->BaseOfImage)
                {
                    FillModuleParameters(Image, Params);
                    break;
                }

                Image = Image->Next;
            }

            if (Image == NULL)
            {
                Status = E_NOINTERFACE;
                
                Iter = g_Target->GetUnloadedModuleInfo();
                if (Iter != NULL &&
                    Iter->Initialize() == S_OK)
                {
                    while (Iter->GetEntry(NULL, Params) == S_OK)
                    {
                        if (*Bases == Params->Base)
                        {
                            Status = S_OK;
                            break;
                        }
                    }
                }

                if (Status != S_OK)
                {
                    ZeroMemory(Params, sizeof(*Params));
                    Params->Base = DEBUG_INVALID_OFFSET;
                }
            }

            Bases++;
            Params++;
        }
    }
    else
    {
        ULONG i, End;
        HRESULT SingleStatus;
        
        Status = S_OK;
        i = Start;
        End = Start + Count;

        if (i < g_CurrentProcess->NumberImages)
        {
            PDEBUG_IMAGE_INFO Image = GetImageByIndex(g_CurrentProcess, i);
            while (i < g_CurrentProcess->NumberImages && i < End)
            {
                FillModuleParameters(Image, Params);
                Image = Image->Next;
                Params++;
                i++;
            }
        }

        if (i < End)
        {
            DEBUG_MODULE_PARAMETERS Param;
            
            SingleStatus = GetUnloadedModuleByIndex
                (i - g_CurrentProcess->NumberImages,
                 &Iter, NULL, &Param);
            if (SingleStatus != S_OK)
            {
                Iter = NULL;
            }
            while (i < End)
            {
                if (SingleStatus != S_OK)
                {
                    ZeroMemory(Params, sizeof(*Params));
                    Params->Base = DEBUG_INVALID_OFFSET;
                    Status = SingleStatus;
                }
                else
                {
                    *Params = Param;
                }
                Params++;

                if (Iter != NULL)
                {
                    SingleStatus = Iter->GetEntry(NULL, &Param);
                    if (SingleStatus == S_FALSE)
                    {
                        SingleStatus = E_INVALIDARG;
                    }
                }
                    
                i++;
            }
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetSymbolModule(
    THIS_
    IN PCSTR Symbol,
    OUT PULONG64 Base
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        PCSTR ModEnd;
        ULONG Len;

        ModEnd = strchr(Symbol, '!');
        if (ModEnd == NULL)
        {
            Status = E_INVALIDARG;
        }
        else if (*(ModEnd+1) != '\0')
        {
            SYM_DUMP_PARAM_EX Param =
            {
                sizeof(Param), (PUCHAR)Symbol, DBG_DUMP_NO_PRINT, 0,
                NULL, NULL, NULL, 0, NULL
            };
            ULONG TypeStatus;
            TYPES_INFO TypeInfo;

            ZeroMemory(&TypeInfo, sizeof(TypeInfo));
            TypeStatus = TypeInfoFound(g_CurrentProcess->Handle,
                                       g_CurrentProcess->ImageHead,
                                       &Param, &TypeInfo);
            if (TypeStatus == NO_ERROR)
            {
                *Base = TypeInfo.ModBaseAddress;
            }
            Status = ResultFromTypeStatus(TypeStatus);
        }
        else
        {
            PDEBUG_IMAGE_INFO Image;

            Status = E_NOINTERFACE;
            Len = (ULONG)(ModEnd - Symbol);
            for (Image = g_CurrentProcess->ImageHead;
                 Image != NULL;
                 Image = Image->Next)
            {
                if (strlen(Image->ModuleName) == Len &&
                    !_memicmp(Symbol, Image->ModuleName, Len))
                {
                    *Base = Image->BaseOfImage;
                    Status = S_OK;
                    break;
                }
            }
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetTypeName(
    THIS_
    IN ULONG64 Module,
    IN ULONG TypeId,
    OUT OPTIONAL PSTR NameBuffer,
    IN ULONG NameBufferSize,
    OUT OPTIONAL PULONG NameSize
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        TYPES_INFO TypeInfo;
        ANSI_STRING TypeName;
        char TypeString[MAX_NAME];

        ZeroMemory(&TypeInfo, sizeof(TypeInfo));
        TypeInfo.TypeIndex = TypeId;
        TypeInfo.hProcess = g_CurrentProcess->Handle;
        TypeInfo.ModBaseAddress = Module;
        TypeName.Buffer = TypeString;
        TypeName.Length = sizeof(TypeString);
        TypeName.MaximumLength = sizeof(TypeString);

        Status = ::GetTypeName(NULL, &TypeInfo, &TypeName);
        if (Status == S_OK)
        {
            Status = FillStringBuffer(TypeName.Buffer, TypeName.Length,
                                      NameBuffer, NameBufferSize, NameSize);
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetConstantName(
    THIS_
    IN ULONG64 Module,
    IN ULONG TypeId,
    IN ULONG64 Value,
    OUT OPTIONAL PSTR NameBuffer,
    IN ULONG NameBufferSize,
    OUT OPTIONAL PULONG NameSize
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        TYPES_INFO TypeInfo;
        ANSI_STRING TypeName;
        char TypeString[MAX_NAME];

        ZeroMemory(&TypeInfo, sizeof(TypeInfo));
        TypeInfo.TypeIndex = TypeId;
        TypeInfo.hProcess = g_CurrentProcess->Handle;
        TypeInfo.ModBaseAddress = Module;
        TypeInfo.Flag = IMAGEHLP_SYMBOL_INFO_VALUEPRESENT;
        TypeInfo.Value = Value;
        TypeName.Buffer = TypeString;
        TypeName.Length = sizeof(TypeString);
        TypeName.MaximumLength = sizeof(TypeString);

        Status = ::GetTypeName(NULL, &TypeInfo, &TypeName);
        if (Status == S_OK)
        {
            Status = FillStringBuffer(TypeName.Buffer, TypeName.Length,
                                      NameBuffer, NameBufferSize, NameSize);
        }
    }

    LEAVE_ENGINE();
    return Status;
}

typedef struct _COPY_FIELD_NAME_CONTEXT {
    ULONG Called;
    ULONG IndexToMatch;
    PSTR NameBuffer;
    ULONG NameBufferSize;
    PULONG NameSize;
    HRESULT Status;
} COPY_FIELD_NAME_CONTEXT;

ULONG
CopyFieldName(
    PFIELD_INFO_EX pField,
    PVOID          Context
    )
{
    COPY_FIELD_NAME_CONTEXT* pInfo = (COPY_FIELD_NAME_CONTEXT *) Context;

    if (pInfo->Called++ == pInfo->IndexToMatch) 
    {
        pInfo->Status = FillStringBuffer((PSTR) pField->fName, strlen((PCHAR) pField->fName)+1,
                                         pInfo->NameBuffer, pInfo->NameBufferSize, pInfo->NameSize);
        return FALSE;
    }
    return TRUE;
}

STDMETHODIMP
DebugClient::GetFieldName(
    THIS_
    IN ULONG64 Module,
    IN ULONG TypeId,
    IN ULONG FieldIndex,
    OUT OPTIONAL PSTR NameBuffer,
    IN ULONG NameBufferSize,
    OUT OPTIONAL PULONG NameSize
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG TypeStatus;
        COPY_FIELD_NAME_CONTEXT FieldInfo =
        {
            0, FieldIndex, NameBuffer, NameBufferSize,
            NameSize, E_INVALIDARG
        };
        SYM_DUMP_PARAM_EX Param =
        {
            sizeof(Param), NULL, DBG_DUMP_NO_PRINT | DBG_DUMP_CALL_FOR_EACH, 0,
            NULL, &FieldInfo, &CopyFieldName, 0, NULL
        };
        TYPES_INFO TypeInfo;

        ZeroMemory(&TypeInfo, sizeof(TypeInfo));
        TypeInfo.hProcess = g_CurrentProcess->Handle;
        TypeInfo.ModBaseAddress = Module;
        TypeInfo.TypeIndex = TypeId;
        DumpType(&TypeInfo, &Param, &TypeStatus);
        if (TypeStatus == NO_ERROR)
        {
            Status = FieldInfo.Status;
        } else 
        {
            Status = ResultFromTypeStatus(TypeStatus);
        }
    }

    LEAVE_ENGINE();
    return Status;
}

#define ALL_TYPE_OPTIONS DEBUG_TYPEOPTS_UNICODE_DISPLAY

STDMETHODIMP
DebugClient::GetTypeOptions(
    THIS_
    OUT PULONG Options
    )
{
    ENTER_ENGINE();

    *Options = 0;
        
    *Options |= g_EnableUnicode ? DEBUG_TYPEOPTS_UNICODE_DISPLAY : 0; 

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::SetTypeOptions(
    THIS_
    IN ULONG Options
    )
{
    if (Options & ~ALL_TYPE_OPTIONS)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    g_EnableUnicode = Options & DEBUG_TYPEOPTS_UNICODE_DISPLAY;
    g_TypeOptions   = Options;

    NotifyChangeSymbolState(DEBUG_CSS_TYPE_OPTIONS, 0, NULL);

    LEAVE_ENGINE();
    return S_OK;

}

STDMETHODIMP
DebugClient::AddTypeOptions(
    THIS_
    IN ULONG Options
    )
{
    if (Options & ~ALL_TYPE_OPTIONS)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    if (Options & DEBUG_TYPEOPTS_UNICODE_DISPLAY) 
    {
        g_EnableUnicode = TRUE;
        NotifyChangeSymbolState(DEBUG_CSS_TYPE_OPTIONS, 0, NULL);
    }
    g_TypeOptions |= Options;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::RemoveTypeOptions(
    THIS_
    IN ULONG Options
    )
{
    if (Options & ~ALL_TYPE_OPTIONS)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    if (Options & DEBUG_TYPEOPTS_UNICODE_DISPLAY) 
    {
        g_EnableUnicode = FALSE;
        NotifyChangeSymbolState(DEBUG_CSS_TYPE_OPTIONS, 0, NULL);
    }
    g_TypeOptions &= ~Options;

    LEAVE_ENGINE();
    return S_OK;

}

STDMETHODIMP
DebugClient::GetTypeId(
    THIS_
    IN ULONG64 Module,
    IN PCSTR Name,
    OUT PULONG TypeId
    )
{
    ULONG TypeStatus;
    
    ENTER_ENGINE();
    
    if (!IS_MACHINE_ACCESSIBLE())
    {
        TypeStatus = TYPE_E_UNEXPECTED;
    }
    else
    {
        SYM_DUMP_PARAM_EX Param =
        {
            sizeof(Param), (PUCHAR)Name, DBG_DUMP_NO_PRINT, 0,
            NULL, NULL, NULL, 0, NULL
        };
        TYPES_INFO TypeInfo;
        PCHAR QualName;

        TypeStatus = CANNOT_ALLOCATE_MEMORY;
        QualName = (PCHAR) malloc(strlen(Name) + 30);
        if (QualName) 
        {
            PCSTR ModEnd;

            if (!strchr(Name, '!')) 
            {
                if (GetModuleName(Module, QualName, 30))
                {
                    strcat(QualName, "!");
                }
            } else // Already qualified name 
            {
                *QualName = 0;
            }
            strcat(QualName, Name);
            
            TypeStatus = SYMBOL_TYPE_INFO_NOT_FOUND;
            Param.sName = (PUCHAR) QualName;
            ZeroMemory(&TypeInfo, sizeof(TypeInfo));
            TypeStatus = TypeInfoFound(g_CurrentProcess->Handle,
                                       g_CurrentProcess->ImageHead,
                                       &Param, &TypeInfo);
            if (TypeStatus == NO_ERROR)
            {
                *TypeId = TypeInfo.TypeIndex;
            }
        }
    }

    LEAVE_ENGINE();
    return ResultFromTypeStatus(TypeStatus);
}

STDMETHODIMP
DebugClient::GetTypeSize(
    THIS_
    IN ULONG64 Module,
    IN ULONG TypeId,
    OUT PULONG Size
    )
{
    ULONG TypeStatus;

    ENTER_ENGINE();
    
    if (!IS_MACHINE_ACCESSIBLE())
    {
        TypeStatus = TYPE_E_UNEXPECTED;
    }
    else
    {
        SYM_DUMP_PARAM_EX Param =
        {
            sizeof(Param), NULL,
            DBG_DUMP_NO_PRINT | DBG_DUMP_GET_SIZE_ONLY, 0,
            NULL, NULL, NULL, 0, NULL
        };
        TYPES_INFO TypeInfo;

        ZeroMemory(&TypeInfo, sizeof(TypeInfo));
        TypeInfo.hProcess = g_CurrentProcess->Handle;
        TypeInfo.ModBaseAddress = Module;
        TypeInfo.TypeIndex = TypeId;
        *Size = DumpType(&TypeInfo, &Param, &TypeStatus);
    }

    LEAVE_ENGINE();
    return ResultFromTypeStatus(TypeStatus);
}

STDMETHODIMP
DebugClient::GetFieldOffset(
    THIS_
    IN ULONG64 Module,
    IN ULONG TypeId,
    IN PCSTR Field,
    OUT PULONG Offset
    )
{
    ULONG TypeStatus;

    ENTER_ENGINE();

    if (!IS_MACHINE_ACCESSIBLE())
    {
        TypeStatus = TYPE_E_UNEXPECTED;
    }
    else
    {
        FIELD_INFO_EX FieldInfo =
        {
            (PUCHAR)Field, NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL
        };
        SYM_DUMP_PARAM_EX Param =
        {
            sizeof(Param), NULL, DBG_DUMP_NO_PRINT, 0,
            NULL, NULL, NULL, 1, &FieldInfo
        };
        TYPES_INFO TypeInfo;

        ZeroMemory(&TypeInfo, sizeof(TypeInfo));
        TypeInfo.hProcess = g_CurrentProcess->Handle;
        TypeInfo.ModBaseAddress = Module;
        TypeInfo.TypeIndex = TypeId;
        DumpType(&TypeInfo, &Param, &TypeStatus);
        if (TypeStatus == NO_ERROR)
        {
            *Offset = (ULONG)FieldInfo.address;
        }
    }

    LEAVE_ENGINE();
    return ResultFromTypeStatus(TypeStatus);
}

STDMETHODIMP
DebugClient::GetSymbolTypeId(
    THIS_
    IN PCSTR Symbol,
    OUT PULONG TypeId,
    OUT OPTIONAL PULONG64 Module
    )
{
    ULONG TypeStatus;

    ENTER_ENGINE();
    
    if (!IS_MACHINE_ACCESSIBLE())
    {
        TypeStatus = TYPE_E_UNEXPECTED;
    }
    else
    {
        TYPES_INFO_ALL TypeInfo;

        ZeroMemory(&TypeInfo, sizeof(TypeInfo));
        TypeStatus = !GetExpressionTypeInfo((PCHAR) Symbol, &TypeInfo);
        if (TypeStatus == NO_ERROR)
        {
            *TypeId = TypeInfo.TypeIndex;
            
            if (Module != NULL)
            {
                *Module = TypeInfo.Module;
            }
        }
    }

    LEAVE_ENGINE();
    return ResultFromTypeStatus(TypeStatus);
}

STDMETHODIMP
DebugClient::GetOffsetTypeId(
    THIS_
    IN ULONG64 Offset,
    OUT PULONG TypeId,
    OUT OPTIONAL PULONG64 Module
    )
{
    HRESULT Status;

    ENTER_ENGINE();
    
    char Sym[MAX_SYMBOL_LEN];

    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else if (!GetNearSymbol(Offset, Sym, sizeof(Sym), NULL, 0))
    {
        Status = E_FAIL;
    }
    else
    {
        Status = GetSymbolTypeId(Sym, TypeId, Module);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ReadTypedDataVirtual(
    THIS_
    IN ULONG64 Offset,
    IN ULONG64 Module,
    IN ULONG TypeId,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesRead
    )
{
    HRESULT Status;
    ULONG Size;

    if ((Status = GetTypeSize(Module, TypeId, &Size)) != S_OK)
    {
        return Status;
    }
    if (Size < BufferSize)
    {
        BufferSize = Size;
    }
    if ((Status = ReadVirtual(Offset, Buffer, BufferSize,
                              BytesRead)) != S_OK)
    {
        return Status;
    }
    return Size > BufferSize ? S_FALSE : S_OK;
}

STDMETHODIMP
DebugClient::WriteTypedDataVirtual(
    THIS_
    IN ULONG64 Offset,
    IN ULONG64 Module,
    IN ULONG TypeId,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesWritten
    )
{
    HRESULT Status;
    ULONG Size;

    if ((Status = GetTypeSize(Module, TypeId, &Size)) != S_OK)
    {
        return Status;
    }
    if (Size < BufferSize)
    {
        BufferSize = Size;
    }
    if ((Status = WriteVirtual(Offset, Buffer, BufferSize,
                               BytesWritten)) != S_OK)
    {
        return Status;
    }
    return Size > BufferSize ? S_FALSE : S_OK;
}

#define ALL_OUTPUT_TYPE_FLAGS              \
    (DEBUG_OUTTYPE_NO_INDENT             | \
     DEBUG_OUTTYPE_NO_OFFSET             | \
     DEBUG_OUTTYPE_VERBOSE               | \
     DEBUG_OUTTYPE_COMPACT_OUTPUT        | \
     DEBUG_OUTTYPE_RECURSION_LEVEL(0xf)  | \
     DEBUG_OUTTYPE_ADDRESS_OF_FIELD      | \
     DEBUG_OUTTYPE_ADDRESS_AT_END        | \
     DEBUG_OUTTYPE_BLOCK_RECURSE )


ULONG
OutputTypeFlagsToDumpOptions(ULONG Flags)
{
    ULONG Options = 0;

    if (Flags & DEBUG_OUTTYPE_NO_INDENT)
    {
        Options |= DBG_DUMP_NO_INDENT;
    }
    if (Flags & DEBUG_OUTTYPE_NO_OFFSET)
    {
        Options |= DBG_DUMP_NO_OFFSET;
    }
    if (Flags & DEBUG_OUTTYPE_VERBOSE)
    {
        Options |= DBG_DUMP_VERBOSE;
    }
    if (Flags & DEBUG_OUTTYPE_COMPACT_OUTPUT)
    {
        Options |= DBG_DUMP_COMPACT_OUT;
    }
    if (Flags & DEBUG_OUTTYPE_ADDRESS_AT_END) 
    {
        Options |= DBG_DUMP_ADDRESS_AT_END;
    }
    if (Flags & DEBUG_OUTTYPE_ADDRESS_OF_FIELD) 
    {
        Options |= DBG_DUMP_ADDRESS_OF_FIELD;
    }
    if (Flags & DEBUG_OUTTYPE_BLOCK_RECURSE) 
    {
        Options |= DBG_DUMP_BLOCK_RECURSE;
    }

    Options |= DBG_DUMP_RECUR_LEVEL(((Flags >> 4) & 0xf));

    return Options;
}

STDMETHODIMP
DebugClient::OutputTypedDataVirtual(
    THIS_
    IN ULONG OutputControl,
    IN ULONG64 Offset,
    IN ULONG64 Module,
    IN ULONG TypeId,
    IN ULONG Flags
    )
{
    if (Flags & ~ALL_OUTPUT_TYPE_FLAGS)
    {
        return E_INVALIDARG;
    }
    
    HRESULT Status;

    ENTER_ENGINE();

    OutCtlSave OldCtl;

    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else if (!PushOutCtl(OutputControl, this, &OldCtl))
    {
        Status = E_INVALIDARG;
    }
    else
    {
        SYM_DUMP_PARAM_EX Param =
        {
            sizeof(Param), NULL, OutputTypeFlagsToDumpOptions(Flags), Offset,
            NULL, NULL, NULL, 0, NULL
        };
        ULONG TypeStatus;
        TYPES_INFO TypeInfo;

        ZeroMemory(&TypeInfo, sizeof(TypeInfo));
        TypeInfo.hProcess = g_CurrentProcess->Handle;
        TypeInfo.ModBaseAddress = Module;
        TypeInfo.TypeIndex = TypeId;
        DumpType(&TypeInfo, &Param, &TypeStatus);
        Status = ResultFromTypeStatus(TypeStatus);
        
        PopOutCtl(&OldCtl);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ReadTypedDataPhysical(
    THIS_
    IN ULONG64 Offset,
    IN ULONG64 Module,
    IN ULONG TypeId,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesRead
    )
{
    HRESULT Status;
    ULONG Size;

    if ((Status = GetTypeSize(Module, TypeId, &Size)) != S_OK)
    {
        return Status;
    }
    if (Size < BufferSize)
    {
        BufferSize = Size;
    }
    if ((Status = ReadPhysical(Offset, Buffer, BufferSize,
                               BytesRead)) != S_OK)
    {
        return Status;
    }
    return Size > BufferSize ? S_FALSE : S_OK;
}

STDMETHODIMP
DebugClient::WriteTypedDataPhysical(
    THIS_
    IN ULONG64 Offset,
    IN ULONG64 Module,
    IN ULONG TypeId,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesWritten
    )
{
    HRESULT Status;
    ULONG Size;

    if ((Status = GetTypeSize(Module, TypeId, &Size)) != S_OK)
    {
        return Status;
    }
    if (Size < BufferSize)
    {
        BufferSize = Size;
    }
    if ((Status = WritePhysical(Offset, Buffer, BufferSize,
                                BytesWritten)) != S_OK)
    {
        return Status;
    }
    return Size > BufferSize ? S_FALSE : S_OK;
}

STDMETHODIMP
DebugClient::OutputTypedDataPhysical(
    THIS_
    IN ULONG OutputControl,
    IN ULONG64 Offset,
    IN ULONG64 Module,
    IN ULONG TypeId,
    IN ULONG Flags
    )
{
    if (Flags & ~ALL_OUTPUT_TYPE_FLAGS)
    {
        return E_INVALIDARG;
    }
    
    HRESULT Status;

    ENTER_ENGINE();

    OutCtlSave OldCtl;

    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else if (!PushOutCtl(OutputControl, this, &OldCtl))
    {
        Status = E_INVALIDARG;
    }
    else
    {
        SYM_DUMP_PARAM_EX Param =
        {
            sizeof(Param), NULL, OutputTypeFlagsToDumpOptions(Flags) |
            DBG_DUMP_READ_PHYSICAL, Offset, NULL, NULL, NULL, 0, NULL
        };
        ULONG TypeStatus;
        TYPES_INFO TypeInfo;

        ZeroMemory(&TypeInfo, sizeof(TypeInfo));
        TypeInfo.hProcess = g_CurrentProcess->Handle;
        TypeInfo.ModBaseAddress = Module;
        TypeInfo.TypeIndex = TypeId;
        DumpType(&TypeInfo, &Param, &TypeStatus);
        Status = ResultFromTypeStatus(TypeStatus);
        
        PopOutCtl(&OldCtl);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetScope(
    THIS_
    OUT OPTIONAL PULONG64 InstructionOffset,
    OUT OPTIONAL PDEBUG_STACK_FRAME ScopeFrame,
    OUT OPTIONAL PVOID ScopeContext,
    IN ULONG ScopeContextSize
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();
    
    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    Status = S_OK;

    PDEBUG_SCOPE Scope;

    Scope = GetCurrentScope();

    if (InstructionOffset) 
    {
        *InstructionOffset = Scope->Frame.InstructionOffset;
    }

    if (ScopeFrame) 
    {
        *ScopeFrame = Scope->Frame;
    }

    if (ScopeContext) 
    {
        if (Scope->State == ScopeFromContext)
        {
            memcpy(ScopeContext, &Scope->Context, 
                   min(sizeof(Scope->Context), ScopeContextSize));
        }
        else if (g_Machine->GetContextState(MCTX_FULL) == S_OK)
        {
            memcpy(ScopeContext, &g_Machine->m_Context,
                   min(sizeof(g_Machine->m_Context), ScopeContextSize));
        }
    }

 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetScope(
    THIS_
    IN ULONG64 InstructionOffset,
    IN OPTIONAL PDEBUG_STACK_FRAME ScopeFrame,
    IN OPTIONAL PVOID ScopeContext,
    IN ULONG ScopeContextSize
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        DEBUG_STACK_FRAME LocalFrame;

        if (ScopeFrame)
        {
            LocalFrame = *ScopeFrame;
        }
        else
        {
            ZeroMemory(&LocalFrame, sizeof(LocalFrame));
            LocalFrame.InstructionOffset = InstructionOffset;
        }

        Status = SetCurrentScope(&LocalFrame, ScopeContext, ScopeContextSize) ?
            S_FALSE : S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ResetScope(
    THIS
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();
    
    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ResetCurrentScope();
        Status = S_OK;
    }
    
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetScopeSymbolGroup(
    THIS_
    IN ULONG Flags,
    IN OPTIONAL PDEBUG_SYMBOL_GROUP Update,
    OUT PDEBUG_SYMBOL_GROUP* Symbols
    )
{
    HRESULT Status;

    if (Flags == 0 ||
        (Flags & ~DEBUG_SCOPE_GROUP_ALL))
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();
    
    if (Update)
    {
        ULONG Dummy;
        
        if ((Status = Update->AddSymbol("*+", &Dummy)) == S_OK) 
        {
            PDEBUG_SCOPE Scope;
             
            if (IS_MACHINE_ACCESSIBLE())
            {
                Scope = GetCurrentScope();
                Scope->LocalsChanged = FALSE;
            }
            *Symbols = Update;
        }
    }
    else 
    {
        *Symbols = new DebugSymbolGroup(this, Flags);
        if (*Symbols != NULL)
        {
            Status = S_OK;
        }
        else
        {
            Status = E_OUTOFMEMORY;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::CreateSymbolGroup(
    THIS_
    OUT PDEBUG_SYMBOL_GROUP* Group
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();
    
    *Group = new DebugSymbolGroup(this);
    if (*Group == NULL)
    {
        Status = E_OUTOFMEMORY;
    }
    else
    {
        Status = S_OK;
    }
    
    LEAVE_ENGINE();
    return Status;
}

struct SymbolMatch
{
    PPROCESS_INFO Process;
    BOOL SingleMod;
    PDEBUG_IMAGE_INFO Mod;
    PCHAR Storage, StorageEnd;
    PCHAR Cur, End;
    char Pattern[1];
};

STDMETHODIMP
DebugClient::StartSymbolMatch(
    THIS_
    IN PCSTR Pattern,
    OUT PULONG64 Handle
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
        goto EH_Exit;
    }
    
    char Module[MAX_MODULE];
    PDEBUG_IMAGE_INFO Mod;
    PCSTR Sym;
    
    // Check for a module qualifier.
    Sym = strchr(Pattern, '!');
    if (Sym != NULL)
    {
        size_t ModLen = Sym - Pattern;
        
        DBG_ASSERT(ModLen < sizeof(Module));

        if (ModLen == 0)
        {
            Status = E_INVALIDARG;
            goto EH_Exit;
        }
        
        memcpy(Module, Pattern, ModLen);
        Module[ModLen] = 0;

        Mod = GetImageByName(g_CurrentProcess, Module, INAME_MODULE);
        if (Mod == NULL)
        {
            Status = E_NOINTERFACE;
            goto EH_Exit;
        }

        Sym++;
    }
    else
    {
        Sym = Pattern;
        Mod = NULL;
    }

    ULONG SymLen;
    SymLen = strlen(Sym);
    SymbolMatch* Match;
    Match = (SymbolMatch*)malloc(sizeof(SymbolMatch) + SymLen);
    if (Match == NULL)
    {
        Status = E_OUTOFMEMORY;
        goto EH_Exit;
    }

    if (Mod == NULL)
    {
        Match->Process = g_CurrentProcess;
        Match->Mod = Match->Process->ImageHead;
        Match->SingleMod = FALSE;
    }
    else
    {
        Match->Process = g_CurrentProcess;
        Match->Mod = Mod;
        Match->SingleMod = TRUE;
    }

    Match->Storage = NULL;
    Match->StorageEnd = NULL;
    Match->Cur = NULL;
    strcpy(Match->Pattern, Sym);
    _strupr(Match->Pattern);

    *Handle = (ULONG64)Match;
    
 EH_Exit:
    LEAVE_ENGINE();
    return Status;
}

#define STORAGE_INC 16384

BOOL CALLBACK
FillMatchStorageCb(PSTR Name, ULONG64 Offset, ULONG Size, PVOID Context)
{
    SymbolMatch* Match = (SymbolMatch*)Context;
    ULONG NameLen = strlen(Name) + 1;
    ULONG RecordLen = NameLen + sizeof(ULONG64);

    if (Match->Cur + RecordLen > Match->StorageEnd)
    {
        PCHAR NewStore;
        size_t NewLen;

        NewLen = (Match->StorageEnd - Match->Storage) + STORAGE_INC;
        NewStore = (PCHAR)realloc(Match->Storage, NewLen);
        if (NewStore == NULL)
        {
            // Terminate the enumeration since there's no more room.
            // This produces a silent failure but it's not
            // important enough to warrant a true failure.
            return FALSE;
        }

        Match->Cur = NewStore + (Match->Cur - Match->Storage);
        
        Match->Storage = NewStore;
        Match->StorageEnd = NewStore + NewLen;

        DBG_ASSERT(Match->Cur + RecordLen <= Match->StorageEnd);
    }

    strcpy(Match->Cur, Name);
    Match->Cur += NameLen;
    *(ULONG64 UNALIGNED *)Match->Cur = Offset;
    Match->Cur += sizeof(Offset);
        
    return TRUE;
}

STDMETHODIMP
DebugClient::GetNextSymbolMatch(
    THIS_
    IN ULONG64 Handle,
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG MatchSize,
    OUT OPTIONAL PULONG64 Offset
    )
{
    ENTER_ENGINE();
    
    SymbolMatch* Match = (SymbolMatch*)Handle;
    ULONG64 Disp;
    HRESULT Status = E_NOINTERFACE;

    // Loop until a matching symbol is found.
    for (;;)
    {
        if (Match->Mod == NULL)
        {
            // Nothing more to enumerate.
            // Status is already set.
            break;
        }
        
        if (Match->Cur == NULL)
        {
            // Enumerate all symbols and stash them away.
            Match->Cur = Match->Storage;
            
            if (!SymEnumerateSymbols64(Match->Process->Handle,
                                       Match->Mod->BaseOfImage,
                                       FillMatchStorageCb, Match))
            {
                Status = WIN32_LAST_STATUS();
                break;
            }

            Match->End = Match->Cur;
            Match->Cur = Match->Storage;
        }

        while (Match->Cur < Match->End)
        {
            PCHAR Name;
            ULONG64 Addr;

            Name = Match->Cur;
            Match->Cur += strlen(Name) + 1;
            Addr = *(ULONG64 UNALIGNED *)Match->Cur;
            Match->Cur += sizeof(Addr);

            // If this symbol matches remember it for return.
            if (MatchPattern(Name, Match->Pattern))
            {
                char Sym[MAX_MODULE + MAX_SYMBOL_LEN + 1];

                strcpy(Sym, Match->Mod->ModuleName);
                strcat(Sym, "!");
                strcat(Sym, Name);

                Status = FillStringBuffer(Sym, 0, Buffer, BufferSize,
                                          MatchSize);

                if (Buffer == NULL)
                {
                    // Do not advance the enumeration as this
                    // is just a size test.
                    Match->Cur = Name;
                }
                
                if (Offset != NULL)
                {
                    *Offset = Addr;
                }
                
                break;
            }
        }

        if (SUCCEEDED(Status))
        {
            break;
        }

        if (Match->SingleMod)
        {
            Match->Mod = NULL;
        }
        else
        {
            Match->Mod = Match->Mod->Next;
        }
        Match->Cur = NULL;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::EndSymbolMatch(
    THIS_
    IN ULONG64 Handle
    )
{
    ENTER_ENGINE();
    
    SymbolMatch* Match = (SymbolMatch*)Handle;
    
    if (Match->Storage != NULL)
    {
        free(Match->Storage);
    }
    free(Match);
    
    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::Reload(
    THIS_
    IN PCSTR Module
    )
{
    ENTER_ENGINE();
    
    HRESULT Status = g_Target->Reload(Module);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetSymbolPath(
    THIS_
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG PathSize
    )
{
    ENTER_ENGINE();
    
    HRESULT Status =
        FillStringBuffer(g_SymbolSearchPath, 0,
                         Buffer, BufferSize, PathSize);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetSymbolPath(
    THIS_
    IN PCSTR Path
    )
{
    ENTER_ENGINE();
    
    HRESULT Status;
    
    Status = bangSymPath(Path, FALSE, NULL, 0) ?
        S_OK : E_OUTOFMEMORY;
    if (Status == S_OK)
    {
        CheckPath(g_SymbolSearchPath);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::AppendSymbolPath(
    THIS_
    IN PCSTR Addition
    )
{
    ENTER_ENGINE();
    
    HRESULT Status;
    
    Status = bangSymPath(Addition, TRUE, NULL, 0) ?
        S_OK : E_OUTOFMEMORY;
    if (Status == S_OK)
    {
        CheckPath(g_SymbolSearchPath);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetImagePath(
    THIS_
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG PathSize
    )
{
    ENTER_ENGINE();
    
    HRESULT Status = FillStringBuffer(g_ExecutableImageSearchPath, 0,
                                      Buffer, BufferSize, PathSize);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetImagePath(
    THIS_
    IN PCSTR Path
    )
{
    ENTER_ENGINE();
    
    HRESULT Status = ChangePath(&g_ExecutableImageSearchPath, Path, FALSE,
                                DEBUG_CSS_PATHS);
    if (Status == S_OK)
    {
        CheckPath(g_ExecutableImageSearchPath);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::AppendImagePath(
    THIS_
    IN PCSTR Addition
    )
{
    ENTER_ENGINE();
    
    HRESULT Status = ChangePath(&g_ExecutableImageSearchPath, Addition, TRUE,
                                DEBUG_CSS_PATHS);
    if (Status == S_OK)
    {
        CheckPath(g_ExecutableImageSearchPath);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetSourcePath(
    THIS_
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG PathSize
    )
{
    ENTER_ENGINE();
    
    HRESULT Status = FillStringBuffer(g_SrcPath, 0,
                                      Buffer, BufferSize, PathSize);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetSourcePathElement(
    THIS_
    IN ULONG Index,
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG ElementSize
    )
{
    ENTER_ENGINE();
    
    HRESULT Status;
    PSTR Elt, EltEnd;

    Elt = FindPathElement(g_SrcPath, Index, &EltEnd);
    if (Elt == NULL)
    {
        Status = E_NOINTERFACE;
        goto EH_Exit;
    }
    
    CHAR Save;
    Save = *EltEnd;
    *EltEnd = 0;
    Status = FillStringBuffer(Elt, (ULONG)(EltEnd - Elt) + 1,
                              Buffer, BufferSize, ElementSize);
    *EltEnd = Save;

 EH_Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetSourcePath(
    THIS_
    IN PCSTR Path
    )
{
    ENTER_ENGINE();
    
    HRESULT Status = ChangePath(&g_SrcPath, Path, FALSE, DEBUG_CSS_PATHS);
    if (Status == S_OK)
    {
        CheckPath(g_SrcPath);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::AppendSourcePath(
    THIS_
    IN PCSTR Addition
    )
{
    ENTER_ENGINE();
    
    HRESULT Status = ChangePath(&g_SrcPath, Addition, TRUE, DEBUG_CSS_PATHS);
    if (Status == S_OK)
    {
        CheckPath(g_SrcPath);
    }

    LEAVE_ENGINE();
    return Status;
}

HRESULT
GetCanonicalPath(PCSTR Path, PSTR Canon)
{
    // First make sure it's a full path.
    // XXX drewb - Probably should also convert drive
    // letters to unambiguous names.
    if (!IS_SLASH(Path[0]) &&
        !(((Path[0] >= 'a' && Path[0] <= 'z') ||
           (Path[0] >= 'A' && Path[0] <= 'Z')) &&
          Path[1] == ':') &&
        !IsUrlPathComponent(Path))
    {
        DWORD FullLen;
        PSTR FilePart;
        
        FullLen = GetFullPathName(Path, MAX_SOURCE_PATH, Canon, &FilePart);
        if (FullLen == 0 || FullLen >= MAX_SOURCE_PATH)
        {
            return WIN32_LAST_STATUS();
        }
    }
    else
    {
        strcpy(Canon, Path);
    }

    // Now remove '.' and '..'.  This is a full path with a filename
    // at the end so all occurrences must be bracketed with
    // path slashes.
    PSTR Rd = Canon, Wr = Canon;

    while (*Rd != 0)
    {
        if (IS_SLASH(*Rd))
        {
            if (Rd[1] == '.')
            {
                if (IS_SLASH(Rd[2]))
                {
                    // Found /./, ignore leading /. and continue
                    // with /.
                    Rd += 2;
                    continue;
                }
                else if (Rd[2] == '.' && IS_SLASH(Rd[3]))
                {
                    // Found /../ so back up one path component
                    // and continue with /.
                    do
                    {
                        Wr--;
                    }
                    while (Wr >= Canon && !IS_PATH_DELIM(*Wr));
                    DBG_ASSERT(Wr >= Canon);

                    Rd += 3;
                    continue;
                }
            }
        }

        *Wr++ = *Rd++;
    }
    *Wr = 0;

    return S_OK;
}

STDMETHODIMP
DebugClient::FindSourceFile(
    THIS_
    IN ULONG StartElement,
    IN PCSTR File,
    IN ULONG Flags,
    OUT OPTIONAL PULONG FoundElement,
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG FoundSize
    )
{
    if (Flags & ~(DEBUG_FIND_SOURCE_DEFAULT |
                  DEBUG_FIND_SOURCE_FULL_PATH |
                  DEBUG_FIND_SOURCE_BEST_MATCH))
    {
        return E_INVALIDARG;
    }

    HRESULT Status;
    char RwFile[MAX_SOURCE_PATH];
    ULONG FileLen;
    char Found[MAX_SOURCE_PATH];
    PSTR MatchPart;
    ULONG Elt;

    // Make a read-write copy of the file as the searching
    // modifies it.
    FileLen = strlen(File) + 1;
    if (FileLen > sizeof(RwFile))
    {
        return E_INVALIDARG;
    }
    memcpy(RwFile, File, FileLen);

    ENTER_ENGINE();
    
    if (FindSrcFileOnPath(StartElement, RwFile, Flags, Found,
                          &MatchPart, &Elt))
    {
        if (Flags & DEBUG_FIND_SOURCE_FULL_PATH)
        {
            Status = GetCanonicalPath(Found, RwFile);
            if (Status != S_OK)
            {
                goto EH_Exit;
            }
            
            strcpy(Found, RwFile);
        }
        
        if (FoundElement != NULL)
        {
            *FoundElement = Elt;
        }
        Status = FillStringBuffer(Found, 0,
                                  Buffer, BufferSize, FoundSize);
    }
    else
    {
        Status = E_NOINTERFACE;
    }

 EH_Exit:
    LEAVE_ENGINE();
    return Status;
}

// XXX drewb - This API is private for the moment due
// to uncertainty about what dbghelp's API is going to
// look like in the long term.
extern "C"
ULONG
IMAGEAPI
SymGetFileLineOffsets64(
    IN  HANDLE                  hProcess,
    IN  LPSTR                   ModuleName,
    IN  LPSTR                   FileName,
    OUT PDWORD64                Buffer,
    IN  ULONG                   BufferLines
    );

STDMETHODIMP
DebugClient::GetSourceFileLineOffsets(
    THIS_
    IN PCSTR File,
    OUT OPTIONAL PULONG64 Buffer,
    IN ULONG BufferLines,
    OUT OPTIONAL PULONG FileLines
    )
{
    HRESULT Status;
    ULONG Line;
    
    if (Buffer != NULL)
    {
        // Initialize map to empty.
        for (Line = 0; Line < BufferLines; Line++)
        {
            Buffer[Line] = DEBUG_INVALID_OFFSET;
        }
    }

    ENTER_ENGINE();
    
    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
        goto EH_Exit;
    }

    PSTR FilePart;
    ULONG HighestLine;
        
    // Request the line information from dbghelp.
    FilePart = (PSTR)File;
    HighestLine =
        SymGetFileLineOffsets64(g_CurrentProcess->Handle, NULL, FilePart,
                                Buffer, BufferLines);
    if (HighestLine == 0xffffffff)
    {
        Status = WIN32_LAST_STATUS();
        goto EH_Exit;
    }
    
    if (HighestLine == 0)
    {
        // Try again with just the filename because the path
        // may be different than what's in the symbol information.
        // XXX drewb - This can cause ambiguity problems.
        FilePart = (PSTR)File + strlen(File) - 1;
        while (FilePart >= File)
        {
            if (IS_PATH_DELIM(*FilePart))
            {
                break;
            }

            FilePart--;
        }
        FilePart++;
        if (FilePart <= File)
        {
            // No path and no information was found for the
            // given file so return not-found.
            Status = E_NOINTERFACE;
            goto EH_Exit;
        }
        
        HighestLine =
            SymGetFileLineOffsets64(g_CurrentProcess->Handle, NULL, FilePart,
                                    Buffer, BufferLines);
        if (HighestLine == 0xffffffff)
        {
            Status = WIN32_LAST_STATUS();
            goto EH_Exit;
        }
        else if (HighestLine == 0)
        {
            Status = E_NOINTERFACE;
            goto EH_Exit;
        }
    }

    if (FileLines != NULL)
    {
        *FileLines = HighestLine;
    }

    // Return S_FALSE if lines were missed because of
    // insufficient buffer space.
    Status = HighestLine > BufferLines ? S_FALSE : S_OK;

 EH_Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetModuleVersionInformation(
    THIS_
    IN ULONG Index,
    IN ULONG64 Base,
    IN PCSTR Item,
    OUT OPTIONAL PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG VerInfoSize
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        PDEBUG_IMAGE_INFO Image;
        
        if (Index == DEBUG_ANY_ID)
        {
            Image = GetImageByOffset(g_CurrentProcess, Base);
        }
        else
        {
            Image = GetImageByIndex(g_CurrentProcess, Index);
        }
        if (Image == NULL)
        {
            Status = E_NOINTERFACE;
        }
        else
        {
            Status = g_Target->
                GetImageVersionInformation(Image->ImagePath,
                                           Image->BaseOfImage, Item,
                                           Buffer, BufferSize, VerInfoSize);
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetModuleNameString(
    THIS_
    IN ULONG Which,
    IN ULONG Index,
    IN ULONG64 Base,
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG NameSize
    )
{
    HRESULT Status;

    if (Which > DEBUG_MODNAME_MAPPED_IMAGE)
    {
        return E_INVALIDARG;
    }
    
    ENTER_ENGINE();

    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG Idx = 0;
        
        Status = E_NOINTERFACE;
        
        PDEBUG_IMAGE_INFO Image = g_CurrentProcess->ImageHead;
        while (Image != NULL)
        {
            if ((Index != DEBUG_ANY_ID && Idx == Index) ||
                (Index == DEBUG_ANY_ID && Base == Image->BaseOfImage))
            {
                PSTR Str;
                DBH_MODSYMINFO SymFile;
                IMAGEHLP_MODULE64 ModInfo;

                switch(Which)
                {
                case DEBUG_MODNAME_IMAGE:
                    Str = Image->ImagePath;
                    break;
                case DEBUG_MODNAME_MODULE:
                    Str = Image->ModuleName;
                    break;
                case DEBUG_MODNAME_LOADED_IMAGE:
                    ModInfo.SizeOfStruct = sizeof(ModInfo);
                    if (!SymGetModuleInfo64(g_CurrentProcess->Handle,
                                            Image->BaseOfImage, &ModInfo))
                    {
                        Status = WIN32_LAST_STATUS();
                        goto Exit;
                    }
                    Str = ModInfo.LoadedImageName;
                    break;
                case DEBUG_MODNAME_SYMBOL_FILE:
                    SymFile.function = dbhModSymInfo;
                    SymFile.sizeofstruct = sizeof(SymFile);
                    SymFile.addr = Image->BaseOfImage;
                    if (!dbghelp(g_CurrentProcess->Handle, &SymFile))
                    {
                        Status = WIN32_LAST_STATUS();
                        goto Exit;
                    }
                    Str = SymFile.file;
                    break;
                case DEBUG_MODNAME_MAPPED_IMAGE:
                    Str = Image->MappedImagePath;
                    break;
                }
                
                Status = FillStringBuffer(Str, 0,
                                          Buffer, BufferSize, NameSize);
                break;
            }

            Image = Image->Next;
            Idx++;
        }
    }

 Exit:
    LEAVE_ENGINE();
    return Status;
}

//----------------------------------------------------------------------------
//
// Routines to make DebugSymbolGroup show Extension functions 
//
//----------------------------------------------------------------------------


CHAR g_ExtensionOutputDataBuffer[MAX_NAME];

class ExtenOutputCallbacks : public IDebugOutputCallbacks
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );
    // IDebugOutputCallbacks.
    STDMETHOD(Output)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Text
        );
};

STDMETHODIMP
ExtenOutputCallbacks::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    *Interface = NULL;

    if (IsEqualIID(InterfaceId, IID_IUnknown) ||
        IsEqualIID(InterfaceId, IID_IDebugOutputCallbacks))
    {
        *Interface = (IDebugOutputCallbacks *)this;
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
ExtenOutputCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
ExtenOutputCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

STDMETHODIMP
ExtenOutputCallbacks::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Text
    )
{
    if ((strlen(Text) +strlen(g_ExtensionOutputDataBuffer)) < MAX_NAME) 
    {
        strcat(g_ExtensionOutputDataBuffer, Text);
    }
    return S_OK;
}

ExtenOutputCallbacks g_ExtensionOutputCallback;

//
// Print out 'Line' in a multiline string MultiLine
//
BOOL        
OutputBufferLine(
    PSTR MultiLine, 
    ULONG Line
    )
{
    CHAR toPrint[200];
    PSTR Start, End;

    Start = MultiLine;
    while (Line && Start) 
    {
        Start = strchr(Start, '\n')+1;
        --Line;
    }
    if (Start) 
    {
        End = strchr(Start, '\n');

        if (End) 
        {
            ULONG len = (ULONG) ((ULONG64) End - (ULONG64) Start);
            if ((len+1) >= sizeof(toPrint)) {
                len = sizeof(toPrint)-2;
            }
            toPrint[0] = 0;
            strncat(toPrint, Start, len);
            dprintf(toPrint);
        } else
        {
            dprintf(Start);
        }
        return TRUE;
    }
    return FALSE;
}


#include "extsfns.h"
//
// EFN Structs
//
#ifndef FIELD_SIZE
#define FIELD_SIZE(type, field) (sizeof(((type *)0)->field))
#endif

#define DIS_FIELD_ENTRY(Type, Field)  \
    {#Field, FIELD_OFFSET(Type, Field), FIELD_SIZE(Type, Field), DGS_FldDefault, 0, 0}
#define DIS_BITFIELD_ENTRY(Type, Name, Field, Mask, Shift)  \
    {#Name, FIELD_OFFSET(Type, Field), FIELD_SIZE(Type, Field), DGS_FldBit, Mask, Shift}

DBG_GENERATED_STRUCT_FIELDS FieldsOf_DEBUG_POOL_DATA[] = {
    DIS_FIELD_ENTRY(DEBUG_POOL_DATA, PoolBlock),
    DIS_FIELD_ENTRY(DEBUG_POOL_DATA, Pool),
    DIS_FIELD_ENTRY(DEBUG_POOL_DATA, PreviousSize),
    DIS_FIELD_ENTRY(DEBUG_POOL_DATA, Size),
    DIS_FIELD_ENTRY(DEBUG_POOL_DATA, PoolTag),
    DIS_FIELD_ENTRY(DEBUG_POOL_DATA, ProcessBilled),
    DIS_BITFIELD_ENTRY(DEBUG_POOL_DATA, Free, AsUlong, 1, 0),
    DIS_BITFIELD_ENTRY(DEBUG_POOL_DATA, LargePool, AsUlong, 1, 1),
    DIS_BITFIELD_ENTRY(DEBUG_POOL_DATA, SpecialPool, AsUlong, 1, 2),
    DIS_BITFIELD_ENTRY(DEBUG_POOL_DATA, Pageable, AsUlong, 1, 3),
    DIS_BITFIELD_ENTRY(DEBUG_POOL_DATA, Protected, AsUlong, 1, 4),
    DIS_BITFIELD_ENTRY(DEBUG_POOL_DATA, Allocated, AsUlong, 1, 5),
    {NULL, 0, 0, DGS_FldBit},
};

DBG_GENERATED_STRUCT_INFO g_InternalStructsInfo[] = {
    { 1, "-Any Extension-",              0, DGS_Extension, 0, NULL},
    { 2, "_EFN_GetPoolData", sizeof(DEBUG_POOL_DATA), DGS_EFN, 
      sizeof(FieldsOf_DEBUG_POOL_DATA)/sizeof(DBG_GENERATED_STRUCT_FIELDS)-1, 
      &FieldsOf_DEBUG_POOL_DATA[0]
    },
    { -1, NULL, 0, DGS_EFN, 0},
};


typedef HRESULT
(WINAPI * PEFN_GENERIC_CALLER)(
    IN PDEBUG_CLIENT Client,
    IN ULONG64 Address,
    OUT PVOID Buffer
    );

PDBG_GENERATED_STRUCT_INFO
GetGeneratedStructInfo(
    ULONG Id,
    ULONG64 Handle
    )
{
    if (Handle == -1) 
    {
        // one of internal debugger structs

        return &g_InternalStructsInfo[Id - 1];
    }


    // Default to "any extension" type
    return &g_InternalStructsInfo[0];
}

BOOL
MatchAndCopyGeneratedStructInfo(
    PCHAR Name,
    PDBG_GENERATED_STRUCT_INFO pGenStrInfo,
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL pSymParam
    )
{
    HRESULT Status = E_FAIL;
    ULONG find;
    for (find=0; pGenStrInfo[find].Name != NULL; find++) 
    {
        if (!_stricmp(pGenStrInfo[find].Name, Name+1) &&
            (strlen(Name) < sizeof(pSymParam->TypeName))) 
        {
            pSymParam->Flags |= SYMBOL_IS_EXTENSION | TYPE_NAME_CHANGED;
            pSymParam->TypeIndex = find+1;
            pSymParam->Size = pGenStrInfo[find].Size;
            strcpy(pSymParam->TypeName, Name);
            pSymParam->External.Module = -1;            
            pSymParam->External.SubElements = pGenStrInfo[find].NumFields;
            pSymParam->External.Flags |= DEBUG_SYMBOL_READ_ONLY;
#ifdef DBG_SYMGROUP_ENABLED
            dprintf("Added Internal struct %lx\n", pGenStrInfo[find].Id);
#endif
            return TRUE;
        }
    }

    return FALSE;
}

HRESULT
AddExtensionAsType(
    PCHAR Extension,
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL pSymParam
    )
{
    HRESULT Status = E_FAIL;
    ULONG find;
 
    if (MatchAndCopyGeneratedStructInfo(Extension, &g_InternalStructsInfo[0], pSymParam)) 
    {
        Status = S_OK;
    }

    if (Status != S_OK) 
    {
        // Nothing mached, default to generic extension type
        find = 0;
        pSymParam->Flags |= SYMBOL_IS_EXTENSION | TYPE_NAME_CHANGED;
        pSymParam->TypeIndex = g_InternalStructsInfo[find].Id;
        pSymParam->Size = g_InternalStructsInfo[find].Size;
        strcpy(pSymParam->TypeName, Extension);
        pSymParam->External.Module = -1;            
        pSymParam->External.SubElements = 0;
        Status = S_OK;

    }
    
    return Status;
}

HRESULT
OutputExtensionForSymGrp(
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL pSymParam,
    DebugClient  *Client
    )
{
    HRESULT Status = E_FAIL;
    
    if (!(pSymParam->Flags & SYMBOL_IS_EXTENSION)) 
    {
        return E_INVALIDARG;
    }

    PDBG_GENERATED_STRUCT_INFO pExtnInfo;
    
    pExtnInfo = GetGeneratedStructInfo(pSymParam->TypeIndex, pSymParam->External.Module);

    if (!pExtnInfo) 
    {
        return E_INVALIDARG;
    }

    if (pExtnInfo->Type == DGS_Extension) 
    {
        ULONG ShowLine = 0;
        PVOID DataBuffer;
        if (pSymParam->SymbolIndex == pSymParam->External.ParentSymbol) 
        {
            DataBuffer = pSymParam->DataBuffer;
            // dprintf("Tarpped %s", g_ExtensionOutputDataBuffer);
        } else 
        {
            ShowLine = (ULONG) pSymParam->Offset;
            DataBuffer = pSymParam->Parent->DataBuffer;
        }
        OutputBufferLine((PSTR) DataBuffer, ShowLine);
    } else if (pExtnInfo->Type = DGS_EFN) 
    {
        if (pSymParam->SymbolIndex == pSymParam->External.ParentSymbol) 
        {
            EXTDLL* Ext = g_ExtDlls;
            while (Ext!=NULL)
            {
                if ((ULONG64) Ext == pSymParam->External.Module) 
                {
                    break;
                }
                Ext = Ext->Next;
            }
            if (Ext) 
            {
                dprintf("%s.%s", Ext->Name, pExtnInfo->Name);
            } else
            {
                dprintf("EFN not found");
            }

        } else 
        {
            // print child value as recieved from parent buffer
            PVOID Buffer;

            if (Buffer = pSymParam->Parent->DataBuffer) 
            {
                ULONG64 Value = 0;

                memcpy(&Value, (PCHAR) Buffer + pSymParam->Offset,
                       min(sizeof(Value), pSymParam->Size));

                if (pSymParam->Mask) 
                {
                    dprintf("%I64lx", (Value >> pSymParam->Shift) & pSymParam->Mask);
                } else
                {
                    dprintf("%I64lx", Value);
                }
            } else 
            {
                dprintf("Error in retriving value");
            }
        }
    }
    return S_OK;
}

HRESULT
FindChildrenForExtensionSym(
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL pParentSym,
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL *pChildren,
    PULONG pChildCount,
    PCHAR *pChildNames
    )
{
    HRESULT Status = E_FAIL;
    ULONG ChildCount=0;

    if (!(pParentSym->Flags & SYMBOL_IS_EXTENSION) ||
        (pParentSym->External.ParentSymbol != pParentSym->SymbolIndex) )
    {
        return E_INVALIDARG;
    }
    
    PDBG_GENERATED_STRUCT_INFO pParentInfo;
    
    pParentInfo = GetGeneratedStructInfo(pParentSym->TypeIndex, pParentSym->External.Module);

    if (!pParentInfo) 
    {
        return E_INVALIDARG;
    }

    //
    // Extensions
    //
    if (pParentInfo->Type == DGS_Extension) 
    {
        ULONG nLines;

        // Do we have any output buffer stored?
        if (!pParentSym->DataBuffer) 
        {
            *pChildCount = 0;
            return E_FAIL;
        }

        // Number of children == number of newlines - 1
        PCHAR scan = strchr((char *) pParentSym->DataBuffer, '\n');
        nLines = 0;
        while (scan)
        {
            ++nLines; ++scan;
            scan = strchr(scan, '\n');
        }

        if (!nLines) 
        {
            *pChildCount = 0;
            return E_FAIL;
        }
        
        *pChildNames = NULL;
        *pChildren = (PDEBUG_SYMBOL_PARAMETERS_INTERNAL) malloc(
            nLines * sizeof( DEBUG_SYMBOL_PARAMETERS_INTERNAL ));
        if (*pChildren == NULL)
        {
            return E_OUTOFMEMORY;
        }

        pParentSym->External.SubElements = nLines;
        ZeroMemory(*pChildren, nLines * sizeof( DEBUG_SYMBOL_PARAMETERS_INTERNAL ));
        for (ULONG ChildCount = 0; ChildCount < nLines; ChildCount++) 
        {
            (*pChildren)[ChildCount].External.ParentSymbol = pParentSym->SymbolIndex;
            (*pChildren)[ChildCount].External.Flags        = DEBUG_SYMBOL_READ_ONLY |
                ((UCHAR) pParentSym->External.Flags + 1);
            (*pChildren)[ChildCount].External.Module       = pParentSym->External.Module;
            (*pChildren)[ChildCount].Parent    = pParentSym;
            (*pChildren)[ChildCount].Name.Buffer = "   ";
            (*pChildren)[ChildCount].Name.Length = (*pChildren)[ChildCount].Name.MaximumLength = 6;
            (*pChildren)[ChildCount].Offset = ChildCount+1;
            (*pChildren)[ChildCount].TypeIndex = pParentSym->TypeIndex;
            (*pChildren)[ChildCount].Flags = SYMBOL_IS_EXTENSION;
        }
        return S_OK;

    }


    //
    // EFN Structs
    //
    if (!pParentInfo->Fields) 
    {
        return E_INVALIDARG;
    }
    assert(pParentSym->TypeIndex == pParentInfo->Id);

    for (ChildCount=0; pParentInfo->Fields[ChildCount].Name != NULL; ChildCount++) ;
    pParentSym->External.SubElements = ChildCount;
    
    *pChildNames = NULL;
    *pChildren = (PDEBUG_SYMBOL_PARAMETERS_INTERNAL) malloc(
        ChildCount * sizeof( DEBUG_SYMBOL_PARAMETERS_INTERNAL ));
    if (*pChildren == NULL)
    {
        return E_OUTOFMEMORY;
    }
    ZeroMemory(*pChildren, ChildCount * sizeof( DEBUG_SYMBOL_PARAMETERS_INTERNAL ));
    for (ChildCount=0; pParentInfo->Fields[ChildCount].Name != NULL; ChildCount++) 
    {
        (*pChildren)[ChildCount].External.ParentSymbol = pParentSym->SymbolIndex;
        (*pChildren)[ChildCount].External.Flags        = DEBUG_SYMBOL_READ_ONLY |
            ((UCHAR) pParentSym->External.Flags + 1);
        (*pChildren)[ChildCount].External.Module       = pParentSym->External.Module;
        (*pChildren)[ChildCount].Parent    = pParentSym;
        (*pChildren)[ChildCount].Name.Buffer = pParentInfo->Fields[ChildCount].Name;
        (*pChildren)[ChildCount].Name.Length = (*pChildren)[ChildCount].Name.MaximumLength =
            strlen((*pChildren)[ChildCount].Name.Buffer)+1;
        (*pChildren)[ChildCount].Offset = pParentInfo->Fields[ChildCount].Offset;
        (*pChildren)[ChildCount].TypeIndex = pParentSym->TypeIndex;
        (*pChildren)[ChildCount].Flags = SYMBOL_IS_EXTENSION;
        (*pChildren)[ChildCount].Size = pParentInfo->Fields[ChildCount].Size;
        (*pChildren)[ChildCount].Mask = pParentInfo->Fields[ChildCount].BitMask;
        (*pChildren)[ChildCount].Shift = pParentInfo->Fields[ChildCount].BitShift;
    }

    return S_OK;
}

HRESULT
RefreshExtensionSymbolParemeter(
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL pSymParam,
    DebugClient *Client
    )
{
    HRESULT Status = E_FAIL;
    ULONG ChildCount=0;

    if (!(pSymParam->Flags & SYMBOL_IS_EXTENSION))
    {
        return E_INVALIDARG;
    }
    PDBG_GENERATED_STRUCT_INFO pExtnInfo;
    
    pExtnInfo = GetGeneratedStructInfo(pSymParam->TypeIndex, pSymParam->External.Module);

    if (!pExtnInfo) 
    {
        return E_INVALIDARG;
    }

    if (pExtnInfo->Type == DGS_Extension) 
    {
        CHAR ExtArg[50];
        PDEBUG_OUTPUT_CALLBACKS OutCbSave;

        Client->FlushCallbacks();
        OutCbSave = Client->m_OutputCb ;

        OutCtlSave OldCtl;

        if (PushOutCtl(DEBUG_OUTCTL_THIS_CLIENT | DEBUG_OUTCTL_OVERRIDE_MASK |DEBUG_OUTCTL_NOT_LOGGED, 
                       Client, &OldCtl))
        {
            g_ExtensionOutputDataBuffer[0] = 0;
            Client->m_OutputCb = &g_ExtensionOutputCallback;

            sprintf(ExtArg, "%I64lx", pSymParam->Address);

            CallAnyExtension(Client, NULL, pSymParam->TypeName+1, ExtArg, FALSE, FALSE, &Status);
            
            PopOutCtl(&OldCtl);

        }
        Client->FlushCallbacks();
        Client->m_OutputCb = OutCbSave;

        if (pSymParam->DataBuffer) 
        {
            free (pSymParam->DataBuffer);
        }
        pSymParam->DataBuffer = malloc(strlen(g_ExtensionOutputDataBuffer) + 1);
        strcpy((char*)pSymParam->DataBuffer, g_ExtensionOutputDataBuffer);
        if (!pSymParam->Expanded && strchr(g_ExtensionOutputDataBuffer, '\n'))
        {
            // Let caller know this can be expanded,
            // number of che=ildren will be figured out by ExpandSymbol
            pSymParam->External.SubElements = 1;
        }
    } else
    {

        if (pExtnInfo->Type = DGS_EFN) 
        {
            PEFN_GENERIC_CALLER EfnRoutine;
            EXTDLL* Ext;
            Ext = g_ExtDlls;

            if (pSymParam->SymbolIndex == pSymParam->External.ParentSymbol) 
            {
                while (Ext!=NULL)
                {
                    if (LoadExtensionDll(Ext))
                    {
                        EfnRoutine = (PEFN_GENERIC_CALLER) GetProcAddress(Ext->Dll, pExtnInfo->Name);
                        if (EfnRoutine != NULL)
                        {
                            Status = S_OK;
                            break;
                        }
                    }

                    Ext = Ext->Next;

                }
                pSymParam->External.Module = (ULONG64) Ext;
                // Call EFN and get the value
                PVOID Buffer = pSymParam->DataBuffer;

                if (!Buffer) 
                {
                    Buffer = malloc(pExtnInfo->Size);
                }
                if (Buffer) 
                {
                    *((PULONG) Buffer) = pExtnInfo->Size;

                    if ((*EfnRoutine)((PDEBUG_CLIENT)Client, pSymParam->Address, Buffer) == S_OK) 
                    {
                        pSymParam->DataBuffer = Buffer;
                    } else 
                    {
                        free (Buffer);
                    }
                }
            } else 
            {
                // nothing to do for EFN subelements, they always use
                // parents databuffer
            }
        }

    
    }
    
    return S_OK;
}
//----------------------------------------------------------------------------
//
// DebugSymbolGroup helpers
//
//----------------------------------------------------------------------------


//
// Initialize DEBUG_SYMBOL_PARAMETERS_INTERNAL from TYPES_INFO_ALL
//
void
TypToParam(PTYPES_INFO_ALL pTyp, PDEBUG_SYMBOL_PARAMETERS_INTERNAL pParam)
{
    pParam->Address = pTyp->Address;
    pParam->Flags   = pTyp->Flags;
    pParam->ExpandTypeAddress = pTyp->SubAddr;
    pParam->External.SubElements = pTyp->SubElements;
    pParam->Size    = pTyp->Size;
    pParam->TypeIndex = pTyp->TypeIndex;
    pParam->Register = pTyp->Register;
    pParam->Offset  = pTyp->Offset;
    pParam->External.Module = pTyp->Module;
    pParam->External.TypeId = pTyp->TypeIndex;
    return;
}

//
// Show / compare corresponding values of TYPES_INFO_ALL and DEBUG_SYMBOL_PARAMETERS_INTERNAL
//
void
ShowDiff(PTYPES_INFO_ALL pTyp, PDEBUG_SYMBOL_PARAMETERS_INTERNAL pParam)
{
#ifdef DBG_SYMGROUP_ENABLED
    dprintf("Address \t%8I64lx %8I64lx\n", pParam->Address ,pTyp->Address);
    dprintf("Flags   \t%8lx %8lx\n", pParam->Flags   ,pTyp->Flags);
    dprintf("ExpAddr \t%8I64lx %8I64lx\n", pParam->ExpandTypeAddress ,pTyp->SubAddr);
    dprintf("Ext.SubEts\t%8lx %8lx\n", pParam->External.SubElements ,pTyp->SubElements);
    dprintf("Size    \t%8lx %8lx\n", pParam->Size    ,pTyp->Size);
    dprintf("TypeIndex \t%8lx %8lx\n", pParam->TypeIndex ,pTyp->TypeIndex);
    dprintf("Register \t%8lx %8lx\n", pParam->Register ,pTyp->Register);
    dprintf("Offset  \t%8I64lx %8I64lx\n", pParam->Offset  ,pTyp->Offset);
    dprintf("ExtModule \t%8I64lx %8I64lx\n", pParam->External.Module ,pTyp->Module);
    dprintf("ExtId   \t%8lx %8lx\n", pParam->External.TypeId ,pTyp->TypeIndex);
#endif    
    return;
}


//    
//   Resolves the typecast vaulue and updates the symbol parameters
//   
//   Typecast  : type string to resolve
//  
//   pSymParam : It has the appropriate values for given symbol as a result
//               of typecast
//
HRESULT
ResolveTypecast(
    PCHAR Typecast,
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL pSymParam
    )
{
    HRESULT Status;
    ANSI_STRING TypeName;
    TYPES_INFO typeInfo;
    
    Status = E_INVALIDARG;
    if (*Typecast == '!') 
    {
        // Its  an extension
        Status = AddExtensionAsType(Typecast, pSymParam);
    } else 
    {
        SYM_DUMP_PARAM_EX Sym;

        ZeroMemory(&typeInfo, sizeof(typeInfo));
        ZeroMemory(&Sym, sizeof(Sym));

        Sym.Options = NO_PRINT;
        Sym.sName = (PUCHAR) Typecast;
        Sym.size = sizeof(SYM_DUMP_PARAM_EX);

        if (!TypeInfoFound(g_CurrentProcess->Handle,
                           g_CurrentProcess->ImageHead,
                           &Sym,
                           &typeInfo))
        {
            // We got a valid type name

            if (strlen(Typecast) < sizeof(pSymParam->TypeName))
            {
                strcpy(pSymParam->TypeName, Typecast);
                if ((pSymParam->TypeIndex != typeInfo.TypeIndex) ||
                    (pSymParam->External.Module != typeInfo.ModBaseAddress)) 
                {
                    pSymParam->Flags |= TYPE_NAME_CHANGED;
                }

                Status = S_OK;
            }
            else
            {
                pSymParam->Flags &= ~TYPE_NAME_MASK;
            }

            pSymParam->TypeIndex = typeInfo.TypeIndex;
            pSymParam->External.Module = typeInfo.ModBaseAddress;
        }


    }
    return Status;
}


//
//  Refresh paremeters for a symbol
//
HRESULT
RefreshSymbolParemeter(
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL pSymParam,
    DebugClient * Client
    )
{
    CHAR TmpName[MAX_NAME], *pTmpName;
    HRESULT Status = S_OK;
    
    if (pSymParam->Flags & SYMBOL_IS_EXTENSION)
    {
        return RefreshExtensionSymbolParemeter(pSymParam, Client);
    }

    if (pSymParam &&
    ((!(pSymParam->External.Flags & DEBUG_SYMBOL_EXPANSION_LEVEL_MASK) ||
      (pSymParam->Flags & TYPE_NAME_CHANGED))))
    {
        // 
        // Symbol's type might have changed 
        //
        SYM_DUMP_PARAM_EX  Sym = {0};
        TYPES_INFO         typeInfo = {0};
        ULONG              TypeStatus = 0;

        Sym.size    = sizeof(SYM_DUMP_PARAM_EX);
        Sym.Options = DBG_RETURN_TYPE| DBG_RETURN_TYPE_VALUES | NO_PRINT ;
        if (pSymParam->Flags & (TYPE_NAME_CHANGED | TYPE_NAME_USED))
        {
            Sym.sName   = (PUCHAR) pSymParam->TypeName;
        }
        else
        {
            Sym.sName   = (PUCHAR) pSymParam->Name.Buffer;
        }

        if (pSymParam->Flags & SYMBOL_IS_EXPRESSION) {
                // The expression ight have changed 
            pSymParam->Address = ExtGetExpression(pSymParam->Name.Buffer);
        }

        if (pSymParam->External.Module &&
            !strchr((PCHAR) Sym.sName, '!') && // We already have mod! in the name
            !(*Sym.sName == '&' || *Sym.sName == '*') &&
            !(pSymParam->Flags & SYMBOL_IS_EXPRESSION) // Do no display mod! if name entered was expression
            ) 
        {
            pTmpName = &TmpName[0];

            // If symbol runs out of scope, this causes lookup in all modules 
            // Search only in its last valid module to avoid slowing down debugger
            if (GetModuleName(pSymParam->External.Module, pTmpName, sizeof(TmpName)))
            {
                strcat(pTmpName, "!");
                strcat(pTmpName, (PCHAR) Sym.sName);
                Sym.sName = (PUCHAR) &TmpName[0];
            }
        }

        if (((pSymParam->Flags & (TYPE_NAME_CHANGED | TYPE_NAME_USED)) && 
             !TypeInfoFound(g_CurrentProcess->Handle,
                            g_CurrentProcess->ImageHead,
                            &Sym,
                            &typeInfo)) &&
            (typeInfo.SymAddress || 
             Sym.addr ||
             (pSymParam->Flags & (TYPE_NAME_CHANGED | TYPE_NAME_USED))))
        {

            if ((pSymParam->Flags & TYPE_NAME_USED) &&
                !(pSymParam->Flags & TYPE_NAME_CHANGED))
            {
                //
                // We'd typecast this, and types do not change with scope
                //
            }
            else if (typeInfo.SymAddress != pSymParam->Address ||
                     typeInfo.TypeIndex  != pSymParam->TypeIndex ||
                     typeInfo.ModBaseAddress != pSymParam->External.Module)
            {
                //      
                // The name refers to different symbol now
                //

                if (pSymParam->Flags & TYPE_NAME_CHANGED)
                {
                    // Just a type cast, keep old address
                    typeInfo.SymAddress  = pSymParam->Address;
                    typeInfo.Flag        = pSymParam->Flags & ADDRESS_TRANSLATION_MASK;
                    typeInfo.Value       = pSymParam->Register;
                }
                else
                {
                    // Change address if not a typecast
                    pSymParam->Address = typeInfo.SymAddress;
                    pSymParam->Flags   = typeInfo.Flag & ADDRESS_TRANSLATION_MASK;
                }

                pSymParam->TypeIndex            = typeInfo.TypeIndex;
                pSymParam->External.Module      = typeInfo.ModBaseAddress;
                pSymParam->External.TypeId      = typeInfo.TypeIndex;
                pSymParam->Register             = (ULONG) typeInfo.Value;

                DEBUG_SYMBOL_PARAMETERS  SavedExt;
                BOOL                     wasExpanded = FALSE;
                if (pSymParam->External.Flags & DEBUG_SYMBOL_EXPANDED)
                {
                    SavedExt = pSymParam->External;
                    wasExpanded = TRUE;
                }

                Sym.Options = DBG_RETURN_TYPE | NO_PRINT;
                Sym.addr    = pSymParam->Address;

                FIND_TYPE_INFO Info;
                Info.Flags = DBG_RETURN_TYPE ;
                Info.InternalParams = pSymParam; Info.nParams = 1;
                DumpTypeAndReturnInfo(&typeInfo, &Sym,
                                      &TypeStatus, &Info);
                if (wasExpanded) 
                {
                    pSymParam->External.Flags = SavedExt.Flags;
                    pSymParam->External.SubElements = SavedExt.SubElements;
                }
                if (TypeStatus)
                {
                    Status = E_INVALIDARG;
                }
                if (pSymParam->Size && (pSymParam->Size  <= sizeof(ULONG64)))
                {
                    pSymParam->External.Flags &= ~DEBUG_SYMBOL_READ_ONLY;
                }
                else
                {
                    pSymParam->External.Flags |= DEBUG_SYMBOL_READ_ONLY;
                }
            }
        }
        else
        {
            TYPES_INFO_ALL typ;

            if (GetExpressionTypeInfo((PCHAR) Sym.sName, &typ))
            {
                DEBUG_SYMBOL_PARAMETERS  SavedExt={0};
                BOOL                     wasExpanded=FALSE;
                if (pSymParam->External.Flags & DEBUG_SYMBOL_EXPANDED)
                {
                    SavedExt = pSymParam->External;
                    wasExpanded = TRUE;
                }

                ShowDiff(&typ, pSymParam);
                TypToParam(&typ, pSymParam);

                if (wasExpanded) 
                {
                    pSymParam->External.Flags = SavedExt.Flags;
                    pSymParam->External.SubElements = SavedExt.SubElements;
                }
            }
            else
            {
                //      
                // Force error in output
                //
                pSymParam->TypeIndex = 0;
                pSymParam->ExpandTypeAddress = 0;

                // Remove children
                if (pSymParam->External.Flags & DEBUG_SYMBOL_EXPANDED)
                {
                    pSymParam->Expanded = FALSE;
                    pSymParam->External.Flags &= ~DEBUG_SYMBOL_EXPANDED;
                    pSymParam->External.SubElements = 0;
                }
            }
        }
    }
    if (pSymParam->Flags & TYPE_NAME_CHANGED)
    {
        pSymParam->Flags &= ~TYPE_NAME_CHANGED;
        pSymParam->Flags |= TYPE_NAME_USED | TYPE_NAME_VALID;
    }


    return Status;
}


//
//   Output value of the symbol
//
HRESULT
OutputDbgSymValue(
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL pSymParam,
    DebugClient  *Client
    )
{
    FIND_TYPE_INFO Info;
    TYPE_DUMP_INTERNAL tdi;
    SYM_DUMP_PARAM_EX Sym;
    TYPES_INFO typeInfo;
    ULONG SubTypes;
    BOOL TypeChanged = FALSE, Expanded;
    ULONG64 Value;
    DEBUG_SYMBOL_PARAMETERS_INTERNAL TempSym;
    
    if (pSymParam->Flags & SYMBOL_IS_EXTENSION)
    {
        return OutputExtensionForSymGrp(pSymParam, Client);
    }

    ZeroMemory(&Sym, sizeof(Sym));
    ZeroMemory(&tdi, sizeof(tdi));

    SubTypes    = pSymParam->External.SubElements;
    Expanded    = pSymParam->External.Flags & DEBUG_SYMBOL_EXPANDED;
    Sym.Options = tdi.TypeOptions =  DBG_RETURN_TYPE| DBG_RETURN_TYPE_VALUES | NO_PRINT;
    Sym.sName   = (PUCHAR) pSymParam->Name.Buffer;
    Sym.size = sizeof(SYM_DUMP_PARAM_EX);

    if (pSymParam->Flags & TYPE_NAME_USED) 
    {
        Sym.sName = (PUCHAR) &pSymParam->TypeName[0];
    }
    if (pSymParam->Parent)
    {
        pSymParam->Address = Sym.addr = pSymParam->Offset + pSymParam->Parent->ExpandTypeAddress;
    }
    else
    {
        Sym.addr = pSymParam->Address;
    }

    tdi.pSymParams = NULL;
    tdi.level = 1;
    tdi.NumSymParams = 1;
    tdi.IsAVar = 1;
    Value               = pSymParam->Register;
    typeInfo.hProcess = tdi.hProcess = g_CurrentProcess->Handle;
    typeInfo.ModBaseAddress = tdi.modBaseAddr =
                                  pSymParam->External.Module;
    typeInfo.TypeIndex  = pSymParam->TypeIndex;
    typeInfo.SymAddress = pSymParam->Address;
    typeInfo.Flag       = pSymParam->Flags & ADDRESS_TRANSLATION_MASK;
    typeInfo.Value      = Value;

    tdi.FieldOptions    = pSymParam->Flags & STRING_DUMP_MASK;

    if (pSymParam->TypeIndex)
    {
        Info.Flags = DBG_RETURN_TYPE ;
        Info.InternalParams = &TempSym; Info.nParams = 1;

        TempSym = *pSymParam;
        DumpTypeAndReturnInfo(&typeInfo, &Sym, (PULONG) &tdi.ErrorStatus, &Info);

        //      Statements below corrupt the number of subelements and their address
//        pSymParam->External.SubElements = Info.FullInfo.SubElements;
//        pSymParam->ExpandTypeAddress = Info.ParentExpandAddress;

        if (tdi.ErrorStatus)
        {
            // dprintf("Error : Cannot get value");
        }
    } 
    else if (pSymParam->Flags & SYMBOL_IS_EXPRESSION) 
    {
        // We only have an address as symbol name, is hasn't
        // been typecasted (correctly) yet
        // Display what we have as address
        dprintf("%p", pSymParam->Address);
    }
    else
    {
        dprintf("Error : Cannot get value");
    }
    if (Expanded)
    {
        //
        // Keep the number of elements we expanded it with
        //
        pSymParam->External.SubElements = SubTypes;
        pSymParam->Expanded = TRUE;
        pSymParam->External.Flags |= DEBUG_SYMBOL_EXPANDED;
    }


    return S_OK;
}


//----------------------------------------------------------------------------
//
// IDebugSymbolGroup.
//
//----------------------------------------------------------------------------

#include "symtype.h"

DebugSymbolGroup::DebugSymbolGroup(
    DebugClient *CreatedBy
    )
{
    m_Refs       = 1;
    m_pSymParams = NULL;
    m_NumParams  = 0;
    m_pCreatedBy = CreatedBy;
    m_Locals     = FALSE;;
    m_ScopeGroup = DEBUG_SCOPE_GROUP_ALL;
}

DebugSymbolGroup::DebugSymbolGroup(
    DebugClient *CreatedBy,
    ULONG        ScopeGroup
    )
{
    m_Refs       = 1;
    m_pSymParams = NULL;
    m_NumParams  = 0;
    m_pCreatedBy = CreatedBy;
    m_Locals     = ScopeGroup == DEBUG_SCOPE_GROUP_LOCALS;
    m_ScopeGroup = ScopeGroup;
    m_LastClassExpanded = TRUE;
    m_thisAdjust = 0;
}

DebugSymbolGroup::~DebugSymbolGroup(void)
{
    ENTER_ENGINE();
    DeleteSymbolParam(0, m_NumParams);
    LEAVE_ENGINE();
}

STDMETHODIMP
DebugSymbolGroup::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    HRESULT Status;
    
    *Interface = NULL;
    Status = S_OK;

    if (DbgIsEqualIID(InterfaceId, IID_IUnknown) ||
        DbgIsEqualIID(InterfaceId, IID_IDebugSymbolGroup))
    {
        AddRef();
        *Interface = (IDebugSymbolGroup *)this;
    }
    else
    {
        Status = E_NOINTERFACE;
    }

    return Status;
}

STDMETHODIMP_(ULONG)
DebugSymbolGroup::AddRef(
    THIS
    )
{
    return InterlockedIncrement((PLONG)&m_Refs);
}

STDMETHODIMP_(ULONG)
DebugSymbolGroup::Release(
    THIS
    )
{
    LONG Refs = InterlockedDecrement((PLONG)&m_Refs);
    if (Refs == 0)
    {
        delete this;
    }
    return Refs;
}

// #define DBG 1

STDMETHODIMP
DebugSymbolGroup::GetNumberSymbols(
    THIS_
    OUT PULONG Number
    )
{
    *Number = m_NumParams;
    return S_OK;
}

int __cdecl
CompareSymParamNames(
    const void *Sym1,
    const void *Sym2
    )
{
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL S1 = *((PDEBUG_SYMBOL_PARAMETERS_INTERNAL *) Sym1);
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL S2 = *((PDEBUG_SYMBOL_PARAMETERS_INTERNAL *) Sym2);

#define IsArg(S)    (S->External.Flags & DEBUG_SYMBOL_IS_ARGUMENT)
    
    if (IsArg(S1) || IsArg(S2))
    {
        if (IsArg(S1) && IsArg(S2)) 
        {
            return (int) S1->Address - (int) S2->Address;
        } else if (IsArg(S1))
        {
            return -1;
        } else 
        {
            return 1;
        }
    }
#undef IsArg
    return _stricmp((*((PDEBUG_SYMBOL_PARAMETERS_INTERNAL *) Sym1))->Name.Buffer,
                   (*((PDEBUG_SYMBOL_PARAMETERS_INTERNAL *) Sym2))->Name.Buffer);
}

BOOL
GetModuleName(
    ULONG64 Base,
    PCHAR Name,
    ULONG SizeOfName
    )
{
    PDEBUG_IMAGE_INFO Image = g_CurrentProcess->ImageHead;
    while (Image != NULL)
    {
        if (Base == Image->BaseOfImage)
        {
            if (strlen(Image->ModuleName) < SizeOfName)
            {
                strcpy(Name, Image->ModuleName);
                return TRUE;
            }
        }

        Image = Image->Next;
    }
    
    IMAGEHLP_MODULE Mod;

    Mod.SizeOfStruct = sizeof (IMAGEHLP_MODULE);
    if (SymGetModuleInfo64(g_CurrentProcess->Handle, Base, &Mod)) 
    {
        if (strlen(Mod.ModuleName) < SizeOfName)
        {
            strcpy(Name, Mod.ModuleName);
            return TRUE;
        }
    }
    return FALSE;
}

STDMETHODIMP
DebugSymbolGroup::AddSymbol(
    THIS_
    IN PCSTR Name,
    OUT PULONG Index
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = E_INVALIDARG;

        if (m_Locals) 
        {
            if (!strcmp(Name, "*")) 
            {
                Status = AddCurrentLocals();            
            }
            else if (!strcmp(Name, "*+"))
            {
                Status = AddCurrentLocals();            
            }
        }
        else 
        {
            Status = AddOneSymbol(Name, NULL, Index);
        }
    }
    
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugSymbolGroup::RemoveSymbolByName(
    THIS_
    IN PCSTR Name
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP
DebugSymbolGroup::RemoveSymbolByIndex(
    THIS_
    IN ULONG Index
    )
{
    HRESULT Status = E_INVALIDARG;

    ENTER_ENGINE();
    
    if (IsRootSymbol(Index))
    {
        if (DeleteSymbolParam(Index, 1))
        {
            Status = S_OK;
        }
    }
    
#ifdef DBG_SYMGROUP_ENABLED
    dprintf("Deleted %lx\n", Index);
    ShowAll();
#endif
    
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugSymbolGroup::GetSymbolName(
    THIS_
    IN ULONG Index,
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG NameSize
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    PDEBUG_SYMBOL_PARAMETERS_INTERNAL Sym;

    Status = E_INVALIDARG;
    
    Sym = LookupSymbolParameter(Index);
    if (Sym)
    {
        if (NameSize)
        {
            *NameSize = Sym->Name.Length;
        }
        Status = FillStringBuffer(Sym->Name.Buffer, Sym->Name.Length, Buffer, BufferSize, NameSize);
    }
    
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugSymbolGroup::GetSymbolParameters(
    THIS_
    IN ULONG Start,
    IN ULONG Count,
    OUT /* size_is(Count) */ PDEBUG_SYMBOL_PARAMETERS Params
    )
{
    HRESULT Status;

    ENTER_ENGINE();
    
    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }
    else if ((Start + Count) > m_NumParams) 
    {
        Status = E_INVALIDARG;
        goto Exit;
    }

    Status = S_OK;
    
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL StartSym;

    ZeroMemory(Params, sizeof(DEBUG_SYMBOL_PARAMETERS) * Count);
    StartSym = LookupSymbolParameter(Start);
    
#ifdef DBG_SYMGROUP_ENABLED
    dprintf("GetSymbolParameters: will return %lx sym params\n", Count);
    ShowAll();
#endif

    while (Count && StartSym)
    {
        // Do not re-resolve locals if they aren't typecast
        if (!m_Locals || (StartSym->Flags & (TYPE_NAME_CHANGED | TYPE_NAME_USED))) 
        {
            Status = RefreshSymbolParemeter(StartSym, m_pCreatedBy);
            if ((Status == S_OK) && StartSym->ExpandTypeAddress) 
            {
                if (!strcmp(StartSym->Name.Buffer, "this")) 
                {
                    StartSym->ExpandTypeAddress -= m_thisAdjust;
                    StartSym->Offset = m_thisAdjust;
                }
            }

        }
        *Params = StartSym->External;
        StartSym = StartSym->Next;
        Count--;
        Params++;
    }

#ifdef DBG_SYMGROUP_ENABLED
    dprintf("End GetSymbolParameters\n");
    ShowAll();
#endif

 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugSymbolGroup::ExpandSymbol(
    THIS_
    IN ULONG Index,
    IN BOOL Expand
    )
{
    HRESULT Status;

    ENTER_ENGINE();
    
    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = ExpandSymPri(Index, Expand);
    }
    
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugSymbolGroup::OutputSymbols(
    THIS_
    IN ULONG OutputControl,
    IN ULONG Flags,
    IN ULONG Start,
    IN ULONG Count
    )
{
    HRESULT Status;

    ENTER_ENGINE();
    
    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

#ifdef DBG_SYMGROUP_ENABLED
    dprintf("Output\n");
    ShowAll();
#endif

    OutCtlSave OldCtl;

    if (!PushOutCtl(OutputControl, m_pCreatedBy, &OldCtl))
    {
        Status = E_INVALIDARG;
        goto Exit;
    }
    
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL StartSym;
    TYPES_INFO typeInfo;

    ZeroMemory(&typeInfo, sizeof(typeInfo));
    
    StartSym = LookupSymbolParameter(Start);
    while (StartSym && Count)
    {
        
        dprintf("%s%s", StartSym->Name.Buffer, DEBUG_OUTPUT_NAME_END );

        OutputDbgSymValue(StartSym, m_pCreatedBy);
        
        dprintf(DEBUG_OUTPUT_VALUE_END);

        if (!(Flags & DEBUG_OUTPUT_SYMBOLS_NO_OFFSETS))
        {
            dprintf("%03lx%s",(ULONG) StartSym->Offset, DEBUG_OUTPUT_OFFSET_END);
        }
            
        //
        // Type Name Output
        //
        if (!(Flags & DEBUG_OUTPUT_SYMBOLS_NO_TYPES))
        {
            CHAR  Name[1024];
            ANSI_STRING TypeName = {sizeof(Name), sizeof(Name), (PCHAR)&Name};

            typeInfo.hProcess = g_CurrentProcess->Handle;
            typeInfo.ModBaseAddress = StartSym->External.Module;
            typeInfo.TypeIndex  = StartSym->TypeIndex;

            if (StartSym->Flags & (TYPE_NAME_VALID | TYPE_NAME_USED))
            {
                //
                // We already have a valid type name 
                //
                strcpy(Name, StartSym->TypeName);
                //dprintf("%s", StartSym->TypeName);
            } 
            else if (StartSym->Flags & SYMBOL_IS_EXTENSION) 
            {
                strcpy(Name, "<Extension>");
            }
            else if (GetTypeName(NULL, &typeInfo, &TypeName) == S_OK)
            {
                if (strlen(TypeName.Buffer) < sizeof(StartSym->TypeName))
                {
                    strcpy(StartSym->TypeName, Name);
                }
                //dprintf("%s", Name);
            }
            else
            {
                strcpy(Name, "Enter new type");
            }
            if (Name[0] == '<')
            {
                // No name
                dprintf("Enter new type");
                StartSym->Flags &= ~TYPE_NAME_VALID;
            }
            else
            {
                StartSym->Flags |= TYPE_NAME_VALID;
                dprintf("%s", Name);
            }
            dprintf(DEBUG_OUTPUT_TYPE_END);
        }

        StartSym = StartSym->Next;
    }

    PopOutCtl(&OldCtl);
    Status = S_OK;

 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugSymbolGroup::WriteSymbol(
    THIS_
    IN ULONG Index,
    IN PCSTR Value
    )
{
    if (!Value)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }


    if (!Value)
    {
        Status = E_INVALIDARG;
        goto Exit;
    }

    PDEBUG_SYMBOL_PARAMETERS_INTERNAL SymInternal;

#ifdef DBG_SYMGROUP_ENABLED
    dprintf("WriteSymbol %lx : %s\n", Index, Value);
#endif

    SymInternal = LookupSymbolParameter(Index);
    if (!SymInternal ||
        !SymInternal->Size ||
        SymInternal->Size > sizeof(ULONG64) ||
        (SymInternal->External.Flags & DEBUG_SYMBOL_READ_ONLY))
    {
        Status = E_INVALIDARG;
        goto Exit;
    }

    Status = E_FAIL;
    
    ULONG64 ChangedValue = 0;
    ULONG   BytesWritten;
    ULONG64 WriteAddress = SymInternal->Address;
        
    if (SymInternal->External.Flags & DEBUG_SYMBOL_IS_FLOAT) 
    {
        // read a float
        float flt = 0;
        if (sscanf(Value, "%g", &flt)) 
        {
            if (SymInternal->Size == sizeof (float)) 
            {
                *((float *) &ChangedValue) = flt;
                Status = S_OK;
            }
            else if (SymInternal->Size == sizeof (double)) // its a double
            {
                *((double *) &ChangedValue) = flt;
                Status = S_OK;
            }
            
            if (Status == S_OK) 
            {
                // Only float nad double types get written out.
                if (!(SymInternal->Flags & SYMF_REGISTER)) 
                {
                    ULONG64 Reg = SymInternal->Register;
                    TranslateAddress(SymInternal->Flags & ADDRESS_TRANSLATION_MASK,
                                     SymInternal->Register,
                                     &WriteAddress,
                                     &Reg);
                    Status = g_Target->WriteVirtual(WriteAddress, 
                                                    (PVOID)&ChangedValue, 
                                                    SymInternal->Size,
                                                    &BytesWritten);
                } else 
                {
                    // We do not know register format for float values
                    Status = E_FAIL;
                }
            }
        }
    }
    else 
    {
        CHAR Token[100];
        PSTR SaveCurCmd = g_CurCmd;
        __try
        {
            if (sscanf(Value, "%s", &Token[0]))
            {
                g_CurCmd = &Token[0];
                g_TypedExpr = TRUE;
                ChangedValue = GetExpression();
                g_TypedExpr = FALSE;
                g_CurCmd = SaveCurCmd;
            }

            if (SymInternal->Flags & SYMF_REGISTER) 
            {
                g_Machine->SetReg64((ULONG) SymInternal->Register,
                                    ChangedValue);
            }
            else if (SymInternal->Name.Buffer[0] == '&')
            {
                SymInternal->Address = ChangedValue;
            }
            else
            {
                ULONG64 Reg = SymInternal->Register, OrigValue;
                TranslateAddress(SymInternal->Flags & ADDRESS_TRANSLATION_MASK,
                                 SymInternal->Register,
                                 &WriteAddress,
                                 &Reg);
                
                // Mask the value if its a bitfield
                if (SymInternal->Mask) 
                {
                    Status = g_Target->ReadVirtual(WriteAddress, 
                                                   (PVOID)&OrigValue, 
                                                    SymInternal->Size, // size is byte aligned from writeaddress
                                                    &BytesWritten);
                    OrigValue &= ~(SymInternal->Mask << SymInternal->Shift);
                    ChangedValue = OrigValue | ((ChangedValue & SymInternal->Mask) << SymInternal->Shift);

                }

                Status = g_Target->WriteVirtual(WriteAddress, 
                                                (PVOID)&ChangedValue, 
                                                SymInternal->Size,
                                                &BytesWritten);
            }
        }
        __except(CommandExceptionFilter(GetExceptionInformation()))
        {
            Status = E_FAIL;
        }                
    }

 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugSymbolGroup::OutputAsType(
    THIS_
    IN ULONG Index,
    IN PCSTR Type
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    Status = E_INVALIDARG;

    PDEBUG_SYMBOL_PARAMETERS_INTERNAL SymInternal;
    
    SymInternal = LookupSymbolParameter(Index);
    if (SymInternal && Type)
    {
        Status = ResolveTypecast((PCHAR) Type, SymInternal);
    }
Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugSymbolGroup::ShowAll(
    THIS
    )
{
    ULONG i;
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL loop = m_pSymParams;

    ENTER_ENGINE();
    dprintf("Total %d syms\n", m_NumParams);
    dprintf("Idx Sub   TI ExFlags  Par ExpIdx ExpAddress Expdd Flag  Address Off Name\n");
    while (loop)
    {
        dprintf64("%2lx:%4lx %4lx%8lx %4lx %6lx  %p  %5lx %4lx %p %03I64lx %s\n",
            loop->SymbolIndex,
            loop->External.SubElements,
            loop->TypeIndex,
            loop->External.Flags,
            loop->External.ParentSymbol,
            loop->ExpandTypeIndex,
            loop->ExpandTypeAddress,
            loop->Expanded,
            loop->Flags,
            loop->Address,
            loop->Offset,
            loop->Name.Buffer
            );
        loop = loop->Next;
    }
    LEAVE_ENGINE();
    return S_OK;
}

//
// Private DebugSymbolGroup methods
//
PDEBUG_SYMBOL_PARAMETERS_INTERNAL 
DebugSymbolGroup::LookupSymbolParameter(
    IN ULONG Index
    ) 
{
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL list = m_pSymParams;
    while (list != NULL)
    {
        if (list->SymbolIndex == Index)
        {
            return list;
        }
        list = list->Next;
    }
    return list;
}

PDEBUG_SYMBOL_PARAMETERS_INTERNAL 
DebugSymbolGroup::LookupSymbolParameter(
    IN PCSTR Name
    ) 
{
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL list = m_pSymParams;
    while (list != NULL)
    {
        if ((list->External.ParentSymbol == list->SymbolIndex) &&
            !strcmp(list->Name.Buffer, Name))
        {
            return list;
        }
        list = list->Next;
    }
    return list;
}


HRESULT
DebugSymbolGroup::AddOneSymbol(
    IN PCSTR Name,
    IN PSYMBOL_INFO pSymInfo,
    OUT PULONG Index
    )
{
    SYM_DUMP_PARAM_EX Sym={0};
    TYPES_INFO     typeInfo={0};
    DEBUG_SYMBOL_PARAMETERS_INTERNAL SymParams={0};
    CHAR    MatchName[MAX_NAME]={0};
    ULONG64 Addr=0;
    PUCHAR  savepch;
    HRESULT Status=S_OK;
    ULONG   SymbolScope = 0;
    BOOL    NameIsExpression;

    strcpy(MatchName, Name);
    if (isdigit(MatchName[0]) || 
        (MatchName[0] == '@') // Register
        ) 
    {
        Addr = ExtGetExpression(Name);
        NameIsExpression = TRUE;
    } else
    {
        NameIsExpression = FALSE;
        Sym.sName = (PUCHAR) Name;
        Sym.addr = 0;
    }


    Sym.Options = NO_PRINT;
    Sym.size = sizeof(SYM_DUMP_PARAM_EX);
    typeInfo.Name.Length = typeInfo.Name.MaximumLength = MAX_NAME;
    typeInfo.Name.Buffer = MatchName;

    if (strlen(Name))
    {
        if (pSymInfo || Addr)
        {

            if (pSymInfo) 
            {
                typeInfo.SymAddress = pSymInfo->Address;
                typeInfo.hProcess   = g_CurrentProcess->Handle;
                typeInfo.Flag       = pSymInfo->Flags;
                typeInfo.TypeIndex  = pSymInfo->TypeIndex;
                typeInfo.Value      = pSymInfo->Register;
                typeInfo.ModBaseAddress = pSymInfo->ModBase;
            } else if (strlen(Name) < MAX_NAME) {
                strcpy(MatchName, Name);
                SymParams.Name.Length = SymParams.Name.MaximumLength = strlen(MatchName) +1;
            }

            SymParams.Address = (Addr ? Addr : typeInfo.SymAddress);

            SymParams.External.Module = typeInfo.ModBaseAddress;
            SymParams.Name            = typeInfo.Name;
            SymParams.TypeIndex       = typeInfo.TypeIndex;
            SymParams.External.TypeId = typeInfo.TypeIndex;
            SymParams.Flags           = typeInfo.Flag & (ADDRESS_TRANSLATION_MASK | SYMBOL_SCOPE_MASK);
            SymParams.Register        = (ULONG) typeInfo.Value;
            SymParams.Expanded = FALSE;
            SymParams.External.Flags = DEBUG_SYMBOL_READ_ONLY;
            SymParams.External.SubElements  = 0;
            
            Sym.Options = DBG_RETURN_TYPE | NO_PRINT ;

            FIND_TYPE_INFO Info;
            Info.Flags = DBG_RETURN_TYPE ;
            Info.InternalParams = &SymParams; Info.nParams = 1;
            
            DumpTypeAndReturnInfo(&typeInfo, &Sym, (PULONG) &Status, &Info);
            if (Status)
            {
                SymParams.TypeIndex = 0;
                Status = E_INVALIDARG;
            }
            if (SymParams.Size)
            {
                SymParams.External.Flags &= ~DEBUG_SYMBOL_READ_ONLY;
            }
            if (NameIsExpression) {
                // Just an address value was given, display the error
                // but remember that value was address only
                SymParams.Flags |= SYMBOL_IS_EXPRESSION;
            }

        } else {
            TYPES_INFO_ALL typ;
            
            strcpy(MatchName, Name);
            SymParams.Name.Buffer = (PCHAR) MatchName;
            SymParams.Name.Length = SymParams.Name.MaximumLength = strlen(MatchName) +1;

            if (Name && *Name && GetExpressionTypeInfo((PCHAR) Name, &typ)) 
            {
                TypToParam(&typ, &SymParams);
                Status = E_FAIL;
            } else
            {
                Status = E_INVALIDARG;
                strcpy(MatchName, Name);
                SymParams.Name.Buffer = (PCHAR) MatchName;
                SymParams.Name.Length = SymParams.Name.MaximumLength = strlen(MatchName) +1;
            }
        }
        if (*Index > m_NumParams) *Index = m_NumParams;
        SymParams.External.ParentSymbol = *Index;
        
        //
        // Check if this symbol falls within the symbolgroup scope
        //
        if (m_ScopeGroup == DEBUG_SCOPE_GROUP_ARGUMENTS) 
        {
            if (!(SymParams.Flags & SYMF_PARAMETER))
            {
                Status = E_INVALIDARG;
                SymParams.TypeIndex = 0;
            }
        } else if (m_ScopeGroup == DEBUG_SCOPE_GROUP_LOCALS) 
        {
            if (!(SymParams.Flags & SYMF_LOCAL))
            {
                Status = E_INVALIDARG;
                SymParams.TypeIndex = 0;
            }
        }
        
        if (SymParams.Flags & IMAGEHLP_SYMBOL_INFO_PARAMETER) 
        {
            SymParams.Flags &= ~IMAGEHLP_SYMBOL_INFO_PARAMETER;
            SymParams.External.Flags |= DEBUG_SYMBOL_IS_ARGUMENT;
        }

        if (SymParams.Flags & IMAGEHLP_SYMBOL_INFO_LOCAL) 
        {
            SymParams.Flags &= ~IMAGEHLP_SYMBOL_INFO_LOCAL;
            SymParams.External.Flags |= DEBUG_SYMBOL_IS_LOCAL;
        }

        if (!strcmp(Name, "this")) 
        {
            GetThisAdjustForCurrentScope(&m_thisAdjust);
            SymParams.ExpandTypeAddress -= m_thisAdjust;
        }
        AddSymbolParameters(*Index, 1, &SymParams);
    } else
    {
        // Null, no need to add

        Status = E_INVALIDARG;
    }
#ifdef DBG_SYMGROUP_ENABLED
    dprintf("Added  %s at %lx\n", Name, *Index);
    ShowAll();
#endif 
    return Status;
}

BOOL
DebugSymbolGroup::IsRootSymbol(
    IN ULONG Index
    )
{
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL Sym;

    Sym = LookupSymbolParameter( Index );
    if (Sym  && (Sym->External.ParentSymbol == Index))
    {
        return TRUE;
    }
    return FALSE;
}

ULONG 
DebugSymbolGroup::FindSortedIndex (
    IN PCSTR Name,
    IN BOOL    IsArg,
    IN ULONG64 Address
    )
{
    ULONG Index;
    BOOL  Found=FALSE;
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL Sym;


    for (Index=0; Index<m_NumParams && !Found; Index++) { 
        
        if (!IsRootSymbol(Index)) {
            continue;
        }
        Sym = LookupSymbolParameter( Index );

    
        if ((Sym->External.Flags & DEBUG_SYMBOL_IS_ARGUMENT) || IsArg)
        {
            if ((Sym->External.Flags & DEBUG_SYMBOL_IS_ARGUMENT) && IsArg) 
            {
                Found = ((LONG64) Sym->Address) > (LONG64) Address;
            } else if (IsArg)
            {
                Found = TRUE;
            }
        } else {
            Found = _stricmp(Sym->Name.Buffer, Name) > 0;
        }

    }
    return Found ? (Index-1) : m_NumParams;
}


VOID
DebugSymbolGroup::ResetIndex(
    IN PDEBUG_SYMBOL_PARAMETERS_INTERNAL Start,
    IN ULONG StartIndex
    )
{
    ULONG OrigIndex;
    LONG  difference;

    if (!Start) return;
    OrigIndex = Start->SymbolIndex;
    difference = (LONG) StartIndex - OrigIndex;
    while (Start!=NULL)
    {
        if (Start->External.ParentSymbol >= OrigIndex)
        {
            Start->External.ParentSymbol = (ULONG) ((LONG) Start->External.ParentSymbol + difference);
        }
        Start->SymbolIndex = StartIndex++;
        Start = Start->Next;
    }
}

ULONG
DebugSymbolGroup::AddSymbolParameters(
    IN ULONG Index,
    IN ULONG Count,
    IN PDEBUG_SYMBOL_PARAMETERS_INTERNAL SymbolParam
    )
{
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL start, newSym, last;
    PCHAR Name;
    CHAR Module[MAX_MODULE];

    if (!Index || !m_pSymParams)
    {
        // add at begining
        last = m_pSymParams;
        start = NULL;
    } else
    {
        start = LookupSymbolParameter(Index-1);
        if (!start)
        {
            return FALSE;
        }
        last = start->Next;
    }

    while (Count)
    {
        ULONG ModNameLen, NameLen;

        if (GetModuleName(SymbolParam->External.Module, &Module[0], MAX_MODULE)) 
        {
            ModNameLen = strlen(Module) + 1; // For '!'
        } else 
        {
            ModNameLen = 0;
        }
        Module[ModNameLen] = '\0';

        NameLen = strlen(SymbolParam->Name.Buffer);
        if (!((newSym = (PDEBUG_SYMBOL_PARAMETERS_INTERNAL) 
                    malloc(sizeof(DEBUG_SYMBOL_PARAMETERS_INTERNAL))) &&
              (Name = (PCHAR) malloc(NameLen + ModNameLen + 1))))
        {
            if (newSym) {
                free(newSym);
            }

            if (start) 
            {
                start->Next = last;
            }
            ResetIndex(last, Index);
            return FALSE;
        }
        
        if (start) 
        {
            start->Next = newSym;
        }
        else 
        {
            m_pSymParams = newSym;
        }

        *newSym = *SymbolParam;
        *Name = 0;
        if (ModNameLen && !strchr(SymbolParam->Name.Buffer, '!') && 
            !m_Locals && 
            !(SymbolParam->External.Flags & DEBUG_SYMBOL_EXPANSION_LEVEL_MASK) &&
            !(SymbolParam->Flags & SYMBOL_IS_EXPRESSION))
        {
            // Unqualified symbol
            strcpy(Name, Module);
            strcat(Name, "!");
        }
        strncat(Name, SymbolParam->Name.Buffer, NameLen);
        newSym->Name.Buffer = Name;
        newSym->Name.Length = newSym->Name.MaximumLength = 
            (USHORT) (NameLen + ModNameLen);
        newSym->SymbolIndex = Index++;

        start = newSym;
        SymbolParam++;
        ++m_NumParams;
        Count--;
    }
    if (start) 
    {
        start->Next = last;
    }
    ResetIndex(last, Index);
    return TRUE;
}


ULONG
DebugSymbolGroup::DeleteSymbolParam(
    IN ULONG Index,
    IN ULONG Count
    ) 
{
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL prev=NULL, delSym, next, freeSym;
    PCHAR Name;
    ULONG MaxDelIndex = Index + Count - 1;
    BOOL  HeadDeleted = FALSE;
    BOOL  DeleteChildren = Count == 0;

    if (!m_pSymParams)
    {
        return TRUE;
    }
#ifdef DBG_SYMGROUP_ENABLED
    dprintf("DeleteSymbolParam(%lx, %lx) :\n", Index, Count);
    ShowAll();
#endif
    if (!DeleteChildren)
    {
        if (Index==0)
        {
            delSym = m_pSymParams;
            next = LookupSymbolParameter(Index + Count);
            HeadDeleted = TRUE;
        } else
        {
            prev = LookupSymbolParameter(Index - 1);
            next = LookupSymbolParameter(Index + Count);
            if (!prev)
            {
                return FALSE;
            }
            delSym = LookupSymbolParameter(Index);
            if (!delSym)
            {
                return FALSE;
            }
        }

        if (delSym->SymbolIndex != Index)
        {
            return FALSE;
        }

        while (Count && delSym)
        {
            Name = delSym->Name.Buffer;
            freeSym = delSym;
            delSym = delSym->Next;
            Count--;
            assert(m_NumParams);
            m_NumParams--;
#ifdef DBG_SYMGROUP_ENABLED
            dprintf("Removed %s at %lx, %lx remaining.\n", Name, freeSym->SymbolIndex, m_NumParams);
#endif
            if (freeSym->DataBuffer && (freeSym->Flags & SYMBOL_IS_EXTENSION)) 
            {
                free( freeSym->DataBuffer );
            }
            free(Name);
            free(freeSym);
        }
    } else
    {
        prev = LookupSymbolParameter(Index);
        next = LookupSymbolParameter(Index + 1);
        MaxDelIndex = Index;
    }

    // clean up parent-less entries
    while (next && (next->External.ParentSymbol >= Index) && 
        next->External.ParentSymbol <= MaxDelIndex)
    {
        Name = next->Name.Buffer;
        freeSym = next;
        next = freeSym->Next;
        MaxDelIndex++;
        assert(m_NumParams);
        m_NumParams--;
#ifdef DBG_SYMGROUP_ENABLED
        dprintf("Removed child %s at %lx, %lx remaining.\n", Name, freeSym->SymbolIndex, m_NumParams);
#endif
        if (freeSym->DataBuffer && (freeSym->Flags & SYMBOL_IS_EXTENSION)) 
        {
            free( freeSym->DataBuffer );
        }
        free(Name);
        free(freeSym);
    }
    if (HeadDeleted)
    {
        m_pSymParams = next;
    }
    if (prev)
    {
        prev->Next = next;
    }
    ResetIndex(next, (DeleteChildren ? (Index+1) : Index));
    return TRUE;
}

HRESULT 
DebugSymbolGroup::AddCurrentLocals()
{
    HRESULT Status = S_OK; 
    // Always return success since this reqiest is processed even if we didn't add anything

    RequireCurrentScope();
    
    GetThisAdjustForCurrentScope(&m_thisAdjust);

    if (EnumerateLocals(AddLocals, (PVOID) this)) 
    {
    }
    
    ULONG Index;

    for (Index = 0; Index < m_NumParams; Index++)
    { 
        if (IsRootSymbol(Index))
        {
            PDEBUG_SYMBOL_PARAMETERS_INTERNAL Sym;

            Sym = LookupSymbolParameter(Index);
            
            if (!Sym) // Or assert (Sym) ??
            {
                continue;
            }
            if (!(Sym->Flags & SYMBOL_IS_IN_SCOPE))
            {
                DeleteSymbolParam(Index,1);
                --Index;
            }
            else
            {
                Sym->Flags &= ~SYMBOL_IS_IN_SCOPE;
            }

        }
    }

    KeepLastScopeClass(NULL, NULL, 0);

    return Status;
}

HRESULT 
DebugSymbolGroup::ResetCurrentLocals()
{
    return S_OK;
}

void 
DebugSymbolGroup::KeepLastScopeClass(
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL Sym_this,
    PCHAR ExpansionState,
    ULONG NumChilds
    )
{
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL temp = LookupSymbolParameter("this");

    if (temp)
    {
        ULONG thisIndex = temp->SymbolIndex;

        if (m_LastClassExpanded) 
        {
            ExpandSymPri(thisIndex, TRUE);
        }
    }
}

HRESULT
DebugSymbolGroup::ExpandSymPri(
    THIS_
    IN ULONG Index,
    IN BOOL Expand
    )
{
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL Parent;
    HRESULT hr = S_OK;
    
    Parent = LookupSymbolParameter(Index);
#ifdef DBG_SYMGROUP_ENABLED
    dprintf("Enpanding %lx (%lx to be %s)\n", Parent->SymbolIndex, Parent->External.SubElements,
        Expand ? "created" : "deleted");
    ShowAll();
#endif

    if (!Parent)
    {
        hr = E_INVALIDARG;
        goto ExitExpandSymbol;
    }
    
    //
    // Special case - check and store if "this" is expanded/collapsed
    //
    if (!strcmp(Parent->Name.Buffer, "this")) 
    {
        m_LastClassExpanded = Expand;
    }

    if (!Expand && Parent->Expanded)
    {
        if (DeleteSymbolParam(Index, 0))
        {
            Parent->Expanded = FALSE;
            Parent->External.Flags &= ~DEBUG_SYMBOL_EXPANDED;
            hr = S_OK;
        }
    } else if (Expand)
    {
        PDEBUG_SYMBOL_PARAMETERS_INTERNAL SubTypes = NULL;
        ULONG Count;
        PCHAR Names = NULL;

        if (Parent->Expanded || !Parent->External.SubElements)
        {
            hr = S_OK;
            goto ExitExpandSymbol;
        }

        hr = FindChildren(Parent, &SubTypes, &Count, &Names);

        if ((hr == S_OK) && Parent->External.SubElements)
        {
            AddSymbolParameters(Parent->SymbolIndex+1, Parent->External.SubElements, SubTypes);
            Parent->External.Flags |= DEBUG_SYMBOL_EXPANDED;
            Parent->Expanded = TRUE;
        }
        if (Names) free (Names);
        if (SubTypes) free (SubTypes);

    }
ExitExpandSymbol:    
#ifdef DBG_SYMGROUP_ENABLED
        dprintf("Enpanded %lx (%lx %s)\n", Parent->SymbolIndex, Parent->External.SubElements,
        Parent->Expanded ? "new" : "deleted");
    ShowAll();
#endif
    return hr;
}

//
//   Returns children of the given symbol
// 
//      pParentSym     : Symbol whose chilren need to be looked up
//
//      pChildren      : Array in which info about children is returned
//                       Caller is responsible for freeig the memory pointed to by this
//
//      pChildCount    : Number of children returned
//
//      pChildNames    : Array of Char[MAX_NAME] containing the children names
//                       Caller is responsible for freeig the memory pointed to by this
//                       
HRESULT
DebugSymbolGroup::FindChildren(
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL pParentSym,
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL *pChildren,
    PULONG pChildCount,
    PCHAR *pChildNames
    )
{
    HRESULT Status = E_FAIL;
    TYPE_DUMP_INTERNAL tdi={0};
    TYPES_INFO         ti = {0};
    SYM_DUMP_PARAM_EX     Sym={0};
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL SubTypes;
    ULONG i;
    PCHAR Names;
    BOOL Success;

    if (pParentSym->Flags & SYMBOL_IS_EXTENSION) 
    {
        return FindChildrenForExtensionSym(pParentSym, pChildren, pChildCount, pChildNames);
    }
    do {

        SubTypes = (PDEBUG_SYMBOL_PARAMETERS_INTERNAL) malloc(
            pParentSym->External.SubElements * sizeof( DEBUG_SYMBOL_PARAMETERS_INTERNAL ));
        Names    = (PCHAR) malloc(pParentSym->External.SubElements * MAX_DISPLAY_NAME);

        if (!SubTypes || !Names)
        {
            if (Names) free (Names);
            if (SubTypes) free (SubTypes);
            Status = E_OUTOFMEMORY;
            break;
        }

        ZeroMemory(SubTypes, pParentSym->External.SubElements * sizeof( DEBUG_SYMBOL_PARAMETERS_INTERNAL));

        for (i=0;i<pParentSym->External.SubElements; i++)
        {
            SubTypes[i].External.ParentSymbol = pParentSym->SymbolIndex;
            SubTypes[i].External.Flags        = DEBUG_SYMBOL_READ_ONLY | 
                                            ((UCHAR) pParentSym->External.Flags + 1);
            SubTypes[i].Expanded              = FALSE;
            SubTypes[i].External.Module       = pParentSym->External.Module;
            SubTypes[i].Parent                = pParentSym;
            SubTypes[i].Size                  = 0;
            SubTypes[i].Name.Length           = SubTypes[i].Name.MaximumLength = MAX_DISPLAY_NAME;
            SubTypes[i].Name.Buffer           = &Names[MAX_DISPLAY_NAME*i];
            SubTypes[i].Flags                 = (pParentSym->Flags & DBG_DUMP_FIELD_STRING);
        }
        Sym.size = sizeof(SYM_DUMP_PARAM_EX);
        Sym.Context = (PVOID) &SubTypes;
        Sym.addr = 0;//pParentSym->ExpandTypeAddress;
        if (pParentSym->Flags & TYPE_NAME_USED) 
        {
            Sym.sName = (PUCHAR) &pParentSym->TypeName[0];
        } else {
            Sym.sName = (PUCHAR) pParentSym->Name.Buffer;
        }

        tdi.TypeOptions = Sym.Options = DBG_RETURN_SUBTYPES | NO_PRINT ;
        Sym.Options = NO_PRINT ;
        tdi.pSymParams = SubTypes;
        tdi.NumSymParams = pParentSym->External.SubElements;
        tdi.level = 0;
        tdi.CopyName = 1;
        tdi.CurrentSymParam = 0;
        ti.hProcess = tdi.hProcess = g_CurrentProcess->Handle;
        ti.ModBaseAddress = tdi.modBaseAddr = pParentSym->External.Module;
        ti.TypeIndex = pParentSym->TypeIndex;
        ti.Value = pParentSym->Register;
        ti.Flag = pParentSym->Flags & ADDRESS_TRANSLATION_MASK;
        ti.SymAddress = pParentSym->Address;

        FIND_TYPE_INFO Info = {0};
        Info.Flags = DBG_RETURN_SUBTYPES ;
        Info.InternalParams = SubTypes; Info.nParams = pParentSym->External.SubElements;

        DumpTypeAndReturnInfo(&ti, &Sym, (PULONG) &tdi.ErrorStatus, &Info);

        Success = TRUE;
        Status = S_OK;

        if (Info.nParams <= pParentSym->External.SubElements)
        {
            pParentSym->External.SubElements = Info.nParams;
            pParentSym->ExpandTypeAddress = Info.ParentExpandAddress;
        } else {
            // We are getting more subtypes than extected, try again
            if (Names) free (Names);
            if (SubTypes) free (SubTypes);

            pParentSym->External.SubElements = Info.nParams;
            Success = FALSE;
        }

    } while (!Success);


    if (pParentSym->Name.Buffer && !strcmp(pParentSym->Name.Buffer, "this")) {
        pParentSym->ExpandTypeAddress -= m_thisAdjust;
    }
    for (i=0;i<pParentSym->External.SubElements; i++)
    {
        if (SubTypes[i].Size)
        {
            SubTypes[i].External.Flags &= ~DEBUG_SYMBOL_READ_ONLY;
        }
        SubTypes[i].Offset = SubTypes[i].Address - pParentSym->ExpandTypeAddress;
    }

    *pChildNames = Names;
    *pChildCount = pParentSym->External.SubElements;
    *pChildren   = SubTypes;

    return Status;
}

BOOL
AreEquivAddress(
    ULONG64 Addr1,
    ULONG   Addr1Flags,
    ULONG   Addr1Reg,
    ULONG64 Addr2,
    ULONG   Addr2Flags,
    ULONG   Addr2Reg
    )
{
    ULONG64 Value1,Value2;
    if (Addr1Flags & SYMF_REGISTER) 
    {
        if (Addr2Flags & SYMF_REGISTER) 
        {
            return (Addr1Reg == Addr2Reg);
        }

        return FALSE;
    }

    TranslateAddress(Addr1Flags, Addr1Reg, &Addr1, &Value1);
    TranslateAddress(Addr2Flags, Addr2Reg, &Addr2, &Value2);

    return (Addr1 == Addr2);
}

BOOL CALLBACK DebugSymbolGroup::AddLocals(
    PSYMBOL_INFO    pSymInfo,
    ULONG           Size,
    PVOID           Context
    )
{
    ULONG Index = -1;
    DebugSymbolGroup *Caller = (DebugSymbolGroup *) Context;

    if (Caller)
    {
        PDEBUG_SYMBOL_PARAMETERS_INTERNAL pSym;

        pSym = Caller->LookupSymbolParameter(pSymInfo->Name);
        
        if (pSym) {
            if (((pSym->TypeIndex == pSymInfo->TypeIndex) || // Its same type
                 (pSym->Flags & TYPE_NAME_MASK)) &&  // Type may be different if it was a typecast
                pSym->External.Module == pSymInfo->ModBase &&
                AreEquivAddress(pSym->Address,
                                pSym->Flags & ADDRESS_TRANSLATION_MASK, 
                                pSym->Register,
                                pSymInfo->Address, 
                                pSymInfo->Flags & ADDRESS_TRANSLATION_MASK, 
                                pSymInfo->Register)) {

                // This is the same symbol 
                pSym->Flags |= SYMBOL_IS_IN_SCOPE;
                return TRUE;
            }

        }
        BOOL IsArg = FALSE;

        if (pSymInfo->Flags & SYMF_PARAMETER)
        {
            IsArg = TRUE;
        }
        Index = Caller->FindSortedIndex(pSymInfo->Name, IsArg, pSymInfo->Address);

//        dprintf("%lx : Adding %s %s \n", Index, IsArg ? "arg" : "   ", pSymInfo->Name);
        
        if (Caller->AddOneSymbol(pSymInfo->Name, pSymInfo, &Index) == S_OK) 
        {
            pSym = Caller->LookupSymbolParameter(Index);
            if (pSym) // should it be assert (pSym) ???
            {
                pSym->Flags |= SYMBOL_IS_IN_SCOPE;
                pSym->External.Flags |= IsArg ? DEBUG_SYMBOL_IS_ARGUMENT : 0;
            }
        }
        
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\dumpwrite.cpp ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    dumpwrite.cpp

Abstract:

    This module implements crashdump writing code.

--*/

#include "ntsdp.hpp"

#include <dbgver.h>
#include <bugcodes.h>

// XXX drewb - Should go in machine.hpp.
#define PAGE_ALIGN(Machine, Addr) \
    ((Addr) & ~((ULONG64)((Machine)->m_PageSize - 1)))

// Internal format flag for testing of microdumps.  This
// will not be made into a public flag and must not conflict
// with them.
#define FORMAT_USER_MICRO 0x80000000

//----------------------------------------------------------------------------
//
// UserFullDumpTargetInfo::Write.
//
//----------------------------------------------------------------------------

#define USER_DUMP_MEMORY_BUFFER 65536

struct CREATE_USER_DUMP_STATE
{
    PTHREAD_INFO Thread;
    PDEBUG_IMAGE_INFO Image;
    ULONG64 MemHandle;
    HANDLE  DumpFileHandle;
    MEMORY_BASIC_INFORMATION64 MemInfo;
    MEMORY_BASIC_INFORMATION32 MemInfo32;
    ULONG64 MemBufDone;
    UCHAR MemBuf[USER_DUMP_MEMORY_BUFFER];
};

BOOL WINAPI
CreateUserDumpCallback(
    ULONG       DataType,
    PVOID*      Data,
    PULONG      DataLength,
    PVOID       UserData
    )
{
    CREATE_USER_DUMP_STATE* State = (CREATE_USER_DUMP_STATE*)UserData;
    PTHREAD_INFO Thread;

    switch(DataType)
    {
    case DMP_DUMP_FILE_HANDLE:
        *Data = State->DumpFileHandle;
        *DataLength = sizeof(HANDLE);
        break;

    case DMP_DEBUG_EVENT:
        static DEBUG_EVENT Event;
        ADDR PcAddr;

        //
        // Fake up an exception event for the current thread.
        //
        
        ZeroMemory(&Event, sizeof(Event));

        g_Machine->GetPC(&PcAddr);
        
        Event.dwDebugEventCode = EXCEPTION_DEBUG_EVENT;
        Event.dwProcessId = g_CurrentProcess->SystemId;
        Event.dwThreadId = g_CurrentProcess->CurrentThread->SystemId;
        if (g_LastEventType == DEBUG_EVENT_EXCEPTION)
        {
            // Use the exception record from the last exception.
            ExceptionRecord64To(&g_LastEventInfo.Exception.ExceptionRecord,
                                &Event.u.Exception.ExceptionRecord);
            Event.u.Exception.dwFirstChance =
                g_LastEventInfo.Exception.FirstChance;
        }
        else
        {
            // Fake a breakpoint exception.
            Event.u.Exception.ExceptionRecord.ExceptionCode =
                STATUS_BREAKPOINT;
            Event.u.Exception.ExceptionRecord.ExceptionAddress =
                (PVOID)(ULONG_PTR)Flat(PcAddr);
            Event.u.Exception.dwFirstChance = TRUE;
        }

        *Data = &Event;
        *DataLength = sizeof(DEBUG_EVENT);
        break;

    case DMP_THREAD_STATE:
        static CRASH_THREAD CrashThread;
        ULONG64 Teb64;

        if (State->Thread == NULL)
        {
            Thread = g_CurrentProcess->ThreadHead;
        }
        else
        {
            Thread = State->Thread->Next;
        }
        State->Thread = Thread;
        if (Thread == NULL)
        {
            return FALSE;
        }

        ZeroMemory(&CrashThread, sizeof(CrashThread));

        CrashThread.ThreadId = Thread->SystemId;
        CrashThread.SuspendCount = Thread->SuspendCount;
        if (IS_LIVE_USER_TARGET())
        {
            if (g_TargetClassQualifier == DEBUG_USER_WINDOWS_PROCESS_SERVER)
            {
                // The priority information isn't important
                // enough to warrant remoting.
                CrashThread.PriorityClass = NORMAL_PRIORITY_CLASS;
                CrashThread.Priority = THREAD_PRIORITY_NORMAL;
            }
            else
            {
                CrashThread.PriorityClass =
                    GetPriorityClass(g_CurrentProcess->Handle);
                CrashThread.Priority =
                    GetThreadPriority(OS_HANDLE(Thread->Handle));
            }
        }
        else
        {
            CrashThread.PriorityClass = NORMAL_PRIORITY_CLASS;
            CrashThread.Priority = THREAD_PRIORITY_NORMAL;
        }
        if (g_Target->GetThreadInfoDataOffset(Thread, NULL, &Teb64) != S_OK)
        {
            Teb64 = 0;
        }
        CrashThread.Teb = (DWORD_PTR)Teb64;

        *Data = &CrashThread;
        *DataLength = sizeof(CrashThread);
        break;

    case DMP_MEMORY_BASIC_INFORMATION:
        if (g_Target->QueryMemoryRegion(&State->MemHandle, FALSE,
                                        &State->MemInfo) != S_OK)
        {
            State->MemHandle = 0;
            State->MemInfo.RegionSize = 0;
            return FALSE;
        }

#ifdef _WIN64
        *Data = &State->MemInfo;
        *DataLength = sizeof(State->MemInfo);
#else
        State->MemInfo32.BaseAddress = (ULONG)State->MemInfo.BaseAddress;
        State->MemInfo32.AllocationBase = (ULONG)State->MemInfo.AllocationBase;
        State->MemInfo32.AllocationProtect = State->MemInfo.AllocationProtect;
        State->MemInfo32.RegionSize = (ULONG)State->MemInfo.RegionSize;
        State->MemInfo32.State = State->MemInfo.State;
        State->MemInfo32.Protect = State->MemInfo.Protect;
        State->MemInfo32.Type = State->MemInfo.Type;
        *Data = &State->MemInfo32;
        *DataLength = sizeof(State->MemInfo32);
#endif
        break;

    case DMP_THREAD_CONTEXT:
        if (State->Thread == NULL)
        {
            Thread = g_CurrentProcess->ThreadHead;
        }
        else
        {
            Thread = State->Thread->Next;
        }
        State->Thread = Thread;
        if (Thread == NULL)
        {
            ChangeRegContext(g_CurrentProcess->CurrentThread);
            return FALSE;
        }

        ChangeRegContext(Thread);
        if (g_Machine->GetContextState(MCTX_CONTEXT) != S_OK)
        {
            ErrOut("Unable to retrieve context for thread %d. "
                   "Dump may be corrupt", Thread->UserId);
            return FALSE;
        }

        *Data = &g_Machine->m_Context;
        *DataLength = g_Machine->m_SizeTargetContext;
        break;

    case DMP_MODULE:
        static ULONG64 ModuleBuffer[(sizeof(CRASH_MODULE) + MAX_MODULE +
                                     sizeof(ULONG64) - 1) / sizeof(ULONG64)];
        PCRASH_MODULE Module;
        PDEBUG_IMAGE_INFO Image;

        if (State->Image == NULL)
        {
            Image = g_CurrentProcess->ImageHead;
        }
        else
        {
            Image = State->Image->Next;
        }
        State->Image = Image;
        if (Image == NULL)
        {
            return FALSE;
        }

        Module = (PCRASH_MODULE)ModuleBuffer;
        Module->BaseOfImage = (DWORD_PTR)Image->BaseOfImage;
        Module->SizeOfImage = Image->SizeOfImage;
        Module->ImageNameLength = strlen(Image->ModuleName) + 1;
        strcpy(Module->ImageName, Image->ModuleName);

        *Data = Module;
        *DataLength = sizeof(*Module) + Module->ImageNameLength;
        break;

    case DMP_MEMORY_DATA:
        ULONG64 Left;

        Left = State->MemInfo.RegionSize - State->MemBufDone;
        if (Left == 0)
        {
            State->MemBufDone = 0;
            if (g_Target->QueryMemoryRegion(&State->MemHandle, FALSE,
                                            &State->MemInfo) != S_OK)
            {
                State->MemHandle = 0;
                State->MemInfo.RegionSize = 0;
                return FALSE;
            }

            Left = State->MemInfo.RegionSize;
        }

        ULONG Read;

        if (Left > USER_DUMP_MEMORY_BUFFER)
        {
            Left = USER_DUMP_MEMORY_BUFFER;
        }
        if (g_Target->ReadVirtual(State->MemInfo.BaseAddress +
                                  State->MemBufDone, State->MemBuf,
                                  (ULONG)Left, &Read) != S_OK ||
            Read < Left)
        {
            ErrOut("ReadVirtual failed. Dump may be corrupt\n");
            return FALSE;
        }

        State->MemBufDone += Read;

        *Data = State->MemBuf;
        *DataLength = Read;
        break;
    }

    return TRUE;
}

HRESULT
UserFullDumpTargetInfo::Write(HANDLE hFile, ULONG FormatFlags, PCSTR Comment)
{
    dprintf("user full dump\n");
    FlushCallbacks();

    if (!IS_LIVE_USER_TARGET())
    {
        ErrOut("User full dumps can only be written in "
               "live user-mode sessions\n");
        return E_UNEXPECTED;
    }
    if (Comment != NULL)
    {
        ErrOut("User full dumps do not support comments\n");
        return E_INVALIDARG;
    }
    
    CREATE_USER_DUMP_STATE* State;

    State = (CREATE_USER_DUMP_STATE*)calloc(1, sizeof(*State));
    if (State == NULL)
    {
        ErrOut("Unable to allocate memory for dump state\n");
        return E_OUTOFMEMORY;
    }
    
    State->DumpFileHandle = hFile;

    HRESULT Status;
    
    if (!DbgHelpCreateUserDump(NULL, CreateUserDumpCallback, State))
    {
        Status = WIN32_LAST_STATUS();
        ErrOut("Dump creation failed, %s\n    \"%s\"\n",
               FormatStatusCode(Status), FormatStatus(Status));
    }
    else
    {
        Status = S_OK;
    }

    free(State);
    return Status;
}

//----------------------------------------------------------------------------
//
// UserMiniDumpTargetInfo::Write.
//
//----------------------------------------------------------------------------

PMINIDUMP_EXCEPTION_INFORMATION
CreateMiniExceptionInformation(PMINIDUMP_EXCEPTION_INFORMATION ExInfo,
                               PEXCEPTION_POINTERS ExPointers,
                               PEXCEPTION_RECORD ExRecord)
{
    // If the last event was an exception put together
    // exception information in minidump format.
    if (g_LastEventType != DEBUG_EVENT_EXCEPTION ||
        g_CurrentProcess != g_EventProcess)
    {
        return NULL;
    }

    // Get the full context for the event thread.
    ChangeRegContext(g_EventThread);
    if (g_Machine->GetContextState(MCTX_CONTEXT) != S_OK)
    {
        return NULL;
    }
    
    ExInfo->ThreadId = g_EventThreadSysId;
    ExInfo->ExceptionPointers = ExPointers;
    ExInfo->ClientPointers = FALSE;
    ExPointers->ExceptionRecord = ExRecord;
    ExceptionRecord64To(&g_LastEventInfo.Exception.ExceptionRecord, ExRecord);
    ExPointers->ContextRecord = (PCONTEXT)&g_Machine->m_Context;
    
    return ExInfo;
}

BOOL WINAPI
MicroDumpCallback(
    IN PVOID CallbackParam,
    IN CONST PMINIDUMP_CALLBACK_INPUT CallbackInput,
    IN OUT PMINIDUMP_CALLBACK_OUTPUT CallbackOutput
    )
{
    switch(CallbackInput->CallbackType)
    {
    case IncludeModuleCallback:
        // Mask off all flags other than the basic write flag.
        CallbackOutput->ModuleWriteFlags &= ModuleWriteModule;
        break;
    case ModuleCallback:
        // Eliminate all unreferenced modules.
        if (!(CallbackOutput->ModuleWriteFlags & ModuleReferencedByMemory))
        {
            CallbackOutput->ModuleWriteFlags = 0;
        }
        break;
    case IncludeThreadCallback:
        if (CallbackInput->IncludeThread.ThreadId != g_EventThreadSysId)
        {
            return FALSE;
        }

        // Reduce write to the minimum of information
        // necessary for a stack walk.
        CallbackOutput->ThreadWriteFlags &= ~ThreadWriteInstructionWindow;
        break;
    }

    return TRUE;
}

HRESULT
UserMiniDumpTargetInfo::Write(HANDLE hFile, ULONG FormatFlags, PCSTR Comment)
{
    if (!IS_USER_TARGET())
    {
        ErrOut("User minidumps can only be written in user-mode sessions\n");
        return E_UNEXPECTED;
    }
    
    dprintf("mini user dump\n");
    FlushCallbacks();

    HRESULT Status;

    if (IS_LIVE_USER_TARGET() && IS_LOCAL_USER_TARGET())
    {
        MINIDUMP_EXCEPTION_INFORMATION ExInfoBuf, *ExInfo;
        EXCEPTION_POINTERS ExPointers;
        EXCEPTION_RECORD ExRecord;
        MINIDUMP_TYPE MiniType;
        MINIDUMP_USER_STREAM UserStreams[1];
        MINIDUMP_USER_STREAM_INFORMATION UserStreamInfo;
        MINIDUMP_CALLBACK_INFORMATION CallbackBuffer;
        PMINIDUMP_CALLBACK_INFORMATION Callback;

        //
        // If we're live we can let the official minidump
        // code do all the work.
        //

        MiniType = MiniDumpNormal;
        if (FormatFlags & DEBUG_FORMAT_USER_SMALL_FULL_MEMORY)
        {
            MiniType = (MINIDUMP_TYPE)(MiniType | MiniDumpWithFullMemory);
        }
        if (FormatFlags & DEBUG_FORMAT_USER_SMALL_HANDLE_DATA)
        {
            MiniType = (MINIDUMP_TYPE)(MiniType | MiniDumpWithHandleData);
        }

        UserStreamInfo.UserStreamCount = 0;
        UserStreamInfo.UserStreamArray = UserStreams;
        if (Comment != NULL)
        {
            UserStreams[UserStreamInfo.UserStreamCount].Type =
                CommentStreamA;
            UserStreams[UserStreamInfo.UserStreamCount].BufferSize =
                strlen(Comment) + 1;
            UserStreams[UserStreamInfo.UserStreamCount].Buffer =
                (PVOID)Comment;
            UserStreamInfo.UserStreamCount++;
        }
        
        ExInfo = CreateMiniExceptionInformation(&ExInfoBuf,
                                                &ExPointers,
                                                &ExRecord);
        

        if (FormatFlags & FORMAT_USER_MICRO)
        {
            // This case isn't expected to be used by users,
            // it's for testing of the microdump support.
            Callback = &CallbackBuffer;
            Callback->CallbackRoutine = MicroDumpCallback;
            Callback->CallbackParam = NULL;
            ExInfo = NULL;
            MiniType = (MINIDUMP_TYPE)(MiniType | MiniDumpFilterMemory);
        }
        else
        {
            Callback = NULL;
        }
        
        if (!MiniDumpWriteDump(g_CurrentProcess->Handle,
                               g_CurrentProcess->SystemId,
                               hFile, MiniType, ExInfo,
                               &UserStreamInfo, Callback))
        {
            Status = WIN32_LAST_STATUS();
            ErrOut("Dump creation failed, %s\n    \"%s\"\n",
                   FormatStatusCode(Status), FormatStatus(Status));
        }
        else
        {
            Status = S_OK;
        }

        // Reset the current register context in case
        // it was changed at some point.
        ChangeRegContext(g_CurrentProcess->CurrentThread);
    }
    else
    {
        // The normal minidump code assumes access to a process,
        // so in the dump case we need to do everything ourself.
        Status = WriteNonProcess(hFile, FormatFlags, Comment);
        if (Status != S_OK)
        {
            ErrOut("Unable to write minidump, %s\n    \"%s\"\n",
                   FormatStatusCode(Status), FormatStatus(Status));
        }
    }

    return Status;
}

#define NP_DUMP_STREAMS 6
#define CHECK_WRITE(Buf, Size)                                          \
    if (!WriteFile(File, Buf, Size, &Write, NULL))                      \
    {                                                                   \
        Status = WIN32_LAST_STATUS();                                   \
        ErrOut("Failed writing to crashdump file - %s\n    \"%s\"\n",   \
                FormatStatusCode(Status),                               \
                FormatStatusArgs(Status, NULL));                        \
        goto Exit;                                                      \
    }

HRESULT
MiniWriteVirtMem(HANDLE File, MINIDUMP_MEMORY_DESCRIPTOR* Mem)
{
    HRESULT Status;
    UCHAR Buf[4096];
    ULONG Write;
    ULONG64 Offset = Mem->StartOfMemoryRange;
    ULONG Left = Mem->Memory.DataSize;
    ULONG Chunk;

    while (Left > 0)
    {
        if (Left > sizeof(Buf))
        {
            Chunk = sizeof(Buf);
        }
        else
        {
            Chunk = Left;
        }

        if ((Status = g_Target->ReadAllVirtual(Offset, Buf, Chunk)) != S_OK)
        {
            goto Exit;
        }

        CHECK_WRITE(Buf, Chunk);

        Left -= Chunk;
        Offset += Chunk;
    }

    Status = S_OK;
    
 Exit:
    return Status;
}

HRESULT
MiniWriteInstructionWindow(HANDLE File, PMINIDUMP_MEMORY_DESCRIPTOR Desc)
{
    ADDR Pc;
    UCHAR Instr[768];

    switch(g_EffMachine)
    {
    case IMAGE_FILE_MACHINE_I386:
    case IMAGE_FILE_MACHINE_AMD64:
        Desc->Memory.DataSize = 256;
        break;
    case IMAGE_FILE_MACHINE_ALPHA:
    case IMAGE_FILE_MACHINE_AXP64:
        Desc->Memory.DataSize = 512;
        break;
    case IMAGE_FILE_MACHINE_IA64:
        Desc->Memory.DataSize = 768;
        break;
    }
    g_Machine->GetPC(&Pc);
    Desc->StartOfMemoryRange = Flat(Pc) - Desc->Memory.DataSize / 2;

    // Figure out how much of the desired memory
    // is actually accessible.
    for (;;)
    {
        ULONG Read;
        
        // If we can read the instructions through the
        // current program counter we'll say that's
        // good enough.
        if (g_Target->ReadVirtual(Desc->StartOfMemoryRange,
                                  Instr, Desc->Memory.DataSize,
                                  &Read) == S_OK &&
            Desc->StartOfMemoryRange + Read > Flat(Pc))
        {
            break;
        }

        // We couldn't read up to the program counter.
        // If the start address is on the previous page
        // move it up to the same page.
        if (PAGE_ALIGN(g_Machine, Desc->StartOfMemoryRange) !=
            PAGE_ALIGN(g_Machine, Flat(Pc)))
        {
            ULONG Fraction = g_Machine->m_PageSize -
                (ULONG)Desc->StartOfMemoryRange & (g_Machine->m_PageSize - 1);
            Desc->StartOfMemoryRange += Fraction;
            Desc->Memory.DataSize -= Fraction;
        }
        else
        {
            // The start and PC were on the same page so
            // we just can't read memory.
            Desc->Memory.DataSize = 0;
            break;
        }
    }

    if (Desc->Memory.DataSize > 0)
    {
        ULONG Write;
    
        if (!WriteFile(File, Instr, Desc->Memory.DataSize, &Write, NULL))
        {
            return WIN32_LAST_STATUS();
        }
    }

    return S_OK;
}

HRESULT
UserMiniDumpTargetInfo::WriteNonProcess(HANDLE File, ULONG FormatFlags,
                                        PCSTR Comment)
{
    HRESULT Status;
    ULONG i;
    ULONG Read, Write;
    ULONG32 Data32;
    RVA DirRva, SectionRva, Rva;
    MINIDUMP_THREAD_EX* MiniThreads = NULL;
    MINIDUMP_MEMORY_DESCRIPTOR* MiniMemory = NULL;
    MINIDUMP_MODULE* MiniModules = NULL;
    ULONG NumStreams;
    BOOL BackingStore = g_TargetMachineType == IMAGE_FILE_MACHINE_IA64;
    ULONG ThreadStructSize = BackingStore ?
        sizeof(MINIDUMP_THREAD_EX) : sizeof(MINIDUMP_THREAD);

    if (FormatFlags != DEBUG_FORMAT_DEFAULT)
    {
        ErrOut("Full memory and handle information minidumps\n"
               "can only be written from a live session\n");
        return E_INVALIDARG;
    }
    if (IS_DUMP_TARGET() &&
        g_TargetClassQualifier != DEBUG_USER_WINDOWS_DUMP)
    {
        ErrOut("Minidumps can only be converted from user full dumps\n");
        return E_INVALIDARG;
    }
    
    //
    // We're writing a minidump from a debug session without
    // a real process that the minidump code can scan.  A lot
    // of information that's present in the minidump, such
    // as file version information, CPU characteristics, etc.
    // are not available, so we produce a pretty spare dump.
    //
    // The dump ends up with thread, module and memory lists
    // plus a system info stream.  There may also be
    // an exception stream if the last event was an exception.
    //

    MiniThreads = new MINIDUMP_THREAD_EX[g_CurrentProcess->NumberThreads];
    MiniMemory = new MINIDUMP_MEMORY_DESCRIPTOR
        [g_CurrentProcess->NumberThreads * (BackingStore ? 3 : 2)];
    MiniModules = new MINIDUMP_MODULE[g_CurrentProcess->NumberImages];
    if (MiniThreads == NULL || MiniMemory == NULL || MiniModules == NULL)
    {
        Status = E_OUTOFMEMORY;
        goto Exit;
    }

    //
    // Write header.
    //
    
    MINIDUMP_HEADER Hdr;

    NumStreams = NP_DUMP_STREAMS;
    if (g_LastEventType != DEBUG_EVENT_EXCEPTION)
    {
        NumStreams--;
    }
    if (Comment == NULL)
    {
        NumStreams--;
    }

    ZeroMemory(&Hdr, sizeof(Hdr));
    Hdr.Signature = MINIDUMP_SIGNATURE;
    // Encode an implementation-specific version into the high word
    // of the version to make it clear what version of the code
    // was used to generate a dump.
    // In order to distinguish minidump.lib generated dumps from
    // dumps written by this code, force on the high bit of the
    // build number.
    Hdr.Version =
        (MINIDUMP_VERSION & 0xffff) |
        ((VER_PRODUCTMAJORVERSION & 0xf) << 28) |
        ((VER_PRODUCTMINORVERSION & 0xf) << 24) |
        (((VER_PRODUCTBUILD & 0xff) | 0x80) << 16);
    Hdr.NumberOfStreams = NumStreams;
    Hdr.TimeDateStamp = FileTimeToTimeDateStamp(g_Target->GetCurrentTimeDateN());
    Rva = sizeof(Hdr);
    Hdr.StreamDirectoryRva = Rva;
    CHECK_WRITE(&Hdr, sizeof(Hdr));

    //
    // Write placeholder directory.
    //

    MINIDUMP_DIRECTORY Dir[NP_DUMP_STREAMS];
    PMINIDUMP_DIRECTORY CurDir;

    ZeroMemory(Dir, sizeof(Dir));
    CHECK_WRITE(Dir, NumStreams * sizeof(Dir[0]));

    DirRva = Rva;
    Rva += NumStreams * sizeof(Dir[0]);
    CurDir = Dir;

    //
    // Write comment stream if necessary.
    //

    if (Comment != NULL)
    {
        Data32 = strlen(Comment) + 1;
        CurDir->StreamType = CommentStreamA;
        CurDir->Location.DataSize = Data32;
        CurDir->Location.Rva = Rva;
        Rva += CurDir->Location.DataSize;
        CurDir++;

        CHECK_WRITE(Comment, Data32);
    }
    
    //
    // Fill out thread descriptions while writing
    // out thread stacks and contexts and accumulating
    // memory records for memory written.
    //

    PTHREAD_INFO Thread;
    MINIDUMP_THREAD_EX* MiniThread;
    MINIDUMP_MEMORY_DESCRIPTOR* MiniMem;
    
    Thread = g_CurrentProcess->ThreadHead;
    MiniThread = MiniThreads;
    MiniMem = MiniMemory;
    for (i = 0; i < g_CurrentProcess->NumberThreads; i++)
    {
        ChangeRegContext(Thread);
        if ((Status = g_Machine->GetContextState(MCTX_CONTEXT)) != S_OK)
        {
            goto Exit;
        }
        
        MiniThread->ThreadId = Thread->SystemId;
        MiniThread->SuspendCount = Thread->SuspendCount;
        MiniThread->PriorityClass = NORMAL_PRIORITY_CLASS;
        MiniThread->Priority = THREAD_PRIORITY_NORMAL;
        if ((Status = g_Target->
             GetThreadInfoDataOffset(Thread, NULL, &MiniThread->Teb)) != S_OK)
        {
            goto Exit;
        }

        ULONG64 StackBase;
        if ((Status = g_Target->
             ReadPointer(g_TargetMachine,
                         MiniThread->Teb +
                         (g_TargetMachine->m_Ptr64 ?
                          STACK_BASE_FROM_TEB64 : STACK_BASE_FROM_TEB32),
                         &StackBase)) != S_OK)
        {
            goto Exit;
        }

        ADDR StackBottom;
        g_Machine->GetSP(&StackBottom);

        if (g_TargetMachineType == IMAGE_FILE_MACHINE_I386)
        {
            //
            // Note: for FPO frames on x86 we access bytes outside of the
            // ESP - StackBase range. Add a couple of bytes extra here so we
            // don't fail these cases.
            //

            AddrSub(&StackBottom, 4);
        }

        MiniThread->Stack.StartOfMemoryRange = Flat(StackBottom);
        MiniThread->Stack.Memory.DataSize =
            (ULONG32)(StackBase - Flat(StackBottom));
        MiniThread->Stack.Memory.Rva = Rva;
        Rva += MiniThread->Stack.Memory.DataSize;

        // Accumulate stack memory descriptors.
        *MiniMem++ = MiniThread->Stack;

        // Write stack memory to file.
        if ((Status = MiniWriteVirtMem(File, &MiniThread->Stack)) != S_OK)
        {
            return Status;
        }

        if (BackingStore)
        {
            ULONG64 StoreBase, StoreTop;

#if 1
            // XXX drewb - The TEB bstore values don't seem to point to
            // the actual base of the backing store.  Just
            // assume it's contiguous with the stack.
            StoreBase = StackBase;
#else
            if ((Status = g_Target->ReadPointer(MiniThread->Teb +
                                                IA64_TEB_BSTORE_BASE,
                                                &StoreBase)) != S_OK)
            {
                goto Exit;
            }
#endif

            // The BSP points to the bottom of the current frame's
            // storage area.  We need to add on the size of the
            // current frame to get the amount of memory that
            // really needs to be stored.  When computing the
            // size of the current frame space for NAT bits
            // must be figured in properly based on the number
            // of entries in the frame.  The NAT collection
            // is spilled on every 63'rd spilled register to
            // make each block an every 64 ULONG64s long.
            // On NT the backing store base is always 9-bit aligned
            // so we can tell when exactly the next NAT spill
            // will occur by looking for when the 9-bit spill
            // region will overflow.
            ULONG FrameSize = g_Ia64Machine.GetReg32(STIFS) &
                IA64_PFS_SIZE_MASK;
            StoreTop = g_Ia64Machine.GetReg64(RSBSP);
            
            // Add in a ULONG64 for every register in the
            // current frame.  While doing so, check for
            // spill entries.
            while (FrameSize-- > 0)
            {
                StoreTop += sizeof(ULONG64);
                if ((StoreTop & 0x1f8) == 0x1f8)
                {
                    // Spill will be placed at this address so
                    // account for it.
                    StoreTop += sizeof(ULONG64);
                }
            }
            
            MiniThread->BackingStore.StartOfMemoryRange = StoreBase;
            MiniThread->BackingStore.Memory.DataSize =
                (ULONG32)(StoreTop - StoreBase);
            MiniThread->BackingStore.Memory.Rva = Rva;
            Rva += MiniThread->BackingStore.Memory.DataSize;

            // Accumulate stack memory descriptors.
            *MiniMem++ = MiniThread->BackingStore;

            // Write stack memory to file.
            if ((Status = MiniWriteVirtMem(File,
                                           &MiniThread->BackingStore)) != S_OK)
            {
                return Status;
            }
        }

        //
        // Try and save a window of instructions around
        // the current PC.
        //
        
        MINIDUMP_MEMORY_DESCRIPTOR InstrMem;

        if ((Status = MiniWriteInstructionWindow(File, &InstrMem)) != S_OK)
        {
            goto Exit;
        }
        if (InstrMem.Memory.DataSize > 0)
        {
            InstrMem.Memory.Rva = Rva;
            Rva += InstrMem.Memory.DataSize;
            *MiniMem++ = InstrMem;
        }

        //
        // Fill out context information and write.
        //

        MiniThread->ThreadContext.DataSize = g_Machine->m_SizeCanonicalContext;
        MiniThread->ThreadContext.Rva = Rva;
        Rva += MiniThread->ThreadContext.DataSize;
        CHECK_WRITE(&g_Machine->m_Context, g_Machine->m_SizeCanonicalContext);

        MiniThread++;
        Thread = Thread->Next;
    }
    
    //
    // Write thread list.
    //

    Data32 = g_CurrentProcess->NumberThreads;
    CurDir->StreamType = ThreadStructSize == sizeof(MINIDUMP_THREAD_EX) ?
        ThreadExListStream : ThreadListStream;
    CurDir->Location.DataSize = sizeof(MINIDUMP_THREAD_LIST) +
        ThreadStructSize * Data32;
    CurDir->Location.Rva = Rva;
    Rva += CurDir->Location.DataSize;
    CurDir++;

    CHECK_WRITE(&Data32, sizeof(Data32));
    MiniThread = MiniThreads;
    for (i = 0; i < Data32; i++)
    {
        CHECK_WRITE(MiniThread, ThreadStructSize);
        MiniThread++;
    }

    //
    // Fill out module information and write supporting data.
    //

    PDEBUG_IMAGE_INFO Image;
    MINIDUMP_MODULE* MiniMod;

    MiniMod = MiniModules;
    for (Image = g_CurrentProcess->ImageHead;
         Image != NULL;
         Image = Image->Next)
    {
        ZeroMemory(MiniMod, sizeof(*MiniMod));
        MiniMod->BaseOfImage = Image->BaseOfImage;
        MiniMod->SizeOfImage = Image->SizeOfImage;
        MiniMod->CheckSum = Image->CheckSum;
        MiniMod->TimeDateStamp = Image->TimeDateStamp;
        MiniMod->ModuleNameRva = Rva;

        //
        // Write name.
        //

        WCHAR WideName[MAX_IMAGE_PATH];

        Data32 = strlen(Image->ImagePath);
        if (!MultiByteToWideChar(CP_ACP, 0, Image->ImagePath,
                                 Data32 + 1, WideName,
                                 sizeof(WideName) / sizeof(WCHAR)))
        {
            Status = WIN32_LAST_STATUS();
            goto Exit;
        }

        Data32 *= sizeof(WCHAR);
        // Written size does not include terminator.
        CHECK_WRITE(&Data32, sizeof(Data32));
        // Data does include terminator.
        Data32 += sizeof(WCHAR);
        CHECK_WRITE(WideName, Data32);
        Rva += sizeof(MINIDUMP_STRING) + Data32;
        
        MiniMod++;
    }

    DBG_ASSERT((ULONG)(MiniMod - MiniModules) ==
               g_CurrentProcess->NumberImages);
    
    //
    // Write module list.
    //

    Data32 = g_CurrentProcess->NumberImages;
    CurDir->StreamType = ModuleListStream;
    CurDir->Location.DataSize = sizeof(MINIDUMP_MODULE_LIST) +
        sizeof(MINIDUMP_MODULE) * Data32;
    CurDir->Location.Rva = Rva;
    Rva += CurDir->Location.DataSize;
    CurDir++;

    CHECK_WRITE(&Data32, sizeof(Data32));
    CHECK_WRITE(MiniModules, sizeof(*MiniModules) * Data32);

    //
    // Write memory list.
    //

    Data32 = (ULONG32)(MiniMem - MiniMemory);
    DBG_ASSERT(Data32 <= g_CurrentProcess->NumberThreads *
               (BackingStore ? 3 : 2));
    
    CurDir->StreamType = MemoryListStream;
    CurDir->Location.DataSize = sizeof(MINIDUMP_MEMORY_LIST) +
        sizeof(MINIDUMP_MEMORY_DESCRIPTOR) * Data32;
    CurDir->Location.Rva = Rva;
    Rva += CurDir->Location.DataSize;
    CurDir++;

    CHECK_WRITE(&Data32, sizeof(Data32));
    CHECK_WRITE(MiniMemory, sizeof(*MiniMemory) * Data32);

    //
    // Fill out what we can of the system information and
    // write it out.
    //

    MINIDUMP_SYSTEM_INFO SysInfo;

    ZeroMemory(&SysInfo, sizeof(SysInfo));
    switch(g_TargetMachineType)
    {
    case IMAGE_FILE_MACHINE_I386:
        SysInfo.ProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
        break;
    case IMAGE_FILE_MACHINE_ALPHA:
        SysInfo.ProcessorArchitecture = PROCESSOR_ARCHITECTURE_ALPHA;
        break;
    case IMAGE_FILE_MACHINE_IA64:
        SysInfo.ProcessorArchitecture = PROCESSOR_ARCHITECTURE_IA64;
        break;
    case IMAGE_FILE_MACHINE_AXP64:
        SysInfo.ProcessorArchitecture = PROCESSOR_ARCHITECTURE_ALPHA64;
        break;
    case IMAGE_FILE_MACHINE_AMD64:
        SysInfo.ProcessorArchitecture = PROCESSOR_ARCHITECTURE_AMD64;
        break;
    }
    SysInfo.MajorVersion = g_KdVersion.MajorVersion;
    SysInfo.MinorVersion = g_KdVersion.MinorVersion;
    SysInfo.BuildNumber = g_TargetBuildNumber;
    SysInfo.PlatformId = g_TargetPlatformId;

    CurDir->StreamType = SystemInfoStream;
    CurDir->Location.DataSize = sizeof(MINIDUMP_SYSTEM_INFO);
    CurDir->Location.Rva = Rva;
    Rva += CurDir->Location.DataSize;
    CurDir++;

    CHECK_WRITE(&SysInfo, sizeof(SysInfo));

    if (g_LastEventType == DEBUG_EVENT_EXCEPTION)
    {
        // Get the full context for the event thread.
        ChangeRegContext(g_EventThread);
        if ((Status = g_Machine->GetContextState(MCTX_CONTEXT)) != S_OK)
        {
            goto Exit;
        }
        
        //
        // Write out the exception context and then
        // the exception stream.
        //

        MINIDUMP_EXCEPTION_STREAM ExStream;

        ExStream.ThreadId = g_EventThreadSysId;
        ExStream.__alignment = 0;
        DBG_ASSERT(sizeof(MINIDUMP_EXCEPTION) ==
                   sizeof(g_LastEventInfo.Exception.ExceptionRecord));
        memcpy(&ExStream.ExceptionRecord,
               &g_LastEventInfo.Exception.ExceptionRecord,
               sizeof(g_LastEventInfo.Exception.ExceptionRecord));
        ExStream.ThreadContext.DataSize = g_Machine->m_SizeCanonicalContext;
        ExStream.ThreadContext.Rva = Rva;
        Rva += ExStream.ThreadContext.DataSize;

        CHECK_WRITE(&g_Machine->m_Context, g_Machine->m_SizeCanonicalContext);
        
        CurDir->StreamType = ExceptionStream;
        CurDir->Location.DataSize = sizeof(MINIDUMP_EXCEPTION_STREAM);
        CurDir->Location.Rva = Rva;
        Rva += CurDir->Location.DataSize;
        CurDir++;

        CHECK_WRITE(&ExStream, sizeof(ExStream));
    }
    
    //
    // Go back to the directory offset and rewrite the
    // fully initialized directory.
    //

    DBG_ASSERT((ULONG)(CurDir - Dir) == NumStreams);
    
    if (SetFilePointer(File, DirRva, NULL, FILE_BEGIN) ==
        INVALID_SET_FILE_POINTER)
    {
        Status = WIN32_LAST_STATUS();
        goto Exit;
    }
    CHECK_WRITE(Dir, NumStreams * sizeof(Dir[0]));
    
 Exit:
    // Register context may have changed so reassert the
    // current thread.
    ChangeRegContext(g_CurrentProcess->CurrentThread);
    delete MiniThreads;
    delete MiniMemory;
    delete MiniModules;
    return Status;
}

//-------------------------------------------------------------------
//  initialize the dump headers
//

#define MINIDUMP_BUGCHECK 0x10000000

void
KernelDumpTargetInfo::InitDumpHeader32(
    PDUMP_HEADER32 pdh,
    PCSTR Comment,
    ULONG BugCheckCodeModifier
    )
{
    ULONG64 Data[4];
    PULONG  FillPtr = (PULONG)pdh;
    ADDR    PcAddr;

    while (FillPtr < (PULONG)(pdh + 1))
    {
        *FillPtr++ = DUMP_SIGNATURE32;
    }

    pdh->Signature           = DUMP_SIGNATURE32;
    pdh->ValidDump           = DUMP_VALID_DUMP32;
    pdh->MajorVersion        = g_KdVersion.MajorVersion;
    pdh->MinorVersion        = g_KdVersion.MinorVersion;

    g_Target->ReadDirectoryTableBase(Data);
    pdh->DirectoryTableBase  = (ULONG)Data[0];

    pdh->PfnDataBase         = (ULONG)KdDebuggerData.MmPfnDatabase;
    pdh->PsLoadedModuleList  = (ULONG)KdDebuggerData.PsLoadedModuleList;
    pdh->PsActiveProcessHead = (ULONG)KdDebuggerData.PsActiveProcessHead;
    pdh->MachineImageType    = g_KdVersion.MachineType;
    pdh->NumberProcessors    = g_TargetNumberProcessors;

    g_Target->ReadBugCheckData(&(pdh->BugCheckCode), Data);
    pdh->BugCheckCode       |= BugCheckCodeModifier;
    pdh->BugCheckParameter1  = (ULONG)Data[0];
    pdh->BugCheckParameter2  = (ULONG)Data[1];
    pdh->BugCheckParameter3  = (ULONG)Data[2];
    pdh->BugCheckParameter4  = (ULONG)Data[3];

    //pdh->VersionUser         = 0;
    pdh->PaeEnabled          = KdDebuggerData.PaeEnabled;
    pdh->KdDebuggerDataBlock = (ULONG)g_KdDebuggerDataBlock;

    // pdh->PhysicalMemoryBlock =;

    g_Machine->GetContextState(MCTX_CONTEXT);
    g_Machine->ConvertContextTo(&g_Machine->m_Context, g_SystemVersion,
                                sizeof(pdh->ContextRecord),
                                pdh->ContextRecord);

    if (g_LastEventType == DEBUG_EVENT_EXCEPTION)
    {
        // Use the exception record from the last event.
        ExceptionRecord64To32(&g_LastEventInfo.Exception.ExceptionRecord,
                              &pdh->Exception);
    }
    else
    {
        ADDR PcAddr;
        
        // Fake a breakpoint exception.
        ZeroMemory(&pdh->Exception, sizeof(pdh->Exception));
        pdh->Exception.ExceptionCode = STATUS_BREAKPOINT;
        g_Machine->GetPC(&PcAddr);
        pdh->Exception.ExceptionAddress = (ULONG)Flat(PcAddr);
    }

    pdh->RequiredDumpSpace.QuadPart = TRIAGE_DUMP_SIZE32;

    pdh->SystemTime.QuadPart = g_Target->GetCurrentTimeDateN();
    pdh->SystemUpTime.QuadPart = g_Target->GetCurrentSystemUpTimeN();

    if (Comment != NULL && Comment[0])
    {
        pdh->Comment[0] = 0;
        strncat(pdh->Comment, Comment, sizeof(pdh->Comment) - 1);
    }
}

void
KernelDumpTargetInfo::InitDumpHeader64(
    PDUMP_HEADER64 pdh,
    PCSTR Comment,
    ULONG BugCheckCodeModifier
    )
{
    ULONG64 Data[4];
    PULONG  FillPtr = (PULONG)pdh;
    ADDR    PcAddr;

    while (FillPtr < (PULONG)(pdh + 1))
    {
        *FillPtr++ = DUMP_SIGNATURE32;
    }

    pdh->Signature           = DUMP_SIGNATURE64;
    pdh->ValidDump           = DUMP_VALID_DUMP64;
    pdh->MajorVersion        = g_KdVersion.MajorVersion;
    pdh->MinorVersion        = g_KdVersion.MinorVersion;

    // IA64 has several page directories.  The defined
    // behavior is to put the kernel page directory
    // in the dump header as that's the one that can
    // be most useful when first initializing the dump.
    if (g_EffMachine == IMAGE_FILE_MACHINE_IA64)
    {
        ULONG Next;
        
        if (g_Machine->SetPageDirectory(PAGE_DIR_KERNEL, 0, &Next) != S_OK)
        {
            ErrOut("Unable to update the kernel dirbase\n");
            Data[0] = 0;
        }
        else
        {
            Data[0] = g_Machine->m_PageDirectories[PAGE_DIR_KERNEL];
        }
    }
    else
    {
        g_Target->ReadDirectoryTableBase(Data);
    }
    pdh->DirectoryTableBase  = Data[0];

    pdh->PfnDataBase         = KdDebuggerData.MmPfnDatabase;
    pdh->PsLoadedModuleList  = KdDebuggerData.PsLoadedModuleList;
    pdh->PsActiveProcessHead = KdDebuggerData.PsActiveProcessHead;
    pdh->MachineImageType    = g_KdVersion.MachineType;
    pdh->NumberProcessors    = g_TargetNumberProcessors;

    g_Target->ReadBugCheckData(&(pdh->BugCheckCode), Data);
    pdh->BugCheckCode       |= BugCheckCodeModifier;
    pdh->BugCheckParameter1  = Data[0];
    pdh->BugCheckParameter2  = Data[1];
    pdh->BugCheckParameter3  = Data[2];
    pdh->BugCheckParameter4  = Data[3];

    //pdh->VersionUser         = 0;

    // PaeEnabled Does not exist in the 64 bit header
    // pdh->PaeEnabled       = KdDebuggerData.PaeEnabled;

    pdh->KdDebuggerDataBlock = g_KdDebuggerDataBlock;

    // pdh->PhysicalMemoryBlock =;

    g_Machine->GetContextState(MCTX_CONTEXT);
    g_Machine->ConvertContextTo(&g_Machine->m_Context, g_SystemVersion,
                                sizeof(pdh->ContextRecord),
                                pdh->ContextRecord);

    if (g_LastEventType == DEBUG_EVENT_EXCEPTION)
    {
        // Use the exception record from the last event.
        pdh->Exception = g_LastEventInfo.Exception.ExceptionRecord;
    }
    else
    {
        ADDR PcAddr;
        
        // Fake a breakpoint exception.
        ZeroMemory(&pdh->Exception, sizeof(pdh->Exception));
        pdh->Exception.ExceptionCode = STATUS_BREAKPOINT;
        g_Machine->GetPC(&PcAddr);
        pdh->Exception.ExceptionAddress = Flat(PcAddr);
    }

    pdh->RequiredDumpSpace.QuadPart = TRIAGE_DUMP_SIZE64;

    pdh->SystemTime.QuadPart = g_Target->GetCurrentTimeDateN();
    pdh->SystemUpTime.QuadPart = g_Target->GetCurrentSystemUpTimeN();

    if (Comment != NULL && Comment[0])
    {
        pdh->Comment[0] = 0;
        strncat(pdh->Comment, Comment, sizeof(pdh->Comment) - 1);
    }
}



//----------------------------------------------------------------------------
//
// KernelFull64DumpTargetInfo::Write.
//
//----------------------------------------------------------------------------


HRESULT
KernelFull64DumpTargetInfo::Write(HANDLE hFile, ULONG FormatFlags,
                                  PCSTR Comment)
{
    PDUMP_HEADER64 pDumpHeader64;
    HRESULT Status;
    ULONG64 offset;
    ULONG Read;
    PPHYSICAL_MEMORY_DESCRIPTOR64 pmb64 = NULL;
    DWORD  i,j;
    PUCHAR pPageBuffer = NULL;
    DWORD  bytesWritten;
    DWORD  percent;
    ULONG64  currentPagesWritten;

    pDumpHeader64 = (PDUMP_HEADER64) LocalAlloc(LPTR, sizeof(DUMP_HEADER64));
    if (pDumpHeader64 == NULL)
    {
        ErrOut("Failed to allocate dump header buffer\n");
        return E_OUTOFMEMORY;
    }

    if (!IS_REMOTE_KERNEL_TARGET() && !IS_KERNEL_FULL_DUMP())
    {
        ErrOut("\nkernel full dumps can only be written when all of physical "
               "memory is accessible - aborting now\n");
        return E_INVALIDARG;
    }

    dprintf("Full kernel dump\n");
    FlushCallbacks();

    KernelDumpTargetInfo::InitDumpHeader64(pDumpHeader64, Comment, 0);
    pDumpHeader64->DumpType = DUMP_TYPE_FULL;

    //
    // now copy the memory descriptor list to our header..
    // first get the pointer va
    //

    Status = g_Target->ReadPointer(g_TargetMachine,
                                   KdDebuggerData.MmPhysicalMemoryBlock,
                                   &offset);

    if (Status != S_OK || (offset == 0))
    {
        ErrOut("Unable to read MmPhysicalMemoryBlock\n");
    }
    else
    {
        //
        // first read the memory descriptor size...
        //

        Status = g_Target->ReadVirtual(offset,
                                       pDumpHeader64->PhysicalMemoryBlockBuffer,
                                       DMP_PHYSICAL_MEMORY_BLOCK_SIZE_64,
                                       &Read);
        if (Status != S_OK || Read != DMP_PHYSICAL_MEMORY_BLOCK_SIZE_64)
        {
            ErrOut("Unable to read MmPhysicalMemoryBlock\n");
        }
        else
        {
            pmb64 = &pDumpHeader64->PhysicalMemoryBlock;

            //
            // calculate total dump file size
            //

            pDumpHeader64->RequiredDumpSpace.QuadPart =
                    pDumpHeader64->PhysicalMemoryBlock.NumberOfPages *
                    g_Machine->m_PageSize;

            //
            // write dump header to crash dump file
            //

            if (!WriteFile(hFile,
                           pDumpHeader64,
                           sizeof(DUMP_HEADER64),
                           &bytesWritten,
                           NULL))
            {
                Status = WIN32_LAST_STATUS();
                ErrOut("Failed writing to crashdump file - %s\n    \"%s\"\n",
                        FormatStatusCode(Status),
                        FormatStatusArgs(Status, NULL));
            }
        }
    }


    if (Status == S_OK)
    {
        pPageBuffer = (PUCHAR) LocalAlloc(LPTR, g_Machine->m_PageSize);
        if (pPageBuffer == NULL)
        {
            ErrOut("Failed to allocate double buffer\n");
        }
        else
        {
            //
            // now write the physical memory out to disk.
            // we use the dump header to retrieve the physical memory base and
            // run count then ask the transport to gecth these pages form the
            // target.  On 1394, the virtual debugger driver will do physical
            // address reads on the remote host since there is a onoe-to-one
            // relationships between physical 1394 and physical mem addresses.
            //

            currentPagesWritten = 0;
            percent = 0;

            for (i = 0; i < pmb64->NumberOfRuns; i++)
            {
                offset = 0;
                offset = pmb64->Run[i].BasePage*g_Machine->m_PageSize;

                if (CheckUserInterrupt())
                {
                    ErrOut("Creation of crashdump file interrupted\n");
                    break;
                }

                for (j = 0; j< pmb64->Run[i].PageCount; j++)
                {
                    //
                    // printout the percent done every 5% increments
                    //

                    if ((currentPagesWritten*100)/pmb64->NumberOfPages == percent)
                    {
                        dprintf("Percent written %d \n", percent);
                        FlushCallbacks();
                        if (g_DbgKdTransport &&
                            g_DbgKdTransport->m_DirectPhysicalMemory)
                        {
                            percent += 5;
                        }
                        else
                        {
                            percent += 1;
                        }
                    }

                    if (g_DbgKdTransport &&
                        g_DbgKdTransport->m_DirectPhysicalMemory)
                    {
                        Status = g_DbgKdTransport->ReadTargetPhysicalMemory(
                                                        offset,
                                                        pPageBuffer,
                                                        g_Machine->m_PageSize,
                                                        &bytesWritten);
                    }
                    else
                    {
                        Status = g_Target->ReadPhysical(offset,
                                                        pPageBuffer,
                                                        g_Machine->m_PageSize,
                                                        &bytesWritten);
                    }

                    if (g_EngStatus & ENG_STATUS_USER_INTERRUPT)
                    {
                        break;
                    }
                    else if (Status != S_OK)
                    {
                        ErrOut("Failed Reading page for crashdump file\n");
                        break;
                    }
                    else
                    {
                        //
                        // now write the page to the local crashdump file
                        //

                        if (!WriteFile(hFile,
                                       pPageBuffer,
                                       g_Machine->m_PageSize,
                                       &bytesWritten,
                                       NULL))
                        {
                            Status = WIN32_LAST_STATUS();
                            ErrOut("Failed writing header to crashdump file - %s\n    \"%s\"\n",
                                    FormatStatusCode(Status),
                                    FormatStatusArgs(Status, NULL));
                            break;
                        }

                        offset += g_Machine->m_PageSize;
                        currentPagesWritten++;
                    }
                }
            }

            LocalFree(pPageBuffer);
        }
    }

    LocalFree(pDumpHeader64);

    return Status;
}

//----------------------------------------------------------------------------
//
// KernelFull32DumpTargetInfo::Write.
//
//----------------------------------------------------------------------------


HRESULT
KernelFull32DumpTargetInfo::Write(HANDLE hFile, ULONG FormatFlags,
                                  PCSTR Comment)
{
    PDUMP_HEADER32 pDumpHeader32 = NULL;
    HRESULT Status;
    ULONG64 offset;
    ULONG Read;
    PPHYSICAL_MEMORY_DESCRIPTOR32 pmb = NULL;
    DWORD  i,j;
    PUCHAR pPageBuffer = NULL;
    DWORD  bytesWritten;
    DWORD  percent;
    ULONG  currentPagesWritten;

    pDumpHeader32 = (PDUMP_HEADER32) LocalAlloc(LPTR, sizeof(DUMP_HEADER32));
    if (pDumpHeader32 == NULL)
    {
        ErrOut("Failed to allocate dump header buffer\n");
        return E_OUTOFMEMORY;
    }

    if (!IS_REMOTE_KERNEL_TARGET() && !IS_KERNEL_FULL_DUMP())
    {
        ErrOut("\nkernel full dumps can only be written when all of physical "
               "memory is accessible - aborting now\n");
        return E_INVALIDARG;
    }

    dprintf("Full kernel dump\n");
    FlushCallbacks();

    //
    // Build the header
    //

    KernelDumpTargetInfo::InitDumpHeader32(pDumpHeader32, Comment, 0);
    pDumpHeader32->DumpType = DUMP_TYPE_FULL;

    //
    // now copy the memory descriptor list to our header..
    // first get the pointer va
    //

    Status = g_Target->ReadPointer(g_TargetMachine,
                                   KdDebuggerData.MmPhysicalMemoryBlock,
                                   &offset);

    if (Status != S_OK || (offset == 0))
    {
        ErrOut("Unable to read MmPhysicalMemoryBlock\n");
    }
    else
    {
        //
        // first read the memory descriptor size...
        //

        Status = g_Target->ReadVirtual(offset,
                                       pDumpHeader32->PhysicalMemoryBlockBuffer,
                                       DMP_PHYSICAL_MEMORY_BLOCK_SIZE_32,
                                       &Read);
        if (Status != S_OK || Read != DMP_PHYSICAL_MEMORY_BLOCK_SIZE_32)
        {
            ErrOut("Unable to read MmPhysicalMemoryBlock\n");
        }
        else
        {
            pmb = &pDumpHeader32->PhysicalMemoryBlock;

            //
            // calculate total dump file size
            //

            pDumpHeader32->RequiredDumpSpace.QuadPart =
                    pDumpHeader32->PhysicalMemoryBlock.NumberOfPages *
                    g_Machine->m_PageSize;

            //
            // write dump header to crash dump file
            //

            if (!WriteFile(hFile,
                           pDumpHeader32,
                           sizeof(DUMP_HEADER32),
                           &bytesWritten,
                           NULL))
            {
                Status = WIN32_LAST_STATUS();
                ErrOut("Failed writing to crashdump file - %s\n    \"%s\"\n",
                        FormatStatusCode(Status),
                        FormatStatusArgs(Status, NULL));
            }
        }
    }


    if (Status == S_OK)
    {
        pPageBuffer = (PUCHAR) LocalAlloc(LPTR, g_Machine->m_PageSize);
        if (pPageBuffer == NULL)
        {
            ErrOut("Failed to allocate double buffer\n");
        }
        else
        {
            //
            // now write the physical memory out to disk.
            // we use the dump header to retrieve the physical memory base and
            // run count then ask the transport to gecth these pages form the
            // target.  On 1394, the virtual debugger driver will do physical
            // address reads on the remote host since there is a onoe-to-one
            // relationships between physical 1394 and physical mem addresses.
            //

            currentPagesWritten = 0;
            percent = 0;

            for (i = 0; i < pmb->NumberOfRuns; i++)
            {
                offset = 0;
                offset = pmb->Run[i].BasePage*g_Machine->m_PageSize;

                if (CheckUserInterrupt())
                {
                    ErrOut("Creation of crashdump file interrupted\n");
                    break;
                }

                for (j = 0; j< pmb->Run[i].PageCount; j++)
                {
                    //
                    // printout the percent done every 5% increments
                    //

                    if ((currentPagesWritten*100)/pmb->NumberOfPages == percent)
                    {
                        dprintf("Percent written %d \n", percent);
                        FlushCallbacks();
                        if (g_DbgKdTransport &&
                            g_DbgKdTransport->m_DirectPhysicalMemory)
                        {
                            percent += 5;
                        }
                        else
                        {
                            percent += 1;
                        }
                    }

                    if (g_DbgKdTransport &&
                        g_DbgKdTransport->m_DirectPhysicalMemory)
                    {
                        Status = g_DbgKdTransport->ReadTargetPhysicalMemory(
                                                        offset,
                                                        pPageBuffer,
                                                        g_Machine->m_PageSize,
                                                        &bytesWritten);
                    }
                    else
                    {
                        Status = g_Target->ReadPhysical(offset,
                                                        pPageBuffer,
                                                        g_Machine->m_PageSize,
                                                        &bytesWritten);
                    }

                    if (g_EngStatus & ENG_STATUS_USER_INTERRUPT)
                    {
                        break;
                    }
                    else if (Status != S_OK)
                    {
                        ErrOut("Failed Reading page for crashdump file\n");
                        break;
                    }
                    else
                    {
                        //
                        // now write the page to the local crashdump file
                        //

                        if (!WriteFile(hFile,
                                       pPageBuffer,
                                       g_Machine->m_PageSize,
                                       &bytesWritten,
                                       NULL))
                        {
                            Status = WIN32_LAST_STATUS();
                            ErrOut("Failed writing header to crashdump file - %s\n    \"%s\"\n",
                                    FormatStatusCode(Status),
                                    FormatStatusArgs(Status, NULL));
                            break;
                        }

                        offset += g_Machine->m_PageSize;
                        currentPagesWritten++;
                    }
                }
            }

            LocalFree(pPageBuffer);
        }
    }

    LocalFree(pDumpHeader32);

    return Status;
}



DWORD
GetNextModuleEntry(
    ModuleInfo *ModIter,
    MODULE_INFO_ENTRY *ModEntry
    )
{
    ZeroMemory(ModEntry, sizeof(MODULE_INFO_ENTRY));

    // XXX we need to handle errors getting the modules

    if (ModIter->GetEntry(ModEntry) != S_OK)
    {
        return 1;
    }

    if (ModEntry->NameLength > (MAX_IMAGE_PATH - 1) *
        (ModEntry->UnicodeNamePtr ? sizeof(WCHAR) : sizeof(CHAR)))
    {
        ErrOut("Module list is corrupt.");
        if (IS_KERNEL_TARGET())
        {
            ErrOut("  Check your kernel symbols.\n");
        }
        else
        {
            ErrOut("  Loader list may be invalid\n");
        }
        return 1;
    }

    // If this entry has no name just skip it.
    if ((ModEntry->NamePtr == NULL) || (ModEntry->NameLength == NULL))
    {
        ErrOut("  Module List has empty entry in it - skipping\n");
        return 2;
    }

    // If the image header information couldn't be read
    // we end up with placeholder values for certain entries.
    // The kernel writes out zeroes in this case so copy
    // its behavior so that there's one consistent value
    // for unknown.
    if (ModEntry->CheckSum == UNKNOWN_CHECKSUM)
    {
        ModEntry->CheckSum = 0;
    }
    if (ModEntry->TimeDateStamp == UNKNOWN_TIMESTAMP)
    {
        ModEntry->TimeDateStamp = 0;
    }
        
    return 0;
}

//----------------------------------------------------------------------------
//
// Shared triage writing things.
//
//----------------------------------------------------------------------------

#define ExtractValue(NAME, val)  {                                    \
    if (!KdDebuggerData.NAME) {                                       \
        val = 0;                                                      \
        ErrOut("KdDebuggerData." #NAME " is NULL\n");                 \
    } else {                                                          \
        ULONG lsize;                                                  \
        g_Target->ReadVirtual(KdDebuggerData.NAME, &(val),            \
                              sizeof(val), &lsize);                   \
    }                                                                 \
}

inline ALIGN_8(unsigned offset)
{
    return (offset + 7) & 0xfffffff8;
}

const unsigned MAX_TRIAGE_STACK_SIZE = 16 * 1024;
const unsigned MAX_TRIAGE_BSTORE_SIZE = 16 * 4096;  // as defined in ntia64.h
const ULONG TRIAGE_DRIVER_NAME_SIZE_GUESS = 0x40;

//
// XXX drewb - This should all be cleaned up and properly
// placed in the dump target and machine.
//

typedef struct _TRIAGE_PTR_DATA_BLOCK
{
    ULONG64 MinAddress;
    ULONG64 MaxAddress;
} TRIAGE_PTR_DATA_BLOCK, *PTRIAGE_PTR_DATA_BLOCK;

// A triage dump is sixteen pages long.  Some of that is
// header information and at least a few other pages will
// be used for basic dump information so limit the number
// of extra data blocks to something less than sixteen
// to save array space.
#define IO_MAX_TRIAGE_DUMP_DATA_BLOCKS 8

ULONG IopNumTriageDumpDataBlocks;
TRIAGE_PTR_DATA_BLOCK IopTriageDumpDataBlocks[IO_MAX_TRIAGE_DUMP_DATA_BLOCKS];

//
// If space is available in a triage dump it's possible
// to add "interesting" data pages referenced by runtime
// information such as context registers.  The following
// lists are offsets into the CONTEXT structure of pointers
// which usually point to interesting data.  They are
// in priority order.
//

#define IOP_LAST_CONTEXT_OFFSET 0xffff

USHORT IopRunTimeContextOffsetsX86[] =
{
    FIELD_OFFSET(X86_NT5_CONTEXT, Ebx),
    FIELD_OFFSET(X86_NT5_CONTEXT, Esi),
    FIELD_OFFSET(X86_NT5_CONTEXT, Edi),
    FIELD_OFFSET(X86_NT5_CONTEXT, Ecx),
    FIELD_OFFSET(X86_NT5_CONTEXT, Edx),
    FIELD_OFFSET(X86_NT5_CONTEXT, Eax),
    IOP_LAST_CONTEXT_OFFSET
};

USHORT IopRunTimeContextOffsetsIa64[] =
{
    FIELD_OFFSET(IA64_CONTEXT, IntS0),
    FIELD_OFFSET(IA64_CONTEXT, IntS1),
    FIELD_OFFSET(IA64_CONTEXT, IntS2),
    FIELD_OFFSET(IA64_CONTEXT, IntS3),
    IOP_LAST_CONTEXT_OFFSET
};

USHORT IopRunTimeContextOffsetsAmd64[] =
{
    FIELD_OFFSET(AMD64_CONTEXT, Rbx),
    FIELD_OFFSET(AMD64_CONTEXT, Rsi),
    FIELD_OFFSET(AMD64_CONTEXT, Rdi),
    FIELD_OFFSET(AMD64_CONTEXT, Rcx),
    FIELD_OFFSET(AMD64_CONTEXT, Rdx),
    FIELD_OFFSET(AMD64_CONTEXT, Rax),
    IOP_LAST_CONTEXT_OFFSET
};

USHORT IopRunTimeContextOffsetsEmpty[] =
{
    IOP_LAST_CONTEXT_OFFSET
};

BOOLEAN
IopIsAddressRangeValid(
    IN ULONG64 VirtualAddress,
    IN ULONG Length
    )
{
    VirtualAddress = PAGE_ALIGN(g_Machine, VirtualAddress);
    Length = (Length + g_Machine->m_PageSize - 1) >> g_Machine->m_PageShift;
    while (Length > 0)
    {
        UCHAR Data;

        if (g_Target->
            ReadAllVirtual(VirtualAddress, &Data, sizeof(Data)) != S_OK)
        {
            return FALSE;
        }
        
        VirtualAddress += g_Machine->m_PageSize;
        Length--;
    }

    return TRUE;
}

BOOLEAN
IoAddTriageDumpDataBlock(
    IN ULONG64 Address,
    IN ULONG Length
    )

/*++

Routine Description:

    Add an entry to the list of data blocks that should
    be saved in any triage dump generated.  The entire
    block must be valid for any of it to be saved.

Arguments:

    Address - Beginning of data block.

    Length - Length of data block.  This must be less than
             the triage dump size.

Return Value:

    TRUE - Block was added.

    FALSE - Block was not added.

--*/

{
    ULONG i;
    PTRIAGE_PTR_DATA_BLOCK Block;
    ULONG64 MinAddress, MaxAddress;

    // Check against SIZE32 for both 32 and 64-bit dumps
    // as no data block needs to be larger than that.
    if (Length >= TRIAGE_DUMP_SIZE32 ||
        !IopIsAddressRangeValid(Address, Length))
    {
        return FALSE;
    }
    
    MinAddress = Address;
    MaxAddress = MinAddress + Length;
    
    //
    // Minimize overlap between the new block and existing blocks.
    // Blocks cannot simply be merged as blocks are inserted in
    // priority order for storage in the dump.  Combining a low-priority
    // block with a high-priority block could lead to a medium-
    // priority block being bumped improperly from the dump.
    //

    Block = IopTriageDumpDataBlocks;
    for (i = 0; i < IopNumTriageDumpDataBlocks; i++, Block++)
    {
        if (MinAddress >= Block->MaxAddress ||
            MaxAddress <= Block->MinAddress)
        {
            // No overlap.
            continue;
        }

        //
        // Trim overlap out of the new block.  If this
        // would split the new block into pieces don't
        // trim to keep things simple.  Content may then
        // be duplicated in the dump.
        //
        
        if (MinAddress >= Block->MinAddress)
        {
            if (MaxAddress <= Block->MaxAddress)
            {
                // New block is completely contained.
                return TRUE;
            }

            // New block extends above the current block
            // so trim off the low-range overlap.
            MinAddress = Block->MaxAddress;
        }
        else if (MaxAddress <= Block->MaxAddress)
        {
            // New block extends below the current block
            // so trim off the high-range overlap.
            MaxAddress = Block->MinAddress;
        }
    }

    if (IopNumTriageDumpDataBlocks >= IO_MAX_TRIAGE_DUMP_DATA_BLOCKS)
    {
        return FALSE;
    }

    Block = IopTriageDumpDataBlocks + IopNumTriageDumpDataBlocks++;
    Block->MinAddress = MinAddress;
    Block->MaxAddress = MaxAddress;

    return TRUE;
}

VOID
IopAddRunTimeTriageDataBlocks(
    IN PCROSS_PLATFORM_CONTEXT Context,
    IN ULONG64 StackMin,
    IN ULONG64 StackMax,
    IN ULONG64 StoreMin,
    IN ULONG64 StoreMax
    )

/*++

Routine Description:

    Add data blocks referenced by the context or
    other runtime state.

Arguments:

    Context - Context record at the time the dump is being generated for.

    StackMin, StackMax - Stack memory boundaries.  Stack memory is
                         stored elsewhere in the dump.

    StoreMin, StoreMax - Backing store memory boundaries.  Store memory
                         is stored elsewhere in the dump.

Return Value:

    None.

--*/

{
    PUSHORT ContextOffset;

    switch(g_TargetMachineType)
    {
    case IMAGE_FILE_MACHINE_I386:
        ContextOffset = IopRunTimeContextOffsetsX86;
        break;
    case IMAGE_FILE_MACHINE_IA64:
        ContextOffset = IopRunTimeContextOffsetsIa64;
        break;
    case IMAGE_FILE_MACHINE_AMD64:
        ContextOffset = IopRunTimeContextOffsetsAmd64;
        break;
    default:
        ContextOffset = IopRunTimeContextOffsetsEmpty;
        break;
    }
    
    while (*ContextOffset < IOP_LAST_CONTEXT_OFFSET)
    {
        ULONG64 Ptr;

        //
        // Retrieve possible pointers from the context
        // registers.
        //

        if (g_Machine->m_Ptr64)
        {
            Ptr = *(PULONG64)((PUCHAR)Context + *ContextOffset);
        }
        else
        {
            Ptr = EXTEND64(*(PULONG)((PUCHAR)Context + *ContextOffset));
        }

        // Stack and backing store memory is already saved
        // so ignore any pointers that fall into those ranges.
        if ((Ptr < StackMin || Ptr >= StackMax) &&
            (Ptr < StoreMin || Ptr >= StoreMax))
        {
            IoAddTriageDumpDataBlock(PAGE_ALIGN(g_Machine, Ptr),
                                     g_Machine->m_PageSize);
        }
        
        ContextOffset++;
    }
}

ULONG
IopSizeTriageDumpDataBlocks(
    ULONG Offset,
    ULONG BufferSize,
    PULONG StartOffset,
    PULONG Count
    )
{
    ULONG i;
    ULONG Size;
    PTRIAGE_PTR_DATA_BLOCK Block;

    *Count = 0;
    
    Block = IopTriageDumpDataBlocks;
    for (i = 0; i < IopNumTriageDumpDataBlocks; i++, Block++)
    {
        Size = ALIGN_8(sizeof(TRIAGE_DATA_BLOCK)) +
            ALIGN_8((ULONG)(Block->MaxAddress - Block->MinAddress));
        if (Offset + Size >= BufferSize)
        {
            break;
        }

        if (i == 0)
        {
            *StartOffset = Offset;
        }

        Offset += Size;
        (*Count)++;
    }

    return Offset;
}

VOID
IopWriteTriageDumpDataBlocks(
    ULONG StartOffset,
    ULONG Count,
    PUCHAR BufferAddress
    )
{
    ULONG i;
    PTRIAGE_PTR_DATA_BLOCK Block;
    PUCHAR DataBuffer;
    PTRIAGE_DATA_BLOCK DumpBlock;

    DumpBlock = (PTRIAGE_DATA_BLOCK)
        (BufferAddress + StartOffset);
    DataBuffer = (PUCHAR)(DumpBlock + Count);
    
    Block = IopTriageDumpDataBlocks;
    for (i = 0; i < Count; i++, Block++)
    {
        DumpBlock->Address = Block->MinAddress;
        DumpBlock->Offset = (ULONG)(DataBuffer - BufferAddress);
        DumpBlock->Size = (ULONG)(Block->MaxAddress - Block->MinAddress);

        g_Target->ReadAllVirtual(Block->MinAddress, DataBuffer,
                                 DumpBlock->Size);
        
        DataBuffer += DumpBlock->Size;
        DumpBlock++;
    }
}

//----------------------------------------------------------------------------
//
// KernelTriage32DumpTargetInfo::Write.
//
//----------------------------------------------------------------------------

HRESULT
KernelTriage32DumpTargetInfo::Write(HANDLE hFile, ULONG FormatFlags,
                                    PCSTR Comment)
{
    HRESULT Status;
    PMEMORY_DUMP32 NewHeader;
    ULONG64 Addr;
    ULONG64 ThreadAddr;
    ULONG   Size;
    BOOL    PushedContext;
    ULONG   CodeMod;
    ULONG   BugCheckCode;
    ULONG64 BugCheckData[4];
    ULONG64 SaveDataPage = 0;

    if (!IS_KERNEL_TARGET())
    {
        ErrOut("kernel minidumps can only be written in kernel-mode sessions\n");
        return E_UNEXPECTED;
    }
    
    dprintf("mini kernel dump\n");
    FlushCallbacks();


    NewHeader = (PMEMORY_DUMP32) malloc(TRIAGE_DUMP_SIZE32);
    if (NewHeader == NULL)
    {
        return E_OUTOFMEMORY;
    }
    
    //
    // Get the current thread address, used to extract various blocks of data.
    // For some bugchecks the interesting thread is a different
    // thread than the current thread, so make the following code
    // generic so it handles any thread.
    //

    if ((Status = g_Target->
         ReadBugCheckData(&BugCheckCode, BugCheckData)) != S_OK)
    {
        goto NewHeader;
    }
    
    if (BugCheckCode == THREAD_STUCK_IN_DEVICE_DRIVER)
    {
        DEBUG_STACK_FRAME StkFrame;
        CROSS_PLATFORM_CONTEXT Context = {0};

        // Modify the bugcheck code to indicate this
        // minidump represents a special state.
        CodeMod = MINIDUMP_BUGCHECK;

        // The interesting thread is the first bugcheck parameter.
        ThreadAddr = BugCheckData[0];

        // We need to make the thread's context the current
        // machine context for the duration of dump generation.
        if ((Status = GetContextFromThreadStack(ThreadAddr, &Context,
                                                &StkFrame, FALSE)) != S_OK)
        {
            goto NewHeader;
        }

        g_Machine->PushContext(&Context);
        PushedContext = TRUE;
    }
    else if (BugCheckCode == SYSTEM_THREAD_EXCEPTION_NOT_HANDLED)
    {
        //
        // System thread stores a context record as the 4th parameter.
        // use that.
        // Also save the context record in case someone needs to look
        // at it.
        //

        if (BugCheckData[3])
        {
            CROSS_PLATFORM_CONTEXT TargetContext, Context;

            if (g_Target->
                ReadAllVirtual(BugCheckData[3], &TargetContext,
                               g_Machine->m_SizeTargetContext) == S_OK &&
                g_Machine->ConvertContextFrom(&Context, g_SystemVersion,
                                              g_Machine->m_SizeTargetContext,
                                              &TargetContext) == S_OK)
            {
                CodeMod = MINIDUMP_BUGCHECK;
                g_Machine->PushContext(&Context);
                PushedContext = TRUE;
                SaveDataPage = BugCheckData[3];
            }
        }
    }
    else if (BugCheckCode == KERNEL_MODE_EXCEPTION_NOT_HANDLED)
    {
        X86_KTRAP_FRAME Trap;
        CROSS_PLATFORM_CONTEXT Context = {0};

        //
        // 3rd parameter is a trap frame.
        //
        // Build a context record out of that only if it's a kernel mode
        // failure because esp may be wrong in that case ???.
        //
        // XXX drewb - This should be a machine method but
        // in order to localize code change to this file
        // for now I'm just making a check.
        if (g_TargetMachineType == IMAGE_FILE_MACHINE_I386 &&
            BugCheckData[2] &&
            g_Target->
            ReadAllVirtual(BugCheckData[2], &Trap, sizeof(Trap)) == S_OK)
        {
            if ((Trap.SegCs & 1) || X86_IS_VM86(Trap.EFlags))
            {
                Context.X86Context.Esp = Trap.HardwareEsp;
            }
            else
            {
                Context.X86Context.Esp = (ULONG)BugCheckData[2] +
                    FIELD_OFFSET(X86_KTRAP_FRAME, HardwareEsp);
            }
            if (X86_IS_VM86(Trap.EFlags))
            {
                Context.X86Context.SegSs =
                    (USHORT)(Trap.HardwareSegSs & 0xffff);
            }
            else if ((Trap.SegCs & X86_MODE_MASK) != 0 /*KernelMode*/)
            {
                //
                // It's user mode.  The HardwareSegSs contains R3 data selector.
                //

                Context.X86Context.SegSs =
                    (USHORT)(Trap.HardwareSegSs | 3) & 0xffff;
            }
            else
            {
                Context.X86Context.SegSs = X86_KGDT_R0_DATA;
            }

            Context.X86Context.SegGs = Trap.SegGs & 0xffff;
            Context.X86Context.SegFs = Trap.SegFs & 0xffff;
            Context.X86Context.SegEs = Trap.SegEs & 0xffff;
            Context.X86Context.SegDs = Trap.SegDs & 0xffff;
            Context.X86Context.SegCs = Trap.SegCs & 0xffff;
            Context.X86Context.Eip = Trap.Eip;
            Context.X86Context.Ebp = Trap.Ebp;
            Context.X86Context.Eax = Trap.Eax;
            Context.X86Context.Ebx = Trap.Ebx;
            Context.X86Context.Ecx = Trap.Ecx;
            Context.X86Context.Edx = Trap.Edx;
            Context.X86Context.Edi = Trap.Edi;
            Context.X86Context.Esi = Trap.Esi;
            Context.X86Context.EFlags = Trap.EFlags;
            
            CodeMod = MINIDUMP_BUGCHECK;
            g_Machine->PushContext(&Context);
            PushedContext = TRUE;
            SaveDataPage = BugCheckData[2];
        }
    }
    else if (BugCheckCode == UNEXPECTED_KERNEL_MODE_TRAP)
    {
        // XXX drewb - Put this in ntdbg.h and remove it
        // from i386_reg.cpp.
#define MAX_RING 3
        struct X86_KTSS
        {
            // Intel's TSS format
            ULONG   Previous;
            struct
            {
                ULONG   Esp;
                ULONG   Ss;
            } Ring[MAX_RING];
            ULONG   Cr3;
            ULONG   Eip;
            ULONG   EFlags;
            ULONG   Eax;
            ULONG   Ecx;
            ULONG   Edx;
            ULONG   Ebx;
            ULONG   Esp;
            ULONG   Ebp;
            ULONG   Esi;
            ULONG   Edi;
            ULONG   Es;
            ULONG   Cs;
            ULONG   Ss;
            ULONG   Ds;
            ULONG   Fs;
            ULONG   Gs;
            ULONG   Ldt;
            USHORT  T;
            USHORT  IoMapBase;
        };

        X86_KTSS Tss;
        CROSS_PLATFORM_CONTEXT Context = {0};

        //
        // Double fault
        //

        // XXX drewb - This should be a machine method but
        // in order to localize code change to this file
        // for now I'm just making a check.
        if (g_TargetMachineType == IMAGE_FILE_MACHINE_I386 &&
            BugCheckData[0] == 8 &&
            BugCheckData[1] &&
            g_Target->
            ReadAllVirtual(BugCheckData[1], &Tss, sizeof(Tss)) == S_OK)
        {
            // The thread is correct in this case.
            // Second parameter is the TSS.  If we have a TSS, convert
            // the context and mark the bugcheck as converted.

            if (Tss.EFlags & X86_EFLAGS_V86_MASK)
            {
                Context.X86Context.SegSs = (USHORT)(Tss.Ss & 0xffff);
            }
            else if ((Tss.Cs & X86_MODE_MASK) != 0)
            {
                //
                // It's user mode.
                // The HardwareSegSs contains R3 data selector.
                //

                Context.X86Context.SegSs =
                    (USHORT)(Tss.Ss | 3) & 0xffff;
            }
            else
            {
                Context.X86Context.SegSs = X86_KGDT_R0_DATA;
            }

            Context.X86Context.SegGs = Tss.Gs & 0xffff;
            Context.X86Context.SegFs = Tss.Fs & 0xffff;
            Context.X86Context.SegEs = Tss.Es & 0xffff;
            Context.X86Context.SegDs = Tss.Ds & 0xffff;
            Context.X86Context.SegCs = Tss.Cs & 0xffff;
            Context.X86Context.Esp = Tss.Esp;
            Context.X86Context.Eip = Tss.Eip;
            Context.X86Context.Ebp = Tss.Ebp;
            Context.X86Context.Eax = Tss.Eax;
            Context.X86Context.Ebx = Tss.Ebx;
            Context.X86Context.Ecx = Tss.Ecx;
            Context.X86Context.Edx = Tss.Edx;
            Context.X86Context.Edi = Tss.Edi;
            Context.X86Context.Esi = Tss.Esi;
            Context.X86Context.EFlags = Tss.EFlags;
            
            CodeMod = MINIDUMP_BUGCHECK;
            g_Machine->PushContext(&Context);
            PushedContext = TRUE;
        }
    }
    else
    {
        CodeMod = 0;

        Status = g_Target->
            GetThreadInfoDataOffset(NULL,
                                    VIRTUAL_THREAD_HANDLE(CURRENT_PROC),
                                    &ThreadAddr);
        if (Status != S_OK)
        {
            goto NewHeader;
        }

        PushedContext = FALSE;
    }

    CCrashDumpWrapper32 Wrapper;

    //
    // setup the main header
    //

    KernelDumpTargetInfo::InitDumpHeader32(&NewHeader->Header, Comment,
                                           CodeMod);
    NewHeader->Header.DumpType = DUMP_TYPE_TRIAGE;
    NewHeader->Header.MiniDumpFields = TRIAGE_DUMP_BASIC_INFO;

    //
    // triage dump header begins on second page
    //

    TRIAGE_DUMP32 *ptdh = &NewHeader->Triage;
    
    ULONG i;

    ptdh->ServicePackBuild = g_TargetServicePackNumber;
    ptdh->SizeOfDump = TRIAGE_DUMP_SIZE32;
    
    ptdh->ContextOffset = FIELD_OFFSET (DUMP_HEADER32, ContextRecord);
    ptdh->ExceptionOffset = FIELD_OFFSET (DUMP_HEADER32, Exception);

    //
    // starting offset in triage dump follows the triage dump header
    //

    unsigned offset =
        ALIGN_8(g_TargetMachine->m_PageSize + sizeof(TRIAGE_DUMP32));

    //
    // write mm information for Win2K and above only
    //

    if (g_SystemVersion >= NT_SVER_W2K)
    {
        ptdh->MmOffset = offset;
        Wrapper.WriteMmTriageInformation((PBYTE)NewHeader + ptdh->MmOffset);
        offset += ALIGN_8(sizeof(DUMP_MM_STORAGE32));
    }

    //
    // write unloaded drivers
    //

    ptdh->UnloadedDriversOffset = offset;
    Wrapper.WriteUnloadedDrivers((PBYTE)NewHeader +
                                 ptdh->UnloadedDriversOffset);
    offset += ALIGN_8(sizeof(ULONG) +
                      MI_UNLOADED_DRIVERS * sizeof(DUMP_UNLOADED_DRIVERS32));

    //
    // write processor control block (KPRCB)
    //

    if (S_OK == g_Target->GetProcessorSystemDataOffset(CURRENT_PROC,
                                                       DEBUG_DATA_KPRCB_OFFSET,
                                                       &Addr))
    {
        ptdh->PrcbOffset = offset;
        g_Target->ReadVirtual(Addr,
                              ((PBYTE)NewHeader) + ptdh->PrcbOffset,
                              g_TargetMachine->m_SizePrcb,
                              &Size);
        offset += ALIGN_8(g_TargetMachine->m_SizePrcb);
    }

    //
    // Write the thread and process data structures.
    //

    ptdh->ProcessOffset = offset;
    offset += ALIGN_8(g_TargetMachine->m_SizeEProcess);
    ptdh->ThreadOffset = offset;
    offset += ALIGN_8(g_TargetMachine->m_SizeEThread);

    g_Target->ReadVirtual(ThreadAddr +
                          g_TargetMachine->m_OffsetKThreadApcProcess,
                          (PBYTE)NewHeader + ptdh->ProcessOffset,
                          g_TargetMachine->m_SizeEProcess,
                          &Size);

    g_Target->ReadVirtual(ThreadAddr,
                          (PBYTE)NewHeader + ptdh->ThreadOffset,
                          g_TargetMachine->m_SizeEThread,
                          &Size);

    //
    // write the call stack
    //

    ADDR StackPtr;
    ULONG64 StackBase = 0;

    g_Machine->GetSP(&StackPtr);
    ptdh->TopOfStack = (ULONG)(ULONG_PTR)Flat(StackPtr);

    g_Target->ReadPointer(g_TargetMachine,
                          g_TargetMachine->m_OffsetKThreadInitialStack +
                          ThreadAddr,
                          &StackBase);

    // Take the Min in case something goes wrong getting the stack base.

    ptdh->SizeOfCallStack = min((ULONG)(ULONG_PTR)(StackBase - Flat(StackPtr)),
                                MAX_TRIAGE_STACK_SIZE);

    ptdh->CallStackOffset = offset;

    if (ptdh->SizeOfCallStack)
    {
        g_Target->ReadVirtual(ptdh->TopOfStack,
                              ((PBYTE)NewHeader) + ptdh->CallStackOffset,
                              ptdh->SizeOfCallStack,
                              &Size);
    }
    offset += ALIGN_8(ptdh->SizeOfCallStack);

    //
    // write debugger data
    //

    if (g_SystemVersion >= NT_SVER_W2K_WHISTLER &&
        g_KdDebuggerDataBlock &&
        (!IS_KERNEL_TRIAGE_DUMP() || g_TriageDumpHasDebuggerData) &&
        offset + ALIGN_8(sizeof(KdDebuggerData)) < TRIAGE_DUMP_SIZE32)
    {
        NewHeader->Header.MiniDumpFields |= TRIAGE_DUMP_DEBUGGER_DATA;
        ptdh->DebuggerDataOffset = offset;
        offset += ALIGN_8(sizeof(KdDebuggerData));
        ptdh->DebuggerDataSize = sizeof(KdDebuggerData);
        memcpy((PBYTE)NewHeader + ptdh->DebuggerDataOffset,
               &KdDebuggerData, sizeof(KdDebuggerData));
    }
            
    //
    // write loaded driver list
    //

    ModuleInfo* ModIter;
    ULONG MaxEntries;

    // Use a heuristic to guess how many entries we
    // can pack into the remaining space.
    MaxEntries = (TRIAGE_DUMP_SIZE32 - offset) /
        (sizeof(DUMP_DRIVER_ENTRY32) + TRIAGE_DRIVER_NAME_SIZE_GUESS);

    ptdh->DriverCount = 0;
    if ((ModIter = g_Target->GetModuleInfo(FALSE)) &&
        ((ModIter->Initialize()) == S_OK))
    {
        while (ptdh->DriverCount < MaxEntries)
        {
            MODULE_INFO_ENTRY ModEntry;
            
            ULONG retval = GetNextModuleEntry(ModIter, &ModEntry);

            if (retval == 1)
            {
                break;
            }
            else if (retval == 2)
            {
                continue;
            }

            ptdh->DriverCount++;
        }
    }

    ptdh->DriverListOffset = offset;
    offset += ALIGN_8(ptdh->DriverCount * sizeof(DUMP_DRIVER_ENTRY32));
    ptdh->StringPoolOffset = offset;
    ptdh->BrokenDriverOffset = 0;

    Wrapper.WriteDriverList((PBYTE)NewHeader, ptdh);

    offset = ptdh->StringPoolOffset + ptdh->StringPoolSize;
    offset += ALIGN_8(offset);
    
    //
    // For XP and above add in any additional data pages and write out
    // whatever fits.
    //

    if (g_SystemVersion >= NT_SVER_W2K_WHISTLER)
    {
        if (SaveDataPage)
        {
            IoAddTriageDumpDataBlock(PAGE_ALIGN(g_Machine, SaveDataPage),
                                     g_Machine->m_PageSize);
        }

        // If the DPC stack is active, save that data page as well.
        // XXX drewb - Put into ntdbg.h and virtualize through machine.
#define X86_KPRCB_DPC_ROUTINE_ACTIVE 0x874
        if (g_TargetMachineType == IMAGE_FILE_MACHINE_I386 &&
            ptdh->PrcbOffset &&
            (*(PULONG)((PUCHAR)NewHeader +
                       ptdh->PrcbOffset + X86_KPRCB_DPC_ROUTINE_ACTIVE)))
        {
            IoAddTriageDumpDataBlock
                (PAGE_ALIGN(g_Machine,
                            EXTEND64(*(PULONG)((PUCHAR)NewHeader +
                                               ptdh->PrcbOffset +
                                               X86_KPRCB_DPC_ROUTINE_ACTIVE))),
                 g_Machine->m_PageSize);
        }
    
        // Add data blocks which might be referred to by
        // the context or other runtime state.
        IopAddRunTimeTriageDataBlocks(&g_Machine->m_Context,
                                      EXTEND64(ptdh->TopOfStack),
                                      EXTEND64(ptdh->TopOfStack +
                                               ptdh->SizeOfCallStack),
                                      0, 0);
        
        // Check which data blocks fit and write them.
        offset = IopSizeTriageDumpDataBlocks(offset, TRIAGE_DUMP_SIZE32,
                                             &ptdh->DataBlocksOffset,
                                             &ptdh->DataBlocksCount);
        offset += ALIGN_8(offset);
        if (ptdh->DataBlocksCount)
        {
            NewHeader->Header.MiniDumpFields |= TRIAGE_DUMP_DATA_BLOCKS;
            IopWriteTriageDumpDataBlocks(ptdh->DataBlocksOffset,
                                         ptdh->DataBlocksCount,
                                         (PUCHAR)NewHeader);
        }
    }
    
    //
    // all options are enabled
    //

    ptdh->TriageOptions = 0xffffffff;

    //
    // end of triage dump validated
    //

    ptdh->ValidOffset = TRIAGE_DUMP_SIZE32 - sizeof(ULONG);
    *(PULONG)(((PBYTE) NewHeader) + ptdh->ValidOffset) = TRIAGE_DUMP_VALID;

    //
    // Write it out to the file.
    //

    ULONG cbWritten;

    if (!WriteFile(hFile,
                   NewHeader,
                   TRIAGE_DUMP_SIZE32,
                   &cbWritten,
                   NULL))
    {
        Status = WIN32_LAST_STATUS();
        ErrOut("Write to minidump file failed for reason %s\n     \"%s\"\n",
               FormatStatusCode(Status),
               FormatStatusArgs(Status, NULL));
    }

    if (cbWritten != TRIAGE_DUMP_SIZE32)
    {
        ErrOut("Write to minidump failed because disk is full.\n");
        Status = E_FAIL;
    }

    if (PushedContext)
    {
        g_Machine->PopContext();
    }
    
 NewHeader:
    free(NewHeader);
    return Status;
}

//----------------------------------------------------------------------------
//
// KernelTriage64DumpTargetInfo::Write.
//
//----------------------------------------------------------------------------

HRESULT
KernelTriage64DumpTargetInfo::Write(HANDLE hFile, ULONG FormatFlags,
                                    PCSTR Comment)
{
    HRESULT Status;
    PMEMORY_DUMP64 NewHeader;
    ULONG64 Addr;
    ULONG64 ThreadAddr;
    ULONG   Size;
    BOOL    PushedContext;
    ULONG   CodeMod;
    ULONG   BugCheckCode;
    ULONG64 BugCheckData[4];
    ULONG64 SaveDataPage = 0;
    ULONG64 BStoreBase = 0;
    ULONG   BStoreSize = 0;

    if (!IS_KERNEL_TARGET())
    {
        ErrOut("kernel minidumps can only be written in kernel-mode sessions\n");
        return E_UNEXPECTED;
    }
    
    dprintf("mini kernel dump\n");
    FlushCallbacks();


    NewHeader = (PMEMORY_DUMP64) malloc(TRIAGE_DUMP_SIZE64);
    if (NewHeader == NULL)
    {
        return E_OUTOFMEMORY;
    }
    
    //
    // Get the current thread address, used to extract various blocks of data.
    // For some bugchecks the interesting thread is a different
    // thread than the current thread, so make the following code
    // generic so it handles any thread.
    //

    if ((Status = g_Target->
         ReadBugCheckData(&BugCheckCode, BugCheckData)) != S_OK)
    {
        goto NewHeader;
    }
    
    if (BugCheckCode == THREAD_STUCK_IN_DEVICE_DRIVER)
    {
        DEBUG_STACK_FRAME StkFrame;
        CROSS_PLATFORM_CONTEXT Context = {0};

        // Modify the bugcheck code to indicate this
        // minidump represents a special state.
        CodeMod = MINIDUMP_BUGCHECK;

        // The interesting thread is the first bugcheck parameter.
        ThreadAddr = BugCheckData[0];

        // We need to make the thread's context the current
        // machine context for the duration of dump generation.
        if ((Status = GetContextFromThreadStack(ThreadAddr, &Context,
                                                &StkFrame, FALSE)) != S_OK)
        {
            goto NewHeader;
        }

        g_Machine->PushContext(&Context);
        PushedContext = TRUE;
    }
    else if (BugCheckCode == SYSTEM_THREAD_EXCEPTION_NOT_HANDLED)
    {
        //
        // System thread stores a context record as the 4th parameter.
        // use that.
        // Also save the context record in case someone needs to look
        // at it.
        //

        if (BugCheckData[3])
        {
            CROSS_PLATFORM_CONTEXT TargetContext, Context;

            if (ReadAllVirtual(BugCheckData[3], &TargetContext,
                               g_Machine->m_SizeTargetContext) == S_OK &&
                g_Machine->ConvertContextFrom(&Context, g_SystemVersion,
                                              g_Machine->m_SizeTargetContext,
                                              &TargetContext) == S_OK)
            {
                CodeMod = MINIDUMP_BUGCHECK;
                g_Machine->PushContext(&Context);
                PushedContext = TRUE;
                SaveDataPage = BugCheckData[3];
            }
        }
    }
    else
    {
        CodeMod = 0;

        Status = g_Target->
            GetThreadInfoDataOffset(NULL,
                                    VIRTUAL_THREAD_HANDLE(CURRENT_PROC),
                                    &ThreadAddr);
        if (Status != S_OK)
        {
            goto NewHeader;
        }

        PushedContext = FALSE;
    }

    CCrashDumpWrapper64 Wrapper;

    //
    // setup the main header
    //

    KernelDumpTargetInfo::InitDumpHeader64(&NewHeader->Header, Comment,
                                           CodeMod);
    NewHeader->Header.DumpType = DUMP_TYPE_TRIAGE;
    NewHeader->Header.MiniDumpFields = TRIAGE_DUMP_BASIC_INFO;

    //
    // triage dump header begins on second page
    //

    TRIAGE_DUMP64 *ptdh = &NewHeader->Triage;

    ULONG i;

    ptdh->ServicePackBuild = g_TargetServicePackNumber;
    ptdh->SizeOfDump = TRIAGE_DUMP_SIZE64;

    ptdh->ContextOffset = FIELD_OFFSET (DUMP_HEADER64, ContextRecord);
    ptdh->ExceptionOffset = FIELD_OFFSET (DUMP_HEADER64, Exception);

    //
    // starting offset in triage dump follows the triage dump header
    //

    unsigned offset =
        ALIGN_8(g_TargetMachine->m_PageSize + sizeof(TRIAGE_DUMP64));

    //
    // write mm information
    //

    ptdh->MmOffset = offset;
    Wrapper.WriteMmTriageInformation((PBYTE)NewHeader + ptdh->MmOffset);
    offset += ALIGN_8(sizeof(DUMP_MM_STORAGE64));

    //
    // write unloaded drivers
    //

    ptdh->UnloadedDriversOffset = offset;
    Wrapper.WriteUnloadedDrivers((PBYTE)NewHeader + ptdh->UnloadedDriversOffset);
    offset += ALIGN_8(sizeof(ULONG64) +
                      MI_UNLOADED_DRIVERS * sizeof(DUMP_UNLOADED_DRIVERS64));

    //
    // write processor control block (KPRCB)
    //

    if (S_OK == g_Target->GetProcessorSystemDataOffset(CURRENT_PROC,
                                                       DEBUG_DATA_KPRCB_OFFSET,
                                                       &Addr))
    {
        ptdh->PrcbOffset = offset;
        g_Target->ReadVirtual(Addr,
                              ((PBYTE)NewHeader) + ptdh->PrcbOffset,
                              g_TargetMachine->m_SizePrcb,
                              &Size);
        offset += ALIGN_8(g_TargetMachine->m_SizePrcb);
    }

    //
    // Write the thread and process data structures.
    //

    ptdh->ProcessOffset = offset;
    offset += ALIGN_8(g_TargetMachine->m_SizeEProcess);
    ptdh->ThreadOffset = offset;
    offset += ALIGN_8(g_TargetMachine->m_SizeEThread);

    g_Target->ReadVirtual(ThreadAddr + g_TargetMachine->m_OffsetKThreadApcProcess,
                          (PBYTE)NewHeader + ptdh->ProcessOffset,
                          g_TargetMachine->m_SizeEProcess,
                          &Size);

    g_Target->ReadVirtual(ThreadAddr,
                          (PBYTE)NewHeader + ptdh->ThreadOffset,
                          g_TargetMachine->m_SizeEThread,
                          &Size);


    //
    // write the call stack
    //

    ADDR StackPtr;
    ULONG64 StackBase = 0;

    g_Machine->GetSP(&StackPtr);
    ptdh->TopOfStack = Flat(StackPtr);

    g_Target->ReadPointer(g_TargetMachine,
                          g_TargetMachine->m_OffsetKThreadInitialStack +
                          ThreadAddr, &StackBase);

    // Take the Min in case something goes wrong getting the stack base.

    ptdh->SizeOfCallStack =
        min((ULONG)(ULONG_PTR)(StackBase - Flat(StackPtr)),
            MAX_TRIAGE_STACK_SIZE);

    ptdh->CallStackOffset = offset;

    if (ptdh->SizeOfCallStack)
    {
        g_Target->ReadVirtual(ptdh->TopOfStack,
                              ((PBYTE)NewHeader) + ptdh->CallStackOffset,
                              ptdh->SizeOfCallStack,
                              &Size);
    }
    offset += ALIGN_8(ptdh->SizeOfCallStack);

    //
    // The IA64 contains two callstacks. The first is the normal
    // callstack, and the second is a scratch region where
    // the processor can spill registers. It is this latter stack,
    // the backing-store, that we now save.
    //

    if (g_TargetMachineType == IMAGE_FILE_MACHINE_IA64)
    {
        ULONG64 BStoreLimit;

        g_Target->ReadPointer(g_TargetMachine,
                              ThreadAddr + FIELD_OFFSET(IA64_THREAD,
                                                        InitialBStore),
                              &BStoreBase);
        g_Target->ReadPointer(g_TargetMachine,
                              ThreadAddr + FIELD_OFFSET(IA64_THREAD,
                                                        BStoreLimit),
                              &BStoreLimit);

        ptdh->ArchitectureSpecific.Ia64.BStoreOffset = offset;
        ptdh->ArchitectureSpecific.Ia64.LimitOfBStore = BStoreLimit;
        ptdh->ArchitectureSpecific.Ia64.SizeOfBStore =
            min((ULONG)(BStoreLimit - BStoreBase),
                MAX_TRIAGE_BSTORE_SIZE);
        BStoreSize = ptdh->ArchitectureSpecific.Ia64.SizeOfBStore;

        if (ptdh->ArchitectureSpecific.Ia64.SizeOfBStore)
        {
            g_Target->ReadVirtual(BStoreBase, ((PBYTE)NewHeader) +
                                  ptdh->ArchitectureSpecific.Ia64.BStoreOffset,
                                  ptdh->ArchitectureSpecific.Ia64.SizeOfBStore,
                                  &Size);
            offset +=
                ALIGN_8(ptdh->ArchitectureSpecific.Ia64.SizeOfBStore);
        }
    }

    //
    // write debugger data
    //

    if (g_SystemVersion >= NT_SVER_W2K_WHISTLER &&
        g_KdDebuggerDataBlock &&
        (!IS_KERNEL_TRIAGE_DUMP() || g_TriageDumpHasDebuggerData) &&
        offset + ALIGN_8(sizeof(KdDebuggerData)) < TRIAGE_DUMP_SIZE64)
    {
        NewHeader->Header.MiniDumpFields |= TRIAGE_DUMP_DEBUGGER_DATA;
        ptdh->DebuggerDataOffset = offset;
        offset += ALIGN_8(sizeof(KdDebuggerData));
        ptdh->DebuggerDataSize = sizeof(KdDebuggerData);
        memcpy((PBYTE)NewHeader + ptdh->DebuggerDataOffset,
               &KdDebuggerData, sizeof(KdDebuggerData));
    }
            
    //
    // write loaded driver list
    //

    ModuleInfo* ModIter;
    ULONG MaxEntries;

        // Use a heuristic to guess how many entries we
        // can pack into the remaining space.
    MaxEntries = (TRIAGE_DUMP_SIZE64 - offset) /
        (sizeof(DUMP_DRIVER_ENTRY64) + TRIAGE_DRIVER_NAME_SIZE_GUESS);
        
    ptdh->DriverCount = 0;
    if ((ModIter = g_Target->GetModuleInfo(FALSE)) &&
        ((ModIter->Initialize()) == S_OK))
    {
        while (ptdh->DriverCount < MaxEntries)
        {
            MODULE_INFO_ENTRY ModEntry;

            ULONG retval = GetNextModuleEntry(ModIter, &ModEntry);

            if (retval == 1)
            {
                break;
            }
            else if (retval == 2)
            {
                continue;
            }

            ptdh->DriverCount++;
        }
    }

    ptdh->DriverListOffset = offset;
    offset += ALIGN_8(ptdh->DriverCount * sizeof(DUMP_DRIVER_ENTRY64));
    ptdh->StringPoolOffset = offset;
    ptdh->BrokenDriverOffset = 0;

    Wrapper.WriteDriverList((PBYTE)NewHeader, ptdh);

    offset = ptdh->StringPoolOffset + ptdh->StringPoolSize;
    offset += ALIGN_8(offset);
    
    //
    // For XP and above add in any additional data pages and write out
    // whatever fits.
    //

    if (g_SystemVersion >= NT_SVER_W2K_WHISTLER)
    {
        if (SaveDataPage)
        {
            IoAddTriageDumpDataBlock(PAGE_ALIGN(g_Machine, SaveDataPage),
                                     g_Machine->m_PageSize);
        }

        // Add data blocks which might be referred to by
        // the context or other runtime state.
        IopAddRunTimeTriageDataBlocks(&g_Machine->m_Context,
                                      ptdh->TopOfStack,
                                      ptdh->TopOfStack +
                                      ptdh->SizeOfCallStack,
                                      BStoreBase,
                                      BStoreSize);
        
        // Check which data blocks fit and write them.
        offset = IopSizeTriageDumpDataBlocks(offset, TRIAGE_DUMP_SIZE64,
                                             &ptdh->DataBlocksOffset,
                                             &ptdh->DataBlocksCount);
        offset += ALIGN_8(offset);
        if (ptdh->DataBlocksCount)
        {
            NewHeader->Header.MiniDumpFields |= TRIAGE_DUMP_DATA_BLOCKS;
            IopWriteTriageDumpDataBlocks(ptdh->DataBlocksOffset,
                                         ptdh->DataBlocksCount,
                                         (PUCHAR)NewHeader);
        }
    }
    
    //
    // all options are enabled
    //

    ptdh->TriageOptions = 0xffffffff;

    //
    // end of triage dump validated
    //

    ptdh->ValidOffset = TRIAGE_DUMP_SIZE64 - sizeof(ULONG);
    *(PULONG)(((PBYTE) NewHeader) + ptdh->ValidOffset) = TRIAGE_DUMP_VALID;

        //
        // Write it out to the file.
        //

    ULONG cbWritten;

    if (!WriteFile(hFile,
                   NewHeader,
                   TRIAGE_DUMP_SIZE64,
                   &cbWritten,
                   NULL))
    {
        Status = WIN32_LAST_STATUS();
        ErrOut("Write to minidump file failed for reason %s\n     \"%s\"\n",
               FormatStatusCode(Status),
               FormatStatusArgs(Status, NULL));
    }

    if (cbWritten != TRIAGE_DUMP_SIZE64)
    {
        ErrOut("Write to minidump failed because disk is full.\n");
        Status = E_FAIL;
    }

    if (PushedContext)
    {
        g_Machine->PopContext();
    }
    
 NewHeader:
    free(NewHeader);
    return Status;
}

//----------------------------------------------------------------------------
//
// Functions.
//
//----------------------------------------------------------------------------

HRESULT
WriteDumpFile(PCSTR DumpFile, ULONG Qualifier, ULONG FormatFlags,
              PCSTR Comment)
{
    ULONG DumpType = DTYPE_COUNT;
    DumpTargetInfo* DumpTarget;
    HRESULT Status;
    ULONG OldMachine;
    HANDLE FileHandle;

    if (!IS_MACHINE_ACCESSIBLE())
    {
        return E_UNEXPECTED;
    }

    if (IS_KERNEL_TARGET())
    {
        if (FormatFlags != DEBUG_FORMAT_DEFAULT)
        {
            return E_INVALIDARG;
        }
        
        //
        // not much we can do without the processor block
        // or at least the PRCB for the current process in a minidump.
        //

        if (!KdDebuggerData.KiProcessorBlock &&
            !g_DumpKiProcessors[CURRENT_PROC])
        {
            ErrOut("Cannot find KiProcessorBlock - "
                   "can not create dump file\n");

            return E_FAIL;
        }

        switch(Qualifier)
        {
        case DEBUG_KERNEL_SMALL_DUMP:
            DumpType = g_TargetMachine->m_Ptr64 ?
                DTYPE_KERNEL_TRIAGE64 : DTYPE_KERNEL_TRIAGE32;
            break;
        case DEBUG_KERNEL_FULL_DUMP:
            if (g_DbgKdTransport != NULL &&
                g_DbgKdTransport->m_DirectPhysicalMemory == FALSE)
            {
                WarnOut("Creating a full kernel dump over the COM port is a "
                        "VERY VERY slow operation.\n"
                        "This command may take many HOURS to complete.  "
                        "Ctrl-C if you want to terminate the command.\n");
            }
            DumpType = g_TargetMachine->m_Ptr64 ?
                DTYPE_KERNEL_FULL64 : DTYPE_KERNEL_FULL32;
            break;
        default:
            // Other formats are not supported.
            return E_INVALIDARG;
        }
    }
    else
    {
        DBG_ASSERT(IS_USER_TARGET());
        
        switch(Qualifier)
        {
        case DEBUG_USER_WINDOWS_SMALL_DUMP:
            if (FormatFlags & ~(DEBUG_FORMAT_USER_SMALL_FULL_MEMORY |
                                DEBUG_FORMAT_USER_SMALL_HANDLE_DATA |
                                FORMAT_USER_MICRO))
            {
                return E_INVALIDARG;
            }

            DumpType = (FormatFlags & DEBUG_FORMAT_USER_SMALL_FULL_MEMORY) ?
                DTYPE_USER_MINI_FULL : DTYPE_USER_MINI_PARTIAL;
            break;
            
        case DEBUG_USER_WINDOWS_DUMP:
            if (FormatFlags != DEBUG_FORMAT_DEFAULT)
            {
                return E_INVALIDARG;
            }
            
            DumpType = g_TargetMachine->m_Ptr64 ?
                DTYPE_USER_FULL64 : DTYPE_USER_FULL32;
            break;
        default:
            // Other formats are not supported.
            return E_INVALIDARG;
        }
    }

    DBG_ASSERT(DumpType < DTYPE_COUNT);

    // Ensure that the dump is always written according to the
    // target machine type and not any emulated machine.
    OldMachine = g_EffMachine;
    SetEffMachine(g_TargetMachineType, FALSE);

    // Flush context first so that the minidump reads the
    // same register values the debugger has.
    FlushRegContext();

    FileHandle = CreateFile(DumpFile, GENERIC_READ | GENERIC_WRITE, 0,
                            NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,
                            NULL);
    if (FileHandle == INVALID_HANDLE_VALUE)
    {
        Status = WIN32_LAST_STATUS();
        ErrOut("Unable to create file '%s' - %s\n    \"%s\"\n", DumpFile,
                FormatStatusCode(Status), FormatStatusArgs(Status, NULL));
    }
    else
    {
        dprintf("Creating %s - ", DumpFile);
        Status = g_DumpTargets[DumpType]->Write(FileHandle, FormatFlags,
                                                Comment);

        CloseHandle(FileHandle);
        if (Status != S_OK)
        {
            DeleteFile(DumpFile);
        }
    }

    SetEffMachine(OldMachine, FALSE);
    return Status;
}

void
ParseDumpFileCommand(void)
{
    BOOL Usage = FALSE;
    ULONG Qual;
    ULONG FormatFlags;

    //
    // Default to minidumps
    //

    if (IS_KERNEL_TARGET())
    {
        Qual = DEBUG_KERNEL_SMALL_DUMP;
        
        if (IS_LOCAL_KERNEL_TARGET())
        {
            error(SESSIONNOTSUP);
        }
    }
    else
    {
        Qual = DEBUG_USER_WINDOWS_SMALL_DUMP;
    }
    FormatFlags = DEBUG_FORMAT_DEFAULT;

    //
    // Scan for options.
    //

    CHAR Save;
    PSTR FileName;
    BOOL SubLoop;
    PCSTR Comment = NULL;
    PSTR CommentEnd = NULL;
    BOOL Unique = FALSE;
    PPROCESS_INFO DumpProcess = g_CurrentProcess;
    
    for (;;)
    {
        if (PeekChar() == '-' || *g_CurCmd == '/')
        {
            SubLoop = TRUE;
            
            g_CurCmd++;
            switch(*g_CurCmd)
            {
            case 'a':
                DumpProcess = NULL;
                break;
                
            case 'c':
                g_CurCmd++;
                Comment = StringValue(STRV_SPACE_IS_SEPARATOR |
                                      STRV_TRIM_TRAILING_SPACE, &Save);
                *g_CurCmd = Save;
                CommentEnd = g_CurCmd;
                break;
                
            case 'f':
                if (IS_KERNEL_TARGET())
                {
                    Qual = DEBUG_KERNEL_FULL_DUMP;
                }
                else
                {
                    Qual = DEBUG_USER_WINDOWS_DUMP;
                }
                break;

            case 'm':
                if (IS_KERNEL_TARGET())
                {
                    Qual = DEBUG_KERNEL_SMALL_DUMP;
                }
                else
                {
                    Qual = DEBUG_USER_WINDOWS_SMALL_DUMP;

                    for (;;)
                    {
                        switch(*(g_CurCmd + 1))
                        {
                        case 'C':
                            // Flag to test microdump code.
                            FormatFlags |= FORMAT_USER_MICRO;
                            break;
                        case 'f':
                            FormatFlags |= DEBUG_FORMAT_USER_SMALL_FULL_MEMORY;
                            break;
                        case 'h':
                            FormatFlags |= DEBUG_FORMAT_USER_SMALL_HANDLE_DATA;
                            break;
                        default:
                            SubLoop = FALSE;
                            break;
                        }

                        if (SubLoop)
                        {
                            g_CurCmd++;
                        }
                        else
                        {
                            break;
                        }
                    }
                }
                break;

            case 'u':
                Unique = TRUE;
                break;
                    
            default:
                ErrOut("Unknown option '%c'\n", *g_CurCmd);
                Usage = TRUE;
                break;
            }

            g_CurCmd++;
        }
        else
        {
            FileName = StringValue(STRV_TRIM_TRAILING_SPACE, &Save);
            if (*FileName)
            {
                break;
            }
            else
            {
                *g_CurCmd = Save;
                Usage = TRUE;
            }
        }

        if (Usage)
        {
            break;
        }
    }

    if (DumpProcess == NULL && !Unique)
    {
        Usage = TRUE;
    }
    
    if (Usage)
    {
        ErrOut("Usage: .dump [options] filename\n");
        ErrOut("Options are:\n");
        ErrOut("  /a - Create dumps for all processes (requires -u)\n");
        ErrOut("  /c <comment> - Add a comment "
               "(not supported in all formats)\n");
        ErrOut("  /f - Create a full dump\n");
        if (IS_KERNEL_TARGET())
        {
            ErrOut("  /m - Create a minidump (default)\n");
        }
        else
        {
            ErrOut("  /m[f][h] - Create a minidump (default)\n");
        }
        ErrOut("  /u - Append unique identifier to dump name\n");
        return;
    }

    if (CommentEnd != NULL)
    {
        *CommentEnd = 0;
    }

    PTHREAD_INFO OldThread = g_CurrentProcess ?
        g_CurrentProcess->CurrentThread : NULL;
    PPROCESS_INFO Process;

    for (Process = g_ProcessHead; Process; Process = Process->Next)
    {
        PSTR DumpFileName;
        char UniqueName[2 * MAX_PATH];
        
        if (DumpProcess != NULL && Process != DumpProcess)
        {
            continue;
        }

        if (Process != g_CurrentProcess)
        {
            SetCurrentThread(Process->ThreadHead, TRUE);
        }

        if (Unique)
        {
            SYSTEMTIME Time;
            char Ext[8], *Dot;

            strcpy(UniqueName, FileName);
            Dot = strrchr(UniqueName, '.');
            if (Dot && strlen(Dot) < sizeof(Ext) - 1)
            {
                strcpy(Ext, Dot);
                *Dot = 0;
            }
            else
            {
                Dot = NULL;
            }

            GetLocalTime(&Time);
            sprintf(UniqueName + strlen(UniqueName),
                    "_%04d-%02d-%02d_%02d-%02d-%02d-%03d",
                    Time.wYear, Time.wMonth, Time.wDay,
                    Time.wHour, Time.wMinute, Time.wSecond,
                    Time.wMilliseconds);

            sprintf(UniqueName + strlen(UniqueName), "_%04X",
                    g_CurrentProcess->SystemId);
        
            if (Dot)
            {
                strcpy(UniqueName + strlen(UniqueName), Ext);
            }

            DumpFileName = UniqueName;
        }
        else
        {
            DumpFileName = FileName;
        }
    
        WriteDumpFile(DumpFileName, Qual, FormatFlags, Comment);
    }

    if (!OldThread || OldThread->Process != g_CurrentProcess)
    {
        SetCurrentThread(OldThread, TRUE);
    }
    *g_CurCmd = Save;
}




// extern PKDDEBUGGER_DATA64 blocks[];


#define ALIGN_DOWN_POINTER(address, type) \
    ((PVOID)((ULONG_PTR)(address) & ~((ULONG_PTR)sizeof(type) - 1)))

#define ALIGN_UP_POINTER(address, type) \
    (ALIGN_DOWN_POINTER(((ULONG_PTR)(address) + sizeof(type) - 1), type))

//----------------------------------------------------------------------------
//
// CCrashDumpWrapper32.
//
//----------------------------------------------------------------------------

void
CCrashDumpWrapper32::WriteDriverList(
    BYTE *pb,
    TRIAGE_DUMP32 *ptdh
    )
{
    ULONG Size;
    PDUMP_DRIVER_ENTRY32 pdde;
    PDUMP_STRING pds;
    ModuleInfo* ModIter;
    ULONG MaxEntries = ptdh->DriverCount;

    ptdh->DriverCount = 0;
    
    if (((ModIter = g_Target->GetModuleInfo(FALSE)) == NULL) ||
        ((ModIter->Initialize()) != S_OK))
    {
        return;
    }

    // pointer to first driver entry to write out
    pdde = (PDUMP_DRIVER_ENTRY32) (pb + ptdh->DriverListOffset);

    // pointer to first module name to write out
    pds = (PDUMP_STRING) (pb + ptdh->StringPoolOffset);

    while ((PBYTE)(pds + 1) < pb + TRIAGE_DUMP_SIZE32 &&
           ptdh->DriverCount < MaxEntries)
    {
        MODULE_INFO_ENTRY ModEntry;

        ULONG retval = GetNextModuleEntry(ModIter, &ModEntry);

        if (retval == 1)
        {
            break;
        }
        else if (retval == 2)
        {
            continue;
        }

        pdde->LdrEntry.DllBase       = (ULONG)(ULONG_PTR)ModEntry.Base;
        pdde->LdrEntry.SizeOfImage   = ModEntry.Size;
        pdde->LdrEntry.CheckSum      = ModEntry.CheckSum;
        pdde->LdrEntry.TimeDateStamp = ModEntry.TimeDateStamp;

        if (ModEntry.UnicodeNamePtr)
        {
            // convert length from bytes to characters
            pds->Length = ModEntry.NameLength / sizeof(WCHAR);
            if ((PBYTE)pds->Buffer + pds->Length + sizeof(WCHAR) >
                pb + TRIAGE_DUMP_SIZE32)
            {
                break;
            }
            
            CopyMemory(pds->Buffer,
                       ModEntry.NamePtr,
                       ModEntry.NameLength);
        }
        else
        {
            pds->Length = ModEntry.NameLength;
            if ((PBYTE)pds->Buffer + pds->Length + sizeof(WCHAR) >
                pb + TRIAGE_DUMP_SIZE32)
            {
                break;
            }
            
            MultiByteToWideChar(CP_ACP, 0,
                                ModEntry.NamePtr, ModEntry.NameLength,
                                pds->Buffer, ModEntry.NameLength);
        }

        // null terminate string
        pds->Buffer[pds->Length] = '\0';

        pdde->DriverNameOffset = (ULONG)((ULONG_PTR) pds - (ULONG_PTR) pb);


        // get pointer to next string
        pds = (PDUMP_STRING) ALIGN_UP_POINTER(((LPBYTE) pds) +
                      sizeof(DUMP_STRING) + sizeof(WCHAR) * (pds->Length + 1),
                                               ULONGLONG);

        pdde = (PDUMP_DRIVER_ENTRY32)(((PUCHAR) pdde) + sizeof(*pdde));

        ptdh->DriverCount++;
    }

    ptdh->StringPoolSize = (ULONG) ((ULONG_PTR)pds -
                                    (ULONG_PTR)(pb + ptdh->StringPoolOffset));
}


void CCrashDumpWrapper32::WriteUnloadedDrivers(BYTE *pb)
{
    ULONG Size;
    ULONG i;
    ULONG Index;
    UNLOADED_DRIVERS32 *pud;
    UNLOADED_DRIVERS32 ud;
    PDUMP_UNLOADED_DRIVERS32 pdud;
    ULONG64 pvMiUnloadedDrivers;
    ULONG ulMiLastUnloadedDriver;

    *((PULONG) pb) = 0;

    //
    // find location of unloaded drivers
    //

    if (!KdDebuggerData.MmUnloadedDrivers ||
        !KdDebuggerData.MmLastUnloadedDriver)
    {
        return;
    }

    g_Target->ReadPointer(g_TargetMachine, KdDebuggerData.MmUnloadedDrivers,
                          &pvMiUnloadedDrivers);

    g_Target->ReadVirtual(KdDebuggerData.MmLastUnloadedDriver,
                          &ulMiLastUnloadedDriver,
                          sizeof(ULONG),
                          &Size);

    if (pvMiUnloadedDrivers == NULL || ulMiLastUnloadedDriver == 0)
    {
        return;
    }

    // point to last unloaded drivers
    pdud = (PDUMP_UNLOADED_DRIVERS32)(((PULONG) pb) + 1);

    //
    // Write the list with the most recently unloaded driver first to the
    // least recently unloaded driver last.
    //

    Index = ulMiLastUnloadedDriver - 1;

    for (i = 0; i < MI_UNLOADED_DRIVERS; i += 1)
    {
        if (Index >= MI_UNLOADED_DRIVERS)
        {
            Index = MI_UNLOADED_DRIVERS - 1;
        }

        // read in unloaded driver
        if (g_Target->ReadVirtual(pvMiUnloadedDrivers +
                                      Index * sizeof(UNLOADED_DRIVERS32),
                                  &ud,
                                  sizeof(ud),
                                  &Size) != S_OK)
        {
            ErrOut("can't read memory from %s",
                   FormatAddr64(pvMiUnloadedDrivers +
                                Index * sizeof(UNLOADED_DRIVERS32)));
        }

        // copy name lengths
        pdud->Name.MaximumLength = ud.Name.MaximumLength;
        pdud->Name.Length = ud.Name.Length;
        if (ud.Name.Buffer == NULL)
        {
            break;
        }

        // copy start and end address
        pdud->StartAddress = ud.StartAddress;
        pdud->EndAddress = ud.EndAddress;

        // restrict name length and maximum name length to 12 characters
        if (pdud->Name.Length > MAX_UNLOADED_NAME_LENGTH)
        {
            pdud->Name.Length = MAX_UNLOADED_NAME_LENGTH;
        }
        if (pdud->Name.MaximumLength > MAX_UNLOADED_NAME_LENGTH)
        {
            pdud->Name.MaximumLength = MAX_UNLOADED_NAME_LENGTH;
        }
        // Can't store pointers in the dump so just zero it.
        pdud->Name.Buffer = 0;
        // Read in name.
        if (g_Target->ReadVirtual((ULONG64) ud.Name.Buffer,
                                  pdud->DriverName,
                                  pdud->Name.MaximumLength,
                                  &Size) != S_OK)
        {
            ErrOut("cannot read memory at address %08x", (ULONG)(ULONG64)(ud.Name.Buffer));
        }

        // move to previous driver
        pdud += 1;
        Index -= 1;
    }

    // number of drivers in the list
    *((PULONG) pb) = i;
}

void CCrashDumpWrapper32::WriteMmTriageInformation(BYTE *pb)
{
    DUMP_MM_STORAGE32 TriageInformation;
    ULONG64 pMmVerifierData;
    ULONG64 pvMmPagedPoolInfo;
    ULONG cbNonPagedPool;
    ULONG cbPagedPool;


    // version information
    TriageInformation.Version = 1;

    // size information
    TriageInformation.Size = sizeof(TriageInformation);

    // get special pool tag
    ExtractValue(MmSpecialPoolTag, TriageInformation.MmSpecialPoolTag);

    // get triage action taken
    ExtractValue(MmTriageActionTaken, TriageInformation.MiTriageActionTaken);
    pMmVerifierData = KdDebuggerData.MmVerifierData;

    // read in verifier level
    // BUGBUG - should not read internal data structures in MM
    //if (pMmVerifierData)
    //    DmpReadMemory(
    //        (ULONG64) &((MM_DRIVER_VERIFIER_DATA *) pMmVerifierData)->Level,
    //        &TriageInformation.MmVerifyDriverLevel,
    //        sizeof(TriageInformation.MmVerifyDriverLevel));
    //else
        TriageInformation.MmVerifyDriverLevel = 0;

    // read in verifier
    ExtractValue(KernelVerifier, TriageInformation.KernelVerifier);

    // read non paged pool info
    ExtractValue(MmMaximumNonPagedPoolInBytes, cbNonPagedPool);
    TriageInformation.MmMaximumNonPagedPool = cbNonPagedPool /
                                              g_TargetMachine->m_PageSize;
    ExtractValue(MmAllocatedNonPagedPool, TriageInformation.MmAllocatedNonPagedPool);

    // read paged pool info
    ExtractValue(MmSizeOfPagedPoolInBytes, cbPagedPool);
    TriageInformation.PagedPoolMaximum = cbPagedPool /
                                         g_TargetMachine->m_PageSize;
    pvMmPagedPoolInfo = KdDebuggerData.MmPagedPoolInformation;

    // BUGBUG - should not read internal data structures in MM
    //if (pvMmPagedPoolInfo)
    //    DmpReadMemory(
    //        (ULONG64) &((MM_PAGED_POOL_INFO *) pvMmPagedPoolInfo)->AllocatedPagedPool,
    //        &TriageInformation.PagedPoolAllocated,
    //        sizeof(TriageInformation.PagedPoolAllocated));
    //else
        TriageInformation.PagedPoolAllocated = 0;

    // read committed pages info
    ExtractValue(MmTotalCommittedPages, TriageInformation.CommittedPages);
    ExtractValue(MmPeakCommitment, TriageInformation.CommittedPagesPeak);
    ExtractValue(MmTotalCommitLimitMaximum, TriageInformation.CommitLimitMaximum);
    memcpy(pb, &TriageInformation, sizeof(TriageInformation));
}

//----------------------------------------------------------------------------
//
// CCrashDumpWrapper64.
//
//----------------------------------------------------------------------------

void
CCrashDumpWrapper64::WriteDriverList(
    BYTE *pb,
    TRIAGE_DUMP64 *ptdh
    )
{
    ULONG Size;
    PDUMP_DRIVER_ENTRY64 pdde;
    PDUMP_STRING pds;
    ModuleInfo* ModIter;
    ULONG MaxEntries = ptdh->DriverCount;

    ptdh->DriverCount = 0;
    
    if (((ModIter = g_Target->GetModuleInfo(FALSE)) == NULL) ||
        ((ModIter->Initialize()) != S_OK))
    {
        return;
    }

    // pointer to first driver entry to write out
    pdde = (PDUMP_DRIVER_ENTRY64) (pb + ptdh->DriverListOffset);

    // pointer to first module name to write out
    pds = (PDUMP_STRING) (pb + ptdh->StringPoolOffset);

    while ((PBYTE)(pds + 1) < pb + TRIAGE_DUMP_SIZE64 &&
           ptdh->DriverCount < MaxEntries)
    {
        MODULE_INFO_ENTRY ModEntry;

        ULONG retval = GetNextModuleEntry(ModIter, &ModEntry);

        if (retval == 1)
        {
            break;
        }
        else if (retval == 2)
        {
            continue;
        }

        pdde->LdrEntry.DllBase       = ModEntry.Base;
        pdde->LdrEntry.SizeOfImage   = ModEntry.Size;
        pdde->LdrEntry.CheckSum      = ModEntry.CheckSum;
        pdde->LdrEntry.TimeDateStamp = ModEntry.TimeDateStamp;

        if (ModEntry.UnicodeNamePtr)
        {
            // convert length from bytes to characters
            pds->Length = ModEntry.NameLength / sizeof(WCHAR);
            if ((PBYTE)pds->Buffer + pds->Length + sizeof(WCHAR) >
                pb + TRIAGE_DUMP_SIZE64)
            {
                break;
            }
            
            CopyMemory(pds->Buffer,
                       ModEntry.NamePtr,
                       ModEntry.NameLength);
        }
        else
        {
            pds->Length = ModEntry.NameLength;
            if ((PBYTE)pds->Buffer + pds->Length + sizeof(WCHAR) >
                pb + TRIAGE_DUMP_SIZE64)
            {
                break;
            }
            
            MultiByteToWideChar(CP_ACP, 0,
                                ModEntry.NamePtr, ModEntry.NameLength,
                                pds->Buffer, ModEntry.NameLength);
        }

        // null terminate string
        pds->Buffer[pds->Length] = '\0';

        pdde->DriverNameOffset = (ULONG)((ULONG_PTR) pds - (ULONG_PTR) pb);


        // get pointer to next string
        pds = (PDUMP_STRING) ALIGN_UP_POINTER(((LPBYTE) pds) +
                      sizeof(DUMP_STRING) + sizeof(WCHAR) * (pds->Length + 1),
                                               ULONGLONG);

        pdde = (PDUMP_DRIVER_ENTRY64)(((PUCHAR) pdde) + sizeof(*pdde));

        ptdh->DriverCount++;
    }

    ptdh->StringPoolSize = (ULONG) ((ULONG_PTR)pds -
                                    (ULONG_PTR)(pb + ptdh->StringPoolOffset));
}


void CCrashDumpWrapper64::WriteUnloadedDrivers(BYTE *pb)
{
    ULONG Size;
    ULONG i;
    ULONG Index;
    UNLOADED_DRIVERS64 *pud;
    UNLOADED_DRIVERS64 ud;
    PDUMP_UNLOADED_DRIVERS64 pdud;
    ULONG64 pvMiUnloadedDrivers;
    ULONG ulMiLastUnloadedDriver;

    *((PULONG) pb) = 0;

    //
    // find location of unloaded drivers
    //

    if (!KdDebuggerData.MmUnloadedDrivers ||
        !KdDebuggerData.MmLastUnloadedDriver)
    {
        return;
    }

    g_Target->ReadPointer(g_TargetMachine, KdDebuggerData.MmUnloadedDrivers,
                          &pvMiUnloadedDrivers);

    g_Target->ReadVirtual(KdDebuggerData.MmLastUnloadedDriver,
                          &ulMiLastUnloadedDriver,
                          sizeof(ULONG),
                          &Size);

    if (pvMiUnloadedDrivers == NULL || ulMiLastUnloadedDriver == 0)
    {
        return;
    }

    // point to last unloaded drivers
    pdud = (PDUMP_UNLOADED_DRIVERS64)(((PULONG64) pb) + 1);

    //
    // Write the list with the most recently unloaded driver first to the
    // least recently unloaded driver last.
    //

    Index = ulMiLastUnloadedDriver - 1;

    for (i = 0; i < MI_UNLOADED_DRIVERS; i += 1)
    {
        if (Index >= MI_UNLOADED_DRIVERS)
        {
            Index = MI_UNLOADED_DRIVERS - 1;
        }

        // read in unloaded driver
        if (g_Target->ReadVirtual(pvMiUnloadedDrivers +
                                      Index * sizeof(UNLOADED_DRIVERS64),
                                  &ud,
                                  sizeof(ud),
                                  &Size) != S_OK)
        {
            ErrOut("can't read memory from %s",
                   FormatAddr64(pvMiUnloadedDrivers +
                                Index * sizeof(UNLOADED_DRIVERS64)));
        }

        // copy name lengths
        pdud->Name.MaximumLength = ud.Name.MaximumLength;
        pdud->Name.Length = ud.Name.Length;
        if (ud.Name.Buffer == NULL)
        {
            break;
        }

        // copy start and end address
        pdud->StartAddress = ud.StartAddress;
        pdud->EndAddress = ud.EndAddress;

        // restrict name length and maximum name length to 12 characters
        if (pdud->Name.Length > MAX_UNLOADED_NAME_LENGTH)
        {
            pdud->Name.Length = MAX_UNLOADED_NAME_LENGTH;
        }
        if (pdud->Name.MaximumLength > MAX_UNLOADED_NAME_LENGTH)
        {
            pdud->Name.MaximumLength = MAX_UNLOADED_NAME_LENGTH;
        }
        // Can't store pointers in the dump so just zero it.
        pdud->Name.Buffer = 0;
        // Read in name.
        if (g_Target->ReadVirtual(ud.Name.Buffer,
                                  pdud->DriverName,
                                  pdud->Name.MaximumLength,
                                  &Size) != S_OK)
        {
            ErrOut("cannot read memory at address %s",
                   FormatAddr64(ud.Name.Buffer));
        }

        // move to previous driver
        pdud += 1;
        Index -= 1;
    }

    // number of drivers in the list
    *((PULONG) pb) = i;
}

void CCrashDumpWrapper64::WriteMmTriageInformation(BYTE *pb)
{
    DUMP_MM_STORAGE64 TriageInformation;
    ULONG64 pMmVerifierData;
    ULONG64 pvMmPagedPoolInfo;
    ULONG64 cbNonPagedPool;
    ULONG64 cbPagedPool;


    // version information
    TriageInformation.Version = 1;

    // size information
    TriageInformation.Size = sizeof(TriageInformation);

    // get special pool tag
    ExtractValue(MmSpecialPoolTag, TriageInformation.MmSpecialPoolTag);

    // get triage action taken
    ExtractValue(MmTriageActionTaken, TriageInformation.MiTriageActionTaken);
    pMmVerifierData = KdDebuggerData.MmVerifierData;

    // read in verifier level
    // BUGBUG - should not read internal data structures in MM
    //if (pMmVerifierData)
    //    DmpReadMemory(
    //        (ULONG64) &((MM_DRIVER_VERIFIER_DATA *) pMmVerifierData)->Level,
    //        &TriageInformation.MmVerifyDriverLevel,
    //        sizeof(TriageInformation.MmVerifyDriverLevel));
    //else
        TriageInformation.MmVerifyDriverLevel = 0;

    // read in verifier
    ExtractValue(KernelVerifier, TriageInformation.KernelVerifier);

    // read non paged pool info
    ExtractValue(MmMaximumNonPagedPoolInBytes, cbNonPagedPool);
    TriageInformation.MmMaximumNonPagedPool = cbNonPagedPool /
                                              g_TargetMachine->m_PageSize;
    ExtractValue(MmAllocatedNonPagedPool, TriageInformation.MmAllocatedNonPagedPool);

    // read paged pool info
    ExtractValue(MmSizeOfPagedPoolInBytes, cbPagedPool);
    TriageInformation.PagedPoolMaximum = cbPagedPool /
                                         g_TargetMachine->m_PageSize;
    pvMmPagedPoolInfo = KdDebuggerData.MmPagedPoolInformation;

    // BUGBUG - should not read internal data structures in MM
    //if (pvMmPagedPoolInfo)
    //    DmpReadMemory(
    //        (ULONG64) &((MM_PAGED_POOL_INFO *) pvMmPagedPoolInfo)->AllocatedPagedPool,
    //        &TriageInformation.PagedPoolAllocated,
    //        sizeof(TriageInformation.PagedPoolAllocated));
    //else
        TriageInformation.PagedPoolAllocated = 0;

    // read committed pages info
    ExtractValue(MmTotalCommittedPages, TriageInformation.CommittedPages);
    ExtractValue(MmPeakCommitment, TriageInformation.CommittedPagesPeak);
    ExtractValue(MmTotalCommitLimitMaximum, TriageInformation.CommitLimitMaximum);
    memcpy(pb, &TriageInformation, sizeof(TriageInformation));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\exts.cpp ===
//----------------------------------------------------------------------------
//
// Extension DLL support.
//
// Copyright (C) Microsoft Corporation, 1997-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"
#include <time.h>

/*
 * _NT_DEBUG_OPTIONS support. Each option in g_EnvDbgOptionNames must have a
 *  corresponding OPTION_* define, in the same order.
 */
DWORD g_EnvDbgOptions;
char * g_EnvDbgOptionNames [OPTION_COUNT] =
{
    "NOEXTWARNING",
    "NOVERSIONCHECK",
};

ULONG g_PipeSerialNumber;

EXTDLL *g_ExtDlls;
LPTSTR g_ExtensionSearchPath = NULL;

ULONG64 g_ExtThread;

ULONG g_ExtGetExpressionRemainderIndex;
BOOL g_ExtGetExpressionSuccess;

WOW64EXTSPROC g_Wow64exts;

WMI_FORMAT_TRACE_DATA g_WmiFormatTraceData;

DEBUG_SCOPE g_ExtThreadSavedScope;
BOOL g_ExtThreadScopeSaved;

WINDBG_EXTENSION_APIS64 g_WindbgExtensions64 =
{
    sizeof(g_WindbgExtensions64),
    ExtOutput64,
    ExtGetExpression,
    ExtGetSymbol,
    ExtDisasm,
    CheckUserInterrupt,
    (PWINDBG_READ_PROCESS_MEMORY_ROUTINE64)ExtReadVirtualMemory,
    ExtWriteVirtualMemory,
    (PWINDBG_GET_THREAD_CONTEXT_ROUTINE)ExtGetThreadContext,
    (PWINDBG_SET_THREAD_CONTEXT_ROUTINE)ExtSetThreadContext,
    (PWINDBG_IOCTL_ROUTINE)ExtIoctl,
    ExtCallStack
};

WINDBG_EXTENSION_APIS32 g_WindbgExtensions32 =
{
    sizeof(g_WindbgExtensions32),
    ExtOutput32,
    ExtGetExpression32,
    ExtGetSymbol32,
    ExtDisasm32,
    CheckUserInterrupt,
    (PWINDBG_READ_PROCESS_MEMORY_ROUTINE32)ExtReadVirtualMemory32,
    ExtWriteVirtualMemory32,
    (PWINDBG_GET_THREAD_CONTEXT_ROUTINE)ExtGetThreadContext,
    (PWINDBG_SET_THREAD_CONTEXT_ROUTINE)ExtSetThreadContext,
    (PWINDBG_IOCTL_ROUTINE)ExtIoctl32,
    ExtCallStack32
};

WINDBG_OLDKD_EXTENSION_APIS g_KdExtensions =
{
    sizeof(g_KdExtensions),
    ExtOutput32,
    ExtGetExpression32,
    ExtGetSymbol32,
    ExtDisasm32,
    CheckUserInterrupt,
    (PWINDBG_READ_PROCESS_MEMORY_ROUTINE32)ExtReadVirtualMemory32,
    ExtWriteVirtualMemory32,
    (PWINDBG_OLDKD_READ_PHYSICAL_MEMORY)ExtReadPhysicalMemory,
    (PWINDBG_OLDKD_WRITE_PHYSICAL_MEMORY)ExtWritePhysicalMemory
};

NTSD_EXTENSION_APIS g_NtsdExtensions64 =
{
    sizeof(g_NtsdExtensions64),
    (PNTSD_OUTPUT_ROUTINE)ExtOutput32,
    (PNTSD_GET_EXPRESSION)ExtGetExpression,
    (PNTSD_GET_SYMBOL)ExtGetSymbol,
    (PNTSD_DISASM)ExtDisasm,
    (PNTSD_CHECK_CONTROL_C)CheckUserInterrupt,
};

NTSD_EXTENSION_APIS g_NtsdExtensions32 =
{
    sizeof(g_NtsdExtensions32),
    (PNTSD_OUTPUT_ROUTINE)ExtOutput32,
    (PNTSD_GET_EXPRESSION)ExtGetExpression32,
    (PNTSD_GET_SYMBOL)ExtGetSymbol32,
    (PNTSD_DISASM)ExtDisasm32,
    (PNTSD_CHECK_CONTROL_C)CheckUserInterrupt,
};

VOID WDBGAPIV
ExtOutput64(
    PCSTR lpFormat,
    ...
    )
{
    va_list Args;
    va_start(Args, lpFormat);
    MaskOutVa(DEBUG_OUTPUT_NORMAL, lpFormat, Args, TRUE);
    va_end(Args);

    // Make sure output for long-running extensions appears regularly.
    TimedFlushCallbacks();
}

VOID WDBGAPIV
ExtOutput32(
    PCSTR lpFormat,
    ...
    )
{
    va_list Args;
    va_start(Args, lpFormat);
    MaskOutVa(DEBUG_OUTPUT_NORMAL, lpFormat, Args, FALSE);
    va_end(Args);

    // Make sure output for long-running extensions appears regularly.
    TimedFlushCallbacks();
}

ULONG64
ExtGetExpression(
    PCSTR CommandString
    )
{
    g_ExtGetExpressionSuccess = FALSE;
    
    if (CommandString == NULL)
    {
        return 0;
    }
    
    ULONG64 ReturnValue;
    PSTR SaveCommand;
    PSTR SaveStart = g_CommandStart;

    if (IS_USER_TARGET())
    {
        if ( strcmp(CommandString, "WOW_BIG_BDE_HACK") == 0 )
        {
            return( (ULONG_PTR)(&segtable[0]) );
        }

        //
        // this is because the kdexts MUST include the address-of operator
        // on all getexpression calls for windbg/c expression evaluators
        //
        if (*CommandString == '&')
        {
            CommandString++;
        }
    }

    SaveCommand = g_CurCmd;
    g_CurCmd = (PSTR)CommandString;
    g_CommandStart = (PSTR)CommandString;
    g_DisableErrorPrint = TRUE;
    __try
    {
        ReturnValue = GetExpression();
        g_ExtGetExpressionSuccess = TRUE;
    }
    __except(CommandExceptionFilter(GetExceptionInformation()))
    {
        ReturnValue = 0;
    }
    g_ExtGetExpressionRemainderIndex =
        (ULONG)(g_CurCmd - g_CommandStart);
    g_DisableErrorPrint = FALSE;
    g_CurCmd = SaveCommand;
    g_CommandStart = SaveStart;

    // Make sure output for long-running extensions appears regularly.
    TimedFlushCallbacks();
    
    return ReturnValue;
}

ULONG
ExtGetExpression32(
    LPCSTR CommandString
    )
{
    return (ULONG)ExtGetExpression(CommandString);
}

void
ExtGetSymbol (
    ULONG64 offset,
    PCHAR pchBuffer,
    PULONG64 pDisplacement
    )
{
    // No way to know how much space we're given, so
    // just assume 256, which many extensions pass in
    GetSymbolStdCall(offset, pchBuffer, 256, pDisplacement, NULL);
    
    // Make sure output for long-running extensions appears regularly.
    TimedFlushCallbacks();
}

void
ExtGetSymbol32(
    ULONG offset,
    PCHAR pchBuffer,
    PULONG pDisplacement
    )
{
    ULONG64 Displacement;

    // No way to know how much space we're given, so
    // just assume 256, which many extensions pass in
    GetSymbolStdCall(EXTEND64(offset), pchBuffer, 256,
                     &Displacement, NULL);
    *pDisplacement = (ULONG)Displacement;
    
    // Make sure output for long-running extensions appears regularly.
    TimedFlushCallbacks();
}

DWORD
ExtDisasm(
    ULONG64 *lpOffset,
    PCSTR lpBuffer,
    ULONG fShowEA
    )
{
    if (!IS_MACHINE_ACCESSIBLE())
    {
        ErrOut("ExtDisasm called before debugger initialized\n");
        return FALSE;
    }
    
    ADDR    tempAddr;
    BOOL    ret;

    Type(tempAddr) = ADDR_FLAT | FLAT_COMPUTED;
    Off(tempAddr) = Flat(tempAddr) = *lpOffset;
    ret = g_Machine->Disassemble(&tempAddr, (PSTR)lpBuffer, (BOOL) fShowEA);
    *lpOffset = Flat(tempAddr);
    return ret;
}

DWORD
ExtDisasm32(
    ULONG *lpOffset,
    PCSTR lpBuffer,
    ULONG fShowEA
    )
{
    ULONG64 Offset = EXTEND64(*lpOffset);
    DWORD rval = ExtDisasm(&Offset, lpBuffer, fShowEA);
    *lpOffset = (ULONG)Offset;
    return rval;
}

BOOL
ExtGetThreadContext(
    DWORD       Processor,
    PVOID       lpContext,
    DWORD       cbSizeOfContext
    )
{
    if (!IS_MACHINE_ACCESSIBLE())
    {
        return FALSE;
    }
    
    // This get may be getting the context of the thread
    // currently cached by the register code.  Make sure
    // the cache is flushed.
    FlushRegContext();

    CROSS_PLATFORM_CONTEXT TargetContext;
    
    g_TargetMachine->InitializeContextFlags(&TargetContext, g_SystemVersion);
    if (g_Target->GetContext(IS_KERNEL_TARGET() ?
                             VIRTUAL_THREAD_HANDLE(Processor) : Processor,
                             &TargetContext) == S_OK &&
        g_Machine->ConvertContextTo(&TargetContext, g_SystemVersion,
                                    cbSizeOfContext, lpContext) == S_OK)
    {
        return TRUE;
    }

    return FALSE;
}

BOOL
ExtSetThreadContext(
    DWORD       Processor,
    PVOID       lpContext,
    DWORD       cbSizeOfContext
    )
{
    if (!IS_MACHINE_ACCESSIBLE())
    {
        return FALSE;
    }

    BOOL Status;
    
    // This set may be setting the context of the thread
    // currently cached by the register code.  Make sure
    // the cache is invalidated.
    ChangeRegContext(NULL);

    CROSS_PLATFORM_CONTEXT TargetContext;
    if (g_Machine->ConvertContextFrom(&TargetContext, g_SystemVersion,
                                      cbSizeOfContext, lpContext) == S_OK &&
        g_Target->SetContext(IS_KERNEL_TARGET() ?
                             VIRTUAL_THREAD_HANDLE(Processor) : Processor,
                             &TargetContext) == S_OK)
    {
        Status = TRUE;
    }
    else
    {
        Status = FALSE;
    }

    // Reset the current thread.
    ChangeRegContext(g_CurrentProcess->CurrentThread);

    return Status;
}

BOOL
ExtReadVirtualMemory(
    IN ULONG64 pBufSrc,
    OUT PUCHAR pBufDest,
    IN ULONG count,
    OUT PULONG pcTotalBytesRead
    )
{
    // Make sure output for long-running extensions appears regularly.
    TimedFlushCallbacks();
    
    ULONG BytesTemp;
    return g_Target->
        ReadVirtual(pBufSrc, pBufDest, count, pcTotalBytesRead != NULL ?
                    pcTotalBytesRead : &BytesTemp) == S_OK;
}

BOOL
ExtReadVirtualMemory32(
    IN ULONG pBufSrc,
    OUT PUCHAR pBufDest,
    IN ULONG count,
    OUT PULONG pcTotalBytesRead
    )
{
    // Make sure output for long-running extensions appears regularly.
    TimedFlushCallbacks();
    
    ULONG BytesTemp;
    return g_Target->
        ReadVirtual(EXTEND64(pBufSrc), pBufDest, count,
                    pcTotalBytesRead != NULL ?
                    pcTotalBytesRead : &BytesTemp) == S_OK;
}

DWORD
ExtWriteVirtualMemory(
    IN ULONG64 addr,
    IN LPCVOID buffer,
    IN ULONG count,
    OUT PULONG pcBytesWritten
    )
{
    ULONG BytesTemp;

    return (g_Target->WriteVirtual(addr, (PVOID)buffer, count,
                                   pcBytesWritten != NULL ?
                                   pcBytesWritten : &BytesTemp) == S_OK);
}

ULONG
ExtWriteVirtualMemory32 (
    IN ULONG addr,
    IN LPCVOID buffer,
    IN ULONG count,
    OUT PULONG pcBytesWritten
    )
{
    ULONG BytesTemp;
    return (g_Target->WriteVirtual(EXTEND64(addr),
                                   (PVOID)buffer, count,
                                   pcBytesWritten != NULL ?
                                   pcBytesWritten : &BytesTemp) == S_OK);
}

BOOL
ExtReadPhysicalMemory(
    ULONGLONG pBufSrc,
    PVOID pBufDest,
    ULONG count,
    PULONG pcTotalBytesRead
    )
{
    // Make sure output for long-running extensions appears regularly.
    TimedFlushCallbacks();
    
    if (ARGUMENT_PRESENT(pcTotalBytesRead)) {
        *pcTotalBytesRead = 0;
    }

    ULONG BytesTemp;
    return g_Target->ReadPhysical(pBufSrc, pBufDest, count,
                                  pcTotalBytesRead != NULL ?
                                  pcTotalBytesRead : &BytesTemp) == S_OK;
}

BOOL
ExtWritePhysicalMemory (
    ULONGLONG pBufDest,
    LPCVOID pBufSrc,
    ULONG count,
    PULONG pcTotalBytesWritten
    )
{
    if (ARGUMENT_PRESENT(pcTotalBytesWritten)) {
        *pcTotalBytesWritten = 0;
    }

    ULONG BytesTemp;
    return g_Target->WritePhysical(pBufDest, (PVOID)pBufSrc, count,
                                   pcTotalBytesWritten != NULL ?
                                   pcTotalBytesWritten : &BytesTemp) == S_OK;
}

DWORD
ExtCallStack(
    DWORD64           FramePointer,
    DWORD64           StackPointer,
    DWORD64           ProgramCounter,
    PEXTSTACKTRACE64  ExtStackFrames,
    DWORD             Frames
    )
{
    PDEBUG_STACK_FRAME StackFrames;
    DWORD              FrameCount;
    DWORD              i;

    StackFrames = (PDEBUG_STACK_FRAME)
        malloc( sizeof(StackFrames[0]) * Frames );
    if (!StackFrames)
    {
        return 0;
    }

    FrameCount = StackTrace( FramePointer, StackPointer, ProgramCounter,
                             StackFrames, Frames, g_ExtThread, 0, FALSE );

    for (i = 0; i < FrameCount; i++)
    {
        ExtStackFrames[i].FramePointer    =  StackFrames[i].FrameOffset;
        ExtStackFrames[i].ProgramCounter  =  StackFrames[i].InstructionOffset;
        ExtStackFrames[i].ReturnAddress   =  StackFrames[i].ReturnOffset;
        ExtStackFrames[i].Args[0]         =  StackFrames[i].Params[0];
        ExtStackFrames[i].Args[1]         =  StackFrames[i].Params[1];
        ExtStackFrames[i].Args[2]         =  StackFrames[i].Params[2];
        ExtStackFrames[i].Args[3]         =  StackFrames[i].Params[3];
    }

    free( StackFrames );

    if (g_ExtThreadScopeSaved) 
    {
        PopScope(&g_ExtThreadSavedScope);
        g_ExtThreadScopeSaved = FALSE;
    }
    
    g_ExtThread = 0;
    
    return FrameCount;
}

DWORD
ExtCallStack32(
    DWORD             FramePointer,
    DWORD             StackPointer,
    DWORD             ProgramCounter,
    PEXTSTACKTRACE32  ExtStackFrames,
    DWORD             Frames
    )
{
    PDEBUG_STACK_FRAME StackFrames;
    DWORD              FrameCount;
    DWORD              i;

    StackFrames = (PDEBUG_STACK_FRAME)
        malloc( sizeof(StackFrames[0]) * Frames );
    if (!StackFrames)
    {
        return 0;
    }

    FrameCount = StackTrace(EXTEND64(FramePointer),
                            EXTEND64(StackPointer),
                            EXTEND64(ProgramCounter),
                            StackFrames,
                            Frames,
                            g_ExtThread,
                            0,
                            FALSE);

    for (i=0; i<FrameCount; i++)
    {
        ExtStackFrames[i].FramePointer    =  (ULONG)StackFrames[i].FrameOffset;
        ExtStackFrames[i].ProgramCounter  =  (ULONG)StackFrames[i].InstructionOffset;
        ExtStackFrames[i].ReturnAddress   =  (ULONG)StackFrames[i].ReturnOffset;
        ExtStackFrames[i].Args[0]         =  (ULONG)StackFrames[i].Params[0];
        ExtStackFrames[i].Args[1]         =  (ULONG)StackFrames[i].Params[1];
        ExtStackFrames[i].Args[2]         =  (ULONG)StackFrames[i].Params[2];
        ExtStackFrames[i].Args[3]         =  (ULONG)StackFrames[i].Params[3];
    }

    free( StackFrames );
    if (g_ExtThreadScopeSaved)
    {
        PopScope(&g_ExtThreadSavedScope);
        g_ExtThreadScopeSaved = FALSE;
    }
    
    g_ExtThread = 0;
    
    return FrameCount;
}

BOOL
ExtIoctl(
    USHORT   IoctlType,
    LPVOID   lpvData,
    DWORD    cbSize
    )
{
    HRESULT            Status;
    BOOL               Bool;
    DWORD              cb = 0;
    PPHYSICAL          phy;
    PIOSPACE64         is;
    PIOSPACE_EX64      isex;
    PBUSDATA           busdata;
    PREAD_WRITE_MSR    msr;
    PREADCONTROLSPACE64 prc;
    PPROCESSORINFO     pi;
    PSEARCHMEMORY      psr;
    PSYM_DUMP_PARAM    pSym;
    PGET_CURRENT_THREAD_ADDRESS pct;
    PGET_CURRENT_PROCESS_ADDRESS pcp;

    // Make sure output for long-running extensions appears regularly.
    TimedFlushCallbacks();
    
    switch( IoctlType )
    {
    case IG_KD_CONTEXT:
        pi = (PPROCESSORINFO) lpvData;
        pi->Processor = (USHORT)CURRENT_PROC;
        pi->NumberProcessors = (USHORT) g_TargetNumberProcessors;
        return TRUE;

    case IG_READ_CONTROL_SPACE:
        // KSPECIAL_REGISTER content is kept in control space
        // so accessing control space may touch data that's
        // cached in the current machine KSPECIAL_REGISTERS.
        // Flush the current machine to maintain consistency.
        if (IS_MACHINE_ACCESSIBLE())
        {
            FlushRegContext();
        }
        
        prc = (PREADCONTROLSPACE64)lpvData;
        Status = g_Target->ReadControl( prc->Processor,
                                        prc->Address,
                                        prc->Buf,
                                        prc->BufLen,
                                        &cb
                                        );
        prc->BufLen = cb;
        return Status == S_OK;

    case IG_WRITE_CONTROL_SPACE:
        // KSPECIAL_REGISTER content is kept in control space
        // so accessing control space may touch data that's
        // cached in the current machine KSPECIAL_REGISTERS.
        // Flush the current machine to maintain consistency.
        if (IS_MACHINE_ACCESSIBLE())
        {
            FlushRegContext();
        }
        
        prc = (PREADCONTROLSPACE64)lpvData;
        Status = g_Target->WriteControl( prc->Processor,
                                         prc->Address,
                                         prc->Buf,
                                         prc->BufLen,
                                         &cb
                                         );
        prc->BufLen = cb;
        return Status == S_OK;

    case IG_READ_IO_SPACE:
        is = (PIOSPACE64)lpvData;
        Status = g_Target->ReadIo( Isa, 0, 1, is->Address, &is->Data,
                                   is->Length, &cb );
        return Status == S_OK;

    case IG_WRITE_IO_SPACE:
        is = (PIOSPACE64)lpvData;
        Status = g_Target->WriteIo( Isa, 0, 1, is->Address, &is->Data,
                                    is->Length, &cb );
        return Status == S_OK;

    case IG_READ_IO_SPACE_EX:
        isex = (PIOSPACE_EX64)lpvData;
        Status = g_Target->ReadIo( isex->InterfaceType,
                                   isex->BusNumber,
                                   isex->AddressSpace,
                                   isex->Address,
                                   &isex->Data,
                                   isex->Length,
                                   &cb
                                   );
        return Status == S_OK;

    case IG_WRITE_IO_SPACE_EX:
        isex = (PIOSPACE_EX64)lpvData;
        Status = g_Target->WriteIo( isex->InterfaceType,
                                    isex->BusNumber,
                                    isex->AddressSpace,
                                    isex->Address,
                                    &isex->Data,
                                    isex->Length,
                                    &cb
                                    );
        return Status == S_OK;

    case IG_READ_PHYSICAL:
        phy = (PPHYSICAL)lpvData;
        Bool =
            ExtReadPhysicalMemory( phy->Address, phy->Buf, phy->BufLen, &cb );
        phy->BufLen = cb;
        return Bool;

    case IG_WRITE_PHYSICAL:
        phy = (PPHYSICAL)lpvData;
        Bool =
            ExtWritePhysicalMemory( phy->Address, phy->Buf, phy->BufLen, &cb );
        phy->BufLen = cb;
        return Bool;

    case IG_LOWMEM_CHECK:
        Status = g_Target->CheckLowMemory();
        return Status == S_OK;

    case IG_SEARCH_MEMORY:
        psr = (PSEARCHMEMORY)lpvData;
        Status = g_Target->SearchVirtual(psr->SearchAddress,
                                         psr->SearchLength,
                                         psr->Pattern,
                                         psr->PatternLength,
                                         1,
                                         &psr->FoundAddress);
        return Status == S_OK;

    case IG_SET_THREAD:
        Bool = FALSE;
        if (IS_KERNEL_TARGET())
        {
            g_EngNotify++; // Turn off engine notifications since this setthread is temporary
            PushScope(&g_ExtThreadSavedScope);
            g_ExtThread = *(PULONG64)lpvData;
            Bool = SetContextFromThreadData(g_ExtThread, FALSE) == S_OK;
            g_ExtThreadScopeSaved = TRUE;
            g_EngNotify--;
        }
        return Bool;

    case IG_READ_MSR:
        msr = (PREAD_WRITE_MSR)lpvData;
        Status = g_Target->ReadMsr (msr->Msr, (PULONG64)&msr->Value);
        return Status == S_OK;

    case IG_WRITE_MSR:
        msr = (PREAD_WRITE_MSR)lpvData;
        Status = g_Target->WriteMsr (msr->Msr, msr->Value);
        return Status == S_OK;

    case IG_GET_KERNEL_VERSION:
        *((PDBGKD_GET_VERSION64)lpvData) = g_KdVersion;
        return TRUE;

    case IG_GET_BUS_DATA:
        busdata = (PBUSDATA)lpvData;
        Status = g_Target->ReadBusData( busdata->BusDataType,
                                        busdata->BusNumber,
                                        busdata->SlotNumber,
                                        busdata->Offset,
                                        busdata->Buffer,
                                        busdata->Length,
                                        &cb
                                        );
        busdata->Length = cb;
        return Status == S_OK;

    case IG_SET_BUS_DATA:
        busdata = (PBUSDATA)lpvData;
        Status = g_Target->WriteBusData( busdata->BusDataType,
                                         busdata->BusNumber,
                                         busdata->SlotNumber,
                                         busdata->Offset,
                                         busdata->Buffer,
                                         busdata->Length,
                                         &cb
                                         );
        busdata->Length = cb;
        return Status == S_OK;

    case IG_GET_CURRENT_THREAD:
        pct = (PGET_CURRENT_THREAD_ADDRESS) lpvData;
        return g_Target->
            GetThreadInfoDataOffset(NULL,
                                    VIRTUAL_THREAD_HANDLE(pct->Processor),
                                    &pct->Address) == S_OK;

    case IG_GET_CURRENT_PROCESS:
        pcp = (PGET_CURRENT_PROCESS_ADDRESS) lpvData;
        return g_Target->
            GetProcessInfoDataOffset(NULL,
                                     pcp->Processor,
                                     pcp->CurrentThread,
                                     &pcp->Address) == S_OK;

    case IG_GET_DEBUGGER_DATA:
        if (!IS_KERNEL_TARGET() ||
            ((PDBGKD_DEBUG_DATA_HEADER64)lpvData)->OwnerTag != KDBG_TAG)
        {
            return FALSE;
        }

        // Don't refresh if asking for the kernel header.

        memcpy(lpvData, &KdDebuggerData, min(sizeof(KdDebuggerData), cbSize));
        return TRUE;

    case IG_RELOAD_SYMBOLS:
        return g_Target->Reload((PCHAR)lpvData) == S_OK;

    case IG_GET_SET_SYMPATH:
        PGET_SET_SYMPATH pgs;
        pgs = (PGET_SET_SYMPATH)lpvData;
        bangSymPath((PCHAR)pgs->Args, FALSE, (PCHAR)pgs->Result,
                    pgs->Length);
        return TRUE;

    case IG_IS_PTR64:
        *((PBOOL)lpvData) = g_TargetMachine->m_Ptr64;
        return TRUE;

    case IG_DUMP_SYMBOL_INFO:
        pSym = (PSYM_DUMP_PARAM) lpvData;
        SymbolTypeDump(g_CurrentProcess->Handle,
                       g_CurrentProcess->ImageHead,
                       pSym, (PULONG)&Status);
        return Status;

    case IG_GET_TYPE_SIZE:
        pSym = (PSYM_DUMP_PARAM) lpvData;
        return SymbolTypeDump(g_CurrentProcess->Handle,
                              g_CurrentProcess->ImageHead,
                              pSym, (PULONG)&Status);

    case IG_GET_TEB_ADDRESS:
        PGET_TEB_ADDRESS pTeb;
        pTeb = (PGET_TEB_ADDRESS) lpvData;
        return g_Target->
            GetThreadInfoTeb(NULL,
                             0,
                             NULL,
                             &pTeb->Address) == S_OK;

    case IG_GET_PEB_ADDRESS:
        PGET_PEB_ADDRESS pPeb;
        pPeb = (PGET_PEB_ADDRESS) lpvData;
        return g_Target->
            GetProcessInfoPeb(NULL,
                              0,
                              pPeb->CurrentThread,
                              &pPeb->Address) == S_OK;

    case IG_GET_CURRENT_PROCESS_HANDLE:
        *(PHANDLE)lpvData = g_CurrentProcess->Handle;
        return TRUE;

    case IG_GET_INPUT_LINE:
        PGET_INPUT_LINE Gil;
        Gil = (PGET_INPUT_LINE)lpvData;
        Gil->InputSize = GetInput(Gil->Prompt, Gil->Buffer, Gil->BufferSize);
        return TRUE;

    case IG_GET_EXPRESSION_EX:
        PGET_EXPRESSION_EX Gee;
        Gee = (PGET_EXPRESSION_EX)lpvData;
        Gee->Value = ExtGetExpression(Gee->Expression);
        Gee->Remainder = Gee->Expression + g_ExtGetExpressionRemainderIndex;
        return g_ExtGetExpressionSuccess;
        
    case IG_TRANSLATE_VIRTUAL_TO_PHYSICAL:
        if (!IS_MACHINE_ACCESSIBLE())
        {
            return FALSE;
        }
        PTRANSLATE_VIRTUAL_TO_PHYSICAL Tvtp;
        Tvtp = (PTRANSLATE_VIRTUAL_TO_PHYSICAL)lpvData;
        ULONG Levels, PfIndex;
        return g_Machine->
            GetVirtualTranslationPhysicalOffsets(Tvtp->Virtual, NULL, 0,
                                                 &Levels, &PfIndex,
                                                 &Tvtp->Physical) == S_OK;
        
    case IG_GET_CACHE_SIZE:
        PULONG64 pCacheSize;
         
        pCacheSize = (PULONG64)lpvData;
        if (IS_KERNEL_TARGET()) {
            *pCacheSize = g_VirtualCache.m_MaxSize;
            return TRUE;
        }
        return FALSE;
    default:
        ErrOut( "\n*** Bad IOCTL request from an extension [%d]\n\n",
                IoctlType );
        return FALSE;
    }

    // NOTREACHED.
    DBG_ASSERT(FALSE);
    return FALSE;
}

BOOL
ExtIoctl32(
    USHORT   IoctlType,
    LPVOID   lpvData,
    DWORD    cbSize
    )
/*++

Routine Description:

    This is the extension Ioctl routine for backward compatibility with
    old extension dlls.  This routine is frozen, and new ioctl support
    should not be added to it.

Arguments:


Return Value:

--*/
{
    HRESULT            Status;
    DWORD              cb = 0;
    PIOSPACE32         is;
    PIOSPACE_EX32      isex;
    PREADCONTROLSPACE  prc;
    PDBGKD_DEBUG_DATA_HEADER32 hdr;
    PDBGKD_GET_VERSION32 pv32;
    PKDDEBUGGER_DATA32   pdbg32;

    // Make sure output for long-running extensions appears regularly.
    TimedFlushCallbacks();
    
    switch( IoctlType )
    {
    case IG_READ_CONTROL_SPACE:
        // KSPECIAL_REGISTER content is kept in control space
        // so accessing control space may touch data that's
        // cached in the current machine KSPECIAL_REGISTERS.
        // Flush the current machine to maintain consistency.
        if (IS_MACHINE_ACCESSIBLE())
        {
            FlushRegContext();
        }
        
        prc = (PREADCONTROLSPACE)lpvData;
        Status = g_Target->ReadControl( prc->Processor,
                                        prc->Address,
                                        prc->Buf,
                                        prc->BufLen,
                                        &cb
                                        );
        prc->BufLen = cb;
        return Status == S_OK;

    case IG_WRITE_CONTROL_SPACE:
        // KSPECIAL_REGISTER content is kept in control space
        // so accessing control space may touch data that's
        // cached in the current machine KSPECIAL_REGISTERS.
        // Flush the current machine to maintain consistency.
        if (IS_MACHINE_ACCESSIBLE())
        {
            FlushRegContext();
        }
        
        prc = (PREADCONTROLSPACE)lpvData;
        Status = g_Target->WriteControl( prc->Processor,
                                         prc->Address,
                                         prc->Buf,
                                         prc->BufLen,
                                         &cb
                                         );
        prc->BufLen = cb;
        return Status == S_OK;

    case IG_READ_IO_SPACE:
        is = (PIOSPACE32)lpvData;
        Status = g_Target->ReadIo( Isa, 0, 1, is->Address, &is->Data,
                                   is->Length, &cb );
        return Status == S_OK;

    case IG_WRITE_IO_SPACE:
        is = (PIOSPACE32)lpvData;
        Status = g_Target->WriteIo( Isa, 0, 1, is->Address, &is->Data,
                                    is->Length, &cb );
        return Status == S_OK;

    case IG_READ_IO_SPACE_EX:
        isex = (PIOSPACE_EX32)lpvData;
        Status = g_Target->ReadIo( isex->InterfaceType,
                                   isex->BusNumber,
                                   isex->AddressSpace,
                                   isex->Address,
                                   &isex->Data,
                                   isex->Length,
                                   &cb
                                   );
        return Status == S_OK;

    case IG_WRITE_IO_SPACE_EX:
        isex = (PIOSPACE_EX32)lpvData;
        Status = g_Target->WriteIo( isex->InterfaceType,
                                    isex->BusNumber,
                                    isex->AddressSpace,
                                    isex->Address,
                                    &isex->Data,
                                    isex->Length,
                                    &cb
                                    );
        return Status == S_OK;

    case IG_SET_THREAD:
        if (IS_KERNEL_TARGET())
        {
            g_EngNotify++; // Turn off engine notifications since this setthread is temporary
            g_ExtThread = EXTEND64(*(PULONG)lpvData);
            PushScope(&g_ExtThreadSavedScope);
            SetContextFromThreadData(g_ExtThread, FALSE);
            g_ExtThreadScopeSaved = TRUE;
            g_EngNotify--;
            return TRUE;
        }
        else
        {
            return FALSE;
        }

    case IG_GET_KERNEL_VERSION:
        //
        // Convert to 32 bit
        //

        pv32 = (PDBGKD_GET_VERSION32)lpvData;

        pv32->MajorVersion    = g_KdVersion.MajorVersion;
        pv32->MinorVersion    = g_KdVersion.MinorVersion;
        pv32->ProtocolVersion = g_KdVersion.ProtocolVersion;
        pv32->Flags           = g_KdVersion.Flags;

        pv32->KernBase           = (ULONG)g_KdVersion.KernBase;
        pv32->PsLoadedModuleList = (ULONG)g_KdVersion.PsLoadedModuleList;
        pv32->MachineType        = g_KdVersion.MachineType;
        pv32->DebuggerDataList   = (ULONG)g_KdVersion.DebuggerDataList;

        pv32->ThCallbackStack = KdDebuggerData.ThCallbackStack;
        pv32->NextCallback    = KdDebuggerData.NextCallback;
        pv32->FramePointer    = KdDebuggerData.FramePointer;

        pv32->KiCallUserMode =
            (ULONG)KdDebuggerData.KiCallUserMode;
        pv32->KeUserCallbackDispatcher =
            (ULONG)KdDebuggerData.KeUserCallbackDispatcher;
        pv32->BreakpointWithStatus =
            (ULONG)KdDebuggerData.BreakpointWithStatus;
        return TRUE;

    case IG_GET_DEBUGGER_DATA:
        if (!IS_KERNEL_TARGET() ||
            ((PDBGKD_DEBUG_DATA_HEADER32)lpvData)->OwnerTag != KDBG_TAG)
        {
            return FALSE;
        }

        // Don't refresh if asking for the kernel header.

        pdbg32 = (PKDDEBUGGER_DATA32)lpvData;

        pdbg32->Header.List.Flink = (ULONG)KdDebuggerData.Header.List.Flink;
        pdbg32->Header.List.Blink = (ULONG)KdDebuggerData.Header.List.Blink;
        pdbg32->Header.OwnerTag = KDBG_TAG;
        pdbg32->Header.Size = sizeof(KDDEBUGGER_DATA32);

#undef UIP
#undef CP
#define UIP(f) pdbg32->f = (ULONG)(KdDebuggerData.f)
#define CP(f) pdbg32->f = (KdDebuggerData.f)

        UIP(KernBase);
        UIP(BreakpointWithStatus);
        UIP(SavedContext);
        CP(ThCallbackStack);
        CP(NextCallback);
        CP(FramePointer);
        CP(PaeEnabled);
        UIP(KiCallUserMode);
        UIP(KeUserCallbackDispatcher);
        UIP(PsLoadedModuleList);
        UIP(PsActiveProcessHead);
        UIP(PspCidTable);
        UIP(ExpSystemResourcesList);
        UIP(ExpPagedPoolDescriptor);
        UIP(ExpNumberOfPagedPools);
        UIP(KeTimeIncrement);
        UIP(KeBugCheckCallbackListHead);
        UIP(KiBugcheckData);
        UIP(IopErrorLogListHead);
        UIP(ObpRootDirectoryObject);
        UIP(ObpTypeObjectType);
        UIP(MmSystemCacheStart);
        UIP(MmSystemCacheEnd);
        UIP(MmSystemCacheWs);
        UIP(MmPfnDatabase);
        UIP(MmSystemPtesStart);
        UIP(MmSystemPtesEnd);
        UIP(MmSubsectionBase);
        UIP(MmNumberOfPagingFiles);
        UIP(MmLowestPhysicalPage);
        UIP(MmHighestPhysicalPage);
        UIP(MmNumberOfPhysicalPages);
        UIP(MmMaximumNonPagedPoolInBytes);
        UIP(MmNonPagedSystemStart);
        UIP(MmNonPagedPoolStart);
        UIP(MmNonPagedPoolEnd);
        UIP(MmPagedPoolStart);
        UIP(MmPagedPoolEnd);
        UIP(MmPagedPoolInformation);
        UIP(MmPageSize);
        UIP(MmSizeOfPagedPoolInBytes);
        UIP(MmTotalCommitLimit);
        UIP(MmTotalCommittedPages);
        UIP(MmSharedCommit);
        UIP(MmDriverCommit);
        UIP(MmProcessCommit);
        UIP(MmPagedPoolCommit);
        UIP(MmExtendedCommit);
        UIP(MmZeroedPageListHead);
        UIP(MmFreePageListHead);
        UIP(MmStandbyPageListHead);
        UIP(MmModifiedPageListHead);
        UIP(MmModifiedNoWritePageListHead);
        UIP(MmAvailablePages);
        UIP(MmResidentAvailablePages);
        UIP(PoolTrackTable);
        UIP(NonPagedPoolDescriptor);
        UIP(MmHighestUserAddress);
        UIP(MmSystemRangeStart);
        UIP(MmUserProbeAddress);
        UIP(KdPrintCircularBuffer);
        UIP(KdPrintCircularBufferEnd);
        UIP(KdPrintWritePointer);
        UIP(KdPrintRolloverCount);
        UIP(MmLoadedUserImageList);
        //
        // DO NOT ADD ANY FIELDS HERE
        // The 32 bit structure should not be changed
        //
        return TRUE;

    case IG_KD_CONTEXT:
    case IG_READ_PHYSICAL:
    case IG_WRITE_PHYSICAL:
    case IG_LOWMEM_CHECK:
    case IG_SEARCH_MEMORY:
    case IG_READ_MSR:
    case IG_WRITE_MSR:
    case IG_GET_BUS_DATA:
    case IG_SET_BUS_DATA:
    case IG_GET_CURRENT_THREAD:
    case IG_GET_CURRENT_PROCESS:
    case IG_RELOAD_SYMBOLS:
    case IG_GET_SET_SYMPATH:
    case IG_IS_PTR64:
    case IG_DUMP_SYMBOL_INFO:
    case IG_GET_TYPE_SIZE:
    case IG_GET_TEB_ADDRESS:
    case IG_GET_PEB_ADDRESS:
    case IG_GET_INPUT_LINE:
    case IG_GET_EXPRESSION_EX:
    case IG_TRANSLATE_VIRTUAL_TO_PHYSICAL:
        // All of these ioctls are handled identically for
        // 32 and 64 bits.  Avoid duplicating all the code.
        return ExtIoctl(IoctlType, lpvData, cbSize);

    default:
        ErrOut( "\n*** Bad IOCTL32 request from an extension [%d]\n\n",
                IoctlType );
        return FALSE;
    }

    // NOTREACHED.
    DBG_ASSERT(FALSE);
    return FALSE;
}


LONG
ExtensionExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo,
    PCSTR Module,
    PCSTR Func
    )
{
    // Any references to objects will be leaked.
    // There's not much the engine can do about this, although
    // it would be possible to record old refcounts and
    // try to restore them.

    if (Module != NULL && Func != NULL)
    {
        ErrOut("%08x Exception in %s.%s debugger extension.\n",
               ExceptionInfo->ExceptionRecord->ExceptionCode,
               Module,
               Func
               );
    }
    else
    {
        ErrOut("%08x Exception in debugger client %s callback.\n",
               ExceptionInfo->ExceptionRecord->ExceptionCode,
               Func
               );
    }

    ErrOut("      PC: %s  VA: %s  R/W: %x  Parameter: %s\n",
           FormatAddr64((ULONG_PTR)ExceptionInfo->ExceptionRecord->ExceptionAddress),
           FormatAddr64(ExceptionInfo->ExceptionRecord->ExceptionInformation[1]),
           ExceptionInfo->ExceptionRecord->ExceptionInformation[0],
           FormatAddr64(ExceptionInfo->ExceptionRecord->ExceptionInformation[2])
           );

    return EXCEPTION_EXECUTE_HANDLER;
}

BOOL
CallExtension(
    DebugClient* Client,
    EXTDLL *Ext,
    PSTR Func,
    PCSTR Args,
    HRESULT* ExtStatus
    )
{
    FARPROC Routine;
    ADDR TempAddr;

    if (IS_KERNEL_TARGET())
    {
        _strlwr(Func);
    }

    Routine = GetProcAddress(Ext->Dll, Func);
    if (Routine == NULL)
    {
        return FALSE;
    }

    if (!(g_EnvDbgOptions & OPTION_NOVERSIONCHECK) && Ext->CheckVersionRoutine)
    {
        Ext->CheckVersionRoutine();
    }

    if (IS_KERNEL_TARGET() && !strcmp(Func, "version"))
    {
        //
        // This is a bit of a hack to avoid a problem with the
        // extension version checking.  Extension version checking
        // comes before the KD connection is established so there's
        // no register context.  If the version checking fails it
        // prints out version information, which tries to call
        // version extensions, which will get here when there's
        // no register context.
        //
        // To work around this, just pass zero to the version extension
        // function since it presumably doesn't care about the
        // address.
        //
        ADDRFLAT(&TempAddr, 0);
    }
    else if (IS_CONTEXT_POSSIBLE())
    {
        g_Machine->GetPC(&TempAddr);
    }
    else
    {
        if (!IS_LOCAL_KERNEL_TARGET())
        {
            WarnOut("Extension called without current PC\n");
        }
        
        ADDRFLAT(&TempAddr, 0);
    }

    *ExtStatus = S_OK;
    
    __try
    {
        switch(Ext->ExtensionType)
        {
        case NTSD_EXTENSION_TYPE:
            //
            // NOTE:
            // Eventhough this type should receive an NTSD_EXTENSION_API
            // structure, ntsdexts.dll (and possibly others) depend on
            // receiving the WinDBG version of the extensions, because they
            // check the size of the structure, and actually use some of the
            // newer exports.  This works because the WinDBG extension API was
            // a superset of the NTSD version.
            //

            ((PNTSD_EXTENSION_ROUTINE)Routine)
                (g_CurrentProcess->Handle,
                 OS_HANDLE(g_CurrentProcess->CurrentThread->Handle),
                 (ULONG)Flat(TempAddr),
                 g_TargetMachine->m_Ptr64 ?
                 (PNTSD_EXTENSION_APIS)&g_WindbgExtensions64 :
                 (PNTSD_EXTENSION_APIS)&g_WindbgExtensions32,
                 (PSTR)Args
                 );
            break;

        case DEBUG_EXTENSION_TYPE:
            if (Client == NULL)
            {
                ErrOut("Unable to call client-style extension "
                       "without a client\n");
            }
            else
            {
                *ExtStatus = ((PDEBUG_EXTENSION_CALL)Routine)
                    ((PDEBUG_CLIENT)(IDebugClientN *)Client, Args);
            }
            break;

        case WINDBG_EXTENSION_TYPE:
            //
            // Support Windbg type extensions for ntsd too
            //
            if (Ext->ApiVersion.Revision < 6 )
            {
                ((PWINDBG_EXTENSION_ROUTINE32)Routine) (
                   g_CurrentProcess->Handle,
                   OS_HANDLE(g_CurrentProcess->CurrentThread->Handle),
                   (ULONG)Flat(TempAddr),
                   CURRENT_PROC,
                   Args
                   );
            }
            else
            {
                ((PWINDBG_EXTENSION_ROUTINE64)Routine) (
                   g_CurrentProcess->Handle,
                   OS_HANDLE(g_CurrentProcess->CurrentThread->Handle),
                   Flat(TempAddr),
                   CURRENT_PROC,
                   Args
                   );
            }
            break;

        case WINDBG_OLDKD_EXTENSION_TYPE:
            ((PWINDBG_OLDKD_EXTENSION_ROUTINE)Routine) (
                (ULONG)Flat(TempAddr),
                &g_KdExtensions,
                Args
                );
            break;
        }
    }
    __except(ExtensionExceptionFilter(GetExceptionInformation(),
                                      Ext->Name, Func))
    {
        ;
    }

    return TRUE;
}

void
LinkExtensionDll(
    EXTDLL* Ext
    )
{
    // Put user-loaded DLLs before default DLLs.
    if (Ext->UserLoaded)
    {
        Ext->Next = g_ExtDlls;
        g_ExtDlls = Ext;
    }
    else
    {
        EXTDLL* Prev;
        EXTDLL* Cur;

        Prev = NULL;
        for (Cur = g_ExtDlls; Cur != NULL; Cur = Cur->Next)
        {
            if (!Cur->UserLoaded)
            {
                break;
            }

            Prev = Cur;
        }

        Ext->Next = Cur;
        if (Prev == NULL)
        {
            g_ExtDlls = Ext;
        }
        else
        {
            Prev->Next = Ext;
        }
    }
}

EXTDLL *
AddExtensionDll(
    char *Name,
    BOOL UserLoaded,
    char **End
    )
{
    EXTDLL *Ext;
    ULONG Len;
    char *Last;

    while (*Name == ' ' || *Name == '\t')
    {
        Name++;
    }
    if (*Name == 0)
    {
        ErrOut("No extension DLL name provided\n");
        return NULL;
    }

    Last = Name;
    while (*Last != 0 && *Last != ' ' && *Last != '\t')
    {
        Last++;
    }
    if (End != NULL)
    {
        *End = Last;
    }
    Len = (ULONG)(Last - Name);

    // See if it's already in the list.
    for (Ext = g_ExtDlls; Ext != NULL; Ext = Ext->Next)
    {
        if (strlen(Ext->Name) == Len && !_memicmp(Name, Ext->Name, Len))
        {
            return Ext;
        }
    }

    Ext = (EXTDLL *)malloc(sizeof(EXTDLL) + Len);
    if (Ext == NULL)
    {
        ErrOut("Unable to allocate memory for extension DLL\n");
        return NULL;
    }

    ZeroMemory(Ext, sizeof(EXTDLL) + Len);
    memcpy(Ext->Name, Name, Len + 1);
    Ext->UserLoaded = UserLoaded;

    LinkExtensionDll(Ext);

    NotifyChangeEngineState(DEBUG_CES_EXTENSIONS, 0, TRUE);
    return Ext;
}

PCTSTR
BuildExtensionSearchPath(
    VOID
    )
{

    DWORD dwSize;
    DWORD dwTotalSize;
    CHAR  ExeDir[MAX_PATH];
    int   ExeRootLen;
    PSTR  OsDirPath;
    CHAR  OsDirTail[32];
    BOOL  PriPaths = FALSE;
        
    //
    // If we are not connected, don't build a path, since we have to pick
    // up extensions based on the OS version.
    //
    if (g_ActualSystemVersion == SVER_INVALID)
    {
        return NULL;
    }

    //
    // If we already have a search path, do not rebuild it.
    //

    if (g_ExtensionSearchPath)
    {
        return g_ExtensionSearchPath;
    }

    // Get the directory the debugger executable is in.
    // -8 because we assume we're adding \w2kfre to the path.
    if (!GetModuleFileName(NULL, ExeDir, MAX_PATH - 8))
    {
        // Error.  Use the current directory.
        strcpy(ExeDir, ".");
        ExeRootLen = 1;
    }
    else
    {
        // Remove the executable name.
        LPSTR pszTmp = strrchr(ExeDir, '\\');
        if (pszTmp)
        {
            *pszTmp = 0;
        }

        if (ExeDir[0] == '\\' && ExeDir[1] == '\\')
        {
            PSTR ExeRootEnd;
            
            // UNC path root.
            ExeRootEnd = strchr(ExeDir + 2, '\\');
            if (ExeRootEnd != NULL)
            {
                ExeRootEnd = strchr(ExeRootEnd + 1, '\\');
            }
            if (ExeRootEnd == NULL)
            {
                ExeRootLen = strlen(ExeDir);
            }
            else
            {
                ExeRootLen = (int)(ExeRootEnd - ExeDir);
            }
        }
        else
        {
            // Drive letter and colon root.
            ExeRootLen = 2;
        }
    }

    //
    // Calc how much space we will need to use.
    //
    // Leave extra room for the current directory, path, and directory of
    // where debugger extensions are located.
    //

    dwTotalSize = GetEnvironmentVariable("PATH", NULL, 0) +
                  GetEnvironmentVariable("_NT_DEBUGGER_EXTENSION_PATH",
                                         NULL, 0) +
                  MAX_PATH * 3;

    g_ExtensionSearchPath = (LPTSTR)calloc(dwTotalSize, sizeof(TCHAR));
    if (!g_ExtensionSearchPath)
    {
        return NULL;
    }
    *g_ExtensionSearchPath = 0;

    //
    // 1 - User specified search path
    //

    if (GetEnvironmentVariable("_NT_DEBUGGER_EXTENSION_PATH",
                               g_ExtensionSearchPath,
                               dwTotalSize - 2))
    {
        strcat(g_ExtensionSearchPath, ";");
    }

    //
    // Figure out whether we need NT6, or NT5/NT4 free or checked extensions
    //

    if (g_ActualSystemVersion > BIG_SVER_START &&
        g_ActualSystemVersion < BIG_SVER_END)
    {
        OsDirPath = "DbgExt";
        strcpy(OsDirTail, "BIG");
    }
    else if (g_ActualSystemVersion > XBOX_SVER_START &&
             g_ActualSystemVersion < XBOX_SVER_END)
    {
        OsDirPath = "DbgExt";
        strcpy(OsDirTail, "XBox");
    }
    else if (g_ActualSystemVersion > NTBD_SVER_START &&
             g_ActualSystemVersion < NTBD_SVER_END)
    {
        OsDirPath = "DbgExt";
        strcpy(OsDirTail, "NtBd");
    }
    else if (g_ActualSystemVersion > EFI_SVER_START &&
             g_ActualSystemVersion < EFI_SVER_END)
    {
        OsDirPath = "DbgExt";
        strcpy(OsDirTail, "EFI");
    }
    else
    {
        // Treat everything else as an NT system.  Use
        // the translated system version now rather than
        // the actual system version.

        PriPaths = TRUE;

        // Skip root as it is already taken from ExeDir.
        OsDirPath = ExeDir + ExeRootLen;
        if (*OsDirPath == '\\')
        {
            OsDirPath++;
        }
        
        if (g_SystemVersion > NT_SVER_W2K)
        {
            strcpy(OsDirTail, "WINXP");
        }
        else
        {
            if (g_SystemVersion <= NT_SVER_NT4)
            {
                strcpy(OsDirTail, "NT4");
            }
            else
            {
                strcpy(OsDirTail, "W2K");
            }

            if (0xC == g_TargetCheckedBuild)
            {
                strcat(OsDirTail, "Chk");
            }
            else
            {
                strcat(OsDirTail, "Fre");
            }
        }
    }

    //
    // 2 - OS specific subdirectories from where we launched the debugger.
    // 3 - pri subdirectory from where we launched the debugger.
    // 4 - Directory from where we launched the debugger.
    //

    PSTR End;
    
    dwSize = strlen(g_ExtensionSearchPath);
    End = g_ExtensionSearchPath + dwSize;
    memcpy(End, ExeDir, ExeRootLen);
    End += ExeRootLen;
    if (*OsDirPath)
    {
        *End++ = '\\';
        strcpy(End, OsDirPath);
        End += strlen(End);
    }
    if (PriPaths)
    {
        sprintf(End, "\\winext;%s\\pri;%s", ExeDir, ExeDir);
        End += strlen(End);
    }
    sprintf(End, "\\%s;%s", OsDirTail, ExeDir);
    End += strlen(End) - 1;

    if (*End == ':')
    {
        *++End = '\\';
    }
    *++End = ';';
    *++End = 0;

    //
    // 4 - Copy environment path
    //

    dwSize = strlen(g_ExtensionSearchPath);

    GetEnvironmentVariable("PATH",
                           g_ExtensionSearchPath + dwSize,
                           dwTotalSize - dwSize - sizeof(TCHAR));

    return g_ExtensionSearchPath;
}


BOOL
IsAbsolutePath(
    PCTSTR Path
    )

/*++

Routine Description:

    Is this path an absolute path? Does not guarentee that the path exists. The
    method is:

        "\\<anything>" is an absolute path

        "{char}:\<anything>" is an absolute path

        anything else is not
--*/

{
    BOOL ret;

    if ( (Path [0] == '\\' && Path [1] == '\\') ||
         (isalpha ( Path [0] ) && Path [1] == ':' && Path [ 2 ] == '\\') )
    {
        ret = TRUE;
    }
    else
    {
        ret = FALSE;
    }

    return ret;
}

BOOL
LoadExtensionDll(
    EXTDLL *Ext
    )
{
    BOOL Found;
    TCHAR szExtPath[_MAX_PATH];

    if (Ext->Dll != NULL)
    {
        // Extension is already loaded.
        return TRUE;
    }
    
    //
    // If we are not allowing network paths, verify that the extension will
    // not be loaded from a network path.
    //

    if (g_EngOptions & DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS)
    {
        DWORD NetCheck;

        NetCheck = NetworkPathCheck (BuildExtensionSearchPath ());

        //
        // Check full path of the extension.
        //

        if (NetCheck != ERROR_FILE_OFFLINE)
        {
            CHAR Drive [ _MAX_DRIVE + 1];
            CHAR Dir [ _MAX_DIR + 1];
            CHAR Path [ _MAX_PATH + 1];

            *Drive = '\000';
            *Dir = '\000';
            _splitpath (Ext->Name, Drive, Dir, NULL, NULL);
            _makepath (Path, Drive, Dir, NULL, NULL);

            NetCheck = NetworkPathCheck (Path);
        }

        if (NetCheck == ERROR_FILE_OFFLINE)
        {
            ErrOut("ERROR: extension search path contains "
                   "network references.\n");
            return FALSE;
        }
    }

    Found = SearchPath(BuildExtensionSearchPath(),
                       Ext->Name,
                       ".dll",
                       sizeof(szExtPath),
                       szExtPath,
                       NULL);

    UINT OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    if ( Found )
    {
        Ext->Dll = LoadLibrary ( szExtPath );
    }
    else if (IsAbsolutePath ( Ext->Name ))
    {
        Ext->Dll = LoadLibrary ( Ext->Name );
    }

    SetErrorMode(OldMode);

    if (Ext->Dll == NULL)
    {
        ErrOut("The call to LoadLibrary(%s) failed with error %d.\n"
               "Please check your debugger configuration "
               "and/or network access\n",
               Ext->Name, GetLastError());
        return FALSE;
    }

    if (!_stricmp(Ext->Name, "wow64exts.dll") ||
        !_stricmp(Ext->Name, "wow64exts"))
    {
        g_Wow64exts = (WOW64EXTSPROC)GetProcAddress(Ext->Dll,"Wow64extsfn");
        DBG_ASSERT(g_Wow64exts);
    }

    if (!_stricmp(Ext->Name, "wmikd.dll") ||
        !_stricmp(Ext->Name, "wmikd"))
    {
        g_WmiFormatTraceData = (WMI_FORMAT_TRACE_DATA)
            GetProcAddress(Ext->Dll, "WmiFormatTraceData");
    }
    
    if (!g_QuietMode)
    {
        dprintf("Loaded %s extension DLL\n", Ext->Name);
    }


    //
    // Now that the extension is loaded, refresh it.
    //

    Ext->Uninit = NULL;

    PDEBUG_EXTENSION_INITIALIZE EngExt;

    EngExt = (PDEBUG_EXTENSION_INITIALIZE)
        GetProcAddress(Ext->Dll, "DebugExtensionInitialize");
    if (EngExt != NULL)
    {
        ULONG Version, Flags;
        HRESULT Status;

        // This is an engine extension.  Initialize it.
        
        Status = EngExt(&Version, &Flags);
        if (Status != S_OK)
        {
            ErrOut("%s!DebugExtensionInitialize failed with 0x%08lX\n",
                   Ext->Name, Status);
            FreeLibrary(Ext->Dll);
            Ext->Dll = NULL;
            return FALSE;
        }

        Ext->ApiVersion.MajorVersion = HIWORD(Version);
        Ext->ApiVersion.MinorVersion = LOWORD(Version);
        Ext->ApiVersion.Revision = 0;

        Ext->Notify = (PDEBUG_EXTENSION_NOTIFY)
            GetProcAddress(Ext->Dll, "DebugExtensionNotify");
        Ext->Uninit = (PDEBUG_EXTENSION_UNINITIALIZE)
            GetProcAddress(Ext->Dll, "DebugExtensionUninitialize");

        Ext->ExtensionType = DEBUG_EXTENSION_TYPE;
        Ext->Init = NULL;
        Ext->ApiVersionRoutine = NULL;
        Ext->CheckVersionRoutine = NULL;

        goto VersionCheck;
    }

    Ext->Init = (PWINDBG_EXTENSION_DLL_INIT64)
        GetProcAddress(Ext->Dll, "WinDbgExtensionDllInit");
// Windbg Api
    if (Ext->Init != NULL)
    {
        Ext->ExtensionType = WINDBG_EXTENSION_TYPE;
        Ext->ApiVersionRoutine = (PWINDBG_EXTENSION_API_VERSION)
            GetProcAddress(Ext->Dll, "ExtensionApiVersion");
        if (Ext->ApiVersionRoutine == NULL)
        {
            FreeLibrary(Ext->Dll);
            Ext->Dll = NULL;
            ErrOut("%s is not a valid windbg extension DLL\n",
                   Ext->Name);
            return FALSE;
        }
        Ext->CheckVersionRoutine = (PWINDBG_CHECK_VERSION)
            GetProcAddress(Ext->Dll, "CheckVersion");

        Ext->ApiVersion = *(Ext->ApiVersionRoutine());

        if (Ext->ApiVersion.Revision >= 6)
        {
            (Ext->Init)(&g_WindbgExtensions64,
                        (USHORT)g_TargetCheckedBuild,
                        (USHORT)g_TargetBuildNumber);
        }
        else
        {
            (Ext->Init)((PWINDBG_EXTENSION_APIS64)&g_WindbgExtensions32,
                        (USHORT)g_TargetCheckedBuild,
                        (USHORT)g_TargetBuildNumber);
        }
    }
    else
    {
        Ext->ApiVersion.Revision = EXT_API_VERSION_NUMBER;
        Ext->ApiVersionRoutine = NULL;
        Ext->CheckVersionRoutine = NULL;
        if (GetProcAddress(Ext->Dll, "NtsdExtensionDllInit"))
        {
            Ext->ExtensionType = NTSD_EXTENSION_TYPE;
        }
        else
        {
            Ext->ExtensionType = IS_KERNEL_TARGET() ?
                WINDBG_OLDKD_EXTENSION_TYPE : NTSD_EXTENSION_TYPE;
        }
    }

 VersionCheck:

#if 0
    // Temporarily remove this print statements.

    if (!(g_EnvDbgOptions & OPTION_NOVERSIONCHECK))
    {
        if (Ext->ApiVersion.Revision < 6)
        {
            dprintf("%s uses the old 32 bit extension API and may not be fully\n", Ext->Name);
            dprintf("compatible with current systems.\n");
        }
        else if (Ext->ApiVersion.Revision < EXT_API_VERSION_NUMBER)
        {
            dprintf("%s uses an earlier version of the extension API than that\n", Ext->Name);
            dprintf("supported by this debugger, and should work properly, but there\n");
            dprintf("may be unexpected incompatibilities.\n");
        }
        else if (Ext->ApiVersion.Revision > EXT_API_VERSION_NUMBER)
        {
            dprintf("%s uses a later version of the extension API than that\n", Ext->Name);
            dprintf("supported by this debugger, and might not function correctly.\n");
            dprintf("You should use the debugger from the SDK or DDK which was used\n");
            dprintf("to build the extension library.\n");
        }
    }
#endif

    // If the extension has a notification routine send
    // notifications appropriate to the current state.
    if (Ext->Notify != NULL)
    {
        if (IS_MACHINE_SET())
        {
            Ext->Notify(DEBUG_NOTIFY_SESSION_ACTIVE, 0);
        }
        if (IS_MACHINE_ACCESSIBLE())
        {
            Ext->Notify(DEBUG_NOTIFY_SESSION_ACCESSIBLE, 0);
        }
    }
    
    return TRUE;
}


void
UnlinkExtensionDll(
    EXTDLL* Match
    )
{
    EXTDLL *Ext;
    EXTDLL *Prev;

    Prev = NULL;
    for (Ext = g_ExtDlls; Ext != NULL; Ext = Ext->Next)
    {
        if (Match == Ext)
        {
            break;
        }

        Prev = Ext;
    }

    if (Ext == NULL) {
        ErrOut("! Extension DLL list inconsistency !\n");
    } else if (Prev == NULL) {
        g_ExtDlls = Ext->Next;
    } else {
        Prev->Next = Ext->Next;
    }
}

void
DeferExtensionDll(
    EXTDLL *Ext
    )
{
    if (Ext->Dll == NULL)
    {
        // Already deferred.
        return;
    }

    Ext->Init = NULL;
    Ext->Notify = NULL;
    Ext->ApiVersionRoutine = NULL;
    Ext->CheckVersionRoutine = NULL;
    
    if (Ext->Uninit != NULL)
    {
        Ext->Uninit();
        Ext->Uninit = NULL;
    }

    if (Ext->Dll != NULL)
    {
        if (!g_QuietMode)
        {
            dprintf("Unloading %s extension DLL\n", Ext->Name);
        }

        FreeLibrary(Ext->Dll);
        Ext->Dll = NULL;
    }
}

void
UnloadExtensionDll(
    EXTDLL *Ext
    )
{
    UnlinkExtensionDll(Ext);
    DeferExtensionDll(Ext);
    free(Ext);
    NotifyChangeEngineState(DEBUG_CES_EXTENSIONS, 0, TRUE);
}

void
MoveExtensionToHead(EXTDLL* Ext)
{
    UnlinkExtensionDll(Ext);
    LinkExtensionDll(Ext);
}

BOOL
CallAnyExtension(DebugClient* Client,
                 EXTDLL* Ext, PSTR Function, PCSTR Arguments,
                 BOOL ModuleSpecified, BOOL ShowWarnings,
                 HRESULT* ExtStatus)
{
    if (Ext == NULL)
    {
        Ext = g_ExtDlls;
    }
    
    // Walk through the list of extension DLLs and attempt to
    // call the given extension function on them.
    while (Ext != NULL)
    {
        //
        // hack : only dbghelp extensions or analyzebugcheck
        // will work on minidump files right now.
        //

        char Name[_MAX_FNAME + 1];

        _splitpath(Ext->Name,NULL,NULL,Name,NULL);

        if (!IS_KERNEL_TRIAGE_DUMP() ||
            !strcmp(Name, "dbghelp") ||
            !_stricmp(Name, "dbgtstext") ||
            !_stricmp(Function, "triage") ||
            !_stricmp(Function, "analyzebugcheck"))
        {
            if (LoadExtensionDll(Ext))
            {
                BOOL DidCall;
                
                DidCall = CallExtension(Client, Ext, Function, Arguments,
                                        ExtStatus);
                if (DidCall &&
                    *ExtStatus != DEBUG_EXTENSION_CONTINUE_SEARCH)
                {
                    return TRUE;
                }

                if (!DidCall && ModuleSpecified)
                {
                    // If a DLL was explicitly specified then the
                    // missing function is an error.
                    if (ShowWarnings &&
                        !(g_EnvDbgOptions & OPTION_NOEXTWARNING))
                    {
                        MaskOut(DEBUG_OUTPUT_EXTENSION_WARNING,
                                "%s has no %s export\n", Ext->Name, Function);
                    }

                    return FALSE;
                }
            }
        }

        Ext = Ext->Next;
    }

    if (ShowWarnings && IS_KERNEL_TRIAGE_DUMP())
    {
        ErrOut("Standard debugger extensions do not work with kernel minidump\n"
               "files because no data is present in the dump file.\n"
               "Consult the debugger documentation for more information on\n"
               "kernel minidump files\n");
    }
    else if (ShowWarnings && !(g_EnvDbgOptions & OPTION_NOEXTWARNING))
    {
        MaskOut(DEBUG_OUTPUT_EXTENSION_WARNING,
                "No export %s found\n", Function);
    }

    return FALSE;
}

void
OutputModuleIdInfo(HMODULE Mod, PSTR ModFile, LPEXT_API_VERSION ApiVer)
{
    char FileBuf[MAX_IMAGE_PATH];
    char *File;
    time_t TimeStamp;
    char *TimeStr;
    char VerStr[64];

    if (Mod == NULL)
    {
        Mod = GetModuleHandle(ModFile);
    }
    
    if (GetFileStringFileInfo(ModFile, "ProductVersion",
                              VerStr, sizeof(VerStr)))
    {
        dprintf("image %s, ", VerStr);
    }
    
    if (ApiVer != NULL)
    {
        dprintf("API %d.%d.%d, ",
                ApiVer->MajorVersion,
                ApiVer->MinorVersion,
                ApiVer->Revision);
    }

    TimeStamp = GetTimestampForLoadedLibrary(Mod);
    TimeStr = ctime(&TimeStamp);
    // Delete newline.
    TimeStr[strlen(TimeStr) - 1] = 0;

    if (GetModuleFileName(Mod, FileBuf, sizeof(FileBuf) - 1) == 0)
    {
        File = "Unable to get filename";
    }
    else
    {
        File = FileBuf;
    }

    dprintf("built %s\n        [path: %s]\n", TimeStr, File);
}

void
OutputExtensions(DebugClient* Client, BOOL Versions)
{
    if (g_ExtensionSearchPath != NULL)
    {
        dprintf("Extension DLL search Path:\n    %s\n",
                g_ExtensionSearchPath);
    }
    else
    {
        dprintf("Default extension DLLs are not loaded until "
                "after initial connection\n");
        if (g_ExtDlls == NULL)
        {
            return;
        }
    }

    dprintf("Extension DLL chain:\n");
    if (g_ExtDlls == NULL)
    {
        dprintf("    <Empty>\n");
        return;
    }

    EXTDLL *Ext;

    for (Ext = g_ExtDlls; Ext != NULL; Ext = Ext->Next)
    {
        if (Versions & (Ext->Dll == NULL))
        {
            LoadExtensionDll(Ext);
        }

        dprintf("    %s: ", Ext->Name);
        if (Ext->Dll != NULL)
        {
            LPEXT_API_VERSION ApiVer;
            
            if ((Ext->ExtensionType == DEBUG_EXTENSION_TYPE) ||
                (Ext->ApiVersionRoutine != NULL))
            {
                ApiVer = &Ext->ApiVersion;
            }
            else
            {
                ApiVer = NULL;
            }
            
            OutputModuleIdInfo(Ext->Dll, Ext->Name, ApiVer);

            if (Versions)
            {
                HRESULT ExtStatus;
                
                CallExtension(Client, Ext, "version", "", &ExtStatus);
            }
        }
        else
        {
            dprintf("(Not loaded)\n");
        }
    }
}

void
LoadMachineExtensions(void)
{
    // Only notify once for all the adds in this function;
    g_EngNotify++;
    
    //
    // Now that we have determined the type of architecture,
    // we can load the right debugger extensions
    //

    if (g_ActualSystemVersion > BIG_SVER_START &&
        g_ActualSystemVersion < BIG_SVER_END)
    {
        goto Refresh;
    }

    if (g_ActualSystemVersion > XBOX_SVER_START &&
        g_ActualSystemVersion < XBOX_SVER_END)
    {
        AddExtensionDll("kdextx86", FALSE, NULL);
        goto Refresh;
    }

    if (g_ActualSystemVersion > NTBD_SVER_START &&
        g_ActualSystemVersion < NTBD_SVER_END)
    {
        goto Refresh;
    }

    // Treat everything else as an NT system.

    if (IS_KERNEL_TARGET())
    {
        if (g_TargetMachineType == IMAGE_FILE_MACHINE_IA64)
        {
            //
            // We rely on force loading of extensions at the end of this
            // routine in order to get the entry point the debugger needs.
            //
            AddExtensionDll("wow64exts", FALSE, NULL);
        }

        switch (g_TargetMachineType)
        {
        case IMAGE_FILE_MACHINE_ALPHA:
            AddExtensionDll("kdextalp", FALSE, NULL);
            break;

        case IMAGE_FILE_MACHINE_I386:
            if (g_SystemVersion > NT_SVER_START &&
                g_SystemVersion <= NT_SVER_W2K)
            {
                AddExtensionDll("kdextx86", FALSE, NULL);
                break;
            }
            // Fall through

        default:
            //
            // For all new architectures and new X86 builds, load
            // kdexts
            //
            AddExtensionDll("kdexts", FALSE, NULL);
            break;
        }

        //
        // Extensions that work on all versions of the OS for kernel mode
        // Many of these are messages about legacy extensions.

        AddExtensionDll("kext", FALSE, NULL);
    }
    else
    {
        // User mode only extensions
        AddExtensionDll("ntsdexts", FALSE, NULL);
        AddExtensionDll("uext", FALSE, NULL);
    }

    // Use the translated system version now rather than
    // the actual system version.

    if (g_SystemVersion > NT_SVER_W2K &&
        g_SystemVersion < NT_SVER_END)
    {
        AddExtensionDll("exts", FALSE, NULL);
    }

    // Load ext.dll for all NT versions
    AddExtensionDll("ext", FALSE, NULL);

 Refresh:

    // Always load the Dbghelp extensions last so they are first on the list
    AddExtensionDll("dbghelp", FALSE, NULL);

    EXTDLL *Ext;

    for (Ext = g_ExtDlls; Ext != NULL; Ext = Ext->Next)
    {
        LoadExtensionDll(Ext);
    }

    g_EngNotify--;
    NotifyChangeEngineState(DEBUG_CES_EXTENSIONS, 0, TRUE);
}

void
NotifyExtensions(ULONG Notify, ULONG64 Argument)
{
    EXTDLL *Ext;

    // This routine deliberately does not provoke
    // a DLL load.
    for (Ext = g_ExtDlls; Ext != NULL; Ext = Ext->Next)
    {
        if (Ext->Notify != NULL)
        {
            Ext->Notify(Notify, Argument);
        }
    }
}

struct SHELL_READER_INFO
{
    HANDLE IoHandles[3];
    HANDLE OutEvent;
};

DWORD WINAPI
ShellReaderThread(
    LPVOID Param
    )
{
    SHELL_READER_INFO* ReaderInfo = (SHELL_READER_INFO*)Param;
    OVERLAPPED Overlapped;
    HANDLE WaitHandles[2];
    DWORD Error;
    UCHAR Buffer[_MAX_PATH];
    DWORD BytesRead;
    DWORD WaitStatus;

    memset(&Overlapped, 0, sizeof(Overlapped));
    Overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (Overlapped.hEvent == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    WaitHandles[0] = Overlapped.hEvent;
    WaitHandles[1] = ReaderInfo->IoHandles[2];

    //
    // wait for data on handle 1.
    // wait for signal on handle 2.
    //

    while (1)
    {
        //
        // initiate the read
        //

        ResetEvent( Overlapped.hEvent );

        if (ReadFile(ReaderInfo->IoHandles[1], Buffer, sizeof(Buffer) - 1,
                     &BytesRead, &Overlapped))
        {
            //
            // Read has successfully completed, print and repeat.
            //

            Buffer[BytesRead] = 0;
            dprintf("%s", Buffer);
            
            // Notify the main thread that output was produced.
            SetEvent(ReaderInfo->OutEvent);
        }
        else
        {
            Error = GetLastError();
            if (Error != ERROR_IO_PENDING)
            {
                dprintf(".shell: ReadFile failed, error == %d\n", Error);
                break;
            }

            // Flush output before waiting.
            FlushCallbacks();

            WaitStatus = WaitForMultipleObjects(2, WaitHandles, FALSE,
                                                INFINITE);
            if (WaitStatus == WAIT_OBJECT_0)
            {
                if (GetOverlappedResult(ReaderInfo->IoHandles[1], &Overlapped,
                                        &BytesRead, TRUE))
                {
                    //
                    // Read has successfully completed
                    //
                    Buffer[BytesRead] = 0;
                    dprintf("%s", Buffer);

                    // Notify the main thread that output was produced.
                    SetEvent(ReaderInfo->OutEvent);
                }
                else
                {
                    Error = GetLastError();
                    dprintf(".shell: GetOverlappedResult failed, "
                            "error == %d\n",
                            Error);
                    break;
                }
            }
            else if (WaitStatus == WAIT_OBJECT_0 + 1)
            {
                //
                // process exited.
                //
                dprintf(".shell: Process exited\n");
                break;
            }
            else
            {
                dprintf(".shell: WaitForMultipleObjects failed; error == %d\n",
                        Error);
                break;
            }
        }
    }

    CloseHandle(Overlapped.hEvent);

    dprintf("Press ENTER to continue\n");

    // Flush all remaining output.
    FlushCallbacks();

    // Notify the main thread that output was produced.
    SetEvent(ReaderInfo->OutEvent);
    
    return 0;
}

BOOL
APIENTRY
MyCreatePipeEx(
    OUT LPHANDLE lpReadPipe,
    OUT LPHANDLE lpWritePipe,
    IN LPSECURITY_ATTRIBUTES lpPipeAttributes,
    IN DWORD nSize,
    DWORD dwReadMode,
    DWORD dwWriteMode
    )

/*++

Routine Description:

    The CreatePipeEx API is used to create an anonymous pipe I/O device.
    Unlike CreatePipe FILE_FLAG_OVERLAPPED may be specified for one or
    both handles.
    Two handles to the device are created.  One handle is opened for
    reading and the other is opened for writing.  These handles may be
    used in subsequent calls to ReadFile and WriteFile to transmit data
    through the pipe.

Arguments:

    lpReadPipe - Returns a handle to the read side of the pipe.  Data
        may be read from the pipe by specifying this handle value in a
        subsequent call to ReadFile.

    lpWritePipe - Returns a handle to the write side of the pipe.  Data
        may be written to the pipe by specifying this handle value in a
        subsequent call to WriteFile.

    lpPipeAttributes - An optional parameter that may be used to specify
        the attributes of the new pipe.  If the parameter is not
        specified, then the pipe is created without a security
        descriptor, and the resulting handles are not inherited on
        process creation.  Otherwise, the optional security attributes
        are used on the pipe, and the inherit handles flag effects both
        pipe handles.

    nSize - Supplies the requested buffer size for the pipe.  This is
        only a suggestion and is used by the operating system to
        calculate an appropriate buffering mechanism.  A value of zero
        indicates that the system is to choose the default buffering
        scheme.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    HANDLE ReadPipeHandle, WritePipeHandle;
    DWORD dwError;
    CHAR PipeNameBuffer[ MAX_PATH ];

    //
    // Only one valid OpenMode flag - FILE_FLAG_OVERLAPPED
    //

    if ((dwReadMode | dwWriteMode) & (~FILE_FLAG_OVERLAPPED))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    //  Set the default timeout to 120 seconds
    //

    if (nSize == 0)
    {
        nSize = 4096;
    }

    sprintf( PipeNameBuffer,
             "\\\\.\\Pipe\\Win32PipesEx.%08x.%08x",
             GetCurrentProcessId(),
             g_PipeSerialNumber++
           );

    ReadPipeHandle = CreateNamedPipeA(
                         PipeNameBuffer,
                         PIPE_ACCESS_INBOUND | dwReadMode,
                         PIPE_TYPE_BYTE | PIPE_WAIT,
                         1,             // Number of pipes
                         nSize,         // Out buffer size
                         nSize,         // In buffer size
                         120 * 1000,    // Timeout in ms
                         lpPipeAttributes
                         );

    if (ReadPipeHandle == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    WritePipeHandle = CreateFileA(
                        PipeNameBuffer,
                        GENERIC_WRITE,
                        0,                         // No sharing
                        lpPipeAttributes,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL | dwWriteMode,
                        NULL                       // Template file
                      );

    if (INVALID_HANDLE_VALUE == WritePipeHandle)
    {
        dwError = GetLastError();
        CloseHandle( ReadPipeHandle );
        SetLastError(dwError);
        return FALSE;
    }

    *lpReadPipe = ReadPipeHandle;
    *lpWritePipe = WritePipeHandle;
    return( TRUE );
}

VOID
fnShell(
    PCSTR Args
    )
{
    //
    // If the debugger always ran through stdin/stdout, we
    // could just run a shell and wait for it.  However, in order
    // to handle fDebugOutput, we have to open pipes and manage
    // the i/o stream for the shell.  Since we need to have that
    // code anyway, always use it.
    //

    //
    // handles 0 and 1 are stdin, stdout.
    // the third handle on the debugger side is
    // the process handle, and the third handle
    // on the shell side is stderr, which is a dup
    // of stdout.
    // The other handle for the debugger is an output event handle
    // that is set by the reader thread when output is generated.
    //
    SHELL_READER_INFO ReaderInfo;
    HANDLE HandlesForShell[3] = {0};
    HANDLE ReaderThreadHandle = 0;
    DWORD ThreadId;
    SECURITY_ATTRIBUTES sa;
    CHAR Shell[_MAX_PATH];
    CHAR Command[2 * _MAX_PATH];
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    CHAR InputBuffer[_MAX_PATH];
    DWORD Bytes;
    DWORD BytesWritten;
    int i;

    C_ASSERT(DIMA(ReaderInfo.IoHandles) == DIMA(HandlesForShell));

    if (g_EngOptions & DEBUG_ENGOPT_DISALLOW_SHELL_COMMANDS)
    {
        ErrOut(".shell has been disabled\n");
        return;
    }
    
    if (SYSTEM_PROCESSES())
    {
        ErrOut(".shell: can't create a process while debugging CSRSS.\n");
        return;
    }

    ZeroMemory(&ReaderInfo, sizeof(ReaderInfo));
    ZeroMemory(&pi, sizeof(pi));
    
    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = TRUE;

    __try
    {
        //
        // Create stdin pipe for ntsd->shell.
        // Neither end needs to be overlapped.
        //

        if ( ! MyCreatePipeEx(
                   &HandlesForShell[0],        // read handle
                   &ReaderInfo.IoHandles[0],   // write handle
                   &sa,                        // security
                   0,                          // size
                   0,                          // read handle overlapped?
                   0                           // write handle overlapped?
                   ))
        {
            ErrOut(".shell: Unable to create stdin pipe.\n");
            __leave;
        }

        //
        // We don't want the shell to inherit our end of the pipe
        // so duplicate it to a non-inheritable one.
        //

        if ( ! DuplicateHandle(
                   GetCurrentProcess(),           // src process
                   ReaderInfo.IoHandles[0],       // src handle
                   GetCurrentProcess(),           // targ process
                   &ReaderInfo.IoHandles[0],      // targ handle
                   0,                             // access
                   FALSE,                         // inheritable
                   DUPLICATE_SAME_ACCESS |
                    DUPLICATE_CLOSE_SOURCE        // options
                   ))
        {
            ErrOut(".shell: Unable to duplicate stdin handle.\n");
            __leave;
        }

        //
        // Create stdout shell->ntsd pipe
        //

        if ( ! MyCreatePipeEx(
                   &ReaderInfo.IoHandles[1],   // read handle
                   &HandlesForShell[1],        // write handle
                   &sa,                        // security
                   0,                          // size
                   FILE_FLAG_OVERLAPPED,       // read handle overlapped?
                   0                           // write handle overlapped?
                   ))
        {
            ErrOut(".shell: Unable to create stdout pipe.\n");
            __leave;
        }

        //
        // We don't want the shell to inherit our end of the pipe
        // so duplicate it to a non-inheritable one.
        //

        if ( ! DuplicateHandle(
                   GetCurrentProcess(),           // src process
                   ReaderInfo.IoHandles[1],       // src handle
                   GetCurrentProcess(),           // targ process
                   &ReaderInfo.IoHandles[1],      // targ handle
                   0,                             // access
                   FALSE,                         // inheritable
                   DUPLICATE_SAME_ACCESS |
                    DUPLICATE_CLOSE_SOURCE        // options
                   ))
        {
            ErrOut(".shell: Unable to duplicate local stdout handle.\n");
            __leave;
        }

        //
        // Duplicate shell's stdout to a new stderr.
        //

        if ( ! DuplicateHandle(
                   GetCurrentProcess(),           // src process
                   HandlesForShell[1],            // src handle
                   GetCurrentProcess(),           // targ process
                   &HandlesForShell[2],           // targ handle
                   0,                             // access
                   TRUE,                          // inheritable
                   DUPLICATE_SAME_ACCESS          // options
                   ))
        {
            ErrOut(".shell: Unable to duplicate stdout handle for stderr.\n");
            __leave;
        }

        //
        // Create an event for output monitoring.
        //
        
        ReaderInfo.OutEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (ReaderInfo.OutEvent == NULL)
        {
            ErrOut(".shell: Unable to allocate event.\n");
            __leave;
        }
        
        if (!GetEnvironmentVariable("SHELL", Shell, sizeof(Shell)))
        {
            if (!GetEnvironmentVariable("ComSpec", Shell, sizeof(Shell)))
            {
                strcpy(Shell, "cmd.exe");
            }
        }

        // Skip leading whitespace on the command string.
        // Some commands, such as "net use", can't handle it.
        if (Args != NULL)
        {
            while (isspace(*Args))
            {
                Args++;
            }
        }
        
        if (Args && *Args)
        {
            //
            // If there was a command, use SHELL /c Command
            //
            sprintf(Command, "%s /c \"%s\"", Shell, Args);
        }
        else
        {
            //
            // If there was no command, just run the shell
            //
            sprintf(Command, "%s", Shell);
        }

        ZeroMemory(&si, sizeof(si));
        si.cb            = sizeof(si);
        si.dwFlags       = STARTF_USESTDHANDLES;
        si.hStdInput     = HandlesForShell[0];
        si.hStdOutput    = HandlesForShell[1];
        si.hStdError     = HandlesForShell[2];
        si.wShowWindow   = SW_SHOW;

        //
        // Create Child Process
        //

        if ( ! CreateProcess(
                   NULL,
                   Command,
                   NULL,
                   NULL,
                   TRUE,
                   GetPriorityClass( GetCurrentProcess() ),
                   NULL,
                   NULL,
                   &si,
                   &pi))
        {
            if (GetLastError() == ERROR_FILE_NOT_FOUND)
            {
                dprintf("%s not found\n", Shell);
            }
            else
            {
                ErrOut("CreateProcess(%s) failed, error %d.\n",
                       Command, GetLastError());
            }
            __leave;
        }

        ReaderInfo.IoHandles[2] = pi.hProcess;

        //
        // Start reader thread to copy shell output
        //
        ReaderThreadHandle = CreateThread(
                                NULL,
                                0,
                                ShellReaderThread,
                                &ReaderInfo,
                                0,
                                &ThreadId
                                );

        ULONG Timeout = 1000;
            
        //
        // Feed input to shell; wait for it to exit.
        //

        while (1)
        {
            ULONG WaitStatus;
            
            // Give the other process a little time to run.
            // This is critical when output is being piped
            // across kd as GetInput causes the machine to
            // sit in the kernel debugger input routine and
            // nobody gets any time to run.
            WaitStatus = WaitForSingleObject(ReaderInfo.OutEvent, 100);
            if (WaitStatus == WAIT_OBJECT_0)
            {
                // Reset the timeout since the process seems to
                // be active.
                Timeout = 1000;
                
                // Some output was produced so let the child keep
                // running to keep the output flowing.  If this
                // was the final output of the process, though,
                // go to the last input request.
                if (WaitForSingleObject(pi.hProcess, 0) != WAIT_OBJECT_0)
                {
                    continue;
                }
            }

            // We've run out of immediate output, so wait for a
            // larger interval to give the process a reasonable
            // amount of time to run.  Show a message to keep
            // users in the loop.
            dprintf("<.shell waiting %d second(s) for process>\n",
                    Timeout / 1000);
            FlushCallbacks();
            
            WaitStatus = WaitForSingleObject(ReaderInfo.OutEvent, Timeout);
            if (WaitStatus == WAIT_OBJECT_0 &&
                WaitForSingleObject(pi.hProcess, 0) != WAIT_OBJECT_0)
            {
                // Reset the timeout since the process seems to
                // be active.
                Timeout = 1000;
                continue;
            }

            Bytes = GetInput("<.shell process may need input>",
                             InputBuffer, sizeof(InputBuffer) - 2);

            // The user may not want to wait, so check for
            // a magic input string that'll abandon the process.
            if (!_strcmpi(InputBuffer, ".shell_quit"))
            {
                break;
            }

            //
            // see if client is still running
            //
            if (WaitForSingleObject(pi.hProcess, 0) == WAIT_OBJECT_0)
            {
                break;
            }

            //
            // GetInput always returns a string without a newline
            //
            strcat(InputBuffer, "\n");
            if (!WriteFile( ReaderInfo.IoHandles[0],
                            InputBuffer,
                            strlen(InputBuffer),
                            &BytesWritten,
                            NULL
                            ))
            {
                //
                // if the write fails, we're done...
                //
                break;
            }

            // The process has some input to chew on so
            // increase the amount of time we'll wait for it.
            Timeout *= 2;
        }
    }
    __finally
    {
        //
        // Close all of the i/o handles first.
        // That will make the reader thread exit if it was running.
        //
        for (i = 0; i < DIMA(ReaderInfo.IoHandles); i++)
        {
            if (ReaderInfo.IoHandles[i])
            {
                CloseHandle(ReaderInfo.IoHandles[i]);
            }
            if (HandlesForShell[i])
            {
                CloseHandle(HandlesForShell[i]);
            }
        }

        if (pi.hThread)
        {
            CloseHandle(pi.hThread);
        }

        if (ReaderThreadHandle)
        {
            WaitForSingleObject(ReaderThreadHandle, INFINITE);
            CloseHandle(ReaderThreadHandle);
        }

        // Close this handle after the thread has exited
        // to avoid it using a bad handle.
        CloseHandle(ReaderInfo.OutEvent);
    }
}

VOID
fnBangCmd(
    DebugClient* Client,
    PSTR ArgString,
    PSTR *ArgNext,
    BOOL BuiltInOnly
    )
{
    PCHAR   pc;
    PCHAR   pc1;
    PCHAR   ModName;
    PCHAR   FnName;
    CHAR    String[MAX_COMMAND];
    EXTDLL  *Ext;
    CHAR    Save;
    PSTR    FnArgs;

    //
    // Shell escape always consumes the entire string.
    //

    if (*ArgString == '!')
    {
        if (ArgNext)
        {
            *ArgNext = ArgString + strlen(ArgString);
        }
        
        fnShell(ArgString + 1);
        return;
    }

    // Copy the command into a local buffer so that we
    // can modify it.
    strcpy(String, ArgString);

    //
    // Syntax is [path-without-spaces]module.function argument-string.
    //

    pc = String;
    while ((*pc == ' ') || (*pc == '\t'))
    {
        pc++;
    }
    
    ModName = pc;
    FnName = NULL;

    while ((*pc != ' ') && (*pc != '\t') && (*pc != '\0') &&
           (*pc != ';') && (*pc != '"'))
    {
        pc++;
    }

    pc1 = pc;
    if (*pc != '\000' && *pc != ';' && *pc != '"')
    {
        *pc = '\000';
        pc++;       // now pc points to any args
    }

    while (*pc1 != '.' && pc1 != ModName)
    {
        pc1--;
    }

    if (*pc1 == '.' && !BuiltInOnly)
    {
        *pc1 = '\0';
        pc1++;
        FnName = pc1;
    }
    else
    {
        FnName = ModName;
        ModName = NULL;
    }

    if ((FnArgs = BufferStringValue(&pc, STRV_ESCAPED_CHARACTERS,
                                    &Save)) == NULL)
    {
        ErrOut("Syntax error in extension string\n");
        return;
    }

    //
    // point to next command:
    //
    if (ArgNext)
    {
        *ArgNext = ArgString + (pc - String);
    }

    //
    //  ModName -> Name of module
    //  FnName -> Name of command to process
    //  FnArgs -> argument to command
    //

    if (ModName != NULL)
    {
        Ext = AddExtensionDll(ModName, TRUE, NULL);
        if (Ext == NULL)
        {
            return;
        }
    }
    else
    {
        Ext = g_ExtDlls;
    }

    if (!_stricmp(FnName, "load"))
    {
        if (ModName == NULL)
        {
            Ext = AddExtensionDll(FnArgs, TRUE, NULL);
            if (Ext == NULL)
            {
                return;
            }
        }
        LoadExtensionDll(Ext);
        return;
    }
    else if (!_stricmp(FnName, "setdll"))
    {
        if (ModName == NULL)
        {
            Ext = AddExtensionDll(FnArgs, TRUE, NULL);
            if (Ext == NULL)
            {
                return;
            }
        }
        MoveExtensionToHead(Ext);
        if (ModName != NULL && Ext->Dll == NULL)
        {
            dprintf("Added %s to extension DLL chain\n", Ext->Name);
        }
        return;
    }
    else if (!_stricmp(FnName, "unload"))
    {
        if (ModName == NULL)
        {
            if (*FnArgs == '\0')
            {
                Ext = g_ExtDlls;
            }
            else
            {
                Ext = AddExtensionDll(FnArgs, TRUE, NULL);
            }
            if (Ext == NULL)
            {
                return;
            }
        }
        if (Ext != NULL)
        {
            UnloadExtensionDll(Ext);
        }
        return;
    }
    else if (!_stricmp(FnName, "unloadall"))
    {
        g_EngNotify++;
        while (g_ExtDlls != NULL)
        {
            UnloadExtensionDll(g_ExtDlls);
        }
        g_EngNotify--;
        NotifyChangeEngineState(DEBUG_CES_EXTENSIONS, 0, TRUE);
        return;
    }

    if (ModName == NULL)
    {
        // Handle built-in commands.

        if (!_stricmp(FnName, "chain"))
        {
            OutputExtensions(Client, FALSE);
            return;
        }
        else if (!_stricmp(FnName, "lines"))
        {
            ParseLines(FnArgs);
            return;
        }
        else if (!_stricmp(FnName, "noversion"))
        {
            dprintf("Extension DLL system version checking is disabled\n");
            g_EnvDbgOptions |= OPTION_NOVERSIONCHECK;
            return;
        }
        else if (!_stricmp(FnName, "reload"))
        {
            g_Target->Reload(FnArgs);
            ClearStoredTypes(0);
            return;
        }
        else if (!_stricmp(FnName, "srcpath") ||
                 !_stricmp(FnName, "srcpath+"))
        {
            //
            // .srcpath needs complete command tail not
            // stopping at semicolons
            //

            FnArgs = ArgString + (FnArgs - String);

            if (ArgNext)
            {
                *ArgNext = FnArgs + strlen(FnArgs);
            }
            ChangeSrcPath(FnArgs, FnName[7] == '+');
            return;
        }
        else if (!_stricmp(FnName, "sympath") ||
                 !_stricmp(FnName, "sympath+"))
        {
            //
            // .sympath needs complete command tail not
            // stopping at semicolons
            //

            FnArgs = ArgString + (FnArgs - String);

            if (ArgNext)
            {
                *ArgNext = FnArgs + strlen(FnArgs);
            }
            bangSymPath(FnArgs, FnName[7] == '+', NULL, 0);
            return;
        }
        else if (!_stricmp(FnName, "exepath") ||
                 !_stricmp(FnName, "exepath+"))
        {
            //
            // .exepath needs complete command tail not
            // stopping at semicolons
            //

            FnArgs = ArgString + (FnArgs - String);

            if (ArgNext)
            {
                *ArgNext = FnArgs + strlen(FnArgs);
            }
            ChangeExePath(FnArgs, FnName[7] == '+');
            return;
        }
        else if (!_stricmp(FnName, "netsyms"))
        {
            if (_stricmp(FnArgs, "1") == 0 ||
                _stricmp(FnArgs, "true") == 0 ||
                _stricmp(FnArgs, "yes") == 0)
            {
                g_EngOptions |= DEBUG_ENGOPT_ALLOW_NETWORK_PATHS;
                g_EngOptions &= ~DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS;
            }
            else if (_stricmp(FnArgs, "0") == 0 ||
                     _stricmp(FnArgs, "false") == 0 ||
                     _stricmp(FnArgs, "no") == 0)
            {
                g_EngOptions |= DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS;
                g_EngOptions &= ~DEBUG_ENGOPT_ALLOW_NETWORK_PATHS;
            }

            if (g_EngOptions & DEBUG_ENGOPT_ALLOW_NETWORK_PATHS)
            {
                dprintf("netsyms = yes\n");
            }
            else if (g_EngOptions & DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS)
            {
                dprintf("netsyms = no\n");
            }
            else
            {
                dprintf("netsyms = don't care\n");
            }
            return;
        }
        else if (!_stricmp(FnName, "context"))
        {
            if (*FnArgs != 0)
            {
                ULONG64 Base = ExtGetExpression(FnArgs);
                ULONG NextIdx;
                
                if (g_Machine->SetPageDirectory(PAGE_DIR_USER, Base,
                                                &NextIdx) != S_OK)
                {
                    WarnOut("WARNING: Unable to reset page directory base\n");
                }
                
                // Flush the cache as anything we read from user mode is
                // no longer valid
                g_VirtualCache.Empty();

                if (Base && !g_VirtualCache.m_ForceDecodePTEs)
                {
                    WarnOut("WARNING: "
                            ".cache forcedecodeptes is not enabled\n");
                }
            }
            else
            {
                dprintf("User-mode page directory base is %I64x\n",
                        g_Machine->m_PageDirectories[PAGE_DIR_USER]);
            }
            return;
        }
        else if (!_stricmp(FnName, "symfix"))
        {
            bangSymPath("symsrv*symsrv.dll*\\\\symbols\\symbols",
                        FALSE, NULL, 0);
            return;
        }
    }

    if (BuiltInOnly)
    {
        error(SYNTAX);
    }

    HRESULT ExtStatus;
    
    CallAnyExtension(Client, Ext, FnName, FnArgs, ModName != NULL, TRUE,
                     &ExtStatus);
}

BOOL
bangSymPath(
    IN PCSTR args,
    IN BOOL Append,
    OUT PSTR string,
    IN ULONG len
    )
{
    PPROCESS_INFO pProcess;

    __try
    {
        if (args != NULL)
        {
            while (*args == ' ' || *args == '\t')
            {
                args++;
            }
        }
        if ( args != NULL && *args )
        {
            if (ChangePath(&g_SymbolSearchPath, args, Append,
                           DEBUG_CSS_PATHS) != S_OK)
            {
                return FALSE;
            }

            pProcess = g_ProcessHead;
            while (pProcess)
            {
                SymSetSearchPath( pProcess->Handle, g_SymbolSearchPath );
                pProcess = pProcess->Next;
            }
        }

        if (string)
        {
            strncpy( string, g_SymbolSearchPath, len );
            string[len - 1] = 0;
        }
        else
        {
            dprintf( "Symbol search path is: %s\n", g_SymbolSearchPath );
            CheckPath(g_SymbolSearchPath);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return FALSE;
    }

    return TRUE;
}

void
ReadDebugOptions (BOOL fQuiet, char * pszOptionsStr)
/*++

Routine Description:

    Parses an options string (see g_EnvDbgOptionNames) and maps
    it to OPTION_ flags (in g_EnvDbgOptions).

Arguments:

    fQuiet - If TRUE, do not print option settings.
    pszOptionsStr - Options string; if NULL, get it from _NT_DEBUG_OPTIONS

Return Value:

    None
--*/
{
    BOOL fInit;
    char ** ppszOption;
    char * psz;
    DWORD dwMask;
    int iOptionCount;

    fInit = (pszOptionsStr == NULL);
    if (fInit)
    {
        g_EnvDbgOptions = 0;
        pszOptionsStr = getenv("_NT_DEBUG_OPTIONS");
    }
    if (pszOptionsStr == NULL)
    {
        if (!fQuiet)
        {
            dprintf("_NT_DEBUG_OPTIONS is not defined\n");
        }
        return;
    }
    psz = pszOptionsStr;
    while (*psz != '\0')
    {
        *psz = (char)toupper(*psz);
        psz++;
    }
    ppszOption = g_EnvDbgOptionNames;
    for (iOptionCount = 0;
         iOptionCount < OPTION_COUNT;
         iOptionCount++, ppszOption++)
    {
        if ((strstr(pszOptionsStr, *ppszOption) == NULL))
        {
            continue;
        }
        dwMask = (1 << iOptionCount);
        if (fInit)
        {
            g_EnvDbgOptions |= dwMask;
        }
        else
        {
            g_EnvDbgOptions ^= dwMask;
        }
    }
    if (!fQuiet)
    {
        dprintf("Debug Options:");
        if (g_EnvDbgOptions == 0)
        {
            dprintf(" <none>\n");
        }
        else
        {
            dwMask = g_EnvDbgOptions;
            ppszOption = g_EnvDbgOptionNames;
            while (dwMask != 0)
            {
                if (dwMask & 0x1)
                {
                    dprintf(" %s", *ppszOption);
                }
                dwMask >>= 1;
                ppszOption++;
            }
            dprintf("\n");
        }
    }
}

//----------------------------------------------------------------------------
//
// LoadWow64ExtsIfNeeded
//
//----------------------------------------------------------------------------

VOID
LoadWow64ExtsIfNeeded(
   VOID
   )
{
   LONG_PTR Wow64Info;
   NTSTATUS Status;
   EXTDLL * Extension;

   // Win9x doesn't support wx86.
   if (g_DebuggerPlatformId != VER_PLATFORM_WIN32_NT)
   {
       return;
   }
   
   //
   // if New process is a Wx86 process, load in the wx86 extensions
   // dll. This will stay loaded until ntsd exits.
   //

   Status = g_NtDllCalls.NtQueryInformationProcess(g_CurrentProcess->Handle,
                                                   ProcessWow64Information,
                                                   &Wow64Info,
                                                   sizeof(Wow64Info),
                                                   NULL
                                                   );

   if (NT_SUCCESS(Status) && Wow64Info)
   {
       Extension = AddExtensionDll("wow64exts", FALSE, NULL);

       //
       // Force load it so we get the entry point the debugger needs
       //
       LoadExtensionDll(Extension);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\exts.h ===
//----------------------------------------------------------------------------
//
// Extension DLL support.
//
// Copyright (C) Microsoft Corporation, 1997-2001.
//
//----------------------------------------------------------------------------

#ifndef _EXTS_H_
#define _EXTS_H_

#define WOW64EXTS_FLUSH_CACHE       0
#define WOW64EXTS_GET_CONTEXT       1
#define WOW64EXTS_SET_CONTEXT       2
#define WOW64EXTS_FLUSH_CACHE_WITH_HANDLE   3

typedef VOID (*WOW64EXTSPROC)(ULONG64, ULONG64, ULONG64, ULONG64);

typedef ULONG (CALLBACK* WMI_FORMAT_TRACE_DATA)
    (PDEBUG_CONTROL Ctrl, ULONG Mask, ULONG DataLen, PVOID Data);

extern ULONG64 g_ExtThread;
extern LPTSTR g_ExtensionSearchPath;
extern WOW64EXTSPROC g_Wow64exts;

extern WMI_FORMAT_TRACE_DATA g_WmiFormatTraceData;

extern DEBUG_SCOPE g_ExtThreadSavedScope;
extern BOOL g_ExtThreadScopeSaved;

//
// Functions prototyped specifically for compatibility with extension
// callback prototypes.  They can also be used directly.
//

VOID WDBGAPIV
ExtOutput64(
    PCSTR lpFormat,
    ...
    );

VOID WDBGAPIV
ExtOutput32(
    PCSTR lpFormat,
    ...
    );

ULONG64
ExtGetExpression(
    PCSTR CommandString
    );

ULONG
ExtGetExpression32(
    PCSTR CommandString
    );

void
ExtGetSymbol(
    ULONG64 Offset,
    PCHAR Buffer,
    PULONG64 Displacement
    );

void
ExtGetSymbol32(
    ULONG Offset,
    PCHAR Buffer,
    PULONG Displacement
    );

DWORD
ExtDisasm(
    PULONG64 lpOffset,
    PCSTR lpBuffer,
    ULONG fShowEA
    );

DWORD
ExtDisasm32(
    PULONG lpOffset,
    PCSTR lpBuffer,
    ULONG fShowEA
    );

BOOL
ExtReadVirtualMemory(
    IN ULONG64 Address,
    OUT PUCHAR Buffer,
    IN ULONG Length,
    OUT PULONG BytesRead
    );

BOOL
ExtReadVirtualMemory32(
    IN ULONG Address,
    OUT PUCHAR Buffer,
    IN ULONG Length,
    OUT PULONG BytesRead
    );

ULONG
ExtWriteVirtualMemory(
    IN ULONG64 Address,
    IN LPCVOID Buffer,
    IN ULONG Length,
    OUT PULONG BytesWritten
    );

ULONG
ExtWriteVirtualMemory32(
    IN ULONG Address,
    IN LPCVOID Buffer,
    IN ULONG Length,
    OUT PULONG BytesWritten
    );

BOOL
ExtGetThreadContext(
    DWORD       Processor,
    PVOID       lpContext,
    DWORD       cbSizeOfContext
    );

BOOL
ExtSetThreadContext(
    DWORD       Processor,
    PVOID       lpContext,
    DWORD       cbSizeOfContext
    );

BOOL
ExtIoctl(
    USHORT   IoctlType,
    LPVOID   lpvData,
    DWORD    cbSize
    );

BOOL
ExtIoctl32(
    USHORT   IoctlType,
    LPVOID   lpvData,
    DWORD    cbSize
    );

DWORD
ExtCallStack(
    DWORD64           FramePointer,
    DWORD64           StackPointer,
    DWORD64           ProgramCounter,
    PEXTSTACKTRACE64  StackFrames,
    DWORD             Frames
    );

DWORD
ExtCallStack32(
    DWORD             FramePointer,
    DWORD             StackPointer,
    DWORD             ProgramCounter,
    PEXTSTACKTRACE32  StackFrames,
    DWORD             Frames
    );

BOOL
ExtReadPhysicalMemory(
    ULONGLONG Address,
    PVOID Buffer,
    ULONG Length,
    PULONG BytesRead
    );

BOOL
ExtWritePhysicalMemory(
    ULONGLONG Address,
    LPCVOID Buffer,
    ULONG Length,
    PULONG BytesWritten
    );

extern WINDBG_EXTENSION_APIS64 g_WindbgExtensions64;
extern WINDBG_EXTENSION_APIS32 g_WindbgExtensions32;
extern NTSD_EXTENSION_APIS g_NtsdExtensions64;
extern NTSD_EXTENSION_APIS g_NtsdExtensions32;
extern WINDBG_OLDKD_EXTENSION_APIS g_KdExtensions;

BOOL
bangSymPath(
    IN PCSTR args,
    IN BOOL Append,
    OUT PSTR string,
    IN ULONG len
    );

void
fnBangCmd(
    DebugClient* Client,
    PSTR argstring,
    PSTR *pNext,
    BOOL BuiltInOnly
    );

VOID
fnShell(
    PCSTR Args
    );

enum ExtensionType
{
    NTSD_EXTENSION_TYPE = 1,
    DEBUG_EXTENSION_TYPE,
    WINDBG_EXTENSION_TYPE,
    WINDBG_OLDKD_EXTENSION_TYPE,
};
    
typedef struct _EXTDLL
{
    struct _EXTDLL *Next;
    HINSTANCE Dll;
    EXT_API_VERSION ApiVersion;

    BOOL UserLoaded;
    
    ExtensionType ExtensionType;
    PDEBUG_EXTENSION_NOTIFY Notify;
    PDEBUG_EXTENSION_UNINITIALIZE Uninit;

    PWINDBG_EXTENSION_DLL_INIT64 Init;
    PWINDBG_EXTENSION_API_VERSION ApiVersionRoutine;
    PWINDBG_CHECK_VERSION CheckVersionRoutine;

    // Array extends to contain the full name.
    char Name[1];

} EXTDLL;

extern EXTDLL* g_ExtDlls;

LONG
ExtensionExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo,
    PCSTR Module,
    PCSTR Func
    );

EXTDLL*
AddExtensionDll(
    char *Name,
    BOOL UserLoaded,
    char **End
    );

BOOL
LoadExtensionDll(
    EXTDLL *Ext
    );

void
DeferExtensionDll(
    EXTDLL *Match
    );

void
UnloadExtensionDll(
    EXTDLL *Match
    );

BOOL
CallAnyExtension(DebugClient* Client,
                 EXTDLL* Ext, PSTR Function, PCSTR Arguments,
                 BOOL ModuleSpecified, BOOL ShowWarnings,
                 HRESULT* ExtStatus);

void OutputModuleIdInfo(HMODULE Mod, PSTR ModFile, LPEXT_API_VERSION ApiVer);
void OutputExtensions(DebugClient* Client, BOOL Versions);

void LoadMachineExtensions(void);

void NotifyExtensions(ULONG Notify, ULONG64 Argument);

/*
 * _NT_DEBUG_OPTIONS support. Each OPTION_ define must have a corresponding
 *  string in gpaszOptions, in the same order.
 */
void ReadDebugOptions (BOOL fQuiet, char * pszOptionsStr);
extern DWORD gdwOptions;
#define OPTION_NOEXTWARNING         0x00000001
#define OPTION_NOVERSIONCHECK       0x00000002
#define OPTION_COUNT                2

VOID
LoadWow64ExtsIfNeeded(
   VOID
   );

#endif // #ifndef _EXTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\i386_asm.cpp ===
//----------------------------------------------------------------------------
//
// Assemble X86 machine implementation.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

#include "i386_asm.h"

UCHAR asm386(ULONG, PUCHAR, PUCHAR);

UCHAR CheckData(void);
PUCHAR ProcessOpcode(void);
PUCHAR GetTemplate(PUCHAR);
UCHAR MatchTemplate(PULONG);
void CheckTemplate(void);
UCHAR CheckPrefix(PUCHAR);
void AssembleInstr(void);
UCHAR MatchOperand(PASM_VALUE, UCHAR);
void OutputInstr(void);
void OutputValue(UCHAR size, PUCHAR pchValue);

extern UCHAR PeekAsmChar(void);
extern ULONG PeekAsmToken(PULONG);
extern void AcceptAsmToken(void);

extern void GetAsmExpr(PASM_VALUE, UCHAR);
extern void GetAsmOperand(PASM_VALUE);
extern PUCHAR X86SearchOpcode(PUCHAR);
extern ULONG savedAsmClass;
extern OPNDTYPE mapOpndType[];

//  flags and values to build the assembled instruction

static UCHAR   fWaitPrfx;       //  if set, use WAIT prefix for float instr
static UCHAR   fOpndOvrd;       //  if set, use operand override prefix
static UCHAR   fAddrOvrd;       //  if set, use address override prefix
static UCHAR   segOvrd;         //  if nonzero, use segment override prefix
static UCHAR   preOpcode;       //  if nonzero, use byte before opcode
static UCHAR   inOpcode;        //  opcode of instruction
static UCHAR   postOpcode;      //  if nonzero, use byte after opcode
static UCHAR   fModrm;          //  if set, modrm byte is defined
static UCHAR   modModrm;        //  if fModrm, mod component of modrm
static UCHAR   regModrm;        //  if fModrm, reg component of modrm
static UCHAR   rmModrm;         //  if fModrm, rm component of modrm
static UCHAR   fSib;            //  if set, sib byte is defined
static UCHAR   scaleSib;        //  if fSib, scale component of sib
static UCHAR   indexSib;        //  if fSib, index component of sib
static UCHAR   baseSib;         //  if fSib, base component of sib
static UCHAR   fSegPtr;         //  if set, segment for far call defined
static USHORT  segPtr;          //  if fSegPtr, value of far call segment
static UCHAR   addrSize;        //  size of address: 0, 1, 2, 4
static LONG    addrValue;       //  value of address, if used
static UCHAR   immedSize;       //  size of immediate: 0, 1, 2, 4
static LONG    immedValue;      //  value of immediate, if used
static UCHAR   immedSize2;      //  size of second immediate, if used
static LONG    immedValue2;     //  value of second immediate, if used
static ULONG   addrAssem;       //  assembly address (formal)
static PUCHAR  pchBin;          //  pointer to binary result string

//  flags and values of the current instruction template being used

static UCHAR   cntTmplOpnd;     //  count of operands in template
static UCHAR   tmplType[3];     //  operand types for current template
static UCHAR   tmplSize[3];     //  operand sizes for current template
static UCHAR   fForceSize;      //  set if operand size must be specified
static UCHAR   fAddToOp;        //  set if addition to opcode
static UCHAR   fNextOpnd;       //  set if character exists for next operand
static UCHAR   fSegOnly;        //  set if only segment is used for operand
static UCHAR   fMpNext;         //  set on 'Mv' tmpl if next tmpl is 'Mp'
static UCHAR   segIndex;        //  index of segment for PUSH/POP

//  values describing the operands processed from the command line

static UCHAR   cntInstOpnd;     //  count of operands read from input line
static UCHAR   sizeOpnd;        //  size of operand for template with size v
static ASM_VALUE avInstOpnd[3];  //  asm values from input line

PUCHAR  pchAsmLine;             //  pointer to input line (formal)
UCHAR fDBit = TRUE;             //  set for 32-bit addr/operand mode

UCHAR segToOvrdByte[] = {
        0x00,                   //  segX
        0x26,                   //  segES
        0x2e,                   //  segCS
        0x36,                   //  segSS
        0x3e,                   //  segDS
        0x64,                   //  segFS
        0x65                    //  segGS
        };

void
BaseX86MachineInfo::Assemble(PADDR paddr, PSTR pchInput)
{
    ULONG   length;
    UCHAR   chBinary[60];

    length = (ULONG)asm386((ULONG)Flat(*paddr), (PUCHAR)pchInput, chBinary);

    if (length) {
//      printf("setting memory at addr: %s - count: %d\n",
//            FormatAddr64(Flat(*paddr)), length);
        if (length != SetMemString(paddr, chBinary, length)) {
            error(MEMORY);
            }
        AddrAdd(paddr,length);
        }
}

UCHAR asm386 (ULONG addrAssemble, PUCHAR pchAssemble, PUCHAR pchBinary)
{
    PUCHAR  pchTemplate;

    UCHAR   index;              //  loop index and temp
    ULONG   temp;               //  general temporary value

    UCHAR   errIndex;           //  error index of all templates
    ULONG   errType;            //  error type of all templates

    //  initialize flags and state variables

    addrAssem = addrAssemble;   //  make assembly address global
    pchAsmLine = pchAssemble;   //  make input string pointer global
    pchBin = pchBinary;         //  make binary string pointer global

    savedAsmClass = (ULONG)-1;  //  no peeked token

    segOvrd = 0;                            //  no segment override
    cntInstOpnd = 0;                        //  no input operands read yet
    fModrm = fSib = fSegPtr = FALSE;        //  no modrm, sib, or far seg
    addrSize = immedSize = immedSize2 = 0;  //  no addr or immed

    //  check for data entry commands for byte (db), word (dw), dword (dd)
    //      if so, process multiple operands directly

    if (!CheckData()) {

        //  from the string in pchAsmLine, parse and lookup the opcode
        //      to return a pointer to its template.  check and process
        //      any prefixes, reading the next opcode for each prefix

        do
            pchTemplate = ProcessOpcode();
        while (CheckPrefix(pchTemplate));

        //  if a pending opcode to process, pchTemplate is not NULL

        if (pchTemplate) {

            //  fNextOpnd is initially set on the condition of characters
            //      being available for the first operand on the input line

            fNextOpnd = (UCHAR)(PeekAsmToken(&temp) != ASM_EOL_CLASS);

            //  continue until match occurs or last template read

            errIndex = 0;               //  start with no error
            do {

                //  get infomation on next template - return pointer to
                //      next template or NULL if last in list

                pchTemplate = GetTemplate(pchTemplate);

                //  match the loaded template against the operands input
                //      if mismatch, index has the operand index + 1 of
                //      the error while temp has the error type.

                index = MatchTemplate(&temp);

                //  determine the error to report as templates are matched
                //      update errIndex to index if later operand
                //      if same operand index, prioritize to give best error:
                //          high: SIZE, BADRANGE, OVERFLOW
                //          medium: OPERAND
                //          low: TOOFEW, TOOMANY

                if (index > errIndex
                       || (index == errIndex &&
                              (errType == TOOFEW || errType == TOOMANY
                                  || temp == SIZE || temp == BADRANGE
                                  || temp == OVERFLOW))) {
                    errIndex = index;
                    errType = temp;
                    };

                }
            while (index && pchTemplate);

            //  if error occured on template match, process it

            if (index)
                error(errType);

            //  preliminary type and size matching has been
            //      successful on the current template.
            //  perform further checks for size ambiguity.
            //  at this point, the assembly is committed to the current
            //       template.  either an error or a successful assembly
            //       follows.

            CheckTemplate();

            //  from the template and operand information, set the field
            //      information of the assembled instruction

            AssembleInstr();

            //  from the assembled instruction information, create the
            //      corresponding binary information

            OutputInstr();
            }
        }

    //  return the size of the binary string output (can be zero)

    return (UCHAR)(pchBin - pchBinary);         //  length of binary string
}

UCHAR CheckData (void)
{
    PUCHAR  pchBinStart = pchBin;
    UCHAR   ch;
    UCHAR   size = 0;
    ASM_VALUE avItem;
    ULONG   temp;

    //  perform an explicit parse for 'db', 'dw', and 'dd'
    //      and set size to that of the data item

    ch = PeekAsmChar();
    if (tolower(ch) == 'd') {
        ch = (UCHAR)tolower(*(pchAsmLine + 1));
        if (ch == 'b')
           size = 1;
        if (ch == 'w')
           size = 2;
        if (ch == 'd')
           size = 4;
        if (size) {
            ch = *(pchAsmLine + 2);
            if (ch != ' ' && ch != '\t' && ch != '\0')
                size = 0;
            }
        }

    //  if a valid command entered, then size is nonzero

    if (size) {

        //  move pointer over command and set loop condition

        pchAsmLine += 2;
        temp = ASM_COMMA_CLASS;

        //  for each item in list:
        //      check for binary buffer overflow
        //      get expression value - error if not immediate value
        //      test for byte and word overflow, if applicable
        //      write the value to the binary buffer
        //      check for comma for next operand

        while (temp == ASM_COMMA_CLASS) {
            if (pchBin >= pchBinStart + 40)
                error(LISTSIZE);
            GetAsmExpr(&avItem, FALSE);
            if (avItem.flags != fIMM)
                error(OPERAND);
            if (avItem.reloc > 1)
                error(RELOC);
            if ((size == 1 && ((LONG)avItem.value < -0x80L
                                  || (LONG)avItem.value > 0xffL))
                   || (size == 2 && ((LONG)avItem.value < -0x8000L
                                        || (LONG)avItem.value > 0xffffL)))
                error(OVERFLOW);
            OutputValue(size, (PUCHAR)&avItem.value);

            temp = PeekAsmToken(&temp);
            if (temp == ASM_COMMA_CLASS)
                AcceptAsmToken();
            else if (temp != ASM_EOL_CLASS)
                error(SYNTAX);
            }

        //  check for any remaining part after the last operand

        if (PeekAsmChar() != '\0')
            error(SYNTAX);
        }

    //  return size of item listed (zero for none)

    return size;
}

PUCHAR ProcessOpcode (void)
{
    UCHAR   ch;
    UCHAR   cbOpcode = 0;
    PUCHAR  pchTemplate;
    UCHAR   szOpcode[12];

    //  skip over any leading white space

    do
        ch = *pchAsmLine++;
    while (ch == ' ' || ch == '\t');

    //  return NULL if end of line

    if (ch == '\0')
        return NULL;

    //  parse out opcode - first string [a-z] [0-9] (case insensitive)

    ch = (UCHAR)tolower(ch);
    while (((ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9')) &&
                        cbOpcode < 11) {
        szOpcode[cbOpcode++] = ch;
        ch = (UCHAR)tolower(*pchAsmLine); pchAsmLine++;
        }

    //  if empty or too long, then error

    if (cbOpcode == 0 || cbOpcode == 11)
        error(BADOPCODE);

    //  allow opcode to have trailing colon and terminate

    if (ch == ':') {
        szOpcode[cbOpcode++] = ch;
        ch = (UCHAR)tolower(*pchAsmLine); pchAsmLine++;
        }
    szOpcode[cbOpcode] = '\0';
    pchAsmLine--;

    //  get pointer to template series for opcode found

    pchTemplate = X86SearchOpcode(szOpcode);
    if (pchTemplate == NULL)
        error(BADOPCODE);

    return pchTemplate;
}

PUCHAR GetTemplate (PUCHAR pchTemplate)
{
    UCHAR   ch;
    UCHAR   ftEnd;              //  set if tEnd for last template in list
    UCHAR   feEnd;              //  set if eEnd for last token in template

    //  initialize template variables and flags

    cntTmplOpnd = segIndex = 0;
    tmplType[0] = tmplType[1] = tmplType[2] = typNULL;
    tmplSize[0] = tmplSize[1] = tmplSize[2] = sizeX;
    fForceSize = fAddToOp = fSegOnly = fMpNext = FALSE;

    fWaitPrfx = FALSE;                  //  no WAIT prefix
    fOpndOvrd = fAddrOvrd = FALSE;      //  no operand or addr overrides
    preOpcode = postOpcode = 0;         //  no pre- or post-opcode
    regModrm = 0;                       //  this is part of some opcodes

    ch = *pchTemplate++;

    //  set pre-opcode for two-byte opcodes (0x0f??) and advance
    //      template if needed

    if (ch == 0x0f) {
        preOpcode = ch;
        ch = *pchTemplate++;
        }

    inOpcode = ch;              //  set opcode

    //  set post-opcode and advance template for floating-point
    //      instructions (0xd8 - 0xdf) using a second byte in
    //      the range 0xc0 - 0xff that is read from the template

    if ((ch & ~0x7) == 0xd8) {
        ch = *pchTemplate;
        if (ch >= 0xc0) {
            postOpcode = ch;
            pchTemplate++;
            }
        }

    //  loop for each flag and/or operand token in template
    //  the last token in the list has the eEnd bit set.

    do {
        //  read the next template token

        ch = *pchTemplate++;

        //  extract the tEnd and eEnd bits from the token

        ftEnd = (UCHAR)(ch & tEnd);
        feEnd = (UCHAR)(ch & eEnd);
        ch &= ~(tEnd | eEnd);

        //  if extracted token is a flag, do the appropriate action

        if (ch < asRegBase)
        switch (ch) {
            case as0x0a:

                //  the postOpcode is set for some decimal instructions

                postOpcode = 0x0a;
                break;

            case asOpRg:

                //  fAddToOp is set if the register index is added
                //      directly to the base opcode value

                fAddToOp = TRUE;
                break;

            case asSiz0:

                //  fOpndOvrd is set or cleared to force a 16-bit operand

                fOpndOvrd = fDBit;
                break;

            case asSiz1:

                //  fOpndOvrd is set or cleared to force a 32-bit operand

                fOpndOvrd = (UCHAR)!fDBit;
                break;

            case asWait:

                //  the flag fWaitPrfx is set to emit WAIT before the
                //      instruction

                fWaitPrfx = TRUE;
                break;

            case asSeg:

                //  in XLAT, the optional memory operand is used to
                //      just specify a segment override prefix

                fSegOnly = TRUE;
                break;

            case asFSiz:

                //  fForceSize is set when a specific size of a memory
                //      operand must be given for some floating instrs

                fForceSize = TRUE;
                break;

            case asMpNx:

                //  fMpNext is set when the next template operand is
                //      'Mp' and is used to determine how to match
                //      'Md' since it matches both 'Mp' and 'Mv'

                fMpNext = TRUE;
                break;
            }

        //  if token is REG value bit, set the variable regModrm to
        //      set the opcode-dependent reg value in the modrm byte

        else if (ch < opnBase)
            regModrm = (UCHAR)(ch - asRegBase);

        //  otherwise, token is operand descriptor.
        //  if segment operand, get segment number from template
        //  normalize and map to get operand type and size.

        else {
            if (ch == opnSeg)
                segIndex = *pchTemplate++;
            ch -= opnBase;
            tmplType[cntTmplOpnd] = mapOpndType[ch].type;
            tmplSize[cntTmplOpnd++] = mapOpndType[ch].size;
            }
        }
    while (!ftEnd);

    //  return either the pointer to the next template or NULL if
    //      the last template for the opcode has been processed

    return (feEnd ? NULL : pchTemplate);
}

UCHAR MatchTemplate (PULONG pErrType)
{
    UCHAR   fMatch = TRUE;
    UCHAR   index;
    ULONG   temp;
    PASM_VALUE pavInstOpnd;     //  pointer to current operand from input

    //  process matching for each operand in the specified template
    //  stop at last operand or when mismatch occurs

    for (index = 0; index < cntTmplOpnd && fMatch; index++) {

        //  set pointer to current instruction operand

        pavInstOpnd = &avInstOpnd[index];

        //  if input operand has not yet been read, check flag
        //  for existence and process it.

        if (index == cntInstOpnd) {
            fMatch = fNextOpnd;
            *pErrType = TOOFEW;
            if (fMatch) {
                cntInstOpnd++;
                GetAsmOperand(pavInstOpnd);

                //  recompute existence of next possible operand
                //      comma implies TRUE, EOL implies FALSE, else error

                temp = PeekAsmToken(&temp);
                if (temp == ASM_COMMA_CLASS) {
                    AcceptAsmToken();
                    fNextOpnd = TRUE;
                    }
                else if (temp == ASM_EOL_CLASS)
                    fNextOpnd = FALSE;
                else
                    error(EXTRACHARS);  // bad parse - immediate error
                }
            }

        if (fMatch) {
            fMatch = MatchOperand(pavInstOpnd, tmplType[index]);
            *pErrType = OPERAND;
            }

        //  if the template and operand type match, do preliminary
        //  check on size based solely on template size specified

        if (fMatch) {
            if (tmplType[index] == typJmp) {

                //  for relative jumps, test if byte offset is
                //      sufficient by computing offset which is
                //      the target offset less the offset of the
                //      next instruction.  (assume Jb instructions
                //      are two bytes in length.

                temp = pavInstOpnd->value - (addrAssem + 2);
                fMatch = (UCHAR)(tmplSize[index] == sizeV
                             || ((LONG)temp >= -0x80 && (LONG)temp <= 0x7f));
                *pErrType = BADRANGE;
                }

            else if (tmplType[index] == typImm) {

                //  for immediate operand,
                //      template sizeV matches sizeB, sizeW, sizeV (all)
                //      template sizeW matches sizeB, sizeW
                //      template sizeB matches sizeB

                fMatch = (UCHAR)(tmplSize[index] == sizeV
                             || pavInstOpnd->size == tmplSize[index]
                             || pavInstOpnd->size == sizeB);
                *pErrType = OVERFLOW;
                }
            else {

                //  for nonimmediate operand,
                //      template sizeX (unspecified) matches all
                //      operand sizeX (unspecified) matches all
                //      same template and operand size matches
                //      template sizeV matches operand sizeW and sizeD
                //          (EXCEPT for sizeD when fMpNext and fDBit set)
                //      template sizeP matches operand sizeD and sizeF
                //      template sizeA matches operand sizeD and sizeQ

                fMatch = (UCHAR)(tmplSize[index] == sizeX
                             || pavInstOpnd->size == sizeX
                             || tmplSize[index] == pavInstOpnd->size
                             || (tmplSize[index] == sizeV
                                    && (pavInstOpnd->size == sizeW
                                           || (pavInstOpnd->size == sizeD
                                                  && (!fMpNext || fDBit))))
                             || (tmplSize[index] == sizeP
                                    && (pavInstOpnd->size == sizeD
                                           || pavInstOpnd->size == sizeF))
                             || (tmplSize[index] == sizeA
                                    && (pavInstOpnd->size == sizeD
                                           || pavInstOpnd->size == sizeQ)));
                *pErrType = SIZE;
                }
            }
        }

    //  if more operands to read, then no match

    if (fMatch & fNextOpnd) {
        fMatch = FALSE;
        index++;                //  next operand is in error
        *pErrType = TOOMANY;
        }

    return fMatch ? (UCHAR)0 : index;
}

void CheckTemplate (void)
{
    UCHAR   index;

    //  if fForceSize is set, then the first (and only) operand is a
    //      memory type.  return an error if its size is unspecified.

    if (fForceSize && avInstOpnd[0].size == sizeX)
        error(OPERAND);

    //  test for template with leading entries of 'Xb', where
    //      'X' includes all types except immediate ('I').  if any
    //      are defined, at least one operand must have a byte size.
    //  this handles the cases of byte or word/dword ambiguity for
    //      instructions with no register operands.

    sizeOpnd = sizeX;
    for (index = 0; index < 2; index++)
        if (tmplType[index] != typImm && tmplSize[index] == sizeB) {
            if (avInstOpnd[index].size != sizeX)
                sizeOpnd = avInstOpnd[index].size;
            }
        else
            break;
    if (index != 0 && sizeOpnd == sizeX)
        error(SIZE);

    //  for templates with one entry of 'Xp', where 'X' is
    //      not 'A', allowable sizes are sizeX (unspecified),
    //      sizeD (dword), and sizeF (fword).  process by
    //      mapping entry sizes 'p' -> 'v', sizeD -> sizeW,
    //      and sizeF -> sizeD
    //  (template 'Ap' is absolute with explicit segment and
    //       'v'-sized offset - really treated as 'Av')

    if (tmplSize[0] == sizeP) {
        tmplSize[0] = sizeV;
        if (avInstOpnd[0].size == sizeD)
            avInstOpnd[0].size = sizeW;
        if (avInstOpnd[0].size == sizeF)
            avInstOpnd[0].size = sizeD;
        }

    //  for templates with the second entry of 'Ma', the
    //      allowable sizes are sizeX (unspecified),
    //      sizeD (dword), and sizeQ (qword).  process by
    //      mapping entry sizes 'a' -> 'v', sizeD -> sizeW,
    //      and sizeQ -> sizeD
    //  (template entry 'Ma' is used only with the BOUND instruction)

    if (tmplSize[1] == sizeA) {
        tmplSize[1] = sizeV;
        if (avInstOpnd[1].size == sizeD)
            avInstOpnd[1].size = sizeW;
        if (avInstOpnd[1].size == sizeQ)
            avInstOpnd[1].size = sizeD;
        }

    //  test for template with leading entries of 'Xv' optionally
    //      followed by one 'Iv' entry.  if two 'Xv' entries, set
    //      size error if one is word and the other is dword.  if
    //      'Iv' entry, test for overflow.

    sizeOpnd = sizeX;
    for (index = 0; index < 3; index++)
        if (tmplSize[index] == sizeV)
            if (tmplType[index] != typImm) {

                //  template entry is 'Xv', set size and check size

                if (avInstOpnd[index].size != sizeX) {
                    if (sizeOpnd != sizeX && sizeOpnd
                                        != avInstOpnd[index].size)
                        error(SIZE);
                    sizeOpnd = avInstOpnd[index].size;
                    }
                }
            else {

                //  template entry is 'Iv', set sizeOpnd to either
                //      sizeW or sizeD and check for overflow

                if (sizeOpnd == sizeX)
                    sizeOpnd = (UCHAR)(fDBit ? sizeD : sizeW);
                if (sizeOpnd == sizeW && avInstOpnd[index].size == sizeD)
                    error(OVERFLOW);
                }
}

UCHAR CheckPrefix (PUCHAR pchTemplate)
{
    UCHAR   fPrefix;

    fPrefix = (UCHAR)(pchTemplate && *pchTemplate != 0x0f
                           && (*pchTemplate & ~7) != 0xd8
                           && *(pchTemplate + 1) == (asPrfx + tEnd + eEnd));
    if (fPrefix)
        *pchBin++ = *pchTemplate;

    return fPrefix;
}

void AssembleInstr (void)
{
    UCHAR   size;
    UCHAR   index;
    PASM_VALUE pavInstOpnd;

    //  set operand override flag if operand size differs than fDBit
    //      (the flag may already be set due to opcode template flag)

    if ((sizeOpnd == sizeW && fDBit)
                                || (sizeOpnd == sizeD && !fDBit))
        fOpndOvrd = TRUE;

    //  for each operand of the successfully matched template,
    //      build the assembled instruction
    //  for template entries with size 'v', sizeOpnd has the size

    for (index = 0; index < cntTmplOpnd; index++) {
        pavInstOpnd = &avInstOpnd[index];
        size = tmplSize[index];
        if (size == sizeV)
            size = sizeOpnd;

        switch (tmplType[index]) {
            case typExp:
            case typMem:
                if (!segOvrd)  //  first one only (movsb...)
                    segOvrd = segToOvrdByte[pavInstOpnd->segovr];
                if (fSegOnly)
                    break;

                fModrm = TRUE;
                if (pavInstOpnd->flags == fREG) {
                    modModrm = 3;
                    rmModrm = pavInstOpnd->base;
                    }
                else {
                    addrValue = (LONG)pavInstOpnd->value;

                    //  for 16-bit or 32-bit index off (E)BP, make
                    //      zero displacement a byte one

                    if (addrValue == 0
                          && (pavInstOpnd->flags != fPTR16
                                        || pavInstOpnd->base != 6)
                          && (pavInstOpnd->flags != fPTR32
                                        || pavInstOpnd->base != indBP))
                            modModrm = 0;
                    else if (addrValue >= -0x80L && addrValue <= 0x7fL) {
                        modModrm = 1;
                        addrSize = 1;
                        }
                    else if (pavInstOpnd->flags == fPTR32
                                 || (pavInstOpnd->flags == fPTR && fDBit)) {
                        modModrm = 2;
                        addrSize = 4;
                        }
                    else if (addrValue >= -0x8000L && addrValue <= 0xffffL) {
                        modModrm = 2;
                        addrSize = 2;
                        }
                    else
                        error(OVERFLOW);
                    if (pavInstOpnd->flags == fPTR) {
                        modModrm = 0;
                        addrSize = (UCHAR)((1 + fDBit) << 1);
                        rmModrm = (UCHAR)(6 - fDBit);
                        }
                    else if (pavInstOpnd->flags == fPTR16) {
                        fAddrOvrd = fDBit;
                        rmModrm = pavInstOpnd->base;
                        if (modModrm == 0 && rmModrm == 6)
                            modModrm = 1;
                        }
                    else {
                        fAddrOvrd = (UCHAR)!fDBit;
                        if (pavInstOpnd->index == 0xff
                                && pavInstOpnd->base != indSP) {
                            rmModrm = pavInstOpnd->base;
                            if (modModrm == 0 && rmModrm == 5)
                                modModrm++;
                            }
                        else {
                            rmModrm = 4;
                            fSib = TRUE;
                            if (pavInstOpnd->base != 0xff) {
                                baseSib = pavInstOpnd->base;
                                if (modModrm == 0 && baseSib == 5)
                                    modModrm++;
                                }
                            else
                                baseSib = 5;
                            if (pavInstOpnd->index != 0xff) {
                                indexSib = pavInstOpnd->index;
                                scaleSib = pavInstOpnd->scale;
                                }
                            else {
                                indexSib = 4;
                                scaleSib = 0;
                                }
                            }
                        }
                    }
                break;

            case typGen:
                if (fAddToOp)
                    inOpcode += pavInstOpnd->base;
                else
                    regModrm = pavInstOpnd->base;
                break;

            case typSgr:
                regModrm = (UCHAR)(pavInstOpnd->base - 1);
                                                //  remove list offset
                break;

            case typReg:
                rmModrm = pavInstOpnd->base;
                break;

            case typImm:
                if (immedSize == 0) {
                    immedSize = size;
                    immedValue = pavInstOpnd->value;
                    }
                else {
                    immedSize2 = size;
                    immedValue2 = pavInstOpnd->value;
                    }
                break;

            case typJmp:

                //  compute displacment for byte offset instruction
                //      and test if in range

                addrValue = pavInstOpnd->value - (addrAssem + 2);
                if (addrValue >= -0x80L && addrValue <= 0x7fL)
                    addrSize = 1;
                else {

                    //  too large for byte, compute for word offset
                    //      and test again if in range
                    //  also allow for two-byte opcode 0f xx

                    addrValue -= 1 + (preOpcode == 0x0f);
                    if (!fDBit) {
                        if (addrValue >= -0x8000L && addrValue <= 0x7fffL)
                            addrSize = 2;
                        else
                            error(BADRANGE);
                        }
                    else {

                        //  recompute again for dword offset instruction

                        addrValue -= 2;
                        addrSize = 4;
                        }
                    }
                fOpndOvrd = FALSE;      //  operand size override is NOT set
                break;

            case typCtl:
            case typDbg:
            case typTrc:
                fModrm = TRUE;
                modModrm = 3;
                regModrm = pavInstOpnd->base;
                break;

            case typSti:
                postOpcode += pavInstOpnd->base;
                break;

            case typSeg:
                break;

            case typXsi:
            case typYdi:
                fAddrOvrd = (UCHAR)
                        ((UCHAR)(pavInstOpnd->flags == fPTR32) != fDBit);
                break;

            case typOff:
                segOvrd = segToOvrdByte[pavInstOpnd->segovr];
                goto jumpAssem;

            case typAbs:
                fSegPtr = TRUE;
                segPtr = pavInstOpnd->segment;
jumpAssem:
                addrValue = (LONG)pavInstOpnd->value;
                if (!fDBit)
                    if (addrValue >= -0x8000L && addrValue <= 0xffffL)
                        addrSize = 2;
                    else
                        error(OVERFLOW);
                else
                    addrSize = 4;
                break;
            }
        }
}

UCHAR MatchOperand (PASM_VALUE pavOpnd, UCHAR tmplType)
{
    UCHAR    fMatch;

    //  if immediate operand, set minimum unsigned size

    if (pavOpnd->flags == fIMM) {
        if ((LONG)pavOpnd->value >= -0x80L && (LONG)pavOpnd->value <= 0xffL)
            pavOpnd->size = sizeB;
        else if ((LONG)pavOpnd->value >= -0x8000L
                                        && (LONG)pavOpnd->value <= 0xffffL)
            pavOpnd->size = sizeW;
        else
            pavOpnd->size = sizeD;
        }

    //  start matching of operands
    //    compare the template and input operand types

    switch (tmplType) {
        case typAX:
            fMatch = (UCHAR)((pavOpnd->flags & fREG)
                        && pavOpnd->index == regG && pavOpnd->base == indAX);
            break;

        case typCL:
            fMatch = (UCHAR)((pavOpnd->flags & fREG)
                         && pavOpnd->index == regG && pavOpnd->size == sizeB
                         && pavOpnd->base == indCX);
            break;

        case typDX:
            fMatch = (UCHAR)((pavOpnd->flags & fREG)
                         && pavOpnd->index == regG && pavOpnd->size == sizeW
                         && pavOpnd->base == indDX);
            break;

        case typAbs:
            fMatch = (UCHAR)(pavOpnd->flags & fFPTR);
            break;

        case typExp:
            fMatch = (UCHAR)((pavOpnd->flags == fREG
                                        && pavOpnd->index == regG)
                        || (pavOpnd->flags == fIMM && pavOpnd->reloc == 1)
                        || (pavOpnd->flags & (fPTR | fPTR16 | fPTR32)) != 0);
            break;

        case typGen:
        case typReg:
            fMatch = (UCHAR)(pavOpnd->flags == fREG
                                        && pavOpnd->index == regG);
            break;

        case typIm1:
            fMatch = (UCHAR)(pavOpnd->flags == fIMM && pavOpnd->value == 1);
            break;

        case typIm3:
            fMatch = (UCHAR)(pavOpnd->flags == fIMM && pavOpnd->value == 3);
            break;

        case typImm:
            fMatch = (UCHAR)(pavOpnd->flags == fIMM && pavOpnd->reloc == 0);
            break;

        case typJmp:
            fMatch = (UCHAR)(pavOpnd->flags == fIMM);
            break;

        case typMem:
            fMatch = (UCHAR)((pavOpnd->flags == fIMM && pavOpnd->reloc == 1)
                     || ((pavOpnd->flags & (fPTR | fPTR16 | fPTR32)) != 0));
            break;

        case typCtl:
            fMatch = (UCHAR)(pavOpnd->flags == fREG
                                                && pavOpnd->index == regC);
            break;

        case typDbg:
            fMatch = (UCHAR)(pavOpnd->flags == fREG
                                                && pavOpnd->index == regD);
            break;

        case typTrc:
            fMatch = (UCHAR)(pavOpnd->flags == fREG
                                                && pavOpnd->index == regT);
            break;

        case typSt:
            fMatch = (UCHAR)(pavOpnd->flags == fREG
                                                && pavOpnd->index == regF);
            break;

        case typSti:
            fMatch = (UCHAR)(pavOpnd->flags == fREG
                                                && pavOpnd->index == regI);
            break;

        case typSeg:
            fMatch = (UCHAR)(pavOpnd->flags == fREG && pavOpnd->index == regS
                                && pavOpnd->base == segIndex);
            break;

        case typSgr:
            fMatch = (UCHAR)(pavOpnd->flags == fREG
                                                && pavOpnd->index == regS);
            break;

        case typXsi:
            fMatch = (UCHAR)(((pavOpnd->flags == fPTR16 && pavOpnd->base == 4)
                       || (pavOpnd->flags == fPTR32 && pavOpnd->base == indSI
                                                 && pavOpnd->index == 0xff))
                     && pavOpnd->value == 0
                     && (pavOpnd->segovr == segX
                                                || pavOpnd->segovr == segDS));
            break;

        case typYdi:
            fMatch = (UCHAR)(((pavOpnd->flags == fPTR16 && pavOpnd->base == 5)
                       || (pavOpnd->flags == fPTR32 && pavOpnd->base == indDI
                                                  && pavOpnd->index == 0xff))
                      && pavOpnd->value == 0
                      && pavOpnd->segovr == segES);
            break;

        case typOff:
            fMatch = (UCHAR)((pavOpnd->flags == fIMM && pavOpnd->reloc == 1)
                                                || pavOpnd->flags == fPTR);
            break;

        default:
            fMatch = FALSE;
            break;
        }

    return fMatch;
}

void OutputInstr (void)
{
    if (fWaitPrfx)
        *pchBin++ = 0x9b;
    if (fAddrOvrd)
        *pchBin++ = 0x67;
    if (fOpndOvrd)
        *pchBin++ = 0x66;
    if (segOvrd)
        *pchBin++ = segOvrd;
    if (preOpcode)
        *pchBin++ = preOpcode;
    *pchBin++ = inOpcode;
    if (postOpcode)
        *pchBin++ = postOpcode;
    if (fModrm)
        *pchBin++ = (UCHAR)((((modModrm << 3) + regModrm) << 3) + rmModrm);
    if (fSib)
        *pchBin++ = (UCHAR)((((scaleSib << 3) + indexSib) << 3) + baseSib);

    OutputValue(addrSize, (PUCHAR)&addrValue);     //  size = 0, 1, 2, 4
    OutputValue((UCHAR)(fSegPtr << 1), (PUCHAR)&segPtr); //  size = 0, 2
    OutputValue(immedSize, (PUCHAR)&immedValue);   //  size = 0, 1, 2, 4
    OutputValue(immedSize2, (PUCHAR)&immedValue2); //  size = 0, 1, 2, 4
}

void OutputValue (UCHAR size, PUCHAR pchValue)
{
    while (size--)
        *pchBin++ = *pchValue++;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\event.cpp ===
//----------------------------------------------------------------------------
//
// Event waiting and processing.
//
// Copyright (C) Microsoft Corporation, 1999-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"
#include <common.ver>

// An event can be signalled on certain events for
// synchronizing other programs with the debugger.
HANDLE g_EventToSignal;

// When both creating a debuggee process and attaching
// the debuggee is left suspended until the attach
// succeeds.  At that point the created process's thread
// is resumed.
ULONG64 g_ThreadToResume;

ULONG g_ExecutionStatusRequest = DEBUG_STATUS_NO_CHANGE;
// Currently in seconds.
ULONG g_PendingBreakInTimeoutLimit = 30;

// Set when events occur.  Can't always be retrieved from
// g_Event{Process|Thread}->SystemId since the events may be creation events
// where the info structures haven't been created yet.
ULONG g_EventThreadSysId;
ULONG g_EventProcessSysId;

ULONG g_LastEventType;
char g_LastEventDesc[MAX_IMAGE_PATH + 64];
PVOID g_LastEventExtraData;
ULONG g_LastEventExtraDataSize;
LAST_EVENT_INFO g_LastEventInfo;

// Set when lookups are done during event handling.
PTHREAD_INFO g_EventThread;
PPROCESS_INFO g_EventProcess;
// This is zero for events without a PC.
ULONG64 g_EventPc;

PDEBUG_EXCEPTION_FILTER_PARAMETERS g_EventExceptionFilter;
ULONG g_ExceptionFirstChance;

ULONG g_SystemErrorOutput = SLE_ERROR;
ULONG g_SystemErrorBreak = SLE_ERROR;

ULONG g_SuspendedExecutionStatus;
CHAR g_SuspendedCmdState;
PDBGKD_ANY_CONTROL_REPORT g_ControlReport;
PCHAR g_StateChangeData;
CHAR g_StateChangeBuffer[2 * PACKET_MAX_SIZE];
DBGKD_ANY_WAIT_STATE_CHANGE g_StateChange;
DBGKD_ANY_CONTROL_SET g_ControlSet;
ULONG64 g_SystemRangeStart;
ULONG64 g_SystemCallVirtualAddress;
ULONG g_SwitchProcessor;
KDDEBUGGER_DATA64 KdDebuggerData;
ULONG64 g_KdDebuggerDataBlock;

char g_CreateProcessBreakName[FILTER_MAX_ARGUMENT];
char g_ExitProcessBreakName[FILTER_MAX_ARGUMENT];
char g_LoadDllBreakName[FILTER_MAX_ARGUMENT];
char g_UnloadDllBaseName[FILTER_MAX_ARGUMENT];
ULONG64 g_UnloadDllBase;
char g_OutEventFilterPattern[FILTER_MAX_ARGUMENT];

DEBUG_EXCEPTION_FILTER_PARAMETERS
g_OtherExceptionList[OTHER_EXCEPTION_LIST_MAX];
EVENT_COMMAND g_OtherExceptionCommands[OTHER_EXCEPTION_LIST_MAX];
ULONG g_NumOtherExceptions;

char g_EventLog[512];
PSTR g_EventLogEnd = g_EventLog;

EVENT_FILTER g_EventFilters[] =
{
    //
    // Debug events.
    //

    "Create thread", "ct", NULL, NULL, 0, DEBUG_FILTER_IGNORE,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, 0,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Exit thread", "et", NULL, NULL, 0, DEBUG_FILTER_IGNORE,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, 0,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Create process", "cpr", NULL, NULL, 0, DEBUG_FILTER_IGNORE,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, 0,
        NULL, NULL, NULL, 0, 0, g_CreateProcessBreakName, 0,
    "Exit process", "epr", NULL, NULL, 0, DEBUG_FILTER_IGNORE,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, 0,
        NULL, NULL, NULL, 0, 0, g_ExitProcessBreakName, 0,
    "Load module", "ld", NULL, NULL, 0, DEBUG_FILTER_OUTPUT,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, 0,
        NULL, NULL, NULL, 0, 0, g_LoadDllBreakName, 0,
    "Unload module", "ud", NULL, NULL, 0, DEBUG_FILTER_IGNORE,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, 0,
        NULL, NULL, NULL, 0, 0, g_UnloadDllBaseName, 0,
    "System error", "ser", NULL, NULL, 0, DEBUG_FILTER_IGNORE,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, 0,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Initial breakpoint", "ibp", NULL, NULL, 0, DEBUG_FILTER_IGNORE,
        DEBUG_FILTER_GO_HANDLED, 0, 0, 0, 0,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Initial module load", "iml", NULL, NULL, 0, DEBUG_FILTER_IGNORE,
        DEBUG_FILTER_GO_HANDLED, 0, 0, 0, 0,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Debuggee output", "out", NULL, NULL, 0, DEBUG_FILTER_OUTPUT,
        DEBUG_FILTER_GO_HANDLED, 0, 0, 0, 0,
        NULL, NULL, NULL, 0, 0, g_OutEventFilterPattern, 0,

    // Default exception filter.
    "Unknown exception", NULL, NULL, NULL, 0, DEBUG_FILTER_SECOND_CHANCE_BREAK,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, 0,
        NULL, NULL, NULL, 0, 0, NULL, 0,

    //
    // Specific exceptions.
    //

    "Access violation", "av", NULL, NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, STATUS_ACCESS_VIOLATION,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Break instruction exception", "bpe", "bpec", NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_HANDLED, 0, 0, 0, STATUS_BREAKPOINT,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "C++ EH exception", "eh", NULL, NULL, 0, DEBUG_FILTER_SECOND_CHANCE_BREAK,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, STATUS_CPP_EH_EXCEPTION,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Control-Break exception", "cce", "cc", NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_HANDLED, 0, 0, 0, DBG_CONTROL_BREAK,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Control-C exception", "cce", "cc", NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_HANDLED, 0, 0, 0, DBG_CONTROL_C,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Data misaligned", "dm", NULL, NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, STATUS_DATATYPE_MISALIGNMENT,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Illegal instruction", "ii", NULL, NULL, 0, DEBUG_FILTER_SECOND_CHANCE_BREAK,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, STATUS_ILLEGAL_INSTRUCTION,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "In-page I/O error", "ip", NULL, " %I64x", 2, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, STATUS_IN_PAGE_ERROR,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Integer divide-by-zero", "dz", NULL, NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, STATUS_INTEGER_DIVIDE_BY_ZERO,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Integer overflow", "iov", NULL, NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, STATUS_INTEGER_OVERFLOW,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Invalid handle", "ch", "hc", NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, STATUS_INVALID_HANDLE,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Invalid lock sequence", "lsq", NULL, NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, STATUS_INVALID_LOCK_SEQUENCE,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Invalid system call", "isc", NULL, NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, STATUS_INVALID_SYSTEM_SERVICE,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Port disconnected", "3c", NULL, NULL, 0, DEBUG_FILTER_SECOND_CHANCE_BREAK,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, STATUS_PORT_DISCONNECTED,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Single step exception", "sse", "ssec", NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_HANDLED, 0, 0, 0, STATUS_SINGLE_STEP,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Stack overflow", "sov", NULL, NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, STATUS_STACK_OVERFLOW,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Visual C++ exception", "vcpp", NULL, NULL, 0, DEBUG_FILTER_IGNORE,
        DEBUG_FILTER_GO_HANDLED, 0, 0, 0, STATUS_VCPP_EXCEPTION,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Wake debugger", "wkd", NULL, NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, STATUS_WAKE_SYSTEM_DEBUGGER,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "WOW64 breakpoint", "wob", NULL, NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_HANDLED, 0, 0, 0, STATUS_WX86_BREAKPOINT,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "WOW64 single step exception", "wos", NULL, NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_HANDLED, 0, 0, 0, STATUS_WX86_SINGLE_STEP,
        NULL, NULL, NULL, 0, 0, NULL, 0,
};

void
ClearEventLog(void)
{
    g_EventLogEnd = g_EventLog;
    *g_EventLogEnd = 0;
}

void
OutputEventLog(void)
{
    if (g_EventLogEnd > g_EventLog)
    {
        dprintf("%s", g_EventLog);
    }
    else
    {
        dprintf("Event log is empty\n");
    }

    dprintf("Last event: %s\n", g_LastEventDesc);
}

void
LogEventDesc(PSTR Desc, ULONG ProcId, ULONG ThreadId)
{
    // Extra space for newline and terminator.
    int Len = strlen(Desc) + 2;
    if (IS_USER_TARGET())
    {
        // Space for process and thread IDs.
        Len += 16;
    }
    if (Len > sizeof(g_EventLog))
    {
        Len = sizeof(g_EventLog);
    }

    int Avail = (int)(sizeof(g_EventLog) - (g_EventLogEnd - g_EventLog));
    if (g_EventLogEnd > g_EventLog && Len > Avail)
    {
        PSTR Save = g_EventLog;
        int Need = Len - Avail;
        
        while (Need > 0)
        {
            PSTR Scan = strchr(Save, '\n');
            if (Scan == NULL)
            {
                break;
            }
            
            Scan++;
            Need -= (int)(Scan - Save);
            Save = Scan;
        }

        if (Need > 0)
        {
            // Couldn't make enough space so throw
            // everything away.
            g_EventLogEnd = g_EventLog;
            *g_EventLogEnd = 0;
        }
        else
        {
            Need = strlen(Save);
            memmove(g_EventLog, Save, Need + 1);
            g_EventLogEnd = g_EventLog + Need;
        }
    }
    
    Avail = (int)(sizeof(g_EventLog) - (g_EventLogEnd - g_EventLog));

    if (IS_USER_TARGET())
    {
        sprintf(g_EventLogEnd, "%04x.%04x: ", ProcId, ThreadId);
        Avail -= strlen(g_EventLogEnd);
        g_EventLogEnd += strlen(g_EventLogEnd);
    }

    strncat(g_EventLogEnd, Desc, Avail);
    g_EventLogEnd += strlen(g_EventLogEnd);
    *g_EventLogEnd++ = '\n';
    *g_EventLogEnd = 0;
}

void
DiscardLastEventInfo(void)
{
    if (g_LastEventDesc[0])
    {
        LogEventDesc(g_LastEventDesc, g_EventProcessSysId, g_EventThreadSysId);
    }
    
    g_LastEventType = 0;
    g_LastEventDesc[0] = 0;
    g_LastEventExtraData = NULL;
    g_LastEventExtraDataSize = 0;
}

void
DiscardLastEvent(void)
{
    // Do this before clearing the other information so
    // it's available for the log.
    DiscardLastEventInfo();
    g_EngDefer &= ~ENG_DEFER_CONTINUE_EVENT;
    g_EventProcessSysId = 0;
    g_EventThreadSysId = 0;
    g_EventPc = 0;

    // Clear any cached memory read during the last event.
    InvalidateMemoryCaches();
}

ULONG
EventStatusToContinue(ULONG EventStatus)
{
    switch(EventStatus)
    {
    case DEBUG_STATUS_GO_NOT_HANDLED:
        return DBG_EXCEPTION_NOT_HANDLED;
    case DEBUG_STATUS_GO_HANDLED:
        return DBG_EXCEPTION_HANDLED;
    case DEBUG_STATUS_NO_CHANGE:
    case DEBUG_STATUS_IGNORE_EVENT:
    case DEBUG_STATUS_GO:
    case DEBUG_STATUS_STEP_OVER:
    case DEBUG_STATUS_STEP_INTO:
    case DEBUG_STATUS_STEP_BRANCH:
        return DBG_CONTINUE;
    default:
        DBG_ASSERT(FALSE);
        return DBG_CONTINUE;
    }
}

HRESULT
PrepareForWait(ULONG Flags, PULONG ContinueStatus)
{
    HRESULT Status;

    Status = PrepareForExecution(g_ExecutionStatusRequest);
    if (Status != S_OK)
    {
        // If S_FALSE, we're at a hard breakpoint so the only thing that
        // happens is that the PC is adjusted and the "wait"
        // can succeed immediately.
        // Otherwise we failed execution preparation.  Either way
        // we need to try and prepare for calls.
        PrepareForCalls(0);

        return FAILED(Status) ? Status : S_OK;
    }

    *ContinueStatus = EventStatusToContinue(g_ExecutionStatusRequest);
    g_EngStatus |= ENG_STATUS_WAITING;

    return S_OK;
}

DWORD
GetContinueStatus(ULONG FirstChance, ULONG Continue)
{
    if (!FirstChance || Continue == DEBUG_FILTER_GO_HANDLED)
    {
        return DBG_EXCEPTION_HANDLED;
    }
    else
    {
        return DBG_EXCEPTION_NOT_HANDLED;
    }
}

void
ProcessDeferredWork(PULONG ContinueStatus)
{
    if (g_EngDefer & ENG_DEFER_SET_EVENT)
    {
        // This event signalling is used by the system
        // to synchronize with the debugger when starting
        // the debugger via AeDebug.  The -e parameter
        // to ntsd sets this value.
        // It could potentially be used in other situations.
        if (g_EventToSignal != NULL)
        {
            SetEvent(g_EventToSignal);
            g_EventToSignal = NULL;
        }

        g_EngDefer &= ~ENG_DEFER_SET_EVENT;
    }

    if (g_EngDefer & ENG_DEFER_RESUME_THREAD)
    {
        DBG_ASSERT(IS_LIVE_USER_TARGET());
        
        ((UserTargetInfo*)g_Target)->m_Services->
            ResumeThreads(1, &g_ThreadToResume, NULL);
        g_ThreadToResume = 0;
        g_EngDefer &= ~ENG_DEFER_RESUME_THREAD;
    }

    if (g_EngDefer & ENG_DEFER_EXCEPTION_HANDLING)
    {
        if (*ContinueStatus == DBG_CONTINUE)
        {
            if (g_EventExceptionFilter != NULL)
            {
                // A user-visible exception occurred so check on how it
                // should be handled.
                *ContinueStatus =
                    GetContinueStatus(g_ExceptionFirstChance,
                                      g_EventExceptionFilter->ContinueOption);
              
            }
            else
            {
                // An internal exception occurred, such as a single-step.
                // Force the continue status.
                *ContinueStatus = g_ExceptionFirstChance;
            }
        }

        g_EngDefer &= ~ENG_DEFER_EXCEPTION_HANDLING;
    }

    // If output was deferred but the wait was exited anyway
    // a stale defer flag will be left.  Make sure it's cleared.
    g_EngDefer &= ~ENG_DEFER_OUTPUT_CURRENT_INFO;

    // Clear at-initial flags.  If the incoming event
    // turns out to be one of them it'll turn on the flag.
    g_EngStatus &= ~(ENG_STATUS_AT_INITIAL_BREAK |
                     ENG_STATUS_AT_INITIAL_MODULE_LOAD);
}

BOOL
SuspendExecution(void)
{
    if (g_EngStatus & ENG_STATUS_SUSPENDED)
    {
        // Nothing to do.
        return FALSE;
    }

    g_LastSelector = -1;          // Prevent stale selector values

    SuspendAllThreads();

    // Don't notify on any state changes as
    // PrepareForCalls will do a blanket notify later.
    g_EngNotify++;

    // If we have an event thread select it.
    if (g_EventThread != NULL)
    {
        DBG_ASSERT(g_RegContextThread == NULL);
        ChangeRegContext(g_EventThread);
    }

    // First set the effective machine to the true
    // processor type so that real processor information
    // can be examined to determine any possible
    // alternate execution states.
    // No need to notify here as another SetEffMachine
    // is coming up.
    SetEffMachine(g_TargetMachineType, FALSE);
    if (g_EngStatus & ENG_STATUS_STATE_CHANGED)
    {
        g_Machine->InitializeContext(g_EventPc, g_ControlReport);
        g_EngStatus &= ~ENG_STATUS_STATE_CHANGED;
    }

    if (!IS_DUMP_TARGET())
    {
        g_Machine->QuietSetTraceMode(TRACE_NONE);
    }

    // Now determine the executing code type and
    // make that the effective machine.
    if (IS_CONTEXT_POSSIBLE())
    {
        g_TargetExecMachine = g_Machine->ExecutingMachine();
    }
    else
    {
        // Local kernel debugging doesn't deal with contexts
        // as everything would be in the context of the debugger.
        // It's safe to just assume the executing machine
        // is the target machine, plus this avoids unwanted
        // context access.
        g_TargetExecMachine = g_TargetMachineType;
    }
    SetEffMachine(g_TargetExecMachine, TRUE);
    
    // Trace flag should always be clear at this point.
    g_EngDefer &= ~ENG_DEFER_HARDWARE_TRACING;

    g_EngNotify--;

    g_EngStatus |= ENG_STATUS_SUSPENDED;
    g_SuspendedExecutionStatus = GetExecutionStatus();
    g_SuspendedCmdState = g_CmdState;

    g_ContextChanged = FALSE;

    return TRUE;
}

HRESULT
ResumeExecution(void)
{
    if ((g_EngStatus & ENG_STATUS_SUSPENDED) == 0)
    {
        // Nothing to do.
        return S_OK;
    }

    if (g_Machine->GetTraceMode() != TRACE_NONE)
    {
        g_EngDefer |= ENG_DEFER_HARDWARE_TRACING;
    }
    
    if (IS_REMOTE_KERNEL_TARGET())
    {
        g_Machine->KdUpdateControlSet(&g_ControlSet);
        g_EngDefer |= ENG_DEFER_UPDATE_CONTROL_SET;
    }

    // Flush context.
    ChangeRegContext(NULL);

    // Make sure stale values aren't held across
    // executions.
    ResetImplicitData();
    FlushMachinePerExecutionCaches();
    
    if (!ResumeAllThreads())
    {
        ChangeRegContext(g_EventThread);
        return E_FAIL;
    }

    g_EngStatus &= ~ENG_STATUS_SUSPENDED;
    return S_OK;
}

void
PrepareForCalls(ULONG64 ExtraStatusFlags)
{
    BOOL HardBrkpt = FALSE;
    ADDR PcAddr;
    BOOL Changed = FALSE;

    // If there's no event then execution didn't really
    // occur so there's no need to suspend.  This will happen
    // when a debuggee exits or during errors on execution
    // preparation.
    if (g_EventThreadSysId != 0)
    {
        if (SuspendExecution())
        {
            Changed = TRUE;
        }
    }
    else
    {
        g_CmdState = 'c';

        // Force notification in this case to ensure
        // that clients know the engine is not running.
        Changed = TRUE;
    }

    if (RemoveBreakpoints())
    {
        Changed = TRUE;
    }

    if (g_CmdState != 'c')
    {
        g_CmdState = 'c';
        Changed = TRUE;

        if (!IS_CONTEXT_ACCESSIBLE())
        {
            ADDRFLAT(&PcAddr, 0);
        }
        else
        {
            g_Machine->GetPC(&PcAddr);
            if (IS_KERNEL_TARGET())
            {
                HardBrkpt = g_Machine->IsBreakpointInstruction(&PcAddr);
            }
        }
        g_DumpDefault = g_UnasmDefault = g_AssemDefault = PcAddr;
    }

    g_EngStatus |= ENG_STATUS_PREPARED_FOR_CALLS;

    if (HardBrkpt &&
        Flat(PcAddr) == KdDebuggerData.BreakpointWithStatus)
    {
        HandleBPWithStatus();
    }

    if (Changed)
    {
        if (IS_MACHINE_ACCESSIBLE())
        {
            ResetCurrentScopeLazy();
        }

        // This can produce many notifications.  Callers should
        // suppress notification when they can to avoid multiple
        // notifications during a single operation.
        NotifyChangeEngineState(DEBUG_CES_EXECUTION_STATUS,
                                DEBUG_STATUS_BREAK | ExtraStatusFlags, TRUE);
        NotifyChangeDebuggeeState(DEBUG_CDS_ALL, 0);
        NotifyExtensions(DEBUG_NOTIFY_SESSION_ACCESSIBLE, 0);
    }
    else if (ExtraStatusFlags == 0)
    {
        // We're exiting a wait so force the current execution
        // status to be sent to let everybody know that a
        // wait is finishing.
        NotifyChangeEngineState(DEBUG_CES_EXECUTION_STATUS,
                                DEBUG_STATUS_BREAK, TRUE);
    }
}

HRESULT
PrepareForExecution(ULONG NewStatus)
{
    ADDR PcAddr;
    BOOL fHardBrkpt = FALSE;
    PTHREAD_INFO StepThread = NULL;
        
    ZeroMemory(&g_PrevRelatedPc, sizeof(g_PrevRelatedPc));

    // If all processes have exited we don't have any way
    // to manipulate the debuggee so we must fail immediately.
    if ((g_EngStatus & ENG_STATUS_PROCESSES_ADDED) &&
        !ANY_PROCESSES())
    {
        return E_UNEXPECTED;
    }

 StepAgain:
    // Display current information on intermediate steps where
    // the debugger UI isn't even invoked.
    if ((g_EngDefer & ENG_DEFER_OUTPUT_CURRENT_INFO) &&
        (g_EngStatus & ENG_STATUS_STOP_SESSION) == 0)
    {
        OutCurInfo(OCI_SYMBOL | OCI_DISASM | OCI_ALLOW_EA |
                   OCI_ALLOW_REG | OCI_ALLOW_SOURCE | OCI_IGNORE_STATE,
                   g_Machine->m_AllMask, DEBUG_OUTPUT_PROMPT_REGISTERS);
        g_EngDefer &= ~ENG_DEFER_OUTPUT_CURRENT_INFO;
    }
    
    // Don't notify on any state changes as
    // PrepareForCalls will do a blanket notify later.
    g_EngNotify++;

    if (g_EngStatus & ENG_STATUS_SUSPENDED)
    {
        if (g_CmdState != 's')
        {
            if (NewStatus != DEBUG_STATUS_IGNORE_EVENT)
            {
                SetExecutionStatus(NewStatus);
                DBG_ASSERT(IS_RUNNING(g_CmdState));
            }
            else
            {
                NewStatus = g_SuspendedExecutionStatus;
                g_CmdState = g_SuspendedCmdState;
            }
        }

        if ((g_StepTraceBp->m_Flags & DEBUG_BREAKPOINT_ENABLED) &&
            g_StepTraceBp->m_MatchThread)
        {
            StepThread = g_StepTraceBp->m_MatchThread;

            // Check and see if we need to fake a step/trace
            // event when artificially moving beyond a hard-coded
            // break instruction.
            if (!StepThread->Process->Exited)
            {
                MachineInfo* Machine = g_Machine;
                
                ChangeRegContext(StepThread);
                Machine->GetPC(&PcAddr);
                fHardBrkpt = Machine->IsBreakpointInstruction(&PcAddr);
                if (fHardBrkpt)
                {
                    g_WatchBeginCurFunc = 1;
                    
                    Machine->AdjustPCPastBreakpointInstruction
                        (&PcAddr, DEBUG_BREAKPOINT_CODE);
                    if (Flat(*g_StepTraceBp->GetAddr()) != OFFSET_TRACE)
                    {
                        ULONG NextMachine;
                
                        Machine->GetNextOffset(g_StepTraceCmdState == 'p',
                                               g_StepTraceBp->GetAddr(),
                                               &NextMachine);
                        g_StepTraceBp->SetProcType(NextMachine);
                    }
                    GetCurrentMemoryOffsets(&g_StepTraceInRangeStart,
                                            &g_StepTraceInRangeEnd);

                    if (StepTracePass(&PcAddr))
                    {
                        // If the step was passed over go back
                        // and update things based on the adjusted PC.
                        g_EngNotify--;
                        goto StepAgain;
                    }
                }
            }
        }

        // If the last event was a hard-coded breakpoint exception
        // we need to move the event thread beyond the break instruction.
        // Note that if we continued stepping on that thread it was
        // handled above, so we only do this if it's a different
        // thread or we're not stepping.
        // If the continuation status is not-handled then
        // we need to let the int3 get hit again.  If we're
        // exiting, though, we don't want to do this.
        if (g_EventThread != NULL &&
            !g_EventThread->Process->Exited &&
            !IS_LOCAL_KERNEL_TARGET() &&
            g_CmdState != 's' &&
            g_EventThread != StepThread &&
            (NewStatus != DEBUG_STATUS_GO_NOT_HANDLED ||
             (g_EngStatus & ENG_STATUS_STOP_SESSION)))
        {
            ChangeRegContext(g_EventThread);
            
            g_Machine->GetPC(&PcAddr);
            if (g_Machine->IsBreakpointInstruction(&PcAddr))
            {
                g_Machine->AdjustPCPastBreakpointInstruction
                    (&PcAddr, DEBUG_BREAKPOINT_CODE);
            }

            if (StepThread != NULL)
            {
                ChangeRegContext(StepThread);
            }
        }
    }

    HRESULT Status;

    if (g_EngStatus & ENG_STATUS_STOP_SESSION)
    {
        // If we're stopping don't insert breakpoints in
        // case we're detaching from the process.  In
        // that case we want threads to run normally.
        Status = S_OK;
    }
    else
    {
        Status = InsertBreakpoints();
    }

    // Resume notification now that modifications are done.
    g_EngNotify--;

    if (Status != S_OK)
    {
        return Status;
    }

    if ((Status = ResumeExecution()) != S_OK)
    {
        return Status;
    }

    g_TargetExecMachine = IMAGE_FILE_MACHINE_UNKNOWN;
    g_EngStatus &= ~ENG_STATUS_PREPARED_FOR_CALLS;

    if (g_CmdState != 's')
    {
        // Now that we've resumed execution notify about the change.
        NotifyChangeEngineState(DEBUG_CES_EXECUTION_STATUS,
                                NewStatus, TRUE);
        NotifyExtensions(DEBUG_NOTIFY_SESSION_INACCESSIBLE, 0);
    }

    if (fHardBrkpt && StepThread != NULL)
    {
        // We're stepping over a hard breakpoint.  This is
        // done entirely by the debugger so no debug event
        // is associated with it.  Instead we simply update
        // the PC and return from the Wait without actually waiting.

        // Step/trace events have empty event info.
        DiscardLastEventInfo();
        g_EventThreadSysId = StepThread->SystemId;
        g_EventProcessSysId = StepThread->Process->SystemId;
        FindEventProcessThread();
        
        return S_FALSE;
    }

    // Once we resume execution the processes and threads
    // can change so we must flush our notion of what's current.
    g_CurrentProcess = NULL;
    g_EventProcess = NULL;
    g_EventThread = NULL;

    if (g_EngDefer & ENG_DEFER_DELETE_EXITED)
    {
        // Reap any threads and processes that have terminated since
        // we last executed.
        if (DeleteExitedInfos())
        {
            OutputProcessInfo("*** exit cleanup ***");
        }

        g_EngDefer &= ~ENG_DEFER_DELETE_EXITED;

        // If all processes have exited we're done.
        if (!ANY_PROCESSES())
        {
            if (IS_LIVE_USER_TARGET())
            {
                // If there's an outstanding event continue it.
                if (g_EngDefer & ENG_DEFER_CONTINUE_EVENT)
                {
                    ((UserTargetInfo*)g_Target)->m_Services->
                        ContinueEvent(DBG_CONTINUE);
                    DiscardLastEvent();
                }
            }

            DiscardMachine(DEBUG_SESSION_END);
            return E_UNEXPECTED;
        }
    }

    return S_OK;
}

HRESULT
PrepareForSeparation(void)
{
    HRESULT Status;
    ULONG OldStop = g_EngStatus & ENG_STATUS_STOP_SESSION;
    
    //
    // The debugger is going to separate from the
    // debuggee, such as during a detach operation.
    // Get the debuggee running again so that it
    // will go on without the debugger.
    //

    g_EngStatus |= ENG_STATUS_STOP_SESSION;

    Status = PrepareForExecution(DEBUG_STATUS_GO_HANDLED);
    if (g_ProcessHead == NULL)
    {
        // All processes are gone so don't consider
        // it an error if we couldn't resume execution.
        Status = S_OK;
    }

    g_EngStatus = (g_EngStatus & ~ENG_STATUS_STOP_SESSION) | OldStop;
    return Status;
}

void
FindEventProcessThread(void)
{
    //
    // If these lookups fail other processes and
    // threads cannot be substituted for the correct
    // ones as that may cause modifications to the
    // wrong data structures.  For example, if a
    // thread exit comes in it cannot be processed
    // with any other process or thread as that would
    // delete the wrong thread.
    //
    
    g_EventProcess = FindProcessBySystemId(g_EventProcessSysId);
    if (g_EventProcess == NULL)
    {
        ErrOut("ERROR: Unable to find system process %X\n",
               g_EventProcessSysId);
        ErrOut("ERROR: The process being debugged has either exited "
               "or cannot be accessed\n");
        ErrOut("ERROR: Many commands will not work properly\n");
    }
    else
    {
        g_EventThread = FindThreadBySystemId(g_EventProcess,
                                             g_EventThreadSysId);
        if (g_EventThread == NULL)
        {
            ErrOut("ERROR: Unable to find system thread %X\n",
                   g_EventThreadSysId);
            ErrOut("ERROR: The thread being debugged has either exited "
                   "or cannot be accessed\n");
            ErrOut("ERROR: Many commands will not work properly\n");
        }
    }

    g_CurrentProcess = g_EventProcess;
    if (g_CurrentProcess != NULL)
    {
        g_CurrentProcess->CurrentThread = g_EventThread;
        DBG_ASSERT(g_EventThread == NULL ||
                   g_EventThread->Process == g_CurrentProcess);
    }
}

static int VoteWeight[] = 
{
    0, // DEBUG_STATUS_NO_CHANGE
    2, // DEBUG_STATUS_GO             
    3, // DEBUG_STATUS_GO_HANDLED     
    4, // DEBUG_STATUS_GO_NOT_HANDLED 
    6, // DEBUG_STATUS_STEP_OVER      
    7, // DEBUG_STATUS_STEP_INTO      
    8, // DEBUG_STATUS_BREAK          
    9, // DEBUG_STATUS_NO_DEBUGGEE    
    5, // DEBUG_STATUS_STEP_BRANCH
    1, // DEBUG_STATUS_IGNORE_EVENT
};

ULONG
MergeVotes(ULONG Cur, ULONG Vote)
{
    // If the vote is actually an error code display a message.
    if (FAILED(Vote))
    {
        ErrOut("Callback failed with %X\n", Vote);
        return Cur;
    }

    // Ignore invalid votes.
    if (
        (
#if DEBUG_STATUS_NO_CHANGE > 0
         Vote < DEBUG_STATUS_NO_CHANGE ||
#endif
         Vote > DEBUG_STATUS_BREAK) &&
        (Vote < DEBUG_STATUS_STEP_BRANCH ||
         Vote > DEBUG_STATUS_IGNORE_EVENT))
    {
        ErrOut("Callback returned invalid vote %X\n", Vote);
        return Cur;
    }

    // Votes are biased towards executing as little
    // as possible.
    //   Break overrides all other votes.
    //   Step into overrides step over.
    //   Step over overrides step branch.
    //   Step branch overrides go.
    //   Go not-handled overrides go handled.
    //   Go handled overrides plain go.
    //   Plain go overrides ignore event.
    //   Anything overrides no change.
    if (VoteWeight[Vote] > VoteWeight[Cur])
    {
        Cur = Vote;
    }

    return Cur;
}

ULONG
ProcessBreakpointOrStepException(PEXCEPTION_RECORD64 Record,
                                 ULONG FirstChance)
{
    ADDR BpAddr;
    ULONG BreakType;
    ULONG EventStatus;

    SuspendExecution();
    // Default breakpoint address to the current PC as that's
    // where the majority are at.
    g_Machine->GetPC(&BpAddr);

    // Check whether the exception is a breakpoint.
    BreakType = g_Machine->IsBreakpointOrStepException(Record, FirstChance,
                                                       &BpAddr,
                                                       &g_PrevRelatedPc);
    if (BreakType & EXBS_BREAKPOINT_ANY)
    {
        // It's a breakpoint of some kind.
        EventOut("*** breakpoint exception\n");
        EventStatus = CheckBreakpointOrStepTrace(&BpAddr, BreakType);
    }
    else
    {
        // It's a true single step or taken branch exception.  
        // We still need to check breakpoints as we may have stepped
        // to an instruction which has a breakpoint.
        EventOut("*** single step or taken branch exception\n");
        EventStatus = CheckBreakpointOrStepTrace(&BpAddr, EXBS_BREAKPOINT_ANY);
    }
    
    if (EventStatus == DEBUG_STATUS_NO_CHANGE)
    {
        // The break/step exception wasn't recognized
        // as a debugger-specific event so handle it as
        // a regular exception.  The default states for
        // break/step exceptions are to break in so
        // this will do the right thing, plus it allows
        // people to ignore or notify for them if they want.
        EventStatus = NotifyExceptionEvent(Record, FirstChance, FALSE);
    }
    else
    {
        // Force the exception to be handled.
        g_EngDefer |= ENG_DEFER_EXCEPTION_HANDLING;
        g_EventExceptionFilter = NULL;
        g_ExceptionFirstChance = DBG_EXCEPTION_HANDLED;
    }

    return EventStatus;
}

ULONG
CheckBreakpointOrStepTrace(PADDR BpAddr, ULONG BreakType)
{
    ULONG EventStatus;
    Breakpoint* Bp;
    ULONG BreakHitType;
    BOOL BpHit;

    BpHit = FALSE;
    Bp = NULL;
    EventStatus = DEBUG_STATUS_NO_CHANGE;

    // Multiple breakpoints can be hit at the same address.
    // Process all possible hits.  Do not do notifications
    // while walking the list as the callbacks may modify
    // the list.  Instead just mark the breakpoint as
    // needing notification in the next pass.
    for (;;)
    {
        Bp = CheckBreakpointHit(g_EventProcess, Bp, BpAddr, BreakType, -1,
                                g_CmdState != 'g' ?
                                DEBUG_BREAKPOINT_GO_ONLY : 0,
                                &BreakHitType, TRUE);
        if (Bp == NULL)
        {
            break;
        }

        if (BreakHitType == BREAKPOINT_HIT)
        {
            Bp->m_Flags |= BREAKPOINT_NOTIFY;
        }
        else
        {
            // This breakpoint was hit but the hit was ignored.
            // Vote to continue execution.
            EventStatus = MergeVotes(EventStatus, DEBUG_STATUS_IGNORE_EVENT);
        }

        BpHit = TRUE;
        Bp = Bp->m_Next;
        if (Bp == NULL)
        {
            break;
        }
    }

    if (!BpHit)
    {
        // If no breakpoints were recognized check for an internal
        // breakpoint.
        EventStatus = CheckStepTrace(BpAddr, EventStatus);

        //
        // If the breakpoint wasn't for a step/trace
        // it's a hard breakpoint and should be
        // handled as a normal exception.
        //

        if (!g_EventProcess->InitialBreakDone)
        {
            g_EngStatus |= ENG_STATUS_AT_INITIAL_BREAK;
        }
        
        // We've seen the initial break for this process.
        g_EventProcess->InitialBreakDone = TRUE;
        // If we were waiting for a break-in exception we've got it.
        g_EngStatus &= ~ENG_STATUS_PENDING_BREAK_IN;
        
        if (EventStatus == DEBUG_STATUS_NO_CHANGE)
        {
            if (!g_EventProcess->InitialBreak)
            {
                // Refresh breakpoints even though we're not
                // stopping.  This gives saved breakpoints
                // a chance to become active.
                RemoveBreakpoints();
                
                EventStatus = DEBUG_STATUS_GO;
                g_EventProcess->InitialBreak = TRUE;
            }
            else if ((!g_EventProcess->InitialBreakWx86) &&
                     (g_TargetMachineType != g_EffMachine) &&
                     (g_EffMachine == IMAGE_FILE_MACHINE_I386))
            {
                // Allow skipping of both the target machine
                // initial break and emulated machine initial breaks.
                RemoveBreakpoints();
                EventStatus = DEBUG_STATUS_GO;
                g_EventProcess->InitialBreakWx86 = TRUE;
            }
        }
    }
    else
    {
        // A breakpoint was recognized.  We need to
        // refresh the breakpoint status since we'll
        // probably need to defer the reinsertion of
        // the breakpoint we're sitting on.
        RemoveBreakpoints();

        // Now do event callbacks for any breakpoints that need it.
        EventStatus = NotifyHitBreakpoints(EventStatus);
    }

    if (g_ThreadToResume != 0)
    {
        g_EngDefer |= ENG_DEFER_RESUME_THREAD;
    }

    return EventStatus;
}

ULONG
CheckStepTrace(PADDR PcAddr, ULONG DefaultStatus)
{
    BOOL WatchStepOver = FALSE;
    ULONG uOciFlags;
    ULONG NextMachine;

    if ((g_StepTraceBp->m_Flags & DEBUG_BREAKPOINT_ENABLED) &&
        Flat(*g_StepTraceBp->GetAddr()) != OFFSET_TRACE)
    {
        NotFlat(*g_StepTraceBp->GetAddr());
        ComputeFlatAddress(g_StepTraceBp->GetAddr(), NULL);
    }

    // We do not check ENG_THREAD_TRACE_SET here because
    // this event detection is only for proper user-initiated
    // step/trace events.  Such an event must occur immediately
    // after the t/p/b, otherwise we cannot be sure that
    // it's actually a debugger event and not an app-generated
    // single-step exception.
    // In user mode we restrict the step/trace state
    // to a single thread to try and be as precise
    // as possible.  This isn't done in kernel mode
    // since kernel mode "threads" are currently
    // just placeholders for processors.  It is
    // possible for a context switch to occur at any
    // time while stepping, meaning a true system
    // thread could move from one processor to another.
    // The processor state, including the single-step
    // flag, will be moved with the thread so single
    // step exceptions will come from the new processor
    // rather than this one, meaning we would ignore
    // it if we used "thread" restrictions.  Instead,
    // just assume any single-step exception while in
    // p/t mode is a debugger step.
    if ((g_StepTraceBp->m_Flags & DEBUG_BREAKPOINT_ENABLED) &&
        g_StepTraceBp->m_Process == g_EventProcess &&
        ((IS_KERNEL_TARGET() && IS_STEP_TRACE(g_CmdState)) ||
         g_StepTraceBp->m_MatchThread == g_EventThread) &&
        (Flat(*g_StepTraceBp->GetAddr()) == OFFSET_TRACE ||
         AddrEqu(*g_StepTraceBp->GetAddr(), *PcAddr)))
    {
        ADDR CurrentSP;

        //  step/trace event occurred

        // Update breakpoint status since we may need to step
        // again and step/trace is updated when breakpoints
        // are inserted.
        RemoveBreakpoints();

        uOciFlags = OCI_DISASM | OCI_ALLOW_REG | OCI_ALLOW_SOURCE |
            OCI_ALLOW_EA;

        if (g_EngStatus & (ENG_STATUS_PENDING_BREAK_IN |
                           ENG_STATUS_USER_INTERRUPT))
        {
            g_WatchFunctions.End(PcAddr);
            return DEBUG_STATUS_BREAK;
        }

        if (IS_KERNEL_TARGET() && g_WatchInitialSP)
        {
            g_Machine->GetSP(&CurrentSP);

            if ((Flat(CurrentSP) + 0x1500 < g_WatchInitialSP) ||
                (g_WatchInitialSP + 0x1500 < Flat(CurrentSP)))
            {
                return DEBUG_STATUS_IGNORE_EVENT;
            }
        }

        if (g_StepTraceInRangeStart != -1 &&
            Flat(*PcAddr) >= g_StepTraceInRangeStart &&
            Flat(*PcAddr) < g_StepTraceInRangeEnd)
        {
            //  test if step/trace range active
            //      if so, compute the next offset and pass through

            g_Machine->GetNextOffset(g_StepTraceCmdState == 'p',
                                     g_StepTraceBp->GetAddr(),
                                     &NextMachine);
            g_StepTraceBp->SetProcType(NextMachine);
            if (g_WatchWhole)
            {
                g_WatchBeginCurFunc = Flat(*g_StepTraceBp->GetAddr());
                g_WatchEndCurFunc = 0;
            }

            return DEBUG_STATUS_IGNORE_EVENT;
        }

        //  active step/trace event - note event if count is zero

        if (!StepTracePass(PcAddr) ||
            (g_WatchFunctions.IsStarted() && AddrEqu(g_WatchTarget, *PcAddr) &&
             (!IS_KERNEL_TARGET() || Flat(CurrentSP) >= g_WatchInitialSP)))
        {
            g_WatchFunctions.End(PcAddr);
            return DEBUG_STATUS_BREAK;
        }

        if (g_WatchFunctions.IsStarted())
        {
            if (g_WatchTrace)
            {
                g_Target->
                    ProcessWatchTraceEvent((PDBGKD_TRACE_DATA)
                                           g_StateChangeData, *PcAddr);
            }
            goto skipit;
        }

        if (g_SrcOptions & SRCOPT_STEP_SOURCE)
        {
            goto skipit;
        }

        //  more remaining events to occur, but output
        //      the instruction (optionally with registers)
        //      compute the step/trace address for next event

        OutCurInfo(uOciFlags, g_Machine->m_AllMask,
                   DEBUG_OUTPUT_PROMPT_REGISTERS);

skipit:
        g_Machine->GetNextOffset(g_StepTraceCmdState == 'p' || WatchStepOver,
                                 g_StepTraceBp->GetAddr(),
                                 &NextMachine);
        g_StepTraceBp->SetProcType(NextMachine);
        GetCurrentMemoryOffsets(&g_StepTraceInRangeStart,
                                &g_StepTraceInRangeEnd);

        return DEBUG_STATUS_IGNORE_EVENT;
    }

    // Carry out deferred breakpoint work if necessary.
    // We need to check the thread deferred-bp flag here as
    // other events may occur before the thread with deferred
    // work gets to execute again, in which case the setting
    // of g_DeferDefined may have changed.
    if ((g_EventThread != NULL &&
         (g_EventThread->Flags & ENG_THREAD_DEFER_BP_TRACE)) ||
        (g_DeferDefined &&
         g_DeferBp->m_Process == g_EventProcess &&
         (Flat(*g_DeferBp->GetAddr()) == OFFSET_TRACE ||
          AddrEqu(*g_DeferBp->GetAddr(), *PcAddr))))
    {
        if ((g_EngOptions & DEBUG_ENGOPT_SYNCHRONIZE_BREAKPOINTS) &&
            IS_USER_TARGET() &&
            g_SelectExecutionThread == SELTHREAD_INTERNAL_THREAD &&
            g_SelectedThread == g_EventThread)
        {
            // The engine internally restricted execution to
            // this particular thread in order to manage
            // breakpoints in multithreaded conditions.
            // The deferred work will be finished before
            // we resume so we can drop the lock.
            g_SelectExecutionThread = SELTHREAD_ANY;
            g_SelectedThread = NULL;
        }
        
        // Deferred breakpoints are refreshed on breakpoint
        // insertion so make sure that insertion happens
        // when things restart.
        RemoveBreakpoints();
        return DEBUG_STATUS_IGNORE_EVENT;
    }

    // If the event was unrecognized return the default status.
    return DefaultStatus;
}

void
AnalyzeDeadlock(PEXCEPTION_RECORD64 Record, ULONG FirstChance)
{
    CHAR Symbol[MAX_SYMBOL_LEN];
    DWORD64 Displacement;
    PTHREAD_INFO pThreadOwner = NULL;
    DWORD TID = 0;
    ADDR addrCritSec;
    RTL_CRITICAL_SECTION CritSec;
    char szBangCritsec[32];

    // poking around inside NT's user-mode RTL_CRITICAL_SECTION and
    // RTL_RESOURCE structures.

    //
    // Get the symbolic name of the routine which
    // raised the exception to see if it matches
    // one of the expected ones in ntdll.
    //

    GetSymbolStdCall((ULONG64)Record->ExceptionAddress,
                     Symbol,
                     sizeof(Symbol),
                     &Displacement,
                     NULL
                     );

    if ( !_stricmp("ntdll!RtlpWaitForCriticalSection", Symbol))
    {
        //
        // If the first parameter is a pointer to the critsect as it
        // should be, switch to the owning thread before bringing
        // up the prompt.  This way it's obvious where the problem
        // is.
        //

        if (Record->ExceptionInformation[0])
        {
            ADDRFLAT(&addrCritSec, Record->ExceptionInformation[0]);
            if (GetMemString(&addrCritSec, (PUCHAR)&CritSec, sizeof(CritSec)))
            {
                if (NULL == CritSec.DebugInfo)
                {
                    dprintf("Critsec %s was deleted or was never initialized.\n",
                            FormatAddr64(Record->ExceptionInformation[0]));
                }
                else if (CritSec.LockCount < -1)
                {
                    dprintf("Critsec %s was left when not owned, corrupted.\n",
                            FormatAddr64(Record->ExceptionInformation[0]));
                }
                else
                {
                    TID = (DWORD)((ULONG_PTR)CritSec.OwningThread);
                    pThreadOwner = FindThreadBySystemId(g_CurrentProcess, TID);
                }
            }
        }

        if (pThreadOwner)
        {
            dprintf("Critsec %s owned by thread %d (.%x) "
                    "caused thread %d (.%x)\n"
                    "      to timeout entering it.  "
                    "Breaking in on owner thread, ask\n"
                    "      yourself why it has held this "
                    "critsec long enough to deadlock.\n"
                    "      Use `~%ds` to switch back to timeout thread.\n",
                    FormatAddr64(Record->ExceptionInformation[0]),
                    pThreadOwner->UserId,
                    pThreadOwner->SystemId,
                    g_CurrentProcess->CurrentThread->UserId,
                    g_CurrentProcess->CurrentThread->SystemId,
                    g_CurrentProcess->CurrentThread->UserId);

            g_EventThread = pThreadOwner;

            SetPromptThread(pThreadOwner, 0);
        }
        else if (TID)
        {
            dprintf("Critsec %s ABANDONED owner thread ID is .%x, "
                    "no such thread.\n",
                    FormatAddr64(Record->ExceptionInformation[0]),
                    TID);
        }

        if (!FirstChance)
        {
            dprintf("!!! second chance !!!\n");
        }

        //
        // do a !critsec for them
        //

        if (Record->ExceptionInformation[0])
        {
            sprintf(szBangCritsec, "critsec %s",
                    FormatAddr64(Record->ExceptionInformation[0]));
            dprintf("!%s\n", szBangCritsec);
            fnBangCmd(NULL, szBangCritsec, NULL, FALSE);
        }
    }
    else if ( !_stricmp("ntdll!RtlAcquireResourceShared", Symbol) ||
              !_stricmp("ntdll!RtlAcquireResourceExclusive", Symbol) ||
              !_stricmp("ntdll!RtlConvertSharedToExclusive", Symbol) )
    {
        dprintf("deadlock in %s ",
                1 + strstr(Symbol, "!")
                );

        GetSymbolStdCall(Record->ExceptionInformation[0],
                         Symbol,
                         sizeof(Symbol),
                         &Displacement,
                         NULL);

        dprintf("Resource %s", Symbol);
        if (Displacement)
        {
            dprintf("+%s", FormatDisp64(Displacement));
        }
        dprintf(" (%s)\n",
                FormatAddr64(Record->ExceptionInformation[0]));
        if (!FirstChance)
        {
            dprintf("!!! second chance !!!\n");
        }


        // Someone who uses RTL_RESOURCEs might write a !resource
        // for ntsdexts.dll like !critsec.
    }
    else
    {
        dprintf("Possible Deadlock in %s ",
                Symbol
                );

        GetSymbolStdCall(Record->ExceptionInformation[0],
                         Symbol,
                         sizeof(Symbol),
                         &Displacement,
                         NULL);

        dprintf("Lock %s", Symbol);
        if (Displacement)
        {
            dprintf("+%s", FormatDisp64(Displacement));
        }
        dprintf(" (%s)\n",
                FormatAddr64(Record->ExceptionInformation[0]));
        if (!FirstChance)
        {
            dprintf("!!! second chance !!!\n");
        }
    }
}

void
OutputDeadlock(PEXCEPTION_RECORD64 Record, ULONG FirstChance)
{
    CHAR Symbol[MAX_SYMBOL_LEN];
    DWORD64 Displacement;

    GetSymbolStdCall(Record->ExceptionInformation[0],
                     Symbol,
                     sizeof(Symbol),
                     &Displacement,
                     NULL);

    dprintf("Possible Deadlock Lock %s+%s at %s\n",
            Symbol,
            FormatDisp64(Displacement),
            FormatAddr64(Record->ExceptionInformation[0]));
    if (!FirstChance)
    {
        dprintf("!!! second chance !!!\n");
    }
}

void
GetEventName(ULONG64 ImageFile, ULONG64 ImageBase,
             ULONG64 NamePtr, WORD Unicode,
             PSTR NameBuffer, ULONG BufferSize)
{
    SIZE_T BytesRead;
    char TempName[MAX_IMAGE_PATH];

    if (NamePtr != 0)
    {
        if (g_Target->ReadPointer(g_TargetMachine, NamePtr, &NamePtr) != S_OK)
        {
            NamePtr = 0;
        }
    }

    if (NamePtr != 0)
    {
        ULONG Done;
        
        if (g_Target->ReadVirtual(NamePtr, TempName, sizeof(TempName),
                                  &Done) != S_OK ||
            Done != sizeof(TempName))
        {
            NamePtr = 0;
        }
    }

    if (NamePtr != 0)
    {
        //
        // We have a name.
        //
        if (Unicode)
        {
            if (!WideCharToMultiByte(
                    CP_ACP,
                    WC_COMPOSITECHECK,
                    (LPWSTR)TempName,
                    -1,
                    NameBuffer,
                    BufferSize,
                    NULL,
                    NULL
                    ))
            {
                //
                // Unicode -> ANSI conversion failed.
                //
                NameBuffer[0] = 0;
            }
        }
        else
        {
            strncpy(NameBuffer, TempName, BufferSize);
            NameBuffer[BufferSize - 1] = 0;
        }
    }
    else
    {
        //
        // We don't have a name, so look in the image.
        // A file handle will only be provided here in the
        // local case so it's safe to case to HANDLE.
        //
        if (!GetModnameFromImage(ImageBase, OS_HANDLE(ImageFile),
                                 NameBuffer, BufferSize))
        {
            NameBuffer[0] = 0;
        }
    }

    if (!NameBuffer[0])
    {
        if (!GetModNameFromLoaderList(g_TargetMachine, 0,
                                      ImageBase, NameBuffer, BufferSize,
                                      TRUE))
        {
            // Buffer should be big enough for this simple name.
            DBG_ASSERT(BufferSize >= 32);
            sprintf(NameBuffer, "image%p", (PVOID)(ULONG_PTR)ImageBase);
        }
    }
    else
    {
        // If the name given doesn't have a full path try
        // and locate a full path in the loader list.
        if ((((NameBuffer[0] < 'a' || NameBuffer[0] > 'z') &&
              (NameBuffer[0] < 'A' || NameBuffer[0] > 'Z')) ||
             NameBuffer[1] != ':') &&
            (NameBuffer[0] != '\\' || NameBuffer[1] != '\\'))
        {
            GetModNameFromLoaderList(g_TargetMachine, 0,
                                     ImageBase, NameBuffer, BufferSize,
                                     TRUE);
        }
    }
}

//----------------------------------------------------------------------------
//
// ConnLiveKernelTargetInfo::WaitForEvent.
//
//----------------------------------------------------------------------------

HRESULT
ConnLiveKernelTargetInfo::WaitForEvent(ULONG Flags, ULONG Timeout)
{
    HRESULT Status;
    ULONG EventStatus;
    NTSTATUS NtStatus;
    ULONG ContinueStatus;
    BOOL SwitchedProcessors;

    // Timeouts can't easily be supported at the moment and
    // aren't really necessary.
    if (Timeout != INFINITE)
    {
        return E_NOTIMPL;
    }

    Status = PrepareForWait(Flags, &ContinueStatus);
    if ((g_EngStatus & ENG_STATUS_WAITING) == 0)
    {
        return Status;
    }

    EventOut("> Executing\n");

    for (;;)
    {
        EventOut(">> Waiting\n");

        SwitchedProcessors = FALSE;

        // Don't process deferred work if this is
        // just a processor switch.
        if (g_CmdState != 's')
        {
            ProcessDeferredWork(&ContinueStatus);
        }

        if (g_EventProcessSysId)
        {
            EventOut(">> Continue with %X\n", ContinueStatus);

            if (g_CmdState == 's')
            {
                // This can either be a real processor switch or
                // a rewait for state change.  Check the switch
                // processor to be sure.
                if (g_SwitchProcessor)
                {
                    DbgKdSwitchActiveProcessor(g_SwitchProcessor - 1);
                    g_SwitchProcessor = 0;
                    SwitchedProcessors = TRUE;
                }
            }
            else
            {
                if (g_EngDefer & ENG_DEFER_UPDATE_CONTROL_SET)
                {
                    NtStatus = DbgKdContinue2(ContinueStatus, g_ControlSet);
                    g_EngDefer &= ~ENG_DEFER_UPDATE_CONTROL_SET;
                }
                else
                {
                    NtStatus = DbgKdContinue(ContinueStatus);
                }
                if (!NT_SUCCESS(NtStatus))
                {
                    ErrOut("DbgKdContinue failed with status %X\n", NtStatus);
                    Status = HRESULT_FROM_NT(NtStatus);
                    goto Exit;
                }
            }
        }

        DiscardLastEvent();

        if (!IS_MACHINE_SET() &&
            (g_EngOptions & DEBUG_ENGOPT_INITIAL_BREAK) &&
            IS_CONN_KERNEL_TARGET())
        {
            // Ask for a breakin to be sent once the
            // code gets into resync.
            g_DbgKdTransport->m_SyncBreakIn = TRUE;
        }

        // When waiting for confirmation of a processor switch don't
        // yield the engine lock in order to prevent other clients
        // from trying to do things with the target while it's
        // switching.
        NtStatus = DbgKdWaitStateChange(&g_StateChange, g_StateChangeBuffer,
                                        sizeof(g_StateChangeBuffer) - 2,
                                        !SwitchedProcessors);
        if (!NT_SUCCESS(NtStatus))
        {
            ErrOut("DbgKdWaitStateChange failed: %08lx\n", NtStatus);
            Status = HRESULT_FROM_NT(NtStatus);
            goto Exit;
        }

        EventOut(">>> State change event %X, proc %d of %d\n",
                 g_StateChange.NewState, g_StateChange.Processor,
                 g_StateChange.NumberProcessors);

        g_EngStatus |= ENG_STATUS_STATE_CHANGED;

        if (!IS_MACHINE_SET())
        {
            dprintf("Kernel Debugger connection established.%s\n",
                    (g_EngOptions & DEBUG_ENGOPT_INITIAL_BREAK) ?
                    "  (Initial Breakpoint requested)" : ""
                    );

            // Initial connection after a fresh boot may only report
            // a single processor as the others haven't started yet.
            g_TargetNumberProcessors = g_StateChange.NumberProcessors;

            Status = InitializeMachine(g_TargetMachineType);
            if (Status != S_OK)
            {
                ErrOut("Unable to initialize target machine information\n");
                goto Exit;
            }

            CreateKernelProcessAndThreads();

            g_EventProcessSysId = VIRTUAL_PROCESS_ID;
            g_EventThreadSysId = VIRTUAL_THREAD_ID(g_StateChange.Processor);
            FindEventProcessThread();

            //
            // Load kernel symbols.
            //

            VerifyKernelBase(TRUE);
            g_Target->OutputVersion();

            RemoveAllKernelBreakpoints();
        }
        else
        {
            // Initial connection after a fresh boot may only report
            // a single processor as the others haven't started yet.
            // Pick up any additional processors.
            if (g_StateChange.NumberProcessors > g_TargetNumberProcessors)
            {
                AddKernelThreads(g_TargetNumberProcessors,
                                 g_StateChange.NumberProcessors -
                                 g_TargetNumberProcessors);
                g_TargetNumberProcessors = g_StateChange.NumberProcessors;
            }

            g_EventProcessSysId = VIRTUAL_PROCESS_ID;
            g_EventThreadSysId = VIRTUAL_THREAD_ID(g_StateChange.Processor);
            FindEventProcessThread();
        }

        g_EventPc = g_StateChange.ProgramCounter;
        g_ControlReport = &g_StateChange.AnyControlReport;
        g_StateChangeData = g_StateChangeBuffer;
        if (g_EventThread)
        {
            g_EventThread->DataOffset = g_StateChange.Thread;
        }

        EventStatus = ProcessStateChange(&g_StateChange, g_StateChangeData);

        EventOut(">>> StateChange event status %X\n", EventStatus);

        if (EventStatus == DEBUG_STATUS_NO_DEBUGGEE)
        {
            // Machine has rebooted or something else
            // which breaks the connection.  Forget the
            // connection and go back to waiting.
            ContinueStatus = DBG_CONTINUE;
        }
        else if (EventStatus == DEBUG_STATUS_BREAK ||
                 SwitchedProcessors)
        {
            // If the event handlers requested a break return
            // to the caller.  This path is also taken
            // when switching processors to guarantee that
            // the target doesn't start running when the
            // user just wanted a processor switch.
            Status = S_OK;
            goto Exit;
        }
        else
        {
            // We're resuming execution so reverse any
            // command preparation that may have occurred
            // while processing the event.
            if ((Status = PrepareForExecution(EventStatus)) != S_OK)
            {
                goto Exit;
            }

            ContinueStatus = EventStatusToContinue(EventStatus);
        }
    }

 Exit:
    g_EngStatus &= ~ENG_STATUS_WAITING;

    // Control is passing back to the caller so the engine must
    // be ready for command processing.
    PrepareForCalls(0);

    // If we did switch processors automatically
    // update the page directory for the new processor.
    if (SwitchedProcessors)
    {
        if (g_TargetMachine->SetDefaultPageDirectories(PAGE_DIR_ALL) != S_OK)
        {
            WarnOut("WARNING: Unable to reset page directories\n");
        }
    }

    EventOut("> Wait returning %X\n", Status);
    return Status;
}

DWORD64
GetKernelModuleBase(
    ULONG64 Address
    )
{
    LIST_ENTRY64            List64;
    ULONG64                 Next64;
    ULONG64                 ListHead;
    NTSTATUS                Status;
    KLDR_DATA_TABLE_ENTRY64 DataTableBuffer;

    if ((ListHead = KdDebuggerData.PsLoadedModuleList) == 0)
    {
        return 0;
    }

    if (g_Target->ReadListEntry(g_TargetMachine,
                                KdDebuggerData.PsLoadedModuleList,
                                &List64) != S_OK)
    {
        return 0;
    }

    if ((Next64 = List64.Flink) == 0)
    {
        return 0;
    }

    while (Next64 != ListHead)
    {
        if (g_Target->ReadLoaderEntry(g_TargetMachine,
                                      Next64, &DataTableBuffer) != S_OK)
        {
            break;
        }
        Next64 = DataTableBuffer.InLoadOrderLinks.Flink;

        if ((Address >= (ULONG64)DataTableBuffer.DllBase) &&
            (Address <  (ULONG64)DataTableBuffer.DllBase +
             DataTableBuffer.SizeOfImage) )
        {
            return (DWORD64)DataTableBuffer.DllBase;
        }
    }

    return 0;
}

HRESULT
LoadKdDataBlock(
    BOOL NotLive
    )

/*++

Routine Description:

    This routine get the kernel's debugger data block.

Arguments:

    UseSymbol - Instread of reading the information over the wire, use the
                symbol information to get the data.
                This is less reliable, but is necessary for crash dumps.

--*/
{
    HRESULT Status;
    LIST_ENTRY64 List64;
    ULONG64 DataList;
    ULONG Result;
    ULONG Size = 0;
    KDDEBUGGER_DATA32 LocalData32;
    KDDEBUGGER_DATA64 LocalData64;

    g_TargetBuildLabName[0] = 0;

    if (NotLive)
    {
        if (!g_KdDebuggerDataBlock)
        {
            if ( (GetOffsetFromSym( "nt!KdDebuggerDataBlock",
                                    (PULONG64) &List64, NULL)) &&
                  (List64.Flink) )
            {
                g_KdDebuggerDataBlock = List64.Flink;
            }
            else
            {
                if (g_SystemVersion > NT_SVER_NT4)
                {
                    // Only print an error for win2k and above to avoid
                    // error output in "normal" circumstances.

                    ErrOut("KdDebuggerDataBlock not available !\n");
                }
                return E_FAIL;
            }
        }
    }
    else
    {
        if (!g_KdVersion.DebuggerDataList)
        {
            // This is always the case in early loader situations
            // so suppress duplicate error messages.
            if ((g_EngErr & ENG_ERR_DEBUGGER_DATA) == 0)
            {
                ErrOut("Debugger data list address is NULL\n");
            }
            return E_FAIL;
        }
        if ((Status = g_Target->ReadListEntry(g_TargetMachine,
                                              g_KdVersion.DebuggerDataList,
                                              &List64)) != S_OK)
        {
            ErrOut("Unable to get address of debugger data list\n");
            return Status;
        }

        g_KdDebuggerDataBlock = List64.Flink;
    }

    //
    // Get the Size of the KDDEBUGGER_DATA block
    //

    if (DbgKdApi64)
    {
        DBGKD_DEBUG_DATA_HEADER64 Header;
        Status = g_Target->ReadVirtual(g_KdDebuggerDataBlock, &Header,
                                       sizeof(Header), &Result);
        if (Status == S_OK && Result == sizeof(Header))
        {
            Size = Header.Size;
        }
    }
    else
    {
        DBGKD_DEBUG_DATA_HEADER32 Header;
        Status = g_Target->ReadVirtual(g_KdDebuggerDataBlock, &Header,
                                       sizeof(Header), &Result);
        if (Status == S_OK && Result == sizeof(Header))
        {
            Size = Header.Size;
        }
    }

    //
    // Only read as much of the data block as we can hold in the debugger.
    //

    if (Size == 0)
    {
        // The data block is not present in older triage dumps
        // so don't give an error message for an expected
        // condition.
        if (!IS_KERNEL_TRIAGE_DUMP())
        {
            ErrOut("KdDebuggerDataBlock Size field is 0 - "
                   "can not read datablock further\n");
        }
        return E_FAIL;
    }

    if (Size > sizeof(KDDEBUGGER_DATA64))
    {
        Size = sizeof(KDDEBUGGER_DATA64);
    }

    //
    // Now read the data
    //

    if (DbgKdApi64)
    {
        Status = g_Target->ReadVirtual(g_KdDebuggerDataBlock, &LocalData64,
                                       Size, &Result);
        if (Status != S_OK || Result != Size)
        {
            ErrOut("KdDebuggerDataBlock Could not be read\n");
            return Status == S_OK ? E_FAIL : Status;
        }

        if (g_TargetMachine->m_Ptr64)
        {
            memcpy(&KdDebuggerData, &LocalData64, Size);
        }
        else
        {
            //
            // Sign extended for X86
            //

            //
            // Extend the header so it doesn't get whacked
            //
            ListEntry32To64((PLIST_ENTRY32)(&LocalData64.Header.List),
                            &(KdDebuggerData.Header.List));

            KdDebuggerData.Header.OwnerTag = LocalData64.Header.OwnerTag;
            KdDebuggerData.Header.Size     = LocalData64.Header.Size;

            //
            // Sign extend all the 32 bits values to 64 bit
            //

            #define UIP(f) if (FIELD_OFFSET(KDDEBUGGER_DATA64, f) < Size)  \
                           {                                               \
                               KdDebuggerData.f =                          \
                                   (ULONG64)(LONG64)(LONG)(LocalData64.f); \
                           }

            #define CP(f)  KdDebuggerData.f = LocalData64.f;


            UIP(KernBase);
            UIP(BreakpointWithStatus);
            UIP(SavedContext);
            CP(ThCallbackStack);
            CP(NextCallback);
            CP(FramePointer);
            CP(PaeEnabled);
            UIP(KiCallUserMode);
            UIP(KeUserCallbackDispatcher);
            UIP(PsLoadedModuleList);
            UIP(PsActiveProcessHead);
            UIP(PspCidTable);
            UIP(ExpSystemResourcesList);
            UIP(ExpPagedPoolDescriptor);
            UIP(ExpNumberOfPagedPools);
            UIP(KeTimeIncrement);
            UIP(KeBugCheckCallbackListHead);
            UIP(KiBugcheckData);
            UIP(IopErrorLogListHead);
            UIP(ObpRootDirectoryObject);
            UIP(ObpTypeObjectType);
            UIP(MmSystemCacheStart);
            UIP(MmSystemCacheEnd);
            UIP(MmSystemCacheWs);
            UIP(MmPfnDatabase);
            UIP(MmSystemPtesStart);
            UIP(MmSystemPtesEnd);
            UIP(MmSubsectionBase);
            UIP(MmNumberOfPagingFiles);
            UIP(MmLowestPhysicalPage);
            UIP(MmHighestPhysicalPage);
            UIP(MmNumberOfPhysicalPages);
            UIP(MmMaximumNonPagedPoolInBytes);
            UIP(MmNonPagedSystemStart);
            UIP(MmNonPagedPoolStart);
            UIP(MmNonPagedPoolEnd);
            UIP(MmPagedPoolStart);
            UIP(MmPagedPoolEnd);
            UIP(MmPagedPoolInformation);
            CP(MmPageSize);
            UIP(MmSizeOfPagedPoolInBytes);
            UIP(MmTotalCommitLimit);
            UIP(MmTotalCommittedPages);
            UIP(MmSharedCommit);
            UIP(MmDriverCommit);
            UIP(MmProcessCommit);
            UIP(MmPagedPoolCommit);
            UIP(MmExtendedCommit);
            UIP(MmZeroedPageListHead);
            UIP(MmFreePageListHead);
            UIP(MmStandbyPageListHead);
            UIP(MmModifiedPageListHead);
            UIP(MmModifiedNoWritePageListHead);
            UIP(MmAvailablePages);
            UIP(MmResidentAvailablePages);
            UIP(PoolTrackTable);
            UIP(NonPagedPoolDescriptor);
            UIP(MmHighestUserAddress);
            UIP(MmSystemRangeStart);
            UIP(MmUserProbeAddress);
            UIP(KdPrintCircularBuffer);
            UIP(KdPrintCircularBufferEnd);
            UIP(KdPrintWritePointer);
            UIP(KdPrintRolloverCount);
            UIP(MmLoadedUserImageList);

            // NT 5.1 additions

            UIP(NtBuildLab);
            UIP(KiNormalSystemCall);

            // NT 5.0 QFE additions

            UIP(KiProcessorBlock);
            UIP(MmUnloadedDrivers);
            UIP(MmLastUnloadedDriver);
            UIP(MmTriageActionTaken);
            UIP(MmSpecialPoolTag);
            UIP(KernelVerifier);
            UIP(MmVerifierData);
            UIP(MmAllocatedNonPagedPool);
            UIP(MmPeakCommitment);
            UIP(MmTotalCommitLimitMaximum);
            UIP(CmNtCSDVersion);

            // NT 5.1 additions

            UIP(MmPhysicalMemoryBlock);
            UIP(MmSessionBase);
            UIP(MmSessionSize);
            UIP(MmSystemParentTablePage);
        }
    }
    else
    {
        if (Size != sizeof(LocalData32))
        {
            ErrOut("Someone changed the definition of KDDEBUGGER_DATA32 - "
                   "please fix\n");
            return E_FAIL;
        }

        Status = g_Target->ReadVirtual(g_KdDebuggerDataBlock, &LocalData32,
                                       sizeof(LocalData32), &Result);
        if (Status != S_OK || Result != sizeof(LocalData32))
        {
            ErrOut("KdDebuggerDataBlock Could not be read\n");
            return Status == S_OK ? E_FAIL : Status;
        }
        else
        {
            //
            // Convert all the 32 bits fields to 64 bit
            //

            #undef UIP
            #undef CP
            #define UIP(f) KdDebuggerData.f = EXTEND64(LocalData32.f)
            #define CP(f) KdDebuggerData.f = (LocalData32.f)

            //
            // Extend the header so it doesn't get whacked
            //
            ListEntry32To64((PLIST_ENTRY32)(&LocalData32.Header.List),
                            &(KdDebuggerData.Header.List));

            KdDebuggerData.Header.OwnerTag = LocalData32.Header.OwnerTag;
            KdDebuggerData.Header.Size     = LocalData32.Header.Size;

            UIP(KernBase);
            UIP(BreakpointWithStatus);
            UIP(SavedContext);
            CP(ThCallbackStack);
            CP(NextCallback);
            CP(FramePointer);
            CP(PaeEnabled);
            UIP(KiCallUserMode);
            UIP(KeUserCallbackDispatcher);
            UIP(PsLoadedModuleList);
            UIP(PsActiveProcessHead);
            UIP(PspCidTable);
            UIP(ExpSystemResourcesList);
            UIP(ExpPagedPoolDescriptor);
            UIP(ExpNumberOfPagedPools);
            UIP(KeTimeIncrement);
            UIP(KeBugCheckCallbackListHead);
            UIP(KiBugcheckData);
            UIP(IopErrorLogListHead);
            UIP(ObpRootDirectoryObject);
            UIP(ObpTypeObjectType);
            UIP(MmSystemCacheStart);
            UIP(MmSystemCacheEnd);
            UIP(MmSystemCacheWs);
            UIP(MmPfnDatabase);
            UIP(MmSystemPtesStart);
            UIP(MmSystemPtesEnd);
            UIP(MmSubsectionBase);
            UIP(MmNumberOfPagingFiles);
            UIP(MmLowestPhysicalPage);
            UIP(MmHighestPhysicalPage);
            UIP(MmNumberOfPhysicalPages);
            UIP(MmMaximumNonPagedPoolInBytes);
            UIP(MmNonPagedSystemStart);
            UIP(MmNonPagedPoolStart);
            UIP(MmNonPagedPoolEnd);
            UIP(MmPagedPoolStart);
            UIP(MmPagedPoolEnd);
            UIP(MmPagedPoolInformation);
            CP(MmPageSize);
            UIP(MmSizeOfPagedPoolInBytes);
            UIP(MmTotalCommitLimit);
            UIP(MmTotalCommittedPages);
            UIP(MmSharedCommit);
            UIP(MmDriverCommit);
            UIP(MmProcessCommit);
            UIP(MmPagedPoolCommit);
            UIP(MmExtendedCommit);
            UIP(MmZeroedPageListHead);
            UIP(MmFreePageListHead);
            UIP(MmStandbyPageListHead);
            UIP(MmModifiedPageListHead);
            UIP(MmModifiedNoWritePageListHead);
            UIP(MmAvailablePages);
            UIP(MmResidentAvailablePages);
            UIP(PoolTrackTable);
            UIP(NonPagedPoolDescriptor);
            UIP(MmHighestUserAddress);
            UIP(MmSystemRangeStart);
            UIP(MmUserProbeAddress);
            UIP(KdPrintCircularBuffer);
            UIP(KdPrintCircularBufferEnd);
            UIP(KdPrintWritePointer);
            UIP(KdPrintRolloverCount);
            UIP(MmLoadedUserImageList);
            //
            // DO NOT ADD ANY FIELDS HERE
            // The 32 bit structure should not be changed
            //
        }
    }

    // Read build lab information if possible.
    Result = 0;
    if (KdDebuggerData.NtBuildLab != 0)
    {
        ULONG PreLen;

        strcpy(g_TargetBuildLabName, "Built by: ");
        PreLen = strlen(g_TargetBuildLabName);
        if (g_Target->ReadVirtual(KdDebuggerData.NtBuildLab,
                                  g_TargetBuildLabName + PreLen,
                                  sizeof(g_TargetBuildLabName) - PreLen - 1,
                                  &Result) == S_OK &&
            Result >= 2)
        {
            Result += PreLen;
        }
    }
    DBG_ASSERT(Result < sizeof(g_TargetBuildLabName));
    g_TargetBuildLabName[Result] = 0;

    //
    // Reset specific fields base on the build lab names
    // NOTE: lab names can be of different cases, so you must do case
    // insensitive compares.
    //

    char BuildLabName[272];

    strcpy(BuildLabName, g_TargetBuildLabName);
    _strlwr(BuildLabName);
    if (strstr(BuildLabName, "lab01"))
    {
        if ((g_TargetBuildNumber > 2405)                     &&
            (g_TargetMachineType == IMAGE_FILE_MACHINE_I386))
        {
            g_TargetMachine->m_OffsetKThreadNextProcessor =
                X86_NT51_KTHREAD_NEXTPROCESSOR_OFFSET;
        }
    }

    //
    // Sanity check and Debug output.
    //

    if (KdDebuggerData.Header.OwnerTag != KDBG_TAG)
    {
        dprintf("\nKdDebuggerData.Header.OwnerTag is wrong !!!\n");
    }

    KdOut("LoadKdDataBlock %08lx\n", Status);
    KdOut("KernBase                   %s\n",
          FormatAddr64(KdDebuggerData.KernBase));
    KdOut("BreakpointWithStatus       %s\n",
          FormatAddr64(KdDebuggerData.BreakpointWithStatus));
    KdOut("SavedContext               %s\n",
          FormatAddr64(KdDebuggerData.SavedContext));
    KdOut("ThCallbackStack            %08lx\n",
          KdDebuggerData.ThCallbackStack);
    KdOut("NextCallback               %08lx\n",
          KdDebuggerData.NextCallback);
    KdOut("FramePointer               %08lx\n",
          KdDebuggerData.FramePointer);
    KdOut("PaeEnabled                 %08lx\n",
          KdDebuggerData.PaeEnabled);
    KdOut("KiCallUserMode             %s\n",
          FormatAddr64(KdDebuggerData.KiCallUserMode));
    KdOut("KeUserCallbackDispatcher   %s\n",
          FormatAddr64(KdDebuggerData.KeUserCallbackDispatcher));
    KdOut("PsLoadedModuleList         %s\n",
          FormatAddr64(KdDebuggerData.PsLoadedModuleList));
    KdOut("PsActiveProcessHead        %s\n",
          FormatAddr64(KdDebuggerData.PsActiveProcessHead));
    KdOut("MmPageSize                 %s\n",
          FormatAddr64(KdDebuggerData.MmPageSize));
    KdOut("MmLoadedUserImageList      %s\n",
          FormatAddr64(KdDebuggerData.MmLoadedUserImageList));
    KdOut("MmSystemRangeStart         %s\n",
          FormatAddr64(KdDebuggerData.MmSystemRangeStart));
    KdOut("KiProcessorBlock           %s\n",
          FormatAddr64(KdDebuggerData.KiProcessorBlock));

    return Status;
}

BOOL
VerifyKernelBase (
    IN BOOL  LoadImage
    )
{
    PDEBUG_IMAGE_INFO p;

    //
    // User mode dumps have no kernel information.
    //

    if (IS_USER_TARGET())
    {
        return FALSE;
    }

    //
    // Ask host for version information
    //

    if (!IS_DUMP_TARGET())
    {
        //
        // Force load of KD data block
        //

        if (g_SystemVersion <= NT_SVER_NT4)
        {
            KdDebuggerData.PsLoadedModuleList =
                EXTEND64(g_KdVersion.PsLoadedModuleList);
            KdDebuggerData.KernBase = g_KdVersion.KernBase;
        }
        else
        {
            if (LoadKdDataBlock(FALSE) != STATUS_SUCCESS)
            {
                goto VerifyError;
            }

            //
            // The version and KdDebuggerData blocks should agree on
            // the version !
            //

            if ((g_KdVersion.KernBase != KdDebuggerData.KernBase)  ||
                (g_KdVersion.PsLoadedModuleList !=
                 KdDebuggerData.PsLoadedModuleList))
            {
                ErrOut("Debugger can not determine kernel base address\n");
            }
        }
    }

    if (LoadImage)
    {
        //
        // Verify only one kernel image loaded & it's at the correct base
        // For crashdump we may not have the KernBase at this point.
        //

        for (p = g_ProcessHead->ImageHead;
             p && KdDebuggerData.KernBase;
             p = p->Next)
        {
            if (p->BaseOfImage == KdDebuggerData.KernBase)
            {
                //
                // Already loaded with current base address
                //

                DelImageByBase(g_CurrentProcess, p->BaseOfImage);
                break;
            }
        }

        //
        // If acceptable kernel image was not found load one now
        //
        // Wow ! possible recursive call to bangReload - that's OK though :-)
        // ... as long as we only call with "NT"
        //

        if (g_Target->Reload(KERNEL_MODULE_NAME) == E_INVALIDARG)
        {
            // The most likely cause of this is missing paths.
            // We don't necessarily need a path to load
            // the kernel, so try again and ignore path problems.
            g_Target->Reload("-P "KERNEL_MODULE_NAME);
        }
    }

    //
    // After the kernel mode symbols are loaded, we can now try to load
    // the DataBlock from the dump file.
    //

    if (IS_DUMP_TARGET() &&
        (!IS_KERNEL_TRIAGE_DUMP() || g_TriageDumpHasDebuggerData))
    {
        LoadKdDataBlock(TRUE);
    }

    if (g_TargetMachineType == IMAGE_FILE_MACHINE_IA64)
    {
        //
        // Try to determine the kernel base virtual mapping address
        // for IA64.  This should be done as early as possible
        // to enable later virtual translations to work.
        //

        if (!IS_KERNEL_TRIAGE_DUMP())
        {
            if (!KdDebuggerData.MmSystemParentTablePage)
            {
                GetOffsetFromSym("nt!MmSystemParentTablePage",
                                 &KdDebuggerData.MmSystemParentTablePage,
                                 NULL);
            }

            if (KdDebuggerData.MmSystemParentTablePage)
            {
                ADDR Addr;
                ULONG64 SysPtp;

                ADDRFLAT(&Addr, KdDebuggerData.MmSystemParentTablePage);
                if (GetMemQword(&Addr, &SysPtp))
                {
                    g_Ia64Machine.
                        SetKernelPageDirectory(SysPtp << IA64_VALID_PFN_SHIFT);
                }
            }
        }

        //
        // Get the system call address from the debugger data block
        // Added around build 2204.
        // Default to symbols otherwise.
        //

        g_SystemCallVirtualAddress = 0;

        if (KdDebuggerData.KiNormalSystemCall)
        {
            g_Target->ReadPointer(g_TargetMachine,
                                  KdDebuggerData.KiNormalSystemCall,
                                  &g_SystemCallVirtualAddress);
        }

        if (!g_SystemCallVirtualAddress)
        {
            g_SystemCallVirtualAddress =
                ExtGetExpression( "nt!KiNormalSystemCall" );
        }

        if (!g_SystemCallVirtualAddress)
        {
            g_SystemCallVirtualAddress =
                ExtGetExpression( "nt!.KiNormalSystemCall" );
        }

        if (!g_SystemCallVirtualAddress)
        {
            WarnOut("Could not get KiNormalSystemCall address\n");
        }
    }

    //
    // Now that we have symbols and a data block try to
    // get CmNtCSDVersion, first from the data block and
    // then from the symbols if necessary.
    //
    // If we didn't get unloaded driver information try to
    // get it from symbols.
    //
    //

    if (!IS_KERNEL_TRIAGE_DUMP())
    {
        if (!KdDebuggerData.CmNtCSDVersion)
        {
            GetOffsetFromSym("nt!CmNtCSDVersion",
                             &KdDebuggerData.CmNtCSDVersion,
                             NULL);
        }

        if (KdDebuggerData.CmNtCSDVersion)
        {
            ADDR Addr;
            ULONG CmNtCSDVersion;
            
            ADDRFLAT(&Addr, KdDebuggerData.CmNtCSDVersion);
            if (GetMemDword(&Addr, &CmNtCSDVersion))
            {
                SetTargetNtCsdVersion(CmNtCSDVersion);
            }
        }

        if (KdDebuggerData.MmUnloadedDrivers == 0)
        {
            GetOffsetFromSym("nt!MmUnloadedDrivers",
                             &KdDebuggerData.MmUnloadedDrivers,
                             NULL);
        }

        if (KdDebuggerData.MmLastUnloadedDriver == 0)
        {
            GetOffsetFromSym("nt!MmLastUnloadedDriver",
                             &KdDebuggerData.MmLastUnloadedDriver,
                             NULL);
        }


        if (KdDebuggerData.KiProcessorBlock == 0)
        {
            GetOffsetFromSym("nt!KiProcessorBlock",
                             &KdDebuggerData.KiProcessorBlock,
                             NULL);
        }

        if (KdDebuggerData.MmPhysicalMemoryBlock == 0)
        {
            GetOffsetFromSym("nt!MmPhysicalMemoryBlock",
                             &KdDebuggerData.MmPhysicalMemoryBlock,
                             NULL);
        }
    }

    //
    // Try to get the start of system memory.
    // This may be zero because we are looking at an NT 4 system, so try
    // looking it up using symbols.
    //

    if (!KdDebuggerData.MmSystemRangeStart)
    {
        GetOffsetFromSym("nt!MmSystemRangeStart",
                         &KdDebuggerData.MmSystemRangeStart,
                         NULL);
    }

    if (KdDebuggerData.MmSystemRangeStart)
    {
        g_Target->ReadPointer(g_TargetMachine,
                              KdDebuggerData.MmSystemRangeStart,
                              &g_SystemRangeStart);
    }

    //
    // If we did not have symbols, at least pick a default value.
    //

    if (!g_SystemRangeStart)
    {
        g_SystemRangeStart = 0xFFFFFFFF80000000;
    }

    if (KdDebuggerData.KernBase < g_SystemRangeStart)
    {
        ErrOut("KdDebuggerData.KernBase < g_SystemRangeStart\n");
    }

    return TRUE;

VerifyError:
    // This is always the case in early loader situations
    // so suppress duplicate error messages.
    if ((g_EngErr & ENG_ERR_DEBUGGER_DATA) == 0)
    {
        WarnOut("Kernel base address could not be determined.  "
                "Please try to reconnect with .reload\n");
        g_EngErr |= ENG_ERR_DEBUGGER_DATA;
    }
    return FALSE;
}

#define EXCEPTION_CODE StateChange->u.Exception.ExceptionRecord.ExceptionCode
#define FIRST_CHANCE   StateChange->u.Exception.FirstChance

ULONG
ProcessStateChange(PDBGKD_ANY_WAIT_STATE_CHANGE StateChange,
                   PCHAR StateChangeData)
{
    ULONG EventStatus;

    //
    // If the reported instruction stream contained breakpoints
    // the kernel automatically removed them.  We need to
    // ensure that breakpoints get reinserted properly if
    // that's the case.
    //

    ULONG Count;

    switch(g_TargetMachineType)
    {
    case IMAGE_FILE_MACHINE_IA64:
        Count = g_ControlReport->IA64ControlReport.InstructionCount;
        break;
    case IMAGE_FILE_MACHINE_ALPHA:
    case IMAGE_FILE_MACHINE_AXP64:
        Count = g_ControlReport->AlphaControlReport.InstructionCount;
        break;
    case IMAGE_FILE_MACHINE_I386:
        Count = g_ControlReport->X86ControlReport.InstructionCount;
        break;
    case IMAGE_FILE_MACHINE_AMD64:
        Count = g_ControlReport->Amd64ControlReport.InstructionCount;
        break;
    }

    if (CheckBreakpointInsertedInRange(g_ProcessHead,
                                       g_EventPc, g_EventPc + Count - 1))
    {
        SuspendExecution();
        RemoveBreakpoints();
    }

    if (StateChange->NewState == DbgKdExceptionStateChange)
    {
        //
        // Read the system range start address from the target system.
        //

        if (g_SystemRangeStart == 0)
        {
            VerifyKernelBase(FALSE);
        }

        EventOut("Exception %X at %p\n", EXCEPTION_CODE, g_EventPc);

        if (EXCEPTION_CODE == STATUS_BREAKPOINT ||
            EXCEPTION_CODE == STATUS_SINGLE_STEP ||
            EXCEPTION_CODE == STATUS_WX86_BREAKPOINT ||
            EXCEPTION_CODE == STATUS_WX86_SINGLE_STEP)
        {
            EventStatus = ProcessBreakpointOrStepException
                (&StateChange->u.Exception.ExceptionRecord,
                 StateChange->u.Exception.FirstChance);
        }
        else if (EXCEPTION_CODE == STATUS_WAKE_SYSTEM_DEBUGGER)
        {
            // The target has requested that the debugger
            // become active so just break in.
            EventStatus = DEBUG_STATUS_BREAK;
        }
        else
        {
            EventStatus =
                NotifyExceptionEvent(&StateChange->u.Exception.ExceptionRecord,
                                     StateChange->u.Exception.FirstChance,
                                     FALSE);
        }
    }
    else if (StateChange->NewState == DbgKdLoadSymbolsStateChange)
    {
        if (StateChange->u.LoadSymbols.UnloadSymbols)
        {
            if (StateChange->u.LoadSymbols.PathNameLength == 0 &&
                StateChange->u.LoadSymbols.ProcessId == 0)
            {
                if (StateChange->u.LoadSymbols.BaseOfDll == (ULONG64)KD_REBOOT ||
                    StateChange->u.LoadSymbols.BaseOfDll == (ULONG64)KD_HIBERNATE)
                {
                    DbgKdContinue(DBG_CONTINUE);
                    ResetConnection(StateChange->u.LoadSymbols.BaseOfDll ==
                                    KD_REBOOT ? DEBUG_SESSION_REBOOT :
                                    DEBUG_SESSION_HIBERNATE);
                    EventStatus = DEBUG_STATUS_NO_DEBUGGEE;
                }
                else
                {
                    ErrOut("Invalid module unload state change\n");
                    EventStatus = DEBUG_STATUS_IGNORE_EVENT;
                }
            }
            else
            {
                EventStatus = NotifyUnloadModuleEvent
                    (StateChangeData, StateChange->u.LoadSymbols.BaseOfDll);
            }
        }
        else
        {
            PDEBUG_IMAGE_INFO pImage;
            CHAR fname[_MAX_FNAME];
            CHAR ext[_MAX_EXT];
            CHAR ImageName[256];
            CHAR ModName[256];
            LPSTR pModName = ModName;
            LPSTR p;

            ModName[0] = '\0';
            _splitpath( StateChangeData, NULL, NULL, fname, ext );
            sprintf( ImageName, "%s%s", fname, ext );
            if (_stricmp(ext, ".sys") == 0)
            {
                pImage = g_EventProcess ? g_EventProcess->ImageHead : NULL;
                while (pImage)
                {
                    if (_stricmp(ImageName, pImage->ImagePath) == 0)
                    {
                        ModName[0] = 'c';
                        strcpy( &ModName[1], ImageName );
                        p = strchr( ModName, '.' );
                        if (p)
                        {
                            *p = '\0';
                        }

                        ModName[8] = '\0';
                        break;
                    }

                    pImage = pImage->Next;
                }
            }
            else if (StateChange->u.LoadSymbols.BaseOfDll ==
                     KdDebuggerData.KernBase)
            {
                //
                // Recognize the kernel module.
                //
                pModName = KERNEL_MODULE_NAME;
            }

            EventStatus = NotifyLoadModuleEvent(
                0, StateChange->u.LoadSymbols.BaseOfDll,
                StateChange->u.LoadSymbols.SizeOfImage,
                *pModName ? pModName : NULL, ImageName,
                StateChange->u.LoadSymbols.CheckSum, 0);
        }
    }
    else if (StateChange->NewState == DbgKdCommandStringStateChange)
    {
        PSTR Command;
        
        //
        // The state change data has two strings one after
        // the other.  The first is a name string identifying
        // the originator of the command.  The second is
        // the command itself.
        //

        Command = StateChangeData + strlen(StateChangeData) + 1;
        _snprintf(g_LastEventDesc, sizeof(g_LastEventDesc) - 1,
                  "%.48s command: '%.192s'",
                  StateChangeData, Command);
        EventStatus = ExecuteEventCommand(DEBUG_STATUS_NO_CHANGE, NULL,
                                          Command);

        // Break in if the command didn't explicitly continuation.
        if (EventStatus == DEBUG_STATUS_NO_CHANGE)
        {
            EventStatus = DEBUG_STATUS_BREAK;
        }
    }
    else
    {
        //
        // Invalid NewState in state change record.
        //
        ErrOut("\nUNEXPECTED STATE CHANGE %08lx\n\n",
               StateChange->NewState);

        EventStatus = DEBUG_STATUS_IGNORE_EVENT;
    }

    return EventStatus;
}

#undef EXCEPTION_CODE
#undef FIRST_CHANCE

void
ResetConnection(ULONG Reason)
{
    if (Reason == DEBUG_SESSION_REBOOT)
    {
        dprintf("Shutdown occurred...unloading all symbol tables.\n");
    }
    else
    {
        dprintf("Hibernate occurred\n");
    }

    DiscardMachine(Reason);
}

void
CreateKernelProcessAndThreads(void)
{
    g_EngNotify++;

    // Create the fake kernel process.
    g_EventProcessSysId = VIRTUAL_PROCESS_ID;
    g_EventThreadSysId = VIRTUAL_THREAD_ID(0);
    NotifyCreateProcessEvent(0, (ULONG64)VIRTUAL_PROCESS_HANDLE, 0, 0,
                             NULL, NULL, 0, 0,
                             (ULONG64)VIRTUAL_THREAD_HANDLE(0), 0, 0, 0,
                             DEBUG_PROCESS_ONLY_THIS_PROCESS, 0);

    // Create any remaining threads.
    AddKernelThreads(1, g_TargetNumberProcessors - 1);

    g_EngNotify--;

    // Don't leave event variables set as these
    // weren't true events.
    g_EventProcessSysId = 0;
    g_EventThreadSysId = 0;
    g_EventProcess = NULL;
    g_EventThread = NULL;
}

void
AddKernelThreads(ULONG Start, ULONG Count)
{
    g_EngNotify++;

    g_EventProcessSysId = VIRTUAL_PROCESS_ID;
    while (Count-- > 0)
    {
        g_EventThreadSysId = VIRTUAL_THREAD_ID(Start);
        NotifyCreateThreadEvent((ULONG64)VIRTUAL_THREAD_HANDLE(Start), 0,
                                0, 0);
        Start++;
    }

    g_EngNotify--;
}

//----------------------------------------------------------------------------
//
// LocalLiveKernelTargetInfo::WaitForEvent.
//
//----------------------------------------------------------------------------

HRESULT
LocalLiveKernelTargetInfo::WaitForEvent(ULONG Flags, ULONG Timeout)
{
    HRESULT Status;
    ULONG i;
    ULONG ContinueStatus;
    SYSTEM_INFO SystemInfo;

    if (g_EngStatus & ENG_STATUS_PROCESSES_ADDED)
    {
        // A wait has already been done.  Local kernels
        // can only generate a single event so further
        // waiting is not possible.
        return E_UNEXPECTED;
    }

    // Even though local kernels don't really wait the standard
    // preparation still needs to be done to set things
    // up and generate the usual callbacks.  The continuation
    // part of things is simply ignored.
    Status = PrepareForWait(Flags, &ContinueStatus);
    if (FAILED(Status))
    {
        return Status;
    }

    GetSystemInfo(&SystemInfo);
    g_TargetNumberProcessors = SystemInfo.dwNumberOfProcessors;

    g_Target->GetKdVersion();

    // This is the first wait.  Simulate any
    // necessary events such as process and thread
    // creations and image loads.

    Status = InitializeMachine(g_TargetMachineType);
    if (Status != S_OK)
    {
        ErrOut("Unable to initialize target machine information\n");
        return Status;
    }

    // Don't give real callbacks for processes/threads as
    // they're just faked in the kernel case.
    g_EngNotify++;

    CreateKernelProcessAndThreads();

    // Load kernel version information and symbols.
    VerifyKernelBase(TRUE);
    g_Target->OutputVersion();

    g_EventProcessSysId = VIRTUAL_PROCESS_ID;
    // Current process always starts at zero.
    g_EventThreadSysId = VIRTUAL_THREAD_ID(0);

    // Clear the global state change just in case somebody's
    // directly accessing it somewhere.
    ZeroMemory(&g_StateChange, sizeof(g_StateChange));
    g_StateChangeData = g_StateChangeBuffer;
    g_StateChangeBuffer[0] = 0;

    // Do not provide a control report; this will force
    // such information to come from context retrieval.
    g_ControlReport = NULL;

    // There isn't a current PC, let it be discovered.
    g_EventPc = 0;

    g_EngStatus |= ENG_STATUS_STATE_CHANGED;

    // The engine is now initialized so a real event
    // can be generated.
    g_EngNotify--;
    FindEventProcessThread();

    Status = S_OK;

    g_EngStatus &= ~ENG_STATUS_WAITING;

    // Control is passing back to the caller so the engine must
    // be ready for command processing.
    PrepareForCalls(0);
    EventOut("> Wait returning %X\n", Status);
    return Status;
}

//----------------------------------------------------------------------------
//
// ExdiLiveKernelTargetInfo::WaitForEvent.
//
//----------------------------------------------------------------------------

HRESULT
ExdiLiveKernelTargetInfo::WaitForEvent(ULONG Flags, ULONG Timeout)
{
    HRESULT Status;
    ULONG EventStatus;
    ULONG ContinueStatus;

    // eXDI deals with hardware exceptions, not software
    // exceptions, so there's no concept of handled/not-handled
    // and first/second-chance.
    Status = PrepareForWait(Flags, &ContinueStatus);
    if ((g_EngStatus & ENG_STATUS_WAITING) == 0)
    {
        return Status;
    }

    EventOut("> Executing\n");

    for (;;)
    {
        EventOut(">> Waiting\n");

        ProcessDeferredWork(&ContinueStatus);

        if (g_EventProcessSysId)
        {
            EventOut(">> Continue with %X\n", ContinueStatus);

            if (g_EngDefer & ENG_DEFER_HARDWARE_TRACING)
            {
                // Processor trace flag was set.  eXDI can change
                // the trace flag itself, though, so use the
                // official eXDI stepping methods rather than
                // rely on the trace flag.  This will result
                // in a single instruction execution, after
                // which the trace flag will be clear so
                // go ahead and clear the defer flag.
                Status = m_Server->DoSingleStep();
                if (Status == S_OK)
                {
                    g_EngDefer &= ~ENG_DEFER_HARDWARE_TRACING;
                }
            }
            else
            {
                Status = m_Server->Run();
            }
            if (Status != S_OK)
            {
                ErrOut("IeXdiServer::Run failed, 0x%X\n", Status);
                goto Exit;
            }
        }

        DiscardLastEvent();

        DWORD Cookie;

        if ((Status = m_Server->StartNotifyingRunChg(&m_RunChange,
                                                     &Cookie)) != S_OK)
        {
            ErrOut("IeXdiServer::StartNotifyingRunChg failed, 0x%X\n",
                   Status);
            goto Exit;
        }

        RUN_STATUS_TYPE RunStatus;

        if ((Status = m_Server->
             GetRunStatus(&RunStatus, &m_RunChange.m_HaltReason,
                          &m_RunChange.m_ExecAddress,
                          &m_RunChange.m_ExceptionCode)) != S_OK)
        {
            ErrOut("IeXdiServer::GetRunStatus failed, 0x%X\n",
                   Status);
            goto Exit;
        }

        DWORD WaitStatus;

        if (RunStatus == rsRunning)
        {
            SUSPEND_ENGINE();

            // We need to run a message pump so COM
            // can deliver calls properly.
            for (;;)
            {
                if (g_EngStatus & ENG_STATUS_EXIT_CURRENT_WAIT)
                {
                    WaitStatus = WAIT_FAILED;
                    SetLastError(ERROR_IO_PENDING);
                    break;
                }
                
                WaitStatus = MsgWaitForMultipleObjects(1, &m_RunChange.m_Event,
                                                       FALSE, Timeout,
                                                       QS_ALLEVENTS);
                if (WaitStatus == WAIT_OBJECT_0 + 1)
                {
                    MSG Msg;
                    
                    if (GetMessage(&Msg, NULL, 0, 0))
                    {
                        TranslateMessage(&Msg);
                        DispatchMessage(&Msg);
                    }
                }
                else
                {
                    // We either successfully waited, timed-out or failed.
                    // Break out to handle it.
                    break;
                }
            }

            RESUME_ENGINE();
        }
        else
        {
            WaitStatus = WAIT_OBJECT_0;
        }

        m_Server->StopNotifyingRunChg(Cookie);
        // Make sure we're not leaving the event set.
        ResetEvent(m_RunChange.m_Event);

        if (WaitStatus == WAIT_TIMEOUT)
        {
            Status = S_FALSE;
            goto Exit;
        }
        else if (WaitStatus != WAIT_OBJECT_0)
        {
            Status = WIN32_LAST_STATUS();
            ErrOut("WaitForSingleObject failed, 0x%X\n", Status);
            goto Exit;
        }

        EventOut(">>> RunChange halt reason %d\n",
                 m_RunChange.m_HaltReason);

        g_EngStatus |= ENG_STATUS_STATE_CHANGED;

        if (!IS_MACHINE_SET())
        {
            dprintf("Kernel Debugger connection established\n");

            g_TargetNumberProcessors = 1;

            // eXDI kernels are always treated as Win2K so
            // it's assumed it uses the 64-bit API.
            if (m_KdSupport == EXDI_KD_NONE)
            {
                DbgKdApi64 = TRUE;
                g_SystemVersion = NT_SVER_W2K;
            }
            
            g_Target->GetKdVersion();

            Status = InitializeMachine(m_ExpectedMachine);
            if (Status != S_OK)
            {
                ErrOut("Unable to initialize target machine information\n");
                goto Exit;
            }

            CreateKernelProcessAndThreads();

            g_EventProcessSysId = VIRTUAL_PROCESS_ID;
            g_EventThreadSysId = VIRTUAL_THREAD_ID(0);
            FindEventProcessThread();

            //
            // Load kernel symbols.
            //

            if (g_ActualSystemVersion > NT_SVER_START &&
                g_ActualSystemVersion < NT_SVER_END)
            {
                VerifyKernelBase(TRUE);
            }
            else
            {
                // Initialize some debugger data fields from known
                // information as there isn't a real data block.
                KdDebuggerData.MmPageSize = g_Machine->m_PageSize;

                if (g_TargetMachineType == IMAGE_FILE_MACHINE_AMD64)
                {
                    // AMD64 always operates in PAE mode.
                    KdDebuggerData.PaeEnabled = TRUE;
                }
            }
            
            g_Target->OutputVersion();
        }
        else
        {
            g_EventProcessSysId = VIRTUAL_PROCESS_ID;
            g_EventThreadSysId = VIRTUAL_THREAD_ID(0);
            FindEventProcessThread();
        }

        g_EventPc = m_RunChange.m_ExecAddress;
        g_ControlReport = NULL;
        g_StateChangeData = NULL;

        EventStatus = ProcessRunChange(m_RunChange.m_HaltReason,
                                       m_RunChange.m_ExceptionCode);

        EventOut(">>> RunChange event status %X\n", EventStatus);

        if (EventStatus == DEBUG_STATUS_NO_DEBUGGEE)
        {
            // Machine has rebooted or something else
            // which breaks the connection.  Forget the
            // connection and go back to waiting.
            ContinueStatus = DBG_CONTINUE;
        }
        else if (EventStatus == DEBUG_STATUS_BREAK)
        {
            // If the event handlers requested a break return
            // to the caller.
            Status = S_OK;
            goto Exit;
        }
        else
        {
            // We're resuming execution so reverse any
            // command preparation that may have occurred
            // while processing the event.
            if ((Status = PrepareForExecution(EventStatus)) != S_OK)
            {
                goto Exit;
            }

            ContinueStatus = EventStatusToContinue(EventStatus);
        }
    }

 Exit:
    g_EngStatus &= ~ENG_STATUS_WAITING;

    // Control is passing back to the caller so the engine must
    // be ready for command processing.
    PrepareForCalls(0);
    EventOut("> Wait returning %X\n", Status);
    return Status;
}

ULONG
ProcessRunChange(ULONG HaltReason, ULONG ExceptionCode)
{
    ULONG EventStatus;
    EXCEPTION_RECORD64 Record;

    switch(HaltReason)
    {
    case hrUser:
    case hrUnknown:
        // User requested break in.
        // Unknown breakin also seems to be the status at power-up.
        EventStatus = DEBUG_STATUS_BREAK;
        break;

    case hrException:
        // Fake an exception record.
        ZeroMemory(&Record, sizeof(Record));
        // The exceptions reported are hardware exceptions so
        // there's no easy mapping to NT exception codes.
        // Just report them as access violations.
        Record.ExceptionCode = STATUS_ACCESS_VIOLATION;
        Record.ExceptionAddress = g_EventPc;
        // Hardware exceptions are always severe so always
        // report them as second-chance.
        EventStatus = NotifyExceptionEvent(&Record, FALSE, FALSE);
        break;

    case hrBp:
        // Fake a breakpoint exception record.
        ZeroMemory(&Record, sizeof(Record));
        Record.ExceptionCode = STATUS_BREAKPOINT;
        Record.ExceptionAddress = g_EventPc;
        EventStatus = ProcessBreakpointOrStepException(&Record, TRUE);
        break;

    case hrStep:
        // Fake a single-step exception record.
        ZeroMemory(&Record, sizeof(Record));
        Record.ExceptionCode = STATUS_SINGLE_STEP;
        Record.ExceptionAddress = g_EventPc;
        EventStatus = ProcessBreakpointOrStepException(&Record, TRUE);
        break;

    default:
        ErrOut("Unknown HALT_REASON %d\n", HaltReason);
        EventStatus = DEBUG_STATUS_BREAK;
        break;
    }

    return EventStatus;
}

//----------------------------------------------------------------------------
//
// UserTargetInfo::WaitForEvent.
//
//----------------------------------------------------------------------------

void
SynthesizeWakeEvent(LPDEBUG_EVENT64 Event,
                    ULONG ProcessId, ULONG ThreadId)
{
    // Fake up an event.
    ZeroMemory(Event, sizeof(*Event));
    Event->dwDebugEventCode = EXCEPTION_DEBUG_EVENT;
    Event->dwProcessId = ProcessId;
    Event->dwThreadId = ThreadId;
    Event->u.Exception.ExceptionRecord.ExceptionCode =
        STATUS_WAKE_SYSTEM_DEBUGGER;
    Event->u.Exception.dwFirstChance = TRUE;
}

#define THREADS_ALLOC 256

HRESULT
CreateNonInvasiveProcessAndThreads(PUSER_DEBUG_SERVICES Services,
                                   ULONG ProcessId, ULONG Flags, ULONG Options,
                                   PULONG InitialThreadId)
{
    ULONG64 Process;
    PUSER_THREAD_INFO Threads, ThreadBuffer;
    ULONG ThreadsAlloc = 0;
    ULONG ThreadCount;
    HRESULT Status;

    //
    // Retrieve process and thread information.  This
    // requires a thread buffer of unknown size and
    // so involves a bit of trial and error.
    //

    for (;;)
    {
        ThreadsAlloc += THREADS_ALLOC;
        ThreadBuffer = new USER_THREAD_INFO[ThreadsAlloc];
        if (ThreadBuffer == NULL)
        {
            return E_OUTOFMEMORY;
        }

        if ((Status = Services->GetProcessInfo(ProcessId, &Process,
                                               ThreadBuffer, ThreadsAlloc,
                                               &ThreadCount)) != S_OK)
        {
            delete ThreadBuffer;
            return Status;
        }

        if (ThreadCount <= ThreadsAlloc)
        {
            break;
        }
    }

    //
    // Create the process and thread structures from
    // the retrieved data.
    //

    Threads = ThreadBuffer;
    
    g_EngNotify++;

    // Create the fake kernel process and initial thread.
    g_EventProcessSysId = ProcessId;
    g_EventThreadSysId = Threads->Id;
    *InitialThreadId = Threads->Id;
    NotifyCreateProcessEvent(0, Process, 0, 0, NULL, NULL, 0, 0,
                             Threads->Handle, 0, 0,
                             Flags | ENG_PROC_THREAD_CLOSE_HANDLE,
                             Options, ENG_PROC_THREAD_CLOSE_HANDLE);

    // Create any remaining threads.
    while (--ThreadCount > 0)
    {
        Threads++;
        g_EventThreadSysId = Threads->Id;
        NotifyCreateThreadEvent(Threads->Handle, 0, 0,
                                ENG_PROC_THREAD_CLOSE_HANDLE);
    }

    g_EngNotify--;

    delete ThreadBuffer;
    
    // Don't leave event variables set as these
    // weren't true events.
    g_EventProcessSysId = 0;
    g_EventThreadSysId = 0;
    g_EventProcess = NULL;
    g_EventThread = NULL;

    return S_OK;
}

HRESULT
ExamineActiveProcess(PUSER_DEBUG_SERVICES Services,
                     ULONG ProcessId, ULONG Flags, ULONG Options,
                     LPDEBUG_EVENT64 Event)
{
    HRESULT Status;
    ULONG InitialThreadId;
    
    if ((Status = CreateNonInvasiveProcessAndThreads
         (Services, ProcessId, Flags, Options, &InitialThreadId)) != S_OK)
    {
        ErrOut("Unable to examine process id %d, %s\n",
               ProcessId, FormatStatusCode(Status));
        return Status;
    }

    if (Flags & ENG_PROC_EXAMINED)
    {
        WarnOut("WARNING: Process %d is not attached as a debuggee\n",
                ProcessId);
        WarnOut("         The process can be examined but debug "
                "events will not be received\n");
    }

    SynthesizeWakeEvent(Event, ProcessId, InitialThreadId);
    
    return S_OK;
}

// When waiting for an attach we check process status relatively
// frequently.  The overall timeout limit is also hard-coded
// as we expect some sort of debug event to always be delivered
// quickly.
#define ATTACH_PENDING_TIMEOUT 100
#define ATTACH_PENDING_TIMEOUT_LIMIT 600

// When not waiting for an attach the wait only waits one second,
// then checks to see if things have changed in a way that
// affects the wait.  All timeouts are given in multiples of
// this interval.
#define DEFAULT_WAIT_TIMEOUT 1000

// A message is printed after this timeout interval to
// let the user know a break-in is pending.
#define PENDING_BREAK_IN_MESSAGE_TIMEOUT_LIMIT 3

HRESULT
UserTargetInfo::WaitForEvent(ULONG Flags, ULONG Timeout)
{
    DEBUG_EVENT64 Event;
    DWORD ContinueStatus;
    HRESULT Status;
    ULONG EventStatus;
    ULONG UseTimeout = Timeout;
    ULONG TimeoutCount = 0;
    ULONG EventUsed;
    ULONG ContinueDefer;
    PPENDING_PROCESS Pending;
    ULONG PendingFlags, PendingOptions;
    ULONG ExamineResumeProcId = 0;

    // Fail if there isn't a debuggee.
    if (!ANY_PROCESSES())
    {
        return E_UNEXPECTED;
    }

    Status = PrepareForWait(Flags, &ContinueStatus);
    
    if ((g_EngStatus & ENG_STATUS_WAITING) == 0)
    {
        return Status;
    }

    if (g_AllPendingFlags & ENG_PROC_ANY_ATTACH)
    {
        dprintf("*** wait with pending attach\n");
    }
    
    EventOut("> Executing\n");

    for (;;)
    {
        EventOut(">> Waiting\n");

        ProcessDeferredWork(&ContinueStatus);

        if (g_EngDefer & ENG_DEFER_CONTINUE_EVENT)
        {
            for (;;)
            {
                EventOut(">> Continue with %X\n", ContinueStatus);
                
                if ((Status = m_Services->
                     ContinueEvent(ContinueStatus)) == S_OK)
                {
                    break;
                }

                //
                // If we got an out of memory error, wait again
                //

                if (Status != E_OUTOFMEMORY)
                {
                    ErrOut("IUserDebugServices::ContinueEvent failed "
                           "with status 0x%X\n", Status);
                    goto Exit;
                }
            }
        }

        DiscardLastEvent();
        PendingFlags = 0;
        PendingOptions = DEBUG_PROCESS_ONLY_THIS_PROCESS;

        if (g_AllPendingFlags & ENG_PROC_ANY_ATTACH)
        {
            // If we're attaching noninvasively or reattaching
            // and still haven't done the work go ahead and do it now.
            if (g_AllPendingFlags & ENG_PROC_ANY_EXAMINE)
            {
                Pending = FindPendingProcessByFlags(ENG_PROC_ANY_EXAMINE);
                if (Pending == NULL)
                {
                    DBG_ASSERT(FALSE);
                    goto Exit;
                }
                
                if ((Status = ExamineActiveProcess
                     (m_Services, Pending->Id, Pending->Flags,
                      Pending->Options, &Event)) != S_OK)
                {
                    goto Exit;
                }

                // If we just started examining a process we
                // suspended all the threads during enumeration.
                // We need to resume them after the normal
                // SuspendExecution suspend to get the suspend
                // count back to normal.
                ExamineResumeProcId = Pending->Id;
                
                PendingFlags = Pending->Flags;
                PendingOptions = Pending->Options;
                RemovePendingProcess(Pending);
                EventUsed = sizeof(Event);
                // This event is not a real continuable event.
                ContinueDefer = 0;
                goto WaitDone;
            }
                
            // While waiting for an attach we need to periodically
            // check and see if the process has exited so we
            // need to force a reasonably small timeout.
            UseTimeout = min(Timeout, ATTACH_PENDING_TIMEOUT);
        }
        else
        {
            // We might be waiting on a break-in.  Keep timeouts moderate
            // to deal with apps hung with a lock that prevents
            // the break from happening.  The timeout is
            // still long enough so that no substantial amount
            // of CPU time is consumed.
            UseTimeout = min(Timeout, DEFAULT_WAIT_TIMEOUT);
        }

        SUSPEND_ENGINE();

        if (g_EngStatus & ENG_STATUS_EXIT_CURRENT_WAIT)
        {
            Status = E_PENDING;
        }
        else
        {
            Status = m_Services->
                WaitForEvent(UseTimeout, &Event, sizeof(Event), &EventUsed);
        }

        RESUME_ENGINE();

        ContinueDefer = ENG_DEFER_CONTINUE_EVENT;
        
    WaitDone:
        if (Status == S_OK)
        {
            if (EventUsed == sizeof(DEBUG_EVENT32))
            {
                DEBUG_EVENT32 Event32 = *(DEBUG_EVENT32*)&Event;
                DebugEvent32To64(&Event32, &Event);
            }
            else if (EventUsed != sizeof(DEBUG_EVENT64))
            {
                ErrOut("Event data corrupt\n");
                Status = E_FAIL;
                goto Exit;
            }

            g_EngDefer |= ContinueDefer;
        
            EventOut(">>> Debug event %u for %X.%X\n",
                     Event.dwDebugEventCode, Event.dwProcessId,
                     Event.dwThreadId);

            g_EventProcessSysId = Event.dwProcessId;
            g_EventThreadSysId = Event.dwThreadId;

            // Look up the process and thread infos in the cases
            // where they already exist.
            if (Event.dwDebugEventCode != CREATE_PROCESS_DEBUG_EVENT &&
                Event.dwDebugEventCode != CREATE_THREAD_DEBUG_EVENT)
            {
                FindEventProcessThread();
            }

            g_EngStatus |= ENG_STATUS_STATE_CHANGED;

            if (Event.dwDebugEventCode == CREATE_PROCESS_DEBUG_EVENT)
            {
                // If we're being notified of a new process take
                // out the pending record for the process.
                Pending = FindPendingProcessById(g_EventProcessSysId);
                if (Pending == NULL &&
                    (g_AllPendingFlags & ENG_PROC_SYSTEM))
                {
                    // Assume that this is the system process
                    // as we attached under a fake process ID so
                    // we can't check for a true match.
                    Pending = FindPendingProcessById(CSRSS_PROCESS_ID);
                }

                if (Pending != NULL)
                {
                    PendingFlags = Pending->Flags;
                    PendingOptions = Pending->Options;

                    if (Pending->Flags & ENG_PROC_ATTACHED)
                    {
                        VerbOut("*** attach succeeded\n");
                        UseTimeout = Timeout;

                        // If we're completing a full attach
                        // we are now a fully active debugger.
                        PendingFlags &= ~ENG_PROC_EXAMINED;
                        
                        // Expect a break-in.
                        g_EngStatus |= ENG_STATUS_PENDING_BREAK_IN;
                        TimeoutCount = 0;
                    }

                    RemovePendingProcess(Pending);
                }
            }

            if (!IS_MACHINE_SET())
            {
                ULONG Machine;
                
                if ((Status = m_Services->
                     GetTargetInfo(&Machine,
                                   &g_TargetNumberProcessors,
                                   &g_TargetPlatformId,
                                   &g_TargetBuildNumber,
                                   &g_TargetCheckedBuild,
                                   g_TargetServicePackString,
                                   sizeof(g_TargetServicePackString),
                                   g_TargetBuildLabName,
                                   sizeof(g_TargetBuildLabName))) != S_OK)
                {
                    ErrOut("Unable to retrieve target machine "
                           "information\n");
                    goto Exit;
                }

                SetTargetSystemVersionAndBuild(g_TargetBuildNumber,
                                               g_TargetPlatformId);
                DbgKdApi64 = g_SystemVersion > NT_SVER_NT4;

                if ((Status = InitializeMachine(Machine)) != S_OK)
                {
                    ErrOut("Unable to initialize target machine "
                           "information\n");
                    goto Exit;
                }
            }

            if (PendingFlags & ENG_PROC_ANY_EXAMINE)
            {
                // We're examining the process rather than
                // debugging it, so no module load events
                // are going to come through.  Reload from
                // the system module list.  This needs
                // to work even if there isn't a path.
                g_Target->Reload("-s -P");
            }

            if ((Event.dwDebugEventCode == CREATE_PROCESS_DEBUG_EVENT ||
                 Event.dwDebugEventCode == CREATE_THREAD_DEBUG_EVENT) &&
                (m_ServiceFlags & DBGSVC_CLOSE_PROC_THREAD_HANDLES))
            {
                PendingFlags |= ENG_PROC_THREAD_CLOSE_HANDLE;
            }

            EventStatus = ProcessDebugEvent(&Event,
                                            PendingFlags, PendingOptions);

            EventOut(">>> DebugEvent status %X\n", EventStatus);

            // If the event handlers requested a break return
            // to the caller.
            if (EventStatus == DEBUG_STATUS_BREAK)
            {
                Status = S_OK;
                goto Exit;
            }
            else
            {
                // We're resuming execution so reverse any
                // command preparation that may have occurred
                // while processing the event.
                // If we just started examining a process we
                // can resume things as it's OK to execute.
                if (ExamineResumeProcId)
                {
                    SuspendResumeThreads(FindProcessBySystemId
                                         (ExamineResumeProcId), FALSE, NULL);
                    ExamineResumeProcId = 0;
                }
                
                if ((Status = PrepareForExecution(EventStatus)) != S_OK)
                {
                    goto Exit;
                }

                ContinueStatus = EventStatusToContinue(EventStatus);
            }
        }
        else
        {
            if (Status == S_FALSE)
            {
                TimeoutCount++;
                
                if (g_AllPendingFlags & ENG_PROC_ATTACHED)
                {
                    VerifyPendingProcesses();
                    if (!ANY_PROCESSES())
                    {
                        Status = E_FAIL;
                        goto Exit;
                    }

                    if (TimeoutCount == ATTACH_PENDING_TIMEOUT_LIMIT)
                    {
                        // Assume that the process has some kind
                        // of lock that's preventing the attach
                        // from succeeding and just do a soft attach.
                        AddExamineToPendingAttach();
                        TimeoutCount = 0;
                    }
                }
                else if (g_EngStatus & ENG_STATUS_PENDING_BREAK_IN)
                {
                    if (TimeoutCount == PENDING_BREAK_IN_MESSAGE_TIMEOUT_LIMIT)
                    {
                        dprintf("Break-in sent, waiting %d seconds...\n",
                                (g_PendingBreakInTimeoutLimit *
                                 DEFAULT_WAIT_TIMEOUT) / 1000);
                    }
                    else if (TimeoutCount >= g_PendingBreakInTimeoutLimit)
                    {
                        // Assume that the process has some kind
                        // of lock that's preventing the break-in
                        // exception from coming through and
                        // just suspend to let the user look at things.
                        WarnOut("WARNING: Break-in timed out, suspending.\n");
                        WarnOut("         This is usually caused by another "
                                "thread holding the loader lock\n");
                        SynthesizeWakeEvent(&Event, g_ProcessHead->SystemId,
                                            g_ProcessHead->ThreadHead->
                                            SystemId);
                        EventUsed = sizeof(Event);
                        ContinueDefer = 0;
                        TimeoutCount = 0;
                        g_EngStatus &= ~ENG_STATUS_PENDING_BREAK_IN;
                        Status = S_OK;
                        goto WaitDone;
                    }
                }
                else if (Timeout != INFINITE &&
                         Timeout <= UseTimeout)
                {
                    Status = S_FALSE;
                    goto Exit;
                }
                
                if (Timeout != INFINITE)
                {
                    // Update overall timeout.  This
                    // isn't incredibly accurate but it
                    // doesn't really need to be.
                    Timeout -= UseTimeout;
                }

                // Loop back to waiting.
            }
            else if (Status == E_OUTOFMEMORY)
            {
                // If we got an out of memory error, wait again
            }
            else
            {
                ErrOut("IUserDebugServices::WaitForEvent failed "
                       "with status 0x%X\n", Status);
                goto Exit;
            }
        }
    }

 Exit:
    g_EngStatus &= ~ENG_STATUS_WAITING;

    // Control is passing back to the caller so the engine must
    // be ready for command processing.
    PrepareForCalls(0);

    // If we have an extra suspend count from examining resume it out now
    // that any normal suspends have been done and it's safe
    // to remove the excess suspend.
    if (ExamineResumeProcId)
    {
        SuspendResumeThreads(FindProcessBySystemId(ExamineResumeProcId),
                             FALSE, NULL);
    }
    
    EventOut("> Wait returning %X\n", Status);
    return Status;
}

/*** ProcessDebugEvent - main dispatch table
*
*   Purpose:
*       As debug events come in, they each have to be handled in a unique
*       manner.  This routine does all of the processing required for each
*       event.
*
*       Also this routine serves the callback mechanism for VDM debug events
*       using the VDMDBG.DLL apis (they require the ability of calling back
*       into the debugger).
*
*       Significant events include creation and termination of processes
*       and threads, and events such as breakpoints.
*
*       Data structures for processes and threads are created and
*       maintained for use by the program.
*
*************************************************************************/

ULONG
ProcessDebugEvent(DEBUG_EVENT64* Event,
                  ULONG PendingFlags, ULONG PendingOptions)
{
    ULONG EventStatus;
    PSTR ImagePath;
    CHAR NameBuffer[MAX_IMAGE_PATH];
    ULONG ModuleSize, CheckSum, TimeDateStamp;
    char ModuleName[MAX_MODULE];

    switch(Event->dwDebugEventCode)
    {
    case CREATE_PROCESS_DEBUG_EVENT:
        // We don't have a process yet but
        // getting the name can involve reading process
        // memory, which in some cases currently wants
        // g_CurrentProcess set.  Hack up a temporary
        // process with just the handle.
        PROCESS_INFO TempProcess;
        THREAD_INFO TempThread;
        memset(&TempProcess, 0, sizeof(TempProcess));
        memset(&TempThread, 0, sizeof(TempThread));
        TempProcess.FullHandle = Event->u.CreateProcessInfo.hProcess;
        TempProcess.Handle = (HANDLE)(ULONG_PTR)TempProcess.FullHandle;
        TempThread.Handle = Event->u.CreateProcessInfo.hThread;
        TempThread.Process = &TempProcess;
        g_CurrentProcess = &TempProcess;
        g_CurrentProcess->ThreadHead = &TempThread;
        g_CurrentProcess->CurrentThread = &TempThread;

        GetEventName(Event->u.CreateProcessInfo.hFile,
                     Event->u.CreateProcessInfo.lpBaseOfImage,
                     Event->u.CreateProcessInfo.lpImageName,
                     Event->u.CreateProcessInfo.fUnicode,
                     NameBuffer, sizeof(NameBuffer));

        GetHeaderInfo((ULONG64)Event->u.CreateProcessInfo.lpBaseOfImage,
                      &CheckSum, &TimeDateStamp, &ModuleSize);
        CreateModuleNameFromPath(NameBuffer, ModuleName);

        LoadWow64ExtsIfNeeded();

        // Clear the temporary process setting.
        g_CurrentProcess = NULL;
        
        EventStatus = NotifyCreateProcessEvent(
            (ULONG64)Event->u.CreateProcessInfo.hFile,
            (ULONG64)Event->u.CreateProcessInfo.hProcess,
            (ULONG64)Event->u.CreateProcessInfo.lpBaseOfImage,
            ModuleSize, ModuleName, NameBuffer, CheckSum, TimeDateStamp,
            (ULONG64)Event->u.CreateProcessInfo.hThread,
            (ULONG64)Event->u.CreateProcessInfo.lpThreadLocalBase,
            (ULONG64)Event->u.CreateProcessInfo.lpStartAddress,
            PendingFlags, PendingOptions,
            (PendingFlags & ENG_PROC_THREAD_CLOSE_HANDLE) ?
            ENG_PROC_THREAD_CLOSE_HANDLE : 0);

        break;

    case EXIT_PROCESS_DEBUG_EVENT:
        if (g_EventProcess == NULL)
        {
            // Assume that this unmatched exit process event is a leftover
            // from a previous restart and just ignore it.
            WarnOut("Ignoring unknown process exit for %X\n",
                    g_EventProcessSysId);
            EventStatus = DEBUG_STATUS_IGNORE_EVENT;
        }
        else
        {
            EventStatus =
                NotifyExitProcessEvent(Event->u.ExitProcess.dwExitCode);
        }
        break;

    case CREATE_THREAD_DEBUG_EVENT:
        EventStatus = NotifyCreateThreadEvent(
            (ULONG64)Event->u.CreateThread.hThread,
            (ULONG64)Event->u.CreateThread.lpThreadLocalBase,
            (ULONG64)Event->u.CreateThread.lpStartAddress,
            PendingFlags);
        break;

    case EXIT_THREAD_DEBUG_EVENT:
        EventStatus = NotifyExitThreadEvent(Event->u.ExitThread.dwExitCode);
        break;

    case LOAD_DLL_DEBUG_EVENT:
        GetEventName(Event->u.LoadDll.hFile,
                     Event->u.LoadDll.lpBaseOfDll,
                     Event->u.LoadDll.lpImageName,
                     Event->u.LoadDll.fUnicode,
                     NameBuffer, sizeof(NameBuffer));

        GetHeaderInfo((ULONG64)Event->u.LoadDll.lpBaseOfDll,
                      &CheckSum, &TimeDateStamp, &ModuleSize);
        CreateModuleNameFromPath(NameBuffer, ModuleName);

        EventStatus = NotifyLoadModuleEvent(
            (ULONG64)Event->u.LoadDll.hFile,
            (ULONG64)Event->u.LoadDll.lpBaseOfDll,
            ModuleSize, ModuleName, NameBuffer, CheckSum, TimeDateStamp);
        break;

    case UNLOAD_DLL_DEBUG_EVENT:
        EventStatus = NotifyUnloadModuleEvent(
            NULL, (ULONG64)Event->u.UnloadDll.lpBaseOfDll);
        break;

    case OUTPUT_DEBUG_STRING_EVENT:
        EventStatus = OutputEventDebugString(&Event->u.DebugString);
        break;

    case RIP_EVENT:
        EventStatus = NotifySystemErrorEvent(Event->u.RipInfo.dwError,
                                             Event->u.RipInfo.dwType);
        break;

    case EXCEPTION_DEBUG_EVENT:
        EventStatus = ProcessEventException(Event);
        break;

    default:
        WarnOut("Unknown event number 0x%08lx\n",
                Event->dwDebugEventCode);
        EventStatus = DEBUG_STATUS_BREAK;
        break;
    }

    return EventStatus;
}

typedef BOOL (__stdcall * PFN_SWITCHDESKTOP)(HDESK hDesktop);
typedef HDESK (__stdcall *PFN_GETTHREADDESKTOP)(DWORD dwThreadId);
typedef BOOL (__stdcall *PFN_CLOSEDESKTOP)(HDESK hDesktop);

PFN_SWITCHDESKTOP g_SwitchDesktop;
PFN_GETTHREADDESKTOP g_GetThreadDesktop;
PFN_CLOSEDESKTOP g_CloseDesktop;
BOOL g_InitUserApis;
BOOL g_UserApisAvailable;

#define ISTS() (!!(USER_SHARED_DATA->SuiteMask & (1 << TerminalServer)))
#define FIRST_CHANCE     Event->u.Exception.dwFirstChance

ULONG
ProcessEventException(DEBUG_EVENT64* Event)
{
    ULONG ExceptionCode;
    ULONG EventStatus;
    BOOL OutputDone = FALSE;

    ExceptionCode = Event->u.Exception.ExceptionRecord.ExceptionCode;
    g_EventPc = (ULONG64)
        Event->u.Exception.ExceptionRecord.ExceptionAddress;

    EventOut("Exception %X at %p\n", ExceptionCode, g_EventPc);
    //
    // If we are debugging a crashed process, force the
    // desktop we are on to the front so the user will know
    // what happened.
    //
    if (g_EventToSignal != NULL &&
        !ISTS() &&
        !SYSTEM_PROCESSES())
    {
        if (!g_InitUserApis)
        {
            HINSTANCE hUser = LoadLibrary("user32.dll");
            if (hUser)
            {
                g_SwitchDesktop = (PFN_SWITCHDESKTOP)
                    GetProcAddress(hUser, "SwitchDesktop");
                g_GetThreadDesktop = (PFN_GETTHREADDESKTOP)
                    GetProcAddress(hUser, "GetThreadDesktop");
                g_CloseDesktop = (PFN_CLOSEDESKTOP)
                    GetProcAddress(hUser, "CloseDesktop");
                if (g_SwitchDesktop && g_GetThreadDesktop &&
                    g_CloseDesktop)
                {
                    g_UserApisAvailable = TRUE;
                }
            }

            g_InitUserApis = TRUE;
        }

        if (g_UserApisAvailable)
        {
            HDESK hDesk;

            hDesk = g_GetThreadDesktop(::GetCurrentThreadId());
            g_SwitchDesktop(hDesk);
            g_CloseDesktop(hDesk);
        }
    }

    if (g_EventThread == NULL)
    {
        ErrOut("ERROR: Exception %X occurred on unknown thread\n",
               ExceptionCode);
        return DEBUG_STATUS_BREAK;
    }
    
    if (ExceptionCode == STATUS_VDM_EVENT)
    {
        ULONG ulRet = VDMEvent(Event);

        switch(ulRet)
        {
        case VDMEVENT_NOT_HANDLED:
            EventStatus = DEBUG_STATUS_GO_NOT_HANDLED;
            break;
        case VDMEVENT_HANDLED:
            EventStatus = DEBUG_STATUS_GO_HANDLED;
            break;
        default:
            // Give vdm code the option of mutating this into
            // a standard exception (like STATUS_BREAKPOINT)
            ExceptionCode = ulRet;
            break;
        }
    }

    switch (ExceptionCode)
    {
    case STATUS_BREAKPOINT:
    case STATUS_SINGLE_STEP:
    case STATUS_WX86_BREAKPOINT:
    case STATUS_WX86_SINGLE_STEP:
        EventStatus = ProcessBreakpointOrStepException
            (&Event->u.Exception.ExceptionRecord, FIRST_CHANCE);
        break;

    case STATUS_VDM_EVENT:
        // do nothing, it's already handled
        EventStatus = DEBUG_STATUS_IGNORE_EVENT;
        break;

    case STATUS_ACCESS_VIOLATION:
        if (FIRST_CHANCE &&
            (g_EngOptions & DEBUG_ENGOPT_IGNORE_LOADER_EXCEPTIONS))
        {
            CHAR chSymBuffer[MAX_SYMBOL_LEN];
            LPSTR s;
            ULONG64 displacement;

            //
            // This option allows new 3.51 binaries to run under
            // this debugger on old 3.1, 3.5 systems and avoid stopping
            // at access violations inside LDR that will be handled
            // by the LDR anyway.
            //
            GetSymbolStdCall((ULONG64)(Event->u.Exception.ExceptionRecord.
                                       ExceptionAddress),
                             chSymBuffer,
                             sizeof(chSymBuffer),
                             &displacement,
                             NULL);

            s = (LPSTR)chSymBuffer;
            if (!_strnicmp( s, "ntdll!", 6 ))
            {
                s += 6;
                if (*s == '_') s += 1;
                if (!_stricmp( s, "LdrpSnapThunk" ) ||
                    !_stricmp( s, "LdrpWalkImportDescriptor" ))
                {
                    EventStatus = DEBUG_STATUS_GO_NOT_HANDLED;
                    break;
                }
            }
        }
        goto NotifyException;

    case STATUS_POSSIBLE_DEADLOCK:
        if (g_TargetPlatformId == VER_PLATFORM_WIN32_NT)
        {
            DBG_ASSERT(IS_USER_TARGET());
            AnalyzeDeadlock(&Event->u.Exception.ExceptionRecord,
                            FIRST_CHANCE);
        }
        else
        {
            OutputDeadlock(&Event->u.Exception.ExceptionRecord,
                           FIRST_CHANCE);
        }

        OutputDone = TRUE;
        goto NotifyException;

    default:
        {
        NotifyException:
            EventStatus =
                NotifyExceptionEvent(&Event->u.Exception.ExceptionRecord,
                                     Event->u.Exception.dwFirstChance,
                                     OutputDone);
        }
        break;
    }

    //
    // Do this for all exceptions, just in case some other
    // thread caused an exception before we get around to
    // handling the breakpoint event.
    //
    g_EngDefer |= ENG_DEFER_SET_EVENT;

    return EventStatus;
}

#undef FIRST_CHANCE

#define INPUT_API_SIG 0xdefaced

typedef struct _hdi
{
    DWORD   dwSignature;
    BYTE    cLength;
    BYTE    cStatus;
} HDI;

ULONG
OutputEventDebugString(OUTPUT_DEBUG_STRING_INFO64* Info)
{
    LPSTR Str, StrOffset, Str2;
    BOOL b;
    ULONG dwNumberOfBytesRead;
    HDI hdi;
    DWORD dwInputSig;
    ULONG EventStatus = DEBUG_STATUS_IGNORE_EVENT;

    if (Info->nDebugStringLength == 0)
    {
        return EventStatus;
    }

    Str = (PSTR)calloc(1, Info->nDebugStringLength);
    if (Str == NULL)
    {
        ErrOut("Unable to allocate debug output buffer\n");
        return EventStatus;
    }

    if (g_Target->ReadVirtual(Info->lpDebugStringData, Str,
                              Info->nDebugStringLength,
                              &dwNumberOfBytesRead) == S_OK &&
        (dwNumberOfBytesRead == (SIZE_T)Info->nDebugStringLength))
    {
        //
        // Special processing for hacky debug input string
        //

        if (g_Target->ReadVirtual(Info->lpDebugStringData +
                                  Info->nDebugStringLength,
                                  &hdi, sizeof(hdi),
                                  &dwNumberOfBytesRead) == S_OK &&
            dwNumberOfBytesRead == sizeof(hdi) &&
            hdi.dwSignature == INPUT_API_SIG)
        {
            StartOutLine(DEBUG_OUTPUT_DEBUGGEE_PROMPT, OUT_LINE_NO_PREFIX);
            MaskOut(DEBUG_OUTPUT_DEBUGGEE_PROMPT, "%s", Str);

            Str2 = (PSTR)calloc(1, hdi.cLength + 1);
            if (Str2)
            {
                GetInput(NULL, Str2, hdi.cLength);
                g_Target->WriteVirtual(Info->lpDebugStringData + 6,
                                       Str2, (DWORD)hdi.cLength, NULL);
                free(Str2);
            }
            else
            {
                ErrOut("Unable to allocate prompt buffer\n");
            }
        }
        else
        {
            StartOutLine(DEBUG_OUTPUT_DEBUGGEE, OUT_LINE_NO_PREFIX);
            MaskOut(DEBUG_OUTPUT_DEBUGGEE, "%s", Str);
            
            EVENT_FILTER* Filter =
                &g_EventFilters[DEBUG_FILTER_DEBUGGEE_OUTPUT];
            if (IS_EFEXECUTION_BREAK(Filter->Params.ExecutionOption) &&
                BreakOnThisOutString(Str))
            {
                EventStatus = DEBUG_STATUS_BREAK;
            }
        }
    }
    else
    {
        ErrOut("Unable to read debug output string, %d\n",
               GetLastError());
    }

    free(Str);
    return EventStatus;
}

//----------------------------------------------------------------------------
//
// DumpTargetInfo::WaitForEvent.
//
//----------------------------------------------------------------------------

HRESULT
DumpTargetInfo::WaitForEvent(ULONG Flags, ULONG Timeout)
{
    HRESULT Status;
    ULONG i;
    ULONG ContinueStatus;
    BOOL HaveContext = FALSE;

    if (g_EngStatus & ENG_STATUS_PROCESSES_ADDED)
    {
        // A wait has already been done.  Crash dumps
        // can only generate a single event so further
        // waiting is not possible.
        return E_UNEXPECTED;
    }

    // Even though dumps don't really wait the standard
    // preparation still needs to be done to set things
    // up and generate the usual callbacks.  The continuation
    // part of things is simply ignored.
    Status = PrepareForWait(Flags, &ContinueStatus);
    if (FAILED(Status))
    {
        return Status;
    }

    // This is the first wait.  Simulate any
    // necessary events such as process and thread
    // creations and image loads.

    Status = InitializeMachine(g_TargetMachineType);
    if (Status != S_OK)
    {
        ErrOut("Unable to initialize target machine information\n");
        return Status;
    }

    // Don't give real callbacks for processes/threads as
    // they're just faked in the dump case.
    g_EngNotify++;

    if (IS_KERNEL_TARGET())
    {
        ULONG CurProc;

        CreateKernelProcessAndThreads();

        // Load kernel symbols.
        VerifyKernelBase(TRUE);
        g_Target->OutputVersion();

        if (!IS_KERNEL_TRIAGE_DUMP())
        {
            if (g_TargetMachineType == IMAGE_FILE_MACHINE_ALPHA ||
                g_TargetMachineType == IMAGE_FILE_MACHINE_AXP64)
            {
                // Try and get the symbol for KiPcrBaseAddress.
                if (!GetOffsetFromSym("nt!KiPcrBaseAddress",
                                      &g_DumpKiPcrBaseAddress,
                                      NULL))
                {
                    // Not a critical failure.
                    g_DumpKiPcrBaseAddress = 0;
                }
            }

            if (KdDebuggerData.KiProcessorBlock)
            {
                ULONG PtrSize = g_TargetMachine->m_Ptr64 ?
                    sizeof(ULONG64) : sizeof(ULONG);

                for (i = 0; i < g_TargetNumberProcessors; i++)
                {
                    Status = ReadPointer(g_TargetMachine,
                                         KdDebuggerData.KiProcessorBlock +
                                         i * PtrSize,
                                         &(g_DumpKiProcessors[i]));
                    if ((Status != S_OK) || !g_DumpKiProcessors[i])
                    {
                        ErrOut("KiProcessorBlock[%d] could not be read\n", i);
                        Status = E_FAIL;
                        g_EngNotify--;
                        goto Exit;
                    }
                }

                HaveContext = TRUE;
            }
        }
        else
        {
            HaveContext = TRUE;
        }

        CurProc = ((KernelDumpTargetInfo*)this)->GetCurrentProcessor();
        if (CurProc == (ULONG)-1)
        {
            WarnOut("Could not determine the current processor, "
                    "using zero\n");
            CurProc = 0;
        }

        if (HaveContext)
        {
            g_EventProcessSysId = VIRTUAL_PROCESS_ID;
            g_EventThreadSysId = VIRTUAL_THREAD_ID(CurProc);
        }

        // Clear the global state change just in case somebody's
        // directly accessing it somewhere.
        ZeroMemory(&g_StateChange, sizeof(g_StateChange));
        g_StateChangeData = g_StateChangeBuffer;
        g_StateChangeBuffer[0] = 0;

        if ((g_TargetMachineType == IMAGE_FILE_MACHINE_I386 ||
             g_TargetMachineType == IMAGE_FILE_MACHINE_IA64) &&
            !IS_KERNEL_TRIAGE_DUMP() &&
            HaveContext)
        {
            //
            // Reset the page directory correctly since NT 4 stores
            // the wrong CR3 value in the context.
            //
            // IA64 dumps start out with just the kernel page
            // directory set so update everything.
            //

            FindEventProcessThread();
            ChangeRegContext(g_EventThread);
            if (g_TargetMachine->
                SetDefaultPageDirectories(PAGE_DIR_ALL) != S_OK)
            {
                WarnOut("WARNING: Unable to reset page directories\n");
            }
            ChangeRegContext(NULL);
            // Flush the cache just in case as vmem mappings changed.
            g_VirtualCache.Empty();
        }
    }
    else
    {
        ULONG Suspend;
        ULONG64 Teb;
        UserDumpTargetInfo* UserDump = (UserDumpTargetInfo*)g_Target;

        g_Target->OutputVersion();

        // Create the process.
        g_EventProcessSysId = UserDump->m_EventProcess;
        if (UserDump->GetThreadInfo(0, &g_EventThreadSysId,
                                    &Suspend, &Teb) != S_OK)
        {
            // Dump doesn't contain thread information so
            // fake it.
            g_EventThreadSysId = VIRTUAL_THREAD_ID(0);
            Suspend = 0;
            Teb = 0;
        }

        EventOut("User dump process %x.%x with %u threads\n",
                 g_EventProcessSysId, g_EventThreadSysId,
                 UserDump->m_ThreadCount);

        NotifyCreateProcessEvent(0, (ULONG64)VIRTUAL_PROCESS_HANDLE, 0, 0,
                                 NULL, NULL, 0, 0,
                                 (ULONG64)VIRTUAL_THREAD_HANDLE(0),
                                 Teb, 0, 0, DEBUG_PROCESS_ONLY_THIS_PROCESS,
                                 0);
        // Update thread suspend count from dump info.
        g_EventThread->SuspendCount = Suspend;

        // Create any remaining threads.
        for (i = 1; i < UserDump->m_ThreadCount; i++)
        {
            UserDump->GetThreadInfo(i, &g_EventThreadSysId, &Suspend, &Teb);

            EventOut("User dump thread %d: %x\n", i, g_EventThreadSysId);

            NotifyCreateThreadEvent((ULONG64)VIRTUAL_THREAD_HANDLE(i),
                                    Teb, 0, 0);
            // Update thread suspend count from dump info.
            g_EventThread->SuspendCount = Suspend;
        }

        g_EventThreadSysId = UserDump->m_EventThread;

        HaveContext = TRUE;

        EventOut("User dump event on %x.%x\n",
                 g_EventProcessSysId, g_EventThreadSysId);
    }

    // Do not provide a control report; this will force
    // such information to come from context retrieval.
    g_ControlReport = NULL;

    g_EventPc = (ULONG64)g_DumpException.ExceptionAddress;

    if (HaveContext)
    {
        FindEventProcessThread();
        ChangeRegContext(g_EventThread);
    }

    //
    // Go ahead and reload all the symbols.
    // This is especially important for minidumps because without
    // symbols and the executable image, we can't unassemble the
    // current instruction.
    //

    Status = g_Target->Reload(HaveContext ? "" : "-P");

    ChangeRegContext(NULL);
    
    if (HaveContext && Status != S_OK)
    {
        g_EngNotify--;
        goto Exit;
    }

    if (IS_USER_TARGET())
    {
        PDEBUG_IMAGE_INFO Image;
        
        // Try and look up the build lab information from kernel32.
        Image = GetImageByName(g_ProcessHead, "kernel32", INAME_MODULE);
        if (Image != NULL)
        {
            char Item[64];
            ULONG PreLen;
            
            sprintf(Item, "\\StringFileInfo\\%04x%04x\\FileVersion",
                    VER_VERSION_TRANSLATION);
            strcpy(g_TargetBuildLabName, "kernel32.dll version: ");
            PreLen = strlen(g_TargetBuildLabName);
            if (FAILED(GetImageVersionInformation
                       (Image->ImagePath, Image->BaseOfImage,
                        Item, g_TargetBuildLabName + PreLen,
                        sizeof(g_TargetBuildLabName) - PreLen, NULL)))
            {
                g_TargetBuildLabName[0] = 0;
            }
        }
    }
    
    g_EngStatus |= ENG_STATUS_STATE_CHANGED;

    // The engine is now initialized so a real event
    // can be generated.
    g_EngNotify--;
    NotifyExceptionEvent(&g_DumpException, g_DumpExceptionFirstChance,
                         g_DumpException.ExceptionCode ==
                         STATUS_BREAKPOINT ||
                         g_DumpException.ExceptionCode ==
                         STATUS_WX86_BREAKPOINT);

    Status = S_OK;

 Exit:
    g_EngStatus &= ~ENG_STATUS_WAITING;

    // Control is passing back to the caller so the engine must
    // be ready for command processing.
    PrepareForCalls(0);
    
#if 0
    // this is now doe in condbg/windbg

    // Run the bugcheck analyzers if this dump has a bugcheck.
    if (Status == S_OK && HaveContext && IS_KERNEL_TARGET())
    {
        ULONG Code;
        ULONG64 Args[4];

        if (ReadBugCheckData(&Code, Args) == S_OK &&
            Code != 0)
        {
            CallBugCheckExtension(NULL);
        }
    }
#endif 

    EventOut("> Wait returning %X\n", Status);
    return Status;
}

//----------------------------------------------------------------------------
//
// Event filters.
//
//----------------------------------------------------------------------------

void ParseImageTail(PSTR Buffer, ULONG BufferSize)
{
    int i;
    char ch;

    Buffer[0] = '\0';

    i = 0;
    while (ch = (char)tolower(*g_CurCmd))
    {
        if (ch == ' ' || ch == '\t' || ch == ';')
        {
            break;
        }

        // Only capture the path tail.
        if (IS_SLASH(ch) || ch == ':')
        {
            i = 0;
        }
        else
        {
            Buffer[i++] = ch;
            if (i == BufferSize - 1)
            {
                // don't overrun the buffer
                break;
            }
        }
        
        g_CurCmd++;
    }
    
    Buffer[i] = '\0';
}

void
ParseUnloadDllBreakAddr(void)
/*++

Routine Description:

    Called after 'sxe ud' has been parsed.  This routine detects an
    optional DLL base address after the 'sxe ud', which tells the debugger
    to run until that specific DLL is unloaded, not just the next DLL.

Arguments:

    None.

Return Value:

    None.

--*/
{
    UCHAR ch;

    g_UnloadDllBase = 0;
    g_UnloadDllBaseName[0] = 0;

    while (ch = (UCHAR)tolower(*g_CurCmd))
    {
        if (ch == ' ')
        {
            break;
        }

        // Skip leading ':'
        if (ch != ':')
        {
            //  Get the base address
            g_UnloadDllBase = GetExpression();
            sprintf(g_UnloadDllBaseName, "0x%s",
                    FormatAddr64(g_UnloadDllBase));
            break;
        }
        g_CurCmd++;
    }
}

void
ParseOutFilterPattern(void)
{
    int i;
    char ch;

    i = 0;
    while (ch = (char)tolower(*g_CurCmd))
    {
        if (ch == ' ')
        {
            break;
        }

        if (ch == ':')
        {
            i = 0;
        }
        else
        {
            g_OutEventFilterPattern[i++] = (char)toupper(ch);
            if (i == sizeof(g_OutEventFilterPattern) - 1)
            {
                // Don't overrun the buffer.
                break;
            }
        }
        
        g_CurCmd++;
    }
    
    g_OutEventFilterPattern[i] = 0;
}

BOOL
BreakOnThisImageTail(PCSTR ImagePath, PCSTR FilterArg)
{
    //
    // No filter specified so break on all events.
    //
    if (!FilterArg || !FilterArg[0])
    {
        return TRUE;
    }

    //
    // Some kind of error looking up the image path.  Break anyhow.
    //
    if (!ImagePath || !ImagePath[0])
    {
        return TRUE;
    }

    PCSTR Tail = PathTail(ImagePath);
    
    //
    // Specified name may not have an extension.  Break
    // on the first event whose name matches regardless of its extension if
    // the break name did not have one.
    //
    if (_strnicmp(Tail, FilterArg, strlen(FilterArg)) == 0)
    {
        return TRUE;
    }
    else if (MatchPattern((PSTR)Tail, (PSTR)FilterArg))
    {
        return TRUE;
    }

    return FALSE;
}

BOOL
BreakOnThisDllUnload(
    ULONG64 DllBase
    )
{
    // 'sxe ud' with no base address specified.  Break on all DLL unloads
    if (g_UnloadDllBase == 0)
    {
        return TRUE;
    }

    // 'sxe ud' with base address specified.  Break if this
    // DLL's base address matches the one specified
    return g_UnloadDllBase == DllBase;
}

BOOL
BreakOnThisOutString(PCSTR OutString)
{
    if (!g_OutEventFilterPattern[0])
    {
        // No pattern means always break.
        return TRUE;
    }

    return MatchPattern((PSTR)OutString, g_OutEventFilterPattern);
}

EVENT_FILTER*
GetSpecificExceptionFilter(ULONG Code)
{
    ULONG i;
    EVENT_FILTER* Filter;

    Filter = g_EventFilters + FILTER_EXCEPTION_FIRST;
    for (i = FILTER_EXCEPTION_FIRST; i <= FILTER_EXCEPTION_LAST; i++)
    {
        if (i != FILTER_DEFAULT_EXCEPTION &&
            Filter->Params.ExceptionCode == Code)
        {
            return Filter;
        }

        Filter++;
    }

    return NULL;
}

void GetOtherExceptionParameters(ULONG Code,
                                 PDEBUG_EXCEPTION_FILTER_PARAMETERS* Params,
                                 EVENT_COMMAND** Command)
{
    ULONG Index;

    for (Index = 0; Index < g_NumOtherExceptions; Index++)
    {
        if (Code == g_OtherExceptionList[Index].ExceptionCode)
        {
            *Params = g_OtherExceptionList + Index;
            *Command = g_OtherExceptionCommands + Index;
            return;
        }
    }

    *Params = &g_EventFilters[FILTER_DEFAULT_EXCEPTION].Params;
    *Command = &g_EventFilters[FILTER_DEFAULT_EXCEPTION].Command;
}

ULONG
SetOtherExceptionParameters(PDEBUG_EXCEPTION_FILTER_PARAMETERS Params,
                            EVENT_COMMAND* Command)
{
    ULONG Index;

    if (g_EventFilters[FILTER_DEFAULT_EXCEPTION].
        Params.ExecutionOption == Params->ExecutionOption &&
        g_EventFilters[FILTER_DEFAULT_EXCEPTION].
        Params.ContinueOption == Params->ContinueOption &&
        !memcmp(&g_EventFilters[FILTER_DEFAULT_EXCEPTION].Command,
                Command, sizeof(*Command)))
    {
        // Exception state same as global state clears entry
        // in list if there.

        for (Index = 0; Index < g_NumOtherExceptions; Index++)
        {
            if (Params->ExceptionCode ==
                g_OtherExceptionList[Index].ExceptionCode)
            {
                g_NumOtherExceptions--;
                memmove(g_OtherExceptionList + Index,
                        g_OtherExceptionList + Index + 1,
                        (g_NumOtherExceptions - Index) *
                        sizeof(g_OtherExceptionList[0]));
                memmove(g_OtherExceptionCommands + Index,
                        g_OtherExceptionCommands + Index + 1,
                        (g_NumOtherExceptions - Index) *
                        sizeof(g_OtherExceptionCommands[0]));
                NotifyChangeEngineState(DEBUG_CES_EVENT_FILTERS,
                                        DEBUG_ANY_ID, TRUE);
                break;
            }
        }
    }
    else
    {
        // Exception state different from global state is added
        // to list if not already there.

        for (Index = 0; Index < g_NumOtherExceptions; Index++)
        {
            if (Params->ExceptionCode ==
                g_OtherExceptionList[Index].ExceptionCode)
            {
                break;
            }
        }
        if (Index == g_NumOtherExceptions)
        {
            if (g_NumOtherExceptions == OTHER_EXCEPTION_LIST_MAX)
            {
                return LISTSIZE;
            }

            Index = g_NumOtherExceptions++;
        }

        g_OtherExceptionList[Index] = *Params;
        g_OtherExceptionCommands[Index] = *Command;
        NotifyChangeEngineState(DEBUG_CES_EVENT_FILTERS, Index, TRUE);
    }

    return 0;
}

ULONG
SetEventFilterExecution(EVENT_FILTER* Filter, ULONG Execution)
{
    ULONG Index = (ULONG)(Filter - g_EventFilters);

    // Non-exception events don't have second chances so
    // demote second-chance break to output.  This matches
    // the intuitive expectation that sxd will disable
    // the break.
    if (
#if DEBUG_FILTER_CREATE_THREAD > 0
        Index >= DEBUG_FILTER_CREATE_THREAD &&
#endif
        Index <= DEBUG_FILTER_SYSTEM_ERROR &&
        Execution == DEBUG_FILTER_SECOND_CHANCE_BREAK)
    {
        Execution = DEBUG_FILTER_OUTPUT;
    }

    Filter->Params.ExecutionOption = Execution;
    Filter->Flags |= FILTER_CHANGED_EXECUTION;

    // Collect any additional arguments.
    switch(Index)
    {
    case DEBUG_FILTER_CREATE_PROCESS:
    case DEBUG_FILTER_EXIT_PROCESS:
    case DEBUG_FILTER_LOAD_MODULE:
        ParseImageTail(Filter->Argument, FILTER_MAX_ARGUMENT);
        break;

    case DEBUG_FILTER_UNLOAD_MODULE:
        ParseUnloadDllBreakAddr();
        break;

    case DEBUG_FILTER_DEBUGGEE_OUTPUT:
        ParseOutFilterPattern();
        break;
    }

    return 0;
}

ULONG
SetEventFilterContinue(EVENT_FILTER* Filter, ULONG Continue)
{
    Filter->Params.ContinueOption = Continue;
    Filter->Flags |= FILTER_CHANGED_CONTINUE;
    return 0;
}

ULONG
SetEventFilterCommand(DebugClient* Client, EVENT_FILTER* Filter,
                      EVENT_COMMAND* EventCommand, PSTR* Command)
{
    if (Command[0] != NULL &&
        ChangeString(&EventCommand->Command[0], &EventCommand->CommandSize[0],
                     Command[0][0] ? Command[0] : NULL) != S_OK)
    {
        return MEMORY;
    }
    if (Command[1] != NULL)
    {
        if (Filter != NULL &&
#if FILTER_SPECIFIC_FIRST > 0
            (ULONG)(Filter - g_EventFilters) >= FILTER_SPECIFIC_FIRST &&
#endif
            (ULONG)(Filter - g_EventFilters) <= FILTER_SPECIFIC_LAST)
        {
            WarnOut("Second-chance command for specific event ignored\n");
        }
        else if (ChangeString(&EventCommand->Command[1],
                              &EventCommand->CommandSize[1],
                              Command[1][0] ? Command[1] : NULL) != S_OK)
        {
            return MEMORY;
        }
    }

    if (Command[0] != NULL || Command[1] != NULL)
    {
        if (Filter != NULL)
        {
            Filter->Flags |= FILTER_CHANGED_COMMAND;
        }
        EventCommand->Client = Client;
    }

    return 0;
}

#define EXEC_TO_CONT(Option) \
    ((Option) == DEBUG_FILTER_BREAK ? \
     DEBUG_FILTER_GO_HANDLED : DEBUG_FILTER_GO_NOT_HANDLED)

ULONG
SetEventFilterEither(DebugClient* Client, EVENT_FILTER* Filter,
                     ULONG Option, BOOL ContinueOption,
                     PSTR* Command)
{
    ULONG Status;

    if (Option != DEBUG_FILTER_REMOVE)
    {
        if (ContinueOption)
        {
            Status = SetEventFilterContinue(Filter, EXEC_TO_CONT(Option));
        }
        else
        {
            Status = SetEventFilterExecution(Filter, Option);
        }
        if (Status != 0)
        {
            return Status;
        }
    }

    return SetEventFilterCommand(Client, Filter, &Filter->Command, Command);
}

ULONG
SetEventFilterByName(DebugClient* Client,
                     ULONG Option, BOOL ForceContinue, PSTR* Command)
{
    PSTR Start = g_CurCmd;
    char Name[8];
    int i;
    char Ch;

    // Collect name.
    i = 0;
    while (i < sizeof(Name) - 1)
    {
        Ch = *g_CurCmd++;
        if (!__iscsym(Ch))
        {
            g_CurCmd--;
            break;
        }

        Name[i++] = (CHAR)tolower(Ch);
    }
    Name[i] = 0;

    // Skip any whitespace after the name.
    while (isspace(*g_CurCmd))
    {
        g_CurCmd++;
    }

    EVENT_FILTER* Filter;
    BOOL Match = FALSE;
    ULONG MatchIndex = DEBUG_ANY_ID;
    ULONG Status = 0;

    // Multiple filters can be altered if they share names.
    Filter = g_EventFilters;
    for (i = 0; i < FILTER_COUNT; i++)
    {
        if (Filter->ExecutionAbbrev != NULL &&
            !strcmp(Name, Filter->ExecutionAbbrev))
        {
            Status = SetEventFilterEither(Client,
                                          Filter, Option, ForceContinue,
                                          Command);
            if (Status != 0)
            {
                goto Exit;
            }

            if (!Match)
            {
                MatchIndex = i;
                Match = TRUE;
            }
            else if (MatchIndex != (ULONG)i)
            {
                // Multiple matches.
                MatchIndex = DEBUG_ANY_ID;
            }
        }

        if (Filter->ContinueAbbrev != NULL &&
            !strcmp(Name, Filter->ContinueAbbrev))
        {
            // Translate execution-style option to continue-style option.
            Status = SetEventFilterEither(Client,
                                          Filter, Option, TRUE, Command);
            if (Status != 0)
            {
                goto Exit;
            }

            if (!Match)
            {
                MatchIndex = i;
                Match = TRUE;
            }
            else if (MatchIndex != (ULONG)i)
            {
                // Multiple matches.
                MatchIndex = DEBUG_ANY_ID;
            }
        }

        Filter++;
    }

    if (!Match)
    {
        ULONG64 ExceptionCode;

        // Name is unrecognized.  Assume it's an exception code.
        g_CurCmd = Start;
        ExceptionCode = GetExpression();
        if (NeedUpper(ExceptionCode))
        {
            return OVERFLOW;
        }

        DEBUG_EXCEPTION_FILTER_PARAMETERS Params, *CurParams;
        EVENT_COMMAND EventCommand, *CurEventCommand;

        GetOtherExceptionParameters((ULONG)ExceptionCode,
                                    &CurParams, &CurEventCommand);

        Params = *CurParams;
        if (Option != DEBUG_FILTER_REMOVE)
        {
            if (ForceContinue)
            {
                Params.ContinueOption = EXEC_TO_CONT(Option);
            }
            else
            {
                Params.ExecutionOption = Option;
            }
        }
        Params.ExceptionCode = (ULONG)ExceptionCode;

        EventCommand = *CurEventCommand;
        Status = SetEventFilterCommand(Client, NULL, &EventCommand, Command);
        if (Status != 0)
        {
            return Status;
        }

        return SetOtherExceptionParameters(&Params, &EventCommand);
    }

 Exit:
    if (Match)
    {
        if (SyncOptionsWithFilters())
        {
            NotifyChangeEngineState(DEBUG_CES_EVENT_FILTERS |
                                    DEBUG_CES_ENGINE_OPTIONS,
                                    DEBUG_ANY_ID, TRUE);
        }
        else
        {
            NotifyChangeEngineState(DEBUG_CES_EVENT_FILTERS, MatchIndex, TRUE);
        }
    }
    return Status;
}

char* g_EfExecutionNames[] =
{
    "break", "second-chance break", "output", "ignore",
};

char* g_EfContinueNames[] =
{
    "handled", "not handled",
};

void
ListEventFilters(void)
{
    EVENT_FILTER* Filter;
    ULONG i;
    BOOL SetOption = TRUE;

    Filter = g_EventFilters;
    for (i = 0; i < FILTER_COUNT; i++)
    {
        if (Filter->ExecutionAbbrev != NULL)
        {
            dprintf("%4s - %s - %s",
                    Filter->ExecutionAbbrev, Filter->Name,
                    g_EfExecutionNames[Filter->Params.ExecutionOption]);
            if (i >= FILTER_EXCEPTION_FIRST &&
                Filter->ContinueAbbrev == NULL)
            {
                dprintf(" - %s\n",
                        g_EfContinueNames[Filter->Params.ContinueOption]);
            }
            else
            {
                dprintf("\n");
            }

            if (Filter->Command.Command[0] != NULL)
            {
                dprintf("       Command: \"%s\"\n",
                        Filter->Command.Command[0]);
            }
            if (Filter->Command.Command[1] != NULL)
            {
                dprintf("       Second command: \"%s\"\n",
                        Filter->Command.Command[1]);
            }
        }

        if (Filter->ContinueAbbrev != NULL)
        {
            dprintf("%4s - %s continue - %s\n",
                    Filter->ContinueAbbrev, Filter->Name,
                    g_EfContinueNames[Filter->Params.ContinueOption]);
        }

        switch(i)
        {
        case DEBUG_FILTER_CREATE_PROCESS:
        case DEBUG_FILTER_EXIT_PROCESS:
        case DEBUG_FILTER_LOAD_MODULE:
        case DEBUG_FILTER_UNLOAD_MODULE:
            if (IS_EFEXECUTION_BREAK(Filter->Params.ExecutionOption) &&
                Filter->Argument[0])
            {
                dprintf("       (only break for %s)\n", Filter->Argument);
            }
            break;
        case DEBUG_FILTER_DEBUGGEE_OUTPUT:
            if (IS_EFEXECUTION_BREAK(Filter->Params.ExecutionOption) &&
                g_OutEventFilterPattern[0])
            {
                dprintf("       (only break for %s matches)\n",
                        g_OutEventFilterPattern);
            }
            break;
        }

        Filter++;
    }

    Filter = &g_EventFilters[FILTER_DEFAULT_EXCEPTION];
    dprintf("\n   * - Other exception - %s - %s\n",
            g_EfExecutionNames[Filter->Params.ExecutionOption],
            g_EfContinueNames[Filter->Params.ContinueOption]);
    if (Filter->Command.Command[0] != NULL)
    {
        dprintf("       Command: \"%s\"\n",
                Filter->Command.Command[0]);
    }
    if (Filter->Command.Command[1] != NULL)
    {
        dprintf("       Second command: \"%s\"\n",
                Filter->Command.Command[1]);
    }

    if (g_NumOtherExceptions > 0)
    {
        dprintf("       Exception option for:\n");
        for (i = 0; i < g_NumOtherExceptions; i++)
        {
            dprintf("           %08lx - %s - %s\n",
                    g_OtherExceptionList[i].ExceptionCode,
                    g_EfExecutionNames[g_OtherExceptionList[i].
                                      ExecutionOption],
                    g_EfContinueNames[g_OtherExceptionList[i].
                                      ContinueOption]);
            if (g_OtherExceptionCommands[i].Command[0] != NULL)
            {
                dprintf("               Command: \"%s\"\n",
                        g_OtherExceptionCommands[i].Command[0]);
            }
            if (g_OtherExceptionCommands[i].Command[1] != NULL)
            {
                dprintf("               Second command: \"%s\"\n",
                        g_OtherExceptionCommands[i].Command[1]);
            }
        }
    }
}

void
ParseSetEventFilter(DebugClient* Client)
{
    UCHAR Ch;

    // Verify that exception constants are properly updated.
    DBG_ASSERT(!strcmp(g_EventFilters[FILTER_EXCEPTION_FIRST - 1].Name,
                       "Debuggee output"));
    DBG_ASSERT(DIMA(g_EventFilters) == FILTER_COUNT);

    Ch = PeekChar();
    if (Ch == '\0')
    {
        ListEventFilters();
    }
    else
    {
        ULONG Option;

        Ch = (UCHAR)tolower(Ch);
        g_CurCmd++;

        switch(Ch)
        {
        case 'd':
            Option = DEBUG_FILTER_SECOND_CHANCE_BREAK;
            break;
        case 'e':
            Option = DEBUG_FILTER_BREAK;
            break;
        case 'i':
            Option = DEBUG_FILTER_IGNORE;
            break;
        case 'n':
            Option = DEBUG_FILTER_OUTPUT;
            break;
        case '-':
            // Special value to indicate "don't change the option".
            // Used for just changing commands.
            Option = DEBUG_FILTER_REMOVE;
            break;
        default:
            error(SYNTAX);
            break;
        }

        BOOL ForceContinue;
        PSTR Command[2];
        ULONG Which;

        ForceContinue = FALSE;
        Command[0] = NULL;
        Command[1] = NULL;

        for (;;)
        {
            while (isspace(PeekChar()))
            {
                g_CurCmd++;
            }

            if (*g_CurCmd == '-' || *g_CurCmd == '/')
            {
                switch(tolower(*(++g_CurCmd)))
                {
                case 'c':
                    if (*(++g_CurCmd) == '2')
                    {
                        Which = 1;
                        g_CurCmd++;
                    }
                    else
                    {
                        Which = 0;
                    }
                    if (PeekChar() != '"')
                    {
                        error(SYNTAX);
                    }
                    if (Command[Which] != NULL)
                    {
                        error(SYNTAX);
                    }
                    Command[Which] = ++g_CurCmd;
                    while (*g_CurCmd && *g_CurCmd != '"')
                    {
                        g_CurCmd++;
                    }
                    if (*g_CurCmd != '"')
                    {
                        error(SYNTAX);
                    }
                    *g_CurCmd = 0;
                    break;

                case 'h':
                    ForceContinue = TRUE;
                    break;

                default:
                    error(SYNTAX);
                }

                g_CurCmd++;
            }
            else
            {
                break;
            }
        }

        ULONG Status;

        if (*g_CurCmd == '*')
        {
            g_CurCmd++;

            Status = SetEventFilterEither
                (Client, &g_EventFilters[FILTER_DEFAULT_EXCEPTION],
                 Option, ForceContinue, Command);
            if (Status == 0)
            {
                g_NumOtherExceptions = 0;
            }
        }
        else
        {
            Status = SetEventFilterByName(Client,
                                          Option, ForceContinue, Command);
        }

        if (Status != 0)
        {
            error(Status);
        }
    }
}

char
ExecutionChar(ULONG Execution)
{
    switch(Execution)
    {
    case DEBUG_FILTER_BREAK:
        return 'e';
    case DEBUG_FILTER_SECOND_CHANCE_BREAK:
        return 'd';
    case DEBUG_FILTER_OUTPUT:
        return 'n';
    case DEBUG_FILTER_IGNORE:
        return 'i';
    }

    return 0;
}

char
ContinueChar(ULONG Continue)
{
    switch(Continue)
    {
    case DEBUG_FILTER_GO_HANDLED:
        return 'e';
    case DEBUG_FILTER_GO_NOT_HANDLED:
        return 'd';
    }

    return 0;
}

void
ListFiltersAsCommands(DebugClient* Client, ULONG Flags)
{
    ULONG i;

    EVENT_FILTER* Filter = g_EventFilters;
    for (i = 0; i < FILTER_COUNT; i++)
    {
        if (Filter->Flags & FILTER_CHANGED_EXECUTION)
        {
            PCSTR Abbrev = Filter->ExecutionAbbrev != NULL ?
                Filter->ExecutionAbbrev : "*";
            dprintf("sx%c %s",
                    ExecutionChar(Filter->Params.ExecutionOption), Abbrev);

            switch(i)
            {
            case DEBUG_FILTER_CREATE_PROCESS:
            case DEBUG_FILTER_EXIT_PROCESS:
            case DEBUG_FILTER_LOAD_MODULE:
            case DEBUG_FILTER_UNLOAD_MODULE:
            case DEBUG_FILTER_DEBUGGEE_OUTPUT:
                if (IS_EFEXECUTION_BREAK(Filter->Params.ExecutionOption) &&
                    Filter->Argument[0])
                {
                    dprintf(":%s", Filter->Argument);
                }
                break;
            }

            dprintf(" ;%c", (Flags & SXCMDS_ONE_LINE) ? ' ' : '\n');
        }

        if (Filter->Flags & FILTER_CHANGED_CONTINUE)
        {
            PCSTR Abbrev = Filter->ContinueAbbrev;
            if (Abbrev == NULL)
            {
                Abbrev = Filter->ExecutionAbbrev != NULL ?
                    Filter->ExecutionAbbrev : "*";
            }

            dprintf("sx%c -h %s ;%c",
                    ContinueChar(Filter->Params.ContinueOption), Abbrev,
                    (Flags & SXCMDS_ONE_LINE) ? ' ' : '\n');
        }

        if (Filter->Flags & FILTER_CHANGED_COMMAND)
        {
            PCSTR Abbrev = Filter->ExecutionAbbrev != NULL ?
                Filter->ExecutionAbbrev : "*";

            dprintf("sx-");
            if (Filter->Command.Command[0] != NULL)
            {
                dprintf(" -c \"%s\"", Filter->Command.Command[0]);
            }
            if (Filter->Command.Command[1] != NULL)
            {
                dprintf(" -c2 \"%s\"", Filter->Command.Command[1]);
            }
            dprintf(" %s ;%c", Abbrev,
                    (Flags & SXCMDS_ONE_LINE) ? ' ' : '\n');
        }

        Filter++;
    }

    PDEBUG_EXCEPTION_FILTER_PARAMETERS Other = g_OtherExceptionList;
    EVENT_COMMAND* EventCommand = g_OtherExceptionCommands;
    for (i = 0; i < g_NumOtherExceptions; i++)
    {
        dprintf("sx%c 0x%x ;%c",
                ExecutionChar(Other->ExecutionOption), Other->ExceptionCode,
                (Flags & SXCMDS_ONE_LINE) ? ' ' : '\n');
        dprintf("sx%c -h 0x%x ;%c",
                ContinueChar(Other->ContinueOption), Other->ExceptionCode,
                (Flags & SXCMDS_ONE_LINE) ? ' ' : '\n');

        if (EventCommand->Command[0] != NULL ||
            EventCommand->Command[1] != NULL)
        {
            dprintf("sx-");
            if (EventCommand->Command[0] != NULL)
            {
                dprintf(" -c \"%s\"", EventCommand->Command[0]);
            }
            if (EventCommand->Command[1] != NULL)
            {
                dprintf(" -c2 \"%s\"", EventCommand->Command[1]);
            }
            dprintf(" 0x%x ;%c", Other->ExceptionCode,
                    (Flags & SXCMDS_ONE_LINE) ? ' ' : '\n');
        }

        Other++;
        EventCommand++;
    }

    if (Flags & SXCMDS_ONE_LINE)
    {
        dprintf("\n");
    }
}

struct SHARED_FILTER_AND_OPTION
{
    ULONG FilterIndex;
    ULONG OptionBit;
};

SHARED_FILTER_AND_OPTION g_SharedFilterOptions[] =
{
    DEBUG_FILTER_INITIAL_BREAKPOINT,  DEBUG_ENGOPT_INITIAL_BREAK,
    DEBUG_FILTER_INITIAL_MODULE_LOAD, DEBUG_ENGOPT_INITIAL_MODULE_BREAK,
    DEBUG_FILTER_EXIT_PROCESS,        DEBUG_ENGOPT_FINAL_BREAK,
};

BOOL
SyncFiltersWithOptions(void)
{
    ULONG ExOption;
    BOOL Changed = FALSE;
    ULONG i;

    for (i = 0; i < DIMA(g_SharedFilterOptions); i++)
    {
        ExOption = (g_EngOptions & g_SharedFilterOptions[i].OptionBit) ?
            DEBUG_FILTER_BREAK : DEBUG_FILTER_IGNORE;
        if (g_EventFilters[g_SharedFilterOptions[i].FilterIndex].
            Params.ExecutionOption != ExOption)
        {
            g_EventFilters[g_SharedFilterOptions[i].FilterIndex].
                Params.ExecutionOption = ExOption;
            Changed = TRUE;
        }
    }
    
    return Changed;
}

BOOL
SyncOptionsWithFilters(void)
{
    ULONG Bit;
    BOOL Changed = FALSE;
    ULONG i;
    
    for (i = 0; i < DIMA(g_SharedFilterOptions); i++)
    {
        Bit = IS_EFEXECUTION_BREAK
            (g_EventFilters[g_SharedFilterOptions[i].FilterIndex].
             Params.ExecutionOption) ?
            g_SharedFilterOptions[i].OptionBit : 0;
        if ((g_EngOptions & g_SharedFilterOptions[i].OptionBit) ^ Bit)
        {
            g_EngOptions =
                (g_EngOptions & ~g_SharedFilterOptions[i].OptionBit) | Bit;
            Changed = TRUE;
        }
    }
    
    return Changed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\i386_asm.h ===
#ifdef  DEBUG
#define dprintf printf
#else
#define dprintf //
#endif

//  token classes and types

#define ASM_CLASS_MASK          0xff00
#define ASM_TYPE_MASK           0x00ff

#define ASM_EOL_CLASS           0x000

#define ASM_ADDOP_CLASS         0x100
#define ASM_ADDOP_PLUS          0x101
#define ASM_ADDOP_MINUS         0x102

#define ASM_MULOP_CLASS         0x200
#define ASM_MULOP_MULT          0x201
#define ASM_MULOP_DIVIDE        0x202
#define ASM_MULOP_MOD           0x203
#define ASM_MULOP_SHL           0x204
#define ASM_MULOP_SHR           0x205

#define ASM_ANDOP_CLASS         0x300

#define ASM_NOTOP_CLASS         0x400

#define ASM_OROP_CLASS          0x500
#define ASM_OROP_OR             0x501
#define ASM_OROP_XOR            0x502

#define ASM_RELOP_CLASS         0x600
#define ASM_RELOP_EQ            0x601
#define ASM_RELOP_NE            0x602
#define ASM_RELOP_LE            0x603
#define ASM_RELOP_LT            0x604
#define ASM_RELOP_GE            0x605
#define ASM_RELOP_GT            0x606

#define ASM_UNOP_CLASS          0x700
#define ASM_UNOP_BY             0x701   //  UNDONE
#define ASM_UNOP_WO             0x702   //  UNDONE
#define ASM_UNOP_DW             0x703   //  UNDONE
#define ASM_UNOP_POI            0x704   //  UNDONE

#define ASM_LOWOP_CLASS         0x800
#define ASM_LOWOP_LOW           0x801
#define ASM_LOWOP_HIGH          0x802

#define ASM_PTROP_CLASS         0x900

#define ASM_SIZE_CLASS          0xa00
#define ASM_SIZE_BYTE           (0xa00 + sizeB)
#define ASM_SIZE_WORD           (0xa00 + sizeW)
#define ASM_SIZE_DWORD          (0xa00 + sizeD)
#define ASM_SIZE_FWORD          (0xa00 + sizeF)
#define ASM_SIZE_QWORD          (0xa00 + sizeQ)
#define ASM_SIZE_TBYTE          (0xa00 + sizeT)
#define ASM_SIZE_SWORD          (0xa00 + sizeS)

#define ASM_OFFOP_CLASS         0xb00
#define ASM_COLNOP_CLASS        0xc00
#define ASM_LPAREN_CLASS        0xd00
#define ASM_RPAREN_CLASS        0xe00
#define ASM_LBRACK_CLASS        0xf00
#define ASM_RBRACK_CLASS        0x1000
#define ASM_DOTOP_CLASS         0x1100
#define ASM_SEGOVR_CLASS        0x1200
#define ASM_SEGMENT_CLASS       0x1300          //  value has 16-bit value
#define ASM_COMMA_CLASS         0x1400

#define ASM_REG_CLASS           0x1500
#define ASM_REG_BYTE            0x1501
#define ASM_REG_WORD            0x1502
#define ASM_REG_DWORD           0x1503
#define ASM_REG_SEGMENT         0x1504
#define ASM_REG_CONTROL         0x1505
#define ASM_REG_DEBUG           0x1506
#define ASM_REG_TRACE           0x1507
#define ASM_REG_FLOAT           0x1508
#define ASM_REG_INDFLT          0x1509

#define ASM_NUMBER_CLASS        0x1600
#define ASM_SYMBOL_CLASS        0x1700

#define ASM_ERROR_CLASS         0xff00  //  only used for PeekToken

#define tEnd    0x80
#define eEnd    0x40

//  template flag and operand tokens

enum {
        asNone, as0x0a, asOpRg, asSiz0, asSiz1, asWait, asSeg,  asFSiz,
        asMpNx, asPrfx,

        asReg0, asReg1, asReg2, asReg3, asReg4, asReg5, asReg6, asReg7,

        opnAL,  opnAX,  opneAX, opnCL,  opnDX,  opnAp,  opnEb,  opnEw,
        opnEv,  opnGb,  opnGw,  opnGv,  opnGd,  opnIm1, opnIm3, opnIb,
        opnIw,  opnIv,  opnJb,  opnJv,  opnM,   opnMa,  opnMb,  opnMw,
        opnMd,  opnMp,  opnMs,  opnMq,  opnMt,  opnMv,  opnCd,  opnDd,
        opnTd,  opnRd,  opnSt,  opnSti, opnSeg, opnSw,  opnXb,  opnXv,
        opnYb,  opnYv,  opnOb,  opnOv
        };

#define asRegBase asReg0        //  first of REG flags
#define opnBase   opnAL         //  first template operand type
                                //  if less, then flag, else operand

enum {
        segX, segES,  segCS,  segSS,  segDS,  segFS,  segGS
        };

enum {
        typNULL,        //  no defined type
        typAX,          //  general register, value EAX
        typCL,          //  general register, value ECX
        typDX,          //  general register, value EDX
        typAbs,         //  absolute type (direct address)
        typExp,         //  expr (mod-r/m) general register or memory pointer
        typGen,         //  general register
        typReg,         //  general register (special reg MOV)
        typIm1,         //  immediate, value 1
        typIm3,         //  immediate, value 3
        typImm,         //  immediate
        typJmp,         //  jump relative offset
        typMem,         //  memory pointer
        typCtl,         //  control register
        typDbg,         //  debug register
        typTrc,         //  trace register
        typSt,          //  floating point top-of-stack
        typSti,         //  floating point index-on-stack
        typSeg,         //  segment register (PUSH/POP opcode)
        typSgr,         //  segment register (MOV opcode)
        typXsi,         //  string source address
        typYdi,         //  string destination address
        typOff          //  memory offset
        };

enum {
        regG,           //  general register
        regS,           //  segment register
        regC,           //  control register
        regD,           //  debug register
        regT,           //  trace register
        regF,           //  float register (st)
        regI            //  float-index register (st(n))
        };

enum {
        indAX,          //  index for EAX, AX, AL
        indCX,          //  index for ECX, CX, CL
        indDX,          //  index for EDX, DX, DL
        indBX,          //  index for EBX, BX, BL
        indSP,          //  index for ESP, SP, AH
        indBP,          //  index for EBP, BP, CH
        indSI,          //  index for ESI, SI, DH
        indDI           //  index for EDI, DI, BH
        };

enum {
        sizeX,          //  no size
        sizeB,          //  byte size
        sizeW,          //  word size
        sizeV,          //  variable size (word or dword)
        sizeD,          //  dword size
        sizeP,          //  pointer size (dword or fword)
        sizeA,          //  dword or qword
        sizeF,          //  fword
        sizeQ,          //  qword
        sizeT,          //  ten-byte
        sizeS           //  sword
        };

//  mapping from operand token to operand type (class and opt. value)

typedef struct tagOPNDTYPE {
        UCHAR   type;
        UCHAR   size;
        } OPNDTYPE, *POPNDTYPE;

typedef struct tagASM_VALUE {
        ULONG   value;
        USHORT  segment;
        UCHAR   reloc;
        UCHAR   size;
        UCHAR   flags;
        UCHAR   segovr;
        UCHAR   index;
        UCHAR   base;
        UCHAR   scale;
        } ASM_VALUE, *PASM_VALUE;

//  bit values of flags in ASM_VALUE
//      flags are mutually exclusive

#define fREG    0x80            //  set if register
#define fIMM    0x40            //  set if immediate
#define fFPTR   0x20            //  set if far ptr
#define fPTR    0x10            //  set if memory ptr (no reg index)
#define fPTR16  0x08            //  set if memory ptr with 16-bit reg index
#define fPTR32  0x04            //  set if memory ptr with 32-bit reg index
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\i386_asmexp.cpp ===
//----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1991-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

#include "i386_asm.h"

UCHAR   PeekAsmChar(void);
ULONG   PeekAsmToken(PULONG);
void    AcceptAsmToken(void);
ULONG   GetAsmToken(PULONG);
ULONG   NextAsmToken(PULONG);
ULONG   GetAsmReg(PUCHAR, PULONG);

void    GetAsmOperand(PASM_VALUE);
void    GetAsmExpr(PASM_VALUE, UCHAR);
void    GetAsmOrTerm(PASM_VALUE, UCHAR);
void    GetAsmAndTerm(PASM_VALUE, UCHAR);
void    GetAsmNotTerm(PASM_VALUE, UCHAR);
void    GetAsmRelTerm(PASM_VALUE, UCHAR);
void    GetAsmAddTerm(PASM_VALUE, UCHAR);
void    GetAsmMulTerm(PASM_VALUE, UCHAR);
void    GetAsmSignTerm(PASM_VALUE, UCHAR);
void    GetAsmByteTerm(PASM_VALUE, UCHAR);
void    GetAsmOffTerm(PASM_VALUE, UCHAR);
void    GetAsmColnTerm(PASM_VALUE, UCHAR);
void    GetAsmDotTerm(PASM_VALUE, UCHAR);
void    GetAsmIndxTerm(PASM_VALUE, UCHAR);
void    AddAsmValues(PASM_VALUE, PASM_VALUE);
void    SwapPavs(PASM_VALUE, PASM_VALUE);

extern  PUCHAR pchAsmLine;

struct _AsmRes {
    PCHAR    pchRes;
    ULONG    valueRes;
    } AsmReserved[] = {
        { "mod",    ASM_MULOP_MOD },
        { "shl",    ASM_MULOP_SHL },
        { "shr",    ASM_MULOP_SHR },
        { "and",    ASM_ANDOP_CLASS },
        { "not",    ASM_NOTOP_CLASS },
        { "or",     ASM_OROP_OR },
        { "xor",    ASM_OROP_XOR },
        { "eq",     ASM_RELOP_EQ },
        { "ne",     ASM_RELOP_NE },
        { "le",     ASM_RELOP_LE },
        { "lt",     ASM_RELOP_LT },
        { "ge",     ASM_RELOP_GE },
        { "gt",     ASM_RELOP_GT },
        { "by",     ASM_UNOP_BY },
        { "wo",     ASM_UNOP_WO },
        { "dw",     ASM_UNOP_DW },
        { "poi",    ASM_UNOP_POI },
        { "low",    ASM_LOWOP_LOW },
        { "high",   ASM_LOWOP_HIGH },
        { "offset", ASM_OFFOP_CLASS },
        { "ptr",    ASM_PTROP_CLASS },
        { "byte",   ASM_SIZE_BYTE },
        { "word",   ASM_SIZE_WORD },
        { "dword",  ASM_SIZE_DWORD },
        { "fword",  ASM_SIZE_FWORD },
        { "qword",  ASM_SIZE_QWORD },
        { "tbyte",  ASM_SIZE_TBYTE }
        };

#define RESERVESIZE (sizeof(AsmReserved) / sizeof(struct _AsmRes))

UCHAR regSize[] = {
        sizeB,          //  byte
        sizeW,          //  word
        sizeD,          //  dword
        sizeW,          //  segment
        sizeD,          //  control
        sizeD,          //  debug
        sizeD,          //  trace
        sizeT,          //  float
        sizeT           //  float with index
        };

UCHAR regType[] = {
        regG,           //  byte - general
        regG,           //  word - general
        regG,           //  dword - general
        regS,           //  segment
        regC,           //  control
        regD,           //  debug
        regT,           //  trace
        regF,           //  float (st)
        regI            //  float-index (st(n))
        };

UCHAR tabWordReg[8] = {         //  rm value
        (UCHAR)-1,              //  AX - error
        (UCHAR)-1,              //  CX - error
        (UCHAR)-1,              //  DX - error
        7,                      //  BX - 111
        (UCHAR)-1,              //  SP - error
        6,                      //  BP - 110
        4,                      //  SI - 100
        5,                      //  DI - 101
        };

UCHAR rm16Table[16] = {         //  new rm         left rm      right rm
        (UCHAR)-1,              //  error          100 = [SI]   100 = [SI]
        (UCHAR)-1,              //  error          100 = [SI]   101 = [DI]
        2,                      //  010 = [BP+SI]  100 = [SI]   110 = [BP]
        0,                      //  000 = [BX+SI]  100 = [SI]   111 = [BX]
        (UCHAR)-1,              //  error          101 = [DI]   100 = [SI]
        (UCHAR)-1,              //  error          101 = [DI]   101 = [DI]
        3,                      //  011 = [BP+DI]  101 = [DI]   110 = [BP]
        1,                      //  001 = [BX+DI]  101 = [DI]   111 = [BX]
        2,                      //  010 = [BP+SI]  110 = [BP]   100 = [SI]
        3,                      //  011 = [BP+DI]  110 = [BP]   101 = [DI]
        (UCHAR)-1,              //  error          110 = [BP]   110 = [BP]
        (UCHAR)-1,              //  error          110 = [BP]   111 = [BX]
        0,                      //  000 = [BX+SI]  111 = [BX]   100 = [SI]
        1,                      //  001 = [BX+DI]  111 = [BX]   101 = [DI]
        (UCHAR)-1,              //  error          111 = [BX]   110 = [BP]
        (UCHAR)-1               //  error          111 = [BX]   111 = [BX]
        };

PUCHAR  savedpchAsmLine;
ULONG   savedAsmClass;
ULONG   savedAsmValue;

/*** PeekAsmChar - peek the next non-white-space character
*
*   Purpose:
*       Return the next non-white-space character and update
*       pchAsmLine to point to it.
*
*   Input:
*       pchAsmLine - present command line position.
*
*   Returns:
*       next non-white-space character
*
*************************************************************************/

UCHAR PeekAsmChar (void)
{
    UCHAR    ch;

    do
        ch = *pchAsmLine++;
    while (ch == ' ' || ch == '\t');
    pchAsmLine--;

    return ch;
}

/*** PeekAsmToken - peek the next command line token
*
*   Purpose:
*       Return the next command line token, but do not advance
*       the pchAsmLine pointer.
*
*   Input:
*       pchAsmLine - present command line position.
*
*   Output:
*       *pvalue - optional value of token
*   Returns:
*       class of token
*
*   Notes:
*       savedAsmClass, savedAsmValue, and savedpchAsmLine saves the
*           token getting state for future peeks.
*       To get the next token, a GetAsmToken or AcceptAsmToken call
*           must first be made.
*
*************************************************************************/

ULONG PeekAsmToken (PULONG pvalue)
{
    UCHAR   *pchTemp;

    //  Get next class and value, but do not
    //  move pchAsmLine, but save it in savedpchAsmLine.
    //  Do not report any error condition.

    if (savedAsmClass == (ULONG)-1) {
        pchTemp = pchAsmLine;
        savedAsmClass = NextAsmToken(&savedAsmValue);
        savedpchAsmLine = pchAsmLine;
        pchAsmLine = pchTemp;
        }
    *pvalue = savedAsmValue;
    return savedAsmClass;
}

/*** AcceptAsmToken - accept any peeked token
*
*   Purpose:
*       To reset the PeekAsmToken saved variables so the next PeekAsmToken
*       will get the next token in the command line.
*
*   Input:
*       None.
*
*   Output:
*       None.
*
*************************************************************************/

void AcceptAsmToken (void)
{
    savedAsmClass = (ULONG)-1;
    pchAsmLine = savedpchAsmLine;
}

/*** GetAsmToken - peek and accept the next token
*
*   Purpose:
*       Combines the functionality of PeekAsmToken and AcceptAsmToken
*       to return the class and optional value of the next token
*       as well as updating the command pointer pchAsmLine.
*
*   Input:
*       pchAsmLine - present command string pointer
*
*   Output:
*       *pvalue - pointer to the token value optionally set.
*   Returns:
*       class of the token read.
*
*   Notes:
*       An illegal token returns the value of ERROR_CLASS with *pvalue
*       being the error number, but produces no actual error.
*
*************************************************************************/

ULONG GetAsmToken (PULONG pvalue)
{
    ULONG   opclass;

    if (savedAsmClass != (ULONG)-1) {
        opclass = savedAsmClass;
        savedAsmClass = (ULONG)-1;
        *pvalue = savedAsmValue;
        pchAsmLine = savedpchAsmLine;
        }
    else
        opclass = NextAsmToken(pvalue);

    if (opclass == ASM_ERROR_CLASS)
        error(*pvalue);

    return opclass;
}

/*** NextAsmToken - process the next token
*
*   Purpose:
*       Parse the next token from the present command string.
*       After skipping any leading white space, first check for
*       any single character tokens or register variables.  If
*       no match, then parse for a number or variable.  If a
*       possible variable, check the reserved word list for operators.
*
*   Input:
*       pchAsmLine - pointer to present command string
*
*   Output:
*       *pvalue - optional value of token returned
*       pchAsmLine - updated to point past processed token
*   Returns:
*       class of token returned
*
*   Notes:
*       An illegal token returns the value of ERROR_CLASS with *pvalue
*       being the error number, but produces no actual error.
*
*************************************************************************/

ULONG NextAsmToken (PULONG pvalue)
{
    ULONG    base;
    UCHAR    chSymbol[MAX_SYMBOL_LEN];
    UCHAR    chPreSym[9];
    ULONG    cbSymbol = 0;
    UCHAR    fNumber = TRUE;
    UCHAR    fSymbol = TRUE;
    UCHAR    fForceReg = FALSE;
    ULONG    errNumber = 0;
    UCHAR    ch;
    UCHAR    chlow;
    UCHAR    chtemp;
    UCHAR    limit1 = '9';
    UCHAR    limit2 = '9';
    UCHAR    fDigit = FALSE;
    ULONG    value = 0;
    ULONG    tmpvalue;
    ULONG    index;
    PDEBUG_IMAGE_INFO pImage;
    ULONG64  value64;

    base = g_DefaultRadix;

    //  skip leading white space

    ch = PeekAsmChar();
    chlow = (UCHAR)tolower(ch);
    pchAsmLine++;

    //  test for special character operators and register variable

    switch (chlow) {
        case '\0':
            pchAsmLine--;
            return ASM_EOL_CLASS;
        case ',':
            return ASM_COMMA_CLASS;
        case '+':
            *pvalue = ASM_ADDOP_PLUS;
            return ASM_ADDOP_CLASS;
        case '-':
            *pvalue = ASM_ADDOP_MINUS;
            return ASM_ADDOP_CLASS;
        case '*':
            *pvalue = ASM_MULOP_MULT;
            return ASM_MULOP_CLASS;
        case '/':
            *pvalue = ASM_MULOP_DIVIDE;
            return ASM_MULOP_CLASS;
        case ':':
            return ASM_COLNOP_CLASS;
        case '(':
            return ASM_LPAREN_CLASS;
        case ')':
            return ASM_RPAREN_CLASS;
        case '[':
            return ASM_LBRACK_CLASS;
        case ']':
            return ASM_RBRACK_CLASS;
        case '@':
            fForceReg = TRUE;
            chlow = (UCHAR)tolower(*pchAsmLine); pchAsmLine++;
            break;
        case '.':
            return ASM_DOTOP_CLASS;
        case '\'':
            for (index = 0; index < 5; index++) {
                ch = *pchAsmLine++;
                if (ch == '\'' || ch == '\0')
                    break;
                value = (value << 8) + (ULONG)ch;
                }
            if (ch == '\0' || index == 0 || index == 5) {
                pchAsmLine--;
                *pvalue = SYNTAX;
                return ASM_ERROR_CLASS;
                }
            pchAsmLine++;
            *pvalue = value;
            return ASM_NUMBER_CLASS;
        }

    //  if first character is a decimal digit, it cannot
    //  be a symbol.  leading '0' implies octal, except
    //  a leading '0x' implies hexadecimal.

    if (chlow >= '0' && chlow <= '9') {
        if (fForceReg) {
            *pvalue = SYNTAX;
            return ASM_ERROR_CLASS;
            }
        fSymbol = FALSE;
        if (chlow == '0') {
            ch = *pchAsmLine++;
            chlow = (UCHAR)tolower(ch);
            if (chlow == 'x') {
                base = 16;
                ch = *pchAsmLine++;
                chlow = (UCHAR)tolower(ch);
                }
            else if (chlow == 'n') {
                base = 10;
                ch = *pchAsmLine++;
                chlow = (UCHAR)tolower(ch);
                }
            else {
                base = 8;
                fDigit = TRUE;
                }
            }
        }

    //  a number can start with a letter only if base is
    //  hexadecimal and it is a hexadecimal digit 'a'-'f'.

    else if ((chlow < 'a' && chlow > 'f') || base != 16)
        fNumber = FALSE;

    //  set limit characters for the appropriate base.

    if (base == 8)
        limit1 = '7';
    if (base == 16)
        limit2 = 'f';

    //  perform processing while character is a letter,
    //  digit, or underscore.

    while ((chlow >= 'a' && chlow <= 'z') ||
           (chlow >= '0' && chlow <= '9') || (chlow == '_')) {

        //  if possible number, test if within proper range,
        //  and if so, accumulate sum.

        if (fNumber) {
            if ((chlow >= '0' && chlow <= limit1) ||
                    (chlow >= 'a' && chlow <= limit2)) {
                fDigit = TRUE;
                tmpvalue = value * base;
                if (tmpvalue < value)
                    errNumber = OVERFLOW;
                chtemp = (UCHAR)(chlow - '0');
                if (chtemp > 9)
                    chtemp -= 'a' - '0' - 10;
                value = tmpvalue + (ULONG)chtemp;
                if (value < tmpvalue)
                    errNumber = OVERFLOW;
                }
            else {
                fNumber = FALSE;
                errNumber = SYNTAX;
                }
            }
        if (fSymbol) {
            if (cbSymbol < 9)
                chPreSym[cbSymbol] = chlow;
            if (cbSymbol < MAX_SYMBOL_LEN - 1)
                chSymbol[cbSymbol++] = ch;
            }
        ch = *pchAsmLine++;
        chlow = (UCHAR)tolower(ch);
        }

    //  back up pointer to first character after token.

    pchAsmLine--;

    if (cbSymbol < 9)
        chPreSym[cbSymbol] = '\0';

    //  if fForceReg, check for register name and return
    //      success or failure

    if (fForceReg)
        if ((index = GetAsmReg(chPreSym, pvalue)) != 0) {
            if (index == ASM_REG_SEGMENT)
                if (PeekAsmChar() == ':') {
                    pchAsmLine++;
                    index = ASM_SEGOVR_CLASS;
                    }
            return index;               //  class type returned by GetAsmReg
            }
        else {
            *pvalue = BADREG;
            return ASM_ERROR_CLASS;
            }

    //  next test for reserved word and symbol string

    if (fSymbol) {

        //  if possible symbol, check lowercase string in chPreSym
        //  for text operator or register name.
        //  otherwise, return symbol value from name in chSymbol.

        for (index = 0; index < RESERVESIZE; index++)
            if (!strcmp((PSTR)chPreSym, AsmReserved[index].pchRes)) {
                *pvalue = AsmReserved[index].valueRes;
                return AsmReserved[index].valueRes & ASM_CLASS_MASK;
                }

        //  start processing string as symbol

        chSymbol[cbSymbol] = '\0';

        //  test if symbol is a module name (with '!' after it)
        //  if so, get next token and treat as symbol

        pImage = GetImageByName(g_CurrentProcess, (PSTR)chSymbol,
                                INAME_MODULE);
        if (pImage && (ch = PeekAsmChar()) == '!') {
            pchAsmLine++;
            ch = PeekAsmChar();
            pchAsmLine++;
            cbSymbol = 0;
            while ((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') ||
                   (ch >= '0' && ch <= '9') || (ch == '_')) {
                chSymbol[cbSymbol++] = ch;
                ch = *pchAsmLine++;
            }
            chSymbol[cbSymbol] = '\0';
            pchAsmLine--;
        }

        if (GetOffsetFromSym((PSTR)chSymbol, &value64, NULL)) {
            *pvalue = (ULONG)value64;
            return ASM_SYMBOL_CLASS;
        }

        //  symbol is undefined.
        //  if a possible hex number, do not set the error type

        if (!fNumber)
            errNumber = VARDEF;
        }

    //  if possible number and no error, return the number

    if (fNumber && !errNumber) {
        if (fDigit) {

            //  check for possible segment specification
            //          "<16-bit number>:"

            if (PeekAsmChar() == ':') {
                pchAsmLine++;
                if (value > 0xffff)
                    error(BADSEG);
                *pvalue = value;
                return ASM_SEGMENT_CLASS;
                }

            *pvalue = value;
            return ASM_NUMBER_CLASS;
            }
        else
            errNumber = SYNTAX;
        }

    //  last chance, undefined symbol and illegal number,
    //      so test for register, will handle old format

    if ((index = GetAsmReg(chPreSym, pvalue)) != 0) {
        if (index == ASM_REG_SEGMENT)
            if (PeekAsmChar() == ':') {
                pchAsmLine++;
                index = ASM_SEGOVR_CLASS;
                }
        return index;           //  class type returned by GetAsmReg
        }

    *pvalue = (ULONG) errNumber;
    return ASM_ERROR_CLASS;
}

ULONG GetAsmReg (PUCHAR pSymbol, PULONG pValue)
{
    static UCHAR vRegList[] = "axcxdxbxspbpsidi";
    static UCHAR bRegList[] = "alcldlblahchdhbh";
    static UCHAR sRegList[] = "ecsdfg";         //  second char is 's'
                                                //  same order as seg enum

    ULONG       index;
    UCHAR       ch0 = *pSymbol;
    UCHAR       ch1 = *(pSymbol + 1);
    UCHAR       ch2 = *(pSymbol + 2);
    UCHAR       ch3 = *(pSymbol + 3);

    //  only test strings with two or three characters

    if (ch0 && ch1) {
        if (ch2 == '\0') {

            //  symbol has two characters, first test for 16-bit register

            for (index = 0; index < 8; index++)
                if (*(PUSHORT)pSymbol == *((PUSHORT)vRegList + index)) {
                    *pValue = index;
                    return ASM_REG_WORD;
                    }

            //  next test for 8-bit register

            for (index = 0; index < 8; index++)
                if (*(PUSHORT)pSymbol == *((PUSHORT)bRegList + index)) {
                    *pValue = index;
                    return ASM_REG_BYTE;
                    }

            //  test for segment register

            if (ch1 == 's')
                for (index = 0; index < 6; index++)
                    if (ch0 == *(sRegList + index)) {
                        *pValue = index + 1;    //  list offset is 1
                        return ASM_REG_SEGMENT;
                        }

            //  finally test for floating register "st" or "st(n)"
            //  parse the arg here as '(', <octal value>, ')'
            //  return value for "st" is REG_FLOAT,
            //     for "st(n)" is REG_INDFLT with value 0-7

            if (ch0 == 's' && ch1 == 't') {
                if (PeekAsmChar() != '(')
                    return ASM_REG_FLOAT;
                else {
                    pchAsmLine++;
                    index = (ULONG)(PeekAsmChar() - '0');
                    if (index < 8) {
                        pchAsmLine++;
                        if (PeekAsmChar() == ')') {
                            pchAsmLine++;
                            *pValue = index;
                            return ASM_REG_INDFLT;
                            }
                        }
                    }
                }
            }

        else if (ch3 == '\0') {

            //  if three-letter symbol, test for leading 'e' and
            //  second and third character being in the 16-bit list

            if (ch0 == 'e') {
                for (index = 0; index < 8; index++)
                    if (*(UNALIGNED USHORT *)(pSymbol + 1) ==
                                        *((PUSHORT)vRegList + index)) {
                        *pValue = index;
                        return ASM_REG_DWORD;
                        }
                }

            //  test for control, debug, and test registers

            else if (ch1 == 'r') {
                ch2 -= '0';
                *pValue = ch2;

                //  legal control registers are CR0, CR2, CR3, CR4

                if (ch0 == 'c') {
                    if (ch2 >= 0 && ch2 <= 4)
                        return ASM_REG_CONTROL;
                    }

                //  legal debug registers are DR0 - DR3, DR6, DR7

                else if (ch0 == 'd') {
                    if (ch2 <= 3 || ch2 == 6 || ch2 == 7)
                        return ASM_REG_DEBUG;
                    }

                //  legal trace registers are TR3 - TR7

                else if (ch0 == 't') {
                    if (ch2 >= 3 && ch2 <= 7)
                        return ASM_REG_TRACE;
                    }
                }
            }
        }
    return 0;
}

//      Operand parser - recursive descent
//
//      Grammar productions:
//
//      <Operand>  ::= <register> | <Expr>
//      <Expr>     ::= <orTerm> [(XOR | OR) <orTerm>]*
//      <orTerm>   ::= <andTerm> [AND <andTerm>]*
//      <andTerm>  ::= [NOT]* <notTerm>
//      <notTerm>  ::= <relTerm> [(EQ | NE | GE | GT | LE | LT) <relTerm>]*
//      <relTerm>  ::= <addTerm> [(- | +) <addTerm>]*
//      <addTerm>  ::= <mulTerm> [(* | / | MOD | SHL | SHR) <mulTerm>]*
//      <mulTerm>  ::= [(- | +)]* <signTerm>
//      <signTerm> ::= [(HIGH | LOW)]* <byteTerm>
//      <byteTerm> ::= [(OFFSET | <type> PTR)]* <offTerm>
//      <offTerm>  ::= [<segovr>] <colnTerm>
//      <colnTerm> ::= <dotTerm> [.<dotTerm>]*
//      <dotTerm>  ::= <indxTerm> ['['<Expr>']']*
//      <indxTerm> ::= <index-reg> | <symbol> | <number> | '('<Expr>')'
//                                                       | '['<Expr>']'

//      <Operand>  ::= <register> | <Expr>

void GetAsmOperand (PASM_VALUE pavExpr)
{
    ULONG   tokenvalue;
    ULONG   classvalue;

    classvalue = PeekAsmToken(&tokenvalue);
    if ((classvalue & ASM_CLASS_MASK) == ASM_REG_CLASS) {
        AcceptAsmToken();
        classvalue &= ASM_TYPE_MASK;
        pavExpr->flags = fREG;
        pavExpr->base = (UCHAR)tokenvalue;      //  index within reg group
        pavExpr->index = regType[classvalue - 1];
        pavExpr->size = regSize[classvalue - 1];
        }
    else {
        GetAsmExpr(pavExpr, FALSE);
        if (pavExpr->reloc > 1)         //  only 0 and 1 are allowed
            error(OPERAND);
        }
}

//      <Expr> ::=  <orTerm> [(XOR | OR) <orTerm>]*

void GetAsmExpr (PASM_VALUE pavValue, UCHAR fBracket)
{
    ULONG   tokenvalue;
    ASM_VALUE avTerm;

dprintf("enter GetAsmExpr\n");
    GetAsmOrTerm(pavValue, fBracket);
    while (PeekAsmToken(&tokenvalue) == ASM_OROP_CLASS) {
        AcceptAsmToken();
        GetAsmOrTerm(&avTerm, fBracket);
        if (!(pavValue->flags & avTerm.flags & fIMM))
            error(OPERAND);
        if (tokenvalue == ASM_OROP_OR)
            pavValue->value |= avTerm.value;
        else
            pavValue->value ^= avTerm.value;
        }
dprintf("exit  GetAsmExpr with %lx\n", pavValue->value);
}

//      <orTerm> ::=  <andTerm> [AND <andTerm>]*

void GetAsmOrTerm (PASM_VALUE pavValue, UCHAR fBracket)
{
    ULONG   tokenvalue;
    ASM_VALUE avTerm;

dprintf("enter GetAsmOrTerm\n");
    GetAsmAndTerm(pavValue, fBracket);
    while (PeekAsmToken(&tokenvalue) == ASM_ANDOP_CLASS) {
        AcceptAsmToken();
        GetAsmAndTerm(&avTerm, fBracket);
        if (!(pavValue->flags & avTerm.flags & fIMM))
            error(OPERAND);
        pavValue->value &= avTerm.value;
        }
dprintf("exit  GetAsmOrTerm with %lx\n", pavValue->value);
}

//      <andTerm> ::= [NOT]* <notTerm>

void GetAsmAndTerm (PASM_VALUE pavValue, UCHAR fBracket)
{
    ULONG   tokenvalue;

dprintf("enter GetAsmAndTerm\n");
    if (PeekAsmToken(&tokenvalue) == ASM_NOTOP_CLASS) {
        AcceptAsmToken();
        GetAsmAndTerm(pavValue, fBracket);
        if (!(pavValue->flags & fIMM))
            error(OPERAND);
        pavValue->value = ~pavValue->value;
        }
    else
        GetAsmNotTerm(pavValue, fBracket);
dprintf("exit  GetAsmAndTerm with %lx\n", pavValue->value);
}

//      <notTerm> ::= <relTerm> [(EQ | NE | GE | GT | LE | LT) <relTerm>]*

void GetAsmNotTerm (PASM_VALUE pavValue, UCHAR fBracket)
{
    ULONG   tokenvalue;
    ULONG   fTest;
    ULONG   fAddress;
    ASM_VALUE avTerm;

dprintf("enter GetAsmNotTerm\n");
    GetAsmRelTerm(pavValue, fBracket);
    while (PeekAsmToken(&tokenvalue) == ASM_RELOP_CLASS) {
        AcceptAsmToken();
        GetAsmRelTerm(&avTerm, fBracket);
        if (!(pavValue->flags & avTerm.flags & fIMM) ||
                pavValue->reloc > 1 || avTerm.reloc > 1)
            error(OPERAND);
        fAddress = pavValue->reloc | avTerm.reloc;
        switch (tokenvalue) {
            case ASM_RELOP_EQ:
                fTest = pavValue->value == avTerm.value;
                break;
            case ASM_RELOP_NE:
                fTest = pavValue->value != avTerm.value;
                break;
            case ASM_RELOP_GE:
                if (fAddress)
                    fTest = pavValue->value >= avTerm.value;
                else
                    fTest = (LONG)pavValue->value >= (LONG)avTerm.value;
                break;
            case ASM_RELOP_GT:
                if (fAddress)
                    fTest = pavValue->value > avTerm.value;
                else
                    fTest = (LONG)pavValue->value > (LONG)avTerm.value;
                break;
            case ASM_RELOP_LE:
                if (fAddress)
                    fTest = pavValue->value <= avTerm.value;
                else
                    fTest = (LONG)pavValue->value <= (LONG)avTerm.value;
                break;
            case ASM_RELOP_LT:
                if (fAddress)
                    fTest = pavValue->value < avTerm.value;
                else
                    fTest = (LONG)pavValue->value < (LONG)avTerm.value;
                break;
            default:
                printf("bad RELOP type\n");
            }
        pavValue->value = (ULONG)(-((LONG)fTest));       //  FALSE = 0; TRUE = -1
        pavValue->reloc = 0;
        pavValue->size = sizeB;         //  immediate value is byte
        }
dprintf("exit  GetAsmNotTerm with %lx\n", pavValue->value);
}

//      <relTerm> ::= <addTerm> [(- | +) <addTerm>]*

void GetAsmRelTerm (PASM_VALUE pavValue, UCHAR fBracket)
{
    ULONG   tokenvalue;
    ASM_VALUE avTerm;

dprintf("enter GetAsmRelTerm\n");
    GetAsmAddTerm(pavValue, fBracket);
    while (PeekAsmToken(&tokenvalue) == ASM_ADDOP_CLASS) {
        AcceptAsmToken();
        GetAsmAddTerm(&avTerm, fBracket);
        if (tokenvalue == ASM_ADDOP_MINUS) {
            if (!(avTerm.flags & (fIMM | fPTR)))
                error(OPERAND);
            avTerm.value = (ULONG)(-((LONG)avTerm.value));
            avTerm.reloc = (UCHAR)(-avTerm.reloc);
            }
        AddAsmValues(pavValue, &avTerm);
        }
dprintf("exit  GetAsmRelTerm with %lx\n", pavValue->value);
}

//      <addTerm> ::= <mulTerm> [(* | / | MOD | SHL | SHR) <mulTerm>]*

void GetAsmAddTerm (PASM_VALUE pavValue, UCHAR fBracket)
{
    ULONG   tokenvalue;
    ASM_VALUE avTerm;

dprintf("enter GetAsmAddTerm\n");
    GetAsmMulTerm(pavValue, fBracket);
    while (PeekAsmToken(&tokenvalue) == ASM_MULOP_CLASS) {
        AcceptAsmToken();
        GetAsmMulTerm(&avTerm, fBracket);

        if (tokenvalue == ASM_MULOP_MULT) {
            if (pavValue->flags & fIMM)
                SwapPavs(pavValue, &avTerm);
            if (!(avTerm.flags & fIMM))
                error(OPERAND);
            if (pavValue->flags & fIMM)
                pavValue->value *= avTerm.value;
            else if ((pavValue->flags & fPTR32)
                        && pavValue->value == 0
                        && pavValue->base != indSP
                        && pavValue->index == 0xff) {
                pavValue->index = pavValue->base;
                pavValue->base = 0xff;
                pavValue->scale = 0xff;
                if (avTerm.value == 1)
                    pavValue->scale = 0;
                if (avTerm.value == 2)
                    pavValue->scale = 1;
                if (avTerm.value == 4)
                    pavValue->scale = 2;
                if (avTerm.value == 8)
                    pavValue->scale = 3;
                if (pavValue->scale == 0xff)
                    error(OPERAND);
                }
            else
                error(OPERAND);
            }
        else if (!(pavValue->flags & avTerm.flags & fIMM))
            error(OPERAND);
        else if (tokenvalue == ASM_MULOP_DIVIDE
                         || tokenvalue == ASM_MULOP_MOD) {
            if (avTerm.value == 0)
                error(DIVIDE);
            if (tokenvalue == ASM_MULOP_DIVIDE)
                pavValue->value /= avTerm.value;
            else
                pavValue->value %= avTerm.value;
            }
        else if (tokenvalue == ASM_MULOP_SHL)
            pavValue->value <<= avTerm.value;
        else
            pavValue->value >>= avTerm.value;
        }
dprintf("exit  GetAsmAddTerm with %lx\n", pavValue->value);
}

//      <mulTerm> ::= [(- | +)]* <signTerm>

void GetAsmMulTerm (PASM_VALUE pavValue, UCHAR fBracket)
{
    ULONG   tokenvalue;

dprintf("enter GetAsmMulTerm\n");
    if (PeekAsmToken(&tokenvalue) == ASM_ADDOP_CLASS) { //  BY WO DW POI UNDN
        AcceptAsmToken();
        GetAsmMulTerm(pavValue, fBracket);
        if (tokenvalue == ASM_ADDOP_MINUS) {
            if (!(pavValue->flags & (fIMM | fPTR)))
                error(OPERAND);
            pavValue->value = (ULONG)(-((LONG)pavValue->value));
            pavValue->reloc = (UCHAR)(-pavValue->reloc);
            }
        }
    else
        GetAsmSignTerm(pavValue, fBracket);
dprintf("exit  GetAsmMulTerm with %lx\n", pavValue->value);
}

//      <signTerm> ::= [(HIGH | LOW)]* <byteTerm>

void GetAsmSignTerm (PASM_VALUE pavValue, UCHAR fBracket)
{
    ULONG   tokenvalue;

dprintf("enter GetAsmSignTerm\n");
    if (PeekAsmToken(&tokenvalue) == ASM_LOWOP_CLASS) {
        AcceptAsmToken();
        GetAsmSignTerm(pavValue, fBracket);
        if (!(pavValue->flags & (fIMM | fPTR)))
            error(OPERAND);
        if (tokenvalue == ASM_LOWOP_LOW)
            pavValue->value = pavValue->value & 0xff;
        else
            pavValue->value = (pavValue->value & ~0xff) >> 8;
        pavValue->flags = fIMM;         //  make an immediate value
        pavValue->reloc = 0;
        pavValue->segment = segX;
        pavValue->size = sizeB;         //  byte value
        }
    else
        GetAsmByteTerm(pavValue, fBracket);
dprintf("exit  GetAsmSignTerm with %lx\n", pavValue->value);
}

//      <byteTerm> ::= [(OFFSET | <size> PTR)]* <offTerm>

void GetAsmByteTerm (PASM_VALUE pavValue, UCHAR fBracket)
{
    ULONG   tokenvalue;
    ULONG   classvalue;

dprintf("enter GetAsmByteTerm\n");
    classvalue = PeekAsmToken(&tokenvalue);
    if (classvalue == ASM_OFFOP_CLASS) {
        AcceptAsmToken();
        GetAsmByteTerm(pavValue, fBracket);
        if (!(pavValue->flags & (fIMM | fPTR)) || pavValue->reloc > 1)
            error(OPERAND);
        pavValue->flags = fIMM;         //  make offset an immediate value
        pavValue->reloc = 0;
        pavValue->size = sizeX;
        pavValue->segment = segX;
        }
    else if (classvalue == ASM_SIZE_CLASS) {
        AcceptAsmToken();
        if (GetAsmToken(&classvalue) != ASM_PTROP_CLASS)    //  dummy token
            error(SYNTAX);
        GetAsmByteTerm(pavValue, fBracket);
        if (!(pavValue->flags & (fIMM | fPTR | fPTR16 | fPTR32))
                || pavValue->reloc > 1
                || pavValue->size != sizeX)
            error(OPERAND);
        pavValue->reloc = 1;            // make ptr a relocatable value
        if (pavValue->flags & fIMM)
            pavValue->flags = fPTR;
        pavValue->size = (UCHAR)(tokenvalue & ASM_TYPE_MASK);
                                                //  value has "size?"
        }
    else
        GetAsmOffTerm(pavValue, fBracket);
dprintf("exit  GetAsmByteTerm with %lx\n", pavValue->value);
}

//      <offTerm>  ::= [<segovr>] <colnTerm>

void GetAsmOffTerm (PASM_VALUE pavValue, UCHAR fBracket)
{
    ULONG   classvalue;
    ULONG   tokenvalue;

dprintf("enter GetAsmOffTerm\n");
    classvalue = PeekAsmToken(&tokenvalue);
    if (classvalue == ASM_SEGOVR_CLASS || classvalue == ASM_SEGMENT_CLASS) {
        if (fBracket)
            error(SYNTAX);
        AcceptAsmToken();
        }
    GetAsmColnTerm(pavValue, fBracket);
    if (classvalue == ASM_SEGOVR_CLASS) {
        if (pavValue->reloc > 1 || pavValue->segovr != segX)
            error(OPERAND);
        pavValue->reloc = 1;            //  make ptr a relocatable value
        if (pavValue->flags & fIMM)
            pavValue->flags = fPTR;
        pavValue->segovr = (UCHAR)tokenvalue;   //  has segment override
        }
    else if (classvalue == ASM_SEGMENT_CLASS) {
        if (!(pavValue->flags & fIMM) || pavValue->reloc > 1)
            error(OPERAND);
        pavValue->segment = (USHORT)tokenvalue; //  segment has segment value
        pavValue->flags = fFPTR;        //  set flag for far pointer
        }
dprintf("exit  GetAsmOffTerm with %lx\n", pavValue->value);
}

//      <colnTerm> ::= <dotTerm> [.<dotTerm>]*

void GetAsmColnTerm (PASM_VALUE pavValue, UCHAR fBracket)
{
    ULONG   tokenvalue;
    ASM_VALUE avTerm;

dprintf("enter GetAsmColnTerm\n");
    GetAsmDotTerm(pavValue, fBracket);
    while (PeekAsmToken(&tokenvalue) == ASM_DOTOP_CLASS) {
        AcceptAsmToken();
        GetAsmDotTerm(&avTerm, fBracket);
        AddAsmValues(pavValue, &avTerm);
        }
dprintf("exit  GetAsmColnTerm with %lx\n", pavValue->value);
}

//      <dotTerm>  ::= <indxTerm> ['['<Expr>']']*

void GetAsmDotTerm (PASM_VALUE pavValue, UCHAR fBracket)
{
    ULONG   tokenvalue;
    ASM_VALUE avExpr;

dprintf("enter GetAsmDotTerm\n");
    GetAsmIndxTerm(pavValue, fBracket);
    if (pavValue->reloc > 1)
        error(OPERAND);
    while (PeekAsmToken(&tokenvalue) == ASM_LBRACK_CLASS) {
        AcceptAsmToken();
        if (fBracket)
            error(SYNTAX);
        GetAsmExpr(&avExpr, TRUE);
        AddAsmValues(pavValue, &avExpr);
        if (GetAsmToken(&tokenvalue) != ASM_RBRACK_CLASS)
            error(SYNTAX);
        if (pavValue->flags & fIMM)
            pavValue->flags = fPTR;
        }
dprintf("exit  GetAsmDotTerm with %lx\n", pavValue->value);
}

//      <indxTerm> ::= <index-reg> | <symbol> | <number> | '('<Expr>')'
//                                                       | '['<Expr>']'

void GetAsmIndxTerm (PASM_VALUE pavValue, UCHAR fBracket)
{
    ULONG   tokenvalue;
    ULONG   classvalue;

dprintf("enter GetAsmIndxTerm\n");
    classvalue = GetAsmToken(&tokenvalue);
    pavValue->segovr = segX;
    pavValue->size = sizeX;
    pavValue->reloc = 0;
    pavValue->value = 0;
    if (classvalue == ASM_LPAREN_CLASS) {
        GetAsmExpr(pavValue, fBracket);
        if (GetAsmToken(&tokenvalue) != ASM_RPAREN_CLASS)
            error(SYNTAX);
        }
    else if (classvalue == ASM_LBRACK_CLASS) {
        if (fBracket)
            error(SYNTAX);
        GetAsmExpr(pavValue, TRUE);
        if (GetAsmToken(&tokenvalue) != ASM_RBRACK_CLASS)
            error(SYNTAX);
        if (pavValue->flags == fIMM)
            pavValue->flags = fPTR;
        }
    else if (classvalue == ASM_SYMBOL_CLASS) {
        pavValue->value = tokenvalue;
        pavValue->flags = fIMM;
        pavValue->reloc = 1;
        }
    else if (classvalue == ASM_NUMBER_CLASS) {
        pavValue->value = tokenvalue;
        pavValue->flags = fIMM;
        }
    else if (classvalue == ASM_REG_WORD) {
        if (!fBracket)
            error(SYNTAX);
        pavValue->flags = fPTR16;
        pavValue->base = tabWordReg[tokenvalue];
        if (pavValue->base == 0xff)
            error(OPERAND);
        }
    else if (classvalue == ASM_REG_DWORD) {
        if (!fBracket)
            error(SYNTAX);
        pavValue->flags = fPTR32;
        pavValue->base = (UCHAR)tokenvalue;
        pavValue->index = 0xff;
        }
    else
        error(SYNTAX);
dprintf("exit  GetAsmIndxTerm with %lx\n", pavValue->value);
}

void AddAsmValues (PASM_VALUE pavLeft, PASM_VALUE pavRight)
{
    //  swap values if left one is a pointer

    if (pavLeft->flags & fPTR)
        SwapPavs(pavLeft, pavRight);

    //  swap values if left one is an immediate

    if (pavLeft->flags & fIMM)
        SwapPavs(pavLeft, pavRight);

    //  the above swaps reduce the cases to test.
    //      pairs with an immediate will have it on the right
    //      pairs with a pointer will have it on the right,
    //          except for a pointer-immediate pair

    //  if both values are 16-bit pointers, combine them

    if (pavLeft->flags & pavRight->flags & fPTR16) {

        //  if either side has both registers (rm < 4), error

        if (!(pavLeft->base & pavRight->base & 4))
            error(OPERAND);

        //  use lookup table to compute new rm value

        pavLeft->base = rm16Table[((pavLeft->base & 3) << 2) +
                                  (pavRight->base & 3)];
        if (pavLeft->base == 0xff)
            error(OPERAND);

        pavRight->flags = fPTR;
        }

    //  if both values are 32-bit pointers, combine them

    if (pavLeft->flags & pavRight->flags & fPTR32) {

        //  error if either side has both base and index,
        //      or if both have index

        if (((pavLeft->base | pavLeft->index) != 0xff)
                || ((pavRight->base | pavRight->index) != 0xff)
                || ((pavLeft->index | pavRight->index) != 0xff))
            error(OPERAND);

        //  if left side has base, swap sides

        if (pavLeft->base != 0xff)
            SwapPavs(pavLeft, pavRight);

        //  two cases remaining, index-base and base-base

        if (pavLeft->base != 0xff) {

            //  left side has base, promote to index but swap if left
            //      base is ESP since it cannot be an index register

            if (pavLeft->base == indSP)
                SwapPavs(pavLeft, pavRight);
            if (pavLeft->base == indSP)
                error(OPERAND);
            pavLeft->index = pavLeft->base;
            pavLeft->scale = 0;
            }

        //  finish by setting left side base to right side value

        pavLeft->base = pavRight->base;

        pavRight->flags = fPTR;
        }

    //  if left side is any pointer and right is nonindex pointer,
    //      combine them.  (above cases set right side to use this code)

    if ((pavLeft->flags & (fPTR | fPTR16 | fPTR32))
                                        && (pavRight->flags & fPTR)) {
        if (pavLeft->segovr + pavRight->segovr != segX
                                && pavLeft->segovr != pavRight->segovr)
            error(OPERAND);
        if (pavLeft->size + pavRight->size != sizeX
                                && pavLeft->size != pavRight->size)
            error(OPERAND);
        pavRight->flags = fIMM;
        }

    //  if right side is immediate, add values and relocs
    //      (above case sets right side to use this code)
    //  illegal value types do not have right side set to fIMM

    if (pavRight->flags & fIMM) {
        pavLeft->value += pavRight->value;
        pavLeft->reloc += pavRight->reloc;
        }
    else
        error(OPERAND);
}

void SwapPavs (PASM_VALUE pavFirst, PASM_VALUE pavSecond)
{
    ASM_VALUE   temp;

    memmove(&temp, pavFirst, sizeof(ASM_VALUE));
    memmove(pavFirst, pavSecond, sizeof(ASM_VALUE));
    memmove(pavSecond, &temp, sizeof(ASM_VALUE));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\event.h ===
//----------------------------------------------------------------------------
//
// Event waiting and processing.
//
// Copyright (C) Microsoft Corporation, 1999-2001.
//
//----------------------------------------------------------------------------

#ifndef __EVENT_H__
#define __EVENT_H__

struct LAST_EVENT_INFO
{
    union
    {
        DEBUG_LAST_EVENT_INFO_BREAKPOINT Breakpoint;
        DEBUG_LAST_EVENT_INFO_EXCEPTION Exception;
        DEBUG_LAST_EVENT_INFO_EXIT_THREAD ExitThread;
        DEBUG_LAST_EVENT_INFO_EXIT_PROCESS ExitProcess;
        DEBUG_LAST_EVENT_INFO_LOAD_MODULE LoadModule;
        DEBUG_LAST_EVENT_INFO_UNLOAD_MODULE UnloadModule;
        DEBUG_LAST_EVENT_INFO_SYSTEM_ERROR SystemError;
    };
};

extern ULONG g_EventProcessSysId;
extern ULONG g_EventThreadSysId;
extern ULONG g_LastEventType;
extern char g_LastEventDesc[];
extern PVOID g_LastEventExtraData;
extern ULONG g_LastEventExtraDataSize;
extern LAST_EVENT_INFO g_LastEventInfo;
extern ULONG64 g_EventPc;
extern PDEBUG_EXCEPTION_FILTER_PARAMETERS g_EventExceptionFilter;
extern ULONG g_ExceptionFirstChance;

extern ULONG64 g_ThreadToResume;
extern HANDLE g_EventToSignal;
extern ULONG g_SystemErrorOutput;
extern ULONG g_SystemErrorBreak;
extern ULONG g_ExecutionStatusRequest;
extern ULONG g_PendingBreakInTimeoutLimit;

extern PCHAR g_StateChangeData;
extern PDBGKD_ANY_CONTROL_REPORT g_ControlReport;
extern ULONG64 g_SystemRangeStart;
extern ULONG64 g_SystemCallVirtualAddress;
extern ULONG g_SwitchProcessor;
extern KDDEBUGGER_DATA64 KdDebuggerData;
extern ULONG64 g_KdDebuggerDataBlock;

void DiscardLastEvent(void);
void ClearEventLog(void);
void OutputEventLog(void);
ULONG EventStatusToContinue(ULONG EventStatus);
HRESULT PrepareForWait(ULONG Flags, PULONG ContinueStatus);
void ProcessDeferredWork(PULONG ContinueStatus);
    
BOOL SuspendExecution(void);
HRESULT ResumeExecution(void);
    
// PrepareForCalls must gracefully handle failures so that
// it is always possible to enter call-handling mode.
void PrepareForCalls(ULONG64 ExtraStatusFlags);
    
// PrepareForExecution should report failures so that
// execution is not started until command mode can be left cleanly.
// This biases things towards running in command mode, which
// is the right thing to do.
HRESULT PrepareForExecution(ULONG NewStatus);

HRESULT PrepareForSeparation(void);
    
void FindEventProcessThread(void);
ULONG MergeVotes(ULONG Cur, ULONG Vote);
    
ULONG ProcessBreakpointOrStepException(PEXCEPTION_RECORD64 Record,
                                       ULONG FirstChance);
ULONG CheckBreakpointOrStepTrace(PADDR BpAddr, ULONG BreakType);
ULONG CheckStepTrace(PADDR PcAddr, ULONG DefaultStatus);

void AnalyzeDeadlock(EXCEPTION_RECORD64* Exception,
                     ULONG FirstChance);
void OutputDeadlock(EXCEPTION_RECORD64* Exception,
                    ULONG FirstChance);
    
void GetEventName(ULONG64 ImageFile, ULONG64 ImageBase,
                  ULONG64 NamePtr, WORD Unicode,
                  PSTR NameBuffer, ULONG BufferSize);

DWORD64 GetKernelModuleBase(ULONG64 Address);
BOOL VerifyKernelBase(BOOL LoadImage);
ULONG ProcessStateChange(PDBGKD_ANY_WAIT_STATE_CHANGE StateChange,
                         PCHAR StateChangeData);
void ResetConnection(ULONG Reason);
void CreateKernelProcessAndThreads(void);
void AddKernelThreads(ULONG Start, ULONG Count);

ULONG ProcessRunChange(ULONG HaltReason, ULONG ExceptionCode);

ULONG ProcessDebugEvent(DEBUG_EVENT64* Event,
                        ULONG PendingFlags, ULONG PendingOptions);
ULONG ProcessEventException(DEBUG_EVENT64* Event);
ULONG OutputEventDebugString(OUTPUT_DEBUG_STRING_INFO64* Info);

//----------------------------------------------------------------------------
//
// Event filtering.
//
//----------------------------------------------------------------------------

extern ULONG64 g_UnloadDllBase;

BOOL BreakOnThisImageTail(PCSTR ImagePath, PCSTR FilterArg);
BOOL BreakOnThisDllUnload(ULONG64 DllBase);
BOOL BreakOnThisOutString(PCSTR OutString);

#define FILTER_MAX_ARGUMENT MAX_IMAGE_PATH

#define FILTER_SPECIFIC_FIRST  DEBUG_FILTER_CREATE_THREAD
#define FILTER_SPECIFIC_LAST   DEBUG_FILTER_DEBUGGEE_OUTPUT

#define FILTER_EXCEPTION_FIRST (FILTER_SPECIFIC_LAST + 1)
#define FILTER_EXCEPTION_LAST  (FILTER_SPECIFIC_LAST + 21)
#define FILTER_DEFAULT_EXCEPTION FILTER_EXCEPTION_FIRST

#define FILTER_COUNT (FILTER_EXCEPTION_LAST + 1)

#define IS_EFEXECUTION_BREAK(Execution) \
    ((Execution) == DEBUG_FILTER_SECOND_CHANCE_BREAK || \
     (Execution) == DEBUG_FILTER_BREAK)

#define FILTER_CHANGED_EXECUTION 0x00000001
#define FILTER_CHANGED_CONTINUE  0x00000002
#define FILTER_CHANGED_COMMAND   0x00000004

struct EVENT_COMMAND
{
    DebugClient* Client;
    // Both first and second chances have commands.
    PSTR Command[2];
    ULONG CommandSize[2];
};

struct EVENT_FILTER
{
    PCSTR Name;
    PCSTR ExecutionAbbrev;
    PCSTR ContinueAbbrev;
    PCSTR OutArgFormat;
    ULONG OutArgIndex;
    DEBUG_EXCEPTION_FILTER_PARAMETERS Params;
    EVENT_COMMAND Command;
    PSTR Argument;
    ULONG Flags;
};

#define OTHER_EXCEPTION_LIST_MAX 32

extern EVENT_FILTER g_EventFilters[];
extern DEBUG_EXCEPTION_FILTER_PARAMETERS g_OtherExceptionList[];
extern EVENT_COMMAND g_OtherExceptionCommands[];
extern ULONG g_NumOtherExceptions;

EVENT_FILTER* GetSpecificExceptionFilter(ULONG Code);
void GetOtherExceptionParameters(ULONG Code,
                                 PDEBUG_EXCEPTION_FILTER_PARAMETERS* Params,
                                 EVENT_COMMAND** Command);
void ParseSetEventFilter(DebugClient* Client);

#define SXCMDS_ONE_LINE 0x00000001

void ListFiltersAsCommands(DebugClient* Client, ULONG Flags);

BOOL SyncFiltersWithOptions(void);
BOOL SyncOptionsWithFilters(void);

#endif // #ifndef __EVENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\i386_asmtpl.cpp ===
#include "ntsdp.hpp"

#include "i386_asm.h"

PUCHAR X86SearchOpcode(PUCHAR);

//  type and size table is ordered on enum of operand types

OPNDTYPE mapOpndType[] = {
    { typAX,  sizeB },          //  opnAL  - AL register - byte
    { typAX,  sizeW },          //  opnAX  - AX register - word
    { typAX,  sizeV },          //  opneAX - eAX register - (d)word
    { typCL,  sizeB },          //  opnCL  - CX register - byte
    { typDX,  sizeW },          //  opnDX -  DX register - word (DX)
    { typAbs, sizeV },          //  opnAp -  absolute pointer (16:16/32)
    { typExp, sizeB },          //  opnEb -  expression (mem/reg) - byte
    { typExp, sizeW },          //  opnEw -  expression (mem/reg) - word
    { typExp, sizeV },          //  opnEv -  expression (mem/reg) - (d)word
    { typGen, sizeB },          //  opnGb -  general register - byte
    { typGen, sizeW },          //  opnGw -  general register - word
    { typGen, sizeV },          //  opnGv -  general register - (d)word
    { typGen, sizeD },          //  opnGd -  general register - dword
    { typIm1, sizeB },          //  opnIm1 - immediate - value 1
    { typIm3, sizeB },          //  opnIm3 - immediate - value 3
    { typImm, sizeB },          //  opnIb -  immediate - byte
    { typImm, sizeW },          //  opnIw -  immediate - word
    { typImm, sizeV },          //  opnIv -  immediate - (d)word
    { typJmp, sizeB },          //  opnJb -  relative jump - byte
    { typJmp, sizeV },          //  opnJv -  relative jump - (d)word
    { typMem, sizeX },          //  opnM  -  memory pointer - nosize
    { typMem, sizeA },          //  opnMa -  memory pointer - (16:16, 32:32)
    { typMem, sizeB },          //  opnMb -  memory pointer - byte
    { typMem, sizeW },          //  opnMw -  memory pointer - word
    { typMem, sizeD },          //  opnMd -  memory pointer - dword
    { typMem, sizeP },          //  opnMp -  memory pointer - (d)(f)word
    { typMem, sizeS },          //  opnMs -  memory pointer - sword
    { typMem, sizeQ },          //  opnMq -  memory pointer - qword
    { typMem, sizeT },          //  opnMt -  memory pointer - ten-byte
    { typMem, sizeV },          //  opnMv -  memory pointer - (d)word
    { typCtl, sizeD },          //  opnCd -  control register - dword
    { typDbg, sizeD },          //  opnDd -  debug register - dword
    { typTrc, sizeD },          //  opnTd -  trace register - dword
    { typReg, sizeD },          //  opnRd -  general register - dword
    { typSt,  sizeT },          //  opnSt -  floating point top-of-stack
    { typSti, sizeT },          //  opnSti - floating point index-on-stack
    { typSeg, sizeW },          //  opnSeg - segment register - PUSH / POP
    { typSgr, sizeW },          //  opnSw -  segment register - MOV
    { typXsi, sizeB },          //  opnXb -  string source - byte
    { typXsi, sizeV },          //  opnXv -  string source - (d)word
    { typYdi, sizeB },          //  opnYb -  string destination - byte
    { typYdi, sizeV },          //  opnYv -  string destination - (d)word
    { typOff, sizeB },          //  opnOb -  memory offset - byte
    { typOff, sizeV }           //  opnOv -  memory offset - (d)word
    };

UCHAR szAAA[] = {
          'a', 'a', 'a', '\0',
                0x37, asNone                       + tEnd + eEnd };

UCHAR szAAD[] = {
          'a', 'a', 'd', '\0',
                0xd5, as0x0a                       + tEnd + eEnd };

UCHAR szAAM[] = {
          'a', 'a', 'm', '\0',
                0xd4, as0x0a                       + tEnd + eEnd };

UCHAR szAAS[] = {
          'a', 'a', 's', '\0',
                0x3f, asNone                       + tEnd + eEnd };

UCHAR szADC[] = {
          'a', 'd', 'c', '\0',
                0x14,         opnAL,   opnIb       + tEnd,
                0x15,         opneAX,  opnIv       + tEnd,
                0x80, asReg2, opnEb,   opnIb       + tEnd,
                0x83, asReg2, opnEv,   opnIb       + tEnd,
                0x81, asReg2, opnEv,   opnIv       + tEnd,
                0x10,         opnEb,   opnGb       + tEnd,
                0x11,         opnEv,   opnGv       + tEnd,
                0x12,         opnGb,   opnEb       + tEnd,
                0x13,         opnGv,   opnEv       + tEnd + eEnd };

UCHAR szADD[] = {
          'a', 'd', 'd', '\0',
                0x04,         opnAL,   opnIb       + tEnd,
                0x05,         opneAX,  opnIv       + tEnd,
                0x80, asReg0, opnEb,   opnIb       + tEnd,
                0x83, asReg0, opnEv,   opnIb       + tEnd,
                0x81, asReg0, opnEv,   opnIv       + tEnd,
                0x00,         opnEb,   opnGb       + tEnd,
                0x01,         opnEv,   opnGv       + tEnd,
                0x02,         opnGb,   opnEb       + tEnd,
                0x03,         opnGv,   opnEv       + tEnd + eEnd };

UCHAR szAND[] = {
          'a', 'n', 'd', '\0',
                0x24,         opnAL,   opnIb       + tEnd,
                0x25,         opneAX,  opnIv       + tEnd,
                0x80, asReg4, opnEb,   opnIb       + tEnd,
                0x83, asReg4, opnEv,   opnIb       + tEnd,
                0x81, asReg4, opnEv,   opnIv       + tEnd,
                0x20,         opnEb,   opnGb       + tEnd,
                0x21,         opnEv,   opnGv       + tEnd,
                0x22,         opnGb,   opnEb       + tEnd,
                0x23,         opnGv,   opnEv       + tEnd + eEnd };

UCHAR szARPL[] = {
          'a', 'r', 'p', 'l', '\0',
                0x63,         opnEw,   opnGw       + tEnd + eEnd };

UCHAR szBOUND[] = {
          'b', 'o', 'u', 'n', 'd', '\0',
                0x62,         opnGv,   opnMa       + tEnd + eEnd };

UCHAR szBSF[] = {
          'b', 's', 'f', '\0',
          0x0f, 0xbc,         opnGv,   opnEv       + tEnd + eEnd };

UCHAR szBSR[] = {
          'b', 's', 'r', '\0',
          0x0f, 0xbd,         opnGv,   opnEv       + tEnd + eEnd };

UCHAR szBSWAP[] = {
          'b', 's', 'w', 'a', 'p', '\0',
          0x0f, 0xc8, asOpRg, opnGd                + tEnd + eEnd };

UCHAR szBT[] = {
          'b', 't', '\0',
          0x0f, 0xa3,         opnEv,   opnGv       + tEnd,
          0x0f, 0xba, asReg4, opnEv,   opnIb       + tEnd + eEnd };

UCHAR szBTC[] = {
          'b', 't', 'c', '\0',
          0x0f, 0xbb,         opnEv,   opnGv       + tEnd,
          0x0f, 0xba, asReg7, opnEv,   opnIb       + tEnd + eEnd };

UCHAR szBTR[] = {
          'b', 't', 'r', '\0',
          0x0f, 0xb3,         opnEv,   opnGv       + tEnd,
          0x0f, 0xba, asReg6, opnEv,   opnIb       + tEnd + eEnd };

UCHAR szBTS[] = {
          'b', 't', 's', '\0',
          0x0f, 0xab,         opnEv,   opnGv       + tEnd,
          0x0f, 0xba, asReg5, opnEv,   opnIb       + tEnd + eEnd };

UCHAR szCALL[] = {
          'c', 'a', 'l', 'l', '\0',
                0xe8,         opnJv                + tEnd,
                0xff, asReg2, asMpNx, opnEv        + tEnd,
                0xff, asReg3, opnMp                + tEnd,
                0x9a,         opnAp                + tEnd + eEnd };

UCHAR szCBW[] = {
          'c', 'b', 'w', '\0',
                0x98, asSiz0                       + tEnd + eEnd };

UCHAR szCDQ[] = {
          'c', 'd', 'q', '\0',
                0x99, asSiz1                       + tEnd + eEnd };

UCHAR szCLC[] = {
          'c', 'l', 'c', '\0',
                0xf8, asNone                       + tEnd + eEnd };

UCHAR szCLD[] = {
          'c', 'l', 'd', '\0',
                0xfc, asNone                       + tEnd + eEnd };

UCHAR szCLI[] = {
          'c', 'l', 'i', '\0',
                0xfa, asNone                       + tEnd + eEnd };

UCHAR szCLTS[] = {
          'c', 'l', 't', 's', '\0',
          0x0f, 0x06, asNone                       + tEnd + eEnd };

UCHAR szCMC[] = {
          'c', 'm', 'c', '\0',
                0xf5, asNone                       + tEnd + eEnd };

UCHAR szCMP[] = {
          'c', 'm', 'p', '\0',
                0x3c,         opnAL,   opnIb       + tEnd,
                0x3d,         opneAX,  opnIv       + tEnd,
                0x80, asReg7, opnEb,   opnIb       + tEnd,
                0x83, asReg7, opnEv,   opnIb       + tEnd,
                0x81, asReg7, opnEv,   opnIv       + tEnd,
                0x38,         opnEb,   opnGb       + tEnd,
                0x39,         opnEv,   opnGv       + tEnd,
                0x3a,         opnGb,   opnEb       + tEnd,
                0x3b,         opnGv,   opnEv       + tEnd + eEnd };

UCHAR szCMPS[] = {
          'c', 'm', 'p', 's', '\0',
                0xa6,         opnXb,   opnYb       + tEnd,
                0xa7,         opnXv,   opnYv       + tEnd + eEnd };

UCHAR szCMPSB[] = {
          'c', 'm', 'p', 's', 'b', '\0',
                0xa6, asNone                       + tEnd + eEnd };

UCHAR szCMPSD[] = {
          'c', 'm', 'p', 's', 'd', '\0',
                0xa7, asSiz1                       + tEnd + eEnd };

UCHAR szCMPSW[] = {
          'c', 'm', 'p', 's', 'w', '\0',
                0xa7, asSiz0                       + tEnd + eEnd };

UCHAR szCMPXCHG[] = {
          'c', 'm', 'p', 'x', 'c', 'h', 'g', '\0',
          0x0f, 0xb0,          opnEb,  opnGb       + tEnd,
          0x0f, 0xb1,          opnEv,  opnGv       + tEnd + eEnd };

UCHAR szCMPXCHG8B[] = {
          'c', 'm', 'p', 'x', 'c', 'h', 'g', '8', 'b', '\0',
                0x0f, 0xc7, asReg1,  opnMq         + tEnd + eEnd };

UCHAR szCPUID[] = {
          'c', 'p', 'u', 'i', 'd', '\0',
                0x0f, 0xa2, asNone                 + tEnd + eEnd };


UCHAR szCS[] = {
          'c', 's', ':', '\0',
                0x2e, asPrfx                       + tEnd + eEnd };

UCHAR szCWD[] = {
          'c', 'w', 'd', '\0',
                0x99, asSiz0                       + tEnd + eEnd };

UCHAR szCWDE[] = {
          'c', 'w', 'd', 'e', '\0',
                0x98, asSiz1                       + tEnd + eEnd };

UCHAR szDAA[] = {
          'd', 'a', 'a', '\0',
                0x27, asNone                       + tEnd + eEnd };

UCHAR szDAS[] = {
          'd', 'a', 's', '\0',
                0x2f, asNone                       + tEnd + eEnd };

UCHAR szDEC[] = {
          'd', 'e', 'c', '\0',
                0x48, asOpRg, opnGv                + tEnd,
                0xfe, asReg1, opnEb                + tEnd,
                0xff, asReg1, opnEv                + tEnd + eEnd };

UCHAR szDIV[] = {
          'd', 'i', 'v', '\0',
                0xf6, asReg6, opnEb                + tEnd,
                0xf7, asReg6, opnEv                + tEnd,
                0xf6, asReg6, opnAL,  opnEb        + tEnd,
                0xf7, asReg6, opneAX, opnEv        + tEnd + eEnd };

UCHAR szDS[] = {
          'd', 's', ':', '\0',
                0x3e, asPrfx                       + tEnd + eEnd };

UCHAR szENTER[] = {
          'e', 'n', 't', 'e', 'r', '\0',
                0xc8,         opnIw,  opnIb        + tEnd + eEnd };

UCHAR szES[] = {
          'e', 's', ':', '\0',
                0x36, asPrfx                       + tEnd + eEnd };

UCHAR szF2XM1[] = {
          'f', '2', 'x', 'm', '1', '\0',
          0xd8, 0xf0, asNone                       + tEnd + eEnd };

UCHAR szFABS[] = {
          'f', 'a', 'b', 's', '\0',
          0xd9, 0xe1, asNone                       + tEnd + eEnd };

UCHAR szFADD[] = {
          'f', 'a', 'd', 'd', '\0',
          0xd8,       asReg0, opnMd,   asFSiz      + tEnd,
          0xdc,       asReg0, opnMq                + tEnd,
          0xd8, 0xc0,         opnSt,   opnSti      + tEnd,
          0xdc, 0xc0,         opnSti,  opnSt       + tEnd,
          0xdc, 0xc1, asNone                       + tEnd + eEnd };

UCHAR szFADDP[] = {
          'f', 'a', 'd', 'd', 'p', '\0',
          0xde, 0xc0,         opnSti,  opnSt       + tEnd + eEnd };

UCHAR szFBLD[] = {
          'f', 'b', 'l', 'd', '\0',
          0xdf,       asReg4, opnMt                + tEnd + eEnd };

UCHAR szFBSTP[] = {
          'f', 'b', 's', 't', 'p', '\0',
          0xdf,       asReg6, opnMt                + tEnd + eEnd };

UCHAR szFCHS[] = {
          'f', 'c', 'h', 's', '\0',
          0xd9, 0xe0, asNone                       + tEnd + eEnd };

UCHAR szFCLEX[] = {
          'f', 'c', 'l', 'e', 'x', '\0',
          0xdb, 0xe2, asWait                       + tEnd + eEnd };

UCHAR szFCOM[] = {
          'f', 'c', 'o', 'm', '\0',
          0xd8, 0xd1, asNone                       + tEnd,
          0xd8, 0xd0,         opnSti               + tEnd,
          0xd8,       asReg2, opnMd,   asFSiz      + tEnd,
          0xdc,       asReg2, opnMq                + tEnd + eEnd };

UCHAR szFCOMP[] = {
          'f', 'c', 'o', 'm', 'p', '\0',
          0xd8, 0xd9, asNone                       + tEnd,
          0xd8, 0xd8,         opnSti               + tEnd,
          0xd8,       asReg3, opnMd,   asFSiz      + tEnd,
          0xdc,       asReg3, opnMq                + tEnd + eEnd };

UCHAR szFCOMPP[] = {
          'f', 'c', 'o', 'm', 'p', 'p', '\0',
          0xde, 0xd9, asNone                       + tEnd + eEnd };

UCHAR szFCOS[] = {
          'f', 'c', 'o', 's', '\0',
          0xd9, 0xff, asNone                       + tEnd + eEnd };

UCHAR szFDECSTP[] = {
          'f', 'd', 'e', 'c', 's', 't', 'p', '\0',
          0xd9, 0xf6, asWait                       + tEnd + eEnd };

UCHAR szFDISI[] = {
          'f', 'd', 'i', 's', 'i', '\0',
          0xdb, 0xe1, asWait                       + tEnd + eEnd };

UCHAR szFDIV[] = {
          'f', 'd', 'i', 'v', '\0',
          0xdc, 0xf9, asNone                       + tEnd,
          0xd8,       asReg6, opnMd,   asFSiz      + tEnd,
          0xdc,       asReg6, opnMq                + tEnd,
          0xd8, 0xf0,         opnSt,   opnSti      + tEnd,
          0xdc, 0xf8,         opnSti,  opnSt       + tEnd + eEnd };

UCHAR szFDIVP[] = {
          'f', 'd', 'i', 'v', 'p', '\0',
          0xde, 0xf8,         opnSti,  opnSt       + tEnd + eEnd };

UCHAR szFDIVR[] = {
          'f', 'd', 'i', 'v', 'r', '\0',
          0xde, 0xf1, asNone                       + tEnd,
          0xd8,       asReg7, opnMd,   asFSiz      + tEnd,
          0xdc,       asReg7, opnMq                + tEnd,
          0xd8, 0xf8,         opnSt,   opnSti      + tEnd,
          0xdc, 0xf0,         opnSti,  opnSt       + tEnd + eEnd };

UCHAR szFDIVRP[] = {
          'f', 'd', 'i', 'v', 'r', 'p', '\0',
          0xde, 0xf0,         opnSti,  opnSt       + tEnd + eEnd };

UCHAR szFENI[] = {
          'f', 'e', 'n', 'i', '\0',
          0xdb, 0xe0, asWait                       + tEnd + eEnd };

UCHAR szFFREE[] = {
          'f', 'f', 'r', 'e', 'e', '\0',
          0xdd, 0xc0, asWait, opnSti               + tEnd + eEnd };

UCHAR szFIADD[] = {
          'f', 'i', 'a', 'd', 'd', '\0',
          0xde,       asReg0, opnMw,   asFSiz      + tEnd,
          0xda,       asReg0, opnMd                + tEnd + eEnd };

UCHAR szFICOM[] = {
          'f', 'i', 'c', 'o', 'm', '\0',
          0xde,       asReg2, opnMw,   asFSiz      + tEnd,
          0xda,       asReg2, opnMd                + tEnd + eEnd };

UCHAR szFICOMP[] = {
          'f', 'i', 'c', 'o', 'm', 'p', '\0',
          0xde,       asReg3, opnMw,   asFSiz      + tEnd,
          0xda,       asReg3, opnMd                + tEnd + eEnd };

UCHAR szFIDIV[] = {
          'f', 'i', 'd', 'i', 'v', '\0',
          0xde,       asReg6, opnMw,   asFSiz      + tEnd,
          0xda,       asReg6, opnMd                + tEnd + eEnd };

UCHAR szFIDIVR[] = {
          'f', 'i', 'd', 'i', 'v', 'r', '\0',
          0xde,       asReg7, opnMw,   asFSiz      + tEnd,
          0xda,       asReg7, opnMd                + tEnd + eEnd };

UCHAR szFILD[] = {
          'f', 'i', 'l', 'd', '\0',
          0xdf,       asReg0, opnMw,   asFSiz      + tEnd,
          0xdb,       asReg0, opnMd                + tEnd,
          0xdf,       asReg5, opnMq                + tEnd + eEnd };

UCHAR szFIMUL[] = {
          'f', 'i', 'm', 'u', 'l', '\0',
          0xde,       asReg1, opnMw,   asFSiz      + tEnd,
          0xda,       asReg1, opnMd                + tEnd + eEnd };

UCHAR szFINCSTP[] = {
          'f', 'i', 'n', 'c', 's', 't', 'p', '\0',
          0xd9, 0xf7, asWait                       + tEnd + eEnd };

UCHAR szFINIT[] = {
          'f', 'i', 'n', 'i', 't', '\0',
          0xdb, 0xe3, asWait                       + tEnd + eEnd };

UCHAR szFIST[] = {
          'f', 'i', 's', 't', '\0',
          0xdf,       asReg2, opnMw,   asFSiz      + tEnd,
          0xdb,       asReg2, opnMd                + tEnd + eEnd };

UCHAR szFISTP[] = {
          'f', 'i', 's', 't', 'p', '\0',
          0xdf,       asReg3, opnMw,   asFSiz      + tEnd,
          0xdb,       asReg3, opnMd                + tEnd,
          0xdf,       asReg7, opnMq                + tEnd + eEnd };

UCHAR szFISUB[] = {
          'f', 'i', 's', 'u', 'b', '\0',
          0xde,       asReg4, opnMw,   asFSiz      + tEnd,
          0xda,       asReg4, opnMd                + tEnd + eEnd };

UCHAR szFISUBR[] = {
          'f', 'i', 's', 'u', 'b', 'r', '\0',
          0xde,       asReg5, opnMw,   asFSiz      + tEnd,
          0xda,       asReg5, opnMd                + tEnd + eEnd };

UCHAR szFLD[] = {
          'f', 'l', 'd', '\0',
          0xd9,       asReg0, opnMd,   asFSiz      + tEnd,
          0xdd,       asReg0, opnMq                + tEnd,
          0xdb,       asReg5, opnMt                + tEnd,
          0xd9, 0xc0,         opnSti               + tEnd + eEnd };

UCHAR szFLD1[] = {
          'f', 'l', 'd', '1', '\0',
          0xd9, 0xe8, asNone                       + tEnd + eEnd };

UCHAR szFLDCW[] = {
          'f', 'l', 'd', 'c', 'w', '\0',
          0xd9,       asWait, asReg5, opnMw        + tEnd + eEnd };

UCHAR szFLDENV[] = {
          'f', 'l', 'd', 'e', 'n', 'v', '\0',
          0xd9,       asWait, asReg4, opnMw        + tEnd + eEnd };

UCHAR szFLDL2E[] = {
          'f', 'l', 'd', 'l', '2', 'e', '\0',
          0xd9, 0xea, asNone                       + tEnd + eEnd };

UCHAR szFLDL2T[] = {
          'f', 'l', 'd', 'l', '2', 't', '\0',
          0xd9, 0xe9, asNone                       + tEnd + eEnd };

UCHAR szFLDLG2[] = {
          'f', 'l', 'd', 'l', 'g', '2', '\0',
          0xd9, 0xec, asNone                       + tEnd + eEnd };

UCHAR szFLDLN2[] = {
          'f', 'l', 'd', 'l', 'n', '2', '\0',
          0xd9, 0xed, asNone                       + tEnd + eEnd };

UCHAR szFLDPI[] = {
          'f', 'l', 'd', 'p', 'i', '\0',
          0xd9, 0xeb, asNone                       + tEnd + eEnd };

UCHAR szFLDZ[] = {
          'f', 'l', 'd', 'z', '\0',
          0xd9, 0xee, asNone                       + tEnd + eEnd };

UCHAR szFMUL[] = {
          'f', 'm', 'u', 'l', '\0',
          0xde, 0xc9, asNone                       + tEnd,
          0xd8,       asReg1, opnMd,   asFSiz      + tEnd,
          0xdc,       asReg1, opnMq                + tEnd,
          0xd8, 0xc8,         opnSt,   opnSti      + tEnd,
          0xdc, 0xc8,         opnSti,  opnSt       + tEnd + eEnd };

UCHAR szFMULP[] = {
          'f', 'm', 'u', 'l', 'p', '\0',
          0xde, 0xc8,         opnSti,  opnSt       + tEnd + eEnd };

UCHAR szFNCLEX[] = {
          'f', 'n', 'c', 'l', 'e', 'x', '\0',
          0xdb, 0xe2, asNone                       + tEnd + eEnd };

UCHAR szFNDISI[] = {
          'f', 'n', 'd', 'i', 's', 'i', '\0',
          0xdb, 0xe1, asNone                       + tEnd + eEnd };

UCHAR szFNENI[] = {
          'f', 'n', 'e', 'n', 'i', '\0',
          0xdb, 0xe0, asNone                       + tEnd + eEnd };

UCHAR szFNINIT[] = {
          'f', 'n', 'i', 'n', 'i', 't', '\0',
          0xdb, 0xe3, asNone                       + tEnd + eEnd };

UCHAR szFNOP[] = {
          'f', 'n', 'o', 'p', '\0',
          0xd9, 0xd0, asNone                       + tEnd + eEnd };

UCHAR szFNSAVE[] = {
          'f', 'n', 's', 'a', 'v', 'e', '\0',
          0xdd,       asReg6, opnM                 + tEnd + eEnd };

UCHAR szFNSTCW[] = {
          'f', 'n', 's', 't', 'c', 'w', '\0',
          0xd9,       asReg7, opnMw                + tEnd + eEnd };

UCHAR szFNSTENV[] = {
          'f', 'n', 's', 't', 'e', 'n', 'v', '\0',
          0xd9,       asReg6, opnM                 + tEnd + eEnd };

UCHAR szFNSTSW[] = {
          'f', 'n', 's', 't', 's', 'w', '\0',
          0xdf, 0xe0, asNone                       + tEnd,
          0xdf, 0xe0,         opnAX                + tEnd,
          0xdf,       asReg7, opnMw                + tEnd + eEnd };

UCHAR szFPATAN[] = {
          'f', 'p', 'a', 't', 'a', 'n', '\0',
          0xd9, 0xf3, asNone                       + tEnd + eEnd };

UCHAR szFPREM[] = {
          'f', 'p', 'r', 'e', 'm', '\0',
          0xd9, 0xf8, asNone                       + tEnd + eEnd };

UCHAR szFPREM1[] = {
          'f', 'p', 'r', 'e', 'm', '1', '\0',
          0xd9, 0xf5, asNone                       + tEnd + eEnd };

UCHAR szFPTAN[] = {
          'f', 'p', 't', 'a', 'n', '\0',
          0xd9, 0xf2, asNone                       + tEnd + eEnd };

UCHAR szFRNDINT[] = {
          'f', 'r', 'n', 'd', 'i', 'n', 't', '\0',
          0xd9, 0xfc, asNone                       + tEnd + eEnd };

UCHAR szFRSTOR[] = {
          'f', 'r', 's', 't', 'o', 'r', '\0',
          0xdd,       asWait, asReg4, opnM         + tEnd + eEnd };

UCHAR szFS[] = {
          'f', 's', ':', '\0',
                0x64, asPrfx                       + tEnd + eEnd };

UCHAR szFSAVE[] = {
          'f', 's', 'a', 'v', 'e', '\0',
          0xdd,       asWait, asReg6, opnM         + tEnd + eEnd };

UCHAR szFSCALE[] = {
          'f', 's', 'c', 'a', 'l', 'e', '\0',
          0xd9, 0xfd, asNone                       + tEnd + eEnd };

UCHAR szFSETPM[] = {
          'f', 's', 'e', 't', 'p', 'm', '\0',
          0xdb, 0xe4, asWait                       + tEnd + eEnd };

UCHAR szFSIN[] = {
          'f', 's', 'i', 'n', '\0',
          0xd9, 0xfe, asNone                       + tEnd + eEnd };

UCHAR szFSINCOS[] = {
          'f', 's', 'i', 'n', 'c', 'o', 's', '\0',
          0xd9, 0xfb, asNone                       + tEnd + eEnd };

UCHAR szFSQRT[] = {
          'f', 's', 'q', 'r', 't', '\0',
          0xd9, 0xfa, asNone                       + tEnd + eEnd };

UCHAR szFST[] = {
          'f', 's', 't', '\0',
          0xd9,       asReg2, opnMd,   asFSiz      + tEnd,
          0xdd,       asReg2, opnMq                + tEnd,
          0xdd, 0xd0,         opnSti               + tEnd + eEnd };

UCHAR szFSTCW[] = {
          'f', 's', 't', 'c', 'w', '\0',
          0xd9,       asWait, asReg7, opnMw        + tEnd + eEnd };

UCHAR szFSTENV[] = {
          'f', 's', 't', 'e', 'n', 'v', '\0',
          0xd9,       asWait, asReg6, opnM         + tEnd + eEnd };

UCHAR szFSTP[] = {
          'f', 's', 't', 'p', '\0',
          0xd9,       asReg3, opnMd,   asFSiz      + tEnd,
          0xdd,       asReg3, opnMq                + tEnd,
          0xdb,       asReg7, opnMt                + tEnd,
          0xdd, 0xd8,         opnSti               + tEnd + eEnd };

UCHAR szFSTSW[] = {
          'f', 's', 't', 's', 'w', '\0',
          0xdf, 0xe0, asWait                       + tEnd,
          0xdf, 0xe0, asWait, opnAX                + tEnd,
          0xdd,       asWait, asReg7, opnMw        + tEnd + eEnd };

UCHAR szFSUB[] = {
          'f', 's', 'u', 'b', '\0',
          0xde, 0xe9, asNone                       + tEnd,
          0xd8,       asReg4, opnMd,   asFSiz      + tEnd,
          0xdc,       asReg4, opnMq                + tEnd,
          0xd8, 0xe0,         opnSt,   opnSti      + tEnd,
          0xdc, 0xe8,         opnSti,  opnSt       + tEnd + eEnd };

UCHAR szFSUBP[] = {
          'f', 's', 'u', 'b', 'p', '\0',
          0xde, 0xe8,         opnSti,  opnSt       + tEnd + eEnd };

UCHAR szFSUBR[] = {
          'f', 's', 'u', 'b', 'r', '\0',
          0xde, 0xe1, asNone                       + tEnd,
          0xd8,       asReg5, opnMd,   asFSiz      + tEnd,
          0xdc,       asReg5, opnMq                + tEnd,
          0xd8, 0xe8,         opnSt,   opnSti      + tEnd,
          0xdc, 0xe0,         opnSti,  opnSt       + tEnd + eEnd };

UCHAR szFSUBRP[] = {
          'f', 's', 'u', 'b', 'r', 'p', '\0',
          0xde, 0xe0,         opnSti,  opnSt       + tEnd + eEnd };

UCHAR szFTST[] = {
          'f', 't', 's', 't', '\0',
          0xd9, 0xe4, asNone                       + tEnd + eEnd };

UCHAR szFUCOM[] = {
          'f', 'u', 'c', 'o', 'm', '\0',
          0xdd, 0xe1, asNone,                      + tEnd,
          0xdd, 0xe0,         opnSti               + tEnd + eEnd };

UCHAR szFUCOMP[] = {
          'f', 'u', 'c', 'o', 'm', 'p', '\0',
          0xdd, 0xe9, asNone                       + tEnd,
          0xdd, 0xe8,         opnSti               + tEnd + eEnd };

UCHAR szFUCOMPP[] = {
          'f', 'u', 'c', 'o', 'm', 'p', 'p', '\0',
          0xda, 0xe9, asNone                       + tEnd + eEnd };

UCHAR szFWAIT[] = {                             //  same as WAIT
          'f', 'w', 'a', 'i', 't', '\0',
          0x9b,       asPrfx                       + tEnd + eEnd };

UCHAR szFXAM[] = {
          'f', 'x', 'a', 'm', '\0',
          0xd9, 0xe5, asNone                       + tEnd + eEnd };

UCHAR szFXCH[] = {
          'f', 'x', 'c', 'h', '\0',
          0xd9, 0xc9, asNone                       + tEnd,
          0xd9, 0xc8,         opnSti               + tEnd + eEnd };

UCHAR szFXTRACT[] = {
          'f', 'x', 't', 'r', 'a', 'c', 't', '\0',
          0xd9, 0xf4, asNone                       + tEnd + eEnd };

UCHAR szFYL2X[] = {
          'f', 'y', 'l', '2', 'x', '\0',
          0xd9, 0xf1, asNone                       + tEnd + eEnd };

UCHAR szFYL2XP1[] = {
          'f', 'y', 'l', '2', 'x', 'p', '1', '\0',
          0xd9, 0xf9, asNone                       + tEnd + eEnd };

UCHAR szGS[] = {
          'g', 's', ':', '\0',
                0x65, asPrfx                       + tEnd + eEnd };

UCHAR szHLT[] = {
          'h', 'l', 't', '\0',
                0xf4, asNone                       + tEnd + eEnd };

UCHAR szIDIV[] = {
          'i', 'd', 'i', 'v', '\0',
                0xf6, asReg7, opnEb                + tEnd,
                0xf7, asReg7, opnEv                + tEnd,
                0xf6, asReg7, opnAL,  opnEb        + tEnd,
                0xf7, asReg7, opneAX, opnEv        + tEnd + eEnd };

UCHAR szIMUL[] = {
          'i', 'm', 'u', 'l', '\0',
                0xf6, asReg5, opnEb                + tEnd,
                0xf7, asReg5, opnEv                + tEnd,
                0xf6, asReg5, opnAL,  opnEb        + tEnd,
                0xf7, asReg5, opneAX, opnEv        + tEnd,
          0x0f, 0xaf,         opnGv,  opnEv        + tEnd,
                0x6b,         opnGv,  opnIb        + tEnd,
                0x69,         opnGv,  opnIv        + tEnd,
                0x6b,         opnGv,  opnEv, opnIb + tEnd,
                0x69,         opnGv,  opnEv, opnIv + tEnd + eEnd };

UCHAR szIN[] = {
          'i', 'n', '\0',
                0xe4,         opnAL,  opnIb        + tEnd,
                0xe5,         opneAX, opnIb        + tEnd,
                0xec,         opnAL,  opnDX        + tEnd,
                0xed,         opneAX, opnDX        + tEnd + eEnd };

UCHAR szINC[] = {
          'i', 'n', 'c', '\0',
                0x40, asOpRg, opnGv                + tEnd,
                0xfe, asReg0, opnEb                + tEnd,
                0xff, asReg0, opnEv                + tEnd + eEnd };

UCHAR szINS[] = {
          'i', 'n', 's', '\0',
                0x6c,         opnYb,  opnDX        + tEnd,
                0x6d,         opnYv,  opnDX        + tEnd + eEnd };

UCHAR szINSB[] = {
          'i', 'n', 's', 'b', '\0',
                0x6c, asNone                       + tEnd + eEnd };

UCHAR szINSD[] = {
          'i', 'n', 's', 'd', '\0',
                0x6d, asSiz1                       + tEnd + eEnd };

UCHAR szINSW[] = {
          'i', 'n', 's', 'w', '\0',
                0x6d, asSiz0                       + tEnd + eEnd };

UCHAR szINT[] = {
          'i', 'n', 't', '\0',
                0xcc,         opnIm3               + tEnd,
                0xcd,         opnIb                + tEnd + eEnd };

UCHAR szINTO[] = {
          'i', 'n', 't', 'o', '\0',
                0xce, asNone                       + tEnd + eEnd };

UCHAR szINVD[] = {
          'i', 'n', 'v', 'd', '\0',
          0x0f, 0x08, asNone                       + tEnd + eEnd };

UCHAR szINVLPG[] = {
          'i', 'n', 'v', 'l', 'p', 'g', '\0',
          0x0f, 0x01, asReg7, opnM                 + tEnd + eEnd };

UCHAR szIRET[] = {
          'i', 'r', 'e', 't', '\0',
                0xcf, asSiz0                       + tEnd + eEnd };

UCHAR szIRETD[] = {
          'i', 'r', 'e', 't', 'd', '\0',
                0xcf, asSiz1                       + tEnd + eEnd };

UCHAR szJA[] = {                                //  same as JNBE
          'j', 'a', '\0',
                0x77,         opnJb                + tEnd,
          0x0f, 0x87,         opnJv                + tEnd + eEnd };

UCHAR szJAE[] = {                               //  same as JNB, JNC
          'j', 'a', 'e', '\0',
                0x73,         opnJb                + tEnd,
          0x0f, 0x83,         opnJv                + tEnd + eEnd };

UCHAR szJB[] = {                                //  same as JC, JNAE
          'j', 'b', '\0',
                0x72,         opnJb                + tEnd,
          0x0f, 0x82,         opnJv                + tEnd + eEnd };

UCHAR szJBE[] = {                               //  same as JNA
          'j', 'b', 'e', '\0',
                0x76,         opnJb                + tEnd,
          0x0f, 0x86,         opnJv                + tEnd + eEnd };

UCHAR szJC[] = {                                //  same as JB, JNAE
          'j', 'c', '\0',
                0x72,         opnJb                + tEnd,
          0x0f, 0x82,         opnJv                + tEnd + eEnd };

UCHAR szJCXZ[] = {
          'j', 'c', 'x', 'z', '\0',
                0xe3, asSiz0, opnJb                + tEnd + eEnd };

UCHAR szJECXZ[] = {
          'j', 'e', 'c', 'x', 'z', '\0',
                0xe3, asSiz1, opnJb                + tEnd + eEnd };

UCHAR szJE[] = {                                //  same as JZ
          'j', 'e', '\0',
                0x74,         opnJb                + tEnd,
          0x0f, 0x84,         opnJv                + tEnd + eEnd };

UCHAR szJG[] = {                                //  same as JNLE
          'j', 'g', '\0',
                0x7f,         opnJb                + tEnd,
          0x0f, 0x8f,         opnJv                + tEnd + eEnd };

UCHAR szJGE[] = {                               //  same as JNL
          'j', 'g', 'e', '\0',
                0x7d,         opnJb                + tEnd,
          0x0f, 0x8d,         opnJv                + tEnd + eEnd };

UCHAR szJL[] = {                                //  same as JNGE
          'j', 'l', '\0',
                0x7c,         opnJb                + tEnd,
          0x0f, 0x8c,         opnJv                + tEnd + eEnd };

UCHAR szJLE[] = {                               //  same as JNG
          'j', 'l', 'e', '\0',
                0x7e,         opnJb                + tEnd,
          0x0f, 0x8e,         opnJv                + tEnd + eEnd };

UCHAR szJMP[] = {
          'j', 'm', 'p', '\0',
                0xeb,         opnJb                + tEnd,
                0xe9,         opnJv                + tEnd,
                0xff, asReg4, opnEv, asMpNx        + tEnd,
                0xff, asReg5, opnMp                + tEnd,
                0xea,         opnAp                + tEnd, + eEnd };

UCHAR szJNA[] = {                               //  same as JBE
          'j', 'n', 'a', '\0',
                0x76,         opnJb                + tEnd,
          0x0f, 0x86,         opnJv                + tEnd + eEnd };

UCHAR szJNAE[] = {                              //  same as JB, JC
          'j', 'n', 'a', 'e','\0',
                0x72,         opnJb                + tEnd,
          0x0f, 0x82,         opnJv                + tEnd + eEnd };

UCHAR szJNB[] = {                               //  same as JAE, JNC
          'j', 'n', 'b', '\0',
                0x73,         opnJb                + tEnd,
          0x0f, 0x83,         opnJv                + tEnd + eEnd };

UCHAR szJNBE[] = {                              //  same as JA
          'j', 'n', 'b', 'e', '\0',
                0x77,         opnJb                + tEnd,
          0x0f, 0x87,         opnJv                + tEnd + eEnd };

UCHAR szJNC[] = {                               //  same as JAE, JNB
          'j', 'n', 'c', '\0',
                0x73,         opnJb                + tEnd,
          0x0f, 0x83,         opnJv                + tEnd + eEnd };

UCHAR szJNG[] = {                               //  same as JLE
          'j', 'n', 'g', '\0',
                0x7e,         opnJb                + tEnd,
          0x0f, 0x8e,         opnJv                + tEnd + eEnd };

UCHAR szJNGE[] = {                              //  same as JNL
          'j', 'n', 'g', 'e', '\0',
                0x7c,         opnJb                + tEnd,
          0x0f, 0x8c,         opnJv                + tEnd + eEnd };

UCHAR szJNE[] = {                               //  same as JNZ
          'j', 'n', 'e', '\0',
                0x75,         opnJb                + tEnd,
          0x0f, 0x85,         opnJv                + tEnd + eEnd };

UCHAR szJNL[] = {                               //  same as JGE
          'j', 'n', 'l', '\0',
                0x7d,         opnJb                + tEnd,
          0x0f, 0x8d,         opnJv                + tEnd + eEnd };

UCHAR szJNLE[] = {                              //  same as JNG
          'j', 'n', 'l', 'e', '\0',
                0x7f,         opnJb                + tEnd,
          0x0f, 0x8f,         opnJv                + tEnd + eEnd };

UCHAR szJNO[] = {
          'j', 'n', 'o', '\0',
                0x71,         opnJb                + tEnd,
          0x0f, 0x81,         opnJv                + tEnd + eEnd };

UCHAR szJNP[] = {                               //  same as JPO
          'j', 'n', 'p', '\0',
                0x7b,         opnJb                + tEnd,
          0x0f, 0x8b,         opnJv                + tEnd + eEnd };

UCHAR szJNS[] = {
          'j', 'n', 's', '\0',
                0x79,         opnJb                + tEnd,
          0x0f, 0x89,         opnJv                + tEnd + eEnd };

UCHAR szJNZ[] = {                               //  same as JNE
          'j', 'n', 'z', '\0',
                0x75,         opnJb                + tEnd,
          0x0f, 0x85,         opnJv                + tEnd + eEnd };

UCHAR szJO[] = {
          'j', 'o', '\0',
                0x70,         opnJb                + tEnd,
          0x0f, 0x80,         opnJv                + tEnd + eEnd };

UCHAR szJP[] = {                                //  same as JPE
          'j', 'p', '\0',
                0x7a,         opnJb                + tEnd,
          0x0f, 0x8a,         opnJv                + tEnd + eEnd };

UCHAR szJPE[] = {                               //  same as JP
          'j', 'p', 'e', '\0',
                0x7a,         opnJb                + tEnd,
          0x0f, 0x8a,         opnJv                + tEnd + eEnd };

UCHAR szJPO[] = {                               //  same as JNP
          'j', 'p', 'o', '\0',
                0x7b,         opnJb                + tEnd,
          0x0f, 0x8b,         opnJv                + tEnd + eEnd };

UCHAR szJS[] = {
          'j', 's', '\0',
                0x78,         opnJb                + tEnd,
          0x0f, 0x88,         opnJv                + tEnd + eEnd };

UCHAR szJZ[] = {                                //  same as JE
          'j', 'z', '\0',
                0x74,         opnJb                + tEnd,
          0x0f, 0x84,         opnJv                + tEnd + eEnd };

UCHAR szLAHF[] = {
          'l', 'a', 'h', 'f', '\0',
                0x9f, asNone                       + tEnd + eEnd };

UCHAR szLAR[] = {
          'l', 'a', 'r', '\0',
          0x0f, 0x02,         opnGv,  opnEv        + tEnd + eEnd };

UCHAR szLDS[] = {
          'l', 'd', 's', '\0',
                0xc5,         opnGv,  opnMp        + tEnd + eEnd };

UCHAR szLEA[] = {
          'l', 'e', 'a', '\0',
                0x8d,         opnGv,  opnM         + tEnd + eEnd };

UCHAR szLEAVE[] = {
          'l', 'e', 'a', 'v', 'e', '\0',
                0xc9, asNone                       + tEnd + eEnd };

UCHAR szLES[] = {
          'l', 'e', 's', '\0',
                0xc4,         opnGv,  opnMp        + tEnd + eEnd };

UCHAR szLFS[] = {
          'l', 'f', 's', '\0',
          0x0f, 0xb4,         opnGv,  opnMp        + tEnd + eEnd };

UCHAR szLGDT[] = {
          'l', 'g', 'd', 't', '\0',
          0x0f, 0x01, asReg2, opnMs                + tEnd + eEnd };

UCHAR szLGS[] = {
          'l', 'g', 's', '\0',
          0x0f, 0xb5,         opnGv,  opnMp        + tEnd + eEnd };

UCHAR szLIDT[] = {
          'l', 'i', 'd', 't', '\0',
          0x0f, 0x01, asReg3, opnMs                + tEnd + eEnd };

UCHAR szLLDT[] = {
          'l', 'l', 'd', 't', '\0',
          0x0f, 0x00, asReg2, opnEw                + tEnd + eEnd };

UCHAR szLMSW[] = {
          'l', 'm', 's', 'w', '\0',
          0x0f, 0x01, asReg6, opnEw                + tEnd + eEnd };

UCHAR szLOCK[] = {
          'l', 'o', 'c', 'k', '\0',
                0xf0, asPrfx                       + tEnd + eEnd };

UCHAR szLODS[] = {
          'l', 'o', 'd', 's', '\0',
                0xac,         opnXb                + tEnd,
                0xad,         opnXv                + tEnd + eEnd };

UCHAR szLODSB[] = {
          'l', 'o', 'd', 's', 'b', '\0',
                0xac, asNone                       + tEnd + eEnd };

UCHAR szLODSD[] = {
          'l', 'o', 'd', 's', 'd', '\0',
                0xad, asSiz1                       + tEnd + eEnd };

UCHAR szLODSW[] = {
          'l', 'o', 'd', 's', 'w', '\0',
                0xad, asSiz0                       + tEnd + eEnd };

UCHAR szLOOP[] = {
          'l', 'o', 'o', 'p', '\0',
                0xe2,         opnJb                + tEnd + eEnd };

UCHAR szLOOPE[] = {                             //  same as LOOPZ
          'l', 'o', 'o', 'p', 'e', '\0',
                0xe1,         opnJb                + tEnd + eEnd };

UCHAR szLOOPNE[] = {                            //  same as LOOPNZ
          'l', 'o', 'o', 'p', 'n', 'e', '\0',
                0xe0,         opnJb                + tEnd + eEnd };

UCHAR szLOOPNZ[] = {                            //  same as LOOPNE
          'l', 'o', 'o', 'p', 'n', 'z', '\0',
                0xe0,         opnJb                + tEnd + eEnd };

UCHAR szLOOPZ[] = {                             //  same as LOOPE
          'l', 'o', 'o', 'p', 'z', '\0',
                0xe1,         opnJb                + tEnd + eEnd };

UCHAR szLSL[] = {
          'l', 's', 'l', '\0',
          0x0f, 0x03,         opnGv,  opnEv        + tEnd + eEnd };

UCHAR szLSS[] = {
          'l', 's', 's', '\0',
          0x0f, 0xb2,         opnGv,  opnMp        + tEnd + eEnd };

UCHAR szLTR[] = {
          'l', 't', 'r', '\0',
          0x0f, 0x00, asReg3, opnEw                + tEnd + eEnd };

UCHAR szMOV[] = {
          'm', 'o', 'v', '\0',
                0xa0,         opnAL,  opnOb        + tEnd,
                0xa1,         opneAX, opnOv        + tEnd,
                0xa2,         opnOb,  opnAL        + tEnd,
                0xa3,         opnOv,  opneAX       + tEnd,
                0x8a,         opnGb,  opnEb        + tEnd,
                0x8b,         opnGv,  opnEv        + tEnd,
                0x88,         opnEb,  opnGb        + tEnd,
                0x89,         opnEv,  opnGv        + tEnd,
                0x8c, asSiz0, opnEw,  opnSw        + tEnd,
                0x8e, asSiz0, opnSw,  opnEw        + tEnd,
                0xb0, asOpRg, opnGb,  opnIb        + tEnd,
                0xb8, asOpRg, opnGv,  opnIv        + tEnd,
                0xc6,         opnEb,  opnIb        + tEnd,
                0xc7,         opnEv,  opnIv        + tEnd,
          0x0f, 0x20,         opnRd,  opnCd        + tEnd,
          0x0f, 0x21,         opnRd,  opnDd        + tEnd,
          0x0f, 0x22,         opnCd,  opnRd        + tEnd,
          0x0f, 0x23,         opnDd,  opnRd        + tEnd,
          0x0f, 0x24,         opnRd,  opnTd        + tEnd,
          0x0f, 0x26,         opnTd,  opnRd        + tEnd + eEnd };

UCHAR szMOVS[] = {
          'm', 'o', 'v', 's', '\0',
                0xa4,         opnXb,   opnYb       + tEnd,
                0xa5,         opnXv,   opnYv       + tEnd + eEnd };

UCHAR szMOVSB[] = {
          'm', 'o', 'v', 's', 'b', '\0',
                0xa4, asNone                       + tEnd + eEnd };

UCHAR szMOVSD[] = {
          'm', 'o', 'v', 's', 'd', '\0',
                0xa5, asSiz1                       + tEnd + eEnd };

UCHAR szMOVSW[] = {
          'm', 'o', 'v', 's', 'w', '\0',
                0xa5, asSiz0                       + tEnd + eEnd };

UCHAR szMOVSX[] = {
          'm', 'o', 'v', 's', 'x', '\0',
          0x0f, 0xbe,         opnGv,  opnEb        + tEnd,
          0x0f, 0xbf,         opnGv,  opnEw        + tEnd + eEnd };

UCHAR szMOVZX[] = {
          'm', 'o', 'v', 'z', 'x', '\0',
          0x0f, 0xb6,         opnGv,  opnEb        + tEnd,
          0x0f, 0xb7,         opnGv,  opnEw        + tEnd + eEnd };

UCHAR szMUL[] = {
          'm', 'u', 'l', '\0',
                0xf6, asReg4, opnEb                + tEnd,
                0xf7, asReg4, opnEv                + tEnd,
                0xf6, asReg4, opnAL,  opnEb        + tEnd,
                0xf7, asReg4, opneAX, opnEv        + tEnd + eEnd };

UCHAR szNEG[] = {
          'n', 'e', 'g', '\0',
                0xf6, asReg3, opnEb                + tEnd,
                0xf7, asReg3, opnEv                + tEnd + eEnd };

UCHAR szNOP[] = {
          'n', 'o', 'p', '\0',
                0x90, asNone                       + tEnd };

UCHAR szNOT[] = {
          'n', 'o', 't', '\0',
                0xf6, asReg2, opnEb                + tEnd,
                0xf7, asReg2, opnEv                + tEnd + eEnd };

UCHAR szOR[] = {
          'o', 'r', '\0',
                0x0c,         opnAL,   opnIb       + tEnd,
                0x0d,         opneAX,  opnIv       + tEnd,
                0x80, asReg1, opnEb,   opnIb       + tEnd,
                0x83, asReg1, opnEv,   opnIb       + tEnd,
                0x81, asReg1, opnEv,   opnIv       + tEnd,
                0x08,         opnEb,   opnGb       + tEnd,
                0x09,         opnEv,   opnGv       + tEnd,
                0x0a,         opnGb,   opnEb       + tEnd,
                0x0b,         opnGv,   opnEv       + tEnd + eEnd };

UCHAR szOUT[] = {
          'o', 'u', 't', '\0',
                0xe6,         opnIb,   opnAL       + tEnd,
                0xe7,         opnIb,   opneAX      + tEnd,
                0xee,         opnDX,   opnAL       + tEnd,
                0xef,         opnDX,   opneAX      + tEnd + eEnd };

UCHAR szOUTS[] = {
          'o', 'u', 't', 's', '\0',
                0x6e,         opnDX,  opnYb        + tEnd,
                0x6f,         opnDX,  opnYv        + tEnd + eEnd };

UCHAR szOUTSB[] = {
          'o', 'u', 't', 's', 'b', '\0',
                0x6e, asNone                       + tEnd + eEnd };

UCHAR szOUTSD[] = {
          'o', 'u', 't', 's', 'd', '\0',
                0x6f, asSiz1                       + tEnd + eEnd };

UCHAR szOUTSW[] = {
          'o', 'u', 't', 's', 'w', '\0',
                0x6f, asSiz0                       + tEnd + eEnd };

UCHAR szPOP[] = {
          'p', 'o', 'p', '\0',
                0x58, asOpRg, opnGv                + tEnd,
                0x8f, asReg0, opnMv                + tEnd,
                0x1f,         opnSeg, segDS, asNone+ tEnd,
                0x07,         opnSeg, segES, asNone+ tEnd,
                0x17,         opnSeg, segSS, asNone+ tEnd,
          0x0f, 0xa1,         opnSeg, segFS, asNone+ tEnd,
          0x0f, 0xa9,         opnSeg, segGS, asNone+ tEnd + eEnd };

UCHAR szPOPA[] = {
          'p', 'o', 'p', 'a', '\0',
                0x61, asSiz0                       + tEnd + eEnd };

UCHAR szPOPAD[] = {
          'p', 'o', 'p', 'a', 'd', '\0',
                0x61, asSiz1                       + tEnd + eEnd };

UCHAR szPOPF[] = {
          'p', 'o', 'p', 'f', '\0',
                0x9d, asSiz0                       + tEnd + eEnd };

UCHAR szPOPFD[] = {
          'p', 'o', 'p', 'f', 'd', '\0',
                0x9d, asSiz1                       + tEnd + eEnd };

UCHAR szPUSH[] = {
          'p', 'u', 's', 'h', '\0',
                0x50, asOpRg, opnGv                + tEnd,
                0xff, asReg6, opnMv                + tEnd,
                0x6a,         opnIb                + tEnd,
                0x68,         opnIv                + tEnd,
                0x0e,         opnSeg, segCS, asNone+ tEnd,
                0x1e,         opnSeg, segDS, asNone+ tEnd,
                0x06,         opnSeg, segES, asNone+ tEnd,
                0x16,         opnSeg, segSS, asNone+ tEnd,
          0x0f, 0xa0,         opnSeg, segFS, asNone+ tEnd,
          0x0f, 0xa8,         opnSeg, segGS, asNone+ tEnd + eEnd };

UCHAR szPUSHA[] = {
          'p', 'u', 's', 'h', 'a', '\0',
                0x60, asSiz0                       + tEnd + eEnd };

UCHAR szPUSHAD[] = {
          'p', 'u', 's', 'h', 'a', 'd', '\0',
                0x60, asSiz1                       + tEnd + eEnd };

UCHAR szPUSHF[] = {
          'p', 'u', 's', 'h', 'f', '\0',
                0x9c, asSiz0                       + tEnd + eEnd };

UCHAR szPUSHFD[] = {
          'p', 'u', 's', 'h', 'f', 'd', '\0',
                0x9c, asSiz1                       + tEnd + eEnd };

UCHAR szRCL[] = {
          'r', 'c', 'l', '\0',
                0xd0, asReg2, opnEb,  opnIm1       + tEnd,
                0xd2, asReg2, opnEb,  opnCL        + tEnd,
                0xc0, asReg2, opnEb,  opnIb        + tEnd,
                0xd1, asReg2, opnEv,  opnIm1       + tEnd,
                0xd3, asReg2, opnEv,  opnCL        + tEnd,
                0xc1, asReg2, opnEv,  opnIb        + tEnd + eEnd };

UCHAR szRCR[] = {
          'r', 'c', 'r', '\0',
                0xd0, asReg3, opnEb,  opnIm1       + tEnd,
                0xd2, asReg3, opnEb,  opnCL        + tEnd,
                0xc0, asReg3, opnEb,  opnIb        + tEnd,
                0xd1, asReg3, opnEv,  opnIm1       + tEnd,
                0xd3, asReg3, opnEv,  opnCL        + tEnd,
                0xc1, asReg3, opnEv,  opnIb        + tEnd + eEnd };

UCHAR szRDMSR[] = {
          'r', 'd', 'm', 's', 'r', '\0',
                0x0f, 0x32, asNone                 + tEnd + eEnd };

UCHAR szRDTSC[] = {
          'r', 'd', 't', 's', 'c', '\0',
                0x0f, 0x31, asNone                 + tEnd + eEnd };

UCHAR szREP[] = {                               //  same as REPE, REPZ
          'r', 'e', 'p', '\0',
                0xf3, asPrfx                       + tEnd + eEnd };

UCHAR szREPE[] = {                              //  same as REP, REPZ
          'r', 'e', 'p', 'e', '\0',
                0xf3, asPrfx                       + tEnd + eEnd };

UCHAR szREPZ[] = {                              //  same as REP, REPE
          'r', 'e', 'p', 'z', '\0',
                0xf3, asPrfx                       + tEnd + eEnd };

UCHAR szREPNE[] = {                             //  same as REPNZ
          'r', 'e', 'p', 'n', 'e', '\0',
                0xf2, asPrfx                       + tEnd + eEnd };

UCHAR szREPNZ[] = {                             //  same as REPNE
          'r', 'e', 'p', 'n', 'z', '\0',
                0xf2, asPrfx                       + tEnd + eEnd };

UCHAR szRET[] = {                               //  same as RETN
          'r', 'e', 't', '\0',
                0xc3, asNone                       + tEnd,
                0xc2,         opnIw                + tEnd + eEnd };

UCHAR szRETF[] = {
          'r', 'e', 't', 'f', '\0',
                0xcb, asNone                       + tEnd,
                0xca,         opnIw                + tEnd + eEnd };

UCHAR szRETN[] = {                              //  same as RET
          'r', 'e', 't', 'n', '\0',
                0xc3, asNone                       + tEnd,
                0xc2,         opnIw                + tEnd + eEnd };

UCHAR szROL[] = {
          'r', 'o', 'l', '\0',
                0xd0, asReg0, opnEb,  opnIm1       + tEnd,
                0xd2, asReg0, opnEb,  opnCL        + tEnd,
                0xc0, asReg0, opnEb,  opnIb        + tEnd,
                0xd1, asReg0, opnEv,  opnIm1       + tEnd,
                0xd3, asReg0, opnEv,  opnCL        + tEnd,
                0xc1, asReg0, opnEv,  opnIb        + tEnd + eEnd };

UCHAR szROR[] = {
          'r', 'o', 'r', '\0',
                0xd0, asReg1, opnEb,  opnIm1       + tEnd,
                0xd2, asReg1, opnEb,  opnCL        + tEnd,
                0xc0, asReg1, opnEb,  opnIb        + tEnd,
                0xd1, asReg1, opnEv,  opnIm1       + tEnd,
                0xd3, asReg1, opnEv,  opnCL        + tEnd,
                0xc1, asReg1, opnEv,  opnIb        + tEnd + eEnd };

UCHAR szRSM[] = {
          'r', 's', 'm', '\0',
                0x0f, 0xaa, asNone                 + tEnd + eEnd };

UCHAR szSAHF[] = {
          's', 'a', 'h', 'f', '\0',
                0x9e, asNone                       + tEnd + eEnd };

UCHAR szSAL[] = {
          's', 'a', 'l', '\0',
                0xd0, asReg4, opnEb,  opnIm1       + tEnd,
                0xd2, asReg4, opnEb,  opnCL        + tEnd,
                0xc0, asReg4, opnEb,  opnIb        + tEnd,
                0xd1, asReg4, opnEv,  opnIm1       + tEnd,
                0xd3, asReg4, opnEv,  opnCL        + tEnd,
                0xc1, asReg4, opnEv,  opnIb        + tEnd + eEnd };

UCHAR szSAR[] = {
          's', 'a', 'r', '\0',
                0xd0, asReg7, opnEb,  opnIm1       + tEnd,
                0xd2, asReg7, opnEb,  opnCL        + tEnd,
                0xc0, asReg7, opnEb,  opnIb        + tEnd,
                0xd1, asReg7, opnEv,  opnIm1       + tEnd,
                0xd3, asReg7, opnEv,  opnCL        + tEnd,
                0xc1, asReg7, opnEv,  opnIb        + tEnd + eEnd };

UCHAR szSBB[] = {
          's', 'b', 'b', '\0',
                0x1c,         opnAL,   opnIb       + tEnd,
                0x1d,         opneAX,  opnIv       + tEnd,
                0x80, asReg3, opnEb,   opnIb       + tEnd,
                0x83, asReg3, opnEv,   opnIb       + tEnd,
                0x81, asReg3, opnEv,   opnIv       + tEnd,
                0x18,         opnEb,   opnGb       + tEnd,
                0x19,         opnEv,   opnGv       + tEnd,
                0x1a,         opnGb,   opnEb       + tEnd,
                0x1b,         opnGv,   opnEv       + tEnd + eEnd };


UCHAR szSCAS[] = {
          's', 'c', 'a', 's', '\0',
                0xae,         opnYb                + tEnd,
                0xaf,         opnYv                + tEnd + eEnd };

UCHAR szSCASB[] = {
          's', 'c', 'a', 's', 'b', '\0',
                0xae, asNone                       + tEnd + eEnd };

UCHAR szSCASD[] = {
          's', 'c', 'a', 's', 'd', '\0',
                0xaf, asSiz1                       + tEnd + eEnd };

UCHAR szSCASW[] = {
          's', 'c', 'a', 's', 'w', '\0',
                0xaf, asSiz0                       + tEnd + eEnd };

UCHAR szSETA[] = {                              //  same as SETNBE
          's', 'e', 't', 'a', '\0',
          0x0f, 0x97,         opnEb                + tEnd + eEnd };

UCHAR szSETAE[] = {                             //  same as SETNB, SETNC
          's', 'e', 't', 'a', 'e', '\0',
          0x0f, 0x93,         opnEb                + tEnd + eEnd };

UCHAR szSETB[] = {                              //  same as SETC, SETNAE
          's', 'e', 't', 'b', '\0',
          0x0f, 0x92,         opnEb                + tEnd + eEnd };

UCHAR szSETBE[] = {                             //  same as SETNA
          's', 'e', 't', 'b', 'e', '\0',
          0x0f, 0x96,         opnEb                + tEnd + eEnd };

UCHAR szSETC[] = {                              //  same as SETB, SETNAE
          's', 'e', 't', 'c', '\0',
          0x0f, 0x92,         opnEb                + tEnd + eEnd };

UCHAR szSETE[] = {                              //  same as SETZ
          's', 'e', 't', 'e', '\0',
          0x0f, 0x94,         opnEb                + tEnd + eEnd };

UCHAR szSETG[] = {                              //  same as SETNLE
          's', 'e', 't', 'g', '\0',
          0x0f, 0x9f,         opnEb                + tEnd + eEnd };

UCHAR szSETGE[] = {                             //  same as SETNL
          's', 'e', 't', 'g', 'e', '\0',
          0x0f, 0x9d,         opnEb                + tEnd + eEnd };

UCHAR szSETL[] = {                              //  same as SETNGE
          's', 'e', 't', 'l', '\0',
          0x0f, 0x9c,         opnEb                + tEnd + eEnd };

UCHAR szSETLE[] = {                             //  same as SETNG
          's', 'e', 't', 'l', 'e', '\0',
          0x0f, 0x9e,         opnEb                + tEnd + eEnd };

UCHAR szSETNA[] = {                             //  same as SETBE
          's', 'e', 't', 'n', 'a', '\0',
          0x0f, 0x96,         opnEb                + tEnd + eEnd };

UCHAR szSETNAE[] = {                            //  same as SETB, SETC
          's', 'e', 't', 'n', 'a', 'e', '\0',
          0x0f, 0x92,         opnEb                + tEnd + eEnd };

UCHAR szSETNB[] = {                             //  same as SETAE, SETNC
          's', 'e', 't', 'n', 'b', '\0',
          0x0f, 0x93,         opnEb                + tEnd + eEnd };

UCHAR szSETNBE[] = {                            //  same as SETA
          's', 'e', 't', 'n', 'b', 'e', '\0',
          0x0f, 0x97,         opnEb                + tEnd + eEnd };

UCHAR szSETNC[] = {                             //  same as SETAE, SETNC
          's', 'e', 't', 'n', 'c', '\0',
          0x0f, 0x93,         opnEb                + tEnd + eEnd };

UCHAR szSETNE[] = {                             //  same as SETNZ
          's', 'e', 't', 'n', 'e', '\0',
          0x0f, 0x95,         opnEb                + tEnd + eEnd };

UCHAR szSETNG[] = {                             //  same as SETLE
          's', 'e', 't', 'n', 'g', '\0',
          0x0f, 0x9e,         opnEb                + tEnd + eEnd };

UCHAR szSETNGE[] = {                            //  same as SETL
          's', 'e', 't', 'n', 'g', 'e', '\0',
          0x0f, 0x9c,         opnEb                + tEnd + eEnd };

UCHAR szSETNL[] = {                             //  same as SETGE
          's', 'e', 't', 'n', 'l', '\0',
          0x0f, 0x9d,         opnEb                + tEnd + eEnd };

UCHAR szSETNLE[] = {                            //  same as SETG
          's', 'e', 't', 'n', 'l', 'e', '\0',
          0x0f, 0x9f,         opnEb                + tEnd + eEnd };

UCHAR szSETNO[] = {
          's', 'e', 't', 'n', 'o', '\0',
          0x0f, 0x91,         opnEb                + tEnd + eEnd };

UCHAR szSETNP[] = {                             //  same as SETPO
          's', 'e', 't', 'n', 'p', '\0',
          0x0f, 0x9b,         opnEb                + tEnd + eEnd };

UCHAR szSETNS[] = {
          's', 'e', 't', 'n', 's', '\0',
          0x0f, 0x99,         opnEb                + tEnd + eEnd };

UCHAR szSETNZ[] = {                             //  same as SETNE
          's', 'e', 't', 'n', 'z', '\0',
          0x0f, 0x95,         opnEb                + tEnd + eEnd };

UCHAR szSETO[] = {
          's', 'e', 't', 'o', '\0',
          0x0f, 0x90,         opnEb                + tEnd + eEnd };

UCHAR szSETP[] = {                              //  same as SETPE
          's', 'e', 't', 'p', '\0',
          0x0f, 0x9a,         opnEb                + tEnd + eEnd };

UCHAR szSETPE[] = {                             //  same as SETP
          's', 'e', 't', 'p', 'e', '\0',
          0x0f, 0x9a,         opnEb                + tEnd + eEnd };

UCHAR szSETPO[] = {                             //  same as SETNP
          's', 'e', 't', 'p', 'o', '\0',
          0x0f, 0x9b,         opnEb                + tEnd + eEnd };

UCHAR szSETS[] = {
          's', 'e', 't', 's', '\0',
          0x0f, 0x98,         opnEb                + tEnd + eEnd };

UCHAR szSETZ[] = {                              //  same as SETE
          's', 'e', 't', 'z', '\0',
          0x0f, 0x94,         opnEb                + tEnd + eEnd };

UCHAR szSGDT[] = {
          's', 'g', 'd', 't', '\0',
          0x0f, 0x01, asReg0, opnMs                + tEnd + eEnd };

UCHAR szSHL[] = {
          's', 'h', 'l', '\0',
                0xd0, asReg4, opnEb,  opnIm1       + tEnd,
                0xd2, asReg4, opnEb,  opnCL        + tEnd,
                0xc0, asReg4, opnEb,  opnIb        + tEnd,
                0xd1, asReg4, opnEv,  opnIm1       + tEnd,
                0xd3, asReg4, opnEv,  opnCL        + tEnd,
                0xc1, asReg4, opnEv,  opnIb        + tEnd + eEnd };

UCHAR szSHLD[] = {
          's', 'h', 'l', 'd', '\0',
          0x0f, 0xa4,         opnEv,  opnGv, opnIb + tEnd,
          0x0f, 0xa5,         opnEv,  opnGv, opnCL + tEnd + eEnd };

UCHAR szSHR[] = {
          's', 'h', 'r', '\0',
                0xd0, asReg5, opnEb,  opnIm1       + tEnd,
                0xd2, asReg5, opnEb,  opnCL        + tEnd,
                0xc0, asReg5, opnEb,  opnIb        + tEnd,
                0xd1, asReg5, opnEv,  opnIm1       + tEnd,
                0xd3, asReg5, opnEv,  opnCL        + tEnd,
                0xc1, asReg5, opnEv,  opnIb        + tEnd + eEnd };

UCHAR szSHRD[] = {
          's', 'h', 'r', 'd', '\0',
          0x0f, 0xac,         opnEv,  opnGv, opnIb + tEnd,
          0x0f, 0xad,         opnEv,  opnGv, opnCL + tEnd + eEnd };

UCHAR szSIDT[] = {
          's', 'i', 'd', 't', '\0',
          0x0f, 0x01, asReg1, opnMs                + tEnd + eEnd };

UCHAR szSLDT[] = {
          's', 'l', 'd', 't', '\0',
          0x0f, 0x00, asReg0, opnEw                + tEnd + eEnd };

UCHAR szSMSW[] = {
          's', 'm', 's', 'w', '\0',
          0x0f, 0x01, asReg4, opnEw                + tEnd + eEnd };

UCHAR szSS[] = {
          's', 's', ':', '\0',
                0x26, asPrfx                       + tEnd + eEnd };

UCHAR szSTC[] = {
          's', 't', 'c', '\0',
                0xf9, asNone                       + tEnd + eEnd };

UCHAR szSTD[] = {
          's', 't', 'd', '\0',
                0xfd, asNone                       + tEnd + eEnd };

UCHAR szSTI[] = {
          's', 't', 'i', '\0',
                0xfb, asNone                       + tEnd + eEnd };

UCHAR szSTOS[] = {
          's', 't', 'o', 's', '\0',
                0xaa,         opnYb                + tEnd,
                0xab,         opnYv                + tEnd + eEnd };

UCHAR szSTOSB[] = {
          's', 't', 'o', 's', 'b', '\0',
                0xaa, asNone                       + tEnd + eEnd };

UCHAR szSTOSD[] = {
          's', 't', 'o', 's', 'd', '\0',
                0xab, asSiz1                       + tEnd + eEnd };

UCHAR szSTOSW[] = {
          's', 't', 'o', 's', 'w', '\0',
                0xab, asSiz0                       + tEnd + eEnd };

UCHAR szSTR[] = {
          's', 't', 'r', '\0',
          0x0f, 0x00, asReg1, opnEw                + tEnd + eEnd };

UCHAR szSUB[] = {
          's', 'u', 'b', '\0',
                0x2c,         opnAL,  opnIb        + tEnd,
                0x2d,         opneAX, opnIv        + tEnd,
                0x80, asReg5, opnEb,  opnIb        + tEnd,
                0x83, asReg5, opnEv,  opnIb        + tEnd,
                0x81, asReg5, opnEv,  opnIv        + tEnd,
                0x28,         opnEb,  opnGb        + tEnd,
                0x29,         opnEv,  opnGv        + tEnd,
                0x2a,         opnGb,  opnEb        + tEnd,
                0x2b,         opnGv,  opnEv        + tEnd + eEnd };

UCHAR szTEST[] = {
          't', 'e', 's', 't', '\0',
                0xa8,         opnAL,  opnIb        + tEnd,
                0xa9,         opneAX, opnIv        + tEnd,
                0xf6, asReg0, opnEb,  opnIb        + tEnd,
                0xf7, asReg0, opnEv,  opnIv        + tEnd,
                0x84,         opnEb,  opnGb        + tEnd,
                0x85,         opnEv,  opnGv        + tEnd + eEnd };

UCHAR szVERR[] = {
          'v', 'e', 'r', 'r', '\0',
          0x0f, 0x00, asReg4, opnEw               + tEnd + eEnd };

UCHAR szVERW[] = {
          'v', 'e', 'r', 'w', '\0',
          0x0f, 0x00, asReg5, opnEw               + tEnd + eEnd };

UCHAR szWAIT[] = {                              //  same as FWAIT
          'w', 'a', 'i', 't', '\0',
          0x9b,       asPrfx                      + tEnd + eEnd };

UCHAR szWBINVD[] = {
          'w', 'b', 'i', 'n', 'v', 'd', '\0',
          0x0f, 0x09, asNone                      + tEnd + eEnd };

UCHAR szWRMSR[] = {
          'w', 'r', 'm', 's', 'r', '\0',
          0x0f, 0x30, asNone                      + tEnd + eEnd };


UCHAR szXADD[] = {
          'x', 'a', 'd', 'd', '\0',
          0x0f, 0xc0,         opnEb,  opnGb        + tEnd,
          0x0f, 0xc1,         opnEv,  opnGv        + tEnd + eEnd };

UCHAR szXCHG[] = {
          'x', 'c', 'h', 'g', '\0',
                0x90, asOpRg, opneAX, opnGv        + tEnd,
                0x90, asOpRg, opnGv,  opneAX       + tEnd,
                0x86,         opnGb,  opnEb        + tEnd,
                0x86,         opnEb,  opnGb        + tEnd,
                0x87,         opnGv,  opnEv        + tEnd,
                0x87,         opnEv,  opnGv        + tEnd + eEnd };

UCHAR szXLAT[] = {
          'x', 'l', 'a', 't', '\0',
                0xd7, asNone                       + tEnd,
                0xd7, asSeg,  opnM                 + tEnd + eEnd };

UCHAR szXOR[] = {
          'x', 'o', 'r', '\0',
                0x34,         opnAL,  opnIb        + tEnd,
                0x35,         opneAX, opnIv        + tEnd,
                0x80, asReg6, opnEb,  opnIb        + tEnd,
                0x83, asReg6, opnEv,  opnIb        + tEnd,
                0x81, asReg6, opnEv,  opnIv        + tEnd,
                0x30,         opnEb,  opnGb        + tEnd,
                0x31,         opnEv,  opnGv        + tEnd,
                0x32,         opnGb,  opnEb        + tEnd,
                0x33,         opnGv,  opnEv        + tEnd + eEnd };

PUCHAR OpTable[] = {
    szAAA,     szAAD,     szAAM,     szAAS,     szADC,     szADD,
    szAND,     szARPL,    szBOUND,   szBSF,     szBSR,     szBSWAP,
    szBT,      szBTC,     szBTR,     szBTS,     szCALL,    szCBW,
    szCDQ,     szCLC,     szCLD,     szCLI,     szCLTS,    szCMC,
    szCMP,     szCMPS,    szCMPSB,   szCMPSD,   szCMPSW,   szCMPXCHG,
    szCMPXCHG8B, szCPUID, szCS,      szCWD,     szCWDE,    szDAA,
    szDAS,     szDEC,     szDIV,     szDS,      szENTER,   szES,
    szF2XM1,   szFABS,    szFADD,    szFADDP,   szFBLD,    szFBSTP,
    szFCHS,    szFCLEX,   szFCOM,    szFCOMP,   szFCOMPP,  szFCOS,
    szFDECSTP, szFDISI,   szFDIV,    szFDIVP,   szFDIVR,   szFDIVRP,
    szFENI,    szFFREE,   szFIADD,   szFICOM,   szFICOMP,  szFIDIV,
    szFIDIVR,  szFILD,    szFIMUL,   szFINCSTP, szFINIT,   szFIST,
    szFISTP,   szFISUB,   szFISUBR,  szFLD,     szFLD1,    szFLDCW,
    szFLDENV,  szFLDL2E,  szFLDL2T,  szFLDLG2,  szFLDLN2,  szFLDPI,
    szFLDZ,    szFMUL,    szFMULP,   szFNCLEX,  szFNDISI,  szFNENI,
    szFNINIT,  szFNOP,    szFNSAVE,  szFNSTCW,  szFNSTENV, szFNSTSW,
    szFPATAN,  szFPREM,   szFPREM1,  szFPTAN,   szFRNDINT, szFRSTOR,
    szFS,      szFSAVE,   szFSCALE,  szFSETPM,  szFSIN,    szFSINCOS,
    szFSQRT,   szFST,     szFSTCW,   szFSTENV,  szFSTP,    szFSTSW,
    szFSUB,    szFSUBP,   szFSUBR,   szFSUBRP,  szFTST,    szFUCOM,
    szFUCOMP,  szFUCOMPP, szFWAIT,   szFXAM,    szFXCH,    szFXTRACT,
    szFYL2X,   szFYL2XP1, szGS,      szHLT,     szIDIV,    szIMUL,
    szIN,      szINC,     szINS,     szINSB,    szINSD,    szINSW,
    szINT,     szINTO,    szINVD,    szINVLPG,  szIRET,    szIRETD,
    szJA,      szJAE,     szJB,      szJBE,     szJC,      szJCXZ,
    szJE,      szJECXZ,   szJG,      szJGE,     szJL,      szJLE,
    szJMP,     szJNA,     szJNAE,    szJNB,     szJNBE,    szJNC,
    szJNE,     szJNG,     szJNGE,    szJNL,     szJNLE,    szJNO,
    szJNP,     szJNS,     szJNZ,     szJO,      szJP,      szJPE,
    szJPO,     szJS,      szJZ,      szLAHF,    szLAR,     szLDS,
    szLEA,     szLEAVE,   szLES,     szLFS,     szLGDT,    szLGS,
    szLIDT,    szLLDT,    szLMSW,    szLOCK,    szLODS,    szLODSB,
    szLODSD,   szLODSW,   szLOOP,    szLOOPE,   szLOOPNE,  szLOOPNZ,
    szLOOPZ,   szLSL,     szLSS,     szLTR,     szMOV,     szMOVS,
    szMOVSB,   szMOVSD,   szMOVSW,   szMOVSX,   szMOVZX,   szMUL,
    szNEG,     szNOP,     szNOT,     szOR,      szOUT,     szOUTS,
    szOUTSB,   szOUTSD,   szOUTSW,   szPOP,     szPOPA,    szPOPAD,
    szPOPF,    szPOPFD,   szPUSH,    szPUSHA,   szPUSHAD,  szPUSHF,
    szPUSHFD,  szRCL,     szRCR,     szRDMSR,   szRDTSC,   szREP,
    szREPE,    szREPNE,   szREPNZ,   szREPZ,    szRET,     szRETF,
    szRETN,    szROL,     szROR,     szRSM,     szSAHF,    szSAL,
    szSAR,     szSBB,     szSCAS,    szSCASB,   szSCASD,   szSCASW,
    szSETA,    szSETAE,   szSETB,    szSETBE,   szSETC,    szSETE,
    szSETG,    szSETGE,   szSETL,    szSETLE,   szSETNA,   szSETNAE,
    szSETNB,   szSETNBE,  szSETNC,   szSETNE,   szSETNG,   szSETNGE,
    szSETNL,   szSETNLE,  szSETNO,   szSETNP,   szSETNS,   szSETNZ,
    szSETO,    szSETP,    szSETPE,   szSETPO,   szSETS,    szSETZ,
    szSGDT,    szSHL,     szSHLD,    szSHR,     szSHRD,    szSIDT,
    szSLDT,    szSMSW,    szSS,      szSTC,     szSTD,     szSTI,
    szSTOS,    szSTOSB,   szSTOSD,   szSTOSW,   szSTR,     szSUB,
    szTEST,    szVERR,    szVERW,    szWAIT,    szWBINVD,  szWRMSR,
    szXADD,    szXCHG,    szXLAT,    szXOR
  };

#define OPTABLESIZE (sizeof(OpTable) / sizeof(PUCHAR))


/*** X86SearchOpcode - search for opcode
*
*   Purpose:
*       Search the opcode table for a match with the string
*       pointed by *pszOp.
*
*   Input:
*       *pszOp - string to search as opcode
*
*   Returns:
*       if not -1, index of match entry in opcode table
*       if -1, not found
*
*************************************************************************/

PUCHAR X86SearchOpcode (PUCHAR pszop)
{
    LONG   low = 0;
    LONG   mid;
    LONG   high = OPTABLESIZE - 1;
    LONG   match;

    while (low <= high) {
        mid = (low + high) / 2;
        match = (ULONG)strcmp((char *)pszop, (char *)OpTable[mid]);
        if (match == -1)
            high = mid - 1;
        else if (match == 1)
            low = mid + 1;
        else
            return OpTable[mid] + strlen((char *)OpTable[mid]) + 1;
        }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\ia64_asm.cpp ===
//----------------------------------------------------------------------------
//
// Assemble IA64 machine implementation.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

void
Ia64MachineInfo::Assemble(PADDR paddr, PSTR pchInput)
{
    // Not going to implement assemble command at this time
    ErrOut("No assemble support for IA64\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\i386_dis.h ===
/********************************** module *********************************/
/*                                                                         */
/*                                 disasmtb                                */
/*                           disassembler for CodeView                     */
/*                                                                         */
/***************************************************************************/
/*                                                                         */
/*    @ Purpose:                                                           */
/*                                                                         */
/*    @ Functions included:                                                */
/*                                                                         */
/*                                                                         */
/*    @ Author: Gerd Immeyer              @ Version:                       */
/*                                                                         */
/*    @ Creation Date: 10.19.89           @ Modification Date:             */
/*                                                                         */
/***************************************************************************/

#define X86_REPN  0xf2
#define X86_REP   0xf3

#define X86_PAUSE        0x90
#define X86_MOVFREGMEM   0x110
#define X86_MOVFMEMREG   0x111
#define X86_MOVHLPS      0x112
#define X86_MOVLHPS      0x116
#define X86_CVTSPI2SPSD  0x12a
#define X86_CVTSPSD2SPI  0x12d
#define X86_CVTSPSD2SPSD 0x15a
#define X86_CVTPS        0x15b
#define X86_MOVDQA_MR    0x16f
#define X86_PSHUF        0x170
#define X86_MOVDQ_7E     0x17e
#define X86_MOVDQA_RM    0x17f
#define X86_PINSRW       0x1c4
#define X86_PEXTRW       0x1c5
#define X86_MOVQ_D6      0x1d6
#define X86_PMOVMSKB     0x1d7
#define X86_CVTPD        0x1e6
#define X86_MOVNT        0x1e7
#define X86_MASKMOV      0x1f7

/* Strings: Operand mnemonics, Segment overrides, etc. for disasm          */

char dszAAA[]       = "aaa";
char dszAAD[]       = "aad";
char dszAAM[]       = "aam";
char dszAAS[]       = "aas";
char dszADC[]       = "adc";
char dszADD[]       = "add";
char dszADDSPSD[]   = "add:? ";
char dszADDRPRFX[]  = "";
char dszAND[]       = "and";
char dszANDNPSD[]   = "andnp?";
char dszANDPSD[]    = "andp?";
char dszARPL[]      = "arpl";
char dszBOUND[]     = "bound";
char dszBSF[]       = "bsf";
char dszBSR[]       = "bsr";
char dszBST[]       = "bst";
char dszBSWAP[]     = "bswap";
char dszBT[]        = "bt";
char dszBTC[]       = "btc";
char dszBTR[]       = "btr";
char dszBTS[]       = "bts";
char dszCALL[]      = "call";
char dszCBW[]       = "cbw";
char dszCDQ[]       = "cdq";
char dszCDQE[]      = "cdqe";
char dszCLC[]       = "clc";
char dszCLD[]       = "cld";
char dszCLFLUSH[]   = "clflush";
char dszCLI[]       = "cli";
char dszCLTS[]      = "clts";
char dszCMC[]       = "cmc";
char dszCMOVO[]     = "cmovo";
char dszCMOVNO[]    = "cmovno";
char dszCMOVB[]     = "cmovb";
char dszCMOVNB[]    = "cmovnb";
char dszCMOVE[]     = "cmove";
char dszCMOVNE[]    = "cmovne";
char dszCMOVBE[]    = "cmovbe";
char dszCMOVA[]     = "cmova";
char dszCMOVS[]     = "cmovs";
char dszCMOVNS[]    = "cmovns";
char dszCMOVP[]     = "cmovp";
char dszCMOVNP[]    = "cmovnp";
char dszCMOVL[]     = "cmovl";
char dszCMOVGE[]    = "cmovge";
char dszCMOVLE[]    = "cmovle";
char dszCMOVNLE[]   = "cmovnle";
char dszCMP[]       = "cmp";
char dszCMPSPSD[]   = "cmp:? ";
char dszCMPS[]      = "cmps";
char dszCMPSB[]     = "cmpsb";
char dszCMPSD[]     = "cmpsd";
char dszCMPSW[]     = "cmpsw";
char dszCMPXCHG[]   = "cmpxchg";
char dszCMPXCHG8B[] = "cmpxchg8b";
char dszCOMISSD[]   = "comis? ";
char dszCPUID[]     = "cpuid";
char dszCS_[]       = "cs:";
char dszCVTBASE[]   = "cvt ";
char dszCVTSPI2SPSD[] = "cvt:i2:? ";
char dszCVTSPSD2SPI[] = "cvt:?2:i ";
char dszCVTSPSD2SPSD[] = "cvt:?2:, ";
char dszCVTTSPSD2SPI[] = "cvtt:?2:i ";
char dszCWD[]       = "cwd";
char dszCWDE[]      = "cwde";
char dszDAA[]       = "daa";
char dszDAS[]       = "das";
char dszDEC[]       = "dec";
char dszDIV[]       = "div";
char dszDIVSPSD[]   = "div:? ";
char dszDS_[]       = "ds:";
char dszEMMS[]      = "emms";
char dszENTER[]     = "enter";
char dszES_[]       = "es:";
char dszF2XM1[]     = "f2xm1";
char dszFABS[]      = "fabs";
char dszFADD[]      = "fadd";
char dszFADDP[]     = "faddp";
char dszFBLD[]      = "fbld";
char dszFBSTP[]     = "fbstp";
char dszFCHS[]      = "fchs";
char dszFCLEX[]     = "fclex";
char dszFCMOVB[]    = "fcmovb";
char dszFCMOVE[]    = "fcmove";
char dszFCMOVBE[]   = "fcmovbe";
char dszFCMOVU[]    = "fcmovu";
char dszFCMOVNB[]   = "fcmovnb";
char dszFCMOVNE[]   = "fcmovne";
char dszFCMOVNBE[]  = "fcmovnbe";
char dszFCMOVNU[]   = "fcmovnu";
char dszFCOM[]      = "fcom";
char dszFCOMI[]     = "fcomi";
char dszFCOMIP[]    = "fcomip";
char dszFCOMP[]     = "fcomp";
char dszFCOMPP[]    = "fcompp";
char dszFCOS[]      = "fcos";
char dszFDECSTP[]   = "fdecstp";
char dszFDISI[]     = "fdisi";
char dszFDIV[]      = "fdiv";
char dszFDIVP[]     = "fdivp";
char dszFDIVR[]     = "fdivr";
char dszFDIVRP[]    = "fdivrp";
char dszFEMMS[]     = "femms";
char dszFENI[]      = "feni";
char dszFFREE[]     = "ffree";
char dszFIADD[]     = "fiadd";
char dszFICOM[]     = "ficom";
char dszFICOMP[]    = "ficomp";
char dszFIDIV[]     = "fidiv";
char dszFIDIVR[]    = "fidivr";
char dszFILD[]      = "fild";
char dszFIMUL[]     = "fimul";
char dszFINCSTP[]   = "fincstp";
char dszFINIT[]     = "finit";
char dszFIST[]      = "fist";
char dszFISTP[]     = "fistp";
char dszFISUB[]     = "fisub";
char dszFISUBR[]    = "fisubr";
char dszFLD[]       = "fld";
char dszFLD1[]      = "fld1";
char dszFLDCW[]     = "fldcw";
char dszFLDENV[]    = "fldenv";
char dszFLDL2E[]    = "fldl2e";
char dszFLDL2T[]    = "fldl2t";
char dszFLDLG2[]    = "fldlg2";
char dszFLDLN2[]    = "fldln2";
char dszFLDPI[]     = "fldpi";
char dszFLDZ[]      = "fldz";
char dszFMUL[]      = "fmul";
char dszFMULP[]     = "fmulp";
char dszFNCLEX[]    = "fnclex";
char dszFNDISI[]    = "fndisi";
char dszFNENI[]     = "fneni";
char dszFNINIT[]    = "fninit";
char dszFNOP[]      = "fnop";
char dszFNSAVE[]    = "fnsave";
char dszFNSTCW[]    = "fnstcw";
char dszFNSTENV[]   = "fnstenv";
char dszFNSTSW[]    = "fnstsw";
char dszFNSTSWAX[]  = "fnstswax";
char dszFPATAN[]    = "fpatan";
char dszFPREM[]     = "fprem";
char dszFPREM1[]    = "fprem1";
char dszFPTAN[]     = "fptan";
char dszFRNDINT[]   = "frndint";
char dszFRSTOR[]    = "frstor";
char dszFSAVE[]     = "fsave";
char dszFSCALE[]    = "fscale";
char dszFSETPM[]    = "fsetpm";
char dszFSIN[]      = "fsin";
char dszFSINCOS[]   = "fsincos";
char dszFSQRT[]     = "fsqrt";
char dszFST[]       = "fst";
char dszFSTCW[]     = "fstcw";
char dszFSTENV[]    = "fstenv";
char dszFSTP[]      = "fstp";
char dszFSTSW[]     = "fstsw";
char dszFSTSWAX[]   = "fstswax";
char dszFSUB[]      = "fsub";
char dszFSUBP[]     = "fsubp";
char dszFSUBR[]     = "fsubr";
char dszFSUBRP[]    = "fsubrp";
char dszFS_[]       = "fs:";
char dszFTST[]      = "ftst";
char dszFUCOM[]     = "fucom";
char dszFUCOMI[]    = "fucomi";
char dszFUCOMIP[]   = "fucomip";
char dszFUCOMP[]    = "fucomp";
char dszFUCOMPP[]   = "fucompp";
char dszFWAIT[]     = "fwait";
char dszFXAM[]      = "fxam";
char dszFXCH[]      = "fxch";
char dszFXSAVE[]    = "fxsave";
char dszFXRSTOR[]   = "fxrstor";
char dszFXTRACT[]   = "fxtract";
char dszFYL2X[]     = "fyl2x";
char dszFYL2XP1[]   = "fyl2xp1";
char dszGS_[]       = "gs:";
char dszHLT[]       = "hlt";
char dszIBTS[]      = "ibts";
char dszIDIV[]      = "idiv";
char dszIMUL[]      = "imul";
char dszIN[]        = "in";
char dszINC[]       = "inc";
char dszINS[]       = "ins";
char dszINSB[]      = "insb";
char dszINSD[]      = "insd";
char dszINSW[]      = "insw";
char dszINT[]       = "int";
char dszINTO[]      = "into";
char dszINVD[]      = "invd";
char dszINVLPG[]    = "invlpg";
char dszIRET[]      = "iret";
char dszIRETD[]     = "iretd";
char dszJA[]        = "ja";
char dszJAE[]       = "jae";
char dszJB[]        = "jb";
char dszJBE[]       = "jbe";
char dszJC[]        = "jc";
char dszJCXZ[]      = "jcxz";
char dszJE[]        = "je";
char dszJECXZ[]     = "jecxz";
char dszJG[]        = "jg";
char dszJGE[]       = "jge";
char dszJL[]        = "jl";
char dszJLE[]       = "jle";
char dszJMP[]       = "jmp";
char dszJNA[]       = "jna";
char dszJNAE[]      = "jnae";
char dszJNB[]       = "jnb";
char dszJNBE[]      = "jnbe";
char dszJNC[]       = "jnc";
char dszJNE[]       = "jne";
char dszJNG[]       = "jng";
char dszJNGE[]      = "jnge";
char dszJNL[]       = "jnl";
char dszJNLE[]      = "jnle";
char dszJNO[]       = "jno";
char dszJNP[]       = "jnp";
char dszJNS[]       = "jns";
char dszJNZ[]       = "jnz";
char dszJO[]        = "jo";
char dszJP[]        = "jp";
char dszJPE[]       = "jpe";
char dszJPO[]       = "jpo";
char dszJRCXZ[]     = "jrcxz";
char dszJS[]        = "js";
char dszJZ[]        = "jz";
char dszLAHF[]      = "lahf";
char dszLAR[]       = "lar";
char dszLDMXCSR[]   = "ldmxcsr";
char dszLDS[]       = "lds";
char dszLEA[]       = "lea";
char dszLEAVE[]     = "leave";
char dszLES[]       = "les";
char dszLFENCE[]    = "lfence";
char dszLFS[]       = "lfs";
char dszLGDT[]      = "lgdt";
char dszLGS[]       = "lgs";
char dszLIDT[]      = "lidt";
char dszLLDT[]      = "lldt";
char dszLMSW[]      = "lmsw";
char dszLOCK[]      = "lock";
char dszLODS[]      = "lods";
char dszLODSB[]     = "lodsb";
char dszLODSD[]     = "lodsd";
char dszLODSW[]     = "lodsw";
char dszLOOP[]      = "loop";
char dszLOOPE[]     = "loope";
char dszLOOPNE[]    = "loopne";
char dszLOOPNZ[]    = "loopnz";
char dszLOOPZ[]     = "loopz";
char dszLSL[]       = "lsl";
char dszLSS[]       = "lss";
char dszLTR[]       = "ltr";
char dszMASKMOVDQU[]= "maskmov";
char dszMAXSPSD[]   = "max:? ";
char dszMFENCE[]    = "mfence";
char dszMINSPSD[]   = "min:? ";
char dszMOV[]       = "mov";
char dszMOVBASE[]   = "mov ";
char dszMOVAPSD[]   = "movap? ";
char dszMOVD[]      = "movd";
char dszMOVDQA[]    = "movdqa";
char dszMOVHLPS[]   = "movhlps";
char dszMOVHPSD[]   = "movhp? ";
char dszMOVLHPS[]   = "movlhps";
char dszMOVLPSD[]   = "movlp? ";
char dszMOVMSKPSD[] = "movmskp? ";
char dszMOVNTI[]    = "movnti";
char dszMOVNTPSD[]  = "movntp? ";
char dszMOVNTDQ[]   = "movnt";
char dszMOVQ[]      = "movq";
char dszMOVS[]      = "movs";
char dszMOVSB[]     = "movsb";
char dszMOVSD[]     = "movsd";
char dszMOVSW[]     = "movsw";
char dszMOVSX[]     = "movsx";
char dszMOVSXD[]    = "movsxd";
char dszMOVUPSSDX[] = "mov ";
char dszMOVZX[]     = "movzx";
char dszMUL[]       = "mul";
char dszMULSPSD[]   = "mul:? ";
char dszNEG[]       = "neg";
char dszNOP[]       = "nop";
char dszNOT[]       = "not";
char dszOPPRFX[]    = "";
char dszOR[]        = "or";
char dszORPSD[]     = "orp? ";
char dszOUT[]       = "out";
char dszOUTS[]      = "outs";
char dszOUTSB[]     = "outsb";
char dszOUTSD[]     = "outsd";
char dszOUTSW[]     = "outsw";
char dszPACKSSDW[]  = "packssdw";
char dszPACKSSWB[]  = "packsswb";
char dszPACKUSWB[]  = "packuswb";
char dszPADDB[]     = "paddb";
char dszPADDD[]     = "paddd";
char dszPADDQ[]     = "paddq";
char dszPADDSB[]    = "paddsb";
char dszPADDSW[]    = "paddsw";
char dszPADDUSB[]   = "paddusb";
char dszPADDUSW[]   = "paddusw";
char dszPADDW[]     = "paddw";
char dszPAND[]      = "pand";
char dszPANDN[]     = "pandn";
char dszPAUSE[]     = "pause";
char dszPAVGB[]     = "pavgb";
char dszPAVGW[]     = "pavgw";
char dszPCMPEQB[]   = "pcmpeqb";
char dszPCMPEQD[]   = "pcmpeqd";
char dszPCMPEQW[]   = "pcmpeqw";
char dszPCMPGTB[]   = "pcmpgtb";
char dszPCMPGTD[]   = "pcmpgtd";
char dszPCMPGTW[]   = "pcmpgtw";
char dszPEXTRW[]    = "pextrw";
char dszPINSRW[]    = "pinsrw";
char dszPMADDWD[]   = "pmaddwd";
char dszPMAXSW[]    = "pmaxsw";
char dszPMAXUB[]    = "pmaxub";
char dszPMINSW[]    = "pminsw";
char dszPMINUB[]    = "pminub";
char dszPMOVMSKB[]  = "pmovmskb";
char dszPMULHUW[]   = "pmulhuw";
char dszPMULHW[]    = "pmulhw";
char dszPMULLW[]    = "pmullw";
char dszPMULUDQ[]   = "pmuludq";
char dszPOP[]       = "pop";
char dszPOPA[]      = "popa";
char dszPOPAD[]     = "popad";
char dszPOPF[]      = "popf";
char dszPOPFD[]     = "popfd";
char dszPOR[]       = "por";
char dszPREFETCH[]  = "prefetch";
char dszPREFETCHNTA[] = "prefetchtnta";
char dszPREFETCHT0[] = "prefetcht0";
char dszPREFETCHT1[] = "prefetcht1";
char dszPREFETCHT2[] = "prefetcht2";
char dszPREFETCHW[]  = "prefetchw";
char dszPSADBW[]    = "psadbw";
char dszPSHUF[]     = "pshuf ";
char dszPSLLD[]     = "pslld";
char dszPSLLDQ[]    = "pslldq";
char dszPSLLW[]     = "psllw";
char dszPSLLQ[]     = "psllq";
char dszPSRAD[]     = "psrad";
char dszPSRAW[]     = "psraw";
char dszPSRLD[]     = "psrld";
char dszPSRLDQ[]    = "psrldq";
char dszPSRLQ[]     = "psrlq";
char dszPSRLW[]     = "psrlw";
char dszPSUBB[]     = "psubb";
char dszPSUBD[]     = "psubd";
char dszPSUBQ[]     = "psubq";
char dszPSUBSB[]    = "psubsb";
char dszPSUBSW[]    = "psubsw";
char dszPSUBUSB[]   = "psubusb";
char dszPSUBUSW[]   = "psubusw";
char dszPSUBW[]     = "psubw";
char dszPUNPCKLBW[] = "punpcklbw";
char dszPUNPCKLDQ[] = "punpckldq";
char dszPUNPCKLWD[] = "punpcklwd";
char dszPUNPCKHBW[] = "punpckhbw";
char dszPUNPCKHDQ[] = "punpckhdq";
char dszPUNPCKHWD[] = "punpckhwd";
char dszPUSH[]      = "push";
char dszPUSHA[]     = "pusha";
char dszPUSHAD[]    = "pushad";
char dszPUSHF[]     = "pushf";
char dszPUSHFD[]    = "pushfd";
char dszPXOR[]      = "pxor";
char dszRCL[]       = "rcl";
char dszRCPSPSD[]   = "rcp:? ";
char dszRCR[]       = "rcr";
char dszRDTSC[]     = "rdtsc";
char dszRDMSR[]     = "rdmsr";
char dszRDPMC[]     = "rdpmc";
char dszREP[]       = "rep ";
char dszREPE[]      = "repe";
char dszREPNE[]     = "repne ";
char dszREPNZ[]     = "repnz";
char dszREPZ[]      = "repz";
char dszRET[]       = "ret";
char dszRETF[]      = "retf";
char dszRETN[]      = "retn";
char dszROL[]       = "rol";
char dszROR[]       = "ror";
char dszRSM[]       = "rsm";
char dszRSQRTSPSD[] = "rsqrt:? ";
char dszSAHF[]      = "sahf";
char dszSAL[]       = "sal";
char dszSAR[]       = "sar";
char dszSBB[]       = "sbb";
char dszSCAS[]      = "scas";
char dszSCASB[]     = "scasb";
char dszSCASD[]     = "scasd";
char dszSCASW[]     = "scasw";
char dszSETA[]      = "seta";
char dszSETAE[]     = "setae";
char dszSETB[]      = "setb";
char dszSETBE[]     = "setbe";
char dszSETC[]      = "setc";
char dszSETE[]      = "sete";
char dszSETG[]      = "setg";
char dszSETGE[]     = "setge";
char dszSETL[]      = "setl";
char dszSETLE[]     = "setle";
char dszSETNA[]     = "setna";
char dszSETNAE[]    = "setnae";
char dszSETNB[]     = "setnb";
char dszSETNBE[]    = "setnbe";
char dszSETNC[]     = "setnc";
char dszSETNE[]     = "setne";
char dszSETNG[]     = "setng";
char dszSETNGE[]    = "setnge";
char dszSETNL[]     = "setnl";
char dszSETNLE[]    = "setnle";
char dszSETNO[]     = "setno";
char dszSETNP[]     = "setnp";
char dszSETNS[]     = "setns";
char dszSETNZ[]     = "setnz";
char dszSETO[]      = "seto";
char dszSETP[]      = "setp";
char dszSETPE[]     = "setpe";
char dszSETPO[]     = "setpo";
char dszSETS[]      = "sets";
char dszSETZ[]      = "setz";
char dszSFENCE[]    = "sfence";
char dszSGDT[]      = "sgdt";
char dszSHL[]       = "shl";
char dszSHLD[]      = "shld";
char dszSHR[]       = "shr";
char dszSHRD[]      = "shrd";
char dszSHUFPSD[]   = "shufp? ";
char dszSIDT[]      = "sidt";
char dszSLDT[]      = "sldt";
char dszSMSW[]      = "smsw";
char dszSQRTSPSD[]  = "sqrt:? ";
char dszSS_[]       = "ss:";
char dszSTC[]       = "stc";
char dszSTD[]       = "std";
char dszSTI[]       = "sti";
char dszSTMXCSR[]   = "stmxcsr";
char dszSTOS[]      = "stos";
char dszSTOSB[]     = "stosb";
char dszSTOSD[]     = "stosd";
char dszSTOSW[]     = "stosw";
char dszSTR[]       = "str";
char dszSUB[]       = "sub";
char dszSUBSPSD[]   = "sub:? ";
char dszSYSCALL[]   = "syscall";
char dszSYSENTER[]  = "sysenter";
char dszSYSEXIT[]   = "sysexit";
char dszSYSRET[]    = "sysret";
char dszTEST[]      = "test";
char dszUCOMISSD[]  = "ucomis? ";
char dszUD2[]       = "ud2";
char dszUNPCKHPSD[] = "unpckhp? ";
char dszUNPCKLPSD[] = "unpcklp? ";
char dszVERR[]      = "verr";
char dszVERW[]      = "verw";
char dszWAIT[]      = "wait";
char dszWBINVD[]    = "wbinvd";
char dszWRMSR[]     = "wrmsr";
char dszXADD[]      = "xadd";
char dszXBTS[]      = "xbts";
char dszXCHG[]      = "xchg";
char dszXLAT[]      = "xlat";
char dszXOR[]       = "xor";
char dszXORPSD[]    = "xorp? ";
char dszRESERVED[]  = "???";
char dszMULTI[]     = "";
char dszDB[]        = "db";

#define MRM        0x40
#define COM        0x80
#define END        0xc0

/* Enumeration of valid actions that can be included in the action table */

enum oprtyp { ADDRP,  ADR_OVR, ALSTR,   ALT,     AXSTR,  BOREG,
              BREG,   BRSTR,   xBYTE,   CHR,     CREG,   xDWORD,
              EDWORD, EGROUPT, FARPTR,  X86_GROUP, GROUPT, IB,
              IST,    IST_ST,  IV,      IW,      LMODRM, MODRM,
              NOP,    OFFS,    OPC0F,   OPR_OVR, QWORD,  REL16,
              REL8,   REP,     SEG_OVR, SREG2,   SREG3,  ST_IST,
              STROP,  TBYTE,   UBYTE,   VAR,     VOREG,  VREG,
              xWORD,  WREG,    WRSTR,   MMWREG,  MMQWORD,XMMWREG,
              OWORD,  XMMOWORD,XMMSD,   CMPIB,   XMMXWORD, MMORWREG,
              XORMMREG, XB,    JCC8,    JCCX,    AMD3DNOW,
            };

/* Enumeration of indices into the action table for instruction classes */

#define O_DoDB          0
#define O_NoOperands    0
#define O_NoOpAlt5      O_NoOperands+1
#define O_NoOpAlt4      O_NoOpAlt5+2
#define O_NoOpAlt3      O_NoOpAlt4+2
#define O_NoOpAlt1      O_NoOpAlt3+2
#define O_NoOpAlt0      O_NoOpAlt1+2
#define O_NoOpStrSI     O_NoOpAlt0+2
#define O_NoOpStrDI     O_NoOpStrSI+2
#define O_NoOpStrSIDI   O_NoOpStrDI+2
#define O_bModrm_Reg    O_NoOpStrSIDI+2
#define O_vModrm_Reg    O_bModrm_Reg+3
#define O_Modrm_Reg     O_vModrm_Reg+3
#define O_bReg_Modrm    O_Modrm_Reg+3
#define O_fReg_Modrm    O_bReg_Modrm+3
#define O_Reg_Modrm     O_fReg_Modrm+3
#define O_AL_Ib         O_Reg_Modrm+3
#define O_AX_Iv         O_AL_Ib+2
#define O_sReg2         O_AX_Iv+2
#define O_oReg          O_sReg2+1
#define O_DoBound       O_oReg+1
#define O_Iv            O_DoBound+3
#define O_wModrm_Reg    O_Iv+1
#define O_Ib            O_wModrm_Reg+3
#define O_Imulxb        O_Ib+1
#define O_Imul          O_Imulxb+4
#define O_Rel8          O_Imul+4
#define O_bModrm_Ib     O_Rel8+1
#define O_Modrm_Ib      O_bModrm_Ib+3
#define O_Modrm_Iv      O_Modrm_Ib+3
#define O_Modrm_sReg3   O_Modrm_Iv+3
#define O_sReg3_Modrm   O_Modrm_sReg3+3
#define O_Modrm         O_sReg3_Modrm+3
#define O_FarPtr        O_Modrm+2
#define O_AL_Offs       O_FarPtr+1
#define O_Offs_AL       O_AL_Offs+2
#define O_AX_Offs       O_Offs_AL+2
#define O_Offs_AX       O_AX_Offs+2
#define O_oReg_Ib       O_Offs_AX+2
#define O_oReg_Iv       O_oReg_Ib+2
#define O_Iw            O_oReg_Iv+2
#define O_Enter         O_Iw+1
#define O_Ubyte_AL      O_Enter+2
#define O_Ubyte_AX      O_Ubyte_AL+2
#define O_AL_Ubyte      O_Ubyte_AX+2
#define O_AX_Ubyte      O_AL_Ubyte+2
#define O_DoInAL        O_AX_Ubyte+2
#define O_DoInAX        O_DoInAL+3
#define O_DoOutAL       O_DoInAX+3
#define O_DoOutAX       O_DoOutAL+3
#define O_Rel16         O_DoOutAX+3
#define O_ADR_OVERRIDE  O_Rel16+1
#define O_OPR_OVERRIDE  O_ADR_OVERRIDE+1
#define O_SEG_OVERRIDE  O_OPR_OVERRIDE+1
#define O_DoInt3        O_SEG_OVERRIDE+1

#if (O_DoInt3 != 115)
#error "operand table has been modified!"
#endif
/* #define O_DoInt      O_DoInt3+2 */

#define O_DoInt         117
#define O_OPC0F         O_DoInt+1
#define O_GROUP11       O_OPC0F+1
#define O_GROUP13       O_GROUP11+5
#define O_GROUP12       O_GROUP13+5
#define O_GROUP21       O_GROUP12+5
#define O_GROUP22       O_GROUP21+5
#define O_GROUP23       O_GROUP22+5
#define O_GROUP24       O_GROUP23+6
#define O_GROUP25       O_GROUP24+6
#define O_GROUP26       O_GROUP25+6
#define O_GROUP4        O_GROUP26+6
#define O_GROUP6        O_GROUP4+4
#define O_GROUP8        O_GROUP6+4
#define O_GROUP31       O_GROUP8+5
#define O_GROUP32       O_GROUP31+3
#define O_GROUP5        O_GROUP32+3
#define O_GROUP7        O_GROUP5+3
#define O_x87_ESC       O_GROUP7+3
#define O_bModrm        O_x87_ESC+2
#define O_wModrm        O_bModrm+2
#define O_dModrm        O_wModrm+2
#define O_fModrm        O_dModrm+2
#define O_vModrm        O_fModrm+2
#define O_vModrm_Iv     O_vModrm+2
#define O_Reg_bModrm    O_vModrm_Iv+3
#define O_Reg_wModrm    O_Reg_bModrm+3
#define O_Modrm_Reg_Ib  O_Reg_wModrm+3
#define O_Modrm_Reg_CL  O_Modrm_Reg_Ib+4
#define O_ST_iST        O_Modrm_Reg_CL+5
#define O_iST           O_ST_iST+2
#define O_iST_ST        O_iST+2
#define O_qModrm        O_iST_ST+2
#define O_tModrm        O_qModrm+2
#define O_DoRep         O_tModrm+2
#define O_Modrm_CReg    O_DoRep+1
#define O_CReg_Modrm    O_Modrm_CReg+3
#define O_AX_oReg       O_CReg_Modrm+3
#define O_MmReg_qModrm  O_AX_oReg+2
#define O_qModrm_MmReg  O_MmReg_qModrm+3
#define O_MmReg_dModrm  O_qModrm_MmReg+3
#define O_dModrm_MmReg  O_MmReg_dModrm+3
#define O_qModrm_Ib     O_dModrm_MmReg+3
#define O_PSHimw        O_qModrm_Ib+3
#define O_PSHimd        O_PSHimw+5
#define O_PSHimq        O_PSHimd+5
#define O_GROUP_0F_AE   O_PSHimq+5
#define O_Sd_XmmReg_oModrm O_GROUP_0F_AE+3
#define O_Sd_oModrm_XmmReg O_Sd_XmmReg_oModrm+4
#define O_Sd_Reg_XmmReg    O_Sd_oModrm_XmmReg+4
#define O_Sd_XmmReg_oModrm_CmpIb O_Sd_Reg_XmmReg+3
#define O_Sd_XmmReg_xModrm O_Sd_XmmReg_oModrm_CmpIb+5
#define O_Sd_MmOrWReg_oModrm O_Sd_XmmReg_xModrm+4
#define O_Sd_XOrMmReg_XOrMmReg O_Sd_MmOrWReg_oModrm+4
#define O_Sd_xModrm_XOrMmReg O_Sd_XOrMmReg_XOrMmReg+3
#define O_GROUP_0F_18   O_Sd_xModrm_XOrMmReg+4
#define O_Sd_XmmReg_oModrm_Ib O_GROUP_0F_18+3
#define O_Jcc8          O_Sd_XmmReg_oModrm_Ib+5
#define O_JccX          O_Jcc8+1
#define O_Sd_XmmReg_qModrm O_JccX+1
#define O_MmReg_dModrm_Ib O_Sd_XmmReg_qModrm+4
#define O_Reg_MmReg_Ib  O_MmReg_dModrm_Ib+4
#define O_Reg_MmReg O_Reg_MmReg_Ib+4
#define O_MmReg_qModrm_3DNow O_Reg_MmReg+3
#define O_GROUP_0F_0D   O_MmReg_qModrm_3DNow+4
#define O_length        O_GROUP_0F_0D+4

typedef unsigned short ActionIndex;

#if( O_length > 65535 )
#error "operand table too large!"
#endif


/* The action table: range of lists of actions to be taken for each possible */
/*   instruction class.                                                      */

static unsigned char actiontbl[] = {
/* NoOperands  */ NOP+END,
/* NoOpAlt5    */ ALT+END,   5,
/* NoOpAlt4    */ ALT+END,   4,
/* NoOpAlt3    */ ALT+END,   3,
/* NoOpAlt1    */ ALT+END,   1,
/* NoOpAlt0    */ ALT+END,   0,
/* NoOpStrSI   */ STROP+END, 1,
/* NoOpStrDI   */ STROP+END, 2,
/* NoOpStrSIDI */ STROP+END, 3,
/* bModrm_Reg  */ xBYTE+MRM, MODRM+COM,  BREG+END,
/* vModrm_Reg  */ VAR+MRM,   LMODRM+COM, BREG+END,
/* Modrm_Reg   */ VAR+MRM,   MODRM+COM,  VREG+END,
/* bReg_Modrm  */ xBYTE+MRM, BREG+COM,   MODRM+END,
/* fReg_Modrm  */ FARPTR+MRM,VREG+COM,   MODRM+END,
/* Reg_Modrm   */ VAR+MRM,   VREG+COM,   MODRM+END,
/* AL_Ib       */ ALSTR+COM, IB+END,
/* AX_Iv       */ AXSTR+COM, IV+END,
/* sReg2       */ SREG2+END,
/* oReg        */ VOREG+END,
/* DoBound     */ VAR+MRM,   VREG+COM,   MODRM+END,
/* Iv          */ IV+END,
/* wModrm_Reg  */ xWORD+MRM, LMODRM+COM, WREG+END,
/* Ib          */ IB+END,
/* Imulxb      */ VAR+MRM,   VREG+COM,   MODRM+COM, XB+END,
/* Imul        */ VAR+MRM,   VREG+COM,   MODRM+COM, IV+END,
/* REL8        */ REL8+END,
/* bModrm_Ib   */ xBYTE+MRM, LMODRM+COM, IB+END,
/* Modrm_Ib    */ VAR+MRM,   LMODRM+COM, IB+END,
/* Modrm_Iv    */ VAR+MRM,   LMODRM+COM, IV+END,
/* Modrm_sReg3 */ xWORD+MRM, MODRM+COM,  SREG3+END,
/* sReg3_Modrm */ xWORD+MRM, SREG3+COM,  MODRM+END,
/* Modrm       */ VAR+MRM,   MODRM+END,
/* FarPtr      */ ADDRP+END,
/* AL_Offs     */ ALSTR+COM, OFFS+END,
/* Offs_AL     */ OFFS+COM,  ALSTR+END,
/* AX_Offs     */ AXSTR+COM, OFFS+END,
/* Offs_AX     */ OFFS+COM,  AXSTR+END,
/* oReg_Ib     */ BOREG+COM, IB+END,
/* oReg_Iv     */ VOREG+COM, IV+END,
/* Iw          */ IW+END,
/* enter       */ IW+COM,    IB+END,
/* Ubyte_AL    */ UBYTE+COM, ALSTR+END,
/* Ubyte_AX    */ UBYTE+COM, AXSTR+END,
/* AL_Ubyte    */ ALSTR+COM, UBYTE+END,
/* AX_Ubyte    */ AXSTR+COM, UBYTE+END,
/* DoInAL      */ ALSTR+COM, WRSTR+END,  2,
/* DoInAX      */ AXSTR+COM, WRSTR+END,  2,
/* DoOutAL     */ WRSTR+COM, 2,          ALSTR+END,
/* DoOutAX     */ WRSTR+COM, 2,          AXSTR+END,
/* REL16       */ REL16+END,
/* ADR_OVERRIDE*/ ADR_OVR,
/* OPR_OVERRIDE*/ OPR_OVR,
/* SEG_OVERRIDE*/ SEG_OVR,
/* DoInt3      */ CHR+END,   '3',
/* DoInt       */ UBYTE+END,
/* Opcode0F    */ OPC0F,
/* group1_1    */ xBYTE+MRM, X86_GROUP,  0,         LMODRM+COM, IB+END,
/* group1_3    */ VAR+MRM,   X86_GROUP,  0,         LMODRM+COM, XB+END,
/* group1_2    */ VAR+MRM,   X86_GROUP,  0,         LMODRM+COM, IV+END,
/* group2_1    */ xBYTE+MRM, X86_GROUP,  1,         LMODRM+COM, IB+END,
/* group2_2    */ VAR+MRM,   X86_GROUP,  1,         LMODRM+COM, IB+END,
/* group2_3    */ xBYTE+MRM, X86_GROUP,  1,         LMODRM+COM, CHR+END, '1',
/* group2_4    */ VAR+MRM,   X86_GROUP,  1,         LMODRM+COM, CHR+END, '1',
/* group2_5    */ xBYTE+MRM, X86_GROUP,  1,         LMODRM+COM, BRSTR+END, 1,
/* group2_6    */ VAR+MRM,   X86_GROUP,  1,         LMODRM+COM, BRSTR+END, 1,
/* group4      */ xBYTE+MRM, X86_GROUP,  2,         LMODRM+END,
/* group6      */ xWORD+MRM, X86_GROUP,  3,         LMODRM+END,
/* group8      */ xWORD+MRM, X86_GROUP,  4,         LMODRM+COM, IB+END,
/* group3_1    */ xBYTE+MRM, GROUPT,     20,
/* group3_2    */ VAR+MRM,   GROUPT,     21,
/* group5      */ VAR+MRM,   GROUPT,     22,
/* group7      */ NOP+MRM,   GROUPT,     23,
/* x87_ESC     */ NOP+MRM,   EGROUPT,
/* bModrm      */ xBYTE+MRM, LMODRM+END,
/* wModrm      */ xWORD+MRM, LMODRM+END,
/* dModrm      */ xDWORD+MRM,LMODRM+END,
/* fModrm      */ FARPTR+MRM,LMODRM+END,
/* vModrm      */ VAR+MRM,   LMODRM+END,
/* vModrm_Iv   */ VAR+MRM,   LMODRM+COM, IV+END,
/* reg_bModrm  */ xBYTE+MRM, VREG+COM,   LMODRM+END,
/* reg_wModrm  */ xWORD+MRM, VREG+COM,   LMODRM+END,
/* Modrm_Reg_Ib*/ VAR+MRM,   MODRM+COM,  VREG+COM,   IB+END,
/* Modrm_Reg_CL*/ VAR+MRM,   MODRM+COM,  VREG+COM,   BRSTR+END, 1,
/* ST_iST      */ NOP+MRM,   ST_IST+END,
/* iST         */ NOP+MRM,   IST+END,
/* iST_ST      */ NOP+MRM,   IST_ST+END,
/* qModrm      */ QWORD+MRM, LMODRM+END,
/* tModrm      */ TBYTE+MRM, LMODRM+END,
/* REP         */ REP,
/* Modrm_CReg  */ EDWORD+MRM,MODRM+COM,  CREG+END,
/* CReg_Modrm  */ EDWORD+MRM,CREG+COM,   MODRM+END,
/* AX_oReg     */ AXSTR+COM, VOREG+END,
/* MmReg_qModrm*/ MMQWORD+MRM, MMWREG+COM, LMODRM+END,
/* qModrm_MmReg*/ MMQWORD+MRM, LMODRM+COM, MMWREG+END,
/* MmReg_dModrm*/ xDWORD+MRM, MMWREG+COM, LMODRM+END,
/* dModrm_MmReg*/ xDWORD+MRM, LMODRM+COM, MMWREG+END,
/* qModrm_Ib   */ MMQWORD+MRM, LMODRM+COM, IB+END,
/* PSHimw      */ MMQWORD+MRM, X86_GROUP,5,          MMWREG+COM, IB+END,
/* PSHimd      */ MMQWORD+MRM, X86_GROUP,6,          MMWREG+COM, IB+END,
/* PSHimq      */ MMQWORD+MRM, X86_GROUP,7,          MMWREG+COM, IB+END,
/* group_0f_ae */ NOP+MRM,   GROUPT,     25,
/* Sd_XmmReg_oModrm*/ XMMSD, XMMOWORD+MRM, XMMWREG+COM, LMODRM+END,
/* Sd_oModrm_XmmReg*/ XMMSD, XMMOWORD+MRM, LMODRM+COM,  XMMWREG+END,
/* Sd_Reg_XmmReg  */ XMMSD+MRM, VREG+COM, XMMWREG+END,
/* Sd_XmmReg_oModrm_CmpIb */ XMMSD, XMMOWORD+MRM, XMMWREG+COM, LMODRM+COM, CMPIB+END,
/* Sd_XmmReg_xModrm*/ XMMSD, XMMXWORD+MRM, XMMWREG+COM, LMODRM+END,
/* Sd_MmOrWReg_xModrm*/ XMMSD, XMMOWORD+MRM, MMORWREG+COM, LMODRM+END,
/* Sd_XOrMmReg_XOrMmReg */ XMMSD+MRM, XORMMREG+COM, LMODRM+END,
/* Sd_xModrm_XOrMmReg */ XMMSD, XMMXWORD+MRM, LMODRM+COM, XORMMREG+END,
/* group_0f_18 */ NOP+MRM,   GROUPT,     26,
/* Sd_XmmReg_oModrm_Ib */ XMMSD, XMMOWORD+MRM, XMMWREG+COM, LMODRM+COM, IB+END,
/* Jcc8        */ JCC8+END,
/* JccX        */ JCCX+END,
/* Sd_XmmReg_qModrm*/ XMMSD, MMQWORD+MRM, XMMWREG+COM, LMODRM+END,
/* MmReg_dModrm_Ib*/ xWORD+MRM, MMWREG+COM, LMODRM+COM, IB+END,
/* Reg_MmReg_Ib*/ MMQWORD+MRM, VREG+COM, MMWREG+COM, IB+END,
/* Reg_MmReg   */ NOP+MRM, VREG+COM, MMWREG+END,
/* MmReg_qModrm_3DNow*/ MMQWORD+MRM, MMWREG+COM, LMODRM, AMD3DNOW+END,
/* group_0f_0d */ xBYTE+MRM, X86_GROUP,  8,         LMODRM+END,
};

#if defined(_M_IX86)
#define BUILDING_ON_X86 1
#else
#define BUILDING_ON_X86 0
#endif

#if BUILDING_ON_X86 == 1
#pragma pack(1)
#endif

typedef struct Tdistbl{
    char *instruct;
    ActionIndex opr;
    } Tdistbl;

#if BUILDING_ON_X86 == 1
#pragma pack()
#endif

/* List of ordered pairs for each instruction:                           */
/*    (pointer to string literal mnemonic,                               */
/*     instruction class index for action table)                         */

static Tdistbl distbl[] = {
    dszADD,   O_bModrm_Reg,             /* 00 ADD mem/reg, reg (byte)    */
    dszADD,   O_Modrm_Reg,              /* 01 ADD mem/reg, reg (word)    */
    dszADD,   O_bReg_Modrm,             /* 02 ADD reg, mem/reg (byte)    */
    dszADD,   O_Reg_Modrm,              /* 03 ADD reg, mem/reg (word)    */
    dszADD,   O_AL_Ib,                  /* 04 ADD AL, I                  */
    dszADD,   O_AX_Iv,                  /* 05 ADD AX, I                  */
    dszPUSH,  O_sReg2,                  /* 06 PUSH ES                    */
    dszPOP,   O_sReg2,                  /* 07 POP ES                     */
    dszOR,    O_bModrm_Reg,             /* 08 OR mem/reg, reg (byte)     */
    dszOR,    O_Modrm_Reg,              /* 09 OR mem/reg, reg (word)     */
    dszOR,    O_bReg_Modrm,             /* 0A OR reg, mem/reg (byte)     */
    dszOR,    O_Reg_Modrm,              /* 0B OR reg, mem/reg (word)     */
    dszOR,    O_AL_Ib,                  /* 0C OR AL, I                   */
    dszOR,    O_AX_Iv,                  /* 0D OR AX, I                   */
    dszPUSH,  O_sReg2,                  /* 0E PUSH CS                    */
    dszMULTI, O_OPC0F,                  /* 0F CLTS & protection ctl(286) */
    dszADC,   O_bModrm_Reg,             /* 10 ADC mem/reg, reg (byte)    */
    dszADC,   O_Modrm_Reg,              /* 11 ADC mem/reg, reg (word)    */
    dszADC,   O_bReg_Modrm,             /* 12 ADC reg, mem/reg (byte)    */
    dszADC,   O_Reg_Modrm,              /* 13 ADC reg, mem/reg (word)    */
    dszADC,   O_AL_Ib,                  /* 14 ADC AL, I                  */
    dszADC,   O_AX_Iv,                  /* 15 ADC AX, I                  */
    dszPUSH,  O_sReg2,                  /* 16 PUSH SS                    */
    dszPOP,   O_sReg2,                  /* 17 POP SS                     */
    dszSBB,   O_bModrm_Reg,             /* 18 SBB mem/reg, reg (byte)    */
    dszSBB,   O_Modrm_Reg,              /* 19 SBB mem/reg, reg (word)    */
    dszSBB,   O_bReg_Modrm,             /* 1A SBB reg, mem/reg (byte)    */
    dszSBB,   O_Reg_Modrm,              /* 1B SBB reg, mem/reg (word)    */
    dszSBB,   O_AL_Ib,                  /* 1C SBB AL, I                  */
    dszSBB,   O_AX_Iv,                  /* 1D SBB AX, I                  */
    dszPUSH,  O_sReg2,                  /* 1E PUSH DS                    */
    dszPOP,   O_sReg2,                  /* 1F POP DS                     */
    dszAND,   O_bModrm_Reg,             /* 20 AND mem/reg, reg (byte)    */
    dszAND,   O_Modrm_Reg,              /* 21 AND mem/reg, reg (word)    */
    dszAND,   O_bReg_Modrm,             /* 22 AND reg, mem/reg (byte)    */
    dszAND,   O_Reg_Modrm,              /* 23 AND reg, mem/reg (word)    */
    dszAND,   O_AL_Ib,                  /* 24 AND AL, I                  */
    dszAND,   O_AX_Iv,                  /* 25 AND AX, I                  */
    dszES_,   O_SEG_OVERRIDE,           /* 26 SEG ES:                    */
    dszDAA,   O_NoOperands,             /* 27 DAA                        */
    dszSUB,   O_bModrm_Reg,             /* 28 SUB mem/reg, reg (byte)    */
    dszSUB,   O_Modrm_Reg,              /* 29 SUB mem/reg, reg (word)    */
    dszSUB,   O_bReg_Modrm,             /* 2A SUB reg, mem/reg (byte)    */
    dszSUB,   O_Reg_Modrm,              /* 2B SUB reg, mem/reg (word)    */
    dszSUB,   O_AL_Ib,                  /* 2C SUB AL, I                  */
    dszSUB,   O_AX_Iv,                  /* 2D SUB AX, I                  */
    dszCS_,   O_SEG_OVERRIDE,           /* 2E SEG CS:                    */
    dszDAS,   O_NoOperands,             /* 2F DAS                        */
    dszXOR,   O_bModrm_Reg,             /* 30 XOR mem/reg, reg (byte)    */
    dszXOR,   O_Modrm_Reg,              /* 31 XOR mem/reg, reg (word)    */
    dszXOR,   O_bReg_Modrm,             /* 32 XOR reg, mem/reg (byte)    */
    dszXOR,   O_Reg_Modrm,              /* 33 XOR reg, mem/reg (word)    */
    dszXOR,   O_AL_Ib,                  /* 34 XOR AL, I                  */
    dszXOR,   O_AX_Iv,                  /* 35 XOR AX, I                  */
    dszSS_,   O_SEG_OVERRIDE,           /* 36 SEG SS:                    */
    dszAAA,   O_NoOperands,             /* 37 AAA                        */
    dszCMP,   O_bModrm_Reg,             /* 38 CMP mem/reg, reg (byte)    */
    dszCMP,   O_Modrm_Reg,              /* 39 CMP mem/reg, reg (word)    */
    dszCMP,   O_bReg_Modrm,             /* 3A CMP reg, mem/reg (byte)    */
    dszCMP,   O_Reg_Modrm,              /* 3B CMP reg, mem/reg (word)    */
    dszCMP,   O_AL_Ib,                  /* 3C CMP AL, I                  */
    dszCMP,   O_AX_Iv,                  /* 3D CMP AX, I                  */
    dszDS_,   O_SEG_OVERRIDE,           /* 3E SEG DS:                    */
    dszAAS,   O_NoOperands,             /* 3F AAS                        */
    dszINC,   O_oReg,                   /* 40 INC AX                     */
    dszINC,   O_oReg,                   /* 41 INC CX                     */
    dszINC,   O_oReg,                   /* 42 INC DX                     */
    dszINC,   O_oReg,                   /* 43 INC BX                     */
    dszINC,   O_oReg,                   /* 44 INC SP                     */
    dszINC,   O_oReg,                   /* 45 INC BP                     */
    dszINC,   O_oReg,                   /* 46 INC SI                     */
    dszINC,   O_oReg,                   /* 47 INC DI                     */
    dszDEC,   O_oReg,                   /* 48 DEC AX                     */
    dszDEC,   O_oReg,                   /* 49 DEC CX                     */
    dszDEC,   O_oReg,                   /* 4A DEC DX                     */
    dszDEC,   O_oReg,                   /* 4B DEC BX                     */
    dszDEC,   O_oReg,                   /* 4C DEC SP                     */
    dszDEC,   O_oReg,                   /* 4D DEC BP                     */
    dszDEC,   O_oReg,                   /* 4E DEC SI                     */
    dszDEC,   O_oReg,                   /* 4F DEC DI                     */
    dszPUSH,  O_oReg,                   /* 50 PUSH AX                    */
    dszPUSH,  O_oReg,                   /* 51 PUSH CX                    */
    dszPUSH,  O_oReg,                   /* 52 PUSH DX                    */
    dszPUSH,  O_oReg,                   /* 53 PUSH BX                    */
    dszPUSH,  O_oReg,                   /* 54 PUSH SP                    */
    dszPUSH,  O_oReg,                   /* 55 PUSH BP                    */
    dszPUSH,  O_oReg,                   /* 56 PUSH SI                    */
    dszPUSH,  O_oReg,                   /* 57 PUSH DI                    */
    dszPOP,   O_oReg,                   /* 58 POP AX                     */
    dszPOP,   O_oReg,                   /* 59 POP CX                     */
    dszPOP,   O_oReg,                   /* 5A POP DX                     */
    dszPOP,   O_oReg,                   /* 5B POP BX                     */
    dszPOP,   O_oReg,                   /* 5C POP SP                     */
    dszPOP,   O_oReg,                   /* 5D POP BP                     */
    dszPOP,   O_oReg,                   /* 5E POP SI                     */
    dszPOP,   O_oReg,                   /* 5F POP DI                     */
    dszPUSHA, O_NoOpAlt5,               /* 60 PUSHA (286) / PUSHAD (386) */
    dszPOPA,  O_NoOpAlt4,               /* 61 POPA (286) / POPAD (286)   */
    dszBOUND, O_DoBound,                /* 62 BOUND reg, Modrm (286)     */
    dszARPL,  O_Modrm_Reg,              /* 63 ARPL Modrm, reg (286)      */
    dszFS_,   O_SEG_OVERRIDE,           /* 64                            */
    dszGS_,   O_SEG_OVERRIDE,           /* 65                            */
    dszOPPRFX,O_OPR_OVERRIDE,           /* 66                            */
    dszADDRPRFX,O_ADR_OVERRIDE,         /* 67                            */
    dszPUSH,  O_Iv,                     /* 68 PUSH word (286)            */
    dszIMUL,  O_Imul,                   /* 69 IMUL (286)                 */
    dszPUSH,  O_Ib,                     /* 6A PUSH byte (286)            */
    dszIMUL,  O_Imulxb,                 /* 6B IMUL (286)                 */
    dszINSB,  O_NoOperands,             /* 6C INSB (286)                 */
    dszINSW,  O_NoOpAlt3,               /* 6D INSW (286) / INSD (386)    */
    dszOUTSB, O_NoOperands,             /* 6E OUTSB (286)                */
    dszOUTSW, O_NoOpAlt4,               /* 6F OUTSW (286) / OUTSD (386)  */
    dszJO,    O_Jcc8,                   /* 70 JO                         */
    dszJNO,   O_Jcc8,                   /* 71 JNO                        */
    dszJB,    O_Jcc8,                   /* 72 JB or JNAE or JC           */
    dszJNB,   O_Jcc8,                   /* 73 JNB or JAE or JNC          */
    dszJZ,    O_Jcc8,                   /* 74 JE or JZ                   */
    dszJNZ,   O_Jcc8,                   /* 75 JNE or JNZ                 */
    dszJBE,   O_Jcc8,                   /* 76 JBE or JNA                 */
    dszJA,    O_Jcc8,                   /* 77 JNBE or JA                 */
    dszJS,    O_Jcc8,                   /* 78 JS                         */
    dszJNS,   O_Jcc8,                   /* 79 JNS                        */
    dszJPE,   O_Jcc8,                   /* 7A JP or JPE                  */
    dszJPO,   O_Jcc8,                   /* 7B JNP or JPO                 */
    dszJL,    O_Jcc8,                   /* 7C JL or JNGE                 */
    dszJGE,   O_Jcc8,                   /* 7D JNL or JGE                 */
    dszJLE,   O_Jcc8,                   /* 7E JLE or JNG                 */
    dszJG,    O_Jcc8,                   /* 7F JNLE or JG                 */
    dszMULTI, O_GROUP11,                /* 80                            */
    dszMULTI, O_GROUP12,                /* 81                            */
    dszRESERVED, O_DoDB,                /* 82                            */
    dszMULTI, O_GROUP13,                /* 83                            */
    dszTEST,  O_bModrm_Reg,             /* 84 TEST reg, mem/reg (byte)   */
    dszTEST,  O_Modrm_Reg,              /* 85 TEST reg, mem/reg (word)   */
    dszXCHG,  O_bModrm_Reg,             /* 86 XCHG reg, mem/reg (byte)   */
    dszXCHG,  O_Modrm_Reg,              /* 87 XCHG reg, mem/reg (word)   */
    dszMOV,   O_bModrm_Reg,             /* 88 MOV mem/reg, reg (byte)    */
    dszMOV,   O_Modrm_Reg,              /* 89 MOV mem/reg, reg (word)    */
    dszMOV,   O_bReg_Modrm,             /* 8A MOV reg, mem/reg (byte)    */
    dszMOV,   O_Reg_Modrm,              /* 8B MOV reg, mem/reg (word)    */
    dszMOV,   O_Modrm_sReg3,            /* 8C MOV mem/reg, segreg        */
    dszLEA,   O_Reg_Modrm,              /* 8D LEA reg, mem               */
    dszMOV,   O_sReg3_Modrm,            /* 8E MOV segreg, mem/reg        */
    dszPOP,   O_Modrm,                  /* 8F POP mem/reg                */
    dszNOP,   O_NoOperands,             /* 90 NOP                        */
    dszXCHG,  O_AX_oReg,                /* 91 XCHG AX,CX                 */
    dszXCHG,  O_AX_oReg,                /* 92 XCHG AX,DX                 */
    dszXCHG,  O_AX_oReg,                /* 93 XCHG AX,BX                 */
    dszXCHG,  O_AX_oReg,                /* 94 XCHG AX,SP                 */
    dszXCHG,  O_AX_oReg,                /* 95 XCHG AX,BP                 */
    dszXCHG,  O_AX_oReg,                /* 96 XCHG AX,SI                 */
    dszXCHG,  O_AX_oReg,                /* 97 XCHG AX,DI                 */
    dszCBW,   O_NoOpAlt0,               /* 98 CBW / CWDE (386)           */
    dszCWD,   O_NoOpAlt1,               /* 99 CWD / CDQ (386)            */
    dszCALL,  O_FarPtr,                 /* 9A CALL seg:off               */
    dszWAIT,  O_NoOperands,             /* 9B WAIT                       */
    dszPUSHF, O_NoOpAlt5,               /* 9C PUSHF / PUSHFD (386)       */
    dszPOPF,  O_NoOpAlt4,               /* 9D POPF / POPFD (386)         */
    dszSAHF,  O_NoOperands,             /* 9E SAHF                       */
    dszLAHF,  O_NoOperands,             /* 9F LAHF                       */
    dszMOV,   O_AL_Offs,                /* A0 MOV AL, mem                */
    dszMOV,   O_AX_Offs,                /* A1 MOV AX, mem                */
    dszMOV,   O_Offs_AL,                /* A2 MOV mem, AL                */
    dszMOV,   O_Offs_AX,                /* A3 MOV mem, AX                */
    dszMOVSB, O_NoOpStrSIDI,            /* A4 MOVSB                      */
    dszMOVSW, O_NoOpStrSIDI,            /* A5 MOVSW / MOVSD (386)        */
    dszCMPSB, O_NoOpStrSIDI,            /* A6 CMPSB                      */
    dszCMPSW, O_NoOpStrSIDI,            /* A7 CMPSW / CMPSD (386)        */
    dszTEST,  O_AL_Ib,                  /* A8 TEST AL, I                 */
    dszTEST,  O_AX_Iv,                  /* A9 TEST AX, I                 */
    dszSTOSB, O_NoOpStrDI,              /* AA STOSB                      */
    dszSTOSW, O_NoOpStrDI,              /* AB STOSW / STOSD (386)        */
    dszLODSB, O_NoOpStrSI,              /* AC LODSB                      */
    dszLODSW, O_NoOpStrSI,              /* AD LODSW / LODSD (386)        */
    dszSCASB, O_NoOpStrDI,              /* AE SCASB                      */
    dszSCASW, O_NoOpStrDI,              /* AF SCASW / SCASD (386)        */
    dszMOV,   O_oReg_Ib,                /* B0 MOV AL, I                  */
    dszMOV,   O_oReg_Ib,                /* B1 MOV CL, I                  */
    dszMOV,   O_oReg_Ib,                /* B2 MOV DL, I                  */
    dszMOV,   O_oReg_Ib,                /* B3 MOV BL, I                  */
    dszMOV,   O_oReg_Ib,                /* B4 MOV AH, I                  */
    dszMOV,   O_oReg_Ib,                /* B5 MOV CH, I                  */
    dszMOV,   O_oReg_Ib,                /* B6 MOV DH, I                  */
    dszMOV,   O_oReg_Ib,                /* B7 MOV BH, I                  */
    dszMOV,   O_oReg_Iv,                /* B8 MOV AX, I                  */
    dszMOV,   O_oReg_Iv,                /* B9 MOV CX, I                  */
    dszMOV,   O_oReg_Iv,                /* BA MOV DX, I                  */
    dszMOV,   O_oReg_Iv,                /* BB MOV BX, I                  */
    dszMOV,   O_oReg_Iv,                /* BC MOV SP, I                  */
    dszMOV,   O_oReg_Iv,                /* BD MOV BP, I                  */
    dszMOV,   O_oReg_Iv,                /* BE MOV SI, I                  */
    dszMOV,   O_oReg_Iv,                /* BF MOV DI, I                  */
    dszMULTI, O_GROUP21,                /* C0 shifts & rotates (286)     */
    dszMULTI, O_GROUP22,                /* C1 shifts & rotates (286)     */
    dszRET,   O_Iw,                     /* C2 RET Rel16                  */
    dszRET,   O_NoOperands,             /* C3 RET                        */
    dszLES,   O_fReg_Modrm,             /* C4 LES reg, mem               */
    dszLDS,   O_fReg_Modrm,             /* C5 LDS reg, mem               */
    dszMOV,   O_bModrm_Ib,              /* C6 MOV mem/reg, I(byte)       */
    dszMOV,   O_Modrm_Iv,               /* C7 MOV mem/reg, I(word)       */
    dszENTER, O_Enter,                  /* C8 ENTER (286)                */
    dszLEAVE, O_NoOperands,             /* C9 LEAVE (286)                */
    dszRETF,  O_Iw,                     /* CA RETF I(word)               */
    dszRETF,  O_NoOperands,             /* CB RETF                       */
    dszINT,   O_DoInt3,                 /* CC INT 3                      */
    dszINT,   O_DoInt,                  /* CD INT                        */
    dszINTO,  O_NoOperands,             /* CE INTO                       */
    dszIRET,  O_NoOpAlt4,               /* CF IRET / IRETD (386)         */
    dszMULTI, O_GROUP23,                /* D0 shifts & rotates,1 (byte)  */
    dszMULTI, O_GROUP24,                /* D1 shifts & rotates,1 (word)  */
    dszMULTI, O_GROUP25,                /* D2 shifts & rotates,CL (byte) */
    dszMULTI, O_GROUP26,                /* D3 shifts & rotates,CL (word) */
    dszAAM,   O_Ib,                     /* D4 AAM                        */
    dszAAD,   O_Ib,                     /* D5 AAD                        */
    dszRESERVED, O_DoDB,                /* D6                            */
    dszXLAT,  O_NoOperands,             /* D7 XLAT                       */
    dszMULTI, O_x87_ESC,                /* D8 ESC                        */
    dszMULTI, O_x87_ESC,                /* D9 ESC                        */
    dszMULTI, O_x87_ESC,                /* DA ESC                        */
    dszMULTI, O_x87_ESC,                /* DB ESC                        */
    dszMULTI, O_x87_ESC,                /* DC ESC                        */
    dszMULTI, O_x87_ESC,                /* DD ESC                        */
    dszMULTI, O_x87_ESC,                /* DE ESC                        */
    dszMULTI, O_x87_ESC,                /* DF ESC                        */
    dszLOOPNE,O_Jcc8,                   /* E0 LOOPNE or LOOPNZ           */
    dszLOOPE, O_Jcc8,                   /* E1 LOOPE or LOOPZ             */
    dszLOOP,  O_Jcc8,                   /* E2 LOOP                       */
    dszJCXZ,  O_Jcc8,                   /* E3 JCXZ / JECXZ (386)         */
    dszIN,    O_AL_Ubyte,               /* E4 IN AL, I                   */
    dszIN,    O_AX_Ubyte,               /* E5 IN AX, I                   */
    dszOUT,   O_Ubyte_AL,               /* E6 OUT I, AL                  */
    dszOUT,   O_Ubyte_AX,               /* E7 OUT I, AX                  */
    dszCALL,  O_Rel16,                  /* E8 CALL Rel16                 */
    dszJMP,   O_Rel16,                  /* E9 JMP Rel16                  */
    dszJMP,   O_FarPtr,                 /* EA JMP seg:off                */
    dszJMP,   O_Rel8,                   /* EB JMP Rel8                   */
    dszIN,    O_DoInAL,                 /* EC IN AL, DX                  */
    dszIN,    O_DoInAX,                 /* ED IN AX, DX                  */
    dszOUT,   O_DoOutAL,                /* EE OUT DX, AL                 */
    dszOUT,   O_DoOutAX,                /* EF OUT DX, AX                 */
    dszLOCK,  O_DoRep,                  /* F0 LOCK                       */
    dszRESERVED, O_DoDB,                /* F1                            */
    dszREPNE, O_DoRep,                  /* F2 REPNE or REPNZ             */
    dszREP,   O_DoRep,                  /* F3 REP or REPE or REPZ        */
    dszHLT,   O_NoOperands,             /* F4 HLT                        */
    dszCMC,   O_NoOperands,             /* F5 CMC                        */
    dszMULTI, O_GROUP31,                /* F6 TEST, NOT, NEG, MUL, IMUL, */
    dszMULTI, O_GROUP32,                /* F7 DIv, IDIv F6=Byte F7=Word  */
    dszCLC,   O_NoOperands,             /* F8 CLC                        */
    dszSTC,   O_NoOperands,             /* F9 STC                        */
    dszCLI,   O_NoOperands,             /* FA CLI                        */
    dszSTI,   O_NoOperands,             /* FB STI                        */
    dszCLD,   O_NoOperands,             /* FC CLD                        */
    dszSTD,   O_NoOperands,             /* FD STD                        */
    dszMULTI, O_GROUP4,                 /* FE INC, DEC mem/reg (byte)    */
    dszMULTI, O_GROUP5,                 /* FF INC, DEC, CALL, JMP, PUSH  */

    // Secondary opcode table begins.

    dszMULTI,    O_GROUP6,              /* 00 MULTI                      */
    dszMULTI,    O_GROUP7,              /* 01 MULTI                      */
    dszLAR,      O_Reg_Modrm,           /* 02 LAR                        */
    dszLSL,      O_Reg_Modrm,           /* 03 LSL                        */
    dszRESERVED, O_DoDB,                /* 04                            */
    dszSYSCALL,  O_NoOperands,          /* 05 SYSCALL                    */
    dszCLTS,     O_NoOperands,          /* 06 CLTS                       */
    dszSYSRET,   O_NoOperands,          /* 07 SYSRET                     */
    dszINVD,     O_NoOperands,          /* 08 INVD                       */
    dszWBINVD,   O_NoOperands,          /* 09 WBINVD                     */
    dszRESERVED, O_DoDB,                /* 0A                            */
    dszUD2,      O_NoOperands,          /* 0B UD2 undefined              */
    dszRESERVED, O_DoDB,                /* 0C                            */
    dszMULTI,    O_GROUP_0F_0D,         /* 0D PREFETCH[W]                */
    dszFEMMS,    O_NoOperands,          /* 0E FEMMS                      */
    dszRESERVED, O_MmReg_qModrm_3DNow,  /* 0F AMD 3DNow family           */
    dszMOVUPSSDX,O_Sd_XmmReg_oModrm,    /* 10 MOVS[SD]X MOVUP[SD] reg, mem*/
    dszMOVUPSSDX,O_Sd_oModrm_XmmReg,    /* 11 MOVS[SD]X MOVUP[SD] mem, reg*/
    dszMOVLPSD,  O_Sd_XmmReg_oModrm,    /* 12 MOVLP[SD] xmm, m64         */
    dszMOVLPSD,  O_Sd_oModrm_XmmReg,    /* 13 MOVLP[SD] m64, xmm         */
    dszUNPCKLPSD,O_Sd_XmmReg_oModrm,    /* 14 UNPCKLP[SD]                */
    dszUNPCKHPSD,O_Sd_XmmReg_oModrm,    /* 15 UNPCKHP[SD]                */
    dszMOVHPSD,  O_Sd_XmmReg_oModrm,    /* 16 MOVHP[SD] xmm, m64         */
    dszMOVHPSD,  O_Sd_oModrm_XmmReg,    /* 17 MOVHP[SD] m64, xmm         */
    dszMULTI,    O_GROUP_0F_18,         /* 18 MULTI                      */
    dszRESERVED, O_DoDB,                /* 19                            */
    dszRESERVED, O_DoDB,                /* 1A                            */
    dszRESERVED, O_DoDB,                /* 1B                            */
    dszRESERVED, O_DoDB,                /* 1C                            */
    dszRESERVED, O_DoDB,                /* 1D                            */
    dszRESERVED, O_DoDB,                /* 1E                            */
    dszRESERVED, O_DoDB,                /* 1F                            */
    dszMOV,      O_Modrm_CReg,          /* 20 MOV Rd,Cd                  */
    dszMOV,      O_Modrm_CReg,          /* 21 MOV Rd,Dd                  */
    dszMOV,      O_CReg_Modrm,          /* 22 MOV Cd,Rd                  */
    dszMOV,      O_CReg_Modrm,          /* 23 MOV Dd,Rd                  */
    dszMOV,      O_Modrm_CReg,          /* 24 MOV Rd,Td                  */
    dszRESERVED, O_DoDB,                /* 25                            */
    dszMOV,      O_CReg_Modrm,          /* 26 MOV Td,Rd                  */
    dszRESERVED, O_DoDB,                /* 27                            */
    dszMOVAPSD,  O_Sd_XmmReg_oModrm,    /* 28 MOVAP[SD] xmm1, xmm2/m128  */
    dszMOVAPSD,  O_Sd_oModrm_XmmReg,    /* 29 MOVAP[SD] xmm2/m128, xmm1  */
    dszCVTSPI2SPSD, O_Sd_XmmReg_qModrm, /* 2A CVT[SP]I2[SP][SD]          */
    dszMOVNTPSD, O_Sd_oModrm_XmmReg,    /* 2B MOVNTP[SD]                 */
    dszCVTTSPSD2SPI, O_Sd_MmOrWReg_oModrm, /* 2C CVTT[SP][SD]2[SP]I      */
    dszCVTSPSD2SPI,  O_Sd_MmOrWReg_oModrm, /* 2D CVT[SP][SD]2[SP]I       */
    dszUCOMISSD, O_Sd_XmmReg_xModrm,    /* 2E UCOMIS[SD]                 */
    dszCOMISSD,  O_Sd_XmmReg_xModrm,    /* 2F COMIS[SD]                  */
    dszWRMSR,    O_NoOperands,          /* 30 WRMSR                      */
    dszRDTSC,    O_NoOperands,          /* 31 RDTSC                      */
    dszRDMSR,    O_NoOperands,          /* 32 RDMSR                      */
    dszRDPMC,    O_NoOperands,          /* 33 RDPMC                      */
    dszSYSENTER, O_NoOperands,          /* 34 SYSENTER                   */
    dszSYSEXIT,  O_NoOperands,          /* 35 SYSEXIT                    */
    dszRESERVED, O_DoDB,                /* 36                            */
    dszRESERVED, O_DoDB,                /* 37                            */
    dszRESERVED, O_DoDB,                /* 38                            */
    dszRESERVED, O_DoDB,                /* 39                            */
    dszRESERVED, O_DoDB,                /* 3A                            */
    dszRESERVED, O_DoDB,                /* 3B                            */
    dszRESERVED, O_DoDB,                /* 3C                            */
    dszRESERVED, O_DoDB,                /* 3D                            */
    dszRESERVED, O_DoDB,                /* 3E                            */
    dszRESERVED, O_DoDB,                /* 3F                            */
    dszCMOVO,    O_Reg_Modrm,           /* 40 CMOVO                      */
    dszCMOVNO,   O_Reg_Modrm,           /* 41 CMOVNO                     */
    dszCMOVB,    O_Reg_Modrm,           /* 42 CMOVB                      */
    dszCMOVNB,   O_Reg_Modrm,           /* 43 CMOVNB                     */
    dszCMOVE,    O_Reg_Modrm,           /* 44 CMOVE                      */
    dszCMOVNE,   O_Reg_Modrm,           /* 45 CMOVNE                     */
    dszCMOVBE,   O_Reg_Modrm,           /* 46 CMOVBE                     */
    dszCMOVA,    O_Reg_Modrm,           /* 47 CMOVNBE                    */
    dszCMOVS,    O_Reg_Modrm,           /* 48 CMOVS                      */
    dszCMOVNS,   O_Reg_Modrm,           /* 49 CMOVNS                     */
    dszCMOVP,    O_Reg_Modrm,           /* 4A CMOVP                      */
    dszCMOVNP,   O_Reg_Modrm,           /* 4B CMOVNP                     */
    dszCMOVL,    O_Reg_Modrm,           /* 4C CMOVL                      */
    dszCMOVGE,   O_Reg_Modrm,           /* 4D CMOVGE                     */
    dszCMOVLE,   O_Reg_Modrm,           /* 4E CMOVLE                     */
    dszCMOVNLE,  O_Reg_Modrm,           /* 4F CMOVNLE                    */
    dszMOVMSKPSD,O_Sd_Reg_XmmReg,       /* 50 MOVMSKP[SD]                */
    dszSQRTSPSD, O_Sd_XmmReg_oModrm,    /* 51 SQRT[SP][SD]               */
    dszRSQRTSPSD,O_Sd_XmmReg_oModrm,    /* 52 RSQRT[SP][SD]              */
    dszRCPSPSD,  O_Sd_XmmReg_oModrm,    /* 53 RCP[SP][SD]                */
    dszANDPSD,   O_Sd_XmmReg_oModrm,    /* 54 ANDP[SD]                   */
    dszANDNPSD,  O_Sd_XmmReg_oModrm,    /* 55 ANDNP[SD]                  */
    dszORPSD,    O_Sd_XmmReg_oModrm,    /* 56 ORP[SD]                    */
    dszXORPSD,   O_Sd_XmmReg_oModrm,    /* 57 XORP[SD]                   */
    dszADDSPSD,  O_Sd_XmmReg_oModrm,    /* 58 ADD[SP][SD]                */
    dszMULSPSD,  O_Sd_XmmReg_oModrm,    /* 59 MUL[SP][SD]                */
    dszCVTSPSD2SPSD, O_Sd_XmmReg_oModrm,/* 5A CVT[SP][SD]2[SP][SD]       */
    dszCVTBASE,  O_Sd_XmmReg_oModrm,    /* 5B CVT<PS> family             */
    dszSUBSPSD,  O_Sd_XmmReg_oModrm,    /* 5C SUB[SP][SD]                */
    dszMINSPSD,  O_Sd_XmmReg_oModrm,    /* 5D MIN[SP][SD]                */
    dszDIVSPSD,  O_Sd_XmmReg_oModrm,    /* 5E DIV[SP][SD]                */
    dszMAXSPSD,  O_Sd_XmmReg_oModrm,    /* 5F MAX[SP][SD]                */
    dszPUNPCKLBW,O_MmReg_qModrm,        /* 60 PUNPCKLBW                  */
    dszPUNPCKLWD,O_MmReg_qModrm,        /* 61 PUNPCKLWD                  */
    dszPUNPCKLDQ,O_MmReg_qModrm,        /* 62 PUNPCKLDQ                  */
    dszPACKSSWB, O_MmReg_qModrm,        /* 63 PACKSSWB                   */
    dszPCMPGTB,  O_MmReg_qModrm,        /* 64 PCMPGTB                    */
    dszPCMPGTW,  O_MmReg_qModrm,        /* 65 PCMPGTW                    */
    dszPCMPGTD,  O_MmReg_qModrm,        /* 66 PCMPGTD                    */
    dszPACKUSWB, O_MmReg_qModrm,        /* 67 PACKUSWB                   */
    dszPUNPCKHBW,O_MmReg_qModrm,        /* 68 PUNPCKHBW                  */
    dszPUNPCKHWD,O_MmReg_qModrm,        /* 69 PUNPCKHWD                  */
    dszPUNPCKHDQ,O_MmReg_qModrm,        /* 6A PUNPCKHDQ                  */
    dszPACKSSDW, O_MmReg_qModrm,        /* 6B PACKSSDW                   */
    dszRESERVED, O_DoDB,                /* 6C                            */
    dszRESERVED, O_DoDB,                /* 6D                            */
    dszMOVD,     O_MmReg_dModrm,        /* 6E MOVD                       */
    dszMOVQ,     O_MmReg_qModrm,        /* 6F MOVQ                       */
    dszPSHUF,    O_Sd_XmmReg_oModrm_Ib, /* 70 PSHUF family               */
    dszMULTI,    O_PSHimw,              /* 71 PS[LR][AL]W immediate      */
    dszMULTI,    O_PSHimd,              /* 72 PS[LR][AL]D immediate      */
    dszMULTI,    O_PSHimq,              /* 73 PS[LR]LQ immediate         */
    dszPCMPEQB,  O_MmReg_qModrm,        /* 74 PCMPEQB                    */
    dszPCMPEQW,  O_MmReg_qModrm,        /* 75 PCMPEQW                    */
    dszPCMPEQD,  O_MmReg_qModrm,        /* 76 PCMPEQD                    */
    dszEMMS,     O_NoOperands,          /* 77 EMMS                       */
    dszRESERVED, O_DoDB,                /* 78                            */
    dszRESERVED, O_DoDB,                /* 79                            */
    dszRESERVED, O_DoDB,                /* 7A                            */
    dszRESERVED, O_DoDB,                /* 7B                            */
    dszRESERVED, O_DoDB,                /* 7C                            */
    dszSETNL,    O_bModrm,              /* 7D SETNL                      */
    dszMOVD,     O_dModrm_MmReg,        /* 7E MOVD                       */
    dszMOVQ,     O_qModrm_MmReg,        /* 7F MOVQ                       */
    dszJO,       O_JccX,                /* 80 JO                         */
    dszJNO,      O_JccX,                /* 81 JNO                        */
    dszJB,       O_JccX,                /* 82 JB                         */
    dszJNB,      O_JccX,                /* 83 JNB                        */
    dszJE,       O_JccX,                /* 84 JE                         */
    dszJNE,      O_JccX,                /* 85 JNE                        */
    dszJBE,      O_JccX,                /* 86 JBE                        */
    dszJNBE,     O_JccX,                /* 87 JNBE                       */
    dszJS,       O_JccX,                /* 88 JS                         */
    dszJNS,      O_JccX,                /* 89 JNS                        */
    dszJP,       O_JccX,                /* 8A JP                         */
    dszJNP,      O_JccX,                /* 8B JNP                        */
    dszJL,       O_JccX,                /* 8C JL                         */
    dszJNL,      O_JccX,                /* 8D JNL                        */
    dszJLE,      O_JccX,                /* 8E JLE                        */
    dszJNLE,     O_JccX,                /* 8F JNLE                       */
    dszSETO,     O_bModrm,              /* 90 SETO                       */
    dszSETNO,    O_bModrm,              /* 91 SETNO                      */
    dszSETB,     O_bModrm,              /* 92 SETB                       */
    dszSETNB,    O_bModrm,              /* 93 SETNB                      */
    dszSETE,     O_bModrm,              /* 94 SETE                       */
    dszSETNE,    O_bModrm,              /* 95 SETNE                      */
    dszSETBE,    O_bModrm,              /* 96 SETBE                      */
    dszSETA,     O_bModrm,              /* 97 SETNBE                     */
    dszSETS,     O_bModrm,              /* 98 SETS                       */
    dszSETNS,    O_bModrm,              /* 99 SETNS                      */
    dszSETP,     O_bModrm,              /* 9A SETP                       */
    dszSETNP,    O_bModrm,              /* 9B SETNP                      */
    dszSETL,     O_bModrm,              /* 9C SETL                       */
    dszSETGE,    O_bModrm,              /* 9D SETGE                      */
    dszSETLE,    O_bModrm,              /* 9E SETLE                      */
    dszSETNLE,   O_bModrm,              /* 9F SETNLE                     */
    dszPUSH,     O_sReg2,               /* A0 PUSH FS                    */
    dszPOP,      O_sReg2,               /* A1 POP FS                     */
    dszCPUID,    O_NoOperands,          /* A2 CPUID                      */
    dszBT,       O_Modrm_Reg,           /* A3 BT                         */
    dszSHLD,     O_Modrm_Reg_Ib,        /* A4 SHLD                       */
    dszSHLD,     O_Modrm_Reg_CL,        /* A5 SHLD                       */
    dszRESERVED, O_DoDB,                /* A6                            */
    dszRESERVED, O_DoDB,                /* A7                            */
    dszPUSH,     O_sReg2,               /* A8 PUSH GS                    */
    dszPOP,      O_sReg2,               /* A9 POP GS                     */
    dszRSM,      O_NoOperands,          /* AA RSM                        */
    dszBTS,      O_vModrm_Reg,          /* AB BTS                        */
    dszSHRD,     O_Modrm_Reg_Ib,        /* AC SHRD                       */
    dszSHRD,     O_Modrm_Reg_CL,        /* AD SHRD                       */
    dszMULTI,    O_GROUP_0F_AE,         /* AE MULTI                      */
    dszIMUL,     O_Reg_Modrm,           /* AF IMUL                       */
    dszCMPXCHG,  O_bModrm_Reg,          /* B0 CMPXCH                     */
    dszCMPXCHG,  O_Modrm_Reg,           /* B1 CMPXCH                     */
    dszLSS,      O_fReg_Modrm,          /* B2 LSS                        */
    dszBTR,      O_Modrm_Reg,           /* B3 BTR                        */
    dszLFS,      O_fReg_Modrm,          /* B4 LFS                        */
    dszLGS,      O_fReg_Modrm,          /* B5 LGS                        */
    dszMOVZX,    O_Reg_bModrm,          /* B6 MOVZX                      */
    dszMOVZX,    O_Reg_wModrm,          /* B7 MOVZX                      */
    dszRESERVED, O_DoDB,                /* B8                            */
    dszRESERVED, O_DoDB,                /* B9                            */
    dszMULTI,    O_GROUP8,              /* BA MULTI                      */
    dszBTC,      O_Modrm_Reg,           /* BB BTC                        */
    dszBSF,      O_Reg_Modrm,           /* BC BSF                        */
    dszBSR,      O_Reg_Modrm,           /* BD BSR                        */
    dszMOVSX,    O_Reg_bModrm,          /* BE MOVSX                      */
    dszMOVSX,    O_Reg_wModrm,          /* BF MOVSX                      */
    dszXADD,     O_bModrm_Reg,          /* C0 XADD                       */
    dszXADD,     O_Modrm_Reg,           /* C1 XADD                       */
    dszCMPSPSD,  O_Sd_XmmReg_oModrm_CmpIb, /* C2 CMP[SP][SD]             */
    dszMOVNTI,   O_Modrm_Reg,           /* C3 MOVNTI                     */
    dszPINSRW,   O_MmReg_dModrm_Ib,     /* C4 PINSRW                     */
    dszPEXTRW,   O_Reg_MmReg_Ib,        /* C5 PEXTRW                     */
    dszSHUFPSD,  O_Sd_XmmReg_oModrm_Ib, /* C6 SHUFP[SD]                  */
    dszCMPXCHG8B,O_qModrm,              /* C7 CMPXCHG8B                  */
    dszBSWAP,    O_oReg,                /* C8 BSWAP                      */
    dszBSWAP,    O_oReg,                /* C9 BSWAP                      */
    dszBSWAP,    O_oReg,                /* CA BSWAP                      */
    dszBSWAP,    O_oReg,                /* CB BSWAP                      */
    dszBSWAP,    O_oReg,                /* CC BSWAP                      */
    dszBSWAP,    O_oReg,                /* CD BSWAP                      */
    dszBSWAP,    O_oReg,                /* CE BSWAP                      */
    dszBSWAP,    O_oReg,                /* CF BSWAP                      */
    dszRESERVED, O_DoDB,                /* D0                            */
    dszPSRLW,    O_MmReg_qModrm,        /* D1 PSRLW                      */
    dszPSRLD,    O_MmReg_qModrm,        /* D2 PSRLD                      */
    dszPSRLQ,    O_MmReg_qModrm,        /* D3 PSRLQ                      */
    dszPADDQ,    O_MmReg_qModrm,        /* D4 PADDQ                      */
    dszPMULLW,   O_MmReg_qModrm,        /* D5 PMULLW                     */
    dszMOVBASE,  O_Sd_oModrm_XmmReg,    /* D6 MOVDQ2Q, MOVQ, MOVQ2DQ     */
    dszPMOVMSKB, O_Reg_MmReg,           /* D7 PMOVMSKB                   */
    dszPSUBUSB,  O_MmReg_qModrm,        /* D8 PSUBUSB                    */
    dszPSUBUSW,  O_MmReg_qModrm,        /* D9 PSUBUSW                    */
    dszPMINUB,   O_MmReg_qModrm,        /* DA PMINUB                     */
    dszPAND,     O_MmReg_qModrm,        /* DB PAND                       */
    dszPADDUSB,  O_MmReg_qModrm,        /* DC PADDUSB                    */
    dszPADDUSW,  O_MmReg_qModrm,        /* DD PADDUSW                    */
    dszPMAXUB,   O_MmReg_qModrm,        /* DE PMAXUB                     */
    dszPANDN,    O_MmReg_qModrm,        /* DF PANDN                      */
    dszPAVGB,    O_MmReg_qModrm,        /* E0 PAVGB                      */
    dszPSRAW,    O_MmReg_qModrm,        /* E1 PSRAW                      */
    dszPSRAD,    O_MmReg_qModrm,        /* E2 PSRAD                      */
    dszPAVGW,    O_MmReg_qModrm,        /* E3 PAVGW                      */
    dszPMULHUW,  O_MmReg_qModrm,        /* E4 PMULHUW                    */
    dszPMULHW,   O_MmReg_qModrm,        /* E5 PMULHW                     */
    dszCVTBASE,  O_Sd_XmmReg_oModrm,    /* E6 CVT<PD> family             */
    dszMOVNTDQ,  O_Sd_xModrm_XOrMmReg,  /* E7 MOVNT{Q}{DQ}               */
    dszPSUBSB,   O_MmReg_qModrm,        /* E8 PSUBSB                     */
    dszPSUBSW,   O_MmReg_qModrm,        /* E9 PSUBSW                     */
    dszPMINSW,   O_MmReg_qModrm,        /* EA PMINSW                     */
    dszPOR,      O_MmReg_qModrm,        /* EB POR                        */
    dszPADDSB,   O_MmReg_qModrm,        /* EC PADDSB                     */
    dszPADDSW,   O_MmReg_qModrm,        /* ED PADDSW                     */
    dszPMAXSW,   O_MmReg_qModrm,        /* EE PMAXSW                     */
    dszPXOR,     O_MmReg_qModrm,        /* EF PXOR                       */
    dszRESERVED, O_DoDB,                /* F0                            */
    dszPSLLW,    O_MmReg_qModrm,        /* F1 PSLLW                      */
    dszPSLLD,    O_MmReg_qModrm,        /* F2 PSLLD                      */
    dszPSLLQ,    O_MmReg_qModrm,        /* F3 PSLLQ                      */
    dszPMULUDQ,  O_MmReg_qModrm,        /* F4 PMULUDQ                    */
    dszPMADDWD,  O_MmReg_qModrm,        /* F5 PMADDWD                    */
    dszPSADBW,   O_MmReg_qModrm,        /* F6 PSADBQ                     */
    dszMASKMOVDQU, O_Sd_XOrMmReg_XOrMmReg, /* F7 MASKMOV{Q}{DQU}         */
    dszPSUBB,    O_MmReg_qModrm,        /* F8 PSUBB                      */
    dszPSUBW,    O_MmReg_qModrm,        /* F9 PSUBW                      */
    dszPSUBD,    O_MmReg_qModrm,        /* FA PSUBD                      */
    dszPSUBQ,    O_MmReg_qModrm,        /* FB PSUBQ                      */
    dszPADDB,    O_MmReg_qModrm,        /* FC PADDB                      */
    dszPADDW,    O_MmReg_qModrm,        /* FD PADDW                      */
    dszPADDD,    O_MmReg_qModrm,        /* FE PADDD                      */
    dszRESERVED, O_DoDB,                /* FF                            */
};

/* Auxilary lists of mnemonics for groups of two byte instructions:      */
/*   All of the instructions within each of these groups are of the same */
/*   class, so only the mnemonic string is needed, the index into the    */
/*   action table is implicit.                                           */

static char *group[][8] = {

/* 00 */    {dszADD,  dszOR,    dszADC,  dszSBB,    /* group 1 */
             dszAND,  dszSUB,   dszXOR,  dszCMP},

/* 01 */    {dszROL,  dszROR,   dszRCL,  dszRCR,    /* group 2 */
             dszSHL,  dszSHR,   dszSHL,  dszSAR},

/* 02 */    {dszINC,      dszDEC,      dszRESERVED, dszRESERVED, /* group 4 */
             dszRESERVED, dszRESERVED, dszRESERVED, dszRESERVED},

/* 03 */    {dszSLDT, dszSTR,   dszLLDT,     dszLTR,    /* group 6 */
             dszVERR, dszVERW,  dszRESERVED, dszRESERVED},

/* 04 */    {dszRESERVED, dszRESERVED, dszRESERVED, dszRESERVED, /* group 8 */
             dszBT,       dszBTS,      dszBTR,      dszBTC},

/* 05 */    {dszRESERVED, dszRESERVED, dszPSRLW,    dszRESERVED, /* PSHimw */
             dszPSRAW,    dszRESERVED, dszPSLLW,    dszRESERVED},
            
/* 06 */    {dszRESERVED, dszRESERVED, dszPSRLD,    dszRESERVED, /* PSHimd */
             dszPSRAD,    dszRESERVED, dszPSLLD,    dszRESERVED},
            
/* 07 */    {dszRESERVED, dszRESERVED, dszPSRLQ,    dszPSRLDQ,   /* PSHimq */
             dszRESERVED, dszRESERVED, dszPSLLQ,    dszPSLLDQ},
            
/* 08 */    {dszPREFETCH, dszPREFETCHW, dszPREFETCH, dszPREFETCH,/* PREFETCH */
             dszPREFETCH, dszPREFETCH,  dszPREFETCH, dszPREFETCH},
            
            };

/* Auxilary orderd pairs for groups of two byte instructions structured  */
/*   the same was as distbl above.                                       */

static Tdistbl groupt[][8] = {

/* 00  00                     x87-D8-1                   */
            { dszFADD,     O_dModrm,     /* D8-0 FADD    */
              dszFMUL,     O_dModrm,     /* D8-1 FMUL    */
              dszFCOM,     O_dModrm,     /* D8-2 FCOM    */
              dszFCOMP,    O_dModrm,     /* D8-3 FCOMP   */
              dszFSUB,     O_dModrm,     /* D8-4 FSUB    */
              dszFSUBR,    O_dModrm,     /* D8-5 FSUBR   */
              dszFDIV,     O_dModrm,     /* D8-6 FDIV    */
              dszFDIVR,    O_dModrm },   /* D8-7 FDIVR   */

/* 01                         x87-D8-2                   */
            { dszFADD,     O_ST_iST,     /* D8-0 FADD    */
              dszFMUL,     O_ST_iST,     /* D8-1 FMUL    */
              dszFCOM,     O_iST,        /* D8-2 FCOM    */
              dszFCOMP,    O_iST,        /* D8-3 FCOMP   */
              dszFSUB,     O_ST_iST,     /* D8-4 FSUB    */
              dszFSUBR,    O_ST_iST,     /* D8-5 FSUBR   */
              dszFDIV,     O_ST_iST,     /* D8-6 FDIV    */
              dszFDIVR,    O_ST_iST },   /* D8-7 FDIVR   */

/* 02   01                    x87-D9-1                   */
            { dszFLD,      O_dModrm,     /* D9-0 FLD     */
              dszRESERVED, O_DoDB,       /* D9-1         */
              dszFST,      O_dModrm,     /* D9-2 FST     */
              dszFSTP,     O_dModrm,     /* D9-3 FSTP    */
              dszFLDENV,   O_Modrm,      /* D9-4 FLDENV  */
              dszFLDCW,    O_Modrm,      /* D9-5 FLDCW   */
              dszFSTENV,   O_Modrm,      /* D9-6 FSTENV  */
              dszFSTCW,    O_Modrm },    /* D9-7 FSTCW   */

/* 03   01                    x87-D9-2 TTT=0,1,2,3       */
            { dszFLD,      O_iST,        /* D9-0 FLD     */
              dszFXCH,     O_iST,        /* D9-1 FXCH    */
              dszFNOP,     O_NoOperands, /* D9-2 FNOP    */
              dszFSTP,     O_iST,        /* D9-3 FSTP    */
              dszRESERVED, O_DoDB,       /* D9-4         */
              dszRESERVED, O_DoDB,       /* D9-5         */
              dszRESERVED, O_DoDB,       /* D9-6         */
              dszRESERVED, O_DoDB   },   /* D9-7         */

/* 04  02                     x89-DA-1                   */
            { dszFIADD,    O_dModrm,     /* DA-0 FIADD   */
              dszFIMUL,    O_dModrm,     /* DA-1 FIMUL   */
              dszFICOM,    O_dModrm,     /* DA-2 FICOM   */
              dszFICOMP,   O_dModrm,     /* DA-3 FICOMP  */
              dszFISUB,    O_dModrm,     /* DA-4 FISUB   */
              dszFISUBR,   O_dModrm,     /* DA-5 FISUBR  */
              dszFIDIV,    O_dModrm,     /* DA-6 FIDIV   */
              dszFIDIVR,   O_dModrm },   /* DA-7 FIDIVR  */

/* 05                         x87-DA-2                   */
            { dszFCMOVB,   O_ST_iST,     /* DA-0 FCMOVB  */
              dszFCMOVE,   O_ST_iST,     /* DA-1 FCMOVE  */
              dszFCMOVBE,  O_ST_iST,     /* DA-2 FCMOVBE */
              dszFCMOVU,   O_ST_iST,     /* DA-3 FCMOVU  */
              dszRESERVED, O_DoDB,       /* DA-4         */
              dszFUCOMPP,  O_NoOperands, /* DA-5         */
              dszRESERVED, O_DoDB,       /* DA-6         */
              dszRESERVED, O_DoDB },     /* DA-7         */

/* 06  03                     x87-DB-1                   */
            { dszFILD,     O_dModrm,     /* DB-0 FILD    */
              dszRESERVED, O_DoDB,       /* DB-1         */
              dszFIST,     O_dModrm,     /* DB-2 FIST    */
              dszFISTP,    O_dModrm,     /* DB-3 FISTP   */
              dszRESERVED, O_DoDB,       /* DB-4         */
              dszFLD,      O_tModrm,     /* DB-5 FLD     */
              dszRESERVED, O_DoDB,       /* DB-6         */
              dszFSTP,     O_tModrm },   /* DB-7 FSTP    */

/* 07                      x87-DB-2 ttt=4        */
            { dszFENI,     O_NoOperands, /* DB-0 FENI    */
              dszFDISI,    O_NoOperands, /* DB-1 FDISI   */
              dszFCLEX,    O_NoOperands, /* DB-2 FCLEX   */
              dszFINIT,    O_NoOperands, /* DB-3 FINIT   */
              dszFSETPM,   O_DoDB,       /* DB-4 FSETPM  */
              dszRESERVED, O_DoDB,       /* DB-5         */
              dszRESERVED, O_DoDB,       /* DB-6         */
              dszRESERVED, O_DoDB },     /* DB-7         */

/* 08 04                      x87-DC-1                   */
            { dszFADD,     O_qModrm,     /* DC-0 FADD    */
              dszFMUL,     O_qModrm,     /* DC-1 FMUL    */
              dszFCOM,     O_qModrm,     /* DC-2 FCOM    */
              dszFCOMP,    O_qModrm,     /* DC-3 FCOMP   */
              dszFSUB,     O_qModrm,     /* DC-4 FSUB    */
              dszFSUBR,    O_qModrm,     /* DC-5 FSUBR   */
              dszFDIV,     O_qModrm,     /* DC-6 FDIV    */
              dszFDIVR,    O_qModrm },   /* DC-7 FDIVR   */

/* 09                         x87-DC-2                   */
            { dszFADD,     O_iST_ST,     /* DC-0 FADD    */
              dszFMUL,     O_iST_ST,     /* DC-1 FMUL    */
              dszFCOM,     O_iST,        /* DC-2 FCOM    */
              dszFCOMP,    O_iST,        /* DC-3 FCOMP   */
              dszFSUB,     O_iST_ST,     /* DC-4 FSUB    */
              dszFSUBR,    O_iST_ST,     /* DC-5 FSUBR   */
              dszFDIV,     O_iST_ST,     /* DC-6 FDIVR   */
              dszFDIVR,    O_iST_ST },   /* DC-7 FDIV    */

/* 10  05                     x87-DD-1                   */
            { dszFLD,      O_qModrm,     /* DD-0 FLD     */
              dszRESERVED, O_DoDB,       /* DD-1         */
              dszFST,      O_qModrm,     /* DD-2 FST     */
              dszFSTP,     O_qModrm,     /* DD-3 FSTP    */
              dszFRSTOR,   O_Modrm,      /* DD-4 FRSTOR  */
              dszRESERVED, O_DoDB,       /* DD-5         */
              dszFSAVE,    O_Modrm,      /* DD-6 FSAVE   */
              dszFSTSW,    O_Modrm },    /* DD-7 FSTSW   */

/* 11                         x87-DD-2                   */
            { dszFFREE,    O_iST,        /* DD-0 FFREE   */
              dszFXCH,     O_iST,        /* DD-1 FXCH    */
              dszFST,      O_iST,        /* DD-2 FST     */
              dszFSTP,     O_iST,        /* DD-3 FSTP    */
              dszFUCOM,    O_iST,        /* DD-4 FUCOM   */
              dszFUCOMP,   O_iST,        /* DD-5 FUCOMP  */
              dszRESERVED, O_DoDB,       /* DD-6         */
              dszRESERVED, O_DoDB },     /* DD-7         */

/* 12  06                     x87-DE-1                   */
            { dszFIADD,    O_wModrm,     /* DE-0 FIADD   */
              dszFIMUL,    O_wModrm,     /* DE-1 FIMUL   */
              dszFICOM,    O_wModrm,     /* DE-2 FICOM   */
              dszFICOMP,   O_wModrm,     /* DE-3 FICOMP  */
              dszFISUB,    O_wModrm,     /* DE-4 FISUB   */
              dszFISUBR,   O_wModrm,     /* DE-5 FISUBR  */
              dszFIDIV,    O_wModrm,     /* DE-6 FIDIV   */
              dszFIDIVR,   O_wModrm },   /* DE-7 FIDIVR  */

/* 13                         x87-DE-2                   */
            { dszFADDP,    O_iST_ST,     /* DE-0 FADDP   */
              dszFMULP,    O_iST_ST,     /* DE-1 FMULP   */
              dszFCOMP,    O_iST,        /* DE-2 FCOMP   */
              dszFCOMPP,   O_NoOperands, /* DE-3 FCOMPP  */
              dszFSUBP,    O_iST_ST,     /* DE-4 FSUBP   */
              dszFSUBRP,   O_iST_ST,     /* DE-5 FSUBRP  */
              dszFDIVP,    O_iST_ST,     /* DE-6 FDIVP   */
              dszFDIVRP,   O_iST_ST },   /* DE-7 FDIVRP  */

/* 14  07                     x87-DF-1                   */
            { dszFILD,     O_wModrm,     /* DF-0 FILD    */
              dszRESERVED, O_DoDB,       /* DF-1         */
              dszFIST,     O_wModrm,     /* DF-2 FIST    */
              dszFISTP,    O_wModrm,     /* DF-3 FISTP   */
              dszFBLD,     O_tModrm,     /* DF-4 FBLD    */
              dszFILD,     O_qModrm,     /* DF-5 FILD    */
              dszFBSTP,    O_tModrm,     /* DF-6 FBSTP   */
              dszFISTP,    O_qModrm },   /* DF-7 FISTP   */

/* 15                         x87-DF-2                   */
            { dszFFREE,    O_iST,        /* DF-0 FFREE   */
              dszFXCH,     O_iST,        /* DF-1 FXCH    */
              dszFST,      O_iST,        /* DF-2 FST     */
              dszFSTP,     O_iST,        /* DF-3 FSTP    */
              dszFSTSW,    O_NoOperands, /* DF-4 FSTSW   */
              dszFUCOMIP,  O_ST_iST,     /* DF-5 FUCOMIP */
              dszFCOMIP,   O_ST_iST,     /* DF-6 FCOMIP  */
              dszRESERVED, O_DoDB },     /* DF-7         */

/* 16   01            x87-D9 Mod=3 TTT=4                 */
            { dszFCHS,     O_NoOperands, /* D9-0 FCHS    */
              dszFABS,     O_NoOperands,  /* D9-1 FABS   */
              dszRESERVED, O_DoDB,       /* D9-2         */
              dszRESERVED, O_DoDB,       /* D9-3         */
              dszFTST,     O_NoOperands, /* D9-4 FTST    */
              dszFXAM,     O_NoOperands, /* D9-5 FXAM    */
              dszRESERVED, O_DoDB,       /* D9-6         */
              dszRESERVED, O_DoDB },     /* D9-7         */

/* 17   01            x87-D9 Mod=3 TTT=5                 */
            { dszFLD1,     O_NoOperands, /* D9-0 FLD1    */
              dszFLDL2T,   O_NoOperands, /* D9-1 FLDL2T  */
              dszFLDL2E,   O_NoOperands, /* D9-2 FLDL2E  */
              dszFLDPI,    O_NoOperands, /* D9-3 FLDPI   */
              dszFLDLG2,   O_NoOperands, /* D9-4 FLDLG2  */
              dszFLDLN2,   O_NoOperands, /* D9-5 FLDLN2  */
              dszFLDZ,     O_NoOperands, /* D9-6 FLDZ    */
              dszRESERVED, O_DoDB },     /* D9-7         */

/* 18   01            x87-D9 Mod=3 TTT=6                   */
            { dszF2XM1,    O_NoOperands,   /* D9-0 F2XM1   */
              dszFYL2X,    O_NoOperands,   /* D9-1 FYL2X   */
              dszFPTAN,    O_NoOperands,   /* D9-2 FPTAN   */
              dszFPATAN,   O_NoOperands,   /* D9-3 FPATAN  */
              dszFXTRACT,  O_NoOperands,   /* D9-4 FXTRACT */
              dszFPREM1,   O_NoOperands,   /* D9-5 FPREM1  */
              dszFDECSTP,  O_NoOperands,   /* D9-6 FDECSTP */
              dszFINCSTP,  O_NoOperands }, /* D9-7 FINCSTP */

/* 19   01            x87-D9 Mod=3 TTT=7                   */
            { dszFPREM,    O_NoOperands,   /* D9-0 FPREM   */
              dszFYL2XP1,  O_NoOperands,   /* D9-1 FYL2XP1 */
              dszFSQRT,    O_NoOperands,   /* D9-2 FSQRT   */
              dszFSINCOS,  O_NoOperands,   /* D9-3 FSINCOS */
              dszFRNDINT,  O_NoOperands,   /* D9-4 FRNDINT */
              dszFSCALE,   O_NoOperands,   /* D9-5 FSCALE  */
              dszFSIN,     O_NoOperands,   /* D9-6 FSIN    */
              dszFCOS,     O_NoOperands }, /* D9-7 FCOS    */

/* 20                  group 3                             */
            { dszTEST,     O_bModrm_Ib,    /* F6-0 TEST    */
              dszRESERVED, O_DoDB,         /* F6-1         */
              dszNOT,      O_bModrm,       /* F6-2 NOT     */
              dszNEG,      O_bModrm,       /* F6-3 NEG     */
              dszMUL,      O_bModrm,       /* F6-4 MUL     */
              dszIMUL,     O_bModrm,       /* F6-5 IMUL    */
              dszDIV,      O_bModrm,       /* F6-6 DIV     */
              dszIDIV,     O_bModrm },     /* F6-7 IDIV    */

/* 21                  group 3                             */
            { dszTEST,     O_vModrm_Iv,    /* F7-0 TEST    */
              dszRESERVED, O_DoDB,         /* F7-1         */
              dszNOT,      O_vModrm,       /* F7-2 NOT     */
              dszNEG,      O_vModrm,       /* F7-3 NEG     */
              dszMUL,      O_vModrm,       /* F7-4 MUL     */
              dszIMUL,     O_vModrm,       /* F7-5 IMUL    */
              dszDIV,      O_vModrm,       /* F7-6 DIV     */
              dszIDIV,     O_vModrm },     /* F7-7 IDIV    */

/* 22                  group 5                             */
            { dszINC,      O_vModrm,     /* FF-0 INC       */
              dszDEC,      O_vModrm,     /* FF-1 DEC       */
              dszCALL,     O_vModrm,     /* FF-2 CALL      */
              dszCALL,     O_fModrm,     /* FF-3 CALL      */
              dszJMP,      O_vModrm,     /* FF-4 JMP       */
              dszJMP,      O_fModrm,     /* FF-5 JMP       */
              dszPUSH,     O_vModrm,     /* FF-6 PUSH      */
              dszRESERVED, O_DoDB },     /* FF-7           */

/* 23                  group 7                             */
            { dszSGDT,     O_Modrm,      /* 0F-0 SGDT      */
              dszSIDT,     O_Modrm,      /* 0F-1 SIDT      */
              dszLGDT,     O_Modrm,      /* 0F-2 LGDT      */
              dszLIDT,     O_Modrm,      /* 0F-3 LIDT      */
              dszSMSW,     O_wModrm,     /* 0F-4 MSW       */
              dszRESERVED, O_DoDB,       /* 0F-5           */
              dszLMSW,     O_wModrm,     /* 0F-6 LMSW      */
              dszINVLPG,   O_Modrm },    /* 0F-7 INVLPG    */

/* 24                 x87-DB Mod=3 TTT != 4                */
            { dszFCMOVNB,  O_ST_iST,     /* DB-0 FCMOVNB   */
              dszFCMOVNE,  O_ST_iST,     /* DB-1 FCMOVNE   */
              dszFCMOVNBE, O_ST_iST,     /* DB-2 FCMOVNBE  */
              dszFCMOVNU,  O_ST_iST,     /* DB-3 FCMOVNU   */
              dszRESERVED, O_DoDB,       /* DB-4           */
              dszFUCOMI,   O_ST_iST,     /* DB-5 FUCOMI    */
              dszFCOMI,    O_ST_iST,     /* DB-6 FCOMI     */
              dszRESERVED, O_DoDB },     /* DB-7           */

/* 25                 Group 0F AE                          */
            { dszFXSAVE,   O_bModrm,     /* AE-0 FXSAVE    */
              dszFXRSTOR,  O_bModrm,     /* AE-1 FXRSTOR   */
              dszLDMXCSR,  O_dModrm,     /* AE-2 LDMXCSR   */
              dszSTMXCSR,  O_dModrm,     /* AE-3 STMXCSR   */
              dszCLFLUSH,  O_bModrm,     /* AE-4 CLFLUSH   */
              dszLFENCE,   O_NoOperands, /* AE-5 LFENCE    */
              dszMFENCE,   O_NoOperands, /* AE-6 MFENCE    */
              dszSFENCE,   O_NoOperands }, /* AE-7 SFENCE  */

/* 26                 Group 0F 18                            */
            { dszPREFETCHNTA, O_bModrm,  /* 18-0 PREFETCHNTA */
              dszPREFETCHT0,  O_bModrm,  /* 18-1 PREFETCHT0  */
              dszPREFETCHT1,  O_bModrm,  /* 18-2 PREFETCHT1  */
              dszPREFETCHT2,  O_bModrm,  /* 18-3 PREFETCHT2  */
              dszRESERVED,    O_DoDB,    /* 18-4             */
              dszRESERVED,    O_DoDB,    /* 18-5             */
              dszRESERVED,    O_DoDB,    /* 18-6             */
              dszRESERVED,    O_DoDB },  /* 18-7             */

            };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\i386_dis.cpp ===
//----------------------------------------------------------------------------
//
// Disassembly portions of X86 machine implementation.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

#include "i386_dis.h"

// See Get/SetRegVal comments in machine.hpp.
#define RegValError Do_not_use_GetSetRegVal_in_machine_implementations
#define GetRegVal(index, val)   RegValError
#define GetRegVal32(index)      RegValError
#define GetRegVal64(index)      RegValError
#define SetRegVal(index, val)   RegValError
#define SetRegVal32(index, val) RegValError
#define SetRegVal64(index, val) RegValError

UCHAR g_X86Int3[] = { 0xcc };

//----------------------------------------------------------------------------
//
// BaseX86MachineInfo methods.
//
//----------------------------------------------------------------------------

/*****                     macros and defines                          *****/

#define X86_CS_OVR 0x2e

#define BIT20(b) ((b) & 0x07)
#define BIT53(b) (((b) >> 3) & 0x07)
#define BIT76(b) (((b) >> 6) & 0x03)
#define MAXOPLEN 10

#define OBOFFSET (m_Ptr64 ? 35 : 26)
#define OBOPERAND (m_Ptr64 ? 43 : 34)
#define OBLINEEND (g_OutputWidth - 3)

/*****                     static tables and variables                 *****/

char* g_X86Reg8[] =
{
    "al", "cl", "dl", "bl", "ah", "ch", "dh", "bh",
    "r8b", "r9b", "r10b", "r11b", "r12b", "r13b", "r14b", "r15b"
};
char* g_Amd64ExtendedReg8[] =
{
    "al", "cl", "dl", "bl", "spl", "bpl", "sil", "dil"
};
char* g_X86RegBase[] =
{
    "ax", "cx", "dx", "bx", "sp", "bp", "si", "di",
    "8", "9", "10", "11", "12", "13", "14", "15"
};
char *g_X86Mrm16[] =
{
    "bx+si", "bx+di", "bp+si", "bp+di", "si", "di", "bp", "bx",
    "r8w", "r9w", "r10w", "r11w", "r12w", "r13w", "r14w", "r15w"
};
char *g_X86Mrm32[] =
{
    "eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi",
    "r8d", "r9d", "r10d", "r11d", "r12d", "r13d", "r14d", "r15d"
};
char *g_X86Mrm64[] =
{
    "rax", "rcx", "rdx", "rbx", "rsp", "rbp", "rsi", "rdi",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"
};

UCHAR g_X86Reg16Idx[] =
{
    X86_NBX, X86_NBX, X86_NBP, X86_NBP,
    X86_NSI, X86_NDI, X86_NBP, X86_NBX,
};
UCHAR g_X86Reg16Idx2[] =
{
    X86_NSI, X86_NDI, X86_NSI, X86_NDI
};
UCHAR g_X86RegIdx[] =
{
    X86_NAX, X86_NCX, X86_NDX, X86_NBX,
    X86_NSP, X86_NBP, X86_NSI, X86_NDI,
    AMD64_R8, AMD64_R9, AMD64_R10, AMD64_R11,
    AMD64_R12, AMD64_R13, AMD64_R14, AMD64_R15
};

static char sregtab[] = "ecsdfg";  // first letter of ES, CS, SS, DS, FS, GS

char* g_CompareIb[] = { "eq", "lt", "le", "unord", "ne", "nlt", "nle", "ord" };

char    hexdigit[] = { '0', '1', '2', '3', '4', '5', '6', '7',
                       '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };

static int              mod;            /* mod of mod/rm byte */
static int              rm;             /* rm of mod/rm byte */
static int              ttt;            /* return reg value (of mod/rm) */
static unsigned char    *pMem;          /* current position in instruction */

ADDR                    EAaddr[2];      //  offset of effective address
static int              EAsize[2];      //  size of effective address item
static char             *pchEAseg[2];   //  normal segment for operand

#define IPREL_MARKER "<-IPREL->"

BOOL g_X86ModrmHasIpRelOffset;
LONG g_X86IpRelOffset;

int g_SegAddrMode;      /* global address size in bits */
int g_SegOpSize;        /* global operand size in bits */
int g_AddrMode;         /* local address size in bits */
int g_OpSize;           /* operand size in bits */

int g_ExtendOpCode;
int g_ExtendAny;
int g_ExtendMrmReg;
int g_ExtendSibIndex;
int g_ExtendRm;

BOOL g_MovX;            // Indicates a MOVSX or MOVZX.
BOOL g_MovSXD;
BOOL g_ForceMrmReg32;   // M/RM register is always 32-bit.
BOOL g_MmRegEa;         // Use mm? registers in reg-only EA.
BOOL g_XmmRegEa;        // Use xmm? registers in reg-only EA.
BOOL g_ControlFlow;     // Control flow instruction.
    
int  g_RepPrefix;

enum
{
    XMM_SS,
    XMM_SD,
    XMM_PS,
    XMM_PD,
};

int                     g_XmmOpSize;

enum
{
    JCC_EA_NONE,
    // Branch must be no-branch + 1.
    JCC_EA_NO_BRANCH,
    JCC_EA_BRANCH,
};

// First entry are bits that must be zero, second
// and third entries are bit shifts for bits that must match.
ULONG g_JccCheckTable[][3] =
{
    X86_BIT_FLAGOF, 0, 0,                               // JNO
    X86_BIT_FLAGCF, 0, 0,                               // JNB
    X86_BIT_FLAGZF, 0, 0,                               // JNZ
    X86_BIT_FLAGCF | X86_BIT_FLAGZF, 0, 0,              // JNBE
    X86_BIT_FLAGSF, 0, 0,                               // JNS
    X86_BIT_FLAGPF, 0, 0,                               // JNP
    0, 7, 11,                                           // JNL
    X86_BIT_FLAGZF, 7, 11,                              // JNLE
};
    
//      internal function definitions

void OutputHexString(char **, PUCHAR, int);
void OutputHexValue(char **, PUCHAR, int, int);
void OutputExHexValue(char **, PUCHAR, int, int);
void OutputHexCode(char **, PUCHAR, int);
void X86OutputString(char **, char *);

void OutputHexAddr(PSTR *, PADDR);

#define FormSelAddress(Addr, Sel, Off) \
    FormAddr(Sel, Off, 0, Addr)
#define FormSegRegAddress(Addr, SegReg, Off) \
    FormAddr(SegReg, Off, FORM_SEGREG, Addr)

void
GetSegAddrOpSizes(MachineInfo* Machine, PADDR Addr)
{
    if ((Type(*Addr) & ADDR_1664) ||
        ((Type(*Addr) & ADDR_FLAT) &&
         Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_AMD64))
    {
        g_SegAddrMode = 64;
        // X86-64 defaults to 32-bit operand sizes even in 64-bit code.
        // Only the address size changes.  An operand size prefix
        // switches from 32- to 64-bit.
        g_SegOpSize = 32;
    }
    else if (Type(*Addr) & (ADDR_V86 | ADDR_16))
    {
        g_SegAddrMode = 16;
        g_SegOpSize = 16;
    }
    else
    {
        g_SegAddrMode = 32;
        g_SegOpSize = 32;
    }
    
    g_AddrMode = g_SegAddrMode;
    g_OpSize = g_SegOpSize;
}

void
OverrideAddrMode(void)
{
    switch(g_SegAddrMode)
    {
    case 16:
        g_AddrMode = 32;
        break;
    case 32:
        g_AddrMode = 16;
        break;
    case 64:
        g_AddrMode = 32;
        break;
    default:
        DBG_ASSERT(FALSE);
        break;
    }
}

void
OverrideOpSize(int OverrideOp)
{
    switch(g_SegAddrMode)
    {
    case 16:
        g_OpSize = 32;
        break;
    case 32:
        g_OpSize = 16;
        break;
    case 64:
        // X86-64 defaults to 32-bit operand sizes even in 64-bit code.
        // Only the address size changes.  A REX operand size prefix
        // switches from 32- to 64-bit.
        if (OverrideOp == 0x66)
        {
            g_OpSize = 16;
        }
        else if (OverrideOp & 8)
        {
            g_OpSize = 64;
        }
        break;
    default:
        DBG_ASSERT(FALSE);
        break;
    }
}

void
ExtendOps(int opcode)
{
    // x86-64 uses these opcodes as the REX override.
    OverrideOpSize(opcode);

    g_ExtendOpCode = opcode;
    g_ExtendAny = 8;
    if (opcode & 1)
    {
        g_ExtendRm = 8;
    }
    if (opcode & 2)
    {
        g_ExtendSibIndex = 8;
    }
    if (opcode & 4)
    {
        g_ExtendMrmReg = 8;
    }
}

void
IgnoreExtend(void)
{
    //
    // Resets any extensions that may have happened.
    // The REX prefix must be the last
    // prefix of an instruction and is ignored otherwise,
    // so this reset is done when any prefix is encountered
    // after the REX prefix.  This should normally never
    // happen but technically it's valid code so we should handle it.
    //
    
    if (g_ExtendOpCode)
    {
        WarnOut("REX prefix ignored\n");
    
        if (g_ExtendOpCode & 8)
        {
            // Op size was changed so put it back.  This
            // is tricky since in theory an op size override
            // prefix could also be present, but let's not
            // worry about that for now.
            g_OpSize = g_SegOpSize;
        }

        g_ExtendOpCode = 0;
        g_ExtendAny = 0;
        g_ExtendRm = 0;
        g_ExtendSibIndex = 0;
        g_ExtendMrmReg = 0;
    }
}

struct AMD_3DNOW_OPSTR
{
    PSTR Str;
    UCHAR Opcode;
};

AMD_3DNOW_OPSTR g_Amd3DNowOpStr[] =
{
    "pavgusb", 0xBF,
    "pfadd", 0x9E,
    "pfsub", 0x9A,
    "pfsubr", 0xAA,
    "pfacc", 0xAE,
    "pfcmpge", 0x90,
    "pfcmpgt", 0xA0,
    "pfcmpeq", 0xB0,
    "pfmin", 0x94,
    "pfmax", 0xA4,
    "pi2fd", 0x0D,
    "pf2id", 0x1D,
    "pfrcp", 0x96,
    "pfrsqrt", 0x97,
    "pfmul", 0xB4,
    "pfrcpit1", 0xA6,
    "pfrsqit1", 0xA7,
    "pfrcpit2", 0xB6,
    "pmulhrw", 0xB7,
    "pf2iw", 0x1C,
    "pfnacc", 0x8A,
    "pfpnacc", 0x8E,
    "pi2fw", 0x0C,
    "pswapd", 0xBB,
};

PSTR
GetAmd3DNowOpString(UCHAR Opcode)
{
    UCHAR i;

    for (i = 0; i < sizeof(g_Amd3DNowOpStr) / sizeof(g_Amd3DNowOpStr[0]); i++)
    {
        if (g_Amd3DNowOpStr[i].Opcode == Opcode)
        {
            return g_Amd3DNowOpStr[i].Str;
        }
    }

    return NULL;
}

BOOL
BaseX86MachineInfo::Disassemble(PADDR paddr, PSTR pchDst, BOOL fEAout)
{
    ULONG64 Offset = Off(*paddr);
    int     opcode;                     /* current opcode */
    int     olen = 2;                   /* operand length */
    int     alen = 2;                   /* address length */
    int     end = FALSE;                /* end of instruction flag */
    int     mrm = FALSE;                /* indicator that modrm is generated*/
    unsigned char *action;              /* action for operand interpretation*/
    long    tmp;                        /* temporary storage field */
    int     indx;                       /* temporary index */
    int     action2;                    /* secondary action */
    int     instlen;                    /* instruction length */
    int     cBytes;                     //  bytes read into instr buffer
    int     segOvr = 0;                 /* segment override opcode */
    UCHAR   membuf[X86_MAX_INSTRUCTION_LEN]; /* current instruction buffer */
    char    *pEAlabel = "";             //  optional label for operand

    char    *pchResultBuf = pchDst;     //  working copy of pchDst pointer
    char    RepPrefixBuffer[32];        //  rep prefix buffer
    char    *pchRepPrefixBuf = RepPrefixBuffer; //  pointer to prefix buffer
    char    OpcodeBuffer[16];           //  opcode buffer
    char    *pchOpcodeBuf = OpcodeBuffer;   //  pointer to opcode buffer
    char    OperandBuffer[MAX_SYMBOL_LEN + 20]; //  operand buffer
    char    *pchOperandBuf = OperandBuffer; //  pointer to operand buffer
    char    ModrmBuffer[MAX_SYMBOL_LEN + 20];   //  modRM buffer
    char    *pchModrmBuf = ModrmBuffer; //  pointer to modRM buffer
    char    EABuffer[64];               //  effective address buffer
    char    *pchEABuf = EABuffer;       //  pointer to EA buffer

    int     obOpcode = OBOFFSET;
    int     obOpcodeMin;
    int     obOpcodeMax;

    int     obOperand = OBOPERAND;
    int     obOperandMin;
    int     obOperandMax;

    int     cbOpcode;
    int     cbOperand;
    int     cbOffset;
    int     cbEAddr;
    int     fTwoLines = FALSE;
    unsigned char BOPaction;
    int     subcode;                    /* bop subcode */
    int     JccEa;
    LONGLONG Branch;

    g_X86ModrmHasIpRelOffset = FALSE;
    g_MovX = FALSE;
    g_MovSXD = FALSE;
    g_ForceMrmReg32 = FALSE;
    g_MmRegEa = FALSE;
    g_XmmRegEa = FALSE;
    g_ControlFlow = FALSE;
    EAsize[0] = EAsize[1] = 0;          //  no effective address
    pchEAseg[0] = dszDS_;
    pchEAseg[1] = dszES_;
    g_RepPrefix = 0;
    g_XmmOpSize = XMM_PS;
    g_ExtendOpCode = 0;
    g_ExtendAny = 0;
    g_ExtendMrmReg = 0;
    g_ExtendSibIndex = 0;
    g_ExtendRm = 0;
    JccEa = JCC_EA_NONE;

    GetSegAddrOpSizes(this, paddr);
    alen = g_AddrMode / 8;
    olen = g_OpSize / 8;

    OutputHexAddr(&pchResultBuf, paddr);

    *pchResultBuf++ = ' ';

    cBytes = (int)GetMemString(paddr, membuf, X86_MAX_INSTRUCTION_LEN);
                                        /* move full inst to local buffer */
    pMem = membuf;                      /* point to begin of instruction */
    opcode = *pMem++;                   /* get opcode */

    if ( opcode == 0xc4 && *pMem == 0xC4 )
    {
        pMem++;
        X86OutputString(&pchOpcodeBuf,"BOP");
        action = &BOPaction;
        BOPaction = IB | END;
        subcode =  *pMem;
        if ( subcode == 0x50 || subcode == 0x52 || subcode == 0x53 ||
             subcode == 0x54 || subcode == 0x57 || subcode == 0x58 ||
             subcode == 0x58 )
        {
            BOPaction = IW | END;
        }
    }
    else
    {
        X86OutputString(&pchOpcodeBuf, distbl[opcode].instruct);
        action = actiontbl + distbl[opcode].opr; /* get operand action */
    }

/*****          loop through all operand actions               *****/

    do
    {
        action2 = (*action) & 0xc0;
        switch((*action++) & 0x3f)
        {
        case ALT:                   /* alter the opcode if not 16-bit */
            if (g_OpSize > 16)
            {
                indx = *action++;
                pchOpcodeBuf = &OpcodeBuffer[indx];
                if (indx == 0)
                {
                    X86OutputString(&pchOpcodeBuf, g_OpSize == 32 ?
                                    dszCWDE : dszCDQE);
                }
                else if (g_OpSize == 64)
                {
                    *pchOpcodeBuf++ = 'q';
                    if (indx == 1)
                    {
                        *pchOpcodeBuf++ = 'o';
                    }
                }
                else
                {
                    *pchOpcodeBuf++ = 'd';
                    if (indx == 1)
                    {
                        *pchOpcodeBuf++ = 'q';
                    }
                }
            }
            break;

        case XMMSD:                 /* SSE-style opcode rewriting */
            {
                char ScalarOrPacked, SingleOrDouble;
                char* DquOrQ, *DqOrQ, *SsdxOrUpsd, *CvtPd, *CvtPs;
                char* MovQD6, *Shuf;
                char* Scan;

                g_MmRegEa = TRUE;
                DquOrQ = "q";
                DqOrQ = "q";
                SsdxOrUpsd = "s?x";
                CvtPd = NULL;
                CvtPs = NULL;
                MovQD6 = NULL;
                switch(g_RepPrefix)
                {
                case X86_REPN:
                    // Scalar double operation.
                    ScalarOrPacked = 's';
                    SingleOrDouble = 'd';
                    CvtPd = "pd2dq";
                    MovQD6 = "dq2q";
                    Shuf = "lw";
                    g_XmmOpSize = XMM_SD;
                    // Assume there was no other lock/rep/etc.
                    pchRepPrefixBuf = RepPrefixBuffer;
                    break;
                case X86_REP:
                    // Scalar single operation.
                    ScalarOrPacked = 's';
                    SingleOrDouble = 's';
                    CvtPd = "dq2pd";
                    CvtPs = "tps2dq";
                    MovQD6 = "q2dq";
                    Shuf = "hw";
                    g_XmmOpSize = XMM_SS;
                    // Assume there was no other lock/rep/etc.
                    pchRepPrefixBuf = RepPrefixBuffer;
                    break;
                default:
                    // No rep prefix means packed single or double
                    // depending on operand size.
                    ScalarOrPacked = 'p';
                    SsdxOrUpsd = "up?";
                    if (g_OpSize == g_SegOpSize)
                    {
                        SingleOrDouble = 's';
                        CvtPs = "dq2ps";
                        Shuf = "w";
                        g_XmmOpSize = XMM_PS;
                    }
                    else
                    {
                        SingleOrDouble = 'd';
                        DqOrQ = "dq";
                        DquOrQ = "dqu";
                        CvtPd = "tpd2dq";
                        CvtPs = "ps2dq";
                        MovQD6 = "q";
                        Shuf = "d";
                        g_XmmRegEa = TRUE;
                        g_XmmOpSize = XMM_PD;
                    }
                    break;
                }

                pchOpcodeBuf = OpcodeBuffer;
                while (*pchOpcodeBuf && *pchOpcodeBuf != ' ')
                {
                    switch(*pchOpcodeBuf)
                    {
                    case ':':
                        *pchOpcodeBuf = ScalarOrPacked;
                        break;
                    case '?':
                        *pchOpcodeBuf = SingleOrDouble;
                        break;
                    case ',':
                        *pchOpcodeBuf = SingleOrDouble == 's' ? 'd' : 's';
                        break;
                    }

                    pchOpcodeBuf++;
                }

                switch(opcode)
                {
                case X86_MOVFREGMEM:
                case X86_MOVFMEMREG:
                    // Append characters for MOVS[SD]X and MOVUP[SD].
                    strcpy(pchOpcodeBuf, SsdxOrUpsd);
                    if ((Scan = strchr(pchOpcodeBuf, '?')) != NULL)
                    {
                        *Scan = SingleOrDouble;
                    }
                    pchOpcodeBuf += strlen(pchOpcodeBuf);
                    break;
                case X86_MOVNT:
                    // Append characters for MOVNTQ and MOVNTDQ.
                    X86OutputString(&pchOpcodeBuf, DqOrQ);
                    break;
                case X86_MASKMOV:
                    // Append characters for MASKMOVQ and MASKMOVDQU.
                    X86OutputString(&pchOpcodeBuf, DquOrQ);
                    break;
                case X86_CVTPD:
                    if (CvtPd == NULL)
                    {
                        // Invalid opcode.
                        pchOpcodeBuf = OpcodeBuffer;
                        X86OutputString(&pchOpcodeBuf, dszRESERVED);
                        action2 = END;
                    }
                    else
                    {
                        // Append characters for CVT<PD>.
                        X86OutputString(&pchOpcodeBuf, CvtPd);
                    }
                    break;
                case X86_CVTPS:
                    if (CvtPs == NULL)
                    {
                        // Invalid opcode.
                        pchOpcodeBuf = OpcodeBuffer;
                        X86OutputString(&pchOpcodeBuf, dszRESERVED);
                        action2 = END;
                    }
                    else
                    {
                        // Append characters for CVT<PS>.
                        X86OutputString(&pchOpcodeBuf, CvtPs);
                    }
                    break;
                case X86_MOVQ_D6:
                    if (MovQD6 == NULL)
                    {
                        // Invalid opcode.
                        pchOpcodeBuf = OpcodeBuffer;
                        X86OutputString(&pchOpcodeBuf, dszRESERVED);
                        action2 = END;
                    }
                    else
                    {
                        // Append characters for MOVQ D6 family.
                        X86OutputString(&pchOpcodeBuf, MovQD6);
                    }
                    break;
                case X86_PSHUF:
                    // Append characters for PSHUF variants.
                    X86OutputString(&pchOpcodeBuf, Shuf);
                    break;
                }
            }
            break;

        case AMD3DNOW:          /* AMD 3DNow post-instruction byte */
            {
                PSTR OpStr;

                // Get the trailing byte and look up
                // the opcode string.
                OpStr = GetAmd3DNowOpString(*pMem++);
                if (OpStr == NULL)
                {
                    // Not a defined 3DNow instruction.
                    // Leave the ??? in the opstring.
                    break;
                }

                // Update opstring to real text.
                pchOpcodeBuf = OpcodeBuffer;
                X86OutputString(&pchOpcodeBuf, OpStr);
            }
            break;
            
        case STROP:
            //  compute size of operands in indx
            //  also if dword operands, change fifth
            //  opcode letter from 'w' to 'd'.

            if (opcode & 1)
            {
                if (g_OpSize == 64)
                {
                    indx = 8;
                    OpcodeBuffer[4] = 'q';
                }
                else if (g_OpSize == 32)
                {
                    indx = 4;
                    OpcodeBuffer[4] = 'd';
                }
                else
                {
                    indx = 2;
                }
            }
            else
            {
                indx = 1;
            }

            if (*action & 1)
            {
                if (fEAout)
                {
                    if (g_AddrMode > 16)
                    {
                        FormSelAddress(&EAaddr[0], 0, GetReg64(X86_NSI));
                    }
                    else
                    {
                        FormSegRegAddress(&EAaddr[0], SEGREG_DATA,
                                          GetReg16(X86_NSI));
                    }
                    EAsize[0] = indx;
                }
            }
            if (*action++ & 2)
            {
                if (fEAout)
                {
                    if (g_AddrMode > 16)
                    {
                        FormSelAddress(&EAaddr[1], 0, GetReg64(X86_NDI));
                    }
                    else
                    {
                        FormSegRegAddress(&EAaddr[1], SEGREG_ES,
                                          GetReg16(X86_NDI));
                    }
                    EAsize[1] = indx;
                }
            }
            break;

        case CHR:                   /* insert a character */
            *pchOperandBuf++ = *action++;
            break;

        case CREG:                  /* set debug, test or control reg */
            if (opcode & 0x04)
            {
                *pchOperandBuf++ = 't';
            }
            else if (opcode & 0x01)
            {
                *pchOperandBuf++ = 'd';
            }
            else
            {
                *pchOperandBuf++ = 'c';
            }
            *pchOperandBuf++ = 'r';
            if (ttt >= 10)
            {
                *pchOperandBuf++ = (char)('0' + ttt / 10);
                ttt %= 10;
            }
            *pchOperandBuf++ = (char)('0' + ttt);
            break;

        case SREG2:                 /* segment register */
            ttt = BIT53(opcode);    //  set value to fall through

        case SREG3:                 /* segment register */
            *pchOperandBuf++ = sregtab[ttt];  // reg is part of modrm
            *pchOperandBuf++ = 's';
            break;

        case BRSTR:                 /* get index to register string */
            ttt = *action++;        /*    from action table */
            goto BREGlabel;

        case BOREG:                 /* byte register (in opcode) */
            ttt = BIT20(opcode);    /* register is part of opcode */
            goto BREGlabel;

        case ALSTR:
            ttt = 0;                /* point to AL register */
        BREGlabel:
        case BREG:                  /* general register */
            if (g_ExtendAny && ttt < 8)
            {
                X86OutputString(&pchOperandBuf, g_Amd64ExtendedReg8[ttt]);
            }
            else
            {
                X86OutputString(&pchOperandBuf, g_X86Reg8[ttt]);
            }
            break;

        case WRSTR:                 /* get index to register string */
            ttt = *action++;        /*    from action table */
            goto WREGlabel;

        case VOREG:                 /* register is part of opcode */
            if (m_ExecTypes[0] == IMAGE_FILE_MACHINE_AMD64 &&
                opcode >= 0x40 && opcode <= 0x4f)
            {
                // Get rid of the inc/dec text as this
                // isn't really an inc/dec.
                pchOpcodeBuf = OpcodeBuffer;

                // Process the REX override.
                ExtendOps(opcode);
                olen = g_OpSize / 8;
                action2 = 0;
                goto getNxtByte;
            }
            
            ttt = BIT20(opcode) + g_ExtendRm;
            goto VREGlabel;

        case AXSTR:
            ttt = 0;                /* point to eAX register */
        VREGlabel:
        case VREG:                  /* general register */
            if ((g_SegAddrMode == 64 &&
                 opcode >= 0x50 && opcode <= 0x5f) ||
                ttt >= 8)
            {
                // Push/pops are always 64-bit in 64-bit segments.
                *pchOperandBuf++ = 'r';
            }
            else if (g_OpSize == 32 ||
                     opcode == X86_PEXTRW ||
                     opcode == X86_PMOVMSKB)
            {
                *pchOperandBuf++ = 'e';
            }
            else if (g_OpSize == 64)
            {
                *pchOperandBuf++ = 'r';
            }
        WREGlabel:
        case WREG:                  /* register is word size */
            X86OutputString(&pchOperandBuf, g_X86RegBase[ttt]);
            if (ttt >= 8)
            {
                if (g_OpSize == 32)
                {
                    *pchOperandBuf++ = 'd';
                }
                else if (g_OpSize == 16)
                {
                    *pchOperandBuf++ = 'w';
                }
            }
            break;

        case MMORWREG:
            if (g_XmmOpSize == XMM_SS || g_XmmOpSize == XMM_SD)
            {
                goto VREGlabel;
            }
            // Fall through.
        MMWREGlabel:
        case MMWREG:
            if (g_OpSize != g_SegOpSize &&
                opcode != X86_CVTSPSD2SPI)
            {
                *pchOperandBuf++ = 'x';
            }
            *pchOperandBuf++ = 'm';
            *pchOperandBuf++ = 'm';
            if (ttt >= 10)
            {
                *pchOperandBuf++ = (char)('0' + ttt / 10);
                ttt %= 10;
            }
            *pchOperandBuf++ = ttt + '0';
            break;

        case XORMMREG:
            if (g_OpSize == g_SegOpSize)
            {
                goto MMWREGlabel;
            }
            // Fall through.
        case XMMWREG:
            if (opcode != X86_PSHUF || g_XmmOpSize != XMM_PS)
            {
                *pchOperandBuf++ = 'x';
            }
            *pchOperandBuf++ = 'm';
            *pchOperandBuf++ = 'm';
            if (ttt >= 10)
            {
                *pchOperandBuf++ = (char)('0' + ttt / 10);
                ttt %= 10;
            }
            *pchOperandBuf++ = ttt + '0';
            break;

        case IST_ST:
            X86OutputString(&pchOperandBuf, "st(0),st");
            *(pchOperandBuf - 5) += (char)rm;
            break;

        case ST_IST:
            X86OutputString(&pchOperandBuf, "st,");
        case IST:
            X86OutputString(&pchOperandBuf, "st(0)");
            *(pchOperandBuf - 2) += (char)rm;
            break;

        case xBYTE:                 /* set instruction to byte only */
            EAsize[0] = 1;
            pEAlabel = "byte ptr ";
            break;

        case VAR:
            if ((g_SegAddrMode == 64 || g_ExtendAny > 0) &&
                opcode == 0x63)
            {
                // In AMD64 REX32 and 64-bit modes this instruction
                // is MOVSXD r64, r/m32 instead of ARPL r/m, reg.
                pchOpcodeBuf = OpcodeBuffer;
                X86OutputString(&pchOpcodeBuf, dszMOVSXD);
                action = &actiontbl[O_Reg_Modrm] + 1;
                g_OpSize = 64;
                g_MovSXD = TRUE;
                goto DWORDlabel;
            }
            else if (opcode == 0xff)
            {
                UCHAR Extra = BIT53(*pMem);
                if (Extra >= 2 && Extra <= 5)
                {
                    g_ControlFlow = TRUE;
                
                    // On x86-64 control-flow operations default to
                    // 64-bit opsize.
                    if (g_SegAddrMode == 64)
                    {
                        if (g_OpSize == 32)
                        {
                            g_OpSize = 64;
                        }
                    }
                }
                else if (g_SegAddrMode == 64 && Extra == 6)
                {
                    // Push/pops are always 64-bit in 64-bit segments.
                    g_OpSize = 64;
                }
            }
            else if (g_SegAddrMode == 64 && opcode == 0x8f)
            {
                // Push/pops are always 64-bit in 64-bit segments.
                g_OpSize = 64;
            }
            olen = g_OpSize / 8;
            
            if (g_OpSize == 64)
            {
                goto QWORDlabel;
            }
            else if (g_OpSize == 32)
            {
                goto DWORDlabel;
            }

        case xWORD:
            if (opcode == X86_PINSRW)
            {
                g_ForceMrmReg32 = TRUE;
            }
            EAsize[0] = 2;
            pEAlabel = "word ptr ";
            break;

        case EDWORD:
            // Control register opsize is mode-independent.
            g_OpSize = g_SegAddrMode;
            if (g_OpSize == 64)
            {
                goto QWORDlabel;
            }
        case xDWORD:
            if (opcode == X86_MOVDQ_7E && g_RepPrefix == X86_REP)
            {
                // Switch to MOVQ xmm1, xmm2/m64.
                pchRepPrefixBuf = RepPrefixBuffer;
                *(pchOpcodeBuf - 1) = 'q';
                EAsize[0] = 8;
                pEAlabel = "qword ptr ";
                g_XmmRegEa = TRUE;
                action = &actiontbl[O_Sd_XmmReg_qModrm] + 2;
                break;
            }
            // Fall through.
        DWORDlabel:
            EAsize[0] = 4;
            pEAlabel = "dword ptr ";
            break;

        case XMMOWORD:
            if (opcode == X86_PSHUF)
            {
                if (g_XmmOpSize == XMM_PS)
                {
                    g_MmRegEa = TRUE;
                    goto QWORDlabel;
                }
                else
                {
                    EAsize[0] = 16;
                    pEAlabel = "oword ptr ";
                    break;
                }
            }
            
            g_XmmRegEa = TRUE;
            if (opcode == X86_CVTPD)
            {
                if (g_XmmOpSize == XMM_SS)
                {
                    EAsize[0] = 8;
                    pEAlabel = "qword ptr ";
                }
                else
                {
                    EAsize[0] = 16;
                    pEAlabel = "oword ptr ";
                }
                break;
            }
            else if (opcode == X86_CVTPS)
            {
                EAsize[0] = 16;
                pEAlabel = "oword ptr ";
                break;
            }
            else if (opcode == X86_MOVQ_D6)
            {
                if (g_XmmOpSize == XMM_SD)
                {
                    // Switch to MOVDQ2Q mm, xmm.
                    EAsize[0] = 16;
                    pEAlabel = "oword ptr ";
                    action = &actiontbl[O_MmReg_qModrm] + 1;
                    break;
                }
            }
            else if (opcode == X86_MOVHLPS && g_XmmOpSize == XMM_PS &&
                     BIT76(*pMem) == 3)
            {
                // reg-reg form of MOVLPS is called MOVHLPS.
                pchOpcodeBuf = OpcodeBuffer;
                X86OutputString(&pchOpcodeBuf, dszMOVHLPS);
            }
            else if (opcode == X86_MOVLHPS && g_XmmOpSize == XMM_PS &&
                     BIT76(*pMem) == 3)
            {
                // reg-reg form of MOVHPS is called MOVLHPS.
                pchOpcodeBuf = OpcodeBuffer;
                X86OutputString(&pchOpcodeBuf, dszMOVLHPS);
            }
            
            // Fall through.
            
        OWORDlabel:
        case OWORD:
            switch(g_XmmOpSize)
            {
            case XMM_SS:
                EAsize[0] = 4;
                pEAlabel = "dword ptr ";
                if (opcode == X86_MOVQ_D6)
                {
                    // Switch to MOVQ xmm1, xmm2/m64.
                    g_XmmRegEa = FALSE;
                    action = &actiontbl[O_Sd_XmmReg_qModrm] + 1;
                }
                break;
            case XMM_SD:
                EAsize[0] = 8;
                pEAlabel = "qword ptr ";
                break;
            default:
                if (opcode == 0x112 || opcode == 0x113 ||
                    opcode == 0x116 || opcode == 0x117 ||
                    opcode == X86_MOVQ_D6 ||
                    (g_OpSize == g_SegOpSize &&
                     (opcode == 0x12c || opcode == X86_CVTSPSD2SPI ||
                      opcode == X86_CVTSPSD2SPSD)))
                {
                    EAsize[0] = 8;
                    pEAlabel = "qword ptr ";
                }
                else
                {
                    EAsize[0] = 16;
                    pEAlabel = "oword ptr ";
                }
                break;
            }
            break;

        case XMMXWORD:
            g_XmmRegEa = TRUE;
            if (g_OpSize == g_SegOpSize)
            {
                if (opcode == X86_MOVNT)
                {
                    EAsize[0] = 8;
                    pEAlabel = "qword ptr ";
                }
                else
                {
                    EAsize[0] = 4;
                    pEAlabel = "dword ptr ";
                }
            }
            else
            {
                if (opcode == X86_MOVNT)
                {
                    EAsize[0] = 16;
                    pEAlabel = "oword ptr ";
                }
                else
                {
                    EAsize[0] = 8;
                    pEAlabel = "qword ptr ";
                }
            }
            break;

        case MMQWORD:
            if (g_OpSize != g_SegOpSize &&
                (opcode == X86_MOVDQA_MR || opcode == X86_MOVDQA_RM))
            {
                pchOpcodeBuf = OpcodeBuffer;
                X86OutputString(&pchOpcodeBuf, dszMOVDQA);
            }
            
            if (opcode == X86_CVTSPI2SPSD)
            {
                g_XmmRegEa = FALSE;
                if (g_XmmOpSize == XMM_SS || g_XmmOpSize == XMM_SD)
                {
                    g_MmRegEa = FALSE;
                    goto DWORDlabel;
                }
            }   
            else if (g_OpSize != g_SegOpSize)
            {
                goto OWORDlabel;
            }
            g_MmRegEa = TRUE;
        QWORDlabel:
        case QWORD:
            EAsize[0] = 8;
            pEAlabel = "qword ptr ";
            break;

        case TBYTE:
            EAsize[0] = 10;
            pEAlabel = "tbyte ptr ";
            break;

        case FARPTR:
            g_ControlFlow = TRUE;
            
            // On x86-64 control-flow operations default to
            // 64-bit opsize.
            if (g_SegAddrMode == 64)
            {
                if (g_OpSize == 32)
                {
                    g_OpSize = 64;
                }
            }
            
            switch(g_OpSize)
            {
            case 16:
                EAsize[0] = 4;
                pEAlabel = "dword ptr ";
                break;
            default:
                EAsize[0] = 6;
                pEAlabel = "fword ptr ";
                break;
            }
            break;

        case LMODRM:                //  output modRM data type
            if (mod != 3)
            {
                X86OutputString(&pchOperandBuf, pEAlabel);
            }
            else
            {
                EAsize[0] = 0;
            }

        case MODRM:                 /* output modrm string */
            if (segOvr)             /* in case of segment override */
            {
                X86OutputString(&pchOperandBuf, distbl[segOvr].instruct);
            }
            *pchModrmBuf = '\0';
            X86OutputString(&pchOperandBuf, ModrmBuffer);
            break;

        case ADDRP:                 /* address pointer */
            // segment
            OutputHexString(&pchOperandBuf, pMem + olen, 2);
            *pchOperandBuf++ = ':';
            // offset
            OutputSymbol(&pchOperandBuf, pMem, olen, segOvr);
            pMem += olen + 2;
            break;

        case JCC8:
            JccEa = ComputeJccEa(opcode, fEAout);
            // Fall through.
        case REL8:                  /* relative address 8-bit */
            if (opcode == 0xe3 && g_AddrMode > 16)
            {
                pchOpcodeBuf = OpcodeBuffer;
                X86OutputString(&pchOpcodeBuf, g_AddrMode == 64 ?
                                dszJRCXZ : dszJECXZ);
            }
            Branch = *(char *)pMem++; /* get the 8-bit rel offset */
            goto DoRelDispl;

        case JCCX:
            JccEa = ComputeJccEa(opcode, fEAout);
            // Fall through.
        case REL16:                 /* relative address 16-/32-bit */
            switch(g_AddrMode)
            {
            case 16:
                Branch = *(short UNALIGNED *)pMem;
                pMem += 2;
                break;
            default:
                Branch = *(long UNALIGNED *)pMem;
                pMem += 4;
                break;
            }
        DoRelDispl:
            /* calculate address */
            Branch += Offset + (pMem - membuf);
            // rel8 and rel16 are only used in control-flow
            // instructions so the target is always relative
            // to CS.  Pass in the CS override to force this.
            OutputSymbol(&pchOperandBuf, (PUCHAR)&Branch, alen, X86_CS_OVR);
            break;

        case UBYTE:                 //  unsigned byte for int/in/out
            OutputHexString(&pchOperandBuf, pMem, 1);  //  ubyte
            pMem++;
            break;

        case CMPIB:
            // Immediate byte comparison encoding for CMP[SP][SD].
            if (*pMem < 8)
            {
                X86OutputString(&pchOperandBuf, g_CompareIb[*pMem]);
                pMem++;
            }
            else
            {
                olen = 1;
                goto DoImmed;
            }
            break;
            
        case IB:                    /* operand is immediate byte */
            // postop for AAD/AAM is 0x0a
            if ((opcode & ~1) == 0xd4)
            {
                // test post-opcode byte
                if (*pMem++ != 0x0a)
                {
                    X86OutputString(&pchOperandBuf, dszRESERVED);
                }
                break;
            }
            olen = 1;               /* set operand length */
            goto DoImmed;

        case IW:                    /* operand is immediate word */
            olen = 2;               /* set operand length */

        case IV:                    /* operand is word or dword */
        DoImmed:
            // AMD64 immediates are only 64-bit in the case of
            // mov reg, immed.  All other operations involving
            // immediates stay 32-bit.
            if (olen == 8 &&
                (opcode < 0xb8 || opcode > 0xbf))
            {
                olen = 4;
            }
            OutputHexValue(&pchOperandBuf, pMem, olen, FALSE);
            pMem += olen;
            break;

        case XB:
            OutputExHexValue(&pchOperandBuf, pMem, 1, g_OpSize / 8);
            pMem++;
            break;
            
        case OFFS:                  /* operand is offset */
            EAsize[0] = (opcode & 1) ? olen : 1;

            if (segOvr)             /* in case of segment override */
            {
                X86OutputString(&pchOperandBuf, distbl[segOvr].instruct);
            }

            *pchOperandBuf++ = '[';
            //  offset
            OutputSymbol(&pchOperandBuf, pMem, alen, segOvr);
            pMem += alen;
            *pchOperandBuf++ = ']';
            break;

        case X86_GROUP:             /* operand is of group 1,2,4,6 or 8 */
            /* output opcode symbol */
            X86OutputString(&pchOpcodeBuf, group[*action++][ttt]);
            break;

        case GROUPT:                /* operand is of group 3,5 or 7 */
            indx = *action;         /* get indx into group from action */
            goto doGroupT;

        case EGROUPT:               /* x87 ESC (D8-DF) group index */
            indx = BIT20(opcode) * 2; /* get group index from opcode */
            /* some operand variations exist */
            if (mod == 3)
            {
                /* for x87 and mod == 3 */
                ++indx;             /* take the next group table entry */
                if (indx == 3)
                {
                    /* for x87 ESC==D9 and mod==3 */
                    if (ttt > 3)
                    {
                        /* for those D9 instructions */
                        indx = 12 + ttt; /* offset index to table by 12 */
                        ttt = rm;   /* set secondary index to rm */
                    }
                }
                else if (indx == 7)
                {
                    /* for x87 ESC==DB and mod==3 */
                    if (ttt == 4)
                    {
                        /* if ttt==4 */
                        ttt = rm;     /* set secondary group table index */
                    }
                    else if ((ttt < 4) || (ttt > 4 && ttt < 7))
                    {
                        // adjust for pentium pro opcodes
                        indx = 24;   /* offset index to table by 24*/
                    }
                }
            }
        doGroupT:
            /* handle group with different types of operands */

            X86OutputString(&pchOpcodeBuf, groupt[indx][ttt].instruct);
            action = actiontbl + groupt[indx][ttt].opr;
            /* get new action */
            break;

        case OPC0F:              /* secondary opcode table (opcode 0F) */
            opcode = *pMem++;    /* get real opcode */
            g_MovX = (BOOL)(opcode == 0xBF || opcode == 0xB7);
            // Point opcode into secondary opcode portion of table.
            opcode += 256;
            goto getNxtByte1;

        case ADR_OVR:               /* address override */
            IgnoreExtend();
            olen = g_OpSize / 8;
            OverrideAddrMode();
            alen = g_AddrMode / 8;
            goto getNxtByte;

        case OPR_OVR:               /* operand size override */
            IgnoreExtend();
            OverrideOpSize(opcode);
            olen = g_OpSize / 8;
            goto getNxtByte;

        case SEG_OVR:               /* handle segment override */
            IgnoreExtend();
            olen = g_OpSize / 8;
            segOvr = opcode;        /* save segment override opcode */
            pchOpcodeBuf = OpcodeBuffer;  // restart the opcode string
            goto getNxtByte;

        case REP:                   /* handle rep/lock prefixes */
            IgnoreExtend();
            olen = g_OpSize / 8;
            g_RepPrefix = opcode;
            *pchOpcodeBuf = '\0';
            if (pchRepPrefixBuf != RepPrefixBuffer)
            {
                *pchRepPrefixBuf++ = ' ';
            }
            X86OutputString(&pchRepPrefixBuf, OpcodeBuffer);
            pchOpcodeBuf = OpcodeBuffer;
        getNxtByte:
            opcode = *pMem++;        /* next byte is opcode */
        getNxtByte1:
            action = actiontbl + distbl[opcode].opr;
            X86OutputString(&pchOpcodeBuf, distbl[opcode].instruct);
            break;

        case NOP:
            if (opcode == X86_PAUSE && g_RepPrefix == X86_REP)
            {
                pchRepPrefixBuf = RepPrefixBuffer;
                pchOpcodeBuf = OpcodeBuffer;
                X86OutputString(&pchOpcodeBuf, dszPAUSE);
            }
            // Fall through.
        default:                    /* opcode has no operand */
            break;
        }

        /* secondary action */
        switch (action2)
        {
        case MRM:
            /* generate modrm for later use */
            /* ignore if it has been generated */
            if (!mrm)
            {
                /* generate modrm */
                DIdoModrm(&pchModrmBuf, segOvr, fEAout);
                mrm = TRUE;         /* remember its generation */
            }
            break;

        case COM:                   /* insert a comma after operand */
            *pchOperandBuf++ = ',';
            break;

        case END:                   /* end of instruction */
            end = TRUE;
            break;
        }
    } while (!end);                        /* loop til end of instruction */

/*****       prepare disassembled instruction for output              *****/

//    dprintf("EAaddr[] = %08lx\n", (ULONG)Flat(EAaddr[0]));


    instlen = (int)(pMem - membuf);

    if (instlen < cBytes)
    {
        cBytes = instlen;
    }

    OutputHexCode(&pchResultBuf, membuf, cBytes);

    if (instlen > cBytes)
    {
        *pchResultBuf++ = '?';
        *pchResultBuf++ = '?';
        //  point past unread byte
        AddrAdd(paddr, 1);
        do
        {
            *pchResultBuf++ = ' ';
        } while (pchResultBuf < pchDst + OBOFFSET);
        X86OutputString(&pchResultBuf, "???\n");
        *pchResultBuf++ = '\0';
        return FALSE;
    }

    AddrAdd(paddr, instlen);

    PSTR Mark;
    
    // Now that we know the complete size of the instruction
    // we can correctly compute IP-relative absolute addresses.
    *pchOperandBuf = 0;
    if (g_X86ModrmHasIpRelOffset &&
        (Mark = strstr(OperandBuffer, IPREL_MARKER)) != NULL)
    {
        PSTR TailFrom, TailTo;
        ULONG64 IpRelAddr;
        size_t TailLen;
        
        // Move the tail of the string to the end of the buffer
        // to make space.
        TailFrom = Mark + sizeof(IPREL_MARKER) - 1;
        TailLen = pchOperandBuf - TailFrom;
        TailTo = OperandBuffer + (sizeof(OperandBuffer) - 1 - TailLen);
        memmove(TailTo, TailFrom, TailLen);

        // Compute the absolute address from the new IP
        // and the offset and format it into the buffer.
        IpRelAddr = Flat(*paddr) + g_X86IpRelOffset;
        OutputSymbol(&Mark, (PUCHAR)&IpRelAddr, g_SegAddrMode == 64 ? 8 : 4,
                     X86_CS_OVR);
        if (Mark < TailTo)
        {
            memmove(Mark, TailTo, TailLen);
            pchOperandBuf = Mark + TailLen;
        }
        else if (Mark >= TailTo + TailLen)
        {
            pchOperandBuf = Mark;
        }
        else
        {
            pchOperandBuf = Mark + (TailLen - (Mark - TailTo));
        }
    }
    
    //  if fEAout is set, build each EA with trailing space in EABuf
    //  point back over final trailing space if buffer nonnull

    if (fEAout)
    {
        for (indx = 0; indx < 2; indx++)
        {
            if (EAsize[indx])
            {
                X86OutputString(&pchEABuf, segOvr ? distbl[segOvr].instruct
                                               : pchEAseg[indx]);
                OutputHexAddr(&pchEABuf, &EAaddr[indx]);
                *pchEABuf++ = '=';
                tmp = GetMemString(&EAaddr[indx], membuf, EAsize[indx]);
                if (tmp == EAsize[indx])
                {
                    OutputHexString(&pchEABuf, membuf, EAsize[indx]);
                }
                else
                {
                    while (EAsize[indx]--)
                    {
                        *pchEABuf++ = '?';
                        *pchEABuf++ = '?';
                    }
                }
                *pchEABuf++ = ' ';
            }
        }

        if (pchEABuf != EABuffer)
        {
            pchEABuf--;
        }
        
        switch(JccEa)
        {
        case JCC_EA_NO_BRANCH:
            X86OutputString(&pchEABuf, "[br=0]");
            break;
        case JCC_EA_BRANCH:
            X86OutputString(&pchEABuf, "[br=1]");
            break;
        }
    }

    //  compute lengths of component strings.
    //  if the rep string is nonnull,
    //      add the opcode string length to the operand
    //      make the rep string the opcode string

    cbOffset = (int)(pchResultBuf - pchDst);
    cbOperand = (int)(pchOperandBuf - OperandBuffer);
    cbOpcode = (int)(pchOpcodeBuf - OpcodeBuffer);
    if (pchRepPrefixBuf != RepPrefixBuffer)
    {
        cbOperand += cbOpcode + (cbOperand != 0);
        cbOpcode = (int)(pchRepPrefixBuf - RepPrefixBuffer);
    }
    cbEAddr = (int)(pchEABuf - EABuffer);

    //  for really long strings, where the opcode and operand
    //      will not fit on a 77-character line, make two lines
    //      with the opcode on offset 0 on the second line with
    //      the operand following after one space

    //if (cbOpcode + cbOperand > OBLINEEND - 1) {
    //    fTwoLines = TRUE;
    //    obOpcode = 0;
    //    obOperand = cbOpcode + 1;
    //    }
    //else {

        //  compute the minimum and maximum offset values for
        //      opcode and operand strings.
        //  if strings are nonnull, add extra for separating space

        obOpcodeMin = cbOffset + 1;
        obOperandMin = obOpcodeMin + cbOpcode + 1;
        obOperandMax = OBLINEEND - cbEAddr - (cbEAddr != 0) - cbOperand;
        obOpcodeMax = obOperandMax - (cbOperand != 0) - cbOpcode;

        //  if minimum offset is more than the maximum, the strings
        //      will not fit on one line.  recompute the min/max
        //      values with no offset and EA strings.

    //    if (obOpcodeMin > obOpcodeMax) {
    //        fTwoLines = TRUE;
    //        obOpcodeMin = 0;
    //        obOperandMin = cbOpcode + 1;
    //        obOperandMax = OBLINEEND - cbOperand;
    //        obOpcodeMax = obOperandMax - (cbOperand != 0) - cbOpcode;
    //        }

        //  compute the opcode and operand offsets.  set offset as
        //      close to the default values as possible.

        if (obOpcodeMin > OBOFFSET)
        {
            obOpcode = obOpcodeMin;
        }
        else if (obOpcodeMax < OBOFFSET)
        {
            obOpcode = obOpcodeMax;
        }

        obOperandMin = obOpcode + cbOpcode + 1;

        if (obOperandMin > OBOPERAND)
        {
            obOperand = obOperandMin;
        }
        else if (obOperandMax < OBOPERAND)
        {
            obOperand = obOperandMax;
        }
    //    }

    //  build the resultant string with the offsets computed

    //  if two lines are to be output,
    //      append the EAddr string
    //      output a new line and reset the pointer

    if (fTwoLines)
    {
        if (pchEABuf != EABuffer)
        {
            do
            {
                *pchResultBuf++ = ' ';
            } while (pchResultBuf < pchDst + OBLINEEND - cbEAddr);
            *pchEABuf = '\0';
            X86OutputString(&pchResultBuf, EABuffer);
        }
        *pchResultBuf++ = '\n';
        pchDst = pchResultBuf;
    }

    //  output rep, opcode, and operand strings

    do
    {
        *pchResultBuf++ = ' ';
    } while (pchResultBuf < pchDst + obOpcode);

    if (pchRepPrefixBuf != RepPrefixBuffer)
    {
        *pchRepPrefixBuf = '\0';
        X86OutputString(&pchResultBuf, RepPrefixBuffer);
        do
        {
            *pchResultBuf++ = ' ';
        } while (pchResultBuf < pchDst + obOperand);
    }

    *pchOpcodeBuf = '\0';
    X86OutputString(&pchResultBuf, OpcodeBuffer);

    if (pchOperandBuf != OperandBuffer)
    {
        do
        {
            *pchResultBuf++ = ' ';
        } while (pchResultBuf < pchDst + obOperand);
        *pchOperandBuf = '\0';
        X86OutputString(&pchResultBuf, OperandBuffer);
    }

    //  if one line is to be output, append the EAddr string

    if (!fTwoLines && pchEABuf != EABuffer)
    {
        *pchEABuf = '\0';
        do
        {
            *pchResultBuf++ = ' ';
        } while (pchResultBuf < pchDst + OBLINEEND - cbEAddr);
        X86OutputString(&pchResultBuf, EABuffer);
    }

    *pchResultBuf++ = '\n';
    *pchResultBuf = '\0';
    return TRUE;
}

void
BaseX86MachineInfo::GetNextOffset(BOOL StepOver,
                                  PADDR NextAddr, PULONG NextMachine)
{
    int     cBytes;
    UCHAR   membuf[X86_MAX_INSTRUCTION_LEN]; //  current instruction buffer
    UCHAR   *pMem;
    UCHAR   opcode;
    int     fPrefix = TRUE;
    int     fRepPrefix = FALSE;
    int     ttt;
    int     rm;
    ULONG64 instroffset;
    int     subcode;

    // NextMachine is always the same.
    *NextMachine = m_ExecTypes[0];
        
    //  read instruction stream bytes into membuf and set mode and
    //      opcode size flags

    GetPC(NextAddr);
    instroffset = Flat(*NextAddr);
    GetSegAddrOpSizes(this, NextAddr);

    /* move full inst to local buffer */
    cBytes = (int)GetMemString(NextAddr, membuf, X86_MAX_INSTRUCTION_LEN);
    
    // Ensure that membuf is padded with innocuous bytes in
    // the section that wasn't read.
    if (cBytes < X86_MAX_INSTRUCTION_LEN)
    {
        memset(membuf + cBytes, 0xcc, X86_MAX_INSTRUCTION_LEN - cBytes);
    }
    
    /* point to begin of instruction */
    pMem = membuf;

    //  read and process any prefixes first

    do
    {
        opcode = *pMem++;        /* get opcode */
        if (opcode == 0x66)
        {
            OverrideOpSize(opcode);
        }
        else if (m_ExecTypes[0] == IMAGE_FILE_MACHINE_AMD64 &&
                 opcode >= 0x40 && opcode <= 0x4f)
        {
            ExtendOps(opcode);
        }
        else if (opcode == 0x67)
        {
            OverrideAddrMode();
        }
        else if ((opcode & ~1) == 0xf2)
        {
            fRepPrefix = TRUE;
        }
        else if (opcode != 0xf0 && (opcode & ~0x18) != 0x26 &&
                 (opcode & ~1) != 0x64)
        {
            fPrefix = FALSE;
        }
    } while (fPrefix);

    //  for instructions that alter the TF (trace flag), return the
    //      offset of the next instruction despite the flag of StepOver

    if (((opcode & ~0x3) == 0x9c) && !g_WatchTrace)
    {
        //  9c-9f, pushf, popf, sahf, lahf
        ;
    }
    else if (opcode == 0xcf)
    {
        ULONG64 RetAddr[2];
        ADDR Sp;
        ULONG Seg;
        
        //  cf - iret - get RA from stack
        FormSegRegAddress(&Sp, SEGREG_STACK, GetReg64(X86_NSP));

        if (GetMemString(&Sp, RetAddr, g_SegAddrMode / 4) !=
            (ULONG)g_SegAddrMode / 4)
        {
            error(MEMORY);
        }

        Seg = *(PUSHORT)((PUCHAR)RetAddr + g_SegAddrMode / 8);
        switch(g_SegAddrMode)
        {
        case 16:
            instroffset = EXTEND64(*(PUSHORT)RetAddr);
            break;
        case 32:
            instroffset = EXTEND64(*(PULONG)RetAddr);
            break;
        case 64:
            instroffset = RetAddr[0];
            break;
        }

        FormSelAddress(NextAddr, Seg, instroffset);
        ComputeFlatAddress(NextAddr, NULL);
        return;
    }
    else if (opcode == 0xc4 && *pMem == 0xc4)
    {
        subcode = *(pMem+1);
        if ( subcode == 0x50 ||
             subcode == 0x52 ||
             subcode == 0x53 ||
             subcode == 0x54 ||
             subcode == 0x57 ||
             subcode == 0x58 ||
             subcode == 0x5D )
        {
            pMem += 3;
        }
        else
        {
            pMem += 2;
        }
    }
    else if (!StepOver)
    {
        //  if tracing just return OFFSET_TRACE to trace
        instroffset = OFFSET_TRACE;
    }
    else if (opcode == 0xe8)
    {
        //  near direct jump
        pMem += g_OpSize > 16 ? 4 : 2;
    }
    else if (opcode == 0x9a)
    {
        //  far direct jump
        pMem += g_OpSize > 16 ? 6 : 4;
    }
    else if (opcode == 0xcd ||
             (opcode >= 0xe0 && opcode <= 0xe2))
    {
        //  loop / int nn instrs
        pMem++;
    }
    else if (opcode == 0xff)
    {
        //  indirect call - compute length
        opcode = *pMem++;               //  get modRM
        ttt = BIT53(opcode);
        if ((ttt & ~1) == 2)
        {
            mod = BIT76(opcode);
            if (mod != 3)
            {
                //  nonregister operand
                rm = BIT20(opcode);
                if (g_AddrMode > 16)
                {
                    if (rm == 4)
                    {
                        rm = BIT20(*pMem++);    //  get base from SIB
                    }
                    if (mod == 0)
                    {
                        if (rm == 5)
                        {
                            pMem += 4;          //  long direct address
                        }                       //  else register
                    }
                    else if (mod == 1)
                    {
                        pMem++;                 //  register with byte offset
                    }
                    else
                    {
                        pMem += 4;              //  register with long offset
                    }
                }
                else
                {
                    // 16-bit mode
                    if (mod == 0)
                    {
                        if (rm == 6)
                        {
                            pMem += 2;          //  short direct address
                        }
                    }
                    else
                    {
                        pMem += mod;            //  reg, byte, word offset
                    }
                }
            }
        }
        else
        {
            instroffset = OFFSET_TRACE;         //  0xff, but not call
        }
    }
    else if (!((fRepPrefix && ((opcode & ~3) == 0x6c ||
                               (opcode & ~3) == 0xa4 ||
                               (opcode & ~1) == 0xaa ||
                               (opcode & ~3) == 0xac)) ||
                               opcode == 0xcc || opcode == 0xce))
    {
        instroffset = OFFSET_TRACE;             //  not repeated string op
    }                                           //  or int 3 / into

    //  if not enough bytes were read for instruction parse,
    //      just give up and trace the instruction

    if (cBytes < pMem - (PUCHAR)membuf)
    {
        instroffset = OFFSET_TRACE;
    }

    //  if not tracing, compute the new instruction offset

    if (instroffset != OFFSET_TRACE)
    {
        instroffset += pMem - (PUCHAR)membuf;
    }

    Flat(*NextAddr) = instroffset;
    ComputeNativeAddress(NextAddr);
}

/*...........................internal function..............................*/
/*                                                                          */
/*                       generate a mod/rm string                           */
/*                                                                          */

void
BaseX86MachineInfo::DIdoModrm (char **ppchBuf, int segOvr, BOOL fEAout)
{
    int     mrm;                        /* modrm byte */
    char    *src;                       /* source string */
    int     sib;
    int     ss;
    int     ind;
    int     oldrm;

    mrm = *pMem++;                      /* get the mrm byte from instruction */
    mod = BIT76(mrm);                   /* get mod */
    ttt = BIT53(mrm) + g_ExtendMrmReg;  /* get reg - used outside routine */
    rm  = BIT20(mrm);                   /* get rm */

    if (mod == 3)
    {
        rm += g_ExtendRm;
        
        /* register only mode */
        if (g_XmmRegEa)
        {
            *(*ppchBuf)++ = 'x';
            *(*ppchBuf)++ = 'm';
            *(*ppchBuf)++ = 'm';
            if (rm >= 10)
            {
                *(*ppchBuf)++ = (char)('0' + rm / 10);
                rm %= 10;
            }
            *(*ppchBuf)++ = rm + '0';
        }
        else if (g_MmRegEa)
        {
            *(*ppchBuf)++ = 'm';
            *(*ppchBuf)++ = 'm';
            *(*ppchBuf)++ = rm + '0';
        }
        else
        {
            if (EAsize[0] == 1)
            {
                /* point to 8-bit register */
                if (g_ExtendAny && rm < 8)
                {
                    src = g_Amd64ExtendedReg8[rm];
                }
                else
                {
                    src = g_X86Reg8[rm];
                }
                X86OutputString(ppchBuf, src);
            }
            else
            {
                src = g_X86RegBase[rm];
                if (g_ForceMrmReg32)
                {
                    *(*ppchBuf)++ = 'e';
                }
                else if (g_OpSize > 16 && !g_MovX)
                {
                    /* make it a 32- or 64-bit register */
                    *(*ppchBuf)++ = (rm >= 8 || g_OpSize == 64 && !g_MovSXD) ?
                        'r' : 'e';
                }
                X86OutputString(ppchBuf, src);
                if (rm >= 8)
                {
                    if (g_OpSize == 32)
                    {
                        *(*ppchBuf)++ = 'd';
                    }
                    else if (g_OpSize == 16)
                    {
                        *(*ppchBuf)++ = 'w';
                    }
                }

                if (g_ControlFlow && fEAout)
                {
                    // This is a call/jmp through a register.
                    // Output a code symbol for the target.
                    ULONG64 Target = GetReg64(g_X86RegIdx[rm]);
                    *(*ppchBuf)++ = ' ';
                    *(*ppchBuf)++ = '{';
                    OutputSymbol(ppchBuf, (PUCHAR)&Target, g_OpSize / 8,
                                 X86_CS_OVR);
                    *(*ppchBuf)++ = '}';
                }
            }
        }
        EAsize[0] = 0;                  //  no EA value to output
        return;
    }

    if (g_AddrMode == 64)
    {
        oldrm = rm;
        if (rm == 4)
        {
            /* rm == 4 implies sib byte */
            sib = *pMem++;              /* get s_i_b byte */
            rm = BIT20(sib);
        }

        *(*ppchBuf)++ = '[';
        if (mod == 0 && rm == 5)
        {
            if (g_SegAddrMode == 64 && oldrm == 5)
            {
                // IP-relative 32-bit displacement.  The
                // displacement is relative to the IP of the
                // next instruction, which can't be computed
                // yet so just put in a marker for post-processing.
                g_X86ModrmHasIpRelOffset = TRUE;
                g_X86IpRelOffset = *(LONG UNALIGNED *)pMem;
                X86OutputString(ppchBuf, IPREL_MARKER);
            }
            else
            {
                // Absolute 32-bit displacement.
                OutputSymbol(ppchBuf, pMem, 4, segOvr);
            }

            pMem += 4;
        }
        else
        {
            rm += g_ExtendRm;
            
            if (fEAout)
            {
                if (segOvr)
                {
                    FormSegRegAddress(&EAaddr[0], GetSegReg(segOvr),
                                      GetReg64(g_X86RegIdx[rm]));
                    pchEAseg[0] = distbl[segOvr].instruct;
                }
                else if (g_X86RegIdx[rm] == X86_NBP ||
                         g_X86RegIdx[rm] == X86_NSP)
                {
                    FormSegRegAddress(&EAaddr[0], SEGREG_STACK,
                                      GetReg64(g_X86RegIdx[rm]));
                    pchEAseg[0] = dszSS_;
                }
                else
                {
                    FormSegRegAddress(&EAaddr[0], SEGREG_DATA,
                                      GetReg64(g_X86RegIdx[rm]));
                }
            }
            X86OutputString(ppchBuf, g_X86Mrm64[rm]);
        }

        if (oldrm == 4)
        {
            //  finish processing sib
            ind = BIT53(sib);
            if (ind != 4)
            {
                ind += g_ExtendSibIndex;
                *(*ppchBuf)++ = '+';
                X86OutputString(ppchBuf, g_X86Mrm64[ind]);
                ss = 1 << BIT76(sib);
                if (ss != 1)
                {
                    *(*ppchBuf)++ = '*';
                    *(*ppchBuf)++ = (char)(ss + '0');
                }
                if (fEAout)
                {
                    AddrAdd(&EAaddr[0], GetReg64(g_X86RegIdx[ind]) * ss);
                }
            }
        }
    }
    else if (g_AddrMode == 32)
    {
        oldrm = rm;
        if (rm == 4)
        {
            /* rm == 4 implies sib byte */
            sib = *pMem++;              /* get s_i_b byte */
            rm = BIT20(sib);
        }

        *(*ppchBuf)++ = '[';
        if (mod == 0 && rm == 5)
        {
            if (g_SegAddrMode == 64 && oldrm == 5)
            {
                // IP-relative 32-bit displacement.  The
                // displacement is relative to the IP of the
                // next instruction, which can't be computed
                // yet so just put in a marker for post-processing.
                g_X86ModrmHasIpRelOffset = TRUE;
                g_X86IpRelOffset = *(LONG UNALIGNED *)pMem;
                X86OutputString(ppchBuf, IPREL_MARKER);
            }
            else
            {
                // Absolute 32-bit displacement.
                OutputSymbol(ppchBuf, pMem, 4, segOvr);
            }

            pMem += 4;
        }
        else
        {
            rm += g_ExtendRm;
            
            if (fEAout)
            {
                if (segOvr)
                {
                    FormSegRegAddress(&EAaddr[0], GetSegReg(segOvr),
                                      EXTEND64(GetReg32(g_X86RegIdx[rm])));
                    pchEAseg[0] = distbl[segOvr].instruct;
                }
                else if (g_X86RegIdx[rm] == X86_NBP ||
                         g_X86RegIdx[rm] == X86_NSP)
                {
                    FormSegRegAddress(&EAaddr[0], SEGREG_STACK,
                                      EXTEND64(GetReg32(g_X86RegIdx[rm])));
                    pchEAseg[0] = dszSS_;
                }
                else
                {
                    FormSegRegAddress(&EAaddr[0], SEGREG_DATA,
                                      EXTEND64(GetReg32(g_X86RegIdx[rm])));
                }
            }
            X86OutputString(ppchBuf, g_X86Mrm32[rm]);
        }

        if (oldrm == 4)
        {
            //  finish processing sib
            ind = BIT53(sib);
            if (ind != 4)
            {
                ind += g_ExtendSibIndex;
                *(*ppchBuf)++ = '+';
                X86OutputString(ppchBuf, g_X86Mrm32[ind]);
                ss = 1 << BIT76(sib);
                if (ss != 1)
                {
                    *(*ppchBuf)++ = '*';
                    *(*ppchBuf)++ = (char)(ss + '0');
                }
                if (fEAout)
                {
                    AddrAdd(&EAaddr[0],
                            EXTEND64(GetReg32(g_X86RegIdx[ind])) * ss);
                }
            }
        }
    }
    else
    {
        //  16-bit addressing mode
        *(*ppchBuf)++ = '[';
        if (mod == 0 && rm == 6)
        {
            OutputSymbol(ppchBuf, pMem, 2, segOvr);   // 16-bit offset
            pMem += 2;
        }
        else
        {
            if (fEAout)
            {
                if (segOvr)
                {
                    FormSegRegAddress(&EAaddr[0], GetSegReg(segOvr),
                                      GetReg16(g_X86Reg16Idx[rm]));
                    pchEAseg[0] = distbl[segOvr].instruct;
                }
                else if (g_X86Reg16Idx[rm] == X86_NBP)
                {
                    FormSegRegAddress(&EAaddr[0], SEGREG_STACK,
                                      GetReg16(g_X86Reg16Idx[rm]));
                    pchEAseg[0] = dszSS_;
                }
                else
                {
                    FormSegRegAddress(&EAaddr[0], SEGREG_DATA,
                                      GetReg16(g_X86Reg16Idx[rm]));
                }
                if (rm < 4)
                {
                    AddrAdd(&EAaddr[0], GetReg16(g_X86Reg16Idx2[rm]));
                }
            }
            X86OutputString(ppchBuf, g_X86Mrm16[rm]);
        }
    }

    //  output any displacement

    if (mod == 1)
    {
        if (fEAout)
        {
            AddrAdd(&EAaddr[0], (long)*(char *)pMem);
        }
        OutputHexValue(ppchBuf, pMem, 1, TRUE);
        pMem++;
    }
    else if (mod == 2)
    {
        long tmp = 0;
        if (g_AddrMode > 16)
        {
            memmove(&tmp,pMem,sizeof(long));
            if (fEAout)
            {
                AddrAdd(&EAaddr[0], tmp);
            }
            OutputHexValue(ppchBuf, pMem, 4, TRUE);
            pMem += 4;
        }
        else
        {
            memmove(&tmp,pMem,sizeof(short));
            if (fEAout)
            {
                AddrAdd(&EAaddr[0], tmp);
            }
            OutputHexValue(ppchBuf, pMem, 2, TRUE);
            pMem += 2;
        }
    }

    if (g_AddrMode == 16 && fEAout)
    {
        Off(EAaddr[0]) &= 0xffff;
        NotFlat(EAaddr[0]);
        Off(EAaddr[1]) &= 0xffff;
        NotFlat(EAaddr[1]);
        ComputeFlatAddress(&EAaddr[0], NULL);
        ComputeFlatAddress(&EAaddr[1], NULL);
    }

    *(*ppchBuf)++ = ']';

    // The value at the effective address may be pointing to an interesting
    // symbol, as with indirect jumps or memory operations.
    // If there's an EA and an exact symbol match, display
    // the extra symbol.
    if (fEAout)
    {
        DWORD64 symbol;

        if (g_Target->ReadPointer(this, Flat(EAaddr[0]), &symbol) == S_OK)
        {
            char* pchBuf = *ppchBuf;

            (*ppchBuf)++;
            if (OutputExactSymbol(ppchBuf, (PUCHAR)&symbol,
                                  m_Ptr64 ? 8 : 4, segOvr))
            {
                *pchBuf = '{';
                *(*ppchBuf)++ = '}';
            }
            else
            {
                (*ppchBuf)--;
            }
        }
    }
}

LONGLONG
GetSignExtendedValue(int OpLen, PUCHAR Mem)
{
    switch(OpLen)
    {
    case 1:
        return *(char *)Mem;
    case 2:
        return *(short UNALIGNED *)Mem;
    case 4:
        return *(long UNALIGNED *)Mem;
    case 8:
        return *(LONGLONG UNALIGNED *)Mem;
    }

    DBG_ASSERT(FALSE);
    return 0;
}

/*** OutputHexValue - output hex value
*  07-Jun-1999 -by- Andre Vachon
*   Purpose:
*       Output the value pointed by *ppchBuf of the specified
*       length.  The value is treated as signed and leading
*       zeroes are not printed.  The string is prefaced by a
*       '+' or '-' sign as appropriate.
*
*   Input:
*       *ppchBuf - pointer to text buffer to fill
*       *pchMemBuf - pointer to memory buffer to extract value
*       length - length in bytes of value (1, 2, and 4 supported)
*       fDisp - set if displacement to output '+'
*
*   Output:
*       *ppchBuf - pointer updated to next text character
*
*************************************************************************/

void
OutputHexValue (char **ppchBuf, PUCHAR pchMemBuf, int length, int fDisp)
{
    LONGLONG value;
    int index;
    char digit[32];

    value = GetSignExtendedValue(length, pchMemBuf);

    length <<= 1;               //  shift once to get hex length

    if (value != 0 || !fDisp)
    {
        if (fDisp)
        {
            //  use neg value for byte displacement
            //  assume very large DWORDs are negative too
            if (value < 0 &&
                (length == 2 ||
                 ((unsigned long)value & 0xff000000) == 0xff000000))
            {
                value = -value;
                *(*ppchBuf)++ = '-';
            }
            else
            {
                *(*ppchBuf)++ = '+';
            }
        }

        *(*ppchBuf)++ = '0';
        *(*ppchBuf)++ = 'x';
        for (index = length - 1; index != -1; index--)
        {
            digit[index] = (char)(value & 0xf);
            value >>= 4;
        }
        index = 0;
        while (digit[index] == 0 && index < length - 1)
        {
            index++;
        }
        while (index < length)
        {
            *(*ppchBuf)++ = hexdigit[digit[index++]];
        }
    }
}

void
OutputExHexValue(char **ppchBuf, PUCHAR pchMemBuf, int MemLen, int OpLen)
{
    LONGLONG Value = GetSignExtendedValue(MemLen, pchMemBuf);
    OutputHexValue(ppchBuf, (PUCHAR)&Value, OpLen, FALSE);
}

/*** OutputHexString - output hex string
*
*   Purpose:
*       Output the value pointed by *ppchMemBuf of the specified
*       length.  The value is treated as unsigned and leading
*       zeroes are printed.
*
*   Input:
*       *ppchBuf - pointer to text buffer to fill
*       *pchValue - pointer to memory buffer to extract value
*       length - length in bytes of value
*
*   Output:
*       *ppchBuf - pointer updated to next text character
*       *ppchMemBuf - pointer update to next memory byte
*
*************************************************************************/

void
OutputHexString (char **ppchBuf, PUCHAR pchValue, int length)
{
    UCHAR chMem;

    pchValue += length;
    while (length--)
    {
        chMem = *--pchValue;
        *(*ppchBuf)++ = hexdigit[chMem >> 4];
        *(*ppchBuf)++ = hexdigit[chMem & 0x0f];
    }
}

/*** OutputHexCode - output hex code
*
*   Purpose:
*       Output the code pointed by pchMemBuf of the specified
*       length.  The value is treated as unsigned and leading
*       zeroes are printed.  This differs from OutputHexString
*       in that bytes are printed from low to high addresses.
*
*   Input:
*       *ppchBuf - pointer to text buffer to fill
*       pchMemBuf - pointer to memory buffer to extract value
*       length - length in bytes of value
*
*   Output:
*       *ppchBuf - pointer updated to next text character
*
*************************************************************************/

void OutputHexCode (char **ppchBuf, PUCHAR pchMemBuf, int length)
{
    UCHAR chMem;

    while (length--)
    {
        chMem = *pchMemBuf++;
        *(*ppchBuf)++ = hexdigit[chMem >> 4];
        *(*ppchBuf)++ = hexdigit[chMem & 0x0f];
    }
}

/*** X86OutputString - output string
*
*   Purpose:
*       Copy the string into the buffer pointed by *ppBuf.
*
*   Input:
*       *pStr - pointer to string
*
*   Output:
*       *ppBuf points to next character in buffer.
*
*************************************************************************/

void
X86OutputString (
    char **ppBuf,
    char *pStr
    )
{
    while (*pStr)
    {
        *(*ppBuf)++ = *pStr++;
    }
}


/*** OutputSymbol - output symbolic value
*
*   Purpose:
*       Output the value in outvalue into the buffer
*       pointed by *pBuf.  Express the value as a
*       symbol plus displacment, if possible.
*
*   Input:
*       *ppBuf - pointer to text buffer to fill
*       *pValue - pointer to memory buffer to extract value
*       length - length in bytes of value
*
*   Output:
*       *ppBuf - pointer updated to next text character
*
*************************************************************************/

void
BaseX86MachineInfo::OutputSymbol (
    char **ppBuf,
    PUCHAR pValue,
    int length,
    int segOvr
    )
{
    CHAR   chSymbol[MAX_SYMBOL_LEN];
    ULONG64 displacement;
    ULONG64 value;

    value = 0;
    memcpy(&value, pValue, length);
    if (length == 4)
    {
        value = EXTEND64(value);
    }

    if (IS_CONTEXT_ACCESSIBLE())
    {
        FormSegRegAddress(&EAaddr[0], GetSegReg(segOvr), value);
        value = Flat(EAaddr[0]);
    }

    GetSymbolStdCall(value, chSymbol, sizeof(chSymbol), &displacement, NULL);
    if (chSymbol[0])
    {
        X86OutputString(ppBuf, chSymbol);
        OutputHexValue(ppBuf, (PUCHAR)&displacement, length, TRUE);
        *(*ppBuf)++ = ' ';
        *(*ppBuf)++ = '(';
        OutputHexString(ppBuf, pValue, length);
        *(*ppBuf)++ = ')';
    }
    else
    {
        OutputHexString(ppBuf, pValue, length);
    }
}

/*** OutputExactSymbol - Output symbolic value only for exact symbol
*                        matches.
*
*************************************************************************/

BOOL
BaseX86MachineInfo::OutputExactSymbol (
    char **ppBuf,
    PUCHAR pValue,
    int length,
    int segOvr
    )
{
    CHAR   chSymbol[MAX_SYMBOL_LEN];
    ULONG64 displacement;
    ULONG64 value;

    value = 0;
    memcpy(&value, pValue, length);
    if (length == 4)
    {
        value = EXTEND64(value);
    }

    GetSymbolStdCall(value, chSymbol, sizeof(chSymbol), &displacement, NULL);
    if (chSymbol[0] && displacement == 0)
    {
        X86OutputString(ppBuf, chSymbol);
        OutputHexValue(ppBuf, (PUCHAR)&displacement, length, TRUE);
        *(*ppBuf)++ = ' ';
        *(*ppBuf)++ = '(';
        OutputHexString(ppBuf, pValue, length);
        *(*ppBuf)++ = ')';
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

void
OutputHexAddr(PSTR *ppBuffer, PADDR paddr)
{
    sprintAddr(ppBuffer, paddr);
    // Remove trailing space.
    (*ppBuffer)--;
    **ppBuffer = 0;
}

ULONG
BaseX86MachineInfo::GetSegReg(int SegOpcode)
{
    switch(SegOpcode)
    {
    case 0x26:
        return SEGREG_ES;
    case X86_CS_OVR:
        return SEGREG_CODE;
    case 0x36:
        return SEGREG_STACK;
    case 0x64:
        return SEGREG_FS;
    case 0x65:
        return SEGREG_GS;
    case 0x3e:
    default:
        return SEGREG_DATA;
    }
}

int
BaseX86MachineInfo::ComputeJccEa(int Opcode, BOOL EaOut)
{
    if (!EaOut)
    {
        return JCC_EA_NONE;
    }

    ULONG Flags;
    int Branch;

    if ((Opcode >= 0x70 && Opcode <= 0x7f) ||
        (Opcode >= 0x180 && Opcode <= 0x18f))
    {
        int Table = (Opcode >> 1) & 7;

        Flags = GetReg32(X86_NFL);
        Branch = Opcode & 1;
        if ((Flags & g_JccCheckTable[Table][0]) != 0 ||
            ((Flags >> g_JccCheckTable[Table][1]) & 1) !=
            ((Flags >> g_JccCheckTable[Table][2]) & 1))
        {
            Branch ^= 1;
        }

        return JCC_EA_NO_BRANCH + Branch;
    }
    else
    {
        ULONG64 Cx = GetReg64(X86_NCX);
        switch(g_OpSize)
        {
        case 16:
            Cx &= 0xffff;
            break;
        case 32:
            Cx &= 0xffffffff;
            break;
        }
        
        switch(Opcode)
        {
        case 0xe0: // LOOPNE.
            Flags = GetReg32(X86_NFL);
            Branch = (Flags & X86_BIT_FLAGZF) == 0 && Cx != 1 ?
                JCC_EA_BRANCH : JCC_EA_NO_BRANCH;
            break;
        case 0xe1: // LOOPE.
            Flags = GetReg32(X86_NFL);
            Branch = (Flags & X86_BIT_FLAGZF) != 0 && Cx != 1 ?
                JCC_EA_BRANCH : JCC_EA_NO_BRANCH;
            break;
        case 0xe2: // LOOP.
            Branch = Cx == 1 ? JCC_EA_NO_BRANCH : JCC_EA_BRANCH;
            break;
        case 0xe3: // J*CXZ.
            Branch = Cx == 0 ? JCC_EA_BRANCH : JCC_EA_NO_BRANCH;
            break;
        default:
            DBG_ASSERT(FALSE);
            Branch = JCC_EA_NONE;
            break;
        }

        return Branch;
    }
}

BOOL
BaseX86MachineInfo::IsBreakpointInstruction(PADDR Addr)
{
    UCHAR Instr[X86_INT3_LEN];

    if (GetMemString(Addr, Instr, X86_INT3_LEN) != X86_INT3_LEN)
    {
        return FALSE;
    }

    return !memcmp(Instr, g_X86Int3, X86_INT3_LEN);
}

HRESULT
BaseX86MachineInfo::InsertBreakpointInstruction(PUSER_DEBUG_SERVICES Services,
                                                ULONG64 Process,
                                                ULONG64 Offset,
                                                PUCHAR SaveInstr,
                                                PULONG64 ChangeStart,
                                                PULONG ChangeLen)
{
    if ((g_TargetMachineType != IMAGE_FILE_MACHINE_I386) &&
        (g_Wow64exts != NULL))
    {
        PPROCESS_INFO ProcInfo = FindProcessByHandle(Process);
        if (ProcInfo != NULL)
        {
            (*g_Wow64exts)(WOW64EXTS_FLUSH_CACHE_WITH_HANDLE,
                           (ULONG64)ProcInfo->Handle, Offset, X86_INT3_LEN);
        }
    }

    *ChangeStart = Offset;
    *ChangeLen = X86_INT3_LEN;
    
    ULONG Done;
    HRESULT Status;

    Status = Services->ReadVirtual(Process, Offset, SaveInstr,
                                   X86_INT3_LEN, &Done);
    if (Status == S_OK && Done != X86_INT3_LEN)
    {
        Status = HRESULT_FROM_WIN32(ERROR_READ_FAULT);
    }

    if (Status == S_OK)
    {
        Status = Services->WriteVirtual(Process, Offset, g_X86Int3,
                                        X86_INT3_LEN, &Done);
        if (Status == S_OK && Done != X86_INT3_LEN)
        {
            Status = HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
        }
    }

    return Status;
}

HRESULT
BaseX86MachineInfo::RemoveBreakpointInstruction(PUSER_DEBUG_SERVICES Services,
                                                ULONG64 Process,
                                                ULONG64 Offset,
                                                PUCHAR SaveInstr,
                                                PULONG64 ChangeStart,
                                                PULONG ChangeLen)
{
    if ((g_TargetMachineType != IMAGE_FILE_MACHINE_I386) &&
        (g_Wow64exts != NULL))
    {
        PPROCESS_INFO ProcInfo = FindProcessByHandle(Process);
        if (ProcInfo != NULL)
        {
            (*g_Wow64exts)(WOW64EXTS_FLUSH_CACHE_WITH_HANDLE,
                           (ULONG64)ProcInfo->Handle, Offset, X86_INT3_LEN);
        }
    }

    *ChangeStart = Offset;
    *ChangeLen = X86_INT3_LEN;
    
    ULONG Done;
    HRESULT Status;

    Status = Services->WriteVirtual(Process, Offset, SaveInstr,
                                    X86_INT3_LEN, &Done);
    if (Status == S_OK && Done != X86_INT3_LEN)
    {
        Status = HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
    }
    return Status;
}

void
BaseX86MachineInfo::AdjustPCPastBreakpointInstruction(PADDR Addr,
                                                      ULONG BreakType)
{
    if (BreakType == DEBUG_BREAKPOINT_CODE)
    {
        AddrAdd(Addr, X86_INT3_LEN);
        SetPC(Addr);
    }
}

BOOL
BaseX86MachineInfo::IsCallDisasm(PCSTR Disasm)
{
    return strstr(Disasm, " call") != NULL;
}

BOOL
BaseX86MachineInfo::IsReturnDisasm(PCSTR Disasm)
{
    return strstr(Disasm, " ret") != NULL ||
        (IS_KERNEL_TARGET() && strstr(Disasm, " iretd") != NULL);
}

BOOL
BaseX86MachineInfo::IsSystemCallDisasm(PCSTR Disasm)
{
    return (strstr(Disasm, " int ") != NULL &&
            strstr(Disasm, " 2e") != NULL) ||
        strstr(Disasm, " sysenter") != NULL ||
        strstr(Disasm, " syscall") != NULL;
}

BOOL
BaseX86MachineInfo::IsDelayInstruction(PADDR Addr)
{
    // X86 does not have delay slots.
    return FALSE;
}

void
BaseX86MachineInfo::GetEffectiveAddr(PADDR Addr)
{
    *Addr = EAaddr[0];
}

void
BaseX86MachineInfo::IncrementBySmallestInstruction(PADDR Addr)
{
    AddrAdd(Addr, 1);
}

void
BaseX86MachineInfo::DecrementBySmallestInstruction(PADDR Addr)
{
    AddrSub(Addr, 1);
}

//----------------------------------------------------------------------------
//
// X86MachineInfo methods.
//
//----------------------------------------------------------------------------

HRESULT
X86MachineInfo::NewBreakpoint(DebugClient* Client, 
                              ULONG Type,
                              ULONG Id,
                              Breakpoint** RetBp)
{
    HRESULT Status;

    switch(Type & (DEBUG_BREAKPOINT_CODE | DEBUG_BREAKPOINT_DATA))
    {
    case DEBUG_BREAKPOINT_CODE:
        *RetBp = new CodeBreakpoint(Client, Id, IMAGE_FILE_MACHINE_I386);
        Status = (*RetBp) ? S_OK : E_OUTOFMEMORY;
        break;
    case DEBUG_BREAKPOINT_DATA:
        *RetBp = new X86DataBreakpoint(Client, Id, X86_CR4, X86_DR6, IMAGE_FILE_MACHINE_I386);
        Status = (*RetBp) ? S_OK : E_OUTOFMEMORY;
        break;
    default:
        // Unknown breakpoint type.
        Status = E_NOINTERFACE;
    }

    return Status;
}

void
X86MachineInfo::InsertAllDataBreakpoints(void)
{
    PPROCESS_INFO ProcessSave = g_CurrentProcess;
    PTHREAD_INFO Thread;

    // Update thread context for every thread.

    g_CurrentProcess = g_ProcessHead;
    while (g_CurrentProcess != NULL)
    {
        Thread = g_CurrentProcess->ThreadHead;
        while (Thread != NULL)
        {
            ULONG Dr7Value;

            BpOut("Thread %d data breaks %d\n",
                  Thread->UserId, Thread->NumDataBreaks);

            ChangeRegContext(Thread);

            // Start with all breaks turned off.
            Dr7Value = GetIntReg(X86_DR7) & ~X86_DR7_CTRL_03_MASK;

            if (Thread->NumDataBreaks > 0)
            {
                ULONG i;

                for (i = 0; i < Thread->NumDataBreaks; i++)
                {
                    X86DataBreakpoint* Bp =
                        (X86DataBreakpoint *)Thread->DataBreakBps[i];

                    ULONG64 Addr = Flat(*Bp->GetAddr());
                    BpOut("  dbp %d at %p\n", i, Addr);
                    if (g_DataBreakpointsChanged)
                    {
                        SetReg32(X86_DR0 + i, (ULONG)Addr);
                    }
                    // There are two enable bits per breakpoint
                    // and four len/rw bits so split up enables
                    // and len/rw when shifting into place.
                    Dr7Value |=
                        ((Bp->m_Dr7Bits & 0xffff0000) << (i * 4)) |
                        ((Bp->m_Dr7Bits & X86_DR7_ALL_ENABLES) << (i * 2));
                }

                // The kernel automatically clears DR6 when it
                // processes a DBGKD_CONTROL_SET.
                if (IS_USER_TARGET())
                {
                    SetReg32(X86_DR6, 0);
                }

                // Set local exact match, which is effectively global on NT.
                Dr7Value |= X86_DR7_LOCAL_EXACT_ENABLE;
            }

            BpOut("  thread %d DR7 %X\n", Thread->UserId, Dr7Value);
            SetReg32(X86_DR7, Dr7Value);

            Thread = Thread->Next;
        }

        g_CurrentProcess = g_CurrentProcess->Next;
    }

    g_CurrentProcess = ProcessSave;
    if (g_CurrentProcess != NULL)
    {
        ChangeRegContext(g_CurrentProcess->CurrentThread);
    }
    else
    {
        ChangeRegContext(NULL);
    }
}

void
X86MachineInfo::RemoveAllDataBreakpoints(void)
{
    SetReg32(X86_DR7, 0);
}

ULONG
X86MachineInfo::IsBreakpointOrStepException(PEXCEPTION_RECORD64 Record,
                                            ULONG FirstChance,
                                            PADDR BpAddr,
                                            PADDR RelAddr)
{
    if (Record->ExceptionCode == STATUS_BREAKPOINT ||
        Record->ExceptionCode == STATUS_WX86_BREAKPOINT)
    {
        // Data breakpoints hit as STATUS_SINGLE_STEP so
        // this can only be a code breakpoint.
        if (IS_USER_TARGET() && FirstChance)
        {
            // Back up to the actual breakpoint instruction.
            AddrSub(BpAddr, X86_INT3_LEN);
            SetPC(BpAddr);
        }
        return EXBS_BREAKPOINT_CODE;
    }
    else if (Record->ExceptionCode == STATUS_SINGLE_STEP ||
             Record->ExceptionCode == STATUS_WX86_SINGLE_STEP)
    {
        // XXX t-tcheng - Conversion for Dr6, Dr7 not implemented yet...

        ULONG Dr6 = GetIntReg(X86_DR6);
        ULONG Dr7 = GetIntReg(X86_DR7);

        BpOut("X86 step: DR6 %X, DR7 %X\n", Dr6, Dr7);

        // The single step bit should always be set if a data breakpoint
        // is hit but also check the DR7 enables just in case.
        if ((Dr6 & X86_DR6_SINGLE_STEP) || (Dr7 & X86_DR7_ALL_ENABLES) == 0 ||
            (Dr6 & X86_DR6_BREAK_03) == 0)
        {
            // XXX drewb - The values in the last-branch MSRs are
            // not helpful for unknown reasons.  Leave this code
            // off until we can determine whether there's a way
            // to get the right branch source address.
#if 0
            if (IS_REMOTE_KERNEL_TARGET() && m_SupportsBranchTrace)
            {
                ULONG64 LastIp;

                if (NT_SUCCESS(DbgKdReadMsr(X86_MSR_LAST_BRANCH_FROM_IP,
                                            &LastIp)))
                {
                    // The branch may have come from a different
                    // segment.  We could try and determine what
                    // code segment it was by reading the stack to
                    // get the saved CS value but it's not worth
                    // it right now.
                    FormAddr(SEGREG_CODE, LastIp,
                             FORM_CODE | FORM_SEGREG |
                             X86_FORM_VM86(GetIntReg(X86_EFL)),
                             RelAddr);
                }
            }
#endif
            
            // This is a true single step exception, not
            // a data breakpoint.
            return EXBS_STEP_INSTRUCTION;
        }
        else
        {
            // Some data breakpoint must be hit.
            // There doesn't appear to be any way
            // to get the faulting address so just leave the PC.
            return EXBS_BREAKPOINT_DATA;
        }
    }

    return EXBS_NONE;
}

void 
X86MachineInfo::PrintStackFrameAddressesTitle(ULONG Flags)
{
    PrintMultiPtrTitle("ChildEBP", 1);
    PrintMultiPtrTitle("RetAddr", 1);
}

void 
X86MachineInfo::PrintStackFrameAddresses(ULONG Flags, 
                                         PDEBUG_STACK_FRAME StackFrame)
{
    dprintf("%s %s ",
        FormatAddr64(StackFrame->FrameOffset),
        FormatAddr64(StackFrame->ReturnOffset));
}

void
X86MachineInfo::PrintStackArgumentsTitle(ULONG Flags)
{
    PrintMultiPtrTitle("Args to Child", 3);
}

void 
X86MachineInfo::PrintStackArguments(ULONG Flags, 
                                    PDEBUG_STACK_FRAME StackFrame)
{
    dprintf("%s %s %s ",
            FormatAddr64(StackFrame->Params[0]),
            FormatAddr64(StackFrame->Params[1]),
            FormatAddr64(StackFrame->Params[2]));
}

void 
X86MachineInfo::PrintStackCallSiteTitle(ULONG Flags)
{
}

void 
X86MachineInfo::PrintStackCallSite(ULONG Flags, 
                                   PDEBUG_STACK_FRAME StackFrame, 
                                   CHAR SymBuf[], 
                                   DWORD64 Displacement, 
                                   USHORT StdCallArgs)
{
    // Truncate the displacement to 32 bits since it can never be
    // greater than 32 bit for X86, and we don't want addresses with no
    // symbols to show up with the leading 0xfffffff

    MachineInfo::PrintStackCallSite(Flags, StackFrame, SymBuf,
                                    (DWORD64)(DWORD)Displacement, StdCallArgs);

    if ((Flags & DEBUG_STACK_FUNCTION_INFO) &&
        !StackFrame->FuncTableEntry)
    {
        if (StdCallArgs != 0xffff)
        {
            dprintf(" [Stdcall: %d]", StdCallArgs);
        }
    }
    else if ((Flags & DEBUG_STACK_FUNCTION_INFO) &&
             StackFrame->FuncTableEntry)
    {
        PFPO_DATA FpoData = (PFPO_DATA)StackFrame->FuncTableEntry;
        switch(FpoData->cbFrame)
        {
        case FRAME_FPO:
            if (FpoData->fHasSEH)
            {
                dprintf(" (FPO: [SEH])");
            }
            else
            {
                dprintf(" (FPO:");
                if (FpoData->fUseBP)
                {
                    dprintf(" [EBP 0x%s]",
                            FormatAddr64(SAVE_EBP(StackFrame)));
                }
                dprintf(" [%d,%d,%d])",
                        FpoData->cdwParams,
                        FpoData->cdwLocals,
                        FpoData->cbRegs);
            }
            break;

        case FRAME_NONFPO:
            dprintf(" (FPO: [Non-Fpo])" );
            break;

        case FRAME_TRAP:
            if (!IS_KERNEL_TARGET())
            {
                goto UnknownFpo;
            }
            
            dprintf(" (FPO: [%d,%d] TrapFrame%s @ %s)",
                    FpoData->cdwParams,
                    FpoData->cdwLocals,
                    TRAP_EDITED(StackFrame) ? "" : "-EDITED",
                    FormatAddr64(SAVE_TRAP(StackFrame)));
            break;

        case FRAME_TSS:
            if (!IS_KERNEL_TARGET())
            {
                goto UnknownFpo;
            }
            
            dprintf(" (FPO: TaskGate %lx:0)",
                    (ULONG)TRAP_TSS(StackFrame));
            break;

        default:
        UnknownFpo:
            dprintf(" (UNKNOWN FPO TYPE)");
            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\i386_mach.hpp ===
//----------------------------------------------------------------------------
//
// X86 machine implementation.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#ifndef __I386_MACH_HPP__
#define __I386_MACH_HPP__

//
// NOTE: Be very careful when using machine-specific header files
// such as nt<plat>.h.  The machine implementation class is
// compiled for all platforms so the nt<plat>.h file will be the
// one for the build platform, not necessarily the platform
// of the machine implementation.  ntdbg.h contains many cross-platform
// types and definitions that can be used to avoid problems.
//

//----------------------------------------------------------------------------
//
// X86 instruction support exists on many different processors.
// BaseX86MachineInfo contains implementations of MachineInfo
// methods that apply to all machines supporting X86 instructions.
//
//----------------------------------------------------------------------------

#define X86_MAX_INSTRUCTION_LEN 16
#define X86_INT3_LEN 1
 
class BaseX86MachineInfo : public MachineInfo
{
public:
    // MachineInfo.
    virtual void Assemble(PADDR Addr, PSTR Input);
    virtual BOOL Disassemble(PADDR Addr, PSTR Buffer, BOOL EffAddr);

    virtual BOOL IsBreakpointInstruction(PADDR Addr);
    virtual HRESULT InsertBreakpointInstruction(PUSER_DEBUG_SERVICES Services,
                                                ULONG64 Process,
                                                ULONG64 Offset,
                                                PUCHAR SaveInstr,
                                                PULONG64 ChangeStart,
                                                PULONG ChangeLen);
    virtual HRESULT RemoveBreakpointInstruction(PUSER_DEBUG_SERVICES Services,
                                                ULONG64 Process,
                                                ULONG64 Offset,
                                                PUCHAR SaveInstr,
                                                PULONG64 ChangeStart,
                                                PULONG ChangeLen);
    virtual void AdjustPCPastBreakpointInstruction(PADDR Addr,
                                                   ULONG BreakType);
    
    virtual BOOL IsCallDisasm(PCSTR Disasm);
    virtual BOOL IsReturnDisasm(PCSTR Disasm);
    virtual BOOL IsSystemCallDisasm(PCSTR Disasm);
    virtual BOOL IsDelayInstruction(PADDR Addr);

    virtual void GetEffectiveAddr(PADDR Addr);
    virtual void GetNextOffset(BOOL StepOver,
                               PADDR NextAddr, PULONG NextMachine);

    virtual void IncrementBySmallestInstruction(PADDR Addr);
    virtual void DecrementBySmallestInstruction(PADDR Addr);

    // BaseX86MachineInfo.
protected:
    ULONG GetMmxRegOffset(ULONG Index, ULONG Fpsw)
    {
        // The FP register area where the MMX registers are
        // aliased onto is stored out relative to the stack top.  MMX
        // register assignments are fixed, though, so we need to
        // take into account the current FP stack top to correctly
        // determine which slot corresponds to which MMX
        // register.
        return (Index - (Fpsw >> 11)) & 7;
    }
    
    void DIdoModrm(char **, int, BOOL);
    void OutputSymbol(char **, PUCHAR, int, int);
    BOOL OutputExactSymbol(char **, PUCHAR, int, int);
    ULONG GetSegReg(int SegOpcode);
    int ComputeJccEa(int Opcode, BOOL EaOut);
};

//----------------------------------------------------------------------------
//
// X86MachineInfo is the MachineInfo implementation specific
// to a true X86 processor.
//
//----------------------------------------------------------------------------

extern BOOL g_X86InCode16;
extern BOOL g_X86InVm86;

class X86MachineInfo : public BaseX86MachineInfo
{
public:
    // MachineInfo.
    virtual HRESULT InitializeConstants(void);
    virtual HRESULT InitializeForTarget(void);
    virtual HRESULT InitializeForProcessor(void);
    
    virtual void InitializeContext
        (ULONG64 Pc, PDBGKD_ANY_CONTROL_REPORT ControlReport);
    virtual HRESULT KdGetContextState(ULONG State);
    virtual HRESULT KdSetContext(void);
    virtual HRESULT ConvertContextFrom(PCROSS_PLATFORM_CONTEXT Context,
                                       ULONG FromSver,
                                       ULONG FromSize, PVOID From);
    virtual HRESULT ConvertContextTo(PCROSS_PLATFORM_CONTEXT Context,
                                     ULONG ToSver, ULONG ToSize, PVOID To);
    virtual void InitializeContextFlags(PCROSS_PLATFORM_CONTEXT Context,
                                        ULONG Version);
    virtual HRESULT GetContextFromThreadStack(ULONG64 ThreadBase,
                                              PCROSS_PLATFORM_THREAD Thread,
                                              PCROSS_PLATFORM_CONTEXT Context,
                                              PDEBUG_STACK_FRAME Frame,
                                              PULONG RunningOnProc);
    
    virtual HRESULT GetExdiContext(IUnknown* Exdi, PEXDI_CONTEXT Context);
    virtual HRESULT SetExdiContext(IUnknown* Exdi, PEXDI_CONTEXT Context);
    virtual void ConvertExdiContextFromContext(PCROSS_PLATFORM_CONTEXT Context,
                                               PEXDI_CONTEXT ExdiContext);
    virtual void ConvertExdiContextToContext(PEXDI_CONTEXT ExdiContext,
                                             PCROSS_PLATFORM_CONTEXT Context);
    virtual void ConvertExdiContextToSegDescs(PEXDI_CONTEXT ExdiContext,
                                              ULONG Start, ULONG Count,
                                              PDESCRIPTOR64 Descs);
    virtual void ConvertExdiContextFromSpecial
        (PCROSS_PLATFORM_KSPECIAL_REGISTERS Special,
         PEXDI_CONTEXT ExdiContext);
    virtual void ConvertExdiContextToSpecial
        (PEXDI_CONTEXT ExdiContext,
         PCROSS_PLATFORM_KSPECIAL_REGISTERS Special);
    
    virtual int  GetType(ULONG index);
    virtual BOOL GetVal(ULONG index, REGVAL *val);
    virtual BOOL SetVal(ULONG index, REGVAL *val);

    virtual void GetPC(PADDR Address);
    virtual void SetPC(PADDR Address);
    virtual void GetFP(PADDR Address);
    virtual void GetSP(PADDR Address);
    virtual ULONG64 GetArgReg(void);
    virtual ULONG GetSegRegNum(ULONG SegReg);
    virtual HRESULT GetSegRegDescriptor(ULONG SegReg, PDESCRIPTOR64 Desc);

    virtual void OutputAll(ULONG Mask, ULONG OutMask);

    virtual TRACEMODE GetTraceMode(void);
    virtual void SetTraceMode(TRACEMODE Mode);
    virtual BOOL IsStepStatusSupported(ULONG Status);

    virtual void KdUpdateControlSet
        (PDBGKD_ANY_CONTROL_SET ControlSet);

    virtual void KdSaveProcessorState(void);
    virtual void KdRestoreProcessorState(void);

    virtual ULONG ExecutingMachine(void);

    virtual HRESULT SetPageDirectory(ULONG Idx, ULONG64 PageDir,
                                     PULONG NextIdx);
    virtual HRESULT GetVirtualTranslationPhysicalOffsets
        (ULONG64 Virt, PULONG64 Offsets, ULONG OffsetsSize,
         PULONG Levels, PULONG PfIndex, PULONG64 LastVal);
    virtual HRESULT GetBaseTranslationVirtualOffset(PULONG64 Offset);

    virtual HRESULT NewBreakpoint(DebugClient* Client, 
                                  ULONG Type, 
                                  ULONG Id, 
                                  Breakpoint** RetBp);

    virtual void InsertAllDataBreakpoints(void);
    virtual void RemoveAllDataBreakpoints(void);
    virtual ULONG IsBreakpointOrStepException(PEXCEPTION_RECORD64 Record,
                                              ULONG FirstChance,
                                              PADDR BpAddr,
                                              PADDR RelAddr);
    
    virtual BOOL DisplayTrapFrame(ULONG64 FrameAddress,
                                  PCROSS_PLATFORM_CONTEXT Context);
    virtual void ValidateCxr(PCROSS_PLATFORM_CONTEXT Context);

    HRESULT DumpTSS(void);
    
    virtual void PrintStackFrameAddressesTitle(ULONG Flags);
    virtual void PrintStackFrameAddresses(ULONG Flags, 
                                          PDEBUG_STACK_FRAME StackFrame);
    virtual void PrintStackArgumentsTitle(ULONG Flags);
    virtual void PrintStackArguments(ULONG Flags, 
                                     PDEBUG_STACK_FRAME StackFrame);
    virtual void PrintStackCallSiteTitle(ULONG Flags);
    virtual void PrintStackCallSite(ULONG Flags, 
                                    PDEBUG_STACK_FRAME StackFrame, 
                                    CHAR SymBuf[], DWORD64 Displacement,
                                    USHORT StdCallArgs);

    virtual void OutputFunctionEntry(PVOID RawEntry);

    virtual HRESULT ReadKernelProcessorId
        (ULONG Processor, PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id);

    // X86MachineInfo.
protected:
    X86_KSPECIAL_REGISTERS m_SpecialRegContext, m_SavedSpecialRegContext;
    BOOL m_SupportsBranchTrace;

    void KdGetSpecialRegistersFromContext(void);
    void KdSetSpecialRegistersInContext(void);

    ULONG GetIntReg(ULONG regnum);
    PULONG64 GetMmxRegSlot(ULONG regnum);
    void GetMmxReg(ULONG regnum, REGVAL *val);
    void GetFloatReg(ULONG regnum, REGVAL *val);
    
    ULONG64 Selector2Address(USHORT TaskRegister);
};

extern X86MachineInfo g_X86Machine;

//
// X86 register names that are reused in other places.
//

extern char g_Gs[];
extern char g_Fs[];
extern char g_Es[];
extern char g_Ds[];
extern char g_Edi[];
extern char g_Esi[];
extern char g_Ebx[];
extern char g_Edx[];
extern char g_Ecx[];
extern char g_Eax[];
extern char g_Ebp[];
extern char g_Eip[];
extern char g_Cs[];
extern char g_Efl[];
extern char g_Esp[];
extern char g_Ss[];
extern char g_Dr0[];
extern char g_Dr1[];
extern char g_Dr2[];
extern char g_Dr3[];
extern char g_Dr6[];
extern char g_Dr7[];
extern char g_Cr0[];
extern char g_Cr2[];
extern char g_Cr3[];
extern char g_Cr4[];
extern char g_Gdtr[];
extern char g_Gdtl[];
extern char g_Idtr[];
extern char g_Idtl[];
extern char g_Tr[];
extern char g_Ldtr[];
extern char g_Di[];
extern char g_Si[];
extern char g_Bx[];
extern char g_Dx[];
extern char g_Cx[];
extern char g_Ax[];
extern char g_Bp[];
extern char g_Ip[];
extern char g_Fl[];
extern char g_Sp[];
extern char g_Bl[];
extern char g_Dl[];
extern char g_Cl[];
extern char g_Al[];
extern char g_Bh[];
extern char g_Dh[];
extern char g_Ch[];
extern char g_Ah[];
extern char g_Iopl[];
extern char g_Of[];
extern char g_Df[];
extern char g_If[];
extern char g_Tf[];
extern char g_Sf[];
extern char g_Zf[];
extern char g_Af[];
extern char g_Pf[];
extern char g_Cf[];
extern char g_Vip[];
extern char g_Vif[];

extern char g_Fpcw[];
extern char g_Fpsw[];
extern char g_Fptw[];
extern char g_St0[];
extern char g_St1[];
extern char g_St2[];
extern char g_St3[];
extern char g_St4[];
extern char g_St5[];
extern char g_St6[];
extern char g_St7[];

extern char g_Mm0[];
extern char g_Mm1[];
extern char g_Mm2[];
extern char g_Mm3[];
extern char g_Mm4[];
extern char g_Mm5[];
extern char g_Mm6[];
extern char g_Mm7[];

extern char g_Mxcsr[];
extern char g_Xmm0[];
extern char g_Xmm1[];
extern char g_Xmm2[];
extern char g_Xmm3[];
extern char g_Xmm4[];
extern char g_Xmm5[];
extern char g_Xmm6[];
extern char g_Xmm7[];

//----------------------------------------------------------------------------
//
// This class handles the case of X86 instructions executing natively
// on an IA64 processor.  It operates just as the X86 machine does
// except that:
//   Context state is retrieved and set through the
//   IA64 register state as defined in the X86-on-IA64 support.
//
// Implementation is in the IA64 code.
//
//----------------------------------------------------------------------------

class X86OnIa64MachineInfo : public X86MachineInfo
{
public:
    virtual HRESULT InitializeForProcessor(void);

    virtual HRESULT UdGetContextState(ULONG State);
    virtual HRESULT UdSetContext(void);
    virtual HRESULT KdGetContextState(ULONG State);
    virtual HRESULT KdSetContext(void);

    virtual HRESULT GetSegRegDescriptor(ULONG SegReg, PDESCRIPTOR64 Desc);

    virtual HRESULT NewBreakpoint(DebugClient* Client, 
                                  ULONG Type, 
                                  ULONG Id, 
                                  Breakpoint** RetBp);

    virtual void InsertAllDataBreakpoints(void);
    virtual void RemoveAllDataBreakpoints(void);

    virtual ULONG IsBreakpointOrStepException(PEXCEPTION_RECORD64 Record,
                                              ULONG FirstChance,
                                              PADDR BpAddr,
                                              PADDR RelAddr);
    
private:
    void X86ContextToIa64(PX86_NT5_CONTEXT X86Context,
                          PIA64_CONTEXT Ia64Context);
    void Ia64ContextToX86(PIA64_CONTEXT Ia64Context,
                          PX86_NT5_CONTEXT X86Context);
};

extern X86OnIa64MachineInfo g_X86OnIa64Machine;

#endif // #ifndef __I386_MACH_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\ia64_dis.h ===
#ifndef _IA64_DIS_
#define _IA64_DIS_

#include <kxia64.h>

#define ASCII_BUF_LENGTH 1536

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\i386_reg.cpp ===
//----------------------------------------------------------------------------
//
// Register portions of X86 machine implementation.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

// XXX drewb - Temporary log to try and catch some
// SET_OF_INVALID_CONTEXT bugchecks occurring randomly on x86.
ULONG g_EspLog[64];
PULONG g_EspLogCur = g_EspLog;

// See Get/SetRegVal comments in machine.hpp.
#define RegValError Do_not_use_GetSetRegVal_in_machine_implementations
#define GetRegVal(index, val)   RegValError
#define GetRegVal32(index)      RegValError
#define GetRegVal64(index)      RegValError
#define SetRegVal(index, val)   RegValError
#define SetRegVal32(index, val) RegValError
#define SetRegVal64(index, val) RegValError

#define X86_RPL_MASK     3

BOOL g_X86InCode16;
BOOL g_X86InVm86;

#define REGALL_SEGREG   REGALL_EXTRA0
#define REGALL_MMXREG   REGALL_EXTRA1
#define REGALL_DREG     REGALL_EXTRA2

REGALLDESC g_X86AllExtraDesc[] =
{
    REGALL_SEGREG, "Segment registers",
    REGALL_MMXREG, "MMX registers",
    REGALL_DREG,   "Debug registers and, in kernel, CR4",
    REGALL_XMMREG, "SSE XMM registers",
    0,             NULL,
};

#define REGALL_CREG     REGALL_EXTRA4
#define REGALL_DESC     REGALL_EXTRA5
REGALLDESC g_X86KernelExtraDesc[] =
{
    REGALL_CREG,   "CR0, CR2 and CR3",
    REGALL_DESC,   "Descriptor and task state",
    0,             NULL,
};

char g_Gs[]    = "gs";
char g_Fs[]    = "fs";
char g_Es[]    = "es";
char g_Ds[]    = "ds";
char g_Edi[]   = "edi";
char g_Esi[]   = "esi";
char g_Ebx[]   = "ebx";
char g_Edx[]   = "edx";
char g_Ecx[]   = "ecx";
char g_Eax[]   = "eax";
char g_Ebp[]   = "ebp";
char g_Eip[]   = "eip";
char g_Cs[]    = "cs";
char g_Efl[]   = "efl";
char g_Esp[]   = "esp";
char g_Ss[]    = "ss";
char g_Dr0[]   = "dr0";
char g_Dr1[]   = "dr1";
char g_Dr2[]   = "dr2";
char g_Dr3[]   = "dr3";
char g_Dr6[]   = "dr6";
char g_Dr7[]   = "dr7";
char g_Cr0[]   = "cr0";
char g_Cr2[]   = "cr2";
char g_Cr3[]   = "cr3";
char g_Cr4[]   = "cr4";
char g_Gdtr[]  = "gdtr";
char g_Gdtl[]  = "gdtl";
char g_Idtr[]  = "idtr";
char g_Idtl[]  = "idtl";
char g_Tr[]    = "tr";
char g_Ldtr[]  = "ldtr";
char g_Di[]    = "di";
char g_Si[]    = "si";
char g_Bx[]    = "bx";
char g_Dx[]    = "dx";
char g_Cx[]    = "cx";
char g_Ax[]    = "ax";
char g_Bp[]    = "bp";
char g_Ip[]    = "ip";
char g_Fl[]    = "fl";
char g_Sp[]    = "sp";
char g_Bl[]    = "bl";
char g_Dl[]    = "dl";
char g_Cl[]    = "cl";
char g_Al[]    = "al";
char g_Bh[]    = "bh";
char g_Dh[]    = "dh";
char g_Ch[]    = "ch";
char g_Ah[]    = "ah";
char g_Iopl[] = "iopl";
char g_Of[]   = "of";
char g_Df[]   = "df";
char g_If[]   = "if";
char g_Tf[]   = "tf";
char g_Sf[]   = "sf";
char g_Zf[]   = "zf";
char g_Af[]   = "af";
char g_Pf[]   = "pf";
char g_Cf[]   = "cf";
char g_Vip[]  = "vip";
char g_Vif[]  = "vif";

char g_Fpcw[]  = "fpcw";
char g_Fpsw[]  = "fpsw";
char g_Fptw[]  = "fptw";
char g_St0[]   = "st0";
char g_St1[]   = "st1";
char g_St2[]   = "st2";
char g_St3[]   = "st3";
char g_St4[]   = "st4";
char g_St5[]   = "st5";
char g_St6[]   = "st6";
char g_St7[]   = "st7";

char g_Mm0[]   = "mm0";
char g_Mm1[]   = "mm1";
char g_Mm2[]   = "mm2";
char g_Mm3[]   = "mm3";
char g_Mm4[]   = "mm4";
char g_Mm5[]   = "mm5";
char g_Mm6[]   = "mm6";
char g_Mm7[]   = "mm7";

char g_Mxcsr[] = "mxcsr";
char g_Xmm0[]  = "xmm0";
char g_Xmm1[]  = "xmm1";
char g_Xmm2[]  = "xmm2";
char g_Xmm3[]  = "xmm3";
char g_Xmm4[]  = "xmm4";
char g_Xmm5[]  = "xmm5";
char g_Xmm6[]  = "xmm6";
char g_Xmm7[]  = "xmm7";

REGDEF g_X86Defs[] =
{
    { g_Gs,    X86_GS   },
    { g_Fs,    X86_FS   },
    { g_Es,    X86_ES   },
    { g_Ds,    X86_DS   },
    { g_Edi,   X86_EDI  },
    { g_Esi,   X86_ESI  },
    { g_Ebx,   X86_EBX  },
    { g_Edx,   X86_EDX  },
    { g_Ecx,   X86_ECX  },
    { g_Eax,   X86_EAX  },
    { g_Ebp,   X86_EBP  },
    { g_Eip,   X86_EIP  },
    { g_Cs,    X86_CS   },
    { g_Efl,   X86_EFL  },
    { g_Esp,   X86_ESP  },
    { g_Ss,    X86_SS   },
    { g_Dr0,   X86_DR0  },
    { g_Dr1,   X86_DR1  },
    { g_Dr2,   X86_DR2  },
    { g_Dr3,   X86_DR3  },
    { g_Dr6,   X86_DR6  },
    { g_Dr7,   X86_DR7  },
    { g_Di,    X86_DI   },
    { g_Si,    X86_SI   },
    { g_Bx,    X86_BX   },
    { g_Dx,    X86_DX   },
    { g_Cx,    X86_CX   },
    { g_Ax,    X86_AX   },
    { g_Bp,    X86_BP   },
    { g_Ip,    X86_IP   },
    { g_Fl,    X86_FL   },
    { g_Sp,    X86_SP   },
    { g_Bl,    X86_BL   },
    { g_Dl,    X86_DL   },
    { g_Cl,    X86_CL   },
    { g_Al,    X86_AL   },
    { g_Bh,    X86_BH   },
    { g_Dh,    X86_DH   },
    { g_Ch,    X86_CH   },
    { g_Ah,    X86_AH   },
    { g_Fpcw,  X86_FPCW },
    { g_Fpsw,  X86_FPSW },
    { g_Fptw,  X86_FPTW },
    { g_St0,   X86_ST0  },
    { g_St1,   X86_ST1  },
    { g_St2,   X86_ST2  },
    { g_St3,   X86_ST3  },
    { g_St4,   X86_ST4  },
    { g_St5,   X86_ST5  },
    { g_St6,   X86_ST6  },
    { g_St7,   X86_ST7  },
    { g_Mm0,   X86_MM0  },
    { g_Mm1,   X86_MM1  },
    { g_Mm2,   X86_MM2  },
    { g_Mm3,   X86_MM3  },
    { g_Mm4,   X86_MM4  },
    { g_Mm5,   X86_MM5  },
    { g_Mm6,   X86_MM6  },
    { g_Mm7,   X86_MM7  },
    { g_Mxcsr, X86_MXCSR},
    { g_Xmm0,  X86_XMM0 },
    { g_Xmm1,  X86_XMM1 },
    { g_Xmm2,  X86_XMM2 },
    { g_Xmm3,  X86_XMM3 },
    { g_Xmm4,  X86_XMM4 },
    { g_Xmm5,  X86_XMM5 },
    { g_Xmm6,  X86_XMM6 },
    { g_Xmm7,  X86_XMM7 },
    { g_Iopl,  X86_IOPL },
    { g_Of,    X86_OF   },
    { g_Df,    X86_DF   },
    { g_If,    X86_IF   },
    { g_Tf,    X86_TF   },
    { g_Sf,    X86_SF   },
    { g_Zf,    X86_ZF   },
    { g_Af,    X86_AF   },
    { g_Pf,    X86_PF   },
    { g_Cf,    X86_CF   },
    { g_Vip,   X86_VIP  },
    { g_Vif,   X86_VIF  },
    { NULL,    REG_ERROR },
};

REGDEF g_X86KernelReg[] =
{
    { g_Cr0,   X86_CR0  },
    { g_Cr2,   X86_CR2  },
    { g_Cr3,   X86_CR3  },
    { g_Cr4,   X86_CR4  },
    { g_Gdtr,  X86_GDTR },
    { g_Gdtl,  X86_GDTL },
    { g_Idtr,  X86_IDTR },
    { g_Idtl,  X86_IDTL },
    { g_Tr,    X86_TR   },
    { g_Ldtr,  X86_LDTR },
    { NULL,    REG_ERROR },
};

REGSUBDEF g_X86SubDefs[] =
{
    { X86_DI,    X86_EDI, 0, 0xffff }, //  DI register
    { X86_SI,    X86_ESI, 0, 0xffff }, //  SI register
    { X86_BX,    X86_EBX, 0, 0xffff }, //  BX register
    { X86_DX,    X86_EDX, 0, 0xffff }, //  DX register
    { X86_CX,    X86_ECX, 0, 0xffff }, //  CX register
    { X86_AX,    X86_EAX, 0, 0xffff }, //  AX register
    { X86_BP,    X86_EBP, 0, 0xffff }, //  BP register
    { X86_IP,    X86_EIP, 0, 0xffff }, //  IP register
    { X86_FL,    X86_EFL, 0, 0xffff }, //  FL register
    { X86_SP,    X86_ESP, 0, 0xffff }, //  SP register
    { X86_BL,    X86_EBX, 0,   0xff }, //  BL register
    { X86_DL,    X86_EDX, 0,   0xff }, //  DL register
    { X86_CL,    X86_ECX, 0,   0xff }, //  CL register
    { X86_AL,    X86_EAX, 0,   0xff }, //  AL register
    { X86_BH,    X86_EBX, 8,   0xff }, //  BH register
    { X86_DH,    X86_EDX, 8,   0xff }, //  DH register
    { X86_CH,    X86_ECX, 8,   0xff }, //  CH register
    { X86_AH,    X86_EAX, 8,   0xff }, //  AH register
    { X86_IOPL,  X86_EFL,12,      3 }, //  IOPL level value
    { X86_OF,    X86_EFL,11,      1 }, //  OF (overflow flag)
    { X86_DF,    X86_EFL,10,      1 }, //  DF (direction flag)
    { X86_IF,    X86_EFL, 9,      1 }, //  IF (interrupt enable flag)
    { X86_TF,    X86_EFL, 8,      1 }, //  TF (trace flag)
    { X86_SF,    X86_EFL, 7,      1 }, //  SF (sign flag)
    { X86_ZF,    X86_EFL, 6,      1 }, //  ZF (zero flag)
    { X86_AF,    X86_EFL, 4,      1 }, //  AF (aux carry flag)
    { X86_PF,    X86_EFL, 2,      1 }, //  PF (parity flag)
    { X86_CF,    X86_EFL, 0,      1 }, //  CF (carry flag)
    { X86_VIP,   X86_EFL,20,      1 }, //  VIP (virtual interrupt pending)
    { X86_VIF,   X86_EFL,19,      1 }, //  VIF (virtual interrupt flag)
    { REG_ERROR, REG_ERROR, 0, 0    }
};

RegisterGroup g_X86BaseGroup =
{
    NULL, 0, g_X86Defs, g_X86SubDefs, g_X86AllExtraDesc
};
RegisterGroup g_X86KernelGroup =
{
    NULL, 0, g_X86KernelReg, NULL, g_X86KernelExtraDesc
};

// First ExecTypes entry must be the actual processor type.
ULONG g_X86ExecTypes[] =
{
    IMAGE_FILE_MACHINE_I386
};

X86MachineInfo g_X86Machine;

HRESULT
X86MachineInfo::InitializeConstants(void)
{
    m_FullName = "x86 compatible";
    m_AbbrevName = "x86";
    m_PageSize = X86_PAGE_SIZE;
    m_PageShift = X86_PAGE_SHIFT;
    m_NumExecTypes = 1;
    m_ExecTypes = g_X86ExecTypes;
    m_Ptr64 = FALSE;
    
    m_AllMask = REGALL_INT32 | REGALL_SEGREG,
    
    m_MaxDataBreakpoints = 4;
    m_SymPrefix = NULL;

    m_SupportsBranchTrace = FALSE;
    
    return MachineInfo::InitializeConstants();
}

HRESULT
X86MachineInfo::InitializeForTarget(void)
{
    m_Groups = &g_X86BaseGroup;
    g_X86BaseGroup.Next = NULL;
    if (IS_KERNEL_TARGET())
    {
        g_X86BaseGroup.Next = &g_X86KernelGroup;
    }
    
    m_OffsetPrcbProcessorState =
        FIELD_OFFSET(X86_PARTIAL_KPRCB, ProcessorState);
    m_OffsetPrcbNumber =
        FIELD_OFFSET(X86_PARTIAL_KPRCB, Number);
    m_TriagePrcbOffset = EXTEND64(X86_TRIAGE_PRCB_ADDRESS);
    if (g_SystemVersion > NT_SVER_NT4)
    {
        m_SizePrcb = X86_NT5_KPRCB_SIZE;
    }
    else
    {
        m_SizePrcb = X86_NT4_KPRCB_SIZE;
    }
    m_OffsetKThreadApcProcess =
        FIELD_OFFSET(CROSS_PLATFORM_THREAD, X86Thread.ApcState.Process);
    m_OffsetKThreadTeb =
        FIELD_OFFSET(CROSS_PLATFORM_THREAD, X86Thread.Teb);
    m_OffsetKThreadInitialStack =
        FIELD_OFFSET(CROSS_PLATFORM_THREAD, X86Thread.InitialStack);
    m_OffsetEprocessPeb = g_SystemVersion > NT_SVER_NT4 ?
        X86_PEB_IN_EPROCESS : X86_NT4_PEB_IN_EPROCESS;
    m_OffsetEprocessDirectoryTableBase =
        X86_DIRECTORY_TABLE_BASE_IN_EPROCESS;

    if (g_TargetBuildNumber > 2407)
    {
        m_OffsetKThreadNextProcessor = X86_NT51_KTHREAD_NEXTPROCESSOR_OFFSET;
    }
    else if (g_TargetBuildNumber > 2230)
    {
        m_OffsetKThreadNextProcessor = X86_2230_KTHREAD_NEXTPROCESSOR_OFFSET;
    }
    else 
    {
        m_OffsetKThreadNextProcessor = X86_KTHREAD_NEXTPROCESSOR_OFFSET;
    }

    if (g_SystemVersion > NT_SVER_NT4)
    {
        m_SizeTargetContext = sizeof(X86_NT5_CONTEXT);
        m_OffsetTargetContextFlags =
            FIELD_OFFSET(X86_NT5_CONTEXT, ContextFlags);
    }
    else
    {
        m_SizeTargetContext = sizeof(X86_CONTEXT);
        m_OffsetTargetContextFlags =
            FIELD_OFFSET(X86_CONTEXT, ContextFlags);
    }
    m_SizeCanonicalContext = sizeof(X86_NT5_CONTEXT);
    m_SverCanonicalContext = NT_SVER_W2K;
    m_SizeControlReport = sizeof(X86_DBGKD_CONTROL_REPORT);

    if (g_TargetBuildNumber > 2407)
    {
        m_SizeEThread = X86_NT51_ETHREAD_SIZE;
    }
    else
    {
        m_SizeEThread = X86_ETHREAD_SIZE;
    }

    m_SizeEProcess = g_SystemVersion > NT_SVER_W2K ?
        X86_NT51_EPROCESS_SIZE : X86_NT5_EPROCESS_SIZE;
    m_OffsetSpecialRegisters = m_SizeTargetContext;
    m_SizeKspecialRegisters = sizeof(X86_KSPECIAL_REGISTERS);
    m_SizePartialKThread = sizeof(X86_THREAD);
    m_SharedUserDataOffset = IS_KERNEL_TARGET() ?
        EXTEND64(X86_KI_USER_SHARED_DATA) : MM_SHARED_USER_DATA_VA;

    return MachineInfo::InitializeForTarget();
}

HRESULT
X86MachineInfo::InitializeForProcessor(void)
{
    if (!strcmp(g_InitProcessorId.X86.VendorString, "GenuineIntel"))
    {
        // Branch trace support was added for the Pentium Pro.
        m_SupportsBranchTrace = g_InitProcessorId.X86.Family >= 6;
    }
    
    return MachineInfo::InitializeForProcessor();
}

void
X86MachineInfo::
InitializeContext(ULONG64 Pc,
                  PDBGKD_ANY_CONTROL_REPORT ControlReport)
{
    ULONG Pc32 = (ULONG)Pc;

    m_Context.X86Nt5Context.Eip = Pc32;
    m_ContextState = Pc32 ? MCTX_PC : MCTX_NONE;

    if (ControlReport != NULL)
    {
        BpOut("InitializeContext(%d) DR6 %X DR7 %X\n",
              g_RegContextProcessor, ControlReport->X86ControlReport.Dr6,
              ControlReport->X86ControlReport.Dr7);
        
        m_Context.X86Nt5Context.Dr6 = ControlReport->X86ControlReport.Dr6;
        m_Context.X86Nt5Context.Dr7 = ControlReport->X86ControlReport.Dr7;
        m_ContextState = MCTX_DR67_REPORT;

        if (ControlReport->X86ControlReport.ReportFlags &
            X86_REPORT_INCLUDES_SEGS)
        {
            //
            // This is for backwards compatibility - older kernels
            // won't pass these registers in the report record.
            //

            m_Context.X86Nt5Context.SegCs =
                ControlReport->X86ControlReport.SegCs;
            m_Context.X86Nt5Context.SegDs =
                ControlReport->X86ControlReport.SegDs;
            m_Context.X86Nt5Context.SegEs =
                ControlReport->X86ControlReport.SegEs;
            m_Context.X86Nt5Context.SegFs =
                ControlReport->X86ControlReport.SegFs;
            m_Context.X86Nt5Context.EFlags =
                ControlReport->X86ControlReport.EFlags;
            m_ContextState = MCTX_REPORT;
        }
    }

    if (!IS_CONTEXT_POSSIBLE())
    {
        g_X86InVm86 = FALSE;
        g_X86InCode16 = FALSE;
    }
    else
    {
        // Check whether we're currently in V86 mode or 16-bit code.
        g_X86InVm86 = X86_IS_VM86(GetIntReg(X86_EFL));
        if (IS_KERNEL_TARGET() && !g_X86InVm86)
        {
            if (ControlReport == NULL ||
                (ControlReport->X86ControlReport.ReportFlags &
                 X86_REPORT_STANDARD_CS) == 0)
            {
                DESCRIPTOR64 Desc;
                
                if (GetSegRegDescriptor(SEGREG_CODE, &Desc) != S_OK)
                {
                    WarnOut("CS descriptor lookup failed\n");
                    g_X86InCode16 = FALSE;
                }
                else
                {
                    g_X86InCode16 = (Desc.Flags & X86_DESC_DEFAULT_BIG) == 0;
                }
            }
            else
            {
                g_X86InCode16 = FALSE;

                // We're in a standard code segment so cache
                // a default descriptor for CS to avoid further
                // CS lookups.
                EmulateNtSelDescriptor(this, m_Context.X86Nt5Context.SegCs,
                                       &m_SegRegDesc[SEGREG_CODE]);
            }
        }
    }

    // Add instructions to cache only if we're in 32-bit flat mode.
    if (Pc32 && ControlReport != NULL &&
        !g_X86InVm86 && !g_X86InCode16)
    {
        CacheReportInstructions
            (Pc, ControlReport->X86ControlReport.InstructionCount,
             ControlReport->X86ControlReport.InstructionStream);
    }
}

HRESULT
X86MachineInfo::KdGetContextState(ULONG State)
{
    HRESULT Status;
        
    if (State >= MCTX_CONTEXT && m_ContextState < MCTX_CONTEXT)
    {
        Status = g_Target->GetContext(g_RegContextThread->Handle, &m_Context);
        if (Status != S_OK)
        {
            return Status;
        }

        // XXX drewb - Temporary log to try and catch some
        // SET_OF_INVALID_CONTEXT bugchecks occurring randomly on x86.
        *g_EspLogCur++ = g_RegContextProcessor | 0x80000000;
        *g_EspLogCur++ = m_Context.X86Nt5Context.Esp;
        if (g_EspLogCur >= g_EspLog + 64)
        {
            g_EspLogCur = g_EspLog;
        }
            
        m_ContextState = MCTX_CONTEXT;
    }

    if (State >= MCTX_FULL && m_ContextState < MCTX_FULL)
    {
        Status = g_Target->GetTargetSpecialRegisters
            (g_RegContextThread->Handle, (PCROSS_PLATFORM_KSPECIAL_REGISTERS)
             &m_SpecialRegContext);
        if (Status != S_OK)
        {
            return Status;
        }
        
        Status = g_Target->GetTargetSegRegDescriptors
            (g_RegContextThread->Handle, 0, SEGREG_COUNT, m_SegRegDesc);
        if (Status != S_OK)
        {
            return Status;
        }

        m_ContextState = MCTX_FULL;
        KdSetSpecialRegistersInContext();

        BpOut("GetContextState(%d) DR6 %X DR7 %X DR0 %X\n",
              g_RegContextProcessor, m_SpecialRegContext.KernelDr6,
              m_SpecialRegContext.KernelDr7, m_SpecialRegContext.KernelDr0);
    }

    return S_OK;
}

HRESULT
X86MachineInfo::KdSetContext(void)
{
    HRESULT Status;
    
    // XXX drewb - Temporary log to try and catch some
    // SET_OF_INVALID_CONTEXT bugchecks occurring randomly on x86.
    *g_EspLogCur++ = g_RegContextProcessor | 0xC0000000;
    *g_EspLogCur++ = m_Context.X86Nt5Context.Esp;
    if (g_EspLogCur >= g_EspLog + 64)
    {
        g_EspLogCur = g_EspLog;
    }
            
    Status = g_Target->SetContext(g_RegContextThread->Handle, &m_Context);
    if (Status != S_OK)
    {
        return Status;
    }

    KdGetSpecialRegistersFromContext();
    Status = g_Target->SetTargetSpecialRegisters
        (g_RegContextThread->Handle, (PCROSS_PLATFORM_KSPECIAL_REGISTERS)
         &m_SpecialRegContext);
    if (Status != S_OK)
    {
        return Status;
    }
    
    BpOut("SetContext(%d) DR6 %X DR7 %X DR0 %X\n",
          g_RegContextProcessor, m_SpecialRegContext.KernelDr6,
          m_SpecialRegContext.KernelDr7, m_SpecialRegContext.KernelDr0);
    
    return S_OK;
}

HRESULT
X86MachineInfo::ConvertContextFrom(PCROSS_PLATFORM_CONTEXT Context,
                                   ULONG FromSver, ULONG FromSize, PVOID From)
{
    if (FromSver <= NT_SVER_NT4)
    {
        if (FromSize < sizeof(X86_CONTEXT))
        {
            return E_INVALIDARG;
        }

        memcpy(Context, From, sizeof(X86_CONTEXT));
        ZeroMemory(Context->X86Nt5Context.ExtendedRegisters,
                   sizeof(Context->X86Nt5Context.ExtendedRegisters));
    }
    else if (FromSize >= sizeof(X86_NT5_CONTEXT))
    {
        memcpy(Context, From, sizeof(X86_NT5_CONTEXT));
    }
    else
    {
        return E_INVALIDARG;
    }

    return S_OK;
}

HRESULT
X86MachineInfo::ConvertContextTo(PCROSS_PLATFORM_CONTEXT Context,
                                 ULONG ToSver, ULONG ToSize, PVOID To)
{
    if (ToSver <= NT_SVER_NT4)
    {
        if (ToSize < sizeof(X86_CONTEXT))
        {
            return E_INVALIDARG;
        }

        memcpy(To, Context, sizeof(X86_CONTEXT));
    }
    else if (ToSize >= sizeof(X86_NT5_CONTEXT))
    {
        memcpy(To, Context, sizeof(X86_NT5_CONTEXT));
    }
    else
    {
        return E_INVALIDARG;
    }

    return S_OK;
}

void
X86MachineInfo::InitializeContextFlags(PCROSS_PLATFORM_CONTEXT Context,
                                       ULONG Version)
{
    ULONG ContextFlags;
    
    ContextFlags = VDMCONTEXT_CONTROL | VDMCONTEXT_INTEGER |
        VDMCONTEXT_SEGMENTS | VDMCONTEXT_FLOATING_POINT;
    if (IS_USER_TARGET())
    {
        ContextFlags |= VDMCONTEXT_DEBUG_REGISTERS;
    }
    
    if (Version <= NT_SVER_NT4)
    {
        Context->X86Context.ContextFlags = ContextFlags;
    }
    else
    {
        Context->X86Nt5Context.ContextFlags = ContextFlags |
            VDMCONTEXT_EXTENDED_REGISTERS;
    }
}

HRESULT
X86MachineInfo::GetContextFromThreadStack(ULONG64 ThreadBase,
                                          PCROSS_PLATFORM_THREAD Thread,
                                          PCROSS_PLATFORM_CONTEXT Context,
                                          PDEBUG_STACK_FRAME Frame,
                                          PULONG RunningOnProc)
{
    HRESULT Status;
    UCHAR Proc;

    //
    // Check to see if the thread is currently running.
    //
    
    if (Thread->X86Thread.State == 2) 
    {
        if ((Status = g_Target->ReadAllVirtual
             (ThreadBase + m_OffsetKThreadNextProcessor, 
              &Proc, sizeof(Proc))) != S_OK)
        {
            return Status;
        }

        *RunningOnProc = Proc;
        return S_FALSE;
    }

    //
    // The thread isn't running so read its stored context information.
    //
    
    X86_KSWITCHFRAME SwitchFrame;

    if ((Status = g_Target->ReadAllVirtual(Thread->X86Thread.KernelStack,
                                           &SwitchFrame,
                                           sizeof(SwitchFrame))) != S_OK)
    {
        return Status;
    }
    
    Frame->InstructionOffset = EXTEND64(SwitchFrame.RetAddr);
    Frame->StackOffset =
        Thread->X86Thread.KernelStack + sizeof(SwitchFrame);

    if ((Status = g_Target->ReadPointer(this, Frame->StackOffset, 
                                        &Frame->FrameOffset)) != S_OK)
    {
        return Status;
    }

    Context->X86Context.Ebp = (ULONG)Frame->FrameOffset;
    Context->X86Context.Esp = (ULONG)Frame->StackOffset;
    // Fill the segments in from current information
    // instead of just leaving them blank.
    Context->X86Context.SegSs = GetIntReg(X86_SS);
    Context->X86Context.SegCs = GetIntReg(X86_CS);
    Context->X86Context.Eip = (ULONG)Frame->InstructionOffset;

    return S_OK;
}

HRESULT
X86MachineInfo::GetExdiContext(IUnknown* Exdi, PEXDI_CONTEXT Context)
{
    // Always ask for everything.
    Context->X86Context.RegGroupSelection.fSegmentRegs = TRUE;
    Context->X86Context.RegGroupSelection.fControlRegs = TRUE;
    Context->X86Context.RegGroupSelection.fIntegerRegs = TRUE;
    Context->X86Context.RegGroupSelection.fFloatingPointRegs = TRUE;
    Context->X86Context.RegGroupSelection.fDebugRegs = TRUE;
    return ((IeXdiX86Context*)Exdi)->GetContext(&Context->X86Context);
}

HRESULT
X86MachineInfo::SetExdiContext(IUnknown* Exdi, PEXDI_CONTEXT Context)
{
    // Don't change the existing group selections on the assumption
    // that there was a full get prior to any modifications so
    // all groups are valid.
    return ((IeXdiX86Context*)Exdi)->SetContext(Context->X86Context);
}

void
X86MachineInfo::ConvertExdiContextFromContext(PCROSS_PLATFORM_CONTEXT Context,
                                              PEXDI_CONTEXT ExdiContext)
{
    if (Context->X86Nt5Context.ContextFlags & VDMCONTEXT_SEGMENTS)
    {
        ExdiContext->X86Context.SegGs = (USHORT)Context->X86Nt5Context.SegGs;
        ExdiContext->X86Context.SegFs = (USHORT)Context->X86Nt5Context.SegFs;
        ExdiContext->X86Context.SegEs = (USHORT)Context->X86Nt5Context.SegEs;
        ExdiContext->X86Context.SegDs = (USHORT)Context->X86Nt5Context.SegDs;
    }

    if (Context->X86Nt5Context.ContextFlags & VDMCONTEXT_CONTROL)
    {
        ExdiContext->X86Context.Ebp = Context->X86Nt5Context.Ebp;
        ExdiContext->X86Context.Eip = Context->X86Nt5Context.Eip;
        ExdiContext->X86Context.SegCs = (USHORT)Context->X86Nt5Context.SegCs;
        ExdiContext->X86Context.EFlags = Context->X86Nt5Context.EFlags;
        ExdiContext->X86Context.Esp = Context->X86Nt5Context.Esp;
        ExdiContext->X86Context.SegSs = (USHORT)Context->X86Nt5Context.SegSs;
    }
    
    if (Context->X86Nt5Context.ContextFlags & VDMCONTEXT_INTEGER)
    {
        ExdiContext->X86Context.Eax = Context->X86Nt5Context.Eax;
        ExdiContext->X86Context.Ebx = Context->X86Nt5Context.Ebx;
        ExdiContext->X86Context.Ecx = Context->X86Nt5Context.Ecx;
        ExdiContext->X86Context.Edx = Context->X86Nt5Context.Edx;
        ExdiContext->X86Context.Esi = Context->X86Nt5Context.Esi;
        ExdiContext->X86Context.Edi = Context->X86Nt5Context.Edi;
    }

    if (Context->X86Nt5Context.ContextFlags & VDMCONTEXT_FLOATING_POINT)
    {
        C_ASSERT(sizeof(X86_FLOATING_SAVE_AREA) ==
                 FIELD_OFFSET(CONTEXT_X86, Dr0) -
                 FIELD_OFFSET(CONTEXT_X86, ControlWord));
        memcpy(&ExdiContext->X86Context.ControlWord,
               &Context->X86Nt5Context.FloatSave,
               sizeof(X86_FLOATING_SAVE_AREA));
    }
        
    if (Context->X86Nt5Context.ContextFlags & VDMCONTEXT_DEBUG_REGISTERS)
    {
        ExdiContext->X86Context.Dr0 = Context->X86Nt5Context.Dr0;
        ExdiContext->X86Context.Dr1 = Context->X86Nt5Context.Dr1;
        ExdiContext->X86Context.Dr2 = Context->X86Nt5Context.Dr2;
        ExdiContext->X86Context.Dr3 = Context->X86Nt5Context.Dr3;
        ExdiContext->X86Context.Dr6 = Context->X86Nt5Context.Dr6;
        ExdiContext->X86Context.Dr7 = Context->X86Nt5Context.Dr7;
    }
}

void
X86MachineInfo::ConvertExdiContextToContext(PEXDI_CONTEXT ExdiContext,
                                            PCROSS_PLATFORM_CONTEXT Context)
{
    Context->X86Nt5Context.SegCs = ExdiContext->X86Context.SegCs;
    Context->X86Nt5Context.SegSs = ExdiContext->X86Context.SegSs;
    Context->X86Nt5Context.SegGs = ExdiContext->X86Context.SegGs;
    Context->X86Nt5Context.SegFs = ExdiContext->X86Context.SegFs;
    Context->X86Nt5Context.SegEs = ExdiContext->X86Context.SegEs;
    Context->X86Nt5Context.SegDs = ExdiContext->X86Context.SegDs;

    Context->X86Nt5Context.EFlags = ExdiContext->X86Context.EFlags;
    Context->X86Nt5Context.Ebp = ExdiContext->X86Context.Ebp;
    Context->X86Nt5Context.Eip = ExdiContext->X86Context.Eip;
    Context->X86Nt5Context.Esp = ExdiContext->X86Context.Esp;
    
    Context->X86Nt5Context.Eax = ExdiContext->X86Context.Eax;
    Context->X86Nt5Context.Ebx = ExdiContext->X86Context.Ebx;
    Context->X86Nt5Context.Ecx = ExdiContext->X86Context.Ecx;
    Context->X86Nt5Context.Edx = ExdiContext->X86Context.Edx;
    Context->X86Nt5Context.Esi = ExdiContext->X86Context.Esi;
    Context->X86Nt5Context.Edi = ExdiContext->X86Context.Edi;

    C_ASSERT(sizeof(X86_FLOATING_SAVE_AREA) ==
             FIELD_OFFSET(CONTEXT_X86, Dr0) -
             FIELD_OFFSET(CONTEXT_X86, ControlWord));
    memcpy(&Context->X86Nt5Context.FloatSave,
           &ExdiContext->X86Context.ControlWord,
           sizeof(X86_FLOATING_SAVE_AREA));

    Context->X86Nt5Context.Dr0 = ExdiContext->X86Context.Dr0;
    Context->X86Nt5Context.Dr1 = ExdiContext->X86Context.Dr1;
    Context->X86Nt5Context.Dr2 = ExdiContext->X86Context.Dr2;
    Context->X86Nt5Context.Dr3 = ExdiContext->X86Context.Dr3;
    Context->X86Nt5Context.Dr6 = ExdiContext->X86Context.Dr6;
    Context->X86Nt5Context.Dr7 = ExdiContext->X86Context.Dr7;
}

void
X86MachineInfo::ConvertExdiContextToSegDescs(PEXDI_CONTEXT ExdiContext,
                                             ULONG Start, ULONG Count,
                                             PDESCRIPTOR64 Descs)
{
    // XXX drewb - Temporary hack to report boot-time 16-bit
    // segment state.  The new x86 context should report
    // segment descriptors.
    while (Count-- > 0)
    {
        ULONG Type;
        
        if (Start == SEGREG_CODE)
        {
            Descs->Base = EXTEND64(0xffff0000);
            Type = 0x13;
        }
        else
        {
            Descs->Base = 0;
            Type = 0x1b;
        }

        Descs->Limit = 0xfffff;
        Descs->Flags = X86_DESC_PRESENT | Type;
        Descs++;

        Start++;
    }
}

void
X86MachineInfo::ConvertExdiContextFromSpecial
    (PCROSS_PLATFORM_KSPECIAL_REGISTERS Special,
     PEXDI_CONTEXT ExdiContext)
{
    // XXX drewb - Implement when the new x86 context is
    // available and provides the appropriate information.
}

void
X86MachineInfo::ConvertExdiContextToSpecial
    (PEXDI_CONTEXT ExdiContext,
     PCROSS_PLATFORM_KSPECIAL_REGISTERS Special)
{
    // XXX drewb - Implement when the new x86 context is
    // available and provides the appropriate information.
}

int
X86MachineInfo::GetType(ULONG regnum)
{
    if (regnum >= X86_MM_FIRST && regnum <= X86_MM_LAST)
    {
        return REGVAL_INT64;
    }
    else if (regnum >= X86_XMM_FIRST && regnum <= X86_XMM_LAST)
    {
        return REGVAL_VECTOR128;
    }
    else if (regnum >= X86_ST_FIRST && regnum <= X86_ST_LAST)
    {
        return REGVAL_FLOAT10;
    }
    else if (regnum < X86_FLAGBASE)
    {
        return REGVAL_INT32;
    }
    else
    {
        return REGVAL_SUB32;
    }
}

/*** X86GetVal - get register value
*
*   Purpose:
*       Return the value of the specified register.
*
*   Input:
*       regnum - register specification
*
*   Returns:
*       Value of register.
*
*************************************************************************/

BOOL
X86MachineInfo::GetVal (
    ULONG regnum,
    REGVAL *val
    )
{
    if (regnum >= X86_MM_FIRST && regnum <= X86_MM_LAST)
    {
        val->type = REGVAL_VECTOR64;
        GetMmxReg(regnum, val);
    }
    else if (regnum >= X86_XMM_FIRST && regnum <= X86_XMM_LAST)
    {
        if (GetContextState(MCTX_CONTEXT) != S_OK)
        {
            return FALSE;
        }
        
        val->type = REGVAL_VECTOR128;
        memcpy(val->bytes, m_Context.X86Nt5Context.FxSave.Reserved3 +
               (regnum - X86_XMM_FIRST) * 16, 16);
    }
    else if (regnum >= X86_ST_FIRST && regnum <= X86_ST_LAST)
    {
        val->type = REGVAL_FLOAT10;
        GetFloatReg(regnum, val);
    }
    else if (regnum < X86_FLAGBASE)
    {
        val->type = REGVAL_INT32;
        val->i64 = (ULONG64)(LONG64)(LONG)GetIntReg(regnum);
    }
    else
    {
        ErrOut("X86MachineInfo::GetVal: "
               "unknown register %lx requested\n", regnum);
        return FALSE;
    }

    return TRUE;
}

/*** X86SetVal - set register value
*
*   Purpose:
*       Set the value of the specified register.
*
*   Input:
*       regnum - register specification
*       val - new register value
*
*   Output:
*       None.
*
*   Notes:
*
*************************************************************************/

BOOL
X86MachineInfo::SetVal (ULONG regnum, REGVAL *val)
{
    if (m_ContextIsReadOnly)
    {
        return FALSE;
    }
    
    if (regnum >= X86_FLAGBASE)
    {
        return FALSE;
    }

    // Optimize away some common cases where registers are
    // set to their current value.
    if ((m_ContextState >= MCTX_PC && regnum == X86_EIP &&
         val->i32 == m_Context.X86Nt5Context.Eip) ||
        (((m_ContextState >= MCTX_DR67_REPORT &&
           m_ContextState <= MCTX_REPORT) ||
          m_ContextState >= MCTX_FULL) && regnum == X86_DR7 &&
         val->i32 == m_Context.X86Nt5Context.Dr7))
    {
        return TRUE;
    }
    
    if (GetContextState(MCTX_DIRTY) != S_OK)
    {
        return FALSE;
    }

    if (regnum >= X86_MM_FIRST && regnum <= X86_MM_LAST)
    {
        *(ULONG64 UNALIGNED *)GetMmxRegSlot(regnum) = val->i64;
        goto Notify;
    }
    else if (regnum >= X86_XMM_FIRST && regnum <= X86_XMM_LAST)
    {
        memcpy(m_Context.X86Nt5Context.FxSave.Reserved3 +
               (regnum - X86_XMM_FIRST) * 16, val->bytes, 16);
        goto Notify;
    }
    else if (regnum >= X86_ST_FIRST && regnum <= X86_ST_LAST)
    {
        memcpy(m_Context.X86Nt5Context.FloatSave.RegisterArea +
               10 * (regnum - X86_ST_FIRST), val->f10, sizeof(val->f10));
        goto Notify;
    }

    BOOL Recognized;

    Recognized = TRUE;
    
    switch (regnum)
    {
    case X86_GS:
        m_Context.X86Nt5Context.SegGs = val->i16;
        m_SegRegDesc[SEGREG_GS].Flags = SEGDESC_INVALID;
        break;
    case X86_FS:
        m_Context.X86Nt5Context.SegFs = val->i16;
        m_SegRegDesc[SEGREG_FS].Flags = SEGDESC_INVALID;
        break;
    case X86_ES:
        m_Context.X86Nt5Context.SegEs = val->i16;
        m_SegRegDesc[SEGREG_ES].Flags = SEGDESC_INVALID;
        break;
    case X86_DS:
        m_Context.X86Nt5Context.SegDs = val->i16;
        m_SegRegDesc[SEGREG_DATA].Flags = SEGDESC_INVALID;
        break;
    case X86_EDI:
        m_Context.X86Nt5Context.Edi = val->i32;
        break;
    case X86_ESI:
        m_Context.X86Nt5Context.Esi = val->i32;
        break;
    case X86_EBX:
        m_Context.X86Nt5Context.Ebx = val->i32;
        break;
    case X86_EDX:
        m_Context.X86Nt5Context.Edx = val->i32;
        break;
    case X86_ECX:
        m_Context.X86Nt5Context.Ecx = val->i32;
        break;
    case X86_EAX:
        m_Context.X86Nt5Context.Eax = val->i32;
        break;
    case X86_EBP:
        m_Context.X86Nt5Context.Ebp = val->i32;
        break;
    case X86_EIP:
        m_Context.X86Nt5Context.Eip = val->i32;
        break;
    case X86_CS:
        m_Context.X86Nt5Context.SegCs = val->i16;
        m_SegRegDesc[SEGREG_CODE].Flags = SEGDESC_INVALID;
        break;
    case X86_EFL:
        if (IS_KERNEL_TARGET())
        {
            // leave TF clear
            m_Context.X86Nt5Context.EFlags = val->i32 & ~0x100;
        }
        else
        {
            // allow TF set
            m_Context.X86Nt5Context.EFlags = val->i32;
        }
        break;
    case X86_ESP:
        m_Context.X86Nt5Context.Esp = val->i32;
        break;
    case X86_SS:
        m_Context.X86Nt5Context.SegSs = val->i16;
        m_SegRegDesc[SEGREG_STACK].Flags = SEGDESC_INVALID;
        break;

    case X86_DR0:
        m_Context.X86Nt5Context.Dr0 = val->i32;
        break;
    case X86_DR1:
        m_Context.X86Nt5Context.Dr1 = val->i32;
        break;
    case X86_DR2:
        m_Context.X86Nt5Context.Dr2 = val->i32;
        break;
    case X86_DR3:
        m_Context.X86Nt5Context.Dr3 = val->i32;
        break;
    case X86_DR6:
        m_Context.X86Nt5Context.Dr6 = val->i32;
        break;
    case X86_DR7:
        m_Context.X86Nt5Context.Dr7 = val->i32;
        break;

    case X86_FPCW:
        m_Context.X86Nt5Context.FloatSave.ControlWord =
            (m_Context.X86Nt5Context.FloatSave.ControlWord & 0xffff0000) |
            (val->i32 & 0xffff);
        break;
    case X86_FPSW:
        m_Context.X86Nt5Context.FloatSave.StatusWord =
            (m_Context.X86Nt5Context.FloatSave.StatusWord & 0xffff0000) |
            (val->i32 & 0xffff);
        break;
    case X86_FPTW:
        m_Context.X86Nt5Context.FloatSave.TagWord =
            (m_Context.X86Nt5Context.FloatSave.TagWord & 0xffff0000) |
            (val->i32 & 0xffff);
        break;
    case X86_MXCSR:
        m_Context.X86Nt5Context.FxSave.MXCsr = val->i32;
        break;
    default:
        Recognized = FALSE;
        break;
    }
        
    if (!Recognized && IS_KERNEL_TARGET())
    {
        Recognized = TRUE;
        
        switch(regnum)
        {
        case X86_CR0:
            m_SpecialRegContext.Cr0 = val->i32;
            break;
        case X86_CR2:
            m_SpecialRegContext.Cr2 = val->i32;
            break;
        case X86_CR3:
            m_SpecialRegContext.Cr3 = val->i32;
            break;
        case X86_CR4:
            m_SpecialRegContext.Cr4 = val->i32;
            break;
        case X86_GDTR:
            m_SpecialRegContext.Gdtr.Base = val->i32;
            break;
        case X86_GDTL:
            m_SpecialRegContext.Gdtr.Limit = (USHORT)val->i32;
            break;
        case X86_IDTR:
            m_SpecialRegContext.Idtr.Base = val->i32;
            break;
        case X86_IDTL:
            m_SpecialRegContext.Idtr.Limit = (USHORT)val->i32;
            break;
        case X86_TR:
            m_SpecialRegContext.Tr = (USHORT)val->i32;
            break;
        case X86_LDTR:
            m_SpecialRegContext.Ldtr = (USHORT)val->i32;
            break;

        default:
            Recognized = FALSE;
            break;
        }
    }

    if (!Recognized)
    {
        ErrOut("X86MachineInfo::SetVal: "
               "unknown register %lx requested\n", regnum);
        return FALSE;
    }

 Notify:
    NotifyChangeDebuggeeState(DEBUG_CDS_REGISTERS,
                              RegCountFromIndex(regnum));
    return TRUE;
}

void
X86MachineInfo::GetPC (PADDR Address)
{
    FormAddr(SEGREG_CODE, EXTEND64(GetIntReg(X86_EIP)),
             FORM_CODE | FORM_SEGREG | X86_FORM_VM86(GetIntReg(X86_EFL)),
             Address);
}

void
X86MachineInfo::SetPC (PADDR paddr)
{
    REGVAL val;

    // We set the EIP to the offset (the non-translated value),
    // because we may not be in "flat" mode !!!

    val.type = REGVAL_INT32;
    val.i32 = (ULONG)Off(*paddr);
    SetVal(X86_EIP, &val);
}

void
X86MachineInfo::GetFP(PADDR Addr)
{
    FormAddr(SEGREG_STACK, EXTEND64(GetIntReg(X86_EBP)),
             FORM_SEGREG | X86_FORM_VM86(GetIntReg(X86_EFL)), Addr);
}

void
X86MachineInfo::GetSP(PADDR Addr)
{
    FormAddr(SEGREG_STACK, EXTEND64(GetIntReg(X86_ESP)),
             FORM_SEGREG | X86_FORM_VM86(GetIntReg(X86_EFL)), Addr);
}

ULONG64
X86MachineInfo::GetArgReg(void)
{
    return (ULONG64)(LONG64)(LONG)GetIntReg(X86_EAX);
}

ULONG
X86MachineInfo::GetSegRegNum(ULONG SegReg)
{
    switch(SegReg)
    {
    case SEGREG_CODE:
        return X86_CS;
    case SEGREG_DATA:
        return X86_DS;
    case SEGREG_STACK:
        return X86_SS;
    case SEGREG_ES:
        return X86_ES;
    case SEGREG_FS:
        return X86_FS;
    case SEGREG_GS:
        return X86_GS;
    case SEGREG_LDT:
        return X86_LDTR;
    }

    return 0;
}

HRESULT
X86MachineInfo::GetSegRegDescriptor(ULONG SegReg, PDESCRIPTOR64 Desc)
{
    if (SegReg == SEGREG_GDT)
    {
        Desc->Base = EXTEND64(GetIntReg(X86_GDTR));
        Desc->Limit = GetIntReg(X86_GDTL);
        Desc->Flags = 0;
        return S_OK;
    }

    // Check and see if we already have a cached descriptor.
    if (m_SegRegDesc[SegReg].Flags != SEGDESC_INVALID)
    {
        *Desc = m_SegRegDesc[SegReg];
        return S_OK;
    }

    HRESULT Status;

    // Attempt to retrieve segment descriptors directly.
    if ((Status = GetContextState(MCTX_FULL)) != S_OK)
    {
        return Status;
    }
    
    // Check and see if we now have a cached descriptor.
    if (m_SegRegDesc[SegReg].Flags != SEGDESC_INVALID)
    {
        *Desc = m_SegRegDesc[SegReg];
        return S_OK;
    }

    //
    // Direct information is not available so look things up
    // in the descriptor tables.
    //
    
    ULONG RegNum = GetSegRegNum(SegReg);
    if (RegNum == 0)
    {
        return E_INVALIDARG;
    }

    // Do a quick sanity test to prevent bad values
    // from causing problems.
    ULONG Selector = GetIntReg(RegNum);
    if (SegReg == SEGREG_LDT && (Selector & 4))
    {
        // The ldtr selector says that it's an LDT selector,
        // which is invalid.  An LDT selector should always
        // reference the GDT.
        ErrOut("Invalid LDTR contents: %04X\n", Selector);
        return E_FAIL;
    }
        
    return g_Target->GetSelDescriptor(this, g_RegContextThread->Handle,
                                      Selector, Desc);
}

/*** X86OutputAll - output all registers and present instruction
*
*   Purpose:
*       To output the current register state of the processor.
*       All integer registers are output as well as processor status
*       registers.  Important flag fields are also output separately.
*
*   Input:
*       Mask - Which information to display.
*
*   Output:
*       None.
*
*************************************************************************/

void
X86MachineInfo::OutputAll(ULONG Mask, ULONG OutMask)
{
    if (GetContextState(MCTX_FULL) != S_OK)
    {
        ErrOut("Unable to retrieve register information\n");
        return;
    }
    
    if (Mask & (REGALL_INT32 | REGALL_INT64))
    {
        ULONG efl;

        MaskOut(OutMask, "eax=%08lx ebx=%08lx ecx=%08lx "
                "edx=%08lx esi=%08lx edi=%08lx\n",
                GetIntReg(X86_EAX),
                GetIntReg(X86_EBX),
                GetIntReg(X86_ECX),
                GetIntReg(X86_EDX),
                GetIntReg(X86_ESI),
                GetIntReg(X86_EDI));

        efl = GetIntReg(X86_EFL);
        MaskOut(OutMask, "eip=%08lx esp=%08lx ebp=%08lx iopl=%1lx "
                "%s %s %s %s %s %s %s %s %s %s\n",
                GetIntReg(X86_EIP),
                GetIntReg(X86_ESP),
                GetIntReg(X86_EBP),
                ((efl >> X86_SHIFT_FLAGIOPL) & X86_BIT_FLAGIOPL),
                (efl & X86_BIT_FLAGVIP) ? "vip" : "   ",
                (efl & X86_BIT_FLAGVIF) ? "vif" : "   ",
                (efl & X86_BIT_FLAGOF) ? "ov" : "nv",
                (efl & X86_BIT_FLAGDF) ? "dn" : "up",
                (efl & X86_BIT_FLAGIF) ? "ei" : "di",
                (efl & X86_BIT_FLAGSF) ? "ng" : "pl",
                (efl & X86_BIT_FLAGZF) ? "zr" : "nz",
                (efl & X86_BIT_FLAGAF) ? "ac" : "na",
                (efl & X86_BIT_FLAGPF) ? "po" : "pe",
                (efl & X86_BIT_FLAGCF) ? "cy" : "nc");
    }

    if (Mask & REGALL_SEGREG)
    {
        MaskOut(OutMask, "cs=%04lx  ss=%04lx  ds=%04lx  es=%04lx  fs=%04lx  "
                "gs=%04lx             efl=%08lx\n",
                GetIntReg(X86_CS),
                GetIntReg(X86_SS),
                GetIntReg(X86_DS),
                GetIntReg(X86_ES),
                GetIntReg(X86_FS),
                GetIntReg(X86_GS),
                GetIntReg(X86_EFL));
    }

    if (Mask & REGALL_FLOAT)
    {
        ULONG i;
        REGVAL val;
        char buf[32];

        MaskOut(OutMask, "fpcw=%04X    fpsw=%04X    fptw=%04X\n",
                GetIntReg(X86_FPCW),
                GetIntReg(X86_FPSW),
                GetIntReg(X86_FPTW));
        
        for (i = X86_ST_FIRST; i <= X86_ST_LAST; i++)
        {
            GetFloatReg(i, &val);
            _uldtoa((_ULDOUBLE *)&val.f10, sizeof(buf), buf);
            MaskOut(OutMask, "st%d=%s  ", i - X86_ST_FIRST, buf);
            i++;
            GetFloatReg(i, &val);
            _uldtoa((_ULDOUBLE *)&val.f10, sizeof(buf), buf);
            MaskOut(OutMask, "st%d=%s\n", i - X86_ST_FIRST, buf);
        }
    }

    if (Mask & REGALL_MMXREG)
    {
        ULONG i;
        REGVAL val;

        for (i = X86_MM_FIRST; i <= X86_MM_LAST; i++)
        {
            GetMmxReg(i, &val);
            MaskOut(OutMask, "mm%d=%08x%08x  ",
                    i - X86_MM_FIRST,
                    val.i64Parts.high, val.i64Parts.low);
            i++;
            GetMmxReg(i, &val);
            MaskOut(OutMask, "mm%d=%08x%08x\n",
                    i - X86_MM_FIRST,
                    val.i64Parts.high, val.i64Parts.low);
        }
    }

    if (Mask & REGALL_XMMREG)
    {
        ULONG i;
        REGVAL Val;

        for (i = X86_XMM_FIRST; i <= X86_XMM_LAST; i++)
        {
            GetVal(i, &Val);
            MaskOut(OutMask, "xmm%d=%hg %hg %hg %hg\n", i - X86_XMM_FIRST,
                    *(float *)&Val.bytes[3 * sizeof(float)],
                    *(float *)&Val.bytes[2 * sizeof(float)],
                    *(float *)&Val.bytes[1 * sizeof(float)],
                    *(float *)&Val.bytes[0 * sizeof(float)]);
        }
    }

    if (Mask & REGALL_CREG)
    {
        MaskOut(OutMask, "cr0=%08lx cr2=%08lx cr3=%08lx\n",
                GetIntReg(X86_CR0),
                GetIntReg(X86_CR2),
                GetIntReg(X86_CR3));
    }

    if (Mask & REGALL_DREG)
    {
        MaskOut(OutMask, "dr0=%08lx dr1=%08lx dr2=%08lx\n",
                GetIntReg(X86_DR0),
                GetIntReg(X86_DR1),
                GetIntReg(X86_DR2));
        MaskOut(OutMask, "dr3=%08lx dr6=%08lx dr7=%08lx",
                GetIntReg(X86_DR3),
                GetIntReg(X86_DR6),
                GetIntReg(X86_DR7));
        if (IS_USER_TARGET())
        {
            MaskOut(OutMask, "\n");
        }
        else
        {
            MaskOut(OutMask, " cr4=%08lx\n", GetIntReg(X86_CR4));
        }
    }

    if (Mask & REGALL_DESC)
    {
        MaskOut(OutMask, "gdtr=%08lx   gdtl=%04lx idtr=%08lx   idtl=%04lx "
                "tr=%04lx  ldtr=%04x\n",
                GetIntReg(X86_GDTR),
                GetIntReg(X86_GDTL),
                GetIntReg(X86_IDTR),
                GetIntReg(X86_IDTL),
                GetIntReg(X86_TR),
                GetIntReg(X86_LDTR));
    }
}

TRACEMODE
X86MachineInfo::GetTraceMode (void)
{
    if (IS_KERNEL_TARGET())
    {
        return m_TraceMode;
    }
    else
    {
        return ((GetIntReg(X86_EFL) & X86_BIT_FLAGTF) != 0) ? 
                    TRACE_INSTRUCTION : TRACE_NONE;
    }
}

void 
X86MachineInfo::SetTraceMode (TRACEMODE Mode)
{
    DBG_ASSERT(Mode == TRACE_NONE ||
               Mode == TRACE_INSTRUCTION ||
               (IS_KERNEL_TARGET() && m_SupportsBranchTrace &&
                Mode == TRACE_TAKEN_BRANCH));

    if (IS_KERNEL_TARGET())
    {
        m_TraceMode = Mode;
    }
    else
    {
        ULONG Efl = GetIntReg(X86_EFL);
        switch (Mode)
        {
        case TRACE_NONE:
            Efl &= ~X86_BIT_FLAGTF;
            break;
        case TRACE_INSTRUCTION:
            Efl |= X86_BIT_FLAGTF;
            break;
        }    
        SetReg32(X86_EFL, Efl);
    }
}

BOOL
X86MachineInfo::IsStepStatusSupported(ULONG Status)
{
    switch(Status) 
    {
    case DEBUG_STATUS_STEP_INTO:
    case DEBUG_STATUS_STEP_OVER:
        return TRUE;
    case DEBUG_STATUS_STEP_BRANCH:
        return IS_KERNEL_TARGET() && m_SupportsBranchTrace;
    default:
        return FALSE;
    }
}

void
X86MachineInfo::KdUpdateControlSet
    (PDBGKD_ANY_CONTROL_SET ControlSet)
{
    TRACEMODE TraceMode = GetTraceMode();
    ULONG64 DebugCtlMsr;
    
    ControlSet->X86ControlSet.TraceFlag = TraceMode != TRACE_NONE;
    ControlSet->X86ControlSet.Dr7 = GetIntReg(X86_DR7);

    if (TraceMode != TRACE_NONE && m_SupportsBranchTrace &&
        NT_SUCCESS(DbgKdReadMsr(X86_MSR_DEBUG_CTL, &DebugCtlMsr)))
    {
        DebugCtlMsr |= X86_DEBUG_CTL_LAST_BRANCH_RECORD;
        if (TraceMode == TRACE_TAKEN_BRANCH)
        {
            DebugCtlMsr |= X86_DEBUG_CTL_BRANCH_TRACE;
        }
        DbgKdWriteMsr(X86_MSR_DEBUG_CTL, DebugCtlMsr);
    }
    
    BpOut("UpdateControlSet(%d) trace %d, DR7 %X\n",
          g_RegContextProcessor, ControlSet->X86ControlSet.TraceFlag,
          ControlSet->X86ControlSet.Dr7);

    if (!g_WatchFunctions.IsStarted() && g_WatchBeginCurFunc != 1)
    {
        ControlSet->X86ControlSet.CurrentSymbolStart = 0;
        ControlSet->X86ControlSet.CurrentSymbolEnd = 0;
    }
    else
    {
        ControlSet->X86ControlSet.CurrentSymbolStart =
            (ULONG)g_WatchBeginCurFunc;
        ControlSet->X86ControlSet.CurrentSymbolEnd =
            (ULONG)g_WatchEndCurFunc;
    }
}

void
X86MachineInfo::KdSaveProcessorState(void)
{
    MachineInfo::KdSaveProcessorState();
    m_SavedSpecialRegContext = m_SpecialRegContext;
}

void
X86MachineInfo::KdRestoreProcessorState(void)
{
    MachineInfo::KdRestoreProcessorState();
    m_SpecialRegContext = m_SavedSpecialRegContext;
}

ULONG
X86MachineInfo::ExecutingMachine(void)
{
    return IMAGE_FILE_MACHINE_I386;
}

HRESULT
X86MachineInfo::SetPageDirectory(ULONG Idx, ULONG64 PageDir,
                                 PULONG NextIdx)
{
    HRESULT Status;
    
    *NextIdx = PAGE_DIR_COUNT;
    
    if (PageDir == 0)
    {
        if (g_ActualSystemVersion > XBOX_SVER_START &&
            g_ActualSystemVersion < XBOX_SVER_END)
        {
            // XBox has only one page directory in CR3 for everything.
            // The process doesn't have a dirbase entry.
            PageDir = GetReg32(X86_CR3);
            if (PageDir == 0)
            {
                // Register retrieval failure.
                return E_FAIL;
            }
        }
        else
        {
            // Assume NT structures.
            if ((Status = g_Target->ReadImplicitProcessInfoPointer
                 (m_OffsetEprocessDirectoryTableBase, &PageDir)) != S_OK)
            {
                return Status;
            }
        }

        if (g_ImplicitProcessDataIsDefault &&
            !IS_LOCAL_KERNEL_TARGET())
        {
            // Verify that the process dirbase matches the CR3 setting
            // as a sanity check.
            ULONG Cr3 = GetReg32(X86_CR3);
            if (Cr3 && Cr3 != (ULONG)PageDir)
            {
                WarnOut("WARNING: Process directory table base %08X "
                        "doesn't match CR3 %08X\n",
                        (ULONG)PageDir, Cr3);
            }
        }
    }

    // Sanitize the value.
    if (KdDebuggerData.PaeEnabled)
    {
        PageDir &= X86_PDBR_MASK;
    }
    else
    {
        PageDir &= X86_VALID_PFN_MASK;
    }

    // There is only one page directory so update all the slots.
    m_PageDirectories[PAGE_DIR_USER] = PageDir;
    m_PageDirectories[PAGE_DIR_SESSION] = PageDir;
    m_PageDirectories[PAGE_DIR_KERNEL] = PageDir;
    
    return S_OK;
}

#define X86_PAGE_FILE_INDEX(Entry) \
    (((ULONG)(Entry) >> 1) & MAX_PAGING_FILE_MASK)
#define X86_PAGE_FILE_OFFSET(Entry) \
    (((Entry) >> 12) << X86_PAGE_SHIFT)

HRESULT
X86MachineInfo::GetVirtualTranslationPhysicalOffsets(ULONG64 Virt,
                                                     PULONG64 Offsets,
                                                     ULONG OffsetsSize,
                                                     PULONG Levels,
                                                     PULONG PfIndex,
                                                     PULONG64 LastVal)
{
    ULONG64 Addr;
    HRESULT Status;

    *Levels = 0;
    
    if (m_Translating)
    {
        return E_UNEXPECTED;
    }
    m_Translating = TRUE;
    
    //
    // throw away top 32 bits on X86.
    //
    Virt &= 0x00000000FFFFFFFF;

    //
    // Reset the page directory in case it was 0
    //
    if (m_PageDirectories[PAGE_DIR_SINGLE] == 0)
    {
        if ((Status = SetDefaultPageDirectories(1 << PAGE_DIR_SINGLE)) != S_OK)
        {
            m_Translating = FALSE;
            return Status;
        }
    }

    KdOut("X86VtoP: Virt %s, pagedir %s\n",
          FormatAddr64(Virt),
          FormatDisp64(m_PageDirectories[PAGE_DIR_SINGLE]));
    
    (*Levels)++;
    if (Offsets != NULL && OffsetsSize > 0)
    {
        *Offsets++ = m_PageDirectories[PAGE_DIR_SINGLE];
        OffsetsSize--;
    }
        
    // This routine uses the fact that the PFN shift is the same
    // as the page shift to simplify some expressions.
    C_ASSERT(X86_VALID_PFN_SHIFT == X86_PAGE_SHIFT);

    if (KdDebuggerData.PaeEnabled)
    {
        ULONG64 Pdpe;
        ULONG64 Entry;

        KdOut("  x86VtoP: PaeEnabled\n");

        // Read the Page Directory Pointer entry.

        Pdpe = ((Virt >> X86_PDPE_SHIFT) * sizeof(Entry)) +
            m_PageDirectories[PAGE_DIR_SINGLE];

        KdOut("X86VtoP: PAE PDPE %s\n", FormatAddr64(Pdpe));
    
        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = Pdpe;
            OffsetsSize--;
        }
        
        if ((Status = g_Target->
             ReadAllPhysical(Pdpe, &Entry, sizeof(Entry))) != S_OK)
        {
            KdOut("X86VtoP: PAE PDPE read error 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }

        // Read the Page Directory entry.
        
        Addr = (((Virt >> X86_PDE_SHIFT_PAE) & X86_PDE_MASK_PAE) *
                sizeof(Entry)) + (Entry & X86_VALID_PFN_MASK_PAE);

        KdOut("X86VtoP: PAE PDE %s\n", FormatAddr64(Addr));
    
        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = Addr;
            OffsetsSize--;
        }
        
        if ((Status = g_Target->
             ReadAllPhysical(Addr, &Entry, sizeof(Entry))) != S_OK)
        {
            KdOut("X86VtoP: PAE PDE read error 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }
        
        // Check for a large page.  Large pages can
        // never be paged out so also check for the present bit.
        if ((Entry & (X86_LARGE_PAGE_MASK | 1)) == (X86_LARGE_PAGE_MASK | 1))
        {
            //
            // If we have a large page and this is a summary dump, then
            // the page may span multiple physical pages that may -- because
            // of how the summary dump is written -- not be included in the
            // dump. Fixup the large page address to its corresponding small
            // page address.
            //

            if (g_DumpType == DTYPE_KERNEL_SUMMARY32)
            {
                ULONG SpannedPages;

                SpannedPages = (ULONG)
                    ((Virt & (X86_LARGE_PAGE_SIZE_PAE - 1)) >> X86_PAGE_SHIFT);
                *LastVal = ((Entry & ~(X86_LARGE_PAGE_SIZE_PAE - 1)) |
                             (SpannedPages << X86_PAGE_SHIFT) |
                             (Virt & (X86_PAGE_SIZE - 1)));
            }
            else
            {
                *LastVal = ((Entry & ~(X86_LARGE_PAGE_SIZE_PAE - 1)) |
                             (Virt & (X86_LARGE_PAGE_SIZE_PAE - 1)));
            }
            
            KdOut("X86VtoP: PAE Large page mapped phys %s\n",
                  FormatAddr64(*LastVal));

            (*Levels)++;
            if (Offsets != NULL && OffsetsSize > 0)
            {
                *Offsets++ = *LastVal;
                OffsetsSize--;
            }
        
            m_Translating = FALSE;
            return S_OK;
        }
        
        // Read the Page Table entry.

        if (Entry == 0)
        {
            KdOut("X86VtoP: PAE zero PDE\n");
            m_Translating = FALSE;
            return HR_PAGE_NOT_AVAILABLE;
        }
        else if (!(Entry & 1))
        {
            Addr = (((Virt >> X86_PTE_SHIFT) & X86_PTE_MASK_PAE) *
                    sizeof(Entry)) + X86_PAGE_FILE_OFFSET(Entry);

            KdOut("X86VtoP: pagefile PAE PTE %d:%s\n",
                  X86_PAGE_FILE_INDEX(Entry), FormatAddr64(Addr));
            
            if ((Status = g_Target->
                 ReadPageFile(X86_PAGE_FILE_INDEX(Entry), Addr,
                              &Entry, sizeof(Entry))) != S_OK)
            {
                KdOut("X86VtoP: PAE PDE not present, 0x%X\n", Status);
                m_Translating = FALSE;
                return Status;
            }
        }
        else
        {
            Addr = (((Virt >> X86_PTE_SHIFT) & X86_PTE_MASK_PAE) *
                    sizeof(Entry)) + (Entry & X86_VALID_PFN_MASK_PAE);

            KdOut("X86VtoP: PAE PTE %s\n", FormatAddr64(Addr));
    
            (*Levels)++;
            if (Offsets != NULL && OffsetsSize > 0)
            {
                *Offsets++ = Addr;
                OffsetsSize--;
            }
        
            if ((Status = g_Target->
                 ReadAllPhysical(Addr, &Entry, sizeof(Entry))) != S_OK)
            {
                KdOut("X86VtoP: PAE PTE read error 0x%X\n", Status);
                m_Translating = FALSE;
                return Status;
            }
        }
        
        if (!(Entry & 0x1) &&
            ((Entry & X86_MM_PTE_PROTOTYPE_MASK) ||
             !(Entry & X86_MM_PTE_TRANSITION_MASK)))
        {
            if (Entry == 0)
            {
                KdOut("X86VtoP: PAE zero PTE\n");
                Status = HR_PAGE_NOT_AVAILABLE;
            }
            else if (Entry & X86_MM_PTE_PROTOTYPE_MASK)
            {
                KdOut("X86VtoP: PAE prototype PTE\n");
                Status = HR_PAGE_NOT_AVAILABLE;
            }
            else
            {
                *PfIndex = X86_PAGE_FILE_INDEX(Entry);
                *LastVal = (Virt & (X86_PAGE_SIZE - 1)) +
                    X86_PAGE_FILE_OFFSET(Entry);
                KdOut("X86VtoP: PAE PTE not present, pagefile %d:%s\n",
                      *PfIndex, FormatAddr64(*LastVal));
                Status = HR_PAGE_IN_PAGE_FILE;
            }
            m_Translating = FALSE;
            return Status;
        }

        *LastVal = ((Entry & X86_VALID_PFN_MASK_PAE) |
                     (Virt & (X86_PAGE_SIZE - 1)));
    
        KdOut("X86VtoP: PAE Mapped phys %s\n", FormatAddr64(*LastVal));

        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = *LastVal;
            OffsetsSize--;
        }
        
        m_Translating = FALSE;
        return S_OK;
    }
    else
    {
        ULONG Entry;

        // Read the Page Directory entry.
        
        Addr = ((Virt >> X86_PDE_SHIFT) * sizeof(Entry)) +
            m_PageDirectories[PAGE_DIR_SINGLE];

        KdOut("X86VtoP: PDE %s\n", FormatDisp64(Addr));
    
        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = Addr;
            OffsetsSize--;
        }
        
        if ((Status = g_Target->
             ReadAllPhysical(Addr, &Entry, sizeof(Entry))) != S_OK)
        {
            KdOut("X86VtoP: PDE read error 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }

        // Check for a large page.  Large pages can
        // never be paged out so also check for the present bit.
        if ((Entry & (X86_LARGE_PAGE_MASK | 1)) == (X86_LARGE_PAGE_MASK | 1))
        {
            *LastVal = ((Entry & ~(X86_LARGE_PAGE_SIZE - 1)) |
                         (Virt & (X86_LARGE_PAGE_SIZE - 1)));
            
            KdOut("X86VtoP: Large page mapped phys %s\n",
                  FormatAddr64(*LastVal));

            (*Levels)++;
            if (Offsets != NULL && OffsetsSize > 0)
            {
                *Offsets++ = *LastVal;
                OffsetsSize--;
            }
        
            m_Translating = FALSE;
            return S_OK;
        }
        
        // Read the Page Table entry.

        if (Entry == 0)
        {
            KdOut("X86VtoP: PAE zero PDE\n");
            m_Translating = FALSE;
            return HR_PAGE_NOT_AVAILABLE;
        }
        else if (!(Entry & 1))
        {
            Addr = (((Virt >> X86_PTE_SHIFT) & X86_PTE_MASK) *
                    sizeof(Entry)) + X86_PAGE_FILE_OFFSET(Entry);

            KdOut("X86VtoP: pagefile PTE %d:%s\n",
                  X86_PAGE_FILE_INDEX(Entry), FormatAddr64(Addr));
    
            if ((Status = g_Target->
                 ReadPageFile(X86_PAGE_FILE_INDEX(Entry), Addr,
                              &Entry, sizeof(Entry))) != S_OK)
            {
                KdOut("X86VtoP: PDE not present, 0x%X\n", Status);
                m_Translating = FALSE;
                return Status;
            }
        }
        else
        {
            Addr = (((Virt >> X86_PTE_SHIFT) & X86_PTE_MASK) *
                   sizeof(Entry)) + (Entry & X86_VALID_PFN_MASK);

            KdOut("X86VtoP: PTE %s\n", FormatAddr64(Addr));
    
            (*Levels)++;
            if (Offsets != NULL && OffsetsSize > 0)
            {
                *Offsets++ = Addr;
                OffsetsSize--;
            }
        
            if ((Status = g_Target->
                 ReadAllPhysical(Addr, &Entry, sizeof(Entry))) != S_OK)
            {
                KdOut("X86VtoP: PTE read error 0x%X\n", Status);
                m_Translating = FALSE;
                return Status;
            }
        }
        
        if (!(Entry & 0x1) &&
            ((Entry & X86_MM_PTE_PROTOTYPE_MASK) ||
             !(Entry & X86_MM_PTE_TRANSITION_MASK)))
        {
            if (Entry == 0)
            {
                KdOut("X86VtoP: zero PTE\n");
                Status = HR_PAGE_NOT_AVAILABLE;
            }
            else if (Entry & X86_MM_PTE_PROTOTYPE_MASK)
            {
                KdOut("X86VtoP: prototype PTE\n");
                Status = HR_PAGE_NOT_AVAILABLE;
            }
            else
            {
                *PfIndex = X86_PAGE_FILE_INDEX(Entry);
                *LastVal = (Virt & (X86_PAGE_SIZE - 1)) +
                    X86_PAGE_FILE_OFFSET(Entry);
                KdOut("X86VtoP: PTE not present, pagefile %d:%s\n",
                      *PfIndex, FormatAddr64(*LastVal));
                Status = HR_PAGE_IN_PAGE_FILE;
            }
            m_Translating = FALSE;
            return Status;
        }

        *LastVal = ((Entry & X86_VALID_PFN_MASK) |
                     (Virt & (X86_PAGE_SIZE - 1)));
    
        KdOut("X86VtoP: Mapped phys %s\n", FormatAddr64(*LastVal));

        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = *LastVal;
            OffsetsSize--;
        }
        
        m_Translating = FALSE;
        return S_OK;
    }
}

HRESULT
X86MachineInfo::GetBaseTranslationVirtualOffset(PULONG64 Offset)
{
    if (KdDebuggerData.PaeEnabled)
    {
        *Offset = EXTEND64(X86_BASE_VIRT_PAE);
    }
    else
    {
        *Offset = EXTEND64(X86_BASE_VIRT);
    }
    return S_OK;
}

BOOL 
X86MachineInfo::DisplayTrapFrame(ULONG64 FrameAddress,
                                 PCROSS_PLATFORM_CONTEXT Context)
{
    X86_KTRAP_FRAME TrapContents;
    CHAR Buffer[200];
    DESCRIPTOR64 Descriptor={0};
    ULONG Esp;
    ULONG64 DisasmAddr;
    ULONG Temp, SegSs, res;
    ULONG EFlags;

#define Preg(S,R) dprintf("%s=%08lx ",S, TrapContents.R);

    if (g_Target->ReadVirtual(FrameAddress, &TrapContents,
                              sizeof(TrapContents), &res) != S_OK)
    {
        dprintf("Unable to read trap frame contents\n");
        return FALSE;
    }

    Preg("eax", Eax);
    Preg("ebx", Ebx);
    Preg("ecx", Ecx);
    Preg("edx", Edx);
    Preg("esi", Esi);
    Preg("edi", Edi);
    dprintf("\n");


    //
    // Figure out ESP
    //

    if (((TrapContents.SegCs & 1) != 0 /*KernelMode*/) ||
        (TrapContents.EFlags & X86_EFLAGS_V86_MASK) ||
        FrameAddress == 0)
    {
        // User-mode frame, real value of Esp is in HardwareEsp
        Esp = TrapContents.HardwareEsp;
    }
    else
    {
        //
        // We ignore if Esp has been edited for now, and we will print a
        // separate line indicating this later.
        //
        // Calculate kernel Esp
        //

        Esp = (ULONG)FrameAddress + FIELD_OFFSET(X86_KTRAP_FRAME, HardwareEsp);
    }

    EFlags = TrapContents.EFlags;

    dprintf("eip=%08lx esp=%08lx ebp=%08lx iopl=%1lx         "
        "%s %s %s %s %s %s %s %s\n",
        TrapContents.Eip,
        Esp,
        TrapContents.Ebp,
        ((EFlags >> 12) & 3),
        (EFlags & 0x800) ? "ov" : "nv",
        (EFlags & 0x400) ? "dn" : "up",
        (EFlags & 0x200) ? "ei" : "di",
        (EFlags & 0x80) ? "ng" : "pl",
        (EFlags & 0x40) ? "zr" : "nz",
        (EFlags & 0x10) ? "ac" : "na",
        (EFlags & 0x4) ? "po" : "pe",
        (EFlags & 0x1) ? "cy" : "nc");

    // Check whether P5 Virtual Mode Extensions are enabled, for display
    // of new EFlags values.

    if ( GetIntReg(X86_CR4) != 0)
    {
        dprintf("vip=%1lx    vif=%1lx\n",
            (EFlags & 0x00100000L) >> 20,
            (EFlags & 0x00080000L) >> 19);
    }

    //
    // Find correct SS
    //

    if (EFlags & X86_EFLAGS_V86_MASK)
    {
        SegSs = (USHORT)(TrapContents.HardwareSegSs & 0xffff);
    }
    else if ((TrapContents.SegCs & X86_MODE_MASK) != 0 /*KernelMode*/)
    {
        //
        // It's user mode.  The HardwareSegSs contains R3 data selector.
        //

        SegSs = (USHORT)(TrapContents.HardwareSegSs | X86_RPL_MASK) & 0xffff;
    }
    else
    {
        SegSs = X86_KGDT_R0_DATA;
    }

    dprintf("cs=%04x  ss=%04x  ds=%04x  es=%04x  fs=%04x  gs=%04x"
        "             efl=%08lx\n",
        (USHORT)(TrapContents.SegCs & 0xffff),
        (USHORT)(SegSs & 0xffff),
        (USHORT)(TrapContents.SegDs & 0xffff),
        (USHORT)(TrapContents.SegEs & 0xffff),
        (USHORT)(TrapContents.SegFs & 0xffff),
        (USHORT)(TrapContents.SegGs & 0xffff),
        EFlags);

    //
    // Check to see if Esp has been edited, and dump new value if it has
    //
    if ( (!(EFlags & X86_EFLAGS_V86_MASK)) &&
        ((TrapContents.SegCs & X86_MODE_MASK) == 0 /*KernelMode*/))
    {
        if ((TrapContents.SegCs & X86_FRAME_EDITED) == 0)
        {
            dprintf("ESP EDITED! New esp=%08lx\n",TrapContents.TempEsp);
        }
    }

    if (FrameAddress)
    {
        dprintf("ErrCode = %08lx\n", TrapContents.ErrCode);
    }

    if (EFlags & X86_EFLAGS_V86_MASK)
    {
        DisasmAddr = ((ULONG64)((USHORT)TrapContents.SegCs & 0xffff) << 4) +
                     (TrapContents.Eip & 0xffff);
    }
    else
    {
        g_Target->GetSelDescriptor(this,
                                   g_CurrentProcess->CurrentThread->Handle,
                                   (USHORT)TrapContents.SegCs, &Descriptor);

        if (Descriptor.Flags & X86_DESC_DEFAULT_BIG)
        {
            DisasmAddr = EXTEND64(TrapContents.Eip);
        }
        else
        {
            DisasmAddr = TrapContents.Eip;// & 0xffff
        }
    }

    ADDR tempAddr;
    Type(tempAddr) = ADDR_FLAT | FLAT_COMPUTED;
    Off(tempAddr) = Flat(tempAddr) = DisasmAddr;

    if (Disassemble(&tempAddr, Buffer, FALSE))
    {
        dprintf("%s", Buffer);
    }
    else
    {
        dprintf("%08lx ???????????????\n", TrapContents.Eip);
    }

    dprintf("\n");

    if (Context) 
    {
        // Fill up the context struct
#define CPCXT(Fld)        Context->X86Context.Fld = TrapContents.Fld
        CPCXT(Ebp);  CPCXT(Eip);  CPCXT(Eax);  CPCXT(Ecx);  CPCXT(Edx); 
        CPCXT(Edi);  CPCXT(Esi);  CPCXT(Ebx);
        CPCXT(SegCs); CPCXT(SegDs); CPCXT(SegEs); CPCXT(SegFs); CPCXT(SegGs);
        CPCXT(EFlags);
#undef CPCXT
        Context->X86Context.SegSs = SegSs;  
        Context->X86Context.Esp = Esp;
    }
    g_LastRegFrame.InstructionOffset = EXTEND64(TrapContents.Eip);
    g_LastRegFrame.StackOffset       = EXTEND64(Esp);
    g_LastRegFrame.FrameOffset       = EXTEND64(TrapContents.Ebp);

    return TRUE;
#undef Preg
}

void
X86MachineInfo::ValidateCxr(PCROSS_PLATFORM_CONTEXT Context)
{
    if (Context->X86Context.EFlags & X86_EFLAGS_V86_MASK)
    {
        Context->X86Context.SegSs &=  0xffff;
    }
    else if ((Context->X86Context.SegCs & X86_MODE_MASK))
    {
        //
        // It's user mode.  The HardwareSegSs contains R3 data selector.
        //
        Context->X86Context.SegSs =
            (USHORT)(Context->X86Context.SegSs | X86_RPL_MASK) & 0xffff;
    }
    else
    {
        Context->X86Context.SegSs = X86_KGDT_R0_DATA;
    }
}
 
void
X86MachineInfo::OutputFunctionEntry(PVOID RawEntry)
{
    PFPO_DATA FpoData = (PFPO_DATA)RawEntry;

    dprintf("OffStart: %08x\n", FpoData->ulOffStart);
    dprintf("ProcSize: 0x%x\n", FpoData->cbProcSize);
    switch(FpoData->cbFrame)
    {
    case FRAME_FPO:
        dprintf("Params:    %d\n", FpoData->cdwParams);
        dprintf("Locals:    %d\n", FpoData->cdwLocals);
        dprintf("Registers: %d\n", FpoData->cbRegs);

        if (FpoData->fHasSEH)
        {
            dprintf("Has SEH\n");
        }
        if (FpoData->fUseBP)
        {
            dprintf("Uses EBP\n");
        }
        break;

    case FRAME_NONFPO:
        dprintf("Non-FPO\n");
        break;

    case FRAME_TRAP:
        if (!IS_KERNEL_TARGET())
        {
            goto UnknownFpo;
        }
        
        dprintf("Params: %d\n", FpoData->cdwParams);
        dprintf("Locals: %d\n", FpoData->cdwLocals);
        dprintf("Trap frame\n");
        break;

    case FRAME_TSS:
        if (!IS_KERNEL_TARGET())
        {
            goto UnknownFpo;
        }

        dprintf("Task gate\n");
        break;

    default:
    UnknownFpo:
        dprintf("Unknown FPO type\n");
        break;
    }
}

HRESULT
X86MachineInfo::ReadKernelProcessorId
    (ULONG Processor, PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id)
{
    HRESULT Status;
    ULONG64 Prcb, PrcbMember;
    ULONG Data;

    if ((Status = g_Target->
         GetProcessorSystemDataOffset(Processor, DEBUG_DATA_KPRCB_OFFSET,
                                      &Prcb)) != S_OK)
    {
        return Status;
    }

    if ((Status = g_Target->
         ReadAllVirtual(Prcb + FIELD_OFFSET(X86_PARTIAL_KPRCB, CpuType),
                        &Data, sizeof(Data))) != S_OK)
    {
        return Status;
    }

    Id->X86.Family = Data & 0xf;
    Id->X86.Model = (Data >> 24) & 0xf;
    Id->X86.Stepping = (Data >> 16) & 0xf;

    if (g_TargetBuildNumber >= 2474)
    {
        // XP
        PrcbMember = X86_2474_KPRCB_VENDOR_STRING;
    }
    else if (g_TargetBuildNumber >= 2251)
    {
        // XP BETA1 and BETA 2
        PrcbMember = X86_2251_KPRCB_VENDOR_STRING;
    }
    else if (g_TargetBuildNumber >= 2087)
    {
        // NT5
        PrcbMember = X86_2087_KPRCB_VENDOR_STRING;
    }
    else
    {
        // NT4
        PrcbMember = X86_1387_KPRCB_VENDOR_STRING;
    }

    if ((Status = g_Target->
         ReadAllVirtual(Prcb + PrcbMember, Id->X86.VendorString,
                        X86_VENDOR_STRING_SIZE)) != S_OK)
    {
        return Status;
    }

    return S_OK;
}

void
X86MachineInfo::KdGetSpecialRegistersFromContext(void)
{
    DBG_ASSERT(m_ContextState >= MCTX_FULL);
    
    m_SpecialRegContext.KernelDr0 = m_Context.X86Nt5Context.Dr0;
    m_SpecialRegContext.KernelDr1 = m_Context.X86Nt5Context.Dr1;
    m_SpecialRegContext.KernelDr2 = m_Context.X86Nt5Context.Dr2;
    m_SpecialRegContext.KernelDr3 = m_Context.X86Nt5Context.Dr3;
    m_SpecialRegContext.KernelDr6 = m_Context.X86Nt5Context.Dr6;
    m_SpecialRegContext.KernelDr7 = m_Context.X86Nt5Context.Dr7;
}

void
X86MachineInfo::KdSetSpecialRegistersInContext(void)
{
    DBG_ASSERT(m_ContextState >= MCTX_FULL);
    
    m_Context.X86Nt5Context.Dr0 = m_SpecialRegContext.KernelDr0;
    m_Context.X86Nt5Context.Dr1 = m_SpecialRegContext.KernelDr1;
    m_Context.X86Nt5Context.Dr2 = m_SpecialRegContext.KernelDr2;
    m_Context.X86Nt5Context.Dr3 = m_SpecialRegContext.KernelDr3;
    m_Context.X86Nt5Context.Dr6 = m_SpecialRegContext.KernelDr6;
    m_Context.X86Nt5Context.Dr7 = m_SpecialRegContext.KernelDr7;
}

ULONG
X86MachineInfo::GetIntReg(ULONG regnum)
{
    switch (m_ContextState)
    {
    case MCTX_PC:
        if (regnum == X86_EIP)
        {
            return m_Context.X86Nt5Context.Eip;
        }
        goto MctxContext;
        
    case MCTX_DR67_REPORT:
        switch (regnum)
        {
        case X86_DR6:    return m_Context.X86Nt5Context.Dr6;
        case X86_DR7:    return m_Context.X86Nt5Context.Dr7;
        }
        goto MctxContext;

    case MCTX_REPORT:
        switch (regnum)
        {
        case X86_CS:     return (USHORT)m_Context.X86Nt5Context.SegCs;
        case X86_DS:     return (USHORT)m_Context.X86Nt5Context.SegDs;
        case X86_ES:     return (USHORT)m_Context.X86Nt5Context.SegEs;
        case X86_FS:     return (USHORT)m_Context.X86Nt5Context.SegFs;
        case X86_EIP:    return m_Context.X86Nt5Context.Eip;
        case X86_EFL:    return m_Context.X86Nt5Context.EFlags;
        case X86_DR6:    return m_Context.X86Nt5Context.Dr6;
        case X86_DR7:    return m_Context.X86Nt5Context.Dr7;
        }
        // Fallthrough!
        
    case MCTX_NONE:
    MctxContext:
        if (GetContextState(MCTX_CONTEXT) != S_OK)
        {
            return 0;
        }
        // Fallthrough!
        
    case MCTX_CONTEXT:
        switch (regnum)
        {
        case X86_CS:     return (USHORT)m_Context.X86Nt5Context.SegCs;
        case X86_DS:     return (USHORT)m_Context.X86Nt5Context.SegDs;
        case X86_ES:     return (USHORT)m_Context.X86Nt5Context.SegEs;
        case X86_FS:     return (USHORT)m_Context.X86Nt5Context.SegFs;
        case X86_EIP:    return m_Context.X86Nt5Context.Eip;
        case X86_EFL:    return m_Context.X86Nt5Context.EFlags;

        case X86_GS:     return (USHORT)m_Context.X86Nt5Context.SegGs;
        case X86_SS:     return (USHORT)m_Context.X86Nt5Context.SegSs;
        case X86_EDI:    return m_Context.X86Nt5Context.Edi;
        case X86_ESI:    return m_Context.X86Nt5Context.Esi;
        case X86_EBX:    return m_Context.X86Nt5Context.Ebx;
        case X86_EDX:    return m_Context.X86Nt5Context.Edx;
        case X86_ECX:    return m_Context.X86Nt5Context.Ecx;
        case X86_EAX:    return m_Context.X86Nt5Context.Eax;
        case X86_EBP:    return m_Context.X86Nt5Context.Ebp;
        case X86_ESP:    return m_Context.X86Nt5Context.Esp;

        case X86_FPCW:
            return m_Context.X86Nt5Context.FloatSave.ControlWord & 0xffff;
        case X86_FPSW:
            return m_Context.X86Nt5Context.FloatSave.StatusWord & 0xffff;
        case X86_FPTW:
            return m_Context.X86Nt5Context.FloatSave.TagWord & 0xffff;

        case X86_MXCSR:
            return m_Context.X86Nt5Context.FxSave.MXCsr;
        }

        //
        // The requested register is not in our current context, load up
        // a complete context
        //

        if (GetContextState(MCTX_FULL) != S_OK)
        {
            return 0;
        }
    }

    //
    // We must have a complete context...
    //

    switch (regnum)
    {
    case X86_GS:
        return (USHORT)m_Context.X86Nt5Context.SegGs;
    case X86_FS:
        return (USHORT)m_Context.X86Nt5Context.SegFs;
    case X86_ES:
        return (USHORT)m_Context.X86Nt5Context.SegEs;
    case X86_DS:
        return (USHORT)m_Context.X86Nt5Context.SegDs;
    case X86_EDI:
        return m_Context.X86Nt5Context.Edi;
    case X86_ESI:
        return m_Context.X86Nt5Context.Esi;
    case X86_SI:
        return(m_Context.X86Nt5Context.Esi & 0xffff);
    case X86_DI:
        return(m_Context.X86Nt5Context.Edi & 0xffff);
    case X86_EBX:
        return m_Context.X86Nt5Context.Ebx;
    case X86_EDX:
        return m_Context.X86Nt5Context.Edx;
    case X86_ECX:
        return m_Context.X86Nt5Context.Ecx;
    case X86_EAX:
        return m_Context.X86Nt5Context.Eax;
    case X86_EBP:
        return m_Context.X86Nt5Context.Ebp;
    case X86_EIP:
        return m_Context.X86Nt5Context.Eip;
    case X86_CS:
        return (USHORT)m_Context.X86Nt5Context.SegCs;
    case X86_EFL:
        return m_Context.X86Nt5Context.EFlags;
    case X86_ESP:
        return m_Context.X86Nt5Context.Esp;
    case X86_SS:
        return (USHORT)m_Context.X86Nt5Context.SegSs;

    case X86_DR0:
        return m_Context.X86Nt5Context.Dr0;
    case X86_DR1:
        return m_Context.X86Nt5Context.Dr1;
    case X86_DR2:
        return m_Context.X86Nt5Context.Dr2;
    case X86_DR3:
        return m_Context.X86Nt5Context.Dr3;
    case X86_DR6:
        return m_Context.X86Nt5Context.Dr6;
    case X86_DR7:
        return m_Context.X86Nt5Context.Dr7;

    case X86_FPCW:
        return m_Context.X86Nt5Context.FloatSave.ControlWord & 0xffff;
    case X86_FPSW:
        return m_Context.X86Nt5Context.FloatSave.StatusWord & 0xffff;
    case X86_FPTW:
        return m_Context.X86Nt5Context.FloatSave.TagWord & 0xffff;

    case X86_MXCSR:
        return m_Context.X86Nt5Context.FxSave.MXCsr;
    }
    
    if (IS_KERNEL_TARGET())
    {
        switch(regnum)
        {
        case X86_CR0:
            return m_SpecialRegContext.Cr0;
        case X86_CR2:
            return m_SpecialRegContext.Cr2;
        case X86_CR3:
            return m_SpecialRegContext.Cr3;
        case X86_CR4:
            return m_SpecialRegContext.Cr4;
        case X86_GDTR:
            return m_SpecialRegContext.Gdtr.Base;
        case X86_GDTL:
            return (ULONG)m_SpecialRegContext.Gdtr.Limit;
        case X86_IDTR:
            return m_SpecialRegContext.Idtr.Base;
        case X86_IDTL:
            return (ULONG)m_SpecialRegContext.Idtr.Limit;
        case X86_TR:
            return (ULONG)m_SpecialRegContext.Tr;
        case X86_LDTR:
            return (ULONG)m_SpecialRegContext.Ldtr;
        }
    }

    ErrOut("X86MachineInfo::GetVal: "
           "unknown register %lx requested\n", regnum);
    return REG_ERROR;
}

PULONG64
X86MachineInfo::GetMmxRegSlot(ULONG regnum)
{
    return (PULONG64)(m_Context.X86Nt5Context.FloatSave.RegisterArea +
                      GetMmxRegOffset(regnum - X86_MM_FIRST,
                                      GetIntReg(X86_FPSW)) * 10);
}

void
X86MachineInfo::GetMmxReg(ULONG regnum, REGVAL *val)
{
    if (GetContextState(MCTX_CONTEXT) == S_OK)
    {
        val->i64 = *(ULONG64 UNALIGNED *)GetMmxRegSlot(regnum);
    }
}

void
X86MachineInfo::GetFloatReg(ULONG regnum, REGVAL *val)
{
    if (GetContextState(MCTX_CONTEXT) == S_OK)
    {
        memcpy(val->f10, m_Context.X86Nt5Context.FloatSave.RegisterArea +
               10 * (regnum - X86_ST_FIRST), sizeof(val->f10));
    }
}

// TSS

ULONG64
X86MachineInfo::Selector2Address(
    USHORT      TaskRegister
    )
{
    DESCRIPTOR64 desc;

    //
    // Lookup task register
    //

    if (g_Target->GetSelDescriptor
        (this, g_CurrentProcess->CurrentThread->Handle,
         TaskRegister, &desc) != S_OK)
    {
        //
        // Can't do it.
        //

        return 0;
    }

    if (X86_DESC_TYPE(desc.Flags) != 9  &&
        X86_DESC_TYPE(desc.Flags) != 0xb)
    {
        //
        // not a 32bit task descriptor
        //

        return 0;
    }

    //
    // Read in Task State Segment
    //

    return desc.Base;
}

HRESULT
X86MachineInfo::DumpTSS(void)

/*++

Routine Description:



Arguments:

    args -

Return Value:

    None

--*/

{

#define MAX_RING 3

    ULONG       taskRegister;
    PUCHAR      buf;
    ULONG64     hostAddress;
    BOOLEAN     extendedDump;
    ULONG       i;
    USHORT SegSs;
    CHAR Buffer[200];
    DESCRIPTOR64 Descriptor;
    ULONG Esp;
    ULONG64 DisasmAddr;

    struct
    {
        // intel's TSS format
        ULONG   Previous;
        struct
        {
            ULONG   Esp;
            ULONG   Ss;
        } Ring[MAX_RING];
        ULONG   Cr3;
        ULONG   Eip;
        ULONG   EFlags;
        ULONG   Eax;
        ULONG   Ecx;
        ULONG   Edx;
        ULONG   Ebx;
        ULONG   Esp;
        ULONG   Ebp;
        ULONG   Esi;
        ULONG   Edi;
        ULONG   Es;
        ULONG   Cs;
        ULONG   Ss;
        ULONG   Ds;
        ULONG   Fs;
        ULONG   Gs;
        ULONG   Ldt;
        USHORT  T;
        USHORT  IoMapBase;
    } TSS;

    buf = (PUCHAR)&TSS;
    *buf = '\0';

    taskRegister = (ULONG) GetExpression();

    //
    // If user specified a 2nd parameter, doesn't matter what it is,
    // dump the portions of the TSS not covered by the trap frame dump.
    //
    if (*g_CurCmd)
    {
        extendedDump = TRUE;
        g_CurCmd += strlen(g_CurCmd);
    }

    hostAddress = Selector2Address((USHORT)taskRegister);

    if (!hostAddress)
    {
        ErrOut("unable to get Task State Segment address from selector %lX\n",
               taskRegister);
        return E_INVALIDARG;
    }

    if (g_Target->ReadVirtual(hostAddress, &TSS, sizeof(TSS), &i) != S_OK)
    {
        ErrOut("unable to read Task State Segment from host address %lx\n",
               hostAddress);
        return E_INVALIDARG;
    }

    //
    // Display it.
    //

    if (extendedDump)
    {
        dprintf("\nTask State Segment (selector 0x%x) at 0x%p\n\n",
                taskRegister,
                hostAddress);
        dprintf("Previous Task Link   = %4x\n", TSS.Previous);
        for (i = 0 ; i < MAX_RING ; i++)
        {
            dprintf("Esp%d = %8x  SS%d = %4x\n",
                    i, TSS.Ring[i].Esp,
                    i, TSS.Ring[i].Ss);
        }
        dprintf("CR3 (PDBR)           = %08x\n", TSS.Cr3);
        dprintf("I/O Map Base Address = %4x, Debug Trap (T) = %s\n",
                TSS.IoMapBase,
                TSS.T == 0 ? "False" : "True");
        dprintf("\nSaved General Purpose Registers\n\n");
    }

    dprintf("eax=%08lx ebx=%08lx ecx=%08lx edx=%08lx esi=%08lx edi=%08lx\n",
                TSS.Eax,
                TSS.Ebx,
                TSS.Ecx,
                TSS.Edx,
                TSS.Esi,
                TSS.Edi);
    Esp = TSS.Esp;

    dprintf("eip=%08lx esp=%08lx ebp=%08lx iopl=%1lx         "
        "%s %s %s %s %s %s %s %s\n",
                TSS.Eip,
                Esp,
                TSS.Ebp,
                ((TSS.EFlags >> 12) & 3),
        (TSS.EFlags & 0x800) ? "ov" : "nv",
        (TSS.EFlags & 0x400) ? "dn" : "up",
        (TSS.EFlags & 0x200) ? "ei" : "di",
        (TSS.EFlags & 0x80) ? "ng" : "pl",
        (TSS.EFlags & 0x40) ? "zr" : "nz",
        (TSS.EFlags & 0x10) ? "ac" : "na",
        (TSS.EFlags & 0x4) ? "po" : "pe",
        (TSS.EFlags & 0x1) ? "cy" : "nc");

    // Check whether P5 Virtual Mode Extensions are enabled, for display
    // of new EFlags values.

    if (GetIntReg(X86_CR4) != 0)
    {
        dprintf("vip=%1lx    vif=%1lx\n",
        (TSS.EFlags & 0x00100000L) >> 20,
        (TSS.EFlags & 0x00080000L) >> 19);
    }

    //
    // Find correct SS
    //

    if (TSS.EFlags & X86_EFLAGS_V86_MASK)
    {
        SegSs = (USHORT)(TSS.Ss & 0xffff);
    }
    else if ((TSS.Cs & X86_MODE_MASK) != 0)
    {
        //
        // It's user mode.  The HardwareSegSs contains R3 data selector.
        //

        SegSs = (USHORT)(TSS.Ss | X86_RPL_MASK) & 0xffff;
    }
    else
    {
        SegSs = X86_KGDT_R0_DATA;
    }

    dprintf("cs=%04x  ss=%04x  ds=%04x  es=%04x  fs=%04x  gs=%04x"
        "             efl=%08lx\n",
            (USHORT)(TSS.Cs & 0xffff),
            (USHORT)(SegSs & 0xffff),
            (USHORT)(TSS.Ds & 0xffff),
            (USHORT)(TSS.Es & 0xffff),
            (USHORT)(TSS.Fs & 0xffff),
            (USHORT)(TSS.Gs & 0xffff),
            TSS.EFlags);

    if (TSS.EFlags & X86_EFLAGS_V86_MASK)
    {
        DisasmAddr = ((ULONG)((USHORT)TSS.Cs & 0xffff) << 4) +
            (TSS.Eip & 0xffff);
    }
    else
    {
        if (g_Target->GetSelDescriptor(this, g_EventThread->Handle,
                                       TSS.Cs, &Descriptor) != S_OK)
        {
            ErrOut("Unable to get TSS CS descriptor\n");
            return E_INVALIDARG;
        }

        if (Descriptor.Flags & X86_DESC_DEFAULT_BIG)
        {
            DisasmAddr = EXTEND64(TSS.Eip);
        }
        else
        {
            DisasmAddr = TSS.Eip & 0xffff;
        }
    }

    
    ADDR tempAddr;
    Type(tempAddr) = ADDR_FLAT | FLAT_COMPUTED;
    Off(tempAddr) = Flat(tempAddr) = DisasmAddr;
    if (Disassemble(&tempAddr, Buffer, FALSE))
    {
        dprintf(Buffer);
    }
    else
    {
        dprintf("%08lx ???????????????\n", TSS.Eip);
    }

    dprintf("\n");

    X86_CONTEXT Context;
#define CPCXT(Fld)        Context.Fld = TSS.Fld
        CPCXT(Ebp);  CPCXT(Eip);  CPCXT(Eax);  CPCXT(Ecx);  CPCXT(Edx); 
        CPCXT(Edi);  CPCXT(Esi);  CPCXT(Ebx);  CPCXT(Esp);
        CPCXT(EFlags);
#undef CPCXT
        
    Context.SegCs = TSS.Ss; Context.SegDs = TSS.Ds; Context.SegEs = TSS.Es; 
    Context.SegFs = TSS.Fs; Context.SegGs = TSS.Gs; Context.SegSs = SegSs;

    g_LastRegFrame.InstructionOffset = EXTEND64(Context.Eip);
    g_LastRegFrame.StackOffset       = EXTEND64(Context.Esp);
    g_LastRegFrame.FrameOffset       = EXTEND64(Context.Ebp);

    SetCurrentScope(&g_LastRegFrame, &Context, sizeof(X86_CONTEXT));
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\i386_reg.h ===
//
// Register bit constants.
//

#define X86_CR4_DEBUG_EXTENSIONS 0x8

#define X86_DR6_BREAK_03 0xf
#define X86_DR6_SINGLE_STEP 0x4000

#define X86_DR7_LOCAL_EXACT_ENABLE 0x100
#define X86_DR7_LEN0_SHIFT 18
#define X86_DR7_RW0_EXECUTE    0x00000
#define X86_DR7_RW0_WRITE      0x10000
#define X86_DR7_RW0_IO         0x20000
#define X86_DR7_RW0_READ_WRITE 0x30000
#define X86_DR7_L0_ENABLE 0x1
#define X86_DR7_ALL_ENABLES 0xff
// All control bits used by breaks 0-3.
#define X86_DR7_CTRL_03_MASK ((ULONG)0xffff00ff)

#define X86_IS_VM86(x) ((unsigned short)(((x) >> 17) & 1))

#define X86_BIT_FLAGOF (1 << 11)
#define X86_BIT_FLAGDF (1 << 10)
#define X86_BIT_FLAGIF (1 << 9)
#define X86_BIT_FLAGTF (1 << 8)
#define X86_BIT_FLAGSF (1 << 7)
#define X86_BIT_FLAGZF (1 << 6)
#define X86_BIT_FLAGAF (1 << 4)
#define X86_BIT_FLAGPF (1 << 2)
#define X86_BIT_FLAGCF (1 << 0)
#define X86_BIT_FLAGVIP (1 << 20)
#define X86_BIT_FLAGVIF (1 << 19)
#define X86_BIT_FLAGIOPL 3
#define X86_SHIFT_FLAGIOPL 12

//
// MSRs and their bits.
//

#define X86_MSR_DEBUG_CTL 0x1d9

#define X86_DEBUG_CTL_LAST_BRANCH_RECORD 0x0001
#define X86_DEBUG_CTL_BRANCH_TRACE       0x0002

#define X86_MSR_LAST_BRANCH_FROM_IP 0x1db
#define X86_MSR_LAST_BRANCH_TO_IP 0x1dc
#define X86_MSR_LAST_EXCEPTION_FROM_IP 0x1dd
#define X86_MSR_LAST_EXCEPTION_TO_IP 0x1de

//
// Native register values.  These register values are shared
// between plain X86 and AMD64.  In IA32 intregs have 32-bit values,
// in AMD64 they have 64-bit values.
// Logically they are the same register, though, and the shared
// disassembler uses them.
//

// 32/64 bit.
#define X86_NAX         1
#define X86_NBX         2
#define X86_NCX         3
#define X86_NDX         4
#define X86_NSI         5
#define X86_NDI         6
#define X86_NSP         7
#define X86_NBP         8
#define X86_NIP         9

// 32 bit.
#define X86_NFL         10

// 16 bit.  These must be a group of consecutive values.
#define X86_NCS         11
#define X86_NDS         12
#define X86_NES         13
#define X86_NFS         14
#define X86_NGS         15
#define X86_NSS         16

#define X86_NSEG_FIRST X86_NCS
#define X86_NSEG_LAST  X86_NSS

//
// IA32 definitions.
//

#define X86_GS          X86_NGS
#define X86_FS          X86_NFS
#define X86_ES          X86_NES
#define X86_DS          X86_NDS
#define X86_EDI         X86_NDI
#define X86_ESI         X86_NSI
#define X86_EBX         X86_NBX
#define X86_EDX         X86_NDX
#define X86_ECX         X86_NCX
#define X86_EAX         X86_NAX
#define X86_EBP         X86_NBP
#define X86_EIP         X86_NIP
#define X86_CS          X86_NCS
#define X86_EFL         X86_NFL
#define X86_ESP         X86_NSP
#define X86_SS          X86_NSS

#define X86_CR0         17
#define X86_CR2         18
#define X86_CR3         19
#define X86_CR4         20

#define X86_DR0         21
#define X86_DR1         22
#define X86_DR2         23
#define X86_DR3         24
#define X86_DR6         25
#define X86_DR7         26

#define X86_GDTR        27
#define X86_GDTL        28
#define X86_IDTR        29
#define X86_IDTL        30
#define X86_TR          31
#define X86_LDTR        32

// SSE registers:
#define X86_MXCSR       50

#define X86_XMM0        51
#define X86_XMM1        52
#define X86_XMM2        53
#define X86_XMM3        54
#define X86_XMM4        55
#define X86_XMM5        56
#define X86_XMM6        57
#define X86_XMM7        58

#define X86_XMM_FIRST   X86_XMM0
#define X86_XMM_LAST    X86_XMM7

// Floating-point registers:
#define X86_FPCW        60
#define X86_FPSW        61
#define X86_FPTW        62

#define X86_ST0         70
#define X86_ST1         71
#define X86_ST2         72
#define X86_ST3         73
#define X86_ST4         74
#define X86_ST5         75
#define X86_ST6         76
#define X86_ST7         77

#define X86_ST_FIRST    X86_ST0
#define X86_ST_LAST     X86_ST7

// MMX registers:
#define X86_MM0         80
#define X86_MM1         81
#define X86_MM2         82
#define X86_MM3         83
#define X86_MM4         84
#define X86_MM5         85
#define X86_MM6         86
#define X86_MM7         87

#define X86_MM_FIRST    X86_MM0
#define X86_MM_LAST     X86_MM7

#define X86_FLAGBASE    100
#define X86_DI          100
#define X86_SI          101
#define X86_BX          102
#define X86_DX          103
#define X86_CX          104
#define X86_AX          105
#define X86_BP          106
#define X86_IP          107
#define X86_FL          108
#define X86_SP          109
#define X86_BL          110
#define X86_DL          111
#define X86_CL          112
#define X86_AL          113
#define X86_BH          114
#define X86_DH          115
#define X86_CH          116
#define X86_AH          117
#define X86_IOPL        118
#define X86_OF          119
#define X86_DF          120
#define X86_IF          121
#define X86_TF          122
#define X86_SF          123
#define X86_ZF          124
#define X86_AF          125
#define X86_PF          126
#define X86_CF          127
#define X86_VIP         128
#define X86_VIF         129
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\ia64_dis.cpp ===
//----------------------------------------------------------------------------
//
// Disassembly portions of IA64 machine implementation.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

#include "ia64_dis.h"

// See Get/SetRegVal comments in machine.hpp.
#define RegValError Do_not_use_GetSetRegVal_in_machine_implementations
#define GetRegVal(index, val)   RegValError
#define GetRegVal32(index)      RegValError
#define GetRegVal64(index)      RegValError
#define SetRegVal(index, val)   RegValError
#define SetRegVal32(index, val) RegValError
#define SetRegVal64(index, val) RegValError

// Breakpoint insertion and removal are done on bundle boundaries.
#define IA64_BP_ALIGN 0xf
#define IA64_BP_LEN 16
// defined in IA64INST.H
ULONGLONG g_Ia64TrapInstr = BREAK_INSTR | (IA64_DEBUG_STOP_BREAKPOINT << 6);

#ifdef DW3      // defined in vdmdbg.h which is in conflict with iel.h
#undef DW3
#endif

#define DECEM    1    /* GetNextOffset() based on Intel Falcon decoder DLL */

#include "decem.h"

/*****************************************************************************/
// Temporary variables for IEL library

unsigned int IEL_t1, IEL_t2, IEL_t3, IEL_t4;
U32  IEL_tempc;
U64  IEL_et1, IEL_et2;
U128 IEL_ext1, IEL_ext2, IEL_ext3, IEL_ext4, IEL_ext5;
S128 IEL_ts1, IEL_ts2;

#define IEL_GETQW0(x) ((ULONG64)IEL_GETDW1(x)) << 32 | IEL_GETDW0(x)


/*****************************************************************************/

#ifdef    DECEM

EM_Decoder_Machine_Type machineType = EM_DECODER_CPU_P7;
EM_Decoder_Machine_Mode machineMode = EM_DECODER_MODE_EM;

BOOL fDecoderInitDone = FALSE;
BOOL fDecoderActive = FALSE;

EM_Decoder_Id    DecoderId = -1;

EM_Decoder_Id  (__cdecl *pfnEM_Decoder_open)(void);

EM_Decoder_Err (__cdecl *pfnEM_Decoder_associate_one)(const EM_Decoder_Id,
                const EM_Decoder_Inst_Id,
                const void *);

EM_Decoder_Err (__cdecl *pfnEM_Decoder_associate_check)(const EM_Decoder_Id,
                EM_Decoder_Inst_Id *);

EM_Decoder_Err (__cdecl *pfnEM_Decoder_setenv)(const EM_Decoder_Id,
                const EM_Decoder_Machine_Type,
                const EM_Decoder_Machine_Mode);

EM_Decoder_Err (__cdecl *pfnEM_Decoder_close)(const EM_Decoder_Id);

EM_Decoder_Err (__cdecl *pfnEM_Decoder_decode)(const EM_Decoder_Id,
                const unsigned char *,
                const int,
                const EM_IL,
                EM_Decoder_Info *);

EM_Decoder_Err (__cdecl *pfnEM_Decoder_inst_static_info)(const EM_Decoder_Id,
                const EM_Decoder_Inst_Id,
                EM_Decoder_Inst_Static_Info *);

const char* (__cdecl *pfnEM_Decoder_ver_str)(void);

void  (__cdecl *pfnEM_Decoder_get_version)(EM_library_version_t *);

const char* (__cdecl *pfnEM_Decoder_err_msg)(EM_Decoder_Err);

EM_Decoder_Err (__cdecl *pfnEM_Decoder_decode_bundle)(const EM_Decoder_Id,
                const unsigned char*,
                const int,
                EM_Decoder_Bundle_Info*);

BOOL 
InitDecoder (void)
{
    EM_library_version_t dec_vs;
    EM_library_version_t *dec_version;

    EM_Decoder_Err    err;

    HINSTANCE hmodDecoder;

        // load EM deocder library if it is not done yet
    if (!fDecoderInitDone) {
        fDecoderInitDone = TRUE;
        const char* c_szFailure = NULL;
        if (
            (hmodDecoder = LoadLibrary("DECEM.DLL")) &&
            (pfnEM_Decoder_open = (EM_Decoder_Id (__cdecl*)(void))
                GetProcAddress(hmodDecoder, c_szFailure = "em_decoder_open")
            ) &&
            (pfnEM_Decoder_associate_one = (EM_Decoder_Err (__cdecl*)(const EM_Decoder_Id, const EM_Decoder_Inst_Id, const void*))
                GetProcAddress(hmodDecoder, c_szFailure = "em_decoder_associate_one")
            ) &&
            (pfnEM_Decoder_associate_check = (EM_Decoder_Err (__cdecl*)(const EM_Decoder_Id, EM_Decoder_Inst_Id*))
                GetProcAddress(hmodDecoder, c_szFailure = "em_decoder_associate_check")
            ) &&
            (pfnEM_Decoder_setenv = 
                (EM_Decoder_Err (__cdecl*)(const EM_Decoder_Id, const EM_Decoder_Machine_Type, const EM_Decoder_Machine_Mode))
                GetProcAddress(hmodDecoder, c_szFailure = "em_decoder_setenv")
            ) &&
            (pfnEM_Decoder_close = (EM_Decoder_Err (__cdecl*)(const EM_Decoder_Id))
                GetProcAddress(hmodDecoder, c_szFailure = "em_decoder_close")
            ) &&
            (pfnEM_Decoder_decode = (EM_Decoder_Err (__cdecl*)(const EM_Decoder_Id, const unsigned char*, const int, const EM_IL, EM_Decoder_Info*))
                GetProcAddress(hmodDecoder, c_szFailure = "em_decoder_decode")
            ) &&
            (pfnEM_Decoder_inst_static_info = (EM_Decoder_Err (__cdecl*)(const EM_Decoder_Id, const EM_Decoder_Inst_Id, EM_Decoder_Inst_Static_Info*))
                GetProcAddress(hmodDecoder, c_szFailure = "em_decoder_inst_static_info")
            ) &&
            (pfnEM_Decoder_ver_str = (const char* (__cdecl*)(void))
                GetProcAddress(hmodDecoder, c_szFailure = "em_decoder_ver_str")
            ) &&
            (pfnEM_Decoder_get_version = (void (__cdecl*)(EM_library_version_t*))
                GetProcAddress(hmodDecoder, c_szFailure = "em_decoder_get_version")
            ) &&
            (pfnEM_Decoder_err_msg = (const char* (__cdecl*)(EM_Decoder_Err))
                GetProcAddress(hmodDecoder, c_szFailure = "em_decoder_err_msg")
            ) &&
            (pfnEM_Decoder_decode_bundle = (EM_Decoder_Err (__cdecl*)(const EM_Decoder_Id, const unsigned char*, const int, EM_Decoder_Bundle_Info*))
                GetProcAddress(hmodDecoder, c_szFailure = "em_decoder_decode_bundle")
            )
        ){
            // Display DECEM.DLL version on initial load
            dec_version = &dec_vs;
            (*pfnEM_Decoder_get_version)(dec_version);
            dprintf("Falcon EM Decoder xversion "
                    "%d.%d, api %d.%d, emdb %d.%d\n",
                    dec_version->xversion.major, dec_version->xversion.minor,
                    dec_version->api.major, dec_version->api.minor,
                    dec_version->emdb.major, dec_version->emdb.minor);

            if ((DecoderId = (*pfnEM_Decoder_open)()) == -1) 
            {
                ErrOut("em_decoder_open failed\n");
            }
            else {
                if (
                    (err = (*pfnEM_Decoder_setenv)(DecoderId, 
                                                   machineType, 
                                                   machineMode)
                    ) != EM_DECODER_NO_ERROR)
                {
                    ErrOut("em_decoder_setenv: %s\n", (*pfnEM_Decoder_err_msg)((EM_Decoder_Err)err));
                } 
                else 
                {
                    fDecoderActive = TRUE;
                } // if
            } // if
        }
        else { // error processing....
            if (!hmodDecoder) 
            {
                ErrOut("LoadLibrary(DECEM.DLL) failed.\n");
            }
            else if (c_szFailure && *c_szFailure) 
            {
                ErrOut("GetProcAddress failed for %s at DECEM.DLL\n", c_szFailure);
            }
            else {
                ErrOut("Unknown failure while initializing DECEM.DLL\n");
            } // iff
        } // if
    } // if (!fDecoderInitDone)

    return fDecoderActive;
} // InitDecoder

#endif    /* DECEM */


BOOL fDisasmInitDone = FALSE;
BOOL fDisasmActive = FALSE;

//
// CIa64Disasm - disassemble an IA64 instruction
//
typedef class CIa64Disasm 
{
public:

    typedef union SBundle 
    {
        UCHAR BundleBuffer[EM_BUNDLE_SIZE];
    } typedef_SBundle;

    static bool GetBundleAndSlot(ULONG64 uLocation, 
                                 ULONG64* pBundleLoc, 
                                 UINT* pSlotNum)
    {
        if (pSlotNum) 
        {
            switch (uLocation & 0xf) 
            {
            case 0:  *pSlotNum = 0; break;
            case 4:  *pSlotNum = 1; break;
            case 8:  *pSlotNum = 2; break;
            default: return false;
            } // switch (uLocation & 0xf)
        } 

        if (pBundleLoc) 
        {
            *pBundleLoc = uLocation & ~0xf;
        }

        return true;
    } // GetBundleAndSlot

    CIa64Disasm(Ia64MachineInfo* pMachineInit);
    
    bool 
    DecodeInstruction(ULONG64 uBundleLoc, const SBundle& r_Bundle, 
                      UINT uSlotNum, EM_Decoder_Info* pInstrInfo);

    bool Disassemble(ULONG64 uLocation, const SBundle& r_Bundle,
                     UINT* pInstrLen, char* szDisBuf, size_t nDisBufSize, 
                     bool bContext);

private:

    Ia64MachineInfo* pMachine;

    typedef class CSzBuffer 
    {
    public:
        CSzBuffer(char* szDisBuf, size_t nDisBufSize);
        void Add(const char* szSrc, size_t nStart = 0);
        void Validate();
        bool IsValid() const {return bValid;}
        size_t length() const {return nSize;}
        const char* c_str() const {return szBuf;}
    protected:
        char* szBuf;
        size_t nMaxSize;
        size_t nSize;
        bool bValid;
    } typedef_CSzBuffer;

    typedef struct SRegFileInfo 
    {
	    EM_Decoder_Regfile_Name DecoderName;
	    char* szName;
	    char* szAlias;
	    char* szMasm;
    } typedef_SRegFileInfo;

    typedef struct SRegInfo
    {
	    EM_Decoder_Reg_Name DecoderName;
	    char* szName;
	    char* szAlias;
	    char* szMasm;
    } typedef_SRegInfo;

    void 
    AddRegister(CSzBuffer* pBuf, const EM_Decoder_Reg_Info& c_RegInfo);

    void 
    AddRegister(CSzBuffer* pBuf, const EM_Decoder_Regfile_Info& c_RegInfo);

    void 
    AddRegister(CSzBuffer* pBuf, EM_Decoder_Reg_Name RegName);

    void 
    AddPredicate(CSzBuffer* pBuf, 
                 const EM_Decoder_Info& c_InstrInfo, bool bContext);

    void 
    AddMnemonic(CSzBuffer* pBuf, const EM_Decoder_Info& c_InstrInfo);


    void 
    AddOperandList(CSzBuffer* pBuf, ULONG64 uBundleLoc, 
                   UINT uSlotNum, const EM_Decoder_Info& c_InstrInfo);

    void 
    AddComment(CSzBuffer* pBuf, ULONG64 uBundleLoc, 
               UINT uSlotNum, const EM_Decoder_Info& c_InstrInfo, 
               bool bContext);

    bool 
    AddOperand(CSzBuffer* pBuf, ULONG64 uBundleLoc, UINT uSlotNum, 
               const EM_Decoder_Operand_Info& c_OperandInfo, 
               bool bSeparator);

    void 
    AddSeparator(CSzBuffer* pBuf);

    static void 
    AddString(CSzBuffer* pBuf, const char* szSrc, size_t nStart = 0)
    {
        pBuf->Add(szSrc, nStart);
    } // AddString

    void 
    AddSymAddr(CSzBuffer* pBuf, ULONG64 uAddress);

    static SRegFileInfo c_aRegFileInfo[];
    static SRegInfo c_aRegInfo[];
} typedef_CIa64Disasm;

//
// CIa64Disasm::CSzBuffer implementation
//

CIa64Disasm::CSzBuffer::CSzBuffer(char* szDisBuf, 
                                  size_t nDisBufSize)

    :szBuf(szDisBuf), nMaxSize(nDisBufSize)
{
    if (nMaxSize) 
    {
        --nMaxSize;
    }
    Validate();
} // CIa64Disasm::CSzBuffer::CSzBuffer

void 
CIa64Disasm::CSzBuffer::Validate() 
{
    nSize = 0;
    bValid = false;
    if (szBuf && nMaxSize) 
    {
        nSize = strlen(szBuf);
        bValid = true;
    } 
} // CIa64Disasm::CSzBuffer::Validate

void 
CIa64Disasm::CSzBuffer::Add(const char* szSrc, 
                            size_t nStart /*= 0*/)
{
    if (!bValid || (nSize >= nMaxSize)) 
    {
        return;
    }

    if (nSize < nStart) 
    {
        size_t nSpaceSize = nStart - nSize;
        memset(szBuf + nSize, ' ', nSpaceSize);
        szBuf[nStart] = char(0);
        nSize = nStart;
    } 

    if (!(szSrc && *szSrc)) 
    {
        return;
    }

    strncat(szBuf, szSrc,  nMaxSize - nSize);
    szBuf[nMaxSize] = char(0);
    nSize += strlen(szBuf + nSize);
} // CIa64Disasm::CSzBuffer::Add

//
// CIa64Disasm implementation
//

CIa64Disasm::CIa64Disasm(Ia64MachineInfo* pMachineInit)
    :pMachine(pMachineInit)
{
    InitDecoder();
} // CIa64Disasm::CIa64Disasm

bool 
CIa64Disasm::DecodeInstruction(ULONG64 uBundleLoc, 
                               const SBundle& r_Bundle, 
                               UINT uSlot, 
                               EM_Decoder_Info* pInstrInfo)
{
    if ((uBundleLoc & 0xf) || (uSlot > 2) || !pInstrInfo) 
    {
        return false;
    }

    uBundleLoc += uSlot;

    U64 Location;
    //IEL_ZERO(DecLocation);
    IEL_ASSIGNU(Location, *(U64*)&uBundleLoc);
    
    EM_Decoder_Err Error = pfnEM_Decoder_decode(DecoderId, 
                                                (unsigned char*)&r_Bundle, 
                                                sizeof(r_Bundle), Location, 
                                                pInstrInfo);

    return ((Error == EM_DECODER_NO_ERROR) && (pInstrInfo->inst != EM_IGNOP));
} // CIa64Disasm::DecodeInstruction


bool 
CIa64Disasm::Disassemble(ULONG64 uLocation,
                         const CIa64Disasm::SBundle& r_Bundle, 
                         UINT* pInstrLen,
                         char* szDisBuf,
                         size_t nDisBufSize,
                         bool bContext)
{
    if (!InitDecoder()) 
    {
        ErrOut("EM decoder library(DECEM.DLL) not active\n");
        return false;
    } 
    
    ULONG64 uBundleLoc;
    UINT uSlotNum;
    if (!GetBundleAndSlot(uLocation, &uBundleLoc, &uSlotNum)) 
    {
        return false;
    }

    CSzBuffer Buf(szDisBuf, nDisBufSize);
        
    EM_Decoder_Info InstrInfo;
    if (!DecodeInstruction(uBundleLoc, r_Bundle, uSlotNum, &InstrInfo)) 
    {
        EM_Decoder_static_info_t StaticInfo; 
        ZeroMemory(&StaticInfo, sizeof(StaticInfo));
        StaticInfo.mnemonic = "???";
        InstrInfo.static_info = &StaticInfo;
        AddMnemonic(&Buf, InstrInfo);
        return true;
    } // if

    AddPredicate(&Buf, InstrInfo, bContext);
    AddMnemonic(&Buf, InstrInfo);
    AddString(&Buf, " ");
    AddOperandList(&Buf, uBundleLoc, uSlotNum, InstrInfo);

    if (EM_DECODER_CYCLE_BREAK((&InstrInfo))) 
    {
        AddString(&Buf, " ;;");
    } 

    AddComment(&Buf, uBundleLoc, uSlotNum, InstrInfo, bContext);

    if (pInstrLen) 
    {
        *pInstrLen = InstrInfo.size;
    }

    return true;
} // CIa64Disasm::Disassemble

void 
CIa64Disasm::AddRegister(CSzBuffer* pBuf,
                         const EM_Decoder_Reg_Info& c_RegInfo)
{
    AddString(pBuf, c_aRegInfo[c_RegInfo.name].szAlias);
} 

void 
CIa64Disasm::AddRegister(CSzBuffer* pBuf,
                         const EM_Decoder_Regfile_Info& c_RegFileInfo)
{
    AddString(pBuf, c_aRegFileInfo[c_RegFileInfo.index.name].szName);
} 

void 
CIa64Disasm::AddRegister(CSzBuffer* pBuf,
                         EM_Decoder_Reg_Name RegName)
{
    AddString(pBuf, c_aRegInfo[RegName].szAlias);
} // CIa64Disasm::AddRegister(CSzBuffer&, EM_Decoder_Reg_Name)

void 
CIa64Disasm::AddPredicate(CSzBuffer* pBuf,
                          const EM_Decoder_Info& c_InstrInfo,
                          bool bContext)
{
    if (!(c_InstrInfo.pred.valid && c_InstrInfo.pred.value)) 
    {
        return;
    }

    AddString(pBuf, "(");

    AddRegister(pBuf, c_InstrInfo.pred);

    const char* szClose;
    if (bContext)
    {
        if ((pMachine->GetReg64(PREDS) >> c_InstrInfo.pred.value) & 0x1) 
        {
            szClose = "=1)"; 
        } 
        else 
        {
            szClose = "=0)"; 
        } // iff
    }
    else 
    {
        szClose = ")";
    } // iff
    AddString(pBuf, szClose);
} // CIa64Disasm::AddPredicate

void 
CIa64Disasm::AddMnemonic(CSzBuffer* pBuf,
                         const EM_Decoder_Info& c_InstrInfo)
{
    AddString(pBuf, c_InstrInfo.static_info->mnemonic, 7);
    AddString(pBuf, NULL, 13);
} // CIa64Disasm::AddMnemonic

void 
CIa64Disasm::AddOperandList(CSzBuffer* pBuf,
                            ULONG64 uBundleLoc,
                            UINT uSlotNum,
                            const EM_Decoder_Info& c_InstrInfo)
{
    bool bAdd = false;

    bAdd |= AddOperand(pBuf, uBundleLoc, uSlotNum, c_InstrInfo.dst1, false);
    bAdd |= AddOperand(pBuf, uBundleLoc, uSlotNum, c_InstrInfo.dst2, bAdd);

    if ((c_InstrInfo.dst1.type != EM_DECODER_NO_OPER) &&
        (c_InstrInfo.src1.type != EM_DECODER_NO_OPER))
    {
        AddString(pBuf, "=");
        bAdd = false;
    } 

    bAdd = AddOperand(pBuf, uBundleLoc, uSlotNum, c_InstrInfo.src1, bAdd);
    bAdd = AddOperand(pBuf, uBundleLoc, uSlotNum, c_InstrInfo.src2, bAdd);
    bAdd = AddOperand(pBuf, uBundleLoc, uSlotNum, c_InstrInfo.src3, bAdd);
    bAdd = AddOperand(pBuf, uBundleLoc, uSlotNum, c_InstrInfo.src4, bAdd);
    bAdd = AddOperand(pBuf, uBundleLoc, uSlotNum, c_InstrInfo.src5, bAdd);
} // CIa64Disasm::AddOperandList

void 
CIa64Disasm::AddComment(CSzBuffer* pBuf, 
                        ULONG64 uBundleLoc, 
                        UINT uSlotNum, 
                        const EM_Decoder_Info& c_InstrInfo,
                        bool bContext)
{
    if (bContext) 
    {
        char szComment[128]; 
        *szComment = 0;
        CSzBuffer Comment(szComment, sizeof(szComment) / sizeof(*szComment));

        if (
            !strncmp(c_InstrInfo.static_info->mnemonic, "br.", 3) &&
            (c_InstrInfo.src1.reg_info.type == EM_DECODER_BR_REG))    
        {
            ULONG64 uTargetAddr = 
                pMachine->GetReg64(c_InstrInfo.src1.reg_info.value + BRRP);

            Comment.Add(" // ");
            AddSymAddr(&Comment, uTargetAddr);

            if ((uTargetAddr == IA64_MM_EPC_VA + 0x20) &&
                !IS_KERNEL_TARGET())
            {
                Comment.Add(" system call");
            }
        }

        if (Comment.length())
        {
            long iCommentStart = long(g_OutputWidth) - Comment.length() - 18;
            AddString(pBuf, Comment.c_str(), 
                      (iCommentStart > 0) ? size_t(iCommentStart) : 0);
        }
    }
} // CIa64Disasm::AddComment

bool 
CIa64Disasm::AddOperand(CSzBuffer* pBuf,
                        ULONG64 uBundleLoc,
                        UINT uSlotNum,
                        const EM_Decoder_Operand_Info& c_OperandInfo,
                        bool bSeparator)
{
    switch (c_OperandInfo.type) 
    {
    case EM_DECODER_REGISTER: 
    {  
        if (bSeparator) 
        {
            AddSeparator(pBuf); 
        }
        AddRegister(pBuf, c_OperandInfo.reg_info);
    } // case EM_DECODER_REGISTER
    break;
        
    case EM_DECODER_REGFILE: 
    {
        if (bSeparator) 
        {
            AddSeparator(pBuf); 
        }
        AddString(pBuf,
                  c_aRegFileInfo[c_OperandInfo.regfile_info.name].szName);
        AddString(pBuf, "[");
        AddRegister(pBuf, c_OperandInfo.regfile_info.index.name);
        AddString(pBuf, "]");
    } // case EM_DECODER_REGFILE
    break;
    
    case EM_DECODER_IMMEDIATE: 
    {
        if (bSeparator) 
        {
            AddSeparator(pBuf); 
        }

        if (EM_DECODER_OPER_IMM_REG((&c_OperandInfo))) 
        {
            EM_Decoder_Reg_Name RegName;
        
            if (EM_DECODER_OPER_IMM_FREG((&c_OperandInfo))) 
            {
                RegName = EM_DECODER_REG_F0;
            }
            else
            {
                DBG_ASSERT(EM_DECODER_OPER_IMM_IREG((&c_OperandInfo)));
                
                RegName = EM_DECODER_REG_R0;
            }
        
            RegName = EM_Decoder_Reg_Name(
                UINT(RegName) + IEL_GETDW0(c_OperandInfo.imm_info.val64));

            AddRegister(pBuf, RegName);
        }
        else 
        {
            U64 ImmVal = c_OperandInfo.imm_info.val64;

            ULONG64 uImmVal = IEL_GETQW0(ImmVal);

            if (c_OperandInfo.imm_info.size == 64) 
            {
                AddSymAddr(pBuf, uImmVal);
            }
            else 
            {
                AddString(pBuf, FormatDisp64(uImmVal));
            }
        }
    }
    break;
    
    case EM_DECODER_MEMORY: 
    {
        if (bSeparator) 
        {
            AddSeparator(pBuf); 
        }
        AddString(pBuf, "[");
        AddRegister(pBuf, c_OperandInfo.mem_info.mem_base.name);
        AddString(pBuf, "]");
    } // case EM_DECODER_MEMORY
    break;
    
    case EM_DECODER_IP_RELATIVE: {
        if (bSeparator) 
        {
            AddSeparator(pBuf); 
        }

        ULONG64 uOffset = IEL_GETQW0(c_OperandInfo.imm_info.val64);
        if (uOffset) 
        {
            uOffset += uBundleLoc;
            AddSymAddr(pBuf, uOffset);
        }
        else 
        {
            AddString(pBuf, "+0");
        } // iff
    } // case EM_DECODER_IP_RELATIVE
    break;

    default: {
        return false;
    } // default
    } // switch (c_OperandInfo.type)

    return true;
} // CIa64Disasm::AddOperand

void 
CIa64Disasm::AddSeparator(CSzBuffer* pBuf)
{
    AddString(pBuf, ", ");
} // CIa64Disasm::AddSeparator

void 
CIa64Disasm::AddSymAddr(CSzBuffer* pBuf,
                        ULONG64 uAddress)
{
    char szSymbol[MAX_SYMBOL_LEN]; 
    ULONG64 uDisplacement = 0;

    GetSymbolStdCall(uAddress, szSymbol, sizeof(szSymbol),
                     &uDisplacement, NULL);
    szSymbol[MAX_SYMBOL_LEN - 1] = char(0);

    if (*szSymbol) 
    {
        AddString(pBuf, szSymbol);
        AddString(pBuf, "+");
        AddString(pBuf, FormatDisp64(uDisplacement));
        AddString(pBuf, " (");
        AddString(pBuf, FormatAddr64(uAddress));
        AddString(pBuf, ")");
    }
    else 
    {
        AddString(pBuf, FormatAddr64(uAddress));
    } // iff
} // CIa64Disasm::AddSymAddr

CIa64Disasm::SRegFileInfo CIa64Disasm::c_aRegFileInfo[] = {
    {EM_DECODER_NO_REGFILE,    "no",    "no",    "no"   },
    {EM_DECODER_REGFILE_PMC,   "pmc",   "pmc",   "pmc"  },
    {EM_DECODER_REGFILE_PMD,   "pmd",   "pmd",   "pmd"  },
    {EM_DECODER_REGFILE_PKR,   "pkr",   "pkr",   "pkr"  },
    {EM_DECODER_REGFILE_RR,    "rr",    "rr",    "rr"   },
    {EM_DECODER_REGFILE_IBR,   "ibr",   "ibr",   "ibr"  },
    {EM_DECODER_REGFILE_DBR,   "dbr",   "dbr",   "dbr"  },
    {EM_DECODER_REGFILE_ITR,   "itr",   "itr",   "itr"  },
    {EM_DECODER_REGFILE_DTR,   "dtr",   "dtr",   "dtr"  },
    {EM_DECODER_REGFILE_MSR,   "msr",   "msr",   "msr"  },
    {EM_DECODER_REGFILE_CPUID, "cpuid", "cpuid", "cpuid"},
    {EM_DECODER_REGFILE_LAST,  "last",  "last",  "last" }
}; // CIa64Disasm::c_aRegFileInfo

CIa64Disasm::SRegInfo CIa64Disasm::c_aRegInfo[] = {
    {EM_DECODER_NO_REG, "%mm", "%mm", "mm"},

    {EM_DECODER_NO_REG, "%error", "%error", "error"}, 
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},

    {EM_DECODER_REG_R0,   "r0",   "r0",   "r0"  },
    {EM_DECODER_REG_R1,   "r1",   "gp",   "gp"  },
    {EM_DECODER_REG_R2,   "r2",   "r2",   "r2"  },
    {EM_DECODER_REG_R3,   "r3",   "r3",   "r3"  },
    {EM_DECODER_REG_R4,   "r4",   "r4",   "r4"  },
    {EM_DECODER_REG_R5,   "r5",   "r5",   "r5"  },
    {EM_DECODER_REG_R6,   "r6",   "r6",   "r6"  },
    {EM_DECODER_REG_R7,   "r7",   "r7",   "r7"  },
    {EM_DECODER_REG_R8,   "r8",   "ret0", "ret0"},
    {EM_DECODER_REG_R9,   "r9",   "ret1", "ret1"},
    {EM_DECODER_REG_R10,  "r10",  "ret2", "ret2"},
    {EM_DECODER_REG_R11,  "r11",  "ret3", "ret3"},
    {EM_DECODER_REG_R12,  "r12",  "sp",   "sp"  },
    {EM_DECODER_REG_R13,  "r13",  "r13",  "r13" },
    {EM_DECODER_REG_R14,  "r14",  "r14",  "r14" },
    {EM_DECODER_REG_R15,  "r15",  "r15",  "r15" },
    {EM_DECODER_REG_R16,  "r16",  "r16",  "r16" },
    {EM_DECODER_REG_R17,  "r17",  "r17",  "r17" },
    {EM_DECODER_REG_R18,  "r18",  "r18",  "r18" },
    {EM_DECODER_REG_R19,  "r19",  "r19",  "r19" },
    {EM_DECODER_REG_R20,  "r20",  "r20",  "r20" },
    {EM_DECODER_REG_R21,  "r21",  "r21",  "r21" },
    {EM_DECODER_REG_R22,  "r22",  "r22",  "r22" },
    {EM_DECODER_REG_R23,  "r23",  "r23",  "r23" },
    {EM_DECODER_REG_R24,  "r24",  "r24",  "r24" },
    {EM_DECODER_REG_R25,  "r25",  "r25",  "r25" },
    {EM_DECODER_REG_R26,  "r26",  "r26",  "r26" },
    {EM_DECODER_REG_R27,  "r27",  "r27",  "r27" },
    {EM_DECODER_REG_R28,  "r28",  "r28",  "r28" },
    {EM_DECODER_REG_R29,  "r29",  "r29",  "r29" },
    {EM_DECODER_REG_R30,  "r30",  "r30",  "r30" },
    {EM_DECODER_REG_R31,  "r31",  "r31",  "r31" },
    {EM_DECODER_REG_R32,  "r32",  "r32",  "r32" },
    {EM_DECODER_REG_R33,  "r33",  "r33",  "r33" },
    {EM_DECODER_REG_R34,  "r34",  "r34",  "r34" },
    {EM_DECODER_REG_R35,  "r35",  "r35",  "r35" },
    {EM_DECODER_REG_R36,  "r36",  "r36",  "r36" },
    {EM_DECODER_REG_R37,  "r37",  "r37",  "r37" },
    {EM_DECODER_REG_R38,  "r38",  "r38",  "r38" },
    {EM_DECODER_REG_R39,  "r39",  "r39",  "r39" },
    {EM_DECODER_REG_R40,  "r40",  "r40",  "r40" },
    {EM_DECODER_REG_R41,  "r41",  "r41",  "r41" },
    {EM_DECODER_REG_R42,  "r42",  "r42",  "r42" },
    {EM_DECODER_REG_R43,  "r43",  "r43",  "r43" },
    {EM_DECODER_REG_R44,  "r44",  "r44",  "r44" },
    {EM_DECODER_REG_R45,  "r45",  "r45",  "r45" },
    {EM_DECODER_REG_R46,  "r46",  "r46",  "r46" },
    {EM_DECODER_REG_R47,  "r47",  "r47",  "r47" },
    {EM_DECODER_REG_R48,  "r48",  "r48",  "r48" },
    {EM_DECODER_REG_R49,  "r49",  "r49",  "r49" },
    {EM_DECODER_REG_R50,  "r50",  "r50",  "r50" },
    {EM_DECODER_REG_R51,  "r51",  "r51",  "r51" },
    {EM_DECODER_REG_R52,  "r52",  "r52",  "r52" },
    {EM_DECODER_REG_R53,  "r53",  "r53",  "r53" },
    {EM_DECODER_REG_R54,  "r54",  "r54",  "r54" },
    {EM_DECODER_REG_R55,  "r55",  "r55",  "r55" },
    {EM_DECODER_REG_R56,  "r56",  "r56",  "r56" },
    {EM_DECODER_REG_R57,  "r57",  "r57",  "r57" },
    {EM_DECODER_REG_R58,  "r58",  "r58",  "r58" },
    {EM_DECODER_REG_R59,  "r59",  "r59",  "r59" },
    {EM_DECODER_REG_R60,  "r60",  "r60",  "r60" },
    {EM_DECODER_REG_R61,  "r61",  "r61",  "r61" },
    {EM_DECODER_REG_R62,  "r62",  "r62",  "r62" },
    {EM_DECODER_REG_R63,  "r63",  "r63",  "r63" },
    {EM_DECODER_REG_R64,  "r64",  "r64",  "r64" },
    {EM_DECODER_REG_R65,  "r65",  "r65",  "r65" },
    {EM_DECODER_REG_R66,  "r66",  "r66",  "r66" },
    {EM_DECODER_REG_R67,  "r67",  "r67",  "r67" },
    {EM_DECODER_REG_R68,  "r68",  "r68",  "r68" },
    {EM_DECODER_REG_R69,  "r69",  "r69",  "r69" },
    {EM_DECODER_REG_R70,  "r70",  "r70",  "r70" },
    {EM_DECODER_REG_R71,  "r71",  "r71",  "r71" },
    {EM_DECODER_REG_R72,  "r72",  "r72",  "r72" },
    {EM_DECODER_REG_R73,  "r73",  "r73",  "r73" },
    {EM_DECODER_REG_R74,  "r74",  "r74",  "r74" },
    {EM_DECODER_REG_R75,  "r75",  "r75",  "r75" },
    {EM_DECODER_REG_R76,  "r76",  "r76",  "r76" },
    {EM_DECODER_REG_R77,  "r77",  "r77",  "r77" },
    {EM_DECODER_REG_R78,  "r78",  "r78",  "r78" },
    {EM_DECODER_REG_R79,  "r79",  "r79",  "r79" },
    {EM_DECODER_REG_R80,  "r80",  "r80",  "r80" },
    {EM_DECODER_REG_R81,  "r81",  "r81",  "r81" },
    {EM_DECODER_REG_R82,  "r82",  "r82",  "r82" },
    {EM_DECODER_REG_R83,  "r83",  "r83",  "r83" },
    {EM_DECODER_REG_R84,  "r84",  "r84",  "r84" },
    {EM_DECODER_REG_R85,  "r85",  "r85",  "r85" },
    {EM_DECODER_REG_R86,  "r86",  "r86",  "r86" },
    {EM_DECODER_REG_R87,  "r87",  "r87",  "r87" },
    {EM_DECODER_REG_R88,  "r88",  "r88",  "r88" },
    {EM_DECODER_REG_R89,  "r89",  "r89",  "r89" },
    {EM_DECODER_REG_R90,  "r90",  "r90",  "r90" },
    {EM_DECODER_REG_R91,  "r91",  "r91",  "r91" },
    {EM_DECODER_REG_R92,  "r92",  "r92",  "r92" },
    {EM_DECODER_REG_R93,  "r93",  "r93",  "r93" },
    {EM_DECODER_REG_R94,  "r94",  "r94",  "r94" },
    {EM_DECODER_REG_R95,  "r95",  "r95",  "r95" },
    {EM_DECODER_REG_R96,  "r96",  "r96",  "r96" },
    {EM_DECODER_REG_R97,  "r97",  "r97",  "r97" },
    {EM_DECODER_REG_R98,  "r98",  "r98",  "r98" },
    {EM_DECODER_REG_R99,  "r99",  "r99",  "r99" },
    {EM_DECODER_REG_R100, "r100", "r100", "r100"},
    {EM_DECODER_REG_R101, "r101", "r101", "r101"},
    {EM_DECODER_REG_R102, "r102", "r102", "r102"},
    {EM_DECODER_REG_R103, "r103", "r103", "r103"},
    {EM_DECODER_REG_R104, "r104", "r104", "r104"},
    {EM_DECODER_REG_R105, "r105", "r105", "r105"},
    {EM_DECODER_REG_R106, "r106", "r106", "r106"},
    {EM_DECODER_REG_R107, "r107", "r107", "r107"},
    {EM_DECODER_REG_R108, "r108", "r108", "r108"},
    {EM_DECODER_REG_R109, "r109", "r109", "r109"},
    {EM_DECODER_REG_R110, "r110", "r110", "r110"},
    {EM_DECODER_REG_R111, "r111", "r111", "r111"},
    {EM_DECODER_REG_R112, "r112", "r112", "r112"},
    {EM_DECODER_REG_R113, "r113", "r113", "r113"},
    {EM_DECODER_REG_R114, "r114", "r114", "r114"},
    {EM_DECODER_REG_R115, "r115", "r115", "r115"},
    {EM_DECODER_REG_R116, "r116", "r116", "r116"},
    {EM_DECODER_REG_R117, "r117", "r117", "r117"},
    {EM_DECODER_REG_R118, "r118", "r118", "r118"},
    {EM_DECODER_REG_R119, "r119", "r119", "r119"},
    {EM_DECODER_REG_R120, "r120", "r120", "r120"},
    {EM_DECODER_REG_R121, "r121", "r121", "r121"},
    {EM_DECODER_REG_R122, "r122", "r122", "r122"},
    {EM_DECODER_REG_R123, "r123", "r123", "r123"},
    {EM_DECODER_REG_R124, "r124", "r124", "r124"},
    {EM_DECODER_REG_R125, "r125", "r125", "r125"},
    {EM_DECODER_REG_R126, "r126", "r126", "r126"},
    {EM_DECODER_REG_R127, "r127", "r127", "r127"},

    {EM_DECODER_REG_F0,   "f0",   "f0",    "f0"   },
    {EM_DECODER_REG_F1,   "f1",   "f1",    "f1"   },
    {EM_DECODER_REG_F2,   "f2",   "f2",    "f2"   },
    {EM_DECODER_REG_F3,   "f3",   "f3",    "f3"   },
    {EM_DECODER_REG_F4,   "f4",   "f4",    "f4"   },
    {EM_DECODER_REG_F5,   "f5",   "f5",    "f5"   },
    {EM_DECODER_REG_F6,   "f6",   "f6",    "f6"   },
    {EM_DECODER_REG_F7,   "f7",   "f7",    "f7"   },
    {EM_DECODER_REG_F8,   "f8",   "farg0", "fret0"},
    {EM_DECODER_REG_F9,   "f9",   "farg1", "fret1"},
    {EM_DECODER_REG_F10,  "f10",  "farg2", "fret2"},
    {EM_DECODER_REG_F11,  "f11",  "farg3", "fret3"},
    {EM_DECODER_REG_F12,  "f12",  "farg4", "fret4"},
    {EM_DECODER_REG_F13,  "f13",  "farg5", "fret5"},
    {EM_DECODER_REG_F14,  "f14",  "farg6", "fret6"},
    {EM_DECODER_REG_F15,  "f15",  "farg7", "fret7"},
    {EM_DECODER_REG_F16,  "f16",  "f16",   "f16"  },
    {EM_DECODER_REG_F17,  "f17",  "f17",   "f17"  },
    {EM_DECODER_REG_F18,  "f18",  "f18",   "f18"  },
    {EM_DECODER_REG_F19,  "f19",  "f19",   "f19"  },
    {EM_DECODER_REG_F20,  "f20",  "f20",   "f20"  },
    {EM_DECODER_REG_F21,  "f21",  "f21",   "f21"  },
    {EM_DECODER_REG_F22,  "f22",  "f22",   "f22"  },
    {EM_DECODER_REG_F23,  "f23",  "f23",   "f23"  },
    {EM_DECODER_REG_F24,  "f24",  "f24",   "f24"  },
    {EM_DECODER_REG_F25,  "f25",  "f25",   "f25"  },
    {EM_DECODER_REG_F26,  "f26",  "f26",   "f26"  },
    {EM_DECODER_REG_F27,  "f27",  "f27",   "f27"  },
    {EM_DECODER_REG_F28,  "f28",  "f28",   "f28"  },
    {EM_DECODER_REG_F29,  "f29",  "f29",   "f29"  },
    {EM_DECODER_REG_F30,  "f30",  "f30",   "f30"  },
    {EM_DECODER_REG_F31,  "f31",  "f31",   "f31"  },
    {EM_DECODER_REG_F32,  "f32",  "f32",   "f32"  },
    {EM_DECODER_REG_F33,  "f33",  "f33",   "f33"  },
    {EM_DECODER_REG_F34,  "f34",  "f34",   "f34"  },
    {EM_DECODER_REG_F35,  "f35",  "f35",   "f35"  },
    {EM_DECODER_REG_F36,  "f36",  "f36",   "f36"  },
    {EM_DECODER_REG_F37,  "f37",  "f37",   "f37"  },
    {EM_DECODER_REG_F38,  "f38",  "f38",   "f38"  },
    {EM_DECODER_REG_F39,  "f39",  "f39",   "f39"  },
    {EM_DECODER_REG_F40,  "f40",  "f40",   "f40"  },
    {EM_DECODER_REG_F41,  "f41",  "f41",   "f41"  },
    {EM_DECODER_REG_F42,  "f42",  "f42",   "f42"  },
    {EM_DECODER_REG_F43,  "f43",  "f43",   "f43"  },
    {EM_DECODER_REG_F44,  "f44",  "f44",   "f44"  },
    {EM_DECODER_REG_F45,  "f45",  "f45",   "f45"  },
    {EM_DECODER_REG_F46,  "f46",  "f46",   "f46"  },
    {EM_DECODER_REG_F47,  "f47",  "f47",   "f47"  },
    {EM_DECODER_REG_F48,  "f48",  "f48",   "f48"  },
    {EM_DECODER_REG_F49,  "f49",  "f49",   "f49"  },
    {EM_DECODER_REG_F50,  "f50",  "f50",   "f50"  },
    {EM_DECODER_REG_F51,  "f51",  "f51",   "f51"  },
    {EM_DECODER_REG_F52,  "f52",  "f52",   "f52"  },
    {EM_DECODER_REG_F53,  "f53",  "f53",   "f53"  },
    {EM_DECODER_REG_F54,  "f54",  "f54",   "f54"  },
    {EM_DECODER_REG_F55,  "f55",  "f55",   "f55"  },
    {EM_DECODER_REG_F56,  "f56",  "f56",   "f56"  },
    {EM_DECODER_REG_F57,  "f57",  "f57",   "f57"  },
    {EM_DECODER_REG_F58,  "f58",  "f58",   "f58"  },
    {EM_DECODER_REG_F59,  "f59",  "f59",   "f59"  },
    {EM_DECODER_REG_F60,  "f60",  "f60",   "f60"  },
    {EM_DECODER_REG_F61,  "f61",  "f61",   "f61"  },
    {EM_DECODER_REG_F62,  "f62",  "f62",   "f62"  },
    {EM_DECODER_REG_F63,  "f63",  "f63",   "f63"  },
    {EM_DECODER_REG_F64,  "f64",  "f64",   "f64"  },
    {EM_DECODER_REG_F65,  "f65",  "f65",   "f65"  },
    {EM_DECODER_REG_F66,  "f66",  "f66",   "f66"  },
    {EM_DECODER_REG_F67,  "f67",  "f67",   "f67"  },
    {EM_DECODER_REG_F68,  "f68",  "f68",   "f68"  },
    {EM_DECODER_REG_F69,  "f69",  "f69",   "f69"  },
    {EM_DECODER_REG_F70,  "f70",  "f70",   "f70"  },
    {EM_DECODER_REG_F71,  "f71",  "f71",   "f71"  },
    {EM_DECODER_REG_F72,  "f72",  "f72",   "f72"  },
    {EM_DECODER_REG_F73,  "f73",  "f73",   "f73"  },
    {EM_DECODER_REG_F74,  "f74",  "f74",   "f74"  },
    {EM_DECODER_REG_F75,  "f75",  "f75",   "f75"  },
    {EM_DECODER_REG_F76,  "f76",  "f76",   "f76"  },
    {EM_DECODER_REG_F77,  "f77",  "f77",   "f77"  },
    {EM_DECODER_REG_F78,  "f78",  "f78",   "f78"  },
    {EM_DECODER_REG_F79,  "f79",  "f79",   "f79"  },
    {EM_DECODER_REG_F80,  "f80",  "f80",   "f80"  },
    {EM_DECODER_REG_F81,  "f81",  "f81",   "f81"  },
    {EM_DECODER_REG_F82,  "f82",  "f82",   "f82"  },
    {EM_DECODER_REG_F83,  "f83",  "f83",   "f83"  },
    {EM_DECODER_REG_F84,  "f84",  "f84",   "f84"  },
    {EM_DECODER_REG_F85,  "f85",  "f85",   "f85"  },
    {EM_DECODER_REG_F86,  "f86",  "f86",   "f86"  },
    {EM_DECODER_REG_F87,  "f87",  "f87",   "f87"  },
    {EM_DECODER_REG_F88,  "f88",  "f88",   "f88"  },
    {EM_DECODER_REG_F89,  "f89",  "f89",   "f89"  },
    {EM_DECODER_REG_F90,  "f90",  "f90",   "f90"  },
    {EM_DECODER_REG_F91,  "f91",  "f91",   "f91"  },
    {EM_DECODER_REG_F92,  "f92",  "f92",   "f92"  },
    {EM_DECODER_REG_F93,  "f93",  "f93",   "f93"  },
    {EM_DECODER_REG_F94,  "f94",  "f94",   "f94"  },
    {EM_DECODER_REG_F95,  "f95",  "f95",   "f95"  },
    {EM_DECODER_REG_F96,  "f96",  "f96",   "f96"  },
    {EM_DECODER_REG_F97,  "f97",  "f97",   "f97"  },
    {EM_DECODER_REG_F98,  "f98",  "f98",   "f98"  },
    {EM_DECODER_REG_F99,  "f99",  "f99",   "f99"  },
    {EM_DECODER_REG_F100, "f100", "f100",  "f100" },
    {EM_DECODER_REG_F101, "f101", "f101",  "f101" },
    {EM_DECODER_REG_F102, "f102", "f102",  "f102" },
    {EM_DECODER_REG_F103, "f103", "f103",  "f103" },
    {EM_DECODER_REG_F104, "f104", "f104",  "f104" },
    {EM_DECODER_REG_F105, "f105", "f105",  "f105" },
    {EM_DECODER_REG_F106, "f106", "f106",  "f106" },
    {EM_DECODER_REG_F107, "f107", "f107",  "f107" },
    {EM_DECODER_REG_F108, "f108", "f108",  "f108" },
    {EM_DECODER_REG_F109, "f109", "f109",  "f109" },
    {EM_DECODER_REG_F110, "f110", "f110",  "f110" },
    {EM_DECODER_REG_F111, "f111", "f111",  "f111" },
    {EM_DECODER_REG_F112, "f112", "f112",  "f112" },
    {EM_DECODER_REG_F113, "f113", "f113",  "f113" },
    {EM_DECODER_REG_F114, "f114", "f114",  "f114" },
    {EM_DECODER_REG_F115, "f115", "f115",  "f115" },
    {EM_DECODER_REG_F116, "f116", "f116",  "f116" },
    {EM_DECODER_REG_F117, "f117", "f117",  "f117" },
    {EM_DECODER_REG_F118, "f118", "f118",  "f118" },
    {EM_DECODER_REG_F119, "f119", "f119",  "f119" },
    {EM_DECODER_REG_F120, "f120", "f120",  "f120" },
    {EM_DECODER_REG_F121, "f121", "f121",  "f121" },
    {EM_DECODER_REG_F122, "f122", "f122",  "f122" },
    {EM_DECODER_REG_F123, "f123", "f123",  "f123" },
    {EM_DECODER_REG_F124, "f124", "f124",  "f124" },
    {EM_DECODER_REG_F125, "f125", "f125",  "f125" },
    {EM_DECODER_REG_F126, "f126", "f126",  "f126" },
    {EM_DECODER_REG_F127, "f127", "f127",  "f127" },

    {EM_DECODER_REG_AR0,   "ar0",   "ar.k0",       "ar.kr0"     },
    {EM_DECODER_REG_AR1,   "ar1",   "ar.k1",       "ar.kr1"     },
    {EM_DECODER_REG_AR2,   "ar2",   "ar.k2",       "ar.kr2"     },
    {EM_DECODER_REG_AR3,   "ar3",   "ar.k3",       "ar.kr3"     },
    {EM_DECODER_REG_AR4,   "ar4",   "ar.k4",       "ar.kr4"     },
    {EM_DECODER_REG_AR5,   "ar5",   "ar.k5",       "ar.kr5"     },
    {EM_DECODER_REG_AR6,   "ar6",   "ar.k6",       "ar.kr6"     },
    {EM_DECODER_REG_AR7,   "ar7",   "ar.k7",       "ar.kr7"     },
    {EM_DECODER_REG_AR8,   "ar8",   "ar8",         "ar8-res"    },
    {EM_DECODER_REG_AR9,   "ar9",   "ar9",         "ar9-res"    },
    {EM_DECODER_REG_AR10,  "ar10",  "ar10",        "ar10-res"   },
    {EM_DECODER_REG_AR11,  "ar11",  "ar11",        "ar11-res"   },
    {EM_DECODER_REG_AR12,  "ar12",  "ar12",        "ar12-res"   },
    {EM_DECODER_REG_AR13,  "ar13",  "ar13",        "ar13-res"   },
    {EM_DECODER_REG_AR14,  "ar14",  "ar14",        "ar14-res"   },
    {EM_DECODER_REG_AR15,  "ar15",  "ar15",        "ar15-res"   },
    {EM_DECODER_REG_AR16,  "ar16",  "ar.rsc",      "ar.rsc"     },
    {EM_DECODER_REG_AR17,  "ar17",  "ar.bsp",      "ar.bsp"     },
    {EM_DECODER_REG_AR18,  "ar18",  "ar.bspstore", "ar.bspstore"},
    {EM_DECODER_REG_AR19,  "ar19",  "ar.rnat",     "ar.rnat"    },
    {EM_DECODER_REG_AR20,  "ar20",  "ar20",        "ar20-res"   },
    {EM_DECODER_REG_AR21,  "ar21",  "ar.fcr",      "ar21-ia32"  },
    {EM_DECODER_REG_AR22,  "ar22",  "ar22",        "ar22-res"   },
    {EM_DECODER_REG_AR23,  "ar23",  "ar23",        "ar23-res"   },
    {EM_DECODER_REG_AR24,  "ar24",  "ar.eflag",    "ar24-ia32"  },
    {EM_DECODER_REG_AR25,  "ar25",  "ar.csd",      "ar25-ia32"  },
    {EM_DECODER_REG_AR26,  "ar26",  "ar.ssd",      "ar26-ia32"  },
    {EM_DECODER_REG_AR27,  "ar27",  "ar.cflg",     "ar27-ia32"  },
    {EM_DECODER_REG_AR28,  "ar28",  "ar.fsr",      "ar28-ia32"  },
    {EM_DECODER_REG_AR29,  "ar29",  "ar.fir",      "ar29-ia32"  },
    {EM_DECODER_REG_AR30,  "ar30",  "ar.fdr",      "ar30-ia32"  },
    {EM_DECODER_REG_AR31,  "ar31",  "ar31",        "ar31-res"   },
    {EM_DECODER_REG_AR32,  "ar32",  "ar.ccv",      "ar.ccv"     },
    {EM_DECODER_REG_AR33,  "ar33",  "ar33",        "ar33-res"   },
    {EM_DECODER_REG_AR34,  "ar34",  "ar34",        "ar34-res"   },
    {EM_DECODER_REG_AR35,  "ar35",  "ar35",        "ar35-res"   },
    {EM_DECODER_REG_AR36,  "ar36",  "ar.unat",     "ar.unat"    },
    {EM_DECODER_REG_AR37,  "ar37",  "ar37",        "ar37-res"   },
    {EM_DECODER_REG_AR38,  "ar38",  "ar38",        "ar38-res"   },
    {EM_DECODER_REG_AR39,  "ar39",  "ar39",        "ar39-res"   },
    {EM_DECODER_REG_AR40,  "ar40",  "ar.fpsr",     "ar.fpsr"    },
    {EM_DECODER_REG_AR41,  "ar41",  "ar41",        "ar41-res"   },
    {EM_DECODER_REG_AR42,  "ar42",  "ar42",        "ar42-res"   },
    {EM_DECODER_REG_AR43,  "ar43",  "ar43",        "ar43-res"   },
    {EM_DECODER_REG_AR44,  "ar44",  "ar.itc",      "ar.itc"     },
    {EM_DECODER_REG_AR45,  "ar45",  "ar45",        "ar45-res"   },
    {EM_DECODER_REG_AR46,  "ar46",  "ar46",        "ar46-res"   },
    {EM_DECODER_REG_AR47,  "ar47",  "ar47",        "ar47-res"   },
    {EM_DECODER_REG_AR48,  "ar48",  "ar48",        "ar48-ign"   },
    {EM_DECODER_REG_AR49,  "ar49",  "ar49",        "ar49-ign"   },
    {EM_DECODER_REG_AR50,  "ar50",  "ar50",        "ar50-ign"   },
    {EM_DECODER_REG_AR51,  "ar51",  "ar51",        "ar51-ign"   },
    {EM_DECODER_REG_AR52,  "ar52",  "ar52",        "ar52-ign"   },
    {EM_DECODER_REG_AR53,  "ar53",  "ar53",        "ar53-ign"   },
    {EM_DECODER_REG_AR54,  "ar54",  "ar54",        "ar54-ign"   },
    {EM_DECODER_REG_AR55,  "ar55",  "ar55",        "ar55-ign"   },
    {EM_DECODER_REG_AR56,  "ar56",  "ar56",        "ar56-ign"   },
    {EM_DECODER_REG_AR57,  "ar57",  "ar57",        "ar57-ign"   },
    {EM_DECODER_REG_AR58,  "ar58",  "ar58",        "ar58-ign"   },
    {EM_DECODER_REG_AR59,  "ar59",  "ar59",        "ar59-ign"   },
    {EM_DECODER_REG_AR60,  "ar60",  "ar60",        "ar60-ign"   },
    {EM_DECODER_REG_AR61,  "ar61",  "ar61",        "ar61-ign"   },
    {EM_DECODER_REG_AR62,  "ar62",  "ar62",        "ar62-ign"   },
    {EM_DECODER_REG_AR63,  "ar63",  "ar63",        "ar63-ign"   },
    {EM_DECODER_REG_AR64,  "ar64",  "ar.pfs",      "ar.pfs"     },
    {EM_DECODER_REG_AR65,  "ar65",  "ar.lc",       "ar.lc"      },
    {EM_DECODER_REG_AR66,  "ar66",  "ar.ec",       "ar.ec"      },
    {EM_DECODER_REG_AR67,  "ar67",  "ar67",        "ar67-res"   },
    {EM_DECODER_REG_AR68,  "ar68",  "ar68",        "ar68-res"   },
    {EM_DECODER_REG_AR69,  "ar69",  "ar69",        "ar69-res"   },
    {EM_DECODER_REG_AR70,  "ar70",  "ar70",        "ar70-res"   },
    {EM_DECODER_REG_AR71,  "ar71",  "ar71",        "ar71-res"   },
    {EM_DECODER_REG_AR72,  "ar72",  "ar72",        "ar72-res"   },
    {EM_DECODER_REG_AR73,  "ar73",  "ar73",        "ar73-res"   },
    {EM_DECODER_REG_AR74,  "ar74",  "ar74",        "ar74-res"   },
    {EM_DECODER_REG_AR75,  "ar75",  "ar75",        "ar75-res"   },
    {EM_DECODER_REG_AR76,  "ar76",  "ar76",        "ar76-res"   },
    {EM_DECODER_REG_AR77,  "ar77",  "ar77",        "ar77-res"   },
    {EM_DECODER_REG_AR78,  "ar78",  "ar78",        "ar78-res"   },
    {EM_DECODER_REG_AR79,  "ar79",  "ar79",        "ar79-res"   },
    {EM_DECODER_REG_AR80,  "ar80",  "ar80",        "ar80-res"   },
    {EM_DECODER_REG_AR81,  "ar81",  "ar81",        "ar81-res"   },
    {EM_DECODER_REG_AR82,  "ar82",  "ar82",        "ar82-res"   },
    {EM_DECODER_REG_AR83,  "ar83",  "ar83",        "ar83-res"   },
    {EM_DECODER_REG_AR84,  "ar84",  "ar84",        "ar84-res"   },
    {EM_DECODER_REG_AR85,  "ar85",  "ar85",        "ar85-res"   },
    {EM_DECODER_REG_AR86,  "ar86",  "ar86",        "ar86-res"   },
    {EM_DECODER_REG_AR87,  "ar87",  "ar87",        "ar87-res"   },
    {EM_DECODER_REG_AR88,  "ar88",  "ar88",        "ar88-res"   },
    {EM_DECODER_REG_AR89,  "ar89",  "ar89",        "ar89-res"   },
    {EM_DECODER_REG_AR90,  "ar90",  "ar90",        "ar90-res"   },
    {EM_DECODER_REG_AR91,  "ar91",  "ar91",        "ar91-res"   },
    {EM_DECODER_REG_AR92,  "ar92",  "ar92",        "ar92-res"   },
    {EM_DECODER_REG_AR93,  "ar93",  "ar93",        "ar93-res"   },
    {EM_DECODER_REG_AR94,  "ar94",  "ar94",        "ar94-res"   },
    {EM_DECODER_REG_AR95,  "ar95",  "ar95",        "ar95-res"   },
    {EM_DECODER_REG_AR96,  "ar96",  "ar96",        "ar96-res"   },
    {EM_DECODER_REG_AR97,  "ar97",  "ar97",        "ar97-res"   },
    {EM_DECODER_REG_AR98,  "ar98",  "ar98",        "ar98-res"   },
    {EM_DECODER_REG_AR99,  "ar99",  "ar99",        "ar99-res"   },
    {EM_DECODER_REG_AR100, "ar100", "ar100",       "ar100-res"  },
    {EM_DECODER_REG_AR101, "ar101", "ar101",       "ar101-res"  },
    {EM_DECODER_REG_AR102, "ar102", "ar102",       "ar102-res"  },
    {EM_DECODER_REG_AR103, "ar103", "ar103",       "ar103-res"  },
    {EM_DECODER_REG_AR104, "ar104", "ar104",       "ar104-res"  },
    {EM_DECODER_REG_AR105, "ar105", "ar105",       "ar105-res"  },
    {EM_DECODER_REG_AR106, "ar106", "ar106",       "ar106-res"  },
    {EM_DECODER_REG_AR107, "ar107", "ar107",       "ar107-res"  },
    {EM_DECODER_REG_AR108, "ar108", "ar108",       "ar108-res"  },
    {EM_DECODER_REG_AR109, "ar109", "ar109",       "ar109-res"  },
    {EM_DECODER_REG_AR110, "ar110", "ar110",       "ar110-res"  },
    {EM_DECODER_REG_AR111, "ar111", "ar111",       "ar111-res"  },
    {EM_DECODER_REG_AR112, "ar112", "ar112",       "ar112-ign"  },
    {EM_DECODER_REG_AR113, "ar113", "ar113",       "ar113-ign"  },
    {EM_DECODER_REG_AR114, "ar114", "ar114",       "ar114-ign"  },
    {EM_DECODER_REG_AR115, "ar115", "ar115",       "ar115-ign"  },
    {EM_DECODER_REG_AR116, "ar116", "ar116",       "ar116-ign"  },
    {EM_DECODER_REG_AR117, "ar117", "ar117",       "ar117-ign"  },
    {EM_DECODER_REG_AR118, "ar118", "ar118",       "ar118-ign"  },
    {EM_DECODER_REG_AR119, "ar119", "ar119",       "ar119-ign"  },
    {EM_DECODER_REG_AR120, "ar120", "ar120",       "ar120-ign"  },
    {EM_DECODER_REG_AR121, "ar121", "ar121",       "ar121-ign"  },
    {EM_DECODER_REG_AR122, "ar122", "ar122",       "ar122-ign"  },
    {EM_DECODER_REG_AR123, "ar123", "ar123",       "ar123-ign"  },
    {EM_DECODER_REG_AR124, "ar124", "ar124",       "ar124-ign"  },
    {EM_DECODER_REG_AR125, "ar125", "ar125",       "ar125-ign"  },
    {EM_DECODER_REG_AR126, "ar126", "ar126",       "ar126-ign"  },
    {EM_DECODER_REG_AR127, "ar127", "ar127",       "ar127-ign"  },

    {EM_DECODER_REG_P0,  "p0",  "p0",  "p0" },
    {EM_DECODER_REG_P1,  "p1",  "p1",  "p1" },
    {EM_DECODER_REG_P2,  "p2",  "p2",  "p2" },
    {EM_DECODER_REG_P3,  "p3",  "p3",  "p3" },
    {EM_DECODER_REG_P4,  "p4",  "p4",  "p4" },
    {EM_DECODER_REG_P5,  "p5",  "p5",  "p5" },
    {EM_DECODER_REG_P6,  "p6",  "p6",  "p6" },
    {EM_DECODER_REG_P7,  "p7",  "p7",  "p7" },
    {EM_DECODER_REG_P8,  "p8",  "p8",  "p8" },
    {EM_DECODER_REG_P9,  "p9",  "p9",  "p9" },
    {EM_DECODER_REG_P10, "p10", "p10", "p10"},
    {EM_DECODER_REG_P11, "p11", "p11", "p11"},
    {EM_DECODER_REG_P12, "p12", "p12", "p12"},
    {EM_DECODER_REG_P13, "p13", "p13", "p13"},
    {EM_DECODER_REG_P14, "p14", "p14", "p14"},
    {EM_DECODER_REG_P15, "p15", "p15", "p15"},
    {EM_DECODER_REG_P16, "p16", "p16", "p16"},
    {EM_DECODER_REG_P17, "p17", "p17", "p17"},
    {EM_DECODER_REG_P18, "p18", "p18", "p18"},
    {EM_DECODER_REG_P19, "p19", "p19", "p19"},
    {EM_DECODER_REG_P20, "p20", "p20", "p20"},
    {EM_DECODER_REG_P21, "p21", "p21", "p21"},
    {EM_DECODER_REG_P22, "p22", "p22", "p22"},
    {EM_DECODER_REG_P23, "p23", "p23", "p23"},
    {EM_DECODER_REG_P24, "p24", "p24", "p24"},
    {EM_DECODER_REG_P25, "p25", "p25", "p25"},
    {EM_DECODER_REG_P26, "p26", "p26", "p26"},
    {EM_DECODER_REG_P27, "p27", "p27", "p27"},
    {EM_DECODER_REG_P28, "p28", "p28", "p28"},
    {EM_DECODER_REG_P29, "p29", "p29", "p29"},
    {EM_DECODER_REG_P30, "p30", "p30", "p30"},
    {EM_DECODER_REG_P31, "p31", "p31", "p31"},
    {EM_DECODER_REG_P32, "p32", "p32", "p32"},
    {EM_DECODER_REG_P33, "p33", "p33", "p33"},
    {EM_DECODER_REG_P34, "p34", "p34", "p34"},
    {EM_DECODER_REG_P35, "p35", "p35", "p35"},
    {EM_DECODER_REG_P36, "p36", "p36", "p36"},
    {EM_DECODER_REG_P37, "p37", "p37", "p37"},
    {EM_DECODER_REG_P38, "p38", "p38", "p38"},
    {EM_DECODER_REG_P39, "p39", "p39", "p39"},
    {EM_DECODER_REG_P40, "p40", "p40", "p40"},
    {EM_DECODER_REG_P41, "p41", "p41", "p41"},
    {EM_DECODER_REG_P42, "p42", "p42", "p42"},
    {EM_DECODER_REG_P43, "p43", "p43", "p43"},
    {EM_DECODER_REG_P44, "p44", "p44", "p44"},
    {EM_DECODER_REG_P45, "p45", "p45", "p45"},
    {EM_DECODER_REG_P46, "p46", "p46", "p46"},
    {EM_DECODER_REG_P47, "p47", "p47", "p47"},
    {EM_DECODER_REG_P48, "p48", "p48", "p48"},
    {EM_DECODER_REG_P49, "p49", "p49", "p49"},
    {EM_DECODER_REG_P50, "p50", "p50", "p50"},
    {EM_DECODER_REG_P51, "p51", "p51", "p51"},
    {EM_DECODER_REG_P52, "p52", "p52", "p52"},
    {EM_DECODER_REG_P53, "p53", "p53", "p53"},
    {EM_DECODER_REG_P54, "p54", "p54", "p54"},
    {EM_DECODER_REG_P55, "p55", "p55", "p55"},
    {EM_DECODER_REG_P56, "p56", "p56", "p56"},
    {EM_DECODER_REG_P57, "p57", "p57", "p57"},
    {EM_DECODER_REG_P58, "p58", "p58", "p58"},
    {EM_DECODER_REG_P59, "p59", "p59", "p59"},
    {EM_DECODER_REG_P60, "p60", "p60", "p60"},
    {EM_DECODER_REG_P61, "p61", "p61", "p61"},
    {EM_DECODER_REG_P62, "p62", "p62", "p62"},
    {EM_DECODER_REG_P63, "p63", "p63", "p63"},

    {EM_DECODER_REG_BR0, "b0", "rp", "bret"},
    {EM_DECODER_REG_BR1, "b1", "b1", "b1"  },
    {EM_DECODER_REG_BR2, "b2", "b2", "b2"  },
    {EM_DECODER_REG_BR3, "b3", "b3", "b3"  },
    {EM_DECODER_REG_BR4, "b4", "b4", "b4"  },
    {EM_DECODER_REG_BR5, "b5", "b5", "b5"  },
    {EM_DECODER_REG_BR6, "b6", "b6", "b6"  },
    {EM_DECODER_REG_BR7, "b7", "b7", "b7"  },

    {EM_DECODER_REG_PR,     "pr",     "pr",      "pr"       },
    {EM_DECODER_REG_PR_ROT, "pr.rot", "pr.rot",  "pr.rot"   },
    {EM_DECODER_REG_CR0,    "cr0",    "cr.dcr",  "cr.dcr"   },
    {EM_DECODER_REG_CR1,    "cr1",    "cr.itm",  "cr.itm"   },
    {EM_DECODER_REG_CR2,    "cr2",    "cr.iva",  "cr.iva"   },
    {EM_DECODER_REG_CR3,    "cr3",    "cr3",     "cr3-res"  },
    {EM_DECODER_REG_CR4,    "cr4",    "cr4",     "cr4-res"  },
    {EM_DECODER_REG_CR5,    "cr5",    "cr5",     "cr5-res"  },
    {EM_DECODER_REG_CR6,    "cr6",    "cr6",     "cr6-res"  },
    {EM_DECODER_REG_CR7,    "cr7",    "cr7",     "cr7-res"  },
    {EM_DECODER_REG_CR8,    "cr8",    "cr.pta",  "cr.pta"   },
    {EM_DECODER_REG_CR9,    "cr9",    "cr.gpta", "cr.gpta"  },
    {EM_DECODER_REG_CR10,   "cr10",   "cr10",    "cr10-res" },
    {EM_DECODER_REG_CR11,   "cr11",   "cr11",    "cr11-res" },
    {EM_DECODER_REG_CR12,   "cr12",   "cr12",    "cr12-res" },
    {EM_DECODER_REG_CR13,   "cr13",   "cr13",    "cr13-res" },
    {EM_DECODER_REG_CR14,   "cr14",   "cr14",    "cr14-res" },
    {EM_DECODER_REG_CR15,   "cr15",   "cr15",    "cr15-res" },
    {EM_DECODER_REG_CR16,   "cr16",   "cr.ipsr", "cr.ipsr"  },
    {EM_DECODER_REG_CR17,   "cr17",   "cr.isr",  "cr.isr"   },
    {EM_DECODER_REG_CR18,   "cr18",   "cr18",    "cr18-res" },
    {EM_DECODER_REG_CR19,   "cr19",   "cr.iip",  "cr.iip"   },
    {EM_DECODER_REG_CR20,   "cr20",   "cr.ifa",  "cr.ifa"   },
    {EM_DECODER_REG_CR21,   "cr21",   "cr.itir", "cr.itir"  },
    {EM_DECODER_REG_CR22,   "cr22",   "cr.iipa", "cr.iipa"  },
    {EM_DECODER_REG_CR23,   "cr23",   "cr.ifs",  "cr.ifs"   },
    {EM_DECODER_REG_CR24,   "cr24",   "cr.iim",  "cr.iim"   },
    {EM_DECODER_REG_CR25,   "cr25",   "cr.iha",  "cr.iha"   },
    {EM_DECODER_REG_CR26,   "cr26",   "cr26",    "cr26-res" },
    {EM_DECODER_REG_CR27,   "cr27",   "cr27",    "cr27-res" },
    {EM_DECODER_REG_CR28,   "cr28",   "cr28",    "cr28-res" },
    {EM_DECODER_REG_CR29,   "cr29",   "cr29",    "cr29-res" },
    {EM_DECODER_REG_CR30,   "cr30",   "cr30",    "cr30-res" },
    {EM_DECODER_REG_CR31,   "cr31",   "cr31",    "cr31-res" },
    {EM_DECODER_REG_CR32,   "cr32",   "cr32",    "cr32-res" },
    {EM_DECODER_REG_CR33,   "cr33",   "cr33",    "cr33-res" },
    {EM_DECODER_REG_CR34,   "cr34",   "cr34",    "cr34-res" },
    {EM_DECODER_REG_CR35,   "cr35",   "cr35",    "cr35-res" },
    {EM_DECODER_REG_CR36,   "cr36",   "cr36",    "cr36-res" },
    {EM_DECODER_REG_CR37,   "cr37",   "cr37",    "cr37-res" },
    {EM_DECODER_REG_CR38,   "cr38",   "cr38",    "cr38-res" },
    {EM_DECODER_REG_CR39,   "cr39",   "cr39",    "cr39-res" },
    {EM_DECODER_REG_CR40,   "cr40",   "cr40",    "cr40-res" },
    {EM_DECODER_REG_CR41,   "cr41",   "cr41",    "cr41-res" },
    {EM_DECODER_REG_CR42,   "cr42",   "cr42",    "cr42-res" },
    {EM_DECODER_REG_CR43,   "cr43",   "cr43",    "cr43-res" },
    {EM_DECODER_REG_CR44,   "cr44",   "cr44",    "cr44-res" },
    {EM_DECODER_REG_CR45,   "cr45",   "cr45",    "cr45-res" },
    {EM_DECODER_REG_CR46,   "cr46",   "cr46",    "cr46-res" },
    {EM_DECODER_REG_CR47,   "cr47",   "cr47",    "cr47-res" },
    {EM_DECODER_REG_CR48,   "cr48",   "cr48",    "cr48-res" },
    {EM_DECODER_REG_CR49,   "cr49",   "cr49",    "cr49-res" },
    {EM_DECODER_REG_CR50,   "cr50",   "cr50",    "cr50-res" },
    {EM_DECODER_REG_CR51,   "cr51",   "cr51",    "cr51-res" },
    {EM_DECODER_REG_CR52,   "cr52",   "cr52",    "cr52-res" },
    {EM_DECODER_REG_CR53,   "cr53",   "cr53",    "cr53-res" },
    {EM_DECODER_REG_CR54,   "cr54",   "cr54",    "cr54-res" },
    {EM_DECODER_REG_CR55,   "cr55",   "cr55",    "cr55-res" },
    {EM_DECODER_REG_CR56,   "cr56",   "cr56",    "cr56-res" },
    {EM_DECODER_REG_CR57,   "cr57",   "cr57",    "cr57-res" },
    {EM_DECODER_REG_CR58,   "cr58",   "cr58",    "cr58-res" },
    {EM_DECODER_REG_CR59,   "cr59",   "cr59",    "cr59-res" },
    {EM_DECODER_REG_CR60,   "cr60",   "cr60",    "cr60-res" },
    {EM_DECODER_REG_CR61,   "cr61",   "cr61",    "cr61-res" },
    {EM_DECODER_REG_CR62,   "cr62",   "cr62",    "cr62-res" },
    {EM_DECODER_REG_CR63,   "cr63",   "cr63",    "cr63-res" },
    {EM_DECODER_REG_CR64,   "cr64",   "cr.lid",  "cr.lid"   },
    {EM_DECODER_REG_CR65,   "cr65",   "cr.ivr",  "cr.ivr"   },
    {EM_DECODER_REG_CR66,   "cr66",   "cr.tpr",  "cr.tpr"   },
    {EM_DECODER_REG_CR67,   "cr67",   "cr.eoi",  "cr.eoi"   },
    {EM_DECODER_REG_CR68,   "cr68",   "cr.irr0", "cr.irr0"  },
    {EM_DECODER_REG_CR69,   "cr69",   "cr.irr1", "cr.irr1"  },
    {EM_DECODER_REG_CR70,   "cr70",   "cr.irr2", "cr.irr2"  },
    {EM_DECODER_REG_CR71,   "cr71",   "cr.irr3", "cr.irr3"  },
    {EM_DECODER_REG_CR72,   "cr72",   "cr.itv",  "cr.itv"   },
    {EM_DECODER_REG_CR73,   "cr73",   "cr.pmv",  "cr.pmv"   },
    {EM_DECODER_REG_CR74,   "cr74",   "cr.cmcv", "cr.cmcv"  },
    {EM_DECODER_REG_CR75,   "cr75",   "cr75",    "cr75-res" },
    {EM_DECODER_REG_CR76,   "cr76",   "cr76",    "cr76-res" },
    {EM_DECODER_REG_CR77,   "cr77",   "cr77",    "cr77-res" },
    {EM_DECODER_REG_CR78,   "cr78",   "cr78",    "cr78-res" },
    {EM_DECODER_REG_CR79,   "cr79",   "cr79",    "cr79-res" },
    {EM_DECODER_REG_CR80,   "cr80",   "cr.lrr0", "cr.lrr0"  },
    {EM_DECODER_REG_CR81,   "cr81",   "cr.lrr1", "cr.lrr1"  },
    {EM_DECODER_REG_CR82,   "cr82",   "cr82",    "cr82-res" },
    {EM_DECODER_REG_CR83,   "cr83",   "cr83",    "cr83-res" },
    {EM_DECODER_REG_CR84,   "cr84",   "cr84",    "cr84-res" },
    {EM_DECODER_REG_CR85,   "cr85",   "cr85",    "cr85-res" },
    {EM_DECODER_REG_CR86,   "cr86",   "cr86",    "cr86-res" },
    {EM_DECODER_REG_CR87,   "cr87",   "cr87",    "cr87-res" },
    {EM_DECODER_REG_CR88,   "cr88",   "cr88",    "cr88-res" },
    {EM_DECODER_REG_CR89,   "cr89",   "cr89",    "cr89-res" },
    {EM_DECODER_REG_CR90,   "cr90",   "cr90",    "cr90-res" },
    {EM_DECODER_REG_CR91,   "cr91",   "cr91",    "cr91-res" },
    {EM_DECODER_REG_CR92,   "cr92",   "cr92",    "cr92-res" },
    {EM_DECODER_REG_CR93,   "cr93",   "cr93",    "cr93-res" },
    {EM_DECODER_REG_CR94,   "cr94",   "cr94",    "cr94-res" },
    {EM_DECODER_REG_CR95,   "cr95",   "cr95",    "cr95-res" },
    {EM_DECODER_REG_CR96,   "cr96",   "cr96",    "cr96-res" },
    {EM_DECODER_REG_CR97,   "cr97",   "cr97",    "cr97-res" },
    {EM_DECODER_REG_CR98,   "cr98",   "cr98",    "cr98-res" },
    {EM_DECODER_REG_CR99,   "cr99",   "cr99",    "cr99-res" },
    {EM_DECODER_REG_CR100,  "cr100",  "cr100",   "cr100-res"},
    {EM_DECODER_REG_CR101,  "cr101",  "cr101",   "cr101-res"},
    {EM_DECODER_REG_CR102,  "cr102",  "cr102",   "cr102-res"},
    {EM_DECODER_REG_CR103,  "cr103",  "cr103",   "cr103-res"},
    {EM_DECODER_REG_CR104,  "cr104",  "cr104",   "cr104-res"},
    {EM_DECODER_REG_CR105,  "cr105",  "cr105",   "cr105-res"},
    {EM_DECODER_REG_CR106,  "cr106",  "cr106",   "cr106-res"},
    {EM_DECODER_REG_CR107,  "cr107",  "cr107",   "cr107-res"},
    {EM_DECODER_REG_CR108,  "cr108",  "cr108",   "cr108-res"},
    {EM_DECODER_REG_CR109,  "cr109",  "cr109",   "cr109-res"},
    {EM_DECODER_REG_CR110,  "cr110",  "cr110",   "cr110-res"},
    {EM_DECODER_REG_CR111,  "cr111",  "cr111",   "cr111-res"},
    {EM_DECODER_REG_CR112,  "cr112",  "cr112",   "cr112-res"},
    {EM_DECODER_REG_CR113,  "cr113",  "cr113",   "cr113-res"},
    {EM_DECODER_REG_CR114,  "cr114",  "cr114",   "cr114-res"},
    {EM_DECODER_REG_CR115,  "cr115",  "cr115",   "cr115-res"},
    {EM_DECODER_REG_CR116,  "cr116",  "cr116",   "cr116-res"},
    {EM_DECODER_REG_CR117,  "cr117",  "cr117",   "cr117-res"},
    {EM_DECODER_REG_CR118,  "cr118",  "cr118",   "cr118-res"},
    {EM_DECODER_REG_CR119,  "cr119",  "cr119",   "cr119-res"},
    {EM_DECODER_REG_CR120,  "cr120",  "cr120",   "cr120-res"},
    {EM_DECODER_REG_CR121,  "cr121",  "cr121",   "cr121-res"},
    {EM_DECODER_REG_CR122,  "cr122",  "cr122",   "cr122-res"},
    {EM_DECODER_REG_CR123,  "cr123",  "cr123",   "cr123-res"},
    {EM_DECODER_REG_CR124,  "cr124",  "cr124",   "cr124-res"},
    {EM_DECODER_REG_CR125,  "cr125",  "cr125",   "cr125-res"},
    {EM_DECODER_REG_CR126,  "cr126",  "cr126",   "cr126-res"},
    {EM_DECODER_REG_CR127,  "cr127",  "cr127",   "cr127-res"},
    {EM_DECODER_REG_PSR,    "psr",    "psr",     "psr"      },
    {EM_DECODER_REG_PSR_L,  "psr.l",  "psr.l",   "psr.l"    },
    {EM_DECODER_REG_PSR_UM, "psr.um", "psr.um",  "psr.um"   },
    {EM_DECODER_REG_IP, "IP", "IP", "ip" },
    {EM_DECODER_EM_REG_LAST, "", "", ""},
    {EM_DECODER_REG_LAST, "", "", ""}
};



UCHAR g_Ia64Disinstr[EM_BUNDLE_SIZE];

/******************************************************************
** Simple IA64 template info... Thierry 12/99.
**
*/

#define GET_TEMPLATE(Bits) \
    ((EM_template_t)(((Bits) >> EM_TEMPLATE_POS) & (EM_NUM_OF_TEMPLATES - 1)))

typedef enum _EM_UNIT { 
   I_Unit, 
   M_Unit, 
   F_Unit, 
   B_Unit, 
   X_Unit, 
   L_Unit, 
   A_Unit, 
   No_Unit 
} EM_UNIT;

typedef enum _EM_SB { 
   SB_Cont, 
   SB_Stop 
} EM_SB;

typedef struct _EM_TEMPLATE_INFO {
   struct {
       EM_UNIT unit;
       EM_SB   stop;
   } slot[EM_SLOT_LAST];
   const char *name;
} EM_TEMPLATE_INFO, *PEM_TEMPLATE_INFO;

EM_TEMPLATE_INFO EmTemplates[] = {
/*      Slot 0               Slot 1             Slot 2
----------------------------------------------------------*/
{ {{M_Unit,  SB_Cont}, {I_Unit,  SB_Cont}, {I_Unit,  SB_Cont}}, ".mii " },
{ {{M_Unit,  SB_Cont}, {I_Unit,  SB_Stop}, {I_Unit,  SB_Cont}}, ".mi_i" },
{ {{M_Unit,  SB_Cont}, {L_Unit,  SB_Cont}, {X_Unit,  SB_Cont}}, ".mlx " },
{ {{No_Unit, SB_Cont}, {No_Unit, SB_Cont}, {No_Unit, SB_Cont}}, "?res " },
{ {{M_Unit,  SB_Cont}, {M_Unit,  SB_Cont}, {I_Unit,  SB_Cont}}, ".mmi " },
{ {{M_Unit,  SB_Stop}, {M_Unit,  SB_Cont}, {I_Unit,  SB_Cont}}, ".m_mi" },
{ {{M_Unit,  SB_Cont}, {F_Unit,  SB_Cont}, {I_Unit,  SB_Cont}}, ".mfi " },
{ {{M_Unit,  SB_Cont}, {M_Unit,  SB_Cont}, {F_Unit,  SB_Cont}}, ".mmf " },
{ {{M_Unit,  SB_Cont}, {I_Unit,  SB_Cont}, {B_Unit,  SB_Cont}}, ".mib " },
{ {{M_Unit,  SB_Cont}, {B_Unit,  SB_Cont}, {B_Unit,  SB_Cont}}, ".mbb " },
{ {{No_Unit, SB_Cont}, {No_Unit, SB_Cont}, {No_Unit, SB_Cont}}, "?res " },
{ {{B_Unit,  SB_Cont}, {B_Unit,  SB_Cont}, {B_Unit,  SB_Cont}}, ".bbb " },
{ {{M_Unit,  SB_Cont}, {M_Unit,  SB_Cont}, {B_Unit,  SB_Cont}}, ".mmb " },
{ {{No_Unit, SB_Cont}, {No_Unit, SB_Cont}, {No_Unit, SB_Cont}}, "?res " },
{ {{M_Unit,  SB_Cont}, {F_Unit,  SB_Cont}, {B_Unit,  SB_Cont}}, ".mfb " },
{ {{No_Unit, SB_Cont}, {No_Unit, SB_Cont}, {No_Unit, SB_Cont}}, "?res " },
};

PEM_TEMPLATE_INFO __inline
EmTemplateInfo(EM_template_t Template)
{
   if (Template >= sizeof(EmTemplates)/sizeof(EmTemplates[0]))
   {
      return NULL;
   }
   return &EmTemplates[Template];
} // EmTemplateInfo()

/*
** End of Simple IA64 template info.
*******************************************************************
*/


/**** disasm - disassemble an IA64 instruction
* Purpose:
*       Disassemble version based on Falcon DISASM.DLL
*
*  Input:
*       pOffset = pointer to offset to start disassembly
*       fEAout = if set, include EA (effective address)
*
*  Output:
*       pOffset = pointer to offset of next instruction
*       pchDst = pointer to result string
*
***************************************************************************/

BOOL
Ia64MachineInfo::Disassemble (PADDR poffset, PSTR bufptr, BOOL fEAout)
{
    U64     location;
    ULONG64 gb_offset;
    UINT    ascii_inst_buf_length;
    PUINT   pascii_inst_buf_length = &ascii_inst_buf_length;
    UINT    bin_inst_buf_length;
    unsigned int actual_length;

    ADDR    tempaddr;
    UCHAR * pbin_inst_buf = &g_Ia64Disinstr[0];
    

    static CIa64Disasm* pIa64Disasm = NULL;
    if (!pIa64Disasm) {
        pIa64Disasm = new CIa64Disasm(this);
        if (!pIa64Disasm) {
            ErrOut("IA64 disassembler initialization failure\n");
            return FALSE;
        } /*if*/
    } /*if*/

    if (IsIA32InstructionSet()) {
        WarnOut("The current context is in IA32 mode.  "
                "IA64 disassembly may be inaccurate.\n");
    }

    IEL_ZERO(location);
    // convert EM address to Gambit internal address.
    // i.e., move slot number from bit(2,3) to bit(0,1)
    gb_offset = ((Flat(*poffset) & (~0xf)) | ((Flat(*poffset) & 0xf) >> 2));
    IEL_ASSIGNU(location, *(U64*)(&gb_offset));

    // convert to bundle address. must be 16 byte aligned
    ADDRFLAT(&tempaddr, (Flat(*poffset) & ~0xf));

    // copy data (if KD, from remote system) to local temp buffer -
    // g_Ia64Disinstr[]
    bin_inst_buf_length = GetMemString(&tempaddr, pbin_inst_buf, sizeof(U128));
        
    m_BufStart = (PCHAR)bufptr;
    m_Buf = m_BufStart;
        
    // display 64-bit address
    sprintf(m_Buf, "%s ", FormatAddr64(Flat(*poffset)));
    m_Buf += strlen(m_Buf);
        
    // TBD display opcode

    // If we're in verbose mode leave space for the bundle type.
    if (g_AsmOptions & ASMOPT_VERBOSE) 
    {
        // Show the bundle type at the beginning of the bundle.
        if (AddrEqu(tempaddr, *poffset)) 
        {
            if (bin_inst_buf_length == sizeof(U128)) 
            {
                PEM_TEMPLATE_INFO Templ = 
                    EmTemplateInfo(GET_TEMPLATE(pbin_inst_buf[0]));
                sprintf(m_Buf, "{ %s", Templ->name);
            } 
            else 
            {
                strcpy(m_Buf, "{ ??? ");
            }
        } 
        else 
        {
            strcpy(m_Buf, "       ");
        }
        m_Buf += strlen(m_Buf);
    }
        
    if (bin_inst_buf_length != sizeof(U128)) 
    {
        BufferString(" ???????? ????\n");
        *m_Buf = '\0';
        return FALSE;
    }

    *pascii_inst_buf_length = ASCII_BUF_LENGTH;

    if (!pIa64Disasm->Disassemble(
            Flat(*poffset), *(CIa64Disasm::SBundle*)pbin_inst_buf, 
            &actual_length,
            m_Buf, *pascii_inst_buf_length, (fEAout != FALSE)))
    {
        ErrOut("Dissassembler failure!!!!\n");        
    }

    switch (EM_IL_GET_SLOT_NO(location))
    {
    case 0:
        IEL_INCU(location);
        break;

    case 1:
        IEL_INCU(location);
        if ((actual_length) != 2)
        {
            break;
        } /*** else fall-through ***/

    case 2:
        U32 syl_size;
        IEL_CONVERT1(syl_size, EM_BUNDLE_SIZE-2);
        IEL_ADDU((location), syl_size, (location));
        break;
    }

    gb_offset = ((ULONG64)IEL_GETQW0(location));

    // convert Gambit internal address to EM address
    Off(*poffset) =  (gb_offset & (~0xf)) | ((gb_offset & 0xf) << 2);
    NotFlat(*poffset);
    ComputeFlatAddress(poffset, NULL);

    m_Buf += strlen(m_Buf);
    
    // If this the last instruction of a bundle mark it.
    if ((Flat(*poffset) & 0xf) == 0) 
    {
        if (g_AsmOptions & ASMOPT_VERBOSE)
        {
            strcpy(m_Buf, "}\n");
            m_Buf += strlen(m_Buf);
        } 
        else 
        {
            *m_Buf++ = '\n';
        }
    }
    
    /* add new line at the end */
    *m_Buf++ = '\n';
    *m_Buf = '\0';
    return TRUE;
} // Ia64MachineInfo::Disassemble

HRESULT
Ia64MachineInfo::NewBreakpoint(DebugClient* Client, 
                               ULONG Type,
                               ULONG Id,
                               Breakpoint** RetBp)
{
    HRESULT Status;

    switch(Type & (DEBUG_BREAKPOINT_CODE | DEBUG_BREAKPOINT_DATA))
    {
    case DEBUG_BREAKPOINT_CODE:
        *RetBp = new CodeBreakpoint(Client, Id, IMAGE_FILE_MACHINE_IA64);
        Status = (*RetBp) ? S_OK : E_OUTOFMEMORY;

        break;
    case DEBUG_BREAKPOINT_DATA:
        *RetBp = new Ia64DataBreakpoint(Client, Id);
        Status = (*RetBp) ? S_OK : E_OUTOFMEMORY;
        break;
    default:
        // Unknown breakpoint type.
        Status = E_NOINTERFACE;
    }

    return Status;
}

BOOL
Ia64MachineInfo::IsBreakpointInstruction(PADDR Addr)
{
    ULONG64 Instr;

    if (IsIA32InstructionSet())
    {
        return g_X86Machine.IsBreakpointInstruction(Addr);
    }
    else
    {
        // No need to align for this check.
        if (GetMemString(Addr, &Instr, sizeof(Instr)) != sizeof(Instr))
        {
            return FALSE;
        }
    
        switch (Flat(*Addr) & 0xf)
        {
        case 0:
            if ((Instr & (INST_SLOT0_MASK)) == (g_Ia64TrapInstr << 5))
            {
                return TRUE;
            }
            break;

        case 4:
            if ((Instr & (INST_SLOT1_MASK)) == (g_Ia64TrapInstr << 14))
            {
                return TRUE;
            }
            break;
            
        case 8:
            if ((Instr & (INST_SLOT2_MASK)) == (g_Ia64TrapInstr << 23))
            {
                return TRUE;
            }
            break;
        }
    }

    return FALSE;
}

HRESULT
Ia64MachineInfo::InsertBreakpointInstruction(PUSER_DEBUG_SERVICES Services,
                                             ULONG64 Process,
                                             ULONG64 Offset,
                                             PUCHAR SaveInstr,
                                             PULONG64 ChangeStart,
                                             PULONG ChangeLen)
{
    ULONG64 Aligned;
    ULONG Off;
    ULONG Done;
    HRESULT Status;

    // Make sure the storage area has space for both the saved
    // instruction bundle and some flags.
    DBG_ASSERT(MAX_BREAKPOINT_LENGTH >= IA64_BP_LEN + sizeof(BOOL));
    
    Aligned = Offset;
    Off = (ULONG)(Aligned & IA64_BP_ALIGN);
    Aligned -= Off;

    *ChangeStart = Aligned;
    *ChangeLen = IA64_BP_LEN;
    
    Status = Services->ReadVirtual(Process, Aligned, SaveInstr,
                                   IA64_BP_LEN, &Done);
    if (Status != S_OK)
    {
        return Status;
    }
    if (Done != IA64_BP_LEN)
    {
        return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
    }

    UCHAR TempInstr[IA64_BP_LEN];
    ULONG64 UNALIGNED *New = (ULONG64 UNALIGNED *)(TempInstr + Off);
    PBOOL Mli = (PBOOL)(SaveInstr + IA64_BP_LEN);

    memcpy(TempInstr, SaveInstr, IA64_BP_LEN);
    *Mli = FALSE;
    
    switch(Off)
    {
    case 0:
        *New = (*New & ~(INST_SLOT0_MASK)) | (g_Ia64TrapInstr << 5);
        break;

    case 4:
        *New = (*New & ~(INST_SLOT1_MASK)) | (g_Ia64TrapInstr << 14);
        break;

    case 8:
        *New = (*New & ~(INST_SLOT2_MASK)) | (g_Ia64TrapInstr << 23);
        break;

    default:
        return E_INVALIDARG;
    }

    // If current instruction is
    // NOT slot 0 check for two-slot MOVL instruction.  Reject
    // request if attempt to set break in slot 2 of MLI template.

    if (Off != 0)
    {
        New = (PULONG64)TempInstr;
        if (((*New & INST_TEMPL_MASK) >> 1) == 0x2)
        {
            if (Off == 4)
            {
                // if template= type 2 MLI, change to type 0
                *New &= ~((INST_TEMPL_MASK >> 1) << 1);
                *Mli = TRUE;
            }
            else
            {
                // set breakpoint at slot 2 of MOVL is illegal
                return E_UNEXPECTED;
            }
        }
    }

    Status = Services->WriteVirtual(Process, Aligned, TempInstr,
                                    IA64_BP_LEN, &Done);
    if (Status == S_OK && Done != IA64_BP_LEN)
    {
        Status = HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
    }
    return Status;
}

HRESULT
Ia64MachineInfo::RemoveBreakpointInstruction(PUSER_DEBUG_SERVICES Services,
                                             ULONG64 Process,
                                             ULONG64 Offset,
                                             PUCHAR SaveInstr,
                                             PULONG64 ChangeStart,
                                             PULONG ChangeLen)
{
    ULONG64 Aligned;
    ULONG Off;
    ULONG Done;
    HRESULT Status;

    Aligned = Offset;
    Off = (ULONG)(Aligned & IA64_BP_ALIGN);
    Aligned -= Off;

    *ChangeStart = Aligned;
    *ChangeLen = IA64_BP_LEN;
    
    UCHAR TempInstr[IA64_BP_LEN];
    ULONG64 UNALIGNED *New;
    ULONG64 UNALIGNED *Old;
    PBOOL Mli;

    // Read in memory since adjacent instructions in the same bundle
    // may have been modified after we save them. We only restore the
    // content of the slot which has the break instruction inserted.
    Status = Services->ReadVirtual(Process, Aligned, TempInstr,
                                   IA64_BP_LEN, &Done);
    if (Status != S_OK)
    {
        return Status;
    }
    if (Done != IA64_BP_LEN)
    {
        return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
    }
            
    New = (ULONG64 UNALIGNED *)(TempInstr + Off);
    Old = (ULONG64 UNALIGNED *)(SaveInstr + Off);
    Mli = (PBOOL)(SaveInstr + IA64_BP_LEN);
    
    switch(Off)
    {
    case 0:
        *New = (*New & ~(INST_SLOT0_MASK)) | (*Old & INST_SLOT0_MASK);
        break;

    case 4:
        *New = (*New & ~(INST_SLOT1_MASK)) | (*Old & INST_SLOT1_MASK);
        break;

    case 8:
        *New = (*New & ~(INST_SLOT2_MASK)) | (*Old & INST_SLOT2_MASK);
        break;

    default:
        return E_INVALIDARG;
    }
            
    // restore template to MLI if displaced instruction was MOVL
    if (*Mli)
    {
        New = (PULONG64)TempInstr;
        *New &= ~((INST_TEMPL_MASK >> 1) << 1); // set template to MLI
        *New |= 0x4;
    }
        
    Status = Services->WriteVirtual(Process, Aligned, TempInstr,
                                    IA64_BP_LEN, &Done);
    if (Status == S_OK && Done != IA64_BP_LEN)
    {
        Status = HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
    }
    return Status;
}

void
Ia64MachineInfo::AdjustPCPastBreakpointInstruction (PADDR Addr, 
                                                    ULONG BreakType)
{
    DBG_ASSERT(BreakType == DEBUG_BREAKPOINT_CODE);

    if (IsIA32InstructionSet()) 
    {
        //
        // IA32 instruction set
        //
        SetPC(AddrAdd(Addr, 1));
    } 
    else 
    {
        //
        // IA64 instruction set
        //
        if ((Flat(*Addr) & 0xf) != 8) 
        {
            SetPC(AddrAdd(Addr, 4));
        } 
        else 
        {
            SetPC(AddrAdd(Addr, 8));
        }
    }
}

void
Ia64MachineInfo::InsertAllDataBreakpoints (void)
{
    PPROCESS_INFO ProcessSave = g_CurrentProcess;
    PTHREAD_INFO Thread;

    // Update thread context for every thread.

    g_CurrentProcess = g_ProcessHead;
    while (g_CurrentProcess != NULL)
    {
        Thread = g_CurrentProcess->ThreadHead;
        while (Thread != NULL)
        {
            DBG_ASSERT(Thread->NumDataBreaks <= m_MaxDataBreakpoints);

            BpOut("Thread %d data %d\n",
                  Thread->UserId, Thread->NumDataBreaks);

            ChangeRegContext(Thread);

            // The kernel automatically sets PSR.db for the
            // kernel so this code only needs to manipulate PSR.db
            // for user-mode debugging.

            ULONG64 RegIPSR;

            ULONG RegDBD = REGDBD0;
            ULONG RegDBDEnd = min(REGDBD7 + 1, REGDBD0 + 2 * m_MaxDataBreakpoints);

            ULONG RegDBI = REGDBI0;
            ULONG RegDBIEnd = min(REGDBI7 + 1, REGDBI0 + 2 * m_MaxDataBreakpoints);

            // Start with all breaks turned off.
            if (IS_USER_TARGET())
            {
                RegIPSR = GetReg64(STIPSR);
                RegIPSR &= ~((ULONG64)1 << PSR_DB);
            }

            if (Thread->NumDataBreaks > 0)
            {
                ULONG i;
                
                for (i = 0; i < Thread->NumDataBreaks; i++)
                {
                    Breakpoint* Bp = Thread->DataBreakBps[i];
                    ULONG ProcType = Bp->GetProcType();

                    DBG_ASSERT((ProcType == IMAGE_FILE_MACHINE_IA64) || 
                               (ProcType == IMAGE_FILE_MACHINE_I386));

                    ULONG64 Addr, Control;

                    if (ProcType == IMAGE_FILE_MACHINE_I386) 
                    {
                        Addr = (ULONG)Flat(*Bp->GetAddr());
                        Control = ((X86OnIa64DataBreakpoint*)Bp)->m_Control;
                    } 
                    else 
                    {
                        Addr = Flat(*Bp->GetAddr());
                        Control = ((Ia64DataBreakpoint*)Bp)->m_Control;
                    }
                        
                    if (Bp->m_DataAccessType == DEBUG_BREAK_EXECUTE) 
                    {
                        BpOut("  ibp %d at %p\n", i, Addr);
                        SetReg64(RegDBI++, Addr);
                        SetReg64(RegDBI++, Control);
                    }
                    else
                    {
                        BpOut("  dbp %d at %p\n", i, Addr);
                        SetReg64(RegDBD++, Addr);
                        SetReg64(RegDBD++, Control);
                    } // iff
                } // for
                RegIPSR |= ((ULONG64)1 << PSR_DB); 
            }
            else if (IS_KERNEL_TARGET())
            {
            }

            // Make sure unused debug registers are clear.
            while (RegDBD < RegDBDEnd)
            {
                SetReg64(RegDBD++, 0);
            }

            while (RegDBI < RegDBIEnd)
            {
                SetReg64(RegDBI++, 0);
            }

            if (IS_USER_TARGET())
            {
                SetReg64(STIPSR, RegIPSR);
            }

            Thread = Thread->Next;
        }
        
        g_CurrentProcess = g_CurrentProcess->Next;
    }
    
    g_CurrentProcess = ProcessSave;
    if (g_CurrentProcess != NULL)
    {
        ChangeRegContext(g_CurrentProcess->CurrentThread);
    }
    else
    {
        ChangeRegContext(NULL);
    }
}

void
Ia64MachineInfo::RemoveAllDataBreakpoints (void)
{
    if (IS_USER_TARGET())
    {
        ULONG64 RegIPSR;

        RegIPSR = GetReg64(STIPSR);
        RegIPSR &= ~((ULONG64)1 << PSR_DB);
        SetReg64(STIPSR, RegIPSR);
    }
    else
    {
        for (UINT i = 1; i < 2 * m_MaxDataBreakpoints; i += 2) 
        {
            SetReg64(REGDBD0 + i, 0);
            SetReg64(REGDBI0 + i, 0);
        }
    }
}

ULONG
Ia64MachineInfo::IsBreakpointOrStepException (PEXCEPTION_RECORD64 Record,
                                              ULONG FirstChance,
                                              PADDR BpAddr,
                                              PADDR RelAddr)
{
    if (Record->ExceptionCode == STATUS_BREAKPOINT)
    {
        // Data breakpoints come in as SINGLE_STEP so
        // this must be a code breakpoint.
        return EXBS_BREAKPOINT_CODE;
    }
    else if (Record->ExceptionCode == STATUS_SINGLE_STEP)
    {
        DBG_ASSERT(Record->NumberParameters >= 5);
        
        // Data breakpoints put the faulting address in
        // the exception information, whereas a true single
        // step exception sets the address to zero.
        if (Record->ExceptionInformation[1])
        {
            // This should be read, write or execute interrupt.
            DBG_ASSERT(Record->ExceptionInformation[4] &
                       (((ULONG64)1 << ISR_X) | 
                        ((ULONG64)1 << ISR_W) | 
                        ((ULONG64)1 << ISR_R)));
            
            ADDRFLAT(BpAddr, Record->ExceptionInformation[1]);
            return EXBS_BREAKPOINT_DATA;
        }
        else if (Record->ExceptionInformation[4] & 0x4) 
        {
            // Must be taken branch exception
            if (RelAddr) 
            {
                // TrapFrame->StIIPA contains actual branch address
                ADDRFLAT(RelAddr, Record->ExceptionInformation[3]); 
            }
            return EXBS_STEP_BRANCH;
        }
        else
        {
            // Must be a real single-step.
            return EXBS_STEP_INSTRUCTION;
        }
    }
    
    return EXBS_NONE;
}

BOOL
Ia64MachineInfo::IsCallDisasm (PCSTR Disasm)
{
    return (strstr(Disasm, " br.call") || strstr(Disasm, ")br.call")) &&
        !strstr(Disasm, "=0)");
}

BOOL
Ia64MachineInfo::IsReturnDisasm (PCSTR Disasm)
{
    return (strstr(Disasm, " br.ret") || strstr(Disasm, ")br.ret")) &&
        !strstr(Disasm, "=0)");
}

BOOL
Ia64MachineInfo::IsSystemCallDisasm(PCSTR Disasm)
{
    return (strstr(Disasm, " break ") || strstr(Disasm, ")break ")) &&
        strstr(Disasm, " 18000") && !strstr(Disasm, "=0)");
}
    
BOOL
Ia64MachineInfo::IsDelayInstruction (PADDR Addr)
{
    return FALSE;        // EM does not implement delay slot
}

void
Ia64MachineInfo::GetEffectiveAddr (PADDR Addr)
{
    ErrOut("! IA64 does not set EA during disasm !\n");
    ADDRFLAT(Addr, 0);
}

void
Ia64MachineInfo::GetNextOffset(BOOL StepOver,
                               PADDR NextAddr, PULONG NextMachine)
{
    ULONG64 returnvalue;
    ULONG64 firaddr, syladdr;
    ADDR    fir;
    ULONG   slot;
    EM_IL   location;

    // Default NextMachine to the same machine.
    *NextMachine = m_ExecTypes[0];
    
    // Check support for hardware stepping.  Older
    // kernels did not handle it properly.
    BOOL UseTraceFlag =
        !IS_KERNEL_TARGET() || (g_KdVersion.Flags & DBGKD_VERS_FLAG_HSS);

    int    instr_length;
    EM_Decoder_Info    info;

    IEL_ZERO(location);

    firaddr = GetReg64(STIIP);        // get bundle address from IIP
    ADDRFLAT( &fir, firaddr );
    instr_length = GetMemString(&fir, (PUCHAR)&g_Ia64Disinstr, sizeof(U128));
    
    slot = (ULONG)((GetReg64(STIPSR) >> PSR_RI) & 0x3);        //  get slot number from ISR.ei
    syladdr = firaddr | slot ;
    IEL_ASSIGNU(location, *(U64*)(&syladdr));

    // assume next slot is the target address
    // convert bundle address - firaddr to EM address
    // the slot# of Gambit internal address is at bit(0,1)
    // EM address slot# is at bit(2,3)
    switch (slot) 
    {
    case 0:
        returnvalue = firaddr + 4;
        break;

    case 1:
        returnvalue = firaddr + 8;
        break;

    case 2:
        returnvalue = firaddr + 16;
        break;

    default:
        WarnOut("GetNextOffset: illegal EM address: %s",
                FormatAddr64(firaddr));
    }

    if (!InitDecoder()) 
    {
        ErrOut("EM decoder library(DECEM.DLL) not active\n");

        // We can't analyze the current instruction to
        // determine how and where to step so just rely
        // on hardware tracing if possible.
        if (UseTraceFlag)
        {
            returnvalue = OFFSET_TRACE;
        }
    } 
    else 
    {
        EM_Decoder_Err err = (*pfnEM_Decoder_decode)(DecoderId,
                                                     g_Ia64Disinstr,
                                                     instr_length,
                                                     location,
                                                     &info);

        if (err == EM_DECODER_NO_ERROR) 
        {
#if 0
            dprintf("GNO inst at %I64x:%d is %d\n",
                    firaddr, slot, info.inst);
#endif
            if (info.EM_info.em_bundle_info.b_template == EM_template_mlx &&
                slot == 1)
            {
                // Increment return offset since L+X instructions take
                // two instruction slots.
                switch (returnvalue & 0xf)
                {
                case 8:
                    returnvalue = returnvalue + 8;
                    break;

                default:
                    WarnOut("GetNextOffset: illegal L+X address: %s",
                            FormatAddr64(firaddr));
                    break;
                }
            }
            
            switch (info.inst)
            {
            // break imm21
            //
            case EM_BREAK_I_IMM21:
            case EM_BREAK_M_IMM21:
            case EM_BREAK_B_IMM21:
            case EM_BREAK_F_IMM21:

                // Stepping over a syscall instruction must set the breakpoint
                // at the caller's return address, not the inst after the
                // syscall.  Stepping into a syscall is not allowed
                // from user-mode.
                if (!StepOver && IS_KERNEL_TARGET() && UseTraceFlag) 
                {
                    returnvalue = OFFSET_TRACE;
                    break;
                }

                if (info.src1.type == EM_DECODER_IMMEDIATE) 
                {
                    if (info.src1.imm_info.imm_type == 
                        EM_DECODER_IMM_UNSIGNED)
                    {
                        if (((IEL_GETDW0(info.src1.imm_info.val64) & 0x1c0000) == 
                              IA64_BREAK_SYSCALL_BASE) ||
                            ((IEL_GETDW0(info.src1.imm_info.val64) & 0x1c0000) == 
                              IA64_BREAK_FASTSYS_BASE))
                        {
                            returnvalue = GetReg64(BRRP);
                        }
                    }
                }
                break;

            //
            // IP-Relative call B3           - br.call b1=target25
            //
            case EM_BR_CALL_SPNT_FEW_B1_TARGET25:
            case EM_BR_CALL_SPNT_MANY_B1_TARGET25:
            case EM_BR_CALL_SPTK_FEW_B1_TARGET25:
            case EM_BR_CALL_SPTK_MANY_B1_TARGET25:
            case EM_BR_CALL_DPNT_FEW_B1_TARGET25:
            case EM_BR_CALL_DPNT_MANY_B1_TARGET25:
            case EM_BR_CALL_DPTK_FEW_B1_TARGET25:
            case EM_BR_CALL_DPTK_MANY_B1_TARGET25:
            case EM_BR_CALL_SPNT_FEW_CLR_B1_TARGET25:
            case EM_BR_CALL_SPNT_MANY_CLR_B1_TARGET25:
            case EM_BR_CALL_SPTK_FEW_CLR_B1_TARGET25:
            case EM_BR_CALL_SPTK_MANY_CLR_B1_TARGET25:
            case EM_BR_CALL_DPNT_FEW_CLR_B1_TARGET25:
            case EM_BR_CALL_DPNT_MANY_CLR_B1_TARGET25:
            case EM_BR_CALL_DPTK_FEW_CLR_B1_TARGET25:
            case EM_BR_CALL_DPTK_MANY_CLR_B1_TARGET25:

                // 64-bit target L+X forms.
            case EM_BRL_CALL_SPTK_FEW_B1_TARGET64:
            case EM_BRL_CALL_SPTK_MANY_B1_TARGET64:
            case EM_BRL_CALL_SPNT_FEW_B1_TARGET64:
            case EM_BRL_CALL_SPNT_MANY_B1_TARGET64:
            case EM_BRL_CALL_DPTK_FEW_B1_TARGET64:
            case EM_BRL_CALL_DPTK_MANY_B1_TARGET64:
            case EM_BRL_CALL_DPNT_FEW_B1_TARGET64:
            case EM_BRL_CALL_DPNT_MANY_B1_TARGET64:
            case EM_BRL_CALL_SPTK_FEW_CLR_B1_TARGET64:
            case EM_BRL_CALL_SPTK_MANY_CLR_B1_TARGET64:
            case EM_BRL_CALL_SPNT_FEW_CLR_B1_TARGET64:
            case EM_BRL_CALL_SPNT_MANY_CLR_B1_TARGET64:
            case EM_BRL_CALL_DPTK_FEW_CLR_B1_TARGET64:
            case EM_BRL_CALL_DPTK_MANY_CLR_B1_TARGET64:
            case EM_BRL_CALL_DPNT_FEW_CLR_B1_TARGET64:
            case EM_BRL_CALL_DPNT_MANY_CLR_B1_TARGET64:

                if (StepOver) 
                {
                    //
                    // Step over the subroutine call;
                    //
                    break;
                }

                // fall through
                //
            //
            // IP-Relative branch B1         - br.cond target25
            //
            case EM_BR_COND_SPNT_FEW_TARGET25:
            case EM_BR_COND_SPNT_MANY_TARGET25:
            case EM_BR_COND_SPTK_FEW_TARGET25:
            case EM_BR_COND_SPTK_MANY_TARGET25:
            case EM_BR_COND_DPNT_FEW_TARGET25:
            case EM_BR_COND_DPNT_MANY_TARGET25:
            case EM_BR_COND_DPTK_FEW_TARGET25:
            case EM_BR_COND_DPTK_MANY_TARGET25:
            case EM_BR_COND_SPNT_FEW_CLR_TARGET25:
            case EM_BR_COND_SPNT_MANY_CLR_TARGET25:
            case EM_BR_COND_SPTK_FEW_CLR_TARGET25:
            case EM_BR_COND_SPTK_MANY_CLR_TARGET25:
            case EM_BR_COND_DPNT_FEW_CLR_TARGET25:
            case EM_BR_COND_DPNT_MANY_CLR_TARGET25:
            case EM_BR_COND_DPTK_FEW_CLR_TARGET25:
            case EM_BR_COND_DPTK_MANY_CLR_TARGET25:

                // 64-bit target L+X forms.
            case EM_BRL_COND_SPTK_FEW_TARGET64:
            case EM_BRL_COND_SPTK_MANY_TARGET64:
            case EM_BRL_COND_SPNT_FEW_TARGET64:
            case EM_BRL_COND_SPNT_MANY_TARGET64:
            case EM_BRL_COND_DPTK_FEW_TARGET64:
            case EM_BRL_COND_DPTK_MANY_TARGET64:
            case EM_BRL_COND_DPNT_FEW_TARGET64:
            case EM_BRL_COND_DPNT_MANY_TARGET64:
            case EM_BRL_COND_SPTK_FEW_CLR_TARGET64:
            case EM_BRL_COND_SPTK_MANY_CLR_TARGET64:
            case EM_BRL_COND_SPNT_FEW_CLR_TARGET64:
            case EM_BRL_COND_SPNT_MANY_CLR_TARGET64:
            case EM_BRL_COND_DPTK_FEW_CLR_TARGET64:
            case EM_BRL_COND_DPTK_MANY_CLR_TARGET64:
            case EM_BRL_COND_DPNT_FEW_CLR_TARGET64:
            case EM_BRL_COND_DPNT_MANY_CLR_TARGET64:

                if (UseTraceFlag) 
                {
                    returnvalue = OFFSET_TRACE;
                    break;
                }
        
                if ((info.pred.valid == TRUE) && 
                    (info.pred.type == EM_DECODER_PRED_REG)) 
                {
                    if ((GetReg64(PREDS) >> info.pred.value) & 0x1) // if PR[qp] = 1
                    {
                        if (info.src1.type == EM_DECODER_IP_RELATIVE) {
                            // imm_info.val64 is sign-extended (imm21 << 4)
                            returnvalue = (IEL_GETQW0(info.src1.imm_info.val64)) + 
                                          firaddr;
                        }
                    }
                }
                break;

            //                               - br.wexit target25
            case EM_BR_WEXIT_SPNT_FEW_TARGET25:
            case EM_BR_WEXIT_SPNT_MANY_TARGET25:
            case EM_BR_WEXIT_SPTK_FEW_TARGET25:
            case EM_BR_WEXIT_SPTK_MANY_TARGET25:
            case EM_BR_WEXIT_DPNT_FEW_TARGET25:
            case EM_BR_WEXIT_DPNT_MANY_TARGET25:
            case EM_BR_WEXIT_DPTK_FEW_TARGET25:
            case EM_BR_WEXIT_DPTK_MANY_TARGET25:
            case EM_BR_WEXIT_SPNT_FEW_CLR_TARGET25:
            case EM_BR_WEXIT_SPNT_MANY_CLR_TARGET25:
            case EM_BR_WEXIT_SPTK_FEW_CLR_TARGET25:
            case EM_BR_WEXIT_SPTK_MANY_CLR_TARGET25:
            case EM_BR_WEXIT_DPNT_FEW_CLR_TARGET25:
            case EM_BR_WEXIT_DPNT_MANY_CLR_TARGET25:
            case EM_BR_WEXIT_DPTK_FEW_CLR_TARGET25:
            case EM_BR_WEXIT_DPTK_MANY_CLR_TARGET25:

                if (UseTraceFlag) 
                {
                    returnvalue = OFFSET_TRACE;
                    break;
                }

                if ((info.pred.valid == TRUE) && 
                    (info.pred.type == EM_DECODER_PRED_REG)) 
                {
                    if ((GetReg64(PREDS) >> info.pred.value) & 0x1)  // if PR[qp] = 1, epilog
                    {
                        if (GetReg64(APEC) <= 1) // WEXIT; branch if EC = 0 or 1
                        {
                            if (info.src1.type == EM_DECODER_IP_RELATIVE) {
                                returnvalue = 
                                    (IEL_GETQW0(info.src1.imm_info.val64)) + firaddr;
                            }
                        }
                    }
                }                                   // if PR[qp] = 0, kernel; fall-thru
                break;

            //                               - br.wtop target25
            case EM_BR_WTOP_SPNT_FEW_TARGET25:
            case EM_BR_WTOP_SPNT_MANY_TARGET25:
            case EM_BR_WTOP_SPTK_FEW_TARGET25:
            case EM_BR_WTOP_SPTK_MANY_TARGET25:
            case EM_BR_WTOP_DPNT_FEW_TARGET25:
            case EM_BR_WTOP_DPNT_MANY_TARGET25:
            case EM_BR_WTOP_DPTK_FEW_TARGET25:
            case EM_BR_WTOP_DPTK_MANY_TARGET25:
            case EM_BR_WTOP_SPNT_FEW_CLR_TARGET25:
            case EM_BR_WTOP_SPNT_MANY_CLR_TARGET25:
            case EM_BR_WTOP_SPTK_FEW_CLR_TARGET25:
            case EM_BR_WTOP_SPTK_MANY_CLR_TARGET25:
            case EM_BR_WTOP_DPNT_FEW_CLR_TARGET25:
            case EM_BR_WTOP_DPNT_MANY_CLR_TARGET25:
            case EM_BR_WTOP_DPTK_FEW_CLR_TARGET25:
            case EM_BR_WTOP_DPTK_MANY_CLR_TARGET25:

                if (UseTraceFlag) 
                {
                    returnvalue = OFFSET_TRACE;
                    break;
                }

                if ((info.pred.valid == TRUE) && 
                    (info.pred.type == EM_DECODER_PRED_REG)) 
                {
                    if ((GetReg64(PREDS) >> info.pred.value) & 0x1) // if PR[qp] = 1, epilog
                    {
                        if (GetReg64(APEC) > 1)  // WTOP; branch if EC > 1
                        {
                            if (info.src1.type == EM_DECODER_IP_RELATIVE)
                            {
                                returnvalue = 
                                    (IEL_GETQW0(info.src1.imm_info.val64)) + firaddr;
                            }
                        }
                    }
                }
                else // if PR[qp] = 0, kernel; branch
                {
                    if (info.src1.type == EM_DECODER_IP_RELATIVE) {
                        returnvalue = 
                            (IEL_GETQW0(info.src1.imm_info.val64)) + firaddr;
                    }
                }
                break;

            //
            // IP-Relative counted branch B2 - br.cloop target25
            //
            case EM_BR_CLOOP_SPNT_FEW_TARGET25:
            case EM_BR_CLOOP_SPNT_MANY_TARGET25:
            case EM_BR_CLOOP_SPTK_FEW_TARGET25:
            case EM_BR_CLOOP_SPTK_MANY_TARGET25:
            case EM_BR_CLOOP_DPNT_FEW_TARGET25:
            case EM_BR_CLOOP_DPNT_MANY_TARGET25:
            case EM_BR_CLOOP_DPTK_FEW_TARGET25:
            case EM_BR_CLOOP_DPTK_MANY_TARGET25:
            case EM_BR_CLOOP_SPNT_FEW_CLR_TARGET25:
            case EM_BR_CLOOP_SPNT_MANY_CLR_TARGET25:
            case EM_BR_CLOOP_SPTK_FEW_CLR_TARGET25:
            case EM_BR_CLOOP_SPTK_MANY_CLR_TARGET25:
            case EM_BR_CLOOP_DPNT_FEW_CLR_TARGET25:
            case EM_BR_CLOOP_DPNT_MANY_CLR_TARGET25:
            case EM_BR_CLOOP_DPTK_FEW_CLR_TARGET25:
            case EM_BR_CLOOP_DPTK_MANY_CLR_TARGET25:

                if (UseTraceFlag) 
                {
                    returnvalue = OFFSET_TRACE;
                    break;
                }

                if (GetReg64(APLC)) // branch if LC != 0
                {
                    if (info.src1.type == EM_DECODER_IP_RELATIVE)
                    {
                        returnvalue = 
                            (IEL_GETQW0(info.src1.imm_info.val64)) + firaddr;
                    }
                }
                break;

            //                               - br.cexit target25
            case EM_BR_CEXIT_SPNT_FEW_TARGET25:
            case EM_BR_CEXIT_SPNT_MANY_TARGET25:
            case EM_BR_CEXIT_SPTK_FEW_TARGET25:
            case EM_BR_CEXIT_SPTK_MANY_TARGET25:
            case EM_BR_CEXIT_DPNT_FEW_TARGET25:
            case EM_BR_CEXIT_DPNT_MANY_TARGET25:
            case EM_BR_CEXIT_DPTK_FEW_TARGET25:
            case EM_BR_CEXIT_DPTK_MANY_TARGET25:
            case EM_BR_CEXIT_SPNT_FEW_CLR_TARGET25:
            case EM_BR_CEXIT_SPNT_MANY_CLR_TARGET25:
            case EM_BR_CEXIT_SPTK_FEW_CLR_TARGET25:
            case EM_BR_CEXIT_SPTK_MANY_CLR_TARGET25:
            case EM_BR_CEXIT_DPNT_FEW_CLR_TARGET25:
            case EM_BR_CEXIT_DPNT_MANY_CLR_TARGET25:
            case EM_BR_CEXIT_DPTK_FEW_CLR_TARGET25:
            case EM_BR_CEXIT_DPTK_MANY_CLR_TARGET25:

                if (UseTraceFlag) 
                {
                    returnvalue = OFFSET_TRACE;
                    break;
                }

                if (!GetReg64(APLC)) // if LC = 0, epilog
                {
                    if (GetReg64(APEC) <= 1) // CEXIT; branch if EC = 0 or 1
                    {
                        if (info.src1.type == EM_DECODER_IP_RELATIVE)
                        {
                            returnvalue = 
                                (IEL_GETQW0(info.src1.imm_info.val64)) + firaddr;
                        }
                    }
                }                                                    // if LC > 0, kernel; fall-thru
                break;

            //                               - br.ctop target25
            case EM_BR_CTOP_SPNT_FEW_TARGET25:
            case EM_BR_CTOP_SPNT_MANY_TARGET25:
            case EM_BR_CTOP_SPTK_FEW_TARGET25:
            case EM_BR_CTOP_SPTK_MANY_TARGET25:
            case EM_BR_CTOP_DPNT_FEW_TARGET25:
            case EM_BR_CTOP_DPNT_MANY_TARGET25:
            case EM_BR_CTOP_DPTK_FEW_TARGET25:
            case EM_BR_CTOP_DPTK_MANY_TARGET25:
            case EM_BR_CTOP_SPNT_FEW_CLR_TARGET25:
            case EM_BR_CTOP_SPNT_MANY_CLR_TARGET25:
            case EM_BR_CTOP_SPTK_FEW_CLR_TARGET25:
            case EM_BR_CTOP_SPTK_MANY_CLR_TARGET25:
            case EM_BR_CTOP_DPNT_FEW_CLR_TARGET25:
            case EM_BR_CTOP_DPNT_MANY_CLR_TARGET25:
            case EM_BR_CTOP_DPTK_FEW_CLR_TARGET25:
            case EM_BR_CTOP_DPTK_MANY_CLR_TARGET25:

                if (!GetReg64(APLC)) // if LC = 0, epilog
                {
                    if (GetReg64(APEC) > 1) // CTOP; branch if EC > 1
                    {
                        if (info.src1.type == EM_DECODER_IP_RELATIVE) 
                        {
                            returnvalue = 
                                (IEL_GETQW0(info.src1.imm_info.val64)) + firaddr;
                        }
                    }
                }
                else // if LC > 0, kernel; branch
                {
                    if (info.src1.type == EM_DECODER_IP_RELATIVE) 
                    {
                        returnvalue = 
                            (IEL_GETQW0(info.src1.imm_info.val64)) + firaddr;
                    }
                }
                break;

            //
            // Indirect call B5            - br.call b1=b2
            //
            case EM_BR_CALL_SPNT_FEW_B1_B2:
            case EM_BR_CALL_SPNT_MANY_B1_B2:
            case EM_BR_CALL_SPTK_FEW_B1_B2:
            case EM_BR_CALL_SPTK_MANY_B1_B2:
            case EM_BR_CALL_DPNT_FEW_B1_B2:
            case EM_BR_CALL_DPNT_MANY_B1_B2:
            case EM_BR_CALL_DPTK_FEW_B1_B2:
            case EM_BR_CALL_DPTK_MANY_B1_B2:
            case EM_BR_CALL_SPNT_FEW_CLR_B1_B2:
            case EM_BR_CALL_SPNT_MANY_CLR_B1_B2:
            case EM_BR_CALL_SPTK_FEW_CLR_B1_B2:
            case EM_BR_CALL_SPTK_MANY_CLR_B1_B2:
            case EM_BR_CALL_DPNT_FEW_CLR_B1_B2:
            case EM_BR_CALL_DPNT_MANY_CLR_B1_B2:
            case EM_BR_CALL_DPTK_FEW_CLR_B1_B2:
            case EM_BR_CALL_DPTK_MANY_CLR_B1_B2:

                if (StepOver) 
                {
                    //
                    // Step over the subroutine call;
                    //
                    break;
                }

                // fall through
                //
            //
            // Indirect branch B4           - br.ia b2
            //
            case EM_BR_IA_SPNT_FEW_B2:
            case EM_BR_IA_SPNT_MANY_B2:
            case EM_BR_IA_SPTK_FEW_B2:
            case EM_BR_IA_SPTK_MANY_B2:
            case EM_BR_IA_DPNT_FEW_B2:
            case EM_BR_IA_DPNT_MANY_B2:
            case EM_BR_IA_DPTK_FEW_B2:
            case EM_BR_IA_DPTK_MANY_B2:
            case EM_BR_IA_SPNT_FEW_CLR_B2:
            case EM_BR_IA_SPNT_MANY_CLR_B2:
            case EM_BR_IA_SPTK_FEW_CLR_B2:
            case EM_BR_IA_SPTK_MANY_CLR_B2:
            case EM_BR_IA_DPNT_FEW_CLR_B2:
            case EM_BR_IA_DPNT_MANY_CLR_B2:
            case EM_BR_IA_DPTK_FEW_CLR_B2:
            case EM_BR_IA_DPTK_MANY_CLR_B2:

                if (UseTraceFlag)
                {
                    returnvalue = OFFSET_TRACE;
                    break;
                }
                
                // Unconditional branch to IA32 so the machine
                // changes.
                *NextMachine = IMAGE_FILE_MACHINE_I386;
                
                // fall through
                //
            //                              - br.cond b2
            case EM_BR_COND_SPNT_FEW_B2:
            case EM_BR_COND_SPNT_MANY_B2:
            case EM_BR_COND_SPTK_FEW_B2:
            case EM_BR_COND_SPTK_MANY_B2:
            case EM_BR_COND_DPNT_FEW_B2:
            case EM_BR_COND_DPNT_MANY_B2:
            case EM_BR_COND_DPTK_FEW_B2:
            case EM_BR_COND_DPTK_MANY_B2:
            case EM_BR_COND_SPNT_FEW_CLR_B2:
            case EM_BR_COND_SPNT_MANY_CLR_B2:
            case EM_BR_COND_SPTK_FEW_CLR_B2:
            case EM_BR_COND_SPTK_MANY_CLR_B2:
            case EM_BR_COND_DPNT_FEW_CLR_B2:
            case EM_BR_COND_DPNT_MANY_CLR_B2:
            case EM_BR_COND_DPTK_FEW_CLR_B2:
            case EM_BR_COND_DPTK_MANY_CLR_B2:

                // If we're in user-mode we can't necessarily
                // use hardware stepping here because this
                // may be a branch into the EPC region for
                // a system call that we do not want to trace.
                if (!StepOver && IS_KERNEL_TARGET() && UseTraceFlag) 
                {
                    returnvalue = OFFSET_TRACE;
                    break;
                }

                if ((info.pred.valid == TRUE) && 
                    (info.pred.type == EM_DECODER_PRED_REG)) 
                {
                    if ((GetReg64(PREDS) >> info.pred.value) & 0x1) // if PR[qp] = 1
                    {
                        if (info.src1.type == EM_DECODER_REGISTER) 
                        {
                            if (info.src1.reg_info.type == EM_DECODER_BR_REG)
                            {
                                returnvalue = GetReg64(info.src1.reg_info.value + BRRP);

                                // Check for syscall (IA64_MM_EPC_VA) then 
                                // return address is in B0
                                if (!IS_KERNEL_TARGET() &&
                                    (returnvalue == IA64_MM_EPC_VA + 0x20)) 
                                {
                                    returnvalue = GetReg64(BRRP);
                                }
                            }
                        }
                    }
                }
                break;

            //                              - br.ret b2
            case EM_BR_RET_SPNT_FEW_B2:
            case EM_BR_RET_SPNT_MANY_B2:
            case EM_BR_RET_SPTK_FEW_B2:
            case EM_BR_RET_SPTK_MANY_B2:
            case EM_BR_RET_DPNT_FEW_B2:
            case EM_BR_RET_DPNT_MANY_B2:
            case EM_BR_RET_DPTK_FEW_B2:
            case EM_BR_RET_DPTK_MANY_B2:
            case EM_BR_RET_SPNT_FEW_CLR_B2:
            case EM_BR_RET_SPNT_MANY_CLR_B2:
            case EM_BR_RET_SPTK_FEW_CLR_B2:
            case EM_BR_RET_SPTK_MANY_CLR_B2:
            case EM_BR_RET_DPNT_FEW_CLR_B2:
            case EM_BR_RET_DPNT_MANY_CLR_B2:
            case EM_BR_RET_DPTK_FEW_CLR_B2:
            case EM_BR_RET_DPTK_MANY_CLR_B2:

                if (UseTraceFlag) 
                {
                    returnvalue = OFFSET_TRACE;
                    break;
                }

                if ((info.pred.valid == TRUE) && 
                    (info.pred.type == EM_DECODER_PRED_REG)) 
                {
                    if ((GetReg64(PREDS) >> info.pred.value) & 0x1) // if PR[qp] = 1
                    {
                        if (info.src1.type == EM_DECODER_REGISTER) 
                        {
                            if (info.src1.reg_info.type == EM_DECODER_BR_REG)
                            {
                                returnvalue = GetReg64(info.src1.reg_info.value + BRRP);
                            }
                        }
                    }
                }
                break;

            // chk always branches under debugger

            case EM_CHK_S_I_R2_TARGET25:
            case EM_CHK_S_M_R2_TARGET25:
            case EM_CHK_S_F2_TARGET25:
            case EM_CHK_A_CLR_R1_TARGET25:
            case EM_CHK_A_CLR_F1_TARGET25:
            case EM_CHK_A_NC_R1_TARGET25:
            case EM_CHK_A_NC_F1_TARGET25:

                if (UseTraceFlag) 
                {
                    returnvalue = OFFSET_TRACE;
                    break;
                }

                if ((info.pred.valid == TRUE) && (info.pred.type == EM_DECODER_PRED_REG)) 
                {
                    if ((GetReg64(PREDS) >> info.pred.value) & 0x1) // if PR[qp] = 1
                    {
                        returnvalue = 
                            IEL_GETQW0(info.src2.imm_info.val64) + firaddr;
                    }
                }
                break;

            default:

                if (UseTraceFlag) 
                {
                    returnvalue = OFFSET_TRACE;
                    break;
                }

                break;
            }
        }
        else if (UseTraceFlag)
        {
            // We can't analyze the current instruction to
            // determine how and where to step so just rely
            // on hardware tracing if possible.
            returnvalue = OFFSET_TRACE;
        }
        else
        {
            ErrOut("em_decoder_decode: %s\n",
                   (*pfnEM_Decoder_err_msg)((EM_Decoder_Err) err));
        }
    }

    ADDRFLAT( NextAddr, returnvalue );
}

BOOL
Ia64MachineInfo::GetPrefixedSymbolOffset(ULONG64 SymOffset,
                                         ULONG Flags,
                                         PULONG64 PrefixedSymOffset)
{
    ULONG64 EntryPoint;
    ULONG64 HalfBundle;
    
    if (g_Target->ReadPointer(this, SymOffset, &EntryPoint) != S_OK)
    {
        if (Flags & GETPREF_VERBOSE)
        {
            ErrOut("Ia64MachineInfo::GetPrefixedSymbolOffset: "
                   "Unable to read IA64 PLABEL entry point @ 0x%I64x\n",
                   SymOffset);
        }
        return FALSE;
    }
    
    *PrefixedSymOffset = EntryPoint;

    if (!ReadVirt(EntryPoint, HalfBundle))
    {
        if (Flags & GETPREF_VERBOSE)
        {
            WarnOut("Ia64MachineInfo::GetPrefixedSymbolOffset: "
                    "Reading half bundle @ 0x%I64x failed\n", EntryPoint);
        }
    }
    else
    {
        PEM_TEMPLATE_INFO TemplInfo;
        
        TemplInfo = EmTemplateInfo(GET_TEMPLATE(HalfBundle));
        if (TemplInfo && (TemplInfo->slot[0].unit != No_Unit))
        {
#if 0
            dprintf("Ia64MachineInfo::GetPrefixedSymbolOffset: "
                    "Seems to be a valid bundle: %s.\n", 
                    TemplInfo->name);
#endif
        }
        else if (Flags & GETPREF_VERBOSE)
        {
            WarnOut("Ia64MachineInfo::GetPrefixedSymbolOffset: "
                    "Read IA64 PLABEL entry point @ 0xI64x is NOT "
                    "a valid bundle...\n", 
                    EntryPoint);
        }
    }

    return TRUE;
}

void
Ia64MachineInfo::IncrementBySmallestInstruction (PADDR Addr)
{
    if ((Flat(*Addr) & 0xf) == 8)
    {
        AddrAdd(Addr, 8);
    }
    else
    {
        AddrAdd(Addr, 4);
    }
}

void
Ia64MachineInfo::DecrementBySmallestInstruction (PADDR Addr)
{
    if ((Flat(*Addr) & 0xf) == 0)
    {
        AddrSub(Addr, 8);
    }
    else
    {
        AddrSub(Addr, 4);
    }
}

void 
Ia64MachineInfo::PrintStackFrameAddressesTitle(ULONG Flags)
{
    if (Flags & DEBUG_STACK_FRAME_ADDRESSES_RA_ONLY)
    {
        MachineInfo::PrintStackFrameAddressesTitle(Flags);
    }
    else 
    {
        PrintMultiPtrTitle("Child-SP", 1);
        PrintMultiPtrTitle("Child-BSP", 1);
        PrintMultiPtrTitle("RetAddr", 1);
    }
}

void 
Ia64MachineInfo::PrintStackFrameAddresses(ULONG Flags, 
                                          PDEBUG_STACK_FRAME StackFrame)
{
    if (Flags & DEBUG_STACK_FRAME_ADDRESSES_RA_ONLY)
    {
        MachineInfo::PrintStackFrameAddresses(Flags, StackFrame);
    }
    else
    {
        dprintf("%s %s %s ", 
                FormatAddr64(StackFrame->StackOffset),
                FormatAddr64(StackFrame->FrameOffset),
                FormatAddr64(StackFrame->ReturnOffset));
    }
}

void 
Ia64MachineInfo::PrintStackArgumentsTitle(ULONG Flags)
{
    if (Flags & DEBUG_STACK_NONVOLATILE_REGISTERS)
    {
        return;
    }
    MachineInfo::PrintStackArgumentsTitle(Flags);
}

void 
Ia64MachineInfo::PrintStackArguments(ULONG Flags, 
                                     PDEBUG_STACK_FRAME StackFrame)
{
    if (Flags & DEBUG_STACK_NONVOLATILE_REGISTERS)
    {
        return;
    }
    MachineInfo::PrintStackArguments(Flags, StackFrame);
}

void 
Ia64MachineInfo::PrintStackNonvolatileRegisters(ULONG Flags, 
                                                PDEBUG_STACK_FRAME StackFrame,
                                                PCROSS_PLATFORM_CONTEXT Context,
                                                ULONG FrameNum)
{
    ULONGLONG   Registers[96+2];
    ULONGLONG   RegisterHome = Context->IA64Context.RsBSP;
    ULONG       RegisterCount;
    ULONG       RegisterNumber;
    ULONG       ReadLength;
    ULONG       i;

    i = (ULONG)Context->IA64Context.StIFS & 0x3fff;

    if (FrameNum = 0) {
        RegisterCount = i & 0x7f;
    } else {
        RegisterCount = (i >> 7) & 0x7f;
    }

    // Sanity.

    if (RegisterCount > 96) {
        return;
    }

    if (RegisterHome & 3) {
        return;
    }

#if 0

    //
    // This is only for debugging this function.
    //

    dprintf("  IFS   %016I64x  PFS  %016I64x\n",
            Context->IA64Context.StIFS,
            Context->IA64Context.RsPFS);
#endif

    if (RegisterCount == 0) {
#if 0 
//        //
//        // Not much point doing anything in this case.
//        //
//
//        dprintf("\n");
//        return;
#endif
        // Display at least 4 registers
        RegisterCount = 4;
    }

    //
    // Calculate the number of registers to read from the
    // RSE stack.  For every 63 registers there will be at
    // at least one NaT collection register, depending on
    // where we start, there may be another one.
    //
    // First, starting at the current BSP, if we cross a 64 (0x40)
    // boundry, then we have an extra.
    //

    ReadLength = (((((ULONG)Context->IA64Context.RsBSP) >> 3) & 0x1f) + RegisterCount) >> 6;

    //
    // Add 1 for every 63 registers.
    //

    ReadLength = (RegisterCount / 63) + RegisterCount;
    ReadLength *= sizeof(ULONGLONG);

    //
    // Read the registers for this frame.
    //

    if (!SwReadMemory(g_CurrentProcess->Handle,
                      RegisterHome,
                      Registers,
                      ReadLength,
                      &i)) {

        //
        // This shouldn't have happened.
        //

        ErrOut("-- Couldn't read registers BSP=%I64x, length %d.\n",
               RegisterHome,
               ReadLength);
        return;
    }


    //
    // Note: the following code should be altered to understand
    //       NaTs as they come from the register stack (currently
    //       it ignores them).
    //

    RegisterNumber = 32;
    for (i = 0; RegisterCount; RegisterHome += sizeof(ULONGLONG), i++) {

        //
        // For now, just skip NaT collection registers.  Every
        // 64th entry is a NaT collection register and the RSE
        // stack is nicely aligned so any entry at an address
        // ending in 63*8 is a NaT entry.
        //
        // 63 * 8  ==  0x3f << 3  ==  0x1f8
        //

        if ((RegisterHome & 0x1f8) == 0x1f8) {
            continue;
        }

        if ((RegisterNumber & 3) == 0) {
            if (RegisterNumber <= 99) {
                dprintf(" ");
            }
            dprintf("r%d", RegisterNumber);
        }

        dprintf(" %s", FormatAddr64(Registers[i]));

        if ((RegisterNumber & 3) == 3) {
            dprintf("\n");
        }

        RegisterNumber++;
        RegisterCount--;
    }

    if ((RegisterNumber & 3) != 0) {
        dprintf("\n");
    }
    dprintf("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\ia64_mach.hpp ===
//----------------------------------------------------------------------------
//
// IA64 machine implementation.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#ifndef __IA64_MACH_HPP__
#define __IA64_MACH_HPP__

//
// NOTE: Be very careful when using machine-specific header files
// such as nt<plat>.h.  The machine implementation class is
// compiled for all platforms so the nt<plat>.h file will be the
// one for the build platform, not necessarily the platform
// of the machine implementation.  ntdbg.h contains many cross-platform
// types and definitions that can be used to avoid problems.
//

class Ia64MachineInfo : public MachineInfo
{
public:
    // MachineInfo.
    virtual HRESULT InitializeConstants(void);
    virtual HRESULT InitializeForTarget(void);
    
    virtual void InitializeContext
        (ULONG64 Pc, PDBGKD_ANY_CONTROL_REPORT ControlReport);
    virtual HRESULT KdGetContextState(ULONG State);
    virtual HRESULT KdSetContext(void);
    virtual HRESULT ConvertContextFrom(PCROSS_PLATFORM_CONTEXT Context,
                                       ULONG FromSver,
                                       ULONG FromSize, PVOID From);
    virtual HRESULT ConvertContextTo(PCROSS_PLATFORM_CONTEXT Context,
                                     ULONG ToSver, ULONG ToSize, PVOID To);
    virtual void InitializeContextFlags(PCROSS_PLATFORM_CONTEXT Context,
                                        ULONG Version);
    virtual HRESULT GetContextFromThreadStack(ULONG64 ThreadBase,
                                              PCROSS_PLATFORM_THREAD Thread,
                                              PCROSS_PLATFORM_CONTEXT Context,
                                              PDEBUG_STACK_FRAME Frame,
                                              PULONG RunningOnProc);
    
    virtual int  GetType(ULONG index);
    virtual BOOL GetVal(ULONG index, REGVAL *val);
    virtual BOOL SetVal(ULONG index, REGVAL *val);

    virtual void GetPC(PADDR Address);
    virtual void SetPC(PADDR Address);
    virtual void GetFP(PADDR Address);
    virtual void GetSP(PADDR Address);
    virtual ULONG64 GetArgReg(void);

    virtual void OutputAll(ULONG Mask, ULONG OutMask);

    virtual TRACEMODE GetTraceMode(void);
    virtual void SetTraceMode(TRACEMODE Mode);
    virtual BOOL IsStepStatusSupported(ULONG Status);

    virtual void KdUpdateControlSet
        (PDBGKD_ANY_CONTROL_SET ControlSet);

    virtual void KdSaveProcessorState(void);
    virtual void KdRestoreProcessorState(void);

    virtual ULONG ExecutingMachine(void);

    virtual HRESULT SetPageDirectory(ULONG Idx, ULONG64 PageDir,
                                     PULONG NextIdx);
    virtual HRESULT GetVirtualTranslationPhysicalOffsets
        (ULONG64 Virt, PULONG64 Offsets, ULONG OffsetsSize,
         PULONG Levels, PULONG PfIndex, PULONG64 LastVal);
    virtual HRESULT GetBaseTranslationVirtualOffset(PULONG64 Offset);

    virtual void Assemble(PADDR Addr, PSTR Input);
    virtual BOOL Disassemble(PADDR Addr, PSTR Buffer, BOOL EffAddr);

    virtual HRESULT NewBreakpoint(DebugClient* Client, 
                                  ULONG Type, 
                                  ULONG Id, 
                                  Breakpoint** RetBp);

    virtual BOOL IsBreakpointInstruction(PADDR Addr);
    virtual HRESULT InsertBreakpointInstruction(PUSER_DEBUG_SERVICES Services,
                                                ULONG64 Process,
                                                ULONG64 Offset,
                                                PUCHAR SaveInstr,
                                                PULONG64 ChangeStart,
                                                PULONG ChangeLen);
    virtual HRESULT RemoveBreakpointInstruction(PUSER_DEBUG_SERVICES Services,
                                                ULONG64 Process,
                                                ULONG64 Offset,
                                                PUCHAR SaveInstr,
                                                PULONG64 ChangeStart,
                                                PULONG ChangeLen);
    virtual void AdjustPCPastBreakpointInstruction(PADDR Addr,
                                                   ULONG BreakType);
    virtual void InsertAllDataBreakpoints(void);
    virtual void RemoveAllDataBreakpoints(void);
    virtual ULONG IsBreakpointOrStepException(PEXCEPTION_RECORD64 Record,
                                              ULONG FirstChance,
                                              PADDR BpAddr,
                                              PADDR RelAddr);
    
    virtual BOOL IsCallDisasm(PCSTR Disasm);
    virtual BOOL IsReturnDisasm(PCSTR Disasm);
    virtual BOOL IsSystemCallDisasm(PCSTR Disasm);
    
    virtual BOOL IsDelayInstruction(PADDR Addr);
    virtual void GetEffectiveAddr(PADDR Addr);
    virtual void GetNextOffset(BOOL StepOver,
                               PADDR NextAddr, PULONG NextMachine);
    virtual BOOL GetPrefixedSymbolOffset(ULONG64 SymOffset,
                                         ULONG Flags,
                                         PULONG64 PrefixedSymOffset);

    virtual void IncrementBySmallestInstruction(PADDR Addr);
    virtual void DecrementBySmallestInstruction(PADDR Addr);

    virtual void PrintStackFrameAddressesTitle(ULONG Flags);
    virtual void PrintStackFrameAddresses(ULONG Flags, 
                                          PDEBUG_STACK_FRAME StackFrame);
    virtual void PrintStackArgumentsTitle(ULONG Flags);
    virtual void PrintStackArguments(ULONG Flags, 
                                     PDEBUG_STACK_FRAME StackFrame);

    virtual void PrintStackNonvolatileRegisters(ULONG Flags, 
                                                PDEBUG_STACK_FRAME StackFrame,
                                                PCROSS_PLATFORM_CONTEXT Context,
                                                ULONG FrameNum);

    virtual BOOL DisplayTrapFrame(ULONG64 FrameAddress,
                                  OUT PCROSS_PLATFORM_CONTEXT Context);
    virtual void ValidateCxr(PCROSS_PLATFORM_CONTEXT Context);

    virtual void OutputFunctionEntry(PVOID RawEntry);
    virtual HRESULT ReadDynamicFunctionTable(ULONG64 Table,
                                             PULONG64 NextTable,
                                             PULONG64 MinAddress,
                                             PULONG64 MaxAddress,
                                             PULONG64 BaseAddress,
                                             PULONG64 TableData,
                                             PULONG TableSize,
                                             PWSTR OutOfProcessDll,
                                             PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE RawTable);
    virtual PVOID FindDynamicFunctionEntry(PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE Table,
                                           ULONG64 Address,
                                           PVOID TableData,
                                           ULONG TableSize);

    virtual HRESULT ReadKernelProcessorId
        (ULONG Processor, PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id);

    // Ia64MachineInfo.
    BOOL IsIA32InstructionSet(VOID);

    void SetKernelPageDirectory(ULONG64 PageDir)
    {
        m_KernPageDir = PageDir;
    }

protected:
    IA64_KSPECIAL_REGISTERS m_SpecialRegContext, m_SavedSpecialRegContext;
    ULONG64 m_KernPageDir;

    void KdGetSpecialRegistersFromContext(void);
    void KdSetSpecialRegistersInContext(void);

    BOOL GetStackedRegVal(IN ULONG64 RsBSP, 
                          IN USHORT FrameSize, 
                          IN ULONG64 RsRNAT, 
                          IN ULONG regnum, 
                          OUT REGVAL *val);
    BOOL SetStackedRegVal(IN ULONG64 RsBSP, 
                          IN USHORT FrameSize, 
                          IN ULONG64 *RsRNAT, 
                          IN ULONG regnum, 
                          IN REGVAL *val);

    friend class X86OnIa64MachineInfo;
};

// BUGBUG 2-21-2000
// add declspec alignment in the definition because of a compiler bug.

extern Ia64MachineInfo DECLSPEC_ALIGN(16) g_Ia64Machine;

#endif // #ifndef __IA64_MACH_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\ia64_reg.h ===
/****************************************************************************
 *                                                                          *
 * The following enumeration is ordered to match the _CONTEXT record.       *
 * Enumerations after STIFS is ordered to match the _KSPECIAL_REGISTERS     *
 * record.    The ORDERING IS NECESSARY for GetRegValue() to index into the *
 * Context record correctly.                                                *
 *                                                                          *
 * SRxxx may be moved as a group only.                                      *
 *                                                                          *
 * Each floating point register occupies two numbers to address the         *
 * Float128 as two high and low 64-bit parts                                *
 *                                                                          *
 ****************************************************************************/

enum {
    /* Begin of _CONTEXT */

// Debug breakpoint registers
    REGDBI0, REGDBI1, REGDBI2, REGDBI3, REGDBI4, REGDBI5, REGDBI6, REGDBI7,
    REGDBD0, REGDBD1, REGDBD2, REGDBD3, REGDBD4, REGDBD5, REGDBD6, REGDBD7,

    /* all floating point high's are inserted for space */
// Lower floating 
//    FLTZERO, FLTONE,
    FLTS0, FLTS0H, FLTS1, FLTS1H, FLTS2, FLTS2H, FLTS3, FLTS3H, FLTT0, FLTT0H, 
    FLTT1, FLTT1H, FLTT2, FLTT2H, FLTT3, FLTT3H, FLTT4, FLTT4H, FLTT5, FLTT5H, 
    FLTT6, FLTT6H,  FLTT7, FLTT7H, FLTT8, FLTT8H, FLTT9, FLTT9H, 

// high floating saved
    FLTS4, FLTS4H, 
    FLTS5, FLTS5H, FLTS6, FLTS6H, FLTS7, FLTS7H, FLTS8, FLTS8H, FLTS9, FLTS9H, 
    FLTS10, FLTS10H, FLTS11, FLTS11H, FLTS12, FLTS12H, FLTS13, FLTS13H, FLTS14, FLTS14H, 
    FLTS15, FLTS15H, FLTS16, FLTS16H, FLTS17, FLTS17H, FLTS18, FLTS18H, FLTS19, FLTS19H,

// high floating temp 
    FLTF32, FLTF32H, FLTF33, FLTF33H, FLTF34, FLTF34H, FLTF35, FLTF35H, FLTF36, FLTF36H,
    FLTF37, FLTF37H, FLTF38, FLTF38H, FLTF39, FLTF39H, FLTF40, FLTF40H, FLTF41, FLTF41H, 
    FLTF42, FLTF42H, FLTF43, FLTF43H, FLTF44, FLTF44H, FLTF45, FLTF45H, FLTF46, FLTF46H, 
    FLTF47, FLTF47H, FLTF48, FLTF48H, FLTF49, FLTF49H, FLTF50, FLTF50H, FLTF51, FLTF51H, 
    FLTF52, FLTF52H, FLTF53, FLTF53H, FLTF54, FLTF54H, FLTF55, FLTF55H, FLTF56, FLTF56H, 
    FLTF57, FLTF57H, FLTF58, FLTF58H, FLTF59, FLTF59H, FLTF60, FLTF60H, FLTF61, FLTF61H,
    FLTF62, FLTF62H, FLTF63, FLTF63H, FLTF64, FLTF64H, FLTF65, FLTF65H, FLTF66, FLTF66H, 
    FLTF67, FLTF67H, FLTF68, FLTF68H, FLTF69, FLTF69H, FLTF70, FLTF70H, FLTF71, FLTF71H, 
    FLTF72, FLTF72H, FLTF73, FLTF73H, FLTF74, FLTF74H, FLTF75, FLTF75H, FLTF76, FLTF76H, 
    FLTF77, FLTF77H, FLTF78, FLTF78H, FLTF79, FLTF79H, FLTF80, FLTF80H, FLTF81, FLTF81H, 
    FLTF82, FLTF82H, FLTF83, FLTF83H, FLTF84, FLTF84H, FLTF85, FLTF85H, FLTF86, FLTF86H, 
    FLTF87, FLTF87H, FLTF88, FLTF88H, FLTF89, FLTF89H, FLTF90, FLTF90H, FLTF91, FLTF91H,
    FLTF92, FLTF92H, FLTF93, FLTF93H, FLTF94, FLTF94H, FLTF95, FLTF95H, FLTF96, FLTF96H, 
    FLTF97, FLTF97H, FLTF98, FLTF98H, FLTF99, FLTF99H, FLTF100, FLTF100H, FLTF101, FLTF101H, 
    FLTF102, FLTF102H, FLTF103, FLTF103H, FLTF104, FLTF104H, FLTF105, FLTF105H, FLTF106, FLTF106H, 
    FLTF107, FLTF107H, FLTF108, FLTF108H, FLTF109, FLTF109H, FLTF110, FLTF110H, FLTF111, FLTF111H, 
    FLTF112, FLTF112H, FLTF113, FLTF113H, FLTF114, FLTF114H, FLTF115, FLTF115H, FLTF116, FLTF116H, 
    FLTF117, FLTF117H, FLTF118, FLTF118H, FLTF119, FLTF119H, FLTF120, FLTF120H, FLTF121, FLTF121H, 
    FLTF122, FLTF122H, FLTF123, FLTF123H, FLTF124, FLTF124H, FLTF125, FLTF125H, FLTF126, FLTF126H, 
    FLTF127, FLTF127H, 
    
    STFPSR,                                          // FP Status saved

// Integer registers
//    INTZERO,
    INTGP, INTT0, INTT1, INTS0, INTS1,
    INTS2, INTS3, INTV0, INTT2, INTT3, INTT4,
    INTSP, INTTEB, INTT5, INTT6, INTT7, INTT8,
    INTT9, INTT10, INTT11, INTT12, INTT13, INTT14,
    INTT15, INTT16, INTT17, INTT18, INTT19, INTT20, 
    INTT21, INTT22, 

    INTNATS,                                         // Nat bits for r1-r31
    PREDS,                                           // predicates saved

// Branch registers
    BRRP, BRS0, BRS1, BRS2, BRS3, BRS4, BRT0, BRT1,

// System registers      - from _CONTEXT record
    APUNAT, APLC, APEC, APCCV, APDCR,                // other application reg's
    RSPFS, RSBSP, RSBSPSTORE, RSRSC, RSRNAT,         // register stack info

    STIPSR, STIIP, STIFS,                            // trap status info

    StFCR,                                           // iA32 copy of Ar21
    Eflag,                                           // iA32 (Ar24)
    SegCSD,                                          // iA32 Descriptor(Ar25)
    SegSSD,                                          // iA32 Descriptor(Ar26)
    Cflag,                                           // iA32 (Ar27)
    STFSR,                                           // x86 FP status    
    STFIR,
    STFDR,

    /* End of _CONTEXT             */

    INTR32, INTR33, INTR34, INTR35, INTR36, INTR37, INTR38, INTR39,
    INTR40, INTR41, INTR42, INTR43, INTR44, 
    INTR45, INTR46, INTR47, INTR48, INTR49,
    INTR50, INTR51, INTR52, INTR53, INTR54, 
    INTR55, INTR56, INTR57, INTR58, INTR59,
    INTR60, INTR61, INTR62, INTR63, INTR64, 
    INTR65, INTR66, INTR67, INTR68, INTR69,
    INTR70, INTR71, INTR72, INTR73, INTR74, 
    INTR75, INTR76, INTR77, INTR78, INTR79,
    INTR80, INTR81, INTR82, INTR83, INTR84, 
    INTR85, INTR86, INTR87, INTR88, INTR89,
    INTR90, INTR91, INTR92, INTR93, INTR94, 
    INTR95, INTR96, INTR97, INTR98, INTR99,
    INTR100, INTR101, INTR102, INTR103, INTR104, 
    INTR105, INTR106, INTR107, INTR108, INTR109,
    INTR110, INTR111, INTR112, INTR113, INTR114,
    INTR115, INTR116, INTR117, INTR118, INTR119,
    INTR120, INTR121, INTR122, INTR123, INTR124, 
    INTR125, INTR126, INTR127,

    /* Begin of _KSPECIAL_REGISTER */

// Kernel debug breakpoint registers
    KRDBI0, KRDBI1, KRDBI2, KRDBI3, KRDBI4, KRDBI5, KRDBI6, KRDBI7,
    KRDBD0, KRDBD1, KRDBD2, KRDBD3, KRDBD4, KRDBD5, KRDBD6, KRDBD7,

// Kernel performance monitor registers
    KRPFC0, KRPFC1, KRPFC2, KRPFC3, KRPFC4, KRPFC5, KRPFC6, KRPFC7,
    KRPFD0, KRPFD1, KRPFD2, KRPFD3, KRPFD4, KRPFD5, KRPFD6, KRPFD7,

// Kernel bank shadow registers
    INTH16, INTH17, INTH18, INTH19, INTH20, INTH21, INTH22, INTH23,
    INTH24, INTH25, INTH26, INTH27, INTH28, INTH29, INTH30, INTH31,

// System registers     - from _KSPECIAL_REGISTERS record
    // application registers

    // CPUID registers
    ACPUID0, ACPUID1, ACPUID2, ACPUID3, ACPUID4, ACPUID5, ACPUID6, ACPUID7,

    // kernel registers
    APKR0, APKR1, APKR2, APKR3, APKR4, APKR5, APKR6, APKR7,
    APITC, APITM, APIVA, APPTA,	APGPTA, 
    STISR, STIDA, STIITR, STIIPA, STIIM, STIHA,

    // SAPIC registers
    SALID, SAIVR, SATPR, SAEOI, SAIRR0, SAIRR1, SAIRR2, SAIRR3,
    SAITV, SAPMV,  SACMCV, SALRR0, SALRR1,
    
    // region registers
    SRRR0, SRRR1, SRRR2, SRRR3, SRRR4, SRRR5, SRRR6, SRRR7,

    // protection key regs
    SRPKR0, SRPKR1, SRPKR2, SRPKR3, SRPKR4, SRPKR5, SRPKR6, SRPKR7, 
    SRPKR8, SRPKR9, SRPKR10, SRPKR11, SRPKR12, SRPKR13, SRPKR14, SRPKR15,
    
    // translation lookaside registers
    SRTRI0, SRTRI1, SRTRI2, SRTRI3, SRTRI4, SRTRI5, SRTRI6, SRTRI7,
    SRTRD0, SRTRD1, SRTRD2, SRTRD3, SRTRD4, SRTRD5, SRTRD6, SRTRD7,

    //  machine specific registers
    SMSR0, SMSR1, SMSR2, SMSR3, SMSR4, SMSR5, SMSR6, SMSR7,
    /* End of _KSPECIAL_REGISTERS */

// IPSR flags

    IPSRBN, IPSRED, IPSRRI, IPSRSS, IPSRDD, IPSRDA, IPSRID, IPSRIT, 
    IPSRME, IPSRIS, IPSRCPL, IPSRRT, IPSRTB, IPSRLP, IPSRDB, 
    IPSRSI, IPSRDI, IPSRPP, IPSRSP, IPSRDFH, IPSRDFL, IPSRDT, 
    IPSRPK, IPSRI, IPSRIC, IPSRAC, IPSRUP, IPSRBE, IPSROR,

// FPSR flags

    FPSRMDH, FPSRMDL, FPSRSF3, FPSRSF2, FPSRSF1, FPSRSF0,
    FPSRTRAPID, FPSRTRAPUD, FPSRTRAPOD, FPSRTRAPZD, FPSRTRAPDD, FPSRTRAPVD,

// Predicate registers
//  PR0, 
          PR1,  PR2,  PR3,
    PR4,  PR5,  PR6,  PR7,
    PR8,  PR9,  PR10, PR11,
    PR12, PR13, PR14, PR15,
    PR16, PR17, PR18, PR19,
    PR20, PR21, PR22, PR23,
    PR24, PR25, PR26, PR27,
    PR28, PR29, PR30, PR31,
    PR32, PR33, PR34, PR35,
    PR36, PR37, PR38, PR39,
    PR40, PR41, PR42, PR43,
    PR44, PR45, PR46, PR47,
    PR48, PR49, PR50, PR51,
    PR52, PR53, PR54, PR55,
    PR56, PR57, PR58, PR59,
    PR60, PR61, PR62, PR63,

    };


#define IA64_DBBASE          REGDBI0
#define IA64_DBLAST          REGDBD7
#define IA64_FLTBASE         FLTS0
#define IA64_FLTLAST         FLTF127
#define IA64_REGBASE         INTGP
#define IA64_ARBASE          APUNAT
#define IA64_SRBASE          KRDBI0
#define IA64_SREND           SMSR7
#define IA64_FLAGBASE        IPSRBN

#define IA64_DB_COUNT (IA64_DBLAST - IA64_DBBASE + 1)

// Debug register flags.
#define IA64_DBR_RDWR           0xC000000000000000UI64
#define IA64_DBR_RD             0x8000000000000000UI64
#define IA64_DBR_WR             0x4000000000000000UI64
#define IA64_DBR_EXEC           0x8000000000000000UI64
#define IA64_DBG_MASK_MASK      0x00FFFFFFFFFFFFFFUI64
#define IA64_DBG_REG_PLM_USER   0x0800000000000000UI64
#define IA64_DBG_REG_PLM_ALL    0x0F00000000000000UI64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\instr.h ===
//----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1997-2001.
//
//----------------------------------------------------------------------------

#ifndef _INSTR_H_
#define _INSTR_H_

// Global assembly control.
#define ASMOPT_VERBOSE 0x00000001

extern ULONG g_AsmOptions;

void ChangeAsmOptions(BOOL Set, PSTR Args);

void igrep(void);
void fnAssemble(PADDR);
void fnUnassemble(PADDR paddr,
                  ULONG64 value,
                  BOOL  fLength);

#endif // #ifndef _INSTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\ia64_reg.cpp ===
/*** ia64_reg.c - processor-specific register structures
*
*   Copyright <C> 1990-2001, Microsoft Corporation
*   Copyright <C> 1995, Intel Corporation
*
*   Purpose:
*       Structures used to parse and access register and flag
*       fields.
*
*   Revision History:
*
*   [-]  10-Jan-1995 HC         Modified for IA64. All registers are 64-bit
*                                except floating point registers are 128-bit.
*   [-]  01-Jul-1990 Richk      Created.
*
*************************************************************************/

#include "ntsdp.hpp"
#include "ia64_dis.h"

// See Get/SetRegVal comments in machine.hpp.
#define RegValError Do_not_use_GetSetRegVal_in_machine_implementations
#define GetRegVal(index, val)   RegValError
#define GetRegVal32(index)      RegValError
#define GetRegVal64(index)      RegValError
#define SetRegVal(index, val)   RegValError
#define SetRegVal32(index, val) RegValError
#define SetRegVal64(index, val) RegValError

// TBD
#define IS_FLOATING_SAVED(Register) ((SAVED_FLOATING_MASK >> Register) & 1L)
#define IS_INTEGER_SAVED(Register) ((SAVED_INTEGER_MASK >> Register) & 1L)


//
// Define saved register masks.
//
#define SAVED_FLOATING_MASK 0xfff00000  // saved floating registers
#define SAVED_INTEGER_MASK 0xf3ffff02   // saved integer registers


//
// Number of Data Breakpoints available under IA64 
//
// XXX olegk - increase to 4 in future 
// (and then remove appropriate check at MapDbgSlotIa64ToX86)
#define IA64_REG_MAX_DATA_BREAKPOINTS 2

//
// This parallels ntreg.h. Symbol assignment models ksia64.h
//

CHAR    szDBI0[] = "dbi0";
CHAR    szDBI1[] = "dbi1";
CHAR    szDBI2[] = "dbi2";
CHAR    szDBI3[] = "dbi3";
CHAR    szDBI4[] = "dbi4";
CHAR    szDBI5[] = "dbi5";
CHAR    szDBI6[] = "dbi6";
CHAR    szDBI7[] = "dbi7";

CHAR    szDBD0[] = "dbd0";
CHAR    szDBD1[] = "dbd1";
CHAR    szDBD2[] = "dbd2";
CHAR    szDBD3[] = "dbd3";
CHAR    szDBD4[] = "dbd4";
CHAR    szDBD5[] = "dbd5";
CHAR    szDBD6[] = "dbd6";
CHAR    szDBD7[] = "dbd7";

CHAR    szF32[] = "f32";    // High floating point temporary (scratch) registers
CHAR    szF33[] = "f33";
CHAR    szF34[] = "f34";
CHAR    szF35[] = "f35";
CHAR    szF36[] = "f36";
CHAR    szF37[] = "f37";
CHAR    szF38[] = "f38";
CHAR    szF39[] = "f39";
CHAR    szF40[] = "f40";
CHAR    szF41[] = "f41";
CHAR    szF42[] = "f42";
CHAR    szF43[] = "f43";
CHAR    szF44[] = "f44";
CHAR    szF45[] = "f45";
CHAR    szF46[] = "f46";
CHAR    szF47[] = "f47";
CHAR    szF48[] = "f48";
CHAR    szF49[] = "f49";

CHAR    szF50[] = "f50";
CHAR    szF51[] = "f51";
CHAR    szF52[] = "f52";
CHAR    szF53[] = "f53";
CHAR    szF54[] = "f54";
CHAR    szF55[] = "f55";
CHAR    szF56[] = "f56";
CHAR    szF57[] = "f57";
CHAR    szF58[] = "f58";
CHAR    szF59[] = "f59";
CHAR    szF60[] = "f60";
CHAR    szF61[] = "f61";
CHAR    szF62[] = "f62";
CHAR    szF63[] = "f63";
CHAR    szF64[] = "f64";
CHAR    szF65[] = "f65";
CHAR    szF66[] = "f66";
CHAR    szF67[] = "f67";
CHAR    szF68[] = "f68";
CHAR    szF69[] = "f69";
CHAR    szF70[] = "f70";
CHAR    szF71[] = "f71";
CHAR    szF72[] = "f72";
CHAR    szF73[] = "f73";
CHAR    szF74[] = "f74";
CHAR    szF75[] = "f75";
CHAR    szF76[] = "f76";
CHAR    szF77[] = "f77";
CHAR    szF78[] = "f78";
CHAR    szF79[] = "f79";
CHAR    szF80[] = "f80";
CHAR    szF81[] = "f81";
CHAR    szF82[] = "f82";
CHAR    szF83[] = "f83";
CHAR    szF84[] = "f84";
CHAR    szF85[] = "f85";
CHAR    szF86[] = "f86";
CHAR    szF87[] = "f87";
CHAR    szF88[] = "f88";
CHAR    szF89[] = "f89";
CHAR    szF90[] = "f90";
CHAR    szF91[] = "f91";
CHAR    szF92[] = "f92";
CHAR    szF93[] = "f93";
CHAR    szF94[] = "f94";
CHAR    szF95[] = "f95";
CHAR    szF96[] = "f96";
CHAR    szF97[] = "f97";
CHAR    szF98[] = "f98";
CHAR    szF99[] = "f99";

CHAR    szF100[] = "f100";
CHAR    szF101[] = "f101";
CHAR    szF102[] = "f102";
CHAR    szF103[] = "f103";
CHAR    szF104[] = "f104";
CHAR    szF105[] = "f105";
CHAR    szF106[] = "f106";
CHAR    szF107[] = "f107";
CHAR    szF108[] = "f108";
CHAR    szF109[] = "f109";
CHAR    szF110[] = "f110";
CHAR    szF111[] = "f111";
CHAR    szF112[] = "f112";
CHAR    szF113[] = "f113";
CHAR    szF114[] = "f114";
CHAR    szF115[] = "f115";
CHAR    szF116[] = "f116";
CHAR    szF117[] = "f117";
CHAR    szF118[] = "f118";
CHAR    szF119[] = "f119";
CHAR    szF120[] = "f120";
CHAR    szF121[] = "f121";
CHAR    szF122[] = "f122";
CHAR    szF123[] = "f123";
CHAR    szF124[] = "f124";
CHAR    szF125[] = "f125";
CHAR    szF126[] = "f126";
CHAR    szF127[] = "f127";

CHAR    szFPSR[] = "fpsr";
CHAR    szFSR[] = "fsr";
CHAR    szFIR[] = "fir";
CHAR    szFDR[] = "fdr";
CHAR    szFCR[] = "fcr"; 

CHAR    szGP[]  = "gp";        // global pointer
CHAR    szSP[] = "sp";         // stack pointer
CHAR    szR32[] = "r32";
CHAR    szR33[] = "r33";
CHAR    szR34[] = "r34";
CHAR    szR35[] = "r35";
CHAR    szR36[] = "r36";
CHAR    szR37[] = "r37";
CHAR    szR38[] = "r38";
CHAR    szR39[] = "r39";
CHAR    szR40[] = "r40";
CHAR    szR41[] = "r41";
CHAR    szR42[] = "r42";
CHAR    szR43[] = "r43";
CHAR    szR44[] = "r44";
CHAR    szR45[] = "r45";
CHAR    szR46[] = "r46";
CHAR    szR47[] = "r47";
CHAR    szR48[] = "r48";
CHAR    szR49[] = "r49";
CHAR    szR50[] = "r50";
CHAR    szR51[] = "r51";
CHAR    szR52[] = "r52";
CHAR    szR53[] = "r53";
CHAR    szR54[] = "r54";
CHAR    szR55[] = "r55";
CHAR    szR56[] = "r56";
CHAR    szR57[] = "r57";
CHAR    szR58[] = "r58";
CHAR    szR59[] = "r59";
CHAR    szR60[] = "r60";
CHAR    szR61[] = "r61";
CHAR    szR62[] = "r62";
CHAR    szR63[] = "r63";
CHAR    szR64[] = "r64";
CHAR    szR65[] = "r65";
CHAR    szR66[] = "r66";
CHAR    szR67[] = "r67";
CHAR    szR68[] = "r68";
CHAR    szR69[] = "r69";
CHAR    szR70[] = "r70";
CHAR    szR71[] = "r71";
CHAR    szR72[] = "r72";
CHAR    szR73[] = "r73";
CHAR    szR74[] = "r74";
CHAR    szR75[] = "r75";
CHAR    szR76[] = "r76";
CHAR    szR77[] = "r77";
CHAR    szR78[] = "r78";
CHAR    szR79[] = "r79";
CHAR    szR80[] = "r80";
CHAR    szR81[] = "r81";
CHAR    szR82[] = "r82";
CHAR    szR83[] = "r83";
CHAR    szR84[] = "r84";
CHAR    szR85[] = "r85";
CHAR    szR86[] = "r86";
CHAR    szR87[] = "r87";
CHAR    szR88[] = "r88";
CHAR    szR89[] = "r89";
CHAR    szR90[] = "r90";
CHAR    szR91[] = "r91";
CHAR    szR92[] = "r92";
CHAR    szR93[] = "r93";
CHAR    szR94[] = "r94";
CHAR    szR95[] = "r95";
CHAR    szR96[] = "r96";
CHAR    szR97[] = "r97";
CHAR    szR98[] = "r98";
CHAR    szR99[] = "r99";
CHAR    szR100[] = "r100";
CHAR    szR101[] = "r101";
CHAR    szR102[] = "r102";
CHAR    szR103[] = "r103";
CHAR    szR104[] = "r104";
CHAR    szR105[] = "r105";
CHAR    szR106[] = "r106";
CHAR    szR107[] = "r107";
CHAR    szR108[] = "r108";
CHAR    szR109[] = "r109";
CHAR    szR110[] = "r110";
CHAR    szR111[] = "r111";
CHAR    szR112[] = "r112";
CHAR    szR113[] = "r113";
CHAR    szR114[] = "r114";
CHAR    szR115[] = "r115";
CHAR    szR116[] = "r116";
CHAR    szR117[] = "r117";
CHAR    szR118[] = "r118";
CHAR    szR119[] = "r119";
CHAR    szR120[] = "r120";
CHAR    szR121[] = "r121";
CHAR    szR122[] = "r122";
CHAR    szR123[] = "r123";
CHAR    szR124[] = "r124";
CHAR    szR125[] = "r125";
CHAR    szR126[] = "r126";
CHAR    szR127[] = "r127";


CHAR    szINTNATS[] = "intnats";
CHAR    szPREDS[] = "preds";

CHAR    szB0[] = "b0";          // branch return pointer
CHAR    szB1[] = "b1";          // branch saved (preserved)
CHAR    szB2[] = "b2";
CHAR    szB3[] = "b3";
CHAR    szB4[] = "b4";
CHAR    szB5[] = "b5";
CHAR    szB6[] = "b6";          // branch temporary (scratch) registers
CHAR    szB7[] = "b7";

CHAR    szCSD[] = "csd";        // iA32 CS descriptor
CHAR    szSSD[] = "ssd";        // iA32 SS descriptor

CHAR    szAPUNAT[] = "unat";
CHAR    szAPLC[] = "lc";
CHAR    szAPEC[] = "ec";
CHAR    szAPCCV[] = "ccv";
CHAR    szAPDCR[] = "dcr";
CHAR    szRSPFS[] = "pfs";
CHAR    szRSBSP[] = "bsp";
CHAR    szRSBSPSTORE[] = "bspstore";
CHAR    szRSRSC[] = "rsc";
CHAR    szRSRNAT[] = "rnat";

CHAR    szEFLAG[] = "eflag";    // iA32 Eflag
CHAR    szCFLAG[] = "cflag";    // iA32 Cflag

CHAR    szSTIPSR[] = "ipsr";
CHAR    szSTIIP[] = "iip";
CHAR    szSTIFS[] = "ifs";

CHAR    szKDBI0[] = "kdbi0";
CHAR    szKDBI1[] = "kdbi1";
CHAR    szKDBI2[] = "kdbi2";
CHAR    szKDBI3[] = "kdbi3";
CHAR    szKDBI4[] = "kdbi4";
CHAR    szKDBI5[] = "kdbi5";
CHAR    szKDBI6[] = "kdbi6";
CHAR    szKDBI7[] = "kdbi7";

CHAR    szKDBD0[] = "kdbd0";
CHAR    szKDBD1[] = "kdbd1";
CHAR    szKDBD2[] = "kdbd2";
CHAR    szKDBD3[] = "kdbd3";
CHAR    szKDBD4[] = "kdbd4";
CHAR    szKDBD5[] = "kdbd5";
CHAR    szKDBD6[] = "kdbd6";
CHAR    szKDBD7[] = "kdbd7";

CHAR    szKPFC0[] = "kpfc0";
CHAR    szKPFC1[] = "kpfc1";
CHAR    szKPFC2[] = "kpfc2";
CHAR    szKPFC3[] = "kpfc3";
CHAR    szKPFC4[] = "kpfc4";
CHAR    szKPFC5[] = "kpfc5";
CHAR    szKPFC6[] = "kpfc6";
CHAR    szKPFC7[] = "kpfc7";

CHAR    szKPFD0[] = "kpfd0";
CHAR    szKPFD1[] = "kpfd1";
CHAR    szKPFD2[] = "kpfd2";
CHAR    szKPFD3[] = "kpfd3";
CHAR    szKPFD4[] = "kpfd4";
CHAR    szKPFD5[] = "kpfd5";
CHAR    szKPFD6[] = "kpfd6";
CHAR    szKPFD7[] = "kpfd7";

CHAR    szH16[] = "h16";          // kernel bank shadow (hidden) registers
CHAR    szH17[] = "h17";
CHAR    szH18[] = "h18";
CHAR    szH19[] = "h19";
CHAR    szH20[] = "h20";
CHAR    szH21[] = "h21";
CHAR    szH22[] = "h22";
CHAR    szH23[] = "h23";
CHAR    szH24[] = "h24";
CHAR    szH25[] = "h25";
CHAR    szH26[] = "h26";
CHAR    szH27[] = "h27";
CHAR    szH28[] = "h28";
CHAR    szH29[] = "h29";
CHAR    szH30[] = "h30";
CHAR    szH31[] = "h31";

CHAR    szACPUID0[] = "cpuid0";
CHAR    szACPUID1[] = "cpuid1";
CHAR    szACPUID2[] = "cpuid2";
CHAR    szACPUID3[] = "cpuid3";
CHAR    szACPUID4[] = "cpuid4";
CHAR    szACPUID5[] = "cpuid5";
CHAR    szACPUID6[] = "cpuid6";
CHAR    szACPUID7[] = "cpuid7";


CHAR    szAPKR0[] = "kr0";
CHAR    szAPKR1[] = "kr1";
CHAR    szAPKR2[] = "kr2";
CHAR    szAPKR3[] = "kr3";
CHAR    szAPKR4[] = "kr4";
CHAR    szAPKR5[] = "kr5";
CHAR    szAPKR6[] = "kr6";
CHAR    szAPKR7[] = "kr7";

CHAR    szAPITC[] = "itc";
CHAR    szAPITM[] = "itm";
CHAR    szAPIVA[] = "iva";
CHAR    szAPPTA[] = "pta";
CHAR    szAPGPTA[] = "apgta";
CHAR    szSTISR[] = "isr";
CHAR    szSTIDA[] = "ifa";
CHAR    szSTIDTR[] = "idtr";
CHAR    szSTIITR[] = "itir";
CHAR    szSTIIPA[] = "iipa";
CHAR    szSTIIM[] = "iim";
CHAR    szSTIHA[] = "iha";

CHAR    szSALID[] = "lid";
CHAR    szSAIVR[] = "ivr";
CHAR    szSATPR[] = "tpr";
CHAR    szSAEOI[] = "eoi";
CHAR    szSAIRR0[] = "irr0";
CHAR    szSAIRR1[] = "irr1";
CHAR    szSAIRR2[] = "irr2";
CHAR    szSAIRR3[] = "irr3";
CHAR    szSAITV[] = "itv";
CHAR    szSAPMV[] = "pmv";
CHAR    szSALRR0[] = "lrr0";
CHAR    szSALRR1[] = "lrr1";
CHAR    szSACMCV[] = "cmcv";

CHAR    szRR0[] = "rr0";
CHAR    szRR1[] = "rr1";
CHAR    szRR2[] = "rr2";
CHAR    szRR3[] = "rr3";
CHAR    szRR4[] = "rr4";
CHAR    szRR5[] = "rr5";
CHAR    szRR6[] = "rr6";
CHAR    szRR7[] = "rr7";

CHAR    szPKR0[] = "pkr0";
CHAR    szPKR1[] = "pkr1";
CHAR    szPKR2[] = "pkr2";
CHAR    szPKR3[] = "pkr3";
CHAR    szPKR4[] = "pkr4";
CHAR    szPKR5[] = "pkr5";
CHAR    szPKR6[] = "pkr6";
CHAR    szPKR7[] = "pkr7";
CHAR    szPKR8[] = "pkr8";
CHAR    szPKR9[] = "pkr9";
CHAR    szPKR10[] = "pkr10";
CHAR    szPKR11[] = "pkr11";
CHAR    szPKR12[] = "pkr12";
CHAR    szPKR13[] = "pkr13";
CHAR    szPKR14[] = "pkr14";
CHAR    szPKR15[] = "pkr15";

CHAR    szTRI0[] = "tri0";
CHAR    szTRI1[] = "tri1";
CHAR    szTRI2[] = "tri2";
CHAR    szTRI3[] = "tri3";
CHAR    szTRI4[] = "tri4";
CHAR    szTRI5[] = "tri5";
CHAR    szTRI6[] = "tri6";
CHAR    szTRI7[] = "tri7";
CHAR    szTRD0[] = "trd0";
CHAR    szTRD1[] = "trd1";
CHAR    szTRD2[] = "trd2";
CHAR    szTRD3[] = "trd3";
CHAR    szTRD4[] = "trd4";
CHAR    szTRD5[] = "trd5";
CHAR    szTRD6[] = "trd6";
CHAR    szTRD7[] = "trd7";

CHAR    szSMSR0[] = "SMSR0";
CHAR    szSMSR1[] = "SMSR1";
CHAR    szSMSR2[] = "SMSR2";
CHAR    szSMSR3[] = "SMSR3";
CHAR    szSMSR4[] = "SMSR4";
CHAR    szSMSR5[] = "SMSR5";
CHAR    szSMSR6[] = "SMSR6";
CHAR    szSMSR7[] = "SMSR7";


// IPSR flags

CHAR    szIPSRBN[] =  "ipsr.bn";
CHAR    szIPSRED[] =  "ipsr.ed";
CHAR    szIPSRRI[] =  "ipsr.ri";
CHAR    szIPSRSS[] =  "ipsr.ss";
CHAR    szIPSRDD[] =  "ipsr.dd";
CHAR    szIPSRDA[] =  "ipsr.da";
CHAR    szIPSRID[] =  "ipsr.id";
CHAR    szIPSRIT[] =  "ipsr.it";
CHAR    szIPSRME[] =  "ipsr.me";
CHAR    szIPSRIS[] =  "ipsr.is";
CHAR    szIPSRCPL[] = "ipsr.cpl";
CHAR    szIPSRRT[] =  "ipsr.rt";
CHAR    szIPSRTB[] =  "ipsr.tb";
CHAR    szIPSRLP[] =  "ipsr.lp";
CHAR    szIPSRDB[] =  "ipsr.db";
CHAR    szIPSRSI[] =  "ipsr.si";
CHAR    szIPSRDI[] =  "ipsr.di";
CHAR    szIPSRPP[] =  "ipsr.pp";
CHAR    szIPSRSP[] =  "ipsr.sp";
CHAR    szIPSRDFH[] = "ipsr.dfh";
CHAR    szIPSRDFL[] = "ipsr.dfl";
CHAR    szIPSRDT[] =  "ipsr.dt";
CHAR    szIPSRPK[] =  "ipsr.pk";
CHAR    szIPSRI[]  =  "ipsr.i";
CHAR    szIPSRIC[] =  "ipsr.ic";
CHAR    szIPSRAC[] =  "ipsr.ac";
CHAR    szIPSRUP[] =  "ipsr.up";
CHAR    szIPSRBE[] =  "ipsr.be";
CHAR    szIPSROR[] =  "ipsr.or";

// FPSR flags

CHAR    szFPSRMDH[] =    "fpsr.mdh";
CHAR    szFPSRMDL[] =    "fpsr.mdl";
CHAR    szFPSRSF3[] =    "fpsr.sf3";
CHAR    szFPSRSF2[] =    "fpsr.sf2";
CHAR    szFPSRSF1[] =    "fpsr.sf1";
CHAR    szFPSRSF0[] =    "fpsr.sf0";
CHAR    szFPSRTRAPID[] = "fpsr.id";
CHAR    szFPSRTRAPUD[] = "fpsr.ud";
CHAR    szFPSRTRAPOD[] = "fpsr.od";
CHAR    szFPSRTRAPZD[] = "fpsr.zd";
CHAR    szFPSRTRAPDD[] = "fpsr.dd";
CHAR    szFPSRTRAPVD[] = "fpsr.vd";

// Predicate registers
//CHAR    szPR0[] = "p0";
CHAR szPR1[]  = "p1";
CHAR szPR2[]  = "p2";
CHAR szPR3[]  = "p3";
CHAR szPR4[]  = "p4";
CHAR szPR5[]  = "p5";
CHAR szPR6[]  = "p6";
CHAR szPR7[]  = "p7";
CHAR szPR8[]  = "p8";
CHAR szPR9[]  = "p9";
CHAR szPR10[] = "p10";
CHAR szPR11[] = "p11";
CHAR szPR12[] = "p12";
CHAR szPR13[] = "p13";
CHAR szPR14[] = "p14";
CHAR szPR15[] = "p15";
CHAR szPR16[] = "p16";
CHAR szPR17[] = "p17";
CHAR szPR18[] = "p18";
CHAR szPR19[] = "p19";
CHAR szPR20[] = "p20";
CHAR szPR21[] = "p21";
CHAR szPR22[] = "p22";
CHAR szPR23[] = "p23";
CHAR szPR24[] = "p24";
CHAR szPR25[] = "p25";
CHAR szPR26[] = "p26";
CHAR szPR27[] = "p27";
CHAR szPR28[] = "p28";
CHAR szPR29[] = "p29";
CHAR szPR30[] = "p30";
CHAR szPR31[] = "p31";
CHAR szPR32[] = "p32";
CHAR szPR33[] = "p33";
CHAR szPR34[] = "p34";
CHAR szPR35[] = "p35";
CHAR szPR36[] = "p36";
CHAR szPR37[] = "p37";
CHAR szPR38[] = "p38";
CHAR szPR39[] = "p39";
CHAR szPR40[] = "p40";
CHAR szPR41[] = "p41";
CHAR szPR42[] = "p42";
CHAR szPR43[] = "p43";
CHAR szPR44[] = "p44";
CHAR szPR45[] = "p45";
CHAR szPR46[] = "p46";
CHAR szPR47[] = "p47";
CHAR szPR48[] = "p48";
CHAR szPR49[] = "p49";
CHAR szPR50[] = "p50";
CHAR szPR51[] = "p51";
CHAR szPR52[] = "p52";
CHAR szPR53[] = "p53";
CHAR szPR54[] = "p54";
CHAR szPR55[] = "p55";
CHAR szPR56[] = "p56";
CHAR szPR57[] = "p57";
CHAR szPR58[] = "p58";
CHAR szPR59[] = "p59";
CHAR szPR60[] = "p60";
CHAR szPR61[] = "p61";
CHAR szPR62[] = "p62";
CHAR szPR63[] = "p63";

// Aliases: allow aliases to general purpose registers that are
// known by more than one name, eg r12 = rsp.

CHAR    szR1GP[]  =      "r1";
CHAR    szR12SP[] =      "r12";
CHAR    szRA[]    =      "ra";
CHAR    szRP[]    =      "rp";
CHAR    szRET0[]  =      "ret0";
CHAR    szRET1[]  =      "ret1";
CHAR    szRET2[]  =      "ret2";
CHAR    szRET3[]  =      "ret3";



REGDEF IA64Regs[] =
{
    
    szDBI0, REGDBI0, szDBI1, REGDBI1, szDBI2, REGDBI2, szDBI3, REGDBI3,
    szDBI4, REGDBI4, szDBI5, REGDBI5, szDBI6, REGDBI6, szDBI7, REGDBI7,
    szDBD0, REGDBD0, szDBD1, REGDBD1, szDBD2, REGDBD2, szDBD3, REGDBD3,
    szDBD4, REGDBD4, szDBD5, REGDBD5, szDBD6, REGDBD6, szDBD7, REGDBD7,

//    g_F0, FLTZERO, g_F1, FLTONE,
    g_F2, FLTS0, g_F3, FLTS1,
    g_F4, FLTS2, g_F5, FLTS3, g_F6, FLTT0, g_F7, FLTT1,
    g_F8, FLTT2, g_F9, FLTT3, g_F10, FLTT4, g_F11, FLTT5,
    g_F12, FLTT6, g_F13, FLTT7, g_F14, FLTT8, g_F15, FLTT9,
    g_F16, FLTS4, g_F17, FLTS5, g_F18, FLTS6, g_F19, FLTS7,
    g_F20, FLTS8, g_F21, FLTS9, g_F22, FLTS10, g_F23, FLTS11,
    g_F24, FLTS12, g_F25, FLTS13, g_F26, FLTS14, g_F27, FLTS15,
    g_F28, FLTS16, g_F29, FLTS17, g_F30, FLTS18, g_F31, FLTS19,
    szF32, FLTF32, szF33, FLTF33, szF34, FLTF34, szF35, FLTF35,
    szF36, FLTF36, szF37, FLTF37, szF38, FLTF38, szF39, FLTF39,
    szF40, FLTF40, szF41, FLTF41, szF42, FLTF42, szF43, FLTF43,
    szF44, FLTF44, szF45, FLTF45, szF46, FLTF46, szF47, FLTF47,
    szF48, FLTF48, szF49, FLTF49, szF50, FLTF50, szF51, FLTF51,
    szF52, FLTF52, szF53, FLTF53, szF54, FLTF54, szF55, FLTF55,
    szF56, FLTF56, szF57, FLTF57, szF58, FLTF58, szF59, FLTF59,
    szF60, FLTF60, szF61, FLTF61, szF62, FLTF62, szF63, FLTF63,
    szF64, FLTF64, szF65, FLTF65, szF66, FLTF66, szF67, FLTF67,
    szF68, FLTF68, szF69, FLTF69, szF70, FLTF70, szF71, FLTF71,
    szF72, FLTF72, szF73, FLTF73, szF74, FLTF74, szF75, FLTF75,
    szF76, FLTF76, szF77, FLTF77, szF78, FLTF78, szF79, FLTF79,
    szF80, FLTF80, szF81, FLTF81, szF82, FLTF82, szF83, FLTF83,
    szF84, FLTF84, szF85, FLTF85, szF86, FLTF86, szF87, FLTF87,
    szF88, FLTF88, szF89, FLTF89, szF90, FLTF90, szF91, FLTF91,
    szF92, FLTF92, szF93, FLTF93, szF94, FLTF94, szF95, FLTF95,
    szF96, FLTF96, szF97, FLTF97, szF98, FLTF98, szF99, FLTF99,
    szF100, FLTF100, szF101, FLTF101, szF102, FLTF102, szF103, FLTF103,
    szF104, FLTF104, szF105, FLTF105, szF106, FLTF106, szF107, FLTF107,
    szF108, FLTF108, szF109, FLTF109, szF110, FLTF110, szF111, FLTF111,
    szF112, FLTF112, szF113, FLTF113, szF114, FLTF114, szF115, FLTF115,
    szF116, FLTF116, szF117, FLTF117, szF118, FLTF118, szF119, FLTF119,
    szF120, FLTF120, szF121, FLTF121, szF122, FLTF122, szF123, FLTF123,
    szF124, FLTF124, szF125, FLTF125, szF126, FLTF126, szF127, FLTF127,

    szFPSR, STFPSR, 

//    g_R0, INTZERO,
    szGP, INTGP, g_R2, INTT0, g_R3, INTT1,
    g_R4, INTS0, g_R5, INTS1, g_R6, INTS2, g_R7, INTS3,
    g_R8, INTV0, g_R9, INTT2, g_R10, INTT3, g_R11, INTT4,
    szSP, INTSP, g_R13, INTTEB, g_R14, INTT5, g_R15, INTT6,
    g_R16, INTT7, g_R17, INTT8, g_R18, INTT9, g_R19, INTT10,
    g_R20, INTT11, g_R21, INTT12, g_R22, INTT13, g_R23, INTT14,
    g_R24, INTT15, g_R25, INTT16, g_R26, INTT17, g_R27, INTT18,
    g_R28, INTT19, g_R29, INTT20, g_R30, INTT21, g_R31, INTT22,

    szINTNATS, INTNATS, 

    szR32, INTR32, szR33, INTR33, szR34, INTR34, szR35, INTR35,
    szR36, INTR36, szR37, INTR37, szR38, INTR38, szR39, INTR39,
    szR40, INTR40, szR41, INTR41, szR42, INTR42, szR42, INTR42,
    szR43, INTR43, szR44, INTR44, szR45, INTR45, szR46, INTR46,
    szR47, INTR47, szR48, INTR48, szR49, INTR49, szR50, INTR50,
    szR51, INTR51, szR52, INTR52, szR53, INTR53, szR54, INTR54,
    szR55, INTR55, szR56, INTR56, szR57, INTR57, szR58, INTR58,
    szR59, INTR59, szR60, INTR60, szR61, INTR61, szR62, INTR62,
    szR63, INTR63, szR64, INTR64, szR65, INTR65, szR66, INTR66,
    szR67, INTR67, szR68, INTR68, szR69, INTR69, szR70, INTR70,
    szR71, INTR71, szR72, INTR72, szR73, INTR73, szR74, INTR74,
    szR75, INTR75, szR76, INTR76, szR77, INTR77, szR78, INTR78,
    szR79, INTR79, szR80, INTR80, szR81, INTR81, szR82, INTR82,
    szR83, INTR83, szR84, INTR84, szR85, INTR85, szR86, INTR86,
    szR87, INTR87, szR88, INTR88, szR89, INTR89, szR90, INTR90,
    szR91, INTR91, szR92, INTR92, szR93, INTR93, szR94, INTR94,
    szR95, INTR95, szR96, INTR96, szR97, INTR97, szR98, INTR98,
    szR99, INTR99, szR100, INTR100, szR101, INTR101, szR102, INTR102,
    szR103, INTR103, szR104, INTR104, szR105, INTR105, szR106, INTR106,
    szR107, INTR107, szR108, INTR108, szR109, INTR109, szR110, INTR110,
    szR111, INTR111, szR112, INTR112, szR112, INTR113, szR114, INTR114,
    szR115, INTR115, szR116, INTR116, szR117, INTR117, szR118, INTR118,
    szR119, INTR119, szR120, INTR120, szR121, INTR121, szR122, INTR122,
    szR123, INTR123, szR124, INTR124, szR125, INTR125, szR126, INTR126,
    szR127, INTR127,


    szPREDS, PREDS,

    szB0, BRRP, szB1, BRS0, szB2, BRS1, szB3, BRS2,
    szB4, BRS3, szB5, BRS4, szB6, BRT0, szB7, BRT1,

    szAPUNAT, APUNAT, szAPLC, APLC,
    szAPEC, APEC, szAPCCV, APCCV, szAPDCR, APDCR, szRSPFS, RSPFS,
    szRSBSP, RSBSP, szRSBSPSTORE, RSBSPSTORE, szRSRSC, RSRSC, szRSRNAT, RSRNAT,

    szSTIPSR, STIPSR, szSTIIP, STIIP, szSTIFS, STIFS,

    szFCR, StFCR,
    szEFLAG, Eflag, 
    szCSD, SegCSD, 
    szSSD, SegSSD,  
    szCFLAG, Cflag,
    szFSR, STFSR, 
    szFIR, STFIR, 
    szFDR, STFDR,

// IPSR flags

    szIPSRBN, IPSRBN,
    szIPSRED, IPSRED, szIPSRRI, IPSRRI, szIPSRSS, IPSRSS, szIPSRDD, IPSRDD,
    szIPSRDA, IPSRDA, szIPSRID, IPSRID, szIPSRIT, IPSRIT, szIPSRME, IPSRME,
    szIPSRIS, IPSRIS, szIPSRCPL, IPSRCPL, szIPSRRT, IPSRRT, szIPSRTB, IPSRTB,
    szIPSRLP, IPSRLP, szIPSRDB, IPSRDB, szIPSRSI, IPSRSI, szIPSRDI, IPSRDI,
    szIPSRPP, IPSRPP, szIPSRSP, IPSRSP, szIPSRDFH, IPSRDFH, szIPSRDFL, IPSRDFL,
    szIPSRDT, IPSRDT, szIPSRPK, IPSRPK, szIPSRI, IPSRI, szIPSRIC, IPSRIC,
    szIPSRAC, IPSRAC, szIPSRUP, IPSRUP, szIPSRBE, IPSRBE, szIPSROR, IPSROR,

// FPSR flags

    szFPSRMDH, FPSRMDH, szFPSRMDL, FPSRMDL,
    szFPSRSF3, FPSRSF3, szFPSRSF2, FPSRSF2,
    szFPSRSF1, FPSRSF1, szFPSRSF0, FPSRSF0,
    szFPSRTRAPID, FPSRTRAPID, szFPSRTRAPUD, FPSRTRAPUD,
    szFPSRTRAPOD, FPSRTRAPOD, szFPSRTRAPZD, FPSRTRAPZD,
    szFPSRTRAPDD, FPSRTRAPDD, szFPSRTRAPVD, FPSRTRAPVD,

// Predicate registers
//  szPR0, PR0, 
                  szPR1,  PR1,  szPR2,  PR2,  szPR3,  PR3,
    szPR4,  PR4,  szPR5,  PR5,  szPR6,  PR6,  szPR7,  PR7,
    szPR8,  PR8,  szPR9,  PR9,  szPR10, PR10, szPR11, PR11,
    szPR12, PR12, szPR13, PR13, szPR14, PR14, szPR15, PR15,
    szPR16, PR16, szPR17, PR17, szPR18, PR18, szPR19, PR19,
    szPR20, PR20, szPR21, PR21, szPR22, PR22, szPR23, PR23,
    szPR24, PR24, szPR25, PR25, szPR26, PR26, szPR27, PR27,
    szPR28, PR28, szPR29, PR29, szPR30, PR30, szPR31, PR31,
    szPR32, PR32, szPR33, PR33, szPR34, PR34, szPR35, PR35,
    szPR36, PR36, szPR37, PR37, szPR38, PR38, szPR39, PR39,
    szPR40, PR40, szPR41, PR41, szPR42, PR42, szPR43, PR43,
    szPR44, PR44, szPR45, PR45, szPR46, PR46, szPR47, PR47,
    szPR48, PR48, szPR49, PR49, szPR50, PR50, szPR51, PR51,
    szPR52, PR52, szPR53, PR53, szPR54, PR54, szPR55, PR55,
    szPR56, PR56, szPR57, PR57, szPR58, PR58, szPR59, PR59,
    szPR60, PR60, szPR61, PR61, szPR62, PR62, szPR63, PR63,

// Aliases

    szR1GP, INTGP, szR12SP, INTSP, szRA, BRRP, szRP, BRRP,
    szRET0, INTV0, szRET1, INTT2, szRET2, INTT3, szRET3, INTT4,

    NULL, 0,
};

REGDEF g_Ia64KernelRegs[] =
{
    szKDBI0, KRDBI0, szKDBI1, KRDBI1, szKDBI2, KRDBI2, szKDBI3, KRDBI3,
    szKDBI4, KRDBI4, szKDBI5, KRDBI5, szKDBI6, KRDBI6, szKDBI7, KRDBI7,

    szKDBD0, KRDBD0, szKDBD1, KRDBD1, szKDBD2, KRDBD2, szKDBD3, KRDBD3,
    szKDBD4, KRDBD4, szKDBD5, KRDBD5, szKDBD6, KRDBD6, szKDBD7, KRDBD7,

    szKPFC0, KRPFC0, szKPFC1, KRPFC1, szKPFC2, KRPFC2, szKPFC3, KRPFC3,
    szKPFC4, KRPFC4, szKPFC5, KRPFC5, szKPFC6, KRPFC6, szKPFC7, KRPFC7,

    szKPFD0, KRPFD0, szKPFD1, KRPFD1, szKPFD2, KRPFD2, szKPFD3, KRPFD3,
    szKPFD4, KRPFD4, szKPFD5, KRPFD5, szKPFD6, KRPFD6, szKPFD7, KRPFD7,

    szH16, INTH16, szH17, INTH17, szH18, INTH18, szH19, INTH19,
    szH20, INTH20, szH21, INTH21, szH22, INTH22, szH23, INTH23,
    szH24, INTH24, szH25, INTH25, szH26, INTH26, szH27, INTH27,
    szH28, INTH28, szH29, INTH29, szH30, INTH30, szH31, INTH31,

    szACPUID0, ACPUID0, szACPUID1, ACPUID1, szACPUID2, ACPUID2, szACPUID3, ACPUID3, 
    szACPUID4, ACPUID4, szACPUID5, ACPUID5, szACPUID6, ACPUID6, szACPUID7, ACPUID7,

    szAPKR0, APKR0, szAPKR1, APKR1, szAPKR2, APKR2, szAPKR3, APKR3,
    szAPKR4, APKR4, szAPKR5, APKR5, szAPKR6, APKR6, szAPKR7, APKR7,

    szAPITC, APITC, szAPITM, APITM, szAPIVA, APIVA,
    szAPPTA, APPTA, szAPGPTA, APGPTA, 
    szSTISR, STISR, szSTIDA, STIDA,
    szSTIITR, STIITR, szSTIIPA, STIIPA, szSTIIM, STIIM, szSTIHA, STIHA,

    szSALID, SALID,
    szSAIVR, SAIVR, szSATPR, SATPR, szSAEOI, SAEOI, szSAIRR0, SAIRR0,
    szSAIRR1, SAIRR1, szSAIRR2, SAIRR2, szSAIRR3, SAIRR3, szSAITV, SAITV,
    szSAPMV, SAPMV, szSACMCV, SACMCV, szSALRR0, SALRR0, szSALRR1, SALRR1,

    szRR0, SRRR0, szRR1, SRRR1, szRR2, SRRR2, szRR3, SRRR3,
    szRR4, SRRR4, szRR5, SRRR5, szRR6, SRRR6, szRR7, SRRR7,

    szPKR0, SRPKR0, szPKR1, SRPKR1, szPKR2, SRPKR2, szPKR3, SRPKR3,
    szPKR4, SRPKR4, szPKR5, SRPKR5, szPKR6, SRPKR6, szPKR7, SRPKR7,
    szPKR8, SRPKR8, szPKR9, SRPKR9, szPKR10, SRPKR10, szPKR11, SRPKR11,
    szPKR12, SRPKR12, szPKR13, SRPKR13, szPKR14, SRPKR14, szPKR15, SRPKR15,

    szTRI0, SRTRI0, szTRI1, SRTRI1, szTRI2, SRTRI2, szTRI3, SRTRI3,
    szTRI4, SRTRI4, szTRI5, SRTRI5, szTRI6, SRTRI6, szTRI7, SRTRI7,
    szTRD0, SRTRD0, szTRD1, SRTRD1, szTRD2, SRTRD2, szTRD3, SRTRD3,
    szTRD4, SRTRD4, szTRD5, SRTRD5, szTRD6, SRTRD6, szTRD7, SRTRD7,

    szSMSR0, SMSR0, szSMSR1, SMSR1, szSMSR2, SMSR2, szSMSR3, SMSR3, 
    szSMSR4, SMSR4, szSMSR5, SMSR5, szSMSR6, SMSR6, szSMSR7, SMSR7,

    NULL, 0,
};

REGSUBDEF IA64SubRegs[] =
{
    // IPSR flags

    { IPSRBN, STIPSR, 44, 1 },          //  BN Register bank #
    { IPSRED, STIPSR, 43, 1 },          //  ED Exception deferal
    { IPSRRI, STIPSR, 41, 0x3 },        //  RI Restart instruction
    { IPSRSS, STIPSR, 40, 1 },          //  SS Single step enable
    { IPSRDD, STIPSR, 39, 1 },          //  DD Data debug fault disable
    { IPSRDA, STIPSR, 38, 1 },          //  DA Disable access and dirty-bit faults
    { IPSRID, STIPSR, 37, 1 },          //  ID Instruction debug fault disable
    { IPSRIT, STIPSR, 36, 1 },          //  IT Instruction address translation
    { IPSRME, STIPSR, 35, 1 },          //  ME Machine check abort mamsk
    { IPSRIS, STIPSR, 34, 1 },          //  IS Instruction set
    { IPSRCPL,STIPSR, 32, 0x3 },        //  CPL Current privilege level
    { IPSRRT, STIPSR, 27, 1 },          //  RT Rigister stack translation
    { IPSRTB, STIPSR, 26, 1 },          //  TB Taaaaken branch trap
    { IPSRLP, STIPSR, 25, 1 },          //  LP Lower privilege transfer trap
    { IPSRDB, STIPSR, 24, 1 },          //  DB Debug breakpoint fault
    { IPSRSI, STIPSR, 23, 1 },          //  SI Secure interval timer(ITC)
    { IPSRDI, STIPSR, 22, 1 },          //  DI Disable instruction set transition
    { IPSRPP, STIPSR, 21, 1 },          //  PP Privileged performance monitor enable
    { IPSRSP, STIPSR, 20, 1 },          //  SP Secure performance monitors
    { IPSRDFH,STIPSR, 19, 1 },          //  DFH Disabled floating-point high register set, f16-f127
    { IPSRDFL,STIPSR, 18, 1 },          //  DFL Disabled floating-point low register set, f0-f15
    { IPSRDT, STIPSR, 17, 1 },          //  DT Data address translation
//  { ?,      STIPSR, 16, 1 },          //  (reserved)
    { IPSRPK, STIPSR, 15, 1 },          //  PK Protection key enabled
    { IPSRI,  STIPSR, 14, 1 },          //  I  Interrupt unmask
    { IPSRIC, STIPSR, 13, 1 },          //  IC Interruption collection
    { IPSRAC, STIPSR,  3, 1 },          //  AC Alignment check
    { IPSRUP, STIPSR,  2, 1 },          //  UP User performance monitor enabled
    { IPSRBE, STIPSR,  1, 1 },          //  BE Big-Endian
    { IPSROR, STIPSR,  0, 1 },          //  OR Ordered memory reference

    // FPSR flags

    { FPSRMDH,    STFPSR, 63,      1 }, //  MDH Upper floating point register written
    { FPSRMDL,    STFPSR, 62,      1 }, //  MDL Lower floating point register written
    { FPSRSF3,    STFPSR, 45, 0x1fff }, //  SF3 Alternate status field 3
    { FPSRSF2,    STFPSR, 32, 0x1fff }, //  SF2 Alternate status field 2
    { FPSRSF1,    STFPSR, 19, 0x1fff }, //  SF1 Alternate status field 1
    { FPSRSF0,    STFPSR,  6, 0x1fff }, //  SF0 Main status field
    { FPSRTRAPID, STFPSR,  5,      1 }, //  TRAPID Inexact floating point trap
    { FPSRTRAPUD, STFPSR,  4,      1 }, //  TRAPUD Underflow floating point trap
    { FPSRTRAPOD, STFPSR,  3,      1 }, //  TRAPOD Overflow flating point trap
    { FPSRTRAPZD, STFPSR,  2,      1 }, //  TRAPZD Zero devide floating point trap
    { FPSRTRAPDD, STFPSR,  1,      1 }, //  TRAPDD Denormal/Unnormal operand floating point trap
    { FPSRTRAPVD, STFPSR,  0,      1 }, //  TRAPVD Invalid operation floating point trap

    // Predicate registers
//  { PR0,  PREDS,  0, 1 },
    { PR1,  PREDS,  1, 1 },
    { PR2,  PREDS,  2, 1 },
    { PR3,  PREDS,  3, 1 },
    { PR4,  PREDS,  4, 1 },
    { PR5,  PREDS,  5, 1 },
    { PR6,  PREDS,  6, 1 },
    { PR7,  PREDS,  7, 1 },
    { PR8,  PREDS,  8, 1 },
    { PR9,  PREDS,  9, 1 },
    { PR10, PREDS, 10, 1 },
    { PR11, PREDS, 11, 1 },
    { PR12, PREDS, 12, 1 },
    { PR13, PREDS, 13, 1 },
    { PR14, PREDS, 14, 1 },
    { PR15, PREDS, 15, 1 },
    { PR16, PREDS, 16, 1 },
    { PR17, PREDS, 17, 1 },
    { PR18, PREDS, 18, 1 },
    { PR19, PREDS, 19, 1 },
    { PR20, PREDS, 20, 1 },
    { PR21, PREDS, 21, 1 },
    { PR22, PREDS, 22, 1 },
    { PR23, PREDS, 23, 1 },
    { PR24, PREDS, 24, 1 },
    { PR25, PREDS, 25, 1 },
    { PR26, PREDS, 26, 1 },
    { PR27, PREDS, 27, 1 },
    { PR28, PREDS, 28, 1 },
    { PR29, PREDS, 29, 1 },
    { PR30, PREDS, 30, 1 },
    { PR31, PREDS, 31, 1 },
    { PR32, PREDS, 32, 1 },
    { PR33, PREDS, 33, 1 },
    { PR34, PREDS, 34, 1 },
    { PR35, PREDS, 35, 1 },
    { PR36, PREDS, 36, 1 },
    { PR37, PREDS, 37, 1 },
    { PR38, PREDS, 38, 1 },
    { PR39, PREDS, 39, 1 },
    { PR40, PREDS, 40, 1 },
    { PR41, PREDS, 41, 1 },
    { PR42, PREDS, 42, 1 },
    { PR43, PREDS, 43, 1 },
    { PR44, PREDS, 44, 1 },
    { PR45, PREDS, 45, 1 },
    { PR46, PREDS, 46, 1 },
    { PR47, PREDS, 47, 1 },
    { PR48, PREDS, 48, 1 },
    { PR49, PREDS, 49, 1 },
    { PR50, PREDS, 50, 1 },
    { PR51, PREDS, 51, 1 },
    { PR52, PREDS, 52, 1 },
    { PR53, PREDS, 53, 1 },
    { PR54, PREDS, 54, 1 },
    { PR55, PREDS, 55, 1 },
    { PR56, PREDS, 56, 1 },
    { PR57, PREDS, 57, 1 },
    { PR58, PREDS, 58, 1 },
    { PR59, PREDS, 59, 1 },
    { PR60, PREDS, 60, 1 },
    { PR61, PREDS, 61, 1 },
    { PR62, PREDS, 62, 1 },
    { PR63, PREDS, 63, 1 },

    { 0, 0, 0 }
};

#define REGALL_HIGHFLOAT        REGALL_EXTRA0
#define REGALL_DREG             REGALL_EXTRA1
REGALLDESC IA64ExtraDesc[] =
{
    REGALL_HIGHFLOAT,  "High floating pointer registers (f32-f127)",
    REGALL_DREG,       "User debug registers",
    0,                 NULL,
};

#define REGALL_SPECIALREG       REGALL_EXTRA2
REGALLDESC g_Ia64KernelExtraDesc[] =
{
    REGALL_SPECIALREG, "KSPECIAL_REGISTERS",
    0,                 NULL,
};

RegisterGroup g_Ia64BaseGroup =
{
    NULL, 0, IA64Regs, IA64SubRegs, IA64ExtraDesc
};
RegisterGroup g_Ia64KernelGroup =
{
    NULL, 0, g_Ia64KernelRegs, NULL, g_Ia64KernelExtraDesc
};

// First ExecTypes entry must be the actual processor type.
ULONG g_Ia64ExecTypes[] =
{
    IMAGE_FILE_MACHINE_IA64, IMAGE_FILE_MACHINE_I386
};

BOOL 
SplitIa64Pc(ULONG64 Pc, ULONG64* Bundle, ULONG64* Slot)
{
    ULONG64 SlotVal = Pc & 0xf;

    switch (SlotVal) 
    {
    case 0: 
    case 4: 
    case 8:  
        SlotVal >>= 2;
        break;
    default: 
        return FALSE;
    } 

    if (Slot) 
    {
        *Slot = SlotVal;
    }
    if (Bundle) 
    {
        *Bundle = Pc & ~(ULONG64)0xf;
    }

    return TRUE;
}

Ia64MachineInfo g_Ia64Machine;

HRESULT
Ia64MachineInfo::InitializeConstants(void)
{
    m_FullName = "Intel IA64";
    m_AbbrevName = "ia64";
    m_PageSize = IA64_PAGE_SIZE;
    m_PageShift = IA64_PAGE_SHIFT;
    m_NumExecTypes = 2;
    m_ExecTypes = g_Ia64ExecTypes;
    m_Ptr64 = TRUE;
    
    m_AllMask = REGALL_INT64 | REGALL_DREG,
        
    m_MaxDataBreakpoints = IA64_REG_MAX_DATA_BREAKPOINTS;
    m_SymPrefix = NULL;

    m_KernPageDir = 0;
    
    return MachineInfo::InitializeConstants();
}

HRESULT
Ia64MachineInfo::InitializeForTarget(void)
{
    m_Groups = &g_Ia64BaseGroup;
    g_Ia64BaseGroup.Next = NULL;
    if (IS_KERNEL_TARGET())
    {
        g_Ia64BaseGroup.Next = &g_Ia64KernelGroup;
    }

    m_OffsetPrcbProcessorState =
        FIELD_OFFSET(IA64_PARTIAL_KPRCB, ProcessorState);
    m_OffsetPrcbNumber =
        FIELD_OFFSET(IA64_PARTIAL_KPRCB, Number);
    m_TriagePrcbOffset = IA64_TRIAGE_PRCB_ADDRESS;
    m_SizePrcb = IA64_KPRCB_SIZE;
    m_OffsetKThreadApcProcess =
        FIELD_OFFSET(CROSS_PLATFORM_THREAD, IA64Thread.ApcState.Process);
    m_OffsetKThreadTeb =
        FIELD_OFFSET(CROSS_PLATFORM_THREAD, IA64Thread.Teb);
    m_OffsetKThreadInitialStack =
        FIELD_OFFSET(CROSS_PLATFORM_THREAD, IA64Thread.InitialStack);
    m_OffsetKThreadNextProcessor = IA64_KTHREAD_NEXTPROCESSOR_OFFSET;
    m_OffsetEprocessPeb =  (g_TargetBuildNumber < 2264 ) ?
        IA64_PEB_IN_EPROCESS : IA64_2259_PEB_IN_EPROCESS;
    m_OffsetEprocessDirectoryTableBase =
        IA64_DIRECTORY_TABLE_BASE_IN_EPROCESS;
    m_SizeTargetContext = sizeof(IA64_CONTEXT);
    m_OffsetTargetContextFlags = FIELD_OFFSET(IA64_CONTEXT, ContextFlags);
    m_SizeCanonicalContext = sizeof(IA64_CONTEXT);
    m_SverCanonicalContext = NT_SVER_W2K;
    m_SizeControlReport = sizeof(IA64_DBGKD_CONTROL_REPORT);
    m_SizeEThread = IA64_ETHREAD_SIZE;
    m_SizeEProcess = IA64_EPROCESS_SIZE;
    m_OffsetSpecialRegisters = IA64_DEBUG_CONTROL_SPACE_KSPECIAL;
    m_SizeKspecialRegisters = sizeof(IA64_KSPECIAL_REGISTERS);
    m_SizePartialKThread = sizeof(IA64_THREAD);
    m_SharedUserDataOffset = IS_KERNEL_TARGET() ?
        IA64_KI_USER_SHARED_DATA : MM_SHARED_USER_DATA_VA;

    return MachineInfo::InitializeForTarget();
}

void
Ia64MachineInfo::
InitializeContext(ULONG64 Pc,
                  PDBGKD_ANY_CONTROL_REPORT ControlReport)
{
    if (Pc)
    {
        ULONG Slot;

        m_ContextState = MCTX_PC;
        Slot = (ULONG)(Pc & 0xc) >> 2;
        m_Context.IA64Context.StIIP = Pc & ~(0xf);
        m_Context.IA64Context.StIPSR &= ~(IPSR_RI_MASK);
        m_Context.IA64Context.StIPSR |=  (ULONGLONG)Slot << PSR_RI;
    }
    else
    {
        m_Context.IA64Context.StIIP = Pc;
    }

    if (Pc && ControlReport != NULL)
    {
        CacheReportInstructions
            (Pc, ControlReport->IA64ControlReport.InstructionCount,
             ControlReport->IA64ControlReport.InstructionStream);
    }
}

HRESULT
Ia64MachineInfo::KdGetContextState(ULONG State)
{
    HRESULT Status;
        
    if (State >= MCTX_CONTEXT && m_ContextState < MCTX_CONTEXT)
    {
        Status = g_Target->GetContext(g_RegContextThread->Handle, &m_Context);
        if (Status != S_OK)
        {
            return Status;
        }

        m_ContextState = MCTX_CONTEXT;
    }
    
    if (State >= MCTX_FULL && m_ContextState < MCTX_FULL)
    {
        Status = g_Target->GetTargetSpecialRegisters
            (g_RegContextThread->Handle, (PCROSS_PLATFORM_KSPECIAL_REGISTERS)
             &m_SpecialRegContext);
        if (Status != S_OK)
        {
            return Status;
        }

        m_ContextState = MCTX_FULL;
        KdSetSpecialRegistersInContext();
    }

    return S_OK;
}

HRESULT
Ia64MachineInfo::KdSetContext(void)
{
    HRESULT Status;
    
    Status = g_Target->SetContext(g_RegContextThread->Handle, &m_Context);
    if (Status != S_OK)
    {
        return Status;
    }

    KdGetSpecialRegistersFromContext();
    Status = g_Target->SetTargetSpecialRegisters
        (g_RegContextThread->Handle, (PCROSS_PLATFORM_KSPECIAL_REGISTERS)
         &m_SpecialRegContext);
    if (Status != S_OK)
    {
        return Status;
    }

    return S_OK;
}

HRESULT
Ia64MachineInfo::ConvertContextFrom(PCROSS_PLATFORM_CONTEXT Context,
                                    ULONG FromSver, ULONG FromSize, PVOID From)
{
    if (FromSize < sizeof(IA64_CONTEXT))
    {
        return E_INVALIDARG;
    }

    memcpy(Context, From, sizeof(IA64_CONTEXT));
    return S_OK;
}

HRESULT
Ia64MachineInfo::ConvertContextTo(PCROSS_PLATFORM_CONTEXT Context,
                                  ULONG ToSver, ULONG ToSize, PVOID To)
{
    if (ToSize < sizeof(IA64_CONTEXT))
    {
        return E_INVALIDARG;
    }

    memcpy(To, Context, sizeof(IA64_CONTEXT));
    return S_OK;
}

void
Ia64MachineInfo::InitializeContextFlags(PCROSS_PLATFORM_CONTEXT Context,
                                        ULONG Version)
{
    Context->IA64Context.ContextFlags =
        IA64_CONTEXT_FULL | IA64_CONTEXT_DEBUG;
}

HRESULT
Ia64MachineInfo::GetContextFromThreadStack(ULONG64 ThreadBase,
                                           PCROSS_PLATFORM_THREAD Thread,
                                           PCROSS_PLATFORM_CONTEXT Context,
                                           PDEBUG_STACK_FRAME Frame,
                                           PULONG RunningOnProc)
{
    HRESULT Status;
    UCHAR Proc;

    //
    // Check to see if the thread is currently running.
    //
    
    if (Thread->IA64Thread.State == 2)
    {
        if ((Status = g_Target->ReadAllVirtual
             (ThreadBase + m_OffsetKThreadNextProcessor, 
              &Proc, sizeof(Proc))) != S_OK) 
            {
                return Status;
            }

        *RunningOnProc = Proc;
        return S_FALSE;
    }
    
    //
    // The thread isn't running so read its stored context information.
    //
    
    IA64_KSWITCH_FRAME SwitchFrame;

    if ((Status = g_Target->ReadAllVirtual(Thread->IA64Thread.KernelStack + 
                                           IA64_STACK_SCRATCH_AREA, 
                                           &SwitchFrame, 
                                           sizeof(SwitchFrame))) != S_OK)
    {
        return Status;
    }

    Context->IA64Context.IntSp = 
        Thread->IA64Thread.KernelStack;
    Context->IA64Context.Preds = SwitchFrame.SwitchPredicates;
    Context->IA64Context.StIIP = SwitchFrame.SwitchRp;
    Context->IA64Context.StFPSR = SwitchFrame.SwitchFPSR;
    Context->IA64Context.BrRp = SwitchFrame.SwitchRp;
    Context->IA64Context.RsPFS = SwitchFrame.SwitchPFS;
    Context->IA64Context.StIFS = SwitchFrame.SwitchPFS;

    SHORT BsFrameSize = 
        (SHORT)(SwitchFrame.SwitchPFS >> IA64_PFS_SIZE_SHIFT) & 
        IA64_PFS_SIZE_MASK;
    SHORT TempFrameSize = 
        BsFrameSize - (SHORT)((SwitchFrame.SwitchBsp >> 3) & 
                              IA64_NAT_BITS_PER_RNAT_REG);

    while (TempFrameSize > 0) 
    {
        BsFrameSize++;
        TempFrameSize -= IA64_NAT_BITS_PER_RNAT_REG;
    } 

    Context->IA64Context.RsBSP = 
        SwitchFrame.SwitchBsp - (BsFrameSize * sizeof(ULONGLONG));

    Context->IA64Context.FltS0 = SwitchFrame.SwitchExceptionFrame.FltS0;
    Context->IA64Context.FltS1 = SwitchFrame.SwitchExceptionFrame.FltS1;
    Context->IA64Context.FltS2 = SwitchFrame.SwitchExceptionFrame.FltS2;
    Context->IA64Context.FltS3 = SwitchFrame.SwitchExceptionFrame.FltS3;
    Context->IA64Context.FltS4 = SwitchFrame.SwitchExceptionFrame.FltS4;
    Context->IA64Context.FltS5 = SwitchFrame.SwitchExceptionFrame.FltS5;
    Context->IA64Context.FltS6 = SwitchFrame.SwitchExceptionFrame.FltS6;
    Context->IA64Context.FltS7 = SwitchFrame.SwitchExceptionFrame.FltS7;
    Context->IA64Context.FltS8 = SwitchFrame.SwitchExceptionFrame.FltS8;
    Context->IA64Context.FltS9 = SwitchFrame.SwitchExceptionFrame.FltS9;
    Context->IA64Context.FltS10 = SwitchFrame.SwitchExceptionFrame.FltS10;
    Context->IA64Context.FltS11 = SwitchFrame.SwitchExceptionFrame.FltS11;
    Context->IA64Context.FltS12 = SwitchFrame.SwitchExceptionFrame.FltS12;
    Context->IA64Context.FltS13 = SwitchFrame.SwitchExceptionFrame.FltS13;
    Context->IA64Context.FltS14 = SwitchFrame.SwitchExceptionFrame.FltS14;
    Context->IA64Context.FltS15 = SwitchFrame.SwitchExceptionFrame.FltS15;
    Context->IA64Context.FltS16 = SwitchFrame.SwitchExceptionFrame.FltS16;
    Context->IA64Context.FltS17 = SwitchFrame.SwitchExceptionFrame.FltS17;
    Context->IA64Context.FltS18 = SwitchFrame.SwitchExceptionFrame.FltS18;
    Context->IA64Context.FltS19 = SwitchFrame.SwitchExceptionFrame.FltS19;
    Context->IA64Context.IntS0 = SwitchFrame.SwitchExceptionFrame.IntS0;
    Context->IA64Context.IntS1 = SwitchFrame.SwitchExceptionFrame.IntS1;
    Context->IA64Context.IntS2 = SwitchFrame.SwitchExceptionFrame.IntS2;
    Context->IA64Context.IntS3 = SwitchFrame.SwitchExceptionFrame.IntS3;
    Context->IA64Context.IntNats = SwitchFrame.SwitchExceptionFrame.IntNats;
    Context->IA64Context.BrS0 = SwitchFrame.SwitchExceptionFrame.BrS0;
    Context->IA64Context.BrS1 = SwitchFrame.SwitchExceptionFrame.BrS1;
    Context->IA64Context.BrS2 = SwitchFrame.SwitchExceptionFrame.BrS2;
    Context->IA64Context.BrS3 = SwitchFrame.SwitchExceptionFrame.BrS3;
    Context->IA64Context.BrS4 = SwitchFrame.SwitchExceptionFrame.BrS4;
    Context->IA64Context.ApEC = SwitchFrame.SwitchExceptionFrame.ApEC;
    Context->IA64Context.ApLC = SwitchFrame.SwitchExceptionFrame.ApLC;

    Frame->InstructionOffset = Context->IA64Context.StIIP;
    Frame->StackOffset = Context->IA64Context.IntSp;
    Frame->FrameOffset = Context->IA64Context.RsBSP;
        
    return S_OK;
}

int
Ia64MachineInfo::GetType(ULONG index)
{
    if (index >= IA64_FLTBASE && index <= IA64_FLTLAST)
    {
        return REGVAL_FLOAT82;
    }
    else if ((index >= INTGP && index <= INTT22) ||
             (index >= INTR32 && index <= INTR127))
    {
        return REGVAL_INT64N;
    }
    else if (index < IA64_FLAGBASE)
    {
        return REGVAL_INT64;
    }
    else
    {
        return REGVAL_SUB64;
    }
}

/*** RegGetVal - get register value
*
*   Purpose:
*       Returns the value of the register from the processor
*       context structure.
*
*   Input:
*       regnum - register specification
*
*   Returns:
*       value of the register from the context structure
*
*************************************************************************/

BOOL
Ia64MachineInfo::GetVal (ULONG regnum, REGVAL *val)
{
    switch(m_ContextState)
    {
    case MCTX_PC:
        switch (regnum)
        {
        case STIIP:
            val->type = REGVAL_INT64;
            val->i64 = m_Context.IA64Context.StIIP;
            return TRUE;
        }
        goto MctxContext;

    case MCTX_REPORT:
#if 0
        // place holder for Debug/Segment registers manipulation via
        // Control REPORT message
        switch (regnum)
        {
        case KRDBI0:
            val->type = REGVAL_INT64;
            val->i64 = SpecialRegContext.KernelDbi0;
            return TRUE;
        }
#endif

        //
        // Requested register was not in MCTX_REPORT - go get the next
        // context level.
        //

    case MCTX_NONE:
    MctxContext:
        if (GetContextState(MCTX_CONTEXT) != S_OK)
        {
            return FALSE;
        }
        // Fallthrough!
        
    case MCTX_CONTEXT:
        if (regnum >= IA64_FLTBASE && regnum <= IA64_FLTLAST)
        {
            val->type = REGVAL_FLOAT82;
            val->f16Parts.high = 0;
            memcpy(val->f82,
                   (PULONGLONG)&m_Context.IA64Context.DbI0 + regnum,
                   sizeof(val->f82));
            return TRUE;
        }
        else if ((regnum >= INTGP) && (regnum <= INTT22)) 
        {
            val->type = REGVAL_INT64N;
            val->Nat = (UCHAR)((m_Context.IA64Context.IntNats >> (regnum - INTGP + 1)) & 0x1);
            val->i64 = *((PULONGLONG)&m_Context.IA64Context.IntGp + regnum - INTGP);
            return TRUE;
        }
        else if ((regnum >= INTR32) && (regnum <= INTR127))
        {
            USHORT FrameSize;
            
            val->type = REGVAL_INT64N;
            regnum -= INTR32;
            FrameSize = (USHORT)(m_Context.IA64Context.StIFS & 0x7F);
            if (regnum >= FrameSize) {
#if 0
                ErrOut("RegGetVal: out-of-frame register r%ld requested\n",
                       regnum+32);
                return FALSE;
#else
                val->i64 = 0;
                val->Nat = TRUE;
                return TRUE;
#endif
            }
            return GetStackedRegVal(m_Context.IA64Context.RsBSP, FrameSize,
                                    m_Context.IA64Context.RsRNAT, regnum, val);
        }
        else if (regnum < IA64_SRBASE)
        {
            val->type = REGVAL_INT64;
            val->i64 = *((PULONGLONG)&m_Context.IA64Context.DbI0 + regnum);
            return TRUE;
        }

        //
        // The requested register is not in our current context, load up
        // a complete context
        //

        if (GetContextState(MCTX_FULL) != S_OK)
        {
            return FALSE;
        }
    }

    //
    // We must have a complete context...
    //

    if (regnum >= IA64_FLTBASE && regnum <= IA64_FLTLAST)
    {
        val->type = REGVAL_FLOAT82;
        val->f16Parts.high = 0;
        memcpy(val->f82,
               (PULONGLONG)&m_Context.IA64Context.DbI0 + regnum,
               sizeof(val->f82));
        return TRUE;
    }
    else if ((regnum >= INTGP) && (regnum <= INTT22))
    {
        val->type = REGVAL_INT64N;
        val->Nat = (UCHAR)((*((PULONGLONG)&m_Context.IA64Context.DbI0 + INTNATS) >> (regnum - INTGP + 1)) & 0x1);
        val->i64 = *((PULONGLONG)&m_Context.IA64Context.DbI0 + regnum);
        return TRUE;
    }
    else if ((regnum >= INTR32) && (regnum <= INTR127))
    {
        USHORT FrameSize;

        val->type = REGVAL_INT64N;
        regnum -= INTR32;
        FrameSize = (USHORT)(m_Context.IA64Context.StIFS & 0x7F);
        if (regnum >= FrameSize) {
#if 0
            ErrOut("RegGetVal: out-of-frame register r%ld requested\n",
                   regnum+32);
            return FALSE;
#else
            val->i64 = 0;
            val->Nat = TRUE;
            return TRUE;
#endif
        }
        return GetStackedRegVal(m_Context.IA64Context.RsBSP, FrameSize,
                                m_Context.IA64Context.RsRNAT, regnum, val);
    }
    else if (regnum < IA64_SRBASE)
    {
        val->type = REGVAL_INT64;
        val->i64 = *((PULONGLONG)&m_Context.IA64Context.DbI0 + regnum);
        return TRUE;
    }
    else if (IS_KERNEL_TARGET() && regnum <= IA64_SREND)
    {
        val->type = REGVAL_INT64;
        val->i64 = *((PULONGLONG)&m_SpecialRegContext.KernelDbI0 +
                     (regnum - IA64_SRBASE));
        return TRUE;
    }
    else
    {
        ErrOut("Ia64MachineInfo::GetVal: "
               "unknown register %lx requested\n", regnum);
        return FALSE;
    }
}

/*** RegSetVal - set register value
*
*   Purpose:
*       Set the value of the register in the processor context
*       structure.
*
*   Input:
*       regnum - register specification
*       regvalue - new value to set the register
*
*   Output:
*       None.
*
*************************************************************************/

BOOL
Ia64MachineInfo::SetVal (ULONG regnum, REGVAL *val)
{
    if (m_ContextIsReadOnly)
    {
        return FALSE;
    }
    
    BOOL Ia32InstructionSet = IsIA32InstructionSet();

    // Optimize away some common cases where registers are
    // set to their current value.

    if ((regnum == STIIP) && (m_ContextState >= MCTX_PC))
    {
        if (val->type != REGVAL_INT64)
        {
            return FALSE;
        }

        ULONG64 Slot, Bundle;

        if ((Ia32InstructionSet && 
             (m_Context.IA64Context.StIIP == val->i64)) ||
            ((SplitIa64Pc(val->i64, &Bundle, &Slot) &&
             (Bundle == m_Context.IA64Context.StIIP) &&
             (Slot == ((m_Context.IA64Context.StIPSR & IPSR_RI_MASK) >> 
                       PSR_RI)))))
        {
            return TRUE;
        }
    }
         
    if (GetContextState(MCTX_DIRTY) != S_OK)
    {
        return FALSE;
    }
    
    if (regnum == STIIP) 
    {
        ULONG64 Bundle, Slot;

        if ((val->type != REGVAL_INT64) || 
            !(Ia32InstructionSet || SplitIa64Pc(val->i64, &Bundle, &Slot)))
        {
            return FALSE;
        }

        if (Ia32InstructionSet) 
        {
            m_Context.IA64Context.StIIP = val->i64;
        }
        else
        {
            m_Context.IA64Context.StIIP = Bundle;
            (m_Context.IA64Context.StIPSR &= ~(IPSR_RI_MASK)) |= 
                (ULONGLONG)Slot << PSR_RI;
        }
    }
    else if (regnum >= IA64_FLTBASE && regnum <= IA64_FLTLAST)
    {
        memcpy((PULONGLONG)&m_Context.IA64Context.DbI0 + regnum,
               val->f82, sizeof(val->f82));
    }
    else if ((regnum >= INTGP) && (regnum <= INTT22))
    {
        ULONG64 Mask = (0x1i64 << (regnum - INTGP + 1));
        
        if (val->Nat) {
            m_Context.IA64Context.IntNats |= Mask;
        } else  {
            m_Context.IA64Context.IntNats &= ~Mask;
            *((PULONGLONG)&m_Context.IA64Context.DbI0 + regnum) = val->i64;
        }
    }
    else if ((regnum >= INTR32) && (regnum <= INTR127))
    {
        USHORT FrameSize;

        regnum -= INTR32;
        FrameSize = (USHORT)(m_Context.IA64Context.StIFS & 0x7F);
        if (regnum >= FrameSize) {
            ErrOut("RegSetVal: out-of-frame register r%ld requested\n",
                   regnum+32);
            return FALSE;
        }
        if (!SetStackedRegVal(m_Context.IA64Context.RsBSP, FrameSize,
                              &m_Context.IA64Context.RsRNAT, regnum, val))
        {
            return FALSE;
        }
    }
    else if (regnum < IA64_SRBASE)
    {
        *((PULONGLONG)&m_Context.IA64Context.DbI0 + regnum) = val->i64;
    }
    else if (IS_KERNEL_TARGET() && regnum <= IA64_SREND)
    {
        *((PULONGLONG)&m_SpecialRegContext.KernelDbI0 + (regnum - IA64_SRBASE)) =
            val->i64;
    }
    else
    {
        ErrOut("Ia64MachineInfo::SetVal: "
               "unknown register %lx requested\n", regnum);
        return FALSE;
    }

    NotifyChangeDebuggeeState(DEBUG_CDS_REGISTERS,
                              RegCountFromIndex(regnum));
    return TRUE;
}

void
Ia64MachineInfo::GetPC (PADDR Address)
{
    ULONG64 value, slot;

    // get slot# from IPSR.ri and place them in bit(2-3)
    slot = (GetReg64(STIPSR) >> (PSR_RI - 2)) & 0xc;
    // Do not use ISR.ei which does not contain the restart instruction slot.

    value = GetReg64(STIIP) | slot;
    ADDRFLAT(Address, value);
}

void
Ia64MachineInfo::SetPC (PADDR paddr)
{
    SetReg64(STIIP, Flat(*paddr));
}

void
Ia64MachineInfo::GetFP(PADDR Address)
{
    //  IA64 software convention has no frame pointer defined.
    //    FP_REG need to be derived from virtual unwind of stack.

    DEBUG_STACK_FRAME StackFrame;

    StackTrace( 0, 0, 0, &StackFrame, 1, 0, 0, FALSE );
    ADDRFLAT(Address, StackFrame.FrameOffset);
}

void
Ia64MachineInfo::GetSP(PADDR Address)
{
    ADDRFLAT(Address, GetReg64(INTSP));
}

ULONG64
Ia64MachineInfo::GetArgReg(void)
{
    return GetReg64(INTV0);
}

/*** RegOutputAll - output all registers and present instruction
*
*   Purpose:
*       Function of "r" command.
*
*       To output the current register state of the processor.
*       All integer registers are output as well as processor status
*       registers in the _CONTEXT record.  Important flag fields are
*       also output separately. OutDisCurrent is called to output the
*       current instruction(s).
*
*   Input:
*       None.
*
*   Output:
*       None.
*
*************************************************************************/

void
Ia64MachineInfo::OutputAll(ULONG Mask, ULONG OutMask)
{
    int       regindex, col = 0;
    int       lastout;
    USHORT    nStackReg;
    REGVAL    val;
    ULONG     i;

    if (GetContextState(MCTX_FULL) != S_OK)
    {
        ErrOut("Unable to retrieve register information\n");
        return;
    }
    
    // Output user debug registers

    if (Mask & REGALL_DREG)
    {
        for (regindex = IA64_DBBASE;
             regindex <= IA64_DBLAST;
             regindex++)
        {
            MaskOut(OutMask, "%9s = %16I64x", 
                    RegNameFromIndex(regindex),
                    GetReg64(regindex));
            if (regindex % 2 == 1)
            {
                MaskOut(OutMask, "\n");
            }
            else
            {
                MaskOut(OutMask, "\t");
            }
        }
        MaskOut(OutMask, "\n");
    }

    if (Mask & (REGALL_INT32 | REGALL_INT64))
    {
        if (Mask & REGALL_SPECIALREG)
        {
            // + ARs + DBs + SRs
            lastout = IA64_SREND + 1;
        }
        else
        {
            // INTs, PREDS, BRs,
            lastout = IA64_SRBASE;
        }

        nStackReg = (USHORT)(GetReg64(STIFS) & 0x7F);

        //   Output all registers, skip INTZERO and floating point registers

        for (regindex = IA64_REGBASE; regindex < lastout; regindex++)
        {
            if (regindex == BRRP || regindex == PREDS || regindex == APUNAT ||
                regindex == IA64_SRBASE || regindex == INTR32) 
            {
                if (col % 2 == 1)
                {
                    MaskOut(OutMask, "\n");
                }
                MaskOut(OutMask, "\n");
                col = 0;
            }

            if (INTGP <= regindex && regindex <= INTT22)
            {
                if (GetVal(regindex, &val))
                {
                    MaskOut(OutMask, "%9s = %16I64x %1lx",
                            RegNameFromIndex(regindex),
                            val.i64, val.Nat);
                }
                if (col % 2 == 1)
                {
                    MaskOut(OutMask, "\n");
                }
                else
                {
                    MaskOut(OutMask, "\t");
                }
                col++;
            }
            else if (INTR32 <= regindex && regindex <= INTR127)
            {
                if ((nStackReg != 0) && GetVal(regindex, &val))
                {
                    MaskOut(OutMask, "%9s = %16I64x %1lx",
                            RegNameFromIndex(regindex),
                            val.i64, val.Nat);
                    nStackReg--;
                    if (col % 2 == 1)
                    {
                        MaskOut(OutMask, "\n");
                    }
                    else
                    {
                        MaskOut(OutMask, "\t");
                    }
                    col++;
                }
            }
            else
            {
                MaskOut(OutMask, "%9s = %16I64x",
                        RegNameFromIndex(regindex),
                        GetReg64(regindex));
                if (col % 2 == 1)
                {
                    MaskOut(OutMask, "\n");
                }
                else
                {
                    MaskOut(OutMask, "\t");
                }
                col++;
            }
        }
        MaskOut(OutMask, "\n");

/*
        //    Output IPSR flags
        MaskOut(OutMask, "\n\tipsr:\tbn ed ri ss dd da id it tme is cpl rt tb lp db\n");
        MaskOut(OutMask, "\t\t %1lx %1lx  %1lx  %1lx  %1lx  %1lx  %1lx  %1lx  %1lx   %1lx  %1lx   %1lx  %1lx  %1lx  %1lx\n",
                GetSubReg32(IPSRBN),
                GetSubReg32(IPSRED),
                GetSubReg32(IPSRRI),
                GetSubReg32(IPSRSS),
                GetSubReg32(IPSRDD),
                GetSubReg32(IPSRDA),
                GetSubReg32(IPSRID),
                GetSubReg32(IPSRIT),
                GetSubReg32(IPSRME),
                GetSubReg32(IPSRIS),
                GetSubReg32(IPSRCPL),
                GetSubReg32(IPSRRT),
                GetSubReg32(IPSRTB),
                GetSubReg32(IPSRLP),
                GetSubReg32(IPSRDB));
        MaskOut(OutMask, "\t\tsi di pp sp dfh dfl dt bn pk i ic ac up be or\n");
        MaskOut(OutMask, "\t\t %1lx  %1lx  %1lx  %1lx  %1lx   %1lx   %1lx  %1lx  %1lx %1lx  %1lx  %1lx  %1lx  %1lx\n",
                GetSubReg32(IPSRSI),
                GetSubReg32(IPSRDI),
                GetSubReg32(IPSRPP),
                GetSubReg32(IPSRSP),
                GetSubReg32(IPSRDFH),
                GetSubReg32(IPSRDFL),
                GetSubReg32(IPSRDT),
                GetSubReg32(IPSRPK),
                GetSubReg32(IPSRI),
                GetSubReg32(IPSRIC),
                GetSubReg32(IPSRAC),
                GetSubReg32(IPSRUP),
                GetSubReg32(IPSRBE),
                GetSubReg32(IPSROR));
*/
    }

    if (Mask & REGALL_FLOAT)
    {
/*
        //    Output FPSR flags
        MaskOut(OutMask, "\n\tfpsr:\tmdh mdl  sf3  sf2  sf1  sf0  id ud od zd dd vd\n");
        MaskOut(OutMask, "\t\t %1lx   %1lx  %04lx %04lx %04lx %04lx   %1lx  %1lx  %1lx  %1lx  %1lx  %1lx\n",
                GetSubReg32(FPSRMDH),
                GetSubReg32(FPSRMDL),
                GetSubReg32(FPSRSF3),
                GetSubReg32(FPSRSF2),
                GetSubReg32(FPSRSF1),
                GetSubReg32(FPSRSF0),
                GetSubReg32(FPSRTRAPID),
                GetSubReg32(FPSRTRAPUD),
                GetSubReg32(FPSRTRAPOD),
                GetSubReg32(FPSRTRAPZD),
                GetSubReg32(FPSRTRAPDD),
                GetSubReg32(FPSRTRAPVD));
*/

        //
        // Print the low floating point register set, skip FLTZERO & FLTONE
        //

        MaskOut(OutMask, "\n");
        for (i = IA64_FLTBASE; i < FLTF32; i += 2)
        {
            GetVal(i, &val);
            MaskOut(OutMask, "%9s = %I64x %I64x\n", RegNameFromIndex(i),
                    val.f16Parts.high, val.f16Parts.low);
        }
    }

    if (Mask & REGALL_HIGHFLOAT)
    {
        //
        // Print the low floating point register set, skip FLTZERO & FLTONE
        //

        MaskOut(OutMask, "\n");
        for (i = FLTF32 ; i <= FLTF127; i += 2)
        {
            GetVal(i, &val);
            MaskOut(OutMask, "%9s = %I64x %I64x\n", RegNameFromIndex(i),
                    val.f16Parts.high, val.f16Parts.low);
        }
    }
}

TRACEMODE
Ia64MachineInfo::GetTraceMode (void)
{
    if (IS_KERNEL_TARGET())
    {
        return m_TraceMode;
    }
    else
    {
        ULONG64 Ipsr = GetReg64(STIPSR);
        if (Ipsr & (1I64 << PSR_SS)) 
        {
            return TRACE_INSTRUCTION;
        }
        else if (Ipsr & (1I64 << PSR_TB)) 
        {
            return TRACE_TAKEN_BRANCH;
        }
        else 
        {
            return TRACE_NONE;
        }
    }
}

void
Ia64MachineInfo::SetTraceMode (TRACEMODE Mode)
{
    DBG_ASSERT(Mode == TRACE_NONE ||
               Mode == TRACE_INSTRUCTION ||
               Mode == TRACE_TAKEN_BRANCH);

    if (IS_KERNEL_TARGET())
    {
        m_TraceMode = Mode;
    }
    else 
    {
        ULONG64 Ipsr, IpsrSave;
        Ipsr = IpsrSave = GetReg64(STIPSR);

        Ipsr &= ~(1I64 << PSR_SS);
        Ipsr &= ~(1I64 << PSR_TB);

        switch (Mode) 
        {
        case TRACE_INSTRUCTION:
            Ipsr |= (1I64 << PSR_SS);
            break;
        case TRACE_TAKEN_BRANCH:
            Ipsr |= (1I64 << PSR_TB);
            break;
        }
        
        if (Ipsr != IpsrSave)
        {
            SetReg64(STIPSR, Ipsr);
        }
    }
}

BOOL
Ia64MachineInfo::IsStepStatusSupported(ULONG Status)
{
    switch (Status) 
    {
    case DEBUG_STATUS_STEP_INTO:   // TRACE_INSTRUCTION
    case DEBUG_STATUS_STEP_OVER:   
    case DEBUG_STATUS_STEP_BRANCH: // TRACE_TAKEN_BRANCH
        return TRUE;
    default:
        return FALSE;
    }
}

void
Ia64MachineInfo::KdUpdateControlSet
    (PDBGKD_ANY_CONTROL_SET ControlSet)
{
    switch (GetTraceMode()) 
    {
    case TRACE_NONE:
        ControlSet->IA64ControlSet.Continue = 
            IA64_DBGKD_CONTROL_SET_CONTINUE_NONE;
        break;

    case TRACE_INSTRUCTION:
        ControlSet->IA64ControlSet.Continue = 
            IA64_DBGKD_CONTROL_SET_CONTINUE_TRACE_INSTRUCTION;
        break;

    case TRACE_TAKEN_BRANCH:
        ControlSet->IA64ControlSet.Continue = 
            IA64_DBGKD_CONTROL_SET_CONTINUE_TRACE_TAKEN_BRANCH;
        break;
    }

    if (!g_WatchFunctions.IsStarted() && g_WatchBeginCurFunc != 1)
    {
        ControlSet->IA64ControlSet.CurrentSymbolStart = 0;
        ControlSet->IA64ControlSet.CurrentSymbolEnd = 0;
    }
    else
    {
        ControlSet->IA64ControlSet.CurrentSymbolStart = g_WatchBeginCurFunc;
        ControlSet->IA64ControlSet.CurrentSymbolEnd = g_WatchEndCurFunc;
    }
}

void
Ia64MachineInfo::KdSaveProcessorState(
    void
    )
{
    MachineInfo::KdSaveProcessorState();
    m_SavedSpecialRegContext = m_SpecialRegContext;
}

void
Ia64MachineInfo::KdRestoreProcessorState(
    void
    )
{
    MachineInfo::KdRestoreProcessorState();
    m_SpecialRegContext = m_SavedSpecialRegContext;
}

ULONG
Ia64MachineInfo::ExecutingMachine(void)
{
    if (IsIA32InstructionSet())
    {
        return IMAGE_FILE_MACHINE_I386;
    }

    return IMAGE_FILE_MACHINE_IA64;
}

HRESULT
Ia64MachineInfo::SetPageDirectory(ULONG Idx, ULONG64 PageDir,
                                  PULONG NextIdx)
{
    HRESULT Status;

    switch(Idx)
    {
    case PAGE_DIR_USER:
        if (PageDir == 0)
        {
            if ((Status = g_Target->ReadImplicitProcessInfoPointer
                 (m_OffsetEprocessDirectoryTableBase, &PageDir)) != S_OK)
            {
                return Status;
            }
        }
        *NextIdx = PAGE_DIR_SESSION;
        break;

    case PAGE_DIR_SESSION:
        if (PageDir == 0)
        {
            if ((Status = g_Target->
                 ReadImplicitProcessInfoPointer
                 (g_Machine->m_OffsetEprocessDirectoryTableBase +
                  5 * sizeof(ULONG64), &PageDir)) != S_OK)
            {
                return Status;
            }
        }
        *NextIdx = PAGE_DIR_KERNEL;
        break;

    case PAGE_DIR_KERNEL:
        if (PageDir == 0)
        {
            PageDir = m_KernPageDir;
            if (PageDir == 0)
            {
                ErrOut("Invalid IA64 kernel page directory base 0x%I64x\n",
                       PageDir);
                return E_FAIL;
            }
        }
        *NextIdx = PAGE_DIR_COUNT;
        break;

    case 4:
        // There's a directly mapped physical section for
        // most of region 4 so allow the default to be
        // set for this directory index.
        if (PageDir != 0)
        {
            return E_INVALIDARG;
        }
        *NextIdx = 5;
        break;
        
    default:
        return E_INVALIDARG;
    }

    // Sanitize the value.
    m_PageDirectories[Idx] =
        ((PageDir & IA64_VALID_PFN_MASK) >> IA64_VALID_PFN_SHIFT) <<
        IA64_PAGE_SHIFT;
    return S_OK;
}

#define IA64_PAGE_FILE_INDEX(Entry) \
    (((ULONG)(Entry) >> 28) & MAX_PAGING_FILE_MASK)
#define IA64_PAGE_FILE_OFFSET(Entry) \
    (((Entry) >> 32) << IA64_PAGE_SHIFT)

HRESULT
Ia64MachineInfo::GetVirtualTranslationPhysicalOffsets(ULONG64 Virt,
                                                      PULONG64 Offsets,
                                                      ULONG OffsetsSize,
                                                      PULONG Levels,
                                                      PULONG PfIndex,
                                                      PULONG64 LastVal)
{
    HRESULT Status;

    *Levels = 0;
    
    if (m_Translating)
    {
        return E_UNEXPECTED;
    }
    m_Translating = TRUE;
    
    ULONG Vrn = (ULONG)((Virt & IA64_REGION_MASK) >> IA64_REGION_SHIFT);
    
    //
    // Reset the page directory in case it was 0
    //
    if (m_PageDirectories[Vrn] == 0)
    {
        if ((Status = SetDefaultPageDirectories(1 << Vrn)) != S_OK)
        {
            m_Translating = FALSE;
            return Status;
        }
    }

    KdOut("Ia64VtoP: Virt %s, pagedir %d:%s\n",
          FormatAddr64(Virt), Vrn, FormatAddr64(m_PageDirectories[Vrn]));
    
    (*Levels)++;
    if (Offsets != NULL && OffsetsSize > 0)
    {
        *Offsets++ = m_PageDirectories[Vrn];
        OffsetsSize--;
    }
        
    //
    // Certain ranges of the system are mapped directly.
    //

    if ((Virt >= IA64_PHYSICAL1_START) && (Virt <= IA64_PHYSICAL1_END))
    {
        *LastVal = Virt - IA64_PHYSICAL1_START;

        KdOut("Ia64VtoP: Direct phys 1 %s\n", FormatAddr64(*LastVal));

        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = *LastVal;
            OffsetsSize--;
        }
        
        m_Translating = FALSE;
        return S_OK;
    }
    if ((Virt >= IA64_PHYSICAL2_START) && (Virt <= IA64_PHYSICAL2_END))
    {
        *LastVal = Virt - IA64_PHYSICAL2_START;

        KdOut("Ia64VtoP: Direct phys 2 %s\n", FormatAddr64(*LastVal));

        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = *LastVal;
            OffsetsSize--;
        }
        
        m_Translating = FALSE;
        return S_OK;
    }

    // If we're still translating and there's no page
    // directory we have a garbage address.
    if (m_PageDirectories[Vrn] == 0)
    {
        m_Translating = FALSE;
        return HR_PAGE_NOT_AVAILABLE;
    }
        
    ULONG64 Addr;
    ULONG64 Entry;
    
    Addr = (((Virt >> IA64_PDE1_SHIFT) & IA64_PDE_MASK) * sizeof(Entry)) +
        m_PageDirectories[Vrn];

    Status = g_Target->ReadAllPhysical(Addr, &Entry, sizeof(Entry));
    
    KdOut("Ia64VtoP: PDE1 %s - %016I64x, 0x%X\n",
          FormatAddr64(Addr), Entry, Status);
    
    (*Levels)++;
    if (Offsets != NULL && OffsetsSize > 0)
    {
        *Offsets++ = Addr;
        OffsetsSize--;
    }
        
    if (Status != S_OK)
    {
        KdOut("Ia64VtoP: PDE1 read error 0x%X\n", Status);
        m_Translating = FALSE;
        return Status;
    }

    if (Entry == 0)
    {
        KdOut("Ia64VtoP: zero PDE1\n");
        m_Translating = FALSE;
        return HR_PAGE_NOT_AVAILABLE;
    }
    else if (!(Entry & 1))
    {
        Addr = (((Virt >> IA64_PDE2_SHIFT) & IA64_PDE_MASK) *
                sizeof(Entry)) + IA64_PAGE_FILE_OFFSET(Entry);

        KdOut("Ia64VtoP: pagefile PDE2 %d:%s\n",
              IA64_PAGE_FILE_INDEX(Entry), FormatAddr64(Addr));
        
        if ((Status = g_Target->
             ReadPageFile(IA64_PAGE_FILE_INDEX(Entry), Addr,
                          &Entry, sizeof(Entry))) != S_OK)
        {
            KdOut("Ia64VtoP: PDE1 not present, 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }
    }
    else
    {
        Addr = (((Virt >> IA64_PDE2_SHIFT) & IA64_PDE_MASK) * sizeof(Entry)) +
            (((Entry & IA64_VALID_PFN_MASK) >> IA64_VALID_PFN_SHIFT) <<
             IA64_PAGE_SHIFT);

        Status = g_Target->ReadAllPhysical(Addr, &Entry, sizeof(Entry));
    
        KdOut("Ia64VtoP: PDE2 %s - %016I64x, 0x%X\n",
              FormatAddr64(Addr), Entry, Status);
    
        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = Addr;
            OffsetsSize--;
        }
        
        if (Status != S_OK)
        {
            KdOut("Ia64VtoP: PDE2 read error 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }
    }
    
    if (Entry == 0)
    {
        KdOut("Ia64VtoP: zero PDE2\n");
        m_Translating = FALSE;
        return HR_PAGE_NOT_AVAILABLE;
    }
    else if (!(Entry & 1))
    {
        Addr = (((Virt >> IA64_PTE_SHIFT) & IA64_PTE_MASK) *
                sizeof(Entry)) + IA64_PAGE_FILE_OFFSET(Entry);

        KdOut("Ia64VtoP: pagefile PTE %d:%s\n",
              IA64_PAGE_FILE_INDEX(Entry), FormatAddr64(Addr));
        
        if ((Status = g_Target->
             ReadPageFile(IA64_PAGE_FILE_INDEX(Entry), Addr,
                          &Entry, sizeof(Entry))) != S_OK)
        {
            KdOut("Ia64VtoP: PDE2 not present, 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }
    }
    else
    {
        Addr = (((Virt >> IA64_PTE_SHIFT) & IA64_PTE_MASK) * sizeof(Entry)) +
            (((Entry & IA64_VALID_PFN_MASK) >> IA64_VALID_PFN_SHIFT) <<
             IA64_PAGE_SHIFT);

        Status = g_Target->ReadAllPhysical(Addr, &Entry, sizeof(Entry));
    
        KdOut("Ia64VtoP: PTE %s - %016I64x, 0x%X\n",
              FormatAddr64(Addr), Entry, Status);
    
        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = Addr;
            OffsetsSize--;
        }
        
        if (Status != S_OK)
        {
            KdOut("Ia64VtoP: PTE read error 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }
    }
    
    if (!(Entry & 0x1) &&
        ((Entry & IA64_MM_PTE_PROTOTYPE_MASK) ||
         !(Entry & IA64_MM_PTE_TRANSITION_MASK)))
    {
        if (Entry == 0)
        {
            KdOut("Ia64VtoP: zero PTE\n");
            Status = HR_PAGE_NOT_AVAILABLE;
        }
        else if (Entry & IA64_MM_PTE_PROTOTYPE_MASK)
        {
            KdOut("Ia64VtoP: prototype PTE\n");
            Status = HR_PAGE_NOT_AVAILABLE;
        }
        else
        {
            *PfIndex = IA64_PAGE_FILE_INDEX(Entry);
            *LastVal = (Virt & (IA64_PAGE_SIZE - 1)) +
                IA64_PAGE_FILE_OFFSET(Entry);
            KdOut("Ia64VtoP: PTE not present, pagefile %d:%s\n",
                  *PfIndex, FormatAddr64(*LastVal));
            Status = HR_PAGE_IN_PAGE_FILE;
        }
        m_Translating = FALSE;
        return Status;
    }

    //
    // This is a page which is either present or in transition.
    // Return the physical address for the request virtual address.
    //
    
    *LastVal = (((Entry & IA64_VALID_PFN_MASK) >> IA64_VALID_PFN_SHIFT) <<
                 IA64_PAGE_SHIFT) | (Virt & (IA64_PAGE_SIZE - 1));
    
    KdOut("Ia64VtoP: Mapped phys %s\n", FormatAddr64(*LastVal));

    (*Levels)++;
    if (Offsets != NULL && OffsetsSize > 0)
    {
        *Offsets++ = *LastVal;
        OffsetsSize--;
    }
        
    m_Translating = FALSE;
    return S_OK;
}

HRESULT
Ia64MachineInfo::GetBaseTranslationVirtualOffset(PULONG64 Offset)
{
    if (IS_LOCAL_KERNEL_TARGET())
    {
        CROSS_PLATFORM_KSPECIAL_REGISTERS Special;
        HRESULT Status;
        
        // We can't actually load a context when
        // local kernel debugging but we can
        // read the special registers and get
        // the PTA value from there.
        if ((Status = g_Target->GetTargetSpecialRegisters
             (VIRTUAL_THREAD_HANDLE(0), &Special)) != S_OK)
        {
            return Status;
        }

        *Offset = Special.IA64Special.ApPTA;
    }
    else
    {
        *Offset = GetReg64(APPTA);
        if (*Offset == 0)
        {
            return E_FAIL;
        }
    }
    return S_OK;
}

#define HIGH128(x) (((FLOAT128 *)(&x))->HighPart)
#define LOW128(x) (((FLOAT128 *)(&x))->LowPart)

#define HIGHANDLOW128(x) HIGH128(x), LOW128(x)

BOOL 
Ia64MachineInfo::DisplayTrapFrame(ULONG64 FrameAddress,
                                  OUT PCROSS_PLATFORM_CONTEXT Context)
{
    IA64_KTRAP_FRAME TrapContents;

    ULONG64 Address=FrameAddress, IntSp;
    ULONG result;
    DWORD64 DisasmAddr;
    DWORD64 Displacement;
    DWORD64 Bsp, RealBsp;
    DWORD SizeOfFrame;
    DWORD i;
    SHORT temp, j;
    CHAR Buffer[80];
    ULONG64 StIIP, StISR;

    if ( g_Target->ReadVirtual(Address, &TrapContents, sizeof(IA64_KTRAP_FRAME), &result) != S_OK)
    {
        dprintf("unable to get trap frame contents\n");
        return FALSE;
    }

    dprintf("f6 (ft0) =\t %016I64x %016I64x\n" , HIGHANDLOW128(TrapContents.FltT0) );
    dprintf("f7 (ft1) =\t %016I64x %016I64x\n" , HIGHANDLOW128(TrapContents.FltT1));
    dprintf("f8 (ft2) =\t %016I64x %016I64x\n" , HIGHANDLOW128(TrapContents.FltT2));
    dprintf("f9 (ft3) =\t %016I64x %016I64x\n" , HIGHANDLOW128(TrapContents.FltT3));
    dprintf("f10 (ft3) =\t %016I64x %016I64x\n" , HIGHANDLOW128(TrapContents.FltT4));
    dprintf("f11 (ft4) =\t %016I64x %016I64x\n" , HIGHANDLOW128(TrapContents.FltT5));
    dprintf("f12 (ft5) =\t %016I64x %016I64x\n" , HIGHANDLOW128(TrapContents.FltT6));
    dprintf("f13 (ft6) =\t %016I64x %016I64x\n" , HIGHANDLOW128(TrapContents.FltT7));
    dprintf("f14 (ft7) =\t %016I64x %016I64x\n" , HIGHANDLOW128(TrapContents.FltT8));
    dprintf("f15 (ft8) =\t %016I64x %016I64x\n" , HIGHANDLOW128(TrapContents.FltT9));

    dprintf("unat =\t %016I64lx\t", TrapContents.ApUNAT);
    dprintf("ccv =\t %016I64lx\n" , TrapContents.ApCCV);
    dprintf("dcr =\t %016I64lx\t" , TrapContents.ApDCR);
    dprintf("preds =\t %016I64lx\n",TrapContents.Preds);

    dprintf("rsc =\t %016I64lx\t",  TrapContents.RsRSC);

    SizeOfFrame = (ULONG)(TrapContents.StIFS & (IA64_PFS_SIZE_MASK));

    if (TrapContents.PreviousMode == 1 /*UserMode*/)
    {
        ULONG64 RsBSPSTORE=TrapContents.RsBSPSTORE;
        dprintf("rnat =\t %016I64lx\n", TrapContents.RsRNAT);
        dprintf("bspstore=%016I64lx\n", RsBSPSTORE);

        //
        // Calculate where the stacked registers are for the function which trapped.  
        // The regisisters are stored in the kernel backing store notCalculated the users.  
        // First calculate the start of the kernel store based on trap address, since 
        // this is a user mode trap we should start at the begining of the kernel stack
        // so just round up the trap address to a page size.  Next calculate the actual 
        // BSP for the function.  This depends on the  BSP and BSPstore at the time of
        // the trap.  Note that the trap handle start the kernel backing store on the 
        // same alignment as the user's BSPstore.  
        // 

        //Calculated
        // Round trap address to a page boundary. The should be the Initial kernel BSP.
        //

        Bsp = (Address + IA64_PAGE_SIZE - 1) & ~(DWORD64)(IA64_PAGE_SIZE - 1);

        //
        // Start the actual stack on the same bountry as the users.
        //

        Bsp += RsBSPSTORE & IA64_RNAT_ALIGNMENT;

        //
        // The BSP of the trap handler is right after all the user values have been
        // saved.  The unsaved user values is the differenc of BSP and BSPStore.
        //

        Bsp += TrapContents.RsBSP - RsBSPSTORE;

    }
    else
    {
        dprintf("rnat =\t ???????? ????????\n", TrapContents.RsRNAT);
        dprintf("bspstore=???????? ????????\n", TrapContents.RsBSPSTORE);

        //
        // For kernel mode the actual BSP is saved.
        //

        Bsp = TrapContents.RsBSP;
    }

    //
    //  Now backup by the size of the faulting functions frame.
    //

    Bsp -= (SizeOfFrame * sizeof(ULONGLONG));

    //
    // Adjust for saved RNATs
    //

    temp = (SHORT)(Bsp >> 3) & IA64_NAT_BITS_PER_RNAT_REG;
    temp += (SHORT)SizeOfFrame - IA64_NAT_BITS_PER_RNAT_REG;
    while (temp >= 0)
    {
        Bsp -= sizeof(ULONGLONG);
        temp -= IA64_NAT_BITS_PER_RNAT_REG;
    }

    dprintf("bsp =\t %016I64lx\t",  TrapContents.RsBSP);
    dprintf("Real bsp = %016I64lx\n",  RealBsp = Bsp);


    dprintf("r1 (gp) =\t %016I64lx\t" ,  TrapContents.IntGp);
    dprintf("r2 (t0) =\t %016I64lx\n" ,  TrapContents.IntT0);
    dprintf("r3 (t1) =\t %016I64lx\t" ,  TrapContents.IntT1);
    dprintf("r8 (v0) =\t %016I64lx\n" ,  TrapContents.IntV0);
    dprintf("r9 (t2) =\t %016I64lx\t" ,  TrapContents.IntT2);
    dprintf("r10 (t3) =\t %016I64lx\n" ,  TrapContents.IntT3);
    dprintf("r11 (t4) =\t %016I64lx\t" ,  TrapContents.IntT4);
    dprintf("r12 (sp) =\t %016I64lx\n" ,  IntSp = TrapContents.IntSp);
    dprintf("r13 (teb) =\t %016I64lx\t" , TrapContents.IntTeb);
    dprintf("r14 (t5) =\t %016I64lx\n" ,  TrapContents.IntT5);
    dprintf("r15 (t6) =\t %016I64lx\t" ,  TrapContents.IntT6);
    dprintf("r16 (t7) =\t %016I64lx\n" ,  TrapContents.IntT7);
    dprintf("r17 (t8) =\t %016I64lx\t" ,  TrapContents.IntT8);
    dprintf("r18 (t9) =\t %016I64lx\n" ,  TrapContents.IntT9);
    dprintf("r19 (t10) =\t %016I64lx\t" , TrapContents.IntT10);
    dprintf("r20 (t11) =\t %016I64lx\n" , TrapContents.IntT11);
    dprintf("r21 (t12) =\t %016I64lx\t" , TrapContents.IntT12);
    dprintf("r22 (t13) =\t %016I64lx\n" , TrapContents.IntT13);
    dprintf("r23 (t14) =\t %016I64lx\t" , TrapContents.IntT14);
    dprintf("r24 (t15) =\t %016I64lx\n" , TrapContents.IntT15);
    dprintf("r25 (t16) =\t %016I64lx\t" , TrapContents.IntT16);
    dprintf("r26 (t17) =\t %016I64lx\n" , TrapContents.IntT17);
    dprintf("r27 (t18) =\t %016I64lx\t" , TrapContents.IntT18);
    dprintf("r28 (t19) =\t %016I64lx\n" , TrapContents.IntT19);
    dprintf("r29 (t20) =\t %016I64lx\t" , TrapContents.IntT20);
    dprintf("r30 (t21) =\t %016I64lx\n" , TrapContents.IntT21);
    dprintf("r31 (t22) =\t %016I64lx\n" , TrapContents.IntT22);

    //
    // Print out the stack registers.
    //

    for ( i = 0; i < SizeOfFrame; Bsp += sizeof(ULONGLONG))
    {
        ULONGLONG reg;

        //
        // Skip the NAT values.
        //

        if ((Bsp & IA64_RNAT_ALIGNMENT) == IA64_RNAT_ALIGNMENT)
        {
            continue;
        }

        if ( g_Target->ReadVirtual( Bsp, &reg, sizeof(ULONGLONG), &result) )
        {
            dprintf("Cannot read backing register store at %16I64x\n", Bsp);
        }

        dprintf("r%d =\t\t %016I64lx", (i + 32), reg);

        if ((i % 2) == 1)
        {
            dprintf("\n");
        }
        else
        {
            dprintf("\t");
        }

        i++;
    }

    dprintf("\n");


    dprintf("b0 (brrp) =\t %016I64lx\n", TrapContents.BrRp);
    dprintf("b6 (brt0) =\t %016I64lx\n", TrapContents.BrT0);
    dprintf("b7 (brt1) =\t %016I64lx\n", TrapContents.BrT1);


    dprintf("nats =\t %016I64lx\n", TrapContents.IntNats);
    dprintf("pfs =\t %016I64lx\n",  TrapContents.RsPFS);

    dprintf("ipsr =\t %016I64lx\n", TrapContents.StIPSR);
    dprintf("isr =\t %016I64lx\n" , (StISR = TrapContents.StISR));
    dprintf("ifa =\t %016I64lx\n" , TrapContents.StIFA);
    dprintf("iip =\t %016I64lx\n" , StIIP = TrapContents.StIIP);
    dprintf("iipa =\t %016I64lx\n", TrapContents.StIIPA);
    dprintf("ifs =\t %016I64lx\n" , TrapContents.StIFS);
    dprintf("iim =\t %016I64lx\n" , TrapContents.StIIM);
    dprintf("iha =\t %016I64lx\n" , TrapContents.StIHA);

    dprintf("fpsr =\t\t  %08lx\n" , TrapContents.StFPSR);


    //  iA32 status info ???

    dprintf("oldirql =\t  %08lx\n" , TrapContents.OldIrql);
    dprintf("previousmode =\t  %08lx\n" , TrapContents.PreviousMode);
    dprintf("trapframe =\t  %08lx\n" , TrapContents.TrapFrame);

    ULONG TrapFrameType = (ULONG)(TrapContents.EOFMarker) & 0xf;

    switch (TrapFrameType)
    {
    case IA64_SYSCALL_FRAME:
        dprintf("Trap Type: syscall\n");
        break;
    case IA64_INTERRUPT_FRAME:
        dprintf("Trap Type: interrupt\n");
        break;
    case IA64_EXCEPTION_FRAME:
        dprintf("Trap Type: exception\n");
        break;
    case IA64_CONTEXT_FRAME:
        dprintf("Trap Type: context\n");
        break;
    default:
        dprintf("Trap Type: unknown\n");
        break;
    }

    DisasmAddr = StIIP;

    //
    // Adjust for the bundle. 
    //

    DisasmAddr += ((StISR >> 41) & 3) * 4;

    GetSymbolStdCall(DisasmAddr, Buffer, sizeof(Buffer), &Displacement, NULL);
    dprintf("\n%s+0x%I64x\n", Buffer, Displacement);
    
    ADDR    tempAddr;
    BOOL    ret;

    Type(tempAddr) = ADDR_FLAT | FLAT_COMPUTED;
    Off(tempAddr) = Flat(tempAddr) = DisasmAddr;
    if (g_Machine->Disassemble(&tempAddr, Buffer, FALSE))
    {

        dprintf(Buffer);

    }
    else
    {

        dprintf("???????????????\n", DisasmAddr);
    }
    
    g_LastRegFrame.InstructionOffset  = StIIP;
    g_LastRegFrame.StackOffset        = IntSp;
    g_LastRegFrame.FrameOffset        = RealBsp;

    if (Context) 
    {
        // Fill up the context struct
#define CPCXT(Fld) Context->IA64Context.Fld = TrapContents.Fld

        CPCXT(BrRp); CPCXT(BrT0); CPCXT(BrT1);

        CPCXT(FltT0); CPCXT(FltT1); CPCXT(FltT2); CPCXT(FltT3); CPCXT(FltT4);
        CPCXT(FltT5); CPCXT(FltT6); CPCXT(FltT7); CPCXT(FltT8); CPCXT(FltT9);

        CPCXT(ApUNAT); CPCXT(ApCCV); CPCXT(ApDCR); CPCXT(Preds); 

        CPCXT(RsRSC); CPCXT(RsRNAT); CPCXT(RsBSPSTORE); CPCXT(RsBSP); CPCXT(RsPFS);

        CPCXT(StIPSR); CPCXT(StIIP); CPCXT(StIFS); CPCXT(StFPSR);
        CPCXT(IntSp);  CPCXT(IntGp); CPCXT(IntV0); CPCXT(IntTeb); CPCXT(IntNats);

        CPCXT(IntT0);  CPCXT(IntT1);  CPCXT(IntT2);  CPCXT(IntT3);  CPCXT(IntT4);  
        CPCXT(IntT5);  CPCXT(IntT6);  CPCXT(IntT7);  CPCXT(IntT8);  CPCXT(IntT9);  
        CPCXT(IntT10); CPCXT(IntT11); CPCXT(IntT12); CPCXT(IntT13); CPCXT(IntT14);  
        CPCXT(IntT15); CPCXT(IntT16); CPCXT(IntT17); CPCXT(IntT18); CPCXT(IntT19);  
        CPCXT(IntT20); CPCXT(IntT21); CPCXT(IntT22); 

        Context->IA64Context.RsBSP = RealBsp; // Store the real Bsp
#undef CPCXT
    }
    return TRUE;
}

void
Ia64MachineInfo::ValidateCxr(PCROSS_PLATFORM_CONTEXT Context)
{
    // XXX drewb - Why doesn't this do anything?
}

void
Ia64MachineInfo::OutputFunctionEntry(PVOID RawEntry)
{
    PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY Entry =
        (PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY)RawEntry;
    
    dprintf("BeginAddress      = %s\n",
            FormatAddr64(Entry->BeginAddress));
    dprintf("EndAddress        = %s\n",
            FormatAddr64(Entry->EndAddress));
    dprintf("UnwindInfoAddress = %s\n",
            FormatAddr64(Entry->UnwindInfoAddress));
}

HRESULT
Ia64MachineInfo::ReadDynamicFunctionTable(ULONG64 Table,
                                          PULONG64 NextTable,
                                          PULONG64 MinAddress,
                                          PULONG64 MaxAddress,
                                          PULONG64 BaseAddress,
                                          PULONG64 TableData,
                                          PULONG TableSize,
                                          PWSTR OutOfProcessDll,
                                          PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE RawTable)
{
    HRESULT Status;

    if ((Status = g_Target->
         ReadAllVirtual(Table, &RawTable->IA64Table,
                        sizeof(RawTable->IA64Table))) != S_OK)
    {
        return Status;
    }

    *NextTable = RawTable->IA64Table.Links.Flink;
    *MinAddress = RawTable->IA64Table.MinimumAddress;
    *MaxAddress = RawTable->IA64Table.MaximumAddress;
    *BaseAddress = RawTable->IA64Table.BaseAddress;
    if (RawTable->IA64Table.Type == IA64_RF_CALLBACK)
    {
        ULONG Done;
        
        *TableData = 0;
        *TableSize = 0;
        if ((Status = g_Target->
             ReadVirtual(RawTable->IA64Table.OutOfProcessCallbackDll,
                         OutOfProcessDll, (MAX_PATH - 1) * sizeof(WCHAR),
                         &Done)) != S_OK)
        {
            return Status;
        }

        OutOfProcessDll[Done / sizeof(WCHAR)] = 0;
    }
    else
    {
        *TableData = RawTable->IA64Table.FunctionTable;
        *TableSize = RawTable->IA64Table.EntryCount *
            sizeof(IMAGE_IA64_RUNTIME_FUNCTION_ENTRY);
        OutOfProcessDll[0] = 0;
    }
    return S_OK;
}

PVOID
Ia64MachineInfo::FindDynamicFunctionEntry(PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE Table,
                                          ULONG64 Address,
                                          PVOID TableData,
                                          ULONG TableSize)
{
    ULONG i;
    PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY Func;
    static IMAGE_IA64_RUNTIME_FUNCTION_ENTRY s_RetFunc;

    Func = (PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY)TableData;
    for (i = 0; i < TableSize / sizeof(IMAGE_IA64_RUNTIME_FUNCTION_ENTRY); i++)
    {
        if (Address >= IA64_RF_BEGIN_ADDRESS(Table->IA64Table.BaseAddress, Func) &&
            Address < IA64_RF_END_ADDRESS(Table->IA64Table.BaseAddress, Func))
        {
            // The table data is temporary so copy the data into
            // a static buffer for longer-term storage.
            s_RetFunc.BeginAddress = Func->BeginAddress;
            s_RetFunc.EndAddress = Func->EndAddress;
            s_RetFunc.UnwindInfoAddress = Func->UnwindInfoAddress;
            return (PVOID)&s_RetFunc;
        }

        Func++;
    }

    return NULL;
}

HRESULT
Ia64MachineInfo::ReadKernelProcessorId
    (ULONG Processor, PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id)
{
    HRESULT Status;
    ULONG64 Prcb, PrcbMember;
    ULONG Data[4];

    if ((Status = g_Target->
         GetProcessorSystemDataOffset(Processor, DEBUG_DATA_KPRCB_OFFSET,
                                      &Prcb)) != S_OK)
    {
        return Status;
    }

    PrcbMember = Prcb + FIELD_OFFSET(IA64_PARTIAL_KPRCB, ProcessorModel);

    if ((Status = g_Target->
         ReadAllVirtual(PrcbMember, Data, sizeof(Data))) != S_OK)
    {
        return Status;
    }

    Id->Ia64.Model = Data[0];
    Id->Ia64.Revision = Data[1];
    Id->Ia64.Family = Data[2];
    Id->Ia64.ArchRev = Data[3];
    
    PrcbMember = Prcb + FIELD_OFFSET(IA64_PARTIAL_KPRCB,
                                     ProcessorVendorString);

    if ((Status = g_Target->
         ReadAllVirtual(PrcbMember, Id->Ia64.VendorString,
                        sizeof(Id->Ia64.VendorString))) != S_OK)
    {
        return Status;
    }

    return S_OK;
}

BOOL
Ia64MachineInfo::IsIA32InstructionSet(VOID)
{
    return ((GetReg64(STIPSR) & (1I64 << PSR_IS)) ? TRUE : FALSE);
}

void
Ia64MachineInfo::KdGetSpecialRegistersFromContext(void)
{
    DBG_ASSERT(m_ContextState >= MCTX_FULL);

    memcpy(&m_SpecialRegContext.KernelDbI0, &m_Context.IA64Context.DbI0,
           IA64_DB_COUNT * sizeof(ULONG64));
}

void
Ia64MachineInfo::KdSetSpecialRegistersInContext(void)
{
    DBG_ASSERT(m_ContextState >= MCTX_FULL);

    memcpy(&m_Context.IA64Context.DbI0, &m_SpecialRegContext.KernelDbI0,
           IA64_DB_COUNT * sizeof(ULONG64));
}

BOOL
Ia64MachineInfo::GetStackedRegVal(
    IN ULONG64 RsBSP, 
    IN USHORT FrameSize, 
    IN ULONG64 RsRNAT, 
    IN ULONG regnum, 
    OUT REGVAL *val
    )
{
    SHORT index;
    SHORT temp;
    ULONG result;
    ULONG64 TargetAddress;
    ULONG64 TargetNatAddress;

    index = (SHORT)(RsBSP >> 3) & NAT_BITS_PER_RNAT_REG;
    temp = index + (SHORT)FrameSize - NAT_BITS_PER_RNAT_REG;
    while (temp >= 0) {
        FrameSize++;
        temp -= NAT_BITS_PER_RNAT_REG;
    }

    TargetAddress = RsBSP;
    while (regnum > 0) {
        regnum -= 1;
        TargetAddress += 8;
        if ((TargetAddress & 0x1F8) == 0x1F8) {
            TargetAddress += 8;
        }
    }


    if (g_Target->ReadVirtual(TargetAddress, (PUCHAR)&val->i64, 8,
                              &result) != S_OK ||
        (result < 8))
    {
        ErrOut("unable to read memory location %I64x\n", TargetAddress);
        return FALSE;
    }

    index = (SHORT)((TargetAddress - (TargetAddress & ~(0x1F8i64))) >> 3);
    TargetNatAddress = TargetAddress | 0x1F8;
    if (TargetNatAddress <= (RsBSP + (FrameSize * sizeof(ULONG64)))) {

        //
        // update backing store
        //

        if (g_Target->ReadVirtual(TargetNatAddress, (PUCHAR)&RsRNAT, 8,
                                  &result) != S_OK || (result < 8))
        {
            ErrOut("unable to read memory location %I64x\n", TargetNatAddress);
            return FALSE;
        }

    }

    val->Nat = (UCHAR)(RsRNAT >> index) & 0x1;
    return TRUE;
}

BOOL
Ia64MachineInfo::SetStackedRegVal(
    IN ULONG64 RsBSP, 
    IN USHORT FrameSize, 
    IN ULONG64 *RsRNAT, 
    IN ULONG regnum, 
    IN REGVAL *val
    )
{
    SHORT index;
    SHORT temp;
    ULONG result;
    ULONG64 Mask;
    ULONG64 LocalRnat;
    ULONG64 TargetAddress;
    ULONG64 TargetNatAddress;

    index = (SHORT)(RsBSP >> 3) & NAT_BITS_PER_RNAT_REG;
    temp = index + (SHORT)FrameSize - NAT_BITS_PER_RNAT_REG;
    while (temp >= 0) {
        FrameSize++;
        temp -= NAT_BITS_PER_RNAT_REG;
    }

    TargetAddress = RsBSP;
    while (regnum > 0) {
        regnum -= 1;
        TargetAddress += 8;
        if ((TargetAddress & 0x1F8) == 0x1F8) {
            TargetAddress += 8;
        }
    }

    if (g_Target->WriteVirtual(TargetAddress, &val->i64, 8, &result) != S_OK ||
        (result < 8))
    {
        ErrOut("unable to write memory location %I64x\n", TargetAddress);
        return FALSE;
    }

    index = (SHORT)((TargetAddress - (TargetAddress & ~(0x1F8i64))) >> 3);
    TargetNatAddress = TargetAddress | 0x1F8;
    Mask = 0x1i64 << index;

    if (TargetNatAddress <= (RsBSP + (FrameSize * sizeof(ULONG64)))) {

        if (g_Target->ReadVirtual(TargetNatAddress, (PUCHAR)&LocalRnat, 8,
                                  &result) != S_OK || (result < 8))
        {
            ErrOut("unable to read memory location %I64x\n", TargetNatAddress);
            return FALSE;
        }

        if (val->Nat) {
            LocalRnat |= Mask;
        } else  {
            LocalRnat &= ~Mask;
        }
        if (g_Target->WriteVirtual(TargetNatAddress, &LocalRnat, 8,
                                   &result) != S_OK ||
            (result < 8))
        {
            ErrOut("unable to write memory location %I64x\n",TargetNatAddress);
            return FALSE;
        }

    } else {

        if (val->Nat) {
            *RsRNAT |= Mask;
        } else  {
            *RsRNAT &= ~Mask;
        }

    }

    return TRUE;
}
    
//----------------------------------------------------------------------------
//
// X86OnIa64MachineInfo.
//
//----------------------------------------------------------------------------

X86OnIa64MachineInfo g_X86OnIa64Machine;

HRESULT
X86OnIa64MachineInfo::InitializeForProcessor(void)
{
    HRESULT Status = X86MachineInfo::InitializeForProcessor();
    m_MaxDataBreakpoints = min(m_MaxDataBreakpoints, 
                               IA64_REG_MAX_DATA_BREAKPOINTS);
    return Status;
}

HRESULT
X86OnIa64MachineInfo::UdGetContextState(ULONG State)
{
    HRESULT Status;
    
    if ((Status = g_Ia64Machine.UdGetContextState(MCTX_FULL)) != S_OK)
    {
        return Status;
    }

    Ia64ContextToX86(&g_Ia64Machine.m_Context.IA64Context,
                     &m_Context.X86Nt5Context);
    m_ContextState = MCTX_FULL;

    return S_OK;
}

HRESULT
X86OnIa64MachineInfo::UdSetContext(void)
{
    g_Ia64Machine.InitializeContextFlags(&g_Ia64Machine.m_Context,
                                         g_SystemVersion);
    X86ContextToIa64(&m_Context.X86Nt5Context,
                     &g_Ia64Machine.m_Context.IA64Context);
    return g_Ia64Machine.UdSetContext();
}


HRESULT
X86OnIa64MachineInfo::KdGetContextState(ULONG State)
{
    HRESULT Status;
    
    dprintf("The context is partially valid. Only x86 user-mode context is available!\n");
    if ((Status = g_Ia64Machine.KdGetContextState(MCTX_FULL)) != S_OK)
    {
        return Status;
    }

    Ia64ContextToX86(&g_Ia64Machine.m_Context.IA64Context,
                     &m_Context.X86Nt5Context);
    m_ContextState = MCTX_FULL;

    return S_OK;
}

HRESULT
X86OnIa64MachineInfo::KdSetContext(void)
{
    dprintf("The context is partially valid. Only x86 user-mode context is available!\n");
    g_Ia64Machine.InitializeContextFlags(&g_Ia64Machine.m_Context,
                                         g_SystemVersion);
    X86ContextToIa64(&m_Context.X86Nt5Context,
                     &g_Ia64Machine.m_Context.IA64Context);
    return g_Ia64Machine.KdSetContext();
}

HRESULT
X86OnIa64MachineInfo::GetSegRegDescriptor(ULONG SegReg, PDESCRIPTOR64 Desc)
{
    // XXX drewb - This should probably use the
    // descriptor information embedded in the IA64 context.
    
    ULONG RegNum = GetSegRegNum(SegReg);
    if (RegNum == 0)
    {
        return E_INVALIDARG;
    }

    return EmulateNtSelDescriptor(this, GetIntReg(RegNum), Desc);
}

HRESULT
X86OnIa64MachineInfo::NewBreakpoint(DebugClient* Client, 
                                    ULONG Type,
                                    ULONG Id,
                                    Breakpoint** RetBp)
{
    HRESULT Status;

    switch(Type & (DEBUG_BREAKPOINT_CODE | DEBUG_BREAKPOINT_DATA))
    {
    case DEBUG_BREAKPOINT_CODE:
        *RetBp = new CodeBreakpoint(Client, Id, IMAGE_FILE_MACHINE_I386);
        Status = (*RetBp) ? S_OK : E_OUTOFMEMORY;

        break;
    case DEBUG_BREAKPOINT_DATA:
        *RetBp = new X86OnIa64DataBreakpoint(Client, Id);
        Status = (*RetBp) ? S_OK : E_OUTOFMEMORY;
        break;
    default:
        // Unknown breakpoint type.
        Status = E_NOINTERFACE;
    }

    return Status;
}

void X86OnIa64MachineInfo::InsertAllDataBreakpoints(void)
{
    DBG_ASSERT(!&X86OnIa64MachineInfo::InsertAllDataBreakpoints);
}

void X86OnIa64MachineInfo::RemoveAllDataBreakpoints(void)
{
    DBG_ASSERT(!&X86OnIa64MachineInfo::RemoveAllDataBreakpoints);
}

ULONG
X86OnIa64MachineInfo::IsBreakpointOrStepException(PEXCEPTION_RECORD64 Record,
                                                  ULONG FirstChance,
                                                  PADDR BpAddr,
                                                  PADDR RelAddr)
{
    //
    // XXX olegk - This is pure hack to eliminate need to map unavalable 
    // in 64-bit context ISR register to DR6.
    // We using the fact that Code Breakpoint is recognized normally and 
    // for Data Breakpoint ISR register is avalable as 5th parameter of 
    // exception record.
    //
    ULONG Exbs = 
        X86MachineInfo::IsBreakpointOrStepException(Record, 
                                                    FirstChance,
                                                    BpAddr, RelAddr);

    if (Exbs == EXBS_BREAKPOINT_CODE) 
    {
        return Exbs;
    }

    if (Record->ExceptionCode == STATUS_WX86_SINGLE_STEP)
    {
        ULONG64 Isr = Record->ExceptionInformation[4]; // Trap code is 2 lower bytes
        ULONG TrapCode = ULONG(Isr & ISR_CODE_MASK);
        ULONG Vector = (ULONG)(Isr >> ISR_IA_VECTOR) & 0xff;

        if (Vector != 1) 
        {
            return EXBS_NONE;
        }

        if (Isr & (1 << ISR_TB_TRAP))
        {
            ADDRFLAT(RelAddr, Record->ExceptionInformation[3]);
            return EXBS_STEP_BRANCH;
        }
        else if (Isr & (1 << ISR_SS_TRAP))
        {
            return EXBS_STEP_INSTRUCTION;
        }
        else {
            if (Isr & ((ULONG64)1 << ISR_X))  // Exec Data Breakpoint
            {
                return EXBS_BREAKPOINT_DATA;
            }
            else // Data Breakpoint
            {
                for (int i = 0; i < 4; ++i)
                {
                    if (TrapCode & (1 << (4 + i))) 
                    {
                        ULONG Addr = GetReg32(X86_DR0 + i);
                        if (Addr) 
                        {
                            ADDRFLAT(BpAddr, Addr);
                            return EXBS_BREAKPOINT_DATA;
                        }
                    }
                }
            }
        }
    }

    return EXBS_NONE;
}

#define NUMBER_OF_387REGS (X86_ST_LAST - X86_ST_FIRST + 1)
#define NUMBER_OF_XMMI_REGS (X86_XMM_LAST - X86_XMM_FIRST + 1)

VOID
Wow64CopyFpFromIa64Byte16(
    IN PVOID Byte16Fp,
    IN OUT PVOID Byte10Fp,
    IN ULONG NumRegs);

VOID
Wow64CopyFpToIa64Byte16(
    IN PVOID Byte10Fp,
    IN OUT PVOID Byte16Fp,
    IN ULONG NumRegs);

VOID
Wow64CopyXMMIToIa64Byte16(
    IN PVOID ByteXMMI,
    IN OUT PVOID Byte16Fp,
    IN ULONG NumRegs);

VOID
Wow64CopyXMMIFromIa64Byte16(
    IN PVOID Byte16Fp,
    IN OUT PVOID ByteXMMI,
    IN ULONG NumRegs);

VOID
Wow64RotateFpTop(
    IN ULONGLONG Ia64_FSR,
    IN OUT FLOAT128 UNALIGNED *ia32FxSave);

VOID
Wow64CopyIa64FromSpill(
    IN PFLOAT128 SpillArea,
    IN OUT FLOAT128 UNALIGNED *ia64Fp,
    IN ULONG NumRegs);

VOID
Wow64CopyIa64ToFill(
    IN FLOAT128 UNALIGNED *ia64Fp,
    IN OUT PFLOAT128 FillArea,
    IN ULONG NumRegs);

BOOL
MapDbgSlotIa64ToX86(
    UINT    Slot,
    ULONG64 Ipsr,
    ULONG64 DbD,
    ULONG64 DbD1,
    ULONG64 DbI,
    ULONG64 DbI1,
    ULONG*  Dr7,
    ULONG*  Dr);

void
MapDbgSlotX86ToIa64(
    UINT     Slot,
    ULONG    Dr7,
    ULONG    Dr,
    ULONG64* Ipsr,
    ULONG64* DbD,
    ULONG64* DbD1,
    ULONG64* DbI,
    ULONG64* DbI1);

void
X86OnIa64MachineInfo::Ia64ContextToX86(
    PIA64_CONTEXT ContextIa64,
    PX86_NT5_CONTEXT ContextX86)
{
    FLOAT128 tmpFloat[NUMBER_OF_387REGS];
    ULONG Ia32ContextFlags = ContextX86->ContextFlags;

    ULONG Tid = GetCurrentThreadId();
    DebugClient* Client;
 
    for (Client = g_Clients; Client != NULL; Client = Client->m_Next)
    {
        if (Client->m_ThreadId == Tid)
        {
            break;
        }
    }

    DBG_ASSERT((Client!=NULL));

    if (!g_Ia64Machine.IsIA32InstructionSet())
    {
        if (g_Wow64exts == NULL)
        {
            dprintf("Need to load wow64exts.dll to retrieve context!\n");
            return;
        }
        (*g_Wow64exts)(WOW64EXTS_GET_CONTEXT, 
                       (ULONG64)Client,
                       (ULONG64)ContextX86,
                       (ULONG64)NULL);
        return;
    }

    if ((Ia32ContextFlags & VDMCONTEXT_CONTROL) == VDMCONTEXT_CONTROL)
    {
        //
        // And the control stuff
        //
        ContextX86->Ebp    = (ULONG)ContextIa64->IntTeb;
        ContextX86->SegCs  = X86_KGDT_R3_CODE|3;
        ContextX86->Eip    = (ULONG)ContextIa64->StIIP;
        ContextX86->SegSs  = X86_KGDT_R3_DATA|3;
        ContextX86->Esp    = (ULONG)ContextIa64->IntSp;
        ContextX86->EFlags = (ULONG)ContextIa64->Eflag;

        //
        // Map single step flag (EFlags.tf = EFlags.tf || PSR.ss)
        //
        if (ContextIa64->StIPSR & (1I64 << PSR_SS))
        {
            ContextX86->EFlags |= X86_BIT_FLAGTF;
        }
    }

    if ((Ia32ContextFlags & VDMCONTEXT_INTEGER)  == VDMCONTEXT_INTEGER)
    {
        //
        // Now for the integer state...
        //
        ContextX86->Edi = (ULONG)ContextIa64->IntT6;
        ContextX86->Esi = (ULONG)ContextIa64->IntT5;
        ContextX86->Ebx = (ULONG)ContextIa64->IntT4;
        ContextX86->Edx = (ULONG)ContextIa64->IntT3;
        ContextX86->Ecx = (ULONG)ContextIa64->IntT2;
        ContextX86->Eax = (ULONG)ContextIa64->IntV0;
    }

    if ((Ia32ContextFlags & VDMCONTEXT_SEGMENTS) == VDMCONTEXT_SEGMENTS)
    {
        //
        // These are constants (and constants are used on ia32->ia64
        // transition, not saved values) so make our life easy...
        //
        ContextX86->SegGs = X86_KGDT_R3_DATA|3;
        ContextX86->SegEs = X86_KGDT_R3_DATA|3;
        ContextX86->SegDs = X86_KGDT_R3_DATA|3;
        ContextX86->SegSs = X86_KGDT_R3_DATA|3;
        ContextX86->SegFs = X86_KGDT_R3_TEB|3;
        ContextX86->SegCs = X86_KGDT_R3_CODE|3;
    }

    if ((Ia32ContextFlags & VDMCONTEXT_EXTENDED_REGISTERS) ==
        VDMCONTEXT_EXTENDED_REGISTERS)
    {
        PX86_FXSAVE_FORMAT xmmi =
            (PX86_FXSAVE_FORMAT) ContextX86->ExtendedRegisters;
        
        xmmi->ControlWord   = (USHORT)(ContextIa64->StFCR & 0xffff);
        xmmi->StatusWord    = (USHORT)(ContextIa64->StFSR & 0xffff);
        xmmi->TagWord       = (USHORT)(ContextIa64->StFSR >> 16) & 0xffff;
        xmmi->ErrorOpcode   = (USHORT)(ContextIa64->StFIR >> 48);
        xmmi->ErrorOffset   = (ULONG) (ContextIa64->StFIR & 0xffffffff);
        xmmi->ErrorSelector = (ULONG) (ContextIa64->StFIR >> 32);
        xmmi->DataOffset    = (ULONG) (ContextIa64->StFDR & 0xffffffff);
        xmmi->DataSelector  = (ULONG) (ContextIa64->StFDR >> 32);
        xmmi->MXCsr         = (ULONG) (ContextIa64->StFCR >> 32) & 0xffff;

        //
        // Copy over the FP registers.  Even though this is the new
        // FXSAVE format with 16-bytes for each register, need to
        // convert from spill/fill format to 80-bit double extended format
        //
        Wow64CopyIa64FromSpill((PFLOAT128) &(ContextIa64->FltT2),
                               (PFLOAT128) xmmi->RegisterArea,
                               NUMBER_OF_387REGS);

        //
        // Rotate the registers appropriately
        //
        Wow64RotateFpTop(ContextIa64->StFSR, (PFLOAT128) xmmi->RegisterArea);

        //
        // Finally copy the xmmi registers
        //
        Wow64CopyXMMIFromIa64Byte16(&(ContextIa64->FltS4),
                                    xmmi->Reserved3,
                                    NUMBER_OF_XMMI_REGS);
    }

    if ((Ia32ContextFlags & VDMCONTEXT_FLOATING_POINT) ==
        VDMCONTEXT_FLOATING_POINT)
    {
        //
        // Copy over the floating point status/control stuff
        //
        ContextX86->FloatSave.ControlWord   = (ULONG)(ContextIa64->StFCR & 0xffff);
        ContextX86->FloatSave.StatusWord    = (ULONG)(ContextIa64->StFSR & 0xffff);
        ContextX86->FloatSave.TagWord       = (ULONG)(ContextIa64->StFSR >> 16) & 0xffff;
        ContextX86->FloatSave.ErrorOffset   = (ULONG)(ContextIa64->StFIR & 0xffffffff);
        ContextX86->FloatSave.ErrorSelector = (ULONG)(ContextIa64->StFIR >> 32);
        ContextX86->FloatSave.DataOffset    = (ULONG)(ContextIa64->StFDR & 0xffffffff);
        ContextX86->FloatSave.DataSelector  = (ULONG)(ContextIa64->StFDR >> 32);

        //
        // Copy over the FP registers into temporary space
        // Even though this is the new
        // FXSAVE format with 16-bytes for each register, need to
        // convert from spill/fill format to 80-bit double extended format
        //
        Wow64CopyIa64FromSpill((PFLOAT128) &(ContextIa64->FltT2),
                               (PFLOAT128) tmpFloat,
                               NUMBER_OF_387REGS);
        //
        // Rotate the registers appropriately
        //
        Wow64RotateFpTop(ContextIa64->StFSR, tmpFloat);

        //
        // And put them in the older FNSAVE format (packed 10 byte values)
        //
        Wow64CopyFpFromIa64Byte16(tmpFloat,
                                  ContextX86->FloatSave.RegisterArea,
                                  NUMBER_OF_387REGS);
    }

    if ((Ia32ContextFlags & VDMCONTEXT_DEBUG_REGISTERS) ==
        VDMCONTEXT_DEBUG_REGISTERS)
    {
        // Ia64 -> X86
        BOOL Valid = TRUE;
        Valid &= MapDbgSlotIa64ToX86(0, ContextIa64->StIPSR, ContextIa64->DbD0, ContextIa64->DbD1, ContextIa64->DbI0, ContextIa64->DbI1, &ContextX86->Dr7, &ContextX86->Dr0);
        Valid &= MapDbgSlotIa64ToX86(1, ContextIa64->StIPSR, ContextIa64->DbD2, ContextIa64->DbD3, ContextIa64->DbI2, ContextIa64->DbI3, &ContextX86->Dr7, &ContextX86->Dr1);
        Valid &= MapDbgSlotIa64ToX86(2, ContextIa64->StIPSR, ContextIa64->DbD4, ContextIa64->DbD5, ContextIa64->DbI4, ContextIa64->DbI5, &ContextX86->Dr7, &ContextX86->Dr2);
        Valid &= MapDbgSlotIa64ToX86(3, ContextIa64->StIPSR, ContextIa64->DbD6, ContextIa64->DbD7, ContextIa64->DbI6, ContextIa64->DbI7, &ContextX86->Dr7, &ContextX86->Dr3);

        if (!Valid)
        {
            WarnOut("Wasn't able to map IA64 debug registers consistently!!!\n");
        }

        //
        // Map single step flag (EFlags.tf = EFlags.tf || PSR.ss)
        //
        if (ContextIa64->StIPSR & (1I64 << PSR_SS))
        {
            ContextX86->EFlags |= X86_BIT_FLAGTF;
        }
    }
}

void
X86OnIa64MachineInfo::X86ContextToIa64(
    PX86_NT5_CONTEXT ContextX86,
    PIA64_CONTEXT ContextIa64)
{
   
    FLOAT128 tmpFloat[NUMBER_OF_387REGS];
    ULONG Ia32ContextFlags = ContextX86->ContextFlags;

    ULONG Tid = GetCurrentThreadId();
    DebugClient* Client;
 
    for (Client = g_Clients; Client != NULL; Client = Client->m_Next)
    {
        if (Client->m_ThreadId == Tid)
        {
            break;
        }
    }

    DBG_ASSERT((Client!=NULL));

    if (!g_Ia64Machine.IsIA32InstructionSet())
    {
        if (g_Wow64exts == NULL)
        {
            dprintf("Need to load wow64exts.dll to retrieve context!\n");
            return;
        }
        (*g_Wow64exts)(WOW64EXTS_SET_CONTEXT, 
                       (ULONG64)Client,
                       (ULONG64)ContextX86,
                       (ULONG64)NULL);
        return;
    }

    if ((Ia32ContextFlags & VDMCONTEXT_CONTROL) == VDMCONTEXT_CONTROL)
    {
        //
        // And the control stuff
        //
        ContextIa64->IntTeb = ContextX86->Ebp;
        ContextIa64->StIIP = ContextX86->Eip;
        ContextIa64->IntSp = ContextX86->Esp;
        ContextIa64->Eflag = ContextX86->EFlags;

        //
        // Map single step flag (PSR.ss = PSR.ss || EFlags.tf)
        //
        if (ContextX86->EFlags & X86_BIT_FLAGTF) 
        {
            ContextIa64->StIPSR |= (1I64 << PSR_SS);
        }

        //
        // The segments (cs and ds) are a constant, so reset them.
        // gr17 has LDT and TSS, so might as well reset
        // all of them while we're at it...
        // These values are forced in during a transition (see simulate.s)
        // so there is no point to trying to get cute and actually
        // pass in the values from the X86 context record
        //
        ContextIa64->IntT8 = ((X86_KGDT_LDT|3) << 32) 
                           | ((X86_KGDT_R3_DATA|3) << 16)
                           | (X86_KGDT_R3_CODE|3);

    }

    if ((Ia32ContextFlags & VDMCONTEXT_INTEGER) == VDMCONTEXT_INTEGER)
    {
        //
        // Now for the integer state...
        //
         ContextIa64->IntT6 = ContextX86->Edi;
         ContextIa64->IntT5 = ContextX86->Esi;
         ContextIa64->IntT4 = ContextX86->Ebx;
         ContextIa64->IntT3 = ContextX86->Edx;
         ContextIa64->IntT2 = ContextX86->Ecx;
         ContextIa64->IntV0 = ContextX86->Eax;
    }

    if ((Ia32ContextFlags & VDMCONTEXT_SEGMENTS) == VDMCONTEXT_SEGMENTS)
    {
        //
        // These are constants (and constants are used on ia32->ia64
        // transition, not saved values) so make our life easy...
        // These values are forced in during a transition (see simulate.s)
        // so there is no point to trying to get cute and actually
        // pass in the values from the X86 context record
        //
        ContextIa64->IntT7 =  ((X86_KGDT_R3_DATA|3) << 48)
                           | ((X86_KGDT_R3_TEB|3) << 32)
                           | ((X86_KGDT_R3_DATA|3) << 16)
                           | (X86_KGDT_R3_DATA|3);
    }

    if ((Ia32ContextFlags & VDMCONTEXT_EXTENDED_REGISTERS) ==
        VDMCONTEXT_EXTENDED_REGISTERS)
    {
        PX86_FXSAVE_FORMAT xmmi =
            (PX86_FXSAVE_FORMAT) ContextX86->ExtendedRegisters;
 
        //
        // And copy over the floating point status/control stuff
        //
        ContextIa64->StFCR = (ContextIa64->StFCR & 0xffffffffffffe040i64) |
                             (xmmi->ControlWord & 0xffff) |
                             ((xmmi->MXCsr & 0xffff) << 32);

        ContextIa64->StFSR = (ContextIa64->StFSR & 0xffffffff00000000i64) | 
                             (xmmi->StatusWord & 0xffff) | 
                             ((xmmi->TagWord & 0xffff) << 16);

        ContextIa64->StFIR = (xmmi->ErrorOffset & 0xffffffff) | 
                             (xmmi->ErrorSelector << 32);

        ContextIa64->StFDR = (xmmi->DataOffset & 0xffffffff) | 
                             (xmmi->DataSelector << 32);

        //
        // Don't touch the original ia32 context. Make a copy.
        //
        memcpy(tmpFloat, xmmi->RegisterArea, 
               NUMBER_OF_387REGS * sizeof(FLOAT128));
        
        // 
        // Rotate registers back since st0 is not necessarily f8
        //
        {
            ULONGLONG RotateFSR = (NUMBER_OF_387REGS - 
                                   ((ContextIa64->StFSR >> 11) & 0x7)) << 11;
            Wow64RotateFpTop(RotateFSR, tmpFloat);
        }

        //
        // Copy over the FP registers.  Even though this is the new
        // FXSAVE format with 16-bytes for each register, need to
        // convert to spill/fill format from 80-bit double extended format
        //
        Wow64CopyIa64ToFill((PFLOAT128) tmpFloat,
                            (PFLOAT128) &(ContextIa64->FltT2),
                            NUMBER_OF_387REGS);

        //
        // Copy over the xmmi registers and convert them into a format
        // that spill/fill can use
        //
        Wow64CopyXMMIToIa64Byte16(xmmi->Reserved3, 
                                  &(ContextIa64->FltS4), 
                                  NUMBER_OF_XMMI_REGS);
    }

    if ((Ia32ContextFlags & VDMCONTEXT_FLOATING_POINT) ==
        VDMCONTEXT_FLOATING_POINT)
    {
        //
        // Copy over the floating point status/control stuff
        // Leave the MXCSR stuff alone
        //
        ContextIa64->StFCR = (ContextIa64->StFCR & 0xffffffffffffe040i64) | 
                             (ContextX86->FloatSave.ControlWord & 0xffff);

        ContextIa64->StFSR = (ContextIa64->StFSR & 0xffffffff00000000i64) | 
                             (ContextX86->FloatSave.StatusWord & 0xffff) | 
                             ((ContextX86->FloatSave.TagWord & 0xffff) << 16);

        ContextIa64->StFIR = (ContextX86->FloatSave.ErrorOffset & 0xffffffff) | 
                             (ContextX86->FloatSave.ErrorSelector << 32);

        ContextIa64->StFDR = (ContextX86->FloatSave.DataOffset & 0xffffffff) | 
                             (ContextX86->FloatSave.DataSelector << 32);


        //
        // Copy over the FP registers from packed 10-byte format
        // to 16-byte format
        //
        Wow64CopyFpToIa64Byte16(ContextX86->FloatSave.RegisterArea,
                                tmpFloat,
                                NUMBER_OF_387REGS);

        // 
        // Rotate registers back since st0 is not necessarily f8
        //
        {
            ULONGLONG RotateFSR = (NUMBER_OF_387REGS - 
                                   ((ContextIa64->StFSR >> 11) & 0x7)) << 11;
            Wow64RotateFpTop(RotateFSR, tmpFloat);
        }

        //
        // Now convert from 80 bit extended format to fill/spill format
        //
        Wow64CopyIa64ToFill((PFLOAT128) tmpFloat,
                            (PFLOAT128) &(ContextIa64->FltT2),
                            NUMBER_OF_387REGS);
    }

    if ((Ia32ContextFlags & VDMCONTEXT_DEBUG_REGISTERS) ==
        VDMCONTEXT_DEBUG_REGISTERS)
    {
        // X86 -> Ia64
        MapDbgSlotX86ToIa64(0, ContextX86->Dr7, ContextX86->Dr0, &ContextIa64->StIPSR, &ContextIa64->DbD0, &ContextIa64->DbD1, &ContextIa64->DbI0, &ContextIa64->DbI1);
        MapDbgSlotX86ToIa64(1, ContextX86->Dr7, ContextX86->Dr1, &ContextIa64->StIPSR, &ContextIa64->DbD2, &ContextIa64->DbD3, &ContextIa64->DbI2, &ContextIa64->DbI3);
        MapDbgSlotX86ToIa64(2, ContextX86->Dr7, ContextX86->Dr2, &ContextIa64->StIPSR, &ContextIa64->DbD4, &ContextIa64->DbD5, &ContextIa64->DbI4, &ContextIa64->DbI5);
        MapDbgSlotX86ToIa64(3, ContextX86->Dr7, ContextX86->Dr3, &ContextIa64->StIPSR, &ContextIa64->DbD6, &ContextIa64->DbD7, &ContextIa64->DbI6, &ContextIa64->DbI7);

        //
        // Map single step flag (PSR.ss = PSR.ss || EFlags.tf)
        //
        if (ContextX86->EFlags & X86_BIT_FLAGTF) 
        {
            ContextIa64->StIPSR |= (1I64 << PSR_SS);
        }
    }
        
}

//
// Helper functions for context conversion
// --copied from \nt\base\wow64\cpu\context\context.c
//

//
// This allows the compiler to be more efficient in copying 10 bytes
// without over copying...
//
#pragma pack(push, 2)
typedef struct _ia32fpbytes {
    ULONG significand_low;
    ULONG significand_high;
    USHORT exponent;
} IA32FPBYTES, *PIA32FPBYTES;
#pragma pack(pop)

VOID
Wow64CopyFpFromIa64Byte16(
    IN PVOID Byte16Fp,
    IN OUT PVOID Byte10Fp,
    IN ULONG NumRegs)
{
    ULONG i;
    PIA32FPBYTES from, to;

    from = (PIA32FPBYTES) Byte16Fp;
    to = (PIA32FPBYTES) Byte10Fp;

    for (i = 0; i < NumRegs; i++) {
        *to = *from;
        from = (PIA32FPBYTES) (((UINT_PTR) from) + 16);
        to = (PIA32FPBYTES) (((UINT_PTR) to) + 10);
    }
}

VOID
Wow64CopyFpToIa64Byte16(
    IN PVOID Byte10Fp,
    IN OUT PVOID Byte16Fp,
    IN ULONG NumRegs)
{
    ULONG i;
    PIA32FPBYTES from, to;  // UNALIGNED

    from = (PIA32FPBYTES) Byte10Fp;
    to = (PIA32FPBYTES) Byte16Fp;

    for (i = 0; i < NumRegs; i++) {
        *to = *from;
        from = (PIA32FPBYTES) (((UINT_PTR) from) + 10);
        to = (PIA32FPBYTES) (((UINT_PTR) to) + 16);
    }
}

//
// Alas, nothing is easy. The ia32 xmmi instructions use 16 bytes and pack
// them as nice 16 byte structs. Unfortunately, ia64 handles it as 2 8-byte
// values (using just the mantissa part). So, another conversion is required
//
VOID
Wow64CopyXMMIToIa64Byte16(
    IN PVOID ByteXMMI,
    IN OUT PVOID Byte16Fp,
    IN ULONG NumRegs)
{
    ULONG i;
    UNALIGNED ULONGLONG *from;
    ULONGLONG *to;

    from = (PULONGLONG) ByteXMMI;
    to = (PULONGLONG) Byte16Fp;

    //
    // although we have NumRegs xmmi registers, each register is 16 bytes
    // wide. This code does things in 8-byte chunks, so total
    // number of times to do things is 2 * NumRegs...
    //
    NumRegs *= 2;

    for (i = 0; i < NumRegs; i++) {
        *to++ = *from++;        // Copy over the mantissa part
        *to++ = 0x1003e;        // Force the exponent part
                                // (see ia64 eas, ia32 FP section - 6.2.7
                                // for where this magic number comes from)
    }
}

VOID
Wow64CopyXMMIFromIa64Byte16(
    IN PVOID Byte16Fp,
    IN OUT PVOID ByteXMMI,
    IN ULONG NumRegs)
{
    ULONG i;
    ULONGLONG *from;
    UNALIGNED ULONGLONG *to;

    from = (PULONGLONG) Byte16Fp;
    to = (PULONGLONG) ByteXMMI;

    //
    // although we have NumRegs xmmi registers, each register is 16 bytes
    // wide. This code does things in 8-byte chunks, so total
    // number of times to do things is 2 * NumRegs...
    //
    NumRegs *= 2;

    for (i = 0; i < NumRegs; i++) {
        *to++ = *from++;        // Copy over the mantissa part
        from++;                 // Skip over the exponent part
    }
}

VOID
Wow64RotateFpTop(
    IN ULONGLONG Ia64_FSR,
    IN OUT FLOAT128 UNALIGNED *ia32FxSave)
/*++

Routine Description:

    On transition from ia64 mode to ia32 (and back), the f8-f15 registers
    contain the st[0] to st[7] fp stack values. Alas, these values don't
    map one-one, so the FSR.top bits are used to determine which ia64
    register has the top of stack. We then need to rotate these registers
    since ia32 context is expecting st[0] to be the first fp register (as
    if FSR.top is zero). This routine only works on full 16-byte ia32
    saved fp data (such as from ExtendedRegisters - the FXSAVE format).
    Other routines can convert this into the older FNSAVE format.

Arguments:

    Ia64_FSR - The ia64 FSR register. Has the FSR.top needed for this routine

    ia32FxSave - The ia32 fp stack (in FXSAVE format). Each ia32 fp register
                 uses 16 bytes.

Return Value:

    None.  

--*/
{
    ULONG top = (ULONG) ((Ia64_FSR >> 11) & 0x7);

    if (top) {
        FLOAT128 tmpFloat[NUMBER_OF_387REGS];
        ULONG i;
        for (i = 0; i < NUMBER_OF_387REGS; i++) {
            tmpFloat[i] = ia32FxSave[i];
        }

        for (i = 0; i < NUMBER_OF_387REGS; i++) {
            ia32FxSave[i] = tmpFloat[(i + top) % NUMBER_OF_387REGS];
        }
    }
}

//
// And now for the final yuck... The ia64 context for floating point
// is saved/loaded using spill/fill instructions. This format is different
// than the 10-byte fp format so we need a conversion routine from spill/fill
// to/from 10byte fp
//

VOID
Wow64CopyIa64FromSpill(
    IN PFLOAT128 SpillArea,
    IN OUT FLOAT128 UNALIGNED *ia64Fp,
    IN ULONG NumRegs)
/*++

Routine Description:

    This function copies fp values from the ia64 spill/fill format
    into the ia64 80-bit format. The exponent needs to be adjusted
    according to the EAS (5-12) regarding Memory to Floating Point
    Register Data Translation in the ia64 floating point chapter

Arguments:

    SpillArea - The ia64 area that has the spill format for fp

    ia64Fp - The location which will get the ia64 fp in 80-bit
             double-extended format

    NumRegs - Number of registers to convert

Return Value:

    None.

--*/
{
    ULONG i;

    for (i = 0; i < NumRegs; i++) {
        ULONG64 Sign = ((SpillArea->HighPart & (1i64 << 17)) != 0);
        ULONG64 Significand = SpillArea->LowPart; 
        ULONG64 Exponent = SpillArea->HighPart & 0x1ffff; 

        if (Exponent && Significand) 
        {
            if (Exponent == 0x1ffff) // NaNs and Infinities
            {   
                Exponent = 0x7fff;
            }
            else 
            {
                ULONG64 Rebias = 0xffff - 0x3fff;
                Exponent -= Rebias;
            }
        }

        ia64Fp->HighPart = (Sign << 15) | Exponent;
        ia64Fp->LowPart = Significand;

        ia64Fp++;
        SpillArea++;
    }
}

VOID
Wow64CopyIa64ToFill(
    IN FLOAT128 UNALIGNED *ia64Fp,
    IN OUT PFLOAT128 FillArea,
    IN ULONG NumRegs)
/*++

Routine Description:

    This function copies fp values from the ia64 80-bit format
    into the fill/spill format used by the os for save/restore
    of the ia64 context. The only magic here is putting back some
    values that get truncated when converting from spill/fill to 
    80-bits. The exponent needs to be adjusted according to the
    EAS (5-12) regarding Memory to Floating Point Register Data
    Translation in the ia64 floating point chapter

Arguments:

    ia64Fp - The ia64 fp in 80-bit double-extended format

    FillArea - The ia64 area that will get the fill format for fp
                  for the copy into the ia64 context area

    NumRegs - Number of registers to convert

Return Value:

    None.

--*/
{
    ULONG i;

    for (i = 0; i < NumRegs; i++) {
        ULONG64 Sign = ((ia64Fp->HighPart & (1i64 << 15)) != 0);
        ULONG64 Significand = ia64Fp->LowPart; 
        ULONG64 Exponent = ia64Fp->HighPart & 0x7fff;

        if (Exponent && Significand) 
        {
            if (Exponent == 0x7fff) // Infinity
            {
                Exponent = 0x1ffff;
            }
            else 
            {
                ULONGLONG Rebias = 0xffff-0x3fff;
                Exponent += Rebias;
            }
        }

        FillArea->LowPart = Significand;
        FillArea->HighPart = (Sign << 17) | Exponent;

        ia64Fp++;
        FillArea++;
    }
}

ULONG 
MapDbgSlotIa64ToX86_GetSize(ULONG64 Db1, BOOL* Valid)
{
    ULONG64 Size = (~Db1 & IA64_DBG_MASK_MASK);
    if (Size > 3)
    {
        *Valid = FALSE;
    }
    return (ULONG)Size;
}

void 
MapDbgSlotIa64ToX86_InvalidateAddr(ULONG64 Db, BOOL* Valid)
{
    if (Db != (ULONG64)(ULONG)Db) 
    {
        *Valid = FALSE;
    }
}

ULONG
MapDbgSlotIa64ToX86_ExecTypeSize(
    UINT     Slot,
    ULONG64  Db,
    ULONG64  Db1,
    BOOL* Valid)
{
    ULONG TypeSize;

    if (!(Db1 >> 63)) 
    {
        *Valid = FALSE;
    }

    TypeSize = (MapDbgSlotIa64ToX86_GetSize(Db1, Valid) << 2); 
    MapDbgSlotIa64ToX86_InvalidateAddr(Db, Valid);
   
    return TypeSize;
}

ULONG
MapDbgSlotIa64ToX86_DataTypeSize(
    UINT     Slot,
    ULONG64  Db,
    ULONG64  Db1,
    BOOL* Valid)
{
    ULONG TypeSize = (ULONG)(Db1 >> 62);

    if ((TypeSize != 1) && (TypeSize != 3))
    {
        *Valid = FALSE;
    }

    TypeSize |= (MapDbgSlotIa64ToX86_GetSize(Db1, Valid) << 2); 
    MapDbgSlotIa64ToX86_InvalidateAddr(Db, Valid);
    
    return TypeSize;
}

BOOL
MapDbgSlotIa64ToX86(
    UINT    Slot,
    ULONG64 Ipsr,
    ULONG64 DbD,
    ULONG64 DbD1,
    ULONG64 DbI,
    ULONG64 DbI1,
    ULONG*  Dr7,
    ULONG*  Dr)
{
    BOOL DataValid = TRUE, ExecValid = TRUE, Valid = TRUE;
    ULONG DataTypeSize, ExecTypeSize;

    // XXX olegk - remove this after IA64_REG_MAX_DATA_BREAKPOINTS will be changed to 4
    if (Slot >= IA64_REG_MAX_DATA_BREAKPOINTS) 
    {
        return TRUE;
    }

    DataTypeSize = MapDbgSlotIa64ToX86_DataTypeSize(Slot, DbD, DbD1, &DataValid);
    ExecTypeSize = MapDbgSlotIa64ToX86_ExecTypeSize(Slot, DbI, DbI1, &ExecValid);
    
    if (DataValid)
    {
        if (!ExecValid)
        {
            *Dr = (ULONG)DbD;
            *Dr7 |= (X86_DR7_LOCAL_EXACT_ENABLE |
                     (1 << Slot * 2) |
                     (DataTypeSize << (16 + Slot * 4)));
            return !DbI && !DbI1;
        }
    }
    else if (ExecValid)
    {
        *Dr = (ULONG)DbI;
        *Dr7 |= (X86_DR7_LOCAL_EXACT_ENABLE |
                 (1 << Slot * 2) |
                 (ExecTypeSize << (16 + Slot * 4)));
        return !DbD && !DbD1;
    }
    
    *Dr7 &= ~(X86_DR7_LOCAL_EXACT_ENABLE |  
              (0xf << (16 + Slot * 4)) | 
              (1 << Slot * 2));

    if (!DbD && !DbD1 && !DbI && !DbI1)
    {
        *Dr = 0;
        return TRUE;
    }
     
    *Dr = ~(ULONG)0;

    return FALSE;
}

void
MapDbgSlotX86ToIa64(
    UINT     Slot,
    ULONG    Dr7,
    ULONG    Dr,
    ULONG64* Ipsr,
    ULONG64* DbD,
    ULONG64* DbD1,
    ULONG64* DbI,
    ULONG64* DbI1)
{
    UINT TypeSize;
    ULONG64 Control;

    if (!(Dr7 & (1 << Slot * 2)))
    {
        return;
    }

    if (Dr == ~(ULONG)0) 
    {
        return;
    }

    TypeSize = Dr7 >> (16 + Slot * 4);

    Control = (IA64_DBG_REG_PLM_USER | IA64_DBG_MASK_MASK) & 
              ~(ULONG64)(TypeSize >> 2);

    switch (TypeSize & 0x3) 
    {
    case 0x0: // Exec
        *DbI1 = Control | IA64_DBR_EXEC;        
        *DbI = Dr;
        break;
    case 0x1: // Write
        *DbD1 = Control | IA64_DBR_WR;
        *DbD = Dr;
        break;
    case 0x3: // Read/Write
        *DbD1 = Control | IA64_DBR_RD | IA64_DBR_WR;
        *DbD = Dr;
        break;
    default:
        return;
    }
    *Ipsr |= (1i64 << PSR_DB); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\machine.hpp ===
//----------------------------------------------------------------------------
//
// Abstraction of processor-specific information.
//
// Copyright (C) Microsoft Corporation, 1999-2001.
//
//----------------------------------------------------------------------------

#ifndef __MACHINE_HPP__
#define __MACHINE_HPP__

// These context information states are intended to be shared among
// processors so they may not all apply to each processor.  The important
// thing is that they are ordered from less information to more.
// Each state includes all the information from the states that precede it.
// More states can be inserted anywhere as new processors require them.
#define MCTX_NONE         0     // No context information.
#define MCTX_PC           1     // Program counter.
#define MCTX_DR67_REPORT  2     // X86: DR6,7 control report.
#define MCTX_REPORT       3     // Control report.
#define MCTX_CONTEXT      4     // Kernel protocol context information.
#define MCTX_FULL         5     // All possible information.
#define MCTX_DIRTY        6     // Dirty context, implies full information.

// Constant offset value returned from GetNextOffset to indicate the
// trace flag should be used.
#define OFFSET_TRACE ((ULONG64)(LONG64)-1)
#define OFFSET_TRACE_32 ((ULONG)OFFSET_TRACE)

// Distinguished error code for GetVirtualTranslationPhysicalOffsets
// to indicate that all translations were successful but
// the page was not present.  In this case the LastVal value
// will contain the page file offset and PfIndex will contain
// the page file number.
#define HR_PAGE_IN_PAGE_FILE  HRESULT_FROM_NT(STATUS_PAGE_FAULT_PAGING_FILE)
// Translation could not complete and a page file location
// for the data could not be determined.
#define HR_PAGE_NOT_AVAILABLE HRESULT_FROM_NT(STATUS_NO_PAGEFILE)

#define MAX_PAGING_FILE_MASK 0xf

//
// Segment register access.
// Processors which do not support segment registers return
// zero for the segment register number.
//

enum
{
    // Descriptor table pseudo-segments.  The GDT does
    // not have a specific register number.
    // These pseudo-segments should be first so that
    // index zero is not used for a normal segreg.
    SEGREG_GDT,
    SEGREG_LDT,

    // Generic segments.
    SEGREG_CODE,
    SEGREG_DATA,
    SEGREG_STACK,
    
    // Extended segments.
    SEGREG_ES,
    SEGREG_FS,
    SEGREG_GS,
    
    SEGREG_COUNT
};

//
// Segment descriptor values.
// Due to the descriptor caching that x86 processors
// do this may differ from the actual in-memory descriptor and
// may be retrieved in a much different way.
//

// Special flags value that marks a descriptor as invalid.
#define SEGDESC_INVALID 0xffffffff

#define X86_DESC_TYPE(Flags) ((Flags) & 0x1f)

#define X86_DESC_PRIVILEGE_SHIFT 5
#define X86_DESC_PRIVILEGE(Flags) (((Flags) >> X86_DESC_PRIVILEGE_SHIFT) & 3)

#define X86_DESC_PRESENT     0x80
#define X86_DESC_LONG_MODE   0x200
#define X86_DESC_DEFAULT_BIG 0x400
#define X86_DESC_GRANULARITY 0x800

typedef struct _DESCRIPTOR64
{
    ULONG64 Base;
    ULONG64 Limit;
    ULONG Flags;
} DESCRIPTOR64, *PDESCRIPTOR64;

#define FORM_VM86       0x00000001
#define FORM_CODE       0x00000002
#define FORM_SEGREG     0x00000004

#define X86_FORM_VM86(Efl) \
    (X86_IS_VM86(Efl) ? FORM_VM86 : 0)
    
//----------------------------------------------------------------------------
//
// Abstract interface for machine information.  All possible
// machine-specific implementations of this interface exist at
// all times.  The effective implementation is selected when
// SetEffMachine is called.  For generic access the abstract
// interface should be used.  In machine-specific code the
// specific implementation classes can be used.
//
// IMPORTANT: Be very careful when using machine-specific header files
// such as nt<plat>.h.  The machine implementation class is
// compiled for all platforms so the nt<plat>.h file will be the
// one for the build platform, not necessarily the platform
// of the machine implementation.  ntdbg.h contains many cross-platform
// types and definitions that can be used to avoid problems.
//
//----------------------------------------------------------------------------

extern BOOL g_PrefixSymbols;
extern BOOL g_ContextChanged;
extern DEBUG_PROCESSOR_IDENTIFICATION_ALL g_InitProcessorId;

struct RegisterGroup
{
    RegisterGroup* Next;
    // Counted automatically.
    ULONG NumberRegs;
    // Regs is assumed to be non-NULL in all groups.
    // SubRegs and AllExtraDesc may be NULL in any group.
    REGDEF* Regs;
    REGSUBDEF* SubRegs;
    REGALLDESC* AllExtraDesc;
};

// Trace modes used by SetTraceMode/GetTraceMode functions
typedef enum 
{
    TRACE_NONE, 
    TRACE_INSTRUCTION,
    TRACE_TAKEN_BRANCH
} TRACEMODE;

// These enumerants are abstract values but currently
// only IA64 actually has different page directories
// so set them up to match the IA64 mapping for convenience.
enum
{
    PAGE_DIR_USER,
    PAGE_DIR_SESSION,
    PAGE_DIR_KERNEL = 7,
    PAGE_DIR_COUNT
};

// For machines which only support a single page directory
// take it from the kernel slot.  All will be updated so
// this is an arbitrary choice.
#define PAGE_DIR_SINGLE PAGE_DIR_KERNEL

// All directories bit mask.
#define PAGE_DIR_ALL ((1 << PAGE_DIR_COUNT) - 1)

// Flags for GetPrefixedSymbolOffset.
#define GETPREF_VERBOSE 0x00000001

class MachineInfo
{
public:
    // Descriptive information.
    PCSTR m_FullName;
    PCSTR m_AbbrevName;
    ULONG m_PageSize;
    ULONG m_PageShift;
    ULONG m_NumExecTypes;
    // First ExecTypes entry must be the actual processor type.
    PULONG m_ExecTypes;
    BOOL m_Ptr64;
    
    // Automatically counted from regs in base Initialize.
    ULONG m_NumberRegs;
    RegisterGroup* m_Groups;
    ULONG m_AllMask;
    // Collected automatically from groups.
    ULONG m_AllMaskBits;
    ULONG m_MaxDataBreakpoints;
    PCSTR m_SymPrefix;
    // Computed automatically.
    ULONG m_SymPrefixLen;

    // Hard-coded type information for machine and platform version.
    ULONG m_OffsetPrcbProcessorState;
    ULONG m_OffsetPrcbNumber;
    ULONG64 m_TriagePrcbOffset;
    ULONG m_SizePrcb;
    ULONG m_OffsetKThreadApcProcess;
    ULONG m_OffsetKThreadTeb;
    ULONG m_OffsetKThreadInitialStack;
    ULONG m_OffsetEprocessPeb;
    ULONG m_OffsetEprocessDirectoryTableBase;
    ULONG m_OffsetKThreadNextProcessor;
    // Size of the native context for the target machine.
    ULONG m_SizeTargetContext;
    // Offset of the flags ULONG in the native context.
    ULONG m_OffsetTargetContextFlags;
    // Control space offset for special registers.
    ULONG m_OffsetSpecialRegisters;
    // Size of the canonical context kept in the MachineInfo.
    ULONG m_SizeCanonicalContext;
    // System version of the canonical context.  Can be compared
    // against g_SystemVersion to see if the target provides
    // canonical contexts or not.
    ULONG m_SverCanonicalContext;
    ULONG m_SizeControlReport;
    ULONG m_SizeEThread;
    ULONG m_SizeEProcess;
    ULONG m_SizeKspecialRegisters;
    // Size of the debugger's *_THREAD partial structure.
    ULONG m_SizePartialKThread;
    ULONG64 m_SharedUserDataOffset;

    // Context could be kept per-thread
    // so that several can be around at once for a cache.
    // That would also make the save/restore stuff unnecessary.
    ULONG m_ContextState;
    CROSS_PLATFORM_CONTEXT m_Context;

    // Segment register descriptors.  These will only
    // be valid on processors that support them, otherwise
    // they will be marked invalid.
    DESCRIPTOR64 m_SegRegDesc[SEGREG_COUNT];
    DESCRIPTOR64 m_SavedSegRegDesc[SEGREG_COUNT];
    
    // Holds the current page directory offsets.
    ULONG64 m_PageDirectories[PAGE_DIR_COUNT];
    BOOL m_Translating;
    
    BOOL m_ContextIsReadOnly;

    // InitializeConstants initializes information which is
    // fixed and unaffected by the type of target being debugged.
    // InitializeForTarget initializes information which
    // varies according to the particular type of target being debugged.
    // InitializeForProcessor initializes information which
    // varies according to the particular type of processor that's
    // present in the target as described by g_InitProcessorId.
    // Derived classes should call base Initialize* after
    // their own initialization.
    virtual HRESULT InitializeConstants(void);
    virtual HRESULT InitializeForTarget(void);
    virtual HRESULT InitializeForProcessor(void);

    virtual void InitializeContext
        (ULONG64 Pc, PDBGKD_ANY_CONTROL_REPORT ControlReport) = 0;
    HRESULT GetContextState(ULONG State);
    HRESULT SetContext(void);
    // Base implementations use Get/SetThreadContext for
    // any request.
    virtual HRESULT UdGetContextState(ULONG State);
    virtual HRESULT UdSetContext(void);
    virtual HRESULT KdGetContextState(ULONG State) = 0;
    virtual HRESULT KdSetContext(void) = 0;
    // Base implementation sets ContextState to NONE.
    virtual void InvalidateContext(void);
    // Context conversion is version-based rather than size-based
    // as the size is ambiguous in certain cases.  For example,
    // ALPHA_CONTEXT and ALPHA_NT5_CONTEXT are the same size
    // so additional information is necessary to distinguish them.
    virtual HRESULT ConvertContextFrom(PCROSS_PLATFORM_CONTEXT Context,
                                       ULONG FromSver,
                                       ULONG FromSize, PVOID From) = 0;
    virtual HRESULT ConvertContextTo(PCROSS_PLATFORM_CONTEXT Context,
                                     ULONG ToSver, ULONG ToSize, PVOID To) = 0;
    virtual void InitializeContextFlags(PCROSS_PLATFORM_CONTEXT Context,
                                        ULONG Version) = 0;
    virtual HRESULT GetContextFromThreadStack(ULONG64 ThreadBase,
                                              PCROSS_PLATFORM_THREAD Thread,
                                              PCROSS_PLATFORM_CONTEXT Context,
                                              PDEBUG_STACK_FRAME Frame,
                                              PULONG RunningOnProc) = 0;

    // Base implementations return E_NOTIMPL.
    virtual HRESULT GetExdiContext(IUnknown* Exdi, PEXDI_CONTEXT Context);
    virtual HRESULT SetExdiContext(IUnknown* Exdi, PEXDI_CONTEXT Context);
    virtual void ConvertExdiContextFromContext(PCROSS_PLATFORM_CONTEXT Context,
                                               PEXDI_CONTEXT ExdiContext);
    virtual void ConvertExdiContextToContext(PEXDI_CONTEXT ExdiContext,
                                             PCROSS_PLATFORM_CONTEXT Context);
    virtual void ConvertExdiContextToSegDescs(PEXDI_CONTEXT ExdiContext,
                                              ULONG Start, ULONG Count,
                                              PDESCRIPTOR64 Descs);
    virtual void ConvertExdiContextFromSpecial
        (PCROSS_PLATFORM_KSPECIAL_REGISTERS Special,
         PEXDI_CONTEXT ExdiContext);
    virtual void ConvertExdiContextToSpecial
        (PEXDI_CONTEXT ExdiContext,
         PCROSS_PLATFORM_KSPECIAL_REGISTERS Special);
             
    // A simple one-deep temporary save stack for CONTEXT information.
    // Useful when you want to swap in an arbitrary context for
    // some machine operation.  This uses the same save area
    // as KdSave/RestoreProcessorState so the two should
    // not be used together.
    void PushContext(PCROSS_PLATFORM_CONTEXT Context)
    {
        DBG_ASSERT (!m_ContextIsReadOnly);
        m_SavedContextState = m_ContextState;
        m_SavedContext = m_Context;
        memcpy(m_SavedSegRegDesc, m_SegRegDesc, sizeof(m_SegRegDesc));
        m_Context = *Context;
        m_ContextState = MCTX_FULL;
        m_ContextIsReadOnly = TRUE;
    }
    void PopContext(void)
    {
        DBG_ASSERT((m_ContextState != MCTX_DIRTY) && (m_ContextIsReadOnly));
        m_Context = m_SavedContext;
        m_ContextState = m_SavedContextState;
        memcpy(m_SegRegDesc, m_SavedSegRegDesc, sizeof(m_SegRegDesc));
        m_ContextIsReadOnly = FALSE;
    }
        
    virtual int  GetType(ULONG index) = 0;
    virtual BOOL GetVal(ULONG index, REGVAL *val) = 0;
    virtual BOOL SetVal(ULONG index, REGVAL *val) = 0;

    virtual void GetPC(PADDR Address) = 0;
    virtual void SetPC(PADDR Address) = 0;
    virtual void GetFP(PADDR Address) = 0;
    virtual void GetSP(PADDR Address) = 0;
    virtual ULONG64 GetArgReg(void) = 0;
    // Base implementations return zero and FALSE.
    virtual ULONG GetSegRegNum(ULONG SegReg);
    virtual HRESULT GetSegRegDescriptor(ULONG SegReg, PDESCRIPTOR64 Desc);

    virtual void OutputAll(ULONG Mask, ULONG OutMask) = 0;

    virtual TRACEMODE GetTraceMode(void) = 0;
    virtual void SetTraceMode(TRACEMODE Mode) = 0;

    // Returns true if trace mode appropriate to specified execution status 
    // (e.g. DEBUG_STATUS_STEP_OVER, DEBUG_STATUS_STEP_INTO,
    // DEBUG_STATUS_STEP_BRANCH...) supported by the machine.
    virtual BOOL IsStepStatusSupported(ULONG Status) = 0;

    void QuietSetTraceMode(TRACEMODE Mode)
    {
        BOOL ContextChangedOrg = g_ContextChanged;
        SetTraceMode(Mode);
        g_ContextChanged = ContextChangedOrg;
    }

    // Base implementation does nothing.
    virtual void KdUpdateControlSet
        (PDBGKD_ANY_CONTROL_SET ControlSet);

    // Base implementations save and restore m_Context and m_ContextState.
    virtual void KdSaveProcessorState(void);
    virtual void KdRestoreProcessorState(void);

    virtual ULONG ExecutingMachine(void) = 0;

    virtual HRESULT SetPageDirectory(ULONG Idx, ULONG64 PageDir,
                                     PULONG NextIdx) = 0;
    HRESULT SetDefaultPageDirectories(ULONG Mask);
    virtual HRESULT GetVirtualTranslationPhysicalOffsets
        (ULONG64 Virt, PULONG64 Offsets, ULONG OffsetsSize,
         PULONG Levels, PULONG PfIndex, PULONG64 LastVal) = 0;
    virtual HRESULT GetBaseTranslationVirtualOffset(PULONG64 Offset) = 0;

    virtual void Assemble(PADDR Addr, PSTR Input) = 0;
    virtual BOOL Disassemble(PADDR Addr, PSTR Buffer, BOOL EffAddr) = 0;

    // Creates new Breakpoint object compatible with specific machine
    virtual HRESULT NewBreakpoint(DebugClient* Client, 
                                  ULONG Type, 
                                  ULONG Id, 
                                  Breakpoint** RetBp);

    virtual BOOL IsBreakpointInstruction(PADDR Addr) = 0;
    virtual HRESULT InsertBreakpointInstruction(PUSER_DEBUG_SERVICES Services,
                                                ULONG64 Process,
                                                ULONG64 Offset,
                                                PUCHAR SaveInstr,
                                                PULONG64 ChangeStart,
                                                PULONG ChangeLen) = 0;
    virtual HRESULT RemoveBreakpointInstruction(PUSER_DEBUG_SERVICES Services,
                                                ULONG64 Process,
                                                ULONG64 Offset,
                                                PUCHAR SaveInstr,
                                                PULONG64 ChangeStart,
                                                PULONG ChangeLen) = 0;
    virtual void AdjustPCPastBreakpointInstruction(PADDR Addr,
                                                   ULONG BreakType) = 0;
    // Base implementations do nothing for platforms which
    // do not support data breakpoints.
    virtual void InsertAllDataBreakpoints(void);
    virtual void RemoveAllDataBreakpoints(void);
    // Base implementation returns EXCEPTION_BRAKEPOINT_ANY
    // for STATUS_BREAKPOINT.
    virtual ULONG IsBreakpointOrStepException(PEXCEPTION_RECORD64 Record,
                                              ULONG FirstChance,
                                              PADDR BpAddr,
                                              PADDR RelAddr);

    virtual BOOL IsCallDisasm(PCSTR Disasm) = 0;
    virtual BOOL IsReturnDisasm(PCSTR Disasm) = 0;
    virtual BOOL IsSystemCallDisasm(PCSTR Disasm) = 0;
    
    virtual BOOL IsDelayInstruction(PADDR Addr) = 0;
    virtual void GetEffectiveAddr(PADDR Addr) = 0;
    // Some processors, such as IA64, have instructions which
    // switch between instruction sets, thus the machine type
    // of the next offset may be different from the current machine.
    // If the NextAddr is OFFSET_TRACE the NextMachine is ignored.
    virtual void GetNextOffset(BOOL StepOver,
                               PADDR NextAddr, PULONG NextMachine) = 0;
    // Base implementation returns the value from StackWalk.
    virtual void GetRetAddr(PADDR Addr);
    // Base implementation does nothing for machines which
    // do not have symbol prefixing.
    virtual BOOL GetPrefixedSymbolOffset(ULONG64 SymOffset,
                                         ULONG Flags,
                                         PULONG64 PrefixedSymOffset);

    virtual void IncrementBySmallestInstruction(PADDR Addr) = 0;
    virtual void DecrementBySmallestInstruction(PADDR Addr) = 0;

    virtual BOOL DisplayTrapFrame(ULONG64 FrameAddress,
                                  PCROSS_PLATFORM_CONTEXT Context) = 0;
    virtual void ValidateCxr(PCROSS_PLATFORM_CONTEXT Context) = 0;

    // Output function entry information for the given entry.
    virtual void OutputFunctionEntry(PVOID RawEntry) = 0;
    // Base implementation returns E_UNEXPECTED.
    virtual HRESULT ReadDynamicFunctionTable(ULONG64 Table,
                                             PULONG64 NextTable,
                                             PULONG64 MinAddress,
                                             PULONG64 MaxAddress,
                                             PULONG64 BaseAddress,
                                             PULONG64 TableData,
                                             PULONG TableSize,
                                             PWSTR OutOfProcessDll,
                                             PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE RawTable);
    // Base implementation returns NULL.
    virtual PVOID FindDynamicFunctionEntry(PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE Table,
                                           ULONG64 Address,
                                           PVOID TableData,
                                           ULONG TableSize);

    virtual HRESULT ReadKernelProcessorId
        (ULONG Processor, PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id) = 0;

    // Base implementation discards page directory entries.
    virtual void FlushPerExecutionCaches(void);
    
    // Stack output functions
    virtual void PrintStackFrameAddressesTitle(ULONG Flags);
    virtual void PrintStackFrameAddresses(ULONG Flags, 
                                          PDEBUG_STACK_FRAME StackFrame);
    virtual void PrintStackArgumentsTitle(ULONG Flags);
    virtual void PrintStackArguments(ULONG Flags, 
                                     PDEBUG_STACK_FRAME StackFrame);
    virtual void PrintStackCallSiteTitle(ULONG Flags);
    virtual void PrintStackCallSite(ULONG Flags, 
                                    PDEBUG_STACK_FRAME StackFrame, 
                                    CHAR SymBuf[], DWORD64 Displacement, 
                                    USHORT StdCallArgs);
    virtual void PrintStackNonvolatileRegisters(ULONG Flags, 
                                                PDEBUG_STACK_FRAME StackFrame,
                                                PCROSS_PLATFORM_CONTEXT Context,
                                                ULONG FrameNum);

    //
    // IMPORTANT
    //
    // Helpers for convenient value access.  When in machine code
    // these helpers are preferred to Get/SetRegVal* because
    // they stay in the same machine whereas the generic code
    // always uses g_Machine.  If a caller makes a direct call
    // on a specific machine g_Machine may not match so the
    // generic code will not work properly.
    //
    // Note that the set methods here do not get the register
    // type as is done in the generic code.  All of these methods
    // assume that the proper call is being made for the register.
    // The Get/SetReg methods also only operate on real registers, not
    // subregisters.  Use the Get/SetSubReg methods when dealing
    // with subregisters.
    //
    
    USHORT GetReg16(ULONG Reg)
    {
        REGVAL RegVal;
        RegVal.i64 = 0;
        GetVal(Reg, &RegVal);
        return RegVal.i16;
    }
    ULONG GetReg32(ULONG Reg)
    {
        REGVAL RegVal;
        RegVal.i64 = 0;
        GetVal(Reg, &RegVal);
        return RegVal.i32;
    }
    void SetReg32(ULONG Reg, ULONG Val)
    {
        REGVAL RegVal;
        RegVal.type = REGVAL_INT32;
        RegVal.i64 = 0;
        RegVal.i32 = Val;
        SetVal(Reg, &RegVal);
    }
    ULONG64 GetReg64(ULONG Reg)
    {
        REGVAL RegVal;
        RegVal.i64 = 0;
        GetVal(Reg, &RegVal);
        return RegVal.i64;
    }
    void SetReg64(ULONG Reg, ULONG64 Val)
    {
        REGVAL RegVal;
        RegVal.type = REGVAL_INT64;
        RegVal.i64 = Val;
        RegVal.Nat = FALSE;
        SetVal(Reg, &RegVal);
    }
    ULONG GetSubReg32(ULONG SubReg)
    {
        REGVAL RegVal;
        REGSUBDEF* SubDef = RegSubDefFromIndex(SubReg);

        if (!SubDef) 
        {
            return 0;
        }

        RegVal.i64 = 0;
        GetVal(SubDef->fullreg, &RegVal);
        return (ULONG)((RegVal.i64 >> SubDef->shift) & SubDef->mask);
    }

    // Helper function to initialize an ADDR given a flat
    // offset from a known segment or segment register.
    void FormAddr(ULONG SegOrReg, ULONG64 Off, ULONG Flags,
                  PADDR Address);

protected:
    TRACEMODE m_TraceMode;

    // KdSave/Restore state.
    ULONG m_SavedContextState;
    CROSS_PLATFORM_CONTEXT m_SavedContext;

    // Common helpers for disassembly.
    PCHAR m_Buf, m_BufStart;
    
    void BufferHex(ULONG64 Value, ULONG Length, BOOL Signed);
    void BufferBlanks(ULONG BufferPos);
    void BufferString(PCSTR String);

    void PrintMultiPtrTitle(const CHAR* Title, USHORT PtrNum);
};

// Effective machine settings.
extern ULONG g_EffMachine;
extern MachineIndex g_EffMachineIndex;
extern MachineInfo* g_Machine;

// Target machine settings.
extern MachineInfo* g_TargetMachine;

extern MachineInfo* g_AllMachines[];

HRESULT InitializeMachines(ULONG TargetMachine);
MachineIndex MachineTypeIndex(ULONG Machine);

// g_AllMachines has a NULL at MACHIDX_COUNT to handle errors.
#define MachineTypeInfo(Machine) g_AllMachines[MachineTypeIndex(Machine)]

void CacheReportInstructions(ULONG64 Pc, ULONG Count, PUCHAR Stream);
void FlushMachinePerExecutionCaches(void);

extern CHAR g_F0[], g_F1[], g_F2[], g_F3[], g_F4[], g_F5[];
extern CHAR g_F6[], g_F7[], g_F8[], g_F9[], g_F10[], g_F11[];
extern CHAR g_F12[], g_F13[], g_F14[], g_F15[], g_F16[], g_F17[];
extern CHAR g_F18[], g_F19[], g_F20[], g_F21[], g_F22[], g_F23[];
extern CHAR g_F24[], g_F25[], g_F26[], g_F27[], g_F28[], g_F29[];
extern CHAR g_F30[], g_F31[];

extern CHAR g_R0[], g_R1[], g_R2[], g_R3[], g_R4[], g_R5[];
extern CHAR g_R6[], g_R7[], g_R8[], g_R9[], g_R10[], g_R11[];
extern CHAR g_R12[], g_R13[], g_R14[], g_R15[], g_R16[], g_R17[];
extern CHAR g_R18[], g_R19[], g_R20[], g_R21[], g_R22[], g_R23[];
extern CHAR g_R24[], g_R25[], g_R26[], g_R27[], g_R28[], g_R29[];
extern CHAR g_R30[], g_R31[];

#endif // #ifndef __MACHINE_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\makefile.inc ===
$O\dbgeng_p.hpp $O\dbgeng_p.cpp $O\dbgeng_s.hpp $O\dbgeng_s.cpp: \
            ..\published\dbgeng.w ..\dbg-common\rremgen.pl
        perl ..\dbg-common\rremgen.pl -g $O ..\published\dbgeng.w
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\machine.cpp ===
//----------------------------------------------------------------------------
//
// Abstraction of processor-specific information.
//
// Copyright (C) Microsoft Corporation, 1999-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

ULONG g_EffMachine = IMAGE_FILE_MACHINE_UNKNOWN;
MachineIndex g_EffMachineIndex = MACHIDX_COUNT;
MachineInfo* g_Machine = NULL;

MachineInfo* g_TargetMachine;

// Leave one extra slot at the end so indexing
// MACHIDX_COUNT returns NULL for the undefined case.
MachineInfo* g_AllMachines[MACHIDX_COUNT + 1];

// TRUE when symbol prefixing should be done.
BOOL g_PrefixSymbols;

// TRUE if context changed while processing
BOOL g_ContextChanged;

DEBUG_PROCESSOR_IDENTIFICATION_ALL g_InitProcessorId;

//----------------------------------------------------------------------------
//
// MachineInfo.
//
//----------------------------------------------------------------------------

HRESULT
MachineInfo::InitializeConstants(void)
{
    m_TraceMode = TRACE_NONE;

    m_ContextState = MCTX_NONE;
    m_ContextIsReadOnly = FALSE;

    m_NumberRegs = 0;
    // Every machine supports basic integer and FP registers.
    m_AllMaskBits = DEBUG_REGISTERS_ALL;

    m_SymPrefixLen = m_SymPrefix != NULL ? strlen(m_SymPrefix) : 0;

    ZeroMemory(m_PageDirectories, sizeof(m_PageDirectories));
    m_Translating = FALSE;

    ULONG i;

    for (i = 0; i < SEGREG_COUNT; i++)
    {
        m_SegRegDesc[i].Flags = SEGDESC_INVALID;
    }

    return S_OK;
}

HRESULT
MachineInfo::InitializeForTarget(void)
{
    InitializeContextFlags(&m_Context, m_SverCanonicalContext);
    return S_OK;
}

HRESULT
MachineInfo::InitializeForProcessor(void)
{
    DBG_ASSERT(m_MaxDataBreakpoints <= MAX_DATA_BREAKS);

    // Count register definitions.
    RegisterGroup* Group;

    for (Group = m_Groups; Group != NULL; Group = Group->Next)
    {
        Group->NumberRegs = 0;

        REGDEF* Def = Group->Regs;
        while (Def->psz != NULL)
        {
            Group->NumberRegs++;
            Def++;
        }

        m_NumberRegs += Group->NumberRegs;

        REGALLDESC* Desc = Group->AllExtraDesc;
        if (Desc != NULL)
        {
            while (Desc->Bit != 0)
            {
                m_AllMaskBits |= Desc->Bit;
                Desc++;
            }
        }
    }

    return S_OK;
}

HRESULT
MachineInfo::GetContextState(ULONG State)
{
    if (g_RegContextThread == NULL)
    {
        // No error message here as this can get hit during
        // Reload("NT") initialization when accessing paged-out memory.
        // It's also noisy in other failure cases, so rely
        // on higher-level error output.
        return E_UNEXPECTED;
    }
    
    if (State == MCTX_DIRTY) 
    {
        g_ContextChanged = TRUE;
    }

    if (m_ContextState >= State)
    {
        return S_OK;
    }

    HRESULT Status = E_UNEXPECTED;

    // Dump support is built into the Ud/Kd routines.
    if (IS_USER_TARGET())
    {
        Status = UdGetContextState(State);
    }
    else if (IS_KERNEL_TARGET())
    {
        Status = KdGetContextState(State);
    }

    if (Status != S_OK)
    {
        ErrOut("GetContextState failed, 0x%X\n", Status);
        return Status;
    }

    if (State == MCTX_DIRTY)
    {
        DBG_ASSERT(m_ContextState >= MCTX_FULL);
        m_ContextState = State;
    }

    DBG_ASSERT(State <= m_ContextState);
    return S_OK;
}

HRESULT
MachineInfo::SetContext(void)
{
    if (m_ContextState != MCTX_DIRTY)
    {
        // Nothing to write.
        return S_OK;
    }

    if (g_RegContextThread == NULL)
    {
        ErrOut("No current thread in SetContext\n");
        return E_UNEXPECTED;
    }

    if (m_ContextIsReadOnly)
    {
        ErrOut("Context cannot be modified\n");
        return E_UNEXPECTED;
    }

    HRESULT Status = E_UNEXPECTED;

    if (IS_DUMP_TARGET())
    {
        ErrOut("Can't set dump file contexts\n");
        return E_UNEXPECTED;
    }
    else if (IS_USER_TARGET())
    {
        Status = UdSetContext();
    }
    else if (IS_KERNEL_TARGET())
    {
        Status = KdSetContext();
    }

    if (Status != S_OK)
    {
        ErrOut("SetContext failed, 0x%X\n", Status);
        return Status;
    }

    // No longer dirty.
    m_ContextState = MCTX_FULL;
    return S_OK;
}

HRESULT
MachineInfo::UdGetContextState(ULONG State)
{
    // MCTX_CONTEXT and MCTX_FULL are the same in user mode.
    if (State >= MCTX_CONTEXT && m_ContextState < MCTX_FULL)
    {
        HRESULT Status = g_Target->GetContext(g_RegContextThread->Handle,
                                              &m_Context);
        if (Status != S_OK)
        {
            return Status;
        }

        Status = g_Target->GetTargetSegRegDescriptors
            (g_RegContextThread->Handle, 0, SEGREG_COUNT, m_SegRegDesc);
        if (Status != S_OK)
        {
            return Status;
        }

        m_ContextState = MCTX_FULL;
    }

    return S_OK;
}

HRESULT
MachineInfo::UdSetContext(void)
{
    return g_Target->SetContext(g_RegContextThread->Handle, &m_Context);
}

void
MachineInfo::InvalidateContext(void)
{
    m_ContextState = MCTX_NONE;
    g_Target->InvalidateTargetContext();

    ULONG i;

    for (i = 0; i < SEGREG_COUNT; i++)
    {
        m_SegRegDesc[i].Flags = SEGDESC_INVALID;
    }
}

HRESULT
MachineInfo::GetExdiContext(IUnknown* Exdi, PEXDI_CONTEXT Context)
{
    return E_NOTIMPL;
}

HRESULT
MachineInfo::SetExdiContext(IUnknown* Exdi, PEXDI_CONTEXT Context)
{
    return E_NOTIMPL;
}

void
MachineInfo::ConvertExdiContextFromContext(PCROSS_PLATFORM_CONTEXT Context,
                                           PEXDI_CONTEXT ExdiContext)
{
    // Nothing to do.
}

void
MachineInfo::ConvertExdiContextToContext(PEXDI_CONTEXT ExdiContext,
                                         PCROSS_PLATFORM_CONTEXT Context)
{
    // Nothing to do.
}

void
MachineInfo::ConvertExdiContextToSegDescs(PEXDI_CONTEXT ExdiContext,
                                          ULONG Start, ULONG Count,
                                          PDESCRIPTOR64 Descs)
{
    // Nothing to do.
}

void
MachineInfo::ConvertExdiContextFromSpecial
    (PCROSS_PLATFORM_KSPECIAL_REGISTERS Special,
     PEXDI_CONTEXT ExdiContext)
{
    // Nothing to do.
}

void
MachineInfo::ConvertExdiContextToSpecial
    (PEXDI_CONTEXT ExdiContext,
     PCROSS_PLATFORM_KSPECIAL_REGISTERS Special)
{
    // Nothing to do.
}

ULONG
MachineInfo::GetSegRegNum(ULONG SegReg)
{
    return 0;
}

HRESULT
MachineInfo::GetSegRegDescriptor(ULONG SegReg, PDESCRIPTOR64 Desc)
{
    return E_UNEXPECTED;
}

void
MachineInfo::KdUpdateControlSet(PDBGKD_ANY_CONTROL_SET ControlSet)
{
    // Nothing to do.
}

void
MachineInfo::KdSaveProcessorState(
    void
    )
{
    m_SavedContext = m_Context;
    m_SavedContextState = m_ContextState;
    memcpy(m_SavedSegRegDesc, m_SegRegDesc, sizeof(m_SegRegDesc));
    m_ContextState = MCTX_NONE;
    g_Target->InvalidateTargetContext();
}

void
MachineInfo::KdRestoreProcessorState(
    void
    )
{
    DBG_ASSERT(m_ContextState != MCTX_DIRTY);
    m_Context = m_SavedContext;
    m_ContextState = m_SavedContextState;
    memcpy(m_SegRegDesc, m_SavedSegRegDesc, sizeof(m_SegRegDesc));
    g_Target->InvalidateTargetContext();
}

HRESULT
MachineInfo::SetDefaultPageDirectories(ULONG Mask)
{
    HRESULT Status;
    ULONG i;
    ULONG64 OldDirs[PAGE_DIR_COUNT];

    memcpy(OldDirs, m_PageDirectories, sizeof(m_PageDirectories));
    i = 0;
    while (i < PAGE_DIR_COUNT)
    {
        // Pass on the set to machine-specific code.
        if (Mask & (1 << i))
        {
            if ((Status = SetPageDirectory(i, 0, &i)) != S_OK)
            {
                memcpy(m_PageDirectories, OldDirs, sizeof(m_PageDirectories));
                return Status;
            }
        }
        else
        {
            i++;
        }
    }
    
    // Try and validate that the new kernel page directory is
    // valid by checking an address that should always
    // be available.
    if ((Mask & (1 << PAGE_DIR_KERNEL)) &&
        IS_KERNEL_TARGET() && KdDebuggerData.PsLoadedModuleList)
    {
        LIST_ENTRY64 List;
            
        if ((Status = g_Target->
             ReadListEntry(this, KdDebuggerData.PsLoadedModuleList,
                           &List)) != S_OK)
        {
            // This page directory doesn't seem valid so restore
            // the previous setting and fail.
            memcpy(m_PageDirectories, OldDirs, sizeof(m_PageDirectories));
        }
    }

    return Status;
}

HRESULT
MachineInfo::NewBreakpoint(DebugClient* Client, 
                           ULONG Type,
                           ULONG Id,
                           Breakpoint** RetBp)
{
    return E_NOINTERFACE;
}

void
MachineInfo::InsertAllDataBreakpoints(void)
{
    // Nothing to do.
}

void
MachineInfo::RemoveAllDataBreakpoints(void)
{
    // Nothing to do.
}

ULONG
MachineInfo::IsBreakpointOrStepException(PEXCEPTION_RECORD64 Record,
                                         ULONG FirstChance,
                                         PADDR BpAddr,
                                         PADDR RelAddr)
{
    return Record->ExceptionCode == STATUS_BREAKPOINT ?
        EXBS_BREAKPOINT_ANY : EXBS_NONE;
}

void
MachineInfo::GetRetAddr(PADDR Addr)
{
    DEBUG_STACK_FRAME StackFrame;

    if (StackTrace(0, 0, 0, &StackFrame, 1, 0, 0, FALSE) > 0)
    {
        ADDRFLAT(Addr, StackFrame.ReturnOffset);
    }
    else
    {
        ErrOut("StackTrace failed\n");
        ADDRFLAT(Addr, 0);
    }
}

BOOL
MachineInfo::GetPrefixedSymbolOffset(ULONG64 SymOffset,
                                     ULONG Flags,
                                     PULONG64 PrefixedSymOffset)
{
    DBG_ASSERT(m_SymPrefix == NULL);
    // This routine should never be called since there's no prefix.
    return FALSE;
}
 
HRESULT
MachineInfo::ReadDynamicFunctionTable(ULONG64 Table,
                                      PULONG64 NextTable,
                                      PULONG64 MinAddress,
                                      PULONG64 MaxAddress,
                                      PULONG64 BaseAddress,
                                      PULONG64 TableData,
                                      PULONG TableSize,
                                      PWSTR OutOfProcessDll,
                                      PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE RawTable)
{
    // No dynamic function table support.
    return E_UNEXPECTED;
}

PVOID
MachineInfo::FindDynamicFunctionEntry(PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE Table,
                                      ULONG64 Address,
                                      PVOID TableData,
                                      ULONG TableSize)
{
    // No dynamic function tables so no match.
    return NULL;
}

void
MachineInfo::FlushPerExecutionCaches(void)
{
    ZeroMemory(m_PageDirectories, sizeof(m_PageDirectories));
    m_Translating = FALSE;
}

void
MachineInfo::FormAddr(ULONG SegOrReg, ULONG64 Off,
                      ULONG Flags, PADDR Address)
{
    PDESCRIPTOR64 SegDesc = NULL;
    DESCRIPTOR64 Desc;

    Address->off = Off;

    if (Flags & FORM_SEGREG)
    {
        ULONG SegRegNum = GetSegRegNum(SegOrReg);
        if (SegRegNum)
        {
            Address->seg = GetReg16(SegRegNum);
        }
        else
        {
            Address->seg = 0;
        }
    }
    else
    {
        Address->seg = (USHORT)SegOrReg;
    }
    
    if (Flags & FORM_VM86)
    {
        Address->type = ADDR_V86;
    }
    else if (Address->seg == 0)
    {
        // A segment wasn't used or segmentation doesn't exist.
        Address->type = ADDR_FLAT;
    }
    else
    {
        HRESULT Status;
        
        if (Flags & FORM_SEGREG)
        {
            Status = GetSegRegDescriptor(SegOrReg, &Desc);
        }
        else
        {
            Status = g_Target->
                GetSelDescriptor(this, g_CurrentProcess->CurrentThread->Handle,
                                 SegOrReg, &Desc);
        }

        if (Status == S_OK)
        {
            static USHORT MainCodeSeg = 0;

            SegDesc = &Desc;
            if (((Flags & FORM_CODE) && (Desc.Flags & X86_DESC_LONG_MODE)) ||
                ((Flags & FORM_CODE) == 0 && g_Amd64InCode64))
            {
                Address->type = ADDR_1664;
            }
            else if (Desc.Flags & X86_DESC_DEFAULT_BIG)
            {
                Address->type = ADDR_1632;
            }
            else
            {
                Address->type = ADDR_16;
            }
            if ((Flags & FORM_CODE) &&
                ((g_EffMachine == IMAGE_FILE_MACHINE_I386 &&
                  Address->type == ADDR_1632) ||
                 (g_EffMachine == IMAGE_FILE_MACHINE_AMD64 &&
                  Address->type == ADDR_1664)))
            {
                if ( MainCodeSeg == 0 )
                {
                    if ( Desc.Base == 0 )
                    {
                        MainCodeSeg = Address->seg;
                    }
                }
                if ( Address->seg == MainCodeSeg )
                {
                    Address->type = ADDR_FLAT;
                }
            }
        }
        else
        {
            Address->type = ADDR_16;
        }
    }
    
    ComputeFlatAddress(Address, SegDesc);
}

void 
MachineInfo::PrintStackFrameAddressesTitle(ULONG Flags)
{
    if (!(Flags & DEBUG_STACK_FRAME_ADDRESSES_RA_ONLY))
    {
        PrintMultiPtrTitle("Child-SP", 1);
    }
    PrintMultiPtrTitle("RetAddr", 1);
}

void 
MachineInfo::PrintStackFrameAddresses(ULONG Flags, 
                                      PDEBUG_STACK_FRAME StackFrame)
{
    if (!(Flags & DEBUG_STACK_FRAME_ADDRESSES_RA_ONLY))
    {
        dprintf("%s ", FormatAddr64(StackFrame->StackOffset));
    }

    dprintf("%s ", FormatAddr64(StackFrame->ReturnOffset));
}

void 
MachineInfo::PrintStackArgumentsTitle(ULONG Flags) 
{
    dprintf(": ");
    PrintMultiPtrTitle("Args to Child", 4);
    dprintf(": ");
}

void 
MachineInfo::PrintStackArguments(ULONG Flags, 
                                 PDEBUG_STACK_FRAME StackFrame)
{
    dprintf(": %s %s %s %s : ",
            FormatAddr64(StackFrame->Params[0]),
            FormatAddr64(StackFrame->Params[1]),
            FormatAddr64(StackFrame->Params[2]),
            FormatAddr64(StackFrame->Params[3]));
}

void 
MachineInfo::PrintStackCallSiteTitle(ULONG Flags)
{
    dprintf("Call Site");
}

void 
MachineInfo::PrintStackCallSite(ULONG Flags, 
                                PDEBUG_STACK_FRAME StackFrame, 
                                CHAR SymBuf[], 
                                DWORD64 Displacement,
                                USHORT StdCallArgs)
{
    if (*SymBuf)
    {
        dprintf("%s", SymBuf);
        if (!(Flags & DEBUG_STACK_PARAMETERS) || 
            !ShowFunctionParameters(StackFrame, SymBuf, Displacement)) 
        {
            // We dont see the parameters
        }

        if (Displacement)
        {
            dprintf("+");
        }
    }
    if (Displacement || !*SymBuf)
    {
        dprintf("0x%s", FormatDisp64(Displacement));
    }
}

void 
MachineInfo::PrintStackNonvolatileRegisters(ULONG Flags, 
                                            PDEBUG_STACK_FRAME StackFrame,
                                            PCROSS_PLATFORM_CONTEXT Context,
                                            ULONG FrameNum)
{
    // Empty base implementation.
}

//----------------------------------------------------------------------------
//
// Functions.
//
//----------------------------------------------------------------------------

HRESULT
InitializeMachines(ULONG TargetMachine)
{
    HRESULT Status;
    ULONG i;

    if (DbgKdApi64 != (g_SystemVersion > NT_SVER_NT4))
    {
        WarnOut("Debug API version does not match system version\n");
    }

    if (IsImageMachineType64(TargetMachine) && !DbgKdApi64)
    {
        WarnOut("64-bit machine not using 64-bit API\n");
    }

    memset(g_AllMachines, 0, sizeof(g_AllMachines));

    // There are several different X86 machines due to
    // the emulations available on various systems and CPUs.
    switch(TargetMachine)
    {
    case IMAGE_FILE_MACHINE_IA64:
        g_AllMachines[MACHIDX_I386] = &g_X86OnIa64Machine;
        break;
    default:
        g_AllMachines[MACHIDX_I386] = &g_X86Machine;
        break;
    }

    g_AllMachines[MACHIDX_ALPHA] = &g_Axp32Machine;
    g_AllMachines[MACHIDX_AXP64] = &g_Axp64Machine;
    g_AllMachines[MACHIDX_IA64] = &g_Ia64Machine;
    g_AllMachines[MACHIDX_AMD64] = &g_Amd64Machine;
    g_TargetMachineType = TargetMachine;
    g_TargetMachine = MachineTypeInfo(TargetMachine);

    ZeroMemory(&g_InitProcessorId, sizeof(g_InitProcessorId));
    
    for (i = 0; i < MACHIDX_COUNT; i++)
    {
        DBG_ASSERT(g_AllMachines[i] != NULL);

        if ((Status = g_AllMachines[i]->InitializeConstants()) != S_OK)
        {
            return Status;
        }
    }

    if (!IS_TARGET_SET())
    {
        return S_OK;
    }
    
    for (i = 0; i < MACHIDX_COUNT; i++)
    {
        if ((Status = g_AllMachines[i]->InitializeForTarget()) != S_OK)
        {
            return Status;
        }
    }

    if (g_TargetMachineType == IMAGE_FILE_MACHINE_UNKNOWN)
    {
        return S_OK;
    }
    
    // Get the base processor ID for determing what
    // kind of features a processor supports.  The
    // assumption is that the processors in a machine
    // will be similar enough that retrieving this
    // for one processor is sufficient.
    // If this fails we continue on without a processor ID.

    if (!IS_DUMP_TARGET())
    {
        g_Target->GetProcessorId(0, &g_InitProcessorId);
    }
    
    for (i = 0; i < MACHIDX_COUNT; i++)
    {
        if ((Status = g_AllMachines[i]->InitializeForProcessor()) != S_OK)
        {
            return Status;
        }
    }

    return S_OK;
}

void
SetEffMachine(ULONG Machine, BOOL Notify)
{
    BOOL Changed = g_EffMachine != Machine;
    if (Changed &&
        g_EffMachine != IMAGE_FILE_MACHINE_UNKNOWN &&
        g_EffMachine != g_TargetMachineType)
    {
        // If the previous machine was not the target machine
        // it may be an emulated machine that uses the
        // target machine's context.  In that case we need to
        // make sure that any dirty registers it has get flushed
        // so that if the new effective machine is the target
        // machine it'll show changes due to changes through
        // the emulated machine.
        if (g_Machine->SetContext() != S_OK)
        {
            // Error already displayed.
            return;
        }
    }

    g_EffMachine = Machine;
    g_EffMachineIndex = MachineTypeIndex(Machine);
    DBG_ASSERT(g_EffMachineIndex <= MACHIDX_COUNT);
    g_Machine = g_AllMachines[g_EffMachineIndex];

    if (Changed && Notify)
    {
        NotifyChangeEngineState(DEBUG_CES_EFFECTIVE_PROCESSOR,
                                g_EffMachine, TRUE);
    }
}

MachineIndex
MachineTypeIndex(ULONG Machine)
{
    switch(Machine)
    {
    case IMAGE_FILE_MACHINE_I386:
        return MACHIDX_I386;
    case IMAGE_FILE_MACHINE_ALPHA:
        return MACHIDX_ALPHA;
    case IMAGE_FILE_MACHINE_AXP64:
        return MACHIDX_AXP64;
    case IMAGE_FILE_MACHINE_IA64:
        return MACHIDX_IA64;
    case IMAGE_FILE_MACHINE_AMD64:
        return MACHIDX_AMD64;
    default:
        return MACHIDX_COUNT;
    }
}

void
CacheReportInstructions(ULONG64 Pc, ULONG Count, PUCHAR Stream)
{
    // There was a long-standing bug in the kernel
    // where it didn't properly remove all breakpoints
    // present in the instruction stream reported to
    // the debugger.  If this kernel suffers from the
    // problem just ignore the stream contents.
    if (Count == 0 || g_TargetBuildNumber < 2300)
    {
        return;
    }

    g_VirtualCache.Add(Pc, Stream, Count);
}

void
FlushMachinePerExecutionCaches(void)
{
    ULONG i;

    for (i = 0; i < MACHIDX_COUNT; i++)
    {
        g_AllMachines[i]->FlushPerExecutionCaches();
    }
}

//----------------------------------------------------------------------------
//
// Common code and constants.
//
//----------------------------------------------------------------------------

/* OutputHex - output hex value
*
*   Purpose:
*       Output the value in outvalue into the buffer
*       pointed by *pBuf.  The value may be signed
*       or unsigned depending on the value fSigned.
*
*   Input:
*       outvalue - value to output
*       length - length in digits
*       fSigned - TRUE if signed else FALSE
*
*   Output:
*       None.
*
***********************************************************************/

UCHAR g_HexDigit[16] =
{
    '0', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
};

void
MachineInfo::BufferHex (
    ULONG64 outvalue,
    ULONG length,
    BOOL  fSigned
    )
{
    UCHAR   digit[32];
    LONG    index = 0;

    DBG_ASSERT(length <= 32);

    if (fSigned && (LONGLONG)outvalue < 0)
    {
        *m_Buf++ = '-';
        outvalue = - (LONGLONG)outvalue;
    }

    do
    {
        digit[index++] = g_HexDigit[outvalue & 0xf];
        outvalue >>= 4;
    }
    while ((fSigned && outvalue) || (!fSigned && index < (LONG)length));

    while (--index >= 0)
    {
        *m_Buf++ = digit[index];
    }
}

/* BlankFill - blank-fill buffer
*
*   Purpose:
*       To fill the buffer at *pBuf with blanks until
*       position count is reached.
*
*   Input:
*       None.
*
*   Output:
*       None.
*
***********************************************************************/

void
MachineInfo::BufferBlanks(ULONG count)
{
    do
    {
        *m_Buf++ = ' ';
    }
    while (m_Buf < m_BufStart + count);
}


/* OutputString - output string
*
*   Purpose:
*       Copy the string into the buffer pointed by pBuf.
*
*   Input:
*       *pStr - pointer to string
*
*   Output:
*       None.
*
***********************************************************************/

void
MachineInfo::BufferString(PCSTR String)
{
    while (*String)
    {
        *m_Buf++ = *String++;
    }
}

void 
MachineInfo::PrintMultiPtrTitle(const CHAR* Title, USHORT PtrNum)
{
    size_t PtrLen = (strlen(FormatAddr64(0)) + 1) * PtrNum;
    size_t TitleLen = strlen(Title);

    if (PtrLen < TitleLen)
    {
        // Extremly rare case so keep it simple while slow
        for (size_t i = 0; i < PtrLen - 1; ++i) 
        {
            dprintf("%c", Title[i]);
        }
        dprintf(" ");
    }
    else 
    {
        dprintf(Title);

        if (PtrLen > TitleLen) 
        {
            char Format[16];
            _snprintf(Format, sizeof(Format) - 1, 
                      "%% %ds", PtrLen - TitleLen);
            dprintf(Format, "");
        }
    }
}

CHAR g_F0[]  = "f0";
CHAR g_F1[]  = "f1";
CHAR g_F2[]  = "f2";
CHAR g_F3[]  = "f3";
CHAR g_F4[]  = "f4";
CHAR g_F5[]  = "f5";
CHAR g_F6[]  = "f6";
CHAR g_F7[]  = "f7";
CHAR g_F8[]  = "f8";
CHAR g_F9[]  = "f9";
CHAR g_F10[] = "f10";
CHAR g_F11[] = "f11";
CHAR g_F12[] = "f12";
CHAR g_F13[] = "f13";
CHAR g_F14[] = "f14";
CHAR g_F15[] = "f15";
CHAR g_F16[] = "f16";
CHAR g_F17[] = "f17";
CHAR g_F18[] = "f18";
CHAR g_F19[] = "f19";
CHAR g_F20[] = "f20";
CHAR g_F21[] = "f21";
CHAR g_F22[] = "f22";
CHAR g_F23[] = "f23";
CHAR g_F24[] = "f24";
CHAR g_F25[] = "f25";
CHAR g_F26[] = "f26";
CHAR g_F27[] = "f27";
CHAR g_F28[] = "f28";
CHAR g_F29[] = "f29";
CHAR g_F30[] = "f30";
CHAR g_F31[] = "f31";

CHAR g_R0[]  = "r0";
CHAR g_R1[]  = "r1";
CHAR g_R2[]  = "r2";
CHAR g_R3[]  = "r3";
CHAR g_R4[]  = "r4";
CHAR g_R5[]  = "r5";
CHAR g_R6[]  = "r6";
CHAR g_R7[]  = "r7";
CHAR g_R8[]  = "r8";
CHAR g_R9[]  = "r9";
CHAR g_R10[] = "r10";
CHAR g_R11[] = "r11";
CHAR g_R12[] = "r12";
CHAR g_R13[] = "r13";
CHAR g_R14[] = "r14";
CHAR g_R15[] = "r15";
CHAR g_R16[] = "r16";
CHAR g_R17[] = "r17";
CHAR g_R18[] = "r18";
CHAR g_R19[] = "r19";
CHAR g_R20[] = "r20";
CHAR g_R21[] = "r21";
CHAR g_R22[] = "r22";
CHAR g_R23[] = "r23";
CHAR g_R24[] = "r24";
CHAR g_R25[] = "r25";
CHAR g_R26[] = "r26";
CHAR g_R27[] = "r27";
CHAR g_R28[] = "r28";
CHAR g_R29[] = "r29";
CHAR g_R30[] = "r30";
CHAR g_R31[] = "r31";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\instr.cpp ===
//----------------------------------------------------------------------------
//
// Functions dealing with instructions, such as assembly or disassembly.
//
// Copyright (C) Microsoft Corporation, 1997-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

static ULONG64 s_igrepSearchStartAddress = 0L;
static ULONG64 s_igrepLastPc;
static CHAR s_igrepLastPattern[256];

ULONG g_AsmOptions;

// This array must be in ASMOPT bit order.
PCSTR g_AsmOptionNames[] =
{
    "verbose"
};

void ChangeAsmOptions(BOOL Set, PSTR Args)
{
    ULONG Flags = 0;
    PSTR Arg;
    ULONG i;
    
    for (;;)
    {
        //
        // Parse out a single flag argument.
        //
        
        while (isspace(*Args))
        {
            *Args++;
        }
        if (*Args == 0)
        {
            break;
        }
        
        Arg = Args;
        
        while (*Args && !isspace(*Args))
        {
            Args++;
        }
        if (isspace(*Args))
        {
            *Args++ = 0;
        }

        //
        // Find value for argument.
        //

        for (i = 0; i < DIMA(g_AsmOptionNames); i++)
        {
            if (!_stricmp(Arg, g_AsmOptionNames[i]))
            {
                break;
            }
        }
        if (i < DIMA(g_AsmOptionNames))
        {
            Flags |= 1 << i;
        }
        else
        {
            ErrOut("Unknown assembly option '%s'\n", Arg);
        }
    }

    if (Set)
    {
        g_AsmOptions |= Flags;
    }
    else
    {
        g_AsmOptions &= ~Flags;
    }

    dprintf("Assembly options:");
    if (g_AsmOptions == 0)
    {
        dprintf(" <default>\n");
    }
    else
    {
        for (i = 0; i < DIMA(g_AsmOptionNames); i++)
        {
            if (g_AsmOptions & (1 << i))
            {
                dprintf(" %s", g_AsmOptionNames[i]);
            }
        }
        dprintf("\n");
    }
}

void igrep (void)
{
    ULONG64 dwNextGrepAddr;
    ULONG64 dwCurrGrepAddr;
    CHAR SourceLine[MAX_DISASM_LEN];
    BOOL NewPc;
    ULONG64 d;
    PCHAR pc = g_CurCmd;
    PCHAR Pattern;
    PCHAR Expression;
    CHAR Symbol[MAX_SYMBOL_LEN];
    ULONG64 Displacement;
    ADDR TempAddr;
    ULONG64 dwCurrentPc;

    g_Machine->GetPC(&TempAddr);
    dwCurrentPc = Flat(TempAddr);
    if ( s_igrepLastPc && s_igrepLastPc == dwCurrentPc )
    {
        NewPc = FALSE;
    }
    else
    {
        s_igrepLastPc = dwCurrentPc;
        NewPc = TRUE;
    }

    //
    // check for pattern.
    //

    Pattern = NULL;
    Expression = NULL;
    if (*pc)
    {
        while (*pc <= ' ')
        {
            pc++;
        }
        Pattern = pc;
        while (*pc > ' ')
        {
            pc++;
        }

        //
        // check for an expression
        //

        if (*pc != '\0')
        {
            *pc = '\0';
            pc++;
            if (*pc <= ' ')
            {
                while (*pc <= ' ')
                {
                    pc++;
                }
            }
            if (*pc)
            {
                Expression = pc;
            }
        }
    }

    if (Pattern)
    {
        for (pc = Pattern; *pc; pc++)
        {
            *pc = (CHAR)toupper(*pc);
        }
        s_igrepLastPattern[0] = '*';
        strcpy(s_igrepLastPattern + 1, Pattern);
        if (Pattern[0] == '*')
        {
            strcpy(s_igrepLastPattern, Pattern);
        }
        if (Pattern[strlen(Pattern)] != '*')
        {
            strcat(s_igrepLastPattern, "*");
        }
    }

    if (Expression)
    {
        s_igrepSearchStartAddress = ExtGetExpression(Expression);
    }
    if (!s_igrepSearchStartAddress)
    {
        dprintf("Search address set to %s\n", FormatAddr64(s_igrepLastPc));
        s_igrepSearchStartAddress = s_igrepLastPc;
        return;
    }
    
    dwNextGrepAddr = s_igrepSearchStartAddress;
    dwCurrGrepAddr = dwNextGrepAddr;

    d = ExtDisasm(&dwNextGrepAddr, SourceLine, FALSE);
    while (d)
    {
        for (pc = SourceLine; *pc; pc++)
        {
            *pc = (CHAR)tolower(*pc);
        }
        if (MatchPattern(SourceLine, s_igrepLastPattern))
        {
            g_LastExpressionValue = dwCurrGrepAddr;
            s_igrepSearchStartAddress = dwNextGrepAddr;
            GetSymbolStdCall(dwCurrGrepAddr, Symbol, sizeof(Symbol),
                             &Displacement, NULL);
            ExtDisasm(&dwCurrGrepAddr, SourceLine, FALSE);
            dprintf("%s", SourceLine);
            return;
        }

        if (CheckUserInterrupt())
        {
            return;
        }

        dwCurrGrepAddr = dwNextGrepAddr;
        d = ExtDisasm(&dwNextGrepAddr, SourceLine, FALSE);
    }
}

/*** fnAssemble - interactive assembly routine
*
*   Purpose:
*       Function of "a <range>" command.
*
*       Prompt the user with successive assembly addresses until
*       a blank line is input.  Assembly errors do not abort the
*       function, but the prompt is output again for a retry.
*       The variables g_CommandStart, g_CurCmd, and cbPrompt
*       are set to make a local error context and restored on routine
*       exit.
*
*   Input:
*       *addr - starting address for assembly
*
*   Output:
*       *addr - address after the last assembled instruction.
*
*   Notes:
*       all error processing is local, no errors are returned.
*
*************************************************************************/

void
TryAssemble(PADDR paddr)
{
    char Assemble[MAX_DISASM_LEN];

    //
    // Set local prompt and command.
    //

    g_CommandStart = Assemble;
    g_CurCmd = Assemble;
    g_PromptLength = 9;

    Assemble[0] = '\0';

    while (TRUE)
    {
        char ch;
        
        dprintAddr(paddr);
        GetInput("", Assemble, sizeof(Assemble));
        g_CurCmd = Assemble;
        RemoveDelChar(g_CurCmd);
        do
        {
            ch = *g_CurCmd++;
        }
        while (ch == ' ' || ch == '\t');
        if (ch == '\0')
        {
            break;
        }
        g_CurCmd--;

        assert(fFlat(*paddr) || fInstrPtr(*paddr));
        g_Machine->Assemble(paddr, g_CurCmd);
    }
}

void
fnAssemble(PADDR paddr)
{
    //
    // Save present prompt and command.
    //

    PSTR    StartSave = g_CommandStart;   //  saved start of cmd buffer
    PSTR    CommandSave = g_CurCmd;       //  current ptr in cmd buffer
    ULONG   PromptSave = g_PromptLength;  //  size of prompt string
    BOOL    Done = FALSE;

    while (!Done)
    {
        __try
        {
            TryAssemble(paddr);

            // If assembly returned normally we're done.
            Done = TRUE;
        }
        __except(CommandExceptionFilter(GetExceptionInformation()))
        {
            // If illegal input was encountered keep looping.
        }
    }

    //
    // Restore entry prompt and command.
    //

    g_CommandStart = StartSave;
    g_CurCmd = CommandSave;
    g_PromptLength = PromptSave;
}

/*** fnUnassemble - disassembly of an address range
*
*   Purpose:
*       Function of "u<range>" command.
*
*       Output the disassembly of the instruction in the given
*       address range.  Since some processors have variable
*       instruction lengths, use fLength value to determine if
*       instruction count or inclusive range should be used.
*
*   Input:
*       *addr - pointer to starting address to disassemble
*       value - if fLength = TRUE, count of instructions to output
*               if fLength = FALSE, ending address of inclusive range
*
*   Output:
*       *addr - address after last instruction disassembled
*
*   Exceptions:
*       error exit: MEMORY - memory access error
*
*   Notes:
*
*************************************************************************/

void
fnUnassemble (
    PADDR Addr,
    ULONG64 Value,
    BOOL Length
    )
{
    if (!IS_MACHINE_ACCESSIBLE())
    {
        error(BADTHREAD);
    }
    
    CHAR    Buffer[MAX_DISASM_LEN];
    BOOL    Status;
    ADDR    EndAddr;
    ULONG   SymAddrFlags = SYMADDR_FORCE | SYMADDR_LABEL | SYMADDR_SOURCE;

    Flat(EndAddr) = Value;

    while ((Length && Value--) || (!Length && AddrLt(*Addr, EndAddr)))
    {
        OutputSymAddr(Flat(*Addr), SymAddrFlags);
        Status = g_Machine->Disassemble(Addr, Buffer, FALSE);
        dprintf("%s", Buffer);
        if (!Status)
        {
            error(MEMORY);
        }

        SymAddrFlags &= ~SYMADDR_FORCE;

        if (CheckUserInterrupt())
        {
            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\mcache.hpp ===
//----------------------------------------------------------------------------
//
// Memory cache object.
//
// Copyright (C) Microsoft Corporation, 1997-2001.
//
//----------------------------------------------------------------------------

#ifndef __MCACHE_HPP__
#define __MCACHE_HPP__

typedef struct _CACHE* PCACHE;

//----------------------------------------------------------------------------
//
// MemoryCache.
//
//----------------------------------------------------------------------------

class MemoryCache
{
public:
    MemoryCache(void);
    ~MemoryCache(void);

    HRESULT Read(IN ULONG64 BaseAddress,
                 IN PVOID UserBuffer,
                 IN ULONG TransferCount,
                 OUT PULONG BytesRead);
    HRESULT Write(IN ULONG64 BaseAddress,
                  IN PVOID UserBuffer,
                  IN ULONG TransferCount,
                  OUT PULONG BytesWritten);

    void Add(IN ULONG64 BaseAddress,
             IN PVOID UserBuffer,
             IN ULONG Length);
    void Remove(IN ULONG64 BaseAddress,
                IN ULONG Length);
    void Empty(void);

    void ParseCommands(void);
    
    //
    // Internal methods.
    //
    
    virtual HRESULT ReadUncached(IN ULONG64 BaseAddress,
                                 IN PVOID UserBuffer,
                                 IN ULONG TransferCount,
                                 OUT PULONG BytesRead) = 0;
    virtual HRESULT WriteUncached(IN ULONG64 BaseAddress,
                                  IN PVOID UserBuffer,
                                  IN ULONG TransferCount,
                                  OUT PULONG BytesWritten) = 0;

    PCACHE Lookup(ULONG64 Offset,
                  ULONG   Length,
                  PULONG  LengthUsed);

    void InsertNode(IN PCACHE node);

    PUCHAR Alloc(IN ULONG Length);
    VOID Free(IN PUCHAR Memory,
              IN ULONG  Length);
    
    VOID PurgeType(ULONG type);

    VOID SetForceDecodePtes(BOOL Enable);

    void Dump(void);
    void DumpNode(PCACHE Node);
    
    ULONG m_MaxSize;
    ULONG m_UserSize;
    BOOL m_DecodePTEs;
    BOOL m_ForceDecodePTEs;
    BOOL m_Suspend;

    ULONG m_Reads, m_CachedReads, m_UncachedReads;
    ULONG64 m_CachedBytes, m_UncachedBytes;
    ULONG m_Misses;
    ULONG m_Size;
    ULONG m_NodeCount;
    BOOL m_PurgeOverride;
    PCACHE m_Root;
};

//----------------------------------------------------------------------------
//
// VirtualMemoryCache.
//
//----------------------------------------------------------------------------

class VirtualMemoryCache : public MemoryCache
{
public:
    virtual HRESULT ReadUncached(IN ULONG64 BaseAddress,
                                 IN PVOID UserBuffer,
                                 IN ULONG TransferCount,
                                 OUT PULONG BytesRead);
    virtual HRESULT WriteUncached(IN ULONG64 BaseAddress,
                                  IN PVOID UserBuffer,
                                  IN ULONG TransferCount,
                                  OUT PULONG BytesWritten);
};

extern VirtualMemoryCache g_VirtualCache;

//----------------------------------------------------------------------------
//
// PhysicalMemoryCache.
//
//----------------------------------------------------------------------------

class PhysicalMemoryCache : public MemoryCache
{
public:
    virtual HRESULT ReadUncached(IN ULONG64 BaseAddress,
                                 IN PVOID UserBuffer,
                                 IN ULONG TransferCount,
                                 OUT PULONG BytesRead);
    virtual HRESULT WriteUncached(IN ULONG64 BaseAddress,
                                  IN PVOID UserBuffer,
                                  IN ULONG TransferCount,
                                  OUT PULONG BytesWritten);
};

extern PhysicalMemoryCache g_PhysicalCache;
extern BOOL g_PhysicalCacheActive;

#define InvalidateMemoryCaches() \
    ( g_VirtualCache.Empty(), g_PhysicalCache.Empty() )

#endif // #ifndef __MCACHE_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\mcache.cpp ===
//----------------------------------------------------------------------------
//
// Memory cache object.
//
// Copyright (C) Microsoft Corporation, 1997-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

typedef struct _CACHE
{
    RTL_SPLAY_LINKS     SplayLinks;
    ULONG64             Offset;
    ULONG               Length;
    USHORT              Flags;
    union
    {
        PUCHAR      Data;
        HRESULT     Status;
    } u;
} CACHE, *PCACHE;

#define C_ERROR         0x0001      // Cache of error code
#define C_DONTEXTEND    0x0002      // Don't try to extend

#define LARGECACHENODE  1024        // Size of large cache node

VirtualMemoryCache g_VirtualCache;
PhysicalMemoryCache g_PhysicalCache;
BOOL g_PhysicalCacheActive;

//----------------------------------------------------------------------------
//
// MemoryCache.
//
//----------------------------------------------------------------------------

MemoryCache::MemoryCache(void)
{
    m_MaxSize = 1000 * 1024;
    m_UserSize = m_MaxSize;
    m_Reads = 0;
    m_CachedReads = 0;
    m_UncachedReads = 0;
    m_CachedBytes = 0;
    m_UncachedBytes = 0;
    m_Misses = 0;
    m_Size = 0;
    m_NodeCount = 0;
    m_PurgeOverride = FALSE;
    m_DecodePTEs = TRUE;
    m_ForceDecodePTEs = FALSE;
    m_Suspend = FALSE;
    m_Root = NULL;
}

MemoryCache::~MemoryCache(void)
{
    Empty();
}

HRESULT
MemoryCache::Read(IN ULONG64 BaseAddress,
                  IN PVOID UserBuffer,
                  IN ULONG TransferCount,
                  IN PULONG BytesRead)
/*++

    This function returns the specified data from the system being debugged
    using the current mapping of the processor.  If the data is not
    in the cache, it will then be read from the target system.

Arguments:

    BaseAddress - Supplies the base address of the memory to be
        copied into the UserBuffer.

    TransferCount - Amount of data to be copied to the UserBuffer.

    UserBuffer - Address to copy the requested data.

    BytesRead - Number of bytes which could actually be copied

--*/
{
    HRESULT     Status;
    PCACHE      node, node2;
    ULONG       nextlength;
    ULONG       i, br;
    PUCHAR      p;

    *BytesRead = 0;

    if (m_MaxSize == 0 || m_Suspend)
    {
        //
        // Cache is off
        //

        goto ReadDirect;
    }

    m_Reads++;
    
    node = Lookup(BaseAddress, TransferCount, &nextlength);
    Status = S_OK;

    for (;;)
    {
        BOOL Cached = FALSE;
        
        if (node == NULL || node->Offset > BaseAddress)
        {
            //
            // We are missing the leading data, read it into the cache
            //

            if (node)
            {
                //
                // Only get (exactly) enough data to reach neighboring cache
                // node. If an overlapped read occurs between the two nodes,
                // the data will be concatenated then.
                //

                nextlength = (ULONG)(node->Offset - BaseAddress);
            }

            p = Alloc (nextlength);
            node = (PCACHE) Alloc (sizeof (CACHE));

            if (p == NULL || node == NULL)
            {
                //
                // Out of memory - just read directly to UserBuffer
                //

                if (p)
                {
                    Free (p, nextlength);
                }
                if (node)
                {
                    Free ((PUCHAR)node, sizeof (CACHE));
                }

                m_UncachedReads++;
                m_UncachedBytes += TransferCount;
                goto ReadDirect;
            }

            //
            // Read missing data into cache node
            //

            node->Offset = BaseAddress;
            node->u.Data = p;
            node->Flags  = 0;

            m_Misses++;
            m_UncachedReads++;

            Status = ReadUncached(BaseAddress, node->u.Data,
                                  nextlength, &br);
            if (Status == HRESULT_FROM_NT(STATUS_CONTROL_C_EXIT))
            {
                Free (p, nextlength);
                Free ((PUCHAR)node, sizeof (CACHE));
                return Status;
            }
            else if (Status != S_OK)
            {
                //
                // There was an error, cache the error for the starting
                // byte of this range
                //

                Free (p, nextlength);
                if (Status != HRESULT_FROM_NT(STATUS_UNSUCCESSFUL) &&
                    Status != HRESULT_FROM_WIN32(ERROR_PARTIAL_COPY))
                {
                    //
                    // For now be safe, don't cache this error
                    //

                    Free ((PUCHAR)node, sizeof (CACHE));
                    ErrOut("ReadMemoryError %08lx at %s\n",
                           Status, FormatAddr64(BaseAddress));
                    return *BytesRead > 0 ? S_OK : Status;
                }

                node->Length = 1;
                node->Flags |= C_ERROR;
                node->u.Status = Status;
            }
            else
            {
                m_UncachedBytes += br;
                node->Length = br;
                if (br != nextlength)
                {
                    //
                    // Some data was not transfered, cache what was returned
                    //

                    node->Flags |= C_DONTEXTEND;
                    m_Size -= (nextlength - br);
                }
            }


            //
            // Insert cache node into splay tree
            //

            InsertNode (node);
        }
        else
        {
            Cached = TRUE;
            m_CachedReads++;
        }

        if (node->Flags & C_ERROR)
        {
            //
            // Hit an error range, we're done
            //

            return *BytesRead > 0 ? S_OK : node->u.Status;
        }

        //
        // Move available data to UserBuffer
        //

        i = (ULONG)(BaseAddress - node->Offset);
        p = node->u.Data + i;
        i = (ULONG) node->Length - i;
        if (TransferCount < i)
        {
            i = TransferCount;
        }
        memcpy (UserBuffer, p, i);

        if (Cached)
        {
            m_CachedBytes += i;
        }
        
        TransferCount -= i;
        BaseAddress += i;
        UserBuffer = (PVOID)((PUCHAR)UserBuffer + i);
        *BytesRead += i;

        if (!TransferCount)
        {
            //
            // All of the user's data has been transfered
            //

            return S_OK;
        }

        //
        // Look for another cache node with more data
        //

        node2 = Lookup (BaseAddress, TransferCount, &nextlength);
        if (node2)
        {
            if ((node2->Flags & C_ERROR) == 0  &&
                node2->Offset == BaseAddress  &&
                node2->Length + node->Length < LARGECACHENODE)
            {
                //
                // Data is continued in node2, adjoin the neigboring
                // cached data in node & node2 together.
                //

                p = Alloc (node->Length + node2->Length);
                if (p != NULL)
                {
                    memcpy (p, node->u.Data, node->Length);
                    memcpy (p+node->Length, node2->u.Data, node2->Length);
                    Free (node->u.Data, node->Length);
                    node->u.Data  = p;
                    node->Length += node2->Length;
                    m_Root = (PCACHE) pRtlDelete ((PRTL_SPLAY_LINKS)node2);
                    Free (node2->u.Data, node2->Length);
                    Free ((PUCHAR)node2, sizeof (CACHE));
                    m_NodeCount--;
                    continue;
                }
            }

            //
            // Only get enough data to reach the neighboring cache node2
            //

            nextlength = (ULONG)(node2->Offset - BaseAddress);
            if (nextlength == 0)
            {
                //
                // Data is continued in node2, go get it.
                //

                node = node2;
                continue;
            }
        }
        else
        {
            if (node->Length > LARGECACHENODE)
            {
                //
                // Current cache node is already big enough. Don't extend
                // it, add another cache node.
                //

                node = NULL;
                continue;
            }
        }

        //
        // Extend the current node to include missing data
        //

        if (node->Flags & C_DONTEXTEND)
        {
            node = NULL;
            continue;
        }

        p = Alloc (node->Length + nextlength);
        if (!p)
        {
            node = NULL;
            continue;
        }

        memcpy (p, node->u.Data, node->Length);
        Free (node->u.Data, node->Length);
        node->u.Data = p;

        //
        // Add new data to end of this node
        //

        m_Misses++;
        m_UncachedReads++;

        Status = ReadUncached(BaseAddress, node->u.Data + node->Length,
                              nextlength, &br);
        if (Status == HRESULT_FROM_NT(STATUS_CONTROL_C_EXIT))
        {
            m_Size -= nextlength;
            return Status;
        }
        else if (Status != S_OK)
        {
            //
            // Return to error to the caller
            //

            node->Flags |= C_DONTEXTEND;
            m_Size -= nextlength;
            ErrOut("ReadMemoryError %08lx at %s\n",
                   Status, FormatAddr64(BaseAddress));
            return *BytesRead > 0 ? S_OK : Status;
        }

        m_UncachedBytes += br;
        if (br != nextlength)
        {
            node->Flags |= C_DONTEXTEND;
            m_Size -= (nextlength - br);
        }

        node->Length += br;
        // Loop, and move data to user's buffer
    }

ReadDirect:
    Status = ReadUncached(BaseAddress, UserBuffer, TransferCount, &br);
    *BytesRead += br;

    if (Status != HRESULT_FROM_NT(STATUS_CONTROL_C_EXIT))
    {
        Status = *BytesRead > 0 ? S_OK : Status;
    }

    return Status;
}


HRESULT
MemoryCache::Write(IN ULONG64 BaseAddress,
                   IN PVOID UserBuffer,
                   IN ULONG TransferCount,
                   OUT PULONG BytesWritten)
{
    // Remove data from cache before writing through to target system.
    Remove(BaseAddress, TransferCount);

    return WriteUncached(BaseAddress, UserBuffer,
                         TransferCount, BytesWritten);
}


PCACHE
MemoryCache::Lookup (
    ULONG64 Offset,
    ULONG   Length,
    PULONG  LengthUsed
    )
/*++

Routine Description:

    Walks the cache tree looking for a matching range closest to
    the supplied Offset.  The length of the range searched is based on
    the past length, but may be adjusted slightly.

    This function will always search for the starting byte.

Arguments:

    Offset  - Starting byte being looked for in cache

    Length  - Length of range being looked for in cache

    LengthUsed - Length of range which was really search for

Return Value:

    NULL    - data for returned range was not found
    PCACHE  - leftmost cachenode which has data for returned range


--*/
{
    PCACHE  node, node2;
    ULONG64 SumOffsetLength;

    if (Length < 0x80 && m_Misses > 3)
    {
        // Try to cache more then tiny amount
        Length = 0x80;
    }

    SumOffsetLength = Offset + Length;
    if (SumOffsetLength < Length)
    {
        //
        // Offset + Length wrapped.  Adjust Length to be only
        // enough bytes before wrapping.
        //

        Length = (ULONG)(0 - Offset);
        SumOffsetLength = (ULONG64)-1;
    }
    *LengthUsed = Length;

    //
    // Find leftmost cache node for BaseAddress thru BaseAddress+Length
    //

    node2 = NULL;
    node  = m_Root;
    while (node != NULL)
    {
        if (SumOffsetLength <= node->Offset)
        {
            node = (PCACHE) RtlLeftChild(&node->SplayLinks);
        }
        else if (node->Offset + node->Length <= Offset)
        {
            node = (PCACHE) RtlRightChild(&node->SplayLinks);
        }
        else
        {
            if (node->Offset <= Offset)
            {
                //
                // Found starting byte
                //

                return node;
            }

            //
            // Check to see if there's a node which has a match closer
            // to the start of the requested range
            //

            node2  = node;
            Length = (ULONG)(node->Offset - Offset);
            node   = (PCACHE) RtlLeftChild(&node->SplayLinks);
        }
    }

    return node2;
}

VOID
MemoryCache::InsertNode (
    IN PCACHE node
    )
{
    PCACHE node2;
    ULONG64 BaseAddress;

    //
    // Insert cache node into splay tree
    //

    RtlInitializeSplayLinks(&node->SplayLinks);

    m_NodeCount++;
    if (m_Root == NULL)
    {
        m_Root = node;
        return;
    }

    node2 = m_Root;
    BaseAddress = node->Offset;
    for (; ;)
    {
        if (BaseAddress < node2->Offset)
        {
            if (RtlLeftChild(&node2->SplayLinks))
            {
                node2 = (PCACHE) RtlLeftChild(&node2->SplayLinks);
                continue;
            }
            RtlInsertAsLeftChild(node2, node);
            break;
        }
        else
        {
            if (RtlRightChild(&node2->SplayLinks))
            {
                node2 = (PCACHE) RtlRightChild(&node2->SplayLinks);
                continue;
            }
            RtlInsertAsRightChild(node2, node);
            break;
        }
    }
    m_Root = (PCACHE) pRtlSplay((PRTL_SPLAY_LINKS)node2);
}

VOID
MemoryCache::Add (
    IN ULONG64 BaseAddress,
    IN PVOID UserBuffer,
    IN ULONG Length
    )
/*++

Routine Description:

    Insert some data into the cache.

Arguments:

    BaseAddress - Virtual address

    Length      - length to cache

    UserBuffer  - data to put into cache

Return Value:

--*/
{
    PCACHE  node;
    PUCHAR  p;

    if (m_MaxSize == 0)
    {
        //
        // Cache is off
        //

        return;
    }

    //
    // Delete any cached info which hits range
    //

    Remove (BaseAddress, Length);

    p = Alloc (Length);
    node = (PCACHE) Alloc (sizeof (CACHE));
    if (p == NULL  ||  node == NULL)
    {
        //
        // Out of memory - don't bother
        //

        if (p)
        {
            Free (p, Length);
        }
        if (node)
        {
            Free ((PUCHAR)node, sizeof (CACHE));
        }

        return;
    }

    //
    // Put data into cache node
    //

    node->Offset = BaseAddress;
    node->Length = Length;
    node->u.Data = p;
    node->Flags  = 0;
    memcpy (p, UserBuffer, Length);
    InsertNode (node);
}


PUCHAR
MemoryCache::Alloc (
    IN ULONG Length
    )
/*++

Routine Description:

    Allocates memory for virtual cache, and tracks total memory
    usage.

Arguments:

    Length  - Amount of memory to allocate

Return Value:

    NULL    - too much memory is in use, or memory could not
              be allocated

    Otherwise, returns to address of the allocated memory

--*/
{
    PUCHAR  p;

    if (m_Size + Length > m_MaxSize)
    {
        return NULL;
    }

    if (!(p = (PUCHAR)malloc (Length)))
    {
        //
        // Out of memory - don't get any larger
        //

        m_Size = m_MaxSize + 1;
        return NULL;
    }

    m_Size += Length;
    return p;
}


VOID
MemoryCache::Free (
    IN PUCHAR Memory,
    IN ULONG  Length
    )
/*++
Routine Description:

    Free memory allocated with Alloc.  Adjusts cache is use totals.

Arguments:

    Memory  - Address of allocated memory

    Length  - Length of allocated memory

Return Value:

    NONE

--*/
{
    m_Size -= Length;
    free (Memory);
}


VOID
MemoryCache::Remove (
    IN ULONG64 BaseAddress,
    IN ULONG TransferCount
    )
/*++

Routine Description:

    Invalidates range from the cache.

Arguments:

    BaseAddress - Starting address to purge
    TransferCount - Length of area to purge

Return Value:

    NONE

--*/
{
    PCACHE  node;
    ULONG   bogus;

    //
    // Invalidate any data in the cache which covers this range
    //

    while (node = Lookup(BaseAddress, TransferCount, &bogus))
    {
        //
        // For now just delete the entire cache node which hits the range
        //

        m_Root = (PCACHE) pRtlDelete (&node->SplayLinks);
        if (!(node->Flags & C_ERROR))
        {
            Free (node->u.Data, node->Length);
        }
        Free ((PUCHAR)node, sizeof (CACHE));
        m_NodeCount--;
    }
}

VOID
MemoryCache::Empty (
    VOID
    )
/*++

Routine Description:

    Purges to entire cache

Arguments:

    NONE

Return Value:

    NONE

--*/
{
    PCACHE  node, node2;

    m_Reads = 0;
    m_CachedReads = 0;
    m_UncachedReads = 0;
    m_CachedBytes = 0;
    m_UncachedBytes = 0;
    m_Misses = 0;
    if (!m_Root)
    {
        return;
    }

    if (m_PurgeOverride != 0)
    {
        WarnOut("WARNING: cache being held\n");
        return;
    }

    node2 = m_Root;
    node2->SplayLinks.Parent = NULL;

    while ((node = node2) != NULL)
    {
        if ((node2 = (PCACHE) node->SplayLinks.LeftChild) != NULL)
        {
            node->SplayLinks.LeftChild = NULL;
            continue;
        }
        if ((node2 = (PCACHE) node->SplayLinks.RightChild) != NULL)
        {
            node->SplayLinks.RightChild = NULL;
            continue;
        }

        node2 = (PCACHE) node->SplayLinks.Parent;
        if (!(node->Flags & C_ERROR))
        {
            free (node->u.Data);
        }
        free (node);
    }

    m_Size = 0;
    m_NodeCount = 0;
    m_Root = NULL;
}


VOID
MemoryCache::PurgeType (
    ULONG   type
    )
/*++

Routine Description:

    Purges all nodes from the cache which match type in question

Arguments:

    type    - type of entries to purge from the cache
                0 - entries of errored ranges
                1 - plus, node which cache user mode entries

Return Value:

    NONE

--*/
{
    PCACHE  node, node2;

    if (!m_Root)
    {
        return;
    }

    //
    // this purges the selected cache entries by copy the all the
    // cache nodes except from the ones we don't want
    //

    node2 = m_Root;
    node2->SplayLinks.Parent = NULL;
    m_Root = NULL;

    while ((node = node2) != NULL)
    {
        if ((node2 = (PCACHE)node->SplayLinks.LeftChild) != NULL)
        {
            node->SplayLinks.LeftChild = NULL;
            continue;
        }
        if ((node2 = (PCACHE)node->SplayLinks.RightChild) != NULL)
        {
            node->SplayLinks.RightChild = NULL;
            continue;
        }

        node2 = (PCACHE) node->SplayLinks.Parent;

        m_NodeCount--;

        if (node->Flags & C_ERROR)
        {
            // remove this one from the tree
            Free ((PUCHAR)node, sizeof (CACHE));
            continue;
        }

        if ((type == 1)  &&  (node->Offset < g_SystemRangeStart))
        {
            // remove this one from the tree
            Free (node->u.Data, node->Length);
            Free ((PUCHAR)node, sizeof (CACHE));
            continue;
        }

        // copy to the new tree
        InsertNode (node);
    }
}

VOID
MemoryCache::SetForceDecodePtes(BOOL Enable)
{
    m_ForceDecodePTEs = Enable;
    if (Enable)
    {
        m_MaxSize = 0;
    }
    else
    {
        m_MaxSize = m_UserSize;
    }
    Empty();
    g_PhysicalCacheActive = Enable;
    g_PhysicalCache.Empty();
}

void
MemoryCache::ParseCommands(void)
{
    ULONG64 Address;

    while (*g_CurCmd == ' ')
    {
        g_CurCmd++;
    }

    _strlwr(g_CurCmd);

    BOOL Parsed = TRUE;
        
    if (IS_KERNEL_TARGET())
    {
        if (strcmp (g_CurCmd, "decodeptes") == 0)
        {
            PurgeType(0);
            m_DecodePTEs = TRUE;
        }
        else if (strcmp (g_CurCmd, "nodecodeptes") == 0)
        {
            m_DecodePTEs = FALSE;
        }
        else if (strcmp (g_CurCmd, "forcedecodeptes") == 0)
        {
            SetForceDecodePtes(TRUE);
        }
        else if (strcmp (g_CurCmd, "noforcedecodeptes") == 0)
        {
            SetForceDecodePtes(FALSE);
        }
        else
        {
            Parsed = FALSE;
        }
    }

    if (Parsed)
    {
        // Command already handled.
    }
    else if (strcmp (g_CurCmd, "hold") == 0)
    {
        m_PurgeOverride = TRUE;
    }
    else if (strcmp (g_CurCmd, "unhold") == 0)
    {
        m_PurgeOverride = FALSE;
    }
    else if (strcmp (g_CurCmd, "flushall") == 0)
    {
        Empty();
    }
    else if (strcmp (g_CurCmd, "flushu") == 0)
    {
        PurgeType(1);
    }
    else if (strcmp (g_CurCmd, "suspend") == 0)
    {
        m_Suspend = TRUE;
    }
    else if (strcmp (g_CurCmd, "nosuspend") == 0)
    {
        m_Suspend = FALSE;
    }
    else if (strcmp (g_CurCmd, "dump") == 0)
    {
        Dump();
        goto Done;
    }
    else if (*g_CurCmd == 'f')
    {
        while (*g_CurCmd >= 'a'  &&  *g_CurCmd <= 'z')
        {
            g_CurCmd++;
        }
        Address = GetExpression();
        Remove(Address, 4096);
        dprintf("Cached info for address %s for 4096 bytes was flushed\n",
                FormatAddr64(Address));
    }
    else if (*g_CurCmd)
    {
        if (*g_CurCmd < '0'  ||  *g_CurCmd > '9')
        {
            dprintf(".cache [{cachesize} | hold | unhold\n");
            dprintf(".cache [flushall | flushu | flush addr]\n");
            if (IS_KERNEL_TARGET())
            {
                dprintf(".cache [decodeptes | nodecodeptes]\n");
                dprintf(".cache [forcedecodeptes | noforcedecodeptes]\n");
            }
            goto Done;
        }
        else
        {
            ULONG NewSize;
            
            NewSize = (ULONG)GetExpression() * 1024;
            if (0 > (LONG)NewSize)
            {
                dprintf("*** Cache size %ld (%#lx KB) is too large - "
                        "cache unchanged.\n", NewSize, KBYTES(NewSize));
            }
            else if (m_ForceDecodePTEs)
            {
                dprintf("Cache size update deferred until "
                        "noforcedecodeptes\n");
                m_UserSize = NewSize;
            }
            else
            {
                m_UserSize = NewSize;
                m_MaxSize = m_UserSize;
                if (m_MaxSize == 0)
                {
                    Empty();
                }
            }
        }
    }

    dprintf("\n");
    dprintf("Max cache size is       : %ld bytes (%#lx KB) %s\n",
            m_MaxSize, KBYTES(m_MaxSize),
            m_MaxSize ? "" : "(cache is off)");
    dprintf("Total memory in cache   : %ld bytes (%#lx KB) \n",
            m_Size - m_NodeCount * sizeof(CACHE),
            KBYTES(m_Size - m_NodeCount * sizeof(CACHE)));
    dprintf("Number of regions cached: %ld\n", m_NodeCount);

    ULONG TotalPartial;
    ULONG64 TotalBytes;
    double PerCached;

    TotalPartial = m_CachedReads + m_UncachedReads;
    TotalBytes = m_CachedBytes + m_UncachedBytes;
    dprintf("%d full reads broken into %d partial reads\n",
            m_Reads, TotalPartial);
    PerCached = TotalPartial ?
        (double)m_CachedReads * 100.0 / TotalPartial : 0.0;
    dprintf("    counts: %d cached/%d uncached, %.2lf%% cached\n",
            m_CachedReads, m_UncachedReads, PerCached);
    PerCached = TotalBytes ?
        (double)m_CachedBytes * 100.0 / TotalBytes : 0.0;
    dprintf("    bytes : %I64d cached/%I64d uncached, %.2lf%% cached\n",
            m_CachedBytes, m_UncachedBytes, PerCached);

    if (m_DecodePTEs)
    {
        dprintf ("** Transition PTEs are implicitly decoded\n");
    }

    if (m_ForceDecodePTEs)
    {
        dprintf("** Virtual addresses are translated to "
                "physical addresses before access\n");
    }
    
    if (m_PurgeOverride)
    {
        dprintf("** Implicit cache flushing disabled **\n");
    }

    if (m_Suspend)
    {
        dprintf("** Cache access is suspended\n");
    }
    
Done:
    while (*g_CurCmd && *g_CurCmd != ';')
    {
        g_CurCmd++;
    }
}

void
MemoryCache::Dump(void)
{
    PCACHE Node;
    
    dprintf("Current size %x, max size %x\n",
            m_Size, m_MaxSize);
    dprintf("%d nodes:\n", m_NodeCount);
    DumpNode(m_Root);
}

void
MemoryCache::DumpNode(PCACHE Node)
{
    if (Node->SplayLinks.LeftChild)
    {
        DumpNode((PCACHE)Node->SplayLinks.LeftChild);
    }
    
    dprintf("  offset %s, length %3x, flags %x, status %08x\n",
            FormatAddr64(Node->Offset), Node->Length,
            Node->Flags, (Node->Flags & C_ERROR) ? Node->u.Status : S_OK);
    
    if (Node->SplayLinks.RightChild)
    {
        DumpNode((PCACHE)Node->SplayLinks.RightChild);
    }
}

//----------------------------------------------------------------------------
//
// VirtualMemoryCache.
//
//----------------------------------------------------------------------------

HRESULT
VirtualMemoryCache::ReadUncached(IN ULONG64 BaseAddress,
                                 IN PVOID UserBuffer,
                                 IN ULONG TransferCount,
                                 OUT PULONG BytesRead)
{
    return g_Target->ReadVirtualUncached(BaseAddress, UserBuffer,
                                         TransferCount, BytesRead);
}

HRESULT
VirtualMemoryCache::WriteUncached(IN ULONG64 BaseAddress,
                                  IN PVOID UserBuffer,
                                  IN ULONG TransferCount,
                                  OUT PULONG BytesWritten)
{
    return g_Target->WriteVirtualUncached(BaseAddress, UserBuffer,
                                          TransferCount, BytesWritten);
}
    
//----------------------------------------------------------------------------
//
// PhysicalMemoryCache.
//
//----------------------------------------------------------------------------

HRESULT
PhysicalMemoryCache::ReadUncached(IN ULONG64 BaseAddress,
                                  IN PVOID UserBuffer,
                                  IN ULONG TransferCount,
                                  OUT PULONG BytesRead)
{
    return g_Target->ReadPhysicalUncached(BaseAddress, UserBuffer,
                                          TransferCount, BytesRead);
}

HRESULT
PhysicalMemoryCache::WriteUncached(IN ULONG64 BaseAddress,
                                   IN PVOID UserBuffer,
                                   IN ULONG TransferCount,
                                   OUT PULONG BytesWritten)
{
    return g_Target->WritePhysicalUncached(BaseAddress, UserBuffer,
                                           TransferCount, BytesWritten);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\memcmd.cpp ===
//----------------------------------------------------------------------------
//
// Functions dealing with memory access, such as reading, writing,
// dumping and entering.
//
// Copyright (C) Microsoft Corporation, 1997-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

ULONG64 EXPRLastDump = 0L;

ADDR g_DumpDefault;  //  default dump address

/*** GetProcessMemString - get memory string values
*
*   Purpose:
*       To read a string of a specified length with the memory
*       values selected.  Break reads across page boundaries -
*       multiples of the page size.
*
*   Input:
*       Addr - offset of memory to start reading
*       Value - pointer to byte string to set with memory values
*
*   Output:
*       bytes at Value set if read successful
*
*   Returns:
*       number of bytes actually read
*
*************************************************************************/

ULONG
GetProcessMemString (
    PPROCESS_INFO Process,
    PADDR Addr,
    PVOID Value,
    ULONG Length
    )

{
    ULONG cTotalBytesRead = 0;

    if (fFlat(*Addr) || fInstrPtr(*Addr))
    {
        PPROCESS_INFO OldCur = g_CurrentProcess;
        g_CurrentProcess = Process;
    
        if (g_Target->ReadVirtual(Flat(*Addr), Value, Length,
                                  &cTotalBytesRead) != S_OK)
        {
            cTotalBytesRead = 0;
        }

        g_CurrentProcess = OldCur;
    }
    
    return cTotalBytesRead;
}

/*** SetProcessMemString - set memory string values
*
*   Purpose:
*       To write a string of a specified length with the memory
*       values selected.
*
*   Input:
*       Addr - offset of memory to start writing
*       Value - pointer to byte string to set with memory values
*
*   Output:
*       bytes at Value set if write successful
*
*   Returns:
*       number of bytes actually write
*
*************************************************************************/

ULONG
SetProcessMemString (
    PPROCESS_INFO Process,
    PADDR Addr,
    PVOID Value,
    ULONG Length
    )

{
    ULONG cTotalBytesWritten = 0;

    if (fFlat(*Addr) || fInstrPtr(*Addr))
    {
        PPROCESS_INFO OldCur = g_CurrentProcess;
        g_CurrentProcess = Process;
    
        if (g_Target->WriteVirtual(Flat(*Addr), Value, Length,
                                   &cTotalBytesWritten) != S_OK)
        {
            cTotalBytesWritten = 0;
        }

        g_CurrentProcess = OldCur;
    }
    
    return cTotalBytesWritten;
}

BOOL
CALLBACK
LocalSymbolEnumerator(
    PSYMBOL_INFO    pSymInfo,
    ULONG           Size,
    PVOID           Context
    )
{
    ULONG64 Value = pSymInfo->Register, Address = pSymInfo->Address;

    TranslateAddress(pSymInfo->Flags, pSymInfo->Register, &Address, &Value);
    
    VerbOut("%s ", FormatAddr64(Address));
    dprintf("%15s = ", pSymInfo->Name);
    if (pSymInfo->Flags & SYMF_REGISTER)
    {
        dprintf( "%I64x\n",
                 Value
                 );
    }
    else
    {
        if (!DumpSingleValue(pSymInfo))
        {
            dprintf("??");
        }
        dprintf("\n");
    }

    if (CheckUserInterrupt())
    {
        return FALSE;
    }

    return TRUE;
}

//----------------------------------------------------------------------------
//
// parseDumpCommand
//
// Parses memory dump commands.
//
//----------------------------------------------------------------------------

void
parseDumpCommand(
    void
    )
{
    CHAR    ch;
    ULONG64 count;
    ULONG   size;
    ULONG   offset;
    BOOL    DumpSymbols;

    static CHAR s_DumpPrimary = 'b';
    static CHAR s_DumpSecondary = ' ';

    ch = (CHAR)tolower(*g_CurCmd);
    if (ch == 'a' || ch == 'b' || ch == 'c' || ch == 'd' ||
        ch == 'f' || ch == 'g' || ch == 'l' || ch == 'u' ||
        ch == 'w' || ch == 's' || ch == 'q' || ch == 't' ||
        ch == 'v' || ch == 'y' || ch == 'p')
    {
        if (ch == 'd' || ch == 's')
        {
            s_DumpPrimary = *g_CurCmd;
        }
        else if (ch == 'p')
        {
            // 'p' maps to the effective pointer size dump.
            s_DumpPrimary = g_Machine->m_Ptr64 ? 'q' : 'd';
        }
        else
        {
            s_DumpPrimary = ch;
        }

        g_CurCmd++;

        s_DumpSecondary = ' ';
        if (s_DumpPrimary == 'd' || s_DumpPrimary == 'q')
        {
            if (*g_CurCmd == 's')
            {
                s_DumpSecondary = *g_CurCmd++;
            }
        }
        else if (s_DumpPrimary == 'l')
        {
            if (*g_CurCmd == 'b')
            {
                s_DumpSecondary = *g_CurCmd++;
            }
        }
        else if (s_DumpPrimary == 'y')
        {
            if (*g_CurCmd == 'b' || *g_CurCmd == 'd')
            {
                s_DumpSecondary = *g_CurCmd++;
            }
        }
    }

    switch (s_DumpPrimary)
    {
    case 'a':
        count = 384;
        GetRange(&g_DumpDefault, &count, 1, SEGREG_DATA);
        fnDumpAsciiMemory(&g_DumpDefault, (ULONG)count);
        break;

    case 'b':
        count = 128;
        GetRange(&g_DumpDefault, &count, 1, SEGREG_DATA);
        fnDumpByteMemory(&g_DumpDefault, (ULONG)count);
        break;

    case 'c':
        count = 32;
        GetRange(&g_DumpDefault, &count, 4, SEGREG_DATA);
        fnDumpDwordAndCharMemory(&g_DumpDefault, (ULONG)count);
        break;

    case 'd':
        count = 32;
        DumpSymbols = s_DumpSecondary == 's';
        GetRange(&g_DumpDefault, &count, 4, SEGREG_DATA);
        fnDumpDwordMemory(&g_DumpDefault, (ULONG)count, DumpSymbols);
        break;

    case 'D':
        count = 15;
        GetRange(&g_DumpDefault, &count, 8, SEGREG_DATA);
        fnDumpDoubleMemory(&g_DumpDefault, (ULONG)count);
        break;

    case 'f':
        count = 16;
        GetRange(&g_DumpDefault, &count, 4, SEGREG_DATA);
        fnDumpFloatMemory(&g_DumpDefault, (ULONG)count);
        break;

    case 'g':
        fnDumpSelector((ULONG)GetExpression());
        break;

    case 'l':
        BOOL followBlink;

        count = 32;
        size = 4;
        followBlink = s_DumpSecondary == 'b';

        if ((ch = PeekChar()) != '\0' && ch != ';')
        {
            GetAddrExpression(SEGREG_DATA, &g_DumpDefault);
            if ((ch = PeekChar()) != '\0' && ch != ';')
            {
                count = GetExpression();
                if ((ch = PeekChar()) != '\0' && ch != ';')
                {
                    size = (ULONG)GetExpression();
                }
            }
        }
        fnDumpListMemory(&g_DumpDefault, (ULONG)count, size, followBlink);
        break;

    case 'q':
        count = 16;
        DumpSymbols = s_DumpSecondary == 's';
        GetRange(&g_DumpDefault, &count, 8, SEGREG_DATA);
        fnDumpQuadMemory(&g_DumpDefault, (ULONG)count, DumpSymbols);
        break;

    case 's':
    case 'S':
        UNICODE_STRING64 UnicodeString;
        ADDR BufferAddr;

        count = 1;
        GetRange(&g_DumpDefault, &count, 2, SEGREG_DATA);
        while (count--)
        {
            if (g_Target->ReadUnicodeString(g_Machine, Flat(g_DumpDefault),
                                            &UnicodeString) == S_OK)
            {
                ADDRFLAT(&BufferAddr, UnicodeString.Buffer);
                if (s_DumpPrimary == 'S')
                {
                    fnDumpUnicodeMemory( &BufferAddr,
                                         UnicodeString.Length / sizeof(WCHAR));
                }
                else
                {
                    fnDumpAsciiMemory( &BufferAddr, UnicodeString.Length );
                }
            }
        }
        break;

    case 't': 
    case 'T':
       SymbolTypeDumpEx(g_CurrentProcess->Handle,
                        g_CurrentProcess->ImageHead,
                        g_CurCmd);
       break;

    case 'u':
        count = 384;
        GetRange(&g_DumpDefault, &count, 2, SEGREG_DATA);
        fnDumpUnicodeMemory(&g_DumpDefault, (ULONG)count);
        break;

    case 'v':
        RequireCurrentScope();
        EnumerateLocals(LocalSymbolEnumerator, NULL);
        break;

    case 'w':
        count = 64;
        GetRange(&g_DumpDefault, &count, 2, SEGREG_DATA);
        fnDumpWordMemory(&g_DumpDefault, (ULONG)count);
        break;

    case 'y':
        switch(s_DumpSecondary)
        {
        case 'b':
            count = 32;
            GetRange(&g_DumpDefault, &count, 1, SEGREG_DATA);
            fnDumpByteBinaryMemory(&g_DumpDefault, (ULONG)count);
            break;

        case 'd':
            count = 8;
            GetRange(&g_DumpDefault, &count, 4, SEGREG_DATA);
            fnDumpDwordBinaryMemory(&g_DumpDefault, (ULONG)count);
            break;

        default:
            error(SYNTAX);
        }
        break;

    default:
        error(SYNTAX);
        break;
    }
}

//----------------------------------------------------------------------------
//
// DumpValues
//
// Generic columnar value dumper.  Returns the number of values
// printed.
//
//----------------------------------------------------------------------------

class DumpValues
{
public:
    DumpValues(ULONG Size, ULONG Columns);

    ULONG Dump(PADDR Start, ULONG Count);

protected:
    // Worker methods that derived classes must define.
    virtual ULONG64 GetValue(void) = 0;
    virtual BOOL PrintValue(void) = 0;
    virtual void PrintUnknown(void) = 0;

    // Optional worker methods.  Base implementations do nothing.
    virtual void EndRow(void);
    
    // Fixed members controlling how this instance dumps values.
    ULONG m_Size;
    ULONG m_Columns;

    // Work members during dumping.
    UCHAR* m_Value;
    ULONG m_Col;
    PADDR m_Start;

    // Optional per-row values.  Out is automatically reset to
    // Base at the beginning of every row.
    UCHAR* m_Base;
    UCHAR* m_Out;
};

DumpValues::DumpValues(ULONG Size, ULONG Columns)
{
    m_Size = Size;
    m_Columns = Columns;
}

ULONG
DumpValues::Dump(PADDR Start, ULONG Count)
{
    ULONG   Read;
    UCHAR   ReadBuffer[512];
    ULONG   Idx;
    ULONG   Block;
    BOOL    First = TRUE;
    ULONG64 Offset;
    ULONG   Printed;
    BOOL    RowStarted;
    ULONG   PageVal;
    ULONG64 NextOffs, NextPage;

    Offset = Flat(*Start);
    Printed = 0;
    RowStarted = FALSE;
    m_Start = Start;
    m_Col = 0;
    m_Out = m_Base;

    while (Count > 0)
    {
        Block = sizeof(ReadBuffer) / m_Size;
        Block = min(Count, Block);
        g_Target->NearestDifferentlyValidOffsets(Offset, &NextOffs, &NextPage);
        PageVal = (ULONG)(NextPage - Offset + m_Size - 1) / m_Size;
        Block = min(Block, PageVal);

        Read = GetMemString(Start, ReadBuffer, Block * m_Size) / m_Size;
        if (Read < Block && NextOffs < NextPage)
        {
            // In dump files data validity can change from
            // one byte to the next so we cannot assume that
            // stepping by pages will always be correct.  Instead,
            // if we didn't have a successful read we step just
            // past the end of the valid data or to the next
            // valid offset, whichever is farther.
            if (Offset + (Read + 1) * m_Size < NextOffs)
            {
                Block = (ULONG)(NextOffs - Offset + m_Size - 1) / m_Size;
            }
            else
            {
                Block = Read + 1;
            }
        }
        m_Value = ReadBuffer;
        Idx = 0;

        if (First && Read >= 1)
        {
            First = FALSE;
            EXPRLastDump = GetValue();
        }

        while (Idx < Block)
        {
            while (m_Col < m_Columns && Idx < Block)
            {
                if (m_Col == 0)
                {
                    dprintAddr(Start);
                    RowStarted = TRUE;
                }

                if (Idx < Read)
                {
                    if (!PrintValue())
                    {
                        // Increment address since this value was
                        // examined, but do not increment print count
                        // or column since no output was produced.
                        AddrAdd(Start, m_Size);
                        goto Exit;
                    }

                    m_Value += m_Size;
                }
                else
                {
                    PrintUnknown();
                }

                Idx++;
                Printed++;
                m_Col++;
                AddrAdd(Start, m_Size);
            }

            if (m_Col == m_Columns)
            {
                EndRow();
                m_Out = m_Base;
                dprintf("\n");
                RowStarted = FALSE;
                m_Col = 0;
            }

            if (CheckUserInterrupt())
            {
                return Printed;
            }
        }

        Count -= Block;
        Offset += Block * m_Size;
    }

 Exit:
    if (RowStarted)
    {
        EndRow();
        m_Out = m_Base;
        dprintf("\n");
    }

    return Printed;
}

void
DumpValues::EndRow(void)
{
    // Empty base implementation.
}

/*** fnDumpAsciiMemory - output ascii strings from memory
*
*   Purpose:
*       Function of "da<range>" command.
*
*       Outputs the memory in the specified range as ascii
*       strings up to 32 characters per line.  The default
*       display is 12 lines for 384 characters total.
*
*   Input:
*       Start - starting address to begin display
*       Count - number of characters to display as ascii
*
*   Output:
*       None.
*
*   Notes:
*       memory locations not accessible are output as "?",
*       but no errors are returned.
*
*************************************************************************/

class DumpAscii : public DumpValues
{
public:
    DumpAscii(void)
        : DumpValues(sizeof(UCHAR), (sizeof(m_Buf) / sizeof(m_Buf[0]) - 1))
    {
        m_Base = m_Buf;
    }

protected:
    // Worker methods that derived classes must define.
    virtual ULONG64 GetValue(void);
    virtual BOOL PrintValue(void);
    virtual void PrintUnknown(void);
    virtual void EndRow(void);

    UCHAR m_Buf[33];
};

ULONG64
DumpAscii::GetValue(void)
{
    return *m_Value;
}

BOOL
DumpAscii::PrintValue(void)
{
    UCHAR ch;

    ch = *m_Value;
    if (ch == 0)
    {
        return FALSE;
    }

    if (ch < 0x20 || ch > 0x7e)
    {
        ch = '.';
    }
    *m_Out++ = ch;

    return TRUE;
}

void
DumpAscii::PrintUnknown(void)
{
    *m_Out++ = '?';
}

void
DumpAscii::EndRow(void)
{
    *m_Out++ = 0;
    dprintf(" \"%s\"", m_Base);
}

ULONG
fnDumpAsciiMemory(
    PADDR Start,
    ULONG Count
    )
{
    DumpAscii Dumper;

    return Count - Dumper.Dump(Start, Count);
}

/*** fnDumpUnicodeMemory - output unicode strings from memory
*
*   Purpose:
*       Function of "du<range>" command.
*
*       Outputs the memory in the specified range as unicode
*       strings up to 32 characters per line.  The default
*       display is 12 lines for 384 characters total (768 bytes)
*
*   Input:
*       Start - starting address to begin display
*       Count - number of characters to display as ascii
*
*   Output:
*       None.
*
*   Notes:
*       memory locations not accessible are output as "?",
*       but no errors are returned.
*
*************************************************************************/

class DumpUnicode : public DumpValues
{
public:
    DumpUnicode(void)
        : DumpValues(sizeof(WCHAR), (sizeof(m_Buf) / sizeof(m_Buf[0]) - 1))
    {
        m_Base = (PUCHAR)m_Buf;
    }

protected:
    // Worker methods that derived classes must define.
    virtual ULONG64 GetValue(void);
    virtual BOOL PrintValue(void);
    virtual void PrintUnknown(void);
    virtual void EndRow(void);

    WCHAR m_Buf[33];
};

ULONG64
DumpUnicode::GetValue(void)
{
    return *(WCHAR *)m_Value;
}

BOOL
DumpUnicode::PrintValue(void)
{
    WCHAR ch;

    ch = *(WCHAR *)m_Value;
    if (ch == UNICODE_NULL)
    {
        return FALSE;
    }

    if (ch < 0x20 || ch > 0x7e)
    {
        ch = L'.';
    }
    *(WCHAR *)m_Out = ch;
    m_Out += sizeof(WCHAR);

    return TRUE;
}

void
DumpUnicode::PrintUnknown(void)
{
    *(WCHAR *)m_Out = L'?';
    m_Out += sizeof(WCHAR);
}

void
DumpUnicode::EndRow(void)
{
    *(WCHAR *)m_Out = UNICODE_NULL;
    m_Out += sizeof(WCHAR);
    dprintf(" \"%ws\"", m_Base);
}

ULONG
fnDumpUnicodeMemory(
    PADDR Start,
    ULONG Count
    )
{
    DumpUnicode Dumper;

    return Count - Dumper.Dump(Start, Count);
}

/*** fnDumpByteMemory - output byte values from memory
*
*   Purpose:
*       Function of "db<range>" command.
*
*       Output the memory in the specified range as hex
*       byte values and ascii characters up to 16 bytes
*       per line.  The default display is 16 lines for
*       256 byte total.
*
*   Input:
*       Start - starting address to begin display
*       Count - number of bytes to display as hex and characters
*
*   Output:
*       None.
*
*   Notes:
*       memory location not accessible are output as "??" for
*       byte values and "?" as characters, but no errors are returned.
*
*************************************************************************/

class DumpByte : public DumpValues
{
public:
    DumpByte(void)
        : DumpValues(sizeof(UCHAR), (sizeof(m_Buf) / sizeof(m_Buf[0]) - 1))
    {
        m_Base = m_Buf;
    }

protected:
    // Worker methods that derived classes must define.
    virtual ULONG64 GetValue(void);
    virtual BOOL PrintValue(void);
    virtual void PrintUnknown(void);
    virtual void EndRow(void);

    UCHAR m_Buf[17];
};

ULONG64
DumpByte::GetValue(void)
{
    return *m_Value;
}

BOOL
DumpByte::PrintValue(void)
{
    UCHAR ch;

    ch = *m_Value;

    if (m_Col == 8)
    {
        dprintf("-");
    }
    else
    {
        dprintf(" ");
    }
    dprintf("%02x", ch);

    if (ch < 0x20 || ch > 0x7e)
    {
        ch = '.';
    }
    *m_Out++ = ch;

    return TRUE;
}

void
DumpByte::PrintUnknown(void)
{
    if (m_Col == 8)
    {
        dprintf("-??");
    }
    else
    {
        dprintf(" ??");
    }
    *m_Out++ = '?';
}

void
DumpByte::EndRow(void)
{
    *m_Out++ = 0;

    while (m_Col < m_Columns)
    {
        dprintf("   ");
        m_Col++;
    }

    if ((m_Start->type & ADDR_1632) == ADDR_1632)
    {
        dprintf(" %s", m_Base);
    }
    else
    {
        dprintf("  %s", m_Base);
    }
}

void
fnDumpByteMemory(
    PADDR Start,
    ULONG Count
    )
{
    DumpByte Dumper;

    Dumper.Dump(Start, Count);
}

/*** fnDumpWordMemory - output word values from memory
*
*   Purpose:
*       Function of "dw<range>" command.
*
*       Output the memory in the specified range as word
*       values up to 8 words per line.  The default display
*       is 16 lines for 128 words total.
*
*   Input:
*       Start - starting address to begin display
*       Count - number of words to be displayed
*
*   Output:
*       None.
*
*   Notes:
*       memory locations not accessible are output as "????",
*       but no errors are returned.
*
*************************************************************************/

class DumpWord : public DumpValues
{
public:
    DumpWord(void)
        : DumpValues(sizeof(WORD), 8) {}

protected:
    // Worker methods that derived classes must define.
    virtual ULONG64 GetValue(void);
    virtual BOOL PrintValue(void);
    virtual void PrintUnknown(void);
};

ULONG64
DumpWord::GetValue(void)
{
    return *(WORD *)m_Value;
}

BOOL
DumpWord::PrintValue(void)
{
    dprintf(" %04x", *(WORD *)m_Value);
    return TRUE;
}

void
DumpWord::PrintUnknown(void)
{
    dprintf(" ????");
}

void
fnDumpWordMemory(
    PADDR Start,
    ULONG Count
    )
{
    DumpWord Dumper;
    
    Dumper.Dump(Start, Count);
}

/*** fnDumpDwordMemory - output dword value from memory
*
*   Purpose:
*       Function of "dd<range>" command.
*
*       Output the memory in the specified range as double
*       word values up to 4 double words per line.  The default
*       display is 16 lines for 64 double words total.
*
*   Input:
*       Start - starting address to begin display
*       Count - number of double words to be displayed
*       fDumpSymbols - Dump symbol for DWORD.
*
*   Output:
*       None.
*
*   Notes:
*       memory locations not accessible are output as "????????",
*       but no errors are returned.
*
*************************************************************************/

class DumpDword : public DumpValues
{
public:
    DumpDword(BOOL DumpSymbols)
        : DumpValues(sizeof(DWORD), DumpSymbols ? 1 : 4)
    {
        m_DumpSymbols = DumpSymbols;
    }

protected:
    // Worker methods that derived classes must define.
    virtual ULONG64 GetValue(void);
    virtual BOOL PrintValue(void);
    virtual void PrintUnknown(void);

    BOOL m_DumpSymbols;
};

ULONG64
DumpDword::GetValue(void)
{
    return *(DWORD *)m_Value;
}

BOOL
DumpDword::PrintValue(void)
{
    CHAR   SymBuf[MAX_SYMBOL_LEN];
    USHORT StdCallArgs;
    ULONG64  Displacement;

    dprintf(" %08lx", *(DWORD *)m_Value);

    if (m_DumpSymbols)
    {
        GetSymbolStdCall(EXTEND64(*(LONG *)m_Value),
                         SymBuf,
                         sizeof(SymBuf),
                         &Displacement,
                         &StdCallArgs);

        if (*SymBuf)
        {
            dprintf(" %s", SymBuf);
            if (Displacement)
            {
                dprintf("+0x%s", FormatDisp64(Displacement));
            }

            if (g_SymOptions & SYMOPT_LOAD_LINES)
            {
                OutputLineAddr(EXTEND64(*(LONG*)m_Value), " [%s @ %d]");
            }
        }
    }

    return TRUE;
}

void
DumpDword::PrintUnknown(void)
{
    dprintf(" ????????");
}

void
fnDumpDwordMemory(
    PADDR Start,
    ULONG Count,
    BOOL fDumpSymbols
    )
{
    DumpDword Dumper(fDumpSymbols);

    Dumper.Dump(Start, Count);
}

/*** fnDumpDwordAndCharMemory - output dword value from memory
*
*   Purpose:
*       Function of "dc<range>" command.
*
*       Output the memory in the specified range as double
*       word values up to 4 double words per line, followed by
*       an ASCII character representation of the bytes.
*       The default display is 16 lines for 64 double words total.
*
*   Input:
*       Start - starting address to begin display
*       Count - number of double words to be displayed
*
*   Output:
*       None.
*
*   Notes:
*       memory locations not accessible are output as "????????",
*       but no errors are returned.
*
*************************************************************************/

class DumpDwordAndChar : public DumpValues
{
public:
    DumpDwordAndChar(void)
        : DumpValues(sizeof(DWORD), (sizeof(m_Buf) - 1) / sizeof(DWORD))
    {
        m_Base = m_Buf;
    }

protected:
    // Worker methods that derived classes must define.
    virtual ULONG64 GetValue(void);
    virtual BOOL PrintValue(void);
    virtual void PrintUnknown(void);
    virtual void EndRow(void);

    UCHAR m_Buf[17];
};

ULONG64
DumpDwordAndChar::GetValue(void)
{
    return *(DWORD *)m_Value;
}

BOOL
DumpDwordAndChar::PrintValue(void)
{
    UCHAR ch;
    ULONG byte;

    dprintf(" %08x", *(DWORD *)m_Value);

    for (byte = 0; byte < sizeof(DWORD); byte++)
    {
        ch = *(m_Value + byte);
        if (ch < 0x20 || ch > 0x7e)
        {
            ch = '.';
        }
        *m_Out++ = ch;
    }

    return TRUE;
}

void
DumpDwordAndChar::PrintUnknown(void)
{
    dprintf(" ????????");
    *m_Out++ = '?';
    *m_Out++ = '?';
    *m_Out++ = '?';
    *m_Out++ = '?';
}

void
DumpDwordAndChar::EndRow(void)
{
    *m_Out++ = 0;
    while (m_Col < m_Columns)
    {
        dprintf("         ");
        m_Col++;
    }
    dprintf("  %s", m_Base);
}

void
fnDumpDwordAndCharMemory(PADDR Start, ULONG Count)
{
    DumpDwordAndChar Dumper;

    Dumper.Dump(Start, Count);
}

/*** fnDumpListMemory - output linked list from memory
*
*   Purpose:
*       Function of "dl addr length size" command.
*
*       Output the memory in the specified range as a linked list
*
*   Input:
*       Start - starting address to begin display
*       Count - number of list elements to be displayed
*
*   Output:
*       None.
*
*   Notes:
*       memory locations not accessible are output as "????????",
*       but no errors are returned.
*
*************************************************************************/

void
fnDumpListMemory(
    PADDR Start,
    ULONG elemcount,
    ULONG size,
    BOOL  followBlink
    )
{
    ULONG64 firstaddr;
    ULONG64 link;
    LIST_ENTRY64 list;
    ADDR  curaddr;
    ULONG linkSize;
    PULONG plink;

    if (Type(*Start) & (ADDR_UNKNOWN | ADDR_V86 | ADDR_16 | ADDR_1632))
    {
        dprintf("[%u,%x:%x`%08x,%08x`%08x] - bogus address type.\n",
                Type(*Start),
                Start->seg,
                (ULONG)(Off(*Start)>>32),
                (ULONG)Off(*Start),
                (ULONG)(Flat(*Start)>>32),
                (ULONG)Flat(*Start)
                );
        return;
    }

    //
    // Setup to follow forward or backward links.  Avoid reading more
    // than the forward link here if going forwards. (in case the link
    // is at the end of a page).
    //

    firstaddr = Flat(*Start);
    while (elemcount-- != 0 && Flat(*Start) != 0)
    {
        if (followBlink)
        {
            if (g_Target->ReadListEntry(g_Machine,
                                        Flat(*Start), &list) != S_OK)
            {
                break;
            }
            link = list.Blink;
        }
        else
        {
            if (g_Target->ReadPointer(g_Machine,
                                      Flat(*Start), &link) != S_OK)
            {
                break;
            }
        }

        curaddr = *Start;
        if (g_Machine->m_Ptr64)
        {
            fnDumpQuadMemory(&curaddr, size, FALSE);
        }
        else
        {
            fnDumpDwordMemory(&curaddr, size, FALSE);
        }

        //
        // If we get back to the first entry, we're done.
        //

        if (link == firstaddr)
        {
            break;
        }

        //
        // Bail if the link is immediately circular.
        //

        if (Flat(*Start) == link)
        {
            break;
        }

        Flat(*Start) = Start->off = link;
        
        if (CheckUserInterrupt())
        {
            WarnOut("-- User interrupt\n");
            return;
        }
    }
}

//----------------------------------------------------------------------------
//
// fnDumpFloatMemory
//
// Dumps float values.
//
//----------------------------------------------------------------------------

class DumpFloat : public DumpValues
{
public:
    DumpFloat(void)
        : DumpValues(sizeof(float), 4) {}

protected:
    // Worker methods that derived classes must define.
    virtual ULONG64 GetValue(void);
    virtual BOOL PrintValue(void);
    virtual void PrintUnknown(void);
};

ULONG64
DumpFloat::GetValue(void)
{
    // NTRAID#72849-2000/02/09-drewb.
    // Expression results are always integers right now
    // so just return the raw bits for the float.
    return *(ULONG *)m_Value;
}

BOOL
DumpFloat::PrintValue(void)
{
    dprintf(" %16.8g", *(float *)m_Value);
    return TRUE;
}

void
DumpFloat::PrintUnknown(void)
{
    dprintf(" ????????????????");
}

void
fnDumpFloatMemory(PADDR Start, ULONG Count)
{
    DumpFloat Dumper;
    
    Dumper.Dump(Start, Count);
}

//----------------------------------------------------------------------------
//
// fnDumpDoubleMemory
//
// Dumps double values.
//
//----------------------------------------------------------------------------

class DumpDouble : public DumpValues
{
public:
    DumpDouble(void)
        : DumpValues(sizeof(double), 3) {}

protected:
    // Worker methods that derived classes must define.
    virtual ULONG64 GetValue(void);
    virtual BOOL PrintValue(void);
    virtual void PrintUnknown(void);
};

ULONG64
DumpDouble::GetValue(void)
{
    // NTRAID#72849-2000/02/09-drewb.
    // Expression results are always integers right now
    // so just return the raw bits for the float.
    return *(ULONG64 *)m_Value;
}

BOOL
DumpDouble::PrintValue(void)
{
    dprintf(" %22.12lg", *(double *)m_Value);
    return TRUE;
}

void
DumpDouble::PrintUnknown(void)
{
    dprintf(" ????????????????????????");
}

void
fnDumpDoubleMemory(PADDR Start, ULONG Count)
{
    DumpDouble Dumper;
    
    Dumper.Dump(Start, Count);
}

/*** fnDumpQuadMemory - output quad value from memory
*
*   Purpose:
*       Function of "dq<range>" command.
*
*       Output the memory in the specified range as quad
*       word values up to 2 quad words per line.  The default
*       display is 16 lines for 32 quad words total.
*
*   Input:
*       Start - starting address to begin display
*       Count - number of double words to be displayed
*
*   Output:
*       None.
*
*   Notes:
*       memory locations not accessible are output as "????????",
*       but no errors are returned.
*
*************************************************************************/

class DumpQuad : public DumpValues
{
public:
    DumpQuad(BOOL DumpSymbols)
        : DumpValues(sizeof(ULONGLONG), DumpSymbols ? 1 : 2)
    {
        m_DumpSymbols = DumpSymbols;
    }

protected:
    // Worker methods that derived classes must define.
    virtual ULONG64 GetValue(void);
    virtual BOOL PrintValue(void);
    virtual void PrintUnknown(void);

    BOOL m_DumpSymbols;
};

ULONG64
DumpQuad::GetValue(void)
{
    return *(ULONG64 *)m_Value;
}

BOOL
DumpQuad::PrintValue(void)
{
    CHAR   SymBuf[MAX_SYMBOL_LEN];
    USHORT StdCallArgs;
    ULONG64  Displacement;

    ULONG64 Val = *(ULONG64*)m_Value;
    dprintf(" %08lx`%08lx", (ULONG)(Val >> 32), (ULONG)Val);

    if (m_DumpSymbols)
    {
        GetSymbolStdCall(Val,
                         SymBuf,
                         sizeof(SymBuf),
                         &Displacement,
                         &StdCallArgs);

        if (*SymBuf)
        {
            dprintf(" %s", SymBuf);
            if (Displacement)
            {
                dprintf("+0x%s", FormatDisp64(Displacement));
            }

            if (g_SymOptions & SYMOPT_LOAD_LINES)
            {
                OutputLineAddr(Val, " [%s @ %d]");
            }
        }
    }

    return TRUE;
}

void
DumpQuad::PrintUnknown(void)
{
    dprintf(" ????????`????????");
}

void
fnDumpQuadMemory(
    PADDR Start,
    ULONG Count,
    BOOL fDumpSymbols
    )
{
    DumpQuad Dumper(fDumpSymbols);

    Dumper.Dump(Start, Count);
}

/*** fnDumpByteBinaryMemory - output binary value from memory
*
*   Purpose:
*       Function of "dyb<range>" command.
*
*       Output the memory in the specified range as binary
*       values up to 32 bits per line.  The default
*       display is 8 lines for 32 bytes total.
*
*   Input:
*       Start - starting address to begin display
*       Count - number of double words to be displayed
*
*   Output:
*       None.
*
*   Notes:
*       memory locations not accessible are output as "????????",
*       but no errors are returned.
*
*************************************************************************/

class DumpByteBinary : public DumpValues
{
public:
    DumpByteBinary(void)
        : DumpValues(sizeof(UCHAR), (DIMA(m_HexValue) - 1) / 3)
    {
        m_Base = m_HexValue;
    }

protected:
    // Worker methods that derived classes must define.
    virtual ULONG64 GetValue(void);
    virtual BOOL PrintValue(void);
    virtual void PrintUnknown(void);
    virtual void EndRow(void);

    UCHAR m_HexValue[13];
};

ULONG64
DumpByteBinary::GetValue(void)
{
    return *m_Value;
}

BOOL
DumpByteBinary::PrintValue(void)
{
    ULONG i;
    UCHAR RawVal;

    RawVal = *m_Value;

    sprintf((PSTR)m_Out, " %02x", RawVal);
    m_Out += 3;

    dprintf(" ");
    for (i = 0; i < 8; i++)
    {
        dprintf("%c", (RawVal & 0x80) ? '1' : '0');
        RawVal <<= 1;
    }

    return TRUE;
}

void
DumpByteBinary::PrintUnknown(void)
{
    dprintf(" ????????");
    strcpy((PSTR)m_Out, " ??");
    m_Out += 3;
}

void
DumpByteBinary::EndRow(void)
{
    while (m_Col < m_Columns)
    {
        dprintf("         ");
        m_Col++;
    }
    dprintf(" %s", m_HexValue);
}

void
fnDumpByteBinaryMemory(
    PADDR Start,
    ULONG Count
    )
{
    DumpByteBinary Dumper;
    PSTR Blanks = g_Machine->m_Ptr64 ? "                 " : "        ";

    dprintf("%s  76543210 76543210 76543210 76543210\n", Blanks);
    dprintf("%s  -------- -------- -------- --------\n", Blanks);
    Dumper.Dump(Start, Count);
}

/*** fnDumpDwordBinaryMemory - output binary value from memory
*
*   Purpose:
*       Function of "dyd<range>" command.
*
*       Output the memory in the specified range as binary
*       values of 32 bits per line.  The default
*       display is 8 lines for 8 dwords total.
*
*   Input:
*       Start - starting address to begin display
*       Count - number of double words to be displayed
*
*   Output:
*       None.
*
*   Notes:
*       memory locations not accessible are output as "????????",
*       but no errors are returned.
*
*************************************************************************/

class DumpDwordBinary : public DumpValues
{
public:
    DumpDwordBinary(void)
        : DumpValues(sizeof(ULONG), 1)
    {
    }

protected:
    // Worker methods that derived classes must define.
    virtual ULONG64 GetValue(void);
    virtual BOOL PrintValue(void);
    virtual void PrintUnknown(void);
    virtual void EndRow(void);

    UCHAR m_HexValue[9];
};

ULONG64
DumpDwordBinary::GetValue(void)
{
    return *(PULONG)m_Value;
}

BOOL
DumpDwordBinary::PrintValue(void)
{
    ULONG i;
    ULONG RawVal;

    RawVal = *(PULONG)m_Value;

    sprintf((PSTR)m_HexValue, "%08lx", RawVal);

    for (i = 0; i < sizeof(ULONG) * 8; i++)
    {
        if ((i & 7) == 0)
        {
            dprintf(" ");
        }
        
        dprintf("%c", (RawVal & 0x80000000) ? '1' : '0');
        RawVal <<= 1;
    }

    return TRUE;
}

void
DumpDwordBinary::PrintUnknown(void)
{
    dprintf(" ???????? ???????? ???????? ????????");
    strcpy((PSTR)m_HexValue, "????????");
}

void
DumpDwordBinary::EndRow(void)
{
    dprintf("  %s", m_HexValue);
}

void
fnDumpDwordBinaryMemory(
    PADDR Start,
    ULONG Count
    )
{
    DumpDwordBinary Dumper;
    PSTR Blanks = g_Machine->m_Ptr64 ? "                 " : "        ";

    dprintf("%s   3          2          1          0\n", Blanks);
    dprintf("%s  10987654 32109876 54321098 76543210\n", Blanks);
    dprintf("%s  -------- -------- -------- --------\n", Blanks);
    Dumper.Dump(Start, Count);
}

//----------------------------------------------------------------------------
//
// fnDumpSelector
//
// Dumps an x86 selector.
//
//----------------------------------------------------------------------------

void
fnDumpSelector(
    ULONG Selector
    )
{
    DESCRIPTOR64 Desc;
    ULONG Type;
    LPSTR TypeName;
    PSTR PreFill, PostFill, Dash;

    if (g_Target->GetSelDescriptor(g_Machine,
                                   g_CurrentProcess->CurrentThread->Handle,
                                   Selector, &Desc) != S_OK)
    {
        ErrOut("Unable to get selector %X description\n", Selector);
        return;
    }

    if (g_Machine->m_Ptr64)
    {
        PreFill = "    ";
        PostFill = "     ";
        Dash = "---------";
    }
    else
    {
        PreFill = "";
        PostFill = "";
        Dash = "";
    }
    
    dprintf("Selector   %sBase%s     %sLimit%s   Type  DPL   Size  Gran\n",
            PreFill, PostFill, PreFill, PostFill);
    dprintf("-------- --------%s --------%s ------ --- ------- ----\n",
            Dash, Dash);

    Type = X86_DESC_TYPE(Desc.Flags);
    if ( Type & 0x10 )
    {
        if ( Type & 0x8 )
        {
            // Code Descriptor
            TypeName = " Code ";
        }
        else
        {
            // Data Descriptor
            TypeName = " Data ";
        }
    }
    else
    {
        TypeName = " Sys. ";
    }

    //   1234   12345678 12345678 ?Type?  1  ....... ....
    dprintf("  %04X   %s %s %s  %d  %s %s\n",
            Selector,
            FormatAddr64(Desc.Base),
            FormatAddr64(Desc.Limit),
            TypeName,
            X86_DESC_PRIVILEGE(Desc.Flags),
            (Desc.Flags & X86_DESC_DEFAULT_BIG) ? "  Big  " : "Not Big",
            (Desc.Flags & X86_DESC_GRANULARITY) ? "Page" : "Byte"
            );
}

//----------------------------------------------------------------------------
//
// parseEnterCommand
//
// Parses memory entry commands.
//
//----------------------------------------------------------------------------

void
parseEnterCommand(
    void
    )
{
    CHAR ch;
    static CHAR s_EnterType = 'b';
    ADDR  addr1;
    UCHAR list[STRLISTSIZE * 2];
    PUCHAR plist = &list[0];
    ULONG count;
    ULONG size;

    ch = (CHAR)tolower(*g_CurCmd);
    if (ch == 'a' || ch == 'b' || ch == 'w' || ch == 'd' || ch == 'q' ||
        ch == 'u')
    {
        g_CurCmd++;
        s_EnterType = ch;
    }
    GetAddrExpression(SEGREG_DATA, &addr1);
    if (s_EnterType == 'a' || s_EnterType == 'u')
    {
        AsciiList((PSTR)list, &count);
        if (count == 0)
        {
            error(UNIMPLEMENT);         //TEMP
        }

        if (s_EnterType == 'u')
        {
            ULONG Ansi;
            
            // Expand ANSI to Unicode.
            Ansi = count;
            count *= 2;
            while (Ansi-- > 0)
            {
                list[Ansi * 2] = list[Ansi];
                list[Ansi * 2 + 1] = 0;
            }
        }
    }
    else
    {
        size = 1;
        if (s_EnterType == 'w')
        {
            size = 2;
        }
        else if (s_EnterType == 'd')
        {
            size = 4;
        }
        else if (s_EnterType == 'q')
        {
            size = 8;
        }

        HexList(list, &count, size);
        if (count == 0)
        {
            fnInteractiveEnterMemory(&addr1, size);
            return;
        }
    }

    //
    // memory was entered at the command line.
    // just write it in, one byte at a time
    //

    while (count--)
    {
        if (SetMemString(&addr1, plist++, 1) != 1)
        {
            error(MEMORY);
        }
        AddrAdd(&addr1, 1);
        
        if (CheckUserInterrupt())
        {
            WarnOut("-- User interrupt\n");
            return;
        }
    }
}

//----------------------------------------------------------------------------
//
// fnInteractiveEnterMemory
//
// Interactively walks through memory, displaying current contents
// and prompting for new contents.
//
//----------------------------------------------------------------------------

void
fnInteractiveEnterMemory(
    PADDR Address,
    ULONG Size
    )
{
    CHAR    EnterBuf[1024];
    PSTR    Enter;
    ULONG64 Content;
    PSTR    CmdSaved = g_CurCmd;
    PSTR    StartSaved = g_CommandStart;
    ULONG64 EnteredValue;
    CHAR    ch;

    g_PromptLength = 9 + 2 * Size;

    while (TRUE)
    {
        if (GetMemString(Address, (PUCHAR)&Content, Size) != Size)
        {
            error(MEMORY);
        }
        dprintAddr(Address);

        switch (Size)
        {
        case 1:
            dprintf("%02x", (UCHAR)Content);
            break;

        case 2:
            dprintf("%04x", (USHORT)Content);
            break;

        case 4:
            dprintf("%08lx", (ULONG)Content);
            break;

        case 8:
            dprintf("%08lx`%08lx", (ULONG)(Content>>32), (ULONG)Content);
            break;
        }

        GetInput(" ", EnterBuf, 1024);
        RemoveDelChar(EnterBuf);
        Enter = EnterBuf;

        if (*Enter == '\0')
        {
            g_CurCmd = CmdSaved;
            g_CommandStart = StartSaved;
            return;
        }

        ch = *Enter;
        while (ch == ' ' || ch == '\t' || ch == ';')
        {
            ch = *++Enter;
        }

        if (*Enter == '\0')
        {
            AddrAdd(Address, Size);
            continue;
        }

        g_CurCmd = Enter;
        g_CommandStart = Enter;
        EnteredValue = HexValue(Size);

        if (SetMemString(Address, (PUCHAR)&EnteredValue, Size) != Size)
        {
            error(MEMORY);
        }
        AddrAdd(Address, Size);
    }
}

/*** fnCompareMemory - compare two ranges of memory
*
*   Purpose:
*       Function of "c<range><addr>" command.
*
*       To compare two ranges of memory, starting at offsets
*       src1addr and src2addr, respectively, for length bytes.
*       Bytes that mismatch are displayed with their offsets
*       and contents.
*
*   Input:
*       src1addr - start of first memory region
*       length - count of bytes to compare
*       src2addr - start of second memory region
*
*   Output:
*       None.
*
*   Exceptions:
*       error exit: MEMORY - memory read access failure
*
*************************************************************************/

void
fnCompareMemory(
    PADDR src1addr,
    ULONG length,
    PADDR src2addr
    )
{
    ULONG   compindex;
    UCHAR   src1ch;
    UCHAR   src2ch;

    for (compindex = 0; compindex < length; compindex++)
    {
        if (!GetMemByte(src1addr, &src1ch))
        {
            error(MEMORY);
        }
        if (!GetMemByte(src2addr, &src2ch))
        {
            error(MEMORY);
        }
        if (src1ch != src2ch)
        {
            dprintAddr(src1addr); dprintf(" %02x - ", src1ch);
            dprintAddr(src2addr); dprintf(" %02x\n", src2ch);
        }
        AddrAdd(src1addr,1);
        AddrAdd(src2addr,1);
        
        if (CheckUserInterrupt())
        {
            WarnOut("-- User interrupt\n");
            return;
        }
    }
}

/*** fnMoveMemory - move a range of memory to another
*
*   Purpose:
*       Function of "m<range><addr>" command.
*
*       To move a range of memory starting at srcaddr to memory
*       starting at destaddr for length bytes.
*
*   Input:
*       srcaddr - start of source memory region
*       length - count of bytes to move
*       destaddr - start of destination memory region
*
*   Output:
*       memory at destaddr has moved values
*
*   Exceptions:
*       error exit: MEMORY - memory reading or writing access failure
*
*************************************************************************/

void
fnMoveMemory(
    PADDR srcaddr,
    ULONG length,
    PADDR destaddr
    )
{
    UCHAR   ch;
    ULONG64 incr = 1;

    if (AddrLt(*srcaddr, *destaddr))
    {
        AddrAdd(srcaddr, length - 1);
        AddrAdd(destaddr, length - 1);
        incr = (ULONG64)-1;
    }
    while (length--)
    {
        if (GetMemString(srcaddr, &ch, 1) != 1)
        {
            error(MEMORY);
        }
        if (SetMemString(destaddr, &ch, 1) != 1)
        {
            error(MEMORY);
        }
        AddrAdd(srcaddr, incr);
        AddrAdd(destaddr, incr);
        
        if (CheckUserInterrupt())
        {
            WarnOut("-- User interrupt\n");
            return;
        }
    }
}

/*** fnFillMemory - fill memory with a byte list
*
*   Purpose:
*       Function of "f<range><bytelist>" command.
*
*       To fill a range of memory with the byte list specified.
*       The pattern repeats if the range size is larger than the
*       byte list size.
*
*   Input:
*       Start - offset of memory to fill
*       length - number of bytes to fill
*       *plist - pointer to byte array to define values to set
*       length - size of *plist array
*
*   Exceptions:
*       error exit: MEMORY - memory write access failure
*
*   Output:
*       memory at Start filled.
*
*************************************************************************/

void
ParseFillMemory(void)
{
    HRESULT Status;
    BOOL Virtual = TRUE;
    ADDR Addr;
    ULONG64 Size;
    UCHAR Pattern[STRLISTSIZE];
    ULONG PatternSize;
    ULONG Done;

    if (*g_CurCmd == 'p')
    {
        Virtual = FALSE;
        g_CurCmd++;
    }
    
    GetRange(&Addr, &Size, 1, SEGREG_DATA);
    HexList(Pattern, &PatternSize, 1);
    if (PatternSize == 0)
    {
        error(SYNTAX);
    }

    if (Virtual)
    {
        Status = g_Target->FillVirtual(Flat(Addr), (ULONG)Size,
                                       Pattern, PatternSize,
                                       &Done);
    }
    else
    {
        Status = g_Target->FillPhysical(Flat(Addr), (ULONG)Size,
                                        Pattern, PatternSize,
                                        &Done);
    }

    if (Status != S_OK)
    {
        error(MEMORY);
    }
    else
    {
        dprintf("Filled 0x%x bytes\n", Done);
    }
}

/*** fnSearchMemory - search memory with for a byte list
*
*   Purpose:
*       Function of "s<range><bytelist>" command.
*
*       To search a range of memory with the byte list specified.
*       If a match occurs, the offset of memory is output.
*
*   Input:
*       Start - offset of memory to start search
*       length - size of range to search
*       *plist - pointer to byte array to define values to search
*       count - size of *plist array
*
*   Output:
*       None.
*
*   Exceptions:
*       error exit: MEMORY - memory read access failure
*
*************************************************************************/

void
fnSearchMemory(
    PADDR Start,
    ULONG64 length,
    PUCHAR plist,
    ULONG count,
    ULONG Granularity
    )
{
    ULONG   searchindex;
    ULONG   listindex;
    UCHAR   ch;
    ADDR    tAddr = *Start;

    ULONG64 Found;
    LONG64 SearchLength = length;
    HRESULT st;

    do
    {
        st = g_Target->SearchVirtual(Flat(*Start),
                                     SearchLength,
                                     plist,
                                     count,
                                     Granularity,
                                     &Found);
        if (st == S_OK)
        {
            ADDRFLAT(&tAddr, Found);
            switch(Granularity)
            {
            case 1:
                fnDumpByteMemory(&tAddr, 16);
                break;
            case 2:
                fnDumpWordMemory(&tAddr, 8);
                break;
            case 4:
                fnDumpDwordAndCharMemory(&tAddr, 4);
                break;
            case 8:
                fnDumpQuadMemory(&tAddr, 2, FALSE);
                break;
            }
            
            // Flush out the output immediately so that
            // the user can see partial results during long searches.
            FlushCallbacks();
            
            SearchLength -= Found - Flat(*Start) + Granularity;
            AddrAdd(Start, (ULONG)(Found - Flat(*Start) + Granularity));
        
            if (CheckUserInterrupt())
            {
                WarnOut("-- User interrupt\n");
                return;
            }
        }
    }
    while (SearchLength > 0 && st == S_OK);
}

void
ParseSearchMemory(void)
{
    ADDR Addr;
    ULONG64 Length;
    UCHAR Pat[STRLISTSIZE];
    ULONG PatLen;
    ULONG Gran;

    while (*g_CurCmd == ' ')
    {
        g_CurCmd++;
    }

    Gran = 1;

    if (*g_CurCmd == '-')
    {
        g_CurCmd++;
        switch(*g_CurCmd)
        {
        case 'w':
            Gran = 2;
            break;
        case 'd':
            Gran = 4;
            break;
        case 'q':
            Gran = 8;
            break;
        default:
            error(SYNTAX);
            break;
        }
        g_CurCmd++;
    }
    
    ADDRFLAT(&Addr, 0);
    Length = 16;
    GetRange(&Addr, &Length, Gran, SEGREG_DATA);
    if (Flat(Addr))
    {
        HexList(Pat, &PatLen, Gran);
        if (PatLen == 0)
        {
            PCSTR Err = "Search pattern missing from";
            ReportError(SYNTAX, &Err);
        }
        
        fnSearchMemory(&Addr, Length * Gran, Pat, PatLen, Gran);
    }
}

/*** fnInputIo - read and output io
*
*   Purpose:
*       Function of "ib, iw, id <address>" command.
*
*       Read (input) and print the value at the specified io address.
*
*   Input:
*       IoAddress - Address to read.
*       InputType - The size type 'b', 'w', or 'd'
*
*   Output:
*       None.
*
*   Notes:
*       I/O locations not accessible are output as "??", "????", or
*       "????????", depending on size.  No errors are returned.
*
*************************************************************************/

void
fnInputIo(
    ULONG64 IoAddress,
    UCHAR InputType
    )
{
    ULONG    InputValue;
    ULONG    InputSize = 1;
    HRESULT  Status;
    CHAR     Format[] = "%01lx";

    InputValue = 0;

    if (InputType == 'w')
    {
        InputSize = 2;
    }
    else if (InputType == 'd')
    {
        InputSize = 4;
    }

    Status = g_Target->ReadIo(Isa, 0, 1, IoAddress, &InputValue, InputSize,
                              NULL);

    dprintf("%s: ", FormatAddr64(IoAddress));

    if (Status == S_OK)
    {
        Format[2] = (CHAR)('0' + (InputSize * 2));
        dprintf(Format, InputValue);
    }
    else
    {
        while (InputSize--)
        {
            dprintf("??");
        }
    }

    dprintf("\n");
}

/*** fnOutputIo - output io
*
*   Purpose:
*       Function of "ob, ow, od <address>" command.
*
*       Write a value to the specified io address.
*
*   Input:
*       IoAddress - Address to read.
*       OutputValue - Value to be written
*       OutputType - The output size type 'b', 'w', or 'd'
*
*   Output:
*       None.
*
*   Notes:
*       No errors are returned.
*
*************************************************************************/

void
fnOutputIo (
    ULONG64 IoAddress,
    ULONG OutputValue,
    UCHAR OutputType
    )
{
    ULONG    OutputSize = 1;

    if (OutputType == 'w')
    {
        OutputSize = 2;
    }
    else if (OutputType == 'd')
    {
        OutputSize = 4;
    }

    g_Target->WriteIo(Isa, 0, 1, IoAddress, &OutputValue, OutputSize, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\memcmd.h ===
//----------------------------------------------------------------------------
//
// memcmd.h
//
// Copyright (C) Microsoft Corporation, 1997-2001.
//
//----------------------------------------------------------------------------

#ifndef _MEMCMD_H_
#define _MEMCMD_H_

extern ULONG64 EXPRLastDump;
extern ADDR    g_DumpDefault;

#define GetMemByte(addr, value) \
    (BOOL)(GetMemString(addr, value, sizeof(UCHAR)) == sizeof(UCHAR))

#define GetMemWord(addr, value) \
    (BOOL)(GetMemString(addr, (PUCHAR)value, sizeof(USHORT)) == \
              sizeof(USHORT))

#define GetMemDword(addr, value) \
    (BOOL)(GetMemString(addr, (PUCHAR)value, sizeof(ULONG)) == \
              sizeof(ULONG))

#define GetMemQword(addr, value) \
    (BOOL)(GetMemString(addr, (PUCHAR)value, sizeof(ULONG64)) == \
              sizeof(ULONG64))

#define GetMemString(Addr, Value, Length) \
    GetProcessMemString(g_CurrentProcess, Addr, Value, Length)
#define SetMemString(Addr, Value, Length) \
    SetProcessMemString(g_CurrentProcess, Addr, Value, Length)

ULONG
GetProcessMemString(
    PPROCESS_INFO Process,
    PADDR Addr,
    PVOID Value,
    ULONG Length
    );

ULONG
SetProcessMemString(
    PPROCESS_INFO Process,
    PADDR Addr,
    PVOID Value,
    ULONG Length
    );

void parseDumpCommand(void);
void parseEnterCommand(void);

ULONG fnDumpAsciiMemory(PADDR, ULONG);
ULONG fnDumpUnicodeMemory (PADDR startaddr, ULONG count);
void fnDumpByteMemory(PADDR, ULONG);
void fnDumpWordMemory(PADDR, ULONG);
void fnDumpDwordMemory(PADDR startaddr, ULONG count, BOOL fDumpSymbols);
void fnDumpDwordAndCharMemory(PADDR, ULONG);
void fnDumpListMemory(PADDR, ULONG, ULONG, BOOL);
void fnDumpFloatMemory(PADDR Start, ULONG Count);
void fnDumpDoubleMemory(PADDR Start, ULONG Count);
void fnDumpQuadMemory(PADDR Start, ULONG Count, BOOL fDumpSymbols);
void fnDumpByteBinaryMemory(PADDR startaddr, ULONG count);
void fnDumpDwordBinaryMemory(PADDR startaddr, ULONG count);
void fnDumpSelector(ULONG Selector);

void fnInteractiveEnterMemory(PADDR, ULONG);
void fnEnterMemory(PADDR, PUCHAR, ULONG);

void fnCompareMemory(PADDR, ULONG, PADDR);
void fnMoveMemory(PADDR, ULONG, PADDR);

void ParseFillMemory(void);
void ParseSearchMemory(void);

void fnInputIo(ULONG64, UCHAR);
void fnOutputIo (ULONG64, ULONG, UCHAR);

#endif // #ifndef _MEMCMD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\mmap.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    mmap.h

Abstract:

    Public header for memmory map class.

Author:

    Matthew D Hendel (math) 16-Sept-1999

Revision History:

--*/

#define HR_REGION_CONFLICT HRESULT_FROM_NT(STATUS_CONFLICTING_ADDRESSES)

BOOL
MemoryMap_Create(
    VOID
    );

BOOL
MemoryMap_Destroy(
    VOID
    );

HRESULT
MemoryMap_AddRegion(
    ULONG64 BaseOfRegion,
    ULONG SizeOfRegion,
    PVOID Buffer,
    PVOID UserData,
    BOOL AllowOverlap
    );

BOOL
MemoryMap_ReadMemory(
    ULONG64 BaseOfRange,
    OUT PVOID Buffer,
    ULONG SizeOfRange,
    PULONG BytesRead
    );

BOOL
MemoryMap_CheckMap(
    IN PVOID Map
    );

BOOL
MemoryMap_GetRegionInfo(
    IN ULONG64 Addr,
    OUT ULONG64* BaseOfRegion, OPTIONAL
    OUT ULONG* SizeOfRegion, OPTIONAL
    OUT PVOID* Buffer, OPTIONAL
    OUT PVOID* UserData OPTIONAL
    );

BOOL
MemoryMap_RemoveRegion(
    IN ULONG64 BaseOfRegion,
    IN ULONG SizeOfRegion
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\ntalias.cpp ===
/*** ntalias.cpp - Alias command processor for NT debugger
*
*   Copyright <C> 1999-2001, Microsoft Corporation
*
*   Purpose:
*       To establish, maintain, and translate alias command tokens
*
*
*   Revision History:
*
*   [-]  08-Aug-1999 Richg      Created.
*
*************************************************************************/

#include "ntsdp.hpp"

PALIAS g_AliasListHead;                 // List of alias elements
ULONG  g_NumAliases;


HRESULT
SetAlias(PCSTR SrcText, PCSTR DstText)
{
    PALIAS pPrevAlias;
    PALIAS pCurAlias;
    PALIAS pNewAlias;

    pNewAlias = (PALIAS)malloc( sizeof(ALIAS) + strlen(SrcText) +
                                strlen(DstText) + 2 );
    if (!pNewAlias)
    {
        return E_OUTOFMEMORY;
    }

    //
    //  Locate Alias, or insertion point
    //
    //  This insertion scheme maintains a sorted list of
    //  alias elements by name.
    //

    pPrevAlias = NULL;
    pCurAlias  = g_AliasListHead;

    while (( pCurAlias != NULL )  &&
           ( strcmp( SrcText, pCurAlias->Name ) > 0 ))
    {
        pPrevAlias = pCurAlias;
        pCurAlias  = pCurAlias->Next;
    }

    //  If there is already an element by that name, clear it.
    if (pCurAlias != NULL &&
        !strcmp(SrcText, pCurAlias->Name))
    {
        PALIAS pTmpAlias = pCurAlias->Next;
        free(pCurAlias);
        pCurAlias = pTmpAlias;
        g_NumAliases--;
    }

    pNewAlias->Next = pCurAlias;
    if (pPrevAlias == NULL)
    {
        g_AliasListHead = pNewAlias;
    }
    else
    {
        pPrevAlias->Next = pNewAlias;
    }
    
    pNewAlias->Name = (PSTR)(pNewAlias + 1);
    pNewAlias->Value = pNewAlias->Name + strlen(SrcText) + 1;
    strcpy( pNewAlias->Name, SrcText  );
    strcpy( pNewAlias->Value, DstText );
    g_NumAliases++;

    return S_OK;
}

/*** ParseSetAlias - Set an alias expression
*
*   Purpose:
*       From the current command line position at g_CurCmd,
*       read the alias name and value tokens.  Once obtained
*       perform an alias list lookup to see if it is a redefinition.
*       If not allocate a new alias element and place it on the
*       alias element list.
*
*
*   Input:
*       Global: g_CurCmd - command line position
*       Global: g_AliasListHead
*
*   Returns:
*       Status
*
*   Exceptions:
*       error exit: SYNTAX errors
*
*************************************************************************/

void
ParseSetAlias(void)
{
    PSTR  pAliasName;
    PSTR  pAliasValue;
    UCHAR ch;

    //
    //  Locate alias name
    //
    PeekChar();

    pAliasName = g_CurCmd;

    do
    {
        ch = *g_CurCmd++;
    } while (ch != ' ' && ch != '\t' && ch != '\0' && ch != ';');

    if ( (ULONG_PTR)(g_CurCmd-1) == (ULONG_PTR)pAliasName )
    {
        error(SYNTAX);
    }

    *--g_CurCmd = '\0';       // Back up and null terminate
                                // the alias name token
    g_CurCmd++;               // -> next char

    //
    //   Locate alias value,  take remaining cmd line as value
    //

    PeekChar();

    pAliasValue = g_CurCmd;

    do
    {
        ch = *g_CurCmd++;
    } while (ch != '\t' && ch != '\0');

    if ( (ULONG_PTR)(g_CurCmd-1) == (ULONG_PTR)pAliasValue )
    {
        error(SYNTAX);
    }

    *--g_CurCmd = '\0';       // Back up and Null terminate
                                // the alias value token

    if (SetAlias(pAliasName, pAliasValue) != S_OK)
    {
        error(MEMORY);
    }
}

HRESULT
DeleteAlias(PCSTR SrcText)
{
    PALIAS pCurAlias;

    if (SrcText[0] == '*' && SrcText[1] == 0)
    {
        //
        //  Delete all aliases
        //
        while ( g_AliasListHead != NULL )
        {
            //
            //  Unchain the element and free it
            //
            pCurAlias = g_AliasListHead->Next;
            free(g_AliasListHead);
            g_AliasListHead = pCurAlias;
        }

        g_NumAliases = 0;
    }
    else
    {
        PALIAS pPrevAlias;
    
        //
        //  Locate and delete the specified alias
        //

        pPrevAlias = NULL;
        pCurAlias  = g_AliasListHead;

        while (( pCurAlias != NULL )  &&
               ( strcmp( SrcText, pCurAlias->Name )))
        {
            pPrevAlias = pCurAlias;
            pCurAlias  = pCurAlias->Next;
        }

        if ( pCurAlias == NULL )
        {
            return E_NOINTERFACE;
        }

        //
        //  Unchain the element and free it
        //
        if (pPrevAlias == NULL)
        {
            g_AliasListHead = pCurAlias->Next;
        }
        else
        {
            pPrevAlias->Next = pCurAlias->Next;
        }
        free( pCurAlias );
        g_NumAliases--;
    }

    return S_OK;
}

/*** ParseDeleteAlias - Delete an alias expression
*
*   Purpose:
*       From the current command line position at g_CurCmd,
*       read the ALias name and perform an alias list lookup
*       to see if it exists and unlink and delete the element.
*
*
*   Input:
*       Global: g_CurCmd - command line position
*       Global: g_AliasListHead
*
*   Returns:
*       Status
*
*   Exceptions:
*       error exit: SYNTAX errors or non-existent element
*
*************************************************************************/

void
ParseDeleteAlias(void)
{
    PSTR  pAliasName;
    UCHAR ch;

    //
    //  Locate alias name on cmd line
    //
    PeekChar();

    pAliasName = g_CurCmd;

    do
    {
        ch = *g_CurCmd++;
    } while (ch != ' ' && ch != '\t' && ch != '\0' && ch != ';');

    if ( (ULONG_PTR)(g_CurCmd-1) == (ULONG_PTR)pAliasName )
    {
        error(SYNTAX);
    }

    *--g_CurCmd = '\0';       // Null terminate the token
    if (ch != '\0')
    {
        g_CurCmd++;
    }

    if (DeleteAlias(pAliasName) != S_OK)
    {
        error(NOTFOUND);
    }
}

/*** ListAliases - List the alias structures
*
*   Purpose:
*       Read and display all of the alias list elements.
*
*
*   Input:
*       Global:  g_AliasListHead
*
*   Returns:
*       Status
*
*   Exceptions:
*       None
*
*************************************************************************/

void
ListAliases(void)
{
    PALIAS pCurAlias;

    pCurAlias = g_AliasListHead;

    if ( pCurAlias == NULL )
    {
        dprintf( "No Alias entries to list. \n" );
        return;
    }

    dprintf   ("  Alias            Value  \n");
    dprintf   (" -------          ------- \n");

    while ( pCurAlias != NULL )
    {
        dprintf(" %-16s %s \n", pCurAlias->Name, pCurAlias->Value );

        pCurAlias = pCurAlias->Next;
    }
}

/*** ReplaceAliases - Replace aliases in the given command string
*
*   Purpose:
*       From the current command line position at g_CurCmd,
*       read each token and build a new command line, replacing
*       tokens with alias value data.  A lookup is performed on
*       each original command line token to determine if it is
*       defined in the alias list.  If so it is replaced on the
*       new command line,  otherwise the original token is
*       placed on the new command line.
*
*
*   Input:
*       Global: g_CurCmd - command line position
*       Global: g_AliasListHead
*
*
*   Returns:
*       Global: g_CurCmd - command line position
*       Global: chCommand
*       Status
*
*************************************************************************/

void
ReplaceAliases(PSTR CommandString)
{
    PSTR        Command = CommandString;
    CHAR       *pToken;
    CHAR        ch;
    CHAR        chdelim[2];

    CHAR        chAliasCommand[MAX_COMMAND];      //  Alias build command area
    CHAR       *pchAliasCommand;

    ULONG       TokenLen;

    PALIAS      pPrevAlias;
    PALIAS      pCurAlias;

    BOOLEAN     LineEnd;


    // If the incoming command looks like an alias-manipulation
    // command don't replace aliases.
    if (CommandString[0] == 'a' &&
        (CommandString[1] == 'd' ||
         CommandString[1] == 'l' ||
         CommandString[1] == 's'))
    {
        return;
    }

    // If the incoming command is all spaces it's probably
    // the result of control characters getting mapped to
    // spaces.  Don't process it as there can't be any
    // aliases and we don't want the trailing space trimming
    // to remove the input space.
    while (*Command == ' ')
    {
        Command++;
    }
    if (*Command == 0)
    {
        return;
    }

    Command = CommandString;
    pchAliasCommand  = chAliasCommand;

    ZeroMemory( pchAliasCommand, sizeof(chAliasCommand) );

    LineEnd = FALSE;

    do
    {
        //
        //  Locate command line token
        //
        while (isspace(*Command))
        {
            PSTR AliasCmdEnd =
                pchAliasCommand + strlen(pchAliasCommand);
            *AliasCmdEnd++ = *Command++;
            *AliasCmdEnd = 0;
        }
       
        pToken = Command;

        do
        {
            ch = *Command++;
        } while (ch != ' '  &&
                 ch != '\'' &&
                 ch != '"'  &&
                 ch != ';'  &&
                 ch != '\t' &&
                 ch != '\0');


        //
        //  Preserve the token delimiter
        //
        chdelim[0] = ch;
        chdelim[1] = '\0';

        if ( ch == '\0' )
        {
            LineEnd = TRUE;
        }

        TokenLen = (ULONG)((Command - 1) - pToken);

        if ( TokenLen != 0 )
        {
            *--Command = '\0';       // Null terminate the string
            Command++;
            ch = *Command;

            //
            //  Locate Alias or end of list
            //
            pCurAlias  = g_AliasListHead;

            while (( pCurAlias != NULL )  &&
                   ( strcmp( pToken, pCurAlias->Name )))
            {
                pCurAlias  = pCurAlias->Next;
            }

            if ( pCurAlias != NULL )
            {
                strcat( pchAliasCommand, pCurAlias->Value );
            }
            else
            {
                strcat( pchAliasCommand, pToken );
            }
        }
        strcat( pchAliasCommand, chdelim );

    } while( !LineEnd );

    //
    //  Strip off any trailing blanks
    //
    pchAliasCommand += strlen( pchAliasCommand );
    ch = *pchAliasCommand;
    while ( ch == '\0' || ch == ' ' )
    {
        *pchAliasCommand = '\0';
        ch = *--pchAliasCommand;
    }

    //
    //  Place the new command line in the command string buffer.
    //
    strcpy( CommandString, chAliasCommand );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\mmap.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    mmap.cpp

Abstract:

    Implementation of memory map class.
    
Author:

    Matthew D Hendel (math) 16-Sep-1999

Revision History:

--*/


#include "ntsdp.hpp"

#define MEMORY_MAP_CHECK (0xDEADF00D)

typedef struct _MEMORY_MAP_ENTRY
{
    ULONG64 BaseOfRegion;
    ULONG SizeOfRegion;
    PVOID Region;
    PVOID UserData;
    BOOL AllowOverlap;
    struct _MEMORY_MAP_ENTRY * Next;
} MEMORY_MAP_ENTRY, * PMEMORY_MAP_ENTRY;


typedef struct _MEMORY_MAP
{
    PMEMORY_MAP_ENTRY List;
    ULONG Check;
    ULONG RegionCount;
} MEMORY_MAP, * PMEMORY_MAP;


PMEMORY_MAP MemoryMap;



PMEMORY_MAP_ENTRY
MemoryMap_FindPreceedingRegion(
    ULONG64 Addr
    );
    
PMEMORY_MAP_ENTRY
MemoryMap_FindContainingRegion(
    ULONG64 Addr
    );




    

BOOL
MemoryMap_Create(
    VOID
    )
/*++
--*/

{
    MemoryMap = (PMEMORY_MAP) malloc ( sizeof (MEMORY_MAP) );
    if (!MemoryMap)
    {
        return FALSE;
    }

    MemoryMap->Check = MEMORY_MAP_CHECK;
    MemoryMap->RegionCount = 0;
    MemoryMap->List = NULL;

    return TRUE;
}


BOOL
MemoryMap_Destroy(
    VOID
    )
/*++
--*/

{
    if (MemoryMap == NULL)
    {
        return TRUE;
    }
    
    PMEMORY_MAP_ENTRY Entry;
    PMEMORY_MAP_ENTRY Next;

    Entry = MemoryMap->List;
    while ( Entry != NULL )
    {
        Next = Entry->Next;
        free ( Entry );
        Entry = Next;
    }

    MemoryMap->Check = 0;
    free ( MemoryMap );
    MemoryMap = NULL;

    return TRUE;
}


PMEMORY_MAP_ENTRY
AddMapEntry(ULONG64 BaseOfRegion, ULONG SizeOfRegion,
            PVOID Buffer, PVOID UserData,
            BOOL AllowOverlap)
{
    PMEMORY_MAP_ENTRY PrevEntry;
    PMEMORY_MAP_ENTRY MapEntry;
    
    MapEntry = (MEMORY_MAP_ENTRY *)malloc ( sizeof ( MEMORY_MAP_ENTRY ) );
    if (!MapEntry)
    {
        return NULL;
    }

    MapEntry->BaseOfRegion = BaseOfRegion;
    MapEntry->SizeOfRegion = SizeOfRegion;
    MapEntry->Region = Buffer;
    MapEntry->UserData = UserData;
    MapEntry->AllowOverlap = AllowOverlap;
    MapEntry->Next = NULL;

    //
    // Insert the element.
    //

    PrevEntry = MemoryMap_FindPreceedingRegion(BaseOfRegion);
    if ( PrevEntry == NULL )
    {
        //
        // Insert at head.
        //
        
        MapEntry->Next = MemoryMap->List;
        MemoryMap->List = MapEntry;
    }
    else
    {
        //
        // Insert in order.
        //
        
        MapEntry->Next = PrevEntry->Next;
        PrevEntry->Next = MapEntry;
    }

    MemoryMap->RegionCount++;

    return MapEntry;
}
    
HRESULT
MemoryMap_AddRegion(
    IN ULONG64 BaseOfRegion,
    IN ULONG SizeOfRegion,
    IN PVOID Buffer,
    IN PVOID UserData,
    IN BOOL AllowOverlap
    )

/*++

Routine Description:

    Add a region to a memory map. The region must not overlap with any
    other region that is already contained in the map.

Return Values:

    TRUE - On success.

    FALSE - On failure.

--*/

{
    PMEMORY_MAP_ENTRY PrevEntry;
    PMEMORY_MAP_ENTRY MapEntry;

    //
    // The region size cannot be zero.
    //
    
    if (SizeOfRegion == 0)
    {
        ErrOut("**** MemoryMap_AddRegion: Empty region being added.\n");
        return S_OK;
    }

    if (IsBadReadPtr(Buffer, SizeOfRegion))
    {
        ErrOut("**** MemoryMap_AddRegion: Mapping too small to map "
               "%s:%X from %p\n", FormatAddr64(BaseOfRegion),
               SizeOfRegion, Buffer);
        return E_INVALIDARG;
    }

    if (MemoryMap == NULL)
    {
        ErrOut("Memory map not initialized\n");
        return E_NOINTERFACE;
    }
    
    ULONG64 EndOfRegion;
    ULONG64 EndOfEntryRegion;
    PMEMORY_MAP_ENTRY Entry;
    ULONG Size;

    while (SizeOfRegion > 0)
    {
        //
        // Find the first overlapping region.
        // We need to rescan the whole list as it
        // may have changed due to insertion of fragments
        // of the new region.
        //
        
        EndOfRegion = BaseOfRegion + SizeOfRegion;
        for (Entry = MemoryMap->List; Entry != NULL; Entry = Entry->Next)
        {
            EndOfEntryRegion = Entry->BaseOfRegion + Entry->SizeOfRegion;

            if (EndOfRegion > Entry->BaseOfRegion &&
                Entry->BaseOfRegion >= BaseOfRegion)
            {
                if (AllowOverlap || Entry->AllowOverlap)
                {
                    // Overlap can occur when a stack, ethread or
                    // eprocess is taken from static data in an image.
                    // For example, the x86 idle process is static
                    // data in ntoskrnl.  Triage dumps contain the
                    // eprocess data and it gets mapped and can overlap
                    // with the ntoskrnl image.
#if 0
                    WarnOut("WARNING: Allowing overlapped region %s - %s\n",
                            FormatAddr64(BaseOfRegion),
                            FormatAddr64(BaseOfRegion + SizeOfRegion - 1));
#endif
                    Entry = NULL;
                }

                break;
            }
        }

        if (Entry == NULL ||
            BaseOfRegion < Entry->BaseOfRegion)
        {
            // There's a portion of the beginning of the new
            // region which does not overlap so add it and
            // trim the description.
        
            Size = Entry == NULL ? SizeOfRegion :
                (ULONG)(Entry->BaseOfRegion - BaseOfRegion);
            if (!AddMapEntry(BaseOfRegion, Size, Buffer, UserData,
                             AllowOverlap))
            {
                return E_OUTOFMEMORY;
            }

            if (Size == SizeOfRegion)
            {
                // None of the region overlapped so we're done.
                return S_OK;
            }
        
            BaseOfRegion += Size;
            SizeOfRegion -= Size;
            Buffer = (PUCHAR)Buffer + Size;
        }

        //
        // Now handle the overlap.
        //

        if (SizeOfRegion > Entry->SizeOfRegion)
        {
            Size = Entry->SizeOfRegion;
        }
        else
        {
            Size = SizeOfRegion;
        }

        if (memcmp(Buffer, Entry->Region, Size))
        {
            ErrOut("**** MemoryMap_AddRegion: "
                   "Conflicting region %s - %s\n",
                   FormatAddr64(BaseOfRegion),
                   FormatAddr64(BaseOfRegion + SizeOfRegion - 1));
            return HR_REGION_CONFLICT;
        }

        // Overlap region data matched so it's OK to just
        // trim the overlap out of the new region and move
        // on to the next possible overlap.
        BaseOfRegion += Size;
        SizeOfRegion -= Size;
        Buffer = (PUCHAR)Buffer + Size;
    }
    
    return S_OK;
}


BOOL
MemoryMap_ReadMemory(
    IN ULONG64 BaseOfRange,
    IN OUT PVOID Buffer,
    IN ULONG SizeOfRange,
    OUT ULONG * BytesRead
    )

/*++

Routine Description:

    Read memory from the memory map. ReadMemory can read across regions, as
    long as there is no unallocated space between regions.

    This routine will do a partial read if the region ends before
    SizeOfRange bytes have been read. In that case BytesRead will return the
    number of bytes actually read.

Arguments:

    BaseOfRange - The base address where we want to read memory from.

    SizeOfRange - The length of the region to read memory from.

    Buffer - A pointer to a buffer to read memory into.

    BytesRead - On success, the number of bytes successfully read.

Return Values:

    TRUE - If any number of bytes were successfully read from the memory map.

    FALSE - If no bytes were read.

--*/

{
    ULONG BytesToReadFromRegion;
    PMEMORY_MAP_ENTRY Entry;
    ULONG64 BaseToRead;
    ULONG SizeToRead;
    PBYTE BufferForRead;
    ULONG_PTR OffsetToRead;
    ULONG Read;
    ULONG AvailSize;

    //
    // We return TRUE if we read any bytes successfully and FALSE if not.
    //

    *BytesRead = 0;
    
    BaseToRead = BaseOfRange;
    SizeToRead = SizeOfRange;
    BufferForRead = (PBYTE) Buffer;

    do
    {
        Entry = MemoryMap_FindContainingRegion(BaseToRead);

        if ( !Entry )
        {
            if (*BytesRead)
            {
                return TRUE;
            }
            else
            {
                return FALSE;
            }
        }

        PMEMORY_MAP_ENTRY NextEntry = Entry->Next;
        
        // Due to overlap there may be other entries
        // that need to be processed even before the
        // end of the containing region.
        AvailSize = Entry->SizeOfRegion;
        while (NextEntry != NULL)
        {
            if (NextEntry->BaseOfRegion > BaseToRead)
            {
                ULONG64 EntryDiff =
                    NextEntry->BaseOfRegion - Entry->BaseOfRegion;
                if (EntryDiff < AvailSize)
                {
                    AvailSize = (ULONG)EntryDiff;
                }
                break;
            }

            NextEntry = NextEntry->Next;
        }

        if (BaseToRead + SizeToRead > Entry->BaseOfRegion + AvailSize)
        {
            BytesToReadFromRegion = (ULONG)
                (Entry->BaseOfRegion - BaseToRead) + AvailSize;
        }
        else
        {
            BytesToReadFromRegion = SizeToRead;
        }

        OffsetToRead = (ULONG_PTR) (BaseToRead - Entry->BaseOfRegion);

        __try
        {
            RtlCopyMemory (BufferForRead,
                           (PBYTE)Entry->Region + OffsetToRead,
                           BytesToReadFromRegion
                           );
        }
        __except(MappingExceptionFilter(GetExceptionInformation()))
        {
            return FALSE;
        }

        *BytesRead += BytesToReadFromRegion;
        BaseToRead += BytesToReadFromRegion;
        SizeToRead -= BytesToReadFromRegion;
        BufferForRead += BytesToReadFromRegion;
    } while ( SizeToRead );

    return TRUE;
}
        
        

BOOL
MemoryMap_GetRegionInfo(
    IN ULONG64 Addr,
    OUT ULONG64* BaseOfRegion, OPTIONAL
    OUT ULONG* SizeOfRegion, OPTIONAL
    OUT PVOID* Buffer, OPTIONAL
    OUT PVOID* UserData OPTIONAL
    )

/*++

Routine Description:

    Get information about the region containing the address Addr.

Arguments:

    Addr - An address that is contained within some region in the map.

    BaseOfRegion - Pointer to a buffer to return the region base.

    SizeOfRegion - Pointer to a buffer to retutn the region size.

    Buffer - Pointer to a buffer to return the region buffer pointer.

    UserData - Pointer to a buffer to return the region client param.

Return Values:

    TRUE - On success.

    FALSE - On failure.

--*/

{
    PMEMORY_MAP_ENTRY Entry;

    Entry = MemoryMap_FindContainingRegion(Addr);

    if ( !Entry )
    {
        return FALSE;
    }

    if ( BaseOfRegion )
    {
        *BaseOfRegion = Entry->BaseOfRegion;
    }

    if ( SizeOfRegion )
    {
        *SizeOfRegion = Entry->SizeOfRegion;
    }

    if ( Buffer )
    {
        *Buffer = Entry->Region;
    }

    if ( UserData )
    {
        *UserData = Entry->UserData;
    }

    return TRUE;
}


BOOL
MemoryMap_RemoveRegion(
    IN ULONG64 BaseOfRegion,
    IN ULONG SizeOfRegion
    )
{
    if (MemoryMap == NULL)
    {
        return FALSE;
    }
    
    // XXX drewb - This should carve the given region out of
    // any existing regions.  Right now we don't need general
    // removal functionality though so only handle the case
    // where the requested removal is an exact single region
    // match.

    PMEMORY_MAP_ENTRY PrevEntry;
    PMEMORY_MAP_ENTRY Entry;

    PrevEntry = MemoryMap_FindPreceedingRegion(BaseOfRegion);
    if (PrevEntry != NULL)
    {
        Entry = PrevEntry->Next;
    }
    else
    {
        Entry = MemoryMap->List;
    }

    if (Entry == NULL)
    {
        ErrOut("MemoryMap_RemoveRegion NULL region for %s:%x\n",
               FormatAddr64(BaseOfRegion), SizeOfRegion);
        return FALSE;
    }
    else if (Entry->BaseOfRegion != BaseOfRegion ||
             Entry->SizeOfRegion != SizeOfRegion)
    {
        ErrOut("MemoryMap_RemoveRegion region mismatch: "
               "%s:%x vs. entry %s:%x\n",
               FormatAddr64(BaseOfRegion), SizeOfRegion,
               FormatAddr64(Entry->BaseOfRegion), Entry->SizeOfRegion);
        return FALSE;
    }

    if (PrevEntry == NULL)
    {
        MemoryMap->List = Entry->Next;
    }
    else
    {
        PrevEntry->Next = Entry->Next;
    }
    free(Entry);
    MemoryMap->RegionCount--;

    return TRUE;
}

//
// Private functions
//


PMEMORY_MAP_ENTRY
MemoryMap_FindPreceedingRegion(
    IN ULONG64 BaseOfRegion
    )
{
    if (MemoryMap == NULL)
    {
        return NULL;
    }
    
    PMEMORY_MAP_ENTRY PrevEntry;
    PMEMORY_MAP_ENTRY Entry;

    PrevEntry = NULL;
    Entry = MemoryMap->List;

    while (Entry != NULL)
    {
        //
        // Assuming they're in order.
        //
        
        if ( Entry->BaseOfRegion >= BaseOfRegion )
        {
            return PrevEntry;
        }

        PrevEntry = Entry;
        Entry = Entry->Next;
    }

    return PrevEntry;
}


PMEMORY_MAP_ENTRY
MemoryMap_FindContainingRegion(
    IN ULONG64 Addr
    )
{
    if (MemoryMap == NULL)
    {
        return NULL;
    }
    
    PMEMORY_MAP_ENTRY Entry;
    PMEMORY_MAP_ENTRY ReturnEntry = NULL;

    Entry = MemoryMap->List;

    //
    // We may have overlapping regions, so keep going until we find
    // the most precise one (assumed to be the one we care about)
    //

    while ( Entry != NULL )
    {
        if ( Entry->BaseOfRegion <= Addr &&
             Addr < Entry->BaseOfRegion + Entry->SizeOfRegion)
        {
            ReturnEntry = Entry;
        }
        else if (ReturnEntry != NULL &&
                 Addr >= ReturnEntry->BaseOfRegion + ReturnEntry->SizeOfRegion)
        {
            // Optimization - we can stop searching if we've already
            // found a block and have now left its region.  We can't
            // stop as long as we're in its region as there may
            // be more exact overlaps anywhere within the entire region.
            break;
        }

        Entry = Entry->Next;
    }

    return ReturnEntry;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\ntcmd.cpp ===
/*** ntcmd.cpp - command processor for NT debugger
*
*   Copyright <C> 1990-2001, Microsoft Corporation
*
*   Purpose:
*       To determine if the command processor should be invoked, and
*       if so, to parse and execute those commands entered.
*
*************************************************************************/

#include "ntsdp.hpp"
#include <time.h>
#include <dbgver.h>

ULONG g_X86BiosBaseAddress;

#define CRASH_BUGCHECK_CODE   0xDEADDEAD

API_VERSION g_NtsdApiVersion =
{
    BUILD_MAJOR_VERSION, BUILD_MINOR_VERSION, API_VERSION_NUMBER, 0
};

API_VERSION g_DbgHelpAV;

// Set if registers should be displayed by default in OutCurInfo.
BOOL g_OciOutputRegs;

ULONG g_DefaultStackTraceDepth = 20;

BOOL g_EchoEventTimestamps;

BOOL g_SwitchedProcs;

// Last command executed.
CHAR g_LastCommand[MAX_COMMAND];

//      state variables for top-level command processing

PSTR    g_CommandStart;         //  start of command buffer
PSTR    g_CurCmd;               //  current pointer in command buffer
ULONG   g_PromptLength = 8;     //  size of prompt string

ADDR g_UnasmDefault; //  default unassembly address
ADDR g_AssemDefault; //  default assembly address

ULONG   g_DefaultRadix = 16;            //  default input base

CHAR    g_SymbolSuffix = 'n';   //  suffix to add to symbol if search
                                //  failure - 'n'-none 'a'-'w'-append

CHAR    g_CmdState = 'i';       //  state of present command processing
                                //  'i'-init; 'g'-go; 't'-trace
                                //  'p'-step; 'c'-cmd; 'b'-branch trace


int g_RedoCount = 0;

BOOL DotCommand(DebugClient* Client);
void EvaluateExp(BOOL Verbose);
void SetSuffix(void);

void
StackTrace(
    PSTR arg
    );

VOID
DumpExr(
    ULONG64 Exr
    );

void
CallBugCheckExtension(DebugClient* Client)
{
    HRESULT Status = E_FAIL;

    if (Client == NULL)
    {
        // Use the session client.
        for (Client = g_Clients; Client != NULL; Client = Client->m_Next)
        {
            if ((Client->m_Flags & (CLIENT_REMOTE | CLIENT_PRIMARY)) ==
                CLIENT_PRIMARY)
            {
                break;
            }
        }
        if (Client == NULL)
        {
            Client = g_Clients;
        }
    }
    
    if (Client != NULL)
    {
        char ExtName[32];

        // Extension name has to be in writable memory as it
        // gets lower-cased.
        strcpy(ExtName, "AnalyzeBugCheck");
        
        // See if any existing extension DLLs are interested
        // in analyzing this bugcheck.
        CallAnyExtension(Client, NULL, ExtName, "",
                         FALSE, FALSE, &Status);
    }

    if (Status != S_OK)
    {
        if (Client == NULL)
        {
            WarnOut("WARNING: Unable to locate a client for "
                    "bugcheck analysis\n");
        }
        
        dprintf("*******************************************************************************\n");
        dprintf("*                                                                             *\n");
        dprintf("*                        Bugcheck Analysis                                    *\n");
        dprintf("*                                                                             *\n");
        dprintf("*******************************************************************************\n");

        Execute(Client, ".bugcheck", DEBUG_EXECUTE_DEFAULT);
        dprintf("\n");
        Execute(Client, "kb", DEBUG_EXECUTE_DEFAULT);
        dprintf("\n");
    }


}

BOOL
dotFrame(
    )
{
    PDEBUG_STACK_FRAME pStackFrame;
    ULONG Traced = 0, Frame = 0;

    if (PeekChar())
    {
        Frame = (ULONG) GetExpression();
    }
    else
    {
        return TRUE;
    }

    pStackFrame = (PDEBUG_STACK_FRAME)
        malloc(sizeof(DEBUG_STACK_FRAME) * (Frame + 1));
    if (!pStackFrame)
    {
        return FALSE;
    }
    Traced = StackTrace(0, 0, 0, pStackFrame, Frame + 1, 0, 0, FALSE);
    
    if (Traced <= Frame)
    {
        return FALSE;
    }

    // Do not change the previous context
    SetCurrentScope(&pStackFrame[Frame], NULL, 0);
    return TRUE;
}


VOID
HandleBPWithStatus(
    VOID
    )
{
    ULONG Status = (ULONG)g_Machine->GetArgReg();

    switch(Status)
    {
    case DBG_STATUS_CONTROL_C:
    case DBG_STATUS_SYSRQ:
        if ((g_EngOptions & DEBUG_ENGOPT_IGNORE_DBGHELP_VERSION) == 0 &&
            !g_QuietMode)
        {
dprintf("*******************************************************************************\n");
dprintf("*                                                                             *\n");

if (Status == DBG_STATUS_SYSRQ)
{
dprintf("*   You are seeing this message because you pressed the SysRq/PrintScreen     *\n");
dprintf("*   key on your test machine's keyboard.                                      *\n");
}

if (Status == DBG_STATUS_DEBUG_CONTROL)
{
dprintf("*   You are seeing this message because you typed in .breakin from ntsd.      *\n");
}

if (Status == DBG_STATUS_CONTROL_C)
{
dprintf("*   You are seeing this message because you pressed either                    *\n");
dprintf("*       CTRL+C (if you run kd.exe) or,                                        *\n");
dprintf("*       CTRL+BREAK (if you run WinDBG),                                       *\n");
dprintf("*   on your debugger machine's keyboard.                                      *\n");

}

dprintf("*                                                                             *\n");
dprintf("*                   THIS IS NOT A BUG OR A SYSTEM CRASH                       *\n");
dprintf("*                                                                             *\n");
dprintf("* If you did not intend to break into the debugger, press the \"g\" key, then   *\n");
dprintf("* press the \"Enter\" key now.  This message might immediately reappear.  If it *\n");
dprintf("* does, press \"g\" and \"Enter\" again.                                          *\n");
dprintf("*                                                                             *\n");
dprintf("*******************************************************************************\n");
        }
        break;

    case DBG_STATUS_BUGCHECK_FIRST:
        ErrOut("\nA fatal system error has occurred.\n");
        ErrOut("Debugger entered on first try; "
               "Bugcheck callbacks have not been invoked.\n");
        // Fall through.

    case DBG_STATUS_BUGCHECK_SECOND:
        ErrOut("\nA fatal system error has occurred.\n\n");
        CallBugCheckExtension(NULL);
        break;

    case DBG_STATUS_FATAL:
        // hals call KeEnterDebugger when they panic.
        break;
    }
    return;
}


/*** InitNtCmd - one-time debugger initialization
*
*   Purpose:
*       To perform the one-time initialization of global
*       variables used in the debugger.
*
*   Input:
*       None.
*
*   Output:
*       None.
*
*   Exceptions:
*       None.
*
*************************************************************************/

HRESULT
InitNtCmd(DebugClient* Client)
{
    HRESULT Status;
    
    if ((Status = InitReg()) != S_OK)
    {
        return Status;
    }

    g_DbgHelpAV = *ImagehlpApiVersionEx(&g_NtsdApiVersion);
    if (g_DbgHelpAV.Revision < g_NtsdApiVersion.Revision)
    {
        //
        // bad version match
        //
        if ((g_EngOptions & DEBUG_ENGOPT_IGNORE_DBGHELP_VERSION) == 0)
        {
            ErrOut("dbghelp.dll has a version mismatch with the debugger\n\n");
            OutputVersionInformation(Client);
            return E_FAIL;
        }
        else
        {
            WarnOut( "dbghelp.dll has a version mismatch "
                     "with the debugger\n\n" );
        }
    }

    g_LastCommand[0] = '\0';

    return S_OK;
}

#define MAX_PROMPT 32

HRESULT
GetPromptText(PSTR Buffer, ULONG BufferSize, PULONG TextSize)
{
    char Prompt[MAX_PROMPT];
    PSTR Text = Prompt;

    if (IS_LOCAL_KERNEL_TARGET())
    {
        strcpy(Text, "lkd");
        Text += 3;
    }
    else if (IS_KERNEL_TARGET())
    {
        if (g_X86InVm86)
        {
            strcpy(Text, "vm");
            Text += 2;
        }
        else if (g_X86InCode16)
        {
            strcpy(Text, "16");
            Text += 2;
        }
        else if (g_TargetMachineType == IMAGE_FILE_MACHINE_AMD64 &&
                 !g_Amd64InCode64)
        {
            strcpy(Text, "32");
            Text += 2;
        }

        if (g_CurrentProcess == NULL ||
            g_CurrentProcess->CurrentThread == NULL ||
            ((IS_KERNEL_FULL_DUMP() || IS_KERNEL_SUMMARY_DUMP()) &&
              KdDebuggerData.KiProcessorBlock == 0))
        {
            strcpy(Text, "?: kd");
            Text += 5;
        }
        else if (g_TargetNumberProcessors > 1)
        {
            sprintf(Text, "%d: kd", CURRENT_PROC);
            Text += strlen(Text);
        }
        else
        {
            strcpy(Text, "kd");
            Text += 2;
        }
    }
    else if (IS_USER_TARGET())
    {
        if (g_CurrentProcess != NULL)
        {
            sprintf(Text, "%1ld", g_CurrentProcess->UserId);
            Text += strlen(Text);
            *Text++ = ':';
            
            if (g_CurrentProcess->CurrentThread != NULL)
            {
                sprintf(Text, "%03ld",
                        g_CurrentProcess->CurrentThread->UserId);
                Text += strlen(Text);
            }
            else
            {
                strcpy(Text, "???");
                Text += 3;
            }
        }
        else
        {
            strcpy(Text, "?:???");
            Text += 5;
        }
    }
    else
    {
        strcpy(Text, "NoTarget");
        Text += 8;
    }

    if (g_Machine && g_EffMachine != g_TargetMachineType)
    {
        *Text++ = ':';
        strcpy(Text, g_Machine->m_AbbrevName);
        Text += strlen(Text);
    }
    
    *Text++ = '>';
    *Text = 0;
    
    return FillStringBuffer(Prompt, (ULONG)(Text - Prompt) + 1,
                            Buffer, BufferSize, TextSize);
}

void
OutputPrompt(PCSTR Format, va_list Args)
{
    char Prompt[MAX_PROMPT];

    GetPromptText(Prompt, sizeof(Prompt), NULL);
    g_PromptLength = strlen(Prompt);

    MaskOut(DEBUG_OUTPUT_PROMPT, "%s", Prompt);
    // Include space after >.
    g_PromptLength++;
    if (Format != NULL)
    {
        MaskOutVa(DEBUG_OUTPUT_PROMPT, Format, Args, TRUE);
    }
}
 
DWORD
CommandExceptionFilter(PEXCEPTION_POINTERS Info)
{
    if (Info->ExceptionRecord->ExceptionCode >=
        (COMMAND_EXCEPTION_BASE + OVERFLOW) &&
        Info->ExceptionRecord->ExceptionCode
        <= (COMMAND_EXCEPTION_BASE + UNIMPLEMENT))
    {
        // This is a legitimate command error code exception.
        return EXCEPTION_EXECUTE_HANDLER;
    }
    else
    {
        // This is some other exception that the command
        // filter isn't supposed to handle.
        ErrOut("Non-command exception %X at %s in command filter\n",
               Info->ExceptionRecord->ExceptionCode,
               FormatAddr64((ULONG64)Info->ExceptionRecord->ExceptionAddress));
        return EXCEPTION_CONTINUE_SEARCH;
    }
}

void
ParseLoadModules(void)
{
    PDEBUG_IMAGE_INFO Image;
    PSTR Pattern;
    CHAR Save;
    BOOL AnyMatched = FALSE;

    Pattern = 
        StringValue(STRV_SPACE_IS_SEPARATOR | STRV_TRIM_TRAILING_SPACE |
                    STRV_ESCAPED_CHARACTERS, &Save);
    _strupr(Pattern);
    
    for (Image = g_ProcessHead->ImageHead; Image; Image = Image->Next)
    {
        if (MatchPattern(Image->ModuleName, Pattern))
        {
            IMAGEHLP_MODULE64 ModInfo;
            
            AnyMatched = TRUE;

            ModInfo.SizeOfStruct = sizeof(ModInfo);
            if (!SymGetModuleInfo64(g_CurrentProcess->Handle,
                                    Image->BaseOfImage, &ModInfo) ||
                ModInfo.SymType == SymDeferred)
            {
                if (!SymLoadModule64(g_CurrentProcess->Handle,
                                     NULL, NULL, NULL,
                                     Image->BaseOfImage, 0))
                {
                    ErrOut("Symbol load for %s failed\n", Image->ModuleName);
                }
                else
                {
                    dprintf("Symbols loaded for %s\n", Image->ModuleName);
                }
            }
            else
            {
                dprintf("Symbols already loaded for %s\n", Image->ModuleName);
            }
        }

        if (CheckUserInterrupt())
        {
            break;
        }
    }

    if (!AnyMatched)
    {
        WarnOut("No modules matched '%s'\n", Pattern);
    }
    
    *g_CurCmd = Save;
}

void
ParseProcessorCommands(void)
{
    ULONG Proc;
    
    if (IS_KERNEL_TRIAGE_DUMP())
    {
        ErrOut("Can't switch processors on a Triage dump\n");
        error(SYNTAX);
    }
                    
    Proc = 0;
    while (*g_CurCmd >= '0' && *g_CurCmd <= '9')
    {
        Proc = Proc * 10 + (*g_CurCmd - '0');
        g_CurCmd++;
    }
    *g_CurCmd = 0;

    if (Proc < g_TargetNumberProcessors)
    {
        if (Proc != g_RegContextProcessor)
        {
            if (IS_DUMP_TARGET())
            {
                SetCurrentProcessorThread(Proc, FALSE);
            }
            else
            {
                g_SwitchProcessor = Proc + 1;
                g_CmdState = 's';
            }
            ResetCurrentScope();
        }
    }
    else
    {
        ErrOut("%d is not a valid processor number\n", Proc);
    }
}

/*** CmdHelp - displays the legal commands
*
*   Purpose:
*       Show user the debuger commands.
*
*   Input:
*       none
*
*   Output:
*       None.
*
*************************************************************************/

VOID
CmdHelp(
    VOID
    )
{
    char buf[16];

    // Commands available on all platforms and in all modes.

    dprintf("\nOpen debugger.chm for complete debugger documentation\n\n");
    
    dprintf("A [<address>] - assemble\n");
    dprintf("BC[<bp>] - clear breakpoint(s)\n");
    dprintf("BD[<bp>] - disable breakpoint(s)\n");
    dprintf("BE[<bp>] - enable breakpoint(s)\n");
    dprintf("BL - list breakpoints\n");
    dprintf("[thread]BP[#] <address> - set breakpoint\n");
    dprintf("C <range> <address> [passes] [command] - compare\n");
    dprintf("D[type][<range>] - dump memory\n");
    dprintf("DL[B] <address> <maxcount> <size> - dump linked list\n");
    dprintf("#[processor] DT [-n|y] [[mod!]name] [[-n|y]fields]\n");
    dprintf("                [address] [-l list] [-a[]|c|i|o|r[#]|v] - \n");
    dprintf("                dump using type information\n");
    dprintf("E[type] <address> [<list>] - enter\n");
    dprintf("F <range> <list> - fill\n");
    dprintf("[thread]G [=<address> [<address>...]] - go\n");
    dprintf("[thread]GH [=<address> [<address>...]] - "
            "go with exception handled\n");
    dprintf("[thread]GN [=<address> [<address>...]] - "
            "go with exception not handled\n");
    dprintf("J<expr> [']cmd1['];[']cmd2['] - conditional execution\n");
    dprintf("[thread|processor]K[B] <count> - stacktrace\n");
    dprintf("KD [<count>] - stack trace with raw data\n");
    dprintf("[thread|processor] KV [ <count> | =<reg> ] - "
            "stacktrace with FPO data\n");
    dprintf("L{+|-}[l|o|s|t|*] - Control source options\n");
    dprintf("LD [<module>] - refresh module information\n");
    dprintf("LM[k|l|u|v] - list modules\n");
    dprintf("LN <expr> - list nearest symbols\n");
    dprintf("LS[.] [<first>][,<count>] - List source file lines\n");
    dprintf("LSA <addr>[,<first>][,<count>] - "
            "List source file lines at addr\n");
    dprintf("LSC - Show current source file and line\n");
    dprintf("LSF[-] <file> - Load or unload a source file for browsing\n");
    dprintf("M <range> <address> - move\n");
    dprintf("N [<radix>] - set / show radix\n");
    dprintf("[thread]P[R] [=<addr>] [<value>] - program step\n");
    dprintf("Q - quit\n");

    dprintf("\n");
    GetInput("Hit Enter...", buf, sizeof(buf) - 1);
    dprintf("\n");

    dprintf("[thread|processor]R[F][L][M <expr>] [[<reg> [= <expr>]]] - "
            "reg/flag\n");
    dprintf("Rm[?] [<expr>] - Control prompt register output mask\n");
    dprintf("S <range> <list> - search\n");
    dprintf("SQ[e|d] - set quiet mode\n");
    dprintf("SS <n | a | w> - set symbol suffix\n");
    dprintf("SX [e|d|i|n [<event>|*|<expr>]] - event filtering\n");
    dprintf("[thread]T[R] [=<address>] [<expr>] - trace\n");
    dprintf("U [<range>] - unassemble\n");
    dprintf("version - show debuggee and debugger version\n");
    dprintf("vertarget - show debuggee version\n");
    dprintf("X [<*|module>!]<*|symbol> - view symbols\n");
    dprintf("<commands>; [processor] z(<expression>) - do while true\n");
    dprintf("~ - list threads status\n");
    dprintf("~#s - set default thread\n");
    dprintf("~[.|#|*|ddd]f - freeze thread\n");
    dprintf("~[.|#|*|ddd]u - unfreeze thread\n");
    dprintf("~[.|#|ddd]k[expr] - backtrace stack\n");
    dprintf("| - list processes status\n");
    dprintf("|#s - set default process\n");
    dprintf("|#<command> - default process override\n");
    dprintf("? <expr> - display expression\n");
    dprintf("? - command help\n");
    dprintf("#<string> [address] - search for a string in the dissasembly\n");
    dprintf("$< <filename> - take input from a command file\n");
    dprintf("<Enter> - repeat previous command\n");
    dprintf("; - command separator\n");
    dprintf("*|$ - comment mark\n");

    dprintf("\n");
    GetInput("Hit Enter...", buf, sizeof(buf) - 1);
    dprintf("\n");

    dprintf("<expr> unary ops: + - not by wo dwo qwo poi hi low\n");
    dprintf("       binary ops: + - * / mod(%%) and(&) xor(^) or(|)\n");
    dprintf("       comparisons: == (=) < > !=\n");
    dprintf("       operands: number in current radix, "
            "public symbol, <reg>\n");
    dprintf("<type> : b (byte), w (word), d[s] (doubleword [with symbols]),\n");
    dprintf("         a (ascii), c (dword and Char), u (unicode), l (list)\n");
    dprintf("         f (float), D (double), s|S (ascii/unicode string)\n");
    dprintf("         q (quadword)\n");
    dprintf("<pattern> : [(nt | <dll-name>)!]<var-name> "
            "(<var-name> can include ? and *)\n");
    dprintf("<event> : ct, et, ld, av, cc (see documentation for full list)\n");
    dprintf("<radix> : 8, 10, 16\n");
    dprintf("<reg> : $u0-$u9, $ea, $exp, $ra, $p\n");
    dprintf("<addr> : %%<32-bit address>\n");
    dprintf("<range> : <address> <address>\n");
    dprintf("        : <address> L <count>\n");
    dprintf("<list> : <byte> [<byte> ...]\n");

    if (IS_KERNEL_TARGET())
    {
        dprintf("\n");
        dprintf("Kernel-mode options:\n");
        dprintf("~<processor>s - change current processor\n");
        dprintf("I<b|w|d> <port> - read I/O port\n");
        dprintf("O<b|w|d> <port> <expr> - write I/O\n");
        dprintf("RDMSR <MSR> - read MSR\n");
        dprintf("SO [<options>] - set kernel debugging options\n");
        dprintf("UX [<address>] - disassemble X86 BIOS code\n");
        dprintf("WRMSR <MSR> - write MSR\n");
        dprintf(".cache [size] - set vmem cache size\n");
        dprintf(".reboot - reboot target machine\n");
    }

    switch(g_EffMachine)
    {
    case IMAGE_FILE_MACHINE_I386:
        dprintf("\n");
        dprintf("x86 options:\n");
        dprintf("BA[#] <e|r|w|i><1|2|4> <addr> - addr bp\n");
        dprintf("DG <selector> - dump selector\n");
        dprintf("KB = <base> <stack> <ip> - stacktrace from specific state\n");
        dprintf("<reg> : [e]ax, [e]bx, [e]cx, [e]dx, [e]si, [e]di, "
                "[e]bp, [e]sp, [e]ip, [e]fl,\n");
        dprintf("        al, ah, bl, bh, cl, ch, dl, dh, "
                "cs, ds, es, fs, gs, ss\n");
        dprintf("        dr0, dr1, dr2, dr3, dr6, dr7\n");
        if (IS_KERNEL_TARGET())
        {
            dprintf("        cr0, cr2, cr3, cr4\n");
            dprintf("        gdtr, gdtl, idtr, idtl, tr, ldtr\n");
        }
        else
        {
            dprintf("        fpcw, fpsw, fptw, st0-st7, mm0-mm7\n");
        }
        dprintf("         xmm0-xmm7\n");
        dprintf("<flag> : iopl, of, df, if, tf, sf, zf, af, pf, cf\n");
        dprintf("<addr> : #<16-bit protect-mode [seg:]address>,\n");
        dprintf("         &<V86-mode [seg:]address>\n");
        break;

    case IMAGE_FILE_MACHINE_IA64:
        dprintf("\n");
        dprintf("IA64 options:\n");
        dprintf("BA[#] <r|w><1|2|4|8> <addr> - addr bp\n");
        dprintf("<reg> : r2-r31, f2-f127, gp, sp, intnats, preds, brrp, brs0-brs4, brt0, brt1,\n");
        dprintf("        dbi0-dbi7, dbd0-dbd7, kpfc0-kpfc7, kpfd0-kpfd7, h16-h31, unat, lc, ec,\n");
        dprintf("        ccv, dcr, pfs, bsp, bspstore, rsc, rnat, ipsr, iip, ifs, kr0-kr7, itc,\n");
        dprintf("        itm, iva, pta, isr, ifa, itir, iipa, iim, iha, lid, ivr, tpr, eoi,\n");
        dprintf("        irr0-irr3, itv, pmv, lrr0, lrr1, cmcv, rr0-rr7, pkr0-pkr15, tri0-tri7,\n");
        dprintf("        trd0-trd7\n");
        break;

    case IMAGE_FILE_MACHINE_ALPHA:
    case IMAGE_FILE_MACHINE_AXP64:
        dprintf("\n");
        dprintf("Alpha options:\n");
        dprintf("<reg> : zero, at, v0, a0-a5, t0-t12, s0-s5, fp, gp, sp, ra\n");
        dprintf("        fpcr, fir, psr, int0-int5, f0-f31\n");
        break;
        
    case IMAGE_FILE_MACHINE_AMD64:
        dprintf("\n");
        dprintf("x86-64 options:\n");
        dprintf("BA[#] <e|r|w|i><1|2|4> <addr> - addr bp\n");
        dprintf("DG <selector> - dump selector\n");
        dprintf("KB = <base> <stack> <ip> - stacktrace from specific state\n");
        dprintf("<reg> : [r|e]ax, [r|e]bx, [r|e]cx, [r|e]dx, [r|e]si, [r|e]di, "
                "[r|e]bp, [r|e]sp, [r|e]ip, [e]fl,\n");
        dprintf("        r8-r15 with b/w/d subregisters\n");
        dprintf("        al, ah, bl, bh, cl, ch, dl, dh, "
                "cs, ds, es, fs, gs, ss\n");
        dprintf("        sil, dil, bpl, spl\n");
        dprintf("        dr0, dr1, dr2, dr3, dr6, dr7\n");
        if (IS_KERNEL_TARGET())
        {
            dprintf("        cr0, cr2, cr3, cr4\n");
            dprintf("        gdtr, gdtl, idtr, idtl, tr, ldtr\n");
        }
        else
        {
            dprintf("        fpcw, fpsw, fptw, st0-st7, mm0-mm7\n");
        }
        dprintf("         xmm0-xmm15\n");
        dprintf("<flag> : iopl, of, df, if, tf, sf, zf, af, pf, cf\n");
        dprintf("<addr> : #<16-bit protect-mode [seg:]address>,\n");
        dprintf("         &<V86-mode [seg:]address>\n");
        break;

    }
    
    dprintf("\nOpen debugger.chm for complete debugger documentation\n\n");
}


/*** ProcessCommands - high-level command processor
*
*   Purpose:
*       If no command string remains, the user is prompted to
*       input one.  Once input, this routine parses the string
*       into commands and their operands.  Error checking is done
*       on both commands and operands.  Multiple commands may be
*       input by separating them with semicolons.  Once a command
*               is parsefd, the appropriate routine (type fnXXXXX) is called
*       to execute the command.
*
*   Input:
*       g_CurCmd = pointer to the next command in the string
*
*   Output:
*       None.
*
*   Exceptions:
*       error exit: SYNTAX - command type or operand error
*       normal exit: termination on 'q' command
*
*************************************************************************/

HRESULT
ProcessCommands(DebugClient* Client, BOOL Nested)
{
    UCHAR    ch;
    ADDR     addr1;
    ADDR     addr2;
    ULONG64  value1;
    ULONG64  value2;
    ULONG    count;
    STACK_TRACE_TYPE traceType;
    BOOL     fLength;
    UCHAR    list[STRLISTSIZE];
    ULONG    size;
    PSTR     SavedCurCmd;
    ULONGLONG valueL;
    PPROCESS_INFO pProcessPrevious = NULL;
    BOOL     parseProcess = FALSE;
    CHAR     buf[MAX_COMMAND];
    HRESULT  Status = S_FALSE;
    CROSS_PLATFORM_CONTEXT Context;
    ULONG    State;

    if (g_CurrentProcess == NULL ||
        g_CurrentProcess->CurrentThread == NULL)
    {
        WarnOut("WARNING: The debugger does not have a current "
                "process or thread\n");
        WarnOut("WARNING: Many commands will not work\n");
    }

    if (!Nested)
    {
        g_SwitchedProcs = FALSE;
    }

    do
    {
        ch = *g_CurCmd++;
        if (ch == '\0' ||
            (ch == ';' && (g_EngStatus & ENG_STATUS_USER_INTERRUPT)))
        {
            if (!Nested)
            {
                g_EngStatus &= ~ENG_STATUS_USER_INTERRUPT;
                g_BreakpointsSuspended = FALSE;
            }

            Status = S_OK;
            // Back up to terminating character in
            // case command processing is reentered without
            // resetting things.
            g_CurCmd--;
            break;
        }
        
EVALUATE:
        while (ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n' ||
               ch == ';')
        {
            ch = *g_CurCmd++;
        }

        if (IS_KERNEL_TARGET())
        {
            if (g_TargetNumberProcessors > MAXIMUM_PROCESSORS)
            {
                WarnOut("WARNING: Number of processors corrupted - using 1\n");
                g_TargetNumberProcessors = 1;
            }

            if (ch >= '0' && ch <= '9')
            {
                if (IS_KERNEL_TRIAGE_DUMP())
                {
                    ErrOut("Can't switch processors on a Triage dump\n");
                    error(SYNTAX);
                }
            
                value1 = 0;
                SavedCurCmd = g_CurCmd;
                while (ch >= '0' && ch <= '9')
                {
                    value1 = value1 * 10 + (ch - '0');
                    ch = *SavedCurCmd++;
                }
                ch = (UCHAR)tolower(ch);
                if (ch == 'r' || ch == 'k' || ch == 'z' ||
                    (ch == 'd' && tolower(*SavedCurCmd) == 't'))
                {
                    if (value1 < g_TargetNumberProcessors)
                    {
                        if (value1 != g_RegContextProcessor)
                        {
                            SaveSetCurrentProcessorThread((ULONG)value1);
                            g_SwitchedProcs = TRUE;
                        }
                    }
                    else
                    {
                        error(BADRANGE);
                    }
                }
                else
                {
                    error(SYNTAX);
                }
                g_CurCmd = SavedCurCmd;
            }
        }

        g_PrefixSymbols = FALSE;
        switch (ch = (UCHAR)tolower(ch)) 
        {
            case '?':
                if ((ch = PeekChar()) == '\0' || ch == ';')
                {
                    CmdHelp();
                }
                else
                {
                    EvaluateExp(FALSE);
                }
                break;
                
            case '$':
                if ( *g_CurCmd++ == '<')
                {
                    ExecuteCommandFile(Client, (PCSTR)g_CurCmd,
                                       DEBUG_EXECUTE_ECHO);
                }
                *g_CurCmd = 0;
                break;
                
            case '~':
                if (IS_USER_TARGET())
                {
                    if (Nested)
                    {
                        ErrOut("Ignoring recursive thread command\n");
                        break;
                    }

                    parseThreadCmds(Client);
                }
                else
                {
                    ParseProcessorCommands();
                }
                break;
                
            case '|':
                if (IS_KERNEL_TARGET())
                {
                    break;
                }
                
                if (!parseProcess)
                {
                    parseProcess = TRUE;
                    pProcessPrevious = g_CurrentProcess;
                }
                parseProcessCmds();
                if (!*g_CurCmd)
                {
                    parseProcess = FALSE;
                }
                else
                {
                    ch = *g_CurCmd++;
                    goto EVALUATE;
                }

                break;
                
            case '.':
                SavedCurCmd = g_CurCmd;
                strcpy(buf, g_CurCmd);
                if (!DotCommand(Client))
                {
                    g_CurCmd = SavedCurCmd;
                    strcpy(g_CurCmd, buf);
                    fnBangCmd(Client, g_CurCmd, &g_CurCmd, TRUE);
                }
                break;

            case '!':
                fnBangCmd(Client, g_CurCmd, &g_CurCmd, FALSE);
                break;

            case '*':
                while (*g_CurCmd != '\0')
                {
                    g_CurCmd++;
                }
                break;

            case '#':
                g_PrefixSymbols = TRUE;
                igrep();
                g_PrefixSymbols = FALSE;
                while (*g_CurCmd != '\0')
                {
                    g_CurCmd++;
                }
                break;

            case 'a':
                //
                //  Alias command or just default to pre-existing
                //  assemble command.
                //
                ch = *g_CurCmd++;
                switch (tolower(ch))
                {
                    //  Alias list
                case 'l':
                    ListAliases();
                    break;

                    //  Alias set
                case 's':
                    ParseSetAlias();
                    break;

                    //  Alias delete
                case 'd':
                    ParseDeleteAlias();
                    break;

                    //  Pre-existing assemble command
                default:
                    if ((ch = PeekChar()) != '\0' && ch != ';')
                    {
                        GetAddrExpression(SEGREG_CODE, &g_AssemDefault);
                    }
                    fnAssemble(&g_AssemDefault);
                    break;
                }
                break;
                
            case 'b':
                ch = *g_CurCmd++;
                ch = (UCHAR)tolower(ch);

                if (!IS_EXECUTION_POSSIBLE())
                {
                    error(SESSIONNOTSUP);
                }

                switch(ch)
                {
                case 'p':
                case 'u':
                case 'a':
                case 'i':
                case 'w':
                    ParseBpCmd(Client, ch, NULL);
                    break;

                case 'c':
                case 'd':
                case 'e':
                    value1 = GetIdList();
                    ChangeBreakpointState(Client, g_CurrentProcess,
                                          (ULONG)value1, ch);
                    break;

                case 'l':
                    if (PeekChar() != ';' && *g_CurCmd)
                    {
                        value1 = GetIdList();
                    }
                    else
                    {
                        value1 = ALL_ID_LIST;
                    }
                    ListBreakpoints(Client, g_CurrentProcess, (ULONG)value1);
                    break;
                        
                default:
                    error(SYNTAX);
                    break;
                }
                break;
                
            case 'c':
                GetRange(&addr1, &value2, 1, SEGREG_DATA);
                GetAddrExpression(SEGREG_DATA, &addr2);
                fnCompareMemory(&addr1, (ULONG)value2, &addr2);
                break;

            case 'd':
                parseDumpCommand();
                break;
            case 'e':
                parseEnterCommand();
                break;

            case 'f':
                ParseFillMemory();
                break;

            case 'g':
                parseGoCmd(NULL, FALSE);
                break;

            case 'i':
                ch = (UCHAR)tolower(*g_CurCmd);
                g_CurCmd++;
                if (ch != 'b' && ch != 'w' && ch != 'd')
                {
                    error(SYNTAX);
                }
                
                if (IS_USER_TARGET() || IS_DUMP_TARGET())
                {
                    error(SESSIONNOTSUP);
                }
                
                fnInputIo((ULONG)GetExpression(), ch);
                break;
                
            case 'j':
                PSTR pch, Start;

                if (GetExpression())
                {
                    pch = g_CurCmd;

                    // Find a semicolon or a quote

                    while (*pch && *pch != ';' && *pch != '\'')
                    {
                        pch++;
                    }
                    if (*pch == ';')
                    {
                        *pch = 0;
                    }
                    else if (*pch)
                    {
                        *pch = ' ';
                        // Find the closing quote
                        while (*pch && *pch != '\'')
                        {
                            pch++;
                        }
                        *pch = 0;
                    }
                }
                else
                {
                    Start = pch = g_CurCmd;

                    // Find a semicolon or a quote

                    while (*pch && *pch != ';' && *pch != '\'')
                    {
                        pch++;
                    }
                    if (*pch == ';')
                    {
                        Start = ++pch;
                    }
                    else if (*pch)
                    {
                        pch++;
                        while (*pch && *pch++ != '\'')
                        {
                            // Empty.
                        }
                        while (*pch && (*pch == ';' || *pch == ' '))
                        {
                            pch++;
                        }
                        Start = pch;
                    }
                    while (*pch && *pch != ';' && *pch != '\'')
                    {
                        pch++;
                    }
                    if (*pch == ';')
                    {
                        *pch = 0;
                    }
                    else if (*pch)
                    {
                        *pch = ' ';
                        // Find the closing quote
                        while (*pch && *pch != '\'')
                        {
                            pch++;
                        }
                        *pch = 0;
                    }
                    g_CurCmd = Start;
                 }
                 ch = *g_CurCmd++;
                 goto EVALUATE;

            case 'k':
            {
                if (IS_LOCAL_KERNEL_TARGET())
                {
                    error(SESSIONNOTSUP);
                }
                if (!IS_CONTEXT_ACCESSIBLE())
                {
                    error(BADTHREAD);
                }
                
                DEBUG_SCOPE_STATE SaveCurrCtxtState = g_ScopeBuffer.State;
                value1 = 0;
                if (g_SwitchedProcs)
                {
                    g_ScopeBuffer.State = ScopeDefault;
                }
                
                PCROSS_PLATFORM_CONTEXT ScopeContext;
                if (ScopeContext = GetCurrentScopeContext())
                {
                    g_Machine->PushContext(ScopeContext);
                }
                
                if (g_EffMachine == IMAGE_FILE_MACHINE_I386)
                {
                    value2 = GetRegVal64(X86_EIP);
                }
                else
                {
                    value2 = 0;
                }

                count = g_DefaultStackTraceDepth;
                ParseStackTrace(&traceType, &addr2, &value1, &value2, &count);

                if (ScopeContext)
                {
                    g_Machine->PopContext();
                }

                if (count >= 0x10000) 
                {
                    ErrOut("Requested number of stack frames (0x%x) is too large! "
                             "The maximum number is 0xffff.\n", 
                           count);

                    error(BADRANGE);
                }

                DoStackTrace( addr2.off, value1, value2, count, traceType );
                if (g_SwitchedProcs)
                {
                    RestoreCurrentProcessorThread();
                    g_SwitchedProcs = FALSE;
                    g_ScopeBuffer.State = SaveCurrCtxtState;
                }
                break;
            }
            
            case 'l':
                ch = (UCHAR)tolower(*g_CurCmd);
                if (ch == 'n')
                {
                    g_CurCmd++;
                    if ((ch = PeekChar()) != '\0' && ch != ';')
                    {
                        GetAddrExpression(SEGREG_CODE, &addr1);
                    }
                    else
                    {
                        PCROSS_PLATFORM_CONTEXT ScopeContext =
                            GetCurrentScopeContext();
                        if (ScopeContext)
                        {
                            g_Machine->PushContext(ScopeContext);
                        }
                        g_Machine->GetPC(&addr1);
                        if (ScopeContext)
                        {
                            g_Machine->PopContext();
                        }
                    }
                    fnListNear(Flat(addr1));
                }
                else if (ch == '+' || ch == '-')
                {
                    g_CurCmd++;
                    ParseSrcOptCmd(ch);
                }
                else if (ch == 's')
                {
                    g_CurCmd++;
                    ch = (UCHAR)tolower(*g_CurCmd);
                    if (ch == 'f')
                    {
                        g_CurCmd++;
                        ParseSrcLoadCmd();
                    }
                    else if (ch == 'p')
                    {
                        g_CurCmd++;
                        ParseOciSrcCmd();
                    }
                    else
                    {
                        ParseSrcListCmd(ch);
                    }
                }
                else if (ch == 'm')
                {
                    ParseDumpModuleTable();
                }
                else if (ch == 'd')
                {
                    g_CurCmd++;
                    ParseLoadModules();
                }
                else
                {
                    error(SYNTAX);
                }
                break;
                
            case 'm':
                {
                    ADDR TempAddr;

                    GetRange(&addr1, &value2, 1, SEGREG_DATA);
                    GetAddrExpression(SEGREG_DATA, &TempAddr);
                    fnMoveMemory(&addr1, (ULONG)value2, &TempAddr);
                }
                break;

            case 'n':
                if ((ch = PeekChar()) != '\0' && ch != ';')
                {
                    if (ch == '8')
                    {
                        g_CurCmd++;
                        g_DefaultRadix = 8;
                    }
                    else if (ch == '1')
                    {
                        ch = *++g_CurCmd;
                        if (ch == '0' || ch == '6')
                        {
                            g_CurCmd++;
                            g_DefaultRadix = 10 + ch - '0';
                        }
                        else
                        {
                            error(SYNTAX);
                        }
                    }
                    else
                    {
                        error(SYNTAX);
                    }
                    NotifyChangeEngineState(DEBUG_CES_RADIX, g_DefaultRadix,
                                            TRUE);
                }
                dprintf("base is %ld\n", g_DefaultRadix);
                break;
                
            case 'o':
                ch = (UCHAR)tolower(*g_CurCmd);
                g_CurCmd++;
                if (ch == 'b')
                {
                    value2 = 1;
                }
                else if (ch == 'w')
                {
                    value2 = 2;
                }
                else if (ch == 'd')
                {
                    value2 = 4;
                }
                else
                {
                    error(SYNTAX);
                }
                
                if (IS_USER_TARGET() || IS_DUMP_TARGET())
                {
                    error(SESSIONNOTSUP);
                }
                
                value1 = GetExpression();
                value2 = HexValue((ULONG)value2);
                fnOutputIo((ULONG)value1, (ULONG)value2, ch);
                break;
                
            case 'w':
            case 'p':
            case 't':
                if (IS_KERNEL_TARGET())
                {
                    if (ch == 'w' &&
                        tolower(g_CurCmd[0]) == 'r'  &&
                        tolower(g_CurCmd[1]) == 'm'  &&
                        tolower(g_CurCmd[2]) == 's'  &&
                        tolower(g_CurCmd[3]) == 'r')
                    {
                        g_CurCmd +=4;
                        value1 = GetExpression();
                        if (g_Target->WriteMsr ((ULONG)value1,
                                                HexValue(8)) != S_OK)
                        {
                            ErrOut ("no such msr\n");
                        }
                        break;
                    }
                }

                parseStepTrace(NULL, FALSE, ch);
                break;
                
            case 'q':
                UCHAR QuitArgument;
                
                QuitArgument = (UCHAR)tolower(PeekChar());
                if ((IS_LIVE_USER_TARGET() && QuitArgument == 'd') ||
                    QuitArgument == 'k' || QuitArgument == 'q')
                {
                    g_CurCmd++;
                }
                if (PeekChar() != 0)
                {
                    error(SYNTAX);
                }

                if (QuitArgument != 'q' &&
                    Client != NULL &&
                    (Client->m_Flags & CLIENT_REMOTE))
                {
                    ErrOut("Exit a remote client with Ctrl-b<enter>.\nIf you "
                           "really want the server to quit use 'qq'.\n");
                    break;
                }
                
                // Detach if requested.
                if (QuitArgument == 'd')
                {
                    DBG_ASSERT(IS_LIVE_USER_TARGET());
                    
                    // If detach isn't supported warn the user
                    // and abort the quit.
                    if (((UserTargetInfo*)g_Target)->m_Services->
                        DetachProcess(0) != S_OK)
                    {
                        ErrOut("The system doesn't support detach\n");
                        break;
                    }

                    if (g_SessionThread &&
                        GetCurrentThreadId() != g_SessionThread)
                    {
                        ErrOut("Detach can only be done by the server\n");
                        break;
                    }
                           
                    HRESULT DetachStatus;
                    
                    if (FAILED(DetachStatus = DetachProcesses()))
                    {
                        ErrOut("Detach failed, 0x%X\n", DetachStatus);
                    }
                }
                else if ((g_GlobalProcOptions &
                          DEBUG_PROCESS_DETACH_ON_EXIT) ||
                         (g_AllProcessFlags & ENG_PROC_EXAMINED))
                {
                    HRESULT PrepareStatus;
                    
                    // We need to restart the program before we
                    // quit so that it's put back in a running state.
                    PrepareStatus = PrepareForSeparation();
                    if (PrepareStatus != S_OK)
                    {
                        ErrOut("Unable to prepare process for detach, "
                               "0x%X\n", PrepareStatus);
                        break;
                    }
                }
                
                dprintf("quit:\n");

                // Force engine into a no-debuggee state
                // to indicate quit.
                g_CmdState = 'q';
                g_EngStatus |= ENG_STATUS_STOP_SESSION;
                NotifyChangeEngineState(DEBUG_CES_EXECUTION_STATUS,
                                        DEBUG_STATUS_NO_DEBUGGEE, TRUE);
                break;

            case 'r':
                if (IS_KERNEL_TARGET())
                {
                    if (tolower(g_CurCmd[0]) == 'd'  &&
                        tolower(g_CurCmd[1]) == 'm'  &&
                        tolower(g_CurCmd[2]) == 's'  &&
                        tolower(g_CurCmd[3]) == 'r')
                    {
                        g_CurCmd +=4;
                        value1 = GetExpression();
                        if (g_Target->ReadMsr((ULONG)value1, &valueL) == S_OK)
                        {
                            dprintf ("msr[%x] = %08x:%08x\n",
                                     (ULONG)value1, (ULONG) (valueL >> 32),
                                     (ULONG) valueL);
                        }
                        else
                        {
                            ErrOut ("no such msr\n");
                        }
                        break;
                    }
                }
                PCROSS_PLATFORM_CONTEXT ScopeContext;
                if (ScopeContext = GetCurrentScopeContext())
                {
                    dprintf("Last set context:\n");
                    g_Machine->PushContext(ScopeContext);
                }
                
                __try
                {
                    ParseRegCmd();
                }
                __finally
                {
                    if (ScopeContext)
                    {
                        g_Machine->PopContext();
                    }
                    if (g_SwitchedProcs)
                    {
                        RestoreCurrentProcessorThread();
                        g_SwitchedProcs = FALSE;
                    }
                }
                break;
                
            case 's':
                ch = (UCHAR)tolower(*g_CurCmd);

                if (ch == 's')
                {
                    g_CurCmd++;
                    SetSuffix();
                }
                else if (ch == 'q')
                {
                    g_CurCmd++;
                    ch = (UCHAR)tolower(*g_CurCmd);
                    if (ch == 'e')
                    {
                        g_QuietMode = TRUE;
                        g_CurCmd++;
                    }
                    else if (ch == 'd')
                    {
                        g_QuietMode = FALSE;
                        g_CurCmd++;
                    }
                    else
                    {
                        g_QuietMode = !g_QuietMode;
                    }
                    dprintf("Quiet mode is %s\n", g_QuietMode ? "ON" : "OFF");
                }
                else if (ch == 'x')
                {
                    g_CurCmd++;
                    ParseSetEventFilter(Client);
                }
                else if (IS_KERNEL_TARGET() && ch == 'o')
                {
                    PSTR pch = ++g_CurCmd;
                    while ((*pch != '\0') && (*pch != ';'))
                    {
                        pch++;
                    }
                    ch = *pch;
                    *pch = '\0';
                    ReadDebugOptions(FALSE, (*g_CurCmd == '\0' ?
                                             NULL : g_CurCmd));
                    *pch = ch;
                    g_CurCmd = pch;
                }
                else
                {
                    // s, s-w, s-d, s-q.
                    ParseSearchMemory();
                }
                break;

            case 'u':
                g_PrefixSymbols = TRUE;
                ch = (UCHAR)tolower(*g_CurCmd);
                if (IS_KERNEL_TARGET() && ch == 'x')
                {
                    g_CurCmd += 1;
                }
                value1 = Flat(g_UnasmDefault);
                value2 = (g_EffMachine == IMAGE_FILE_MACHINE_IA64) ? 9 : 8;  
                fLength = GetRange(&g_UnasmDefault, &value2, 0, SEGREG_CODE);

                if (IS_KERNEL_TARGET() && ch == 'x')
                {
                    ADDR addr;
                    char text[MAX_DISASM_LEN];
                    if (g_X86BiosBaseAddress == 0)
                    {
                        g_X86BiosBaseAddress =
                            (ULONG)ExtGetExpression("hal!HalpEisaMemoryBase");
                        ADDRFLAT(&addr, g_X86BiosBaseAddress);
                        GetMemString(&addr, (PUCHAR)&g_X86BiosBaseAddress, 4);
                    }

                    addr = g_UnasmDefault;
                    addr.flat += (g_X86BiosBaseAddress + (addr.seg<<4));
                    addr.off = addr.flat;
                    addr.type = ADDR_V86 | INSTR_POINTER;
                    for (value2 = 0; value2 < 8; value2++)
                    {
                        g_X86Machine.Disassemble( &addr, text, TRUE );
                        addr.flat = addr.off;
                        dprintf("%s", text );
                    }
                    g_UnasmDefault = addr;
                    g_UnasmDefault.off -=
                        (g_X86BiosBaseAddress + (addr.seg<<4));
                    g_UnasmDefault.flat = g_UnasmDefault.off;
                }
                else
                {
                    fnUnassemble(&g_UnasmDefault,
                                 value2,
                                 fLength);
                }
                break;

            case 'v':
                if (_stricmp(g_CurCmd, "ertarget") == 0)
                {
                    g_CurCmd += strlen(g_CurCmd);
                    g_Target->OutputVersion();
                }
                else if (_stricmp(g_CurCmd, "ersion") == 0)
                {
                    g_CurCmd += strlen(g_CurCmd);
                    // Print target version, then debugger version.
                    g_Target->OutputVersion();
                    OutputVersionInformation(Client);
                }
                else
                {
                    error(SYNTAX);
                }
                break;

            case 'x':
                ParseExamine();
                break;

            case ';':
            case '\0':
                g_CurCmd--;
                break;

        case 'z':

            // Works like do{ cmds }while(Cond);
            // Eg. p;z(eax<2);

            if (CheckUserInterrupt())
            {
                // Eat the expression also to prevent
                // spurious extra character errors.
                GetExpression();
                g_RedoCount = 0;
                break;
            }
            if (GetExpression())
            {
                g_CurCmd = g_CommandStart;
                ++g_RedoCount;
                dprintf("redo [%d] %s\n", g_RedoCount, g_CurCmd );
                FlushCallbacks();
                ch = *g_CurCmd++;
                goto EVALUATE;
            }
            else
            {
                g_RedoCount = 0;
            }
            break;

        default:
            error(SYNTAX);
            break;
        }
        do
        {
            ch = *g_CurCmd++;
        } while (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r');
        if (ch != ';' && ch != '\0')
        {
            error(EXTRACHARS);
        }
        g_CurCmd--;
    }
    while (g_CmdState == 'c');

    if (Status == S_FALSE)
    {
        PSTR Scan = g_CurCmd;
        
        // We switched to a non-'c' cmdState so the
        // loop was exited.  Check and see if we're
        // also at the end of the command as that will
        // take precedence in what the return value is.
        while (*Scan == ' ' || *Scan == '\t' || *Scan == ';')
        {
            Scan++;
        }
        
        Status = *Scan ? S_FALSE : S_OK;
    }

    g_EngStatus &= ~ENG_STATUS_USER_INTERRUPT;
    return Status;
}

HRESULT
ProcessCommandsAndCatch(DebugClient* Client)
{
    HRESULT Status;
    
    __try
    {
        Status = ProcessCommands(Client, FALSE);
    }
    __except(CommandExceptionFilter(GetExceptionInformation()))
    {
        g_CurCmd = g_CommandStart;
        *g_CurCmd = '\0';
        g_LastCommand[0] = '\0';
        Status = E_FAIL;
        g_EngStatus &= ~ENG_STATUS_USER_INTERRUPT;
    }

    return Status;
}

/*** fnEvaluateExp - evaluate expression
*
*   Purpose:
*       Function for the "?<exp>" command.
*
*       Evaluate the expression and output it in both
*       hexadecimal and decimal.
*
*   Input:
*       g_CurCmd - pointer to operand in command line
*
*   Output:
*       None.
*
*************************************************************************/

void
EvaluateExp (
    BOOL Verbose
    )
{
    LONG64 Value;
    LONG Val32;
    BOOL Use64;

    Value = GetExpression();
    
    // Allow 64-bit expressions to be evaluated even on
    // 32-bit platforms since they can also use 64-bit numbers.
    Use64 = g_Machine->m_Ptr64 || NeedUpper(Value);
    Val32 = (LONG)Value;

    if (!Verbose)
    {
        if (Use64)
        {
            dprintf("Evaluate expression: %I64d = %08x`%08x\n",
                    Value, (ULONG)(Value >> 32), Val32);
        }
        else
        {
            dprintf("Evaluate expression: %d = %08x\n",
                    Val32, Val32);
        }
    }
    else
    {
        dprintf("Evaluate expression:\n");
        if (Use64)
        {
            dprintf("  Hex:     %08x`%08x\n", (ULONG)(Value >> 32), Val32);
            dprintf("  Decimal: %I64d\n", Value);
        }
        else
        {
            dprintf("  Hex:     %08x\n", Val32);
            dprintf("  Decimal: %d\n", Val32);
        }

        ULONG Shift = Use64 ? 63 : 30;
        dprintf("  Octal:   ");
        for (;;)
        {
            dprintf("%c", ((Value >> Shift) & 7) + '0');
            if (Shift == 0)
            {
                break;
            }
            Shift -= 3;
        }
        dprintf("\n");

        Shift = Use64 ? 63 : 31;
        dprintf("  Binary: ");
        for (;;)
        {
            if ((Shift & 7) == 7)
            {
                dprintf(" ");
            }
            
            dprintf("%c", ((Value >> Shift) & 1) + '0');
            if (Shift == 0)
            {
                break;
            }
            Shift--;
        }
        dprintf("\n");

        Shift = Use64 ? 56 : 24;
        dprintf("  Chars:   ");
        for (;;)
        {
            Val32 = (LONG)((Value >> Shift) & 0xff);
            if (Val32 >= ' ' && Val32 <= 127)
            {
                dprintf("%c", Val32);
            }
            else
            {
                dprintf(".");
            }
            if (Shift == 0)
            {
                break;
            }
            Shift -= 8;
        }
        dprintf("\n");
    }
}

void
ScanForImages(void)
{
    ULONG64 Handle = 0;
    MEMORY_BASIC_INFORMATION64 Info;
    BOOL Verbose = FALSE;
    
    //
    // Scan virtual memory looking for image headers.
    //

    while (g_Target->QueryMemoryRegion(&Handle, FALSE, &Info) == S_OK)
    {
        ULONG64 Addr;

        if (Verbose)
        {
            dprintf("Checking %s - %s\n",
                    FormatAddr64(Info.BaseAddress),
                    FormatAddr64(Info.BaseAddress + Info.RegionSize - 1));
            FlushCallbacks();
        }
        
        //
        // Check for MZ at the beginning of every page.
        //

        Addr = Info.BaseAddress;
        while (Addr < Info.BaseAddress + Info.RegionSize)
        {
            USHORT ShortSig;
            ULONG Done;
            
            if (g_Target->ReadVirtual(Addr, &ShortSig, sizeof(ShortSig),
                                      &Done) == S_OK &&
                Done == sizeof(ShortSig) &&
                ShortSig == IMAGE_DOS_SIGNATURE)
            {
                dprintf("  MZ at %s, prot %08X, type %08X\n",
                        FormatAddr64(Addr), Info.Protect, Info.Type);
                FlushCallbacks();
            }

            if (CheckUserInterrupt())
            {
                WarnOut("  Aborted\n");
                return;
            }
            
            Addr += g_Machine->m_PageSize;
        }
    }
}

void
OutputMemRegion(ULONG64 Addr)
{
    ULONG64 Handle = Addr;
    MEMORY_BASIC_INFORMATION64 Info;
    
    if (g_Target->QueryMemoryRegion(&Handle, TRUE, &Info) == S_OK)
    {
        dprintf("Region %s - %s, prot %08X, type %08X\n",
                FormatAddr64(Info.BaseAddress),
                FormatAddr64(Info.BaseAddress + Info.RegionSize - 1),
                Info.Protect, Info.Type);
    }
    else
    {
        dprintf("No region contains %s\n", FormatAddr64(Addr));
    }
}

void
SetEffMachineByName(void)
{
    if (PeekChar() != ';' && *g_CurCmd)
    {
        PSTR Name = g_CurCmd;
        
        while (*g_CurCmd && *g_CurCmd != ';' && !isspace(*g_CurCmd))
        {
            g_CurCmd++;
        }
        if (*g_CurCmd)
        {
            *g_CurCmd++ = 0;
        }

        ULONG Machine;
        
        if (Name[0] == '.' && Name[1] == 0)
        {
            // Reset to target machine.
            Machine = g_TargetMachineType;
        }
        else if (Name[0] == '#' && Name[1] == 0)
        {
            // Reset to executing machine.
            Machine = g_TargetExecMachine;
        }
        else
        {
            for (Machine = 0; Machine < MACHIDX_COUNT; Machine++)
            {
                if (!_strcmpi(Name, g_AllMachines[Machine]->m_AbbrevName))
                {
                    break;
                }
            }
            
            if (Machine >= MACHIDX_COUNT)
            {
                ErrOut("Unknown machine '%s'\n", Name);
                return;
            }

            Machine = g_AllMachines[Machine]->m_ExecTypes[0];
        }

        SetEffMachine(Machine, TRUE);
    }

    if (g_Machine != NULL)
    {
        dprintf("Effective machine: %s (%s)\n",
                g_Machine->m_FullName, g_Machine->m_AbbrevName);
    }
    else
    {
        dprintf("No effective machine\n");
    }
}

void
ListProcesses(void)
{
    BOOL ListCurrent = FALSE;
    BOOL Verbose = FALSE;
    
    if (!IS_LIVE_USER_TARGET())
    {
        error(SESSIONNOTSUP);
    }
    
    while (PeekChar() == '-' || *g_CurCmd == '/')
    {
        switch(*++g_CurCmd)
        {
        case 'c':
            if (g_CurrentProcess == NULL)
            {
                error(BADPROCESS);
            }
            ListCurrent = TRUE;
            break;
        case 'v':
            Verbose = TRUE;
            break;
        default:
            ErrOut("Unknown option '%c'\n", *g_CurCmd);
            break;
        }

        g_CurCmd++;
    }
            
    PUSER_DEBUG_SERVICES Services = ((UserTargetInfo*)g_Target)->m_Services;
    
#define MAX_IDS 1024
    ULONG Ids[MAX_IDS];
    HRESULT Status;
    ULONG IdCount;
    ULONG i;
    char DescBuf[2 * MAX_PATH];
    PSTR Desc;
    ULONG DescLen;

    if (ListCurrent)
    {
        Ids[0] = g_CurrentProcess->SystemId;
        IdCount = 1;
    }
    else
    {
        if ((Status = Services->GetProcessIds(Ids, MAX_IDS, &IdCount)) != S_OK)
        {
            ErrOut("Unable to get process list, %s\n",
                   FormatStatusCode(Status));
            return;
        }

        if (IdCount > MAX_IDS)
        {
            WarnOut("Process list missing %d processes\n",
                    IdCount - MAX_IDS);
            IdCount = MAX_IDS;
        }
    }

    if (Verbose)
    {
        Desc = DescBuf;
        DescLen = sizeof(DescBuf);
    }
    else
    {
        Desc = NULL;
        DescLen = 0;
    }
    
    for (i = 0; i < IdCount; i++)
    {
        char ExeName[MAX_PATH];
        int Space;

        if (Ids[i] < 10)
        {
            Space = 3;
        }
        else if (Ids[i] < 100)
        {
            Space = 2;
        }
        else if (Ids[i] < 1000)
        {
            Space = 1;
        }
        else
        {
            Space = 0;
        }
        dprintf("%.*s", Space, "        ");
        
        if (FAILED(Status = Services->
                   GetProcessDescription(Ids[i], DEBUG_PROC_DESC_DEFAULT,
                                         ExeName, sizeof(ExeName), NULL,
                                         Desc, DescLen, NULL)))
        {
            ErrOut("0n%d Error %s\n", Ids[i], FormatStatusCode(Status));
        }
        else if (Ids[i] >= 0x80000000)
        {
            dprintf("0x%x %s\n", Ids[i], ExeName);
        }
        else
        {
            dprintf("0n%d %s\n", Ids[i], ExeName);
        }

        if (Desc && Desc[0])
        {
            dprintf("       %s\n", Desc);
        }
    }
}

void
EchoString(void)
{
    CHAR Save;
    PSTR Str;

    Str = StringValue(STRV_TRIM_TRAILING_SPACE, &Save);
    dprintf("%s\n", Str);
    *g_CurCmd = Save;
}

void
ParseAttachProcess(void)
{
    ULONG Pid;
    ULONG Flags = DEBUG_ATTACH_DEFAULT;

    while (PeekChar() == '-' || *g_CurCmd == '/')
    {
        switch(*++g_CurCmd)
        {
        case 'e':
            Flags = DEBUG_ATTACH_EXISTING;
            break;
        case 'v':
            Flags = DEBUG_ATTACH_NONINVASIVE;
            break;
        default:
            ErrOut("Unknown option '%c'\n", *g_CurCmd);
            break;
        }

        g_CurCmd++;
    }
            
    Pid = (ULONG)GetExpression();
    
    PPENDING_PROCESS Pending;
    HRESULT Status;

    Status = StartAttachProcess(Pid, Flags, &Pending);
    if (Status == S_OK)
    {
        dprintf("Attach will occur on next execution\n");
    }
}

void
ParseOutputFunctionEntry(void)
{
    if (!IS_MACHINE_ACCESSIBLE())
    {
        error(BADTHREAD);
    }

    BOOL SymDirect = FALSE;
    
    while (PeekChar() == '-' || *g_CurCmd == '/')
    {
        switch(*++g_CurCmd)
        {
        case 's':
            SymDirect = TRUE;
            break;
        default:
            ErrOut("Unknown option '%c'\n", *g_CurCmd);
            break;
        }

        g_CurCmd++;
    }
            
    ULONG64 Addr = GetExpression();
    PVOID FnEnt;
    
    if (SymDirect)
    {
        FnEnt = SymFunctionTableAccess64(g_CurrentProcess->Handle, Addr);
    }
    else
    {
        FnEnt = SwFunctionTableAccess(g_CurrentProcess->Handle, Addr);
    }
    if (FnEnt == NULL)
    {
        ErrOut("No function entry for %s\n", FormatAddr64(Addr));
        return;
    }

    dprintf("%s function entry %s for:\n",
            SymDirect ? "Symbol" : "Debugger", FormatAddr64((ULONG_PTR)FnEnt));
    fnListNear(Addr);
    dprintf("\n");
    g_Machine->OutputFunctionEntry(FnEnt);
}

void
ParseOutputFilter(void)
{
    if (PeekChar() != ';' && *g_CurCmd)
    {
        g_OutFilterResult = TRUE;
        
        while (PeekChar() == '-' || *g_CurCmd == '/')
        {
            switch(*++g_CurCmd)
            {
            case '!':
                g_OutFilterResult = FALSE;
                break;
            default:
                ErrOut("Unknown option '%c'\n", *g_CurCmd);
                break;
            }

            g_CurCmd++;
        }
            
        CHAR Save;
        PSTR Pat = StringValue(STRV_TRIM_TRAILING_SPACE |
                               STRV_ESCAPED_CHARACTERS, &Save);

        if (strlen(Pat) + 1 > sizeof(g_OutFilterPattern))
        {
            error(OVERFLOW);
        }
        
        strcpy(g_OutFilterPattern, Pat);
        *g_CurCmd = Save;
        _strupr(g_OutFilterPattern);
    }
    
    if (g_OutFilterPattern[0])
    {
        dprintf("Only display debuggee output that %s '%s'\n",
                g_OutFilterResult ? "matches" : "doesn't match",
                g_OutFilterPattern);
    }
    else
    {
        dprintf("No debuggee output filter set\n");
    }
}

void
ParseSeparateCurrentProcess(PSTR Command)
{
    HRESULT Status;
    ULONG Mode;
    char Desc[128];

    if (!strcmp(Command, "abandon"))
    {
        Mode = SEP_ABANDON;
    }
    else if (!strcmp(Command, "detach"))
    {
        Mode = SEP_DETACH;
    }
    else if (!strcmp(Command, "kill"))
    {
        Mode = SEP_TERMINATE;
    }
    else
    {
        error(SYNTAX);
    }
            
    if ((Status = SeparateCurrentProcess(Mode, Desc)) == S_OK)
    {
        dprintf("%s\n", Desc);
    }
    else if (Status == E_NOTIMPL)
    {
        dprintf("The system doesn't support %s\n", Command);
    }
    else
    {
        dprintf("Unable to %s, %s\n",
                Command, FormatStatusCode(Status));
    }
}

void
ParseSetChildDebug(void)
{
    if (!IS_LIVE_USER_TARGET())
    {
        error(SESSIONNOTSUP);
    }
    if (g_CurrentProcess == NULL)
    {
        error(BADTHREAD);
    }

    HRESULT Status;
    PUSER_DEBUG_SERVICES Services = ((UserTargetInfo*)g_Target)->m_Services;
    ULONG Opts;

    Opts = g_CurrentProcess->Options;
    
    if (PeekChar() && *g_CurCmd != ';')
    {
        ULONG64 Val = GetExpression();
        if (Val)
        {
            Opts &= ~DEBUG_PROCESS_ONLY_THIS_PROCESS;
        }
        else
        {
            Opts |= DEBUG_PROCESS_ONLY_THIS_PROCESS;
        }
        
        if ((Status = Services->SetProcessOptions(g_CurrentProcess->FullHandle,
                                                  Opts)) != S_OK)
        {
            if (Status == E_NOTIMPL)
            {
                ErrOut("The system doesn't support changing the flag\n");
            }
            else
            {
                ErrOut("Unable to set process options, %s\n",
                       FormatStatusCode(Status));
            }
            return;
        }

        g_CurrentProcess->Options = Opts;
    }

    dprintf("Processes created by the current process will%s be debugged\n",
            (Opts & DEBUG_PROCESS_ONLY_THIS_PROCESS) ? " not" : "");
}

/*** fnDotCmdHelp - displays the legal dot commands
*
*   Purpose:
*       Show user the dot commands.
*
*   Input:
*       none
*
*   Output:
*       None.
*
*************************************************************************/

VOID
fnDotCmdHelp(
    VOID
    )
{
    dprintf(". commands:\n");
    dprintf("   .abandon - abandon the current process\n");
    dprintf("   .asm[-] [options...] - change disassembly options\n");
    if (IS_LIVE_USER_TARGET())
    {
        dprintf("   .attach <proc> - attach to <proc> at next execution\n");
        dprintf("   .breakin - break into KD\n");
    }
    if (IS_KERNEL_TARGET())
    {
        dprintf("   .bugcheck - display the bugcheck code and parameters for a crashed\n");
        dprintf("       system\n");
    }
    dprintf("   .chain - list current extensions\n");
    dprintf("   .childdbg <0|~0> - turn child process debugging on or off\n");
    dprintf("   .clients - list currently active clients\n");
    if (IS_KERNEL_TARGET())
    {
        dprintf("   .context [<address>] - set page directory base\n");
        dprintf("   .crash - cause target to bugcheck\n");
    }
    if (IS_LIVE_USER_TARGET())
    {
        dprintf("   .create <command line> - create a new process\n");
    }
    dprintf("   .cxr <address> - dump context record at specified address\n"
            "                    k* after this gives cxr stack\n");
    if (IS_LIVE_USER_TARGET())
    {
        dprintf("   .detach - detach from the current process\n");
    }
    dprintf("   .dump [options] filename - create a dump file on the host system\n");
    dprintf("   .echo [\"string\"|string] - Echo string\n");
    dprintf("   .ecxr - dump context record for current exception\n");
    dprintf("   .enable_unicode [0/1] - dump USHORT array/pointers and unicode strings\n");
    if (IS_REMOTE_USER_TARGET())
    {
        dprintf("   .endpsrv - cause the current session's process server to exit\n");
    }
    dprintf("   .exepath [dir[;...]] - set executable search path\n");
    dprintf("   .exepath+ [dir[;...]] - append executable search path\n");
    dprintf("   .exr <address> - dump exception record at specified address\n");
    dprintf("   .fnent <address> - dump function entry for the given code address\n");
    dprintf("   .formats <expr> - displays expression result in many formats\n");
    dprintf("   .help - display this help\n");
    dprintf("   .kframes <count> - set default stack trace depth\n");
    if (IS_LIVE_USER_TARGET())
    {
        dprintf("   .kill - kill the current process\n");
    }
    dprintf("   .lastevent - display the last event that occurred\n");
    dprintf("   .lines - toggle line symbol loading\n");
    dprintf("   .logfile - display log status\n");
    dprintf("   .logopen [<file>] - open new log file\n");
    dprintf("   .logappend [<file>] - append to log file\n");
    dprintf("   .logclose - close log file\n");
    dprintf("   .noshell - Disable shell commands\n");
    dprintf("   .noversion - disable extension version checking\n");
    dprintf("   .ofilter <pattern> - filter debuggee output against the given pattern\n");
    dprintf("   .process [<address>] - Sets implicit process\n"
            "           Resets default if no address specified.\n");
    if (IS_REMOTE_KERNEL_TARGET())
    {
        dprintf("   .reboot - reboot target\n");
    }
    dprintf("   .reload [filename[=<address>]] - reload symbols\n");
    dprintf("   .remote <pipename> - start remote.exe server\n");
    dprintf("   .server <options> - start engine server\n");
    dprintf("   .sleep <milliseconds> - debugger sleeps for given duration\n");
    dprintf("       Useful for allowing access to a machine that's broken in on an ntsd -d.\n");
    dprintf("   .srcpath [dir[;...]] - set source search path\n");
    dprintf("   .srcpath+ [dir[;...]] - append source search path\n");
    dprintf("   .sympath [dir[;...]] - set symbol search path\n");
    dprintf("   .sympath+ [dir[;...]] - append symbol search path\n");
    dprintf("   .shell [<command>] - execute shell command\n");
    if (IS_LIVE_USER_TARGET())
    {
        dprintf("   .tlist - list running processes\n");
    }
    if (IS_KERNEL_TARGET())
    {
        dprintf("   .trap <address> - Dump a trap frame\n");
        if (g_EffMachine == IMAGE_FILE_MACHINE_I386)
        {
            dprintf("   .tss <selector> - Dump a Task State Segment\n");
        }
    
    }
    dprintf("   .thread [<address>] - Sets context of thread at address\n"
            "           Resets default context if no address specified.\n");
    dprintf("\n");
    dprintf("The following can be used with any extension module:\n");
    dprintf("   .load\n");
    dprintf("   .setdll\n");
    dprintf("   .unload\n");
    dprintf("   .unloadall\n");
    dprintf("\n");
}

/*** fnDotCommand - parse and execute dot command
*
*   Purpose:
*       Parse and execute all commands starting with a dot ('.').
*
*   Input:
*       g_CurCmd - pointer to character after dot in command line
*
*   Output:
*       None.
*
*************************************************************************/

#define MAX_DOT_COMMAND 16

BOOL
DotCommand(
    DebugClient* Client
    )
{
    ULONG       index = 0;
    char        chCmd[MAX_DOT_COMMAND];
    UCHAR       ch;
    ADDR        tempAddr;
    HRESULT     Status;
    ULONG64     Value;

    //  read in up to the first few alpha characters into
    //      chCmd, converting to lower case

    while (index < MAX_DOT_COMMAND)
    {
        ch = (UCHAR)tolower(*g_CurCmd);
        if ((ch >= 'a' && ch <= 'z') || ch == '-' || ch == '+' || ch == '_')
        {
            chCmd[index++] = ch;
            g_CurCmd++;
        }
        else
        {
            break;
        }
    }

    //  if all characters read, then too big, else terminate

    if (index == MAX_DOT_COMMAND)
    {
        error(SYNTAX);
    }
    chCmd[index] = '\0';

    //  test for the commands

    if (!strcmp(chCmd, "asm") || !strcmp(chCmd, "asm-"))
    {
        ChangeAsmOptions(chCmd[3] != '-', g_CurCmd);
        // Command uses the whole string so we're done.
        *g_CurCmd = 0;
    }
    else if (!strcmp(chCmd, "x"))
    {
        dprintf("Pending %X, process %X\n",
                g_AllPendingFlags, g_AllProcessFlags);
    }
    else if (!strcmp(chCmd, "bpcmds"))
    {
        ULONG Flags = 0;
        PPROCESS_INFO Process = g_CurrentProcess;
        ULONG Id;
        
        while (PeekChar() == '-')
        {
            switch(*(++g_CurCmd))
            {
            case '1':
                Flags |= BPCMDS_ONE_LINE;
                break;
            case 'd':
                Flags |= BPCMDS_FORCE_DISABLE;
                break;
            case 'e':
                Flags |= BPCMDS_EXPR_ONLY;
                break;
            case 'm':
                Flags |= BPCMDS_MODULE_HINT;
                break;
            case 'p':
                g_CurCmd++;
                Id = (ULONG)GetTermExprDesc("Process ID missing from");
                Process = FindProcessByUserId(Id);
                if (!Process)
                {
                    error(BADPROCESS);
                }
                g_CurCmd--;
                break;
            default:
                dprintf("Unknown option '%c'\n", *g_CurCmd);
                break;
            }

            g_CurCmd++;
        }
        
        // Internal command only.
        ListBreakpointsAsCommands(Client, Process, Flags);
    }
    else if (!strcmp(chCmd, "bpsync"))
    {
        if (PeekChar() && *g_CurCmd != ';')
        {
            if (GetExpression())
            {
                g_EngOptions |= DEBUG_ENGOPT_SYNCHRONIZE_BREAKPOINTS;
            }
            else
            {
                g_EngOptions &= ~DEBUG_ENGOPT_SYNCHRONIZE_BREAKPOINTS;
            }
        }
        dprintf("Breakpoint synchronization %s\n",
                (g_EngOptions & DEBUG_ENGOPT_SYNCHRONIZE_BREAKPOINTS) ?
                "enabled" : "disabled");
    }
    else if (!strcmp(chCmd, "childdbg"))
    {
        ParseSetChildDebug();
    }
    else if (!strcmp(chCmd, "clients"))
    {
        DebugClient* Cur;
        
        for (Cur = g_Clients; Cur != NULL; Cur = Cur->m_Next)
        {
            if (Cur->m_Flags & CLIENT_PRIMARY)
            {
                dprintf("%s, last active %s",
                        Cur->m_Identity, ctime(&Cur->m_LastActivity));
            }
        }
    }
    else if (!strcmp(chCmd, "cxr"))
    {
         ULONG Flags = 0;
         ULONG64 ContextBase = 0;

         if (PeekChar())
         {
             ContextBase = GetExpression();
         }

         if (ContextBase)
         {
             OutputVirtualContext(ContextBase, REGALL_INT32 | REGALL_INT64 | 
                                  (g_EffMachine == IMAGE_FILE_MACHINE_I386 ?
                                   REGALL_EXTRA0 : 0));
         }
         else if (GetCurrentScopeContext())
         {
             dprintf("Resetting default context\n");
             ResetCurrentScope();
         }
    }
    else if (!strcmp(chCmd, "dump"))
    {
        ParseDumpFileCommand();
    }
    else if (!strcmp(chCmd, "dumpdebug"))
    {
        if (IS_DUMP_TARGET())
        {
            //
            // Dump detailed statistics to debug dump files
            //

            ((DumpTargetInfo *)g_Target)->DumpDebug();
        }
        else
        {
            error(SESSIONNOTSUP);
        }
    }
    else if (!strcmp(chCmd, "dumpoff"))
    {
        if (IS_DUMP_TARGET())
        {
            //
            // Show the file offset for a VA.
            //
            
            ULONG64 Addr = GetExpression();
            ULONG64 Offs;
            ULONG File;
            ULONG Avail;

            Offs = ((DumpTargetInfo*)g_Target)->
                VirtualToOffset(Addr, &File, &Avail);
            dprintf("Virtual %s maps to file %d offset %I64x\n",
                    FormatAddr64(Addr), File, Offs);
        }
        else
        {
            error(SESSIONNOTSUP);
        }
    }
    else if (!strcmp(chCmd, "dumppoff"))
    {
        if (IS_KERNEL_SUMMARY_DUMP() || IS_KERNEL_FULL_DUMP())
        {
            //
            // Show the file offset for a physical address.
            //
            
            ULONG64 Addr = GetExpression();
            ULONG Avail;
            
            dprintf("Physical %I64x maps to file offset %I64x\n",
                    Addr, ((KernelFullSumDumpTargetInfo *)g_Target)->
                    PhysicalToOffset(Addr, &Avail));
        }
        else
        {
            error(SESSIONNOTSUP);
        }
    }
    else if (!strcmp(chCmd, "echo"))
    {
        EchoString();
    }
    else if (!strcmp(chCmd, "ecxr"))
    {
        CROSS_PLATFORM_CONTEXT Context;
        
        if ((Status = g_Target->GetExceptionContext(&Context)) != S_OK)
        {
            ErrOut("Unable to get exception context, 0x%X\n", Status);
        }
        else
        {
            OutputContext(&Context, REGALL_INT32 | REGALL_INT64 | 
                          (g_EffMachine == IMAGE_FILE_MACHINE_I386 ?
                           REGALL_EXTRA0 : 0));
        }
    }
    else if (!strcmp(chCmd, "effmach"))
    {
        SetEffMachineByName();
    }
    else if (!strcmp(chCmd, "enable_unicode"))
    {
        g_EnableUnicode = (BOOL) GetExpression();
        if (g_EnableUnicode) 
        {
            g_TypeOptions |= DEBUG_TYPEOPTS_UNICODE_DISPLAY;
        } else 
        {
            g_TypeOptions &= ~DEBUG_TYPEOPTS_UNICODE_DISPLAY;
        }
        // Callback to update locals and watch window
        NotifyChangeSymbolState(DEBUG_CSS_TYPE_OPTIONS, 0, NULL);
    }
    else if (IS_REMOTE_USER_TARGET() && !strcmp(chCmd, "endpsrv"))
    {
        ((UserTargetInfo*)g_Target)->m_Services->Uninitialize(TRUE);
        dprintf("Server told to exit\n");
    }
    else if (!strcmp(chCmd, "exr"))
    {
         DumpExr(GetExpression());
    }
    else if (!strcmp(chCmd, "esplog"))
    {
        extern ULONG g_EspLog[];
        extern PULONG g_EspLogCur;
        ULONG i;
        PULONG Cur = g_EspLogCur;
        
        // XXX drewb - Temporary log to try and catch some
        // SET_OF_INVALID_CONTEXT bugchecks occurring randomly on x86.
        for (i = 0; i < 32; i++)
        {
            if (Cur <= g_EspLog)
            {
                Cur = g_EspLog + 64;
            }

            Cur -= 2;

            if ((*Cur & 0x80000000) == 0)
            {
                // Unused slot.
                break;
            }

            if (*Cur & 0x40000000)
            {
                dprintf("%2d: Set proc %2d: %08X\n",
                        i, *Cur & 0xffff, Cur[1]);
            }
            else
            {
                dprintf("%2d: Get proc %2d: %08X\n",
                        i, *Cur & 0xffff, Cur[1]);
            }
        }
    }
    else if (!strcmp(chCmd, "eventlog"))
    {
        OutputEventLog();
    }
    else if (!strcmp(chCmd, "fnent"))
    {
        ParseOutputFunctionEntry();
    }
    else if (!strcmp(chCmd, "formats"))
    {
        EvaluateExp(TRUE);
    }
    else if (!_stricmp( chCmd, "frame" ))
    {
        dotFrame();
        PrintStackFrame(&GetCurrentScope()->Frame,
                        DEBUG_STACK_FRAME_ADDRESSES |
                        DEBUG_STACK_FRAME_NUMBERS |
                        DEBUG_STACK_SOURCE_LINE);
    }
    else if (!strcmp(chCmd, "help"))
    {
        fnDotCmdHelp();
    }
    else if (!strcmp(chCmd, "imgscan"))
    {
        ScanForImages();
    }
#if _ENABLE_DOT_K_COMMANDS
    else if (chCmd[0] == 'k')
    {
        fnStackTrace(&chCmd[1]);
    }
#endif
    else if (IS_CONN_KERNEL_TARGET() && !strcmp(chCmd, "kdtrans"))
    {
        g_DbgKdTransport->OutputInfo();
    }
    else if (IS_CONN_KERNEL_TARGET() && !strcmp(chCmd, "kdfiles"))
    {
        ParseKdFileAssoc();
    }
    else if (!strcmp(chCmd, "kframes"))
    {
        g_DefaultStackTraceDepth = (ULONG)GetExpression();
        dprintf("Default stack trace depth is 0n%d frames\n",
                g_DefaultStackTraceDepth);
    }
    else if (!strcmp(chCmd, "lastevent"))
    {
        dprintf("Last event: %s\n", g_LastEventDesc);
    }
    else if (!strcmp(chCmd, "logappend"))
    {
        fnLogOpen(TRUE);
    }
    else if (!strcmp(chCmd, "logclose"))
    {
        fnLogClose();
    }
    else if (!strcmp(chCmd, "logfile"))
    {
        if (g_LogFile >= 0)
        {
            dprintf("Log '%s' open%s\n",
                    g_OpenLogFileName,
                    g_OpenLogFileAppended ? " for append" : "");
        }
        else
        {
            dprintf("No log file open\n");
        }
    }
    else if (!strcmp(chCmd, "logopen"))
    {
        fnLogOpen(FALSE);
    }
    else if (!strcmp(chCmd, "memregion"))
    {
        OutputMemRegion(GetExpression());
    }
    else if (!strcmp(chCmd, "noengerr"))
    {
        // Internal command to clear out the error suppression
        // flags in case we want to rerun operations and check
        // for errors that may be in suppression mode.
        g_EngErr = 0;
    }
    else if (!strcmp(chCmd, "noshell"))
    {
        g_EngOptions |= DEBUG_ENGOPT_DISALLOW_SHELL_COMMANDS;
        dprintf("Shell commands disabled\n");
    }
    else if (!strcmp(chCmd, "ofilter"))
    {
        ParseOutputFilter();
    }
    else if (!strcmp(chCmd, "outmask") ||
             !strcmp(chCmd, "outmask-"))
    {
        // Private internal command for debugging the debugger.
        ULONG Expr = (ULONG)GetExpression();
        if (chCmd[7] == '-')
        {
            Client->m_OutMask &= ~Expr;
        }
        else
        {
            Client->m_OutMask |= Expr;
        }
        dprintf("Client %p mask is %X\n", Client, Client->m_OutMask);
        CollectOutMasks();
    }
    else if (!strcmp(chCmd, "echotimestamps"))
    {
        g_EchoEventTimestamps = !g_EchoEventTimestamps;
        dprintf("Event timestamps are now %s\n",
                 g_EchoEventTimestamps ? "enabled" : "disabled");
    }
    else if (!strcmp(chCmd, "process"))
    {
        ParseSetImplicitProcess();
    }
    else if (!strcmp(chCmd, "server"))
    {
        // Skip whitespace.
        if (PeekChar() == 0)
        {
            ErrOut("Usage: .server tcp:port=<Socket>  OR  "
                   ".server npipe:pipe=<PipeName>\n");
        }
        else
        {
            Status = Client->StartServer(g_CurCmd);
            if (Status != S_OK)
            {
                ErrOut("Unable to start server, 0x%X\n", Status);
            }
            else
            {
                dprintf("Server started with '%s'\n", g_CurCmd);
            }
            *g_CurCmd = 0;
        }
    }
    else if (!strcmp(chCmd, "shell"))
    {
        fnShell(g_CurCmd);
        // Command uses the whole string so we're done.
        *g_CurCmd = 0;
    }
    else if (!strcmp(chCmd, "sleep"))
    {
        ULONG WaitStatus;
        ULONG Millis = 
            (ULONG)GetExprDesc("Number of milliseconds missing from");
        
        // This command is intended for use with ntsd/cdb -d
        // when being at the prompt locks up the target machine.
        // If you want to use the target machine for something,
        // such as copy symbols, there's no easy way to get it
        // running again without resuming the program.  By
        // sleeping you can return control to the target machine
        // without changing the session state.
        // The sleep is done with a wait on a named event so
        // that it can be interrupted from a different process.
        ResetEvent(g_SleepPidEvent);
        WaitStatus = WaitForSingleObject(g_SleepPidEvent, Millis);
        if (WaitStatus == WAIT_OBJECT_0)
        {
            dprintf("Sleep interrupted\n");
        }
        else if (WaitStatus != WAIT_TIMEOUT)
        {
            ErrOut("Sleep failed, %s\n",
                   FormatStatusCode(WIN32_LAST_STATUS()));
        }
    }
    else if (!strcmp(chCmd, "sxcmds"))
    {
        ULONG Flags = 0;
        
        while (PeekChar() == '-')
        {
            switch(*(++g_CurCmd))
            {
            case '1':
                Flags |= SXCMDS_ONE_LINE;
                break;
            default:
                dprintf("Unknown option '%c'\n", *g_CurCmd);
                break;
            }

            g_CurCmd++;
        }
        
        // Internal command only.
        ListFiltersAsCommands(Client, Flags);
    }
    else if (!strcmp(chCmd, "symopt+") ||
             !strcmp(chCmd, "symopt-"))
    {
        ULONG Flags = (ULONG)GetExpression();

        if (chCmd[6] == '+')
        {
            Flags |= g_SymOptions;
        }
        else
        {
            Flags = g_SymOptions & ~Flags;
        }

        dprintf("Symbol options are %X\n", Flags);
        SetSymOptions(Flags);
    }
    else if (!strcmp(chCmd, "thread"))
    {
        ParseSetImplicitThread();
    }
    else if (!strcmp(chCmd, "time"))
    {
        g_Target->OutputTime();
    }
    else if (!strcmp(chCmd, "wake"))
    {
        ULONG Pid = (ULONG)GetExpression();
        if (!SetPidEvent(Pid, OPEN_EXISTING))
        {
            ErrOut("Process %d is not a sleeping debugger\n", Pid);
        }
    }
    else if ((IS_REMOTE_KERNEL_TARGET() || IS_REMOTE_USER_TARGET()) &&
             !strcmp(chCmd, "cache"))
    {
        g_VirtualCache.ParseCommands();
    }
    else if (IS_REMOTE_KERNEL_TARGET() &&
             !strcmp(chCmd, "pcache"))
    {
        g_PhysicalCache.ParseCommands();
    }
    else if (IS_KERNEL_TARGET())
    {
        if (!strcmp(chCmd, "trap"))
        {
             ULONG64 frame = 0 ;
             CROSS_PLATFORM_CONTEXT Context;

             if (PeekChar())
             {
                 frame = GetExpression();
             }

             if (frame)
             {
                 g_TargetMachine->DisplayTrapFrame(frame, &Context);

                 SetCurrentScope(&g_LastRegFrame, &Context, sizeof(Context));
             }
             else if (GetCurrentScopeContext())
             {
                 dprintf("Resetting default context\n");
                 ResetCurrentScope();
             }
        }
        else if ((g_EffMachine == IMAGE_FILE_MACHINE_I386) &&
                 !strcmp(chCmd, "tss")) 
        {
            g_X86Machine.DumpTSS();
        }
        else if (!IS_LOCAL_KERNEL_TARGET())
        {
            if (!strcmp(chCmd, "bugcheck"))
            {
                ULONG Code;
                ULONG64 Args[4];
                
                g_Target->ReadBugCheckData(&Code, Args);
                dprintf("Bugcheck code %08X\n", Code);
                dprintf("Arguments %s %s %s %s\n",
                        FormatAddr64(Args[0]), FormatAddr64(Args[1]),
                        FormatAddr64(Args[2]), FormatAddr64(Args[3]));
            }
            else if (!IS_DUMP_TARGET())
            {
                if (!strcmp(chCmd, "pagein"))
                {
                    ParsePageIn();
                }
                else if (!strcmp(chCmd, "reboot") && ch == '\0')
                {
                    //  null out .reboot command
                    g_LastCommand[0] = '\0';
                    g_Target->Reboot();
                }
                else if (IS_CONN_KERNEL_TARGET() &&
                         !strcmp(chCmd, "crash"))
                {
                    g_LastCommand[0] = '\0';
                    DbgKdCrash( CRASH_BUGCHECK_CODE );
                    // Go back to waiting for a state change to
                    // receive the bugcheck exception.
                    g_CmdState = 's';
                }
                else
                {
                    return FALSE;
                }
            }
            else
            {
                return FALSE;
            }
        }
        else
        {
            return FALSE;
        }
    }
    else if (IS_LIVE_USER_TARGET())
    {
        if (!strcmp(chCmd, "abandon") ||
            !strcmp(chCmd, "detach") ||
            !strcmp(chCmd, "kill"))
        {
            ParseSeparateCurrentProcess(chCmd);
        }
        else if (!strcmp(chCmd, "attach"))
        {
            ParseAttachProcess();
        }
        else if (!strcmp(chCmd, "breakin"))
        {
            if (g_DebuggerPlatformId == VER_PLATFORM_WIN32_NT)
            {
                if (g_SystemVersion <= NT_SVER_NT4)
                {
                    // SysDbgBreakPoint isn't supported, so
                    // try to use user32's PrivateKDBreakPoint.
                    if (InitDynamicCalls(&g_User32CallsDesc) == S_OK &&
                        g_User32Calls.PrivateKDBreakPoint != NULL)
                    {
                        g_User32Calls.PrivateKDBreakPoint();
                    }
                    else
                    {
                        ErrOut(".breakin is not supported on this system\n");
                    }
                }
                else
                {
                    NTSTATUS NtStatus;
                
                    NtStatus = g_NtDllCalls.NtSystemDebugControl
                        (SysDbgBreakPoint, NULL, 0, NULL, 0, NULL);
                    if (NtStatus == STATUS_ACCESS_DENIED)
                    {
                        ErrOut(".breakin requires debug privilege\n");
                    }
                    else if (NtStatus == STATUS_INVALID_INFO_CLASS)
                    {
                        ErrOut(".breakin is not supported on this system\n");
                    }
                    else if (!NT_SUCCESS(NtStatus))
                    {
                        ErrOut(".breakin failed, 0x%X\n", NtStatus);
                    }
                }
            }
            else
            {
                ErrOut(".breakin not supported on this platform\n");
            }
        }
        else if (!strcmp(chCmd, "create"))
        {
            PPENDING_PROCESS Pending;
            PSTR CmdLine;
            CHAR Save;

            CmdLine = StringValue(STRV_TRIM_TRAILING_SPACE, &Save);
            Status = StartCreateProcess(CmdLine, DEBUG_ONLY_THIS_PROCESS,
                                        &Pending);
            if (Status == S_OK)
            {
                dprintf("Create will proceed with next execution\n");
            }
            *g_CurCmd = Save;
        }
        else if (!strcmp(chCmd, "tlist"))
        {
            ListProcesses();
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        // Target not set yet.
        return FALSE;
    }

    return TRUE;
}

VOID
ParseStackTrace (
    PSTACK_TRACE_TYPE pTraceType,
    PADDR  StartFP,
    PULONG64 Esp,
    PULONG64 Eip,
    PULONG Count
    )
{
    UCHAR   ch;

    ch = PeekChar();
    *pTraceType = STACK_TRACE_TYPE_DEFAULT;

    if (tolower(ch) == 'b')
    {
        g_CurCmd++;
        *pTraceType = STACK_TRACE_TYPE_KB;
    }
    else if (tolower(ch) == 'v')
    {
        g_CurCmd++;
        *pTraceType = STACK_TRACE_TYPE_KV;
    }
    else if (tolower(ch) == 'd')
    {
        g_CurCmd++;
        *pTraceType = STACK_TRACE_TYPE_KD;
    }
    else if (tolower(ch) == 'p')
    {
        g_CurCmd++;
        *pTraceType = STACK_TRACE_TYPE_KP;
    }
    ch = PeekChar();

    if (tolower(ch) == 'n')
    {
        g_CurCmd++;
        *pTraceType = (STACK_TRACE_TYPE) (*pTraceType + STACK_TRACE_TYPE_KN);
    }

    if (!PeekChar() && GetCurrentScopeContext())
    {
        dprintf("  *** Stack trace for last set context - .thread resets it\n");
    }

    if (PeekChar() == '=')
    {
        g_CurCmd++;
        GetAddrExpression(SEGREG_STACK, StartFP);
    }
    else if (g_EffMachine == IMAGE_FILE_MACHINE_I386)
    {
        g_Machine->GetFP(StartFP);
    }
    else
    {
        ADDRFLAT(StartFP, 0);
    }

    *Count = g_DefaultStackTraceDepth;

    if (g_EffMachine == IMAGE_FILE_MACHINE_I386 &&
        (ch = PeekChar()) != '\0' && ch != ';')
    {
        //
        // If only one more value it's the count
        //

        *Count = (ULONG)GetExpression();

        if ((ch = PeekChar()) != '\0' && ch != ';')
        {
            //
            // More then one value, set extra value for special
            // FPO backtrace
            //

            *Eip   = GetExpression();
            *Esp   = *Count;
            *Count = g_DefaultStackTraceDepth;
        }
    }

    if ((ch = PeekChar()) != '\0' && ch != ';')
    {
        *Count = (ULONG)GetExpression();
        if ((LONG)*Count < 1)
        {
            g_CurCmd++;
            error(SYNTAX);
        }
    }
}

void
SetSuffix(void)
{
    UCHAR   ch;

    ch = PeekChar();
    ch = (UCHAR)tolower(ch);

    if (ch == ';' || ch == '\0')
    {
        if (g_SymbolSuffix == 'n')
        {
            dprintf("n - no suffix\n");
        }
        else if (g_SymbolSuffix == 'a')
        {
            dprintf("a - ascii\n");
        }
        else
        {
            dprintf("w - wide\n");
        }
    }
    else if (ch == 'n' || ch == 'a' || ch == 'w')
    {
        g_SymbolSuffix = ch;
        g_CurCmd++;
    }
    else
    {
        error(SYNTAX);
    }
}

void
OutputVersionInformation(DebugClient* Client)
{
    char Buf[MAX_PATH];
    DBH_DIAVERSION DiaVer;
    
    //
    // Print out the connection options if we are doing live debugging.
    //
    if (IS_KERNEL_TARGET())
    {
        switch(g_TargetClassQualifier)
        {
        case DEBUG_KERNEL_CONNECTION:
            g_DbgKdTransport->GetParameters(Buf, sizeof(Buf));
            break;
        case DEBUG_KERNEL_LOCAL:
            strcpy(Buf, "Local Debugging");
            break;
        case DEBUG_KERNEL_EXDI_DRIVER:
            strcpy(Buf, "eXDI Debugging");
            break;
        default:
            strcpy(Buf, "Dump File");
            break;
        }
        
        dprintf("Connection options: %s\n", Buf);
    }

    dprintf("Command line: '%s'\n", GetCommandLine());

    dprintf("dbgeng:  ");
    OutputModuleIdInfo(NULL, "dbgeng.dll", NULL);

    dprintf("dbghelp: ");
    OutputModuleIdInfo(NULL, "dbghelp.dll", NULL);

    DiaVer.function = dbhDiaVersion;
    DiaVer.sizeofstruct = sizeof(DiaVer);
    if (dbghelp(NULL, &DiaVer))
    {
        dprintf("        DIA version: %d\n", DiaVer.ver);
    }

    // Dump information about the IA64 support DLLs if they're
    // loaded.  Don't bother forcing them to load.
    if (GetModuleHandle("decem.dll") != NULL)
    {
        dprintf("decem:   ");
        OutputModuleIdInfo(NULL, "decem.dll", NULL);
    }

    OutputExtensions(Client, TRUE);
}

VOID
DumpExr(
    ULONG64 ExrAddress
    )
{
    ULONG   i;
    CHAR Buffer[256];
    ULONG64 displacement;
    EXCEPTION_RECORD64  Exr64;
    EXCEPTION_RECORD32  Exr32;
    EXCEPTION_RECORD64 *Exr = &Exr64;
    ULONG BytesRead;
    HRESULT hr = S_OK;

    if (ExrAddress == (ULONG64) -1) 
    {
        if (g_LastEventType == DEBUG_EVENT_EXCEPTION)
        {
            Exr64 = g_LastEventInfo.Exception.ExceptionRecord;
        }
        else
        {
            ErrOut("Last event was not an exception\n");
            return;
        }
    }
    else if (g_TargetMachine->m_Ptr64) 
    {
        hr = g_Target->ReadVirtual(ExrAddress,
                                   &Exr64,
                                   sizeof(Exr64),
                                   &BytesRead);
    }
    else 
    {
        hr = g_Target->ReadVirtual(ExrAddress,
                                   &Exr32,
                                   sizeof(Exr32),
                                   &BytesRead);
        ExceptionRecord32To64(&Exr32, &Exr64);
    }
    if (hr != S_OK)
    {
        dprintf64("Cannot read Exception record @ %p\n", ExrAddress);
        return;
    }
    
    GetSymbolStdCall(Exr->ExceptionAddress, &Buffer[0], sizeof(Buffer),
                     &displacement, NULL);

    if (*Buffer)
    {
        dprintf64("ExceptionAddress: %p (%s",
                  Exr->ExceptionAddress,
                  Buffer);
        if (displacement)
        {
            dprintf64("+0x%p)\n", displacement);
        }
        else
        {
            dprintf64(")\n");
        }
    }
    else
    {
        dprintf64("ExceptionAddress: %p\n", Exr->ExceptionAddress);
    }
    dprintf("   ExceptionCode: %08lx\n", Exr->ExceptionCode);
    dprintf("  ExceptionFlags: %08lx\n", Exr->ExceptionFlags);

    dprintf("NumberParameters: %d\n", Exr->NumberParameters);
    if (Exr->NumberParameters > EXCEPTION_MAXIMUM_PARAMETERS)
    {
        Exr->NumberParameters = EXCEPTION_MAXIMUM_PARAMETERS;
    }
    for (i = 0; i < Exr->NumberParameters; i++)
    {
        dprintf64("   Parameter[%d]: %p\n", i, Exr->ExceptionInformation[i]);
    }

    //
    // Known Exception processing:
    //

    switch ( Exr->ExceptionCode )
    {
    case STATUS_ACCESS_VIOLATION:
        if ( Exr->NumberParameters == 2 )
        {
            dprintf64("Attempt to %s address %p\n",
                      (Exr->ExceptionInformation[0] ?
                       "write to" : "read from"),
                      Exr->ExceptionInformation[1] );
            
        }
        break;

    case STATUS_IN_PAGE_ERROR:
        if ( Exr->NumberParameters == 3 )
        {
            dprintf64("Inpage operation failed at %p, due to I/O error %p\n",
                      Exr->ExceptionInformation[1],
                      Exr->ExceptionInformation[2] );
        }
        break;

    case STATUS_INVALID_HANDLE:
    case STATUS_HANDLE_NOT_CLOSABLE:
        dprintf64( "Thread tried to close a handle that was "
                   "invalid or illegal to close\n");
        break;

    case STATUS_POSSIBLE_DEADLOCK:
        if ( Exr->NumberParameters == 1 )
        {
            RTL_CRITICAL_SECTION64  CritSec64;
            RTL_CRITICAL_SECTION32  CritSec32;
            ULONG Result ;
            
            GetSymbolStdCall( Exr->ExceptionInformation[0],
                              &Buffer[0], sizeof(Buffer),
                              &displacement, NULL );

            if ( *Buffer )
            {
                dprintf64("Critical section at %p (%s+%p)",
                          Exr->ExceptionInformation[0],
                          Buffer,
                          displacement );
            }
            else
            {
                dprintf64("Critical section at %p",
                          Exr->ExceptionInformation[0] );

            }

            if (g_TargetMachine->m_Ptr64)
            {
                hr = g_Target->ReadVirtual(Exr->ExceptionInformation[0],
                                           &CritSec64,
                                           sizeof(CritSec64),
                                           &BytesRead);

            }
            else
            {
                hr = g_Target->ReadVirtual(Exr->ExceptionInformation[0],
                                           &CritSec32,
                                           sizeof(CritSec32),
                                           &BytesRead);
                if (hr == S_OK)
                {
                    CritSec64.OwningThread = CritSec32.OwningThread;
                }

            }
            if (hr == S_OK)
            {
                dprintf64("is owned by thread %p,\n"
                          "causing this thread to raise an exception",
                          CritSec64.OwningThread );
            }

            dprintf("\n");

        }
        break;

    default:
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\ntalias.hpp ===
/*** ntalias.hpp - Alias command processor for NT debugger
*
*   Copyright <C> 1999-2001, Microsoft Corporation
*
*   Purpose:
*       To establish, maintain, and translate alias command tokens
*
*
*   Revision History:
*
*   [-]  08-Aug-1999 Richg      Created.
*
*************************************************************************/

#ifndef __NTALIAS_HP__
#define __NTALIAS_HP__

/************************************************************************
 *                                                                      *
 *  Name:     ALIAS structure                                           *
 *                                                                      *
 *  Purpose:  Structure used to contain Alias elements. This sturcture  *
 *            is only forward linked (Next.flink).                      *
 *                                                                      *
 *            This structure is allocated by fnSetAliasExpression( )    *
 *            and freed by fnDeleteAliasExpression( ).                  *
 *                                                                      *
 *  Anchor:   AliasListHead                                             *
 *                                                                      *
 ************************************************************************/
typedef struct _ALIAS
{
    struct _ALIAS* Next;                // Link
    PSTR           Name;                // Name\text of aliased token
    PSTR           Value;               // Alias text
} ALIAS, *PALIAS;

extern PALIAS g_AliasListHead;
extern ULONG  g_NumAliases;

HRESULT SetAlias(PCSTR SrcText, PCSTR DstText);
void    ParseSetAlias(void);
HRESULT DeleteAlias(PCSTR SrcText);
void    ParseDeleteAlias(void);
void    ListAliases(void);

void    ReplaceAliases(PSTR CommandString);

#endif // #ifndef __NTALIAS_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\ntexpr.h ===
//----------------------------------------------------------------------------
//
// ntexpr.h
//
// Copyright (C) Microsoft Corporation, 1997-2001.
//
//----------------------------------------------------------------------------

#ifndef _NTEXPR_H_
#define _NTEXPR_H_

extern ULONG64 g_LastExpressionValue;
extern BOOL g_AllowUnresolvedSymbols;
extern ULONG g_NumUnresolvedSymbols;
extern BOOL g_TypedExpr;

PADDR GetAddrExprDesc(ULONG SegReg, PCSTR ExprDesc, PADDR Addr);
ULONG64 GetExprDesc(PCSTR ExprDesc);
ULONG64 GetTermExprDesc(PCSTR ExprDesc);

#define GetAddrExpression(SegReg, Addr) GetAddrExprDesc(SegReg, NULL, Addr)
#define GetExpression() GetExprDesc(NULL)

CHAR
PeekChar(
    void
    );

BOOL
GetRange (
    PADDR Addr,
    PULONG64 Value,
    ULONG Size,
    ULONG SegReg
    );

LONG64
EvaluateSourceExpression(
    PCHAR pExpr
    );

#endif // #ifndef _NTEXPR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\ntexpr.cpp ===
/*** ntexpr.cpp - expression evaluator for NT debugger
*
*   Copyright <C> 1990-2001, Microsoft Corporation
*
*   Purpose:
*       With the current command line at *g_CurCmd, parse
*       and evaluate the next expression.
*
*   Revision History:
*
*   [-]  18-Apr-1990 Richk      Created - split from ntcmd.c.
*
*************************************************************************/

#include "ntsdp.hpp"

struct Res
{
    char     chRes[3];
    ULONG    classRes;
    ULONG    valueRes;
};

Res g_Reserved[] =
{
    { 'o', 'r', '\0', LOGOP_CLASS, LOGOP_OR  },
    { 'b', 'y', '\0', UNOP_CLASS,  UNOP_BY   },
    { 'w', 'o', '\0', UNOP_CLASS,  UNOP_WO   },
    { 'd', 'w', 'o',  UNOP_CLASS,  UNOP_DWO  },
    { 'q', 'w', 'o',  UNOP_CLASS,  UNOP_QWO  },
    { 'h', 'i', '\0', UNOP_CLASS,  UNOP_HI   },
    { 'm', 'o', 'd',  MULOP_CLASS, MULOP_MOD },
    { 'x', 'o', 'r',  LOGOP_CLASS, LOGOP_XOR },
    { 'a', 'n', 'd',  LOGOP_CLASS, LOGOP_AND },
    { 'p', 'o', 'i',  UNOP_CLASS,  UNOP_POI  },
    { 'n', 'o', 't',  UNOP_CLASS,  UNOP_NOT  },
    { 'l', 'o', 'w',  UNOP_CLASS,  UNOP_LOW  },
    { 'v', 'a', 'l',  UNOP_CLASS,  UNOP_VAL  }
};

Res g_X86Reserved[] =
{
    { 'e', 'a', 'x',  REG_CLASS,   X86_EAX   },
    { 'e', 'b', 'x',  REG_CLASS,   X86_EBX   },
    { 'e', 'c', 'x',  REG_CLASS,   X86_ECX   },
    { 'e', 'd', 'x',  REG_CLASS,   X86_EDX   },
    { 'e', 'b', 'p',  REG_CLASS,   X86_EBP   },
    { 'e', 's', 'p',  REG_CLASS,   X86_ESP   },
    { 'e', 'i', 'p',  REG_CLASS,   X86_EIP   },
    { 'e', 's', 'i',  REG_CLASS,   X86_ESI   },
    { 'e', 'd', 'i',  REG_CLASS,   X86_EDI   },
    { 'e', 'f', 'l',  REG_CLASS,   X86_EFL   }
};

#define RESERVESIZE (sizeof(g_Reserved) / sizeof(Res))
#define X86_RESERVESIZE (sizeof(g_X86Reserved) / sizeof(Res))

char * g_X86SegRegs[] =
{
    "cs", "ds", "es", "fs", "gs", "ss"
};
#define X86_SEGREGSIZE (sizeof(g_X86SegRegs) / sizeof(char *))

ULONG  g_SavedClass;
LONG64 g_SavedValue;
PSTR   g_SavedCommand;

TYPES_INFO g_ExprTypeInfo;

ULONG64 g_LastExpressionValue;

BOOL g_AllowUnresolvedSymbols;
ULONG g_NumUnresolvedSymbols;
BOOL g_ForcePositiveNumber;
// Syms in a expression evaluate to values rather than address
BOOL g_TypedExpr;

PCSTR g_ExprDesc;

USHORT g_AddrExprType;
ADDR g_TempAddr;

ULONG
PeekToken(
    PLONG64 pvalue
    );

ULONG
GetTokenSym(
    PLONG64 pvalue
    );

ULONG
NextToken(
    PLONG64 pvalue
    );

ULONG
GetRegToken(
    PCHAR str,
    PULONG64 value
    );

void
AcceptToken(
    void
    );

ULONG64
GetCommonExpression(
    VOID
    );

LONG64
GetExpr(
    void
    );

LONG64
GetLRterm(
    void
    );

LONG64
GetLterm(
    void
    );

LONG64
GetShiftTerm(
    void
    );

LONG64
GetAterm(
    void
    );

LONG64
GetMterm(
    void
    );

LONG64
GetTerm(
    void
    );

LONG64
GetTypedExpression(
    void
    );

BOOL
GetSymValue(
    PSTR Symbol,
    PULONG64 pValue
    );

ULONG
GetRegToken(
    char *str,
    PULONG64 value
    )
/*++

Routine Description:


Arguments:


Return Value:

--*/
{
    if ((*value = RegIndexFromName(str)) != REG_ERROR)
    {
        return REG_CLASS;
    }
    else
    {
        *value = BADREG;
        return ERROR_CLASS;
    }
}

void
ForceAddrExpression(ULONG SegReg, PADDR Address, ULONG64 Value)
{
    DESCRIPTOR64 DescBuf, *Desc = NULL;
        
    *Address = g_TempAddr;
    // Rewriting the offset may change flat address so
    // be sure to recompute it later.
    Off(*Address) = Value;

    //  If it wasn't an explicit address expression
    //  force it to be an address

    if (!(g_AddrExprType & ~INSTR_POINTER))
    {
        g_AddrExprType = Address->type =
            g_X86InVm86 ? ADDR_V86 : (g_X86InCode16 ? ADDR_16 : ADDR_FLAT);
        if (g_AddrExprType != ADDR_FLAT &&
            SegReg < SEGREG_COUNT &&
            g_Machine->GetSegRegDescriptor(SegReg, &DescBuf) == S_OK)
        {
            PCROSS_PLATFORM_CONTEXT ScopeContext =
                GetCurrentScopeContext();
            if (ScopeContext)
            {
                g_Machine->PushContext(ScopeContext);
            }

            Address->seg = (USHORT)
                GetRegVal32(g_Machine->GetSegRegNum(SegReg));
            Desc = &DescBuf;
            
            if (ScopeContext)
            {
                g_Machine->PopContext();
            }
        }
        else
        {
            Address->seg = 0;
        }
    }
    else if fnotFlat(*Address)
    {
        //  This case (i.e., g_AddrExprType && !flat) results from
        //  an override (i.e., %,,&, or #) being used but no segment
        //  being specified to force a flat address computation.

        Type(*Address) = g_AddrExprType;
        Address->seg = 0;

        if (SegReg < SEGREG_COUNT)
        {
            //  test flag for IP or EIP as register argument
            //      if so, use CS as default register
            if (fInstrPtr(*Address))
            {
                SegReg = SEGREG_CODE;
            }
        
            if (g_Machine->GetSegRegDescriptor(SegReg, &DescBuf) == S_OK)
            {
                PCROSS_PLATFORM_CONTEXT ScopeContext =
                    GetCurrentScopeContext();
		if (ScopeContext)
                {
                    g_Machine->PushContext(ScopeContext);
                }

                Address->seg = (USHORT)
                    GetRegVal32(g_Machine->GetSegRegNum(SegReg));
                Desc = &DescBuf;
                
		if (ScopeContext)
                {
                    g_Machine->PopContext();
                }
            }
        }
    }

    // Force sign-extension of 32-bit flat addresses.
    if (Address->type == ADDR_FLAT && !g_Machine->m_Ptr64)
    {
	Off(*Address) = EXTEND64(Off(*Address));
    }

    // Force an updated flat address to be computed.
    NotFlat(*Address);
    ComputeFlatAddress(Address, Desc);
}

PADDR
GetAddrExprDesc(
    ULONG SegReg,
    PCSTR Desc,
    PADDR Address
    )
{
    NotFlat(*Address);

    // Evaluate a normal expression and then
    // force the result to be an address.

    if (Desc == NULL)
    {
        Desc = "Address expression missing from";
    }
    
    ULONG64 Value = GetExprDesc(Desc);
    ForceAddrExpression(SegReg, Address, Value);

    g_ExprDesc = NULL;
    return Address;
}

ULONG64
GetExprDesc(PCSTR ExprDesc)
{
    if (ExprDesc != NULL)
    {
        g_ExprDesc = ExprDesc;
    }
    else
    {
        g_ExprDesc = "Numeric expression missing from";
    }

    ULONG64 Value = GetCommonExpression();
    g_LastExpressionValue = Value;
    
    g_ExprDesc = NULL;
    return Value;
}
    
ULONG64
GetTermExprDesc(PCSTR ExprDesc)
{
    if (ExprDesc != NULL)
    {
        g_ExprDesc = ExprDesc;
    }
    else
    {
        g_ExprDesc = "Numeric value missing from";
    }

    g_SavedClass = INVALID_CLASS;
    
    ULONG64 Value = GetTerm();
    
    g_ExprDesc = NULL;
    return Value;
}
    
/*** GetCommonExpression - read and evaluate expression
*
*   Purpose:
*       From the current command line position at g_CurCmd,
*       read and evaluate the next possible expression.
*
*************************************************************************/

ULONG64
GetCommonExpression(VOID)
{
    CHAR ch;

    g_SavedClass = INVALID_CLASS;

    ch = PeekChar();
    switch(ch)
    {
    case '&':
        g_CurCmd++;
        g_AddrExprType = ADDR_V86;
        break;
    case '#':
        g_CurCmd++;
        g_AddrExprType = ADDR_16;
        break;
    case '%':
        g_CurCmd++;
        g_AddrExprType = ADDR_FLAT;
        break;
    default:
        g_AddrExprType = ADDR_NONE;
        break;
    }
    
    PeekChar();
    return (ULONG64)GetExpr();
}

/*** GetExpr - Get expression
*
*   Purpose:
*       Parse logical-terms separated by logical operators into
*       expression value.
*
*   Input:
*       g_CurCmd - present command line position
*
*   Returns:
*       long value of logical result.
*
*   Exceptions:
*       error exit: SYNTAX - bad expression or premature end-of-line
*
*   Notes:
*       may be called recursively.
*       <expr> = <lterm> [<logic-op> <lterm>]*
*       <logic-op> = AND (&), OR (|), XOR (^)
*
*************************************************************************/

LONG64
GetExpr (
    void
    )
{
    LONG64    value1;
    LONG64    value2;
    ULONG  opclass;
    LONG64    opvalue;

//dprintf("LONG64 GetExpr ()\n");
    value1 = GetLRterm();
    while ((opclass = PeekToken(&opvalue)) == LOGOP_CLASS) {
        AcceptToken();
        value2 = GetLRterm();
        switch (opvalue) {
            case LOGOP_AND:
                value1 &= value2;
                break;
            case LOGOP_OR:
                value1 |= value2;
                break;
            case LOGOP_XOR:
                value1 ^= value2;
                break;
            default:
                error(SYNTAX);
        }
    }
    return value1;
}

/*** GetLRterm - get logical relational term
*
*   Purpose:
*       Parse logical-terms separated by logical relational
*       operators into the expression value.
*
*   Input:
*       g_CurCmd - present command line position
*
*   Returns:
*       long value of logical result.
*
*   Exceptions:
*       error exit: SYNTAX - bad expression or premature end-of-line
*
*   Notes:
*       may be called recursively.
*       <expr> = <lterm> [<rel-logic-op> <lterm>]*
*       <logic-op> = '==' or '=', '!=', '>', '<'
*
*************************************************************************/

LONG64
GetLRterm (
    void
    )
{
    LONG64    value1;
    LONG64    value2;
    ULONG  opclass;
    LONG64    opvalue;

//dprintf("LONG64 GetLRterm ()\n");
    value1 = GetLterm();
    while ((opclass = PeekToken(&opvalue)) == LRELOP_CLASS) {
        AcceptToken();
        value2 = GetLterm();
        switch (opvalue) {
            case LRELOP_EQ:
                value1 = (value1 == value2);
                break;
            case LRELOP_NE:
                value1 = (value1 != value2);
                break;
            case LRELOP_LT:
                value1 = (value1 < value2);
                break;
            case LRELOP_GT:
                value1 = (value1 > value2);
                break;
            default:
                error(SYNTAX);
        }
    }
    return value1;
}

/*** GetLterm - get logical term
*
*   Purpose:
*       Parse shift-terms separated by shift operators into
*       logical term value.
*
*   Input:
*       g_CurCmd - present command line position
*
*   Returns:
*       long value of sum.
*
*   Exceptions:
*       error exit: SYNTAX - bad logical term or premature end-of-line
*
*   Notes:
*       may be called recursively.
*       <lterm> = <sterm> [<shift-op> <sterm>]*
*       <shift-op> = <<, >>, >>>
*
*************************************************************************/

LONG64
GetLterm (
    void
    )
{
    LONG64    value1 = GetShiftTerm();
    LONG64    value2;
    ULONG     opclass;
    LONG64    opvalue;

//dprintf("LONG64 GetLterm ()\n");
    while ((opclass = PeekToken(&opvalue)) == SHIFT_CLASS) {
        AcceptToken();
        value2 = GetShiftTerm();
        switch (opvalue) {
        case SHIFT_LEFT:
            value1 <<= value2;
            break;
        case SHIFT_RIGHT_LOGICAL:
            value1 = (LONG64)((ULONG64)value1 >> value2);
            break;
        case SHIFT_RIGHT_ARITHMETIC:
            value1 >>= value2;
            break;
        default:
            error(SYNTAX);
        }
    }
    return value1;
}

/*** GetShiftTerm - get logical term
*
*   Purpose:
*       Parse additive-terms separated by additive operators into
*       shift term value.
*
*   Input:
*       g_CurCmd - present command line position
*
*   Returns:
*       long value of sum.
*
*   Exceptions:
*       error exit: SYNTAX - bad shift term or premature end-of-line
*
*   Notes:
*       may be called recursively.
*       <sterm> = <aterm> [<add-op> <aterm>]*
*       <add-op> = +, -
*
*************************************************************************/

LONG64
GetShiftTerm (
    void
    )
{
    LONG64    value1 = GetAterm();
    LONG64    value2;
    ULONG     opclass;
    LONG64    opvalue;
    BOOL      faddr = (BOOL) (g_AddrExprType != ADDR_NONE);

//dprintf("LONG64 GetShifTerm ()\n");
    while ((opclass = PeekToken(&opvalue)) == ADDOP_CLASS) {
        AcceptToken();
        value2 = GetAterm();
        if (!faddr && g_AddrExprType) {
            LONG64 tmp = value1;
            value1 = value2;
            value2 = tmp;
        }
        if (g_AddrExprType & ~INSTR_POINTER)
        {
            switch (opvalue) {
                case ADDOP_PLUS:
                    AddrAdd(&g_TempAddr,value2);
                    value1 += value2;
                    break;
                case ADDOP_MINUS:
                    AddrSub(&g_TempAddr,value2);
                    value1 -= value2;
                    break;
                default:
                    error(SYNTAX);
            }
        } else {
            switch (opvalue) {
                case ADDOP_PLUS:
                    value1 += value2;
                    break;
                case ADDOP_MINUS:
                    value1 -= value2;
                    break;
                default:
                    error(SYNTAX);
            }
        }
    }
    return value1;
}

/*** GetAterm - get additive term
*
*   Purpose:
*       Parse multiplicative-terms separated by multipicative operators
*       into additive term value.
*
*   Input:
*       g_CurCmd - present command line position
*
*   Returns:
*       long value of product.
*
*   Exceptions:
*       error exit: SYNTAX - bad additive term or premature end-of-line
*
*   Notes:
*       may be called recursively.
*       <aterm> = <mterm> [<mult-op> <mterm>]*
*       <mult-op> = *, /, MOD (%)
*
*************************************************************************/

LONG64
GetAterm (
    void
    )
{
    LONG64    value1;
    LONG64    value2;
    ULONG     opclass;
    LONG64    opvalue;

//dprintf("LONG64 GetAterm ()\n");
    value1 = GetMterm();
    while ((opclass = PeekToken(&opvalue)) == MULOP_CLASS)
    {
        AcceptToken();
        value2 = GetMterm();
        switch (opvalue)
        {
        case MULOP_MULT:
            value1 *= value2;
            break;
        case MULOP_DIVIDE:
            if (value2 == 0)
            {
                error(OPERAND);
            }
            value1 /= value2;
            break;
        case MULOP_MOD:
            if (value2 == 0)
            {
                error(OPERAND);
            }
            value1 %= value2;
            break;
        case MULOP_SEG:
            PDESCRIPTOR64 pdesc;
            DESCRIPTOR64 desc;

            pdesc = NULL;
            if (g_AddrExprType != ADDR_NONE)
            {
                Type(g_TempAddr) = g_AddrExprType;
            }
            else
            {
                // We don't know what kind of address this is
                // Let's try to figure it out.
                if (g_X86InVm86)
                {
                    g_AddrExprType = Type(g_TempAddr) = ADDR_V86;
                }
                else if (g_Target->GetSelDescriptor
                         (g_Machine, g_CurrentProcess->CurrentThread->Handle,
                          (ULONG)value1, &desc) != S_OK)
                {
                    error(BADSEG);
                }
                else
                {
                    g_AddrExprType = Type(g_TempAddr) =
                        (desc.Flags & X86_DESC_DEFAULT_BIG) ?
                        ADDR_1632 : ADDR_16;
                    pdesc = &desc;
                }
            }

            g_TempAddr.seg  = (USHORT)value1;
            g_TempAddr.off  = value2;
            ComputeFlatAddress(&g_TempAddr, pdesc);
            value1 = value2;
            break;

        default:
            error(SYNTAX);
        }
    }

    return value1;
}

/*** GetMterm - get multiplicative term
*
*   Purpose:
*       Parse basic-terms optionally prefaced by one or more
*       unary operators into a multiplicative term.
*
*   Input:
*       g_CurCmd - present command line position
*
*   Returns:
*       long value of multiplicative term.
*
*   Exceptions:
*       error exit: SYNTAX - bad multiplicative term or premature end-of-line
*
*   Notes:
*       may be called recursively.
*       <mterm> = [<unary-op>] <term> | <unary-op> <mterm>
*       <unary-op> = <add-op>, ~ (NOT), BY, WO, DW, HI, LOW
*
*************************************************************************/

LONG64
GetMterm (
    void
    )
{
    LONG64  value;
    ULONG   opclass;
    LONG64  opvalue;
    ULONG   size = 0;

//dprintf("LONG64 GetMterm ()\n");
    if ((opclass = PeekToken(&opvalue)) == UNOP_CLASS ||
                                opclass == ADDOP_CLASS)
    {
        AcceptToken();
        if (opvalue == UNOP_VAL) 
        {
            // Do not use default expression handler for type expressions.
            value = GetTypedExpression();
        }
        else
        {
            value = GetMterm();
        }
        switch (opvalue)
        {
        case UNOP_NOT:
            value = !value;
            break;
        case UNOP_BY:
            size = 1;
            break;
        case UNOP_WO:
            size = 2;
            break;
        case UNOP_DWO:
            size = 4;
            break;
        case UNOP_POI:
            size = 0xFFFF;
            break;
        case UNOP_QWO:
            size = 8;
            break;
        case UNOP_LOW:
            value &= 0xffff;
            break;
        case UNOP_HI:
            value = (ULONG)value >> 16;
            break;
        case ADDOP_PLUS:
            break;
        case ADDOP_MINUS:
            value = -value;
            break;
        case UNOP_VAL:
            break;
        default:
            error(SYNTAX);
        }

        if (size)
        {
            ADDR CurAddr;
            
            NotFlat(CurAddr);

            ForceAddrExpression(SEGREG_COUNT, &CurAddr, value);

            value = 0;

            //
            // For pointers, call read pointer so we read the correct size
            // and sign extend.
            //

            if (size == 0xFFFF)
            {
                if (g_Target->ReadPointer(g_Machine,
                                          Flat(CurAddr),
                                          (PULONG64)&value) != S_OK)
                {
                    error(MEMORY);
                }
            }
            else
            {
                if (GetMemString(&CurAddr, &value, size) != size)
                {
                    error(MEMORY);
                }
            }

            // We've looked up an arbitrary value so we can
            // no longer consider this an address expression.
            g_AddrExprType = ADDR_NONE;
        }
    }
    else
    {
        value = GetTerm();
    }
    return value;
}

/*** GetTerm - get basic term
*
*   Purpose:
*       Parse numeric, variable, or register name into a basic
*       term value.
*
*   Input:
*       g_CurCmd - present command line position
*
*   Returns:
*       long value of basic term.
*
*   Exceptions:
*       error exit: SYNTAX - empty basic term or premature end-of-line
*
*   Notes:
*       may be called recursively.
*       <term> = ( <expr> ) | <register-value> | <number> | <variable>
*       <register-value> = @<register-name>
*
*************************************************************************/

LONG64
GetTerm (
    void
    )
{
    LONG64 value;
    ULONG  opclass;
    LONG64 opvalue;

//dprintf("LONG64 GetTerm ()\n");
    opclass = GetTokenSym(&opvalue);
    if (opclass == LPAREN_CLASS)
    {
        value = GetExpr();
        if (GetTokenSym(&opvalue) != RPAREN_CLASS)
        {
            error(SYNTAX);
        }
    }
    else if (opclass == LBRACK_CLASS)
    {
        value = GetExpr();
        if (GetTokenSym(&opvalue) != RBRACK_CLASS)
        {
            error(SYNTAX);
        }
    }
    else if (opclass == REG_CLASS)
    {
        if ((g_EffMachine == IMAGE_FILE_MACHINE_I386 &&
             (opvalue == X86_EIP || opvalue == X86_IP)) ||
            (g_EffMachine == IMAGE_FILE_MACHINE_AMD64 &&
             (opvalue == AMD64_RIP || opvalue == AMD64_EIP ||
              opvalue == AMD64_IP)))
        {
            g_AddrExprType |= INSTR_POINTER;
        }

        PCROSS_PLATFORM_CONTEXT ScopeContext = GetCurrentScopeContext();
	if (ScopeContext)
        {
             g_Machine->PushContext(ScopeContext);
        }
        
        value = GetRegVal64((ULONG)opvalue);
        
	if (ScopeContext)
        {
            g_Machine->PopContext();
        }
    }
    else if (opclass == NUMBER_CLASS ||
             opclass == SYMBOL_CLASS ||
             opclass == LINE_CLASS)
    {
        value = opvalue;
    }
    else
    {
        ReportError(SYNTAX, &g_ExprDesc);
    }

    return value;
}

/*** GetRange - parse address range specification
*
*   Purpose:
*       With the current command line position, parse an
*       address range specification.  Forms accepted are:
*       <start-addr>            - starting address with default length
*       <start-addr> <end-addr> - inclusive address range
*       <start-addr> l<count>   - starting address with item count
*
*   Input:
*       g_CurCmd - present command line location
*       size - nonzero - (for data) size in bytes of items to list
*                        specification will be "length" type with
*                        *fLength forced to TRUE.
*              zero - (for instructions) specification either "length"
*                     or "range" type, no size assumption made.
*
*   Output:
*       *addr - starting address of range
*       *value - if *fLength = TRUE, count of items (forced if size != 0)
*                              FALSE, ending address of range
*       (*addr and *value unchanged if no second argument in command)
*
*   Returns:
*       A value of TRUE is returned if no length is specified, or a length
*       or an ending address is specified and size is not zero. Otherwise,
*       a value of FALSE is returned.
*
*   Exceptions:
*       error exit:
*               SYNTAX - expression error
*               BADRANGE - if ending address before starting address
*
*************************************************************************/

BOOL
GetRange (
    PADDR addr,
    PULONG64 value,
    ULONG size,
    ULONG SegReg
    )
{
    CHAR ch;
    PSTR psz;
    ADDR EndRange;
    BOOL fL = FALSE;
    BOOL fLength;
    BOOL fSpace = FALSE;

    PeekChar();          //  skip leading whitespace first

    //  Pre-parse the line, look for a " L"

    for (psz = g_CurCmd; *psz; psz++)
    {
        if ((*psz == 'L' || *psz == 'l') && fSpace)
        {
            fL = TRUE;
            *psz = '\0';
            break;
        }
        else if (*psz == ';')
        {
            break;
        }

        fSpace = (BOOL)(*psz == ' ');
    }

    fLength = TRUE;
    if ((ch = PeekChar()) != '\0' && ch != ';')
    {
        GetAddrExpression(SegReg, addr);
        if (((ch = PeekChar()) != '\0' && ch != ';') || fL)
        {
            if (!fL)
            {
                GetAddrExpression(SegReg, &EndRange);
                if (AddrGt(*addr, EndRange))
                {
                    error(BADRANGE);
                }

                if (size)
                {
                    *value = AddrDiff(EndRange, *addr) / size + 1;
                }
                else
                {
                    *value = Flat(EndRange);
                    fLength = FALSE;
                }
            }
            else
            {
                g_CurCmd = psz + 1;
                *value = GetExprDesc("Length of range missing from");
                *psz = 'l';

                // If the length is huge assume the user made
                // some kind of mistake.
                if (*value > 1000000)
                {
                    error(BADRANGE);
                }
            }
        }
    }

    return fLength;
}

/*** PeekChar - peek the next non-white-space character
*
*   Purpose:
*       Return the next non-white-space character and update
*       g_CurCmd to point to it.
*
*   Input:
*       g_CurCmd - present command line position.
*
*   Returns:
*       next non-white-space character
*
*************************************************************************/

CHAR
PeekChar (
    void
    )
{
    CHAR    ch;

    do
    {
        ch = *g_CurCmd++;
    } while (ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n');
    
    g_CurCmd--;
    return ch;
}

/*** PeekToken - peek the next command line token
*
*   Purpose:
*       Return the next command line token, but do not advance
*       the g_CurCmd pointer.
*
*   Input:
*       g_CurCmd - present command line position.
*
*   Output:
*       *pvalue - optional value of token
*   Returns:
*       class of token
*
*   Notes:
*       g_SavedClass, g_SavedValue, and g_SavedCommand saves the token getting
*       state for future peeks.  To get the next token, a GetToken or
*       AcceptToken call must first be made.
*
*************************************************************************/

ULONG
PeekToken (
    PLONG64 pvalue
    )
{
    PSTR Temp;

//dprintf("ULONG PeekToken (PLONG64 pvalue)\n");
    //  Get next class and value, but do not
    //  move g_CurCmd, but save it in g_SavedCommand.
    //  Do not report any error condition.

    if (g_SavedClass == INVALID_CLASS)
    {
        Temp = g_CurCmd;
        g_SavedClass = NextToken(&g_SavedValue);
        g_SavedCommand = g_CurCmd;
        g_CurCmd = Temp;
        if (g_SavedClass == ADDOP_CLASS && g_SavedValue == ADDOP_PLUS)
        {
            g_ForcePositiveNumber = TRUE;
        }
        else
        {
            g_ForcePositiveNumber = FALSE;
        }
    }
    *pvalue = g_SavedValue;
    return g_SavedClass;
}

/*** AcceptToken - accept any peeked token
*
*   Purpose:
*       To reset the PeekToken saved variables so the next PeekToken
*       will get the next token in the command line.
*
*   Input:
*       None.
*
*   Output:
*       None.
*
*************************************************************************/

void
AcceptToken (
    void
    )
{
//dprintf("void AcceptToken (void)\n");
    g_SavedClass = INVALID_CLASS;
    g_CurCmd = g_SavedCommand;
}

/*** GetToken - peek and accept the next token
*
*   Purpose:
*       Combines the functionality of PeekToken and AcceptToken
*       to return the class and optional value of the next token
*       as well as updating the command pointer g_CurCmd.
*
*   Input:
*       g_CurCmd - present command string pointer
*
*   Output:
*       *pvalue - pointer to the token value optionally set.
*   Returns:
*       class of the token read.
*
*   Notes:
*       An illegal token returns the value of ERROR_CLASS with *pvalue
*       being the error number, but produces no actual error.
*
*************************************************************************/

ULONG
GetTokenSym (
    PLONG64 pvalue
    )
{
    ULONG   opclass;

//dprintf("ULONG GetTokenSym (PLONG pvalue)\n");
    if (g_SavedClass != INVALID_CLASS)
    {
        opclass = g_SavedClass;
        g_SavedClass = INVALID_CLASS;
        *pvalue = g_SavedValue;
        g_CurCmd = g_SavedCommand;
    }
    else
    {
        opclass = NextToken(pvalue);
    }

    if (opclass == ERROR_CLASS)
    {
        error((ULONG)*pvalue);
    }

    return opclass;
}

struct DISPLAY_AMBIGUOUS_SYMBOLS
{
    PSTR Module;
    MachineInfo* Machine;
};

BOOL CALLBACK
DisplayAmbiguousSymbols(
    PSYMBOL_INFO    SymInfo,
    ULONG           Size,
    PVOID           UserContext
    )
{
    DISPLAY_AMBIGUOUS_SYMBOLS* Context =
        (DISPLAY_AMBIGUOUS_SYMBOLS*)UserContext;

    if (IgnoreEnumeratedSymbol(Context->Machine, SymInfo))
    {
        return TRUE;
    }
        
    dprintf("Matched: %s %s!%s",
            FormatAddr64(SymInfo->Address), Context->Module, SymInfo->Name);
    ShowSymbolInfo(SymInfo);
    dprintf("\n");
    
    return TRUE;
}

ULONG
EvalSymbol(PSTR Name, PULONG64 Value)
{
    if (g_CurrentProcess == NULL)
    {
        return INVALID_CLASS;
    }

    if (g_TypedExpr)
    {
        if (GetSymValue(Name, Value))
        {
            return SYMBOL_CLASS;
        }
        else
        {
            return INVALID_CLASS;
        }
    }

    ULONG Count;
    PDEBUG_IMAGE_INFO Image;
    
    if (!(Count = GetOffsetFromSym(Name, Value, &Image)))
    {
        // If a valid module name was given we can assume
        // the user really intended this as a symbol reference
        // and return a not-found error rather than letting
        // the text be checked for other kinds of matches.
        if (Image != NULL)
        {
            *Value = VARDEF;
            return ERROR_CLASS;
        }
        else
        {
            return INVALID_CLASS;
        }
    }
    
    if (Count == 1)
    {
        // Found an unambiguous match.
        Type(g_TempAddr) = ADDR_FLAT | FLAT_COMPUTED;
        Flat(g_TempAddr) = Off(g_TempAddr) = *Value;
        g_AddrExprType = Type(g_TempAddr);
        return SYMBOL_CLASS;
    }
            
    //
    // Multiple matches were found so the name is ambiguous.
    // Enumerate the instances and display them.
    //

    Image = GetImageByOffset(g_CurrentProcess, *Value);
    if (Image != NULL)
    {
        DISPLAY_AMBIGUOUS_SYMBOLS Context;
        char FoundSymbol[MAX_SYMBOL_LEN];
        ULONG64 Disp;

        // The symbol found may not have exactly the name
        // passed in due to prefixing or other modifications.
        // Look up the actual name found.
        GetSymbolStdCall(*Value, FoundSymbol, sizeof(FoundSymbol),
                         &Disp, NULL);

        Context.Module = Image->ModuleName;
        Context.Machine =
            MachineTypeInfo(ModuleMachineType(g_CurrentProcess,
                                              Image->BaseOfImage));
        if (Context.Machine == NULL)
        {
            Context.Machine = g_Machine;
        }
        SymEnumSymbols(g_CurrentProcess->Handle, Image->BaseOfImage,
                       FoundSymbol, DisplayAmbiguousSymbols, &Context);
    }
    
    *Value = AMBIGUOUS;
    return ERROR_CLASS;
}

/*** NextToken - process the next token
*
*   Purpose:
*       Parse the next token from the present command string.
*       After skipping any leading white space, first check for
*       any single character tokens or register variables.  If
*       no match, then parse for a number or variable.  If a
*       possible variable, check the reserved word list for operators.
*
*   Input:
*       g_CurCmd - pointer to present command string
*
*   Output:
*       *pvalue - optional value of token returned
*       g_CurCmd - updated to point past processed token
*   Returns:
*       class of token returned
*
*   Notes:
*       An illegal token returns the value of ERROR_CLASS with *pvalue
*       being the error number, but produces no actual error.
*
*************************************************************************/

ULONG
NextToken (
    PLONG64 pvalue
    )
{
    ULONG               base = g_DefaultRadix;
    BOOL                allowSignExtension;
    CHAR                chSymbol[MAX_SYMBOL_LEN];
    CHAR                chSymbolString[MAX_SYMBOL_LEN];
    CHAR                chPreSym[9];
    ULONG               cbSymbol = 0;
    BOOL                fNumber = TRUE;
    BOOL                fSymbol = TRUE;
    BOOL                fForceReg = FALSE;
    BOOL                fForceSym = FALSE;
    ULONG               errNumber = 0;
    CHAR                ch;
    CHAR                chlow;
    CHAR                chtemp;
    CHAR                limit1 = '9';
    CHAR                limit2 = '9';
    BOOL                fDigit = FALSE;
    ULONG64             value = 0;
    ULONG64             tmpvalue;
    ULONG               index;
    PDEBUG_IMAGE_INFO   pImage;
    PSTR                CmdSave;
    IMAGEHLP_MODULE64   mi;
    BOOL                UseDeferred;
    BOOL                WasDigit;
    ULONG               off32;
    ULONG               SymClass;

    // do sign extension for kernel only
    allowSignExtension = IS_KERNEL_TARGET();

    PeekChar();
    ch = *g_CurCmd++;

    chlow = (CHAR)tolower(ch);

    // Check to see if we're at a symbol prefix followed by
    // a symbol character.  Symbol prefixes often contain
    // characters meaningful in other ways in expressions so
    // this check must be performed before the specific expression
    // character checks below.
    if (g_Machine != NULL &&
        g_Machine->m_SymPrefix != NULL &&
        chlow == g_Machine->m_SymPrefix[0] &&
        (g_Machine->m_SymPrefixLen == 1 ||
         !strncmp(g_CurCmd, g_Machine->m_SymPrefix + 1,
                 g_Machine->m_SymPrefixLen - 1)))
    {
        CHAR ChNext = *(g_CurCmd + g_Machine->m_SymPrefixLen - 1);
        CHAR ChNextLow = (CHAR)tolower(ChNext);

        if (ChNextLow == '_' ||
            (ChNextLow >= 'a' && ChNextLow <= 'z'))
        {
            // A symbol character followed the prefix so assume it's
            // a symbol.
            cbSymbol = g_Machine->m_SymPrefixLen;
            DBG_ASSERT(cbSymbol <= sizeof(chPreSym));

            g_CurCmd--;
            memcpy(chPreSym, g_CurCmd, g_Machine->m_SymPrefixLen);
            memcpy(chSymbol, g_CurCmd, g_Machine->m_SymPrefixLen);
            g_CurCmd += g_Machine->m_SymPrefixLen + 1;
            ch = ChNext;
            chlow = ChNextLow;

            fForceSym = TRUE;
            fForceReg = FALSE;
            fNumber = FALSE;
            goto ProbableSymbol;
        }
    }
    
    //  test for special character operators and register variable

    switch (chlow)
    {
    case '\0':
    case ';':
        g_CurCmd--;
        return EOL_CLASS;
    case '+':
        *pvalue = ADDOP_PLUS;
        return ADDOP_CLASS;
    case '-':
        *pvalue = ADDOP_MINUS;
        return ADDOP_CLASS;
    case '*':
        *pvalue = MULOP_MULT;
        return MULOP_CLASS;
    case '/':
        *pvalue = MULOP_DIVIDE;
        return MULOP_CLASS;
    case '%':
        *pvalue = MULOP_MOD;
        return MULOP_CLASS;
    case '&':
        *pvalue = LOGOP_AND;
        return LOGOP_CLASS;
    case '|':
        *pvalue = LOGOP_OR;
        return LOGOP_CLASS;
    case '^':
        *pvalue = LOGOP_XOR;
        return LOGOP_CLASS;
    case '=':
        if (*g_CurCmd == '=')
        {
            g_CurCmd++;
        }
        *pvalue = LRELOP_EQ;
        return LRELOP_CLASS;
    case '>':
        if (*g_CurCmd == '>')
        {
            g_CurCmd++;
            if (*g_CurCmd == '>')
            {
                g_CurCmd++;
                *pvalue = SHIFT_RIGHT_ARITHMETIC;
            }
            else
            {
                *pvalue = SHIFT_RIGHT_LOGICAL;
            }
            return SHIFT_CLASS;
        }
        *pvalue = LRELOP_GT;
        return LRELOP_CLASS;
    case '<':
        if (*g_CurCmd == '<')
        {
            g_CurCmd++;
            *pvalue = SHIFT_LEFT;
            return SHIFT_CLASS;
        }
        *pvalue = LRELOP_LT;
        return LRELOP_CLASS;
    case '!':
        if (*g_CurCmd != '=')
        {
            break;
        }
        g_CurCmd++;
        *pvalue = LRELOP_NE;
        return LRELOP_CLASS;
    case '~':
        *pvalue = UNOP_NOT;
        return UNOP_CLASS;
    case '(':
        return LPAREN_CLASS;
    case ')':
        return RPAREN_CLASS;
    case '[':
        return LBRACK_CLASS;
    case ']':
        return RBRACK_CLASS;
    case '.':
        g_Machine->GetPC(&g_TempAddr);
        *pvalue = Flat(g_TempAddr);
        g_AddrExprType = Type(g_TempAddr);
        return NUMBER_CLASS;
    case ':':
        *pvalue = MULOP_SEG;
        return MULOP_CLASS;
    }
    
    // Look for source line expressions.  Because source file names
    // can contain a lot of expression characters which are meaningful
    // to the lexer the whole expression is enclosed in ` characters.
    // This makes them easy to identify and scan.

    if (chlow == '`')
    {
        ULONG FoundLine;

        // Scan forward for closing `

        CmdSave = g_CurCmd;

        while (*g_CurCmd != '`' && *g_CurCmd != ';' && *g_CurCmd != 0)
        {
            g_CurCmd++;
        }

        if (*g_CurCmd == ';' || *g_CurCmd == 0)
        {
            *pvalue = SYNTAX;
            return ERROR_CLASS;
        }

        *g_CurCmd = 0;

        FoundLine = GetOffsetFromLine(CmdSave, &value);

        *g_CurCmd++ = '`';

        if (FoundLine == LINE_NOT_FOUND && g_AllowUnresolvedSymbols)
        {
            g_NumUnresolvedSymbols++;
            FoundLine = LINE_FOUND;
            value = 0;
        }
        
        if (FoundLine == LINE_FOUND)
        {
            *pvalue = value;
            Type(g_TempAddr) = ADDR_FLAT | FLAT_COMPUTED;
            Flat(g_TempAddr) = Off(g_TempAddr) = value;
            g_AddrExprType = Type(g_TempAddr);
            return LINE_CLASS;
        }
        else
        {
            *pvalue = NOTFOUND;
            return ERROR_CLASS;
        }
    }

    //  special prefixes - '@' for register - '!' for symbol

    if (chlow == '@' || chlow == '!')
    {
        fForceReg = (BOOL)(chlow == '@');
        fForceSym = (BOOL)!fForceReg;
        fNumber = FALSE;
        ch = *g_CurCmd++;
        chlow = (CHAR)tolower(ch);
    }

    //  if string is followed by '!', but not '!=',
    //      then it is a module name and treat as text

    CmdSave = g_CurCmd;

    WasDigit = FALSE;
    while ((chlow >= 'a' && chlow <= 'z') ||
           (chlow >= '0' && chlow <= '9') ||
           (WasDigit && chlow == '`') ||
           (chlow == '_') || (chlow == '$') || (chlow == '~'))
    {
        WasDigit = (chlow >= '0' && chlow <= '9') ||
            (chlow >= 'a' && chlow <= 'f');
        chlow = (CHAR)tolower(*g_CurCmd);
        g_CurCmd++;
    }

    //  treat as symbol if a nonnull string is followed by '!',
    //      but not '!='

    if (chlow == '!' && *g_CurCmd != '=' && CmdSave != g_CurCmd)
    {
        fNumber = FALSE;
    }

    g_CurCmd = CmdSave;
    chlow = (CHAR)tolower(ch);       //  ch was NOT modified

    if (fNumber)
    {
        if (chlow == '\'')
        {
            *pvalue = 0;
            while (TRUE)
            {
                ch = *g_CurCmd++;

                if (!ch)
                {
                    *pvalue = SYNTAX;
                    return ERROR_CLASS;
                }

                if (ch == '\'')
                {
                    if (*g_CurCmd != '\'')
                    {
                        break;
                    }
                    ch = *g_CurCmd++;
                }
                else if (ch == '\\')
                {
                    ch = *g_CurCmd++;
                }

                *pvalue = (*pvalue << 8) | ch;
            }

            return NUMBER_CLASS;
        }

        //  if first character is a decimal digit, it cannot
        //  be a symbol.  leading '0' implies octal, except
        //  a leading '0x' implies hexadecimal.

        if (chlow >= '0' && chlow <= '9')
        {
            if (fForceReg)
            {
                *pvalue = SYNTAX;
                return ERROR_CLASS;
            }
            fSymbol = FALSE;
            if (chlow == '0')
            {
                //
                // too many people type in leading 0x so we can't use it to
                // deal with sign extension.
                //
                ch = *g_CurCmd++;
                chlow = (CHAR)tolower(ch);
                if (chlow == 'n')
                {
                    base = 10;
                    ch = *g_CurCmd++;
                    chlow = (CHAR)tolower(ch);
                    fDigit = TRUE;
                }
                else if (chlow == 't')
                {
                    base = 8;
                    ch = *g_CurCmd++;
                    chlow = (CHAR)tolower(ch);
                    fDigit = TRUE;
                }
                else if (chlow == 'x')
                {
                    base = 16;
                    ch = *g_CurCmd++;
                    chlow = (CHAR)tolower(ch);
                    fDigit = TRUE;
                }
                else if (chlow == 'y')
                {
                    base = 2;
                    ch = *g_CurCmd++;
                    chlow = (CHAR)tolower(ch);
                    fDigit = TRUE;
                }
                else
                {
                    // Leading zero is used only to imply a positive value
                    // that shouldn't get sign extended.
                    fDigit = TRUE;
                }
            }
        }

        //  a number can start with a letter only if base is
        //  hexadecimal and it is a hexadecimal digit 'a'-'f'.

        else if ((chlow < 'a' || chlow > 'f') || base != 16)
        {
            fNumber = FALSE;
        }

        //  set limit characters for the appropriate base.

        if (base == 2)
        {
            limit1 = '1';
        }
        else if (base == 8)
        {
            limit1 = '7';
        }
        else if (base == 16)
        {
            limit2 = 'f';
        }
    }

 ProbableSymbol:
    
    //  perform processing while character is a letter,
    //  digit, underscore, tilde or dollar-sign.

    while ((chlow >= 'a' && chlow <= 'z') ||
           (chlow >= '0' && chlow <= '9') ||
           (fDigit && base == 16 && chlow == '`') ||
           (chlow == '_') || (chlow == '$') || (chlow == '~'))
    {
        //  if possible number, test if within proper range,
        //  and if so, accumulate sum.

        if (fNumber)
        {
            if ((chlow >= '0' && chlow <= limit1) ||
                (chlow >= 'a' && chlow <= limit2))
            {
                fDigit = TRUE;
                tmpvalue = value * base;
                if (tmpvalue < value)
                {
                    errNumber = OVERFLOW;
                }
                chtemp = (CHAR)(chlow - '0');
                if (chtemp > 9)
                {
                    chtemp -= 'a' - '0' - 10;
                }
                value = tmpvalue + (ULONG64)chtemp;
                if (value < tmpvalue)
                {
                    errNumber = OVERFLOW;
                }
            }
            else if (fDigit && chlow == '`')
            {
                //
                // if ` character is seen, disallow sign extension
                //
                allowSignExtension = FALSE;
            }
            else
            {
                fNumber = FALSE;
                errNumber = SYNTAX;
            }
        }
        if (fSymbol)
        {
            if (cbSymbol < sizeof(chPreSym))
            {
                chPreSym[cbSymbol] = chlow;
            }
            if (cbSymbol < MAX_SYMBOL_LEN - 1)
            {
                chSymbol[cbSymbol++] = ch;
            }
        }
        ch = *g_CurCmd++;
        
        if (g_TypedExpr)
        {
            if (ch == '.')
            {
                chSymbol[cbSymbol++] = ch;
                ch = *g_CurCmd++;
            }
            else if (ch == '-' && *g_CurCmd == '>')
            {
                chSymbol[cbSymbol++] = ch;
                ch = *g_CurCmd++;
                chSymbol[cbSymbol++] = ch;
                ch = *g_CurCmd++;
            }
        }
        chlow = (CHAR)tolower(ch);
    }

    //  back up pointer to first character after token.

    g_CurCmd--;

    if (cbSymbol < sizeof(chPreSym))
    {
        chPreSym[cbSymbol] = '\0';
    }

    if (g_EffMachine == IMAGE_FILE_MACHINE_I386 ||
        g_EffMachine == IMAGE_FILE_MACHINE_AMD64)
    {
        //
        //  catch segment overrides here
        //

        if (!fForceReg && ch == ':')
        {
            for (index = 0; index < X86_SEGREGSIZE; index++)
            {
                if (!strncmp(chPreSym, g_X86SegRegs[index], 2))
                {
                    fForceReg = TRUE;
                    fSymbol = FALSE;
                    break;
                }
            }
        }
    }

    //  if fForceReg, check for register name and return
    //      success or failure

    if (fForceReg)
    {
        return GetRegToken(chPreSym, (PULONG64)pvalue);
    }

    //  test if number

    if (fNumber && !errNumber && fDigit)
    {
        if (allowSignExtension && !g_ForcePositiveNumber && 
            ((value >> 32) == 0)) 
        {
            *pvalue = (LONG)value;
        } 
        else 
        {
            *pvalue = value;
        }
        return NUMBER_CLASS;
    }

    //  next test for reserved word and symbol string

    if (fSymbol && !fForceReg)
    {
        //  check lowercase string in chPreSym for text operator
        //  or register name.
        //  otherwise, return symbol value from name in chSymbol.

        if (!fForceSym && (cbSymbol == 2 || cbSymbol == 3))
        {
            for (index = 0; index < RESERVESIZE; index++)
            {
                if (!strncmp(chPreSym, g_Reserved[index].chRes, 3))
                {
                    *pvalue = g_Reserved[index].valueRes;
                    return g_Reserved[index].classRes;
                }
            }
            if (g_EffMachine == IMAGE_FILE_MACHINE_I386 ||
                g_EffMachine == IMAGE_FILE_MACHINE_AMD64)
            {
                for (index = 0; index < X86_RESERVESIZE; index++)
                {
                    if (!strncmp(chPreSym,
                                 g_X86Reserved[index].chRes, 3))
                    {
                        *pvalue = g_X86Reserved[index].valueRes;
                        return g_X86Reserved[index].classRes;
                    }
                }
            }
        }

        //  start processing string as symbol

        chSymbol[cbSymbol] = '\0';

        //  test if symbol is a module name (followed by '!')
        //  if so, get next token and treat as symbol

        if (PeekChar() == '!')
        {
            // chSymbolString holds the name of the symbol to be searched.
            // chSymbol holds the symbol image file name.

            g_CurCmd++;
            ch = PeekChar();
            g_CurCmd++;

            // Scan prefix if one is present.
            if (g_Machine != NULL &&
                g_Machine->m_SymPrefix != NULL &&
                ch == g_Machine->m_SymPrefix[0] &&
                (g_Machine->m_SymPrefixLen == 1 ||
                 !strncmp(g_CurCmd, g_Machine->m_SymPrefix + 1,
                          g_Machine->m_SymPrefixLen - 1)))
            {
                cbSymbol = g_Machine->m_SymPrefixLen;
                memcpy(chSymbolString, g_CurCmd - 1,
                       g_Machine->m_SymPrefixLen);
                g_CurCmd += g_Machine->m_SymPrefixLen - 1;
                ch = *g_CurCmd++;
            }
            else
            {
                cbSymbol = 0;
            }
            
            while ((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') ||
                   (ch >= '0' && ch <= '9') || (ch == '_') || (ch == '$'))
            {
                chSymbolString[cbSymbol++] = ch;
                ch = *g_CurCmd++;
                if (g_TypedExpr)
                {
                    if (ch == '.')
                    {
                        chSymbolString[cbSymbol++] = ch;
                        ch = *g_CurCmd++;
                    }
                    else if (ch == '-' && *g_CurCmd == '>')
                    {
                        chSymbolString[cbSymbol++] = ch;
                        ch = *g_CurCmd++;
                        chSymbolString[cbSymbol++] = ch;
                        ch = *g_CurCmd++;
                    }
                }
            }
            chSymbolString[cbSymbol] = '\0';
            g_CurCmd--;

            if (cbSymbol == 0)
            {
                *pvalue = SYNTAX;
                return ERROR_CLASS;
            }

            strcat( chSymbol, "!" );
            strcat( chSymbol, chSymbolString );

            SymClass = EvalSymbol(chSymbol, &value);
            if (SymClass != INVALID_CLASS)
            {
                *pvalue = value;
                return SymClass;
            }
        }
        else
        {
            if (cbSymbol == 0)
            {
                *pvalue = SYNTAX;
                return ERROR_CLASS;
            }

            SymClass = EvalSymbol(chSymbol, &value);
            if (SymClass != INVALID_CLASS)
            {
                *pvalue = value;
                return SymClass;
            }

            //
            // Quick test for register names too
            //
            if (!fForceSym &&
                (tmpvalue = GetRegToken(chPreSym,
                                        (PULONG64)pvalue)) != ERROR_CLASS)
            {
                return (ULONG)tmpvalue;
            }
        }

        //
        //  symbol is undefined.
        //  if a possible hex number, do not set the error type
        //
        if (!fNumber)
        {
            errNumber = VARDEF;
        }
    }

    //
    //  last chance, undefined symbol and illegal number,
    //      so test for register, will handle old format
    //
    if (!fForceSym &&
        (tmpvalue = GetRegToken(chPreSym,
                                (PULONG64)pvalue)) != ERROR_CLASS)
    {
        return (ULONG)tmpvalue;
    }

    if (g_AllowUnresolvedSymbols)
    {
        g_NumUnresolvedSymbols++;
        *pvalue = 0;
        Type(g_TempAddr) = ADDR_FLAT | FLAT_COMPUTED;
        Flat(g_TempAddr) = Off(g_TempAddr) = *pvalue;
        g_AddrExprType = Type(g_TempAddr);
        return SYMBOL_CLASS;
    }

    //
    //  no success, so set error message and return
    //
    *pvalue = (ULONG64)errNumber;
    return ERROR_CLASS;
}


LONG64
EvaluateSourceExpression(
    PCHAR pExpr
    )
{
    BOOL sav = g_TypedExpr;
    PSTR savPch = g_CurCmd;
    g_TypedExpr = TRUE;
    g_CurCmd = pExpr;
    ULONG64 res;
    __try
    {
	res = GetExpression();
    }
    __except(CommandExceptionFilter(GetExceptionInformation()))
    {
	res = 0;
    }
    g_CurCmd = savPch;
    g_TypedExpr = sav;
    return res;
}

/*
      Inputs
       g_CurCmd - points to start of typed expression
    
       Must be ([*|&] Sym[(.->)Field])
         
      Outputs
       Evaluates typed expression and returns value
      
*/

LONG64
GetTypedExpression(
    void
    )
{
    ULONG64 Value=0;
    BOOL    AddrOf=FALSE, ValueAt=FALSE;
    CHAR    c;
    static CHAR    Name[MAX_NAME], Field[MAX_NAME];

    c = PeekChar();

    switch (c)
    { 
    case '(':
        g_CurCmd++;
        Value = GetTypedExpression();
        c = PeekChar();
        if (c != ')') 
        {
            error(SYNTAX);
            return 0;
        }
        ++g_CurCmd;
        return Value;
    case '&':
        // Get Offset/Address
//        AddrOf = TRUE;
//        g_CurCmd++;
//        PeekChar();
        break;
    case '*':
    default:
        break;
    }

#if 0
    ULONG i=0;
    ValueAt = TRUE;
    g_CurCmd++;
    PeekChar();
    break;
    c = PeekChar();
    while ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') ||
           (c >= '0' && c <= '9') || (c == '_') || (c == '$') ||
           (c == '!')) { 
        // Sym Name
        Name[i++] = c;
        c = *++g_CurCmd;
    }
    Name[i]=0;

    if (c=='.') 
    {
        ++g_CurCmd;
    } else if (c=='-' && *++g_CurCmd == '>') 
    {
        ++g_CurCmd;
    }

    i=0;
    c = PeekChar();

    while ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') ||
           (c >= '0' && c <= '9') || (c == '_') || (c == '$') ||
           (c == '.') || (c == '-') || (c == '>')) { 
        Field[i++]= c;
        c = *++g_CurCmd;
    }
    Field[i]=0;

    SYM_DUMP_PARAM Sym = {0};
    FIELD_INFO     FieldInfo ={0};

    Sym.size      = sizeof(SYM_DUMP_PARAM);
    Sym.sName     = (PUCHAR) Name;
    Sym.Options   = DBG_DUMP_NO_PRINT;    

    if (Field[0]) 
    {
        Sym.nFields = 1;
        Sym.Fields  = &FieldInfo;

        FieldInfo.fName = (PUCHAR) Field;

        if (AddrOf) 
        {
            FieldInfo.fOptions |= DBG_DUMP_FIELD_RETURN_ADDRESS;
        }
    } else if (AddrOf)
    {
        PUCHAR pch = g_CurCmd;
        
        g_CurCmd = &Name[0];
        Value = GetMterm();
        g_CurCmd = pch;
        return Value;
    } else
    {
        Sym.Options |= DBG_DUMP_GET_SIZE_ONLY;
    }
    
    ULONG Status=0;
    ULONG Size = SymbolTypeDump(0, NULL, &Sym, &Status);

    if (!Status) 
    {
        if (!Field[0] && (Size <= sizeof (Value)))
        {
            // Call routine again to read value
            Sym.Options |= DBG_DUMP_COPY_TYPE_DATA;
            Sym.Context = (PVOID) &Value;
            if ((SymbolTypeDump(0, NULL, &Sym, &Status) == 8) && (Size == 4))
            {
                Value = (ULONG) Value;
            }
        } else if (Field[0] && (FieldInfo.size <= sizeof(ULONG64)))
        {
            Value = FieldInfo.address;
        } else  // too big
        {
            Value = 0;
        }

    }
#endif

    AddrOf = g_TypedExpr;
    g_TypedExpr = TRUE;
    Value = GetMterm();
    g_TypedExpr = AddrOf;

    return Value;
}

/*
  Evaluate the value in symbol expression Symbol
*/

BOOL
GetSymValue(
    PSTR Symbol,
    PULONG64 pValue
    )
{
    TYPES_INFO_ALL Typ;

    if (GetExpressionTypeInfo(Symbol, &Typ)) {
        if (Typ.Flags) {
            if (Typ.Flags & IMAGEHLP_SYMBOL_INFO_VALUEPRESENT) {
                *pValue = Typ.Value;
                return TRUE;
            }
            
            TranslateAddress(Typ.Flags, Typ.Register, &Typ.Address, &Typ.Value);
            if (Typ.Value && (Typ.Flags & SYMF_REGISTER)) {
                *pValue = Typ.Value;
                return TRUE;
            }
        }
        if (Symbol[0] == '&') {
            *pValue = Typ.Address;
            return TRUE;
        } else if (Typ.Size <= sizeof(*pValue)) {
            ULONG64 Val = 0;
            ULONG cb;
            if (g_Target->ReadVirtual(Typ.Address, &Val, Typ.Size, &cb) == S_OK) {
                *pValue = Val;
                return TRUE;
            }
        }
    }

    *pValue = 0;
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\ntsdp.hpp ===
//----------------------------------------------------------------------------
//
// Global header file.
//
// Copyright (C) Microsoft Corporation, 1999-2001.
//
//----------------------------------------------------------------------------

#ifndef __NTSDP_HPP__
#define __NTSDP_HPP__

#pragma warning( disable : 4101 )

// Always turn GUID definitions on.  This requires a compiler
// with __declspec(selectany) to compile properly.
#define INITGUID

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#define STATUS_CPP_EH_EXCEPTION    0xe06d7363

// In the kernel debugger there is a virtual process representing
// kernel space.  It has an artificial handle and threads
// representing each processor in the machine.
// A similar scheme is used in user dump files where real
// handles don't exist.
#define VIRTUAL_PROCESS_ID 0xf0f0f0f0
#define VIRTUAL_PROCESS_HANDLE ((HANDLE)(ULONG_PTR)VIRTUAL_PROCESS_ID)

// In kernel mode the index is a processor index.  In user
// dumps it's the thread index in the dump.
#define VIRTUAL_THREAD_HANDLE(Index) ((ULONG64)((Index) + 1))
#define VIRTUAL_THREAD_INDEX(Handle) ((ULONG)((Handle) - 1))
#define VIRTUAL_THREAD_ID(Index) ((Index) + 1)

#include <windows.h>

#define _IMAGEHLP64
#include <dbghelp.h>

#include <kdbg1394.h>
#define NOEXTAPI
#include <wdbgexts.h>
#define DEBUG_NO_IMPLEMENTATION
#include <dbgeng.h>
#include <ntdbg.h>

#include "dbgsvc.h"

#include <ntsdexts.h>
#include <vdmdbg.h>
#include <ntiodump.h>

#include <assert.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <crt\io.h>
#include <fcntl.h>
#include <time.h>

#include <alphaops.h>
#include <ia64inst.h>
#include <dbgimage.h>
#include <dbhpriv.h>
#include <cmnutil.hpp>
#include <pparse.hpp>
#include <dllimp.h>

#include <exdi.h>
#include <exdi_x86_64.h>


// Could not go into system header because CRITICAL_SECTION not defined in the
// kernel.

__inline
void
CriticalSection32To64(
    IN PRTL_CRITICAL_SECTION32 Cr32,
    OUT PRTL_CRITICAL_SECTION64 Cr64
    )
{
    COPYSE(Cr64,Cr32,DebugInfo);
    Cr64->LockCount = Cr32->LockCount;
    Cr64->RecursionCount = Cr32->RecursionCount;
    COPYSE(Cr64,Cr32,OwningThread);
    COPYSE(Cr64,Cr32,LockSemaphore);
    COPYSE(Cr64,Cr32,SpinCount);
}


//
// Pointer-size-specific system structures.
//

typedef struct _EXCEPTION_DEBUG_INFO32 {
    EXCEPTION_RECORD32 ExceptionRecord;
    DWORD dwFirstChance;
} EXCEPTION_DEBUG_INFO32, *LPEXCEPTION_DEBUG_INFO32;

typedef struct _CREATE_THREAD_DEBUG_INFO32 {
    ULONG hThread;
    ULONG lpThreadLocalBase;
    ULONG lpStartAddress;
} CREATE_THREAD_DEBUG_INFO32, *LPCREATE_THREAD_DEBUG_INFO32;

typedef struct _CREATE_PROCESS_DEBUG_INFO32 {
    ULONG hFile;
    ULONG hProcess;
    ULONG hThread;
    ULONG lpBaseOfImage;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    ULONG lpThreadLocalBase;
    ULONG lpStartAddress;
    ULONG lpImageName;
    WORD fUnicode;
} CREATE_PROCESS_DEBUG_INFO32, *LPCREATE_PROCESS_DEBUG_INFO32;

typedef struct _EXIT_THREAD_DEBUG_INFO32 {
    DWORD dwExitCode;
} EXIT_THREAD_DEBUG_INFO32, *LPEXIT_THREAD_DEBUG_INFO32;

typedef struct _EXIT_PROCESS_DEBUG_INFO32 {
    DWORD dwExitCode;
} EXIT_PROCESS_DEBUG_INFO32, *LPEXIT_PROCESS_DEBUG_INFO32;

typedef struct _LOAD_DLL_DEBUG_INFO32 {
    ULONG hFile;
    ULONG lpBaseOfDll;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    ULONG lpImageName;
    WORD fUnicode;
} LOAD_DLL_DEBUG_INFO32, *LPLOAD_DLL_DEBUG_INFO32;

typedef struct _UNLOAD_DLL_DEBUG_INFO32 {
    ULONG lpBaseOfDll;
} UNLOAD_DLL_DEBUG_INFO32, *LPUNLOAD_DLL_DEBUG_INFO32;

typedef struct _OUTPUT_DEBUG_STRING_INFO32 {
    ULONG lpDebugStringData;
    WORD fUnicode;
    WORD nDebugStringLength;
} OUTPUT_DEBUG_STRING_INFO32, *LPOUTPUT_DEBUG_STRING_INFO32;

typedef struct _RIP_INFO32 {
    DWORD dwError;
    DWORD dwType;
} RIP_INFO32, *LPRIP_INFO32;

typedef struct _DEBUG_EVENT32 {
    DWORD dwDebugEventCode;
    DWORD dwProcessId;
    DWORD dwThreadId;
    union {
        EXCEPTION_DEBUG_INFO32 Exception;
        CREATE_THREAD_DEBUG_INFO32 CreateThread;
        CREATE_PROCESS_DEBUG_INFO32 CreateProcessInfo;
        EXIT_THREAD_DEBUG_INFO32 ExitThread;
        EXIT_PROCESS_DEBUG_INFO32 ExitProcess;
        LOAD_DLL_DEBUG_INFO32 LoadDll;
        UNLOAD_DLL_DEBUG_INFO32 UnloadDll;
        OUTPUT_DEBUG_STRING_INFO32 DebugString;
        RIP_INFO32 RipInfo;
    } u;
} DEBUG_EVENT32, *LPDEBUG_EVENT32;

typedef struct _EXCEPTION_DEBUG_INFO64 {
    EXCEPTION_RECORD64 ExceptionRecord;
    DWORD dwFirstChance;
} EXCEPTION_DEBUG_INFO64, *LPEXCEPTION_DEBUG_INFO64;

typedef struct _CREATE_THREAD_DEBUG_INFO64 {
    ULONG64 hThread;
    ULONG64 lpThreadLocalBase;
    ULONG64 lpStartAddress;
} CREATE_THREAD_DEBUG_INFO64, *LPCREATE_THREAD_DEBUG_INFO64;

typedef struct _CREATE_PROCESS_DEBUG_INFO64 {
    ULONG64 hFile;
    ULONG64 hProcess;
    ULONG64 hThread;
    ULONG64 lpBaseOfImage;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    ULONG64 lpThreadLocalBase;
    ULONG64 lpStartAddress;
    ULONG64 lpImageName;
    WORD fUnicode;
} CREATE_PROCESS_DEBUG_INFO64, *LPCREATE_PROCESS_DEBUG_INFO64;

typedef struct _EXIT_THREAD_DEBUG_INFO64 {
    DWORD dwExitCode;
} EXIT_THREAD_DEBUG_INFO64, *LPEXIT_THREAD_DEBUG_INFO64;

typedef struct _EXIT_PROCESS_DEBUG_INFO64 {
    DWORD dwExitCode;
} EXIT_PROCESS_DEBUG_INFO64, *LPEXIT_PROCESS_DEBUG_INFO64;

typedef struct _LOAD_DLL_DEBUG_INFO64 {
    ULONG64 hFile;
    ULONG64 lpBaseOfDll;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    ULONG64 lpImageName;
    WORD fUnicode;
} LOAD_DLL_DEBUG_INFO64, *LPLOAD_DLL_DEBUG_INFO64;

typedef struct _UNLOAD_DLL_DEBUG_INFO64 {
    ULONG64 lpBaseOfDll;
} UNLOAD_DLL_DEBUG_INFO64, *LPUNLOAD_DLL_DEBUG_INFO64;

typedef struct _OUTPUT_DEBUG_STRING_INFO64 {
    ULONG64 lpDebugStringData;
    WORD fUnicode;
    WORD nDebugStringLength;
} OUTPUT_DEBUG_STRING_INFO64, *LPOUTPUT_DEBUG_STRING_INFO64;

typedef struct _RIP_INFO64 {
    DWORD dwError;
    DWORD dwType;
} RIP_INFO64, *LPRIP_INFO64;

typedef struct _DEBUG_EVENT64 {
    DWORD dwDebugEventCode;
    DWORD dwProcessId;
    DWORD dwThreadId;
    DWORD __alignment;
    union {
        EXCEPTION_DEBUG_INFO64 Exception;
        CREATE_THREAD_DEBUG_INFO64 CreateThread;
        CREATE_PROCESS_DEBUG_INFO64 CreateProcessInfo;
        EXIT_THREAD_DEBUG_INFO64 ExitThread;
        EXIT_PROCESS_DEBUG_INFO64 ExitProcess;
        LOAD_DLL_DEBUG_INFO64 LoadDll;
        UNLOAD_DLL_DEBUG_INFO64 UnloadDll;
        OUTPUT_DEBUG_STRING_INFO64 DebugString;
        RIP_INFO64 RipInfo;
    } u;
} DEBUG_EVENT64, *LPDEBUG_EVENT64;


#define STATUS_VCPP_EXCEPTION 0x406d1388
#define VCPP_DEBUG_SET_NAME 0x1000

// This structure is passed as the lpArguments field of
// RaiseException so its members need to be decoded out
// of the exception arguments array.
typedef struct tagEXCEPTION_VISUALCPP_DEBUG_INFO32
{
    DWORD dwType;               // one of the enums from above
    union
    {
        struct
        {
            DWORD szName;       // pointer to name (in user addr space)
            DWORD dwThreadID;   // thread ID (-1=caller thread)
            DWORD dwFlags;      // reserved for future use (eg User thread, System thread)
        } SetName;
    };
} EXCEPTION_VISUALCPP_DEBUG_INFO32;

typedef struct tagEXCEPTION_VISUALCPP_DEBUG_INFO64
{
    DWORD dwType;               // one of the enums from above
    DWORD __alignment;
    union
    {
        struct
        {
            DWORD64 szName;     // pointer to name (in user addr space)
            DWORD dwThreadID;   // thread ID (-1=caller thread)
            DWORD dwFlags;      // reserved for future use (eg User thread, System thread)
        } SetName;
    };
} EXCEPTION_VISUALCPP_DEBUG_INFO64;


//
// Global declarations.
//


#define ARRAYSIZE       20
#define STRLISTSIZE     128

#define MAX_SYMBOL_LEN 4096
// Allow space for a symbol, a code address, an EA and other things in
// a line of disassembly.
#define MAX_DISASM_LEN (MAX_SYMBOL_LEN + 128)

#define MAX_THREAD_NAME 32

// Maximum number of bytes possible for a breakpoint instruction.
// Currently sized to hold an entire IA64 bundle plus flags due to
// extraction and insertion considerations.
#define MAX_BREAKPOINT_LENGTH 20

#define MAX_SOURCE_PATH 1024
#define IS_SLASH(Ch) ((Ch) == '/' || (Ch) == '\\')
#define IS_PATH_DELIM(Ch) (IS_SLASH(Ch) || (Ch) == ':')

// Maximum command string.  DbgPrompt has a limit of 512
// characters so that would be one potential limit.  We
// have users who want to use longer command lines, though,
// such as Autodump which scripts the debugger with very long
// sx commands.  The other obvious limit is MAX_SYMBOL_LEN
// since it makes sense that you should be able to give a
// command with a full symbol name, so use that.
#define MAX_COMMAND MAX_SYMBOL_LEN

// Maximum length of a full path for an image.  Technically
// this can be very large but realistically it's rarely
// greater than MAX_PATH.  Use our own constant instead
// of MAX_PATH in case we need to raise it at some point.
// If this constant is increased it's likely that changes
// to dbghelp will be required to increase buffer sizes there.
#define MAX_IMAGE_PATH MAX_PATH

#define BUILD_MAJOR_VERSION (VER_PRODUCTVERSION_W >> 8)
#define BUILD_MINOR_VERSION (VER_PRODUCTVERSION_W & 0xff)
#define BUILD_REVISION      API_VERSION_NUMBER

#define KERNEL_MODULE_NAME       "NT"
#define HAL_MODULE_NAME          "hal"
#define HAL_IMAGE_FILE_NAME      "hal.dll"
#define KDHWEXT_MODULE_NAME      "kdcom"
#define KDHWEXT_IMAGE_FILE_NAME  "kdcom.dll"
#define NTLDR_IMAGE_NAME         "ntldr"
#define OSLOADER_IMAGE_NAME      "osloader"
#define SETUPLDR_IMAGE_NAME      "setupldr"

#define LDR_IMAGE_SIZE          0x80000

#define KBYTES(Bytes) (((Bytes) + 1023) / 1024)

enum
{
    OPTFN_ADD,
    OPTFN_REMOVE,
    OPTFN_SET
};

enum
{
    DII_GOOD_CHECKSUM = 1,
    DII_UNKNOWN_TIMESTAMP,
    DII_UNKNOWN_CHECKSUM,
    DII_BAD_CHECKSUM
};

enum INAME
{
    INAME_IMAGE_PATH,
    INAME_IMAGE_PATH_TAIL,
    INAME_MODULE,
};

#define MAX_MODULE 64

typedef struct _DEBUG_IMAGE_INFO
{
    struct _DEBUG_IMAGE_INFO *Next;
    BOOL                     Unloaded;
    HANDLE                   File;
    DWORD64                  BaseOfImage;
    DWORD                    SizeOfImage;
    DWORD                    CheckSum;
    DWORD                    TimeDateStamp;
    UCHAR                    GoodCheckSum;
    CHAR                     ModuleName[MAX_MODULE];
    CHAR                     OriginalModuleName[MAX_MODULE];
    CHAR                     ImagePath[MAX_IMAGE_PATH];
    // Executable image mapping information for images
    // mapped with minidumps.
    CHAR                     MappedImagePath[MAX_IMAGE_PATH];
    PVOID                    MappedImageBase;
} DEBUG_IMAGE_INFO, *PDEBUG_IMAGE_INFO;

//----------------------------------------------------------------------------
//
// Thread and process information is much different bewteen
// user and kernel debugging.  The structures exist and are
// as common as possible to enable common code.
//
// In user debugging process and thread info track the system
// processes and threads being debugged.
//
// In kernel debugging there is only one process that represents
// kernel space.  There is one thread per processor, each
// representing that processor's thread state.
//
//----------------------------------------------------------------------------

#define ENG_PROC_ATTACHED        0x00000001
#define ENG_PROC_CREATED         0x00000002
#define ENG_PROC_EXAMINED        0x00000004
#define ENG_PROC_ATTACH_EXISTING 0x00000008
// Currently the only system process specially marked is CSR.
#define ENG_PROC_SYSTEM          0x00000010

#define ENG_PROC_ANY_ATTACH     (ENG_PROC_ATTACHED | ENG_PROC_EXAMINED)
#define ENG_PROC_ANY_EXAMINE    (ENG_PROC_EXAMINED | ENG_PROC_ATTACH_EXISTING)

// Handle must be closed when deleted.
// This flag applies to both processes and threads.
#define ENG_PROC_THREAD_CLOSE_HANDLE 0x80000000

// The debugger set the trace flag when deferring
// breakpoint work on the last event for this thread.
#define ENG_THREAD_DEFER_BP_TRACE 0x00000001

// Processes which were created or attached but that
// have not yet generated events yet.
struct PENDING_PROCESS
{
    ULONG64 Handle;
    // Initial thread information is only valid for creations.
    ULONG64 InitialThreadHandle;
    ULONG Id;
    ULONG InitialThreadId;
    ULONG Flags;
    ULONG Options;
    PENDING_PROCESS* Next;
};
typedef struct PENDING_PROCESS* PPENDING_PROCESS;

#define MAX_DATA_BREAKS 4

typedef struct _THREAD_INFO
{
    // Generic information.
    struct _THREAD_INFO     *Next;
    struct _PROCESS_INFO    *Process;
    ULONG                    UserId;
    ULONG                    SystemId;
    BOOL                     Exited;
    ULONG64                  DataOffset;
    // For kernel mode and dumps the thread handle is
    // a virtual handle.
    ULONG64                  Handle;
    ULONG                    Flags;
    // Only set by VCPP exceptions.
    char                     Name[MAX_THREAD_NAME];

    class Breakpoint*        DataBreakBps[MAX_DATA_BREAKS];
    ULONG                    NumDataBreaks;

    // Only partially-implemented in kd.
    ULONG64                  StartAddress;
    BOOL                     Frozen;
    ULONG                    SuspendCount;
    ULONG                    FreezeCount;
    ULONG                    InternalFreezeCount;
} THREAD_INFO, *PTHREAD_INFO;

typedef struct _PROCESS_INFO
{
    struct _PROCESS_INFO    *Next;
    ULONG                    NumberImages;
    PDEBUG_IMAGE_INFO        ImageHead;
    PDEBUG_IMAGE_INFO        ExecutableImage;
    ULONG                    NumberThreads;
    PTHREAD_INFO             ThreadHead;
    PTHREAD_INFO             CurrentThread;
    ULONG                    UserId;
    ULONG                    SystemId;
    BOOL                     Exited;
    ULONG64                  DataOffset;
    // For kernel mode and dumps the process handle is
    // a virtual handle for the kernel/dump process.
    // dbghelp still uses HANDLE as the process handle
    // type even though we may want to pass in 64-bit
    // process handles when remote debugging.  Keep
    // a cut-down version of the handle for normal
    // use but also keep the full handle around in
    // case it's needed.
    HANDLE                   Handle;
    ULONG64                  FullHandle;
    BOOL                     InitialBreakDone;
    BOOL                     InitialBreak;
    BOOL                     InitialBreakWx86;
    ULONG                    Flags;
    ULONG                    Options;
    ULONG                    NumBreakpoints;
    class Breakpoint*        Breakpoints;
    class Breakpoint*        BreakpointsTail;
    ULONG64                  DynFuncTableList;
} PROCESS_INFO, *PPROCESS_INFO;

extern PPENDING_PROCESS g_ProcessPending;

extern PPROCESS_INFO g_ProcessHead;
extern PPROCESS_INFO g_EventProcess;
extern PTHREAD_INFO  g_EventThread;
extern PPROCESS_INFO g_CurrentProcess;
extern PTHREAD_INFO  g_SelectedThread;

enum
{
    SELTHREAD_ANY,
    SELTHREAD_THREAD,
    SELTHREAD_INTERNAL_THREAD,
};
extern ULONG         g_SelectExecutionThread;

#define CURRENT_PROC \
    VIRTUAL_THREAD_INDEX(g_CurrentProcess->CurrentThread->Handle)

// Registry keys.
#define DEBUG_ENGINE_KEY "Software\\Microsoft\\Debug Engine"

// Possibly truncates and sign-extends a value to 64 bits.
#define EXTEND64(Val) ((ULONG64)(LONG64)(LONG)(Val))

#define IsPow2(Val) \
    (((Val) & ((Val) - 1)) == 0)

// Machine type indices for machine-type-indexed things.
enum MachineIndex
{
    MACHIDX_I386,
    MACHIDX_ALPHA,
    MACHIDX_AXP64,
    MACHIDX_IA64,
    MACHIDX_AMD64,
    MACHIDX_COUNT
};

void SetEffMachine(ULONG Machine, BOOL Notify);

//
// Specific modules.
//

typedef struct _ADDR* PADDR;
typedef struct _DESCRIPTOR64* PDESCRIPTOR64;
class DebugClient;

typedef enum _DEBUG_SCOPE_STATE
{
    ScopeDefault,
    ScopeDefaultLazy,
    ScopeFromContext,
} DEBUG_SCOPE_STATE;

typedef struct _DEBUG_SCOPE
{
    BOOL              LocalsChanged;
    DEBUG_SCOPE_STATE State;
    DEBUG_STACK_FRAME Frame;
    CROSS_PLATFORM_CONTEXT Context;
    ULONG             ContextState;
    FPO_DATA          CachedFpo;
} DEBUG_SCOPE, *PDEBUG_SCOPE;

#include "dbgrpc.hpp"

#include "dbgclt.hpp"
#include "dbgsym.hpp"
#include "addr.h"
#include "target.hpp"
#include "register.h"
#include "machine.hpp"

#include "brkpt.hpp"
#include "callback.h"
#include "dbgkdapi.h"
#include "dbgkdtrans.hpp"
#include "event.h"
#include "exts.h"
#include "float10.h"
#include "instr.h"
#include "mcache.hpp"
#include "memcmd.h"
#include "mmap.h"
#include "ntalias.hpp"
#include "ntcmd.h"
#include "ntexpr.h"
#include "ntsdtok.h"
#include "ntsrc.h"
#include "ntsym.h"
#include "symtype.h"
#include "procthrd.h"
#include "stepgo.hpp"
#include "stkwalk.h"
#include "util.h"
#include "vdm.h"

#include "alpha_reg.h"
#include "amd64_reg.h"
#include "i386_reg.h"
#include "ia64_reg.h"

#include "alpha_mach.hpp"
#include "i386_mach.hpp"
// Must come after i386_mach.hpp.
#include "amd64_mach.hpp"
#include "ia64_mach.hpp"

// Must come after target.hpp.
#include "dump.hpp"

#include "dbgsvc.hpp"

//
//  The Splay function takes as input a pointer to a splay link in a tree
//  and splays the tree.  Its function return value is a pointer to the
//  root of the splayed tree.
//

PRTL_SPLAY_LINKS
pRtlSplay (
    PRTL_SPLAY_LINKS Links
    );

//
//  The Delete function takes as input a pointer to a splay link in a tree
//  and deletes that node from the tree.  Its function return value is a
//  pointer to the root of the tree.  If the tree is now empty, the return
//  value is NULL.
//

PRTL_SPLAY_LINKS
pRtlDelete (
    PRTL_SPLAY_LINKS Links
    );


#define EnumerateLocals(CallBack, Context)        \
SymEnumSymbols(g_CurrentProcess->Handle,   \
           0,                          \
           NULL,                       \
           CallBack,                   \
           Context                     \
           )

#endif // ifndef __NTSDP_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\ntcmd.h ===
//----------------------------------------------------------------------------
//
// ntcmd.h
//
// Copyright (C) Microsoft Corporation, 1997-2001.
//
//----------------------------------------------------------------------------

#ifndef _NTCMD_H_
#define _NTCMD_H_

#define IS_RUNNING(CmdState) \
    ((CmdState) == 'g' || (CmdState) == 'p' || \
     (CmdState) == 't' || (CmdState) == 'b')
#define IS_STEP_TRACE(CmdState) \
    ((CmdState) == 'p' || (CmdState) == 't' || (CmdState) == 'b')

extern BOOL    g_OciOutputRegs;
extern PSTR    g_CommandStart;
extern PSTR    g_CurCmd;
extern ULONG   g_PromptLength;
extern CHAR    g_LastCommand[];
extern CHAR    g_CmdState;
extern CHAR    g_SymbolSuffix;
extern ULONG   g_DefaultRadix;
extern ADDR    g_UnasmDefault;
extern ADDR    g_AssemDefault;
extern BOOL    g_SwitchedProcs;
extern API_VERSION g_NtsdApiVersion;
extern ULONG   g_DefaultStackTraceDepth;
extern BOOL    g_EchoEventTimestamps;

typedef enum _STACK_TRACE_TYPE
{
   STACK_TRACE_TYPE_DEFAULT = 0,
   STACK_TRACE_TYPE_KB      = 1,
   STACK_TRACE_TYPE_KV      = 2,
   STACK_TRACE_TYPE_KD      = 3,
   STACK_TRACE_TYPE_KP      = 4,
   STACK_TRACE_TYPE_KN      = 5,
   STACK_TRACE_TYPE_KBN     = 6,
   STACK_TRACE_TYPE_KVN     = 7,
   STACK_TRACE_TYPE_KDN     = 8,
   STACK_TRACE_TYPE_KPN     = 9,
   STACK_TRACE_TYPE_MAX
} STACK_TRACE_TYPE, *PSTACK_TRACE_TYPE;

#define COMMAND_EXCEPTION_BASE 0x0dbcd000

VOID
ParseStackTrace (
    PSTACK_TRACE_TYPE pTraceType,
    PADDR  StartFP,
    PULONG64 Esp,
    PULONG64 Eip,
    PULONG Count
    );

extern HRESULT InitNtCmd(DebugClient* Client);
extern void OutputVersionInformation(DebugClient* Client);
extern DWORD CommandExceptionFilter(PEXCEPTION_POINTERS Info);
extern HRESULT ProcessCommands(DebugClient* Client, BOOL Nested);
extern HRESULT ProcessCommandsAndCatch(DebugClient* Client);
extern HRESULT GetPromptText(PSTR Buffer, ULONG BufferSize, PULONG TextSize);
extern void OutputPrompt(PCSTR Format, va_list Args);

VOID
HandleBPWithStatus(
    VOID
    );

void CallBugCheckExtension(DebugClient* Client);

void
ParsePageIn(void);

#endif // #ifndef _NTCMD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\ntsdtok.h ===
//  error codes

#define OVERFLOW        0x1000
#define SYNTAX          0x1001
#define BADRANGE        0x1002
#define VARDEF          0x1003
#define EXTRACHARS      0x1004
#define LISTSIZE        0x1005
#define STRINGSIZE      0x1006
#define MEMORY          0x1007
#define BADREG          0x1008
#define BADOPCODE       0x1009
#define SUFFIX          0x100a
#define OPERAND         0x100b
#define ALIGNMENT       0x100c
#define PREFIX          0x100d
#define DISPLACEMENT    0x100e
#define BPLISTFULL      0x100f
#define BPDUPLICATE     0x1010
#define BADTHREAD       0x1011
#define DIVIDE          0x1012
#define TOOFEW          0x1013
#define TOOMANY         0x1014
#define SIZE            0x1015
#define BADSEG          0x1016
#define RELOC           0x1017
#define BADPROCESS      0x1018
#define AMBIGUOUS       0x1019
#define FILEREAD        0x101a
#define LINENUMBER      0x101b
#define BADSEL          0x101c
#define SYMTOOSMALL     0x101d
#define BPIONOTSUP      0x101e
#define NOTFOUND        0x101f
#define SESSIONNOTSUP   0x1020

#define UNIMPLEMENT     0x1099

//  token classes (< 100) and types (>= 100)


#define EOL_CLASS       0
#define ADDOP_CLASS     1
#define ADDOP_PLUS      100
#define ADDOP_MINUS     101
#define MULOP_CLASS     2
#define MULOP_MULT      200
#define MULOP_DIVIDE    201
#define MULOP_MOD       202
#define MULOP_SEG       203
//#define MULOP_64        204
#define LOGOP_CLASS     3
#define LOGOP_AND       300
#define LOGOP_OR        301
#define LOGOP_XOR       302
#define LRELOP_CLASS    4
#define LRELOP_EQ       400
#define LRELOP_NE       401
#define LRELOP_LT       402
#define LRELOP_GT       403
#define UNOP_CLASS      5
#define UNOP_NOT        500
#define UNOP_BY         501
#define UNOP_WO         502
#define UNOP_DWO        503
#define UNOP_POI        504
#define UNOP_LOW        505
#define UNOP_HI         506
#define UNOP_QWO        507
#define UNOP_VAL        508
#define LPAREN_CLASS    6
#define RPAREN_CLASS    7
#define LBRACK_CLASS    8
#define RBRACK_CLASS    9
#define REG_CLASS       10
#define NUMBER_CLASS    11
#define SYMBOL_CLASS    12
#define LINE_CLASS      13
#define SHIFT_CLASS     14
#define SHIFT_LEFT              1400
#define SHIFT_RIGHT_LOGICAL     1401
#define SHIFT_RIGHT_ARITHMETIC  1402

#define ERROR_CLASS     99              //only used for PeekToken()
#define INVALID_CLASS   -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\ntsrc.h ===
//----------------------------------------------------------------------------
//
// ntsrc.h
//
// Copyright (C) Microsoft Corporation, 1997-2001.
//
//----------------------------------------------------------------------------

#ifndef _NTSRC_H_
#define _NTSRC_H_

#define SRCOPT_STEP_SOURCE      0x00000001
#define SRCOPT_LIST_LINE        0x00000002
#define SRCOPT_LIST_SOURCE      0x00000004
#define SRCOPT_LIST_SOURCE_ONLY 0x00000008

extern ULONG g_SrcOptions;
extern PSTR g_SrcPath;
extern ULONG g_OciSrcBefore, g_OciSrcAfter;

typedef struct _SRCFILE
{
    struct _SRCFILE *Next;
    LPSTR File;
    ULONG Lines;
    LPSTR *LineText;
    LPSTR RawText;
} SRCFILE, *PSRCFILE;

void UnloadSrcFiles(void);

void OutputLineAddr(ULONG64 Offset);
void OutputSrcLines(PSRCFILE File, ULONG First, ULONG Last, ULONG Mark);
BOOL OutputSrcLinesAroundAddr(ULONG64 Offset, ULONG Before, ULONG After);

enum
{
    // Information was found.
    LINE_FOUND,
    // No information was found.
    LINE_NOT_FOUND,
    // A specific module was referenced and it did
    // not contain the requested line.
    LINE_NOT_FOUND_IN_MODULE,
};

ULONG GetOffsetFromLine(PSTR FileLine, PULONG64 Offset);

void ParseSrcOptCmd(CHAR Cmd);
void ParseSrcLoadCmd(void);
void ParseSrcListCmd(CHAR Cmd);
void ParseOciSrcCmd(void);

void ParseLines(PSTR Args);

BOOL
FindSrcFileOnPath(
    ULONG StartElement,
    LPSTR File,
    ULONG Flags,
    PSTR Found,
    PSTR* MatchPart,
    PULONG FoundElement
    );

void ChangeSrcPath(PSTR Args, BOOL Append);
void ChangeExePath(PSTR Args, BOOL Append);

#endif // #ifndef _NTSRC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\ntsrc.cpp ===
//----------------------------------------------------------------------------
//
// Source file searching and loading.
//
// Copyright (C) Microsoft Corporation, 1997-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

// #define DBG_SRC
// #define VERBOSE_SRC

ULONG g_SrcOptions;

LPSTR g_SrcPath;
PSRCFILE g_SrcFiles;
PSRCFILE g_CurSrcFile;
ULONG g_CurSrcLine;

ULONG g_OciSrcBefore;
ULONG g_OciSrcAfter = 1;

PSRCFILE
LoadSrcFile(
    LPSTR FileName,
    LPSTR RecordFileName
    )
{
    PathFile* File;
    PSRCFILE SrcFile, Realloc;
    ULONG Avail;
    ULONG BaseLen, Len, Done;
    LPSTR Cur, End;
    ULONG Lines;
    LPSTR *CurLine, LineStart;
    ULONG ReadLen;

    if (OpenPathFile(FileName, g_SymOptions, &File) != S_OK)
    {
        return NULL;
    }

    BaseLen = sizeof(SRCFILE) + strlen(RecordFileName) + 1;
    Len = BaseLen;
    SrcFile = NULL;
    for (;;)
    {
        if (File->QueryDataAvailable(&Avail) != S_OK)
        {
            goto EH_CloseFile;
        }
        if (Avail == 0)
        {
            if (SrcFile == NULL)
            {
                goto EH_CloseFile;
            }
            break;
        }

        Realloc = (SRCFILE *)realloc(SrcFile, Len + Avail);
        if (Realloc == NULL)
        {
            goto EH_CloseFile;
        }
        SrcFile = Realloc;
        
        if (File->Read((LPSTR)SrcFile + Len, Avail, &Done) != S_OK ||
            Done < Avail)
        {
            goto EH_CloseFile;
        }

        Len += Avail;
    }
    
    SrcFile->File = (LPSTR)(SrcFile + 1);
    strcpy(SrcFile->File, RecordFileName);
    SrcFile->RawText = (LPSTR)SrcFile + BaseLen;
    Len -= BaseLen;

    // Count lines in the source file.  Stop before the last character
    // to handle the case where there's a newline at the end of the
    // file in the same way as where there isn't one.

    Lines = 0;
    Cur = SrcFile->RawText;
    End = SrcFile->RawText + Len;
    while (Cur < End - 1)
    {
        if (*Cur++ == '\n')
        {
            Lines++;
        }
    }
    Lines++;

    SrcFile->LineText = (char **)malloc(sizeof(LPSTR) * Lines);
    if (SrcFile->LineText == NULL)
    {
        goto EH_CloseFile;
    }

    SrcFile->Lines = Lines;
    Cur = SrcFile->RawText;
    CurLine = SrcFile->LineText;
    LineStart = Cur;
    while (Cur < End - 1)
    {
        if (*Cur == '\n')
        {
            *CurLine++ = LineStart;
            *Cur = 0;
            LineStart = Cur+1;
        }
        else if (*Cur == '\r')
        {
            *Cur = 0;
        }
        Cur++;
    }
    *CurLine++ = LineStart;

    delete File;

    SrcFile->Next = g_SrcFiles;
    g_SrcFiles = SrcFile;

#ifdef VERBOSE_SRC
    dprintf("Loaded '%s' '%s' %d lines\n", FileName, RecordFileName, Lines);
#endif

    return SrcFile;

 EH_CloseFile:
    free(SrcFile);
    delete File;
    return NULL;
}

void
DeleteSrcFile(
    PSRCFILE SrcFile
    )
{
    if (g_CurSrcFile == SrcFile)
    {
        g_CurSrcFile = NULL;
        g_CurSrcLine = 0;
    }

    free(SrcFile->LineText);
    free(SrcFile);
}

BOOL
MatchSrcFileName(
    PSRCFILE SrcFile,
    LPSTR File
    )
{
    LPSTR FileStop, MatchStop;

    //
    // SRCFILE filenames are saved as the partial path that
    // matched a source path component rather than the full path
    // of the file as loaded.  When matching against potentially full
    // path information in debug info it's useful to use the incoming
    // string as the filename and the SRCFILE filename as the match
    // string.  A full match indicates that the partial path matches
    // completely and so should be used.
    //
    // This doesn't work so well for human input where the filename is
    // likely to be just a filename with no path.  In this case there
    // won't be a full match of the match string, nor is just flipping
    // the order of strings useful because that would allow submatches
    // such as "foo.c" matching "barfoo.c".  Instead this code tests
    // two conditions:
    // 1.  Full match string match.
    // 2.  Full file string match (implies partial match string match)
    //     and the mismatch character is a path separator.
    //     This forces filenames to match completely.
    //

    if (SymMatchFileName(File, SrcFile->File, &FileStop, &MatchStop) ||
        (FileStop < File && IS_PATH_DELIM(*MatchStop)))
    {
#ifdef DBG_SRC
        dprintf("'%s' matches '%s'\n", SrcFile->File, File);
#endif
        return TRUE;
    }
    else
    {
#ifdef DBG_SRC
        dprintf("'%s' doesn't match '%s'\n", SrcFile->File, File);
#endif
        return FALSE;
    }
}

BOOL
UnloadSrcFile(
    LPSTR File
    )
{
    PSRCFILE SrcFile, Prev;

    Prev = NULL;
    for (SrcFile = g_SrcFiles; SrcFile != NULL; SrcFile = SrcFile->Next)
    {
        if (MatchSrcFileName(SrcFile, File))
        {
            break;
        }

        Prev = SrcFile;
    }

    if (SrcFile == NULL)
    {
        return FALSE;
    }

    if (Prev != NULL)
    {
        Prev->Next = SrcFile->Next;
    }
    else
    {
        g_SrcFiles = SrcFile->Next;
    }

    DeleteSrcFile(SrcFile);
    return TRUE;
}

void
UnloadSrcFiles(
    void
    )
{
    PSRCFILE Cur, Next;

    for (Cur = g_SrcFiles; Cur != NULL; Cur = Next)
    {
        Next = Cur->Next;

        DeleteSrcFile(Cur);
    }

    g_SrcFiles = NULL;
}

PSRCFILE
FindLoadedSrcFile(
    LPSTR File
    )
{
    PSRCFILE SrcFile;

    for (SrcFile = g_SrcFiles; SrcFile != NULL; SrcFile = SrcFile->Next)
    {
        if (MatchSrcFileName(SrcFile, File))
        {
#ifdef DBG_SRC
            dprintf("Found loaded file '%s'\n", SrcFile->File);
#endif
            return SrcFile;
        }
    }

    return NULL;
}

void
ConcatPathComponents(
    LPSTR Path,
    LPSTR PathEnd,
    LPSTR* PathOut,
    LPSTR FilePath,
    LPSTR Buffer
    )
{
    if (PathEnd == NULL)
    {
        PathEnd = strchr(Path, ';');
        if (PathEnd != NULL)
        {
            if (PathOut != NULL)
            {
                *PathOut = PathEnd + 1;
            }
        }
        else
        {
            PathEnd = Path + strlen(Path);
            if (PathOut != NULL)
            {
                *PathOut = NULL;
            }
        }
    }

    if (PathEnd > Path)
    {
        memcpy(Buffer, Path, (int)(PathEnd - Path));
        PathEnd = Buffer + (PathEnd - Path - 1);

        // Attempt to avoid duplicating separators while forcing separation.
        if ((*PathEnd == ':' && *FilePath == ':') ||
            (IS_SLASH(*PathEnd) && IS_SLASH(*FilePath)))
        {
            FilePath++;
        }
        else if (!IS_PATH_DELIM(*PathEnd) && !IS_PATH_DELIM(*FilePath))
        {
            *(++PathEnd) = '\\';
        }
        
        strcpy(PathEnd + 1, FilePath);
    }
    else
    {
        strcpy(Buffer, FilePath);
    }
}

void
EditPathSlashes(
    LPSTR Path
    )
{
    if (!IsUrlPathComponent(Path))
    {
        return;
    }
    
    PSTR Scan = Path;
        
    // Flip all backslashes forwards.
    while (*Scan)
    {
        if (*Scan == '\\')
        {
            *Scan = '/';
        }
        
        Scan++;
    }
}

BOOL
SrcFileExists(
    LPSTR Path,
    LPSTR PathEnd,
    LPSTR* PathOut,
    LPSTR FilePath,
    LPSTR File
    )
{
    char Buffer[MAX_SOURCE_PATH];

    ConcatPathComponents(Path, PathEnd, PathOut, FilePath, Buffer);
    if (File != NULL)
    {
        ULONG Len = strlen(Buffer);
        Buffer[Len] = '\\';
        strcpy(Buffer + Len + 1, File);
    }

    EditPathSlashes(Buffer);

#ifdef DBG_SRC
    dprintf("Check for existence of '%s'\n", Buffer);
#endif

    FILE_IO_TYPE IoType;
    
    return PathFileExists(Buffer, g_SymOptions, &IoType);
}

BOOL
FindSrcFileOnPath(
    ULONG StartElement,
    LPSTR File,
    ULONG Flags,
    PSTR Found,
    PSTR* MatchPart,
    PULONG FoundElement
    )
{
    LPSTR PathSuff;
    LPSTR Path;
    LPSTR PathStart;
    LPSTR PathSep;
    LPSTR PathCharPtr;
    char PathChar;
    ULONG Elt;

    // Find the element of the path to start at.
    PathStart = FindPathElement(g_SrcPath, StartElement, &PathSep);
    if (PathStart == NULL)
    {
        goto CheckPlainFile;
    }

    // Split the given filename into a path prefix and a path
    // suffix.  Initially the path prefix is any path components
    // and the path suffix is just the filename.  If there
    // are path components attempt to match them against the source
    // path.  Keep backing up the path one component at a time
    // until a match is found or the prefix is emptied.  At
    // that point just do a plain file search along the source path.
    PathSuff = File + strlen(File);

    for (;;)
    {
        while (--PathSuff >= File)
        {
            if (IS_SLASH(*PathSuff) ||
                (*PathSuff == ':' && !IS_SLASH(*(PathSuff + 1))))
            {
                break;
            }
        }
        PathSuff++;

        // If we've run out of path prefix we're done with this
        // part of the search.
        if (PathSuff == File)
        {
            break;
        }

        char Save;
        LPSTR BestPathStart;
        LPSTR BestPathEnd;
        LPSTR BestFile;
        ULONG BestElement;
        LPSTR MatchPath;
        LPSTR MatchFile;

        Save = *(PathSuff - 1);
        *(PathSuff - 1) = 0;

#ifdef DBG_SRC
        dprintf("Check path pre '%s' suff '%s'\n",
                File, PathSuff);
#endif

        Path = PathStart;
        Elt = StartElement;
        BestPathStart = NULL;
        BestFile = PathSuff - 2;
        while (*Path != 0)
        {
            PathSep = strchr(Path, ';');
            if (PathSep == NULL)
            {
                PathSep = Path + strlen(Path);
            }

            // Trim trailing slashes on path components as
            // the file components have them trimmed so
            // leaving them would confuse the matching.
            PathCharPtr = PathSep;
            if (PathCharPtr > Path && IS_SLASH(PathCharPtr[-1]))
            {
                PathCharPtr--;
            }
            
            PathChar = *PathCharPtr;
            if (PathChar != 0)
            {
                *PathCharPtr = 0;
            }
            else
            {
                // Back up off the terminator so that PathSep
                // can be advanced the same way for both
                // ';' and end-of-string cases.
                PathSep--;
            }

            SymMatchFileName(Path, File, &MatchPath, &MatchFile);

#ifdef DBG_SRC
            dprintf("Match '%s' against '%s': %d (match '%s')\n",
                    Path, File, MatchFile - File, MatchFile + 1);
#endif

            *PathCharPtr = PathChar;

            if (MatchFile < BestFile &&
                SrcFileExists(Path, MatchPath + 1, NULL,
                              MatchFile + 1, PathSuff))
            {
                BestPathStart = Path;
                BestPathEnd = MatchPath + 1;
                BestFile = MatchFile + 1;
                BestElement = Elt;

                // Check for complete match or first-match mode.
                if (MatchPath < Path || MatchFile < File ||
                    (Flags & DEBUG_FIND_SOURCE_BEST_MATCH) == 0)
                {
                    break;
                }
            }

            Path = PathSep + 1;
            Elt++;
        }

        *(PathSuff - 1) = Save;

        if (BestPathStart != NULL)
        {
#ifdef DBG_SRC
            dprintf("Found partial file '%.*s' on path '%.*s'\n",
                    PathSuff - BestFile, BestFile,
                    BestPathEnd - BestPathStart, BestPathStart);
#endif
                    
            // Return the match found.
            ConcatPathComponents(BestPathStart, BestPathEnd, NULL,
                                 BestFile, Found);
            EditPathSlashes(Found);
            *MatchPart = BestFile;
            *FoundElement = BestElement;
            
#ifdef DBG_SRC
            dprintf("Found partial file '%s' at %d\n",
                    Found, *FoundElement);
#endif
            
            return TRUE;
        }

        // Skip past separator.
        PathSuff--;
    }

    // Traverse all directories in the source path and try them with the
    // filename given.  Start with the given filename
    // to make the most restrictive check.  If
    // no match is found keep trimming components off and
    // checking again.

    PathSuff = File;
    
    for (;;)
    {
#ifdef DBG_SRC
        dprintf("Scan all paths for '%s'\n", PathSuff);
#endif
        
        Path = PathStart;
        Elt = StartElement;
        while (Path != NULL && *Path != 0)
        {
            if (SrcFileExists(Path, NULL, &PathSep, PathSuff, NULL))
            {
                // SrcFileExists leaves PathSep set to the
                // path element after the separator so back up
                // one when forming the return path.
                if (PathSep != NULL)
                {
                    PathSep--;
                }
                
#ifdef DBG_SRC
                dprintf("Found file suffix '%s' on path '%.*s'\n",
                        PathSuff, PathSep != NULL ?
                        PathSep - Path : strlen(Path), Path);
#endif

                ConcatPathComponents(Path, PathSep, NULL, PathSuff, Found);
                EditPathSlashes(Found);
                *MatchPart = PathSuff;
                *FoundElement = Elt;

#ifdef DBG_SRC
                dprintf("Found file suffix '%s' at %d\n",
                        Found, *FoundElement);
#endif
            
                return TRUE;
            }

            Path = PathSep;
            Elt++;
        }

        // Trim a component from the front of the path suffix.
        PathSep = PathSuff;
        while (*PathSep != 0 &&
               !IS_SLASH(*PathSep) &&
               (*PathSep != ':' || IS_SLASH(*(PathSep + 1))))
        {
            PathSep++;
        }
        if (*PathSep == 0)
        {
            // Nothing left to trim.
            break;
        }

        PathSuff = PathSep + 1;
    }

 CheckPlainFile:

#ifdef DBG_SRC
    dprintf("Check plain file '%s'\n", File);
#endif
    
    if (GetFileAttributes(File) != -1)
    {
        strcpy(Found, File);
        *MatchPart = File;
        *FoundElement = -1;

#ifdef DBG_SRC
        dprintf("Found plain file '%s' at %d\n", Found, *FoundElement);
#endif
        
        return TRUE;
    }
    
    return FALSE;
}

PSRCFILE
LoadSrcFileOnPath(
    LPSTR File
    )
{
    if (g_SrcPath == NULL)
    {
        return LoadSrcFile(File, File);
    }

    char Found[MAX_SOURCE_PATH];
    PSTR MatchPart;
    ULONG Elt;

    if (FindSrcFileOnPath(0, File, DEBUG_FIND_SOURCE_BEST_MATCH,
                          Found, &MatchPart, &Elt))
    {
        return LoadSrcFile(Found, MatchPart);
    }
    
    dprintf("No source found for '%s'\n", File);

    return NULL;
}

PSRCFILE
FindSrcFile(
    LPSTR File
    )
{
    PSRCFILE SrcFile;

#ifdef DBG_SRC
    dprintf("Find '%s'\n", File);
#endif

    SrcFile = FindLoadedSrcFile(File);
    if (SrcFile == NULL)
    {
        SrcFile = LoadSrcFileOnPath(File);
    }
    return SrcFile;
}

void
OutputLineAddr(
    ULONG64 Offset
    )
{
    IMAGEHLP_LINE64 Line;
    ULONG Disp;

    Line.SizeOfStruct = sizeof(Line);
    if (SymGetLineFromAddr64(g_CurrentProcess->Handle,
                           Offset,
                           &Disp,
                           &Line))
    {
        dprintf("%s(%d)", Line.FileName, Line.LineNumber);
        if (Disp != 0)
        {
            dprintf("+0x%x", Disp);
        }
        dprintf("\n");
    }
}

void
OutputSrcLines(
    PSRCFILE File,
    ULONG First,
    ULONG Last,
    ULONG Mark
    )
{
    ULONG i;
    LPSTR *Text;

    if (First < 1)
    {
        First = 1;
    }
    if (Last > File->Lines)
    {
        Last = File->Lines;
    }

    Text = &File->LineText[First-1];
    for (i = First; i <= Last; i++)
    {
        if (i == Mark)
        {
            dprintf(">");
        }
        else
        {
            dprintf(" ");
        }

        dprintf("%5d: %s\n", i, *Text++);
    }
}

BOOL
OutputSrcLinesAroundAddr(
    ULONG64 Offset,
    ULONG Before,
    ULONG After
    )
{
    IMAGEHLP_LINE64 Line;
    ULONG Disp;
    PSRCFILE SrcFile;

    Line.SizeOfStruct = sizeof(Line);
    if (!SymGetLineFromAddr64(g_CurrentProcess->Handle,
                            Offset,
                            &Disp,
                            &Line))
    {
        return FALSE;
    }

    SrcFile = FindSrcFile(Line.FileName);
    if (SrcFile == NULL)
    {
        return FALSE;
    }

    OutputSrcLines(SrcFile,
                   Line.LineNumber-Before, Line.LineNumber+After-1,
                   Line.LineNumber);
    return TRUE;
}

ULONG
GetOffsetFromLine(
    PSTR FileLine,
    PULONG64 Offset
    )
{
    IMAGEHLP_LINE64 Line;
    LPSTR Mod;
    LPSTR File;
    LPSTR LineStr;
    LPSTR SlashF, SlashB;
    ULONG LineNum;
    ULONG Disp;
    ULONG OldSym;
    ULONG NewSym;
    BOOL  AllowDisp;
    BOOL  Ret;
    PDEBUG_IMAGE_INFO Image = NULL;

    if ((g_SymOptions & SYMOPT_LOAD_LINES) == 0)
    {
        WarnOut("WARNING: Line information loading disabled\n");
    }

    OldSym = g_SymOptions;
    NewSym = g_SymOptions;
    
    // Symbol directives can prefix the source expression.
    // These can be given by sufficiently knowledgeable users
    // but they're primarily a back-channel communication
    // mechanism for windbg's source management.
    if (*FileLine == '<')
    {
        FileLine++;
        while (*FileLine != '>')
        {
            switch(*FileLine)
            {
            case 'U':
                // Restrict the search to just loaded modules.
                NewSym |= SYMOPT_NO_UNQUALIFIED_LOADS;
                break;
            default:
                error(SYNTAX);
            }

            FileLine++;
        }

        FileLine++;
    }
    
    // Crack string of the form [module!][file][:line] into its
    // components.  Note that ! is a valid filename character so
    // it's possible for ambiguity to occur between module references
    // and filenames.  This code assumes that ! is uncommon and
    // handles it as a module separator unless there's a : or \ or /
    // before it.  : can also occur in paths and is filtered
    // in a similar manner.

    File = strchr(FileLine, '!');
    LineStr = strchr(FileLine, ':');
    SlashF = strchr(FileLine, '/');
    SlashB = strchr(FileLine, '\\');

    if (File != NULL &&
        (LineStr != NULL && File > LineStr) ||
        (SlashF != NULL && File > SlashF) ||
        (SlashB != NULL && File > SlashB))
    {
        File = NULL;
    }

    if (File != NULL)
    {
        if (File == FileLine)
        {
            error(SYNTAX);
        }

        Mod = FileLine;
        *File++ = 0;
    }
    else
    {
        Mod = NULL;
        File = FileLine;
    }

    // If a module was specified check and see if it's
    // a module that's currently present as that
    // will affect which error code is returned.
    if (Mod != NULL)
    {
        Image = GetImageByName(g_CurrentProcess, Mod, INAME_MODULE);
    }
    
    // Look for the first colon after path components.
    while (LineStr != NULL &&
           (LineStr < File || LineStr < SlashF || LineStr < SlashB))
    {
        LineStr = strchr(LineStr + 1, ':');
    }

    LineNum = 1;
    if (LineStr != NULL)
    {
        PSTR NumEnd;

        // A specific line was given so don't allow a displacement.
        AllowDisp = FALSE;
        *LineStr = 0;
        LineNum = strtoul(LineStr + 1, &NumEnd, 0);

        if (*NumEnd == '+')
        {
            // Setting the high bit of the line number
            // tells dbghelp to search in at-or-greater mode.
            // This may produce displacements so allow them.
            LineNum |= 0x80000000;
            AllowDisp = TRUE;
        }
        else if (*NumEnd == '~')
        {
            // Find the closest line number.
            AllowDisp = TRUE;
        }
        else if (*NumEnd && *NumEnd != ' ' && *NumEnd != '\t')
        {
            error(SYNTAX);
        }
    }
    else
    {
        AllowDisp = TRUE;
    }

    Line.SizeOfStruct = sizeof(Line);
    Ret = FALSE;

    // If this is a pure linenumber reference then we need to fill in
    // the line information with a current location before doing
    // the line-relative query.
    if (*File == 0)
    {
        ADDR Pc;

        if (Mod != NULL)
        {
            goto EH_Ret;
        }

        g_Machine->GetPC(&Pc);
        if (!SymGetLineFromAddr64(g_CurrentProcess->Handle,
                                Flat(Pc),
                                &Disp,
                                &Line))
        {
            goto EH_Ret;
        }

        File = NULL;
    }

    // Establish any special symbol options requested.
    SymSetOptions(NewSym);
    
    Ret = SymGetLineFromName64(g_CurrentProcess->Handle, Mod,
                               File, LineNum, (PLONG)&Disp, &Line);

    SymSetOptions(OldSym);

 EH_Ret:
    if (Mod != NULL)
    {
        *(File-1) = '!';
    }

    if (LineStr != NULL)
    {
        *LineStr = ':';
    }

    // Only return a match if it's exact or no line number was specified.
    if (Ret && (Disp == 0 || AllowDisp))
    {
        *Offset = Line.Address;
        return LINE_FOUND;
    }
    else if (Image != NULL)
    {
        return LINE_NOT_FOUND_IN_MODULE;
    }
    else
    {
        return LINE_NOT_FOUND;
    }
}

void
ParseSrcOptCmd(
    CHAR Cmd
    )
{
    char Cmd2;
    DWORD Opt;

    Cmd2 = PeekChar();
    if (Cmd2 == 'l')
    {
        g_CurCmd++;
        Opt = SRCOPT_LIST_LINE;
    }
    else if (Cmd2 == 'o')
    {
        g_CurCmd++;
        Opt = SRCOPT_LIST_SOURCE_ONLY;
    }
    else if (Cmd2 == 's')
    {
        g_CurCmd++;
        Opt = SRCOPT_LIST_SOURCE;
    }
    else if (Cmd2 == 't')
    {
        g_CurCmd++;
        Opt = SRCOPT_STEP_SOURCE;
    }
    else if (Cmd2 == '0')
    {
        // Numeric options.
        if (*(++g_CurCmd) != 'x')
        {
            error(SYNTAX);
        }
        else
        {
            g_CurCmd++;
            Opt = (DWORD)HexValue(4);
        }
    }
    else if (Cmd2 == '*')
    {
        g_CurCmd++;
        // All.
        Opt = 0xffffffff;
    }
    else if (Cmd2 != 0 && Cmd2 != ';')
    {
        error(SYNTAX);
    }
    else
    {
        // No character means display current settings.
        Opt = 0;
    }

    ULONG OldSrcOpt = g_SrcOptions;
    
    if (Cmd == '+')
    {
        g_SrcOptions |= Opt;

        if ((SymGetOptions() & SYMOPT_LOAD_LINES) == 0)
        {
            WarnOut("  WARNING: Line information loading disabled\n");
        }
    }
    else
    {
        g_SrcOptions &= ~Opt;
    }

    if ((OldSrcOpt ^ g_SrcOptions) & SRCOPT_STEP_SOURCE)
    {
        NotifyChangeEngineState(DEBUG_CES_CODE_LEVEL,
                                (g_SrcOptions & SRCOPT_STEP_SOURCE) ?
                                DEBUG_LEVEL_SOURCE : DEBUG_LEVEL_ASSEMBLY,
                                TRUE);
    }
    
    dprintf("Source options are %x:\n", g_SrcOptions);
    if (g_SrcOptions == 0)
    {
        dprintf("    None\n");
    }
    else
    {
        if (g_SrcOptions & SRCOPT_STEP_SOURCE)
        {
            dprintf("    %2x/t - Step/trace by source line\n",
                    SRCOPT_STEP_SOURCE);
        }
        if (g_SrcOptions & SRCOPT_LIST_LINE)
        {
            dprintf("    %2x/l - List source line for LN and prompt\n",
                    SRCOPT_LIST_LINE);
        }
        if (g_SrcOptions & SRCOPT_LIST_SOURCE)
        {
            dprintf("    %2x/s - List source code at prompt\n",
                    SRCOPT_LIST_SOURCE);
        }
        if (g_SrcOptions & SRCOPT_LIST_SOURCE_ONLY)
        {
            dprintf("    %2x/o - Only show source code at prompt\n",
                    SRCOPT_LIST_SOURCE_ONLY);
        }
    }
}

void
ParseSrcLoadCmd(
    void
    )
{
    LPSTR Semi;
    PSRCFILE SrcFile;
    char Cur;
    BOOL Unload;

    // Check for an unload request.
    Unload = FALSE;
    if (*g_CurCmd == '-')
    {
        g_CurCmd++;
        Unload = TRUE;
    }

    while ((Cur = *g_CurCmd) == ' ' || Cur == '\t')
    {
        g_CurCmd++;
    }

    if (Cur == 0 || Cur == ';')
    {
        error(SYNTAX);
    }

    // Look for a semicolon, otherwise assume the whole command
    // line is the file path.

    Semi = strchr(g_CurCmd, ';');
    if (Semi != NULL)
    {
        *Semi = 0;
    }

    if (Unload)
    {
        if (UnloadSrcFile(g_CurCmd))
        {
            dprintf("Unloaded '%s'\n", g_CurCmd);
        }
    }
    else
    {
        SrcFile = FindSrcFile(g_CurCmd);
        if (SrcFile == NULL)
        {
            dprintf("Unable to load '%s'\n", g_CurCmd);
        }
    }

    if (Semi != NULL)
    {
        *Semi = ';';
        g_CurCmd = Semi;
    }
    else
    {
        g_CurCmd += strlen(g_CurCmd);
    }

    if (!Unload && SrcFile != NULL)
    {
        g_CurSrcFile = SrcFile;
        g_CurSrcLine = 1;
    }
}

void
ParseSrcListCmd(
    CHAR Cmd
    )
{
    LONG First, Count;
    char Cur;
    ULONG OldBase;
    ADDR Addr;
    ULONG Mark;

    if (Cmd == '.')
    {
        g_CurCmd++;

        PDEBUG_SCOPE Scope = GetCurrentScope();
	if (Scope->Frame.InstructionOffset)
        {
	    // List current frame
	    ADDRFLAT(&Addr, Scope->Frame.InstructionOffset);
	}
        else
        {
	    // List at PC.
	    g_Machine->GetPC(&Addr);
	}
        Cmd = 'a';
    }
    else if (Cmd == 'a')
    {
        g_CurCmd++;

        // List at address, so get an address.
        GetAddrExpression(SEGREG_CODE, &Addr);

        // Search for and consume trailing ,
        while ((Cur = *g_CurCmd) == ' ' || Cur == '\t')
        {
            g_CurCmd++;
        }
        if (Cur == ',')
        {
            Cur = *++g_CurCmd;
            if (Cur == 0 || Cur == ';')
            {
                error(SYNTAX);
            }
        }
    }
    else if (Cmd == 'c')
    {
        g_CurCmd++;

        if (g_CurSrcFile != NULL)
        {
            dprintf("Current: %s(%d)\n", g_CurSrcFile->File, g_CurSrcLine);
        }
        else
        {
            dprintf("No current source file\n");
        }
        return;
    }

    while ((Cur = *g_CurCmd) == ' ' || Cur == '\t')
    {
        g_CurCmd++;
    }

    // Force base 10 for linenumbers.

    OldBase = g_DefaultRadix;
    g_DefaultRadix = 10;

    if (Cur == 0 || Cur == ';')
    {
        First = Cmd == 'a' ? -4 : g_CurSrcLine;
        Count = 10;
    }
    else if (Cur == ',')
    {
        First = Cmd == 'a' ? -4 : g_CurSrcLine;
        g_CurCmd++;
        Count = (ULONG)GetExpression();
    }
    else
    {
        First = (ULONG)GetExpression();
        if (*g_CurCmd == ',')
        {
            g_CurCmd++;
            Count = (ULONG)GetExpression();
        }
        else
        {
            Count = 10;
        }
    }

    g_DefaultRadix = OldBase;

    if (Count < 1)
    {
        error(SYNTAX);
    }

    Mark = 0;

    if (Cmd == 'a')
    {
        DWORD Disp;
        IMAGEHLP_LINE64 Line;
        PSRCFILE SrcFile;

        // Listing from the source file that Addr is in.

        Line.SizeOfStruct = sizeof(Line);
        if (!SymGetLineFromAddr64(g_CurrentProcess->Handle,
                                Flat(Addr),
                                &Disp,
                                &Line))
        {
            return;
        }

        SrcFile = FindSrcFile(Line.FileName);
        if (SrcFile == NULL)
        {
            return;
        }

        g_CurSrcFile = SrcFile;
        g_CurSrcLine = Line.LineNumber;
        Mark = Line.LineNumber;
    }

    if (g_CurSrcFile == NULL)
    {
        dprintf("No current source file\n");
        return;
    }

    // Address list commands are always relative,
    // as are negative starting positions.
    if (Cmd == 'a' || First < 0)
    {
        g_CurSrcLine += First;
    }
    else
    {
        g_CurSrcLine = First;
    }

    OutputSrcLines(g_CurSrcFile, g_CurSrcLine, g_CurSrcLine+Count-1, Mark);

    g_CurSrcLine += Count;
}

void
ParseOciSrcCmd(
    void
    )
{
    if (PeekChar() != ';' && *g_CurCmd)
    {
        ULONG64 Val1 = GetExpression();
        ULONG64 Val2 = 0;
    
        if (PeekChar() != ';' && *g_CurCmd)
        {
            Val2 = GetExpression();
        }
        else
        {
            Val2 = (Val1 + 1) / 2;
            Val1 -= Val2;
        }

        g_OciSrcBefore = (ULONG)Val1;
        g_OciSrcAfter = (ULONG)Val2;
    }

    if ((g_SrcOptions & SRCOPT_LIST_SOURCE) == 0)
    {
        WarnOut("WARNING: Source line display is disabled\n");
    }
    
    dprintf("At the prompt, display %d source lines before and %d after\n",
            g_OciSrcBefore, g_OciSrcAfter);
}

void
ParseLines(PSTR Args)
{
    ULONG NewOpts = g_SymOptions ^ SYMOPT_LOAD_LINES;
    
    while (Args && *Args)
    {
        while (*Args == ' ' || *Args == '\t')
        {
            Args++;
        }

        if (*Args == '-' || *Args == '/')
        {
            Args++;
            switch(*Args++)
            {
            case 'd':
                NewOpts &= ~SYMOPT_LOAD_LINES;
                break;
            case 'e':
                NewOpts |= SYMOPT_LOAD_LINES;
                break;
            case 't':
                // Toggle, already done.
                break;
            default:
                error(SYNTAX);
            }
        }
        else
        {
            break;
        }
    }
                
    SetSymOptions(NewOpts);

    if (g_SymOptions & SYMOPT_LOAD_LINES)
    {
        dprintf("Line number information will be loaded\n");
    }
    else
    {
        dprintf("Line number information will not be loaded\n");
    }
}

void
ChangeSrcPath(
    PSTR Args,
    BOOL Append
    )
{
    while (*Args == ' ' || *Args == '\t')
    {
        Args++;
    }

    if (*Args != 0)
    {
        if (ChangePath(&g_SrcPath, Args, Append,
                       DEBUG_CSS_PATHS) != S_OK)
        {
            return;
        }
    }

    if (g_SrcPath == NULL)
    {
        dprintf("No source search path\n");
    }
    else
    {
        dprintf("Source search path is: %s\n", g_SrcPath);
        CheckPath(g_SrcPath);
    }
}

void
ChangeExePath(
    PSTR Args,
    BOOL Append
    )
{
    while (*Args == ' ' || *Args == '\t')
    {
        Args++;
    }

    if (*Args != 0)
    {
        if (ChangePath(&g_ExecutableImageSearchPath, Args, Append,
                       DEBUG_CSS_PATHS) != S_OK)
        {
            return;
        }
    }

    if (g_ExecutableImageSearchPath == NULL)
    {
        dprintf("No exectutable image search path\n");
    }
    else
    {
        dprintf("Executable image search path is: %s\n",
                g_ExecutableImageSearchPath);
        CheckPath(g_ExecutableImageSearchPath);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\ntsym.cpp ===
//----------------------------------------------------------------------------
//
// Symbol-handling routines.
//
// Copyright (C) Microsoft Corporation, 1997-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

#include <stddef.h>
#include <cvconst.h>
#include <common.ver>

typedef struct _EXAMINE_INFO
{
    BOOL Verbose;
} EXAMINE_INFO, *PEXAMINE_INFO;

LPSTR g_SymbolSearchPath;
LPSTR g_ExecutableImageSearchPath;

// Symbol options that require symbol reloading to take effect.
#define RELOAD_SYM_OPTIONS \
    (SYMOPT_UNDNAME | SYMOPT_NO_CPP | SYMOPT_DEFERRED_LOADS | \
     SYMOPT_LOAD_LINES | SYMOPT_IGNORE_CVREC | SYMOPT_LOAD_ANYTHING | \
     SYMOPT_EXACT_SYMBOLS)

ULONG   g_SymOptions = SYMOPT_CASE_INSENSITIVE | SYMOPT_UNDNAME |
                       SYMOPT_NO_CPP | SYMOPT_OMAP_FIND_NEAREST |
                       SYMOPT_DEFERRED_LOADS;

CHAR g_SymBuffer[SYM_BUFFER_SIZE];
CHAR g_SymStartBuffer[SYM_BUFFER_SIZE];
PIMAGEHLP_SYMBOL64 g_Sym = (PIMAGEHLP_SYMBOL64) g_SymBuffer;
PIMAGEHLP_SYMBOL64 g_SymStart = (PIMAGEHLP_SYMBOL64) g_SymStartBuffer;

ULONG g_NumUnloadedModules;

PSTR g_DmtNameDescs[DMT_NAME_COUNT] =
{
    "Loaded symbol image file", "Symbol file", "Mapped memory image file",
    "Image path",
};

DEBUG_SCOPE g_ScopeBuffer;

void
RefreshAllModules(void)
{
    PPROCESS_INFO Process;
        
    // Force all loaded symbols to be unloaded so that symbols will
    // be reloaded with any updated settings.
    for (Process = g_ProcessHead;
         Process != NULL;
         Process = Process->Next)
    {
        PDEBUG_IMAGE_INFO Image;

        for (Image = Process->ImageHead;
             Image != NULL;
             Image = Image->Next)
        {
            SymUnloadModule64(Process->Handle, Image->BaseOfImage);
            ClearStoredTypes(Image->BaseOfImage);
            if (!SymLoadModule64(Process->Handle,
                                 Image->File,
                                 PrepareImagePath(Image->ImagePath),
                                 Image->ModuleName,
                                 Image->BaseOfImage,
                                 Image->SizeOfImage))
            {
                ErrOut("Unable to reload %s\n", Image->ModuleName);
            }
        }
    }
}

void
SetSymOptions(ULONG Options)
{
    ULONG OldOptions = g_SymOptions;
    
    g_SymOptions = Options;
    SymSetOptions(g_SymOptions);
    NotifyChangeSymbolState(DEBUG_CSS_SYMBOL_OPTIONS, g_SymOptions, NULL);

    if ((OldOptions ^ g_SymOptions) & RELOAD_SYM_OPTIONS)
    {
        RefreshAllModules();
    }
}

BOOL
IsImageMachineType64(DWORD MachineType)
{
    switch (MachineType)
    {
    case IMAGE_FILE_MACHINE_AXP64:
    case IMAGE_FILE_MACHINE_IA64:
    case IMAGE_FILE_MACHINE_AMD64:
        return TRUE;
    default:
        return FALSE;
    }
}

ULONG64
GetRegValIA64(
    PCROSS_PLATFORM_CONTEXT Context,
    PDEBUG_STACK_FRAME      Frame,
    ULONG                   RegID
    )
{

    ULONGLONG   Registers[96+2];
    ULONGLONG   RegisterHome = Frame->FrameOffset;
    ULONG       RegisterCount;
    ULONG       RegisterNumber;
    ULONG       ReadLength;
    ULONG       i;

    if (Frame->FrameNumber = 0)
    {
        RegisterCount = (ULONG) Context->IA64Context.StIFS & 0x7f;
    }
    else
    {
        RegisterCount = 96;
    }

    // Sanity.

    if (RegisterCount > 96)
    {
        return g_Machine->GetReg64(RegID);
    }

    if (RegisterHome & 3)
    {
        return g_Machine->GetReg64(RegID);
    }

    if ((RegID >= INTR32) && (RegID < INTR32 + RegisterCount))
    {
        //
        // Read only what we have to
        //
        RegisterCount = RegID - INTR32 + 1;

        //
        // Calculate the number of registers to read from the
        // RSE stack.  For every 63 registers there will be at
        // at least one NaT collection register, depending on
        // where we start, there may be another one.
        //
        // First, starting at the current BSP, if we cross a 64 (0x40)
        // boundry, then we have an extra.
        //

        ReadLength = (((((ULONG)Frame->FrameOffset) >> 3) & 0x1f) +
                      RegisterCount) >> 6;

        //
        // Add 1 for every 63 registers.
        //

        ReadLength = (RegisterCount / 63) + RegisterCount;
        ReadLength *= sizeof(ULONGLONG);

        //
        // Read the registers for this frame.
        //

        if (!SwReadMemory(g_CurrentProcess->Handle,
                          RegisterHome,
                          Registers,
                          ReadLength,
                          &i))
        {
            //
            // This shouldn't have happened.
            //
            return g_Machine->GetReg64(RegID);
        }


        return Registers[RegID - INTR32];
    }
    else
    {
        return g_Machine->GetReg64(RegID);
    }

    if (RegisterCount == 0)
    {
        //
        // Not much point doing anything in this case.
        //

        return g_Machine->GetReg64(RegID);
    }

    //
    // Note: the following code should be altered to understand
    //       NaTs as they come from the register stack (currently
    //       it ignores them).
    //

    RegisterNumber = 32;
}

ULONG64
GetScopeRegVal(ULONG RegId)
{
    PDEBUG_SCOPE Scope = GetCurrentScope();
    
    if (g_EffMachine == IMAGE_FILE_MACHINE_IA64)
    {
        switch (RegId)
        {
        case INTSP:
            return Scope->Frame.StackOffset;
        case RSBSP:
            return Scope->Frame.FrameOffset;
        default:
            // continue
            ;
        }

        CROSS_PLATFORM_CONTEXT Context;

        Context = g_Machine->m_Context;

        return GetRegValIA64(&Context, &Scope->Frame, RegId);
    }
    else if (g_EffMachine == IMAGE_FILE_MACHINE_I386)
    {
        switch (RegId)
        {
        case X86_EBP:
            if (Scope->Frame.FuncTableEntry) 
            {
                PFPO_DATA FpoData = (PFPO_DATA)Scope->Frame.FuncTableEntry;
                if (FpoData->cbFrame == FRAME_FPO)
                {
                    //
                    // Get EBP from FPO data, if available
                    //
                    if (SAVE_EBP(&Scope->Frame)) 
                    {
                        return SAVE_EBP(&Scope->Frame);
                    } 
                    else 
                    {
                        //
                        // Guess the ebp value, in most cases for FPO frames its
                        // a DWORD off frameoffset
                        // 
                        return Scope->Frame.FrameOffset + sizeof(DWORD);
                    }
                }
            }
            return Scope->Frame.FrameOffset;
        case X86_ESP:
            return Scope->Frame.StackOffset;
        default:
            // continue
            ;
        }
    }
    return g_Machine->GetReg64(RegId);
}



/*
*    TranslateAddress
*         Flags            Flags returned by dbghelp
*         Address          IN Address returned by dbghelp
*                          OUT Address of symbol
*         Value            Value of the symbol if its in register
*
*/
BOOL
TranslateAddress(
    IN ULONG        Flags,
    IN ULONG        RegId,
    IN OUT PULONG64 Address,
    OUT PULONG64    Value
    )
{
    PCROSS_PLATFORM_CONTEXT ScopeContext = GetCurrentScopeContext();
    if (ScopeContext)
    {
        g_Machine->PushContext(ScopeContext);
    }
    
    if (Flags & SYMF_REGREL)
    {
        ULONG64 RegContent;
        
        if (RegId)
        {
            RegContent = GetScopeRegVal(RegId);
        }
        else if (Value)
        {
            //
            // *Value has RegID and *Address has Offset
            //
            RegContent = GetScopeRegVal(RegId = (ULONG) *Value);
        }
        else
        {
            DBG_ASSERT(FALSE);
            if (ScopeContext)
            {
                g_Machine->PopContext();
            }
            return FALSE;
        }

        *Address = RegContent + ((LONG64) (LONG) (ULONG) *Address);
#if 0 
        // This is now adjusted in GetScopeRegVal
        if (g_EffMachine == IMAGE_FILE_MACHINE_I386 &&
            RegId == X86_EBP)
        {
            PDEBUG_SCOPE Scope = GetCurrentScope();
            PFPO_DATA pFpoData = (PFPO_DATA)Scope->Frame.FuncTableEntry;
            if (pFpoData &&
                (pFpoData->cbFrame == FRAME_FPO ||
                 pFpoData->cbFrame == FRAME_TRAP))
            {
                // Compensate for FPO's not having ebp
                *Address += sizeof(DWORD);
            }
        }
#endif
    }
    else if (Flags & SYMF_REGISTER)
    {
        if (Value)
        {
            if (RegId)
            {
                *Value = GetScopeRegVal(RegId);
            }
            else
            {
                *Value = GetScopeRegVal((ULONG) *Address);
            }
        }
    }
    else if (Flags & SYMF_FRAMEREL)
    {
        PDEBUG_SCOPE Scope = GetCurrentScope();
        if (Scope->Frame.FrameOffset)
        {
            *Address += Scope->Frame.FrameOffset;
            
            PFPO_DATA pFpoData = (PFPO_DATA)Scope->Frame.FuncTableEntry;
            if (g_EffMachine == IMAGE_FILE_MACHINE_I386 &&
                pFpoData &&
                (pFpoData->cbFrame == FRAME_FPO ||
                 pFpoData->cbFrame == FRAME_TRAP))
            {
                // Compensate for FPO's not having ebp
                *Address += sizeof(DWORD);
            }
        }
        else
        {
            ADDR FP;

            g_Machine->GetFP(&FP);
            FP.flat = (LONG64) FP.flat + *Address;
            *Address = FP.flat;
        }
    }
    if (ScopeContext)
    {
        g_Machine->PopContext();
    }
    return TRUE;
}

void
GetSymbolStdCall(ULONG64 Offset,
                 PCHAR Buffer,
                 ULONG BufferLen,
                 PULONG64 Displacement,
                 PUSHORT StdCallParams
                 )
{
    IMAGEHLP_MODULE64 Mod;

    // Assert that we have at least a minimum amount of space.
    DBG_ASSERT(BufferLen >= sizeof(Mod.ModuleName));
    Buffer[BufferLen - 1] = 0;
    
    // In the past symbolic information would report the
    // size of stdcall arguments, thus the StdCallParams argument
    // could be filled out.  Nowadays we do not have access
    // to this information so just set it to 0xffff, which
    // means unknown.  In the future perhaps this can be
    // turned back on.
    if (StdCallParams != NULL)
    {
        *StdCallParams = 0xffff;
    }

    Mod.SizeOfStruct = sizeof(Mod);
    // SymGetModuleInfo does special things with a -1 offset,
    // so just assume there's never a symbol there and skip the call.
    if (Offset != -1 &&
        SymGetModuleInfo64(g_CurrentProcess->Handle, Offset, &Mod))
    {
        if (SymGetSymFromAddr64(g_CurrentProcess->Handle, Offset,
                                Displacement, g_Sym))
        {
            if (*Displacement == (ULONG64)-1)
            {
                // In some BBT cases dbghelp can tell that an offset
                // is associated with a particular symbol but it
                // doesn't have a valid offset.  Present the symbol
                // but in a way that makes it clear that it's
                // this special case.
                _snprintf(Buffer, BufferLen - 1,
                          "%s!%s <PERF> (%s+0x%I64x)",
                          Mod.ModuleName, g_Sym->Name,
                          Mod.ModuleName, (Offset - Mod.BaseOfImage));
                *Displacement = 0;
            }
            else
            {
                _snprintf(Buffer, BufferLen - 1,
                          "%s!%s", Mod.ModuleName, g_Sym->Name);
            }
            return;
        }
        else
        {
            if (Offset >= Mod.BaseOfImage &&
                Offset <= Mod.BaseOfImage + Mod.ImageSize)
            {
                strcpy(Buffer, Mod.ModuleName);
                *Displacement = Offset - Mod.BaseOfImage;
                return;
            }
        }
    }

    ULONG64 FscBase;

    // XXX drewb - Temporary hack so that stack traces
    // show meaningful symbols for the fast system call
    // code stuck in the shared user data area.
    switch(IsInFastSyscall(Offset, &FscBase))
    {
    case FSC_FOUND:
        strcpy(Buffer, "*SharedUserSystemCall");
        *Displacement = Offset - FscBase;
        return;
    }
    
    *Buffer = 0;
    *Displacement = Offset;
}

BOOL
GetNearSymbol(
    ULONG64 Offset,
    PSTR Buffer,
    ULONG BufferLen,
    PULONG64 Disp,
    LONG Delta
    )
{
    IMAGEHLP_MODULE64 Mod;

    // Assert that we have at least a minimum amount of space.
    DBG_ASSERT(BufferLen >= sizeof(Mod.ModuleName));
    Buffer[BufferLen - 1] = 0;
    
    Mod.SizeOfStruct = sizeof(Mod);
    // SymGetModuleInfo does special things with a -1 offset,
    // so just assume there's never a symbol there and skip the call.
    if (Offset != -1 &&
        SymGetModuleInfo64(g_CurrentProcess->Handle, Offset, &Mod))
    {
        if (SymGetSymFromAddr64(g_CurrentProcess->Handle, Offset, Disp, g_Sym))
        {
            if (Delta < 0)
            {
                while (Delta++ < 0)
                {
                    if (!SymGetSymPrev(g_CurrentProcess->Handle, g_Sym))
                    {
                        return FALSE;
                    }
                }

                if (Disp != NULL)
                {
                    *Disp = Offset - g_Sym->Address;
                }
            }
            else if (Delta > 0)
            {
                while (Delta-- > 0)
                {
                    if (!SymGetSymNext(g_CurrentProcess->Handle, g_Sym))
                    {
                        return FALSE;
                    }
                }

                if (Disp != NULL)
                {
                    *Disp = g_Sym->Address - Offset;
                }
            }

            _snprintf(Buffer, BufferLen - 1,
                      "%s!%s", Mod.ModuleName, g_Sym->Name);
            return TRUE;
        }
        else if (Delta == 0 &&
                 Offset >= Mod.BaseOfImage &&
                 Offset <= Mod.BaseOfImage + Mod.ImageSize)
        {
            strcpy(Buffer, Mod.ModuleName);
            if (Disp != NULL)
            {
                *Disp = Offset - Mod.BaseOfImage;
            }
            return TRUE;
        }
    }

    return FALSE;
}

PDEBUG_IMAGE_INFO
GetImageByIndex(PPROCESS_INFO Process, ULONG Index)
{
    PDEBUG_IMAGE_INFO Image = Process->ImageHead;
    while (Index > 0 && Image != NULL)
    {
        Index--;
        Image = Image->Next;
    }
    return Image;
}

PDEBUG_IMAGE_INFO
GetImageByOffset(PPROCESS_INFO Process, ULONG64 Offset)
{
    PDEBUG_IMAGE_INFO Image = Process->ImageHead;
    while (Image != NULL &&
           (Offset < Image->BaseOfImage ||
            Offset >= Image->BaseOfImage + Image->SizeOfImage))
    {
        Image = Image->Next;
    }
    return Image;
}

PDEBUG_IMAGE_INFO
GetImageByName(PPROCESS_INFO Process, PCSTR Name, INAME Which)
{
    PDEBUG_IMAGE_INFO Image = Process->ImageHead;
    while (Image != NULL)
    {
        PCSTR WhichStr;

        switch(Which)
        {
        case INAME_IMAGE_PATH:
            WhichStr = Image->ImagePath;
            break;
        case INAME_IMAGE_PATH_TAIL:
            WhichStr = PathTail(Image->ImagePath);
            break;
        case INAME_MODULE:
            if (Image->OriginalModuleName[0] &&
                !_stricmp(Image->OriginalModuleName, Name))
            {
                return Image;
            }
            WhichStr = Image->ModuleName;
            break;
        }
        
        if (_stricmp(WhichStr, Name) == 0)
        {
            break;
        }

        Image = Image->Next;
    }
    return Image;
}

#define IMAGE_IS_PATTERN ((PDEBUG_IMAGE_INFO)-1)

PDEBUG_IMAGE_INFO
ParseModuleName(PBOOL ModSpecified)
{
    PSTR    CmdSaved = g_CurCmd;
    CHAR    Name[MAX_MODULE];
    PSTR    Dst = Name;
    CHAR    ch;
    BOOL    HasWild = FALSE;

    //  first, parse out a possible module name, either a '*' or
    //      a string of 'A'-'Z', 'a'-'z', '0'-'9', '_', '~' (or null)

    ch = PeekChar();
    g_CurCmd++;

    while ((ch >= 'A' && ch <= 'Z') ||
           (ch >= 'a' && ch <= 'z') ||
           (ch >= '0' && ch <= '9') ||
           ch == '_' || ch == '~' || ch == '*' || ch == '?')
    {
        if (ch == '*' || ch == '?')
        {
            HasWild = TRUE;
        }
        
        *Dst++ = ch;
        ch = *g_CurCmd++;
    }
    *Dst = '\0';
    g_CurCmd--;

    //  if no '!' after name and white space, then no module specified
    //      restore text pointer and treat as null module (PC current)

    if (PeekChar() == '!')
    {
        g_CurCmd++;
    }
    else
    {
        g_CurCmd = CmdSaved;
        Name[0] = '\0';
    }

    //  Name either has: '*' for all modules,
    //                   '\0' for current module,
    //                   nonnull string for module name.
    *ModSpecified = Name[0] != 0;
    if (HasWild)
    {
        return IMAGE_IS_PATTERN;
    }
    else if (Name[0])
    {
        return GetImageByName(g_CurrentProcess, Name, INAME_MODULE);
    }
    else
    {
        return NULL;
    }
}

BOOL CALLBACK
ParseExamineSymbolInfo(
    PSYMBOL_INFO    SymInfo,
    ULONG           Size,
    PVOID           ExamineInfoArg
    )
{
    PEXAMINE_INFO ExamineInfo = (PEXAMINE_INFO)ExamineInfoArg;
    ULONG64 Address = SymInfo->Address;
    PDEBUG_IMAGE_INFO Image;

    Image = GetImageByOffset(g_CurrentProcess, SymInfo->ModBase);
    if (Image && ((SymInfo->Flags & IMAGEHLP_SYMBOL_INFO_LOCAL) == 0))
    {
        dprintf( "%s  %s!%s",
                 FormatAddr64(Address),
                 Image->ModuleName,
                 SymInfo->Name);
    }
    else
    {
        ULONG64 Value = 0;

        TranslateAddress(SymInfo->Flags, SymInfo->Register,
                         &Address, &Value);
        dprintf( "%s  %s",
                 FormatAddr64(Address),
                 SymInfo->Name);
    }

    if (ExamineInfo->Verbose)
    {
        dprintf(" ");
        ShowSymbolInfo(SymInfo);
    }
    
    dprintf("\n");

    return !CheckUserInterrupt();
}

/*** ParseExamine - parse and execute examine command
*
* Purpose:
*       Parse the current command string and examine the symbol
*       table to display the appropriate entries.  The entries
*       are displayed in increasing string order.  This function
*       accepts underscores, alphabetic, and numeric characters
*       to match as well as the special characters '?', '*', '['-']'.
*
* Input:
*       g_CurCmd - pointer to current command string
*
* Output:
*       offset and string name of symbols displayed
*
*************************************************************************/

void
ParseExamine(void)
{
    CHAR    StringBuf[MAX_SYMBOL_LEN];
    UCHAR   ch;
    PSTR    String = StringBuf;
    PSTR    Start;
    PSTR    ModEnd;
    BOOL    ModSpecified;
    ULONG64 Base = 0;
    ULONG   Count;
    PDEBUG_IMAGE_INFO Image;
    EXAMINE_INFO ExamineInfo;

    // Get module pointer from name in command line (<string>!).

    PeekChar();
    Start = g_CurCmd;
    
    Image = ParseModuleName(&ModSpecified);

    ModEnd = g_CurCmd;
    ch = PeekChar();

    // Special case the command "x <pattern>!" to dump out the module table.
    if (Image == IMAGE_IS_PATTERN &&
        (ch == ';' || ch == '\0'))
    {
        *(ModEnd - 1) = 0;
        _strupr(Start);
        DumpModuleTable(DMT_STANDARD, Start);
        return;
    }

    if (ModSpecified)
    {
        if (Image == NULL)
        {
            // The user specified a module that doesn't exist.
            error(VARDEF);
        }
        else if (Image == IMAGE_IS_PATTERN)
        {
            // The user gave a pattern string for the module
            // so we need to pass it on for dbghelp to scan with.
            memcpy(String, Start, (ModEnd - Start));
            String += ModEnd - Start;
        }
        else
        {
            // A specific image was given and found so
            // confine the search to that one image.
            Base = Image->BaseOfImage;
        }
    }
    
    g_CurCmd++;

    // Condense leading underscores into a "_#" 
    // that will match zero or more underscores.  This causes all
    // underscore-prefixed symbols to match the base symbol name
    // when the pattern is prefixed by an underscore.
    if (ch == '_')
    {
        *String++ = '_';
        *String++ = '#';
        do
        {
            ch = *g_CurCmd++;
        } while (ch == '_');
    }

    ch = (UCHAR)toupper(ch);
    while (ch && ch != ';' && ch != ' ')
    {
        *String++ = ch;
        ch = (CHAR)toupper(*g_CurCmd);
        g_CurCmd++;
    }
    *String = '\0';
    g_CurCmd--;

    ExamineInfo.Verbose = TRUE;

    // We nee the scope for all cases since param values are displayed for 
    // function in scope
    RequireCurrentScope();

    SymEnumSymbols(g_CurrentProcess->Handle,
                   Base,
                   StringBuf,
                   ParseExamineSymbolInfo,
                   &ExamineInfo);
}

/*** fnListNear - function to list symbols near an address
*
*  Purpose:
*       from the address specified, access the symbol table to
*       find the closest symbolic addresses both before and after
*       it.  output these on one line (if spaces permits).
*
*  Input:
*       addrstart - address to base listing
*
*  Output:
*       symbolic and absolute addresses of variable on or before
*       and after the specified address
*
*************************************************************************/

void
fnListNear(ULONG64 AddrStart)
{
    ULONG64 Displacement;
    IMAGEHLP_MODULE64 Mod;

    if (g_SrcOptions & SRCOPT_LIST_LINE)
    {
        OutputLineAddr(AddrStart);
    }

    if (SymGetSymFromAddr64(g_CurrentProcess->Handle, AddrStart,
                            &Displacement, g_Sym))
    {
        Mod.SizeOfStruct = sizeof(Mod);
        if (!SymGetModuleInfo64(g_CurrentProcess->Handle, AddrStart, &Mod))
        {
            return;
        }

        dprintf("(%s)   %s!%s",
                FormatAddr64(g_Sym->Address),
                Mod.ModuleName,
                g_Sym->Name);

        if (Displacement)
        {
            dprintf("+0x%s   ", FormatDisp64(Displacement));
        }
        else
        {
            dprintf("   ");
        }

        if (SymGetSymNext64(g_CurrentProcess->Handle, g_Sym))
        {
            dprintf("|  (%s)   %s!%s",
                    FormatAddr64(g_Sym->Address),
                    Mod.ModuleName,
                    g_Sym->Name);
        }
        dprintf("\n");
    }
}

void
DumpModuleTable(ULONG Flags, PSTR Pattern)
{
    PDEBUG_IMAGE_INFO Image;
    IMAGEHLP_MODULE64 mi;
    DBH_MODSYMINFO SymFile;
    ULONG i;

    if (g_TargetMachine->m_Ptr64)
    {
        dprintf("start             end                 module name\n");
    }
    else
    {
        dprintf("start    end        module name\n");
    }

    Image = g_CurrentProcess->ImageHead;
    while (Image)
    {
        ULONG PrimaryName;
        PSTR Names[DMT_NAME_COUNT];
        
        if (Pattern != NULL &&
            !MatchPattern(Image->ModuleName, Pattern))
        {
            Image = Image->Next;
            continue;
        }
        
        mi.SizeOfStruct = sizeof(mi);
        if (!SymGetModuleInfo64( g_CurrentProcess->Handle,
                                 Image->BaseOfImage, &mi ))
        {
            mi.SymType = SymNone;
        }

        if (Flags & (DMT_SYM_FILE_NAME | DMT_VERBOSE))
        {
            SymFile.function = dbhModSymInfo;
            SymFile.sizeofstruct = sizeof(SymFile);
            SymFile.addr = Image->BaseOfImage;
            if (!dbghelp(g_CurrentProcess->Handle, &SymFile))
            {
                sprintf(SymFile.file, "<Error: %s>",
                        FormatStatusCode(WIN32_LAST_STATUS()));
            }
        }
        else
        {
            SymFile.file[0] = 0;
        }

        Names[DMT_NAME_SYM_IMAGE] = mi.LoadedImageName;
        Names[DMT_NAME_SYM_FILE] = SymFile.file;
        Names[DMT_NAME_MAPPED_IMAGE] = Image->MappedImagePath;
        Names[DMT_NAME_IMAGE_PATH] = Image->ImagePath;
        
        if (Flags & DMT_SYM_FILE_NAME)
        {
            PrimaryName = DMT_NAME_SYM_FILE;
        }
        else if (Flags & DMT_MAPPED_IMAGE_NAME)
        {
            PrimaryName = DMT_NAME_MAPPED_IMAGE;
        }
        else if (Flags & DMT_IMAGE_PATH_NAME)
        {
            PrimaryName = DMT_NAME_IMAGE_PATH;
        }
        else
        {
            PrimaryName = DMT_NAME_SYM_IMAGE;
        }
        
        //
        // Skip modules filtered by flags
        //
        if ((Flags & DMT_ONLY_LOADED_SYMBOLS) &&
            (mi.SymType == SymDeferred))
        {
            Image = Image->Next;
            continue;
        }

        if (IS_KERNEL_TARGET())
        {
            if ((Flags & DMT_ONLY_USER_SYMBOLS) &&
                (Image->BaseOfImage >= g_SystemRangeStart))
            {
                Image = Image->Next;
                continue;
            }

            if ((Flags & DMT_ONLY_KERNEL_SYMBOLS) &&
                (Image->BaseOfImage <= g_SystemRangeStart))
            {
                Image = Image->Next;
                continue;
            }
        }

        _strlwr( Image->ModuleName );

        dprintf( "%s %s   %-8s   ",
                 FormatAddr64(Image->BaseOfImage),
                 FormatAddr64(Image->BaseOfImage + Image->SizeOfImage),
                 Image->ModuleName
               );

        if (Flags & DMT_NO_SYMBOL_OUTPUT) 
        {
            goto SkipSymbolOutput;
        }
        if (PrimaryName == DMT_NAME_MAPPED_IMAGE ||
            PrimaryName == DMT_NAME_IMAGE_PATH)
        {
            dprintf("  %s\n",
                    *Names[PrimaryName] ? Names[PrimaryName] : "<none>");
            goto SkipSymbolOutput;
        }
        
        switch (Image->GoodCheckSum)
        {
        case DII_GOOD_CHECKSUM:
            dprintf( "  " );
            break;
        case DII_UNKNOWN_TIMESTAMP:
            dprintf( "T " );
            break;
        case DII_UNKNOWN_CHECKSUM:
            dprintf( "C " );
            break;
        case DII_BAD_CHECKSUM:
            dprintf( "# " );
            break;
        }

        if (mi.SymType == SymDeferred)
        {
            dprintf( "(deferred)                 " );
        }
        else if (mi.SymType == SymNone)
        {
            dprintf( "(no symbolic information)  " );
        }
        else
        {
            switch ( mi.SymType )
            {
            case SymCoff:
                dprintf( "(coff symbols)             " );
                break;

            case SymCv:
                dprintf( "(codeview symbols)         " );
                break;

            case SymPdb:
                dprintf( "(pdb symbols)              " );
                break;

            case SymExport:
                dprintf( "(export symbols)           " );
                break;
            }
            
            dprintf("%s", *Names[PrimaryName] ? Names[PrimaryName] : "<none>");
        }

        dprintf("\n");

    SkipSymbolOutput:
        if (Flags & DMT_VERBOSE)
        {

            for (i = 0; i < DMT_NAME_COUNT; i++)
            {
                if (i != PrimaryName && *Names[i])
                {
                    dprintf("    %s: %s\n", g_DmtNameDescs[i], Names[i]);
                }
            }
        }
        if (Flags & (DMT_VERBOSE | DMT_IMAGE_TIMESTAMP))
        {
            LPSTR TimeDateStr = TimeToStr(Image->TimeDateStamp);
            dprintf("    Checksum: %08X  Timestamp: %s (%08X)\n",
                    Image->CheckSum, TimeDateStr, Image->TimeDateStamp);
            
        }
        if (Flags & DMT_VERBOSE)
        {

            VS_FIXEDFILEINFO FixedVer;

            if (g_Target->GetImageVersionInformation
                (Image->ImagePath, Image->BaseOfImage, "\\",
                 &FixedVer, sizeof(FixedVer), NULL) == S_OK)
            {
                char Item[64];
                char VerString[128];
                
                dprintf("    File version: %d.%d.%d.%d"
                        "  Product version: %d.%d.%d.%d\n",
                        FixedVer.dwFileVersionMS >> 16,
                        FixedVer.dwFileVersionMS & 0xFFFF,
                        FixedVer.dwFileVersionLS >> 16,
                        FixedVer.dwFileVersionLS & 0xFFFF,
                        FixedVer.dwProductVersionMS >> 16,
                        FixedVer.dwProductVersionMS & 0xFFFF,
                        FixedVer.dwProductVersionLS >> 16,
                        FixedVer.dwProductVersionLS & 0xFFFF);
                dprintf("    File flags: %X (Mask %X)  File OS: %X  "
                        "File type: %X.%X\n",
                        FixedVer.dwFileFlags & FixedVer.dwFileFlagsMask,
                        FixedVer.dwFileFlagsMask, FixedVer.dwFileOS,
                        FixedVer.dwFileType, FixedVer.dwFileSubtype);
                dprintf("    File date: %08X.%08X\n",
                        FixedVer.dwFileDateMS, FixedVer.dwFileDateLS);
                
                sprintf(Item, "\\StringFileInfo\\%04x%04x\\FileVersion",
                        VER_VERSION_TRANSLATION);
                if (SUCCEEDED(g_Target->GetImageVersionInformation
                              (Image->ImagePath, Image->BaseOfImage, Item,
                               VerString, sizeof(VerString), NULL)))
                {
                    dprintf("    Version string: %s\n", VerString);
                }
            }
        }

        if (CheckUserInterrupt())
        {
            break;
        }

        Image = Image->Next;
    }

    UnloadedModuleInfo* Unl;
    
    if ((Flags & (DMT_ONLY_LOADED_SYMBOLS | DMT_ONLY_USER_SYMBOLS)) == 0)
    {
        ULONG LumFlags = LUM_OUTPUT;

        LumFlags |= ((Flags & DMT_VERBOSE) ? LUM_OUTPUT_VERBOSE : 0);
        LumFlags |= ((Flags & DMT_IMAGE_TIMESTAMP) ? LUM_OUTPUT_TIMESTAMP : 0);
        dprintf("\n");
        ListUnloadedModules(LumFlags, Pattern);
    }
}

void
ParseDumpModuleTable(void)
{
    ULONG Flags = DMT_STANDARD;
    char Pattern[MAX_MODULE];
    PSTR Pat = NULL;

    g_CurCmd++;

    for (;;)
    {
        // skip white space
        while (isspace(*g_CurCmd))
        {
            g_CurCmd++;
        }

        if (*g_CurCmd == 'f')
        {
            Flags = (Flags & ~DMT_NAME_FLAGS) | DMT_IMAGE_PATH_NAME;
            g_CurCmd++;
        }
        else if (*g_CurCmd == 'i')
        {
            Flags = (Flags & ~DMT_NAME_FLAGS) | DMT_SYM_IMAGE_FILE_NAME;
            g_CurCmd++;
        }
        else if (*g_CurCmd == 'l')
        {
            Flags |= DMT_ONLY_LOADED_SYMBOLS;
            g_CurCmd++;
        }
        else if (*g_CurCmd == 'm')
        {
            g_CurCmd++;
            // skip white space
            while (isspace(*g_CurCmd))
            {
                g_CurCmd++;
            }
            Pat = Pattern;
            while (*g_CurCmd && !isspace(*g_CurCmd))
            {
                if ((Pat - Pattern) < sizeof(Pattern) - 1)
                {
                    *Pat++ = *g_CurCmd;
                }
                
                g_CurCmd++;
            }
            *Pat = 0;
            Pat = Pattern;
            _strupr(Pat);
        }
        else if (*g_CurCmd == 'p')
        {
            Flags = (Flags & ~DMT_NAME_FLAGS) | DMT_MAPPED_IMAGE_NAME;
            g_CurCmd++;
        }
        else if (*g_CurCmd == 't')
        {
            Flags = (Flags & ~(DMT_NAME_FLAGS)) | DMT_NAME_SYM_IMAGE | DMT_IMAGE_TIMESTAMP
                | DMT_NO_SYMBOL_OUTPUT;
            g_CurCmd++;
        }
        else if (*g_CurCmd == 'v')
        {
            Flags |= DMT_VERBOSE;
            g_CurCmd++;
        }
        else if (IS_KERNEL_TARGET())
        {
            if (*g_CurCmd == 'u')
            {
                Flags |= DMT_ONLY_USER_SYMBOLS;
                g_CurCmd++;
            }
            else if (*g_CurCmd == 'k')
            {
                Flags |= DMT_ONLY_KERNEL_SYMBOLS;
                g_CurCmd++;
            }
            else
            {
                break;
            }
        }
        else
        {
            break;
        }
    }

    DumpModuleTable(Flags, Pat);
}

void
GetCurrentMemoryOffsets (
                        PULONG64 pMemoryLow,
                        PULONG64 pMemoryHigh
                        )
{
    *pMemoryLow = (ULONG64)(LONG64)-1;          //  default value for no source
}


ULONG
ReadImageData(
    ULONG64 Address,
    HANDLE  hFile,
    LPVOID  Buffer,
    ULONG   Size
    )
{
    if (hFile)
    {
        ULONG   Result;

        if (!SetFilePointer( hFile, (ULONG)Address, NULL, FILE_BEGIN ))
        {
            return 0;
        }

        if (!ReadFile( hFile, Buffer, Size, &Result, NULL))
        {
            return 0;
        }
    }
    else
    {
        ULONG Result;

        if (g_Target->ReadVirtual(Address, Buffer, Size, &Result) != S_OK ||
            Result < Size)
        {
            return 0;
        }
    }

    return Size;
}

BOOL
GetModnameFromImageInternal(ULONG64 BaseOfDll,
                            HANDLE  hFile,
                            LPSTR   lpName,
                            ULONG   NameSize
                            )
{
    IMAGE_DEBUG_DIRECTORY       DebugDir;
    PIMAGE_DEBUG_MISC           pMisc;
    PIMAGE_DEBUG_MISC           pT;
    DWORD                       rva;
    int                         nDebugDirs;
    int                         i;
    int                         j;
    int                         l;
    BOOL                        rVal = FALSE;
    PVOID                       pExeName;
    IMAGE_DOS_HEADER            dh;
    USHORT                      NumberOfSections;
    USHORT                      Characteristics;
    ULONG64                     address;
    DWORD                       sig;
    PIMAGE_SECTION_HEADER       pSH = NULL;
    DWORD                       cb;
    NTSTATUS                    Status;
    ULONG                       Result;
    IMAGE_NT_HEADERS64          nh64;
    PIMAGE_NT_HEADERS32         pnh32 = (PIMAGE_NT_HEADERS32) &nh64;
    BOOL                        fCheckDllExtensionInExportTable = FALSE;


    lpName[0] = 0;

    if (hFile)
    {
        BaseOfDll = 0;
    }

    address = BaseOfDll;

    ReadImageData( address, hFile, &dh, sizeof(dh) );

    if (dh.e_magic == IMAGE_DOS_SIGNATURE)
    {
        address += dh.e_lfanew;
    }

    ReadImageData( address, hFile, &sig, sizeof(sig) );

    if (sig != IMAGE_NT_SIGNATURE)
    {
        IMAGE_FILE_HEADER            fh;
        IMAGE_ROM_OPTIONAL_HEADER   rom;

        ReadImageData( address, hFile, &fh, sizeof(IMAGE_FILE_HEADER) );
        address += sizeof(IMAGE_FILE_HEADER);
        ReadImageData( address, hFile, &rom, sizeof(rom) );
        address += sizeof(rom);

        if (rom.Magic == IMAGE_ROM_OPTIONAL_HDR_MAGIC)
        {
            NumberOfSections = fh.NumberOfSections;
            Characteristics = fh.Characteristics;
            nDebugDirs = rva = 0;
        }
        else
        {
            goto Finish;
        }
    }
    else
    {
        //
        // read the head as a 64 bit header and cast it appropriately.
        //

        ReadImageData( address, hFile, &nh64, sizeof(nh64) );

        if (IsImageMachineType64(pnh32->FileHeader.Machine))
        {
            address += sizeof(IMAGE_NT_HEADERS64);
            NumberOfSections = nh64.FileHeader.NumberOfSections;
            Characteristics = nh64.FileHeader.Characteristics;
            nDebugDirs = nh64.OptionalHeader.
                DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size /
                sizeof(IMAGE_DEBUG_DIRECTORY);
            rva = nh64.OptionalHeader.
                DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;
        }
        else
        {
            address += sizeof(IMAGE_NT_HEADERS32);
            NumberOfSections = pnh32->FileHeader.NumberOfSections;
            Characteristics = pnh32->FileHeader.Characteristics;
            nDebugDirs = pnh32->OptionalHeader.
                DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size /
                sizeof(IMAGE_DEBUG_DIRECTORY);
            rva = pnh32->OptionalHeader.
                DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;
        }
    }


    // After this point, none of the image datastructures have changed between
    // 32bit NT and 64bit NT.

    cb = NumberOfSections * IMAGE_SIZEOF_SECTION_HEADER;
    pSH = (PIMAGE_SECTION_HEADER)malloc( cb );
    if (!pSH)
    {
        goto Finish;
    }

    if (!ReadImageData( address, hFile, pSH, cb ))
    {
        goto Finish;
    }

    if (!nDebugDirs)
    {
        goto CheckExportTable;
    }

    for (i = 0; i < NumberOfSections; i++)
    {
        if (rva >= pSH[i].VirtualAddress &&
            rva < pSH[i].VirtualAddress + pSH[i].SizeOfRawData)
        {
            break;
        }
    }

    if (i >= NumberOfSections)
    {
        goto CheckExportTable;
    }

    rva = rva - pSH[i].VirtualAddress;
    if (hFile)
    {
        rva += pSH[i].PointerToRawData;
    }
    else
    {
        rva += pSH[i].VirtualAddress;
    }

    for (j = 0; j < nDebugDirs; j++)
    {
        ReadImageData( rva + (sizeof(DebugDir) * j) + BaseOfDll,
                       hFile, &DebugDir, sizeof(DebugDir) );

        if (DebugDir.Type == IMAGE_DEBUG_TYPE_MISC)
        {
            l = DebugDir.SizeOfData;
            pMisc = pT = (PIMAGE_DEBUG_MISC)malloc(l);

            if (!pMisc)
            {
                break;
            }

            if (!hFile &&
                ((ULONG)DebugDir.AddressOfRawData < pSH[i].VirtualAddress ||
                 (ULONG)DebugDir.AddressOfRawData >=
                 pSH[i].VirtualAddress + pSH[i].SizeOfRawData))
            {
                //
                // the misc debug data MUST be in the .rdata section
                // otherwise the debugger cannot access it as it is not
                // mapped in.
                //
                break;
            }

            if (hFile)
            {
                address = DebugDir.PointerToRawData;
            }
            else
            {
                address = DebugDir.AddressOfRawData + BaseOfDll;
            }

            ReadImageData( address, hFile, pMisc, l );

            while (l > 0)
            {
                if (pMisc->DataType != IMAGE_DEBUG_MISC_EXENAME)
                {
                    //
                    // beware corrupt images:
                    //
                    if (pMisc->Length == 0 ||
                        pMisc->Length > (ULONG)l)
                    {
                        break;
                    }
                    l -= pMisc->Length;
                    pMisc = (PIMAGE_DEBUG_MISC)
                            (((LPSTR)pMisc) + pMisc->Length);
                }
                else
                {
                    pExeName = (PVOID)&pMisc->Data[ 0 ];

                    if (!pMisc->Unicode)
                    {
                        strncat(lpName, (LPSTR)pExeName, NameSize - 1);
                        rVal = TRUE;
                    }
                    else
                    {
                        WideCharToMultiByte(CP_ACP,
                                            0,
                                            (LPWSTR)pExeName,
                                            -1,
                                            lpName,
                                            NameSize,
                                            NULL,
                                            NULL);
                        rVal = TRUE;
                    }

                    //
                    //  Undo stevewo's error
                    //

                    if (_stricmp(&lpName[strlen(lpName) - 4], ".DBG") == 0)
                    {
                        char    rgchPath[MAX_IMAGE_PATH];
                        char    rgchBase[_MAX_FNAME];

                        _splitpath(lpName, NULL, rgchPath, rgchBase, NULL);
                        if (strlen(rgchPath) == 4)
                        {
                            rgchPath[strlen(rgchPath) - 1] = 0;
                            strcpy(lpName, rgchBase);
                            strcat(lpName, ".");
                            strcat(lpName, rgchPath);
                        }
                        else if (Characteristics & IMAGE_FILE_DLL)
                        {
                            strcpy(lpName, rgchBase);
                            strcat(lpName, ".dll");
                        }
                        else
                        {
                            strcpy(lpName, rgchBase);
                            strcat(lpName, ".exe");
                        }
                    }
                    break;
                }
            }

            free(pT);

            break;
        }
        else if ((DebugDir.Type == IMAGE_DEBUG_TYPE_CODEVIEW) &&
                 ((!hFile && DebugDir.AddressOfRawData) ||
                  (hFile && DebugDir.PointerToRawData)) &&
                 (DebugDir.SizeOfData > sizeof(NB10IH)))
        {
            DWORD   Signature;
            char    rgchPath[MAX_IMAGE_PATH];
            char    rgchBase[_MAX_FNAME];

            // Mapped CV info.  Read the data and see what the content is.

            if (hFile)
            {
                address = DebugDir.PointerToRawData;
            }
            else
            {
                address = DebugDir.AddressOfRawData + BaseOfDll;
            }

            if (!ReadImageData( address, hFile, &Signature,
                                sizeof(Signature) ))
            {
                break;
            }

            // NB10 or PDB7 signature?
            if (Signature == NB10_SIG ||
                Signature == RSDS_SIG)
            {
                ULONG HdrSize = Signature == NB10_SIG ?
                    sizeof(NB10IH) : sizeof(RSDSIH);
                
                address += HdrSize;

                if ((DebugDir.SizeOfData - sizeof(HdrSize)) > MAX_PATH)
                {
                    // Something's wrong here.  The record should only contain
                    // a MAX_PATH path name.
                    break;
                }

                if (DebugDir.SizeOfData - HdrSize > NameSize)
                {
                    break;
                }
                if (!ReadImageData(address, hFile, lpName,
                                   DebugDir.SizeOfData - HdrSize))
                {
                    break;
                }

                _splitpath(lpName, NULL, rgchPath, rgchBase, NULL);

                // Files are sometimes generated with .pdb appended
                // to the image name rather than replacing the extension
                // of the image name, such as foo.exe.pdb.
                // splitpath only takes off the outermost extension,
                // so check and see if the base already has an extension
                // we recognize.
                PSTR Ext = strrchr(rgchBase, '.');
                if (Ext != NULL &&
                    (!strcmp(Ext, ".exe") || !strcmp(Ext, ".dll") ||
                     !strcmp(Ext, ".sys")))
                {
                    // The base already has an extension so use
                    // it as-is.
                    strcpy(lpName, rgchBase);
                    fCheckDllExtensionInExportTable = !strcmp(Ext, ".dll");
                }
                else if (Characteristics & IMAGE_FILE_DLL)
                {
                    strcpy(lpName, rgchBase);
                    strcat(lpName, ".dll");
                    fCheckDllExtensionInExportTable = TRUE;
                }
                else
                {
                    strcpy(lpName, rgchBase);
                    strcat(lpName, ".exe");
                }

                rVal = TRUE;
            }
        }
    }

    if (!rVal || fCheckDllExtensionInExportTable)
    {
        CHAR Char;
        ULONG64 ExportNameRva;
        char FileName[MAX_IMAGE_PATH];
        int x;

        ExportNameRva = 0;

CheckExportTable:

        // No luck wandering the debug info.  Try the export table.

        if (IsImageMachineType64(pnh32->FileHeader.Machine))
        {
            rva = nh64.OptionalHeader.
                DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
        }
        else
        {
            rva = pnh32->OptionalHeader.
                DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
        }

        if (!rva)
        {
            goto Finish;
        }

        for (i = 0; i < NumberOfSections; i++)
        {
            if (rva >= pSH[i].VirtualAddress &&
                rva < pSH[i].VirtualAddress + pSH[i].SizeOfRawData)
            {
                break;
            }
        }

        if (i >= NumberOfSections)
        {
            goto Finish;
        }

        if (hFile)
        {
            rva = rva - pSH[i].VirtualAddress + pSH[i].PointerToRawData;
        }

        if (!ReadImageData( rva + offsetof(IMAGE_EXPORT_DIRECTORY, Name) +
                            BaseOfDll, hFile, &ExportNameRva, sizeof(DWORD)))
        {
            goto Finish;
        }

        if (hFile)
        {
            ExportNameRva = ExportNameRva - pSH[i].VirtualAddress +
                            pSH[i].PointerToRawData;
        }

        ExportNameRva += BaseOfDll;

        rVal = TRUE;
        x = 0;
        do
        {
            if (!ReadImageData( ExportNameRva,
                                hFile, &Char, sizeof(Char)))
            {
                rVal = FALSE;
                break;
            }
            ExportNameRva++;
            FileName[x] = Char;
            x++;
        } while (Char && (x < sizeof(FileName)));

        if (fCheckDllExtensionInExportTable)
        {
            char rgchExtFromExportTable[_MAX_EXT];

            _splitpath(FileName, NULL, NULL, NULL, rgchExtFromExportTable);
            if (_stricmp(rgchExtFromExportTable, ".dll"))
            {
                // Export table has something different.
                // Use it with our base name.
                strcpy(lpName + strlen(lpName) - 4,
                       rgchExtFromExportTable);
            }
        }
        else
        {
            lpName[0] = 0;
            strncat(lpName, FileName, NameSize - 1);
        }
    }

 Finish:
    if (pSH)
    {
        free(pSH);
    }

    return rVal;
}

BOOL
GetModnameFromImage(ULONG64   BaseOfDll,
                    HANDLE    hFile,
                    LPSTR     lpName,
                    ULONG     NameSize)
{
    BOOL Status = GetModnameFromImageInternal( BaseOfDll, NULL,
                                               lpName, NameSize );
    if (!Status && hFile != NULL)
    {
        Status = GetModnameFromImageInternal( BaseOfDll, hFile,
                                              lpName, NameSize );
    }
    return Status;
}


BOOL
GetHeaderInfo(
    IN  ULONG64     BaseOfDll,
    OUT LPDWORD     CheckSum,
    OUT LPDWORD     TimeDateStamp,
    OUT LPDWORD     SizeOfImage
    )
{
    IMAGE_NT_HEADERS32          nh32;
    IMAGE_DOS_HEADER            dh;
    ULONG64                   address;
    DWORD                       sig;


    address = BaseOfDll;

    ReadImageData( address, NULL, &dh, sizeof(dh) );

    if (dh.e_magic == IMAGE_DOS_SIGNATURE) {
        address += dh.e_lfanew;
    }

    ReadImageData( address, NULL, &sig, sizeof(sig) );

    if (sig != IMAGE_NT_SIGNATURE) {

        IMAGE_FILE_HEADER fh;
        ReadImageData( address, NULL, &fh, sizeof(IMAGE_FILE_HEADER) );

        *CheckSum      = 0;
        *TimeDateStamp = fh.TimeDateStamp;
        *SizeOfImage   = 0;

        return TRUE;
    }

    // Attempt to read as a 32bit header, then reread if the image type is 64bit.
    // This works because IMAGE_FILE_HEADER, which is at the start of the IMAGE_NT_HEADERS,
    // is the same on 32bit NT and 64bit NT and IMAGE_NT_HEADER32 <= IMAGE_NT_HEADER64.
    ReadImageData( address, NULL, &nh32, sizeof(nh32) );

    if (IsImageMachineType64(nh32.FileHeader.Machine)) {

        // Image is 64bit.  Reread as a 64bit structure.
        IMAGE_NT_HEADERS64          nh64;

       ReadImageData( address, NULL, &nh64, sizeof(nh64) );

        *CheckSum      = nh64.OptionalHeader.CheckSum;
        *TimeDateStamp = nh64.FileHeader.TimeDateStamp;
        *SizeOfImage   = nh64.OptionalHeader.SizeOfImage;
    }

    else {
        *CheckSum      = nh32.OptionalHeader.CheckSum;
        *TimeDateStamp = nh32.FileHeader.TimeDateStamp;
        *SizeOfImage   = nh32.OptionalHeader.SizeOfImage;
    }

    return TRUE;
}

PCSTR
PrependPrefixToSymbol( char   PrefixedString[],
                       PCSTR  pString,
                       PCSTR *RegString
                       )
{
    if ( RegString )
    {
        *RegString = NULL;
    }

    PCSTR bangPtr;
    int   bang = '!';
    PCSTR Tail;

    bangPtr = strchr( pString, bang );
    if ( bangPtr )
    {
        Tail = bangPtr + 1;
    }
    else
    {
        Tail = pString;
    }

    if ( strncmp( Tail, g_Machine->m_SymPrefix, g_Machine->m_SymPrefixLen ) )
    {
        ULONG Loc = (ULONG)(Tail - pString);
        if (Loc > 0)
        {
            memcpy( PrefixedString, pString, Loc );
        }
        memcpy( PrefixedString + Loc, g_Machine->m_SymPrefix,
                g_Machine->m_SymPrefixLen );
        if ( RegString )
        {
            *RegString = &PrefixedString[Loc];
        }
        Loc += g_Machine->m_SymPrefixLen;
        strcpy( &PrefixedString[Loc], Tail );
        return PrefixedString;
    }
    else
    {
        return pString;
    }
}

BOOL
ForceSymbolCodeAddress(PSYMBOL_INFO Symbol, MachineInfo* Machine)
{
    ULONG64 Code = Symbol->Address;
        
    if (Symbol->Flags & SYMF_FORWARDER)
    {
        char Fwd[2 * MAX_PATH];
        ULONG Read;
        PSTR Sep;
        
        // The address of a forwarder entry points to the
        // string name of the function that things are forwarded
        // to.  Look up that name and try to get the address
        // from it.
        if (g_Target->ReadVirtual(Symbol->Address, Fwd, sizeof(Fwd),
                                  &Read) != S_OK ||
            Read < 2)
        {
            ErrOut("Unable to read forwarder string\n");
            return FALSE;
        }

        Fwd[sizeof(Fwd) - 1] = 0;
        if (!(Sep = strchr(Fwd, '.')))
        {
            ErrOut("Unable to read forwarder string\n");
            return FALSE;
        }
        
        *Sep = '!';
        if (GetOffsetFromSym(Fwd, &Code, NULL) != 1)
        {
            ErrOut("Unable to get address of forwarder '%s'\n", Fwd);
            return FALSE;
        }
    }
    else if (Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_IA64 &&
             (Symbol->Flags & SYMF_EXPORT))
    {
        // On IA64 the export entries contain the address
        // of the plabel.  We want the actual code address
        // so resolve the plabel to its code.
        if (!Machine->GetPrefixedSymbolOffset(Symbol->Address,
                                              GETPREF_VERBOSE,
                                              &Code))
        {
            return FALSE;
        }
    }

    Symbol->Address = Code;
    return TRUE;
}

/*** GetOffsetFromSym - return offset from symbol specified
*
* Purpose:
*       external routine.
*       With the specified symbol, set the pointer to
*       its offset.  The variable chSymbolSuffix may
*       be used to append a character to repeat the search
*       if it first fails.
*
* Input:
*       pString - pointer to input symbol
*
* Output:
*       pOffset - pointer to offset to be set
*
* Returns:
*       BOOL value of success
*
*************************************************************************/

#ifndef _DBGHELP_USER_GENERATED_SYMBOLS_NOTSUPPORTED

extern "C" {

BOOL
IMAGEAPI
SymSetSymWithAddr64(
      IN  HANDLE             hProcess,
      IN  DWORD64            qwAddr,
      IN  LPSTR              SymString,
      OUT PIMAGEHLP_SYMBOL64 Symbol
   );

}

#endif // ! _DBGHELP_USER_GENERATED_SYMBOLS_NOTSUPPORTED

BOOL
GetOffsetFromMod(
    PCSTR pString,
    PULONG64 pOffset
    )
{
    if (!strchr(pString, '!'))
    {
        // Could be a module name
        PDEBUG_IMAGE_INFO pImage = g_CurrentProcess->ImageHead;

        while (pImage)
        { 
            if (!_stricmp(pString, &pImage->ModuleName[0]) ||
                (pImage->OriginalModuleName[0] && 
                 !_stricmp(pString, &pImage->OriginalModuleName[0])))
            {
                *pOffset = pImage->BaseOfImage;
                return TRUE;
            }
            pImage = pImage->Next;
        }
    }
    return FALSE;
}

BOOL
IgnoreEnumeratedSymbol(class MachineInfo* Machine,
                       PSYMBOL_INFO SymInfo)
{
    ULONG64 Func;

    //
    // IA64 plabels are publics with the same name
    // as the function they refer to.  This causes
    // ambiguity problems as we end up with two
    // hits.  The plabel is rarely interesting, though,
    // so just filter them out here so that expressions
    // always evaluate to the function itself.
    //

    if (Machine->m_ExecTypes[0] != IMAGE_FILE_MACHINE_IA64 ||
        SymInfo->Scope != SymTagPublicSymbol ||
        SymInfo->Flags & SYMF_FUNCTION ||
        !Machine->GetPrefixedSymbolOffset(SymInfo->Address, 0, &Func))
    {
        return FALSE;
    }
    
    PSTR FuncSym;
            
    __try
    {
        FuncSym = (PSTR)alloca(MAX_SYMBOL_LEN * 2);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        FuncSym = NULL;
    }

    if (FuncSym == NULL)
    {
        return FALSE;
    }

    SYMBOL_INFO LocalSymInfo;
    
    // We have to save and restore the original data as
    // dbghelp always uses a single buffer to store all
    // symbol information.  The incoming symbol info
    // is going to be wiped out when we
    // call GetSymbolStdCall.
    LocalSymInfo = *SymInfo;
    strcpy(FuncSym + MAX_SYMBOL_LEN, SymInfo->Name);
    
    ULONG64 FuncSymDisp;

    GetSymbolStdCall(Func, FuncSym, MAX_SYMBOL_LEN,
                     &FuncSymDisp, NULL);

    *SymInfo = LocalSymInfo;
    strcpy(SymInfo->Name, FuncSym + MAX_SYMBOL_LEN);
    return FuncSymDisp == 0 && strstr(FuncSym, SymInfo->Name);
}
    
struct COUNT_SYMBOL_MATCHES
{
    MachineInfo* Machine;
    SYMBOL_INFO ReturnSymInfo;
    CHAR        SymbolNameOverflowBuffer[MAX_SYMBOL_LEN];
    ULONG Matches;
};

BOOL CALLBACK
CountSymbolMatches(
    PSYMBOL_INFO    SymInfo,
    ULONG           Size,
    PVOID           UserContext
    )
{
    COUNT_SYMBOL_MATCHES* Context =
        (COUNT_SYMBOL_MATCHES*)UserContext;

    if (IgnoreEnumeratedSymbol(Context->Machine, SymInfo))
    {
        return TRUE;
    }
    
    if (Context->Matches == 1) 
    {
        // We already have one match, check if we got a duplicate.
        if ((SymInfo->Address == Context->ReturnSymInfo.Address) &&
            !strcmp(SymInfo->Name, Context->ReturnSymInfo.Name)) 
        {
            // Looks like the same symbol, ignore it.
            return TRUE;
        }
    }

    Context->ReturnSymInfo = *SymInfo;
    if (SymInfo->NameLen < MAX_SYMBOL_LEN) 
    {
        strcpy(Context->ReturnSymInfo.Name, SymInfo->Name);
    }
    Context->Matches++;

    return TRUE;
}

ULONG
MultiSymFromName(IN  HANDLE       Process,
                 IN  LPSTR        Name,
                 IN  ULONG64      ImageBase,
                 IN  MachineInfo* Machine,
                 OUT PSYMBOL_INFO Symbol)
{
    ULONG Matches;
    
    RequireCurrentScope();

    if (ImageBase == 0)
    {
        if (!SymFromName(Process, Name, Symbol))
        {
            return 0;
        }

        Matches = 1;
    }
    else
    {
        COUNT_SYMBOL_MATCHES Context;
        ULONG MaxName = Symbol->MaxNameLen;

        Context.Machine = Machine;
        Context.ReturnSymInfo = *Symbol;
        if (Symbol->NameLen < MAX_SYMBOL_LEN) 
        {
            strcpy(Context.ReturnSymInfo.Name, Symbol->Name);
        }
        Context.Matches = 0;
        SymEnumSymbols(Process, ImageBase, Name,
                       CountSymbolMatches, &Context);
        *Symbol = Context.ReturnSymInfo;
        Symbol->MaxNameLen = MaxName;
        if (Symbol->MaxNameLen > Context.ReturnSymInfo.NameLen) 
        {
            strcpy(Symbol->Name, Context.ReturnSymInfo.Name);
        }

        Matches = Context.Matches;
    }

    if (Matches == 1 &&
        !ForceSymbolCodeAddress(Symbol, Machine))
    {
        return 0;
    }
    
    return Matches;
}

ULONG
GetOffsetFromSym(PCSTR String,
                 PULONG64 Offset,
                 PDEBUG_IMAGE_INFO* Image)
{
    CHAR ModifiedString[MAX_SYMBOL_LEN + 64];
    CHAR Suffix[2];
    SYMBOL_INFO SymInfo = {0};
    ULONG Count;

    if (Image != NULL)
    {
        *Image = NULL;
    }
    
    //
    // We can't do anything without a current process.
    //

    if (g_CurrentProcess == NULL)
    {
        return 0;
    }

    if ( strlen(String) == 0 )
    {
        return 0;
    }

    if (GetOffsetFromMod(String, Offset)) 
    {
        return 1;
    }

    //
    // If a module name was given look up the module
    // and determine the processor type so that the
    // appropriate machine is used for the following
    // machine-specific operations.
    //

    PDEBUG_IMAGE_INFO StrImage;
    ULONG64 ImageBase;
    PCSTR ModSep = strchr(String, '!');
    if (ModSep != NULL)
    {
        ULONG Len = (ULONG)(ModSep - String);
        memcpy(ModifiedString, String, Len);
        ModifiedString[Len] = 0;
        StrImage = GetImageByName(g_CurrentProcess, ModifiedString,
                                  INAME_MODULE);
        if (Image != NULL)
        {
            *Image = StrImage;
        }
        ImageBase = StrImage ? StrImage->BaseOfImage : 0;
    }
    else
    {
        StrImage = NULL;
        ImageBase = 0;
    }

    MachineInfo* Machine = g_Machine;

    if (StrImage != NULL)
    {
        Machine = MachineTypeInfo(ModuleMachineType(g_CurrentProcess,
                                                    StrImage->BaseOfImage));
        if (Machine == NULL)
        {
            Machine = g_Machine;
        }
    }
    
    if ( g_PrefixSymbols && Machine->m_SymPrefix != NULL )
    {
        PCSTR PreString;
        PCSTR RegString;

        PreString = PrependPrefixToSymbol( ModifiedString, String,
                                           &RegString );
        if ( Count =
             MultiSymFromName( g_CurrentProcess->Handle, (PSTR)PreString,
                               ImageBase, Machine, &SymInfo ) )
        {
            *Offset = SymInfo.Address;
            goto GotOffsetSuccess;
        }
        if ( (PreString != String) &&
             (Count =
              MultiSymFromName( g_CurrentProcess->Handle, (PSTR)String,
                                ImageBase, Machine, &SymInfo ) ) )
        {
            // Ambiguous plabels shouldn't be further resolved,
            // so just return the information for the plabel.
            if (Count > 1)
            {
                *Offset = SymInfo.Address;
                goto GotOffsetSuccess;
            }
            
            if (Machine->GetPrefixedSymbolOffset(SymInfo.Address,
                                                 GETPREF_VERBOSE,
                                                 Offset))
            {
#ifndef _DBGHELP_USER_GENERATED_SYMBOLS_NOTSUPPORTED
                if ( ! SymSetSymWithAddr64( g_CurrentProcess->Handle,
                                            *Offset, (PSTR)RegString,
                                            g_Sym ) )
                {
                    DWORD LastError = GetLastError();

                    if ( LastError != ERROR_ALREADY_EXISTS )
                    {
                        ErrOut("GetOffsetFromSym: "
                               "%s registration in dbghelp: "
                               "FAILED!!!, lerr:0x%lx\n",
                               RegString, LastError );
                    }
#endif // !_DBGHELP_USER_GENERATED_SYMBOLS_NOTSUPPORTED
                }
                else
                {
                    // This symbol doesn't appear to actually
                    // be a plabel so just use the symbol address.
                    *Offset = SymInfo.Address;
                }
            }
            else
            {
                *Offset = SymInfo.Address;
            }
            goto GotOffsetSuccess;
        }
    }
    else if (Count =
             MultiSymFromName( g_CurrentProcess->Handle, (PSTR)String,
                               ImageBase, Machine, &SymInfo ))
    {
        *Offset = SymInfo.Address;
        goto GotOffsetSuccess;
    }

    if (g_SymbolSuffix != 'n')
    {
        strcpy( ModifiedString, String );
        Suffix[0] = g_SymbolSuffix;
        Suffix[1] = '\0';
        strcat( ModifiedString, Suffix );
        if (Count =
            MultiSymFromName( g_CurrentProcess->Handle, ModifiedString,
                              ImageBase, Machine, &SymInfo ))
        {
            *Offset = SymInfo.Address;
            goto GotOffsetSuccess;
        }
    }

    return 0;

GotOffsetSuccess:
    TranslateAddress(SymInfo.Flags, SymInfo.Register, Offset, &SymInfo.Value);
    if (SymInfo.Flags & SYMF_REGISTER)
    {
        *Offset = SymInfo.Value;
    }
    return Count;
}

void
CreateModuleNameFromPath(LPSTR ImagePath, LPSTR ModuleName)
{
    PSTR Scan;
    
    ModuleName[0] = 0;
    strncat( ModuleName, PathTail(ImagePath), MAX_MODULE - 1 );
    Scan = strchr( ModuleName, '.' );
    if (Scan != NULL)
    {
        *Scan = '\0';
    }
}

void
GetAdjacentSymOffsets(
                     ULONG64   addrStart,
                     PULONG64  prevOffset,
                     PULONG64  nextOffset
                     )
{
    DWORD64 Displacement;

    //
    // assume failure
    //
    *prevOffset = 0;
    *nextOffset = (ULONG64) -1;

    //
    // get the symbol for the initial address
    //
    if (!SymGetSymFromAddr64( g_CurrentProcess->Handle, addrStart, &Displacement, g_SymStart )) {
        return;
    }

    *prevOffset = g_SymStart->Address;

    if (SymGetSymNext64( g_CurrentProcess->Handle, g_SymStart )) {
        *nextOffset = g_SymStart->Address;
    }

    return;
}

BOOL
SymbolCallbackFunction(
                      HANDLE  hProcess,
                      ULONG   ActionCode,
                      ULONG64 CallbackData,
                      ULONG64 UserContext
                      )
{
    PIMAGEHLP_DEFERRED_SYMBOL_LOAD64 idsl;
    PIMAGEHLP_CBA_READ_MEMORY        prm;
    PIMAGEHLP_CBA_EVENT              evt;
    PDEBUG_IMAGE_INFO                pImage;
    IMAGEHLP_MODULE64                mi;
    PUCHAR                           p;
    ULONG                            i;
    ULONG                            OldSymOptions;

    idsl = (PIMAGEHLP_DEFERRED_SYMBOL_LOAD64) CallbackData;

    switch ( ActionCode )
    {
    case CBA_DEBUG_INFO:
        assert(CallbackData && *(LPSTR)CallbackData);
        dprintf("%s", (LPSTR)CallbackData);
        break;

    case CBA_EVENT:
        evt = (PIMAGEHLP_CBA_EVENT)CallbackData;
        assert(evt);
        if (evt->desc && *evt->desc)
            dprintf("%s", evt->desc);
        break;

    case CBA_DEFERRED_SYMBOL_LOAD_CANCEL:
        if (g_EngStatus & (ENG_STATUS_USER_INTERRUPT |
                           ENG_STATUS_PENDING_BREAK_IN))
        {
            return TRUE;
        }
        break;

    case CBA_DEFERRED_SYMBOL_LOAD_START:
        pImage = g_CurrentProcess->ImageHead;
        while (pImage)
        {
            if (idsl->BaseOfImage == pImage->BaseOfImage)
            {
                _strlwr( idsl->FileName );
                VerbOut( "Loading symbols for %s %16s ->   ",
                         FormatAddr64(idsl->BaseOfImage),
                         idsl->FileName
                       );
                return TRUE;
            }
            pImage = pImage->Next;
        }
        break;

    case CBA_DEFERRED_SYMBOL_LOAD_FAILURE:
        if (IS_KERNEL_TARGET() &&
            idsl->SizeOfStruct >= FIELD_OFFSET(IMAGEHLP_DEFERRED_SYMBOL_LOAD,
                                               Reparse))
        {
            i = 0;

            if (strncmp(idsl->FileName, "dump_", sizeof("dump_")-1) == 0)
            {
                i = sizeof("dump_")-1;
            }

            if (strncmp(idsl->FileName, "hiber_", sizeof("hiber_")-1) == 0)
            {
                i = sizeof("hiber_")-1;
            }

            if (i)
            {
                if (_stricmp (idsl->FileName+i, "scsiport.sys") == 0)
                {
                    strcpy (idsl->FileName, "diskdump.sys");
                }
                else
                {
                    strcpy(idsl->FileName, idsl->FileName+i);
                }

                idsl->Reparse = TRUE;
                return TRUE;
            }
        }

        if (idsl->FileName && *idsl->FileName)
        {
            VerbOut( "*** Error: could not load symbols for %s\n",
                     idsl->FileName );
        }
        else
        {
            VerbOut( "*** Error: could not load symbols [MODNAME UNKNOWN]\n");
        }
        break;

    case CBA_DEFERRED_SYMBOL_LOAD_COMPLETE:
        pImage = g_CurrentProcess->ImageHead;
        
        // Do not load unqualified symbols in this callback sine this
        // could result in stack owerflow
        OldSymOptions = SymGetOptions();
        SymSetOptions(OldSymOptions | SYMOPT_NO_UNQUALIFIED_LOADS);
        
        while (pImage)
        {
            if ((idsl->BaseOfImage == pImage->BaseOfImage) ||
                (pImage->BaseOfImage == 0))
            {
                VerbOut( "%s\n", idsl->FileName );
                pImage->GoodCheckSum = DII_GOOD_CHECKSUM;

                //
                // If we had a 0 timestamp for the image, try to update it
                // from the image since for NT4 - XP, the kernel
                // does not report timestamps in the initial symbol load
                // module
                //

                if (pImage->BaseOfImage &&
                    (pImage->TimeDateStamp == 0))
                {
                    DWORD CheckSum;
                    DWORD TimeDateStamp;
                    DWORD SizeOfImage;
                    if (GetHeaderInfo(pImage->BaseOfImage,
                                      &CheckSum,
                                      &TimeDateStamp,
                                      &SizeOfImage))
                    {
                        pImage->TimeDateStamp = TimeDateStamp;
                    }
                }

                if ((idsl->TimeDateStamp == 0)   ||
                    (pImage->TimeDateStamp == 0) ||
                    (pImage->TimeDateStamp == UNKNOWN_TIMESTAMP))
                {
                    dprintf( "*** WARNING: Unable to verify "
                             "timestamp for %s\n", idsl->FileName );
                    pImage->GoodCheckSum = DII_UNKNOWN_TIMESTAMP;
                }
                else
                {
                    if ((idsl->CheckSum == 0)     ||
                        (pImage->CheckSum == 0) ||
                        (pImage->CheckSum == UNKNOWN_CHECKSUM))
                    {
                        dprintf( "*** WARNING: Unable to verify "
                                 "checksum for %s\n", idsl->FileName );
                        pImage->GoodCheckSum = DII_UNKNOWN_CHECKSUM;
                    }
                    else if (idsl->CheckSum != pImage->CheckSum)
                    {
                        pImage->GoodCheckSum = DII_BAD_CHECKSUM;

                        if (g_TargetMachineType == IMAGE_FILE_MACHINE_I386)
                        {
                            if (IS_USER_TARGET() ||
                                g_TargetNumberProcessors == 1)
                            {
                                //
                                // See if this is an MP image with the
                                // lock table removed by setup. If
                                // it is and the timestamps match, don't
                                // print the invalid checksum warning.
                                //

                                char szFileName[_MAX_FNAME];
                                _splitpath(idsl->FileName, NULL, NULL,
                                           szFileName, NULL);

                                if ((!_stricmp(szFileName, "kernel32") ||
                                     (IS_KERNEL_TARGET() &&
                                      !_stricmp(szFileName, "win32k")) ||
                                     !_stricmp(szFileName, "wow32") ||
                                     !_stricmp(szFileName, "ntvdm") ||
                                     !_stricmp(szFileName, "ntdll")) &&
                                    (pImage->TimeDateStamp ==
                                     idsl->TimeDateStamp))
                                {
                                    pImage->GoodCheckSum = DII_GOOD_CHECKSUM;
                                }
                            }
                        }

                        if (pImage->GoodCheckSum == DII_BAD_CHECKSUM)
                        {
                            //
                            // Only print the message if the timestamps
                            // are wrong.
                            //

                            if (pImage->TimeDateStamp != idsl->TimeDateStamp)
                            {
                                dprintf("*** WARNING: symbols timestamp "
                                        "is wrong 0x%08x 0x%08x for %s\n",
                                        pImage->TimeDateStamp,
                                        idsl->TimeDateStamp,
                                        idsl->FileName);
                            }
                        }
                    }
                }

                mi.SizeOfStruct = sizeof(mi);
                if (SymGetModuleInfo64( g_CurrentProcess->Handle,
                                        idsl->BaseOfImage, &mi ))
                {
                    if (mi.SymType == SymExport)
                    {
                        WarnOut("*** ERROR: Symbol file could not be found."
                                "  Defaulted to export symbols for %s - \n",
                                idsl->FileName);
                    }
                    if (mi.SymType == SymNone)
                    {
                        WarnOut("*** ERROR: Module load completed but "
                                "symbols could not be loaded for %s\n",
                                idsl->FileName);
                    }
                }
                NotifyChangeSymbolState(DEBUG_CSS_LOADS,
                                        idsl->BaseOfImage, g_CurrentProcess);
                SymSetOptions(OldSymOptions);
                return TRUE;
            }
            pImage = pImage->Next;
        }
        VerbOut( "\n" );
        NotifyChangeSymbolState(DEBUG_CSS_LOADS,
                                idsl->BaseOfImage, 
                                g_CurrentProcess);
        SymSetOptions(OldSymOptions);
        break;

    case CBA_SYMBOLS_UNLOADED:
        VerbOut( "Symbols unloaded for %s %s\n",
                 FormatAddr64(idsl->BaseOfImage),
                 idsl->FileName
                 );
        break;

    case CBA_READ_MEMORY:
        prm = (PIMAGEHLP_CBA_READ_MEMORY)CallbackData;
        return g_Target->ReadVirtual(prm->addr,
                                     prm->buf,
                                     prm->bytes,
                                     prm->bytesread) == S_OK;

    case CBA_SET_OPTIONS:
        // Symbol options are set through the interface
        // so the debugger generally knows about them
        // already.  The only flag that we want to check
        // here is the debug flag since it can be changed
        // through !sym.  There is no need to notify
        // about this as it's only an internal flag.
        g_SymOptions = (g_SymOptions & ~SYMOPT_DEBUG) |
            (*(PULONG)CallbackData & SYMOPT_DEBUG);
        break;

    default:
        return FALSE;
    }

    return FALSE;
}

BOOL
ValidatePathComponent(PCSTR Part)
{
    if (strlen(Part) == 0)
    {
        return FALSE;
    }
    else if (!_strnicmp(Part, "SYMSRV*", 7) ||
             IsUrlPathComponent(Part))
    {
        // No easy way to validate symbol server or URL paths.
        // They're virtually always network references,
        // so just disallow all such usage when net
        // access isn't allowed.
        if (g_EngOptions & DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS)
        {
            return FALSE;
        }
        
        return TRUE;
    }
    else
    {
        DWORD Attrs;
        DWORD OldMode;
        char Expand[MAX_PATH];

        // Otherwise make sure this is a valid directory.
        if (!ExpandEnvironmentStrings(Part, Expand, sizeof(Expand)))
        {
            return FALSE;
        }
        
        if (g_EngOptions & DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS)
        {
            // Don't call GetFileAttributes when network paths
            // are disabled as net operations may cause deadlocks.
            if (NetworkPathCheck(Expand) != ERROR_SUCCESS)
            {
                return FALSE;
            }
        }

        // We can still get to this point when debugging CSR
        // if the user has explicitly allowed net paths.
        // This check isn't important enough to risk a hang.
        if (SYSTEM_PROCESSES())
        {
            return TRUE;
        }
        
        OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    
        Attrs = GetFileAttributes(Expand);

        SetErrorMode(OldMode);
        return Attrs != 0xffffffff && (Attrs & FILE_ATTRIBUTE_DIRECTORY);
    }
}

VOID
FeedSymPath(
    LPSTR pSymbolSearchPath,
    LPSTR raw
    )
{
    DWORD dw;
    LPSTR rawbuf;
    LPSTR p;
    BOOL  bAppend;

    if (!raw)
    {
        return;
    }

    p = strtok(raw, ";");
    while (p)
    {
        bAppend = FALSE;

        // Check and see if this string is already in the path.
        // If it is, don't add it again.
        PSTR Dup = strstr(pSymbolSearchPath, p);
        if (Dup != NULL)
        {
            PSTR DupEnd = Dup + strlen(p);
            if ((Dup == pSymbolSearchPath || Dup[-1] == ';') &&
                (*DupEnd == 0 || *DupEnd == ';'))
            {
                p = strtok(NULL, ";");
                continue;
            }
        }

        bAppend = ValidatePathComponent(p);
        if (bAppend)
        {
            if (*pSymbolSearchPath)
            {
                strcat(pSymbolSearchPath, ";");
            }
            strcat(pSymbolSearchPath, p);
        }
        else
        {
            WarnOut("WARNING: %s is not accessible, ignoring\n", p);
        }

        p = strtok(NULL, ";");
    }
}

void
SetSymbolSearchPath(PPROCESS_INFO Process)
{
    LPSTR lpExePathEnv;
    size_t cbExePath;

    LPSTR lpSymPathEnv;
    LPSTR lpAltSymPathEnv;
    LPSTR lpSymPath;
    size_t cbSymPath;
    LPSTR NewMem;

    //
    // Load the Binary path (needed for triage dumps)
    //

    // No clue why this or the next is 18 ...
    cbExePath = 18;

    if (g_ExecutableImageSearchPath)
    {
        cbExePath += strlen(g_ExecutableImageSearchPath) + 1;
    }

    if (lpExePathEnv = getenv("_NT_EXECUTABLE_IMAGE_PATH"))
    {
        cbExePath += strlen(lpExePathEnv) + 1;
    }

    NewMem = (char*)realloc(g_ExecutableImageSearchPath, cbExePath);
    if (!NewMem)
    {
        ErrOut("Not enough memory to allocate/initialize "
               "ExecutableImageSearchPath");
        return;
    }
    if (!g_ExecutableImageSearchPath)
    {
        *NewMem = 0;
    }
    g_ExecutableImageSearchPath = NewMem;

    FeedSymPath(g_ExecutableImageSearchPath, lpExePathEnv);

    //
    // Load symbol Path
    //

    cbSymPath = 18;
    if (g_SymbolSearchPath)
    {
        cbSymPath += strlen(g_SymbolSearchPath) + 1;
    }
    if (lpSymPathEnv = getenv("_NT_SYMBOL_PATH"))
    {
        cbSymPath += strlen(lpSymPathEnv) + 1;
    }
    if (lpAltSymPathEnv = getenv("_NT_ALT_SYMBOL_PATH"))
    {
        cbSymPath += strlen(lpAltSymPathEnv) + 1;
    }

    NewMem = (char*)realloc(g_SymbolSearchPath, cbSymPath);
    if (!NewMem)
    {
        ErrOut("Not enough memory to allocate/initialize "
               "SymbolSearchPath");
        return;
    }
    if (!g_SymbolSearchPath)
    {
        *NewMem = 0;
    }
    g_SymbolSearchPath = NewMem;

    FeedSymPath(g_SymbolSearchPath, lpAltSymPathEnv);
    FeedSymPath(g_SymbolSearchPath, lpSymPathEnv);

    SymSetSearchPath( Process->Handle, g_SymbolSearchPath );

    dprintf("Symbol search path is: %s\n",
            *g_SymbolSearchPath ?
            g_SymbolSearchPath :
            "*** Invalid *** : Verify _NT_SYMBOL_PATH setting" );

    if (g_ExecutableImageSearchPath)
    {
        dprintf("Executable search path is: %s\n",
                g_ExecutableImageSearchPath);
    }
}

BOOL
SetCurrentScope(
    IN PDEBUG_STACK_FRAME ScopeFrame,
    IN OPTIONAL PVOID ScopeContext,
    IN ULONG ScopeContextSize
    )
{
    BOOL ScopeChanged;
    PDEBUG_SCOPE Scope = &g_ScopeBuffer;
    
    if (Scope->State == ScopeDefaultLazy) 
    {
        // Its not a lazy scope now
        Scope->State = ScopeDefault;
    }
    
    ScopeChanged = SymSetContext(g_CurrentProcess->Handle,
                                 (PIMAGEHLP_STACK_FRAME) ScopeFrame,
                                 ScopeContext);
    
    if (ScopeContext && (sizeof(Scope->Context) >= ScopeContextSize)) 
    {
        memcpy(&Scope->Context, ScopeContext, ScopeContextSize);
        Scope->ContextState = MCTX_FULL;
        Scope->State = ScopeFromContext;
        NotifyChangeDebuggeeState(DEBUG_CDS_REGISTERS, DEBUG_ANY_ID);
    }
    
    Scope->LocalsChanged = ScopeChanged;
    
    if (ScopeChanged ||
        (ScopeFrame->FrameOffset != Scope->Frame.FrameOffset))
    {
        Scope->Frame = *ScopeFrame;
        Scope->LocalsChanged = TRUE;
        if (ScopeFrame->FuncTableEntry)
        {
            // Cache the FPO data since the pointer is only temporary
            Scope->CachedFpo =
                *((PFPO_DATA) ScopeFrame->FuncTableEntry);
            Scope->Frame.FuncTableEntry =
                (ULONG64) &Scope->CachedFpo;
        }
        NotifyChangeSymbolState(DEBUG_CSS_SCOPE, 0, g_CurrentProcess);
    }
    else
    {
        Scope->Frame = *ScopeFrame;
        if (ScopeFrame->FuncTableEntry)
        {
            // Cache the FPO data since the pointer is only temporary
            Scope->CachedFpo =
                *((PFPO_DATA) ScopeFrame->FuncTableEntry);
            Scope->Frame.FuncTableEntry =
                (ULONG64) &Scope->CachedFpo;
        }
    }
    
    return ScopeChanged;
}

BOOL
ResetCurrentScopeLazy(void)
{
    PDEBUG_SCOPE Scope = &g_ScopeBuffer;
    if (Scope->State == ScopeFromContext)
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_REGISTERS, DEBUG_ANY_ID);
    }
    
    Scope->State = ScopeDefaultLazy;

    return TRUE;
}

BOOL
ResetCurrentScope(void)
{
    DEBUG_STACK_FRAME LocalFrame;
    PDEBUG_SCOPE Scope = &g_ScopeBuffer;
    
    if (Scope->State == ScopeFromContext)
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_REGISTERS, DEBUG_ANY_ID);
    }
    
    Scope->State = ScopeDefault;
    
    ZeroMemory(&LocalFrame, sizeof(LocalFrame));

    // At the initial kernel load the system is only partially
    // initialized and is very sensitive to bad memory reads.
    // Stack traces can cause reads through unusual memory areas
    // so it's best to avoid them at this time.  This isn't
    // much of a problem since users don't usually expect a locals
    // context at this point.
    if ((IS_USER_TARGET() ||
         (g_EngStatus & ENG_STATUS_AT_INITIAL_MODULE_LOAD) == 0) &&
        IS_CONTEXT_ACCESSIBLE())
    {
        if (!StackTrace(0, 0, 0, &LocalFrame, 1, 0, 0, TRUE))
        {
            ADDR Addr;
            g_Machine->GetPC(&Addr);
            LocalFrame.InstructionOffset = Addr.off;
        }
    }
    
    return SetCurrentScope(&LocalFrame, NULL, 0);
}

void
ListUnloadedModules(ULONG Flags, PSTR Pattern)
{
    UnloadedModuleInfo* Unl;

    g_NumUnloadedModules = 0;
    if (!IS_KERNEL_TARGET())
    {
        return;
    }
    
    Unl = g_Target->GetUnloadedModuleInfo();
    if (Unl == NULL || Unl->Initialize() != S_OK)
    {
        ErrOut("Unable to examine unloaded module list\n");
        return;
    }

    char UnlName[MAX_UNLOADED_NAME_LENGTH / sizeof(WCHAR) + 1];
    DEBUG_MODULE_PARAMETERS Params;

    if (Flags & LUM_OUTPUT)
    {
        dprintf("Unloaded modules:\n");
    }
    
    while (Unl->GetEntry(UnlName, &Params) == S_OK)
    {
        g_NumUnloadedModules++;
        
        if (Pattern != NULL &&
            !MatchPattern(UnlName, Pattern))
        {
            continue;
        }
        
        if (Flags & LUM_OUTPUT_TERSE)
        {
            dprintf(".");
            continue;
        }

        if (Flags & LUM_OUTPUT)
        {
            dprintf("%s %s   %-8s",
                    FormatAddr64(Params.Base),
                    FormatAddr64(Params.Base + Params.Size),
                    UnlName);
        }
            
        if (Flags & ( LUM_OUTPUT_VERBOSE | LUM_OUTPUT_TIMESTAMP))
        {
            PSTR TimeDateStr = TimeToStr(Params.TimeDateStamp);

            dprintf("    Timestamp: %s (%08X)",
                    TimeDateStr, Params.TimeDateStamp);
        }

        dprintf("\n");
    }

    dprintf("\n");
}

ULONG
ModuleMachineType(PPROCESS_INFO Process, ULONG64 Offset)
{
    ULONG64 Base = SymGetModuleBase64(Process->Handle, Offset);
    if (Base == 0)
    {
        return IMAGE_FILE_MACHINE_UNKNOWN;
    }

    PPROCESS_INFO OldCur = g_CurrentProcess;
    g_CurrentProcess = Process;
    
    ULONG Machine = IMAGE_FILE_MACHINE_UNKNOWN;
    IMAGE_DOS_HEADER DosHdr;
    IMAGE_NT_HEADERS64 NtHdr;
    ULONG Done;

    if (g_Target->ReadVirtual(Base, &DosHdr, sizeof(DosHdr), &Done) == S_OK &&
        Done == sizeof(DosHdr) &&
        DosHdr.e_magic == IMAGE_DOS_SIGNATURE &&
        g_Target->ReadVirtual(Base + DosHdr.e_lfanew, &NtHdr,
                              FIELD_OFFSET(IMAGE_NT_HEADERS64,
                                           FileHeader.NumberOfSections),
                              &Done) == S_OK &&
        Done == FIELD_OFFSET(IMAGE_NT_HEADERS64,
                             FileHeader.NumberOfSections) &&
        NtHdr.Signature == IMAGE_NT_SIGNATURE &&
        MachineTypeIndex(NtHdr.FileHeader.Machine) != MACHIDX_COUNT)
    {
        Machine = NtHdr.FileHeader.Machine;
    }

    g_CurrentProcess = OldCur;
    return Machine;
}

ULONG
IsInFastSyscall(ULONG64 Addr, PULONG64 Base)
{
    if (g_TargetMachineType != IMAGE_FILE_MACHINE_I386 ||
        g_TargetPlatformId != VER_PLATFORM_WIN32_NT ||
        g_SystemVersion < NT_SVER_W2K_WHISTLER)
    {
        return FSC_NONE;
    }
    
    ULONG64 FastBase = g_TargetBuildNumber >= 2412 ?
        X86_SHARED_SYSCALL_BASE_GTE2412 :
        X86_SHARED_SYSCALL_BASE_LT2412;
    
    if (Addr >= FastBase &&
        Addr < (FastBase + X86_SHARED_SYSCALL_SIZE))
    {
        *Base = FastBase;
        return FSC_FOUND;
    }

    return FSC_NONE;
}

BOOL
ShowFunctionParameters(PDEBUG_STACK_FRAME StackFrame,
                       PSTR SymBuf, ULONG64 Displacement)
{
    SYM_DUMP_PARAM_EX SymFunction = {0};
    ULONG Status = 0;
    PDEBUG_SCOPE Scope = GetCurrentScope();
    DEBUG_SCOPE SavScope = *Scope;

    SymFunction.size = sizeof(SYM_DUMP_PARAM_EX);
//    SymFunction.sName = (PUCHAR) SymBuf;
    SymFunction.addr = StackFrame->InstructionOffset;
    SymFunction.Options = DBG_DUMP_COMPACT_OUT | DBG_DUMP_FUNCTION_FORMAT;
    
    //    SetCurrentScope to this function
    SymSetContext(g_CurrentProcess->Handle,
                  (PIMAGEHLP_STACK_FRAME) StackFrame, NULL);
    Scope->Frame = *StackFrame;
    if (StackFrame->FuncTableEntry)
    {
        // Cache the FPO data since the pointer is only temporary
        Scope->CachedFpo = *((PFPO_DATA) StackFrame->FuncTableEntry);
        Scope->Frame.FuncTableEntry =
            (ULONG64) &Scope->CachedFpo;
    }

    if (!SymbolTypeDumpNew(&SymFunction, &Status) &&
        !Status)
    {
        Status = TRUE;
    }

    g_ScopeBuffer = SavScope;
    SymSetContext(g_CurrentProcess->Handle,
                  (PIMAGEHLP_STACK_FRAME) &Scope->Frame, NULL);

    return !Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\ntsym.h ===
//----------------------------------------------------------------------------
//
// Symbol-handling routines.
//
// Copyright (C) Microsoft Corporation, 1997-2001.
//
//----------------------------------------------------------------------------

#ifndef _NTSYM_H_
#define _NTSYM_H_

#define SYM_BUFFER_SIZE (sizeof(IMAGEHLP_SYMBOL64) + MAX_SYMBOL_LEN)

#define MatchPattern(Str, Pat) \
    SymMatchString(Str, Pat, FALSE)

extern DEBUG_STACK_FRAME g_LastRegFrame;

// The scope buffer is only exposed so that it
// can be looked at without requiring a function call.
// Users of scope information should go through the
// scope abstraction functions.
extern DEBUG_SCOPE g_ScopeBuffer;

extern LPSTR g_SymbolSearchPath;
extern LPSTR g_ExecutableImageSearchPath;

extern ULONG g_SymOptions;
extern PIMAGEHLP_SYMBOL64 g_Sym;
extern PIMAGEHLP_SYMBOL64 g_SymStart;

extern ULONG g_NumUnloadedModules;

void RefreshAllModules(void);
void SetSymOptions(ULONG Options);

BOOL IsImageMachineType64(DWORD MachineType);

void
CreateModuleNameFromPath(
    LPSTR szImagePath,
    LPSTR szModuleName
    );

void
fnListNear (
    ULONG64 addrStart
    );

BOOL
GetHeaderInfo(
    IN  ULONG64   BaseOfDll,
    OUT LPDWORD     CheckSum,
    OUT LPDWORD     TimeDateStamp,
    OUT LPDWORD     SizeOfImage
    );

void
GetSymbolStdCall (
    ULONG64 Offset,
    PCHAR Buffer,
    ULONG BufferLen,
    PULONG64 Displacement,
    PUSHORT StdCallParams
    );

BOOL
GetNearSymbol(
    ULONG64 Offset,
    PSTR Buffer,
    ULONG BufferLen,
    PULONG64 Disp,
    LONG Delta
    );

BOOL ValidatePathComponent(PCSTR Part);
void SetSymbolSearchPath(PPROCESS_INFO Process);
void DeferSymbolLoad(PDEBUG_IMAGE_INFO);
void LoadSymbols(PDEBUG_IMAGE_INFO);
void UnloadSymbols(PDEBUG_IMAGE_INFO);

BOOL IgnoreEnumeratedSymbol(class MachineInfo* Machine,
                            PSYMBOL_INFO SymInfo);

PCSTR
PrependPrefixToSymbol( char   PrefixedString[],
                       PCSTR  pString,
                       PCSTR *RegString
                       );

ULONG
GetOffsetFromSym(
    PCSTR String,
    PULONG64 Offset,
    PDEBUG_IMAGE_INFO* Image
    );

void
GetAdjacentSymOffsets(
    ULONG64   addrStart,
    PULONG64  prevOffset,
    PULONG64  nextOffset
    );

void
GetCurrentMemoryOffsets (
    PULONG64 pMemoryLow,
    PULONG64 pMemoryHigh
    );


PDEBUG_IMAGE_INFO GetImageByIndex(PPROCESS_INFO Process, ULONG Index);
PDEBUG_IMAGE_INFO GetImageByOffset(PPROCESS_INFO Process, ULONG64 Offset);
PDEBUG_IMAGE_INFO GetImageByName(PPROCESS_INFO Process, PCSTR Name,
                                 INAME Which);

BOOL
GetModnameFromImage(
    ULONG64   BaseOfDll,
    HANDLE    File,
    LPSTR     Name,
    ULONG     NameSize
    );

typedef enum _DMT_FLAGS
{
    DMT_SYM_IMAGE_FILE_NAME = 0x0000,
    DMT_ONLY_LOADED_SYMBOLS = 0x0001,
    DMT_ONLY_USER_SYMBOLS   = 0x0002,
    DMT_ONLY_KERNEL_SYMBOLS = 0x0004,
    DMT_VERBOSE             = 0x0008,
    DMT_SYM_FILE_NAME       = 0x0010,
    DMT_MAPPED_IMAGE_NAME   = 0x0020,
    DMT_IMAGE_PATH_NAME     = 0x0040,
    DMT_IMAGE_TIMESTAMP     = 0x0080,
    DMT_NO_SYMBOL_OUTPUT    = 0x0100,
} DMT_FLAGS;

#define DMT_STANDARD   DMT_SYM_FILE_NAME
#define DMT_NAME_FLAGS \
    (DMT_SYM_IMAGE_FILE_NAME | DMT_SYM_FILE_NAME | DMT_MAPPED_IMAGE_NAME | \
     DMT_IMAGE_PATH_NAME)

enum
{
    DMT_NAME_SYM_IMAGE,
    DMT_NAME_SYM_FILE,
    DMT_NAME_MAPPED_IMAGE,
    DMT_NAME_IMAGE_PATH,
    DMT_NAME_COUNT
};

void
DumpModuleTable(
    ULONG DMT_Flags,
    PSTR Pattern
    );

void ParseDumpModuleTable(void);
void ParseExamine(void);

BOOL
SymbolCallbackFunction(
    HANDLE  hProcess,
    ULONG   ActionCode,
    ULONG64 CallbackData,
    ULONG64 UserContext
    );

BOOL
TranslateAddress(
    IN ULONG        Flags,
    IN ULONG        RegId,
    IN OUT PULONG64 Address,
    OUT PULONG64    Value
    );

BOOL SetCurrentScope(IN PDEBUG_STACK_FRAME ScopeFrame,
                     IN OPTIONAL PVOID ScopeContext,
                     IN ULONG ScopeContextSize);
BOOL ResetCurrentScope(void);
BOOL ResetCurrentScopeLazy(void);

inline PDEBUG_SCOPE
GetCurrentScope(void)
{
    if (g_ScopeBuffer.State == ScopeDefaultLazy)
    {
        ResetCurrentScope();
    }

    return &g_ScopeBuffer;
}
inline PCROSS_PLATFORM_CONTEXT
GetCurrentScopeContext(void)
{
    if (g_ScopeBuffer.State == ScopeFromContext)
    {
        return &g_ScopeBuffer.Context;
    }
    else
    {
        return NULL;
    }
}

// Force lazy scope to be updated so that actual
// scope data is available.
#define RequireCurrentScope() \
    GetCurrentScope()

inline void
PushScope(PDEBUG_SCOPE Buffer)
{
    *Buffer = g_ScopeBuffer;
}
inline void
PopScope(PDEBUG_SCOPE Buffer)
{
    g_ScopeBuffer = *Buffer;
}

#define LUM_OUTPUT           0x0001
#define LUM_OUTPUT_VERBOSE   0x0002
#define LUM_OUTPUT_TERSE     0x0004
#define LUM_OUTPUT_TIMESTAMP 0x0008

void ListUnloadedModules(ULONG Flags, PSTR Pattern);

ULONG ModuleMachineType(PPROCESS_INFO Process, ULONG64 Offset);

enum
{
    FSC_NONE,
    FSC_FOUND,
};

ULONG IsInFastSyscall(ULONG64 Addr, PULONG64 Base);

BOOL ShowFunctionParameters(PDEBUG_STACK_FRAME StackFrame,
                            PSTR SymBuf, ULONG64 Displacement);

#endif // #ifndef _NTSYM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\procthrd.h ===
//----------------------------------------------------------------------------
//
// Process and thread routines.
//
// Copyright (C) Microsoft Corporation, 1997-2000.
//
//----------------------------------------------------------------------------

#ifndef _PROCTHRD_H_
#define _PROCTHRD_H_

#define ANY_PROCESSES() \
    (g_ProcessHead != NULL || g_ProcessPending != NULL)

#define SYSTEM_PROCESSES() \
    (((g_AllProcessFlags | g_AllPendingFlags) & ENG_PROC_SYSTEM) != 0)

extern ULONG g_NextProcessUserId;
extern ULONG g_AllProcessFlags;
extern ULONG g_NumberProcesses;
extern ULONG g_TotalNumberThreads;
extern ULONG g_MaxThreadsInProcess;
extern PTHREAD_INFO g_RegContextThread;
extern ULONG g_RegContextProcessor;
extern ULONG g_AllPendingFlags;

PPROCESS_INFO FindProcessByUserId(ULONG Id);
PTHREAD_INFO FindThreadByUserId(PPROCESS_INFO Process, ULONG Id);

PPROCESS_INFO FindProcessBySystemId(ULONG Id);
PTHREAD_INFO FindThreadBySystemId(PPROCESS_INFO Process, ULONG Id);

PPROCESS_INFO FindProcessByHandle(ULONG64 Handle);
PTHREAD_INFO FindThreadByHandle(PPROCESS_INFO Process, ULONG64 Handle);

PPROCESS_INFO
AddProcess(
    ULONG SystemId,
    ULONG64 Handle,
    ULONG InitialThreadSystemId,
    ULONG64 InitialThreadHandle,
    ULONG64 InitialThreadDataOffset,
    ULONG64 StartOffset,
    ULONG Flags,
    ULONG Options,
    ULONG InitialThreadFlags
    );
PTHREAD_INFO
AddThread(
    PPROCESS_INFO Process,
    ULONG SystemId,
    ULONG64 Handle,
    ULONG64 DataOffset,
    ULONG64 StartOffset,
    ULONG Flags
    );
 
void RemoveAndDeleteProcess(PPROCESS_INFO Process, PPROCESS_INFO Prev);
BOOL DeleteExitedInfos(void);

void OutputProcessInfo(PSTR Title);

void ChangeRegContext(PTHREAD_INFO Thread);
void FlushRegContext(void);

void SetCurrentThread(PTHREAD_INFO Thread, BOOL Hidden);
void SetCurrentProcessorThread(ULONG Processor, BOOL Hidden);
void SaveSetCurrentProcessorThread(ULONG Processor);
void RestoreCurrentProcessorThread(void);

void SuspendAllThreads(void);
BOOL ResumeAllThreads(void);

void SuspendResumeThreads(PPROCESS_INFO Process, BOOL Susp,
                          PTHREAD_INFO Match);

#define SPT_DEFAULT_OCI_FLAGS \
    (OCI_SYMBOL | OCI_DISASM | OCI_FORCE_EA | OCI_ALLOW_SOURCE | \
     OCI_ALLOW_REG)
void SetPromptThread(PTHREAD_INFO pThread, ULONG uOciFlags);

void fnOutputProcessInfo(PPROCESS_INFO);
void fnOutputThreadInfo(PTHREAD_INFO);

void parseThreadCmds(DebugClient* Client);
void parseProcessCmds(void);

void AddPendingProcess(PPENDING_PROCESS Pending);
void RemovePendingProcess(PPENDING_PROCESS Pending);
void DiscardPendingProcess(PPENDING_PROCESS Pending);
void DiscardPendingProcesses(void);
PPENDING_PROCESS FindPendingProcessByFlags(ULONG Flags);
PPENDING_PROCESS FindPendingProcessById(ULONG Id);
void VerifyPendingProcesses(void);
void AddExamineToPendingAttach(void);

HRESULT StartAttachProcess(ULONG ProcessId, ULONG AttachFlags,
                           PPENDING_PROCESS* Pending);
HRESULT StartCreateProcess(PSTR CommandLine, ULONG CreateFlags,
                           PPENDING_PROCESS* Pending);
HRESULT TerminateProcess(PPROCESS_INFO Process);
HRESULT TerminateProcesses(void);
HRESULT DetachProcess(PPROCESS_INFO Process);
HRESULT DetachProcesses(void);
HRESULT AbandonProcess(PPROCESS_INFO Process);

enum
{
    SEP_TERMINATE,
    SEP_DETACH,
    SEP_ABANDON,
};

HRESULT SeparateCurrentProcess(ULONG Mode, PSTR Description);

#endif // #ifndef _PROCTHRD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\register.cpp ===
//----------------------------------------------------------------------------
//
// Generic register support code.  All processor-specific code is in
// the processor-specific register files.
//
// Copyright (C) Microsoft Corporation, 1997-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

DEBUG_STACK_FRAME g_LastRegFrame;

static char *g_PseudoNames[REG_PSEUDO_COUNT] =
{
    "$exp", "$ea", "$p", "$ra", "$thread", "$proc", "$teb", "$peb",
    "$tid", "$tpid",
};

PCSTR g_UserRegs[REG_USER_COUNT];

//----------------------------------------------------------------------------
//
// InitReg
//
// Initializes the register support.
//
//----------------------------------------------------------------------------

HRESULT
InitReg(void)
{
    // Placeholder in case something needs to be done.
    return S_OK;
}

//----------------------------------------------------------------------------
//
// NeedUpper
//
// Determines whether the upper 32 bits of a 64-bit register is
// an important value or just a sign extension.
//
//----------------------------------------------------------------------------

BOOL
NeedUpper(ULONG64 val)
{
    //
    // if the high bit of the low part is set, then the
    // high part must be all ones, else it must be zero.
    //

    return ((val & 0xffffffff80000000L) != 0xffffffff80000000L) &&
         ((val & 0xffffffff00000000L) != 0);
}

//----------------------------------------------------------------------------
//
// ScanHexVal
//
// Scans an integer register value as a hex number.
//
//----------------------------------------------------------------------------

PSTR
ScanHexVal(PSTR StrVal, REGVAL *RegVal)
{
    ULONG64 Max;
    CHAR ch;

    switch(RegVal->type)
    {
    case REGVAL_INT16:
        Max = 0x1000;
        break;
    case REGVAL_SUB32:
    case REGVAL_INT32:
        Max = 0x10000000;
        break;
    case REGVAL_SUB64:
    case REGVAL_INT64:
    case REGVAL_INT64N:
        Max = 0x1000000000000000;
        break;
    }

    while (*StrVal == ' ' || *StrVal == '\t')
    {
        StrVal++;
    }
    
    RegVal->Nat = 0;
    RegVal->i64 = 0;
    for (;;)
    {
        ch = (CHAR)tolower(*StrVal);
        if ((ch < '0' || ch > '9') &&
            (ch < 'a' || ch > 'f'))
        {
            if (g_EffMachine == IMAGE_FILE_MACHINE_IA64 &&
                ch == 'n')
            {
                StrVal++;
                RegVal->Nat = 1;
            }
            break;
        }

        if (RegVal->i64 >= Max)
        {
            error(OVERFLOW);
        }

        ch -= '0';
        if (ch > 9)
        {
            ch -= 'a' - '0' - 10;
        }
        RegVal->i64 = RegVal->i64 * 0x10 + ch;

        StrVal++;
    }

    return StrVal;
}

//----------------------------------------------------------------------------
//
// ScanRegVal
//
// Sets a register value from a string.
//
//----------------------------------------------------------------------------

PSTR
ScanRegVal(
    ULONG Index,
    PSTR Str,
    BOOL Get64
    )
{
    if (Index >= REG_USER_FIRST && Index <= REG_USER_LAST)
    {
        SetUserReg(Index, Str);
        return Str + strlen(Str);
    }
    else
    {
        PSTR      StrVal;
        CHAR      ch;
        REGVAL    RegVal, TmpVal;
        _ULDBL12  F12;
        int       Used;

        StrVal = Str;

        do
        {
            ch = *StrVal++;
        } while (ch == ' ' || ch == '\t');

        if (ch == 0)
        {
            error(SYNTAX);
        }
        StrVal--;

        RegVal.type = g_Machine->GetType(Index);

        switch(RegVal.type)
        {
        case REGVAL_INT16:
        case REGVAL_SUB32:
        case REGVAL_INT32:
        case REGVAL_SUB64:
        case REGVAL_INT64:
        case REGVAL_INT64N:
            if (Str == g_CurCmd)
            {
                RegVal.i64 = GetExpression();
                RegVal.Nat = 0;
                StrVal = g_CurCmd;
            }
            else
            {
                StrVal = ScanHexVal(StrVal, &RegVal);
            }
            break;
        case REGVAL_FLOAT8:
            __strgtold12(&F12, &StrVal, StrVal, 0);
            _ld12tod(&F12, (UDOUBLE *)&RegVal.f8);
            break;
        case REGVAL_FLOAT10:
            __strgtold12(&F12, &StrVal, StrVal, 0);
            _ld12told(&F12, (_ULDOUBLE *)&RegVal.f10);
            break;
        case REGVAL_FLOAT82:
            UDOUBLE UDbl;
            FLOAT128 F82;

            // read as REGVAL_FLOAT10 (80 bit) and transfer to double
            __strgtold12(&F12, &StrVal, StrVal, 0);
            _ld12tod(&F12, &UDbl);

            DoubleToFloat82(UDbl.x, &F82);

            RegVal.type = REGVAL_FLOAT82;
            memcpy(&RegVal.f82, &F82, min(sizeof(F82), sizeof(RegVal.f82)));
            break;
        case REGVAL_FLOAT16:
            // NTRAID#72859-2000/02/09-drewb
            // Should implement real f16 handling.
            // For now scan as two 64-bit parts.
            TmpVal.type = REGVAL_INT64;
            StrVal = ScanHexVal(StrVal, &TmpVal);
            RegVal.f16Parts.high = (LONG64)TmpVal.i64;
            StrVal = ScanHexVal(StrVal, &TmpVal);
            RegVal.f16Parts.low = TmpVal.i64;
            break;
        case REGVAL_VECTOR64:
            // XXX drewb - Allow format overrides to
            // scan in any format for vectors.
            if (Str == g_CurCmd)
            {
                RegVal.i64 = GetExpression();
                RegVal.Nat = 0;
                StrVal = g_CurCmd;
            }
            else
            {
                StrVal = ScanHexVal(StrVal, &RegVal);
            }
            break;
        case REGVAL_VECTOR128:
            // XXX drewb - Allow format overrides to
            // scan in any format for vectors.
            if (sscanf(StrVal, "%f%f%f%f%n",
                       &RegVal.bytes[3 * sizeof(float)],
                       &RegVal.bytes[2 * sizeof(float)],
                       &RegVal.bytes[1 * sizeof(float)],
                       &RegVal.bytes[0],
                       &Used) != 5)
            {
                error(SYNTAX);
            }
            StrVal += Used;
            break;

        default:
            error(BADREG);
        }

        ch = *StrVal;
        if (ch != 0 && ch != ',' && ch != ';' && ch != ' ' && ch != '\t')
        {
            error(SYNTAX);
        }

        SetRegVal(Index, &RegVal);

        return StrVal;
    }
}

//----------------------------------------------------------------------------
//
// InputRegVal
//
// Prompts for a new register value.
//
//----------------------------------------------------------------------------

void InputRegVal(ULONG index, BOOL Get64)
{
    CHAR chVal[_MAX_PATH];
    int  type;
    char *prompt = NULL;

    if (index >= REG_USER_FIRST && index <= REG_USER_LAST)
    {
        prompt = "; new value: ";
    }
    else
    {
        type = g_Machine->GetType(index);

        switch(type)
        {
        case REGVAL_INT16:
            prompt = "; hex int16 value: ";
            break;
        case REGVAL_SUB64:
        case REGVAL_INT64:
        case REGVAL_INT64N:
            if (Get64)
            {
                prompt = "; hex int64 value: ";
                break;
            }
            // Fall through.
        case REGVAL_SUB32:
        case REGVAL_INT32:
            prompt = "; hex int32 value: ";
            break;
        case REGVAL_FLOAT8:
            prompt = "; 32-bit float value: ";
            break;
        case REGVAL_FLOAT10:
            prompt = "; 80-bit float value: ";
            break;
        case REGVAL_FLOAT82:
            prompt = "; 82-bit float value: ";
            break;
        case REGVAL_FLOAT16:
            prompt = "; 128-bit float value (two 64-bit hex): ";
            break;
        case REGVAL_VECTOR64:
            prompt = "; hex int64 value: ";
            break;
        case REGVAL_VECTOR128:
            prompt = "; 32-bit float 4-vector: ";
            break;
        default:
            error(BADREG);
        }
    }

    GetInput(prompt, chVal, sizeof(chVal));
    RemoveDelChar(chVal);
    ScanRegVal(index, chVal, Get64);
}

//----------------------------------------------------------------------------
//
// OutputRegVal
//
// Displays the given register's value.
//
//----------------------------------------------------------------------------

void OutputRegVal(ULONG index, BOOL Show64)
{
    if (index >= REG_USER_FIRST && index <= REG_USER_LAST)
    {
        index -= REG_USER_FIRST;

        if (g_UserRegs[index] == NULL)
        {
            dprintf("<Empty>");
        }
        else
        {
            dprintf("%s", g_UserRegs[index]);
        }
    }
    else
    {
        REGVAL val;
        char Buf[32];

        GetRegVal(index, &val);

        switch(val.type)
        {
        case REGVAL_INT16:
            dprintf("%04x", val.i32);
            break;
        case REGVAL_SUB32:
            dprintf("%x", val.i32);
            break;
        case REGVAL_INT32:
            dprintf("%08x", val.i32);
            break;
        case REGVAL_SUB64:
            if (Show64)
            {
                if (NeedUpper(val.i64))
                {
                    dprintf("%x%08x", val.i64Parts.high, val.i64Parts.low);
                }
                else
                {
                    dprintf("%x", val.i32);
                }
            }
            else
            {
                dprintf("%x", val.i64Parts.low);
                if (NeedUpper(val.i64))
                {
                    dprintf("*");
                }
            }
            break;
        case REGVAL_INT64:
            if (Show64)
            {
                dprintf("%08x%08x", val.i64Parts.high, val.i64Parts.low);
            }
            else
            {
                dprintf("%08x", val.i64Parts.low);
                if (NeedUpper(val.i64))
                {
                    dprintf("*");
                }
            }
            break;
        case REGVAL_INT64N:
            dprintf("%08x%08x %01x", val.i64Parts.high, val.i64Parts.low,
                    val.i64Parts.Nat);
            break;
        case REGVAL_FLOAT8:
            dprintf("%22.12g", val.f8);
            break;
        case REGVAL_FLOAT10:
            _uldtoa((_ULDOUBLE *)&val.f10, sizeof(Buf) - 1, Buf);
            dprintf(Buf);
            break;
        case REGVAL_FLOAT82: 
            FLOAT128 f128;
            FLOAT82_FORMAT* f82; 
            f82 = (FLOAT82_FORMAT*)&f128;
            memcpy(&f128, &val.f82, min(sizeof(f128), sizeof(val.f82)));
            dprintf("%22.12g (%u:%05x:%016I64x)", 
                    Float82ToDouble(&f128),
                    UINT(f82->sign), UINT(f82->exponent), 
                    ULONG64(f82->significand));
            break;
        case REGVAL_FLOAT16:
            // NTRAID#72859-2000/02/09-drewb
            // Should implement real f16 handling.
            // For now print as two 64-bit parts.
            dprintf("%08x%08x %08x%08x",
                    (ULONG)(val.f16Parts.high >> 32),
                    (ULONG)val.f16Parts.high,
                    (ULONG)(val.f16Parts.low >> 32),
                    (ULONG)val.f16Parts.low);
            break;
        case REGVAL_VECTOR64:
            // XXX drewb - Allow format overrides to
            // show in any format for vectors.
            dprintf("%016I64x", val.i64);
            break;
        case REGVAL_VECTOR128:
            // XXX drewb - Allow format overrides to
            // show in any format for vectors.
            dprintf("%f %f %f %f",
                    *(float *)&val.bytes[3 * sizeof(float)],
                    *(float *)&val.bytes[2 * sizeof(float)],
                    *(float *)&val.bytes[1 * sizeof(float)],
                    *(float *)&val.bytes[0]);
            break;
        default:
            error(BADREG);
        }
    }
}

//----------------------------------------------------------------------------
//
// OutputNameRegVal
//
// Displays the given register's name and value.
//
//----------------------------------------------------------------------------

void OutputNameRegVal(ULONG index, BOOL Show64)
{
    if (index >= REG_USER_FIRST && index <= REG_USER_LAST)
    {
        dprintf("$u%d=", index - REG_USER_FIRST);
    }
    else
    {
        REGVAL val;

        // Validate the register before any output.
        GetRegVal(index, &val);

        dprintf("%s=", RegNameFromIndex(index));
    }
    OutputRegVal(index, Show64);
}

//----------------------------------------------------------------------------
//
// ShowAllMask
//
// Display given mask settings.
//
//----------------------------------------------------------------------------

void ShowAllMask(void)
{
    dprintf("Register output mask is %x:\n", g_Machine->m_AllMask);
    if (g_Machine->m_AllMask == 0)
    {
        dprintf("    Nothing\n");
    }
    else
    {
        if (g_Machine->m_AllMask & REGALL_INT64)
        {
            dprintf("    %4x - Integer state (64-bit)\n",
                    REGALL_INT64);
        }
        else if (g_Machine->m_AllMask & REGALL_INT32)
        {
            dprintf("    %4x - Integer state (32-bit)\n",
                    REGALL_INT32);
        }
        if (g_Machine->m_AllMask & REGALL_FLOAT)
        {
            dprintf("    %4x - Floating-point state\n",
                    REGALL_FLOAT);
        }

        ULONG Bit;

        Bit = 1 << REGALL_EXTRA_SHIFT;
        while (Bit > 0)
        {
            if (g_Machine->m_AllMask & Bit)
            {
                RegisterGroup* Group;
                REGALLDESC *BitDesc;
                
                for (Group = g_Machine->m_Groups;
                     Group != NULL;
                     Group = Group->Next)
                {
                    BitDesc = Group->AllExtraDesc;
                    if (BitDesc == NULL)
                    {
                        continue;
                    }
                    
                    while (BitDesc->Bit != 0)
                    {
                        if (BitDesc->Bit == Bit)
                        {
                            break;
                        }

                        BitDesc++;
                    }

                    if (BitDesc->Bit != 0)
                    {
                        break;
                    }
                }

                if (BitDesc != NULL && BitDesc->Bit != 0)
                {
                    dprintf("    %4x - %s\n",
                            BitDesc->Bit, BitDesc->Desc);
                }
                else
                {
                    dprintf("    %4x - ?\n", Bit);
                }
            }

            Bit <<= 1;
        }
    }
}

//----------------------------------------------------------------------------
//
// ParseAllMaskCmd
//
// Interprets commands affecting AllMask.
//
//----------------------------------------------------------------------------

void ParseAllMaskCmd(void)
{
    CHAR ch;

    if (!IS_MACHINE_SET())
    {
        error(SESSIONNOTSUP);
    }
    
    g_CurCmd++;

    ch = PeekChar();
    if (ch == '\0' || ch == ';')
    {
        // Show current setting.
        ShowAllMask();
    }
    else if (ch == '?')
    {
        // Explain settings.
        g_CurCmd++;

        dprintf("    %4x - Integer state (32-bit) or\n",
                REGALL_INT32);
        dprintf("    %4x - Integer state (64-bit), 64-bit takes precedence\n",
                REGALL_INT64);
        dprintf("    %4x - Floating-point state\n",
                REGALL_FLOAT);
        
        RegisterGroup* Group;
        REGALLDESC *Desc;

        for (Group = g_Machine->m_Groups; Group != NULL; Group = Group->Next)
        {
            Desc = Group->AllExtraDesc;
            if (Desc != NULL)
            {
                while (Desc->Bit != 0)
                {
                    dprintf("    %4x - %s\n", Desc->Bit, Desc->Desc);
                    Desc++;
                }
            }
        }
    }
    else
    {
        ULONG Mask = (ULONG)GetExpression();
        g_Machine->m_AllMask = Mask & g_Machine->m_AllMaskBits;
        if (g_Machine->m_AllMask != Mask)
        {
            WarnOut("Ignored invalid bits %X\n", Mask & ~g_Machine->m_AllMask);
        }
    }
}

/*** ParseRegCmd - parse register command
*
*   Purpose:
*       Parse the register ("r") command.
*           if "r", output all registers
*           if "r <reg>", output only the register <reg>
*           if "r <reg> =", output only the register <reg>
*               and prompt for new value
*           if "r <reg> = <value>" or "r <reg> <value>",
*               set <reg> to value <value>
*
*           if "rm #", set all register output mask.
*
*   Input:
*       *g_CurCmd - pointer to operands in command string
*
*   Output:
*       None.
*
*   Exceptions:
*       error exit:
*               SYNTAX - character after "r" not register name
*
*************************************************************************/

#define isregchar(ch) \
    ((ch) == '$' || \
     ((ch) >= '0' && (ch) <= '9') || \
     ((ch) >= 'a' && (ch) <= 'z') || \
     (ch) == '.')

VOID
ParseRegCmd (
    VOID
    )
{
    CHAR ch;
    ULONG AllMask;

    // rm manipulates AllMask.
    if (*g_CurCmd == 'm')
    {
        ParseAllMaskCmd();
        return;
    }

    if (IS_LOCAL_KERNEL_TARGET())
    {
        error(SESSIONNOTSUP);
    }
    if (!IS_MACHINE_ACCESSIBLE())
    {
        error(BADTHREAD);
    }

    AllMask = g_Machine->m_AllMask;

    switch(*g_CurCmd++)
    {
    case 'F':
        AllMask = REGALL_FLOAT;
        break;

    case 'L':
        if (AllMask & REGALL_INT32)
        {
            AllMask = (AllMask & ~REGALL_INT32) | REGALL_INT64;
        }
        break;

    case 'M':
        AllMask = (ULONG)GetExpression();
        break;

    case 'X':
        AllMask = REGALL_XMMREG;
        break;

    default:
        g_CurCmd--;
        break;
    }

    // If just 'r', output information about the current thread context.

    if ((ch = PeekChar()) == '\0' || ch == ';')
    {
        OutCurInfo(OCI_FORCE_ALL, AllMask, DEBUG_OUTPUT_NORMAL);
        g_Machine->GetPC(&g_AssemDefault);
        g_UnasmDefault = g_AssemDefault;
    }
    else
    {
        // if [processor]r, no register can be specified.
        if (g_SwitchedProcs)
        {
            error(SYNTAX);
        }

        for (;;)
        {
            char    RegName[16];
            ULONG   index;
            BOOL    fNewLine;

            // Collect register name.
            index = 0;

            while (index < sizeof(RegName) - 1)
            {
                ch = (char)tolower(*g_CurCmd);
                if (!isregchar(ch))
                {
                    break;
                }

                g_CurCmd++;
                RegName[index++] = ch;
            }

            RegName[index] = 0;

            // Check for a user register.
            if (index == 4 &&
                RegName[0] == '$' &&
                RegName[1] == '.' &&
                RegName[2] == 'u' &&
                isdigit(RegName[3]))
            {
                index = REG_USER_FIRST + (RegName[3] - '0');
            }
            else if ((index = RegIndexFromName(RegName)) == REG_ERROR)
            {
                error(BADREG);
            }

            fNewLine = FALSE;

            //  if "r <reg>", output value

            if ((ch = PeekChar()) == '\0' || ch == ',' || ch == ';')
            {
                OutputNameRegVal(index, AllMask & REGALL_INT64);
                fNewLine = TRUE;
            }
            else if (ch == '=' || g_QuietMode)
            {
                //  if "r <reg> =", output and prompt for new value

                if (ch == '=')
                {
                    g_CurCmd++;
                }

                if ((ch = PeekChar()) == '\0' || ch == ',' || ch == ';')
                {
                    OutputNameRegVal(index, AllMask & REGALL_INT64);
                    InputRegVal(index, AllMask & REGALL_INT64);
                }
                else
                {
                    //  if "r <reg> = <value>", set the value

                    g_CurCmd = ScanRegVal(index, g_CurCmd,
                                            AllMask & REGALL_INT64);
                    ch = PeekChar();
                }
            }
            else
            {
                error(SYNTAX);
            }

            if (ch == ',')
            {
                if (fNewLine)
                {
                    dprintf(" ");
                }

                while (*g_CurCmd == ' ' || *g_CurCmd == ',')
                {
                    g_CurCmd++;
                }
            }
            else
            {
                if (fNewLine)
                {
                    dprintf("\n");
                }

                break;
            }
        }
    }
}

//----------------------------------------------------------------------------
//
// ExpandUserRegs
//
// Searches for occurrences of $u<digit> and replaces them with the
// corresponding user register string.
//
//----------------------------------------------------------------------------

void
ExpandUserRegs(PSTR sz)
{
    PCSTR val;
    ULONG len;
    PSTR copy;

    while (TRUE)
    {
        // Look for a '$'.
        while (*sz != 0 && *sz != '$')
        {
            sz++;
        }

        // End of line?
        if (*sz == 0)
        {
            break;
        }

        // Check for 'u' and a digit.
        sz++;
        if (*sz != 'u')
        {
            continue;
        }
        sz++;
        if (!isdigit(*sz))
        {
            continue;
        }

        val = g_UserRegs[*sz - '0'];

        if (val == NULL)
        {
            len = 0;
        }
        else
        {
            len = strlen(val);
        }

        copy = sz - 2;
        sz++;

        // Move string tail to make room for the replacement text.
        memmove(copy + len, sz, strlen(sz) + 1);

        // Insert replacement text.
        if (len > 0)
        {
            memcpy(copy, val, len);
        }

        // Restart scan at beginning of replaced text to handle
        // nested replacements.
        sz = copy;
    }
}

//----------------------------------------------------------------------------
//
// PsuedoIndexFromName
//
// Recognizes pseudo-register names.
//
//----------------------------------------------------------------------------

ULONG PseudoIndexFromName(PCSTR name)
{
    ULONG i;

    for (i = 0; i < REG_PSEUDO_COUNT; i++)
    {
        if (!_stricmp(g_PseudoNames[i], name))
        {
            return i + REG_PSEUDO_FIRST;
        }
    }
    return REG_ERROR;
}

//----------------------------------------------------------------------------
//
// GetPseudoVal
//
// Returns pseudo-register values.
//
//----------------------------------------------------------------------------

ULONG64
GetPseudoVal(
    ULONG Index
    )
{
    ADDR Addr;
    ULONG64 Val;
    ULONG64 Id;

    switch(Index)
    {
    case PSEUDO_LAST_EXPR:
        return g_LastExpressionValue;
        
    case PSEUDO_EFF_ADDR:
        g_Machine->GetEffectiveAddr(&Addr);
        if (fnotFlat(Addr))
        {
            error(BADREG);
        }
        return Flat(Addr);
        
    case PSEUDO_LAST_DUMP:
        if (g_EffMachine == IMAGE_FILE_MACHINE_I386)
        {
            // Sign extended on X86 so "dc @$p" works as expected.
            return (ULONG64)(LONG64)(LONG)EXPRLastDump;
        }
        else
        {
            return EXPRLastDump;
        }
        
    case PSEUDO_RET_ADDR:
        g_Machine->GetRetAddr(&Addr);
        if (fnotFlat(Addr))
        {
            error(BADREG);
        }
        return Flat(Addr);
        
    case PSEUDO_IMP_THREAD:
        if (GetImplicitThreadData(&Val) != S_OK)
        {
            error(BADREG);
        }
        return Val;
        
    case PSEUDO_IMP_PROCESS:
        if (GetImplicitProcessData(&Val) != S_OK)
        {
            error(BADREG);
        }
        return Val;
        
    case PSEUDO_IMP_TEB:
        if (GetImplicitThreadDataTeb(&Val) != S_OK)
        {
            error(BADREG);
        }
        return Val;
        
    case PSEUDO_IMP_PEB:
        if (GetImplicitProcessDataPeb(&Val) != S_OK)
        {
            error(BADREG);
        }
        return Val;
        
    case PSEUDO_IMP_THREAD_ID:
        if (GetImplicitThreadDataTeb(&Val) != S_OK ||
            g_Target->ReadPointer(g_Machine,
                                  Val + 9 * (g_Machine->m_Ptr64 ? 8 : 4),
                                  &Id) != S_OK)
        {
            error(BADREG);
        }
        return Id;
        
    case PSEUDO_IMP_THREAD_PROCESS_ID:
        if (GetImplicitThreadDataTeb(&Val) != S_OK ||
            g_Target->ReadPointer(g_Machine,
                                  Val + 8 * (g_Machine->m_Ptr64 ? 8 : 4),
                                  &Id) != S_OK)
        {
            error(BADREG);
        }
        return Id;
        
    default:
        error(BADREG);
    }

    return 0;
}

//----------------------------------------------------------------------------
//
// GetRegVal
//
// Gets a register value, performing subregister mapping if necessary.
//
//----------------------------------------------------------------------------

void
GetRegVal(
    ULONG index,
    REGVAL *val
    )
{
    int type;
    REGSUBDEF *subdef;

    if (index >= REG_PSEUDO_FIRST && index <= REG_PSEUDO_LAST)
    {
        val->type = REGVAL_INT64;
        val->i64 = GetPseudoVal(index);
        return;
    }

    type = g_Machine->GetType(index);
    if (type == REGVAL_SUB32 || type == REGVAL_SUB64)
    {
        subdef = RegSubDefFromIndex(index);
        if (subdef == NULL)
        {
            error(BADREG);
        }

        index = subdef->fullreg;
    }

    if (!g_Machine->GetVal(index, val))
    {
        error(BADREG);
    }

    if (type == REGVAL_SUB32 || type == REGVAL_SUB64)
    {
        if (val->type == REGVAL_SUB32)
        {
            val->i64Parts.high = 0;
        }

        val->type = type;
        val->i64 = (val->i64 >> subdef->shift) & subdef->mask;
    }
}

ULONG
GetRegVal32(
    ULONG index
    )
{
    REGVAL val;

    GetRegVal(index, &val);
    return val.i32;
}

ULONG64
GetRegVal64(
    ULONG index
    )
{
    REGVAL val;

    GetRegVal(index, &val);
    return val.i64;
}

//----------------------------------------------------------------------------
//
// GetUserReg
//
// Gets a user register value.
//
//----------------------------------------------------------------------------

PCSTR
GetUserReg(ULONG index)
{
    return g_UserRegs[index - REG_USER_FIRST];
}

//----------------------------------------------------------------------------
//
// SetRegVal
//
// Sets a register value, performing subregister mapping if necessary.
//
//----------------------------------------------------------------------------

void SetRegVal(ULONG index, REGVAL *val)
{
    REGSUBDEF *subdef;
    REGVAL baseval;

    if (index >= REG_PSEUDO_FIRST && index <= REG_PSEUDO_LAST)
    {
        error(BADREG);
    }

    if (val->type == REGVAL_SUB32 || val->type == REGVAL_SUB64)
    {
        // Look up subreg definition.
        subdef = RegSubDefFromIndex(index);
        if (subdef == NULL)
        {
            error(BADREG);
        }

        index = subdef->fullreg;

        if (!g_Machine->GetVal(index, &baseval))
        {
            error(BADREG);
        }

        if (val->type == REGVAL_SUB32)
        {
            val->i64Parts.high = 0;
        }

        if (val->i64 > subdef->mask)
        {
            error(OVERFLOW);
        }

        baseval.i64 =
            (baseval.i64 & ~(subdef->mask << subdef->shift)) |
            ((val->i64 & subdef->mask) << subdef->shift);

        val = &baseval;
    }

    if (!g_Machine->SetVal(index, val))
    {
        error(BADREG);
    }
}

void SetRegVal32(ULONG index, ULONG val)
{
    REGVAL regval;

    regval.type = g_Machine->GetType(index);
    memset(&regval, 0, sizeof(regval));
    regval.i32 = val;
    SetRegVal(index, &regval);
}

void SetRegVal64(ULONG index, ULONG64 val)
{
    REGVAL regval;

    regval.type = g_Machine->GetType(index);
    memset(&regval, 0, sizeof(regval));
    regval.i64 = val;
    SetRegVal(index, &regval);
}

//----------------------------------------------------------------------------
//
// SetUserReg
//
// Sets a user register value.
//
//----------------------------------------------------------------------------

BOOL
SetUserReg(ULONG index, PCSTR val)
{
    PCSTR Copy;
    
    index -= REG_USER_FIRST;

    Copy = _strdup(val);
    if (Copy == NULL)
    {
        ErrOut("Unable to allocate memory for user register value\n");
        return FALSE;
    }
    
    if (g_UserRegs[index] != NULL)
    {
        free((PSTR)g_UserRegs[index]);
    }

    g_UserRegs[index] = Copy;

    return TRUE;
}

//----------------------------------------------------------------------------
//
// RegIndexFromName
//
// Maps a register index to its name string.
//
//----------------------------------------------------------------------------

ULONG
RegIndexFromName(PCSTR Name)
{
    ULONG Index;
    REGDEF* Def;
    RegisterGroup* Group;

    // Check for pseudo registers.
    Index = PseudoIndexFromName(Name);
    if (Index != REG_ERROR)
    {
        return Index;
    }
    
    if (g_Machine)
    {
        for (Group = g_Machine->m_Groups; Group != NULL; Group = Group->Next)
        {
            Def = Group->Regs;
            while (Def->psz != NULL)
            {
                if (!strcmp(Def->psz, Name))
                {
                    return Def->index;
                }

                Def++;
            }
        }
    }
    
    return REG_ERROR;
}

//----------------------------------------------------------------------------
//
// RegNameFromIndex
//
// Maps a register index to its name.
//
//----------------------------------------------------------------------------

PCSTR
RegNameFromIndex(ULONG Index)
{
    REGDEF* Def;
    
    if (Index >= REG_PSEUDO_FIRST && Index <= REG_PSEUDO_LAST)
    {
        return g_PseudoNames[Index - REG_PSEUDO_FIRST];
    }

    Def = RegDefFromIndex(Index);
    if (Def != NULL)
    {
        return Def->psz;
    }
    else
    {
        return NULL;
    }
}

//----------------------------------------------------------------------------
//
// RegSubDefFromIndex
//
// Maps a subregister index to a subregister definition.
//
//----------------------------------------------------------------------------

REGSUBDEF*
RegSubDefFromIndex(ULONG Index)
{
    RegisterGroup* Group;
    REGSUBDEF* SubDef;
    
    for (Group = g_Machine->m_Groups; Group != NULL; Group = Group->Next)
    {
        SubDef = Group->SubRegs;
        if (SubDef == NULL)
        {
            continue;
        }
        
        while (SubDef->subreg != REG_ERROR)
        {
            if (SubDef->subreg == Index)
            {
                return SubDef;
            }

            SubDef++;
        }
    }

    return NULL;
}

//----------------------------------------------------------------------------
//
// RegDefFromIndex
//
// Maps a register index to its definition.
//
//----------------------------------------------------------------------------

REGDEF*
RegDefFromIndex(ULONG Index)
{
    REGDEF* Def;
    RegisterGroup* Group;

    for (Group = g_Machine->m_Groups; Group != NULL; Group = Group->Next)
    {
        Def = Group->Regs;
        while (Def->psz != NULL)
        {
            if (Def->index == Index)
            {
                return Def;
            }

            Def++;
        }
    }

    return NULL;
}

//----------------------------------------------------------------------------
//
// RegDefFromCount
//
// Maps a count to a register definition.
//
//----------------------------------------------------------------------------

REGDEF*
RegDefFromCount(ULONG Count)
{
    RegisterGroup* Group;

    for (Group = g_Machine->m_Groups; Group != NULL; Group = Group->Next)
    {
        if (Count < Group->NumberRegs)
        {
            break;
        }

        Count -= Group->NumberRegs;
    }

    DBG_ASSERT(Group != NULL);
    
    return Group->Regs + Count;
}

//----------------------------------------------------------------------------
//
// RegCountFromIndex
//
// Maps an index to a count.
//
//----------------------------------------------------------------------------

ULONG
RegCountFromIndex(ULONG Index)
{
    REGDEF* Def;
    RegisterGroup* Group;
    ULONG Count;

    Count = 0;
    for (Group = g_Machine->m_Groups; Group != NULL; Group = Group->Next)
    {
        Def = Group->Regs;
        while (Def->psz != NULL)
        {
            if (Def->index == Index)
            {
                return Count + (ULONG)(Def - Group->Regs);
            }

            Def++;
        }

        Count += Group->NumberRegs;
    }

    return NULL;
}

HRESULT
OutputContext(
    IN PCROSS_PLATFORM_CONTEXT TargetContext,
    IN ULONG Flag
    )
{
    HRESULT Status;
    CROSS_PLATFORM_CONTEXT Context;

    // Convert target context to canonical form.
    if ((Status = g_Machine->ConvertContextFrom(&Context, g_SystemVersion,
                                                g_Machine->m_SizeTargetContext,
                                                TargetContext)) != S_OK)
    {
        return Status;
    }
    
    g_Machine->ValidateCxr(&Context);
    g_Machine->PushContext(&Context);

    OutCurInfo(OCI_SYMBOL | OCI_DISASM | OCI_FORCE_REG | OCI_ALLOW_SOURCE,
               Flag, DEBUG_OUTPUT_NORMAL);
        
    switch(g_EffMachine)
    { 
    case IMAGE_FILE_MACHINE_I386:
        g_LastRegFrame.InstructionOffset = g_TargetMachine->GetReg64(X86_EIP);
        g_LastRegFrame.StackOffset       = g_TargetMachine->GetReg64(X86_ESP);
        g_LastRegFrame.FrameOffset       = g_TargetMachine->GetReg64(X86_EBP);
        break;
    case IMAGE_FILE_MACHINE_IA64:
        g_LastRegFrame.InstructionOffset = g_TargetMachine->GetReg64(STIIP);
        g_LastRegFrame.StackOffset       = g_TargetMachine->GetReg64(INTSP);
        g_LastRegFrame.FrameOffset       = g_TargetMachine->GetReg64(RSBSP);
        break;
    case IMAGE_FILE_MACHINE_AXP64:
    case IMAGE_FILE_MACHINE_ALPHA:
        g_LastRegFrame.InstructionOffset =
            g_TargetMachine->GetReg64(ALPHA_FIR);
        g_LastRegFrame.StackOffset       = g_TargetMachine->GetReg64(SP_REG);
        g_LastRegFrame.FrameOffset       = g_TargetMachine->GetReg64(FP_REG);
        break;
    case IMAGE_FILE_MACHINE_AMD64:
        g_LastRegFrame.InstructionOffset =
            g_TargetMachine->GetReg64(AMD64_RIP);
        g_LastRegFrame.StackOffset =
            g_TargetMachine->GetReg64(AMD64_RSP);
        g_LastRegFrame.FrameOffset =
            g_TargetMachine->GetReg64(AMD64_RBP);
        break;
    default:
        break;
    } 
        
    g_Machine->PopContext();

    SetCurrentScope(&g_LastRegFrame, &Context,
                    g_Machine->m_SizeCanonicalContext);
    return S_OK;
}

HRESULT
OutputVirtualContext(
    IN ULONG64 ContextBase,
    IN ULONG Flag
    )
{
    if (!ContextBase) 
    {
        return E_INVALIDARG;
    }

    HRESULT Status;
    CROSS_PLATFORM_CONTEXT Context;
    ULONG ContextSize;

    //
    // Read the context data out of virtual memory and
    // call into the raw context output routine.
    //
    
    if ((Status = g_Target->ReadVirtual(ContextBase, &Context,
                                        g_Machine->m_SizeTargetContext,
                                        &ContextSize)) != S_OK)
    {
        return Status;
    }
    if (ContextSize != g_Machine->m_SizeTargetContext)
    {
        return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
    }

    return OutputContext(&Context, Flag);
}

void
fnStackTrace(
    PSTR arg
    )
{
    ULONG Flags = (DEBUG_STACK_COLUMN_NAMES |
                   DEBUG_STACK_FRAME_ADDRESSES |
                   DEBUG_STACK_SOURCE_LINE);
    ULONG Count =100;
    ULONG Frames;

    switch (*arg) 
    {
    case 'v' :
        Flags |= DEBUG_STACK_FUNCTION_INFO | DEBUG_STACK_NONVOLATILE_REGISTERS;
        // Fall thru
    case 'b' :
        Flags |= DEBUG_STACK_ARGUMENTS;
    }

    PDEBUG_STACK_FRAME stk;
    stk = (PDEBUG_STACK_FRAME)
        LocalAlloc( LPTR, Count * sizeof(DEBUG_STACK_FRAME) );
    if (!stk)
    {
        dprintf("Out of memory\n");
        return;
    }

    Frames = StackTrace(g_LastRegFrame.FrameOffset,
                        g_LastRegFrame.StackOffset, 
                        g_LastRegFrame.InstructionOffset,
                        stk, Count, 0, 0, FALSE);

    if (Frames) 
    {
        PrintStackTrace(Frames, stk, Flags);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\register.h ===
//----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1997-2001.
//
//----------------------------------------------------------------------------

#ifndef _REGISTER_H_
#define _REGISTER_H_

#define REG_ERROR (0xffffffffUL)

#define REG_PSEUDO_FIRST 0x7ffffe00
enum
{
    PSEUDO_LAST_EXPR = REG_PSEUDO_FIRST,
    PSEUDO_EFF_ADDR,
    PSEUDO_LAST_DUMP,
    PSEUDO_RET_ADDR,
    PSEUDO_IMP_THREAD,
    PSEUDO_IMP_PROCESS,
    PSEUDO_IMP_TEB,
    PSEUDO_IMP_PEB,
    PSEUDO_IMP_THREAD_ID,
    PSEUDO_IMP_THREAD_PROCESS_ID,
    PSEUDO_AFTER_LAST
};
#define REG_PSEUDO_LAST ((int)PSEUDO_AFTER_LAST - 1)
#define REG_PSEUDO_COUNT (REG_PSEUDO_LAST - REG_PSEUDO_FIRST + 1)

#define REG_USER_FIRST 0x7fffff00
// Could support more user registers by allowing letters as names in
// addition to digits, or by allowing multiple digits.  Both may
// present compatibility issues.
#define REG_USER_COUNT 10
#define REG_USER_LAST  (REG_USER_FIRST + REG_USER_COUNT - 1)

enum
{
    REGVAL_ERROR,
    REGVAL_INT16,
    REGVAL_SUB32,
    REGVAL_INT32,
    REGVAL_SUB64,
    REGVAL_INT64,
    REGVAL_INT64N,   // 64-bit + Nat bit
    REGVAL_FLOAT8,
    // x86 80-bit FP.
    REGVAL_FLOAT10,
    // IA64 82-bit FP.
    REGVAL_FLOAT82,
    REGVAL_FLOAT16,
    REGVAL_VECTOR64,
    REGVAL_VECTOR128,
};

// Defines a mapping from register name to register index.
typedef struct _REGDEF
{
    char  *psz;
    ULONG index;
} REGDEF;

// Defines a mapping from an index to a portion of a register.
typedef struct _REGSUBDEF
{
    ULONG     subreg;
    ULONG     fullreg;
    ULONG     shift;
    ULONG64   mask;
} REGSUBDEF;

// Holds the contents of a register.
typedef struct _REGVAL
{
    int type;
    union
    {
        USHORT i16;
        ULONG i32;
        struct
        {
            ULONG64 i64;
            UCHAR Nat;
        };
        struct
        {
            ULONG low;
            ULONG high;
            UCHAR Nat;
        } i64Parts;
        double f8;
        UCHAR f10[10];
        UCHAR f82[11];
        struct
        {
            ULONG64 low;
            LONG64 high;
        } f16Parts;
        UCHAR f16[16];
        UCHAR bytes[16];
    };
} REGVAL;

//
// Defines sets of information to display when showing all registers.
//

// Cross-platform.  64-bit display takes precedence over 32-bit display
// if both are enabled.
#define REGALL_INT32            0x00000001
#define REGALL_INT64            0x00000002
#define REGALL_FLOAT            0x00000004

// Given specific meanings per-platform (3 is XMM on all platforms).
#define REGALL_EXTRA0           0x00000008
#define REGALL_EXTRA1           0x00000010
#define REGALL_EXTRA2           0x00000020
#define REGALL_XMMREG           0x00000040
#define REGALL_EXTRA4           0x00000080
#define REGALL_EXTRA5           0x00000100
#define REGALL_EXTRA6           0x00000200
#define REGALL_EXTRA7           0x00000400
#define REGALL_EXTRA8           0x00000800
#define REGALL_EXTRA9           0x00001000
#define REGALL_EXTRA10          0x00002000
#define REGALL_EXTRA11          0x00004000
#define REGALL_EXTRA12          0x00008000
#define REGALL_EXTRA13          0x00010000
#define REGALL_EXTRA14          0x00020000
#define REGALL_EXTRA15          0x00040000

#define REGALL_EXTRA_SHIFT      3

// Descriptions of REGALL_EXTRA flag meanings.
typedef struct _REGALLDESC
{
    ULONG Bit;
    char *Desc;
} REGALLDESC;

HRESULT InitReg(void);
void ParseRegCmd(void);
void ExpandUserRegs(PSTR Str);
BOOL NeedUpper(ULONG64 val);

void    GetRegVal(ULONG index, REGVAL *val);
ULONG   GetRegVal32(ULONG index);
ULONG64 GetRegVal64(ULONG index);
PCSTR   GetUserReg(ULONG index);

void SetRegVal(ULONG index, REGVAL *val);
void SetRegVal32(ULONG index, ULONG val);
void SetRegVal64(ULONG index, ULONG64 val);
BOOL SetUserReg(ULONG index, PCSTR val);

ULONG RegIndexFromName(PCSTR Name);
PCSTR RegNameFromIndex(ULONG Index);
REGSUBDEF* RegSubDefFromIndex(ULONG Index);
REGDEF* RegDefFromIndex(ULONG Index);
REGDEF* RegDefFromCount(ULONG Count);
ULONG RegCountFromIndex(ULONG Index);

HRESULT
OutputContext(
    IN PCROSS_PLATFORM_CONTEXT TargetContext,
    IN ULONG Flag
    );

HRESULT
OutputVirtualContext(
    IN ULONG64 ContextBase,
    IN ULONG Flag
    );

#endif // #ifndef _REGISTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\rpc_dbgeng.cpp ===
//----------------------------------------------------------------------------
//
// Engine interface proxies and stubs.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

// Generated headers.
#include "dbgeng_p.hpp"
#include "dbgeng_s.hpp"
#include "dbgsvc_p.hpp"
#include "dbgsvc_s.hpp"

//----------------------------------------------------------------------------
//
// Initialization.
//
//----------------------------------------------------------------------------

void
DbgRpcInitializeClient(void)
{
    DbgRpcInitializeStubTables_dbgeng(DBGRPC_SIF_DBGENG_FIRST);
    DbgRpcInitializeStubTables_dbgsvc(DBGRPC_SIF_DBGSVC_FIRST);

    // Ensure that the V1 interfaces can't change.
    C_ASSERT(DBGRPC_UNIQUE_IDebugAdvanced == 19156);
    C_ASSERT(DBGRPC_UNIQUE_IDebugBreakpoint == 76131);
    C_ASSERT(DBGRPC_UNIQUE_IDebugClient == 229769);
    C_ASSERT(DBGRPC_UNIQUE_IDebugControl == 590362);
    C_ASSERT(DBGRPC_UNIQUE_IDebugDataSpaces == 180033);
    C_ASSERT(DBGRPC_UNIQUE_IDebugEventCallbacks == 87804);
    C_ASSERT(DBGRPC_UNIQUE_IDebugInputCallbacks == 10391);
    C_ASSERT(DBGRPC_UNIQUE_IDebugOutputCallbacks == 9646);
    C_ASSERT(DBGRPC_UNIQUE_IDebugRegisters == 69746);
    C_ASSERT(DBGRPC_UNIQUE_IDebugSymbolGroup == 53300);
    C_ASSERT(DBGRPC_UNIQUE_IDebugSymbols == 376151);
    C_ASSERT(DBGRPC_UNIQUE_IDebugSystemObjects == 135421);

    // Ensure that the V2 interfaces can't change.
    C_ASSERT(DBGRPC_UNIQUE_IDebugClient2 == 258161);
    C_ASSERT(DBGRPC_UNIQUE_IDebugControl2 == 635813);
    C_ASSERT(DBGRPC_UNIQUE_IDebugDataSpaces2 == 231471);
    C_ASSERT(DBGRPC_UNIQUE_IDebugSymbols2 == 435328);
    C_ASSERT(DBGRPC_UNIQUE_IDebugSystemObjects2 == 155936);
}
    
//----------------------------------------------------------------------------
//
// Proxy and stub support.
//
//----------------------------------------------------------------------------

DbgRpcStubFunction
DbgRpcGetStub(USHORT StubIndex)
{
    USHORT If = (USHORT) DBGRPC_STUB_INDEX_INTERFACE(StubIndex);
    USHORT Mth = (USHORT) DBGRPC_STUB_INDEX_METHOD(StubIndex);
    DbgRpcStubFunctionTable* Table;

    if (If <= DBGRPC_SIF_DBGENG_LAST)
    {
        Table = g_DbgRpcStubs_dbgeng;
    }
    else if (If >= DBGRPC_SIF_DBGSVC_FIRST &&
             If >= DBGRPC_SIF_DBGSVC_LAST)
    {
        Table = g_DbgRpcStubs_dbgsvc;
        If -= DBGRPC_SIF_DBGSVC_FIRST;
    }
    else
    {
        return NULL;
    }
    if (Mth >= Table[If].Count)
    {
        return NULL;
    }

    return Table[If].Functions[Mth];
}

#if DBG
PCSTR
DbgRpcGetStubName(USHORT StubIndex)
{
    USHORT If = (USHORT) DBGRPC_STUB_INDEX_INTERFACE(StubIndex);
    USHORT Mth = (USHORT) DBGRPC_STUB_INDEX_METHOD(StubIndex);
    DbgRpcStubFunctionTable* Table;
    PCSTR** Names;

    if (If <= DBGRPC_SIF_DBGENG_LAST)
    {
        Table = g_DbgRpcStubs_dbgeng;
        Names = g_DbgRpcStubNames_dbgeng;
    }
    else if (If >= DBGRPC_SIF_DBGSVC_FIRST &&
             If >= DBGRPC_SIF_DBGSVC_LAST)
    {
        Table = g_DbgRpcStubs_dbgsvc;
        Names = g_DbgRpcStubNames_dbgsvc;
        If -= DBGRPC_SIF_DBGSVC_FIRST;
    }
    else
    {
        return "!InvalidInterface!";
    }
    if (Mth >= Table[If].Count)
    {
        return "!InvalidStubIndex!";
    }

    return Names[If][Mth];
}
#endif // #if DBG

HRESULT
DbgRpcPreallocProxy(REFIID InterfaceId, PVOID* Interface,
                    DbgRpcProxy** Proxy, PULONG IfUnique)
{
    HRESULT Status;
    
    Status = DbgRpcPreallocProxy_dbgeng(InterfaceId, Interface,
                                        Proxy, IfUnique);
    
    if (Status == E_NOINTERFACE)
    {
        Status = DbgRpcPreallocProxy_dbgsvc(InterfaceId, Interface,
                                            Proxy, IfUnique);
    }

    return Status;
}

void
DbgRpcDeleteProxy(class DbgRpcProxy* Proxy)
{
    // All proxies used here are similar simple single
    // vtable proxy objects so IDebugClient can represent them all.
    delete (ProxyIDebugClient*)Proxy;
}

HRESULT
DbgRpcServerThreadInitialize(void)
{
    return g_Target->ThreadInitialize();
}

void
DbgRpcServerThreadUninitialize(void)
{
    g_Target->ThreadUninitialize();
}

void
DbgRpcError(char* Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    MaskOutVa(DEBUG_OUTPUT_ERROR, Format, Args, TRUE);
    va_end(Args);
}

//----------------------------------------------------------------------------
//
// Generated RPC proxies and stubs.
//
//----------------------------------------------------------------------------

#include "dbgeng_p.cpp"
#include "dbgeng_s.cpp"

//----------------------------------------------------------------------------
//
// Hand-written proxies and stubs.
//
//----------------------------------------------------------------------------

STDMETHODIMP
ProxyIDebugClient::CreateClient(
    OUT PDEBUG_CLIENT* Client
    )
{
    DbgRpcConnection* Conn;

    // Always look up the owning connection.
    Conn = DbgRpcGetConnection(m_OwningThread);
    if (Conn == NULL)
    {
        return RPC_E_CONNECTION_TERMINATED;
    }

    if (GetCurrentThreadId() != m_OwningThread)
    {
        // The caller wants a new client for a new thread.
        // Create a new RPC connection based on the owning connection.
        DbgRpcTransport* Trans = Conn->m_Trans->Clone();
        if (Trans == NULL)
        {
            return E_OUTOFMEMORY;
        }

        return DbgRpcCreateServerConnection(Trans, &IID_IDebugClient,
                                            (IUnknown**)Client);
    }

    //
    // Just creating another client for the owning thread.
    // Normal RPC.
    //

    HRESULT Status;
    DbgRpcCall Call;
    PUCHAR Data;
    PDEBUG_CLIENT Proxy;

    if ((Data = Conn->StartCall(&Call, m_ObjectId,
                                DBGRPC_STUB_INDEX(m_InterfaceIndex,
                                                  DBGRPC_SMTH_IDebugClient_CreateClient),
                                0, sizeof(DbgRpcObjectId))) == NULL)
    {
        Status = E_OUTOFMEMORY;
    }
    else
    {
        if ((Proxy = DbgRpcPreallocIDebugClientProxy()) == NULL)
        {
            Status = E_OUTOFMEMORY;
        }
        else
        {
            Status = Conn->SendReceive(&Call, &Data);

            if (Status == S_OK)
            {
                *Client = (PDEBUG_CLIENT)
                    ((ProxyIDebugClient*)Proxy)->
                    InitializeProxy(*(DbgRpcObjectId*)Data, Proxy);
            }
            else
            {
                delete Proxy;
            }
        }

        Conn->FreeData(Data);
    }

    return Status;
}

STDMETHODIMP
ProxyIDebugClient::StartProcessServer(
    IN ULONG Flags,
    IN PCSTR Options,
    IN PVOID Reserved
    )
{
    if (::GetCurrentThreadId() != m_OwningThread)
    {
        return E_INVALIDARG;
    }

    if (Reserved != NULL)
    {
        return E_INVALIDARG;
    }

    DbgRpcConnection* Conn;
    DbgRpcCall Call;
    PUCHAR Data;
    HRESULT Status;
    ULONG Len = strlen(Options) + 1;

    if ((Conn = DbgRpcGetConnection(m_OwningThread)) == NULL ||
        (Data = Conn->StartCall(&Call, m_ObjectId,
                                DBGRPC_STUB_INDEX(m_InterfaceIndex,
                                                  DBGRPC_SMTH_IDebugClient_StartProcessServer),
                                Len + sizeof(ULONG), 0)) == NULL)
    {
        Status = E_OUTOFMEMORY;
    }
    else
    {
        PUCHAR InData = Data;
        *(ULONG*)InData = Flags;
        InData += sizeof(ULONG);
        memcpy(InData, Options, Len);

        Status = Conn->SendReceive(&Call, &Data);
        Conn->FreeData(Data);
    }

    return Status;
}

STDMETHODIMP
ProxyIDebugClient2::CreateClient(
    OUT PDEBUG_CLIENT* Client
    )
{
    DbgRpcConnection* Conn;

    // Always look up the owning connection.
    Conn = DbgRpcGetConnection(m_OwningThread);
    if (Conn == NULL)
    {
        return RPC_E_CONNECTION_TERMINATED;
    }

    if (GetCurrentThreadId() != m_OwningThread)
    {
        // The caller wants a new client for a new thread.
        // Create a new RPC connection based on the owning connection.
        DbgRpcTransport* Trans = Conn->m_Trans->Clone();
        if (Trans == NULL)
        {
            return E_OUTOFMEMORY;
        }

        return DbgRpcCreateServerConnection(Trans, &IID_IDebugClient,
                                            (IUnknown**)Client);
    }

    //
    // Just creating another client for the owning thread.
    // Normal RPC.
    //

    HRESULT Status;
    DbgRpcCall Call;
    PUCHAR Data;
    PDEBUG_CLIENT Proxy;

    if ((Data = Conn->StartCall(&Call, m_ObjectId,
                                DBGRPC_STUB_INDEX(m_InterfaceIndex,
                                                  DBGRPC_SMTH_IDebugClient2_CreateClient),
                                0, sizeof(DbgRpcObjectId))) == NULL)
    {
        Status = E_OUTOFMEMORY;
    }
    else
    {
        if ((Proxy = DbgRpcPreallocIDebugClientProxy()) == NULL)
        {
            Status = E_OUTOFMEMORY;
        }
        else
        {
            Status = Conn->SendReceive(&Call, &Data);

            if (Status == S_OK)
            {
                *Client = (PDEBUG_CLIENT)
                    ((ProxyIDebugClient*)Proxy)->
                    InitializeProxy(*(DbgRpcObjectId*)Data, Proxy);
            }
            else
            {
                delete Proxy;
            }
        }

        Conn->FreeData(Data);
    }

    return Status;
}

STDMETHODIMP
ProxyIDebugClient2::StartProcessServer(
    IN ULONG Flags,
    IN PCSTR Options,
    IN PVOID Reserved
    )
{
    if (::GetCurrentThreadId() != m_OwningThread)
    {
        return E_INVALIDARG;
    }

    if (Reserved != NULL)
    {
        return E_INVALIDARG;
    }

    DbgRpcConnection* Conn;
    DbgRpcCall Call;
    PUCHAR Data;
    HRESULT Status;
    ULONG Len = strlen(Options) + 1;

    if ((Conn = DbgRpcGetConnection(m_OwningThread)) == NULL ||
        (Data = Conn->StartCall(&Call, m_ObjectId,
                                DBGRPC_STUB_INDEX(m_InterfaceIndex,
                                                  DBGRPC_SMTH_IDebugClient2_StartProcessServer),
                                Len + sizeof(ULONG), 0)) == NULL)
    {
        Status = E_OUTOFMEMORY;
    }
    else
    {
        PUCHAR InData = Data;
        *(ULONG*)InData = Flags;
        InData += sizeof(ULONG);
        memcpy(InData, Options, Len);

        Status = Conn->SendReceive(&Call, &Data);
        Conn->FreeData(Data);
    }

    return Status;
}

//
// The following methods are hand-written to convert
// varargs output into simple strings before sending
// them on.
//

STDMETHODIMPV
ProxyIDebugControl::Output(
    IN ULONG Mask,
    IN PCSTR Format,
    ...
    )
{
    va_list Args;
    HRESULT Status;

    if (::GetCurrentThreadId() != m_OwningThread)
    {
        return E_INVALIDARG;
    }

    va_start(Args, Format);
    Status = OutputVaList(Mask, Format, Args);
    va_end(Args);
    return Status;
}

STDMETHODIMP
ProxyIDebugControl::OutputVaList(
    THIS_
    IN ULONG Mask,
    IN PCSTR Format,
    IN va_list Args
    )
{
    int Len;

    // Need the engine lock for the global buffers.
    ENTER_ENGINE();

    if (TranslateFormat(g_FormatBuffer, Format, Args, OUT_BUFFER_SIZE - 1))
    {
        Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1,
                         g_FormatBuffer, Args);
    }
    else
    {
        Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1, Format, Args);
    }
    if (Len <= 0)
    {
        LEAVE_ENGINE();
        return E_INVALIDARG;
    }
    else
    {
        Len++;
    }

    DbgRpcConnection* Conn;
    DbgRpcCall Call;
    PUCHAR Data;
    HRESULT Status;

    if ((Conn = DbgRpcGetConnection(m_OwningThread)) == NULL ||
        (Data = Conn->StartCall(&Call, m_ObjectId,
                                DBGRPC_STUB_INDEX(DBGRPC_SIF_IDebugControl,
                                                  DBGRPC_SMTH_IDebugControl_OutputVaList),
                                Len + sizeof(ULONG), 0)) == NULL)
    {
        LEAVE_ENGINE();
        Status = E_OUTOFMEMORY;
    }
    else
    {
        PUCHAR InData = Data;
        *(ULONG*)InData = Mask;
        InData += sizeof(ULONG);
        memcpy(InData, g_OutBuffer, Len);

        LEAVE_ENGINE();

        Status = Conn->SendReceive(&Call, &Data);
        Conn->FreeData(Data);
    }

    return Status;
}

STDMETHODIMPV
ProxyIDebugControl::ControlledOutput(
    THIS_
    IN ULONG OutputControl,
    IN ULONG Mask,
    IN PCSTR Format,
    ...
    )
{
    va_list Args;
    HRESULT Status;

    if (::GetCurrentThreadId() != m_OwningThread)
    {
        return E_INVALIDARG;
    }

    va_start(Args, Format);
    Status = ControlledOutputVaList(OutputControl, Mask, Format, Args);
    va_end(Args);
    return Status;
}

STDMETHODIMP
ProxyIDebugControl::ControlledOutputVaList(
    THIS_
    IN ULONG OutputControl,
    IN ULONG Mask,
    IN PCSTR Format,
    IN va_list Args
    )
{
    int Len;

    // Need the engine lock for the global buffers.
    ENTER_ENGINE();

    if (TranslateFormat(g_FormatBuffer, Format, Args, OUT_BUFFER_SIZE - 1))
    {
        Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1,
                         g_FormatBuffer, Args);
    }
    else
    {
        Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1, Format, Args);
    }
    if (Len <= 0)
    {
        LEAVE_ENGINE();
        return E_INVALIDARG;
    }
    else
    {
        Len++;
    }

    DbgRpcConnection* Conn;
    DbgRpcCall Call;
    PUCHAR Data;
    HRESULT Status;

    if ((Conn = DbgRpcGetConnection(m_OwningThread)) == NULL ||
        (Data = Conn->StartCall(&Call, m_ObjectId,
                                DBGRPC_STUB_INDEX(DBGRPC_SIF_IDebugControl,
                                                  DBGRPC_SMTH_IDebugControl_ControlledOutputVaList),
                                Len + 2 * sizeof(ULONG), 0)) == NULL)
    {
        LEAVE_ENGINE();
        Status = E_OUTOFMEMORY;
    }
    else
    {
        PUCHAR InData = Data;
        *(ULONG*)InData = OutputControl;
        InData += sizeof(ULONG);
        *(ULONG*)InData = Mask;
        InData += sizeof(ULONG);
        memcpy(InData, g_OutBuffer, Len);

        LEAVE_ENGINE();

        Status = Conn->SendReceive(&Call, &Data);
        Conn->FreeData(Data);
    }

    return Status;
}

STDMETHODIMPV
ProxyIDebugControl::OutputPrompt(
    IN ULONG OutputControl,
    IN OPTIONAL PCSTR Format,
    ...
    )
{
    va_list Args;
    HRESULT Status;

    if (::GetCurrentThreadId() != m_OwningThread)
    {
        return E_INVALIDARG;
    }

    va_start(Args, Format);
    Status = OutputPromptVaList(OutputControl, Format, Args);
    va_end(Args);
    return Status;
}

STDMETHODIMP
ProxyIDebugControl::OutputPromptVaList(
    THIS_
    IN ULONG OutputControl,
    IN OPTIONAL PCSTR Format,
    IN va_list Args
    )
{
    int Len;

    if (Format != NULL)
    {
        // Need the engine lock for the global buffers.
        ENTER_ENGINE();

        if (TranslateFormat(g_FormatBuffer, Format, Args, OUT_BUFFER_SIZE - 1))
        {
            Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1,
                             g_FormatBuffer, Args);
        }
        else
        {
            Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1, Format, Args);
        }
        if (Len <= 0)
        {
            LEAVE_ENGINE();
            return E_INVALIDARG;
        }
        else
        {
            Len++;
        }
    }
    else
    {
        Len = 0;
    }

    DbgRpcConnection* Conn;
    DbgRpcCall Call;
    PUCHAR Data;
    HRESULT Status;

    // Presence/absence of text will be detected in the stub
    // by checking the input size on the call.
    if ((Conn = DbgRpcGetConnection(m_OwningThread)) == NULL ||
        (Data = Conn->StartCall(&Call, m_ObjectId,
                                DBGRPC_STUB_INDEX(DBGRPC_SIF_IDebugControl,
                                                  DBGRPC_SMTH_IDebugControl_OutputPromptVaList),
                                Len + sizeof(ULONG), 0)) == NULL)
    {
        if (Format != NULL)
        {
            LEAVE_ENGINE();
        }
        Status = E_OUTOFMEMORY;
    }
    else
    {
        PUCHAR InData = Data;
        *(ULONG*)InData = OutputControl;
        InData += sizeof(ULONG);
        memcpy(InData, g_OutBuffer, Len);

        if (Format != NULL)
        {
            LEAVE_ENGINE();
        }

        Status = Conn->SendReceive(&Call, &Data);
        Conn->FreeData(Data);
    }

    return Status;
}

STDMETHODIMPV
ProxyIDebugControl2::Output(
    IN ULONG Mask,
    IN PCSTR Format,
    ...
    )
{
    va_list Args;
    HRESULT Status;

    if (::GetCurrentThreadId() != m_OwningThread)
    {
        return E_INVALIDARG;
    }

    va_start(Args, Format);
    Status = OutputVaList(Mask, Format, Args);
    va_end(Args);
    return Status;
}

STDMETHODIMP
ProxyIDebugControl2::OutputVaList(
    THIS_
    IN ULONG Mask,
    IN PCSTR Format,
    IN va_list Args
    )
{
    int Len;

    // Need the engine lock for the global buffers.
    ENTER_ENGINE();

    if (TranslateFormat(g_FormatBuffer, Format, Args, OUT_BUFFER_SIZE - 1))
    {
        Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1,
                         g_FormatBuffer, Args);
    }
    else
    {
        Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1, Format, Args);
    }
    if (Len <= 0)
    {
        LEAVE_ENGINE();
        return E_INVALIDARG;
    }
    else
    {
        Len++;
    }

    DbgRpcConnection* Conn;
    DbgRpcCall Call;
    PUCHAR Data;
    HRESULT Status;

    if ((Conn = DbgRpcGetConnection(m_OwningThread)) == NULL ||
        (Data = Conn->StartCall(&Call, m_ObjectId,
                                DBGRPC_STUB_INDEX(DBGRPC_SIF_IDebugControl2,
                                                  DBGRPC_SMTH_IDebugControl2_OutputVaList),
                                Len + sizeof(ULONG), 0)) == NULL)
    {
        LEAVE_ENGINE();
        Status = E_OUTOFMEMORY;
    }
    else
    {
        PUCHAR InData = Data;
        *(ULONG*)InData = Mask;
        InData += sizeof(ULONG);
        memcpy(InData, g_OutBuffer, Len);

        LEAVE_ENGINE();

        Status = Conn->SendReceive(&Call, &Data);
        Conn->FreeData(Data);
    }

    return Status;
}

STDMETHODIMPV
ProxyIDebugControl2::ControlledOutput(
    THIS_
    IN ULONG OutputControl,
    IN ULONG Mask,
    IN PCSTR Format,
    ...
    )
{
    va_list Args;
    HRESULT Status;

    if (::GetCurrentThreadId() != m_OwningThread)
    {
        return E_INVALIDARG;
    }

    va_start(Args, Format);
    Status = ControlledOutputVaList(OutputControl, Mask, Format, Args);
    va_end(Args);
    return Status;
}

STDMETHODIMP
ProxyIDebugControl2::ControlledOutputVaList(
    THIS_
    IN ULONG OutputControl,
    IN ULONG Mask,
    IN PCSTR Format,
    IN va_list Args
    )
{
    int Len;

    // Need the engine lock for the global buffers.
    ENTER_ENGINE();

    if (TranslateFormat(g_FormatBuffer, Format, Args, OUT_BUFFER_SIZE - 1))
    {
        Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1,
                         g_FormatBuffer, Args);
    }
    else
    {
        Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1, Format, Args);
    }
    if (Len <= 0)
    {
        LEAVE_ENGINE();
        return E_INVALIDARG;
    }
    else
    {
        Len++;
    }

    DbgRpcConnection* Conn;
    DbgRpcCall Call;
    PUCHAR Data;
    HRESULT Status;

    if ((Conn = DbgRpcGetConnection(m_OwningThread)) == NULL ||
        (Data = Conn->StartCall(&Call, m_ObjectId,
                                DBGRPC_STUB_INDEX(DBGRPC_SIF_IDebugControl2,
                                                  DBGRPC_SMTH_IDebugControl2_ControlledOutputVaList),
                                Len + 2 * sizeof(ULONG), 0)) == NULL)
    {
        LEAVE_ENGINE();
        Status = E_OUTOFMEMORY;
    }
    else
    {
        PUCHAR InData = Data;
        *(ULONG*)InData = OutputControl;
        InData += sizeof(ULONG);
        *(ULONG*)InData = Mask;
        InData += sizeof(ULONG);
        memcpy(InData, g_OutBuffer, Len);

        LEAVE_ENGINE();

        Status = Conn->SendReceive(&Call, &Data);
        Conn->FreeData(Data);
    }

    return Status;
}

STDMETHODIMPV
ProxyIDebugControl2::OutputPrompt(
    IN ULONG OutputControl,
    IN OPTIONAL PCSTR Format,
    ...
    )
{
    va_list Args;
    HRESULT Status;

    if (::GetCurrentThreadId() != m_OwningThread)
    {
        return E_INVALIDARG;
    }

    va_start(Args, Format);
    Status = OutputPromptVaList(OutputControl, Format, Args);
    va_end(Args);
    return Status;
}

STDMETHODIMP
ProxyIDebugControl2::OutputPromptVaList(
    THIS_
    IN ULONG OutputControl,
    IN OPTIONAL PCSTR Format,
    IN va_list Args
    )
{
    int Len;

    if (Format != NULL)
    {
        // Need the engine lock for the global buffers.
        ENTER_ENGINE();

        if (TranslateFormat(g_FormatBuffer, Format, Args, OUT_BUFFER_SIZE - 1))
        {
            Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1,
                             g_FormatBuffer, Args);
        }
        else
        {
            Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1, Format, Args);
        }
        if (Len <= 0)
        {
            LEAVE_ENGINE();
            return E_INVALIDARG;
        }
        else
        {
            Len++;
        }
    }
    else
    {
        Len = 0;
    }

    DbgRpcConnection* Conn;
    DbgRpcCall Call;
    PUCHAR Data;
    HRESULT Status;

    // Presence/absence of text will be detected in the stub
    // by checking the input size on the call.
    if ((Conn = DbgRpcGetConnection(m_OwningThread)) == NULL ||
        (Data = Conn->StartCall(&Call, m_ObjectId,
                                DBGRPC_STUB_INDEX(DBGRPC_SIF_IDebugControl2,
                                                  DBGRPC_SMTH_IDebugControl2_OutputPromptVaList),
                                Len + sizeof(ULONG), 0)) == NULL)
    {
        if (Format != NULL)
        {
            LEAVE_ENGINE();
        }
        Status = E_OUTOFMEMORY;
    }
    else
    {
        PUCHAR InData = Data;
        *(ULONG*)InData = OutputControl;
        InData += sizeof(ULONG);
        memcpy(InData, g_OutBuffer, Len);

        if (Format != NULL)
        {
            LEAVE_ENGINE();
        }

        Status = Conn->SendReceive(&Call, &Data);
        Conn->FreeData(Data);
    }

    return Status;
}

HRESULT
SFN_IDebugClient_StartProcessServer(
    IUnknown* __drpc_If,
    DbgRpcConnection* __drpc_Conn,
    DbgRpcCall* __drpc_Call,
    PUCHAR __drpc_InData,
    PUCHAR __drpc_OutData
    )
{
    ULONG Flags = *(ULONG*)__drpc_InData;
    __drpc_InData += sizeof(ULONG);
    return ((IDebugClient*)__drpc_If)->
        StartProcessServer(Flags, (PSTR)__drpc_InData, NULL);
}

HRESULT
SFN_IDebugClient2_StartProcessServer(
    IUnknown* __drpc_If,
    DbgRpcConnection* __drpc_Conn,
    DbgRpcCall* __drpc_Call,
    PUCHAR __drpc_InData,
    PUCHAR __drpc_OutData
    )
{
    ULONG Flags = *(ULONG*)__drpc_InData;
    __drpc_InData += sizeof(ULONG);
    return ((IDebugClient2*)__drpc_If)->
        StartProcessServer(Flags, (PSTR)__drpc_InData, NULL);
}

HRESULT
SFN_IDebugControl_OutputVaList(
    IUnknown* __drpc_If,
    DbgRpcConnection* __drpc_Conn,
    DbgRpcCall* __drpc_Call,
    PUCHAR __drpc_InData,
    PUCHAR __drpc_OutData
    )
{
    ULONG Mask = *(ULONG*)__drpc_InData;
    __drpc_InData += sizeof(ULONG);
    return ((IDebugControl*)__drpc_If)->
        Output(Mask, "%s", (PSTR)__drpc_InData);
}

HRESULT
SFN_IDebugControl_ControlledOutputVaList(
    IUnknown* __drpc_If,
    DbgRpcConnection* __drpc_Conn,
    DbgRpcCall* __drpc_Call,
    PUCHAR __drpc_InData,
    PUCHAR __drpc_OutData
    )
{
    ULONG OutputControl = *(ULONG*)__drpc_InData;
    __drpc_InData += sizeof(ULONG);
    ULONG Mask = *(ULONG*)__drpc_InData;
    __drpc_InData += sizeof(ULONG);
    return ((IDebugControl*)__drpc_If)->
        ControlledOutput(OutputControl, Mask, "%s", (PSTR)__drpc_InData);
}

HRESULT
SFN_IDebugControl_OutputPromptVaList(
    IUnknown* __drpc_If,
    DbgRpcConnection* __drpc_Conn,
    DbgRpcCall* __drpc_Call,
    PUCHAR __drpc_InData,
    PUCHAR __drpc_OutData
    )
{
    ULONG OutputControl = *(ULONG*)__drpc_InData;
    __drpc_InData += sizeof(ULONG);
    if (__drpc_Call->InSize > sizeof(ULONG))
    {
        return ((IDebugControl*)__drpc_If)->
            OutputPrompt(OutputControl, "%s", (PSTR)__drpc_InData);
    }
    else
    {
        return ((IDebugControl*)__drpc_If)->OutputPrompt(OutputControl, NULL);
    }
}

HRESULT
SFN_IDebugControl2_OutputVaList(
    IUnknown* __drpc_If,
    DbgRpcConnection* __drpc_Conn,
    DbgRpcCall* __drpc_Call,
    PUCHAR __drpc_InData,
    PUCHAR __drpc_OutData
    )
{
    ULONG Mask = *(ULONG*)__drpc_InData;
    __drpc_InData += sizeof(ULONG);
    return ((IDebugControl2*)__drpc_If)->
        Output(Mask, "%s", (PSTR)__drpc_InData);
}

HRESULT
SFN_IDebugControl2_ControlledOutputVaList(
    IUnknown* __drpc_If,
    DbgRpcConnection* __drpc_Conn,
    DbgRpcCall* __drpc_Call,
    PUCHAR __drpc_InData,
    PUCHAR __drpc_OutData
    )
{
    ULONG OutputControl = *(ULONG*)__drpc_InData;
    __drpc_InData += sizeof(ULONG);
    ULONG Mask = *(ULONG*)__drpc_InData;
    __drpc_InData += sizeof(ULONG);
    return ((IDebugControl2*)__drpc_If)->
        ControlledOutput(OutputControl, Mask, "%s", (PSTR)__drpc_InData);
}

HRESULT
SFN_IDebugControl2_OutputPromptVaList(
    IUnknown* __drpc_If,
    DbgRpcConnection* __drpc_Conn,
    DbgRpcCall* __drpc_Call,
    PUCHAR __drpc_InData,
    PUCHAR __drpc_OutData
    )
{
    ULONG OutputControl = *(ULONG*)__drpc_InData;
    __drpc_InData += sizeof(ULONG);
    if (__drpc_Call->InSize > sizeof(ULONG))
    {
        return ((IDebugControl2*)__drpc_If)->
            OutputPrompt(OutputControl, "%s", (PSTR)__drpc_InData);
    }
    else
    {
        return ((IDebugControl2*)__drpc_If)->OutputPrompt(OutputControl, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\splay.cpp ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    Splay.cpp

Abstract:

    Stolen from ntos\rtl\splay.c

    Copied here to avoid pulling in an obj from another project.

--*/

#include "ntsdp.hpp"


#define SwapPointers(Type, Ptr1, Ptr2) {      \
    Type _SWAP_POINTER_TEMP;                  \
    _SWAP_POINTER_TEMP = (Ptr1);              \
    (Ptr1) = (Ptr2);                          \
    (Ptr2) = _SWAP_POINTER_TEMP;              \
    }

#define ParentsChildPointerAddress(Links) ( \
    RtlIsLeftChild(Links) ?                 \
        &(((Links)->Parent)->LeftChild)     \
    :                                       \
        &(((Links)->Parent)->RightChild)    \
    )

PRTL_SPLAY_LINKS
pRtlSubtreePredecessor (
    IN PRTL_SPLAY_LINKS Links
    );

VOID
SwapSplayLinks (
    IN PRTL_SPLAY_LINKS Link1,
    IN PRTL_SPLAY_LINKS Link2
    );


PRTL_SPLAY_LINKS
pRtlSplay (
    IN PRTL_SPLAY_LINKS Links
    )

/*++

Routine Description:

    The Splay function takes as input a pointer to a splay link in a tree
    and splays the tree.  Its function return value is a pointer to the
    root of the splayed tree.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - returns a pointer to the root of the splayed tree.

--*/

{
    PRTL_SPLAY_LINKS L;
    PRTL_SPLAY_LINKS P;
    PRTL_SPLAY_LINKS G;

    //
    //  while links is not the root we need to keep rotating it toward
    //  the root
    //

    L = Links;

    while (!RtlIsRoot(L)) {

        P = RtlParent(L);
        G = RtlParent(P);

        if (RtlIsLeftChild(L)) {

            if (RtlIsRoot(P)) {

                /*
                  we have the following case

                          P           L
                         / \         / \
                        L   c  ==>  a   P
                       / \             / \
                      a   b           b   c
                */

                //
                //  Connect P & b
                //

                P->LeftChild = L->RightChild;
                if (P->LeftChild != NULL) {P->LeftChild->Parent = P;}

                //
                //  Connect L & P
                //

                L->RightChild = P;
                P->Parent = L;

                //
                //  Make L the root
                //

                L->Parent = L;

            } else if (RtlIsLeftChild(P)) {

                /*
                  we have the following case

                          |           |
                          G           L
                         / \         / \
                        P   d  ==>  a   P
                       / \             / \
                      L   c           b   G
                     / \                 / \
                    a   b               c   d
                */

                //
                //  Connect P & b
                //

                P->LeftChild = L->RightChild;
                if (P->LeftChild != NULL) {P->LeftChild->Parent = P;}

                //
                //  Connect G & c
                //

                G->LeftChild = P->RightChild;
                if (G->LeftChild != NULL) {G->LeftChild->Parent = G;}

                //
                //  Connect L & Great GrandParent
                //

                if (RtlIsRoot(G)) {
                    L->Parent = L;
                } else {
                    L->Parent = G->Parent;
                    *(ParentsChildPointerAddress(G)) = L;
                }

                //
                //  Connect L & P
                //

                L->RightChild = P;
                P->Parent = L;

                //
                //  Connect P & G
                //

                P->RightChild = G;
                G->Parent = P;

            } else { // RtlIsRightChild(Parent)

                /*
                  we have the following case

                        |                |
                        G                L
                       / \             /   \
                      a   P           G     P
                         / \         / \   / \
                        L   d  ==>  a   b c   d
                       / \
                      b   c
                */

                //
                //  Connect G & b
                //

                G->RightChild = L->LeftChild;
                if (G->RightChild != NULL) {G->RightChild->Parent = G;}

                //
                //  Connect P & c
                //

                P->LeftChild = L->RightChild;
                if (P->LeftChild != NULL) {P->LeftChild->Parent = P;}

                //
                //  Connect L & Great GrandParent
                //

                if (RtlIsRoot(G)) {
                    L->Parent = L;
                } else {
                    L->Parent = G->Parent;
                    *(ParentsChildPointerAddress(G)) = L;
                }

                //
                //  Connect L & G
                //

                L->LeftChild = G;
                G->Parent = L;

                //
                //  Connect L & P
                //

                L->RightChild = P;
                P->Parent = L;

            }

        } else { // RtlIsRightChild(L)

            if (RtlIsRoot(P)) {

                /*
                  we have the following case

                        P               L
                       / \             / \
                      a   L           P   c
                         / \         / \
                        b   c  ==>  a   b
                */

                //
                //  Connect P & b
                //

                P->RightChild = L->LeftChild;
                if (P->RightChild != NULL) {P->RightChild->Parent = P;}

                //
                //  Connect P & L
                //

                L->LeftChild = P;
                P->Parent = L;

                //
                //  Make L the root
                //

                L->Parent = L;

            } else if (RtlIsRightChild(P)) {

                /*
                  we have the following case

                      |                   |
                      G                   L
                     / \                 / \
                    a   P               P   d
                       / \             / \
                      b   L           G   c
                         / \         / \
                        c   d  ==>  a   b
                */

                //
                //  Connect G & b
                //

                G->RightChild = P->LeftChild;
                if (G->RightChild != NULL) {G->RightChild->Parent = G;}

                //
                //  Connect P & c
                //

                P->RightChild = L->LeftChild;
                if (P->RightChild != NULL) {P->RightChild->Parent = P;}

                //
                //  Connect L & Great GrandParent
                //

                if (RtlIsRoot(G)) {
                    L->Parent = L;
                } else {
                    L->Parent = G->Parent;
                    *(ParentsChildPointerAddress(G)) = L;
                }

                //
                //  Connect L & P
                //

                L->LeftChild = P;
                P->Parent = L;

                //
                //  Connect P & G
                //

                P->LeftChild = G;
                G->Parent = P;

            } else { // RtlIsLeftChild(P)

                /*
                  we have the following case

                          |              |
                          G              L
                         / \           /   \
                        P   d         P     G
                       / \           / \   / \
                      a   L    ==>  a   b c   d
                         / \
                        b   c
                */

                //
                //  Connect P & b
                //

                P->RightChild = L->LeftChild;
                if (P->RightChild != NULL) {P->RightChild->Parent = P;}

                //
                //  Connect G & c
                //

                G->LeftChild = L->RightChild;
                if (G->LeftChild != NULL) {G->LeftChild->Parent = G;}

                //
                //  Connect L & Great GrandParent
                //

                if (RtlIsRoot(G)) {
                    L->Parent = L;
                } else {
                    L->Parent = G->Parent;
                    *(ParentsChildPointerAddress(G)) = L;
                }

                //
                //  Connect L & P
                //

                L->LeftChild = P;
                P->Parent = L;

                //
                //  Connect L & G
                //

                L->RightChild = G;
                G->Parent = L;

            }
        }
    }

    return L;
}


PRTL_SPLAY_LINKS
pRtlDelete (
    IN PRTL_SPLAY_LINKS Links
    )

/*++

Routine Description:

    The Delete function takes as input a pointer to a splay link in a tree
    and deletes that node from the tree.  Its function return value is a
    pointer to the root of the tree.  If the tree is now empty, the return
    value is NULL.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - returns a pointer to the root of the tree.

--*/

{
    PRTL_SPLAY_LINKS Predecessor;
    PRTL_SPLAY_LINKS Parent;
    PRTL_SPLAY_LINKS Child;

    PRTL_SPLAY_LINKS *ParentChildPtr;

    //
    //  First check to see if Links as two children.  If it does then swap
    //  Links with its subtree predecessor.  Now we are guaranteed that Links
    //  has at most one child.
    //

    if ((RtlLeftChild(Links) != NULL) && (RtlRightChild(Links) != NULL)) {

        //
        //  get the predecessor, and swap their position in the tree
        //

        Predecessor = pRtlSubtreePredecessor(Links);
        SwapSplayLinks(Predecessor, Links);

    }

    //
    //  If Links has no children then delete links by checking if it is
    //  already the root or has a parent.  If it is the root then the
    //  tree is now empty, otherwise it set the appropriate parent's child
    //  pointer (i.e., the one to links) to NULL, and splay the parent.
    //

    if ((RtlLeftChild(Links) == NULL) && (RtlRightChild(Links) == NULL)) {

        //
        //  Links has no children, if it is the root then return NULL
        //

        if (RtlIsRoot(Links)) {

            return NULL;
        }

        //
        //  Links as not children and is not the root, so to the parent's
        //  child pointer to NULL and splay the parent.
        //

        Parent = RtlParent(Links);

        ParentChildPtr = ParentsChildPointerAddress(Links);
        *ParentChildPtr = NULL;

        return pRtlSplay(Parent);

    }

    //
    //  otherwise Links has one child.  If it is the root then make the child
    //  the new root, otherwise link together the child and parent, and splay
    //  the parent.  But first remember who our child is.
    //

    if (RtlLeftChild(Links) != NULL) {
        Child = RtlLeftChild(Links);
    } else {
        Child = RtlRightChild(Links);
    }

    //
    //  If links is the root then we make the child the root and return the
    //  child.
    //

    if (RtlIsRoot(Links)) {
        Child->Parent = Child;
        return Child;
    }

    //
    //  Links is not the root, so set link's parent child pointer to be
    //  the child and the set child's parent to be link's parent, and splay
    //  the parent.
    //

    ParentChildPtr = ParentsChildPointerAddress(Links);
    *ParentChildPtr = Child;
    Child->Parent = Links->Parent;

    return pRtlSplay(RtlParent(Child));

}
#if 0

VOID
RtlDeleteNoSplay (
    IN PRTL_SPLAY_LINKS Links,
    IN OUT PRTL_SPLAY_LINKS *Root
    )

/*++

Routine Description:

    The Delete function takes as input a pointer to a splay link in a tree,
    a pointer to the callers pointer to the tree and deletes that node from
    the tree.  The caller's pointer is updated upon return.  If the tree is
    now empty, the value is NULL.

    Unfortunately, the original RtlDelete() always splays and this is not
    always a desireable side-effect.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

    Root - Pointer to the callers pointer to the root 

Return Value:

    None

--*/

{
    PRTL_SPLAY_LINKS Predecessor;
    PRTL_SPLAY_LINKS Parent;
    PRTL_SPLAY_LINKS Child;

    PRTL_SPLAY_LINKS *ParentChildPtr;

    //
    //  First check to see if Links as two children.  If it does then swap
    //  Links with its subtree predecessor.  Now we are guaranteed that Links
    //  has at most one child.
    //

    if ((RtlLeftChild(Links) != NULL) && (RtlRightChild(Links) != NULL)) {

        //
        //  get the predecessor, and swap their position in the tree
        //

        Predecessor = pRtlSubtreePredecessor(Links);

        if (RtlIsRoot(Links)) {

            //
            //  If we're switching with the root of the tree, fix the
            //  caller's root pointer
            //

            *Root = Predecessor;
        }

        SwapSplayLinks(Predecessor, Links);

    }

    //
    //  If Links has no children then delete links by checking if it is
    //  already the root or has a parent.  If it is the root then the
    //  tree is now empty, otherwise it set the appropriate parent's child
    //  pointer (i.e., the one to links) to NULL.
    //

    if ((RtlLeftChild(Links) == NULL) && (RtlRightChild(Links) == NULL)) {

        //
        //  Links has no children, if it is the root then set root to NULL
        //

        if (RtlIsRoot(Links)) {

            *Root = NULL;

            return;
        }

        //
        //  Links as not children and is not the root, so to the parent's
        //  child pointer to NULL.
        //

        ParentChildPtr = ParentsChildPointerAddress(Links);
        *ParentChildPtr = NULL;

        return;
    }

    //
    //  otherwise Links has one child.  If it is the root then make the child
    //  the new root, otherwise link together the child and parent. But first
    //  remember who our child is.
    //

    if (RtlLeftChild(Links) != NULL) {
        Child = RtlLeftChild(Links);
    } else {
        Child = RtlRightChild(Links);
    }

    //
    //  If links is the root then we make the child the root and return the
    //  child.
    //

    if (RtlIsRoot(Links)) {
        Child->Parent = Child;

        *Root = Child;

        return;
    }

    //
    //  Links is not the root, so set link's parent child pointer to be
    //  the child and the set child's parent to be link's parent.
    //

    ParentChildPtr = ParentsChildPointerAddress(Links);
    *ParentChildPtr = Child;
    Child->Parent = Links->Parent;

    return;
}


PRTL_SPLAY_LINKS
RtlSubtreeSuccessor (
    IN PRTL_SPLAY_LINKS Links
    )

/*++

Routine Description:

    The SubtreeSuccessor function takes as input a pointer to a splay link
    in a tree and returns a pointer to the successor of the input node of
    the substree rooted at the input node.  If there is not a successor, the
    return value is NULL.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - returns a pointer to the successor in the subtree

--*/

{
    PRTL_SPLAY_LINKS Ptr;

    /*
      check to see if there is a right subtree to the input link
      if there is then the subtree successor is the left most node in
      the right subtree.  That is find and return P in the following diagram

                  Links
                     \
                      .
                     .
                    .
                   /
                  P
                   \
    */

    if ((Ptr = RtlRightChild(Links)) != NULL) {

        while (RtlLeftChild(Ptr) != NULL) {
            Ptr = RtlLeftChild(Ptr);
        }

        return Ptr;

    }

    //
    //  otherwise we are do not have a subtree successor so we simply return
    //  NULL
    //

    return NULL;

}

#endif

PRTL_SPLAY_LINKS
pRtlSubtreePredecessor (
    IN PRTL_SPLAY_LINKS Links
    )

/*++

Routine Description:

    The SubtreePredecessor function takes as input a pointer to a splay link
    in a tree and returns a pointer to the predecessor of the input node of
    the substree rooted at the input node.  If there is not a predecessor,
    the return value is NULL.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - returns a pointer to the predecessor in the subtree

--*/

{
    PRTL_SPLAY_LINKS Ptr;

    //
    //  check to see if there is a left subtree to the input link
    //  if there is then the subtree predecessor is the right most node in
    //  the left subtree.  That is find and return P in the following diagram
    //
    //              Links
    //               /
    //              .
    //               .
    //                .
    //                 P
    //                /
    //

    if ((Ptr = RtlLeftChild(Links)) != NULL) {

        while (RtlRightChild(Ptr) != NULL) {
            Ptr = RtlRightChild(Ptr);
        }

        return Ptr;

    }

    //
    //  otherwise we are do not have a subtree predecessor so we simply return
    //  NULL
    //

    return NULL;

}

#if 0

PRTL_SPLAY_LINKS
RtlRealSuccessor (
    IN PRTL_SPLAY_LINKS Links
    )

/*++

Routine Description:

    The RealSuccessor function takes as input a pointer to a splay link
    in a tree and returns a pointer to the successor of the input node within
    the entire tree.  If there is not a successor, the return value is NULL.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - returns a pointer to the successor in the entire tree

--*/

{
    PRTL_SPLAY_LINKS Ptr;

    /*
      first check to see if there is a right subtree to the input link
      if there is then the real successor is the left most node in
      the right subtree.  That is find and return P in the following diagram

                  Links
                     \
                      .
                     .
                    .
                   /
                  P
                   \
    */

    if ((Ptr = RtlRightChild(Links)) != NULL) {

        while (RtlLeftChild(Ptr) != NULL) {
            Ptr = RtlLeftChild(Ptr);
        }

        return Ptr;

    }

    /*
      we do not have a right child so check to see if have a parent and if
      so find the first ancestor that we are a left decendent of. That
      is find and return P in the following diagram

                       P
                      /
                     .
                      .
                       .
                      Links
    */

    Ptr = Links;
    while (RtlIsRightChild(Ptr)) {
        Ptr = RtlParent(Ptr);
    }

    if (RtlIsLeftChild(Ptr)) {
        return RtlParent(Ptr);
    }

    //
    //  otherwise we are do not have a real successor so we simply return
    //  NULL
    //

    return NULL;

}


PRTL_SPLAY_LINKS
RtlRealPredecessor (
    IN PRTL_SPLAY_LINKS Links
    )

/*++

Routine Description:

    The RealPredecessor function takes as input a pointer to a splay link
    in a tree and returns a pointer to the predecessor of the input node
    within the entire tree.  If there is not a predecessor, the return value
    is NULL.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - returns a pointer to the predecessor in the entire tree

--*/

{
    PRTL_SPLAY_LINKS Ptr;

    /*
      first check to see if there is a left subtree to the input link
      if there is then the real predecessor is the right most node in
      the left subtree.  That is find and return P in the following diagram

                  Links
                   /
                  .
                   .
                    .
                     P
                    /
    */

    if ((Ptr = RtlLeftChild(Links)) != NULL) {

        while (RtlRightChild(Ptr) != NULL) {
            Ptr = RtlRightChild(Ptr);
        }

        return Ptr;

    }

    /*
      we do not have a left child so check to see if have a parent and if
      so find the first ancestor that we are a right decendent of. That
      is find and return P in the following diagram

                       P
                        \
                         .
                        .
                       .
                    Links
    */

    Ptr = Links;
    while (RtlIsLeftChild(Ptr)) {
        Ptr = RtlParent(Ptr);
    }

    if (RtlIsRightChild(Ptr)) {
        return RtlParent(Ptr);
    }

    //
    //  otherwise we are do not have a real predecessor so we simply return
    //  NULL
    //

    return NULL;

}
#endif

VOID
SwapSplayLinks (
    IN PRTL_SPLAY_LINKS Link1,
    IN PRTL_SPLAY_LINKS Link2
    )

{
    PRTL_SPLAY_LINKS *Parent1ChildPtr;
    PRTL_SPLAY_LINKS *Parent2ChildPtr;

    /*
      We have the following situation


             Parent1            Parent2
                |                  |
                |                  |
              Link1              Link2
               / \                / \
              /   \              /   \
            LC1   RC1          LC2   RC2

      where one of the links can possibly be the root and one of the links
      can possibly be a direct child of the other.  Without loss of
      generality we'll make link2 be the possible and root and link1 be
      the possible child.
    */

    if ((RtlIsRoot(Link1)) || (RtlParent(Link2) == Link1)) {
        SwapPointers(PRTL_SPLAY_LINKS, Link1, Link2);
    }

    //
    //  The four cases we need to handle are
    //
    //  1. Link1 is not a child of link2 and link2 is not the root
    //  2. Link1 is not a child of link2 and link2 is     the root
    //  3. Link1 is     a child of link2 and link2 is not the root
    //  4. Link1 is     a child of link2 and link2 is     the root
    //
    //
    //  Each case will be handled separately
    //

    if (RtlParent(Link1) != Link2) {

        if (!RtlIsRoot(Link2)) {

            //
            //  Case 1 the initial steps are:
            //
            //  1. get both parent child pointers
            //  2. swap the parent child pointers
            //  3. swap the parent pointers
            //

            Parent1ChildPtr = ParentsChildPointerAddress(Link1);
            Parent2ChildPtr = ParentsChildPointerAddress(Link2);

            SwapPointers(PRTL_SPLAY_LINKS, *Parent1ChildPtr, *Parent2ChildPtr);

            SwapPointers(PRTL_SPLAY_LINKS, Link1->Parent, Link2->Parent);

        } else {

            //
            //  Case 2 the initial steps are:
            //
            //  1. Set link1's parent child pointer to link2
            //  2. Set parent pointer of link2 to link1's parent
            //  3. Set parent pointer of link1 to be itself
            //

            Parent1ChildPtr = ParentsChildPointerAddress(Link1);
            *Parent1ChildPtr = Link2;

            Link2->Parent = Link1->Parent;

            Link1->Parent = Link1;

        }

        //
        //  Case 1 and 2 common steps are:
        //
        //  1. swap the child pointers
        //

        SwapPointers(PRTL_SPLAY_LINKS, Link1->LeftChild, Link2->LeftChild);
        SwapPointers(PRTL_SPLAY_LINKS, Link1->RightChild, Link2->RightChild);

    } else { // RtlParent(Link1) == Link2

        if (!RtlIsRoot(Link2)) {

            //
            //  Case 3 the initial steps are:
            //
            //  1. Set Link2's parent child pointer to link1
            //  2. Set Link1's parent pointer to parent of link2
            //

            Parent2ChildPtr = ParentsChildPointerAddress(Link2);
            *Parent2ChildPtr = Link1;

            Link1->Parent = Link2->Parent;

        } else {

            //
            //  Case 4 the initial steps are:
            //
            //  1. Set Link1's parent pointer to be link1
            //

            Link1->Parent = Link1;

        }

        //
        //  Case 3 and 4 common steps are:
        //
        //  1. Swap the child pointers
        //  2. if link1 was a left child (i.e., RtlLeftChild(Link1) == Link1)
        //     then set left child of link1 to link2
        //     else set right child of link1 to link2
        //

        SwapPointers(PRTL_SPLAY_LINKS, Link1->LeftChild, Link2->LeftChild);
        SwapPointers(PRTL_SPLAY_LINKS, Link1->RightChild, Link2->RightChild);

        if (Link1->LeftChild == Link1) {
            Link1->LeftChild = Link2;
        } else {
            Link1->RightChild = Link2;
        }

    }

    //
    //  Case 1, 2, 3, 4 common (and final) steps are:
    //
    //  1. Fix the parent pointers of the left and right children
    //

    if (Link1->LeftChild  != NULL) {Link1->LeftChild->Parent  = Link1;}
    if (Link1->RightChild != NULL) {Link1->RightChild->Parent = Link1;}
    if (Link2->LeftChild  != NULL) {Link2->LeftChild->Parent  = Link2;}
    if (Link2->RightChild != NULL) {Link2->RightChild->Parent = Link2;}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\procthrd.cpp ===
//----------------------------------------------------------------------------
//
// Process and thread routines.
//
// Copyright (C) Microsoft Corporation, 1997-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

ULONG g_NextProcessUserId;
ULONG g_AllProcessFlags;
ULONG g_NumberProcesses;
ULONG g_TotalNumberThreads;
ULONG g_MaxThreadsInProcess;

PPROCESS_INFO g_ProcessHead;
PPROCESS_INFO g_CurrentProcess;

// Thread specified in thread commands.  Used for specific
// thread stepping and execution.
PTHREAD_INFO g_SelectedThread;
ULONG g_SelectExecutionThread;

PTHREAD_INFO g_RegContextThread;
ULONG g_RegContextProcessor = -1;
PTHREAD_INFO g_RegContextSaved;
ULONG64 g_SaveImplicitThread;
ULONG64 g_SaveImplicitProcess;

ULONG g_AllPendingFlags;

PPROCESS_INFO
FindProcessByUserId(
    ULONG Id
    )
{
    PPROCESS_INFO Process;

    Process = g_ProcessHead;
    while (Process && Process->UserId != Id)
    {
        Process = Process->Next;
    }

    return Process;
}

PTHREAD_INFO
FindThreadByUserId(
    PPROCESS_INFO Process,
    ULONG Id
    )
{
    PTHREAD_INFO Thread;

    if (Process != NULL)
    {
        for (Thread = Process->ThreadHead;
             Thread != NULL;
             Thread = Thread->Next)
        {
            if (Thread->UserId == Id)
            {
                return Thread;
            }
        }
    }
    else
    {
        for (Process = g_ProcessHead;
             Process != NULL;
             Process = Process->Next)
        {
            for (Thread = Process->ThreadHead;
                 Thread != NULL;
                 Thread = Thread->Next)
            {
                if (Thread->UserId == Id)
                {
                    return Thread;
                }
            }
        }
    }

    return NULL;
}

PPROCESS_INFO
FindProcessBySystemId(
    ULONG Id
    )
{
    PPROCESS_INFO Process;

    Process = g_ProcessHead;
    while (Process && Process->SystemId != Id)
    {
        Process = Process->Next;
    }

    return Process;
}

PTHREAD_INFO
FindThreadBySystemId(
    PPROCESS_INFO Process,
    ULONG Id
    )
{
    PTHREAD_INFO Thread;

    if (Process != NULL)
    {
        for (Thread = Process->ThreadHead;
             Thread != NULL;
             Thread = Thread->Next)
        {
            if (Thread->SystemId == Id)
            {
                return Thread;
            }
        }
    }
    else
    {
        for (Process = g_ProcessHead;
             Process != NULL;
             Process = Process->Next)
        {
            for (Thread = Process->ThreadHead;
                 Thread != NULL;
                 Thread = Thread->Next)
            {
                if (Thread->SystemId == Id)
                {
                    return Thread;
                }
            }
        }
    }

    return NULL;
}

PPROCESS_INFO
FindProcessByHandle(
    ULONG64 Handle
    )
{
    PPROCESS_INFO Process;

    Process = g_ProcessHead;
    while (Process && Process->FullHandle != Handle)
    {
        Process = Process->Next;
    }

    return Process;
}

PTHREAD_INFO
FindThreadByHandle(
    PPROCESS_INFO Process,
    ULONG64 Handle
    )
{
    PTHREAD_INFO Thread;

    if (Process != NULL)
    {
        for (Thread = Process->ThreadHead;
             Thread != NULL;
             Thread = Thread->Next)
        {
            if (Thread->Handle == Handle)
            {
                return Thread;
            }
        }
    }
    else
    {
        for (Process = g_ProcessHead;
             Process != NULL;
             Process = Process->Next)
        {
            for (Thread = Process->ThreadHead;
                 Thread != NULL;
                 Thread = Thread->Next)
            {
                if (Thread->Handle == Handle)
                {
                    return Thread;
                }
            }
        }
    }

    return NULL;
}

ULONG
FindNextThreadUserId(void)
{
    //
    // In a dump threads are never deleted so we don't
    // have to worry about trying to reuse low thread IDs.
    // Just do a simple incremental ID so that large numbers
    // of threads can be created quickly.
    //
    if (IS_DUMP_TARGET())
    {
        return g_TotalNumberThreads;
    }
    
    ULONG UserId = 0;
    
    // Find the lowest unused thread ID across all threads
    // in all processes.  Thread user IDs are kept unique
    // across all threads to prevent user confusion and also
    // to give extensions a unique ID for threads.
    for (;;)
    {
        PPROCESS_INFO Process;
        PTHREAD_INFO Thread;
            
        // Search all threads to see if the current ID is in use.
        for (Process = g_ProcessHead;
             Process != NULL;
             Process = Process->Next)
        {
            for (Thread = Process->ThreadHead;
                 Thread != NULL;
                 Thread = Thread->Next)
            {
                if (Thread->UserId == UserId)
                {
                    break;
                }
            }
            
            if (Thread != NULL)
            {
                break;
            }
        }

        if (Process != NULL)
        {
            // A thread is already using the current ID.
            // Try the next one.
            UserId++;
        }
        else
        {
            break;
        }
    }

    return UserId;
}

PPROCESS_INFO
AddProcess(
    ULONG SystemId,
    ULONG64 Handle,
    ULONG InitialThreadSystemId,
    ULONG64 InitialThreadHandle,
    ULONG64 InitialThreadDataOffset,
    ULONG64 StartOffset,
    ULONG Flags,
    ULONG Options,
    ULONG InitialThreadFlags
    )
{
    PPROCESS_INFO ProcessNew;
    PPROCESS_INFO Process;

    ProcessNew = (PPROCESS_INFO)calloc(1, sizeof(PROCESS_INFO));
    if (!ProcessNew)
    {
        ErrOut("memory allocation failed\n");
        return NULL;
    }

    if (AddThread(ProcessNew, InitialThreadSystemId, InitialThreadHandle,
                  InitialThreadDataOffset, StartOffset,
                  InitialThreadFlags) == NULL)
    {
        free(ProcessNew);
        return NULL;
    }

    // Process IDs always increase with time to
    // prevent reuse of IDs.  New processes are
    // therefore always at the end of the sorted
    // ID list.
    if (g_ProcessHead == NULL)
    {
        ProcessNew->Next = g_ProcessHead;
        g_ProcessHead = ProcessNew;
    }
    else
    {
        Process = g_ProcessHead;
        while (Process->Next)
        {
            Process = Process->Next;
        }
        ProcessNew->Next = NULL;
        Process->Next = ProcessNew;
    }
    ProcessNew->UserId = g_NextProcessUserId++;
    ProcessNew->SystemId = SystemId;
    ProcessNew->FullHandle = Handle;
    ProcessNew->Handle = (HANDLE)(ULONG_PTR)Handle;
    ProcessNew->InitialBreak = IS_KERNEL_TARGET() ||
        (g_EngOptions & DEBUG_ENGOPT_INITIAL_BREAK) != 0;
    ProcessNew->InitialBreakWx86 =
        (g_EngOptions & DEBUG_ENGOPT_INITIAL_BREAK) != 0;
    ProcessNew->Flags = Flags;
    ProcessNew->Options = Options;
    g_AllProcessFlags |= Flags;

    g_NumberProcesses++;
    
    g_Sym->SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL64);
    g_Sym->MaxNameLength = MAX_SYMBOL_LEN;
    g_SymStart->SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL64);
    g_SymStart->MaxNameLength = MAX_SYMBOL_LEN;
    SymInitialize( ProcessNew->Handle, NULL, FALSE );
    SymRegisterCallback64( ProcessNew->Handle, SymbolCallbackFunction, 0 );

    if (IS_USER_TARGET() &&
        g_TargetMachineType != IMAGE_FILE_MACHINE_I386)
    {
        SymRegisterFunctionEntryCallback64
            (ProcessNew->Handle, TargetInfo::DynamicFunctionTableCallback,
             (ULONG_PTR)g_TargetMachine);
    }
        
    SetSymbolSearchPath(ProcessNew);

    return ProcessNew;
}

PTHREAD_INFO
AddThread(
    PPROCESS_INFO Process,
    ULONG SystemId,
    ULONG64 Handle,
    ULONG64 DataOffset,
    ULONG64 StartOffset,
    ULONG Flags
    )
{
    PTHREAD_INFO ThreadCurrent;
    PTHREAD_INFO ThreadAfter;
    PTHREAD_INFO ThreadNew;
    ULONG        UserId;

    ThreadNew = (PTHREAD_INFO)calloc(1, sizeof(THREAD_INFO));
    if (!ThreadNew)
    {
        ErrOut("memory allocation failed\n");
        return NULL;
    }

    UserId = FindNextThreadUserId();

    // Insert the thread into the process's thread list in
    // sorted order.
    ThreadCurrent = NULL;
    for (ThreadAfter = Process->ThreadHead;
         ThreadAfter != NULL;
         ThreadAfter = ThreadAfter->Next)
    {
        if (ThreadAfter->UserId > UserId)
        {
            break;
        }

        ThreadCurrent = ThreadAfter;
    }
        
    ThreadNew->Next = ThreadAfter;
    if (ThreadCurrent == NULL)
    {
        Process->ThreadHead = ThreadNew;
    }
    else
    {
        ThreadCurrent->Next = ThreadNew;
    }

    ThreadNew->Process = Process;
    Process->NumberThreads++;
    ThreadNew->UserId = UserId;

    ThreadNew->SystemId = SystemId;
    ThreadNew->Handle = Handle;
    ThreadNew->StartAddress = StartOffset;
    ThreadNew->Frozen = ThreadNew->Exited = FALSE;
    ThreadNew->DataOffset = DataOffset;
    ThreadNew->Flags = Flags;

    g_TotalNumberThreads++;
    if (Process->NumberThreads > g_MaxThreadsInProcess)
    {
        g_MaxThreadsInProcess = Process->NumberThreads;
    }
    
    return ThreadNew;
}

void
DeleteThread(PTHREAD_INFO Thread)
{
    Thread->Process->NumberThreads--;
    if (Thread->Process->CurrentThread == Thread)
    {
        Thread->Process->CurrentThread = NULL;
    }
    RemoveThreadBreakpoints(Thread);
    if (Thread->Flags & ENG_PROC_THREAD_CLOSE_HANDLE)
    {
        DBG_ASSERT(IS_LIVE_USER_TARGET());
        ((UserTargetInfo*)g_Target)->m_Services->CloseHandle(Thread->Handle);
    }
    free(Thread);

    PPROCESS_INFO Process;

    g_TotalNumberThreads--;
    g_MaxThreadsInProcess = 0;
    for (Process = g_ProcessHead;
         Process != NULL;
         Process = Process->Next)
    {
        if (Process->NumberThreads > g_MaxThreadsInProcess)
        {
            g_MaxThreadsInProcess = Process->NumberThreads;
        }
    }
}

void
UpdateAllProcessFlags(void)
{
    PPROCESS_INFO Process;
    
    g_AllProcessFlags = 0;
    for (Process = g_ProcessHead;
         Process != NULL;
         Process = Process->Next)
    {
        g_AllProcessFlags |= Process->Flags;
    }
}

void
DeleteProcess(PPROCESS_INFO Process)
{
    PDEBUG_IMAGE_INFO Image;
    PTHREAD_INFO Thread;

    while (Process->ThreadHead != NULL)
    {
        Thread = Process->ThreadHead;
        Process->ThreadHead = Thread->Next;
        DeleteThread(Thread);
    }
    
    // Suppress notifications until all images are deleted.
    g_EngNotify++;

    while (Image = Process->ImageHead)
    {
        Process->ImageHead = Image->Next;
        DelImage(Process, Image);
    }
    SymCleanup(Process->Handle);

    g_EngNotify--;
    NotifyChangeSymbolState(DEBUG_CSS_UNLOADS, 0, Process);

    RemoveProcessBreakpoints(Process);

    if (Process->Flags & ENG_PROC_THREAD_CLOSE_HANDLE)
    {
        DBG_ASSERT(IS_LIVE_USER_TARGET());
        ((UserTargetInfo*)g_Target)->m_Services->
            CloseHandle(Process->FullHandle);
    }
    
    free(Process);
    g_NumberProcesses--;

    UpdateAllProcessFlags();
}

void
RemoveAndDeleteProcess(PPROCESS_INFO Process, PPROCESS_INFO Prev)
{
    if (Prev == NULL)
    {
        g_ProcessHead = Process->Next;
    }
    else
    {
        Prev->Next = Process->Next;
    }
    DeleteProcess(Process);
}

BOOL
DeleteExitedInfos(void)
{
    PPROCESS_INFO Process;
    PPROCESS_INFO ProcessNext;
    PPROCESS_INFO ProcessPrev;
    BOOL DeletedSomething = FALSE;

    ProcessPrev = NULL;
    for (Process = g_ProcessHead;
         Process != NULL;
         Process = ProcessNext)
    {
        ProcessNext = Process->Next;
        
        if (Process->Exited)
        {
            RemoveAndDeleteProcess(Process, ProcessPrev);
            DeletedSomething = TRUE;
        }
        else
        {
            PTHREAD_INFO Thread;
            PTHREAD_INFO ThreadPrev;
            PTHREAD_INFO ThreadNext;
            
            ThreadPrev = NULL;
            for (Thread = Process->ThreadHead;
                 Thread != NULL;
                 Thread = ThreadNext)
            {
                ThreadNext = Thread->Next;
                
                if (Thread->Exited)
                {
                    DeleteThread(Thread);
                    DeletedSomething = TRUE;

                    if (ThreadPrev == NULL)
                    {
                        Process->ThreadHead = ThreadNext;
                    }
                    else
                    {
                        ThreadPrev->Next = ThreadNext;
                    }
                }
                else
                {
                    ThreadPrev = Thread;
                }
            }

            PDEBUG_IMAGE_INFO Image;
            PDEBUG_IMAGE_INFO ImagePrev;
            PDEBUG_IMAGE_INFO ImageNext;

            ImagePrev = NULL;
            for (Image = Process->ImageHead;
                 Image != NULL;
                 Image = ImageNext)
            {
                ImageNext = Image->Next;
                
                if (Image->Unloaded)
                {
                    ULONG64 ImageBase = Image->BaseOfImage;
                    
                    // Delay notification until the image
                    // is cleaned up and the image list
                    // repaired.
                    g_EngNotify++;
                    DelImage(Process, Image);
                    g_EngNotify--;
                    DeletedSomething = TRUE;

                    if (ImagePrev == NULL)
                    {
                        Process->ImageHead = ImageNext;
                    }
                    else
                    {
                        ImagePrev->Next = ImageNext;
                    }

                    NotifyChangeSymbolState(DEBUG_CSS_UNLOADS, ImageBase,
                                            Process);
                }
                else
                {
                    ImagePrev = Image;
                }
            }

            ProcessPrev = Process;
        }
    }

    return DeletedSomething;
}

void
OutputProcessInfo(
    char *s
    )
{
    PPROCESS_INFO   pProcess;
    PTHREAD_INFO    pThread;
    PDEBUG_IMAGE_INFO     pImage;

    // Kernel mode only has a virtual process and threads right
    // now so it isn't particularly interesting.
    if (IS_KERNEL_TARGET())
    {
        return;
    }
    
    VerbOut("OUTPUT_PROCESS: %s\n",s);
    pProcess = g_ProcessHead;
    while (pProcess)
    {
        VerbOut("id: %x  Handle: %I64x  index: %d\n",
                pProcess->SystemId,
                pProcess->FullHandle,
                pProcess->UserId);
        pThread = pProcess->ThreadHead;
        while (pThread)
        {
            VerbOut("  id: %x  hThread: %I64x  index: %d  addr: %s\n",
                    pThread->SystemId,
                    pThread->Handle,
                    pThread->UserId,
                    FormatAddr64(pThread->StartAddress));
            pThread = pThread->Next;
        }
        pImage = pProcess->ImageHead;
        while (pImage)
        {
            VerbOut("  hFile: %I64x  base: %s\n",
                    (ULONG64)((ULONG_PTR)pImage->File),
                    FormatAddr64(pImage->BaseOfImage));
            pImage = pImage->Next;
        }
        pProcess = pProcess->Next;
    }
}

/*** ChangeRegContext - change thread register context
*
*   Purpose:
*       Update the current register context to the thread specified.
*       The NULL value implies no context.  Update pActiveThread
*       to point to the thread in context.
*
*   Input:
*       pNewContext - pointer to new thread context (NULL if none).
*
*   Output:
*       None.
*
*   Exceptions:
*       failed register context call (get or set)
*
*   Notes:
*       Call with NULL argument to flush current register context
*       before continuing with program.
*
*************************************************************************/

void
ChangeRegContext (
    PTHREAD_INFO pThreadNew
    )
{
    if (pThreadNew != g_RegContextThread)
    {
        // Flush any old thread context.
        // We need to be careful when flushing context to
        // NT4 boxes at the initial module load because the
        // system is in a very fragile state and writing
        // back the context generally causes a bugcheck 50.
        if (g_RegContextThread != NULL && g_RegContextThread->Handle != NULL &&
            (IS_USER_TARGET() || g_ActualSystemVersion != NT_SVER_NT4 ||
             g_LastEventType != DEBUG_EVENT_LOAD_MODULE))
        {
            HRESULT Hr;

            Hr = g_Machine->SetContext();
            if (Hr == S_OK &&
                g_Machine != g_TargetMachine)
            {
                // If we're flushing register context we need to make
                // sure that all machines involved are flushed so
                // that context information actually gets sent to
                // the target.
                Hr = g_TargetMachine->SetContext();
            }
            if (Hr != S_OK)
            {
                ErrOut("MachineInfo::SetContext failed - pThread: %N  "
                       "Handle: %I64x  Id: %x - Error == 0x%X\n",
                       g_RegContextThread,
                       g_RegContextThread->Handle,
                       g_RegContextThread->SystemId,
                       Hr);
            }
        }
        
        g_RegContextThread = pThreadNew;
        if (g_RegContextThread != NULL)
        {
            g_RegContextProcessor = 
                VIRTUAL_THREAD_INDEX(g_RegContextThread->Handle);
        }
        else
        {
            g_RegContextProcessor = -1;
        }
        g_LastSelector = -1;

        // We've now selected a new source of processor data so
        // all machines, both emulated and direct, must be invalidated.
        for (ULONG i = 0; i < MACHIDX_COUNT; i++)
        {
            g_AllMachines[i]->InvalidateContext();
        }
    }
}

void
FlushRegContext(void)
{
    PTHREAD_INFO CurThread = g_RegContextThread;
    ChangeRegContext(NULL);
    ChangeRegContext(CurThread);
}

void
SetCurrentThread(PTHREAD_INFO Thread, BOOL Hidden)
{
    BOOL Changed =
        (!g_CurrentProcess && Thread) ||
        (g_CurrentProcess && !Thread) ||
        g_CurrentProcess->CurrentThread != Thread;
    
    ChangeRegContext(Thread);
    if (Thread != NULL)
    {
        g_CurrentProcess = Thread->Process;
    }
    else
    {
        g_CurrentProcess = NULL;
    }
    if (g_CurrentProcess != NULL)
    {
        g_CurrentProcess->CurrentThread = Thread;
    }

    // We're switching processors so invalidate
    // the implicit data pointers so they get refreshed.
    ResetImplicitData();
    
    // In kernel targets update the page directory for the current
    // processor's page directory base value so that virtual
    // memory mappings are done according to the current processor
    // state.  This only applies to full dumps because triage
    // dumps only have a single processor, so there's nothing to
    // switch, and summary dumps only guarantee that the crashing
    // processor's page directory page is saved.  A user can
    // still manually change the directory through .context if
    // they wish.
    if (IS_KERNEL_TARGET() && IS_KERNEL_FULL_DUMP())
    {
        if (g_TargetMachine->SetDefaultPageDirectories(PAGE_DIR_ALL) != S_OK)
        {
            WarnOut("WARNING: Unable to reset page directories\n");
        }
    }
    
    if (!Hidden && Changed)
    {
        if (Thread != NULL)
        {
            g_Machine->GetPC(&g_AssemDefault);
            g_UnasmDefault = g_AssemDefault;
        }
        
        NotifyChangeEngineState(DEBUG_CES_CURRENT_THREAD,
                                Thread != NULL ? Thread->UserId : DEBUG_ANY_ID,
                                TRUE);
    }
}

void
SetCurrentProcessorThread(ULONG Processor, BOOL Hidden)
{
    //
    // Switch to the thread representing a particular processor.
    // This only works with the kernel virtual threads.
    //

    DBG_ASSERT(IS_KERNEL_TARGET());

    PTHREAD_INFO Thread = FindThreadBySystemId(g_CurrentProcess,
                                               VIRTUAL_THREAD_ID(Processor));
    DBG_ASSERT(Thread != NULL);

    SetCurrentThread(Thread, Hidden);
}

void
SaveSetCurrentProcessorThread(ULONG Processor)
{
    // This is only used for kd sessions to conserve
    // bandwidth when temporarily switching processors.
    DBG_ASSERT(IS_KERNEL_TARGET());

    g_RegContextSaved = g_RegContextThread;
    g_Machine->KdSaveProcessorState();
    g_RegContextThread = NULL;
    g_SaveImplicitThread = g_ImplicitThreadData;
    g_SaveImplicitProcess = g_ImplicitProcessData;

    // Don't notify on this change as it is only temporary.
    g_EngNotify++;
    SetCurrentProcessorThread(Processor, TRUE);
    g_EngNotify--;
}

void
RestoreCurrentProcessorThread(void)
{
    // This is only used for kd sessions to conserve
    // bandwidth when temporarily switching processors.
    DBG_ASSERT(IS_KERNEL_TARGET());

    g_Machine->KdRestoreProcessorState();
    if (g_RegContextSaved != NULL)
    {
        g_RegContextProcessor =
            VIRTUAL_THREAD_INDEX(g_RegContextSaved->Handle);
    }
    else
    {
        g_RegContextProcessor = -1;
    }
    g_LastSelector = -1;
    g_RegContextThread = g_RegContextSaved;
    g_ImplicitThreadData = g_SaveImplicitThread;
    g_ImplicitProcessData = g_SaveImplicitProcess;
    
    // Don't notify on this change as it was only temporary.
    g_EngNotify++;
    SetCurrentThread(g_RegContextThread, TRUE);
    g_EngNotify--;
}

#define BUFFER_THREADS 64

void
SuspendAllThreads(void)
{
    if (IS_DUMP_TARGET() || IS_KERNEL_TARGET())
    {
        // Nothing to do.
        return;
    }
    
    PPROCESS_INFO Process;
    PTHREAD_INFO Thread;
    ULONG64 Threads[BUFFER_THREADS];
    ULONG Counts[BUFFER_THREADS];
    PULONG StoreCounts[BUFFER_THREADS];
    ULONG Buffered;
    ULONG i;

    Buffered = 0;
    Process = g_ProcessHead;
    while (Process != NULL)
    {
        Thread = Process->ThreadHead;
        while (Thread != NULL)
        {
            if (!Process->Exited &&
                !Thread->Exited &&
                Thread->Handle != 0)
            {
#ifdef DBG_SUSPEND
                dprintf("** suspending thread id: %x handle: %I64x\n",
                        Thread->SystemId, Thread->Handle);
#endif

                if (Thread->InternalFreezeCount > 0)
                {
                    Thread->InternalFreezeCount--;
                }
                else if (Thread->FreezeCount > 0)
                {
                    dprintf("thread %d can execute\n", Thread->UserId);
                    Thread->FreezeCount--;
                }
                else
                {
                    if (Buffered == BUFFER_THREADS)
                    {
                        if ((((UserTargetInfo*)g_Target)->m_Services->
                             SuspendThreads(Buffered, Threads,
                                            Counts)) != S_OK)
                        {
                            WarnOut("SuspendThread failed\n");
                        }

                        for (i = 0; i < Buffered; i++)
                        {
                            *StoreCounts[i] = Counts[i];
                        }
                        
                        Buffered = 0;
                    }

                    Threads[Buffered] = Thread->Handle;
                    StoreCounts[Buffered] = &Thread->SuspendCount;
                    Buffered++;
                }
            }
            
            Thread = Thread->Next;
        }
        
        Process = Process->Next;
    }
    
    if (Buffered > 0)
    {
        if ((((UserTargetInfo*)g_Target)->m_Services->
             SuspendThreads(Buffered, Threads, Counts)) != S_OK)
        {
            WarnOut("SuspendThread failed\n");
        }
        
        for (i = 0; i < Buffered; i++)
        {
            *StoreCounts[i] = Counts[i];
        }
    }
}

BOOL
ResumeAllThreads(void)
{
    PPROCESS_INFO Process;
    PTHREAD_INFO Thread;

    if (IS_DUMP_TARGET())
    {
        // Nothing to do.
        return TRUE;
    }
    else if (IS_KERNEL_TARGET())
    {
        // Wipe out all thread data offsets since the set
        // of threads on the processors after execution will
        // not be the same.
        for (Thread = g_ProcessHead->ThreadHead;
             Thread != NULL;
             Thread = Thread->Next)
        {
            Thread->DataOffset = 0;
        }

        return TRUE;
    }

    BOOL EventActive = FALSE;
    BOOL EventAlive = FALSE;
    ULONG64 Threads[BUFFER_THREADS];
    ULONG Counts[BUFFER_THREADS];
    PULONG StoreCounts[BUFFER_THREADS];
    ULONG Buffered;
    ULONG i;

    Buffered = 0;
    Process = g_ProcessHead;
    while (Process != NULL)
    {
        Thread = Process->ThreadHead;
        while (Thread != NULL)
        {
            if (!Process->Exited &&
                !Thread->Exited &&
                Thread->Handle != 0)
            {
                if (Process == g_EventProcess)
                {
                    EventAlive = TRUE;
                }
                
#ifdef DBG_SUSPEND
                dprintf("** resuming thread id: %x handle: %I64x\n",
                        Thread->SystemId, Thread->Handle);
#endif

                if ((g_EngStatus & ENG_STATUS_STOP_SESSION) == 0 &&
                    Process == g_EventProcess &&
                    ((g_SelectExecutionThread != SELTHREAD_ANY &&
                      Thread != g_SelectedThread) ||
                     (g_SelectExecutionThread == SELTHREAD_ANY &&
                      Thread->Frozen)))
                {
                    if (g_SelectExecutionThread != SELTHREAD_INTERNAL_THREAD)
                    {
                        dprintf("thread %d not executing\n", Thread->UserId);
                        Thread->FreezeCount++;
                    }
                    else
                    {
                        Thread->InternalFreezeCount++;
                    }
                }
                else
                {
                    if (Process == g_EventProcess)
                    {
                        EventActive = TRUE;
                    }
                
                    if (Buffered == BUFFER_THREADS)
                    {
                        if ((((UserTargetInfo*)g_Target)->m_Services->
                             ResumeThreads(Buffered, Threads,
                                           Counts)) != S_OK)
                        {
                            WarnOut("ResumeThread failed\n");
                        }

                        for (i = 0; i < Buffered; i++)
                        {
                            *StoreCounts[i] = Counts[i];
                        }
                    
                        Buffered = 0;
                    }
                    
                    Threads[Buffered] = Thread->Handle;
                    StoreCounts[Buffered] = &Thread->SuspendCount;
                    Buffered++;
                }
            }
            
            Thread = Thread->Next;
        }

        Process = Process->Next;
    }
    
    if (Buffered > 0)
    {
        if ((((UserTargetInfo*)g_Target)->m_Services->
             ResumeThreads(Buffered, Threads, Counts)) != S_OK)
        {
            WarnOut("ResumeThread failed\n");
        }

        for (i = 0; i < Buffered; i++)
        {
            *StoreCounts[i] = Counts[i];
        }
    }

    if (EventAlive && !EventActive)
    {
        ErrOut("No active threads to run in event process %d\n",
               g_EventProcess->UserId);
        return FALSE;
    }
    
    return TRUE;
}

void
parseProcessCmds (
    void
    )
{
    UCHAR       ch;
    PPROCESS_INFO pProcess;
    ULONG       UserId;

    ch = PeekChar();
    if (ch == '\0' || ch == ';')
    {
        fnOutputProcessInfo(NULL);
    }
    else
    {
        pProcess = g_CurrentProcess;
        g_CurCmd++;
        if (ch == '.')
        {
            ;
        }
        else if (ch == '#')
        {
            pProcess = g_EventProcess;
        }
        else if (ch == '*')
        {
            pProcess = NULL;
        }
        else if (ch >= '0' && ch <= '9')
        {
            UserId = 0;
            do
            {
                UserId = UserId * 10 + ch - '0';
                ch = *g_CurCmd++;
            } while (ch >= '0' && ch <= '9');
            g_CurCmd--;
            pProcess = FindProcessByUserId(UserId);
            if (pProcess == NULL)
            {
                error(BADPROCESS);
            }
        }
        else
        {
            g_CurCmd--;
        }
        
        ch = PeekChar();
        if (ch == '\0' || ch == ';')
        {
            fnOutputProcessInfo(pProcess);
        }
        else
        {
            g_CurCmd++;
            if (tolower(ch) == 's')
            {
                if (pProcess == NULL)
                {
                    error(BADPROCESS);
                }
                if (pProcess->CurrentThread == NULL)
                {
                    pProcess->CurrentThread = pProcess->ThreadHead;
                    if (pProcess->CurrentThread == NULL)
                    {
                        error(BADPROCESS);
                    }
                }
                SetPromptThread(pProcess->CurrentThread,
                                SPT_DEFAULT_OCI_FLAGS);
            }
            else
            {
                g_CurCmd--;
            }
        }
    }
}

void
SetPromptThread(
    PTHREAD_INFO pThread,
    ULONG uOciFlags
    )
{
    SetCurrentThread(pThread, FALSE);
    ResetCurrentScope();
    OutCurInfo(uOciFlags, g_Machine->m_AllMask,
               DEBUG_OUTPUT_PROMPT_REGISTERS);
    // Assem/unasm defaults already reset so just update
    // the dump default from them.
    g_DumpDefault = g_AssemDefault;
}

void
fnOutputProcessInfo (
    PPROCESS_INFO pProcessOut
    )
{
    PPROCESS_INFO pProcess;

    pProcess = g_ProcessHead;
    while (pProcess)
    {
        if (pProcessOut == NULL || pProcessOut == pProcess)
        {
            char CurMark;
            PSTR DebugKind;
            
            if (pProcess == g_CurrentProcess)
            {
                CurMark = '.';
            }
            else if (pProcess == g_EventProcess)
            {
                CurMark = '#';
            }
            else
            {
                CurMark = ' ';
            }

            DebugKind = "child";
            if (pProcess->Exited)
            {
                DebugKind = "exited";
            }
            else if (pProcess->Flags & ENG_PROC_ATTACHED)
            {
                DebugKind = (pProcess->Flags & ENG_PROC_SYSTEM) ?
                    "system" : "attach";
            }
            else if (pProcess->Flags & ENG_PROC_CREATED)
            {
                DebugKind = "create";
            }
            else if (pProcess->Flags & ENG_PROC_EXAMINED)
            {
                DebugKind = "examine";
            }
            
            dprintf("%c%3ld\tid: %lx\t%s\tname: %s\n",
                    CurMark,
                    pProcess->UserId,
                    pProcess->SystemId,
                    DebugKind,
                    pProcess->ExecutableImage != NULL ?
                    pProcess->ExecutableImage->ImagePath :
                    (pProcess->ImageHead != NULL ?
                     pProcess->ImageHead->ImagePath :
                     "?NoImage?")
                    );
        }
        
        pProcess = pProcess->Next;
    }
}

void
SuspendResumeThreads(PPROCESS_INFO Process, BOOL Susp, PTHREAD_INFO Match)
{
    PTHREAD_INFO Thrd;

    if (Process == NULL)
    {
        ErrOut("SuspendResumeThreads given a NULL process\n");
        return;
    }
    
    for (Thrd = Process->ThreadHead;
         Thrd != NULL;
         Thrd = Thrd->Next)
    {
        if (Match != NULL && Match != Thrd)
        {
            continue;
        }
                    
        HRESULT Status;
        ULONG Count;
                        
        if (Susp)
        {
            Status = ((UserTargetInfo*)g_Target)->m_Services->
                SuspendThreads(1, &Thrd->Handle, &Count);
        }
        else
        {
            Status = ((UserTargetInfo*)g_Target)->m_Services->
                ResumeThreads(1, &Thrd->Handle, &Count);
        }
        if (Status != S_OK)
        {
            ErrOut("Operation failed for thread %d, 0x%X\n",
                   Thrd->UserId, Status);
        }
        else
        {
            Thrd->SuspendCount = Count;
        }
    }
}

void
parseThreadCmds (
    DebugClient* Client
    )
{
    CHAR        ch;
    PTHREAD_INFO pThread, Thrd, OrigThread;
    ULONG       UserId;
    ULONG64     value1;
    ULONG64     value3;
    ULONG       value4;
    ADDR        value2;
    STACK_TRACE_TYPE traceType;
    BOOL        fFreezeThread = FALSE;
    PCHAR       Tmp;

    ch = PeekChar();
    if (ch == '\0' || ch == ';')
    {
        fnOutputThreadInfo(NULL);
    }
    else
    {
        g_CurCmd++;

        pThread = g_CurrentProcess->CurrentThread;
        fFreezeThread = TRUE;
        
        if (ch == '.')
        {
            // Current thread is the default.
        }
        else if (ch == '#')
        {
            pThread = g_EventThread;
        }
        else if (ch == '*')
        {
            pThread = NULL;
            fFreezeThread = FALSE;
        }
        else if (ch >= '0' && ch <= '9')
        {
            UserId = 0;
            do
            {
                UserId = UserId * 10 + ch - '0';
                ch = *g_CurCmd++;
            }
            while (ch >= '0' && ch <= '9');
            g_CurCmd--;
            pThread = FindThreadByUserId(g_CurrentProcess, UserId);
            if (pThread == NULL)
            {
                error(BADTHREAD);
            }
        }
        else
        {
            g_CurCmd--;
        }
        
        ch = PeekChar();
        if (ch == '\0' || ch == ';')
        {
            fnOutputThreadInfo(pThread);
        }
        else
        {
            g_CurCmd++;
            switch (ch = (CHAR)tolower(ch))
            {
            case 'b':
                ch = (CHAR)tolower(*g_CurCmd);
                g_CurCmd++;
                if (ch != 'p' && ch != 'a' && ch != 'u')
                {
                    if (ch == '\0' || ch == ';')
                    {
                        g_CurCmd--;
                    }
                    error(SYNTAX);
                }
                ParseBpCmd(Client, ch, pThread);
                break;

            case 'e':
                Tmp = g_CurCmd;
                OrigThread = g_CurrentProcess->CurrentThread;
                for (Thrd = g_CurrentProcess->ThreadHead;
                     Thrd;
                     Thrd = Thrd->Next)
                {
                    if (pThread == NULL || Thrd == pThread)
                    {
                        g_CurCmd = Tmp;
                        SetCurrentThread(Thrd, TRUE);
                        
                        ProcessCommands(Client, TRUE);
                        
                        if (g_EngStatus & ENG_STATUS_USER_INTERRUPT)
                        {
                            g_EngStatus &= ~ENG_STATUS_USER_INTERRUPT;
                            break;
                        }
                    }
                }
                SetCurrentThread(OrigThread, TRUE);
                break;
                
            case 'f':
            case 'u':
                if (pThread == NULL)
                {
                    pThread = g_CurrentProcess->ThreadHead;
                    while (pThread)
                    {
                        pThread->Frozen = (BOOL)(ch == 'f');
                        pThread = pThread->Next;
                    }
                }
                else
                {
                    pThread->Frozen = (BOOL)(ch == 'f');
                }
                break;
                
            case 'g':
                if (pThread)
                {
                    ChangeRegContext(pThread);
                }
                parseGoCmd(pThread, fFreezeThread);
                ChangeRegContext(g_CurrentProcess->CurrentThread);
                break;
                
            case 'k':
                if (pThread == NULL)
                {
                    Tmp = g_CurCmd;
                    for (pThread = g_CurrentProcess->ThreadHead;
                         pThread;
                         pThread = pThread->Next)
                    {
                        g_CurCmd = Tmp;
                        dprintf("\n");
                        fnOutputThreadInfo(pThread);
                        ChangeRegContext(pThread);
                        value1 = 0;
                        if (g_EffMachine == IMAGE_FILE_MACHINE_I386)
                        {
                            value3 = GetRegVal64(X86_EIP);
                        }
                        else
                        {
                            value3 = 0;
                        }
                        ParseStackTrace(&traceType,
                                        &value2,
                                        &value1,
                                        &value3,
                                        &value4);
                        DoStackTrace( value2.off,
                                      value1,
                                      value3,
                                      value4,
                                      traceType );
                        if (g_EngStatus & ENG_STATUS_USER_INTERRUPT)
                        {
                            break;
                        }
                    }
                }
                else
                {
                    ChangeRegContext(pThread);
                    value1 = 0;
                    if (g_EffMachine == IMAGE_FILE_MACHINE_I386)
                    {
                        value3 = GetRegVal64(X86_EIP);
                    }
                    else
                    {
                        value3 = 0;
                    }
                    ParseStackTrace(&traceType,
                                    &value2,
                                    &value1,
                                    &value3,
                                    &value4);
                    DoStackTrace( value2.off,
                                  value1,
                                  value3,
                                  value4,
                                  traceType );
                }

                ChangeRegContext(g_CurrentProcess->CurrentThread);
                break;

            case 'm':
            case 'n':
                SuspendResumeThreads(g_CurrentProcess, ch == 'n', pThread);
                break;
                
            case 'p':
            case 't':
                if (pThread)
                {
                    ChangeRegContext(pThread);
                }
                parseStepTrace(pThread, fFreezeThread, ch);
                ChangeRegContext(g_CurrentProcess->CurrentThread);
                break;
                
            case 'r':
                if (pThread == NULL)
                {
                    Tmp = g_CurCmd;
                    for (pThread = g_CurrentProcess->ThreadHead;
                         pThread;
                         pThread = pThread->Next)
                    {
                        g_CurCmd = Tmp;
                        ChangeRegContext(pThread);
                        ParseRegCmd();
                    }
                }
                else
                {
                    ChangeRegContext(pThread);
                    ParseRegCmd();
                }
                ChangeRegContext(g_CurrentProcess->CurrentThread);
                break;
                
            case 's':
                if (pThread == NULL)
                {
                    error(BADTHREAD);
                }
                SetPromptThread(pThread, SPT_DEFAULT_OCI_FLAGS);
                break;
                
            default:
                error(SYNTAX);
            }
        }
    }
}

void
fnOutputThreadInfo (
    PTHREAD_INFO pThreadOut
    )
{
    PTHREAD_INFO pThread;

    pThread = g_CurrentProcess != NULL ? g_CurrentProcess->ThreadHead : NULL;
    while (pThread)
    {
        if (pThreadOut == NULL || pThreadOut == pThread)
        {
            ULONG64 DataOffset;
            HRESULT Status;
            char CurMark;

            Status =
                g_Target->GetThreadInfoDataOffset(pThread, NULL, &DataOffset);
            if (Status != S_OK)
            {
                WarnOut("Unable to get thread data for thread %u\n",
                        pThread->UserId);
                DataOffset = 0;
            }

            if (pThread == g_CurrentProcess->CurrentThread)
            {
                CurMark = '.';
            }
            else if (pThread == g_EventThread)
            {
                CurMark = '#';
            }
            else
            {
                CurMark = ' ';
            }
            
            dprintf("%c%3ld  id: %lx.%lx   Suspend: %d Teb %s ",
                    CurMark,
                    pThread->UserId,
                    g_CurrentProcess->SystemId,
                    pThread->SystemId,
                    pThread->SuspendCount,
                    FormatAddr64(DataOffset)
                    );
            if (pThread->Frozen)
            {
                dprintf("Frozen");
            }
            else
            {
                dprintf("Unfrozen");
            }
            if (pThread->Name[0])
            {
                dprintf(" \"%s\"", pThread->Name);
            }
            dprintf("\n");
        }

        if (CheckUserInterrupt())
        {
            break;
        }
        
        pThread = pThread->Next;
    }
}

//----------------------------------------------------------------------------
//
// Process creation and attach functions.
//
//----------------------------------------------------------------------------

void
AddPendingProcess(PPENDING_PROCESS Pending)
{
    Pending->Next = g_ProcessPending;
    g_ProcessPending = Pending;
    g_AllPendingFlags |= Pending->Flags;
}

void
RemovePendingProcess(PPENDING_PROCESS Pending)
{
    PPENDING_PROCESS Prev, Cur;
    ULONG AllFlags = 0;

    Prev = NULL;
    for (Cur = g_ProcessPending; Cur != NULL; Cur = Cur->Next)
    {
        if (Cur == Pending)
        {
            break;
        }

        Prev = Cur;
        AllFlags |= Cur->Flags;
    }

    if (Cur == NULL)
    {
        DBG_ASSERT(Cur != NULL);
        return;
    }

    Cur = Cur->Next;
    if (Prev == NULL)
    {
        g_ProcessPending = Cur;
    }
    else
    {
        Prev->Next = Cur;
    }
    DiscardPendingProcess(Pending);

    while (Cur != NULL)
    {
        AllFlags |= Cur->Flags;
        Cur = Cur->Next;
    }
    g_AllPendingFlags = AllFlags;
}

void
DiscardPendingProcess(PPENDING_PROCESS Pending)
{
    DBG_ASSERT(IS_LIVE_USER_TARGET());
    PUSER_DEBUG_SERVICES Services = ((UserTargetInfo*)g_Target)->m_Services;

    if (Pending->InitialThreadHandle)
    {
        Services->CloseHandle(Pending->InitialThreadHandle);
    }
    if (Pending->Handle)
    {
        Services->CloseHandle(Pending->Handle);
    }
    delete Pending;
}

void
DiscardPendingProcesses(void)
{
    while (g_ProcessPending != NULL)
    {
        PPENDING_PROCESS Next = g_ProcessPending->Next;
        DiscardPendingProcess(g_ProcessPending);
        g_ProcessPending = Next;
    }

    g_AllPendingFlags = 0;
}

PPENDING_PROCESS
FindPendingProcessByFlags(ULONG Flags)
{
    PPENDING_PROCESS Cur;
    
    for (Cur = g_ProcessPending; Cur != NULL; Cur = Cur->Next)
    {
        if (Cur->Flags & Flags)
        {
            return Cur;
        }
    }

    return NULL;
}

PPENDING_PROCESS
FindPendingProcessById(ULONG Id)
{
    PPENDING_PROCESS Cur;
    
    for (Cur = g_ProcessPending; Cur != NULL; Cur = Cur->Next)
    {
        if (Cur->Id == Id)
        {
            return Cur;
        }
    }

    return NULL;
}

void
VerifyPendingProcesses(void)
{
    DBG_ASSERT(IS_LIVE_USER_TARGET());
    PUSER_DEBUG_SERVICES Services = ((UserTargetInfo*)g_Target)->m_Services;

    PPENDING_PROCESS Cur;

 Restart:
    for (Cur = g_ProcessPending; Cur != NULL; Cur = Cur->Next)
    {
        ULONG ExitCode;
        
        if (Cur->Handle &&
            Services->GetProcessExitCode(Cur->Handle, &ExitCode) == S_OK)
        {
            ErrOut("Process %d exited before attach completed\n", Cur->Id);
            RemovePendingProcess(Cur);
            goto Restart;
        }
    }
}

void
AddExamineToPendingAttach(void)
{
    PPENDING_PROCESS Cur;
    
    for (Cur = g_ProcessPending; Cur != NULL; Cur = Cur->Next)
    {
        if (Cur->Flags & ENG_PROC_ATTACHED)
        {
            Cur->Flags |= ENG_PROC_EXAMINED;
            g_AllPendingFlags |= ENG_PROC_EXAMINED;
        }
    }
}
    
HRESULT
StartAttachProcess(ULONG ProcessId, ULONG AttachFlags,
                   PPENDING_PROCESS* Pending)
{
    HRESULT Status;
    PPENDING_PROCESS Pend;

    DBG_ASSERT(IS_LIVE_USER_TARGET());

    if (GetCurrentThreadId() != g_SessionThread)
    {
        ErrOut("Can only attach from the primary thread\n");
        return E_UNEXPECTED;
    }

    if (ProcessId == GetCurrentProcessId())
    {
        ErrOut("Can't debug the current process\n");
        return E_INVALIDARG;
    }
    
    Pend = new PENDING_PROCESS;
    if (Pend == NULL)
    {
        ErrOut("Unable to allocate memory\n");
        return E_OUTOFMEMORY;
    }

    if ((AttachFlags & DEBUG_ATTACH_NONINVASIVE) == 0)
    {
        if ((Status = ((UserTargetInfo*)g_Target)->m_Services->
             AttachProcess(ProcessId, AttachFlags,
                           &Pend->Handle, &Pend->Options)) != S_OK)
        {
            ErrOut("Cannot debug pid %ld, %s\n    \"%s\"\n",
                   ProcessId, FormatStatusCode(Status), FormatStatus(Status));
            delete Pend;
            return Status;
        }

        Pend->Flags = ENG_PROC_ATTACHED;
        if (AttachFlags & DEBUG_ATTACH_EXISTING)
        {
            Pend->Flags |= ENG_PROC_ATTACH_EXISTING;
        }
        
        if (ProcessId == CSRSS_PROCESS_ID)
        {
            if (IS_LOCAL_USER_TARGET())
            {
                g_EngOptions |= DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS |
                    DEBUG_ENGOPT_IGNORE_DBGHELP_VERSION;
                g_EngOptions &= ~DEBUG_ENGOPT_ALLOW_NETWORK_PATHS;
            }

            Pend->Flags |= ENG_PROC_SYSTEM;
        }
    }
    else
    {
        Pend->Handle = 0;
        Pend->Flags = ENG_PROC_EXAMINED;
        Pend->Options = DEBUG_PROCESS_ONLY_THIS_PROCESS;
    }

    Pend->Id = ProcessId;
    Pend->InitialThreadId = 0;
    Pend->InitialThreadHandle = 0;
    AddPendingProcess(Pend);
    *Pending = Pend;
        
    return S_OK;
}

HRESULT
StartCreateProcess(PSTR CommandLine, ULONG CreateFlags,
                   PPENDING_PROCESS* Pending)
{
    HRESULT Status;
    PPENDING_PROCESS Pend;

    DBG_ASSERT(IS_LIVE_USER_TARGET());

    if ((CreateFlags & (DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS)) == 0)
    {
        return E_INVALIDARG;
    }

    if (GetCurrentThreadId() != g_SessionThread)
    {
        ErrOut("Can only use .create from the primary thread\n");
        return E_UNEXPECTED;
    }
    
    Pend = new PENDING_PROCESS;
    if (Pend == NULL)
    {
        ErrOut("Unable to allocate memory\n");
        return E_OUTOFMEMORY;
    }
    
    dprintf("CommandLine: %s\n", CommandLine);

    if ((Status = ((UserTargetInfo*)g_Target)->m_Services->
         CreateProcess(CommandLine, CreateFlags,
                       &Pend->Id, &Pend->InitialThreadId,
                       &Pend->Handle, &Pend->InitialThreadHandle)) != S_OK)
    {
        ErrOut("Cannot execute '%s', %s\n    \"%s\"\n",
               CommandLine, FormatStatusCode(Status),
               FormatStatusArgs(Status, &CommandLine));
        delete Pend;
    }
    else
    {
        Pend->Flags = ENG_PROC_CREATED;
        Pend->Options = (CreateFlags & DEBUG_ONLY_THIS_PROCESS) ?
            DEBUG_PROCESS_ONLY_THIS_PROCESS : 0;
        AddPendingProcess(Pend);
        *Pending = Pend;
    }
    
    return Status;
}

void
MarkProcessExited(PPROCESS_INFO Process)
{
    Process->Exited = TRUE;
    g_EngDefer |= ENG_DEFER_DELETE_EXITED;
}

HRESULT
TerminateProcess(PPROCESS_INFO Process)
{
    DBG_ASSERT(IS_LIVE_USER_TARGET());
    PUSER_DEBUG_SERVICES Services = ((UserTargetInfo*)g_Target)->m_Services;
    HRESULT Status = S_OK;
    
    if (!Process->Exited)
    {
        if ((Process->Flags & ENG_PROC_EXAMINED) == 0 &&
            (Status = Services->TerminateProcess(Process->FullHandle,
                                                 E_FAIL)) != S_OK)
        {
            ErrOut("TerminateProcess failed, %s\n",
                   FormatStatusCode(Status));
        }
        else
        {
            MarkProcessExited(Process);
        }
    }

    return Status;
}

HRESULT
TerminateProcesses(void)
{
    DBG_ASSERT(IS_LIVE_USER_TARGET());

    HRESULT Status;
   